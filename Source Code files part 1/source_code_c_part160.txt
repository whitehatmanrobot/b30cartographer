is invoked only in protected mode and grows the SFT to its max;
; size by linking in one more tanle entry.				     ;
;----------------------------------------------------------------------------;

	assumes ds,nothing
	assumes	es,nothing

cProc	GrowSFTToMax,<NEAR,PUBLIC,PASCAL>,<es,ax,di>

	localW	NewHandles		;# of extra handles being allocated
	localW	NewTableSize		;size of newtable
	localB	GrowLimit		;size to grow sft to

cBegin
	ReSetKernelDS

; get the amount of free space and decide on the number of handle entries that
; we want to add. If the memory space is more than 8*64K, make the total number 
; of handle entries 256 else make it 100.

	mov	GrowLimit,SFT_HIGH_LIM	;assume we will grow upto 255
	xor	bx,bx			;dummy parameter
	cCall	GetFreeSpace,<bx>	;dx:ax returns free area size
	cmp	dx,SFT_GROW_LIM_IN_64K	;is it more than or equal (in 64k incs)
	jae	@f		        ;yes
	mov	GrowLimit,SFT_LOW_LIM	;low on memory, grow till 100
@@:
	  
; allocate a free selector.

	xor	ax,ax			;allocate selector function code
	mov	cx,1			;need to get 1 selector
	int	31h			;ax has the selector

; get the address of the first in the SFT chain.

	push	ax			;save the slector
	mov	ah,52h			;get SYSVARS call
	int	21h			;es:bx points to DOS SYSVAR structure
	lea	bx,[bx+sftHead]		;es:bx points to the start of the sft
	mov	cx,es:[bx][2]		;get the segment
	mov	dx,es:[bx]		;get the offset
	pop	ax			;get back the free selector

; modify the base of the free selector to point to the first link in the system
; file table list.

	mov	bx,ax			;get the selector here
	call	SetSelectorBaseLim64k	;set selector base and limit.

; now get into a loop, to find out the number of file handles that the system
; currently.

	xor	ah,ah			;will count handles here.
	mov	es,bx			;es points to the first entry

CountNumHandles:

	xor	bx,bx			;es:bx points to first table
	mov	cx,es:[bx].sftCount	;get the number of handles
	add	ah,cl			;accumulate no of handles here
	cmp	word ptr es:[bx],-1	;end of chain ?
	jz	AddOneMoreSFTLink	;end of current list reached
	mov	cx,word ptr es:[bx].sftLink[2];get the segment of next node
	mov	dx,word ptr es:[bx].sftLink[0];get the offset of the next node
	mov	bx,es			;get the selector
	call	SetSelectorBaseLim64k	;modify sel to point to next node
	jmp	short CountNumHandles	;continue

AddOneMoreSFTLink:

; find out the number of extra handles for which we will allocate space

	mov	al,GrowLimit		;max number of handles
	cmp	ah,al			;is it already more than limit ?
	jae	GrowSFTToMaxRet		;no need to grow any more.

ifdef WOW
	xchg	ah,al
	xor	ah,ah
	Debug_Out "GrowSFTToMax: At least 128 files handles required in CONFIG.SYS only specified #AX"
	jmp	ExitKernel
else
	sub	al,ah			;al has the no of extra handles
	xor	ah,ah			;ax has no of extra handles
	mov	NewHandles,ax		;save it.
	mul	FileEntrySize		;dx:ax has size of table
	add	ax,(SIZE SFT) - 1	;size of the initial header
	mov	NewTableSize,ax		;save size
	regptr	dxax,dx,ax

	save	<es,bx>
	cCall	GlobalDOSAlloc,<dxax>	;allocate the block
	jcxz	GrowSFTToMaxRet		;no memory to allocate

	cCall	SetOwner,<ax,hExeHead>

; store the pointer to the new link in the current link.

	push	bx			;save
	mov	bx,ax			;get the new selector
	call	GetSelectorSegment	;returns segment of sel in ax, in dx
	pop	bx			;restore 
	mov	word ptr es:[bx].sftLink[2],dx
	mov	word ptr es:[bx].sftLink[0],0

; we have to save the address of this last original link so that it can be
; restored to be the last at DisableKernel time. We will save the current 
; selector and delete it at disable time

	mov	word ptr [pSftLink],bx	;save
	mov	word ptr [pSftLink+2],es

	mov	bx,es			;get the selector
	mov	es,ax			;es points to new link

; initialize memory tp all zeros

	xor	di,di			;es:di points to new buffer
	mov	cx,NewTableSize		;size of buffer
	xor	al,al			;want to initialize to 0's
	rep	stosb			;initialized

; prepare the header for the new table.

	xor	bx,bx			;es:bx points to the new table
	mov	cx,-1			;link terminator code
	mov	word ptr es:[bx].sftLink[2],cx
	mov	word ptr es:[bx].sftLink[0],cx
	mov	cx,NewHandles		;# of handles in this node
	mov	es:[bx].sftCount,cx
endif; WOW

GrowSFTToMaxRet:

cEnd
;----------------------------------------------------------------------------;
; SetSelectorBaseLim64k:						     ;
;									     ;
; Given a selector value in bx and a real mode lptr in cx:dx, it sets the ba-;
; -se of the selector to that value and sets it to be a 64k data segment. AX ;
; is preserved.								     ;
;									     ;
;----------------------------------------------------------------------------;

SetSelectorBaseLim64k	proc  near

	push	ax			;save

; calculate the linear base address.

	xor	ax,ax			;will have high nibble of shift
	shl	cx,1			;shift by 1
	rcl	ax,1			;gather in
	shl	cx,1			;shift by 1
	rcl	ax,1			;gather in
	shl	cx,1			;shift by 1
	rcl	ax,1			;gather in
	shl	cx,1			;shift by 1
	rcl	ax,1			;gather in
	add	cx,dx			;add in the offset
	adc	ax,0			;ax:cx has the base
	mov	dx,cx			;get into proper registers
	mov	cx,ax			;cx:dx has the base
	mov	ax,7			;set selector base code
	int	31h			;the base of the selector has been set
	inc	ax			;set selector limit code
	mov	dx,-1			;64-1k limit
	xor	cx,cx			;cx:dx=64-1k
	int	31h			;limit set to 64-1k

	pop	ax			;restore ax
	ret

SetSelectorBaseLim64k endp
;----------------------------------------------------------------------------;
; GetSelectorSegment:							     ;
;									     ;
; Given a slector in bx pointing to DOS memory, this function returns the    ;
; real mode segment value in DX. AX,BX is preserved.			     ;
;----------------------------------------------------------------------------;

GetSelectorSegment  proc near

	push	ax			;save
	push	bx			;save
	mov	ax,6			;get selector base
	int	31h			;cx:dx has base
	shr	cx,1			;shift by 1
	rcr	dx,1			;gather into dx
	shr	cx,1			;shift by 1
	rcr	dx,1			;gather into dx
	shr	cx,1			;shift by 1
	rcr	dx,1			;gather into dx
	shr	cx,1			;shift by 1
	rcr	dx,1			;gather into dx
	pop	bx			;restore
	pop	ax			;dx has segment value
	ret

GetSelectorSegment endp
;----------------------------------------------------------------------------;


sEnd	INITCODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\diskio.asm ===
TITLE   DISKIO

include kernel.inc

externFP Int21Handler

sBegin  CODE

ASSUMES CS,CODE

externNP	MyAnsiToOem

cProc	I_lopen,<PUBLIC,FAR>
;       parmD   lpFilename
;       parmW   mode
;	localV	OemBuffer,128
cBegin  nogen
        mov     ch,3Dh          ; Open File
	jmps	loccommon
cEnd    nogen

cProc	I_lcreat,<PUBLIC,FAR>
;	parmD   lpFilename
;	parmW   attributes
;	localV	OemBuffer,128
cBegin  nogen
        mov     ch,3Ch          ; Create File
cEnd	nogen

	errn$	loccommon

cProc	loccommon,<PUBLIC,FAR>
	parmD   lpFilename
	parmW   attributes
	localV	OemBuffer,128
cBegin

; Common code for open and creat functions. CH = function code

	push	cx
	lea	bx, OemBuffer
	cCall	MyAnsiToOem,<lpFilename,ss,bx>
	pop	cx
	mov	cl, byte ptr attributes
        mov     ax,cx
        xor     ch,ch
	smov	ds, ss
	lea	dx, OemBuffer
	DOSCALL
        jnc     lopen_ok
        mov     ax,-1
lopen_ok:
cEnd


cProc	I_lclose,<PUBLIC,FAR>
;       parmW   fd
cBegin  nogen
        mov     bx,sp
        mov     bx,ss:[bx+4]
        mov     ah,3Eh              ; DOS file close function
	DOSCALL
        mov     ax,-1
        jc      lclose_end
        inc     ax
lclose_end:
        ret     2
cEnd    nogen

cProc	I_llseek,<PUBLIC,FAR>
;   parmW   fh
;   parmD   fileOffset
;   parmW   mode
cBegin  nogen
        mov     bx,sp
        mov     dx,ss:[bx+6]
        mov     cx,ss:[bx+8]
        mov     ax,ss:[bx+4]
        mov     bx,ss:[bx+10]
        mov     ah,42h
	DOSCALL
        jnc     lseek_ok
        mov     ax,-1
        cwd                         ; must return a long
lseek_ok:
        ret     8
cEnd    nogen

cProc	I_lwrite,<PUBLIC,FAR>
;       parmW   fh
;       parmD   lpBuf
;       parmW   bufsize
cBegin  nogen
        mov     cl,40h
        jmp	short _lrw
cEnd	nogen

cProc	I_lread,<PUBLIC,FAR>
;       parmW   fh
;       parmD   lpBuf
;       parmW   bufsize
cBegin  nogen
        mov     cl,3fh
	errn$	_lrw
cEnd    nogen

; Common code for read and write functions. CL = function code
cProc	_lrw,<PUBLIC,FAR>
cBegin nogen
        mov     bx,sp
        push    ds
	mov	ah,cl			    ; read or write operation
	mov	cx,ss:[bx+4]		    ; bufSize
	lds	dx,DWORD PTR ss:[bx+6]	    ; lpBuf
	mov	bx,ss:[bx+10]		    ; fh
	DOSCALL
        pop     ds
        jnc     lwrite_ok
        mov     ax,-1
lwrite_ok:
        ret     8
cEnd    nogen

sEnd    CODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\atom.asm ===
title   ATOM - atom package

include kernel.inc
include gpfix.inc

MAXINTATOM = 0C000h

PRIME      = 37

ACTION_FIND = 0
ACTION_ADD  = 1
ACTION_DEL  = 2

ATOMTABLE   STRUC
at_prime        DW  ?			; Hash modulus
at_hashTable    DW  ?			; variable length array
ATOMTABLE   ENDS

ATOM    STRUC
a_chain DW  ?
a_usage DW  ?
a_len   DB  ?
a_name  DB  ?
ATOM    ENDS


externW  <pAtomTable>


externFP <LocalAlloc,LocalFree,GlobalHandle>
externNP <MyUpper>
ifdef FE_SB
externNP MyIsDBCSLeadByte
endif

sBegin MISCCODE
assumes	cs, misccode
assumes	ds, nothing
assumes	es, nothing

;
; This procedure should be called once by each new client program.  It
; will initialize the atom table for the caller's DS and store a pointer
; to the atom table in a reserve location in the caller's DS.
; We expect return value to be in CX as well as AX.  (jcxz!)
;
cProc	InitAtomTable,<PUBLIC,FAR>
    parmW   tblSize
cBegin
	mov     ax,ds:[pAtomTable]	; Don't create if already exists
	or      ax,ax
	jnz     initdone
	mov     bx,tblSize
	or      bx,bx
	jnz     gotsize
	mov     bl,PRIME
gotsize:
	push    bx
	inc     bx			; space for table size
	shl     bx,1
	mov     ax,LA_ZEROINIT
	cCall   LocalAlloc,<ax,bx>
	pop     dx
	jcxz    initDone		; Failure
	mov     ds:[pAtomTable],ax
	mov     bx,ax
	mov     ds:[bx].at_prime,dx	; First word in hash is hash modulus
initDone:
	mov     cx,ax
cEnd

sEnd MISCCODE


sBegin  CODE

assumes CS,CODE
assumes DS,NOTHING
assumes ES,NOTHING


labelFP <PUBLIC,DelAtom>
	mov     cl,ACTION_DEL
	db      0BBh			; mov bx,

labelVDO AddAtom
	mov     cl,ACTION_ADD
	db      0BBh    		; mov bx,

labelVDO FindAtom
	mov     cl,ACTION_FIND
	errn$   LookupAtom
;
; Common procedure to add, find or delete an atom table entry.  Called
; with a far pointer to the name string and an action code in CL register
; Works in an SS != DS environment.
;
cProc   LookupAtom,<PUBLIC,FAR>,<ds,si,di>
    parmD   pName
    localW  hName
    localB  action
cBegin
	beg_fault_trap  la_trap

	mov     [action],cl

	mov     cx,SEG_pName		; If segment value is zero
ifdef FE_SB
	or	cx,cx
	jne	@F
	jmp	haveIntAtom
@@:
else
	jcxz    haveIntAtom 		;   ...then integer atom
endif
	mov	hName,cx
	les     si,pName   		; ES:SI = pName
	cmp     byte ptr es:[si],'#'        ; Check for integer atom
	je      parseIntAtom
	xor     ax,ax
	cmp     ds:[pAtomTable],ax          ; Make sure we have an atom table
	jne     tblokay
	cCall	InitAtomTable,<ax>
	jcxz    fail1
notIntAtom:
	les     si,pName		; ES:SI = pName
tblokay:
	xor     ax,ax   		; c = 0
	xor     cx,cx   		; size = 0
	xor     dx,dx   		; hash = 0
	cld
loop1:  				; while {
	lods    byte ptr es:[si]	; c = *pName++
	or      al,al   		; if (!c) break;
	jz      xloop1
	inc     cl      		; size++
	jz      fail1   		; if (size > 255) fail
ifdef FE_SB
	call	MyIsDBCSLeadByte	; Is first of 2byte DBCS char ?
	jnc	loop1ax			; Yes.
endif
	call    MyUpper
ifdef FE_SB
	jmp	short loop1a		; go normal
loop1ax:
	mov	bx, dx			; caluculate hash value
	rol	bx, 1
	add	bx, dx
	add	bx, ax
	ror	dx, 1
	add	dx, bx
	lods	byte ptr es:[si]	; Get Next char
	or	al, al			; end of strings ?
	jz	xloop1			; yes, break;
	inc	cl			;
	jz	fail1			; (size > 255) error
endif
loop1a:
	mov     bx,dx   		; hash =
	rol     bx,1    		;   + hash << 1
	add     bx,dx   		;   + hash
	add     bx,ax   		;   + c
	ror     dx,1    		;   + hash >> 1
	add     dx,bx
	jmp     loop1   		; } end of while loop

; Here if pName points to string of the form:  #nnnn
parseIntAtom:
	inc     si      		; pName++
	xor     cx,cx   		; sum = 0
	xor	ax,ax
loop3:
	lods    byte ptr es:[si]	; c = *pName++
	or      al,al   		; if (!c) break;
	jz      xloop3
	sub     al,'0'  		; if (!isdigit(c))
	cmp     al,9
	ja      notIntAtom      	;
	imul	cx, cx, 10		; sum = (sum * 10) + (c - '0')
	add	cx, ax
	jmp     loop3
haveIntAtom:
	mov     cx,OFF_pName    	; Get integer atom
xloop3:
	jcxz    fail1
	cmp     cx,MAXINTATOM
	jae     fail1
	mov     ax,cx   		; return sum
	jmp     do_exit

fail1:
	xor     ax,ax   		; Fail, return NULL
	jmp     do_exit

xloop1:
	jcxz    fail1   		; if (size == 0) fail
	xchg    ax,dx   		; DX:AX = hash
	mov     bx,ds:[pAtomTable]
	div     ds:[bx].at_prime
	lea     bx,ds:[bx].at_hashTable     ; pp = &hashTable[ hash % PRIME ]
	shl     dx,1
	add     bx,dx
	mov     dx,cx   		; size
	mov     ax,ss   		; Setup for cmpsb
	mov     es,ax
loop2:  				; while {
	mov     si,[bx] 		; p = *pp
	or      si,si   		; if (!p) break
	jz      xloop2

	cmp     [si].a_len,dl   	; if (p->len != size)
	jne     loop2a  		;   continue
	les     di,pName		; s2 = pName
	lea     si,[si].a_name  	; s1 = &p->name
	mov     cx,dx   		; size
loop4:
	jcxz    loop4x
	dec     cx
	lodsb   			; c1 = *s1++
ifdef FE_SB
	call	MyIsDBCSLeadByte	; first byte of 2byte ?
	jc	loop4a			; No, go normal
	mov	ah, al			; save char
	mov	al, es:[di]		; get *s2
	inc	di			; s2++
	cmp	ah, al			; compare *s1, *s2
	jne	loop4x			; not same, do next strings
	jcxz	loop4x			; not necessary but case of bad strings
	dec	cx
	lodsb				; get next char ( this must be second
	mov	ah, al			; of 2byte )
	mov	al, es:[di]
	inc	di
	cmp	ah, al
	je	loop4			; same, go next char
	jmp	loop4x			; not same, go next strings
loop4a:
endif
	call    MyUpper
	mov     ah,al
	mov     al,es:[di]
	call    MyUpper
	inc     di      		; c2 = *s2++
	cmp     ah,al
	je      loop4
loop4x:
	mov     si,[bx] 		; p = *pp
	je      xloop2
loop2a:
	lea     bx,[si].a_chain 	; pp = &p->chain
	jmp     short loop2     	; } end of while loop

xloop2:
	; Dispatch on command.
	xor     cx,cx
	mov     cl,[action]
	jcxz    do_find
	errnz   ACTION_FIND
	loop    do_delete
	errnz   ACTION_ADD-1

do_add:
	or      si,si   		; NULL?
	jz      do_insert

	inc     [si].a_usage    	; Already in list. Increment reference count.
	jmp     short do_find


do_delete:
	or      si,si   		; NULL?
	jz      short do_exit   	; Return NULL for internal errors
	dec     [si].a_usage
	jg      do_delete1
	xor     di,di
	xchg    [si].a_chain,di 	; *pp = p->chain, p->chain = 0;
	mov     [bx],di
	cCall   LocalFree,<si>  	; LocalFree( p )

do_delete1:
	xor     si,si   		; p = NULL
	jmp     short do_find

do_insert:
	mov     di,bx   		; save pp
	push    dx      		; save size
	add     dx,size ATOM    	; p = LocalAlloc( sizeof( ATOM )+size )
	mov     bx,LA_ZEROINIT
	cCall   LocalAlloc,<bx,dx>          ; LocalAlloc( ZEROINIT, size )
	pop     cx      		; restore size
	mov     si,ax
	or      si,si
	jz      do_find
	mov     [di],si 		; *pp = p
	inc     [si].a_usage    	; p->usage = 1
	mov     [si].a_len,cl   	; p->len = size
	mov     bx,si
	push    ds      		; ES = DS
	pop     es
	lea     di,[si].a_name  	; strcpy( &p->name, pName )
	xor     cx,cx
	mov     cl,[si].a_len   	; CX = #bytes to move
	inc     cx      		; include terminating null
	lds     si,pName
	cld
	rep     movsb
	push    es
	pop     ds      		; Restore DS
	mov     si,bx
do_find:
	mov     ax,si   		; return p
	shr     ax,1
	shr     ax,1
	jz      do_exit
	or      ax,MAXINTATOM
	end_fault_trap
do_exit:
cEnd
la_trap:
	fault_fix_stack
	xor     ax,ax   		; return NULL/FALSE
	jmp     do_exit

cProc	IDeleteAtom,<PUBLIC,FAR>
    parmW   atom1
    regPtr  lpName,ds,bx
cBegin
	mov     bx,atom1
	cmp     bx,MAXINTATOM
	jb      freeExit
	shl     bx,2
	lea     bx,[bx].a_name
	cCall   DelAtom,<lpName>
	jmp     short freeDone
freeExit:
	xor     ax,ax
freeDone:
cEnd


cProc	IGetAtomHandle,<PUBLIC,FAR>
    parmW   atom2
cBegin
	mov     ax,atom2
	cmp     ax,MAXINTATOM
	jae	@F
	xor	ax, ax
@@:	shl     ax,2
cEnd

cProc	IGetAtomName,<PUBLIC,FAR>,<si,di>
    parmW   atom3
    parmD   pString
    parmW   maxChars
cBegin
	beg_fault_trap  getn_trap
	cld
	les     di,pString
	cmp	maxChars,0
	je	getnFail
	xor     cx,cx
	mov     byte ptr es:[di],cl
	mov     bx,atom3
	cmp     bx,MAXINTATOM
	jb      getIntAtom
	shl     bx,2

; Parameter validation - is this a pointer to a valid local allocation
; block, and is the block in use?
nfd = la_next - la_fixedsize		; given pointer to data, get
	mov	si, [bx.nfd]		; pointer to 'next' allocation
	mov	si, [si]		; p = p->prev
	and	si, not (LA_BUSY + LA_MOVEABLE)
	sub	si, bx
	cmp	si, -la_fixedsize
	jnz	getnFail
	test	word ptr [bx-la_fixedsize], LA_BUSY
	jz	getnFail

; The usage count must be >0
	cmp     [bx].a_usage,cx
	je      getnFail
; Len must be >0
	mov     cl,[bx].a_len
	jcxz    getnFail
	cmp     maxChars,cx
	jg      getnOkay
	mov     cx,maxChars
	dec     cx
getnOkay:
	lea     si,[bx].a_name
	mov     ax,cx
	rep     movsb
	mov     byte ptr es:[di],0
	jmps	getnDone

getn_trap:
	fault_fix_stack		; Yes, fault handler can be within range
getnFail:
	mov	ax, atom3
	krDebugOut DEB_WARN, "GetAtomName(#AX,...) Can't find atom"
	xor	ax, ax
	jmps	getnDone

getIntAtom:
	; When a buffer of length "n" is passed, we must reserve space for
	; the '#' character and a null terminator;
	; Fixed Bug #6143 --SANKAR-- 11-9-89
	mov	cx, maxChars
	cmp	cx, 2		; one '#' and one '\0' are a must!
	jl	getnFail	; If it is less we fail;
	sub	cx, 2		; Allow two char spaces for '#' and '\0'
	mov	maxChars, cx

	or      bx,bx
	jz      getnFail
	mov     al,'#'
	stosb
	mov     ax,bx
	mov     bx,10
	mov	cx, maxChars
	jcxz	getIntDone
getIntLoop:
	xor     dx,dx
	div     bx
	push    dx
	dec     cx
	or      ax,ax
	jz      gotIntAtom
	jcxz    gotIntAtom
	jmp     getIntLoop
gotIntAtom:
	sub     maxChars,cx
	mov     cx,maxChars
getIntChar:
	pop     ax
	add     al,'0'
	stosb
	loop    getIntChar
getIntDone:
	xor     al,al
	stosb
	mov     ax,maxChars
	inc     ax	; For the '#' Character
	end_fault_trap
getnDone:
cEnd


sEnd    CODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\context.asm ===
page    ,132
                title   CONTEXT - task event procedures.

.xlist
include gpfix.inc
include kernel.inc
include tdb.inc
include pdb.inc
ifdef WOW
include vint.inc
include wowcmpat.inc
endif
.list

externFP CloseCachedFiles
externFP Int21Handler
externFP Far_real_dos

externFP GlobalAlloc
externFP GlobalFree
externFP GlobalLock
externFP GlobalUnlock
externFP GetAppCompatFlags
ifdef FE_SB
externFP FarMyIsDBCSLeadByte
endif

ifdef WOW
externFP IGetModuleFileName
endif

DataBegin

externB Kernel_Flags
externW cpLowHeap
externW selLowHeap
externW selHighHeap
externW selWoaPdb
externB InScheduler
externB DOS_version
externB DOS_revision
externB lpszFileName
;externW pGlobalHeap
externW winVer
externW topPDB
externW cur_dos_PDB
externW Win_PDB
externW curTDB
externW WinFlags
externW FileEntrySize
externW shell_file_TDB
externD shell_file_proc
externD ptrace_DLL_entry
externD ptrace_app_entry
externD lpfnToolHelpProc
externD dressed_for_success
externB fTaskSwitchCalled
externW LockTDB
DataEnd

sBegin  CODE
assumes ds,NOTHING
assumes cs,CODE

externD pYieldProc
ifndef WOW
externNP Reschedule
externNP DeleteTask
externNP InsertTask
endif ; WOW

ifdef WOW
externFP MyGetAppWOWCompatFlagsEx
endif

ifndef WOW
;-----------------------------------------------------------------------;
; WaitEvent                                                             ;
;                                                                       ;
; If an event is waiting on taskID, suspend the current task until      ;
; an event is ready.  Returns if an event was ready and no reschedule   ;
; occured.  Otherwise returns true to indicate a reschedule has occured.;
;                                                                       ;
; Arguments:                                                            ;
;                                                                       ;
; Returns:                                                              ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;                                                                       ;
; Calls:                                                                ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Sat Mar 28, 1987 05:13:50p  -by-  David N. Weise   [davidw]          ;
; Wrote it.                                                             ;
;-----------------------------------------------------------------------;

        assumes ds, nothing
        assumes es, nothing

cProc   WaitEvent,<PUBLIC,FAR>,<bx,ds>
        parmW   taskID
cBegin

        push    ds
        SetKernelDS
        cmp     LockTDB, 0              ;Do we have a locked task
        jne     @F                      ;Yes, we want to be able to reboot
        mov     fTaskSwitchCalled, 1    ;Tell Reboot VxD that we're scheduling
@@:
        pop     ds

        mov     ax,taskID
        call    GetTaskHandle0
        mov     ds,ax
        xor     ax,ax
wait_test:
        pushf
        FCLI
        dec     ds:[TDB_nEvents]
        jge     wait_exit
        mov     ds:[TDB_nEvents],0

; go uncritical

        pop     bx
        test    bh,02                   ; the interrupt flag
        jz      leave_int_off
        FSTI
leave_int_off:

        smov    es, 0
    .386
        smov    fs, 0
        smov    gs, 0
    .286
        push    cs
        call    Reschedule
        mov     al,-1
        jmp     wait_test

wait_exit:
        pop     bx
        test    bh,02                   ; the interrupt flag
        jz      leave_ints_off
        FSTI
leave_ints_off:

cEnd

;-----------------------------------------------------------------------;
; DirectedYield                                                         ;
;                                                                       ;
; This does a yield and attempts to yield to the specific yo-yo.        ;
; In reschedule is checked the event count of the target task, if       ;
; non-zero then that task is started.  Else the task queue is searched  ;
; as normal.                                                            ;
;                                                                       ;
; Arguments:                                                            ;
;       parmW yield_to                                                  ;
;                                                                       ;
; Returns:                                                              ;
;       nothing                                                         ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       All                                                             ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;                                                                       ;
; Calls:                                                                ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Sat Mar 28, 1987 06:14:17p  -by-  David N. Weise   [davidw]          ;
; Fixed it for aaronr.                                                  ;
;                                                                       ;
;  Fri Feb 06, 1987 00:00:11a  -by-  David N. Weise   [davidw]          ;
; Wrote it for aaronr.                                                  ;
;-----------------------------------------------------------------------;

        assumes ds, nothing
        assumes es, nothing

cProc   DirectedYield,<PUBLIC,FAR>
;       parmW yield_to
cBegin nogen

        push    bp
        mov     bp,sp
        push    ax
        push    ds

; get rid of the argument on the stack

        mov     ax,[bp][2]              ; move IP up
        xchg    [bp][4],ax
        xchg    [bp][6],ax              ; move CS up
        SetKernelDS

        mov     ds,curTDB
        assumes ds,nothing
        mov     ds:[TDB_Yield_to],ax
;
; Since this function is used by SendMessage() to switch directly
; to and from the destination app, we don't want to call USER to recieve
; any messages, since that causes unnecessary and inefficient recursion.
;
ifdef DISABLE
        cmp     ds:[TDB_QUEUE],0
        pop     ds
        pop     ax
        pop     bp
        jz      dy_OldYield
        add     sp,2                    ; waste the space
        jmp     cs:pYieldProc           ; Jump through CS VARIABLE
else
        pop     ds
        pop     ax
        pop     bp
endif

dy_OldYield:
        add     sp,2                    ; waste the space
        jmps    OldYield                ; If no task queue, do OLD Yield.

cEnd nogen


;-----------------------------------------------------------------------;
; Yield                                                                 ;
;                                                                       ;
; Does what it says.                                                    ;
;                                                                       ;
; Arguments:                                                            ;
;                                                                       ;
; Returns:                                                              ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;                                                                       ;
; Calls:                                                                ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Sat May 09, 1987 12:21:13p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.                                       ;
;                                                                       ;
;  Wed Apr 15, 1987 12:13:00p  -by-  Raymond E. Ozzie [-iris-]          ;
; Changed Yield to work for tasks that don't ever do an INITAPP, and    ;
; thus don't have a task queue.  These are presumably tasks that do     ;
; some sort of background computational activity that don't have a      ;
; window associated with them.                                          ;
;                                                                       ;
;-----------------------------------------------------------------------;

        assumes ds, nothing
        assumes es, nothing

cProc   Yield,<PUBLIC,FAR>
cBegin nogen


        push    ds
        SetKernelDS
        mov     ds,curTDB
        assumes ds, nothing
        mov     ds:[TDB_Yield_to],0
        cmp     ds:[TDB_QUEUE],0
        pop     ds
        jz      OldYield                ; If no task queue, do OLD Yield.
        jmp     cs:pYieldProc           ; Pass to USER Jump through CS VARIABLE

cEnd nogen

        assumes ds, nothing
        assumes es, nothing

cProc   OldYield,<PUBLIC,FAR>,<ds>
cBegin
        SetKernelDS
        xor     ax,ax
        cmp     InScheduler,al          ; can't yield if inside scheduler
        jnz     yld3                    ; just return false
        cmp     CurTDB,0                ; did it kill itself?
        jz      @F
        mov     ds,CurTDB
        assumes ds, nothing
        inc     ds:[TDB_nEvents]

@@:     smov    es, ax
    .386
        smov    fs, ax
        smov    gs, ax
    .286
        push    cs
        call    Reschedule
        dec     ds:[TDB_nEvents]
        mov     ax,-1                   ; TRUE
yld3:
cEnd

endif           ; !WOW

        assumes ds, nothing
        assumes es, nothing

GetTaskHandle2:
        mov     bx,sp
        mov     ax,ss:[bx+8]
        mov     bx,ss:[bx+6]
        jmps    GetTaskHandle0
GetTaskHandle1:
        mov     bx,sp
        mov     ax,ss:[bx+6]
GetTaskHandle0:
        or      ax,ax
        jnz     gt1
        SetKernelDS     es
        mov     ax,curTDB
gt1:    mov     es,ax
        assumes es, nothing
;       cmp     es:[TDB_sig],TDB_SIGNATURE
;       jne     gt2
        ret
;gt2:   kerror  ERR_TASKID,<GetTaskHandle: Invalid task handle>
;       ret

ifndef WOW

;;
;; PostEvent( taskID ) - increment the event counter for a task.  Return
;; false if invalid task handle passed.  Otherwise return true, after
;; setting the scheduler flag that says a new task might be ready to
;; run.
;;
        assumes ds, nothing
        assumes es, nothing

cProc   PostEvent,<PUBLIC,FAR>
;       parmW   taskID
cBegin  nogen
        call    GetTaskHandle1
        inc     es:[TDB_nEvents]        ; indicate one more event
        ret     2
cEnd    nogen

endif           ; !WOW

;-------------------------------------------------------
;
;  Get the Task pull model event queue handle
;
        assumes ds, nothing
        assumes es, nothing

cProc   GetTaskQueue,<PUBLIC,FAR>
;       parmW   taskID
cBegin  nogen
        call    GetTaskHandle1
        mov     ax,es:[TDB_queue]
        ret     2
cEnd    nogen

;-------------------------------------------------------
;
;  Get the Task pull model event queue handle into DS
;
        assumes ds, nothing
        assumes es, nothing

cProc   GetTaskQueueDS,<PUBLIC,FAR>
cBegin  nogen
        SetKernelDS
        mov     ds,curTDB
        assumes ds, nothing
        mov     ds,ds:[TDB_queue]
        ret
cEnd    nogen

;-------------------------------------------------------
;
;  Get the Task pull model event queue handle into ES
;
        assumes ds, nothing
        assumes es, nothing

cProc   GetTaskQueueES,<PUBLIC,FAR>
cBegin  nogen
        SetKernelDS     es
        mov     es,curTDB
        assumes es,nothing
        mov     es,es:[TDB_queue]
        ret
cEnd    nogen

        assumes ds, nothing
        assumes es, nothing

cProc   SetTaskSignalProc,<PUBLIC,FAR>
;       parmW   taskID
;       parmD   signalProc
cBegin  nogen
        mov     bx,sp
        mov     ax,ss:[bx+8]
        call    GetTaskHandle0
        mov     ax,ss:[bx+4]
        mov     dx,ss:[bx+6]
        xchg    ax,es:[TDB_USignalProc].off
        xchg    dx,es:[TDB_USignalProc].sel
        ret     6
cEnd    nogen

;--------------------------------------------------------
;
;  Set (and Get) the Task pull model event queue handle
;
        assumes ds, nothing
        assumes es, nothing

cProc   SetTaskQueue,<PUBLIC,FAR>
;       parmW   taskID
;       parmW   hQueue
cBegin  nogen
        call    GetTaskHandle2
        mov     ax,bx
        xchg    ax,es:[TDB_queue]
        ret     4
cEnd    nogen

ifndef WOW

;--------------------------------------------------------
;
;  Set (and Get) Task Priority
;
        assumes ds, nothing
        assumes es, nothing

cProc   SetPriority,<PUBLIC,FAR>
;       parmW   taskID
;       parmW   newPri
cBegin  nogen
        call    GetTaskHandle2
        add     bl,es:[TDB_priority]
        cmp     bl,-32
        jge     stp1
        mov     bl,-32
stp1:   cmp     bl,15
        jle     stp2
        mov     bl,15
stp2:   push    bx
        mov     bh,1                    ; put at back of priority queue
        cmp     es:[TDB_priority],bl    ; SetPriority( 0 )?
        jne     stp3                    ; No, continue
        mov     ax,es                   ; Yes, is this the current task?
        push    ds
        SetKernelDS
        cmp     ax,curTDB
        pop     ds
        assumes ds, nothing
        je      stp4                    ; Yes, exit without doing anything
        mov     bh,0                    ; No, put at front of priority queue
stp3:
        add     bl,bh
        mov     es:[TDB_priority],bl
        push    bx
        push    es
        cCall   DeleteTask,<es>
        cCall   InsertTask,<ax>
        pop     es
        pop     ax
        sub     es:[TDB_priority],ah
stp4:
        pop     ax
        cbw
        ret     4
cEnd    nogen

endif ; WOW - the above code is not required in WOW

;;
;; Aaron Reynolds 7/20/87 - Added so folks like USER can ask if this is Winoldap
;;
;; IsWinoldapTask( taskID ) - Is this a Winoldap Task?
;; false if not a Winoldap task, else true
;; This works by returning the low bit in the Global Heap pointer of the task's
;; PDB. Nobody in KERNEL sets this bit (it is always initialized to 0). It is
;; up to WINOLDAP to mark its tasks by setting the low bit itself.
;;
        assumes ds, nothing
        assumes es, nothing

cProc   IsWinoldapTask,<PUBLIC,FAR>
;       parmW   taskID
cBegin  nogen
ifdef WOW
        xor ax, ax                      ; always return false
else
        call    GetTaskHandle1
        mov     es,es:[TDB_PDB]         ; Get PDB pointer from task handle
        mov     ax,word ptr es:[PDB_GlobalHeap] ; Get low word of Global heap ptr
        and     ax,0000000000000001B    ; Mask to low bit
endif
        ret     2
cEnd    nogen


;----------------------------------------------------------------------------;
; IsTask
;
; OLE 1.0 DLLs check whether the task they are talking to is a genuine one
; or not. This they do by calling IsTask(). So, I look for -1 as the hTask,
; which was returned from GetWindowTask() as BOGUSGDT for the 32 bit tasks
; and for the 16 bit tasks a correct value was returned.
;
; So, if we find hTask on this function as -1, we should return TRUE to
; keep OLE DLLs happy.
;
; ChandanC Feb 9th 1993.
;
;----------------------------------------------------------------------------;


; Validate a task handle
; davidds
cProc   IsTask,<PUBLIC, FAR>
;       parmW  taskID
cBegin  nogen
        mov    bx,sp
        mov    ax,ss:[bx+4]

        or      ax,ax
        jz      IT_err

ifdef WOW
        test   al, 0100b        ; Check for task aliases (see WOLE2.C) or BOGUSGDT
        jnz    task_check

task_ok:
        mov    ax, 1
        jmp    SHORT IT_exit

task_check:
endif

.286p
        lsl    bx,ax
        jnz    IT_err
        cmp    bx,size TDB
        jl     IT_err
        mov    es,ax
        cmp    es:[TDB_sig],TDB_SIGNATURE
        jne    IT_err
        jmp    short IT_exit

IT_err:
        xor    ax,ax

IT_exit:
        ret    2
cEnd    nogen

;-----------------------------------------------------------------------;
; CVW_Hack
;
; This is a little hack for the next rev of CVW.  This is a cheap
; way to break into an app just before it really starts up.  We
; call off to the ptrace DLL and then jump off to the real entry
; point.
;
; Entry:
;       none
;
; Returns:
;       none
;
; Registers Preserved:
;       all
;
; Registers Destroyed:
;
; History:
;
;  Mon 27-Feb-1989 20:22:06  -by-  David N. Weise  [davidw]
; Wrote it.
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   CVW_Hack,<PUBLIC,FAR>

cBegin nogen
        sub     sp, 4
        ;** See if we should call the TOOLHELP hook first
        push    ds
        SetKernelDS
        test    Kernel_Flags[2],KF2_TOOLHELP ;TOOLHELP.DLL?
        jz      st_NoToolHelp           ;Nope
        push    ax                      ;Save regs we use
        push    cx
        push    bx

        push    Win_PDB                 ; Preserve Win_TDB across ToolHelp call
        cmp     curTDB,0
        jz      @F
        push    es
        mov     es,curTDB
        push    es:[TDB_PDB]
        pop     ds:Win_PDB
        pop     es
@@:
        mov     ax,SDM_LOADTASK
        mov     bx,WORD PTR ptrace_app_entry[0] ;Task start address in CX:DX
        mov     cx,WORD PTR ptrace_app_entry[2]

        call    lpfnToolHelpProc        ;Do it

        pop     Win_PDB

        pop     bx
        pop     cx
        pop     ax

        ;** Since we got here, we know that at least one of the two
        ;**     (WINDEBUG, TOOLHELP) or both are here.  Since we know
        ;**     TOOLHELP is here, we still need to check for WINDEBUG.
        ;**     If it's here, act as if TOOLHELP were not
        cmp     WORD PTR ptrace_DLL_entry[2],0 ;WINDEBUG present?
        jnz     st_NoToolHelp           ;Yes, give it a turn

        ;** Since we have no one else to call, simply start the task
        ;**     Stack:  AX[-2] BP[0] DS[2] RETFIP[4] RETFCS[6]
        push    bp
        mov     bp,sp
        push    ax
        mov     ax,WORD PTR ptrace_app_entry[0] ;Get the IP value
        mov     [bp + 4],ax             ;Put in place of RETFIP
        mov     ax,WORD PTR ptrace_app_entry[2] ;Get the CS value
        mov     [bp + 6],ax             ;Put in place of RETFCS
        pop     ax                      ;Clean up and start up the task
        pop     bp
        pop     ds
        retf

st_NoToolHelp:
        pop     ds
        add     sp, 4

        ;** Now call CVW's hook (WINDEBUG.DLL)
        push    ax
        push    bx
        push    cx
        push    ds
        mov     bx,ds
        SetKernelDS
        push    ptrace_app_entry.sel    ; push real app entry point
        push    ptrace_app_entry.off

        push    cs                      ; push return to return
        push    codeOffset cvwh_clever



        push    ptrace_DLL_entry.sel    ; push call into ptrace
        push    ptrace_DLL_entry.off

        push    ptrace_app_entry.sel
        push    ptrace_app_entry.off
        mov     ds,bx
        UnsetKernelDS
        mov     ax,59h
        pop     bx
        pop     cx
        retf                            ; 'call' ptrace
cvwh_clever:
        mov     bx,sp
        mov     ax,ss:[bx].10
        mov     cx,ss:[bx].06
        mov     bx,ss:[bx].08
        retf    8                       ; return to real entry point

cEnd nogen

;-----------------------------------------------------------------------;
; FileCDR_notify
;
;
; Entry:
;
; Returns:
;
; Registers Destroyed:
;
; History:
;  Thu 08-Jun-1989 17:04:49  -by-  David N. Weise  [davidw]
; Wrote it!
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   FileCDR_notify,<PUBLIC,FAR>,<ax,bx,cx,dx,si,di,ds,es>
        localW  hHunkOMemory
        localD  lpDestFile
cBegin
        mov     hHunkOMemory, 0                 ; Handle/flag for RENAME
        mov     SEG_lpDestFile, es
        mov     OFF_lpDestFile, di
        mov     si,dx                           ; DS:SI points to [source] file
        SetKernelDS     es
        cmp     word ptr shell_file_proc[2],0
        jnz     @F
fcdr_no_exitj:
        jmp     fcdr_no_exit
@@:
        mov     di,dataOffset lpszFileName      ; Where we will copy filename
        cmp     ah, 56h                         ; RENAME?
        jne     fcdr_no_alloc

        mov     ax, 256                         ; Get enough for two filenames
        xor     bx, bx
        mov     cx, (GA_SHAREABLE SHL 8)+GA_MOVEABLE+GA_NOCOMPACT+GA_NODISCARD
        cCall   GlobalAlloc,<cx, bx, ax>
        or      ax, ax
        jz      fcdr_no_exitj
        mov     hHunkOMemory, ax
        cCall   GlobalLock,<ax>
        mov     es, dx
        UnSetKernelDS   es
        mov     di, ax
        mov     ah, 56h
fcdr_no_alloc:

        cld
        push    ax                      ; push arguments to call
        push    es
        push    di
        cmp     byte ptr ds:[si][1],':'
        jnz     nodrive
ifdef FE_SB
        mov     al, byte ptr ds:[si][0]
        call    FarMyIsDBCSLeadByte
        jnc     nodrive
endif
        lodsb
        inc     si
        or      al,20h                  ; convert to lower case
        sub     al,'a'                  ; convert to number
        jmps    gotdrive
nodrive:
        mov     ah,19h
        DOSCALL
gotdrive:
        mov     dl,al
        inc     dl
        add     al,'A'                  ; convert to ascii
        mov     ah,':'
        stosw
        mov     bx,'/' shl 8 + '\'
        mov     al,ds:[si]

        cmp     al,bh
        jz      getpath
        cmp     al,bl
        jz      getpath
        mov     al,bl
        stosb
        mov     cx,ds
        xchg    si,di
        smov    ds,es
        mov     ah,47h
        DOSCALL
        mov     ds,cx
        xchg    si,di
        xor     al,al
ifdef FE_SB
; seek pointer to final byte of path.
        xor     ah,ah                   ; flag to indicate last char is dbc
bsl_1:
        mov     al,es:[di]
        test    al,al                   ; end of string?
        jz      bsl_2                   ; jump if so
        inc     di
        xor     ah,ah
        call    FarMyIsDBCSLeadByte     ; DBC?
        jc      bsl_1                   ; jump if not
        inc     ah                      ; indicate 'DBC'
        jmp     bsl_1
bsl_2:
        test    ah,ah                   ; last char is DBC?
        jnz     getpath                 ; yes - don't test '\/'
else
        mov     cx,-1
        repnz   scasb
        dec     di
endif
        mov     al,es:[di-1]
        cmp     al,bh
        je      getpath
        cmp     al,bl
        je      getpath
        mov     al,bl
        stosb
getpath:

@@:     lodsb
        or      al,al
        stosb
        jnz     @B

        cmp     hHunkOMemory, 0
        jz      no_second_file

        lds     si, lpDestFile                  ; Tack destination file name
copy_second:                                    ; after source file name
        lodsb
        stosb
        or      al, al
        jnz     copy_second

no_second_file:
        SetKernelDS     es

if KDEBUG

        call    shell_file_proc

else    ; KDEBUG
;
; The call to shell_file_proc can blow up if the variable has not
; been updated properly, and we generate an invalid call fault.
;
        beg_fault_trap  bad_shell_file_proc

        call    shell_file_proc

        jmps    good_shell_file_proc

bad_shell_file_proc:

        fault_fix_stack
;
; If shell_file_proc has a bad non-zero value, then zero it out
; so USER doesn't get confused.
;
        xor     si,si
        mov     word ptr [shell_file_proc],si
        mov     word ptr [shell_file_proc+2],si

        end_fault_trap

good_shell_file_proc:

endif   ; KDEBUG

        mov     si, hHunkOMemory                ; Free up memory if necessary
        or      si, si
        jz      fcdr_no_exit
        cCall   GlobalUnlock,<si>
        cCall   GlobalFree,<si>

fcdr_no_exit:
cEnd

;-----------------------------------------------------------------------;
; InitTask1
;
;
; Entry:
;
; Returns:
;
; Registers Destroyed:
;
; History:
;  Sun 04-Feb-1990 23:47:37  -by-  David N. Weise  [davidw]
; Wrote it!
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   InitTask1,<PUBLIC,FAR>

;       parmD   callback
cBegin nogen
        mov     bx,sp
        push    ds
        SetKernelDS
        mov     ax,ss:[bx].4
        mov     dressed_for_success.off,ax
        mov     ax,ss:[bx].6
        mov     dressed_for_success.sel,ax
        pop     ds
        ret     4
cEnd nogen

ifdef WOW
;-----------------------------------------------------------------------;
; IsTaskLocked								;
; 									;
; Another hack procedure to determine if the current task is locked.	;
; A non-NULL value is returned if the task is locked and NULL is	;
; returned is the task is not locked.					;
;                                                                       ;
; This will always return null, because we will always have more than   ;
; one WOW app. (wowexec is always running                               ;
;                                                                       ;
; This api is used by QuickC                                            ;
;                                                         - Nanduri     ;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

cProc	IsTaskLocked,<PUBLIC,FAR>
cBegin  nogen
        xor ax,ax
	ret
cEnd    nogen

endif           ; WOW


        assumes ds, nothing
        assumes es, nothing

cProc   GetVersion,<PUBLIC,FAR>
cBegin nogen
        push    ds
        SetKernelDS
        cCall   GetAppCompatFlags,<0>
        test    dx, HIW_GACF_WINVER31
        jz      gv0
        mov     ax, 0a03h               ; Win ver 3.10 if app hack set
        jmps    gv1

gv0:
        mov     ax, 5f03h               ; Win ver 3.95
;       mov     ax,winVer
;       xchg    ah,al
gv1:
        mov     dh,DOS_version
        mov     dl,DOS_revision

        pop     ds
        UnSetKernelDS
        ret
cEnd nogen


sEnd    CODE



sBegin  MISCCODE
assumes cs, misccode
assumes ds, nothing
assumes es, nothing

ExternNP MISCMapDStoDATA

;-----------------------------------------------------------------------;
;
; SetErrorMode - set the current task's error mode
;
; Entry:
;       parmW   errMode 0001h = fail critical errors to app
;                       0002h = don't put up pmode fault message
;                       8000h = don't promt for file in OpenFile
;
; Returns:
;       AX = old flags
;
; History:
;  Sun 11-Feb-1990 19:01:12  -by-  David N. Weise  [davidw]
; Added this nifty comment block.
;-----------------------------------------------------------------------;

        assumes ds, nothing
        assumes es, nothing

cProc   ISetErrorMode,<PUBLIC,FAR>
        parmW   errMode
cBegin
        cCall   MISCMapDStoDATA
        ResetKernelDS
        mov     ax,errMode
        mov     ds,CurTDB
        UnSetKernelDS
        xchg    ds:[TDB_ErrMode],ax
cEnd


;-----------------------------------------------------------------------;
; GetWinFlags
;
; Gets the WinFlags for those wimps that can't import
; __WinFlags properly!
;
; Entry:
;       none
;
; Returns:
;       AX = WinFlags
;
; History:
;  Wed 05-Jul-1989 20:19:46  -by-  David N. Weise  [davidw]
; Wrote it!
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   GetWinFlags,<PUBLIC,FAR>
cBegin nogen
        push    ds
        cCall   MISCMapDStoDATA
        ResetKernelDS
; Comment out this app hack since toolbook is no longer hacked...
; above is from Win95 source, why is toolbook no longer hacked? -DaveHart

        xor	ax, ax
	push	ax			; NULL => current task
	cCall	GetAppCompatFlags
        test    ax, GACF_HACKWINFLAGS
        mov     ax,WinFlags
        jz      @f

ifdef WOW
        ; fixes toolbook for WOW  -BobDay
;        and     ah, not ( WF1_WINNT or WF1_PAGING )
        and     ah, not WF1_WINNT ; fixes some apps that think they can't run on NT
else
        and     ah, not WF1_PAGING      ; fixes toolbook
endif

@@:
        xor     dx,dx
        pop     ds
        ret
cEnd nogen


;--------------------------------------------------------
;
;  GetExeVersion - return the current task's expected Windows version
;
        assumes ds, nothing
        assumes es, nothing

cProc   GetExeVersion,<PUBLIC,FAR>
cBegin  nogen
        push    ds
        call    MISCMapDStoDATA
        ReSetKernelDS
        mov     ds, CurTDB
        UnSetKernelDS
        mov     ax, ds:[TDB_ExpWinVer]
        pop     ds
        ret
cEnd    nogen

ifndef WOW
;-----------------------------------------------------------------------;
; WinOldApCall                                                          ;
;                                                                       ;
; This gives WinOldAp the information it needs to run in Expanded       ;
; Memory.                                                               ;
;                                                                       ;
; Arguments:                                                            ;
;       none                                                            ;
;                                                                       ;
; Returns:                                                              ;
;       (Real Mode)                                                     ;
;       BX    = XMS Handle of segment cache block                       ;
;       CX    = Size (in K bytes) of segment cache block                ;
;       DS:SI = pointer to original Int 21h handler                     ;
;       DI    = DOS System File Table Entry size                        ;
;                                                                       ;
;       (Protected Mode)                                                ;
;       AX    = Selector to low (lower 640k) heap block                 ;
;       BX    = paragraph count of low heap block                       ;
;       CX    = Selector to high (above 1024k & HMA) heap block         ;
;       DX    = Selector to fixed low PDB block for WOA use             ;
;       DS:SI = pointer to original Int 21h handler                     ;
;       DI    = DOS System File Table Entry size                        ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;                                                                       ;
; Calls:                                                                ;
;       nothing                                                         ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Wed Mar 25, 1987 03:03:57p  -by-  David N. Weise   [davidw]          ;
; Wrote it.                                                             ;
;-----------------------------------------------------------------------;

        assumes ds, nothing
        assumes es, nothing

cProc   WinOldApCall,<PUBLIC,FAR>
;       parmW   func
cBegin nogen

        push    ds
        call    MISCMapDStoDATA
        ReSetKernelDS
        mov     bx,sp                   ; check function code
        cmp     word ptr ss:[bx+6],0    ;  0 - get WOA info call
        jz      get_info                ; !0 - close cached files call

        push    Win_PDB                 ; Save current PDB
        cCall   CloseCachedFiles,<topPDB> ; close the cached files--really
        pop     Win_PDB                 ; 'Set' it back
;;;     mov     bx, Win_PDB
;;;     mov     ah, 50h                   ; Reset the PDB
;;;     call    far_real_DOS
;;;     mov     cur_dos_PDB, bx           ; Keep variables in sync
        jmps    woa_exit                  ;  closes them when passed topPDB

get_info:

        mov     ax,selLowHeap
        mov     bx,cpLowHeap
        mov     cx,selHighHeap
        mov     dx,selWoaPdb

        mov     di,FileEntrySize        ;DOS version specific SFT entry size

woa_exit:
        pop     ds
        ret     2

cEnd nogen
endif


;-----------------------------------------------------------------------;
; RegisterPtrace
;
; The ptrace engine DLL gets calls on behalf of the KERNEL.
;
; Entry:
;
; Returns:
;
; Registers Destroyed:
;
; History:
;  Fri 02-Feb-1990 23:41:54  -by-  David N. Weise  [davidw]
; We'll get this right one of these days.
;
;  Mon 27-Feb-1989 20:22:06  -by-  David N. Weise  [davidw]
; Wrote it!
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   RegisterPtrace,<PUBLIC,FAR>

;       parmD   ptrace_proc

cBegin nogen
        push    ds
        call    MISCMapDStoDATA
        ReSetKernelDS
        mov     bx,sp
        or      Kernel_flags[2],KF2_PTRACE
        mov     ax,ss:[bx][6]
        mov     ptrace_DLL_entry.off,ax
        or      ax,ss:[bx][8]           ; is there one?
        mov     ax,ss:[bx][8]
        mov     ptrace_DLL_entry.sel,ax

        jnz     rp_done

        ;** If TOOLHELP's still installed, we don't really want to clear the
        ;**     flag.  If it's unhooked, clear the flag
        test    Kernel_flags[2], KF2_TOOLHELP
        jnz     rp_done
        and     Kernel_flags[2],NOT KF2_PTRACE
rp_done:
        pop     ds
        ret     4
cEnd nogen


;-----------------------------------------------------------------------;
; ToolHelpHook
;
;       Allows TOOLHELP.DLL to get PTrace notifications BEFORE the
;       normal PTrace hook used by WINDEBUG.DLL.  The WINDEBUG.DLL
;       hook is now obsolete and is maintained only for backward
;       compatibility.
;
;       TOOLHELP calls this function with a valid lpfn or with NULL
;       when it is ready to unhook.
;
;       July 25, 1991 [jont]
;-----------------------------------------------------------------------;

cProc   ToolHelpHook,<PUBLIC,FAR>, <ds,si,di>
        parmD   lpfn
cBegin
        SetKernelDSMisc

        ;** Set/clear the ToolHelp hook installed flag + we also set the
        ;*      PTrace flag because the ToolHelp hook is just a new
        ;*      PTrace hook.  We can only clear it, though, if BOTH PTrace
        ;**     hooks are now clear.
        or      Kernel_Flags[2],KF2_TOOLHELP OR KF2_PTRACE ;Set the flags
        mov     ax,WORD PTR lpfn[0]     ;Get the offset
        mov     dx,WORD PTR lpfn[2]     ;  and the selector
        mov     bx,ax                   ;Get a copy to trash
        or      bx,dx                   ;NULL?
        jnz     THH_Installed           ;No
        and     Kernel_Flags[2],NOT KF2_TOOLHELP ;Clear the flag
        cmp     WORD PTR ptrace_dll_entry[2],0 ;WINDEBUG.DLL lurking?
        jnz     THH_Installed           ;Yes, don't clear PTrace flag
        and     Kernel_Flags[2],NOT KF2_PTRACE ;Clear the flag
THH_Installed:

        ;** Install the hook and return the old one
        xchg    ax,WORD PTR lpfnToolHelpProc[0]
        xchg    dx,WORD PTR lpfnToolHelpProc[2]
cEnd

;-----------------------------------------------------------------------;
; FileCDR
;
; Allows the shell to set a procedure that gets called when
; a file or directory is created, moved, or destroyed.
;
; Entry:
;       parmD   lpNotifyProc    call back function
;
; Returns:
;       AX != 0 success
;
; History:
;  Mon 05-Jun-1989 22:59:33  -by-  David N. Weise  [davidw]
; Wrote it!
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   FileCDR,<PUBLIC,FAR>
;       parmD   lpNotifyProc
cBegin nogen
        mov     bx,sp
        push    ds
        call    MISCMapDStoDATA
        ReSetKernelDS
        mov     ax,ss:[bx][6]
        cmp     ax,-1                           ; is sel == -1, return current
        jne     @F                              ; proc
        mov     ax,shell_file_proc.off
        mov     dx,shell_file_proc.sel
        jmps    fcdr_exit

@@:
        xchg    shell_file_proc.sel,ax
        or      ax,ax
        jz      @F
        mov     cx,curTDB
        cmp     cx,shell_file_TDB
        jnz     fcdr_error
@@:     mov     ax,ss:[bx][4]
        mov     shell_file_proc.off,ax
        mov     ax,curTDB
        mov     shell_file_TDB,ax
        mov     ax,1
        jmps    fcdr_exit

fcdr_error:
        xchg    shell_file_proc.sel,ax  ; replace what was there
        xor     ax,ax

fcdr_exit:
        pop     ds
        UnSetKernelDS
        retf    4
cEnd nogen


sEnd    MISCCODE
end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\diag.asm ===
;***************************************************************************
;*  DIAG.ASM
;*
;*      Diagnostic-mode routines used to log interesting output to a log
;*      file.  Diagnostic mode is enabled/disabled through a command line
;*      switch.
;*
;*      Created by JonT starting 19 July 1991
;*
;***************************************************************************

	TITLE	LOG - Diagnostic mode logging routines

.xlist
include kernel.inc
.list

.386p


DataBegin

externD lpWindowsDir
externW cBytesWinDir
externB szDiagStart
externB szCRLF

globalW fDiagMode,0                     ;Set in LDBOOT.ASM
szLogFileName   DB      'BOOTLOG.TXT', 0
szPath          DB      128 DUP(0)      ;Entire pathname to file
IF KDEBUG
externB	szInitSpew
ENDIF

DataEnd

externFP Int21Handler
externFP OutputDebugString

;** Note that this goes in the fixed code segment
sBegin	CODE
assumes CS,CODE

;  DiagQuery
;
;       Exported entry point that can be called to determine if in
;       diagnostic mode.  Returns TRUE iff in diagnostic mode.

cProc   DiagQuery, <FAR,PUBLIC>, <si,di,ds>
cBegin
        SetKernelDS

        mov     ax,fDiagMode            ;Return the flag
cEnd


;  DiagOutput
;
;       Exported entry point to allow a string to be written to the
;       log file.  The file is flushed after writing the string
;       guaranteeing that it always gets in there in case we abort
;       immediately after the call.

cProc   DiagOutput, <FAR,PUBLIC>, <si,di,ds>
	parmD   lpstr
	localW  wHandle
cBegin
	SetKernelDS

	;** Check for diag mode
	cmp     fDiagMode,1             ;Diag mode?
	jne     SHORT DO_End            ;Nope, get out

	;** Reopen the log file
	mov     ah,3dh                  ;Create file call
	mov     al,22h                  ;R/W, Deny W to others
	mov     dx,dataOFFSET szPath    ;File name pointer
	DOSCALL
	jc      SHORT DO_Error          ;Error, get out
	mov     wHandle,ax              ;Save the handle

	;** Seek to the end
	mov     ax,4202h                ;Seek to end of file call
	mov     bx,wHandle              ;Get the file handle
	xor     cx,cx                   ;0 bytes before end of file
	xor     dx,dx
	DOSCALL
	jc      SHORT DO_Error          ;Error, get out

	;** Get the length of the string
	xor     cx,cx                   ;Get max length
	dec     cx                      ;  (0xffff)
	les     di,lpstr                ;Point to the string
	xor     al,al                   ;Zero byte
	repnz   scasb                   ;Find the zero byte
	neg     cx                      ;Get the length
	dec     cx
	dec     cx

IF KDEBUG
        ;** Spit to debug terminal in debug KERNEL
        push    cx
        push    WORD PTR lpstr[2]
        push    WORD PTR lpstr[0]
        call    OutputDebugString
	pop     cx
ENDIF

        ;** Write the string
        push    ds                      ;Save our DS
        mov     ah,40h                  ;Write file call
        mov     bx,wHandle              ;Get the handle
        lds     dx,lpstr                ;Get the buffer pointer
        UnsetKernelDS
        DOSCALL
        pop     ds
        ResetKernelDS
        jnc     SHORT DO_Close          ;No problem

DO_Error:
        mov     fDiagMode,0             ;Clear diagnostic mode and close file

        ;** Close the file
DO_Close:
        mov     bx,wHandle              ;Handle in BX
        or      bx,bx                   ;File open?
        jz      SHORT DO_End            ;Nope, just get out
        mov     ah,3eh                  ;Close file call
        DOSCALL
DO_End:

cEnd


;  DiagInit
;
;       Called from Bootstap (LDBOOT.ASM) and is used to create the log file
;       and write the startup message to it.

cProc   DiagInit, <FAR,PUBLIC>, <ds,si,di>
        localW  wHandle
cBegin
        SetKernelDS
        smov    es,ds                   ;Point to kernel DS with ES

        ;** Get the full path name
        mov     di,dataOFFSET szPath    ;Point to destination path
        mov     cx,cBytesWinDir         ;Get the length of the directory
        lds     si,lpWindowsDir         ;Point to the Windows directory
        UnsetKernelDS
        rep     movsb                   ;Copy it
        smov    ds,es                   ;Get DS back to kernel DS
        ResetKernelDS
        mov     si,dataOFFSET szLogFileName ;Point to log file name
        cmp     BYTE PTR [di - 1],'/'   ;Check for trailing separator
        je      SHORT DI_NoSeparator    ;No separator needed
        mov     al,'\'                  ;Get the other separator
        cmp     [di - 1],al             ;Check for other separator
        je      SHORT DI_NoSeparator    ;None needed
        stosb                           ;Put a '\' in
DI_NoSeparator:
        lodsb                           ;Get the char
        stosb                           ;Write it
        or      al,al                   ;Zero byte?
        jnz     DI_NoSeparator          ;No, loop for next char

IF KDEBUG
        ;** Spit to debug terminal in debug KERNEL
        push    ds
	push    dataOFFSET szInitSpew
        call    OutputDebugString       ;Spit out the message
        push    ds
        push    dataOFFSET szPath       ;Spit out log filename
        call    OutputDebugString
        push    ds
        push    dataOFFSET szCRLF       ;Write a CR/LF
        call    OutputDebugString
ENDIF

        ;** Try to open the file.  If it exists, we use it as it
        mov     ah,3dh                  ;Open file call
        xor     cx,cx                   ;Normal file
        mov     al,22h                  ;R/W, Deny W to others
        mov     dx,dataOFFSET szPath    ;File name pointer
        DOSCALL
        jc      SHORT DI_Create         ;Error, need to create file
        mov     wHandle,ax              ;Save the handle

        ;** Seek to the end
        mov     ax,4202h                ;Seek to end of file call
        mov     bx,wHandle              ;Get the file handle
        xor     cx,cx                   ;0 bytes before end of file
        xor     dx,dx
        DOSCALL
	jmps	DI_CloseIt		;Close file now

        ;** Create the log file
DI_Create:
        mov     ah,3ch                  ;Create file call
        xor     cx,cx                   ;Normal file
        mov     dx,dataOFFSET szPath    ;File name pointer
        DOSCALL
        mov     wHandle,ax              ;Save the handle

        ;** On error, disable logging
        jc      SHORT DI_End            ;Error, get out without enabling
DI_CloseIt:
        mov     fDiagMode,1             ;We're in diag mode now

        ;** Close the file (we reopen it on each call to DiagOutput)
        mov     bx,wHandle              ;Handle in BX
        mov     ah,3eh                  ;Close file call
        DOSCALL

        ;** Now start the log file
        mov     ax,dataOFFSET szDiagStart ;Point to the string
        cCall   DiagOutput, <ds,ax>     ;Start the file

DI_End:
cEnd

sEnd

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\gpcont.inc ===
SHERLOCK = 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\enable.asm ===
.xlist
include kernel.inc
include pdb.inc
include tdb.inc
include newexe.inc
ifdef WOW
include vint.inc
endif
.list

externFP KillLibraries
ifndef WOW
externFP WriteOutProfiles
endif

DataBegin

externB PhantArray
externB kernel_flags
externB fBreak
externB fInt21
ifndef WOW
externB fProfileMaybeStale
endif
externW curTDB
externW headPDB
externW topPDB
externD lpInt21
externD pSftLink
externD lpWinSftLink
externD pSysProc
externD pMouseTermProc
externD pKeyboardTermProc
externD pSystemTermProc
externW MyCSAlias

externD myInt2F

DataEnd

sBegin  CODE
assumes CS,CODE
assumes ds, nothing
assumes es, nothing

externD prevInt00Proc
externD prevInt21Proc
externD prevInt24Proc
externD prevInt2FProc
externD prevInt3FProc
externD prevInt67Proc
externD prevInt02Proc
externD prevInt04Proc
externD prevInt06Proc
externD prevInt07Proc
externD prevInt3EProc
externD prevInt75Proc
externD prevInt0CProc
externD prevInt0DProc
externD prevIntx6Proc
externD prevInt0EProc
ifdef WOW
externD prevInt01proc
externD prevInt03proc
externD oldInt00proc
endif


externNP real_DOS
externNP Enter_gmove_stack
externNP TerminatePDB

;-----------------------------------------------------------------------;
; InternalEnableDOS
;
;
; Entry:
;       none
; Returns:
;
; Registers Destroyed:
;
; History:
;  Thu 21-Sep-1989 20:44:48  -by-  David N. Weise  [davidw]
; Added this nifty comment block.
;-----------------------------------------------------------------------;

SetWinVec  MACRO   vec
        externFP Int&vec&Handler
        mov     dx, codeoffset Int&vec&Handler
        mov     ax, 25&vec&h
        pushf
        call    prevInt21Proc
        endm

        assumes ds, nothing
        assumes es, nothing

cProc   InternalEnableDOS,<PUBLIC,FAR>
cBegin  nogen

        push    si
        push    ds
        SetKernelDS

        mov     al,1
        xchg    al,fInt21               ; set hook count to 1
        or      al,al                   ; was it zero?
        jz      @f
        jmp     ena21                   ; no, just leave
@@:

; now link back nodes to SFT if kernel had done it before. InternalDisableDOS
; saves the link in the DWORD variable lpWinSftLink. If this variable is NULL
; then either this is the first time InternalEnableDOS is being called or
; else the SFT had not been grown.

        cmp     lpWinSftLink.sel,0      ;was it allocated ?
        jz      @f                      ;no.
        push    ds                      ;save
        mov     cx,lpWinSftLink.sel     ;get the selector
        mov     dx,lpWinSftLink.off     ;get the offset
        lds     bx,[pSftLink]           ;place where we hooked new entry
        mov     word ptr ds:[bx][0],dx  ;restore offset
        mov     word ptr ds:[bx][2],cx  ;restore segment
        pop     ds                      ;restore data segment
@@:


; WARNING!! The ^C setting diddle MUST BE FIRST IN HERE......
;   If you do some other INT 21 call before this you will have
;   a "^C window", so don't do it....

        mov     ax,3301h                ; disable ^C checking
        mov     dl,0
        call    real_DOS

        mov     bx,TopPDB
        mov     ah,50h
        call    real_DOS                ; This way, or TDB_PDB gets set wrong

ifndef WOW
ends1:  mov     ah,6                    ; clean out any pending keys
        mov     dl,0FFh
        call    real_DOS
        jnz     ends1
endif

        mov     es,curTDB
        mov     bx,es:[TDB_PDB]
        mov     ah,50h
        int     21h

        push    ds
        lds     dx,myInt2F
        mov     ax,252Fh
        int     21h

        smov    ds,cs                   ; Pick up executable sel/seg
        UnSetKernelDS
        SetWinVec 24
        SetWinVec 00
        SetWinVec 02
        SetWinVec 04
        SetWinVec 06
        SetWinVec 07
        SetWinVec 3E
        SetWinVec 75
        pop     ds
        ReSetKernelDS

        mov     bx,2                    ; 2 = Enable/Disable one drive logic
        xor     ax,ax                   ; FALSE = Disable
        cCall   [pSysProc],<bx,ax>      ; NOTE: destroys ES if DOS < 3.20

; Set up the PhantArray by calling inquire system for each drive letter

        mov     bx,dataOffset PhantArray + 25   ; Array index
        mov     cx,26                           ; Drive #
SetPhant:
        dec     cx
        push    cx
        push    bx
        mov     dx,1                            ; InquireSystem
        cCall   [pSysProc],<dx,cx>
        pop     bx
        pop     cx
        mov     byte ptr [bx],0                 ; Assume not Phantom
        cmp     ax,2
        jae     NotPhant                        ; Assumption correct
;       or      dx,dx                           ; Drive just invalid?
;       jz      NotPhant                        ; Yes, assumption correct
        mov     byte ptr [bx],dl                ; Drive is phantom
NotPhant:
        dec     bx                              ; Next array element
        jcxz    phant_done
        jmp     SetPhant
phant_done:

        lds     dx,lpInt21
        UnSetKernelDS
        mov     ax,2521h
        int     21h
ena21:
        pop     ds
        pop     si
        ret
cEnd    nogen



;-----------------------------------------------------------------------;
; InternalDisableDOS                                                    ;
;                                                                       ;
;                                                                       ;
; Arguments:                                                            ;
;                                                                       ;
; Returns:                                                              ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;                                                                       ;
; Calls:                                                                ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Mon Oct 16, 1989 11:04:50  -by-   Amit Chatterjee  [amitc]           ;
;  InternalDisableDOS now takes away any nodes that kernel would have   ;
;  added to the SFT. InternalEnableDOS puts the nodes backs. Previously ;
;  the delinking was done by DisableKernel, but no one linked it back!  ;
;                                                                       ;
;  Sat May 09, 1987 02:00:52p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.                                       ;
;                                                                       ;
;  Thu Apr 16, 1987 11:32:00p  -by-    Raymond E. Ozzie  [-iris-]       ;
; Changed InternalDisableDOS to use real dos for 52h function, since    ;
; DosTrap3 doesn't have 52h defined and PassOnThrough will croak if the ;
; current TDB's signature is 0, as it is during exit after the last     ;
; task has been deleted.                                                ;
;-----------------------------------------------------------------------;

ReSetDOSVec  MACRO   vec
        lds     dx,PrevInt&vec&proc
        mov     ax,25&vec&h
        int     21h
        endm

        assumes ds, nothing
        assumes es, nothing

cProc   InternalDisableDOS,<PUBLIC,FAR>
cBegin
        SetKernelDS     es
        xor     ax,ax
        xchg    al,fInt21               ; set hook count to zero
        or      al,al                   ; was it non zero?
        jnz     @F
        jmp     dis21                   ; no, just leave
@@:
        mov     bx,2                    ; 2 = Enable/Disable one drive logic
        mov     ax,1                    ; TRUE = Enable
        push    es
        cCall   pSysProc,<bx,ax>
        pop     es

        mov     ax,3301h                ; disable ^C checking
        mov     dl,0
        pushf
        call    [prevInt21Proc]

        mov     ax,2521h
        lds     dx,prevInt21Proc
        pushf
        call    [prevInt21Proc]

        push    es
        mov     ax,352Fh
        int     21h
        mov     ax,es
        pop     es
        mov     myInt2F.sel,ax
        mov     myInt2F.off,bx

        ReSetDOSVec 00                  ; as a favor in win2 we restored this
        ReSetDOSVec 24
        ReSetDOSVec 2F
        ReSetDOSVec 02
        ReSetDOSVec 04
        ReSetDOSVec 06
        ReSetDOSVec 07
        ReSetDOSVec 3E
        ReSetDOSVec 75

        mov     dl,fBreak               ; return state of ^C checking
        mov     ax,3301h
        int     21h

dis21:
cEnd

;------------------------------------------------------------------
;
; Ancient WinOldAp hook.
;
;------------------------------------------------------------------
        public  EnableDOS

EnableDOS       Label   Byte
if kdebug
        krDebugOut DEB_WARN, "Don't call EnableDOS"
endif
        retf

;------------------------------------------------------------------
;
; Ancient WinOldAp hook.
;
;------------------------------------------------------------------
        public  DisableDOS

DisableDOS      Label   Byte
if kdebug
        krDebugOut DEB_WARN, "Don't call DisableDOS"
endif
        retf

;------------------------------------------------------------------
;
; Ancient WinOldAp hook.
;
;------------------------------------------------------------------
        public  EnableKernel

EnableKernel    Label   Byte
if kdebug
        krDebugOut DEB_WARN, "Don't call EnableKernel"
endif
        retf


;-----------------------------------------------------------------------;
; DisableKernel                                                         ;
;                                                                       ;
; This call is provided as a Kernel service to applications that        ;
; wish to totally unhook Windows in order to do something radical       ;
; such as save the state of the world and restore it at a later         ;
; time.  This is similar in many ways to the way OLDAPP support         ;
; works, with the addition that it also unhooks the kernel.             ;
;                                                                       ;
; Arguments:                                                            ;
;                                                                       ;
; Returns:                                                              ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       DI,SI,DS                                                        ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;                                                                       ;
; Calls:                                                                ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Sat May 09, 1987 02:34:35p  -by-  David N. Weise    [davidw]         ;
; Merged changes in.  Most of this came from ExitKernel.                ;
;                                                                       ;
;  Tue Apr 28, 1987 11:12:00a  -by-  R.E.O. SpeedWagon [-????-]         ;
; Changed to indirect thru PDB to get JFN under DOS 3.x.                ;
;                                                                       ;
;  Mon Apr 20, 1987 11:34:00p  -by-  R.E.O. SpeedWagon [-????-]         ;
; Set PDB to topPDB before final int 21/4C; we were sometimes exiting   ;
; with a task's PDB, and thus we came back to ExitCall2 instead of      ;
; going back to DOS!                                                    ;
;-----------------------------------------------------------------------;

        assumes ds, nothing
        assumes es, nothing

cProc   DisableKernel,<PUBLIC,FAR>,<si,di>
cBegin

        SetKernelDS
        or      Kernel_flags[2],KF2_WIN_EXIT    ; prevent int 24h dialogs
        cmp     prevInt21Proc.sel,0
        je      nodisable
        call    InternalDisableDOS
nodisable:

        SetKernelDS
        mov     ax,0203h                ; Reset not present fault.
        mov     bl,0Bh
        mov     cx,prevInt3Fproc.sel
        mov     dx,prevInt3Fproc.off
        int     31h

        mov     ax,0203h                ; Reset stack fault.
        mov     bl,0Ch
        mov     cx,prevInt0Cproc.sel
        mov     dx,prevInt0Cproc.off
        int     31h

        mov     ax,0203h                ; Reset GP fault.
        mov     bl,0Dh
        mov     cx,prevInt0Dproc.sel
        mov     dx,prevInt0Dproc.off
        int     31h

        mov     ax,0203h                ; Reset invalid op-code exception.
        mov     bl,06h
        mov     cx,prevIntx6proc.sel
        mov     dx,prevIntx6proc.off
        int     31h

        mov     ax,0203h                ; Reset page fault.
        mov     bl,0Eh
        mov     cx,prevInt0Eproc.sel
        mov     dx,prevInt0Eproc.off
        int     31h

ifdef WOW
        mov     ax,0203h                ; Reset divide overflow traps
        mov     bl,00h
        mov     cx,oldInt00proc.sel
        mov     dx,oldInt00proc.off
        int     31h

        mov     ax,0203h                ; Reset single step traps
        mov     bl,01h
        mov     cx,prevInt01proc.sel
        mov     dx,prevInt01proc.off
        int     31h

        mov     ax,0203h                ; Reset breakpoint traps
        mov     bl,03h
        mov     cx,prevInt03proc.sel
        mov     dx,prevInt03proc.off
        int     31h
endif

        mov     dx, [HeadPDB]
        SetKernelDS     es
        UnSetKernelDS
exk1:
        mov     ds,dx
        cmp     dx, [topPDB]            ; Skip KERNEL, he is about to get
        je      exk3                    ; a 4C stuffed down his throat

        push    ds
        call    TerminatePDB
        pop     ds

exk3:
        mov     dx,ds:[PDB_Chain]       ; move to next PDB in chain
        or      dx,dx
        jnz     exk1

        mov     bx,[topPDB]             ; set to initial DOS task PDB
        mov     ah,50h                  ; set PDB function
        int     21h
        and     Kernel_flags[2],NOT KF2_WIN_EXIT        ; prevent int 24h dialogs
;
; Close all files on Kernel's PSP, 'cause we're gonna shrink the SFT and
; quit ourselves afterwards.
;
        mov     ds,[topPDB]
        mov     cx,ds:[PDB_JFN_Length]
exk4:   mov     bx,cx                   ; close all file handles
        dec     bx
        cmp     bx,5                    ; console-related handle?
        jb      exk5                    ; yup, don't close it (AUX, etc.)
        mov     ah,3eh
        int     21h
exk5:   loop    exk4

; kernel could have added some nodes to the SFT. Delink them by removing
; the link from the last DOS link in the chain. We need to remember the 
; current pointer there so that InternalEnableDOS can put it back.

        lds     bx,[pSftLink]           ;place where we hooked new entry
        assumes ds,nothing
        mov     cx,ds                   ;this could have been unitialized too
        jcxz    exk6                    ;if unitialized, nothing to do
        mov     dx,ds:[bx].off          ;get the current offset
        mov     cx,ds:[bx].sel          ;get the current segment
        mov     ds:[bx].off,-1          ;remove windows SFT link
        mov     ds:[bx].sel, 0          ;remove windows SFT link
        mov     lpWinSftLink.off,dx     ;save the offset
        mov     lpWinSftLink.sel,cx     ;save the segment
exk6:

        UnSetKernelDS   es
cEnd

;------------------------------------------------------------------
;
; ExitKernel -- Bye, bye.
;
;------------------------------------------------------------------
ifndef WOW  ; If we are closing down WOW then we don't want to go back to the DOS Prompt
            ; We want to kill the NTVDM WOW Process - so we don't need/want this code.

        assumes ds, nothing
        assumes es, nothing

cProc   ExitKernel,<PUBLIC,FAR>
;       parmW   exitcode
cBegin  nogen
        SetKernelDS
        or      Kernel_flags[2],KF2_WIN_EXIT    ; prevent int 24h dialogs
        call    KillLibraries           ; Tell DLLs that the system is exiting

        mov     si,sp
        mov     si,ss:[si+4]            ; get exit code

; Call driver termination procs, just to make sure that they have removed
; their interrupt vectors.

        push    si
        mov     ax,word ptr [pMouseTermProc]
        or      ax,word ptr [pMouseTermProc+2]
        jz      trm0
        call    [pMouseTermProc]
        CheckKernelDS
trm0:   mov     ax,word ptr [pKeyboardTermProc]
        or      ax,word ptr [pKeyboardTermProc+2]
        jz      trm1
        call    [pKeyboardTermProc]
        CheckKernelDS
trm1:   mov     ax,word ptr [pSystemTermProc]
        or      ax,word ptr [pSystemTermProc+2]
        jz      trm2
        call    [pSystemTermProc]
        CheckKernelDS
trm2:   pop     si

        call    WriteOutProfiles
        mov     fProfileMaybeStale,1             ; Make sure we check the
                                                ;  INI file next time around
;;;     cCall   CloseCachedFiles,<topPDB>

; Close open files and unhook kernel hooks

; get on a stack that's not in EMS land

        call    Enter_gmove_stack

        cCall   DisableKernel
        CheckKernelDS

        cmp     si,EW_REBOOTSYSTEM      ; Reboot windows?
        jnz     exitToDos

ifndef WOW
        mov     ax,1600h
        int     2Fh
        test    al,7Fh
        jz      NotRunningEnhancedMode
        cmp     al,1
        je      exitToDos               ;RunningWindows3862x
        cmp     al,-1
        je      exitToDos               ;RunningWindows3862x
        xor     di,di                   ; Zero return regs
        mov     es,di
        mov     bx,0009h                ; Reboot device ID
        mov     ax,1684h                ; Get device API entry point
        int     2Fh
        mov     ax,es
        or      ax,di
        jz      exitToDos               ; Reboot vxd not loaded. Exit to dos

        ; Call the reboot function
        mov     ax,0100h
        push    es
        push    di
        mov     bx,sp
        call    DWORD PTR ss:[bx]

        jmp     short exitToDos         ; Reboot didn't work just exit to dos

NotRunningEnhancedMode:
endif ; WOW

        mov     ah, 0Dh                 ; Disk Reset so that Smartdrv etc buffers
        int     21h                     ; are written to disk

        mov     ax, 0FE03h              ; Flush Norton NCache
        mov     si, "CF"
        mov     di, "NU"
        stc                             ; Yes!  Really set carry too!
        int     2Fh

        int     19h                     ; Reboot via int 19h


exitToDos:
        mov     ax,si
        mov     ah,4Ch                  ; Leave Windows.
        int     21h
cEnd    nogen

endif   ; NOT WOW

sEnd    CODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\fixexe.c ===
/***	FIXEXE.C
 *
 *	Copyright (c) 1991 Microsoft Corporation
 *
 *	DESCRIPTION
 *	Patches specified .EXE file as required to load Windows KERNEL.EXE
 *	Removes requirement for LINK4 from Build
 *	It also produces same effect as EXEMOD file /MAX 0
 *
 *	Set DOS .EXE size to size of file +512
 *	Set MAX alloc to Zero
 *
 *
 *	MODIFICATION HISTORY
 *	03/18/91    Matt Felton
 */

#define TRUE 1

#include <stdio.h>


main(argc, argv)
int argc;
char **argv;
{
    FILE *hFile;
    long lFilesize;
    int iLengthMod512;
    int iSizeInPages;
    int iZero;

    iZero= 0;

    if (argc == 1)
	fprintf(stderr, "Usage: fixexe [file]\n");

    while (++argv,--argc) {
	hFile = fopen(*argv, "rb+");
	if (!hFile) {
	    fprintf(stderr, "cannot open %s\n", *argv);
	    continue;
	}
	printf("Processing %s\n", *argv);

	/* calculate the .EXE file size in bytes */

	fseek(hFile, 0L, SEEK_END);
	lFilesize = ftell(hFile);
	iSizeInPages = (lFilesize + 511) / 512;
	iLengthMod512 = lFilesize % 512;

	printf("Filesize is %lu bytes, %i pages, %i mod\n",lFilesize,iSizeInPages,iLengthMod512);

	/* set DOS EXE File size to size of file + 512 */
	fseek(hFile, 2L, SEEK_SET);
	fwrite( &iLengthMod512, sizeof(iLengthMod512), 1, hFile );
	fwrite( &iSizeInPages, sizeof(iSizeInPages), 1, hFile );

	/* Now perform EXEMOD file /MAX 0 equivalent */
	fseek(hFile, 12L, SEEK_SET);
	fwrite( &iZero, sizeof(iZero), 1, hFile);

	fclose(hFile);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\error.c ===
#include "kernel.h"

#define WINAPI _far _pascal _loadds
typedef unsigned int UINT;
typedef const char _far* LPCSTR;
typedef HANDLE HTASK;

#include "logerror.h"

int  WINAPI FatalExitC(WORD);
void WINAPI OutputDebugString(LPCSTR);

void DebugLogParamError(VOID FAR* param, FARPROC lpfn, WORD err);
void DebugLogError(WORD err, VOID FAR* lpInfo);
int  WINAPI GetOwnerName(WORD sel, char far *buf, WORD buflen);
int  WINAPI FarGetOwner(WORD sel);

#define CODESEG             _based(_segname("_CODE"))

#define SELECTOROF(lp)	    HIWORD(lp)
#define OFFSETOF(lp)        LOWORD((DWORD)lp)
#define MAKELONG(a, b)	    ((LONG)(((WORD)(a)) | ((DWORD)((WORD)(b))) << 16))
#define MAKELP(sel, off)    ((VOID FAR *)MAKELONG(off, sel))

#if KDEBUG

UINT DebugOptions = 0;
UINT DebugFilter = 0;

#define FMT_WORD    0
#define FMT_DWORD   1
#define FMT_LP      2

struct TYPEMAP
{
    UINT err;
    char CODESEG* szType;       // Compiler bug: this can't be _based
    char CODESEG* szFmt;
};

static char CODESEG szParam[] = "parameter";
static char CODESEG szD16[] = "%s: Invalid %s: %d\r\n";
static char CODESEG szD32[] = "%s: Invalid %s: %ld\r\n";
static char CODESEG szX16[] = "%s: Invalid %s: %#04x\r\n";
static char CODESEG szX32[] = "%s: Invalid %s: %#08lx\r\n";
static char CODESEG szLP[]  = "%s: Invalid %s: %#04x:%#04x\r\n";

static char CODESEG sz_value[] = "value";
static char CODESEG sz_index[] = "index";
static char CODESEG sz_flags[] = "flags";
static char CODESEG sz_selector[] = "selector";
static char CODESEG sz_pointer[] = "pointer";
static char CODESEG sz_function_pointer [] = "function pointer";
static char CODESEG sz_string_pointer [] = "string pointer";
static char CODESEG sz_HINSTANCE[] = "HINSTANCE";
static char CODESEG sz_HMODULE[] = "HMODULE";
static char CODESEG sz_global_handle [] = "global handle";
static char CODESEG sz_local_handle [] = "local handle";
static char CODESEG sz_atom[] = "atom";
static char CODESEG sz_HWND[] = "HWND";
static char CODESEG sz_HMENU[] = "HMENU";
static char CODESEG sz_HCURSOR[] = "HCURSOR";
static char CODESEG sz_HICON[] = "HICON";
static char CODESEG sz_HGDIOBJ[] = "HGDIOBJ";
static char CODESEG sz_HDC[] = "HDC";
static char CODESEG sz_HPEN[] = "HPEN";
static char CODESEG sz_HFONT[] = "HFONT";
static char CODESEG sz_HBRUSH[] = "HBRUSH";
static char CODESEG sz_HBITMAP[] = "HBITMAP";
static char CODESEG sz_HRGN[] = "HRGN";
static char CODESEG sz_HPALETTE[] = "HPALETTE";
static char CODESEG sz_HANDLE[] = "HANDLE";
static char CODESEG sz_HFILE[] = "HFILE";
static char CODESEG sz_HMETAFILE[] = "HMETAFILE";
static char CODESEG sz_CID[] = "CID";
static char CODESEG sz_HDRVR[] = "HDRVR";
static char CODESEG sz_HDWP[] = "HDWP";

static char CODESEG*pszLP = szLP;
static char CODESEG*pszD32 = szD32;
static char CODESEG*pszX32 = szX32;

#define DEFMAP(err, type, fmt) \
    { err, type, fmt }
struct TYPEMAP CODESEG typemap[] =
{
    DEFMAP(ERR_BAD_VALUE,        sz_value,        szD16),
    DEFMAP(ERR_BAD_INDEX,        sz_index,        szD16),
    DEFMAP(ERR_BAD_FLAGS,        sz_flags,        szX16),
    DEFMAP(ERR_BAD_SELECTOR,     sz_selector,     szX16),
    DEFMAP(ERR_BAD_DFLAGS,       sz_flags,        szX32),
    DEFMAP(ERR_BAD_DVALUE,       sz_value,        szD32),
    DEFMAP(ERR_BAD_DINDEX,       sz_index,        szD32),
    DEFMAP(ERR_BAD_PTR,          sz_pointer,      szLP),
    DEFMAP(ERR_BAD_FUNC_PTR,     sz_function_pointer, szLP),
    DEFMAP(ERR_BAD_STRING_PTR,   sz_string_pointer, szLP),
    DEFMAP(ERR_BAD_HINSTANCE,    sz_HINSTANCE,    szX16),
    DEFMAP(ERR_BAD_HMODULE,      sz_HMODULE,      szX16),
    DEFMAP(ERR_BAD_GLOBAL_HANDLE,sz_global_handle, szX16),
    DEFMAP(ERR_BAD_LOCAL_HANDLE, sz_local_handle, szX16),
    DEFMAP(ERR_BAD_ATOM,         sz_atom,         szX16),
    DEFMAP(ERR_BAD_HWND,         sz_HWND,         szX16),
    DEFMAP(ERR_BAD_HMENU,        sz_HMENU,        szX16),
    DEFMAP(ERR_BAD_HCURSOR,      sz_HCURSOR,      szX16),
    DEFMAP(ERR_BAD_HICON,        sz_HICON,        szX16),
    DEFMAP(ERR_BAD_GDI_OBJECT,   sz_HGDIOBJ,      szX16),
    DEFMAP(ERR_BAD_HDC,          sz_HDC,          szX16),
    DEFMAP(ERR_BAD_HPEN,         sz_HPEN,         szX16),
    DEFMAP(ERR_BAD_HFONT,        sz_HFONT,        szX16),
    DEFMAP(ERR_BAD_HBRUSH,       sz_HBRUSH,       szX16),
    DEFMAP(ERR_BAD_HBITMAP,      sz_HBITMAP,      szX16),
    DEFMAP(ERR_BAD_HRGN,         sz_HRGN,         szX16),
    DEFMAP(ERR_BAD_HPALETTE,     sz_HPALETTE,     szX16),
    DEFMAP(ERR_BAD_HANDLE,       sz_HANDLE,       szX16),
    DEFMAP(ERR_BAD_HFILE,        sz_HFILE,        szX16),
    DEFMAP(ERR_BAD_HMETAFILE,    sz_HMETAFILE,    szX16),
    DEFMAP(ERR_BAD_CID,          sz_CID,          szX16),
    DEFMAP(ERR_BAD_HDRVR,        sz_HDRVR,        szX16),
    DEFMAP(ERR_BAD_HDWP,         sz_HDWP,         szX16)
};

int (_cdecl _far *wsprintf)(LPSTR, LPCSTR, ...) = NULL;
int (WINAPI *wvsprintf)(LPSTR lpszOut, LPCSTR lpszFmt, const void FAR* lpParams) = NULL;

#define ORD_WSPRINTF	420
#define ORD_WVSPRINTF   421

BOOL _fastcall LoadWsprintf(void)
{
    static char CODESEG rgchUSER[] = "USER";

    HANDLE hmod;

    hmod = GetModuleHandle(rgchUSER);

    if (!hmod)
	return FALSE;

    (FARPROC)wsprintf = GetProcAddress(hmod, MAKELP(NULL, ORD_WSPRINTF));
    (FARPROC)wvsprintf = GetProcAddress(hmod, MAKELP(NULL, ORD_WVSPRINTF));

    if (!SELECTOROF(wsprintf))
    {
        static char CODESEG rgch[] = "KERNEL: Can't call wsprintf: USER not initialized\r\n";
        OutputDebugString(rgch);
        return FALSE;
    }
    return TRUE;
}

typedef struct
{
    UINT flags;
    LPCSTR lpszFmt;
    WORD args[1];
} DOPARAMS;

#define BUFFERSLOP  32

BOOL DebugOutput2(DOPARAMS FAR* pparams)
{
    UINT flags = pparams->flags;
    BOOL fBreak = FALSE;
    BOOL fPrint = TRUE;
    char rgch[80*2 + BUFFERSLOP];    // max 2 lines (don't want to hog too much stack space)
    static char CODESEG szCRLF[] = "\r\n";
    char far *prefix, far *prefix1;

    switch (flags & DBF_SEVMASK)
    {
    case DBF_TRACE:
	// If the flags don't match the debug filter,
	// don't print the trace message.
	// If the trace matches the filter, check for TRACEBREAK.
	//
	prefix = "t ";
	if (!((flags & DBF_FILTERMASK) & DebugFilter))
	    fPrint = FALSE;
	else if (DebugOptions & DBO_TRACEBREAK)
	    fBreak = TRUE;
	break;

    case DBF_WARNING:
	prefix = "wn ";
	if (DebugOptions & DBO_WARNINGBREAK)
	    fBreak = TRUE;
	break;

    case DBF_ERROR:
	prefix = "err ";
	if (!(DebugOptions & DBO_NOERRORBREAK))
	    fBreak = TRUE;
	break;

    case DBF_FATAL:
	prefix = "fatl ";
	if (!(DebugOptions & DBO_NOFATALBREAK))
	    fBreak = TRUE;
	break;
    }

    // If DBO_SILENT is specified, don't print anything.
    //
    if (DebugOptions & DBO_SILENT)
	fPrint = FALSE;

    if ((lstrlen((LPSTR)pparams->lpszFmt) <= sizeof(rgch) - BUFFERSLOP) &&
            (SELECTOROF(wsprintf) || LoadWsprintf()) && (fPrint || fBreak))
    {
	int hinst = HIWORD(pparams);

	for (prefix1 = rgch; *prefix; ) *prefix1++ = *prefix++;
	prefix1 += GetOwnerName(hinst, prefix1, 16);
	*prefix1++ = ' ';
	wvsprintf(prefix1, pparams->lpszFmt, (void FAR*)pparams->args);
	OutputDebugString(rgch);
	OutputDebugString(szCRLF);
    }

    if (fBreak)
    {
        // If we are supposed to break with an int 3, then return TRUE.
        //
        if (DebugOptions & DBO_INT3BREAK)
            return TRUE;

        return FatalExitC(flags);
    }
    return FALSE;
}

BOOL LogParamError2(WORD err, FARPROC lpfn, VOID FAR* param, WORD caller)
{
    BOOL fBreak;

    fBreak = FALSE;
    if (err & ERR_WARNING)
    {
	if (DebugOptions & DBO_WARNINGBREAK)
	    fBreak = TRUE;
    }
    else
    {
	if (!(DebugOptions & DBO_NOERRORBREAK))
	    fBreak = TRUE;
    }

    // If we're not breaking and SILENT is specified, just return.
    //
    if (!fBreak && (DebugOptions & DBO_SILENT))
        return FALSE;

    if (SELECTOROF(wsprintf) || LoadWsprintf())
    {
	char rgch[128];
	char rgchProcName[50], far *rpn;
	char CODESEG* pszType;          // compiler bug: see above
	char CODESEG* pszFmt;
	int i, hinst;
	WORD errT;
	void FAR GetProcName(FARPROC lpfn, LPSTR lpch, int cch);
	char far *prefix1;

	GetProcName(lpfn, rgchProcName, sizeof(rgchProcName));
	  /* if we got a real proc name, then copy just the proc name */
	for (rpn = rgchProcName; *rpn && (*rpn != '(') && (*rpn != ':'); rpn++)
	  ;
	if (*rpn == ':') {
	  lstrcpy(rgchProcName, rpn+1);
	}

	pszFmt  = szX32;
	pszType = szParam;
	errT = (err & ~ERR_WARNING);
	for (i = 0; i < (sizeof(typemap) / sizeof(struct TYPEMAP)); i++)
	{
	    if (typemap[i].err == errT)
	    {
		pszFmt = typemap[i].szFmt;
		pszType = typemap[i].szType;
		break;
	    }
	}
        if (err & ERR_WARNING) {
	  lstrcpy(rgch, "wn ");
	  prefix1 = rgch+3;
	} else {
	  lstrcpy(rgch, "err ");
	  prefix1 = rgch+4;
	}
	hinst = HIWORD(prefix1);
	prefix1 += GetOwnerName(hinst, prefix1, 16);
	if (FarGetOwner(hinst) != FarGetOwner(caller)) {
	    *prefix1++ = '-';
	    *prefix1++ = '>';
	    prefix1 += GetOwnerName(caller, prefix1, 16);
	}
	*prefix1++ = ' ';

	if (pszFmt == pszLP)
	    wsprintf(prefix1, pszFmt, (LPSTR)rgchProcName, (LPSTR)pszType, SELECTOROF(param), OFFSETOF(param));
	else if (pszFmt == pszD32 || pszFmt == pszX32)
	    wsprintf(prefix1, pszFmt, (LPSTR)rgchProcName, (LPSTR)pszType, (DWORD)param);
	else
	    wsprintf(prefix1, pszFmt, (LPSTR)rgchProcName, (LPSTR)pszType, (WORD)(DWORD)param);

	OutputDebugString(rgch);
    }

    if (fBreak)
    {
        // If we are supposed to break with an int 3, then return TRUE.
        //
        if (DebugOptions & DBO_INT3BREAK)
            return TRUE;

        return FatalExitC(err);
    }
    return FALSE;
}

extern HTASK allocTask;
extern DWORD allocCount;
extern DWORD allocBreak;
extern char  allocModName[8];

void FAR _loadds SetupAllocBreak(HTASK htask);
char far* GetTaskModNamePtr(HTASK htask);

BOOL WINAPI IGetWinDebugInfo(WINDEBUGINFO FAR* lpwdi, UINT flags)
{
    int i;

    lpwdi->flags = flags;

    if (flags & WDI_OPTIONS)
        lpwdi->dwOptions = DebugOptions;

    if (flags & WDI_FILTER)
        lpwdi->dwFilter = DebugFilter;

    if (flags & WDI_ALLOCBREAK)
    {
        lpwdi->dwAllocBreak = allocBreak;
        lpwdi->dwAllocCount = allocCount;
        for (i = 0; i < 8; i++)
            lpwdi->achAllocModule[i] = allocModName[i];
    }
    return TRUE;
}

BOOL WINAPI ISetWinDebugInfo(const WINDEBUGINFO FAR* lpwdi)
{
    int i;

    if (lpwdi->flags & WDI_OPTIONS)
        DebugOptions = (UINT)lpwdi->dwOptions;

    if (lpwdi->flags & WDI_FILTER)
        DebugFilter = (UINT)lpwdi->dwFilter;

    if (lpwdi->flags & WDI_ALLOCBREAK)
    {
        allocTask = NULL;
        allocBreak = lpwdi->dwAllocBreak;
        allocCount = 0;     // Always reset count to 0.

        for (i = 0; i < 8; i++)
            allocModName[i] = lpwdi->achAllocModule[i];

        {
            extern HTASK headTDB;
            HTASK htask;

            // Enumerate all current tasks to see if any match
            //
            #define TDB_next    0
            for (htask = headTDB; htask; htask = *((HTASK FAR*)MAKELP(htask, TDB_next)))
                SetupAllocBreak(htask);
        }
    }
    return TRUE;
}

void FAR _loadds SetupAllocBreak(HTASK htask)
{
    int i;
    char far* pchAlloc;
    char far* pchTask;

    // If alloc break task already set up, exit.
    //
    if (allocTask)
        return;

    // If no alloc break in effect, nothing to do.
    //
    if (allocModName[0] == 0)
        return;

    pchAlloc = allocModName;
    pchTask = GetTaskModNamePtr(htask);

    for (i = 8; --i != 0; pchAlloc++, pchTask++)
    {
        char ch1 = *pchAlloc;
        char ch2 = *pchTask;

        if (ch1 >= 'a' && ch1 <= 'z')
            ch1 -= ('a' - 'A');

        if (ch2 >= 'a' && ch2 <= 'z')
            ch2 -= ('a' - 'A');

        if (ch1 != ch2)
            return;

        if (ch1 == 0 || ch2 == 0)
            break;
    }

    // Set the alloc break task, and init the count to 0.
    //
    allocTask = htask;
    allocCount = 0;
}

#else   // !KDEBUG

BOOL WINAPI GetWinDebugInfo(WINDEBUGINFO FAR* lpwdi, UINT flags)
{
    return FALSE;
}

BOOL WINAPI SetWinDebugInfo(const WINDEBUGINFO FAR* lpwdi)
{
    return FALSE;
}

#endif  // !KDEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\gpfix.asm ===
; gpfix.asm - pointer validation routines

	include gpfix.inc
	include kernel.inc
	include tdb.inc
	include newexe.inc


sBegin  GPFIX0
__GP	label	word
;gpbeg   dw	0, 0, 0, 0	; for use in handler
public __GP
sEnd    GPFIX0

sBegin  GPFIX1
gpend	dw	0
sEnd    GPFIX1

sBegin DATA
;this segment is page locked and will be accessible during a GP fault
;has the names of modules that are allowed to use our funky GP fault handling
; mechanism. Format: length byte, module name. The table is zero-terminated.
gp_valid_modules label	byte
db	3, "GDI"
db	4, "USER"
db	6, "KERNEL"
db	6, "PENWIN"
db	7, "DISPLAY"
db	8, "MMSYSTEM"
db	0	;end of table
sEnd   DATA

ifdef DISABLE
sBegin	DATA
;ExternW wErrorOpts
sEnd	DATA
endif


;public  gpbeg, gpend


sBegin  CODE
assumes CS,CODE

externA __AHINCR

externNP GetOwner
externNP EntProcAddress
externFP GetExePtr
externFP SetSelectorLimit

;===============================================================
;
;
cProc   IsBadReadPtr,<PUBLIC,FAR,NONWIN>
ParmD	lp
ParmW	cb
cBegin
beg_fault_trap  BadRead1
	les	bx,lp		; check selector
	mov	cx,cb
	jcxz	ReadDone1
	dec	cx
	add	bx,cx
	jc      BadRead		; check 16 bit overflow
	mov	al,es:[bx]	; check read permission, limit
end_fault_trap
ReadDone1:
        xor     ax,ax
ReadDone:
cEnd

BadRead1:
	fault_fix_stack
BadRead:
        mov     ax,1
	jmp	short ReadDone

;===============================================================
;
;
cProc   IsBadWritePtr,<PUBLIC,FAR,NONWIN>
ParmD	lp
ParmW	cb
cBegin
beg_fault_trap  BadWrite1
	les	bx,lp		; check selector
	mov	cx,cb
	jcxz	WriteDone1
	dec	cx
	add	bx,cx
	jc      BadWrite	; check 16 bit overflow
	or	es:byte ptr [bx],0 ; check write permission, limit
end_fault_trap
WriteDone1:
	xor     ax, ax
WriteDone:
cEnd

BadWrite1:
	fault_fix_stack
BadWrite:
	mov	ax,1
	jmp	short WriteDone

;===============================================================
; BOOL IsBadFlatReadWritePtr(VOID HUGE*lp, DWORD cb, WORD fWrite)
; This will validate a Flat pointer plus a special hack for Fox Pro
; to detect their poorly tiled selector (ie. all n selector with 
; limit of 64K) (Our tiling is such that you can access up to end of
; the block using any one of the intermediate selectors flat)
; if we detect such a case we will fix up the limit on the first sel
; so GDI can access all of the memory as a 1st_sel:32-bit offset

cProc	IsBadFlatReadWritePtr,<PUBLIC,FAR,NONWIN>
ParmD	lp
ParmD	cb
ParmW	fWrite
cBegin
beg_fault_trap  frp_trap
	les	bx,lp		; check selector
	.386p

	mov	eax,cb
	movzx	ebx, bx

	test	eax,eax		; cb == 0, all done.
	jz	frp_ok

	add	ebx,eax
	dec	ebx

	cmp	fWrite, 0
	jne	frp_write

	mov	al,es:[ebx]		; read last byte
	jmp	frp_ok

frp_write:
	or	byte ptr es:[ebx], 0	; write last byte

frp_ok:
	xor	ax,ax
end_fault_trap
frp_exit:
cEnd

frp_trap:
	fault_fix_stack
frp_bad:
	push	ebx
	mov	ecx, ebx			; get cb
	shr	ecx, 16				; get high word
	jecxz	frp_bade			; if < 64K then bad ptr

	mov	ax, es
	lsl	eax, eax			; get limit on 1st sel
	jnz	frp_bade			; bad sel?
	cmp	ax, 0ffffh			; 1st of poorly tiled sels?
	jne	frp_bade			; N: return bad ptr
	; now we have to confirm that this is indeed the first of a bunch
	; of poorly tiled sels and fix up the limit correctly of the first sel

	movzx	ebx, ax				; ebx = lim total of tiled sels
	inc	ebx				; make it 10000
	mov	dx, es

frp_loop:

	add	dx,__AHINCR			; next sel in array
	lsl	eax, edx
	jnz	frp_bade
	cmp	ecx, 1				; last sel?
	je	@f
	; if its not the last sel, then its limit has to be ffffh
	; otherwise it probably is not a poorly tiled sel.
	cmp	eax, 0ffffh
	jne	frp_bade
@@:
	add	ebx, eax			; upd total limit
	inc	ebx				; add 1 for middle sels

	loop	frp_loop
	dec	ebx				; take exact limit of last sel

	pop	edx				; get cb
	cmp	edx, ebx
	jg	frp_bade_cleaned

	; set limit of 1st sel to be ebx
	push	es
	push	ebx
	call	SetSelectorLimit

if KDEBUG
	mov	ax, es
	krDebugOut DEB_WARN, "Fixing poorly tiled selector #AX for flat access"
endif

	jmp	frp_ok


frp_bade:
	pop	ebx
frp_bade_cleaned:

	.286p
	mov	ax,1
	jmp	frp_exit

;===============================================================
; BOOL IsBadHugeReadPtr(VOID HUGE*lp, DWORD cb)
;
cProc   IsBadHugeReadPtr,<PUBLIC,FAR,NONWIN>
ParmD	lp
ParmD   cb
cBegin
beg_fault_trap  hrp_trap
	les	bx,lp		; check selector

        mov     ax,off_cb
        mov     cx,seg_cb

        mov     dx,ax           ; if cb == 0, then all done.
        or      dx,cx
        jz      hrp_ok

        sub     ax,1            ; decrement the count
        sbb     cx,0

        add     bx,ax           ; adjust cx:bx by pointer offset
	adc     cx,0
	jc      hrp_bad 	; (bug #10446, pass in -1L as count)

	jcxz    hrplast         ; deal with leftover
hrploop:
        mov     al,es:[0ffffh]  ; touch complete segments.
        mov     dx,es
        add     dx,__AHINCR
        mov     es,dx
        loop    hrploop
hrplast:
        mov     al,es:[bx]
hrp_ok:
        xor     ax,ax
end_fault_trap
hrp_exit:
cEnd

hrp_trap:
	fault_fix_stack
hrp_bad:
	mov     ax,1
        jmp     hrp_exit

;===============================================================
; BOOL IsBadHugeWritePtr(VOID HUGE*lp, DWORD cb)
;
cProc   IsBadHugeWritePtr,<PUBLIC,FAR,NONWIN>
ParmD	lp
ParmD   cb
cBegin
beg_fault_trap  hwp_trap
	les	bx,lp		; check selector

        mov     ax,off_cb
        mov     cx,seg_cb

        mov     dx,ax           ; if cb == 0, then all done.
        or      dx,cx
        jz      hwp_ok

	sub     ax,1            ; decrement the count
	sbb     cx,0

	add     bx,ax           ; adjust cx:bx by pointer offset
	adc     cx,0
	jc      hwp_bad 	; (bug #10446, pass in -1L as count)

	jcxz    hwplast         ; deal with leftover
hwploop:
	or      byte ptr es:[0ffffh],0   ; touch complete segments.
	mov     dx,es
	add     dx,__AHINCR
	mov     es,dx
	loop    hwploop
hwplast:
	or      byte ptr es:[bx],0
hwp_ok:
	xor     ax,ax
end_fault_trap
hwp_exit:
cEnd

hwp_trap:
	fault_fix_stack
hwp_bad:
	mov     ax,1
        jmp     hwp_exit

;===============================================================
;
;
cProc	IsBadCodePtr,<PUBLIC,FAR,NONWIN>
ParmD	lpfn
cBegin
beg_fault_trap  BadCode1
	mov	cx,seg_lpfn
	lar	ax,cx
	jnz     BadCode		; Oh no, this isn't a selector!

	test	ah, 8
	jz	BadCode		; Oh no, this isn't code!

	mov	es,cx		; Validate the pointer
	mov	bx,off_lpfn
	mov	al,es:[bx]

end_fault_trap
	xor     ax, ax
CodeDone:
cEnd

BadCode1:
	fault_fix_stack
BadCode:
	mov	ax,1
	jmp	short CodeDone


;========================================================
;
; BOOL IsBadStringPtr(LPSTR lpsz, UINT cch);
;
cProc	IsBadStringPtr,<PUBLIC,FAR,NONWIN>,<DI>
ParmD   lpsz
ParmW   cchMax
cBegin
beg_fault_trap	BadStr1
	les	di,lpsz 	; Scan the string.
	xor	ax,ax
	mov	cx,-1
	cld
	repnz	scasb
end_fault_trap
        neg     cx              ; cx = string length + 1
        dec     cx
        cmp     cx,cchMax
        ja      BadStr          ; if string length > cchMax, then bad string.
bspexit:
cEnd

BadStr1:
	fault_fix_stack
BadStr:
        mov     ax,1
        jmp     bspexit

;-----------------------------------------------------------------------;
; HasGPHandler								;
; 									;
; See if GP fault handler is registered for faulting address.		;
;									;
; This scheme can only be used by registered modules. You register 	;
; a module by adding an entry containing a length byte followed by	;
; the module name in the gp_valid_modules table defined above.		;
; 									;
; Arguments:								;
;	parmD   lpFaultAdr						;
; 									;
; Returns:								;
;	AX = New IP of handler						;
;	AX = 0 if no handler registered					;
;									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
;	DI,SI,DS							;
;									;
; Registers Destroyed:							;
; 	AX,BX,CX,DX,ES							;
;									;
; Calls:								;
;	GetOwner							;
;	EntProcAddress							;
;									;
;	The __GP table has the format of 4 words per entry, plus a	;
;	zero word to terminate the table.  The 'seg' value should be	;
;	the actual selector (it must be fixed up by the linker),	;
;	and the offset values should be relative to the start of the	;
;	segment or group.  The handler must be in the same code segment	;
;	as the fault range (this ensures that the handler is present	;
;	at GP fault time).						;
;									;
;    __GP label word							;
;    public __GP							;
;	    seg, offset begin, offset end, handler      		;
;	    ... 							;
;	    0   							;
;       								;
;	The symbol '__GP' needs to be in the resident name table, so    ;
;	it should be added to the DEF file like this (with an   	;
;	appropriate ordinal value):     				;
;       								;
;	EXPORTS 							;
;	  __GP @??? RESIDENTNAME					;
;       								;
; 									;
; History:								;
;	?? Jun 91 Don Corbitt [donc] Wrote it				;
;	30 Jul 91 Don Corbitt [donc] Added support for __GP table	;
;-----------------------------------------------------------------------;


cProc	HasGPHandler,<PUBLIC,FAR,NONWIN>,<ds,si,di>
ParmD	lpfn
cBegin
	cCall	GetOwner, <SEG_lpfn>	; find owner of faulting code
	or	ax, ax
        jz      to_fail ;HH_fail

        lar     bx, ax                  ; make sure segment is present
	jnz	to_fail ;HH_fail
	test	bx, 8000h
	jz      to_fail ;HH_fail

        mov     es, ax
	cmp	es:[ne_magic], NEMAGIC
	jz	@f
to_fail:	
	jmp	HH_fail
@@:

	; check if the faulting module is allowed to use this scheme
	SetKernelDS
	mov	di, es:[ne_restab]
	mov	bx, di
	inc	bx		; save ptr to module name
	xor	cx,cx
	xor	ax,ax
	mov	si, offset gp_valid_modules
	mov	al, es:[di]
	cld
friend_or_fiend:
	mov	cl, [si]
	jcxz	HH_fail
	cmp	al,cl
	jnz	next_friend
	mov	di, bx		; need to keep restoring di
	inc	si		; skip len byte
	repe	cmpsb
	jz	we_know_this_chap
	dec	si		; point to the mismatch
next_friend:
	add	si, cx
	inc	si		
	jmp	short friend_or_fiend
we_know_this_chap:

	xor	cx, cx
	mov	si, es:[ne_restab]	; restore si
	jmp	short @F		; start in middle of code

HH_nextSym:
	add	si, cx			; skip name
	add	si, 3			; and entry point
@@:	mov	cl, es:[si]		; get length of symbol
	jcxz	HH_fail			; end of table - not found
	cmp	cl, 4			; name length
	jnz	HH_nextSym
	cmp	es:[si+1], '__'		; look for '__GP'
	jnz	HH_nextSym
	cmp	es:[si+3], 'PG'
	jnz	HH_nextSym
	mov	ax, es:[si+5]		; get ordinal for '__GP'
if	KDEBUG
        cCall   EntProcAddress,<es,ax,1>
else
	cCall	EntProcAddress,<es,ax>	; I hate conditional assembly....
endif
	mov	cx, ax
	or	cx, dx
	jz	HH_fail			; This shouldn't ever fail, but...

	lar	bx, dx			; make sure segment is present
	jnz	HH_fail
	test	bx, 8000h
	jz	HH_fail

	mov	ds, dx
	mov	si, ax
	mov	ax, SEG_lpfn
	mov	dx, OFF_lpfn
next_fault_val:
	mov	cx, [si]
	jcxz	HH_fail
	cmp	cx, ax			; does segment match?
	jnz	gp_mismatch
	cmp	[si+2], dx		; block start
	ja	gp_mismatch
	cmp	[si+4], dx		; block end
	jbe	gp_mismatch
	mov	ax, [si+6]		; get new IP
	jmp	short HH_done

gp_mismatch:
	add	si, 8
	jmp	short next_fault_val

HH_fail:
	xor	ax, ax
HH_done:
cEnd

;========================================================================
;
; BOOL IsSharedSelector(HGLOBAL h);
;
; Makes sure the given selector is shareable. Currently, we just check
; if it is owned by a DLL. We also need to check GMEM_SHARE bit but 
; this isn't saved...
;
cProc	IsSharedSelector,<PUBLIC,FAR,NOWIN>
ParmW   sharedsel
cBegin
	push	sharedsel
	call	GetExePtr
        or      ax,ax                   ; bogus handle: exit.
	jz	ISS_Done
	mov	es,ax
	xor	ax,ax
	test	es:[ne_flags],NENOTP
	jz	ISS_Done		; Not a DLL
	inc	ax			; Yup a DLL

ISS_Done:
cEnd

sEnd    CODE

	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\handle.asm ===
TITLE	HANDLE - Handle Table Manager



.xlist
include kernel.inc
.list

sBegin	CODE
assumes CS,CODE
;-----------------------------------------------------------------------;
; hthread 								;
; 									;
; Threads together a list of free handles.				;
;									;
; Arguments:								;
;	DI = start of chain						;
;	CX = #handle entries in chain					;
; 									;
; Returns:								;
;	AX = address of first handle entry on free list			;
;	CX = 0								;
;	DI = address of first word after handle block			;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Mon Oct 27, 1986 10:09:23a  -by-  David N. Weise   [davidw]		;
; Restructured as a result of separating handle.asm and lhandle.asm.	;
; 									;
;  Tue Oct 14, 1986 04:11:46p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.					;
;									;
;  Wed Jul  8, 1987 14:36      -by-  Rick  N. Zucker  [rickz]		;
; changed to hthread from ghthead to be used by local handle entries    ;
; 									;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

cProc	hthread,<PUBLIC,NEAR>
cBegin nogen
	push	di			; Save first free handle entry
	smov	es,ds
	cld
ht1:					; Chain entries together via he_link
	errnz	<he_link>
	errnz	<he_link - lhe_link>
	lea	ax,[di].SIZE HandleEntry
	stosw
	mov	ax,HE_FREEHANDLE
	errnz	<2 - he_flags>
	errnz	<he_flags - lhe_flags>
	stosw
	errnz	<4 - SIZE HandleEntry>
	errnz	<SIZE HandleEntry - SIZE LocalHandleEntry>
	loop	ht1
					; Null terminate free list
	mov	[di-SIZE HandleEntry].he_link,cx
	pop	ax			; Return free handle address
	ret
cEnd nogen

sEnd	CODE


end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\gpcont.asm ===
; GPCont.asm - code to allow continuation after GP faults

.xlist
include kernel.inc
include newexe.inc	; ne_restab
include gpcont.inc
.list

if SHERLOCK

FAULTSTACKFRAME struc

fsf_BP		dw	?	; Saved BP
fsf_msg		dw	?	; Near pointer to message describing fault
fsf_prev_IP	dw	?	; IP of previous fault handler
fsf_prev_CS	dw	?	; CS of previous fault handler
fsf_ret_IP	dw	?	; DPMI fault handler frame follows
fsf_ret_CS	dw	?
fsf_err_code	dw	?
fsf_faulting_IP dw	?
fsf_faulting_CS dw	?
fsf_flags	dw	?
fsf_SP		dw	?
fsf_SS		dw	?

FAULTSTACKFRAME ends

fsf_DS	equ	word ptr -10
fsf_ES	equ	word ptr -10
fsf_FS	equ	word ptr -10
fsf_GS	equ	word ptr -10

;flag bits set in gpRegs
strCX	=	1
strSI	=	2
strDI	=	4
segDS	=	8
segES	=	16
segFS	=	32
segGS	=	64


ifdef WOW
sBegin  MISCCODE

externFP DisAsm86

    assumes ds,nothing
    assumes es,nothing

;-----------------------------------------------------------------------;
; allows DisAsm86 to be called from _TEXT code segment
cProc Far_DisAsm86,<PUBLIC,FAR>,<dx>
    parmD   cp
cBegin
    mov     ax,cp.off
    mov     dx,cp.sel
    cCall   <far ptr DisAsm86>,<dx,ax>
cEnd

sEnd MISCCODE
endif ;; WOW



DataBegin
externB szGPCont
szKernel db	6,'KERNEL'
szUser	db	4,'USER'
szDrWatson db	'DRWATSON'


externW	gpTrying	; retrying current operation
externW gpEnable	; user has enabled GP continue
externW gpSafe		; current instruction is safe
externW gpInsLen	; length of faulting instruction
externW gpRegs		; bit field of modified regs
externD	pSErrProc	; pointer to SysErrBox in USER
DataEnd

externFP IsBadCodePtr
externFP FarFindExeInfo

sBegin	CODE
assumes	CS,CODE

ifndef WOW
externNP DisAsm86
endif
externNP GetOwner

;extern int far pascal SysErrorBox(char far *text, char far *caption,
;		int b1, int b2, int b3);
SEB_OK         = 1	; Button with "OK".
SEB_CANCEL     = 2	; Button with "Cancel"
SEB_YES        = 3	; Button with "&Yes"
SEB_NO         = 4	; Button with "&No"
SEB_RETRY      = 5	; Button with "&Retry"
SEB_ABORT      = 6	; Button with "&Abort"
SEB_IGNORE     = 7	; Button with "&Ignore"
SEB_CLOSE      = 8	; Button with "Close"
SEB_DEFBUTTON  = 8000h	; Mask to make this button default

SEB_BTN1       = 1	; Button 1 was selected
SEB_BTN2       = 2	; Button 1 was selected
SEB_BTN3       = 3	; Button 1 was selected

;Name:	int PrepareToParty(char *modName)
;Desc:	Checks whether we can continue the current app by skipping an
;	instruction.  If so, it performs the side effects of the
;	instruction.  This must be called after a call to DisAsm86() has
;	set the gpXxxx global vars.
;Bugs:	Should do more checking, should check for within a device driver,

cProc PrepareToParty,<PUBLIC,NEAR>,<si,di>
	parmD	modName
	parmD	appName
cBegin
	ReSetKernelDS

	mov	ax, [gpEnable]		; User enabled continue
	test	ax, 1			; We know how to continue
	jz	ptp_poop

	cld
	dec	[modName.off]		; include length byte in compare
	les	di, [modName]

	test	ax, 4			; can continue in KERNEL?
	jnz	@F
	lea	si, szKernel
	mov	cx, 7
	repe	cmpsb
	jz	ptp_poop		; fault in Kernel is fatal

@@:	test	ax, 8			; can continue in USER?
	jnz	@F
	mov	di, modName.off
	lea	si, szUser
	mov	cx, 5
	repe	cmpsb
	jz	ptp_poop		; fault in User is fatal

@@:	cmp     [gpTrying], 0
	jne	ptp_exit		; AX != 0 - do it again

	cmp	pSErrProc.sel, 0	; Is USER loaded?
	je	ptp_poop

	mov	ax, dataoffset szGPCont
	mov	bx, SEB_CLOSE or SEB_DEFBUTTON	; dumb cmacros
	cCall	[pSErrProc],<ds, ax, appName, bx, 0, SEB_IGNORE>
	cmp	ax, SEB_BTN3
	jne	ptp_poop
;	mov	[gpTrying], 100
	jmps	ptp_exit		; AX != 0

ptp_poop:				; every party needs a pooper
	xor	ax, ax
ptp_exit:
cEnd
	UnSetKernelDS


cProc	SafeDisAsm86,<NEAR,PUBLIC>
	parmD	cp
cBegin
	ReSetKernelDS
	mov	[gpSafe], 0		; assume unsafe

	mov	bx, cp.off		; make sure we can disassemble
	add	bx, 10			; at least a 10-byte instruction
	jc	sda_exit		; offset wrap-around - failed

	cCall	IsBadCodePtr,<seg_cp, bx>
	or	ax, ax
	jnz	sda_exit

ifdef WOW
	cCall	<far ptr Far_DisAsm86>,<cp>
else
	cCall	DisAsm86,<cp>
endif
	mov	[gpInsLen], ax
sda_exit:
cEnd


; return value in DX:AX and ES:AX (your choice), sets Z flag if failure
cProc	FindSegName,<NEAR,PUBLIC>,<ds>
	parmW	segval
cBegin
	cCall	GetOwner,<segval>
	mov	dx, ax
	or	ax, ax
	jz	fsn_exit
	mov	es, ax
	mov	ax, es:[ne_restab]
	inc	ax
fsn_exit:
cEnd

	public	GPContinue
GPContinue proc	near
	push	si			; instruction length
	test	[gpEnable], 1
	jz	s_fail

	cCall	SafeDisAsm86,<[bp].fsf_faulting_CS,[bp].fsf_faulting_IP>
	test	[gpSafe], 1
	jz	s_fail

	push	ds
	push	dataoffset szDrWatson
	push	8
	Call	FarFindExeInfo
	or	ax, ax
	jnz	s_fail

	cCall   FindSegName,<[bp].fsf_faulting_CS>
	jz	s_fail
	push	dx
	push	ax

	cCall	FindSegName,<[bp].fsf_SS>
	jz	s_fail4
	push	dx
	push	ax

	cCall   PrepareToParty
	or	ax, ax
	jz	s_fail

; Perform side-effects

	mov	ax, [gpRegs]		; Invalid value to DS?
	test	ax, segDS
	jz	@F
	mov	[bp].fsf_DS, 0

@@:	test	ax, segES               ; Invalid value to ES?
	jz	@F
	mov	[bp].fsf_ES, 0

	.386p
@@:	xor	bx, bx                  ; Invalid value to FS?
	test	ax, segFS
	jz	short @F
	mov	fs, bx

@@:	test	ax, segGS               ; Invalid value to GS?
	jz	short @F
	mov	gs, bx
	.286p
@@:
	test	ax, 0
; check other reg side effects
	mov	bx, [gpInsLen]		; Fixup IP for instruction length
	add	[bp].fsf_faulting_IP, bx
	mov	ax, 1
	jmps	s_end

s_fail4:
	add	sp, 4
s_fail:
	xor	ax, ax
s_end:
	pop	si
	ret
GPContinue endp

sEnd	CODE



endif		; SHERLOCK
	end

    regs.ip += faultlen;		/* set at top of func - don't reuse
    if ((int)gpStack < 0) {
      for (i=0; i<8; i++) stack[i+gpStack] = stack[i];
    } else if (gpStack) {
      for (i=7; i>=0; i--) stack[i+gpStack] = stack[i];
    }
    regs.sp += gpStack << 1;
    if (gpRegs & strCX) {
      len = regs.cx * memSize;
      regs.cx = 0;
    } else len = memSize;
    if (gpRegs & strSI) {		/* doesn't handle 32 bit regs
      regs.si += len;
      if (regs.si < (word)len)		/* if overflow, set to big value
	regs.si = 0xfff0;		/* so global vars in heap don't get
    }					/* trashed when we continue
    if (gpRegs & strDI) {
      regs.di += len;
      if (regs.di < (word)len) regs.di = 0xfff0;
    }
  }

  return party;
} /* Sherlock
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\hmem.asm ===
title	HMem
;HMem.asm - huge memory functions HMemCpy, etc

include	gpfix.inc
include	kernel.inc

externFP Int21Handler

DataBegin
externW WinFlags
ifdef WOW
externD pFileTable
externW cur_dos_PDB
externW Win_PDB
endif
DataEnd

ifdef WOW
externFP WOWFileRead
externFP WOWFileWrite
endif

sBegin CODE
assumes cs,CODE

ifdef WOW
externD  prevInt21proc
endif


externA  __AHINCR


cProc	hMemCpy,<PUBLIC,FAR>,<ds, si, di>
	parmD	dest			; to ES:DI
	parmD	src			; to DS:SI
	parmD	cnt			; to DX:AX
	localW	flags
cBegin
	SetKernelDS
	mov	bx, WinFlags
	mov	flags, bx
	mov	dx, seg_cnt		; DX:AX is 32 bit length
	mov	ax, off_cnt
	xor	cx, cx			; 0 if fault loading operands
beg_fault_trap hmc_trap
	lds	si, src
	les	di, dest
	cld
hmc_loop:
	mov	cx, 8000h		; try to copy 32K

	cmp	cx, si			; space left in source?
	jae	@F
	mov	cx, si

@@:	cmp	cx, di			; space left in dest?
	jae	@F
	mov	cx, di

@@:     neg	cx			; convert bytes left to positive

	or	dx, dx			; >64K left to copy?
	jnz	@F

	cmp	cx, ax			; At least this much left?
	jbe	@F
	mov	cx, ax

@@:	sub	ax, cx			; Decrement count while we're here
	sbb	dx, 0

	test	flags, WF_CPU386 + WF_CPU486 + WF_ENHANCED
	jnz	hmc_do32

	shr	cx, 1			; Copy 32KB
	rep	movsw
	adc	cx, 0
	rep	movsb
	jmps	hmc_copied

hmc_do32:
	.386p
	push	cx
	shr	cx, 2
	rep	movsd
	pop	cx
	and	cx, 3
	rep	movsb
	.286p

hmc_copied:
	mov	cx, ax			; At end of copy?
	or	cx, dx
	jz	hmc_done

	or	si, si			; Source wrap-around?
	jnz	@F
	mov	bx, ds
	add	bx, __AHINCR
	mov	ds, bx

@@:	or	di, di			; Dest wrap-around?
	jnz	@F
	mov	bx, es
	add	bx, __AHINCR
	mov	es, bx
end_fault_trap
@@:     jmps	hmc_loop

hmc_trap:
	fault_fix_stack			; DX:AX = bytes left if failure
	krDebugOut DEB_ERROR, "hMemCopy: Copy past end of segment"
	add	ax, cx
	adc	dx, 0
hmc_done:				; DX:AX = 0 if success

cEnd

ifdef W_Q21
cProc	_HREAD, <PUBLIC, FAR, NODATA>, <ds>
	parmW	h
	parmD	lpData
	parmD	dwCnt
cBegin
	SetKernelDS ds
	push	bx
	mov	bx, Win_PDB
	cmp	bx, cur_dos_PDB
	je	HR_PDB_ok

	push	ax
	mov	cur_dos_PDB,bx
	mov	ah,50h
	pushf
	call	cs:prevInt21Proc	; JUMP THROUGH CS VARIABLE
	pop	ax
HR_PDB_OK:
	pop	bx

	cCall	WowFileRead,<h,lpData,dwCnt,cur_dos_PDB,0,pFileTable>

;   DX:AX = Number Bytes Read
;   DX = FFFF, AX = Error Code

	inc	dx
	jnz	@f

	xor	dx,dx
	or	ax, -1
@@:
	dec	dx
cEnd

cProc	_HWRITE, <PUBLIC, FAR, NODATA>, <ds>
	parmW	h
	parmD	lpData
	parmD	dwCnt
cBegin
	SetKernelDS ds

	push	bx			; Setting the DOS PDB can probably
	mov	bx, Win_PDB		; be removed just pass Win_PDB to
	cmp	bx, cur_dos_PDB 	; the WOW thunk
	je	HW_PDB_ok

	push	ax
	mov	cur_dos_PDB,bx
	mov	ah,50h
	pushf
	call	cs:prevInt21Proc	; JUMP THROUGH CS VARIABLE
	pop	ax
HW_PDB_OK:
	pop	bx

	cCall	WowFileWrite,<h,lpData,dwCnt,cur_dos_PDB,0,pFileTable>

;   DX:AX = Number Bytes Read
;   DX = FFFF, AX = Error Code

	inc	dx
	jnz	@f

	xor	dx,dx
	or	ax, -1
@@:
	dec	dx
cEnd

else
public	_HREAD, _HWRITE

_HREAD:
	mov	bx, 3f00h
	jmps	hugeIO

_HWRITE:
	mov	bx, 4000h

cProc   hugeIO, <FAR, NODATA>, <ds, si, di, cx>
	parmW	h
	parmD	lpData
	parmD	dwCnt
	localD	dwTot
	localW	func
cBegin
	mov	func, bx		; read from a file
	mov	bx, h
	xor	cx, cx
	mov	seg_dwTot, cx
	mov	off_dwTot, cx
beg_fault_trap hr_fault
	lds	dx, lpData
	mov	si, seg_dwCnt
	mov	di, off_dwCnt

hr_loop:
	mov	cx, 8000h		; try to do 32KB

	cmp	cx, dx			; space left in data buffer
	jae	@F
	mov	cx, dx
	neg	cx

@@:	or	si, si			; at least 64K left
	jnz	@F
	cmp	cx, di
	jbe	@F
	mov	cx, di

@@:	mov	ax, func		; talk to DOS
	DOSCALL
	jc	hr_oops

	add     off_dwTot, ax		; update transfer count
	adc	seg_dwTot, 0

	cmp	ax, cx			; end of file?
	jnz	hr_done

	sub	di, ax			; decrement count
	sbb	si, 0

	mov	cx, si			; end of count
	or	cx, di
	jz	hr_done

	add	dx, ax			; update pointer to data
	jnz	@F			; wrapped to next segment
	mov	ax, ds
	add	ax, __AHINCR
	mov	ds, ax
end_fault_trap
@@:	jmps	hr_loop

hr_fault:
	pop	dx
	pop	ax
;	krDebugOut DEB_ERROR, "File I/O past end of memory block"
	krDebugOut DEB_ERROR, "GP fault in _hread/_hwrite at #DX #AX"
;	fault_fix_stack

hr_oops:
	or	dx, -1
	mov	seg_dwTot, dx
	mov	off_dwTot, dx

hr_done:
	mov	dx, seg_dwTot
	mov	ax, off_dwTot
cEnd
endif ; WOW

sEnd

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\i21task.asm ===
.xlist
include kernel.inc
include tdb.inc
include pdb.inc
include kdos.inc
include protect.inc
ifdef WOW
include vint.inc
endif
.list

externFP LoadLibrary
externFP LoadModule
externFP GlobalFree,
externFP GlobalFreeAll
externFP GlobalCompact
externFP FreeModule
externFP GlobalDOSFree
externFP FreeSelector
externFP GetProcAddress                  ; WIN32S
externFP ISetErrorMode                   ; WIN32S
externFP ISetHandleCount

externFP ExitKernelThunk
externNP DPMIProc

extrn   BUNNY_351:FAR

ifdef WOW
DRIVE_REMOTE    equ 4
externW  headTDB
externFP lstrlen
externFP WOWSetIdleHook
externFP GetDriveType
externFP WowShutdownTimer
externFP WowTrimWorkingSet
externB  fShutdownTimerStarted
externW cur_drive_owner
endif

externW pStackBot
;externW pStackMin
externW pStackTop

DataBegin

externB Kernel_flags
externB num_tasks
externB Kernel_InDOS
externB Kernel_InINT24

externB WOAName
externB grab_name
externB fBooting
externB graphics
externB fExitOnLastApp

externW cur_dos_PDB
externW Win_PDB
externW headPDB
externW topPDB
externW curTDB
externW curDTA
externW PHTcount
externW gmove_stack
externW MyCSSeg
externW wExitingTDB
externD lpSystemDir

if KDEBUG
externW allocTask
endif

externD lpint21
externD pExitProc
externD pDisplayCritSec
externW	PagingFlags
externD lpReboot

ifdef FE_SB
ifndef KOREA
externD pJpnSysProc
endif
endif

DataEnd

sBegin  DATA
externW gmove_stack


ifndef WOW
WIN32S = 1           ; enable code for Win32S support
endif

ifdef WIN32S
; Win32S support
selExecPE       DW      0
offExecPE       DW      0
endif

sEnd    DATA

assumes DS,NOTHING
sBegin	CODE
assumes CS,CODE

externD prevInt21Proc

externNP Real_DOS
externNP PathDrvDSDX
externNP SetErrorDrvDSDX
externNP SetCarryRet
externNP ExitSchedule
externNP UnlinkObject
externNP final_call_for_DOS

externNP cmp_sel_address
externNP free_sel
externNP SegToSelector

if SDEBUG
externNP DebugExitCall
endif
externNP DeleteTask


;-----------------------------------------------------------------------;
; Set_DTA		(DOS Call 1Ah)					;
; 									;
; Simply records on a task basis the DTA.				;
; 									;
; Arguments:								;
; 									;
; Returns:								;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Sat Jan 10, 1987 09:19:36p  -by-  David N. Weise   [davidw]          ;
; Wrote it.								;
;-----------------------------------------------------------------------;

	assumes ds, nothing
	assumes es, nothing

cProc	Set_DTA,<PUBLIC,NEAR>
cBegin nogen
	push	es
	SetKernelDS	es
	mov	curDTA.off,dx
	mov	curDTA.sel,ds
	mov	es,curTDB
	UnSetKernelDS	es
	cmp	es:[TDB_sig],TDB_SIGNATURE
	jne	Set_DTA_noTDB
	mov	es:[TDB_DTA].off,dx
	mov	es:[TDB_DTA].sel,ds
Set_DTA_noTDB:
	pop	es
	jmp	final_call_for_DOS
cEnd nogen


;-----------------------------------------------------------------------;
; SaveRegs								;
; 									;
; Does what it says.							;
;									;
; Arguments:								;
; 									;
; Returns:								;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Fri Jan 16, 1987 09:57:49p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

cProc	SaveRegs,<PUBLIC,NEAR>
cBegin nogen

	xchg	dx, user_DX		; Return address in DX
	push	es
	push	bx
	push	ax
	push	cx
	push	si
	push	di
	and	USER_FL,11111110b	; clc flag
	push	dx
	mov	dx, user_DX		; Rescue DX for what it's worth
	cld

	ret
cEnd nogen

;-----------------------------------------------------------------------;
; RestoreRegs								;
; 									;
; Does what it says and (used to cli).					;
; 									;
; Arguments:								;
; 									;
; Returns:								;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Fri Jan 16, 1987 10:00:41p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

cProc	RestoreRegs,<PUBLIC,NEAR>
cBegin nogen

	pop	di			; Return address
	xchg	di, user_BP		; Insert for ret later, get saved BP
	mov	bp, di
	dec	bp
	pop	di
	pop	si
	pop	cx
	pop	ax
	pop	bx
	pop	es
	pop	dx
	pop	ds
	ret				; SP points to user_BP
cEnd nogen

;-----------------------------------------------------------------------;
;                                                                       ;
;  Handle the Int21 func 67 call "Set Maximum Handle Count"             ;
;                                                                       ;
;-----------------------------------------------------------------------;

cProc   SetMaxHandleCount,<PUBLIC,NEAR>
cBegin  nogen
        pop     ds
        pop     bp                              ; clean up stack
        dec     bp

        cmp     bx, 255
        ja      smhc_err1

        push    bx
        push    cx
        push    dx

        cCall   ISetHandleCount,<bx>
        pop     dx
        pop     cx
        pop     bx

        cmp     ax, bx                          ; did we get everything?
        jne     smhc_err2
        clc
        jmp     smhcexit

smhc_err1:
        mov     ax,4                            ; too many open files
        stc                                     ; set carry flag
        jmp     smhcexit

smhc_err2:
        mov     ax,8                            ; not enough memory
        stc                                     ; set carry flag
smhcexit:
        STIRET
        ret


cEnd    nogen


;-----------------------------------------------------------------------;
; Set_Vector		(DOS Call 25h)					;
; Get_Vector		(DOS Call 35h)					;
;									;
;									;
; Arguments:								;
;									;
; Returns:								;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Sat Jan 17, 1987 01:48:29a  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

cProc	Set_Vector,<PUBLIC,NEAR>
cBegin nogen
	push	di
	push	es
	call	IsItIntercepted
	jnz	notintercepted
	SetKernelDS es
	mov	es, CurTDB		; We intercepted it, change
	UnSetKernelDS es		; vector in the TDB
	mov	es:[di].off, dx
	mov	es:[di].sel, ds
	jmps	sv_done 		; And just return
notintercepted:
	SetKernelDS es
	cmp	fBooting,1
	jz	sv_no_restrictions
	cmp	graphics,0		; in the stand alone OS/2 box?
	jz	@F
;ifdef   JAPAN
ifdef   NOT_USE_BY_NT_JAPANESE
        push    ax
        push    bx                      ; 04/23/91 -yukini
        mov     bx,0
        cCall   [pJpnSysProc], <bx,ax>  ; call System.JapanInquireSystem to
                                        ; get vector can be modified or not.
        test    ax,ax
        pop     bx
        pop     ax
        jz      sv_done                 ; jump if cannot be modified
else
	cmp	al,1Bh
	jz	sv_done
	cmp	al,1Ch
	jz	sv_done
endif
@@:	cmp	al,21h			; trying to reset our traps?
	jz	sv_done
	cmp	al,24h			; trying to reset our traps?
        jz      sv_done
        cmp     al,2fh                  ; setting idle detect vector?
        jnz     sv_no_restrictions      ; no, proceed normally
        push    ax
        push    dx
        push    ds
        cCall   WOWSetIdleHook          ; set the real hook back in Win32
        pop     ds
        pop     dx
        pop     ax
        jmp     bodacious_cowboys
sv_no_restrictions:
	cmp	al,21h
	jnz	bodacious_cowboys
	mov	lpint21.off,dx
	mov	lpint21.sel,ds
bodacious_cowboys:
	call	real_DOS

sv_done:
	pop	es
	pop	di
	pop	ds
	pop	bp			; clean up stack
	dec	bp
        STIRET

cEnd nogen

	assumes	ds, nothing
	assumes	es, nothing

cProc	Get_Vector,<PUBLIC,NEAR>
cBegin nogen
	pop	ds
	pop	bp			; clean up stack
	dec	bp
	push	di
	call	IsItIntercepted
	jnz	notintercepted1
	push	ds			; We intercepted it, get the
	SetKernelDS			; vector from the TDB
	mov	ds, CurTDB
	UnSetKernelDS
	mov	bx, [di]
	mov	es, [di+2]
	pop	ds
	pop	di
	jmps	gv_done
notintercepted1:
	pop	di
	call	real_DOS
gv_done:
        STIRET

cEnd nogen



cProc	IsItIntercepted,<PUBLIC,NEAR>
cBegin nogen
	mov	di, TDB_INTVECS
	cmp	al, 00h
	je	yes_intercepted
	add	di, 4
	cmp	al, 02h
	je	yes_intercepted
	add	di, 4
	cmp	al, 04h
	je	yes_intercepted
	add	di, 4
	cmp	al, 06h
	je	yes_intercepted
	add	di, 4
	cmp	al, 07h
	je	yes_intercepted
	add	di, 4
	cmp	al, 3Eh
	je	yes_intercepted
	add	di, 4
	cmp	al, 75h
yes_intercepted:
	ret
cEnd nogen


;-----------------------------------------------------------------------;
; ExecCall		(DOS Call 4Bh)					;
; 									;
; 									;
; Arguments:								;
; 									;
; Returns:								;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Mon 07-Aug-1989 23:39:59  -by-  David N. Weise  [davidw]		;
; Added support for long command lines to WinOldApp.			;
;									;
;  Sat Jan 17, 1987 01:39:44a  -by-  David N. Weise   [davidw]		;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

cProc	ExecCall,<PUBLIC,NEAR>
cBegin nogen
	call	PathDrvDSDX		; Check drive
	jnc	EC1			; Drive OK
	call	SetErrorDrvDSDX 	; Set up errors
	jmp	SetCarryRet		; Error

EC1:	call	SaveRegs
	call	far ptr FarExecCall
	call	RestoreRegs
        STIRET
cEnd nogen


;-----------------------------------------------------------------------;
; TerminatePDB								;
;									;
; It calls DOS to terminate the current task.				;
;									;
; Arguments:								;
;	DI = exit code							;
; Returns:								;
;	nothing								;
; Error Returns:							;
;	nothing								;
; Registers Preserved:							;
;	none								;
; Registers Destroyed:							;
;									;
; Calls:								;
;									;
; History:								;
;									;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

cProc	TerminatePDB,<PUBLIC,NEAR>
cBegin	nogen

	SetKernelDS	ES
	mov	bx, ds				; DS is PDB being terminated
	cmp	cur_dos_PDB, bx			; Ensure DOS/anyone on the
	je	short @F			; int 21h chain has correct PDB
	mov	ah, 50h
	pushf
	call	prevInt21Proc
@@:
	mov	ax, ds:[PDB_Parent_PID]		; Parent PDB
	mov	Win_PDB, ax			; These will be changed by DOS
	mov	cur_dos_PDB, ax

	or	Kernel_Flags[2],KF2_WIN_EXIT
	mov	ax,di			; AL = exit code
	mov	ah, 0			; Alternative exit for PMODE which returns
	call	real_DOS		; let DOS clean up
	UnSetKernelDS	es

	errn$	DosExitReturn

cEnd	nogen

;
; The DOS terminate call above will return to
; the following label, DosExitReturn.  This is
; a separate procedure in order to be declared FAR.
;
	assumes	ds, nothing
	assumes	es, nothing

cProc	DosExitReturn,<PUBLIC,FAR>
cBegin nogen

	SetKernelDS ES
	mov	Kernel_InDOS,0
	mov	Kernel_InINT24,0
	and	Kernel_Flags[2],NOT KF2_WIN_EXIT
	retn

cEnd nogen

;-----------------------------------------------------------------------;
; ExitCall		(DOS Call 4Ch)					;
;									;
; It terminates the current task.					;
;									;
; Arguments:								;
;	AL = exit code							;
; Returns:								;
;	nothing								;
; Error Returns:							;
;	nothing								;
; Registers Preserved:							;
;	none								;
; Registers Destroyed:							;
;	none								;
; Calls:								;
;	TerminatePDB							;
;	GlobalFreeAll							;
;	UnlinkObject							;
;	DeleteTask							;
;	GlobalFree							;
;	FreeModule							;
; History:								;
;									;
;  Mon 07-Aug-1989 23:39:59  -by-  David N. Weise  [davidw]		;
; Removed WinOldApp support.						;
;									;
;  Sun Apr 26, 1987 03:20:05p  -by-  David N. Weise   [davidw]		;
; Made it switch stacks to the temp_stack because of EMS.		;
; 									;
;  Mon Sep 29, 1986 04:06:08p  -by-  Charles Whitmer  [chuckwh]		;
; Made it kill all threads in the current process.			;
;									;
;  Mon Sep 29, 1986 03:27:12p  -by-  Charles Whitmer  [chuckwh]		;
; Made it call UnlinkObject rather than do the work inline.		;
;									;
;  Mon Sep 29, 1986 09:22:08a  -by-  Charles Whitmer  [chuckwh]		;
; Documented it.							;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

cProc	ExitCall,<PUBLIC,NEAR>
cBegin          nogen

ifdef WOW
        ; Set to a Known DIR so that if an app was running over the network
        ; the user can disconnect once the app terminates.
        ; This also allows a subdirectory to be removed after a Win16 app
        ; had that dir as the current dir, but was terminated.

        SetKernelDS

        push    ax
        push    si
        push    dx
        push    ds

        lds     si,lpSystemDir          ; ds:si points to system directory
        mov     dl,[si]                 ; put drive letter into AL
        add     dl,-65                  ; subtract 'A' to get drive number
        mov     ah,0Eh
        call    real_DOS                ; select disk

        add     si,2                    ; let SI point to the first '\' past d:

        mov     al,[si + 1]             ; save first character after '\'
        push    ax

        mov     byte ptr [si + 1],0     ; null-terminate string after root dir
        mov     dx,si
        mov     ah,3Bh
        call    real_DOS                ; select directory

        pop     ax
        mov     [si + 1],al             ; restore string to its original state
        ;
        ; During task exit/abort ntdos $abort notifies the debugger of the
        ; "module unload" of the EXE using the full path to the EXE that
        ; follows the environment block.  We don't want ntdos to make the
        ; module unload callout because we do it ourself during our
        ; DelModule of the EXE module.  So we have a protocol, we zero
        ; the environment selector in our PDB, DPMI translates this to
        ; segment zero properly, and ntdos skips the callout if the environment
        ; segment is zero.
        ;
        pop     ds
        ReSetKernelDS
        mov     es,[curTDB]               ; DS = current TDB
        mov     es, es:[TDB_PDB]
        xor     ax,ax
        mov     word ptr es:[PDB_environ], ax

        pop     dx
        pop     si
        pop     ax
endif


if SDEBUG
        ;** Save the TDB of the currently exiting task.  We check for this
        ;**     in DebugWrite so that we don't get recursive
        ;**     debug strings at task exit time.  This is a gross hack
        ;**     for QCWin and their numerous param validation errors.
        mov     bx,curTDB               ;Get current task handle
        mov     wExitingTDB,bx          ;Save as exiting TDB
        cCall   DebugExitCall           ;Passes exit code in AL
endif ; SDEBUG

        .386
        smov    fs, 0
        smov    gs, 0
        .286p

        xchg    di,ax                   ; DI = exit code

        cmp     graphics,1              ; is there a display driver around?
        jnz     @F
	mov	ax,1
ifndef WOW ; WOW doesn't have a display dirver to call
	cCall	pDisplayCritSec,<ax>	; tell display driver to shut up
endif
        or      Kernel_Flags[2],KF2_WIN386CRAZINESS
@@:     mov     ds,curTDB               ; DS = current TDB
        assumes ds,nothing

; We may have gotten here due to stack checking.  Let's make sure
;  that we are on a stack we can deal with.

        test    ds:[TDB_flags],TDBF_OS2APP
        jz      @F
        mov     ax,sp
        mov     ss:[pStackBot],ax
@@:     xor     ax,ax
        mov     ss:[pStackTop],ax

; remove the PDB from the chain

        mov     es,ds:[TDB_PDB]
        mov     dx,PDB_Chain
        mov     bx,dataOffset HeadPDB
        call    UnlinkObject

        xor     si,si                   ; source of zero

; Dec total # of tasks, if last task in system, then quit Windows completely.

        smov    es,ds
        assumes es,nothing
	SetKernelDS
ifdef WOW
	cmp	fExitOnLastApp,0	; Quit WOW when the last app dies ?
	jz	@f

	cmp	num_tasks,2		; Last Task (ingnoring WOWEXEC) ?
	jz	last_task
@@:
endif
        dec     num_tasks
	jnz	not_the_last_task

last_task:
        ;** Unhook local reboot VxD stuff
        cmp     WORD PTR lpReboot[2], 0 ;Reboot handler installed?
        je      @F                      ;No
        push    es
        mov     ax, 0201h               ;Reboot VxD #201:  Set callback addr
        xor     di, di                  ;Zero CS means no SYS VM local
        mov     es, di
        call    [lpReboot]              ;  reboot handler
        pop     es
@@:

        call    BUNNY_351

ifndef WOW				; For WOW ex just want to get out of here - no need to call USER16 or GDI16
	cCall	pExitProc,<si,si>	; this does not return
endif
        cCall   ExitKernelThunk,<si>

        assumes es, nothing
not_the_last_task:

; Signal( hTask, SG_EXIT, ExitCode, 0, Queue ) if we have a user signal proc

        push    es
        cmp     es:[si].TDB_USignalProc.sel,si
        jz      no_signal_proc
        mov     bx,SG_EXIT
        cCall   es:[si].TDB_USignalProc,<es,bx,di,es:[si].TDB_Module,es:[si].TDB_Queue>
no_signal_proc:

	pop	es

	mov	bl,6
	DPMICALL    0202h		 ; DPMI get exception handler vector
        push    cx
        push    dx

        mov     cx,cs
        lea     dx,exit_call_guts
        mov     bl,6
	DPMICALL    0203h		 ; DPMI set exception handler vector

        pop     dx
        pop     cx
;
; Generate an invalid opcode exception fault.  This causes DPMI to call
; our "exception handler."
;
	db	0fh,0ffh
exit_call_guts:
        FSTI                     ; we're called with ints disabled
        mov     bp,sp           ; BP -> RETIP RETCS EC IP CS FL SP SS
;
; Restore the previous invalid exception handler vector.
;
	mov	bl,6
	DPMICALL 0203h
;
; Point the return stack at Kernel's temporary stack.
;
        mov     ax,dataOffset gmove_stack
        mov     [bp+12],ax
        mov     ax,seg gmove_stack
        mov     [bp+14],ax
;
; Replace the return address on the DPMI fault handler routine with
; our exit code.
;
        lea     ax,ExitSchedule
        mov     [bp+6],ax
        mov     [bp+8],cs

        push    es

        cCall   GlobalFreeAll,<si>      ; free up all task data
        pop     es

; Remove from queue.

        push    es
        cCall   DeleteTask,<es>
        pop     es
        mov     ds,es:[TDB_PDB]         ; DS = current PDB

	UnsetKernelDS			; DS is PDB to terminate

	call	TerminatePDB		; Call DOS to close down files etc.

	ReSetKernelDS ES		; TerminatePDB returned with ES set

	xor	bp,bp			; set up valid frame
	mov	ds,curTDB

; If this task has a PHT, decrement the PHT count and clear the pointer
;  and zap the PHT pointer so we don't look at it anymore.
;  NOTE - BP contains a convenient zero.

	mov	ax,ds:[TDB_PHT].sel
	or	ax,ds:[TDB_PHT].off
	jz	no_PHT
	mov	ds:[TDB_PHT].sel,bp
	mov	ds:[TDB_PHT].off,bp
	dec	PHTcount		; dec # tasks with PHT's
no_PHT:
	UnSetKernelDS	es
	cCall	FreeModule,<ds:[TDB_Module]>	; Free the module for this task
	xor	ax,ax
	mov	ds:[TDB_sig],ax 	; Mark TDB as invalid

        ;** Nuke any JFN that is outside the PDB.  We can tell that the
        ;**     JFN points outside the PDB if the offset is zero.  PDB
        ;**     JFN's never have a zero offset and outside ones always do.
	push	ds
	mov	ds, ds:[TDB_PDB]
        cmp     WORD PTR ds:[PDB_JFN_Pointer][0], 0 ;JFN pointer into PDB?
        jne     EC_NoFreeJFN            ;Yes, don't free anything
        push    WORD PTR ds:[PDB_JFN_Table] ;Get our selector
        call    GlobalDOSFree
EC_NoFreeJFN:

	SetKernelDS
 
        cmp     num_tasks,1             ; Last task? (except wowexec)
        jne     @f                      ; branch if not last task
if 0
        ; This code is unneeded because if we're a separate VDM, we exit above when
        ; the last task exited.
        cmp     fExitOnLastApp, 0       ; Shared WOW?
        jne     @F                      ; branch if not shared WOW
endif

        cCall   WowShutdownTimer, <1>       ; start shutdown timer
        mov     fShutdownTimerStarted, 1
        cCall   GlobalCompact,<-1, -1>      ; free up as many pages as possible
        cCall   WowTrimWorkingSet           ; trim working set to minimum
@@:
	mov	bx, topPDB
	mov	Win_PDB, bx
	mov	cur_dos_PDB, bx
	mov	ah, 50h
	pushf
	call	prevInt21Proc		; Set PDB to KERNEL's
	pop	ds
	UnSetKernelDS
	xchg	bx, ds:[TDB_PDB]
	cCall	free_sel,<bx>		; Free the PDB selector

	call	far ptr FreeTDB		; Tosses PDB's memory
        SetKernelDS
ifndef WOW
        mov     curTDB,0        ; We can use this, setting curTDB = 0
else
        ;; We do this a little later - see tasking.asm exitschedule
endif
	or	PagingFlags, 8	;  to save a few bytes.

        ;** Task has been nuked.  Clear the DebugWrite task exiting flag
        mov     wExitingTDB,0

        ; fix current drive owner
        mov     ax, cur_drive_owner
        cmp     ax, curTDB
        jnz     @f
        ; so it is the owner of a current drive -- nuke it
        mov     cur_drive_owner, 0
@@:

if 0    ; We could call this on every task exit -- need to see if
        ; it slows down Winstone 94, if it's needed after we use MEM_RESET
        ; If you enable this call, disable the similar call just above.
        cCall   WowTrimWorkingSet           ; trim working set to minimum
endif

        retf                    ; To ExitSchedule
cEnd nogen	

	assumes	ds, nothing
	assumes	es, nothing

cProc	FreeTDB, <PUBLIC,FAR>
cBegin nogen

	cCall	FreeSelector,<ds:[TDB_MPI_Sel]>
	mov	ax,ds
if KDEBUG
;
; If we're freeing the alloc break task, zero out the global.
;
        SetKernelDS
        cmp     ax,allocTask
        jnz     @F
        mov     allocTask,0
@@:
        UnSetKernelDS
endif
	smov	ds,0
	cCall	GlobalDOSFree,<ax>
	ret

cEnd nogen

;-----------------------------------------------------------------------;
; set_PDB			(DOS Call 50h)				;
; 									;
; This is an undocumented DOS call to set the current PDB.		;
; DOS does not check for ^C's on this call, in fact it never turns	;
; on the interrupts.							;
;									;
; Arguments:								;
; 									;
; Returns:								;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Fri Jan 23, 1987 07:07:14p  -by-  David N. Weise   [davidw]          ;
; Wrote it.								;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

cProc	set_PDB,<PUBLIC,NEAR>
cBegin nogen
	SetKernelDS
	mov	cur_dos_PDB,bx
	mov	Win_PDB,bx
	mov	ds,curTDB
	assumes ds,nothing
	mov	ds:[TDB_PDB],bx
	call	real_DOS
	pop	ds
	pop	bp			; clean up stack
	dec	bp
        STIRET
cEnd nogen


;-----------------------------------------------------------------------;
; get_PDB								;
;									;
; This is an undocumented DOS call to set the current PDB.		;
; DOS does not check for ^C's on this call, in fact it never turns	;
; on the interrupts.							;
; Trapping this is superfluous is real mode but necessary in protect	;
; mode since the DOS extender may not be doing the segment		;
; translation properly. 						;
;									;
; Entry:								;
;									;
; Returns:								;
;									;
; Registers Destroyed:							;
;									;
; History:								;
;  Tue 13-Jun-1989 18:22:16  -by-  David N. Weise  [davidw]		;
; Wrote it.								;
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	get_PDB,<PUBLIC,NEAR>
cBegin nogen
	SetKernelDS
	call	real_DOS
	mov	bx,cur_dos_PDB
	pop	ds
	pop	bp			; clean up stack
	dec	bp
        STIRET
cEnd nogen

sEnd code

sBegin NRESCODE
assumes cs, NRESCODE
assumes	ds, nothing
assumes	es, nothing

externNP MapDStoDATA


;-----------------------------------------------------------------------;
; BuildPDB								;
; 									;
; 									;
; Arguments:								;
; 									;
; Returns:								;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Thu 04-Jan-1990 20:15:27  -by-  David N. Weise  [davidw]		;
; Made it avoid closing cached files if the PDB being copied is not	;
; the topPDB.  This is for supporting inheriting a parents files.	;
;									;
;  Mon 11-Sep-1989 19:13:52  -by-  David N. Weise  [davidw]		;
; Removed returning validity in AX, and removed copying of FCBs.	;
;									;
;  Mon 07-Aug-1989 23:39:59  -by-  David N. Weise  [davidw]		;
; Added support for long command lines to WinOldApp.			;
;									;
;  Sun Jan 18, 1987 00:27:52a  -by-  David N. Weise   [davidw]		;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

cProc	BuildPDB,<PUBLIC,FAR>,<si,di>
	ParmW	oldPDB
	ParmW	newPDB
	ParmD	ParmBlock
	ParmW	newSize
        ParmW   fWOA
cBegin
	call	MapDStoDATA
	ReSetKernelDS

	push	Win_PDB			; Save current PDB

	mov	bx,oldPDB		; set current PDB for copy
	mov	Win_PDB, bx

	mov	dx,newPDB
	mov	si,newSize
	mov	ah,55h			; duplicate PDB
	int	21h

	mov	bx, oldPDB
	mov	dx, newPDB
	mov	cur_dos_PDB, dx		; DOS call 55h sets the PDB to this

nothing_to_close:

	pop	Win_PDB			; restore former PDB

	xor	di,di

	mov	cx, MyCSSeg
	mov	ds,dx
	UnSetKernelDS
	mov	es,dx
	add	si,dx
	mov	ax,oldPDB
	mov	[di].PDB_Parent_PID,ax	; parent = OldPDB
	mov	[di].PDB_Block_Len,si

	mov	[di].PDB_Exit.off,codeOffset DosExitReturn
	mov	[di].PDB_Exit.sel, cx

; No private global heap yet.

	mov	[di].PDB_GlobalHeap.lo,di
	mov	[di].PDB_GlobalHeap.hi,di

; Set up proper command line stuff.

	lds	si,ParmBlock
	lds	si,ds:[si].lpcmdline	; command line
	mov	di,PDB_DEF_DTA
        mov     cx,di
        cmp     fWOA,0
	jz	@F			; Winoldap can have long command line
        mov     cx,ds:[si]              ; get byte count
        cld
        movsb                           ; copy count byte
        inc     cx
        inc     si
@@:     rep     movsb                   ; Store command line.

cEnd


cProc	FarExecCall,<PUBLIC,FAR>
cBegin nogen

; Check if file extension is .COM, .BAT, .PIF, if so it needs emulation...

        cld
        les     di,User_DSDX


ifdef WOW
;
;  Wow LoadModule handles all forms of exec including
;  pe images, com, bat, pif files etc.
;
        lds     si,User_ESBX
	regptr	esdx,es,dx
	regptr	dssi,ds,si
        cCall   LoadModule,<esdx,dssi>
        cmp     ax, LME_MAXERR          ; check for error...
        jae     ex8
        jmp short ex7                     ; no, return error

else

        mov     cx,-1
	xor	al,al
	repnz	scasb			; scan to end of string
	neg	cx
	dec	cx			; cx has length (including null)
	mov	ax,es:[di-5]
	or	ah,20h
	mov	bx,es:[di-3]		; complete check for .COM
	or	bx,2020h		; convert to lower case

	cmp	ax,'c.' 		; check for .COM file extension
	jnz	ex1b			; no match...attempt load module
	cmp	bx,'mo'
	jz	ex4			; yes! go immediatly to GO

ex1b:	cmp	ax,'b.' 		; check for .BAT extension...
	jnz	ex1c
	cmp	bx,'ta'
	jz	ex4

ex1c:	cmp	ax,'p.' 		; check for .PIF extension...
	jnz	ex2
	cmp	bx,'fi'
        jz      ex4

ex2:    lds     si,User_ESBX
	regptr	esdx,es,dx
	regptr	dssi,ds,si
        push    cx                      ; save length of string
	cCall	LoadModule,<esdx,dssi>
        pop     cx
        cmp     ax, LME_MAXERR          ; check for error...
	jb	ex3
	jmp	ex8
ex3:    cmp     ax, LME_INVEXE		; wrong format?
	jz	ex4
	cmp     ax, LME_EXETYPE		; quick basic app
        jz      ex4

        cmp     ax, LME_PE              ; Win32 PE format
        jz      @F
	jmp	ex7			; no, return error
@@:


ifdef WIN32S
	push    cx
; Win32S support -  (AviN)   11-19-91

        lds     si,User_DSDX
	push	ds
        push    si
        lds     si,User_ESBX
        push    ds:[si+4]           ; CmdLine sel
        push    ds:[si+2]           ;         offset

        les     bx, ds:[si+6]       ; FCB1
        push    es:[bx+2]           ; nCmdShow

        call    FAR PTR ExecPE
        pop     cx

        cmp     ax, 32
        jbe     @F
        jmp     ex8
@@:
        cmp     ax, 11                  ; NOT PE
        je      @F
        jmp     ex7

@@:

; end of Win32S support
endif

ex4:

; Run an old application
;
; If we are running in the OS/2 3x box, we do not support running old
; apps.  If someone trys this, put up a nasty message and return with
; an error.  (Thu 12-Nov-1987 : bobgu)


	mov	dx,cx			; save length of file name
	sub	sp,256			; make room for command line
	smov	es,ss
	mov	di,sp
	lds	si,User_ESBX
	lds	si,ds:[si].lpcmdline
	xor	ax,ax
	xor	cx,cx
	mov	cl,ds:[si]
	inc	cx
        movsb
        stosb
        rep     movsb
	mov	cx,dx
	lds	si,User_DSDX
	rep	movsb
	mov	byte ptr es:[di][-1],10	; terminate with line feed
	mov	di,sp
	add	es:[di],dx

	mov	bx,es
	push	ds
	call	MapDStoDATA
	smov	es, ds
	pop	ds
        ReSetKernelDS es

        test    Kernel_flags[2],KF2_DOSX ; DOSX winoldap doesn't need special
	jnz	@F			 ;  special handling
	mov	ax,dataOffset grab_name
	push	bx
	push	dx
	push	es
	cCall	LoadLibrary,<es,ax>
	pop	es
	pop	dx
	pop	bx
	cmp	ax,32
	jae	@F
	add	sp, 256			; undo damage to stack
	jmps	ex7
@@:

        or      Kernel_flags[1],KF1_WINOLDAP
        lds     si,User_ESBX
	mov	ds:[si].lpcmdline.off,di
	mov	ds:[si].lpcmdline.sel,bx
	mov	dx,dataOffset WOAName
	regptr	esdx,es,dx
	regptr	dssi,ds,si
	cCall	LoadModule,<esdx,dssi>
	assumes	es, nothing
	add	sp,256
	cmp	ax,32			; check for error...
	jae	ex8
	cmp	ax,2			; file not found?
	jnz	ex7			; no, return error
        mov     al,23                   ; flag WINOLDAP error

;; ndef wow
endif

ex7:    or      User_FL,1               ; set carry flag
	or	ax,ax			; out of memory?
	jnz	ex8
	mov	ax,8h			; yes, return proper error code
ex8:	mov	User_AX,ax		; return AX value

	ret
cEnd nogen


ifdef WIN32S
SZW32SYS        db  "W32SYS.DLL", 0
ExecPEOrd       equ  3

;-----------------------------------------------------------------------;
; ExecPE
; Get ExecPE address in W32SYS.DLL, and call it
; 11-13-91   AviN   created
;-----------------------------------------------------------------------;

cProc   ExecPE,<PUBLIC,FAR>
cBegin	nogen
	push	ds
        mov     ax, SEG selExecPE
        mov     ds, ax

assumes DS, DATA

        mov     dx, selExecPE          ; check for a valid address
        or      dx, dx
        jnz     ep_x

        mov     ax, offExecPE
        or      ax, ax
        jnz     ep_err                 ; already failed, don't try again


        cCall   ISetErrorMode, <8000h>
        push    ax

        lea     ax, SZW32SYS
        cCall   LoadLibrary,<cs, ax>

        pop     dx
        push    ax
        cCall   ISetErrorMode,<dx>      ; restore original error mode
        pop     ax

        cmp     ax, 32
        jbe     ep_err

        push    ax
        push    0
        push    ExecPEOrd
        cCall   GetProcAddress
        or      dx,dx
        jz      ep_err
        mov     selExecPE, dx
        mov     offExecPE, ax
ep_x:

        pop     ax                      ; saved DS
        push    selExecPE               ; jmp to ExecPE
        push    offExecPE
        mov     ds, ax
        retf

ep_err:
                                        ; if w32sys support no available return
        mov     ax, 11                  ; invalid module format
        mov     offExecPE, ax           ; and record for next time

        pop     ds
	retf    10                      ; pop ExecPE parameters


assumes DS,NOTHING
cEnd    nogen
endif


sEnd NRESCODE

sBegin MISCCODE
assumes cs, misccode
assumes ds, nothing
assumes es, nothing

externNP MISCMapDStoDATA

;-----------------------------------------------------------------------;
;                                                                       ;
;  Get the Current PDB without doing a DOS call.                        ;
;                                                                       ;
;-----------------------------------------------------------------------;

cProc   GetCurrentPDB,<PUBLIC,FAR>
cBegin  nogen
        push    ds
        call    MISCMapDStoDATA
        ReSetKernelDS
        mov     dx,TopPDB
        mov     ds,curTDB
        UnSetKernelDS
        mov     ax,ds:[TDB_PDB]
        pop     ds
        ret
cEnd    nogen


sEnd MISCCODE

end

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\i21entry.asm ===
.xlist
include kernel.inc
include pdb.inc
include tdb.inc
include newexe.inc
include protect.inc
ifdef WOW
include vint.inc
endif
.list

ifdef WOW
;
; Int 21 tracing control.  If TraceInt21 is defined, ifdef's cause
; extra debugging output before/after the DOS call.
;
; TraceInt21 equ 1 ; uncomment this line to log Int 21 operations.
endif


DataBegin

externB PhantArray
externB kernel_flags
externB Kernel_InDOS
externB Kernel_InINT24
externB fInt21
externB InScheduler
externB CurDOSDrive
externB DOSDrives
externW curTDB
externW curDTA
;externW headPDB
;externW topPDB
externW Win_PDB
externW cur_dos_PDB
externW cur_drive_owner
externW LastExtendedError
ifndef WOW
externB WinIniInfo
externB PrivateProInfo
externB fProfileMaybeStale
externB fWriteOutProfilesReenter
endif
externB fBooting
;externD lpWinSftLink

ifdef WOW
externD pPMDosCURDRV
externD pPMDosPDB
externD pPMDosExterr
externD pPMDosExterrLocus
externD pPMDosExterrActionClass

externD pFileTable
externW WinFlags
externW fLMdepth
externW WOWLastError
externB WOWErrClass
externB WOWErrAction
externB WOWErrLocation
endif

DataEnd

externFP WriteOutProfiles
ifdef WOW
externFP WOWFileRead
externFP WOWFileWrite
externFP WOWFileLSeek
externFP WOWFileCreate
externFP WOWFileOpen
externFP WOWFileClose
externFP WOWFileGetAttributes
externFP WOWFileSetAttributes
externFP WOWFileGetDateTime
externFP WOWFileSetDateTime
externFP WOWFileLock
externFP WOWDelFile
externFP WOWFindFirst
externFP WOWFindNext
externFP WOWSetDefaultDrive
externFP WOWGetCurrentDirectory
externFP WOWSetCurrentDirectory
externFP WOWGetCurrentDate
externFP WOWDeviceIOCTL
endif

SetDosErr macro ErrorCode,ErrorCodeLocus,ErrorCodeAction,ErrorCodeClass
        push es
        push di
        push ax
        mov  ax, pPMDosExterr.sel
        mov  es, ax
        pop  ax

        mov di, pPMDosExterr.off
        mov word ptr es:[di], ErrorCode
        mov WOWLastError, ErrorCode

        ifnb <ErrorCodeLocus>
           mov di, pPMDosExterrLocus.off
           mov byte ptr es:[di], ErrorCodeLocus
        endif
        ifnb <ErrorCodeAction>
           mov di, pPMDosExterrActionClass.off
           mov byte ptr es:[di], ErrorCodeAction
           mov byte ptr es:[di+1], ErrorCodeClass
        endif
        pop di
        pop es
endm

CheckDosErr macro
        push es
        push di
        push ax
        mov  ax, pPMDosExterr.sel
        mov  es, ax
        pop  ax
        mov  di, pPMDosExterr.off
        cmp  word ptr es:[di], 0
        pop  di
        pop  es
endm


GetDosErr macro regCode,regCodeLocus,regCodeAction,regCodeClass
        push es
        push di
        push ax
        mov ax, pPMDosExterr.sel
        mov es, ax
        pop ax

        mov di, pPMDosExterr.off
        mov regCode, word ptr es:[di]
        ; mov regCode, WOWLastError

        ifnb <regCodeLocus>
             mov di, pPMDosExterrLocus.off
             mov regCodeLocus, byte ptr es:[di]
        endif

        ifnb <regCodeAction>
             mov di, pPMDosExterrActionClass.off
             mov regCodeAction, byte ptr es:[di]
             mov regCodeClass,  byte ptr es:[di+1]
        endif

        pop di
        pop es
endm


sBegin  CODE
assumes CS,CODE
assumes ds, nothing
assumes es, nothing

externD prevInt21Proc

ifdef WOW
externFP WOWLFNEntry

externNP DPMIProc
endif


;***********************************************************************;
;                                                                       ;
;                       WINDOWS mediated system calls.                  ;
;                                                                       ;
;   Windows mediates certain system calls.   Several matters complicate ;
;   the mediation:                                                      ;
;                                                                       ;
;   a.  MSDOS uses registers to pass arguments.  Thus, registers AND    ;
;       ANY RETURN VALUES in registers must be preserved across tasks.  ;
;                                                                       ;
;   b.  MSDOS stores global state information that must be preserved    ;
;       on a task by task basis.                                        ;
;                                                                       ;
;   c.  To handle multiple exec calls, the notion of a "parent" task    ;
;       is introduced.                                                  ;
;                                                                       ;
;                                                                       ;
;***********************************************************************;

entry   macro   fred
if1
        dw      0
else
ifndef  fred
        extrn   fred:near
endif
        dw      CODEOffset fred
endif
        endm

sEnd    CODE


sBegin  DATA
DosTrap1        label   word
;;;             entry   not_supported           ; 00  abort call
;;;             entry   not_supported           ; 01  read keyboard and echo
;;;             entry   not_supported           ; 02  display character
;;;             entry   not_supported           ; 03  aux input
;;;             entry   not_supported           ; 04  aux output
;;;             entry   not_supported           ; 05  printer output
;;;             entry   not_supported           ; 06  direct console IO
;;;             entry   not_supported           ; 07  direct console input
;;;             entry   not_supported           ; 08  read keyboard
;;;             entry   not_supported           ; 09  display string
;;;             entry   not_supported           ; 0A  buffered keyboard input
;;;             entry   not_supported           ; 0B  check keyboard status
;;;             entry   not_supported           ; 0C  flush keyboard buffer
;;;             entry   PassOnThrough           ; 0D  disk reset
                entry   Select_Disk             ; 0E
                entry   not_supported           ; 0F  open file FCB
                entry   not_supported           ; 10  close file FCB
                entry   FCBCall                 ; 11  search first FCB
                entry   not_supported           ; 12  search next FCB
                entry   not_supported           ; 13  delete file FCB
                entry   not_supported           ; 14  read FCB
                entry   not_supported           ; 15  write FCB
                entry   not_supported           ; 16  create file FCB
                entry   not_supported           ; 17  rename file FCB
                entry   not_supported           ; 18  ???
                entry   PassOnThrough           ; 19  current disk
                entry   Set_DTA                 ; 1A
                entry   not_supported           ; 1B  allocation table info
                entry   not_supported           ; 1C  allocation table info
                entry   not_supported           ; 1D  ???
                entry   not_supported           ; 1E  ???
                entry   not_supported           ; 1F  ???
                entry   not_supported           ; 20  ???
                entry   not_supported           ; 21  read FCB
                entry   not_supported           ; 22  write FCB
                entry   not_supported           ; 23  file size FCB
                entry   not_supported           ; 24  set record field FCB
                entry   Set_Vector              ; 25
                entry   not_supported           ; 26
                entry   not_supported           ; 27  random read FCB
                entry   not_supported           ; 28  random write FCB
                entry   not_supported           ; 29  parse filename FCB
                entry   PassOnThrough           ; 2A  get date
                entry   PassOnThrough           ; 2B  set date
                entry   PassOnThrough           ; 2C  get time
                entry   PassOnThrough           ; 2D  set time
                entry   PassOnThrough           ; 2E  set verify
                entry   PassOnThrough           ; 2F  get DTA
                entry   PassOnThrough           ; 30  get DOS version
                entry   not_supported           ; 31  TSR
                entry   DLDriveCall1            ; 32
                entry   not_supported           ; 33  break state
                entry   not_supported           ; 34  ???
                entry   Get_Vector              ; 35
                entry   DLDriveCall1            ; 36
                entry   not_supported           ; 37  ???
                entry   not_supported           ; 38  country info
                entry   PathDSDXCall            ; 39
                entry   PathDSDXCall            ; 3A
                entry   Change_Dir              ; 3B
                entry   PathDSDXCall            ; 3C
                entry   PathDSDXCall            ; 3D
                entry   FileHandleCall          ; 3E
                entry   PassOnThrough           ; 3F
                entry   PassOnThrough           ; 40
                entry   PathDSDXCall            ; 41
                entry   FileHandleCall          ; 42
                entry   PathDSDXCall            ; 43
                entry   Xenix_Status            ; 44
                entry   FileHandleCall          ; 45
                entry   FileHandleCall          ; 46
                entry   DLDriveCall2            ; 47
                entry   not_supported           ; 48  allocate memory
                entry   not_supported           ; 49  free memory
                entry   not_supported           ; 4A  reallocate memory
                entry   ExecCall                ; 4B
                entry   ExitCall                ; 4C
                entry   not_supported           ; 4D  get return code
                entry   PathDSDXCall            ; 4E
                entry   PassOnThrough           ; 4F  find next
                entry   set_PDB                 ; 50
                entry   get_PDB                 ; 51
                entry   not_supported           ; 52  ???
                entry   not_supported           ; 53  ???
                entry   PassOnThrough           ; 54  get verify
                entry   not_supported           ; 55  ???
                entry   XenixRename             ; 56
                entry   FileHandleCall          ; 57
                entry   not_supported           ; 58  ???
                entry   PassOnThrough           ; 59  extended error
                entry   PathDSDXCall            ; 5A  create unique file
                entry   PathDSDXCall            ; 5B  create new file
                entry   FileHandleCall          ; 5C  lock/unlock file access
                entry   not_supported           ; 5D  ???
                entry   PassOnThrough           ; 5E  network stuff
                entry   AssignCall              ; 5F  network stuff
                entry   NameTrans               ; 60
                entry   not_supported           ; 61  ???
                entry   get_PDB                 ; 62
                entry   PassOnThrough           ; 63
                entry   PassOnThrough           ; 64
                entry   PassOnThrough           ; 65
                entry   PassOnThrough           ; 66
                entry   SetMaxHandleCount               ; 67
                entry   PassOnThrough           ; 68
                entry   PassOnThrough           ; 69
                entry   PassOnThrough           ; 6a
                entry   PassOnThrough           ; 6b
                entry   PathDSSICall            ; 6c  Extended File Open
                entry   PassOnThrough           ; 6d
                entry   PassOnThrough           ; 6e
                entry   PassOnThrough           ; 6f
                entry   PassOnThrough           ; 70
                entry   PassOnThrough           ; 71  LFN API
TableEnd = 71h


ifdef W_Q21
QuickDispatchTable      label   word
QD_FIRST equ    0eh
        dw      offset QuickSetDefaultDrive     ;0e
        dw      offset Not_WOW_Handled          ;0f
        dw      offset Not_WOW_Handled          ;10
        dw      offset Not_WOW_Handled          ;11
        dw      offset Not_WOW_Handled          ;12
        dw      offset Not_WOW_Handled          ;13
        dw      offset Not_WOW_Handled          ;14
        dw      offset Not_WOW_Handled          ;15
        dw      offset Not_WOW_Handled          ;16
        dw      offset Not_WOW_Handled          ;17
        dw      offset Not_WOW_Handled          ;18
        dw      offset QuickGetDefaultDrive     ;19
        dw      offset Not_WOW_Handled          ;1a
        dw      offset Not_WOW_Handled          ;1b
        dw      offset Not_WOW_Handled          ;1c
        dw      offset Not_WOW_Handled          ;1d
        dw      offset Not_WOW_Handled          ;1e
        dw      offset Not_WOW_Handled          ;1f
        dw      offset Not_WOW_Handled          ;20
        dw      offset Not_WOW_Handled          ;21
        dw      offset Not_WOW_Handled          ;22
        dw      offset Not_WOW_Handled          ;23
        dw      offset Not_WOW_Handled          ;24
        dw      offset Not_WOW_Handled          ;25
        dw      offset Not_WOW_Handled          ;26
        dw      offset Not_WOW_Handled          ;27
        dw      offset Not_WOW_Handled          ;28
        dw      offset Not_WOW_Handled          ;29
        dw      offset QuickGetDate             ;2a
        dw      offset Not_WOW_Handled          ;2b
        dw      offset Not_WOW_Handled          ;2c
        dw      offset Not_WOW_Handled          ;2d
        dw      offset Not_WOW_Handled          ;2e
        dw      offset Not_WOW_Handled          ;2f
        dw      offset Not_WOW_Handled          ;30
        dw      offset Not_WOW_Handled          ;31
        dw      offset Not_WOW_Handled          ;32
        dw      offset Not_WOW_Handled          ;33
        dw      offset Not_WOW_Handled          ;34
        dw      offset Not_WOW_Handled          ;35
        dw      offset Not_WOW_Handled          ;36
        dw      offset Not_WOW_Handled          ;37
        dw      offset Not_WOW_Handled          ;38
        dw      offset Not_WOW_Handled          ;39
        dw      offset Not_WOW_Handled          ;3a
        dw      offset QuickSetCurrentDirectory ;3b
        dw      offset QuickCreate              ;3c
        dw      offset QuickOpen                ;3d
        dw      offset QuickClose               ;3e
        dw      offset QuickRead                ;3f
        dw      offset Quickwrite               ;40
        dw      offset QuickDelete              ;41
        dw      offset QuickLSeek               ;42
        dw      offset QuickGetSetAttributes    ;43
        dw      offset QuickDeviceIOCTL         ;44
        dw      offset Not_WOW_Handled          ;45
        dw      offset Not_WOW_Handled          ;46
        dw      offset QuickGetCurrentDirectory ;47
        dw      offset Not_WOW_Handled          ;48
        dw      offset Not_WOW_Handled          ;49
        dw      offset Not_WOW_Handled          ;4a
        dw      offset Not_WOW_Handled          ;4b
        dw      offset Not_WOW_Handled          ;4c
        dw      offset Not_WOW_Handled          ;4d
        dw      offset QuickFindFirstFile       ;4e
        dw      offset QuickFindNextFile        ;4f
        dw      offset Not_WOW_Handled          ;50
        dw      offset Not_WOW_Handled          ;51
        dw      offset Not_WOW_Handled          ;52
        dw      offset Not_WOW_Handled          ;53
        dw      offset Not_WOW_Handled          ;54
        dw      offset Not_WOW_Handled          ;55
        dw      offset Not_WOW_Handled          ;56
        dw      offset QuickFileDateTime        ;57
        dw      offset Not_WOW_Handled          ;58
        dw      offset QuickExtendedError       ;59
        dw      offset Not_WOW_Handled          ;5a
        dw      offset Not_WOW_Handled          ;5b
        dw      offset QuickLock                ;5c

ifdef IGROUP_HAS_ENOUGH_ROOM
        dw      offset Not_WOW_Handled          ;5d
        dw      offset Not_WOW_Handled          ;5e
        dw      offset Not_WOW_Handled          ;5f
        dw      offset Not_WOW_Handled          ;60
        dw      offset Not_WOW_Handled          ;61
        dw      offset Not_WOW_Handled          ;62
        dw      offset Not_WOW_Handled          ;63
        dw      offset Not_WOW_Handled          ;64
        dw      offset Not_WOW_Handled          ;65
        dw      offset Not_WOW_Handled          ;66
        dw      offset Not_WOW_Handled          ;67
        dw      offset Not_WOW_Handled          ;68
        dw      offset Not_WOW_Handled          ;69
        dw      offset Not_WOW_Handled          ;6a
        dw      offset Not_WOW_Handled          ;6b
        dw      offset Not_WOW_Handled          ;6c
        dw      offset Not_WOW_Handled          ;6d
        dw      offset Not_WOW_Handled          ;6e
        dw      offset Not_WOW_Handled          ;6f
        dw      offset Not_WOW_Handled          ;70
        dw      offset QuickLFNApiCall          ;71

QD_LAST equ     71h

else

QD_LAST equ     5ch
QD_LFNAPI equ   71h

endif


QuickDispatchAddr       dw      ?
endif

sEnd    DATA

sBegin  CODE

;-----------------------------------------------------------------------;
;                                                                       ;
;                       Interrupt 21h handler.                          ;
;                                                                       ;
;-----------------------------------------------------------------------;

labelFP <PUBLIC,Int21Handler>

;-----------------------------------------------------------------------;
; Int21Entry                                                            ;
;                                                                       ;
; The is the dispatcher for our INT 21h handler.                        ;
;                                                                       ;
; Arguments:                                                            ;
;                                                                       ;
; Returns:                                                              ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;                                                                       ;
; Calls:                                                                ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Mon 07-Aug-1989 23:48:06  -by-  David N. Weise  [davidw]             ;
; Made it use a jump table!!                                            ;
;                                                                       ;
;  Thu Apr 16, 1987 07:44:19p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.                                       ;
;-----------------------------------------------------------------------;

        assumes ds, nothing
        assumes es, nothing

cProc   Int21Entry,<PUBLIC,NEAR>
cBegin nogen
        push    ds
        SetKernelDS
        cmp     fInt21, 0
        je      not_me
        pop     ds
        UnSetKernelDS
        inc     bp
        push    bp
        mov     bp, sp
        push    ds
        push    bx                      ; Will be exchanged later
        SetKernelDS
        cmp     ah,12h
        jbe     dont_reset_InDOS
        mov     Kernel_InDOS,0
        mov     Kernel_InINT24,0
dont_reset_InDOS:
        cmp     Kernel_InDOS,0
        jz      not_in_INT24
        mov     kernel_InINT24,1
not_in_INT24:
ifndef WOW ; FOR WOW All the Profile Stuff is handled by Win 32
        ;** On every DOS call, the profile string buffers may become stale
        ;**     in case the app does a DOS call on the INI file.
        ;**     We set the stale profile file and on the next profile read
        ;**     or write, we will check to see if the file is dirty.
        ;**     27-Nov-1991 [JonT]
        mov     ds:[fProfileMaybeStale], 1

        ;** In a similar situation to the above, DOS calls done after
        ;**     profile string calls but before task switches may depend on
        ;**     the data being flushed to the INI file from the buffer.
        ;**     So, here we do a fast check to see if the profile buffers
        ;**     have unflushed information.  If they do, we flush them.
        ;**     Note that 2 is PROUNCLEAN taken from UP.C
        ;**     27-Nov-1991 [JonT]
        test    WinIniInfo.ProFlags, 2          ;Win.INI dirty?
        jnz     I21_Flush_It                    ;Yes, flush it
        test    PrivateProInfo.ProFlags, 2      ;Private profile dirty?
        jz      I21_Done_Flushing               ;No. Neither.

        ;** When writing out profiles we trash pretty much all the registers
        ;**     and since we can't do this for a DOS call, we save everything
I21_Flush_It:
        cmp     fWriteOutProfilesReenter, 0     ;Ignore if reentering
        jne     I21_Done_Flushing               ;  because of profile strings
        pusha
        push    es
        .386
        push    fs
        push    gs
        cCall   WriteOutProfiles
        pop     gs
        pop     fs
        .286p
        pop     es
        popa
endif ; NOT WOW
I21_Done_Flushing:

        mov     bx, CODEOffset PassOnThrough
        cmp     ah,TableEnd                     ; Table is for call 0Eh to 6ch
        ja      let_it_go
        cmp     ah, 0Eh
        jb      let_it_go
        mov     bh, 0
        mov     bl, ah
        add     bx, bx                          ; Word index in bx
        mov     bx, word ptr DosTrap1[bx][-0Eh*2]
let_it_go:
        xchg    bx, [bp-4]                      ; 'pop bx' and push proc addr
        mov     ds, [bp-2]                      ; Restore DS
        UnSetKernelDS
ifdef WOW ; always want to avoid sti in WOW
        push    ax
        pushf
        pop     ax
        test    ah, 2
        pop     ax
        jnz     short ints_are_enabled
endif ; WOW
        FSTI
ints_are_enabled:
        ret
not_me:
        pop     ds
;;;     jmp     prevInt21Proc
        call    real_dos
        retf    2
cEnd nogen

;-----------------------------------------------------------------------;
; not_supported
;
;
; Entry:
;
; Returns:
;
; Registers Destroyed:
;
; History:
;  Sun 06-Aug-1989 13:26:19  -by-  David N. Weise  [davidw]
; Wrote it!
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   not_supported,<PUBLIC,NEAR>
cBegin nogen
        jmps    PassOnThrough
;;;     cmp     ah,55h
;;;     jnz     @F
;;;     jmp     PassOnThrough
;;;@@:  int     3
cEnd nogen


;-----------------------------------------------------------------------;
; PassOnThrough                                                         ;
;                                                                       ;
; This doesn't quite pass on through anymore.  It calls down to DOS.    ;
; In this fashion we know when we are in DOS.  In addition this routine ;
; does the delayed binding of DOS variables after task switches.        ;
;                                                                       ;
; Arguments:                                                            ;
;                                                                       ;
; Returns:                                                              ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;                                                                       ;
; Calls:                                                                ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Sun 25-Mar-1990 15:31:49  -by-  David N. Weise  [davidw]             ;
; added the check for 2Fh, GetDTA, so that the correct one is gotten!   ;
;                                                                       ;
;  Tue Feb 03, 1987 10:32:25p  -by-  David N. Weise   [davidw]          ;
; Put in the delayed binding of DOS variables.                          ;
;                                                                       ;
;  Tue Feb 03, 1987 10:26:01p  -by-  David N. Weise   [davidw]          ;
; Rewrote it and added this nifty comment block.                        ;
;-----------------------------------------------------------------------;

        assumes ds, nothing
        assumes es, nothing

f_iret:
        FIRET

cProc   PassOnThrough,<PUBLIC,NEAR>
cBegin nogen

        SetKernelDS
        test    Kernel_Flags,KF_restore_disk
        jnz     maybe_restore_disk

PUBLIC final_call_for_DOS
final_call_for_DOS:
        pop     ds
        UnSetKernelDS
        push    [bp][6]
        and     [bp][-2],NOT CPUF_TRAP
        popf                            ; Correct input flags back in flags
        pop     bp
        dec     bp
        call    real_DOS
        push    bp                      ; pass back the correct flags
        mov     bp,sp
        pushf
        pop     [bp][6]
ifdef WOW
        test    [bp][6], 200h           ; Interrupts on?
        pop     bp
        jnz     short no_sti
else
        pop     bp
endif
        FSTI
no_sti:
        jmp     f_iret

maybe_restore_disk:

; Note, caller's DS is on stack, current DS == kernel DS

        cmp     ah,2Fh                  ; get DTA, don't hit disk but
        jz      OnThrough               ;  DTA must be set correctly!

        cmp     ah,29h                  ; for system calls 29h -> 30h ....
        jb      OnThrough
        cmp     ah,30h                  ; don't restore directory...
        jbe     final_call_for_DOS              ; ...they don't hit disk

        cmp     ah,3Fh                  ; file handle read
        jz      final_call_for_DOS
        cmp     ah,40h                  ; file handle write
        jz      final_call_for_DOS
        cmp     ah,50h                  ; for system calls 50h -> 51h ....
        jz      final_call_for_DOS
        cmp     ah,51h                  ; don't restore directory...
        jz      final_call_for_DOS              ; ...they don't hit disk

; restore the DOS environment

OnThrough:
        push    ax
        push    bx
        push    dx
        push    es

        SetKernelDS     es
        cmp     [CurTDB], 0
        je      DeadTDB
        and     Kernel_Flags,NOT KF_restore_disk
        mov     ds,[CurTDB]
        cmp     ds:[TDB_sig],TDB_SIGNATURE
        jz      @F
DeadTDB:
        jmp     done_restoring_dos
@@:

; restore DTA

        mov     ax,ds:[TDB_DTA].sel
        mov     dx,ds:[TDB_DTA].off
        cmp     dx,curDTA.off
        jnz     restore_DTA
        cmp     ax,curDTA.sel
        jz      dont_restore_DTA
restore_DTA:
        mov     curDTA.sel,ax
        mov     curDTA.off,dx
        push    ds
        mov     ds,ax
        mov     ah,1Ah
        call    real_DOS
        pop     ds
dont_restore_DTA:


; restore drive and directory

;-----------------------------------------------------------------------;
; We now need to perform a little check.                                ;
; On DOS >= 3.20 it is possible that the phantom drive state            ;
; has changed since we stored this tasks current drive and current      ;
; directory in his task header. UNDER NO CIRCUMSTANCES do we want       ;
; to SetDrive or CHDIR on a phantom drive if the first level of hooks   ;
; are in (to allow this results in the "Please Insert Disk..." message) ;
; so we check out the SetDrive drive number.                            ;
; If it is phantom we will NOT restore drive or directory.              ;
;-----------------------------------------------------------------------;

        xor     dx,dx
        mov     dl,ds:[TDB_Drive]
        and     dl,01111111b
        mov     bx,dx                   ; Index into PhantArray
        CheckKernelDS   es
        cmp     byte ptr PhantArray[bx],0
        jnz     done_restoring_dos

no_drive_check:

        mov     ax,ds
        cmp     ax,cur_drive_owner
        jz       hasnt_been_changed

        inc     InScheduler             ; prevent Int 24h dialog boxes

        lar     ax, cur_drive_owner     ; Ensure we have valid TDB
        jnz     restore_dos             ; in cur_drive_owner
        test    ah, DSC_PRESENT
        jz      restore_dos
        lsl     ax, cur_drive_owner
        cmp     ax, TDBsize-1
        jb      restore_dos
        push    es
        mov     es, cur_drive_owner
        UnsetKernelDS   es
        cmp     es:[TDB_sig], TDB_SIGNATURE
        jne     restore_dos0            ; Dead TDB, can't compare
        mov     al, es:[TDB_Drive]
        ; these messages allow to track current drive problems
        ; krDebugOut DEB_WARN, "Current Drive Owner: #ES Current TDB #DS"
        ; krDebugOut DEB_WARN, "Current Drive Owner: Drive #AX"
        ; krDebugOut DEB_WARN, "Current TDB: Drive #DX"
        and     al,01111111b
        cmp     al, dl
        jne     restore_dos0            ; Drive the same?

        push    cx                      ; Compare directories
        push    si
        push    di
        mov     si, TDB_LFNDirectory
        mov     di, si
        xor     al, al                  ; Scan for end of string
        mov     cx, size TDB_LFNDirectory
        cld
        ; Current drive problem trace
        ; krDebugOut DEB_WARN, "Current Drive Owner: @es:di / Current TDB: @ds:si"
        repne   scasb
        mov     cx, di                  ; Calculate length
        sub     cx, si

        mov     di, si
        rep     cmpsb
        pop     di
        pop     si
        pop     cx
        pop     es
        ResetKernelDS   es
        jnz     restore_directory       ; We know the drive is the same
        jmps    have_new_owner


restore_dos0:
        pop     es
restore_dos:
        mov     ah,0Eh
        call    real_DOS                ; select the disk

restore_directory:
        mov     dx,TDB_LFNDirectory

        ; current directory problem trace
        ; krDebugOut DEB_WARN, "Restoring directory @ds:dx"

        mov     ah,3Bh
        call    real_DOS                ; change directory

have_new_owner:
        dec     InScheduler             ; allow int 24's
        mov     cur_drive_owner,ds

hasnt_been_changed:

done_restoring_dos:

        ; current drive/dir problem trace
        ; krDebugOut DEB_WARN, "Done restoring dos"

        pop     es
        UnSetKernelDS   es
        pop     dx
        pop     bx
        pop     ax
        jmp     final_call_for_DOS

cEnd nogen


;-----------------------------------------------------------------------;
; real_DOS                                                              ;
;                                                                       ;
; Calls the real DOS.                                                   ;
;                                                                       ;
; Arguments:                                                            ;
;                                                                       ;
; Returns:                                                              ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;                                                                       ;
; Calls:                                                                ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Mon 07-Aug-1989 23:45:48  -by-  David N. Weise  [davidw]             ;
; Removed WinOldApp support.                                            ;
;                                                                       ;
;  Mon Apr 20, 1987 07:59:00p  -by-  R. O.           [      ]           ;
; Set cur_dos_PDB when we call DOS to change it, for efficiency.        ;
;                                                                       ;
;  Sun Jan 11, 1987 07:18:19p  -by-  David N. Weise  [davidw]           ;
; Put the per task maintenance of ^C here instead of in the switcher.   ;
;                                                                       ;
;  Sun Jan 04, 1987 01:19:16p  -by-  David N. Weise  [davidw]           ;
; Wrote it.                                                             ;
;-----------------------------------------------------------------------;

        assumes ds, nothing
        assumes es, nothing

cProc   far_real_dos,<PUBLIC,FAR>
cBegin nogen
        call    real_dos
        ret
cEnd nogen

cProc   real_dos,<PUBLIC,NEAR>
cBegin nogen
        pushf
        push    ds
        SetKernelDS
        mov     Kernel_InDOS,1

        push    bx
if KDEBUG
        cmp     ah, 50h                 ; SET PSP
        jne     OK_PDB                  ; No, all's fine
        cmp     bx, Win_PDB             ; It is Win_PDB, isn't it?
        je      OK_PDB
        int 3
        int 3
OK_PDB:
endif
        mov     bx, Win_PDB
        cmp     bx, cur_dos_PDB
        je      PDB_ok

        push    ax
        mov     cur_dos_PDB,bx
ifdef W_Q21
        call    SetPDBForDOS
else

        mov     ah,50h
        pushf
        call    cs:prevInt21Proc        ; JUMP THROUGH CS VARIABLE
endif ; W_Q21
        pop     ax


PDB_OK:
        pop     bx


ifdef TraceInt21  ; <<< Only Useful when debugging fileio routine >>>

        test    fBooting,1
        jnz     @f

        krDebugOut DEB_WARN, "DOS Call        #AX bx #BX cx #CX dx #DX"

        cmp     ah,3dh                  ; Open ?
        jnz     @f

        pop     ds                      ; USERs DS
        push    ds
        UnSetKernelDS

        krDebugOut DEB_WARN,"Opening File @DS:DX"

        SetKernelDS
@@:

        cmp     ah,3ch                  ; Create ?
        jnz     @f

        pop     ds                      ; USERs DS
        push    ds
        UnSetKernelDS

        krDebugOut DEB_WARN,"Creating File @DS:DX"

        SetKernelDS
@@:

endif


ifdef W_Q21
;   If we are the running in protected mode then there is no need to
;   switch to v86 mode and then to call the DOSKrnl for most Int 21
;   operations - since mode switches are slow and DOSX has to read
;   into a buffer in low memory and copy it high.   Since we just want
;   to call the Win32 file system we can stay in protected mode.
;   For some DOS calls which don't happen very frequently we don't
;   bother intercepting them.

        cmp     ah,59h                  ; GetExtendedError ?
        jz      short @f
        ; SetDosErr 0h
        mov     WOWLastError,0h
@@:

;-----------------------------------------------------------------------------
; Dispatch code for WOW quick entry points
;-----------------------------------------------------------------------------

        cmp     ah, QD_FIRST
        jb      really_call_dos
        cmp     ah, QD_LAST
        ja      really_call_dos
        push    bx
        xor     bh, bh
        mov     bl, ah
        sub     bx, QD_FIRST
        shl     bx, 1
        mov     bx, QuickDispatchTable[bx]
        mov     QuickDispatchAddr, bx
        pop     bx
        jmp     word ptr QuickDispatchAddr

really_call_dos:

ifndef IGROUP_HAS_ENOUGH_ROOM
        cmp     ah, QD_LFNAPI
        je      QuickLFNApiCall
endif

        jmp     Not_WOW_Handled

;-----------------------------------------------------------------------------
; WOW quick entry points
;-----------------------------------------------------------------------------

QuickLFNApiCall:
        ; first, we emulate dos to reduce size of 32-bit required processing
        ; then we don't care for many other fun things like retrying anything
        ; through dos as we call into dem from here and thus result is
        ; likely to be the same

        ; this is a place-holder for user flags - see demlfn.c for details
        pushf

        push ES

        ; next goes user ds - we need to get it off the stack - it however is
        ; already there... we need to replicate it's value somehow

        push ax ; there will it be - bogus value for now
                ; could have been a sub sp, 2

        push bp
        push di
        push si
        push dx
        push cx
        push bx
        push ax
        mov bx, sp
        mov dx, ss:[bx+20] ; dx - user ds
        mov ss:[bx + 14], dx ; shove user ds into the right place

        ; this call takes ss:sp as a pointer to a dos-like user stack frame
        ;

        cCall WOWLFNEntry,<ss, bx>

        ; return is dx:ax, where ax is non-zero for errors and
        ; dx is 0xffff for hard error
        ; if hard error case is encountered, the procedure turns to
        ; "real dos" then, allowing for int24 to be fired properly
        ; To continue in real_dos we need to restore regs
        ; dem does not touch registers on failed calls thus
        ; we can pop them off the stack and continue
        ;
        SetDosErr ax
        ; mov WOWLastError, ax

        ; resulting flags are :
        ;   - if no carry then no error
        ;   - if carry then error
        ;      - if zero then harderror


        pop ax ; restore ax
        pop bx ;
        pop cx
        pop dx
        pop si
        pop di

        ; here we need to preserve flags so they stay after the stack
        ; adjustment
        add sp, 6 ; the rest are not important to retrieve

        ; now get the mod flags
        popf

        .386
        jnc QuickDone

        ; carry - this is an error

        jz Not_WoW_Handled ; if zero - hard error there

        ; here zero is not set - the just return error

        .286p

        ; here is error condition to be returned to the app

        ; restore error code and return to the app
        mov ax, WOWLastError
        jmp QerrRet


QuickDelete:
        push    dx
        push    bx
        push    ax
        mov     bx,sp
        mov     bx,ss:[bx + 6]  ; BX = USER DS

        cCall   WOWDelFile,<BX,DX>

;       DX = FFFF, AX = Error Code      if failure
;       AX = 0                          if success

        inc     dx
        jnz     qdf_ok

        jmp     DoDos

qdf_ok:
        pop     ax
        pop     bx
        pop     dx
        jmp     QuickDone

        regptr  cxdx,cx,dx
        regptr  axdx,ax,dx

QuickExtendedError:

        ; CheckDosErr
        cmp     WOWLastError, 0
        jnz     DoExtendedError
        jmp     Not_WOW_Handled

DoExtendedError:
        GetDosErr ax, ch, bl, bh
        ; mov     ax,WOWLastError ;load values for extended error
        ; mov     bh,WOWErrClass
        ; mov     bl,WOWErrAction
        ; mov     ch,WOWErrLocation ; location
        jmp     QuickDone

QuickGetDate:
        cCall   WowGetCurrentDate
        push    dx                              ;year
        mov     dl, ah                          ;monthday
        mov     ah, al                          ;
        mov     cl, 4                           ;shift count
        shr     ah, cl
        mov     dh, ah                          ;month
        and     al, 0fh                         ;weekday
        mov     ah, 2ah                         ;reload ah
        pop     cx                              ;cx is now the year
        jmp     QuickDone


QuickGetDefaultDrive:
        call    GetDefaultDriveFromDOS
        mov     CurDOSDrive, al
        jmp     QuickDone

GetDefaultDriveFromDOS:
        push    di
        push    es
        les     di, pPMDosCURDRV
        mov     al, byte ptr es:[di]            ;get drive number from DOS

        ; GetDefaultDriveFromDos trace
        ; pusha
        ; xor     ah, ah
        ; krDebugOut DEB_WARN, "GetDefaultDriveFromDos: ret #ax"
        ; popa

        pop     es
        pop     di
        ret

QuickSetPSPAddress:
        call    SetPDBForDOS
        jmp     QuickDone

SetPDBForDOS:
        push    es
        push    di
        push    cx
        push    dx
        push    bx

        DPMICALL 0006h                  ; Get physical address

        mov     bx,cx                   ; hiword of address
        mov     cx,4                    ; shift count
        shr     dx,cl
        mov     cx,12                   ; for high nibble
        shl     bx,cl
        or      dx,bx                   ; now real mode segment

        les     di, pPMDosPDB           ; get pointer to PDB in DOS
        mov     word ptr es:[di],dx     ; set new PDB

        pop     bx
        pop     dx
        pop     cx
        pop     di
        pop     es
        ret

QuickSetDefaultDrive:
        push    dx
        push    ax

        call    GetDefaultDriveFromDOS
        cmp     dl, al                          ;doing a NOP?
        jz      short @f                        ;yes, skip call to WOW

        cCall   WowSetDefaultDrive,<DX>

        mov     CurDOSDrive, al                 ;returned from SetDefaultDrive
@@:
        pop     ax
        mov     al, 26                          ;this is what DOS does
        pop     dx
        jmp     QuickDone

QuickGetCurrentDirectory:
        push    ax
        push    dx
        push    bx
        mov     bx,sp
        mov     bx,ss:[bx + 6]  ; BX = USER DS

        cCall   WowGetCurrentDirectory,<DX,BX,SI>

        pop     bx
        inc     dx                              ;DX=FFFF on error
        pop     dx
        jz      short qgcd_err                  ;jif error
        pop     ax
        mov     al, 0                           ;this is what DOS does
        jmp     QuickDone

QuickSetCurrentDirectory:
        push    ax
        push    dx
        push    bx
        mov     bx,sp
        mov     bx,ss:[bx + 6]  ; BX = USER DS

        cCall   WowSetCurrentDirectory,<BX,DX>

        pop     bx
        inc     dx                              ;DX=FFFF on error
        pop     dx
        jz      short qgcd_err                  ;jif error
        pop     ax
        mov     al, 0                           ;BUGBUG is this what DOS does?
        jmp     QuickDone

qgcd_err:
        add     sp, 2                           ;leave error code in AX
        SetDosErr ax, 9, 1ch, 1
        ; mov     WOWLastError,ax                ;use this for filefind errors
        ; mov     WOWErrClass,1                   ;this is what DOS seems to do
        ; mov     WOWErrAction,1ch
        ; mov     WOWErrLocation,9
        jmp     QErrRet

QuickDeviceIOCTL:
        cmp     al, 8                           ;removeable media only
        jz      short @f
        jmp     Not_WOW_Handled
@@:
        push    dx

        cCall   WowDeviceIOCTL,<BX,AX>

        inc     dx
        pop     dx
        jnz     short @f
        jmp     QErrRet
@@:
        jmp     QuickDone


QuickFindFirstFile:
        push    dx
        push    bx
        push    si
        push    di
        mov     si, curDTA.sel
        mov     di, curDTA.off
        mov     bx,sp
        mov     bx,ss:[bx + 8]  ; BX = USER DS

ifdef TraceInt21  ; <<< Only Useful when debugging fileio routine >>>

        test    fBooting,1
        jnz     @f

        mov     ds,bx                ; USERs DS
        UnSetKernelDS
        krDebugOut DEB_WARN, "QuickFindFirstFile looking for @DS:DX"
        SetKernelDS
@@:
endif

        cCall   WowFindFirst,<CX,BX,DX,SI,DI>

ifdef TraceInt21  ; <<< Only Useful when debugging fileio routine >>>

        or      ax, ax
        jnz     @f
        mov     bx, curDTA.off
        mov     si, curDTA.sel
        mov     ds, si
        UnSetKernelDS
        mov     si, bx
        mov     bx, 18h
        mov     di, [si+bx]
        mov     bx, 16h
        mov     dx, [si+bx]
        mov     bx, 1Eh
        add     bx, si
        krDebugOut DEB_WARN, "QuickFindFirstFile found @DS:BX, date #DI, time #DX"
        mov     bx, 1Ah
        mov     di, [si+bx]
        mov     bx, 1Ch
        mov     dx, [si+bx]
        mov     bx, 15h
        mov     bl, [si+bx]
        xor     bh, bh
        krDebugOut DEB_WARN, "                     attribute #BX size #DX:#DI"
        SetKernelDS
@@:
endif

        pop     di
        pop     si
        pop     bx
        pop     dx
        or      ax, ax
        jnz     qfErr
        jmp     QuickDone

QuickFindNextFile:
        push    si
        push    di

        mov     si, curDTA.sel
        mov     di, curDTA.off
        cCall   WowFindNext,<SI,DI>
        pop     di
        pop     si
        or      ax, ax
        jnz     qfErr
        jmp     QuickDone
qfErr:
        SetDosErr ax,2,3,8
        ; mov     WOWLastError,ax                ;use this for filefind errors
        ; mov     WOWErrClass,8
        ; mov     WOWErrAction,3  ; file or item not found, prompt user
        ; mov     WOWErrLocation,2 ; location is block device

        krDebugOut DEB_WARN, "QFindErr: #AX"

        jmp     QErrRet

QuickLSeek:
        push    dx
        push    bx
        push    ax

        xor     ah,ah
        cCall   WowFileLSeek,<BX,CXDX,AX,cur_dos_PDB,0,pFileTable>

;       DX:AX = File Position           if success
;       DX = FFFF, AX = Error Code      if failure

        inc     dx
        jnz     LSeekFinish
        jmp     DoDos
LSeekFinish:
        dec     dx
        add     sp,6
        jmp     QuickDone

QuickCreate:
        push    dx
        push    bx
        push    ax

        test    cx, 8           ; ATTR_VOLUME?
        jz      short @f        ; no, ok
        jmp     DoDos           ; yes, not supported in wow32
@@:

        mov     bx,sp
        mov     bx,ss:[bx + 6]  ; BX = USER DS
        cCall   WowFileCreate,<CX,BX,DX,cur_dos_PDB,0,pFileTable>

;       AX = FileHandle                 if success
;       AX = FFFF                       if path was a device
;       DX = FFFF, AX = Error Code      if failure

        cmp     ax,0FFFFh
        jnz     short @f        ;
        jmp     DoDos           ; Device case, just go through DOS
@@:
        inc     dx              ; Set the zero flag on error.
        jz      QOpenError      ;   Error occured
        add     sp,2            ; discard AX
        pop     bx
        pop     dx
ifdef TraceInt21
        jmp     QuickDone       ; Success
else
        jmp     QuickDone       ; Success
endif

QuickOpen:
        push    dx
        push    bx
        push    ax

        mov     bx,sp
        mov     bx,ss:[bx + 6]  ; BX = USER DS
        xor     ah,ah           ; clear AH leaving file-access in AX
        cCall   WowFileOpen,<BX,DX,AX,cur_dos_PDB,0,pFileTable>

;       AX = FileHandle                 if success
;       AX = FFFF                       if path was a device
;       DX = FFFF, AX = Error Code      if failure

        cmp     ax,0FFFFh
ifdef TraceInt21
        jnz     @f
        jmp     DoDos
@@:
else
        .386
        jz      DoDos           ; Device case, just go through DOS
        .286p
endif
        inc     dx              ; Set the zero flag on error.
        jz      QOpenError      ;   Error occured
        add     sp,2            ; discard AX
        pop     bx
        pop     dx
        jmps    QuickDone       ; Success

QOpenError:
        cmp     ax, 3           ; If the error is not file_not_found or path_not_found
ifdef TraceInt21
        jbe     @f
        jmp     DoDos
@@:
else
        .386
        ja      DoDos           ; then go through DOS again for the open.
        .286p
endif
        cmp     ax, 2
        jb      DoDos

        SetDosErr ax,2,3,8
        ; mov     WOWLastError,ax
        ; mov     WOWErrClass,8
        ; mov     WOWErrAction,3  ; file or item not found, prompt user
        ; mov     WOWErrLocation,2 ; location is block device

        add     sp,2            ; discard saved AX, since AX = Error Code
        pop     bx
        pop     dx
QErrRet:
ifdef TraceInt21
        krDebugOut DEB_WARN, "Q21 fails    AX #AX bx #BX cx #CX dx #DX (t)"
endif
        pop     ds
        popf
        stc                     ; Set Carry = ERROR
        ret

QuickRead:
        pop     ax              ; AX = USER DS
        push    ax
        push    dx                      ; save user pointer
        cCall   WowFileRead,<BX,AXDX,0,CX,cur_dos_PDB,0,pFileTable>

;       AX = Number Bytes Read
;       DX = FFFF, AX = Error Code

        inc     dx
        pop     dx              ; restore user pointer
        jz      QRError
QuickDone:
ifdef TraceInt21
        krDebugOut DEB_WARN, "Q21 succeeds AX #AX bx #BX cx #CX dx #DX (t)"
endif
        pop     ds
        popf
        clc                     ; Clear Carry - OK Read
        ret

QuickClose:
        push    dx
        push    bx
        push    ax
        cCall   WowFileClose,<BX,cur_dos_PDB,0,pFileTable>

;       DX = FFFF, AX = Error Code      if failure
;       AX = FFFF                       if path was a device

        cmp     ax,0FFFFh
        jz      DoDos           ; Device opens go through DOS
        inc     dx              ; Sets zero flag on error.
        jz      DoDos           ; Let DOS Handle Close Errors
        pop     bx              ; Throw old AX out
        pop     bx
        pop     dx
        mov     ah,3Eh          ; bogus multiplan fix
        jmps    QuickDone       ; Success

DoDos:
        pop     ax
        pop     bx
        pop     dx
        jmp     Not_WOW_Handled

QRError:
        mov     ah,3Fh          ; On Error Retry Operation Via DOEem
        jmp     Not_WOW_Handled

QuickGetSetAttributes:
        cmp     al, 0
        jz      short qget_attr
        cmp     al, 1
        jz      short qset_attr
        jmp     Not_WOW_Handled

qget_attr:
        push    dx
        push    bx
        push    ax

        mov     bx,sp
        mov     bx,ss:[bx + 6]  ; BX = USER DS
        cCall   WowFileGetAttributes,<BX,DX>

;       AX = Attributes                 if success
;       DX = FFFF, AX = Error Code      if failure

        inc     dx
        jz      DoDos           ; if failure retry through DOS
        mov     cx,ax           ; move result into CX
        pop     ax
        pop     bx
        pop     dx
        jmp     QuickDone

qset_attr:
        push    dx
        push    bx
        push    ax

        mov     bx,sp
        mov     bx,ss:[bx + 6]  ; BX = USER DS
        cCall   WowFileSetAttributes,<CX,BX,DX>

;       DX = FFFF, AX = Error Code      if failure

        inc     dx
        jz      DoDos           ; if failure retry through DOS
        pop     ax
        pop     bx
        pop     dx
        jmp     QuickDone


QuickFileDateTime:
        cmp     al, 0
        jz      short qget_datetime
        cmp     al, 1
        jz      short qset_datetime
        jmp     Not_WOW_Handled

qget_datetime:
        push    dx
        push    bx
        push    ax
        cCall   WowFileGetDateTime,<BX,cur_dos_PDB,0,pFileTable>

;       AX = Time, DX = Date            if success
;       AX = FFFF                       if failure

        cmp     ax,0FFFFh
        jz      DoDos
        mov     cx,ax
        pop     ax
        pop     bx
        add     sp,2            ; throw away saved DX
        jmp     QuickDone

qset_datetime:
        push    dx
        push    bx
        push    ax
        cCall   WowFileSetDateTime,<BX,CX,DX,cur_dos_PDB,0,pFileTable>

;       AX = 0                          if success
;       AX = FFFF                       if failure

        cmp     ax,0FFFFh
        jnz     short @f
        jmp     DoDos
@@:
        pop     ax
        pop     bx
        pop     dx
        jmp     QuickDone

QuickLock:
        push    dx
        push    bx
        push    ax
        cCall   WowFileLock,<AX,BX,CX,DX,SI,DI,cur_dos_PDB,0,pFileTable>

;       DX = FFFF, AX = Error Code      if failure
;       AX = 0                          if success

        inc     dx
        jnz     FinishLock
        cmp     ax, 21h                 ;is this lock violation?
        jz      short @f                ;yes, give it back to app
        jmp     DoDos
@@:
        add     sp,2            ; discard saved AX, since AX = Error Code
        pop     bx
        pop     dx
        SetDosErr ax,2,2,10
       ; mov     WOWLastError,ax
       ; mov     WOWErrClass,10          ;ext. err info for lock violation
       ; mov     WOWErrAction,2
       ; mov     WOWErrLocation,2
        jmp     QErrRet

FinishLock:
        add     sp,2            ; throw out old AX
        pop     bx
        pop     dx
        jmp     QuickDone

QuickWrite:
        pop     ax              ; AX = USER DS
        push    ax
        push    dx
        cCall   WowFileWrite,<BX,AXDX,0,CX,cur_dos_PDB,0,pFileTable>

;       AX = Number Bytes Read
;       DX = FFFF, AX = Error Code

        inc     dx
        pop     dx              ; restore user pointer
        jz      RetryWrite
        jmp     QuickDone

RetryWrite:
        mov     ah,40h          ; On Error Retry Operation Via DOEem

;-----------------------------------------------------------------------------
; END OF WOW quick entry points
;-----------------------------------------------------------------------------

Not_WOW_Handled:
endif  ; W_Q21

;
; Intercept Select Disk and Get Current Disk
;
        cmp     ah, 0Eh
        je      rd_Select
        cmp     ah, 19h
        je      rd_Get
rd_no_intercept:

;;;     test    Kernel_flags,kf_restore_CtrlC
;;;     jz      no_need_to_set_CtrlC
;;;     and     Kernel_flags,not kf_restore_CtrlC
;;;
;;;     push    ax
;;;     push    bx
;;;     push    es
;;;     mov     es,curTDB
;;;     cmp     es:[TDB_sig],TDB_SIGNATURE
;;;     jne     PDB_okay
;;;
; restore PDB
;;;
;;;     mov     bx,Win_PDB
;;;     cmp     bx,cur_dos_PDB
;;;     jz      PDB_okay
;;;if KDEBUG
;;;     cmp     bx,es:[TDB_PDB]
;;;     jz      @F
;;;     int     1
;;;@@:
;;;endif
;;;     mov     cur_dos_PDB,bx
;;;     mov     ah,50h
;;;     pushf
;;;     call    cs:prevInt21Proc        ; JUMP THROUGH CS VARIABLE
;;;PDB_okay:
;;;
;;;     pop     es
;;;     pop     bx
;;;     pop     ax
;;;no_need_to_set_CtrlC:

        pop     ds
        UnSetKernelDS
        call    cs:prevInt21Proc        ; JUMP THROUGH CS VARIABLE
ifdef TraceInt21
        pushf
        jc      rd_Trace_CarrySet
        krDebugOut DEB_WARN, "DOS succeeds AX #AX bx #BX cx #CX dx #DX"
        jmp     @f
rd_Trace_CarrySet:
        krDebugOut DEB_WARN, "DOS fails    AX #AX bx #BX cx #CX dx #DX"
@@:
        popf
endif
rd_after_DOS:
        push    ds
        SetKernelDS
rd_after_DOS1:
        push    ax
        mov     al,kernel_inINT24
        mov     Kernel_InDOS,al         ; dont change flags!
        pushf
        or      al, al                  ; If in int 24h, don't
        jnz     @F                      ; reset extended error yet
        cmp     LastExtendedError[2],-1 ; Flag to indicate saved status
        je      @F

        push    dx
        lea     dx, LastExtendedError
        mov     ax, 5D0Ah
        pushf
        call    cs:prevInt21Proc
        mov     LastExtendedError[2], -1        ; Forget the status
        pop     dx
@@:
        popf
        pop     ax
        pop     ds
        UnSetKernelDS
        ret

rd_Select:
        ReSetKernelDS
        cmp     dl, CurDOSDrive         ; Setting to current drive?
        jne     rd_invalidate           ;  no, invalidate saved value

        mov     al, DOSDrives           ;  yes, emulate call

rd_intercepted:
        pop     ds                      ; Return from the DOS call
        UnSetKernelDS
        popf
        jmps    rd_after_DOS

rd_invalidate:
        ReSetKernelDS
        mov     CurDOSDrive, 0FFh       ; Invalidate saved drive
        jmps    rd_no_intercept

rd_Get:
        ReSetKernelDS
        cmp     CurDOSDrive, 0FFh       ; Saved drive invalid?
        jne     rd_have_drive           ;  no, return it

        pop     ds                      ;  yes, call DOS to get it
        UnSetKernelDS
        call    cs:prevInt21Proc
        push    ds
        SetKernelDS
        mov     CurDOSDrive, al         ; And save it
        jmps    rd_after_DOS1

rd_have_drive:
        ReSetKernelDS
        mov     al, CurDOSDrive         ; We have the drive, emulate call
        jmps    rd_intercepted          ; and return

cEnd nogen

;**
;
; NoHookDOSCall -- Issue an INT 21 circumventing all Windows Hooks
;
;       This call is provided as a Kernel service to Core routines
;       which wish to issue DOS INT 21h calls WITHOUT the intervention
;       of the Windows INT 21h hooks.
;
;   ENTRY:
;       All registers as for INT 21h
;
;   EXIT:
;       All registers as for particular INT 21h call
;
;   USES:
;       As per INT 21h call
;
;
cProc   NoHookDOSCall,<PUBLIC,FAR>
cBegin
        call    real_DOS
cEnd


;**
;
; DOS3CALL -- Issue an INT 21 for caller
;
;       This call is provided as a Kernel service to applications that
;       wish to issue DOS INT 21h calls WITHOUT coding an INT 21h, which
;       is incompatible with protected mode.
;
;   ENTRY:
;       All registers as for INT 21h
;
;   EXIT:
;       All registers as for particular INT 21h call
;
;   USES:
;       As per INT 21h call
;
;
cProc   DOS3CALL,<PUBLIC,FAR>
cBegin  nogen
        DOSCALL
        retf
cEnd    nogen


sEnd    CODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\ikernel.inc ===
AllocCStoDSAlias	     equ  <IAllocCStoDSAlias>
AllocDStoCSAlias	     equ  <IAllocDStoCSAlias>
FreeSelector		     equ  <IFreeSelector>
ChangeSelector		     equ  <IChangeSelector>
LoadResource		     equ  <ILoadResource>
AccessResource		     equ  <IAccessResource>
FindResource		     equ  <IFindResource>
AllocResource		     equ  <IAllocResource>
FreeResource		     equ  <IFreeResource>
LockResource		     equ  <ILockResource>
SetResourceHandler	     equ  <ISetResourceHandler>
SizeofResource		     equ  <ISizeofResource>
;AddAtom                      equ  <IAddAtom>
DeleteAtom		     equ  <IDeleteAtom>
;FindAtom                     equ  <IFindAtom>
GetAtomName		     equ  <IGetAtomName>
GetAtomHandle		     equ  <IGetAtomHandle>
;Catch                        equ  <ICatch>
;Throw                        equ  <IThrow>
FreeModule		     equ  <IFreeModule>
FreeLibrary		     equ  <IFreeLibrary>
FatalAppExit		     equ  <IFatalAppExit>
GlobalAlloc		     equ  <IGlobalAlloc>
GlobalFree		     equ  <IGlobalFree>
GlobalHandle		     equ  <IGlobalHandle>
GlobalLock		     equ  <IGlobalLock>
GlobalReAlloc		     equ  <IGlobalReAlloc>
GlobalSize		     equ  <IGlobalSize>
GlobalUnlock		     equ  <IGlobalUnlock>
GlobalFlags		     equ  <IGlobalFlags>
GlobalWire		     equ  <IGlobalWire>
GlobalUnWire		     equ  <IGlobalUnWire>
GlobalLRUNewest 	     equ  <IGlobalLRUNewest>
GlobalLRUOldest 	     equ  <IGlobalLRUOldest>
GlobalNotify		     equ  <IGlobalNotify>
GlobalPageLock		     equ  <IGlobalPageLock>
GlobalPageUnlock	     equ  <IGlobalPageUnlock>
GlobalFix		     equ  <IGlobalFix>
GlobalUnfix		     equ  <IGlobalUnfix>
LockSegment		     equ  <ILockSegment>
UnlockSegment		     equ  <IUnlockSegment>
GetWindowsDirectory	     equ  <IGetWindowsDirectory>
GetSystemDirectory	     equ  <IGetSystemDirectory>
MakeProcInstance	     equ  <IMakeProcInstance>
FreeProcInstance	     equ  <IFreeProcInstance>
GetCodeInfo		     equ  <IGetCodeInfo>
GetProcAddress		     equ  <IGetProcAddress>
GetModuleHandle 	     equ  <IGetModuleHandle>
GetModuleUsage		     equ  <IGetModuleUsage>
GetModuleFileName	     equ  <IGetModuleFileName>
GetInstanceData 	     equ  <IGetInstanceData>
GetFreeSpace		     equ  <IGetFreeSpace>
GetTempFileName 	     equ  <IGetTempFileName>
;lstrcpy                      equ  <Ilstrcpy>
;lstrcat                      equ  <Ilstrcat>
;lstrlen                      equ  <Ilstrlen>
_lopen			     equ  <I_lopen>
_lclose 		     equ  <I_lclose>
_lcreat 		     equ  <I_lcreat>
_llseek 		     equ  <I_llseek>
_lread			     equ  <I_lread>
_lwrite 		     equ  <I_lwrite>
LoadLibrary		     equ  <ILoadLibrary>
;LoadModule		     equ  <ILoadModule> ;;; ATM: Can't call internal function
LocalAlloc		     equ  <ILocalAlloc>
LocalFree		     equ  <ILocalFree>
LocalLock		     equ  <ILocalLock>
LocalReAlloc		     equ  <ILocalReAlloc>
LocalSize		     equ  <ILocalSize>
LocalUnlock		     equ  <ILocalUnlock>
LocalFlags		     equ  <ILocalFlags>
LocalNotify		     equ  <ILocalNotify>
OpenFile		     equ  <IOpenFile>
;SwitchStackTo                equ  <ISwitchStackTo>
SetHandleCount               equ  <ISetHandleCount>
SetErrorMode		     equ  <ISetErrorMode>
SwapRecording		     equ  <ISwapRecording>
WinExec 		     equ  <IWinExec>
GetProfileInt		     equ  <IGetProfileInt>
GetProfileString	     equ  <IGetProfileString>
GetPrivateProfileInt	     equ  <IGetPrivateProfileInt>
GetPrivateProfileString      equ  <IGetPrivateProfileString>
WriteProfileString       equ  <IWriteProfileString>
WritePrivateProfileString    equ  <IWritePrivateProfileString>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\i21file.asm ===
title	INT21 - INT 21 handler for scheduler

.xlist
include kernel.inc
include tdb.inc
include pdb.inc
include kdos.inc
ifdef WOW
include vint.inc
endif
.list

externFP FileCDR_notify

DataBegin

externB PhantArray
externB DOSDrives
externB CurDOSDrive
externW curTDB

DataEnd

assumes DS,NOTHING
sBegin	CODE
assumes CS,CODE

;externNP GrowSFT
externNP PassOnThrough
externNP final_call_for_DOS
externNP real_DOS
externNP MyUpper
externNP Int21Handler

ifdef FE_SB
externNP MyIsDBCSLeadByte		    ;near call is fine
endif

externFP ResidentFindExeFile
externFP GetModuleHandle
externFP FlushCachedFileHandle
externFP WOWDelFile

public ASSIGNCALL
public NAMETRANS
public DLDRIVECALL1
public DLDRIVECALL2
public XENIXRENAME
public FCBCALL
public PATHDSDXCALL
public PATHDSSICALL
public SetCarryRet
public SetErrorDrvDSDX


;-----------------------------------------------------------------------;
; Select_Disk		(DOS Call 0Eh)					;
; 									;
; 									;
; Arguments:								;
; 									;
; Returns:								;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Wed Jan 28, 1987 00:40:48a  -by- David N. Weise    [dnw]		;
; Rewrote it.  It used to save and restore the current disk inside of	;
; DOS on task swaps.  Now it will restore on demand.			;
; 									;
;  Sat Jan 17, 1987 08:19:27p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

cProc	Select_Disk,<PUBLIC,NEAR>
cBegin nogen
	SetKernelDS
	cmp	dl, CurDOSDrive		; Must set if not this!
	jne	MustSetIt
					; See if it matches saved drive for TDB
	cmp	[CurTDB], 0		; See if we have a TDB
	je	MustSetIt
	push	es
	mov	es, [CurTDB]
	cmp	es:[TDB_sig], TDB_SIGNATURE
	jne	DeadTDB
	push	ax     
	mov	al, es:[TDB_Drive]
	and	al, 7Fh		  	; Zap save drive flag
	cmp	al, dl			; Drive the same?
	pop	ax
	pop	es			
	jne	MustSetIt		;  no, set it
	mov	al, DOSDrives		; Return number of logical drives
	jmp	DriveErrorRet		; Well, it really just returns!
DeadTDB:
	pop	es
MustSetIt:
	push	dx
	inc	dx			; A=1
	call	CheckDriveDL
	pop	dx
	jnc	cd_no_drive_check
	call	SetErrorDLDrv
	jmp	DriveErrorRet
cEnd nogen


;-----------------------------------------------------------------------;
; Change_Dir		(DOS Call 3Bh)					;
; 									;
; 									;
; Arguments:								;
; 									;
; Returns:								;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Wed Jan 28, 1987 00:40:48a  -by- David N. Weise    [dnw]		;
; Rewrote it.  It used to save and restore the current directory	;
; on task swaps.  Now it will restore on demand.			;
; 									;
;  Sat Jan 17, 1987 08:21:13p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

cProc	Change_Dir,<PUBLIC,NEAR>
cBegin nogen
	call	PathDrvDSDX
	jnc	cd_no_drive_check	; Drive OK
	call	SetErrorDrvDSDX
	jmp	SetCarryRet
cd_no_drive_check:
	SetKernelDS
	mov	ds,CurTDB
	UnSetKernelDS
	cmp	ds:[TDB_sig],TDB_SIGNATURE
	jne	Change_Dir1
	and	ds:[TDB_Drive],01111111b	; indicate save needed
Change_Dir1:
	jmp	PassOnThrough
cEnd nogen


;-----------------------------------------------------------------------;
; FileHandleCall	(DOS Calls 3Eh,42h,45h,46h,57h,5Ch)		;
;									;
; Checks to see if the token in the PDB is 80h.  80h represents a	;
; file that was closed on a floppy by us in order to prompt for a	;
; file (see CloseOpenFiles).  If the token is 80h then it is set	;
; to FFh.								;
; 									;
; Arguments:								;
; 									;
; Returns:								;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Tue Sep 29, 1987 03:30:46p  -by-  David N. Weise      [davidw]	;
; Changed the special token from FEh to 80h to avoid conflict with	;
; Novell netware that starts with SFT FEh and counts down.		;
; 									;
;  Tue Apr 28, 1987 11:12:00a  -by-  Raymond E. Ozzie [-iris-]		;
; Changed to indirect thru PDB to get JFN under DOS 3.x.		;
;									;
;  Sat Jan 17, 1987 01:54:54a  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

cProc	FileHandleCall,<PUBLIC,NEAR>
cBegin nogen
if1
; %OUT    FileHandleCall DISABLED
endif
	jmp	final_call_for_DOS
cEnd nogen


;-----------------------------------------------------------------------;
; Xenix_Status		(DOS Call 44h)					;
; 									;
; 									;
; Arguments:								;
; 									;
; Returns:								;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
;	FileHandleCall							;
;	PassOnThrough							;
; 									;
; History:								;
; 									;
;  Mon 07-Aug-1989 23:45:48  -by-  David N. Weise  [davidw]		;
; Removed WinOldApp support.						;
;									;
;  Sat Jan 17, 1987 10:17:31p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

cProc	Xenix_Status,<PUBLIC,NEAR>
cBegin nogen
	cmp	al,4
	jb	xs1
	cmp	al,7
	jz	xs1
	cmp	al,10
	jz	xs1
	jmp	PassOnThrough

xs1:	jmp	FileHandleCall
cEnd nogen


;********************************************************************
;
; Phantom drive Traps
;
;********************************************************************

;**
;
; AssignCall -- Trap for Define Macro Call 5F03h
;
; ENTRY:
;	Regs for 5F03h except BP is standard INT 21h frame ptr
; EXIT:
;	Through PassOnThrough or Error path if phantom drive detected
; USES:
;	Flags and via DOS if error
;
AssignCall:
	cmp	ax,5F03h		; Only care about 03 call
	jnz	AssignCall_OK
	cmp	bl,4			; With BL = 4 (assign block)
	jnz	AssignCall_OK
	cmp	byte ptr [si],0		; Ignore this special case
	jz	AssignCall_OK
	push	dx
	mov	dx,si
	call	PathDrvDSDX
	pop	dx
	jc	AssignCall_bad
AssignCall_OK:
	jmp	PassOnThrough

AssignCall_bad:
	push	word ptr [si]
	mov	byte ptr [si],'$'	; Bogus drive letter
	call	real_DOS		; Set error
	pop	word ptr [si]		; reset string
	jmp	SetCarryRet


;**
;
; NameTrans -- Trap for NameTrans Call 60h
;
; ENTRY:
;	Regs for 60h except BP is standard INT 21h frame ptr
; EXIT:
;	Through PassOnThrough or Error path if phantom drive detected
; USES:
;	Flags and via DOS if error
;
NameTrans:
	push	dx
	mov	dx,si			; Point with DS:DX to call PathDrvDSDX
	call	PathDrvDSDX
	pop	dx
	jc	@F
	jmp	POTJ1			; Drive OK
@@:
	push	word ptr [si]
	mov	byte ptr [si],'$'	; Bogus drive letter
	call	real_DOS		; DOS sets error
	pop	word ptr [si]		; Restore users drive
	jmp	SetCarryRet		; Error

si_no_good:
	call	SetErrorDrvDSDX 	; Set error
	pop	dx
	jmp	SetCarryRet		; Error

PathDSSICall:				; Simple clone of PathDSDXCall
	push	dx			; but start with offset in SI,
	mov	dx, si			; and we know this is a file open
	call	PathDrvDSDX		; call.
	jc	si_no_good
	pop	dx
	pop	ds
	push	ax
	push	[bp][6]			; Original flags
	push	cs
	mov	ax, codeoffset si_back_here ; Now have IRET frame
	push	ax
	push	[bp]			; Original bp+1
	mov	bp, sp
	mov	ax, [bp][8]
	push	ds
	jmp	PassOnThrough		; Do the DOS call
si_back_here:
	pushf
	inc	bp
	push	bp			; pass back the correct flags
	mov	bp,sp
	xchg	ax, [bp][4]
	jc	@F
	push	dx
	mov	dx, si
	call	FileCDR_notify
	pop	dx
@@:
	push	[bp]
	pop	[bp][6]
	add	sp, 2
	pop	[bp][12]
	pop	ax
	pop	bp
	dec	bp
	jmp	f_iret


;**
;
; PathDSDXCall -- Trap for Calls which point to a path with DS:DX
;
; ENTRY:
;	Regs for call except BP is standard INT 21h frame ptr
; EXIT:
;	Through PassOnThrough or Error path if phantom drive detected
; USES:
;	Flags and via DOS if error
;
PathDSDXCall:
	call	PathDrvDSDX
	jnc	@f
	jmp    pd_drive_no_good        ; Drive not OK
@@:
	;   If OPEN with SHARING, check to see if this could be a file in
	;   the file handle cache.  GetModuleHandle is fairly quick as
	;   opposed to fully qualifying the path involved, but that would
	;   mean two DOS calls in addition to the open.  Kernel opens modules
	;   in compatibility mode, so sharing bits will barf if the file
	;   is in the cache.  why is this a problem?  CVW opens modules
	;   with sharing modes and we broke em when we fixed the fh cache.
	;   won't worry about other DOS calls like create or delete since
	;   they will damage things anyway.
	;
ife SHARE_AWARE
	cmp	ah,3Dh			; open call?
	jnz	maybe_notify
	test	al, 01110000b		; sharing bits?
	jz	maybe_notify

	call	DealWithCachedModule

endif

maybe_notify:
ifdef WOW
	cmp	ah,41h			; Delete call?
	jnz	not_delete

	call	DealWithCachedModule	; Yes Flush it out of our cache

not_delete:
endif; WOW
	cmp	ah,5Bh
	ja	no_notify_jmp		; DOS call we don't know
	cmp	ah,3Dh
	jnz	nd_101
	jmp	diddle_share_bits	; Don't notify on open file.
nd_101:
	cmp	ah,4Eh
	jz	no_notify_jmp		; Don't notify on find first.
	cmp	ah,56h
	jz	no_notify_jmp		; Handle rename specially.
	cmp	ax, 4300h		; Get File Attributes
	jz	no_notify_jmp
	pop	ds
	push	ax
	push	[bp][6]			; Original flags
	push	cs
	mov	ax, codeoffset back_here ; Now have IRET frame
	push	ax
	push	[bp]			; Original bp+1
	mov	bp, sp
	mov	ax, [bp][8]
	push	ds
POTJ1:
	jmp	PassOnThrough		; Do the DOS call

no_notify_jmp:
	jmps	no_notify


back_here:
	pushf
	inc	bp
	push	bp			; pass back the correct flags
	mov	bp,sp
	xchg	ax, [bp][4]
	jc	call_failed
	call	FileCDR_notify
call_failed:
	push	[bp]
	pop	[bp][6]
	add	sp, 2
	pop	[bp][12]
	pop	ax
	pop	bp
	dec	bp
	jmp	f_iret

diddle_share_bits:			; Make ALL opens use SHARE bits
if SHARE_AWARE
	test	al, 70h			; Any share bits now?
	jnz	no_notify		;  yes, fine.

	or	al, OF_SHARE_DENY_NONE	; For Read access
	test	al, 3			; Write or Read/Write access?
	jz	no_notify		;  no, SHARE_DENY_NONE is fine
					;  yes, want SHARE_DENY_WRITE
	xor	al, OF_SHARE_DENY_WRITE OR OF_SHARE_DENY_NONE
endif
no_notify:
	jmps	POTJ			; Drive OK

pd_drive_no_good:
	call	SetErrorDrvDSDX 	; Set error
	jmps	SetCarryRet		; Error

;**
;
; DLDriveCall1 -- Trap for Calls which have a drive number (A = 1) in DL
;			and carry NOT set if error.
;
; ENTRY:
;	Regs for call except BP is standard INT 21h frame ptr
; EXIT:
;	Through PassOnThrough or Error path if phantom drive detected CARRY not
;		diddled
; USES:
;	Flags and via DOS if error
;
DLDriveCall1:
	call	CheckDriveDL
	jnc	POTJ			; Drive OK
	call	SetErrorDLDrv		; Set error
	jmps	DriveErrorRet		; Error

;**
;
; DLDriveCall2 -- Trap for Calls which have a drive number (A = 1) in DL
;			and carry set if error.
;
; ENTRY:
;	Regs for call except BP is standard INT 21h frame ptr
; EXIT:
;	Through PassOnThrough or Error path if phantom drive detected CARRY set
; USES:
;	Flags and via DOS if error
;
DLDriveCall2:
	call	CheckDriveDL
	jnc	POTJ			; Drive OK
	call	SetErrorDLDrv		; Set error
	jmps	SetCarryRet		; Error

;**
;
; FCBCall -- Trap for Calls which point to an FCB with DS:DX
;
; ENTRY:
;	Regs for call except BP is standard INT 21h frame ptr
; EXIT:
;	Through PassOnThrough or Error path if phantom drive detected
; USES:
;	Flags and via DOS if error
;
FCBCall:
	push	dx
	push	si
	mov	si,dx
	cmp	byte ptr [si],0FFh	; Extended FCB?
	jnz	NotExt			; No
	add	si,7			; Point to drive
NotExt:
	mov	dl,byte ptr [si]	; Get drive
	or	dl,dl
	jz	FCBOK			; default drive
	call	CheckDriveDL
	jc	FCBBad
FCBOK:
	pop	si
	pop	dx
POTJ:
	jmp	PassOnThrough

FCBBad:
	push	dx			; Save drive
	mov	dx,si			; Point to standard FCB
	mov	byte ptr [si],0F0h	; Known bogus drive
	call	real_DOS
	pop	dx
	mov	byte ptr [si],dl	; Restore user drive
	pop	si
	pop	dx
	jmps	DriveErrorRet


SetCarryRet:
	or	User_FL,00000001b	; Set carry
	jmps	DriveErrorRet


DriveErrorRet:
	pop	ds
	pop	bp
	dec	bp
	FSTI
	jmp	f_iret


;**
;
; XenixRename -- Trap for Call 56h
;
; ENTRY:
;	Regs for call except BP is standard INT 21h frame ptr
; EXIT:
;	Through PassOnThrough or Error path if phantom drive detected CARRY set
; USES:
;	Flags and via DOS if error
;
XenixRename:

; On rename we MUST deal with BOTH strings to prevent access to any
;	 phantom drives.

	call	PathDrvDSDX		; Check DS:DX drive
	xchg	di,dx			; ES:DI <-> DS:DX
	push	ds
	push	es
	pop	ds
	pop	es
	jnc	XR_010
	jmp	RenameError		; bad
XR_010:
	call	PathDrvDSDX		; Check ES:DI drive
	jnc	XR_020
	jmp	RenameError
XR_020:
	xchg	di,dx			; ES:DI <-> DS:DX
	push	ds
	push	es
	pop	ds
	pop	es

	pop	ds
	push	ax
	push	[bp][6]			; Original flags
	push	cs
	mov	ax, codeoffset back_here1 ; Now have FIRET frame
	push	ax
	push	[bp]			; Original bp+1
	mov	bp, sp
	mov	ax, [bp][8]
	push	ds
	jmp	PassOnThrough		; Do the DOS call
back_here1:
	pushf
	inc	bp
	push	bp			; pass back the correct flags
	mov	bp,sp
	xchg	[bp][4], ax
	jc	call_failed1

;;;	mov	ah,41h			; delete file
	call	FileCDR_notify
;;;	push	ds
;;;	push	es
;;;	pop	ds
;;;	pop	es
;;;	xchg	di,dx
;;;	mov	ah,5Bh			; create new file
;;;	call	FileCDR_notify
;;;	push	ds
;;;	push	es
;;;	pop	ds
;;;	pop	es
;;;	xchg	di,dx

call_failed1:
	push	[bp]
	pop	[bp][6]
	add	sp, 2
	pop	[bp][12]
	pop	ax
	pop	bp
	dec	bp
	jmp	f_iret

RenameError:
	xchg	di,dx			; DS:DX <-> ES:DI
	push	ds
	push	es
	pop	ds
	pop	es

; We patch the ES:DI drive letter even if it isn't there.
;   Since we are setting an error anyway this is OK.

	push	word ptr ES:[di]
	mov	byte ptr ES:[di],'$'	; Bogus drive letter
	call	SetErrorDrvDSDX		; Set error
	pop	word ptr ES:[di]
	jmp	SetCarryRet		; Error

;**
;
; PathDrvDSDX -- Check a path pointed to by DS:DX for phantom drives
;
; ENTRY:
;	DS:DX points to path
; EXIT:
;	Carry set if phantom drive detected
;	Carry clear if no phantom drives detected
; USES:
;	Flags
;
	public	PathDrvDSDX
PathDrvDSDX:
	push	si
	mov	si,dx		; Point with SI
	mov	dx,word ptr [si]; Get first two chars
	or	dl,dl		; NUL in first byte?
	jz	PDROK		; yes, OK
ifdef FE_SB
	push	ax
	mov	al,dl
	call	MyIsDBCSLeadByte    ; see if char is DBC.
	pop	ax
	jnc	PDROK		; jump if char is a DBC
endif
	or	dh,dh		; NUL in second byte?
	jz	PDROK		; yes, OK
	cmp	dh,':'		; Drive given?
	jnz	PDROK		; No, OK
	or	dl,20h		; to lower case
	sub	dl,60h		; DL is drive #, A=1
	call	CheckDriveDL	; Check it out
	jmps	PDPPRET

PDROK:
	clc
PDPPRET:
	mov	dx,si
	pop	si
	ret

;**
;
; SetErrorDrvDSDX -- Set an error on a DS:DX call by calling the DOS
;
; ENTRY:
;	DS:DX points to path with phantom drive
;	All other regs approp for INT 21 CALL
; EXIT:
;	DOS called to set up error
; USES:
;	Flags
;	Regs as for INT 21 CALL
;
SetErrorDrvDSDX:
	push	si
	mov	si,dx
	push	word ptr [si]
	mov	byte ptr [si],'$'	; Bogus drive letter
	call	real_DOS		; DOS sets error
	pop	word ptr [si]		; Restore users drive
	pop	si
	ret

;**
;
; SetErrorDLDrv -- Set an error on a DL call by calling the DOS
;
; ENTRY:
;	DL is drive # (A=1) of a phantom drive.
;	All other regs approp for INT 21 CALL
; EXIT:
;	DOS called to set up error
; USES:
;	Flags
;	Regs as for INT 21 CALL
;
SetErrorDLDrv:
	push	dx
	mov	dl,0F0h			; Bogus drive letter
	call	real_DOS		; DOS sets error
	pop	dx			; Restore users drive
ret43:	ret

;**
;
; CheckDriveDL -- Check DL drive (A = 1)
;
; ENTRY:
;	DL is drive # (A=1)
; EXIT:
;	Carry Set if phantom drive
;	Carry Clear if NOT phantom drive
; USES:
;	Flags
;
CheckDriveDL:
	push	bx
	mov	bx,dx
	dec	bl			; A = 0
	cmp	bl,26			; 0 >= DL < 26?
	jae	OKDRV			; No, cant be phantom then
	xor	bh,bh
	add	bx,dataOffset PhantArray; Index into PhantArray
	push	ds
	SetKernelDS
	cmp	byte ptr ds:[bx],0	; Non-zero entry means phantom
	pop	ds
	UnSetKernelDS
	stc
	jnz	BadDrv
OKDRV:
	clc
BadDrv:
	pop	bx
	ret


ife SHARE_AWARE

;**
;
; DealWithCachedModule -- closes a cached module if it looks like a filename
;
;   ENTRY:
;	Same as PathDSDXCall
;
;   EXIT:
;	Unchanged
;
;   USES:
;	None
;
;   SIDE EFFECT:
;	Closes entry in file handle cache if it has the same base name
;
public DealWithCachedModule
DealWithCachedModule:
	pusha
	push	ds
	push	es			; save all registers

	mov	si, dx			; point ds:si to string
	sub	sp, 130 		; big number for paranoia
	mov	di, sp
	push	ss
	pop	es			; es:di to string
	cld				; forwards

copy_name_loop:
	lodsb				; get a char
	cmp	al, 0			; end of string?
	jz	end_of_name
	cmp	al, ':' 		; path seperator?
	jz	path_sep
	cmp	al, '\'
	jz	path_sep
	cmp	al, '/'
	jz	path_sep
	call	MyUpper 		; upcase the char
	stosb

ifdef FE_SB
	call	MyIsDBCSLeadByte
	jc	copy_name_loop		; copy second byte in east
	movsb
endif

	jmp	short copy_name_loop
path_sep:
	mov	di, sp			; point back to beginning
	jmp	short copy_name_loop
end_of_name:
	stosb
	mov	di, sp			; point back to beginning

	SetKernelDS

	cCall	ResidentFindExeFile, <ss,di>	; find it
	or	ax, ax
	jz	@F

	cCall	FlushCachedFileHandle, <ax> ; flush it
@@:
	add	sp, 130

	pop	es
	pop	ds			; restore registers
	popa
	UnsetKernelDS
	ret

endif

f_iret:
	FIRET

sEnd	CODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\ikernel.h ===
#define API	_far _pascal _loadds

HANDLE	API IGlobalAlloc(WORD, DWORD);
DWORD	API IGlobalCompact(DWORD);
HANDLE	API IGlobalFree(HANDLE);
DWORD	API IGlobalHandle(WORD);
LPSTR	API IGlobalLock(HANDLE);
HANDLE	API IGlobalReAlloc(HANDLE, DWORD, WORD);
DWORD	API IGlobalSize(HANDLE);
BOOL	API IGlobalUnlock(HANDLE);
WORD	API IGlobalFlags(HANDLE);
LPSTR	API IGlobalWire(HANDLE);
BOOL	API IGlobalUnWire(HANDLE);
HANDLE	API IGlobalLRUNewest(HANDLE);
HANDLE	API IGlobalLRUOldest(HANDLE);
VOID	API IGlobalNotify(FARPROC);
WORD	API IGlobalPageLock(HANDLE);
WORD	API IGlobalPageUnlock(HANDLE);
VOID	API IGlobalFix(HANDLE);
BOOL	API IGlobalUnfix(HANDLE);
DWORD	API IGlobalDosAlloc(DWORD);
WORD	API IGlobalDosFree(WORD);
HANDLE	API IGetModuleHandle(LPSTR);
int	API IGetModuleUsage(HANDLE);
int	API IGetModuleFileName(HANDLE, LPSTR, int);
FARPROC API IGetProcAddress(HANDLE, LPSTR);
FARPROC API IMakeProcInstance(FARPROC, HANDLE);
void	API IFreeProcInstance(FARPROC);
void	API IOutputDebugString(LPSTR);
//LPSTR   API Ilstrcpy( LPSTR, LPSTR );
//LPSTR   API Ilstrcat( LPSTR, LPSTR );
//int     API IlstrOriginal( LPSTR, LPSTR );
//int     API Ilstrlen( LPSTR );
int	API I_lopen( LPSTR, int );
int	API I_lclose( int );
int	API I_lcreat( LPSTR, int );
LONG	API I_llseek( int, long, int );
WORD	API I_lread( int, LPSTR, int );
WORD	API I_lwrite( int, LPSTR, int );

#define GlobalAlloc		     IGlobalAlloc
#define GlobalFree		     IGlobalFree
#define GlobalHandle		     IGlobalHandle
#define GlobalLock		     IGlobalLock
#define GlobalReAlloc		     IGlobalReAlloc
#define GlobalSize		     IGlobalSize
#define GlobalUnlock		     IGlobalUnlock
#define GlobalFlags		     IGlobalFlags
#define GlobalWire		     IGlobalWire
#define GlobalUnWire		     IGlobalUnWire
#define GlobalLRUNewest 	     IGlobalLRUNewest
#define GlobalLRUOldest 	     IGlobalLRUOldest
#define GlobalNotify		     IGlobalNotify
#define GlobalPageLock		     IGlobalPageLock
#define GlobalPageUnlock	     IGlobalPageUnlock
#define GlobalFix		     IGlobalFix
#define GlobalUnfix		     IGlobalUnfix
#define GetProcAddress		     IGetProcAddress
#define GetModuleHandle 	     IGetModuleHandle
#define GetModuleUsage		     IGetModuleUsage
#define GetModuleFileName	     IGetModuleFileName
#define GetFreeSpace		     IGetFreeSpace
#define GetTempFileName 	     IGetTempFileName
//#define lstrcpy                      Ilstrcpy
//#define lstrcat                      Ilstrcat
//#define lstrOriginal                 IlstrOriginal
//#define lstrlen                      Ilstrlen
#define _lopen			     I_lopen
#define _lclose 		     I_lclose
#define _lcreat 		     I_lcreat
#define _llseek 		     I_llseek
#define _lread			     I_lread
#define _lwrite 		     I_lwrite
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\kdataend.asm ===
TITLE	KDATAEND - Kernel ending data area


; This file contains the kernel data items that must be at the end of
; their respective segments.  This file is last in the link order.

include kernel.inc


; The PADDATA segment performs two functions:  it provides ginit with
; space to create the ending global heap sentinel, and it forces the
; linker to fully expand DGROUP in the .EXE file.  Kernel uses DGROUP
; before it's actually loaded by LoadSegment, so it needs to be fully
; expanded when loaded by the DOS EXEC call of kernel.

sBegin	PADDATA

	DB	32 DUP (0FFh)			; Room for final arena entry

sEnd	PADDATA

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\int24.asm ===
;-----------------------------------------------------------------------;
;									;
;		    Windows Critical Error Handler			;
;									;
;-----------------------------------------------------------------------;

.xlist
include kernel.inc
include tdb.inc
ifdef WOW
include vint.inc
endif
.list

DEVSTRC struc
devLink dd	?
devAttr dw	?
devPtr1 dw	?
devPtr2 dw	?
devName db	8 dup (?)
DEVSTRC ends

IDABORT	 =   3
IDRETRY	 =   4
IDIGNORE =   5

;-----------------------------------------------------------------------;
;									;
; XENIX calls all return error codes through AX.  If an error occurred	;
; then the carry bit will be set and the error code is in AX.		;
; If no error occurred then the carry bit is reset and AX contains	;
; returned info.							;
;									;
; Since the set of error codes is being extended as we extend the	;
; operating system, we have provided a means for applications to ask	;
; the system for a recommended course of action when they receive an	;
; error.								;
;									;
; The GetExtendedError system call returns a universal error, an error	;
; location and a recommended course of action.	The universal error	;
; code is a symptom of the error REGARDLESS of the context in which	;
; GetExtendedError is issued.						;
;									;
; These are the universal int 24h mappings for the old INT 24 set of	;
; errors.								;
;									;
;-----------------------------------------------------------------------;

error_write_protect		EQU	19
error_bad_unit			EQU	20
error_not_ready			EQU	21
error_bad_command		EQU	22
error_CRC			EQU	23
error_bad_length		EQU	24
error_Seek			EQU	25
error_not_DOS_disk		EQU	26
error_sector_not_found		EQU	27
error_out_of_paper		EQU	28
error_write_fault		EQU	29
error_read_fault		EQU	30
error_gen_failure		EQU	31

; These are the new 3.0 error codes reported through INT 24h

error_sharing_violation		EQU	32
error_lock_violation		EQU	33
error_wrong_disk		EQU	34
error_FCB_unavailable		EQU	35

; New OEM network-related errors are 50-79

error_not_supported		EQU	50

; End of INT 24h reportable errors

error_file_exists		EQU	80
error_DUP_FCB			EQU	81	; *****
error_cannot_make		EQU	82
error_FAIL_I24			EQU	83

; New 3.0 network related error codes

error_out_of_structures		EQU	84
error_Already_assigned		EQU	85
error_invalid_password		EQU	86
error_invalid_parameter		EQU	87
error_NET_write_fault		EQU	88

error_I24_write_protect		EQU	0
error_I24_bad_unit		EQU	1
error_I24_not_ready		EQU	2
error_I24_bad_command		EQU	3
error_I24_CRC			EQU	4
error_I24_bad_length		EQU	5
error_I24_Seek			EQU	6
error_I24_not_DOS_disk		EQU	7
error_I24_sector_not_found	EQU	8
error_I24_out_of_paper		EQU	9
error_I24_write_fault		EQU	0Ah
error_I24_read_fault		EQU	0Bh
error_I24_gen_failure		EQU	0Ch
; NOTE: Code 0Dh is used by MT-DOS.
error_I24_wrong_disk		EQU	0Fh

; THE FOLLOWING ARE MASKS FOR THE AH REGISTER ON Int 24h

Allowed_FAIL			EQU	00001000b
Allowed_RETRY			EQU	00010000b
Allowed_IGNORE			EQU	00100000b

;NOTE: ABORT is ALWAYS allowed

I24_operation			EQU	00000001b	;Z if READ,NZ if Write
I24_area			EQU	00000110b	; 00 if DOS
							; 01 if FAT
							; 10 if root DIR
DataBegin

externB SysErr
externB msgWriteProtect
externB drvlet1
externB msgCannotReadDrv
externB drvlet2
externB msgCannotWriteDrv
externB drvlet3
externB msgShare
externB drvlet4
externB msgNetError
externB drvlet5
externB msgCannotReadDev
externB devenam1
externB msgCannotWriteDev
externB devenam2
externB devenam3
externB msgNetErrorDev
externB msgNoPrinter
externB OutBuf
externB Kernel_Flags
externB Kernel_InDOS
externB Kernel_InINT24
externB InScheduler
externB cdevat
externB errcap
externB fNovell
externB fDW_Int21h
externW pGlobalHeap
externW CurTDB
;externW MyCSDS
externW LastExtendedError
if 0; EarleH
externW LastCriticalError
endif ; 0
externD pSErrProc
externD InDOS

fDialogShown	db	0	; NZ if end user sees dialog box


DataEnd

INT24STACK	STRUC
Int24_IP	dw	?
Int24_CS	dw	?
Int24_FG	dw	?
Int24_AX	dw	?
Int24_BX	dw	?
Int24_CX	dw	?
Int24_DX	dw	?
Int24_SI	dw	?
Int24_DI	dw	?
Int24_BP	dw	?
Int24_DS	dw	?
Int24_ES	dw	?
INT24STACK	ENDS


sBegin	code
	assumes cs,code
	assumes ds,nothing
	assumes es,nothing

externD prevInt21Proc

externNP AppendFirst
externNP GetKernelDataSeg

;-----------------------------------------------------------------------;
; Int24Handler								;
; 									;
; This is the default disk error handling code available to all		;
; users if they do not try to intercept interrupt 24h.			;
; The two options given the user are RETRY and FAIL.  Retry goes back	;
; to DOS.  If FAIL is chosen then for DOS 3.XX we return to DOS, but	;
; for DOS 2.XX we do the fail ourselves and return to the APP.		;
;									;
; Arguments:								;
; 									;
; Returns:								;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Tue Feb 03, 1987 10:10:09p  -by-  David N. Weise   [davidw]		;
; Removed the poking around in DOS by using Kernel_InDOS.		;
; 									;
;  Tue Jan 27, 1987 07:58:56p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

cProc	Int24Handler,<PUBLIC,NEAR>
cBegin nogen

	push	ds
	SetKernelDS
	mov	fDialogShown, 0 	; Assume no dialog box
	inc	InScheduler		; Prevent recursion
	cmp	InScheduler,1		; Well are we?
	jz	NotInSched		; No, then handle this one
	jmp	ReturnError		; Yes, return abort

NotInSched:
	mov	Kernel_InINT24,1
        FSTI
	cld
	push	es
	push	dx
	push	cx
	push	bx

; Save away the return capabilities mask.

	mov	errcap,ah		; save the capabilities mask
	push	di
	mov	ds,bp
	UnSetKernelDS
	SetKernelDS	es
	mov	cx,[si].devAttr
	mov	cdevat,ch
	mov	di,dataOffset devenam1
	mov	cx,8
	add	si,devName		; pull up device name (even on block)
	push	si
	rep	movsb
	pop	si
	mov	di,dataOffset devenam2
	mov	cl,8
	push	si
	rep	movsb
	pop	si
	mov	di,dataOffset devenam3
	mov	cl,8
	rep	movsb
	pop	di

	SetKernelDS
	UnSetKernelDS	es
if 0; EarleH
	mov	LastCriticalError, di
endif

	add	al,'A'			; compute drive letter (even on character)
	mov	drvlet1,al
	mov	drvlet2,al
	mov	drvlet3,al
	mov	drvlet4,al
	mov	drvlet5,al

; At app exit time we will Ignore any critical errors.	This is
;  because errors that usually occur at app exit time are generally
;  due to the network beeping death.  Trying to put up the dialog
;  hangs Windows because USER doesn't think the task exists any more.
;  THIS IS AN INCREADABLE HACK!!  We don'r really know if we can
;  ignore all critical errors, but hey, nobodies complained yet.

	test	Kernel_flags[2],KF2_WIN_EXIT	; prevent int 24h dialogs
	jz	SetMsg
	xor	ax,ax
	jmp	eexit

SetMsg: test	ah,1
	jz	ReadMes

WriteMes:
	mov	si,dataOffset msgCannotWriteDev
	test	cdevat,10000000b
	jnz	Gotmes
	mov	si,dataOffset msgCannotWriteDrv
	jmps	Gotmes

ReadMes:
	mov	si,dataOffset msgCannotReadDev
	test	cdevat,10000000b
	jnz	Gotmes
	mov	si,dataOffset msgCannotReadDrv
Gotmes:

; reach into DOS to get the extended error code

;;;	les	bx,InDOS
;;;	mov	ax,es:[bx].3

	push	es				; DOS may trash these...
	push	ds
	push	si
	push	di
	xor	bx, bx
	mov	ah, 59h
	pushf	      
	call	prevInt21Proc
	mov	LastExtendedError, ax
	mov	LastExtendedError[2], bx
	mov	LastExtendedError[4], cx
	pop	di		      
	pop	si
	pop	ds
	pop	es
		
	mov	dx,dataOffset msgWriteProtect
	cmp	ax,error_write_protect
	jz	prmes				; Yes
	mov	dx,dataOffset msgNoPrinter
	cmp	al,error_out_of_paper
	jz	prmes				; Yes
	mov	dx,dataOffset msgShare
	cmp	al,error_sharing_violation
	jz	prmes				; Yes
	cmp	al,error_lock_violation
	jz	prmes				; Yes
	mov	dx,dataOffset msgNetError
	test	cdevat,10000000b
	jz	check_net_error
	mov	dx,dataOffset msgNetErrorDev
check_net_error:
	cmp	al,50
	jb	not_net_error
	cmp	al,80
	ja	not_net_error
	test	Kernel_Flags[2],KF2_APP_EXIT
	jz	prmes
	jmps	ReturnError

not_net_error:

	mov	dx,si			; Message in SI is correct

prmes:	call	AppendFirst		; print error type

	mov	es,curTDB		; Point to current task
	mov	ax,es:[TDB_errMode]	; See if wants default error processing
	test	al,1			; Low-order bit = zero means
	jz	ask			; ...put up dialog box
	mov	al,2
	jmps	eexit			; <> 0  means return error from call

ask:	mov	es,pGlobalHeap
	inc	es:[hi_freeze]		; freeze global heap
	call	ShowDialogBox
	mov	fDialogShown, dl	; will be 0 if dialog box NOT shown
	mov	es,pGlobalHeap
	dec	es:[hi_freeze]		; thaw global heap

eexit:	pop	bx
	pop	cx
	pop	dx
	pop	es
	cmp	al,2			; retry, ignore?
	jb	aexit			; yes, return to dos

	cmp	fNovell, 0
	je	ReturnError		; Not NOVELL
	test	errcap, Allowed_FAIL
	jnz	ReturnError		; We CAN fail, so we do.
	push	ax
	mov	ax, di
	cmp	al, 0Ch			; General failure
	pop	ax
	jne	ReturnError
	cmp	word ptr devenam1[0], 'EN'
	jne	ReturnError
	cmp	word ptr devenam1[2], 'WT'
	jne	ReturnError
	cmp	word ptr devenam1[4], 'RO'
	jne	ReturnError
	cmp	word ptr devenam1[6], 'K'
	jne	ReturnError
	mov	al, 2			; ABORT because NOVELL doesn't like FAIL
	jmps	aexit

ReturnError:
	mov	al,3			; change to return error code

; If the user canceled an error generated by the Int 21h to AUX: in kernel's
; DebugWrite routine, set a flag telling DebugWrite not to do that anymore.

	cmp	fDialogShown, 0 	; Did end user see dialog box?
	jz	not_krnl
	cmp	fDW_Int21h, 0		; fDW_Int21h will == 0 if caused by
	jnz	not_krnl		;  Int 21h/Write to AUX: in DebugWrite.
	mov	fDW_Int21h, 2		; Prevent DebugWrite from trying again
not_krnl:				;  (any value >= 2, <= 0FEh works)

aexit:	mov	Kernel_InINT24,0
	dec	InScheduler
	pop	ds
	UnSetKernelDS	ds
        FSTI
	iret
cEnd nogen


;-----------------------------------------------------------------------;
; ShowDialogBox
;
;
; Entry:
;
; Returns:
;
; Registers Destroyed:
;
; History:
;  Sat 02-Dec-1989 15:28:51  -by-  David N. Weise  [davidw]
; Removed the stack switching because of the new WinOldAp support,
; and added this nifty comment block.
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	ShowDialogBox,<PUBLIC,NEAR>

cBegin nogen

	CheckKernelDS
	ReSetKernelDS

	mov	ax,3			; assume no USER therefor CANCEL
	xor	dx, dx
	cmp	pSErrProc.sel,0 	; is there a USER yet?
	jz	sdb_exit

	push	bp
	xor	bp,bp
	push	bp
	mov	bp,sp
	push	ds
	mov	ax,dataOffset OutBuf	; lpText
        push    ax
	push	ds
	mov	ax,dataOffset SysErr	; lpCaption
        push    ax

; Set up the buttons based on the capabilities mask.  Cancel is always
;  availible.  Retry and Ignore are not always available.

	mov	ax,SEB_CANCEL+SEB_DEFBUTTON ; cancel is always allowed
        push    ax
	xor	ax,ax			; assume no second button
if 0 ; 05 feb 1990, ignoring is not user friendly, win 2.x did not allow it
	test	errcap,20h		; is ignore allowed?
	jz	button_2
	mov	ax,SEB_IGNORE		; ignore is the second button
endif

button_2:
        push    ax

	xor	ax,ax			; assume no third button
	test	errcap,10h		; is retry allowed?
	jz	button_3
	mov	ax,SEB_RETRY		; retry is the third button
button_3:
        push    ax
dobox:
	call	[pSErrProc]		; USER.SysErrorBox()
	mov	dx, ax

; We need to map the return as follows:
;   button 1 (Cancel) =>  3  3
;   button 2 (Retry)  =>  1  0
;   button 3 (Ignore) =>  0  1

	sub	al,2
	jnb	codeok
	mov	al,3
codeok:
	pop	bp
	pop	bp
sdb_exit:
	ret

cEnd nogen

;-----------------------------------------------------------------------;
; GetLPErrMode								;
; 									;
; This routine returns a long pointer to the Kernel_InDOS and		;
; Kernel_InINT24 bytes inside the KERNEL.  It is used by 386 WINOLDAP	;
; to prevent switching while inside INT 24 errors from other VMs.	;
; 									;
; NOTE: Do not change this call without talking to the WIN/386 group.	;
; NOTE: USER also uses this call to determine whether PostMessage       ;
;       can call FatalExit.                                             ;
; 									;
; Arguments:								;
;	none								;
; 									;
; Returns:								;
;	DX:AX = pointer to Kernel_InDOS followed by Kernel_InINT24	;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
;	all								;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Tue Jan 27, 1987 07:13:27p  -by-  David N. Weise   [davidw]          ;
; Rewrote it and added this nifty comment block.			;
;									;
;  7/23/87 -by- Arron Reynolds [aaronr], updated comments to desired	;
;	state.								;
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	GetLPErrMode,<PUBLIC,FAR>
cBegin	nogen
	call	GetKernelDataSeg
	mov	dx, ax
	mov	ax,dataOffset Kernel_InDOS
	ret
cEnd	nogen

sEnd	code

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\kdos.inc ===
SG_EXIT       = 20H

TASKREG STRUC
TASKDX  DW      ?
TASKBX  DW      ?
TASKES  DW      ?
TASKCX  DW      ?
TASKAX  DW      ?
TASKDI  DW      ?
TASKSI  DW      ?
TASKDS  DW      ?
TASKBP  DW      ?
TASKREG ENDS

; Exit codes in upper byte

Exit_terminate	    EQU	    0
Exit_abort	    EQU	    0
Exit_Ctrl_C	    EQU	    1
Exit_Hard_Error	    EQU	    2
Exit_Keep_process   EQU	    3

user_FG     equ  word ptr [bp+6]
user_FL     equ  byte ptr [bp+6]
user_CS     equ  word ptr [bp+4]
user_IP     equ  word ptr [bp+2]
user_BP     equ  word ptr [bp]
user_DS     equ  word ptr [bp-2]
user_DX     equ  word ptr [bp-4]
user_DSDX   equ dword ptr [bp-4]
user_ES     equ  word ptr [bp-6]
user_BX     equ  word ptr [bp-8]
user_ESBX   equ dword ptr [bp-8]
user_AX     equ  word ptr [bp-10]
user_AL     equ  byte ptr [bp-10]
user_CX     equ  word ptr [bp-12]
user_SI     equ  word ptr [bp-14]
user_DI     equ  word ptr [bp-16]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\intnn.asm ===
.xlist
include kernel.inc
include pdb.inc
include tdb.inc
.list

DataBegin

externW curTDB

DataEnd

sBegin  CODE
externD prevInt10proc
assumes CS,CODE
assumes	ds, nothing
assumes	es, nothing

;-----------------------------------------------------------------------;
; IntnnHandlers - Handlers for int 0, 2, 4, 6, 7, 10, 3E, 75		;
;									;
; Slimed in here for lack of a better place.				;
; Merely jump through the vector saved in the TDB			;
;									;
;-----------------------------------------------------------------------;

cProc	Int00Handler,<PUBLIC,FAR>
cBegin nogen
	push	bx
	mov	bx, TDB_INTVECS
IntnnCommon:
	sub	sp, 2			; Make room for dword (saved bx is
	push	bp			;		       other word)
	mov	bp, sp
	push	ds

	SetKernelDS
	mov	ds, CurTDB
	UnSetKernelDS
	push	[bx]			; Fill in dword with vector contents
	pop	[bp+2]
	mov	bx, [bx+2]
	xchg	bx, [bp+4]		; Fill in segment, recover bx
	pop	ds
	pop	bp
	retf
cEnd nogen

cProc	Int02Handler,<PUBLIC,FAR>
cBegin nogen
	push	bx
	mov	bx, TDB_INTVECS+4
	jmps	IntnnCommon
cEnd nogen

cProc	Int04Handler,<PUBLIC,FAR>
cBegin nogen
	push	bx
	mov	bx, TDB_INTVECS+8
	jmps	IntnnCommon
cEnd nogen

cProc	Int06Handler,<PUBLIC,FAR>
cBegin nogen
	push	bx
	mov	bx, TDB_INTVECS+12
	jmps	IntnnCommon
cEnd nogen

cProc	Int07Handler,<PUBLIC,FAR>
cBegin nogen
	push	bx
	mov	bx, TDB_INTVECS+16
	jmps	IntnnCommon
cEnd nogen

cProc	Int3EHandler,<PUBLIC,FAR>
cBegin nogen
	push	bx
	mov	bx, TDB_INTVECS+20
	jmps	IntnnCommon
cEnd nogen

cProc	Int75Handler,<PUBLIC,FAR>
cBegin nogen
	push	bx
	mov	bx, TDB_INTVECS+24
	jmps	IntnnCommon
cEnd nogen

ifdef WOW

cProc   Int10Handler,<PUBLIC,FAR>

;; QuattroPro for windows does direct VGA programming if they detect
;; that the monitor they are running on is a VGA.   On NT if they program
;; the VGA we trap all the operations in NTVDM - but it makes QuattroPro
;; look very slow.   So we lie to them here bl = 0 No monitor.   That way
;; they don't do direct VGA programming and run fast.
;;       - mattfe june 93
;;
;; if function == 1h (get monitor type)
;;      then return 0 - No monitor
;; else
;;      chain into real int10 handler

cBegin nogen
        cmp     ah,1ah
        jne     int10h_dontbother

        mov     bl,00h
        IRET

int10h_dontbother:
        jmp     cs:prevInt10proc
cEnd nogen

endif; WOW

;-----------------------------------------------------------------------;
; FOR INT HANDLER	SEE						;
;									;
;	21h		i21entry.asm					;
;	3Fh		ldint.asm					;
;									;
;-----------------------------------------------------------------------;


sEnd	CODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\kdata.asm ===
TITLE   KDATA - Kernel data area

win3debdata=1
include gpfix.inc               ; include first to define segment order
include kernel.inc
include gpcont.inc              ; do we alloc Sherlock data items?

extrn __ahshift:ABS             ; Pull in LDBOOT.ASM next from KERNOBJ.LIB

sBegin  CODE
externFP Int21Handler
sEnd    CODE

public  __acrtused
        __acrtused = 9697

;------------------------------------------------------------------------
; Segment definations to define labels at the segment start.  Don't put
; any code or data here.
;------------------------------------------------------------------------

sBegin  INITCODE
labelB  <PUBLIC,initcode>
labelB  <PUBLIC,beg_initcode>
sEnd    INITCODE

DataBegin INIT
labelB  <PUBLIC,initdata>
labelB  <PUBLIC,beg_initdata>
DataEnd INIT


;------------------------------------------------------------------------
;       D A T A   S E G M E N T   V A R I A B L E S
;------------------------------------------------------------------------

DataBegin

; The following items must remain in the same location and order.  These
; items also appear in the initial paragraph of each application's DS.

        ORG     0

        DW  0
  globalW       oOldSP,0
  globalW       hOldSS,5
  globalW       pLocalHeap,0
  globalW       pAtomTable,0
  globalW       pStackTop,<dataOffset gmove_stack_top>
  globalW       pStackMin,<dataOffset gmove_stack>
  globalW       pStackBot,<dataOffset gmove_stack>

;------------------------------------------------------------------------
if KDEBUG
; If this word gets trashed, then we overflowed our stack

globalW gmove_stack_sig,STACK_SIGNATURE,16
endif

labelB  <PUBLIC,lpszFileName>   ; Used in FileCDR_notify
        gmove_stack_top label byte

        EVEN

        DW      256 DUP (0)     ; gmove requires at least 64 words

globalW gmove_stack,0

globalW prev_gmove_SP,0
globalW prev_gmove_SS,0
globalW ss_sel,0

;------------------------------------------------------------------

; The debugger requires that the following items remain in the same
; relative order.

  labelW        <PUBLIC,THHOOK> ; So ToolHelp can find this stuff, too.
  globalW hGlobalHeap,0 ; Handle to master object
  globalW pGlobalHeap,0 ; Current physical address of master object
  globalW hExeHead,0    ; Head of module list maintained by Load/Free Module
  globalW hExeSweep,0   ; ... 1st module for LRU sweep to examine

  globalW topPDB,0      ; DOS PDB on entry
  globalW headPDB,0     ; link list of PDBs
  globalW topsizePDB,0  ; DOS PDB size upon entry
  globalW headTDB,0     ; head of task queue
  globalW curTDB,0      ; handle for currently running task
  globalW loadTDB,0     ; handle for currently loading task
  globalW LockTDB,0     ; handle of super task
  globalW SelTableLen,0 ; DONT MOVE THIS
  globalD SelTableStart,0       ; DONT MOVE THIS
    globalD     hBmDPMI,0       ; DPMI handle to BurgerMaster

;------------------------------------------------------------------------
globalW winVer,400h     ; Windows version number for KERNEL.EXE header
globalW fWinx,0         ; Flag from ldboot.asm
globalW f8087,0         ; non zero if 8087 installed
globalW PHTcount,0      ; Count of tasks with a PHT
globalW hGDI,0          ; module handle of GDI
globalW hUser,0         ; module handle of User
globalW hShell,0        ; module handle of Shell
globalW fLMdepth,0      ; # of recursive LoadModules
globalW wDefRIP,0       ; Value to return from RIP in Debug
globalB num_Tasks,0     ; number of tasks (i.e. TDB's) in system
globalB InScheduler,0   ; True if inside scheduler
globalB graphics,1      ; True if user/keyboard/gdi/display loaded
        DB 0
globalB fastfp,1        ; True if suppress FWAIT before FOp

;globalW PID_for_fake,0          ; the PID allocated for the fake task
;globalW EMS_calc_swap_line,0    ; The calculated swap line
;globalW EMSCurPID,0             ; The current PID.

globalW MaxCodeSwapArea,0       ; The max paragraphs SetSwapAreaSize can set.

globalW selLowHeap,0            ; selector to Windows Low ( < 640k) heap block
globalW cpLowHeap,0             ; count of paragraphs of Low heap block
globalW selHighHeap,0           ; selector to Windows High ( >640k) heap block
globalW selWoaPdb,0             ; selector to fixed low PDB for WinOldApp
globalW sel_alias_array,0       ; the selector alias array (286 only)
globalW temp_sel,0              ; Single pre-allocated selector
globalD dressed_for_success,0   ; callback into OS/2 mapping layer at app start

globalD InDOS,0                 ; -> in dos flags and stuff
globalD pSftLink,0              ; -> end of Sft chain when we started
globalD lpWinSftLink,0          ; -> first node in chain that windows adds

ifdef WOW
globalD pDosWowData,0           ; -> rmode pointer to DosWowData in DOSDATA
globalD pPMDosCDSCNT,0          ; -> DOS CDS Count variable
globalD pPMDosCURDRV,0          ; -> DOS CurDrv variable
globalD pPMDosPDB,0             ; -> pointer to PDB in DOSDATA
globalD pPMDosExterr,0          ; -> pointer to DOS Exterr var (word)
globalD pPMDosExterrLocus, 0    ; -> pointer to DOS ExterrLocus var (byte)
globalD pPMDosExterrActionClass,0 ; -> pointer to DOS ExterrActionClass (word, byte each)
endif

globalD pFileTable,0            ; -> beginning of Sft chain
globalW FileEntrySize,0         ; size of one sft entry
globalD curDTA,0                ; what DOS thinks is the current DTA
globalW cur_dos_PDB,0           ; what DOS thinks is the current PDB
globalW Win_PDB,0               ; what we want the PDB to be
globalW cur_drive_owner,0       ; last TDB to change the disk or directory
globalB fBreak,0                ; state of dos break flag between e&d dos
globalB LastDriveSwapped,0      ; drive letter of last drive where disk swap
globalB DOS_version,0           ; DOS major version number
globalB DOS_revision,0          ; DOS minor version number
globalB fInt21,0                ; Flag indicating INT 21 hooks are installed
globalB fNovell,0               ; Have Novell network
globalB fPadCode,0              ; Pad code segments for 286 chip bug
globalB CurDOSDrive,0FFh        ; Current drive according to DOS
globalB DOSDrives,26            ; number of logical drives from DOS

;----------------------------------------------------------------------

; PhantArray is a byte array indexed by zero based drive number.
;  A non-zero value indicates the drive is phantom.

globalB PhantArray,0,26


; Keyboard inquire structure
globalB fFarEast,0              ; non zero means far eastern keyboard
ifdef   FE_SB

labelB  <PUBLIC,DBCSVectorTable> ;LanguageId, SizeOfDBCSVector, [BeginRange, EndRange] []
dw 411h                          ;JAPAN
db 4, 81h, 9Fh, 0E0h, 0FCh
dw 412h                          ;KOREA
db 2, 81h, 0FEh
dw 404h                          ;TAIWAN
db 2, 81h, 0FEh
dw 804h                          ;PRC
db 2, 81h, 0FEh
dw 0C04h                         ;HONGKONG
db 2, 81h, 0FEh
db 0                             ;End of table

globalB fDBCSLeadTable,0,256    ; DBCS lead byte index table

endif   ;FE_SB
globalB KeyInfo,0,%(SIZE KBINFO)

; Procedure addresses initialized by InitFwdRef

        ALIGN 4

globalD pSysProc,0              ; -> SYSTEM.InquireSystem
globalD pTimerProc,0            ; -> SYSTEM.CreateTimer
globalD pSystemTermProc,0       ; -> SYSTEM.Disable
globalD pKeyProc,0              ; -> KEYBOARD.AnsiToOem
globalD pKeyProc1,0             ; -> KEYBOARD.OemToAnsi
globalD pKeyboardTermProc,0     ; -> KEYBOARD.Disable
globalD pKeyboardSysReq,0       ; -> KEYBOARD.EnableKBSysReq
globalD pDisplayCritSec,0       ; -> DISPLAY.500
globalD pMouseTermProc,0        ; -> MOUSE.Disable
globalD pMBoxProc,0             ; -> USER.MessageBox
globalD pSErrProc,0             ; -> USER.SysErrorBox
globalD pExitProc,0             ; -> USER.ExitWindows
globalD pDisableProc,0          ; -> USER.DisableOEMLayer
globalD pUserInitDone,0         ; -> USER.routine to call when init is done
globalD pPostMessage,0          ; -> USER.PostMessage function
globalD pSignalProc,0           ; -> USER.SignalProc function
globalD pIsUserIdle,0           ; -> USER.IsUserIdle function
globalD pUserGetFocus,0         ; -> USER.GetFocus function
globalD pUserGetWinTask,0       ; -> USER.GetWindowTask function
globalD pUserIsWindow,0         ; -> USER.IsWindow function
globalD pGetFreeSystemResources,0 ; -> USER.GetFreeSystemResources function
globalD plstrcmp,0              ; -> USER.lstrcmp function


globalD lpInt21,0               ; support for NOVELL stealing int 21h
globalD myInt2F,0               ; support for NOVELL swapping with DOS apps
globalD FatalExitProc,0         ; Intercept for FatalExit()

globalD ptrace_dll_entry,0      ; -> ptrace engine DLL entry
globalD ptrace_app_entry,0      ; -> real entry point for app
globalD lpfnToolHelpProc,0      ; TOOLHELP.DLL PTrace function
globalW wExitingTDB,0           ; Flag for DebugWrite--no debug strings at exit
globalD shell_file_proc,0       ; -> shell for file create/del notify
globalW shell_file_TDB,0        ; shell TDB
if SWAPPRO
  globalD prevIntF0proc,0       ; -> previous Int F0h handler
  globalW hSwapPro,-1           ; file handle for swap profiler
  globalB fSwappro,0            ; 0 = no swap info, 1 = swaps, 2 = all
          DB    0
endif

globalD gcompact_start,0        ; start to measure swapping
globalD gcompact_timer,0        ; time spent in gcompact to measure swapping

ifdef  FE_SB
ifndef KOREA
  globalD pJpnSysProc,0         ; -> SYSTEM.JapanInquireSystem
endif
endif

globalW WinFlags,0              ; see kernel.inc for defs of these

globalB Kernel_Flags,0,4        ; see kernel.inc for defs of these
;
; WARNING!! Do not disturb the order of the next two variables....
;    See GetLPErrormode in INT24.ASM  ARR 7/23/87
;
globalB Kernel_InDOS,0          ; set when we call the REAL DOS
globalB Kernel_InINT24,0        ; set when Int 24h calls DOS funcs < 13

; fBooting bits:
; bit 1 (2h) is reset after kernel is loaded (for fixed blks alloc strategy)
; fBooting is zeroed as a whole after full booting by bootdone
globalB fBooting,3              ; Set to zero by bootdone
globalB fChkSum,0               ; Flag set if segment checksumming enabled
globalB fCheckFree,1            ; Set to zero by slowboot
globalB cdevat,0                ; Int 24 state
globalB errcap,0                ; Int 24 error capabilities mask
ifndef WOW
; profile APIs are thunked
globalB fProfileDirty,0         ; Profiles need writing
globalB fProfileMaybeStale,0    ; Profiles MAY need to be reread
globalB fWriteOutProfilesReenter,0 ; Are we currently in WriteOutProfiles?
endif
globalB fPokeAtSegments,1       ; Idle time load of segments
globalB fTaskSwitchCalled, 0    ; Local Reboot only works when task switching
globalD WinAppHooks,0           ; winapps can hook this for std winoldap.

public WOAName
WOAName     DB 'WINOLDAP.MOD',0
globalB grab_name,0,128

ALIGN 4

globalD lpWindowsDir,0          ; -> to WFP of where win.ini lives
globalD lpSystemDir,0           ; -> to WFP of where kernel lives
globalW cBytesWinDir,0          ; length of WFP for windows dir
globalW cBytesSysDir,0          ; length of WFP for system dir
ifdef WOW
globalD lpSystemRootDir,0       ; -> value of SystemRoot environment var
globalD lpSystem16Dir,0         ; -> to WFP of \windows\system
globalD lpSystemWx86Dir,0       ; \windows\system32\Wx86
globalW cBytesSystemRootDir,0   ; length of SystemrootEnvironment var
globalW cBytesSys16Dir,0        ; in WOW lpSystemDir points to \windows\system32
globalW cBytesSysWx86Dir,0      ; in WOW Windows\system32\Wx86
public Sys16Suffix
Sys16Suffix DB '\system'        ; append to WinDir to get lpSystem16Dir
public cBytesSys16Suffix
cBytesSys16Suffix DW ($ - dataoffset Sys16Suffix)
public SysWx86Suffix
SysWx86Suffix DB '\Sys32x86'    ; append to WinDir to get lpSystemWx86Dir
public cBytesSysWx86Suffix
cBytesSysWx86Suffix DW ($ - dataoffset SysWx86Suffix)

endif


globalD lpGPChain,0             ; GP fault hack for WEPs - chain to this addr

if SHERLOCK
  globalW gpTrying,0            ; Trying to continue after a GP fault
  globalW gpEnable, 1           ; Enable GP continuation
  globalW gpInsLen, 0           ; Length of faulting instruction
  globalW gpSafe, 0             ; OK to skip current instruction
  globalW gpRegs, 0             ; Regs modified by faulting insn
  globalW gpStack, 0            ; movement of stack by faulting insn
endif

ifndef WOW
; The profile APIs are thunked for WOW
globalB WinIniInfo,0,%(size PROINFO)
globalB PrivateProInfo,0,%(size PROINFO)
endif ; ndef WOW
public szUserPro
szUserPro   DB 'WIN.INI',0
ifndef WOW
            DB  72 dup (0)      ; Room for a long path
;;;globalB      fUserPro,0              ; Current Profile is WIN.INI
;;;globalD lpszUserPro,0
endif
; ndef WOW

ifdef WOW
globalW hWinnetDriver, 0
endif ;WOW

globalW BufPos,0                ; buffer pointer with OutBuf
globalB OutBuf,0,70             ; 70 character out buffer

EVEN
globalW MyCSAlias,0             ; Kernel's CS/DS Alias
globalW MyCSSeg,0               ; Kernel's CS as a segment
globalW MyDSSeg,0               ; Kernel's DS as a segment
globalW hLoadBlock,0            ; Handle that points to in memory file image
globalW segLoadBlock,0          ; Segment address of file image
globalW wMyOpenFileReent, 0     ; Reentrant flag for MyOpenFile

  globalW cpShrink,0
  globalW cpShrunk,0            ; Delta from beginning of file to hLoadBlock


  globalW PagingFlags,0
  globalW ArenaSel,0
  globalW FirstFreeSel,0
  globalW CountFreeSel,0
  globalD FreeArenaList,0
  globalD FreeArenaCount,0
  globalD HighestArena,0
  globalD temp_arena,0
  globalD NextCandidate,-1
  globalW Win386_Blocks,0
  globalW InitialPages,0
  globalD lpReboot,0                      ; Reboot VxD address

globalW BaseDsc,0
globalW kr1dsc,0
globalW kr2dsc,0
globalW blotdsc,0
globalW DemandLoadSel,0

globalW fhcStealNext,<(MAXFHCACHELEN-1)*size fhCacheStruc+dataOffset fhCache>   ; Next fhCache entry to use
globalW fhCacheEnd,<MAXFHCACHELEN*size fhCacheStruc+dataOffset fhCache> ; End of the cache
globalW fhCacheLen,MINFHCACHELEN
globalB fhCache,0,%(MAXFHCACHELEN*size fhCacheStruc)

if KDEBUG
  globalB fLoadTrace, 0
  globalB fPreloadSeg, 0
  globalB fKTraceOut, 0                 ; Used by DebugWrite to ignore traces
                                        ;   to be sent to PTrace
endif
globalB fDW_Int21h, 0FFh            ; FF if okay for DebugWrite to use Int 21h

    ALIGN 2

if 0; EarleH
globalW LastCriticalError,-1
endif
globalW LastExtendedError,-1,3          ; Don't move this
globalW Reserved,0,8                    ; Don't move this

ifdef WOW
;------------------------------------------------------------------------
;       W O W    G L O B A L   D A T A
;------------------------------------------------------------------------
public  achTermsrvWindowsDir   ; per user windows directory (for .ini files)
achTermsrvWindowsDir DB MaxFileLen dup (0)

globalW wCurTaskSS,0    ; Currently Running Task SS
globalW wCurTaskBP,0    ; Currently Running Task BP
globalD Dem16to32handle,0 ; -> DOS Emulation 16 to 32 bit handle convertion
globalD FastBop,0       ; eip value for fast bop entry point
globalW FastBopCS,0     ; CS value for fast bop entry point
globalD FastWOW,0       ; eip for fast WOW32 entry point when doing thunk call
globalW FastWOWCS,0     ; CS value for fast wow entry point
globalD FastWOWCbRet,0  ; eip for fast WOW32 entrypoint to return from callback
globalW FastWOWCbRetCS,0; cs for above
globalW WOWFastBopping,0; non-zero if fast call to WOW32 enabled
                        ; Jmp indirect through here for faster bops
globalB fExitOnLastApp,0    ; Close WOW when the last app exits (not WOWEXEC)
globalB fShutdownTimerStarted,0 ; 1 if the shutdown timer is running (shared WOW)

;; do not rearrange these or stick anything in the middle!
;;
;;
wowtablemodstart label byte
globalW MOD_KERNEL    ,0    ; kernel must be first!
globalW MOD_DKERNEL   ,0
globalW MOD_USER      ,0
globalW MOD_DUSER     ,0
globalW MOD_GDI       ,0
globalW MOD_DGDI      ,0
globalW MOD_KEYBOARD  ,0
globalW MOD_SOUND     ,0
globalW MOD_SHELL     ,0
globalW MOD_WINSOCK   ,0
globalW MOD_TOOLHELP  ,0
globalW MOD_MMEDIA    ,0
globalW MOD_COMMDLG   ,0
ifdef FE_SB
globalW MOD_WINNLS    ,0
globalW MOD_WIFEMAN   ,0
endif ; FE_SB
globalW ModCount      ,<($ - dataoffset wowtablemodstart) / 2>
;;
;;
;; do not rearrange these or stick anything in the middle!

globalW DebugWOW,1      ; bit 0 = 1 WOW is being debugged, 0 = WOW is not
globalW TraceOff,0      ; bit 0 = 1 turn off trace interrupts during apis

globalW WOWLastError,0 ; Last error returned by int 21
globalB WOWErrClass, 0
globalB WOWErrAction, 0
globalB WOWErrLocation, 0

endif
globalD Dos_Flag_Addr, 0

DataEnd


;------------------------------------------------------------------------
;       C O D E   S E G M E N T   V A R I A B L E S
;------------------------------------------------------------------------

sBegin  CODE
assumes cs,CODE

        EVEN

        dw      18h dup(0F4CCh) ; Catch them jmps, calls & rets to 0
                                ; and offset segment for putting in HMA
globalW MyCSDS,0                ; Kernel's DS
globalW gdtdsc,0

        ALIGN   4

globalD pYieldProc,0            ; -> USER.UserYield
globalD pStringFunc,0           ; -> USER.StringFunc function

globalD prevInt21proc,0         ; -> previous INT 21h handler
globalD prevInt24proc,0         ; -> previous Int 24h handler
globalD prevInt2Fproc,0         ; -> previous Int 24h handler
globalD prevInt3Fproc,0         ; -> previous Int 3Fh handler
globalD prevInt67proc,0         ; -> previous Int 67h handler
globalD prevInt00proc,0         ; -> previous INT 00h handler   !! don't move
                                ;                               !! don't move
globalD prevInt02proc,0         ; -> previous INT 02h handler   !! don't move
globalD prevInt04proc,0         ; -> previous INT 04h handler   !! don't move
globalD prevInt06proc,0         ; -> previous INT 06h handler   !! don't move
globalD prevInt07proc,0         ; -> previous INT 07h handler   !! don't move
globalD prevInt3Eproc,0         ; -> previous INT 3Eh handler   !! don't move
globalD prevInt75proc,0         ; -> previous INT 75h handler   !! don't move
globalD prevIntx6proc,0         ; -> previous invalid op-code Fault handler
globalD prevInt0Cproc,0         ; -> previous stack fault handler
globalD prevInt0Dproc,0         ; -> previous GP Fault handler
globalD prevInt0Eproc,0         ; -> previous Page Fault handler
ifdef WOW
globalD prevInt31proc,0         ; used to speed dpmi calls
globalD oldInt00proc,0          ; for debugging traps
globalD prevInt01proc,0         ; for debugging traps
globalD prevInt03proc,0         ; for debugging traps
globalD prevInt10proc,0         ; -> previous INT 10 handler
endif

if 0
        PUBLIC DummyKeyboardOEMToAnsi
DummyKeyboardOEMToAnsi proc far
        ret                 ; used for non-graphics version
DummyKeyboardOEMToAnsi endp
endif

sEnd    CODE


;------------------------------------------------------------------------
;       I N I T D A T A    S E G M E N T    V A R I A B L E S
;------------------------------------------------------------------------

DataBegin INIT

globalW oNRSeg,0
globalW oMSeg,0
globalD lpBootApp,0             ; Long pointer to app to run after booting
ifndef WOW
; WOW doesn't muck with WOAName buffer, we leave it as WINOLDAP.MOD
labelB  <PUBLIC,woa_286>
        db 'WINOLDAP.MOD'
labelB  <PUBLIC,woa_386>
        db 'WINOA386.MOD'
endif
labelB  <PUBLIC,bootExecBlock>
        EXECBLOCK <0,0,0,0>
globalW win_show,2
        dw      1               ; show open window

DataEnd INIT

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\kernel.h ===
/*
 *  KERNEL.H - C header file for all C kernel files
 *
 */

/*
 * The following is defined as the null string as the kernel is compiled
 * with the -PLM switch
 */
#ifndef PASCAL
#define PASCAL
#endif

#define BUILDDLL 1
#define	PMODE	 1
/*
 * Define the following non-zero and the debugging support in the kernel
 * is enabled
 */
#ifndef WINDEBUG
#define KDEBUG 0
#else
#define KDEBUG 1
#endif

#ifdef ROMWIN
#define ROM 1
#else
#define ROM 0
#endif

/* Register definition. */
#define REG
#define LONG       long
#define NULL       0

/* Define common constants. */
#define TRUE    1
#define FALSE   0

/* Far and Near dummy pointer attributes. */
#define FAR  far
#define NEAR near
typedef char far *FARP;
typedef char *NEARP;
typedef char far *LPSTR;
typedef char *PSTR;
typedef int ( far PASCAL * FARPROC )();
typedef int ( near PASCAL * NEARPROC )();
/* Standard types. */
typedef unsigned long     DWORD;
typedef unsigned short int WORD;
typedef WORD *pWORD;
typedef unsigned char      BYTE;
typedef int  BOOL;
#define VOID void

typedef WORD HANDLE;

typedef struct {
    WORD Offset;
    WORD Segment;
    } FARADDR;
typedef FARADDR *pFARADDR;

/*
 * Internel near kernel procedures
 */

FARPROC StartProcAddress( HANDLE, int );
HANDLE  StartTask( HANDLE, HANDLE, HANDLE, FARPROC );
HANDLE  StartLibrary( HANDLE, FARP, FARPROC );
HANDLE  FindExeInfo( FARP, WORD );
FARP    GetStringPtr( HANDLE, int, WORD );
HANDLE  AddModule( HANDLE );
HANDLE  DelModule( HANDLE );
void    IncExeUsage( HANDLE );
void    DecExeUsage( HANDLE );
void    PreloadResources( HANDLE, int );
HANDLE  GetExePtr( HANDLE );
DWORD   GetStackPtr( HANDLE );
WORD    GetInstance( HANDLE );
HANDLE  LoadExeHeader( int, int, FARP );
HANDLE  TrimExeHeader( HANDLE );
int     AllocAllSegs( HANDLE );
HANDLE  LoadSegment( HANDLE, WORD, int, int );
WORD    MyLock( HANDLE );
HANDLE  MyFree( HANDLE );
HANDLE  MyResAlloc( HANDLE, WORD, WORD, WORD );


/*
 * Undocumented, exported kernel procedures
 */

#if KDEBUG
#ifdef WOW
LPSTR far GetDebugString( int );
#else
LPSTR GetDebugString( int );
#endif
BOOL far   PASCAL GlobalInit( WORD, WORD, WORD, WORD );
WORD far * PASCAL GlobalInfoPtr( void );
#define GlobalFreeze( dummy ) ( *(GlobalInfoPtr()+1) += 1 )
#define GlobalMelt( dummy )   ( *(GlobalInfoPtr()+1) -= 1 )
#endif

void        PASCAL PatchStack( WORD far *, WORD, WORD );
WORD far *  PASCAL SearchStack( WORD far *, WORD );

int         far PASCAL SetPriority( HANDLE, int );
HANDLE      far PASCAL LockCurrentTask( BOOL );
HANDLE      far PASCAL GetTaskQueue( HANDLE );
HANDLE      far PASCAL SetTaskQueue( HANDLE, HANDLE );
WORD        far PASCAL GetCurrentPDB( void );
WORD        far PASCAL BuildPDB( WORD, WORD, FARP, WORD );
void        far PASCAL EnableDOS( void );
void        far PASCAL DisableDOS( void );
BOOL        far PASCAL IsScreenGrab( void );

HANDLE      far PASCAL CreateTask( DWORD, FARP, HANDLE);
HANDLE      far PASCAL GetDSModule( WORD );
HANDLE      far PASCAL GetDSInstance( WORD );
void        far PASCAL CallProcInstance( void );
FARPROC     far PASCAL SetTaskSignalProc( HANDLE, FARPROC );
FARPROC     far PASCAL SetTaskSwitchProc( HANDLE, FARPROC );
FARPROC     far PASCAL SetTaskInterchange( HANDLE, FARPROC );
void        far PASCAL ExitKernel( int );


/*
 * Exported procedures for KERNEL module
 */

/*
 * Interface to FatalExit procedure
 */

void far PASCAL FatalExit( int );
void far PASCAL ValidateCodeSegments();

/* Interface to Catch and Throw procedures */

typedef int CATCHBUF[ 9 ];
typedef int FAR *LPCATCHBUF;
int         FAR PASCAL Catch( LPCATCHBUF );
void        FAR PASCAL Throw( LPCATCHBUF, int );


/*
 * Interface to local memory manager
 */

#define LMEM_FIXED          0x0000
#define LMEM_MOVEABLE       0x0002
#define LMEM_NOCOMPACT      0x0010
#define LMEM_NODISCARD      0x0020
#define LMEM_ZEROINIT       0x0040
#define LMEM_MODIFY         0x0080
#define LMEM_DISCARDABLE    0x0F00

#define LNOTIFY_OUTOFMEM 0
#define LNOTIFY_MOVE     1
#define LNOTIFY_DISCARD  2

BOOL    far PASCAL LocalInit( WORD, char *, char * );
HANDLE  far PASCAL LocalAlloc( WORD, WORD );
HANDLE  far PASCAL LocalReAlloc( HANDLE, WORD, WORD );
HANDLE  far PASCAL LocalFree( HANDLE );
char *  far PASCAL LocalLock( HANDLE );
BOOL    far PASCAL LocalUnlock( HANDLE );
WORD    far PASCAL LocalSize( HANDLE );
HANDLE  far PASCAL LocalHandle( WORD );
WORD    far PASCAL LocalCompact( WORD );
FARPROC far PASCAL LocalNotify( FARPROC );
int     far PASCAL LocalNotifyDefault( int, HANDLE, WORD );
#define LocalDiscard( h ) LocalReAlloc( h, 0, LMEM_MOVEABLE )

extern WORD * PASCAL pLocalHeap;

#define dummy 0
#define LocalFreeze( dummy ) ( *(pLocalHeap+1) += 1 )
#define LocalMelt( dummy )   ( *(pLocalHeap+1) -= 1 )
#define LocalHandleDelta( delta ) ( (delta) ? (*(pLocalHeap+9) = (delta)) : *(pLocalHeap+9))

#define calloc( n,size )    LocalAlloc( LMEM_ZEROINIT, n*(size) )
#define malloc( size )      LocalAlloc( 0, size )
#define free( p )           LocalFree( p )
#define realloc( p, size )  LocalReAlloc( p, size, LMEM_ZEROINIT )

/*
 * Interface to global memory manager
 */

#define GMEM_FIXED          0x0000
#define GMEM_ALLOCHIGH      0x0001      /* Kernel use only */
#define GMEM_MOVEABLE       0x0002
#define GMEM_DISCCODE       0x0004
#define GMEM_NOCOMPACT      0x0010
#define GMEM_NODISCARD      0x0020
#define GMEM_ZEROINIT       0x0040
#define GMEM_MODIFY         0x0080
#define GMEM_DISCARDABLE    0x0100
#define GMEM_SHARE          0x1000
#define GMEM_SHAREALL       0x2000

#define GNOTIFY_OUTOFMEM 0
#define GNOTIFY_MOVE     1
#define GNOTIFY_DISCARD  2

#define HIWORD(l)  ((WORD)(((DWORD)(l) >> 16) & 0xFFFF))
#define LOWORD(l)  ((WORD)(DWORD)(l))

HANDLE      far PASCAL GlobalAlloc( WORD, DWORD );
HANDLE      far PASCAL GlobalReAlloc( HANDLE, DWORD, WORD );
HANDLE      far PASCAL GlobalFree( HANDLE );
HANDLE      far PASCAL GlobalFreeAll( WORD );
char far *  far PASCAL GlobalLock( HANDLE );
BOOL        far PASCAL GlobalUnlock( HANDLE );
DWORD       far PASCAL GlobalSize( HANDLE );
DWORD       far PASCAL GlobalHandle( WORD );
DWORD	    far PASCAL GlobalHandleNoRIP( WORD );
HANDLE      far PASCAL LockSegment( WORD );
HANDLE      far PASCAL UnlockSegment( WORD );
DWORD       far PASCAL GlobalCompact( DWORD );
#define LockData( dummy )   LockSegment( 0xFFFF )
#define UnlockData( dummy ) UnlockSegment( 0xFFFF )
#define GlobalDiscard( h ) GlobalReAlloc( h, 0L, GMEM_MOVEABLE )


/*
 * Interface to the task scheduler
 */

BOOL        far PASCAL Yield( void );
BOOL        far PASCAL WaitEvent( HANDLE );
BOOL        far PASCAL PostEvent( HANDLE );
HANDLE      far PASCAL GetCurrentTask( void );
BOOL        far PASCAL KillTask( HANDLE );


/*
 * Interface to the dynamic loader/linker
 */

HANDLE      far PASCAL LoadModule( LPSTR, LPSTR );
void        far PASCAL FreeModule( HANDLE );
HANDLE      far PASCAL GetModuleHandle( LPSTR );
FARPROC     far PASCAL GetProcAddress(  HANDLE, LPSTR );
FARPROC     far PASCAL MakeProcInstance( FARPROC, HANDLE );
void        far PASCAL FreeProcInstance( FARPROC );
int         far PASCAL GetInstanceData( HANDLE, PSTR, int );
int         far PASCAL GetModuleUsage( HANDLE );
int         far PASCAL GetModuleFileName( HANDLE, LPSTR, int );


/*
 * Interface to the resource manager
 */

HANDLE      far PASCAL FindResource( HANDLE, LPSTR, LPSTR );
HANDLE      far PASCAL LoadResource( HANDLE, HANDLE );
BOOL        far PASCAL FreeResource( HANDLE );

char far *  far PASCAL LockResource( HANDLE );

FARPROC     far PASCAL SetResourceHandler( HANDLE, LPSTR, FARPROC );
HANDLE      far PASCAL AllocResource( HANDLE, HANDLE, DWORD );
WORD        far PASCAL SizeofResource( HANDLE, HANDLE );
int         far PASCAL AccessResource( HANDLE, HANDLE );

#define MAKEINTRESOURCE(i)  (LPSTR)((unsigned long)((WORD)i))

/* Predefined resource types */
#define RT_CURSOR       MAKEINTRESOURCE( 1 )
#define RT_BITMAP       MAKEINTRESOURCE( 2 )
#define RT_ICON         MAKEINTRESOURCE( 3 )
#define RT_MENU         MAKEINTRESOURCE( 4 )
#define RT_DIALOG       MAKEINTRESOURCE( 5 )
#define RT_STRING       MAKEINTRESOURCE( 6 )
#define RT_FONTDIR      MAKEINTRESOURCE( 7 )
#define RT_FONT         MAKEINTRESOURCE( 8 )


/*
 * Interface to the user profile

int         far PASCAL GetProfileInt( LPSTR, LPSTR, int );
int         far PASCAL GetProfileString( LPSTR, LPSTR, LPSTR, LPSTR, int );
void        far PASCAL WriteProfileString( LPSTR, LPSTR, LPSTR );
 */


/*
 * Interface to the atom manager
 */

typedef WORD ATOM;

BOOL        far PASCAL InitAtomTable( int );
ATOM        far PASCAL FindAtom( LPSTR );
ATOM        far PASCAL AddAtom( LPSTR );
ATOM        far PASCAL DeleteAtom( ATOM );
WORD        far PASCAL GetAtomName( ATOM, LPSTR, int  );
HANDLE      far PASCAL GetAtomHandle( ATOM );

#define MAKEINTATOM(i)  (LPSTR)((unsigned long)((WORD)i))

#define ATOMSTRUC struct atomstruct
typedef ATOMSTRUC *PATOM;
typedef ATOMSTRUC {
    PATOM chain;
    WORD  usage;             /* Atoms are usage counted. */
    BYTE  len;               /* length of ASCIZ name string */
    BYTE  name;              /* beginning of ASCIZ name string */
} ATOMENTRY;

typedef struct {
    int     numEntries;
    PATOM   pAtom[ 1 ];
} ATOMTABLE;

extern ATOMTABLE * PASCAL pAtomTable;


/*
 * Interface to the string functions
 */

int         far PASCAL lstrcmp( LPSTR, LPSTR );
LPSTR       far PASCAL lstrcpy( LPSTR, LPSTR );
LPSTR       far PASCAL lstrcat( LPSTR, LPSTR );
int         far PASCAL lstrlen( LPSTR );
LPSTR       far PASCAL lstrbscan( LPSTR, LPSTR );
LPSTR       far PASCAL lstrbskip( LPSTR, LPSTR );

/*
 * Interface to the file I/O functions
 */

int         far PASCAL OpenPathname( LPSTR, int );
int         far PASCAL DeletePathname( LPSTR );
int         far PASCAL _lopen( LPSTR, int );
void        far PASCAL _lclose( int );
int         far PASCAL _lcreat( LPSTR, int );
LONG        far PASCAL _llseek( int, long, int );
WORD        far PASCAL _lread( int, LPSTR, int );
WORD        far PASCAL _lwrite( int, LPSTR, int );
BOOL        FAR PASCAL AnsiToOem( LPSTR, LPSTR );
BOOL        FAR PASCAL OemToAnsi( LPSTR, LPSTR );
BYTE        FAR PASCAL AnsiUpper( LPSTR );
BYTE        FAR PASCAL AnsiLower( LPSTR );
LPSTR       FAR PASCAL AnsiNext( LPSTR );
LPSTR       FAR PASCAL AnsiPrev( LPSTR, LPSTR );

typedef struct  {
        BYTE    cBytes;                 /* length of structure */
        BYTE    fFixedDisk;             /* non-zero if file located on non- */
                                        /* removeable media */
        WORD    nErrCode;               /* DOS error code if OpenFile fails */
        BYTE    reserved[ 4 ];
        BYTE    szPathName[ 128 ];
} OFSTRUCT;
typedef OFSTRUCT      *POFSTRUCT;
typedef OFSTRUCT NEAR *NPOFSTRUCT;
typedef OFSTRUCT FAR  *LPOFSTRUCT;

int         FAR PASCAL GetTempFileName( BYTE, LPSTR, WORD, LPSTR );
int         FAR PASCAL OpenFile( LPSTR, LPOFSTRUCT, WORD );
int        NEAR PASCAL MyOpenFile( LPSTR, LPOFSTRUCT, WORD );

/* Flags for GetTempFileName */

#define TF_FORCEDRIVE   (BYTE)0x80  /* Forces use of current dir of passed */
                                    /* drive */
/* Flags for OpenFile */

#define OF_REOPEN       0x8000
#define OF_EXIST        0x4000
#define OF_PROMPT       0x2000
#define OF_CREATE       0x1000
#define OF_CANCEL       0x0800
#define OF_VERIFY       0x0400
#define OF_DELETE       0x0200
/* Can use these with _lopen too */
#define	OF_SHARE_COMPAT	    0x00
#define	OF_SHARE_EXCLUSIVE  0x10
#define	OF_SHARE_DENY_WRITE 0x20
#define	OF_SHARE_DENY_READ  0x30
#define	OF_SHARE_DENY_NONE  0x40
#define	OF_NO_INHERIT	    0x80
			     	
#define READ        0       /* Flags for _lopen */
#define WRITE       1
#define READ_WRITE  2

#if KDEBUG
int PASCAL KernelError( int, LPSTR, LPSTR );
void far PASCAL FarKernelError( int, LPSTR, LPSTR );
#else
#define FarKernelError( a, b, c ) FatalExit( a )
#endif

/* See KERNEL.INC for parallel definitions */

#define ERR_LMEM        0x0100      /* Local memory manager errors */
#define ERR_GMEM        0x0200      /* Global memory manager errors */
#define ERR_TASK        0x0300      /* Task scheduler errors */

#define ERR_LD          0x0400      /* Dynamic loader/linker errors */
#define ERR_LDBOOT      0x0401      /* Error booting */
#define ERR_LDLOAD      0x0401      /* Unable to load a file */

#define ERR_RESMAN      0x0500      /* Resource manager errors */
#define ERR_MISSRES     0x0501      /* Missing resource table */
#define ERR_BADRESTYPE  0x0502      /* Bad resource type */
#define ERR_BADRESNAME  0x0503      /* Bad resource name */
#define ERR_BADRESFILE  0x0504      /* Bad resource file */
#define ERR_BADDEFAULT  0x0506      /* Bad parameter to profile routine */

#define ERR_ATOM        0x0600      /* Atom manager errors */
#define ERR_IO          0x0700      /* I/O package errors */

#define ERR_PARAMETER   0x0800      /* Parameter checking RIP */

#define HE_DISCARDED    0x40
#define HE_SHAREALL     0x20
#define HE_SHARE        0x10
#define HE_DISCARDABLE  0x0F

#define HE_FREEHANDLE   0xFFFF

#define LHE_DISCARDED    0x40
#define LHE_SHAREALL     0x20
#define LHE_SHARE        0x10
#define LHE_DISCARDABLE  0x0F

#define LHE_FREEHANDLE   0xFFFF

#define HANDLEENTRY struct handleentry
#define HANDLETABLE struct handletable
#define LOCALHANDLEENTRY struct localhandleentry
#define LOCALHANDLETABLE struct localhandletable
#define FREEHANDLEENTRY struct freehandleentry
#define LOCALFREEHANDLEENTRY struct localfreehandleentry

HANDLEENTRY {
    WORD    he_address;
    BYTE    he_flags;
    BYTE    he_seg_no;
};
typedef HANDLEENTRY *PHANDLEENTRY;

HANDLETABLE {
    WORD    ht_count;
    HANDLEENTRY    ht_entry[ 1 ];
};
typedef HANDLETABLE *PHANDLETABLE;

LOCALHANDLEENTRY {
    WORD    lhe_address;
    BYTE    lhe_flags;
    BYTE    lhe_count;
};
typedef LOCALHANDLEENTRY *PLOCALHANDLEENTRY;

LOCALHANDLETABLE {
    WORD    ht_count;
    LOCALHANDLEENTRY    ht_entry[ 1 ];
};
typedef LOCALHANDLETABLE *PLOCALHANDLETABLE;

FREEHANDLEENTRY {
    WORD    he_link;
    WORD    he_free;
};
typedef FREEHANDLEENTRY *PFREEHANDLEENTRY;

LOCALFREEHANDLEENTRY {
    WORD    lhe_link;
    WORD    lhe_free;
};
typedef LOCALFREEHANDLEENTRY *PLOCALFREEHANDLEENTRY;

#define LOCALARENA struct localarena

LOCALARENA {
    LOCALARENA         *la_prev;
    LOCALARENA         *la_next;
    LOCALHANDLEENTRY   *la_handle;
};
typedef LOCALARENA *PLOCALARENA;

#define LOCALARENAFREE struct localarenafree

LOCALARENAFREE {
    LOCALARENAFREE     *la_prev;	/* previous block */
    LOCALARENAFREE     *la_next;	/* next block */
    int 		la_size;	/* size of block (includes header) */
    LOCALARENAFREE     *ls_free_prev;	/* previous free entry */
    LOCALARENAFREE     *la_free_next;	/* next free entry */
};
typedef LOCALARENAFREE *PLOCALARENAFREE;

#define LOCALSTATS struct localstats

LOCALSTATS {
    WORD ls_ljoin;
    WORD ls_falloc;
    WORD ls_fexamine;
    WORD ls_fcompact;
    WORD ls_ffound;
    WORD ls_ffoundne;
    WORD ls_malloc;
    WORD ls_mexamine;
    WORD ls_mcompact;
    WORD ls_mfound;
    WORD ls_mfoundne;
    WORD ls_fail;
    WORD ls_lcompact;
    WORD ls_cloop;
    WORD ls_cexamine;
    WORD ls_cfree;
    WORD ls_cmove;
};

typedef struct {
    WORD                hi_check;
    WORD                hi_freeze;
    WORD                hi_count;
    PLOCALARENA         hi_first;
    PLOCALARENA         hi_last;
    BYTE                hi_ncompact;
    BYTE                hi_dislevel;
    WORD                hi_distotal;
    LOCALHANDLETABLE   *hi_htable;
    LOCALHANDLEENTRY   *hi_hfree;
    WORD                hi_hdelta;
    NEARPROC            hi_hexpand;
    LOCALSTATS         *hi_pstats;

    FARPROC             li_notify;
    WORD                li_lock;
    WORD                li_extra;
    WORD		li_minsize;
} LOCALINFO;

typedef LOCALINFO *PLOCALINFO;

#define LA_BUSY     1
#define LA_MOVEABLE 2
#define LA_ALIGN   (LA_MOVEABLE+LA_BUSY)
#define LA_MASK    (~ LA_ALIGN)

typedef HANDLEENTRY     far *LPHANDLEENTRY;
typedef HANDLETABLE     far *LPHANDLETABLE;
typedef FREEHANDLEENTRY far *LPFREEHANDLEENTRY;

typedef LOCALHANDLEENTRY     far *LPLOCALHANDLEENTRY;
typedef LOCALHANDLETABLE     far *LPLOCALHANDLETABLE;
typedef LOCALFREEHANDLEENTRY far *LPLOCALFREEHANDLEENTRY;

#define GLOBALARENA struct globalarena

GLOBALARENA {
    BYTE            ga_count;
    WORD            ga_owner;
    WORD            ga_size;
    BYTE            ga_flags;
    WORD            ga_prev;
    WORD            ga_next;
    HANDLEENTRY    *ga_handle;
    HANDLEENTRY    *ga_lruprev;
    HANDLEENTRY    *ga_lrunext;
};

#define ga_sig ga_count

typedef GLOBALARENA far *LPGLOBALARENA;

typedef struct {
    WORD            hi_check;
    WORD            hi_freeze;
    WORD            hi_count;
    WORD            hi_first;
    WORD            hi_last;
    BYTE            hi_ncompact;
    BYTE            hi_dislevel;
    WORD            hi_distotal;
    HANDLETABLE    *hi_htable;
    HANDLEENTRY    *hi_hfree;
    WORD            hi_hdelta;
    NEARPROC        hi_hexpand;
    WORD           *hi_pstats;

    WORD            gi_lrulock;
    HANDLEENTRY    *gi_lruchain;
    WORD            gi_lrucount;
    WORD            gi_reserve;
    WORD            gi_disfence;
    WORD	    gi_alt_first;
    WORD	    gi_alt_last;
    WORD	    gi_alt_count;
    HANDLEENTRY	   *gi_alt_lruchain;
    WORD	    gi_alt_lrucount;
    WORD	    gi_alt_reserve;
    WORD	    gi_alt_disfence;
} GLOBALINFO;

typedef GLOBALINFO far *LPGLOBALINFO;

#define GA_SIGNATURE    0x4D
#define GA_ENDSIG       0x5A

#define GA_FIXED 1
#define GA_ALIGN GA_FIXED
#define GA_MASK  (~ GA_ALIGN)

#define lpGlobalArena( w ) (LPGLOBALARENA)((DWORD)(w) << 16)
#define lpHandleEntry( w ) (LPHANDLEENTRY)(pMaster | (WORD)(w))
#define lpHandleTable( w ) (LPHANDLETABLE)(pMaster | (WORD)(w))

/*
 * Structure passed between user profile routines
 */
typedef	struct {
	LPSTR	lpProFile;	/* Pointer to INI filename */
	LPSTR	lpBuffer;	/* Pointer to buffer containing file */
	int	hBuffer;	/* Handle of buffer */
	unsigned BufferLen;	/* Length of buffer */
	int	FileHandle;	/* File handle - -1 if not open */
	int	ProFlags;	/* Open, writing etc */
    WORD wClusterSize;  /* Cluster size on this drive */
	OFSTRUCT ProBuf;	/* OpenFile info */
} PROINFO;

/* WinFlags[0] */

#define	WF_PMODE	0x01	/* Windows is running in Protected Mode */
#define	WF_CPU286	0x02	/* Windows is running on an 80286 cpu */
#define	WF_CPU386	0x04	/*    "     "	"     "  " 80386 cpu */
#define	WF_CPU486	0x08	/* Windows is running on an 80486 cpu */
#define	WF_STANDARD	0x10	/* Running Windows/286 */
#define	WF_ENHANCED	0x20	/* Running Windows/386 */
#define	WF_CPU086	0x40	/* Windows is running on an  8086 cpu */
#define	WF_CPU186	0x80	/* Windows is running on an 80186 cpu */
			  	
/* WinFlags[1] */

#define	WF1_LARGEFRAME	0x01	/* Running in EMS small frame */
#define	WF1_SMALLFRAME	0x02	/* Running in EMS large frame */
#define	WF1_80x87	0x04	/* There is a co-processor present */
			  
#ifndef WINDEBUG

#include "ikernel.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\kernel.inc ===
; Include file for kernel assembler source files.

?PLM = 1
?WIN = 1
?NODATA = 1
?DF = 1
?386regs = 1
ifndef WINDEBUG
	KDEBUG = 0
	WDEBUG = 0
	DOS5 = 1		; Do not mark far stack frames.
else
	KDEBUG = 1
	WDEBUG = 1
endif

SHARE_AWARE = 0

BUILDDLL	equ	1
PMODE		equ	1

include cmacros.inc
include logerror.inc
include vint.inc

DEB_ERROR       equ DBF_ERROR
DEB_WARN        equ DBF_WARNING
DEB_TRACE       equ DBF_TRACE
DEB_FERROR      equ DBF_FATAL
DEB_krMemMan    equ DBF_KRN_MEMMAN
DEB_krLoadMod   equ DBF_KRN_LOADMODULE
DEB_krLoadSeg   equ DBF_KRN_SEGMENTLOAD
DEB_IERROR      equ DBF_ERROR
DEB_IWARN       equ DBF_WARNING
DEB_ITRACE      equ DBF_TRACE
DEB_IFERROR     equ DBF_FATAL

;DEB_ERROR       =  1
;DEB_WARN        =  2
;DEB_TRACE       =  4
;DEB_FERROR      =  8    ;; fatal error - terminate app
;DEB_IERROR      = 10h
;DEB_IWARN       = 20h
;DEB_ITRACE      = 40h
;DEB_IFERROR     = 80h ;; fatal error - terminate app
;DEB_FERRORS     = DEB_FERROR or DEB_IFERROR
;DEB_ERRORS      = DEB_ERROR OR DEB_IERROR OR DEB_FERRORS
;DEB_WARNS       = DEB_WARN OR DEB_IWARN
;DEB_TRACES      = DEB_TRACE OR DEB_ITRACE
;DEB_NOCRLF      = 8000h ;; No CR/LF in string
DEB_BREAKLEVEL  = 099h
DEB_INFOLEVEL   = 099h or 022h

if KDEBUG
  ;include win3deb.inc
  ;declare_debug kr
  ;declare_areas Kernel, kr, <MemMan, LoadMod, LoadSeg>

ifndef win3deb
externFP    _krDebugTest
endif

BegData	macro
  _DATA	SEGMENT PARA PUBLIC 'DATA'
endm

EndData	macro
  _DATA ENDS
endm

krDebugOut    macro   flags,msg
    local   a, b
    BegData
a label byte
ife ((flags and DBF_SEVMASK) - DBF_FATAL)
	db	"fatl"
elseife ((flags and DBF_SEVMASK) - DBF_ERROR)
	db	"err"
elseife ((flags and DBF_SEVMASK) - DBF_WARNING)
	db	"wn"
else
	db	"t"
endif
ifdef WOW
    db	    " W16Kernel: "
else
    db	    " Kernel: "
endif
    db	    msg
    db	    0ah
    db	    0
    EndData
    push    flags or DBF_KERNEL
    push    offset a
    call    _krDebugTest
endm

else
  krDebugOut macro flag, str, vals
  endm
endif

if1
ifndef ?DFSTACK
 ?DFSTACK1 = 0
else
 ?DFSTACK1 = 1
endif
endif

; Define IGROUP segments

createSeg   _TEXT,CODE,WORD,PUBLIC,CODE,IGROUP
createSeg   _INITTEXT,INITCODE,WORD,PUBLIC,CODE,IGROUP

defGrp IGROUP,CODE


; Define Non-resident segments (after "defGrp IGROUP")

createSeg   _NRESTEXT,NRESCODE,WORD,PUBLIC,CODE
createSeg   _MISCTEXT,MISCCODE,WORD,PUBLIC,CODE

; Define DGROUP segments

createSeg   _DATA,DATA,PARA,PUBLIC,DATA,DGROUP
createSeg   _GPFIX0,GPFIX0,WORD,PUBLIC,DATA,DGROUP  ; GP fault trapping
createSeg   _GPFIX,GPFIX,WORD,PUBLIC,DATA,DGROUP
createSeg   _GPFIX1,GPFIX1,WORD,PUBLIC,DATA,DGROUP
createSeg   _INITDATA,INITDATA,WORD,PUBLIC,DATA,DGROUP
if ?DFSTACK1
  createSeg   STACK,STACK,PARA,PUBLIC,DATA,DGROUP
endif
createSeg   _PADDATA,PADDATA,BYTE,PUBLIC,DATA,DGROUP

defGrp	    DGROUP,DATA


if ?CHKSTK1
externP <chkstk>
endif


DISCARD_HIGH	= 1
TONYS_EMS_STUFF = 0

if KDEBUG
RSHORT	equ	<>
else
RSHORT	equ	short
endif

.286

	.286p
	INTBASE = 90h
	RNTBASE = 45h

  ifndef PM386
	PMODE32 = 0
  else
	PMODE32 = 1
  endif

  ifndef ALIASTRACKING
	ALIASES = 0
  else
	ALIASES = 1
  endif


if1

ifdef FE_SB
	FFDBCS = 1
else
	FFDBCS = 0
endif

KRNLDS	EQU	<DATA>

ifdef ROMWIN
	ROM = 1
	if PMODE
	%OUT ROM Kernel requires Protect Mode
	.err
	endif
else
	ROM = 0
endif

outif	ROM,0,<ROM Windows kernel>

outif	KDEBUG,0,<Debug Kernel.>

outif	FFDBCS,0,<DBCS code enabled>

; The following three are obsolete, but they need to have the
; proper values so dead code doesn't get assembled, and live
; code does.

SDEBUG		equ	1

LDCHKSUM	equ	0

SWAPPRO		equ	0

endif

 ERR_LMEM  =   00100h  ; Local memory errors
 ERR_LMEMCRIT  =   00140h  ; Local heap is busy
 ERR_LMEMHANDLE  =   00180h  ; Invalid local handle
 ERR_LMEMLOCK  =   001C0h  ; LocalLock count overflow
 ERR_LMEMUNLOCK  =   001F0h  ; LocalUnlock count underflow

 ERR_GMEM  =   00200h  ; global memory errors
;ERR_GMEMCRIT  =   00240h  ; Critical section problems
 ERR_GMEMHANDLE  =   00280h  ; Invalid global handle
 ERR_GMEMLOCK  =   002C0h  ; globalLock count overflow
 ERR_GMEMUNLOCK  =   002F0h  ; globalUnlock count underflow

;ERR_TASK  =   00300h  ; task schedule errors
;ERR_TASKID  =   00301h  ; Invalid task ID
;ERR_TASKEXIT  =   00302h  ; Invalid exit system call
;ERR_TASKFRAME =   00303h  ; Invalid BP chain

;ERR_LD    =   00400h  ; dynamic loader/linker errors
;ERR_LDBOOT  =   00401h  ; Error during boot process
;ERR_LDLOAD  =   00402h  ; Error loading a module
;ERR_LDORD =   00403h  ; Invalid ordinal reference
;ERR_LDNAME  =   00404h  ; Invalid entry name reference
;ERR_LDPROC  =   00405h  ; Invalid start proc
ERR_LDMODULE	=   00406h	; Invalid module handle
;ERR_LDRELOC =   00407h  ; Invalid relocation record
;ERR_LDFWDREF  =   00408h  ; Error saving forward reference
;ERR_LDREADSEG =   00409h  ; Error reading segment contents
;ERR_LDREADREL =   00410h  ; Error reading segment contents
;ERR_LDDISK  =   00411h  ; Insert disk for specified file
ERR_LDNRTABLE	=   00412h	; Error reading non-resident table
;ERR_LDFILES =   00413h  ; Out of files
;ERR_LDINT3F =   004FFh  ; INT 3F handler unable to load segment

;ERR_RESMAN  =   00500h  ; resource manager/user profile errors
;ERR_MISSRES =   00501h  ; Missing resource table
;ERR_BADRESTYPE  =   00502h  ; Bad resource type
;ERR_BADRESNAME  =   00503h  ; Bad resource name
ERR_BADRESFILE	=   00504h	; Bad resource file
ERR_BADRESREAD	=   00505h	; Error reading resource
ERR_BADDEFAULT	=   00506h	; Bad default pointer for profile routine

;ERR_ATOM  =   00600h  ; atom manager errors

;ERR_IO    =   00700h  ; I/O package errors

ERR_PARAMETER   =   00800h      ; Internal KERNEL parameter validation

;** PTrace notification indexes.  See 2lddebug and 3lddebug
SDM_RIN 	=  9
SDM_BANKLINE	=  10
SDM_NEWTASK	=  11
SDM_FLUSHTASK	=  12
SDM_SWITCHOUT	=  13
SDM_SWITCHIN	=  14
SDM_KEYBOARD	=  15
SDM_MAXFUNC	=  15
SDM_LOADSEG	=  50h
SDM_MOVESEG	=  51h
SDM_FREESEG	=  52h
SDM_RELEASESEG	=  5Ch
SDM_GLOBALHEAP	=  3
SDM_CONWRITE	=  12h
SDM_CONREAD	=  1
SDM_DGH 	=  56h
SDM_DFL 	=  57h
SDM_DLL 	=  58h
SDM_LOADTASK	=  59h
SDM_POSTLOAD	=  60h
SDM_EXITCALL	=  62h
SDM_INT2	=  63h
SDM_LOADDLL	=  64h
SDM_DELMODULE	=  65h
; New notifications
SDM_LOGERROR	=  66h	    ; cx = error code, dx:bx = ptr to optional info
SDM_LOGPARAMERROR = 67h     ; es:bx = ptr to struct { err, lpfn, param };

if1
outif	?RIPAUX,0
endif

; DataBegin/End macros are used to bracket data items.	Examples:
;
; DataBegin			; in segment DATA
;	globalD flarp,0
; DataEnd
;
; DataBegin	INIT		; in segment INITDATA
;	globalW who_cares,1022
; DataEnd	INIT

DataBegin	macro	type
% sBegin  &type&%KRNLDS
assumes ds, %KRNLDS
	endm

DataEnd 	macro	type
assumes ds,nothing
sEnd	&type&%KRNLDS
	endm

;-----------------------------------------------------------------------
; cProcVDO  - cProc "Validate Debug Only"
;
; Same as cProc, except used for "Validate in Debug Only" entry points.
; Declares Iname if debug, name if retail.
;
cProcVDO macro  name,opts,savelist
  if KDEBUG
        cProc   <I&name>,<opts>,<savelist>
  else
        LabelFP <PUBLIC, I&name>
        cProc   <name>,<opts>,<savelist>
  endif
endm


;-----------------------------------------------------------------------
; LabelVDO
;
; Similar to LabelFP, except used for "validate in debug only" entry points.
; Declares Iname if debug, name if
;
LabelVDO macro  name
  if KDEBUG
        LabelFP <PUBLIC, I&name>
  else
        LabelFP <PUBLIC, I&name>
        LabelFP <PUBLIC, name>
  endif
endm
if KDEBUG

ife ?RIPAUX
externFP FarKernelError
ifndef WOW
externNP NearKernelError
endif
externFP	KOutDSStr
endif

ifdef WOW
externFP	<KernelError>
else
externNP	<KernelError>
endif

DataBegin
externB	szFKE	; "**** Fatal Kernel Error ****" - Only define the string once
DataEnd

kerror	macro	errcode,msg,segarg,offarg
	local	a
  ifnb	    <errcode>		;; Push either AX or errcode
	push	errcode			;; Don't trash AX anymore!
  else
	push	ax
  endif

  ifnb	<msg>				;; Put strings in DGROUP so jcond
    _DATA SEGMENT PARA PUBLIC 'DATA' ;; can be short (not jump around)
    a label byte
    db  '&msg',0
    _DATA ENDS
	push	dataOffset a
  else
	push	dataOffset szFKE
  endif

  ifnb	    <segarg>		;; Push seg:offset or NULLPTR
	push	segarg
	push	offarg
  else
	push	0
	push	0
  endif

  ifdef WOW
	call	FarKernelError		;; Call Kernel Error
  else
	call	NearKernelError		;; Call Kernel Error
  endif
endm

fkerror macro	errcode,msg,segarg,offarg
	local	a
  ifnb	    <errcode>		;; Push either AX or errcode
	push	errcode			;; Don't trash AX anymore!
  else
	push	ax
  endif

  ifnb	<msg>				;; Put strings in DGROUP so jcond
    _DATA SEGMENT PARA PUBLIC 'DATA' ;; can be short (not jump around)
    a label byte
    db  '&msg',0
    _DATA ENDS
	push	dataOffset a
  else
	push	dataOffset szFKE
  endif

  ifnb	<segarg>		;; Push seg:offset or NULLPTR
	push	segarg
	push	offarg
  else
	push	0
	push	0
  endif

	call	FarKernelError		;; Call Kernel Error
endm

mkerror macro	errcode,msg,segarg,offarg
	local	a
  ifnb	    <errcode>		;; Push either AX or errcode
	push	errcode			;; Don't trash AX anymore!
  else
	push	ax
  endif

  ifnb	<msg>				;; Put strings in DGROUP so jcond
    _DATA SEGMENT PARA PUBLIC 'DATA' ;; can be short (not jump around)
    a label byte
    db  '&msg',0
    _DATA ENDS
	push	dataOffset a
  else
	push	dataOffset szFKE
  endif

  ifnb	    <segarg>		;; Push seg:offset or NULLPTR
	push	segarg
	push	offarg
  else
	push	0
	push	0
  endif

	call	FarKernelError		;; Call Kernel Error
endm

else  ;; not KDEBUG

ifdef WOW ; For WOW we call FatalExitC which thunks to WK32FatalExit.
externFP        <FatalExitC>
kerror  macro   errcode,msg,segarg,offarg       ;; Non-Debug version
        cCall   FatalExitC,<errcode>
	endm

fkerror macro	errcode,msg,segarg,offarg	;; Non-Debug version
        cCall   FatalExitC,<errcode>
	endm

mkerror macro	errcode,msg,segarg,offarg	;; Non-Debug version
        cCall   FatalExitC,<errcode>
	endm
else  ;; not WOW
    ife ?RIPAUX		 ; Dont declare external in RIPAUX.ASM
        externFP	<FatalExitDeath>
    endif
kerror	macro	errcode,msg,segarg,offarg	;; Non-Debug version
	cCall	FatalExitDeath,<errcode>
	endm

fkerror macro	errcode,msg,segarg,offarg	;; Non-Debug version
	cCall	FatalExitDeath,<errcode>
	endm

mkerror macro	errcode,msg,segarg,offarg	;; Non-Debug version
	cCall	FatalExitDeath,<errcode>
	endm
endif  ;; not WOW
endif  ;; not KDEBUG

; define misc. register pairs
;
regptr	esax,es,ax
regptr	esbx,es,bx
regptr	essi,es,si
regptr	esdi,es,di
regptr	dsax,ds,ax
regptr	dsbx,ds,bx
regptr	dsdx,ds,dx
regptr	dssi,ds,si
regptr	dsdi,ds,di
regptr	csbx,cs,bx
regptr	csdx,cs,dx
regptr	cssi,cs,si
regptr	csdi,cs,di
regptr	dxax,dx,ax
regptr	ssbx,ss,bx
regptr	ssdi,ss,di

;	The jmpnext macro and associated symbols are used to generate
;	the fall-through chain and generate the labels required for
;	error checking.

??ji	=	0			;;Initial index value

jmpnext macro e
jn %??ji,%(??ji+1),e			;;Set next label
endm

jn macro i,j,e
.sall
??ji&i:
.xall
ifb <e>					;;If not the end of the chain
	db	03Dh			;;cmp ax, next two bytes
errn$	??ji&j,+2			;;next label must be two bytes away
endif
??ji=j					;;increment counter
endm

smov	macro	segreg1,segreg2
	push	segreg2
	pop	segreg1
endm

jmps	macro	n
	jmp	short n
endm

ret_far	macro	add_2_stack
ifnb	<add_2_stack>
	db	0CAh
	dw	add_2_stack
else
	db	0CBh
endif
	endm


entry	macro	routine
	extrn	routine		:near
	dw	Offset IGROUP:routine
	endm


STACK_SIGNATURE equ	'WD'
MPIT_SIGNATURE	equ	'TP'

INT21	macro
	int	21h		; Force an actual int 21h
	endm

DOSCALL	macro
	pushf
	push	cs
	call	near ptr Int21Handler	; Call our handler directly!
	endm

DOSFCALL	macro
	pushf
	call	far ptr Int21Handler	; Call our handler directly!
	endm

SetKernelDSNRes	macro	segreg   	; usable in kernel NRES segment
ifndef KDataSeg
externW KDataSeg
endif
ifnb	<segreg>
ifdifi	<segreg>,<es>
	mov	segreg, cs:KDataSeg
else
	mov	es, cs:KDataSeg
endif
	assumes <segreg>, %KRNLDS
else
	mov	ds, cs:KDataSeg
	assumes ds, %KRNLDS
endif
	endm

SetKernelDSMisc	macro	segreg		; usable in kernel MISC segment
ifndef MKDataSeg
externW MKDataSeg
endif
ifnb	<segreg>
ifdifi	<segreg>,<es>
	mov	segreg, cs:MKDataSeg
else
	mov	es, cs:MKDataSeg
endif
	assumes <segreg>, %KRNLDS
else
	mov	ds, cs:MKDataSeg
	assumes ds, %KRNLDS
endif
	endm

SetKernelDS	macro	segreg
ifndef MyCSDS
externW MyCSDS
endif
ifnb	<segreg>
ifdifi	<segreg>,<es>
	mov	segreg, cs:MyCSDS
else
	mov	es, cs:MyCSDS
endif
	assumes <segreg>, %KRNLDS
else
	mov	ds, cs:MyCSDS
	assumes ds, %KRNLDS
endif
	endm

UnSetKernelDS	macro	segreg
ifnb	<segreg>
	assumes	<segreg>, nothing
else
	assumes	ds, nothing
endif
	endm

ReSetKernelDS	macro	segreg
ifnb	<segreg>
	assumes <segreg>, %KRNLDS
else
	assumes ds, %KRNLDS
endif
	endm

CheckKernelDS	macro	segreg
	local	ok
if KDEBUG
ifndef MyCSDS
externW MyCSDS
endif
	push	ax
ifnb	<segreg>
	mov	ax, segreg
else
	mov	ax, ds
endif
	cmp	ax, cs:MyCSDS
	je	short ok
	int 3
ok:
	pop	ax
endif
	endm

SetKernelCSDword	macro	pdw, dwseg, dwoff
ifndef SetKernelCSDwordProc
externNP SetKernelCSDwordProc
endif
	cCall	SetKernelCSDwordProc,<pdw,dwseg,dwoff>
	endm

Critical_check	macro
	local	hey_dude
if KDEBUG
	push	ds
	mov	ds,pGlobalHeap
	cmp	ds:[gi_lrulock],0	; Make sure we're critical!
	jnz	short hey_dude
	int	3
hey_dude:
	pop	ds
endif
endm

TDB_check_ES	macro
	local	hey_dude
if KDEBUG
	cmp	es:[TDB_sig],TDB_SIGNATURE
	jz	short hey_dude
	int	3
hey_dude:
endif
endm

TDB_check_DS	macro
	local	hey_dude
if KDEBUG
	cmp	ds:[TDB_sig],TDB_SIGNATURE
	jz	short hey_dude
	int	3
hey_dude:
endif
endm

NE_check_ES	macro
	local	hey_dude
if KDEBUG
	cmp	es:[ne_magic],NEMAGIC
	jz	short hey_dude
	int	3
hey_dude:
endif
endm

NE_check_DS    macro
	local	hey_dude
if KDEBUG
	cmp	ds:[ne_magic],NEMAGIC
	jz	short hey_dude
	int	3
hey_dude:
endif
endm

ife 3-3
sel_check	macro reg
	local	hey_dude, aaarrrggghhh
if KDEBUG
	or	reg, reg
	jz	short hey_dude
	test	reg, 4h				; Must be LDT
	jz	short aaarrrggghhh
	test	reg,2h				; Must be ring 2 or 3
	jnz	short hey_dude			; yes, fine
aaarrrggghhh:
	int 3
        xor     reg, reg                    ; HACK!! bug 5896
hey_dude:
endif
	and	reg, not 7
endm

else

sel_check	macro reg
	local	hey_dude, aaarrrggghhh
if KDEBUG
	or	reg, reg
	jz	short hey_dude
	test	reg, 4h				; Must be LDT
	jnz	short hey_dude
	int 3
hey_dude:
endif
	and	reg, not 7
endm

endif

KBINFO		STRUC
kbRanges	DB	4 dup (0)  ; Far East ranges for KANJI
kbStateSize	DW	0	; #bytes of state info maintained by TOASCII
KBINFO		ENDS


EXECBLOCK	struc
envseg		dw	?	; seg addr of environment
lpcmdline	dd	?	; pointer to asciz command line
lpfcb1		dd	?	; default fcb at 5C
lpfcb2		dd	?	; default fcb at 6C
EXECBLOCK	ends

SYSINITVAR	STRUC
dpbhead		DD	?	; Head of DPB-FAT list
sfthead		DD	?	; Head of SFT table list
pclockdev	DD	?	; pointer to clock device
pcondev		DD	?	; pointer to console device
SYSI_MAXSEC	    DW	    ?		; maximum sector size
SYSI_BUF	    DD	    ?		; points to Hashinitvar
SYSI_CDS	    DD	    ?		; CDS list
SYSI_FCB	    DD	    ?		; FCB chain
SYSI_Keep	    DW	    ?		; keep count
SYSI_NUMIO	    DB	    ?		; Number of block devices
SYSI_NCDS	    DB	    ?		; number of CDS's
SYSI_DEV	    DD	    ?		; device list
SYSI_ATTR	    DW	    ?		; null device attribute word
SYSI_STRAT	    DW	    ?		; null device strategy entry point
SYSI_INTER	    DW	    ?		; null device interrupt entry point
SYSI_NAME	    DB	 8 DUP(?)	; null device name
SYSI_SPLICE	    DB	    0		; TRUE -> splicees being done
SYSI_IBMDOS_SIZE    DW	    ?		; DOS size in paragraphs
SYSI_IFS_DOSCALL@   DD	    ?		; IFS DOS service rountine entry
SYSI_IFS	    DD	    ?		; IFS header chain
SYSI_BUFFERS	    DW	    ?,0 	; BUFFERS= values (m,n)
SYSI_BOOT_DRIVE     DB	    ?		; boot drive A=1 B=2,..
SYSI_DWMOVE	    DB	    0		; 1 if 386 machine
SYSI_EXT_MEM	    DW	    0		; Extended memory size in KB.
SYSINITVAR	ENDS
;
; system file table
;
SFT		STRUC
sftLink		DD	?
sftCount	DW	?	; number of entries
sftFile		DB	?
SFT		ENDS

SFT_ENTRY3	STRUC
sf_ref_count3	DW	?	; number of processes sharing fcb
sf_mode3	DW	?	; mode of access
sf_attr3	DB	?	; attribute of file
sf_flags	DW	?
sf_devptr	DD	?
		DB	21 dup (?)	; this is 21 for DOS 3.1
sf_name		DB	?
SFT_ENTRY3	ENDS

DPB	STRUC
dpb_drive	DB	?	; Logical drive # assoc with DPB (A=0,B=1,...)
DPB	ENDS

devid_device	EQU	0080H	; true if a device
sf_isnet	EQU	8000H	; true if network drive


	INTVECTOR	= 00Bh
	INTSIZE 	= 8


HILO	STRUC
lo	DW	?
hi	DW	?
HILO	ENDS

SEGOFF	STRUC
off	DW	?
sel	DW	?
SEGOFF	ENDS


; CPU flags

CPUF_CARRY		= 0000000000000001b
;			= 0000000000000010b
CPUF_PARITY		= 0000000000000100b
;			= 0000000000001000b
CPUF_AUXCARRY		= 0000000000010000b
;			= 0000000000100000b
CPUF_ZERO		= 0000000001000000b
CPUF_SIGN		= 0000000010000000b
CPUF_TRAP		= 0000000100000000b
CPUF_INTERRUPT		= 0000001000000000b
CPUF_DIRECTION		= 0000010000000000b
CPUF_OVERFLOW		= 0000100000000000b
CPUF_IOPL		= 0011000000000000b
CPUF_NESTEDTASK 	= 0100000000000000b
;			= 1000000000000000b

; WM_FILESYSCHANGE message wParam value

WM_FILESYSCHANGE	= 0034h

FSC_CREATE		= 0
FSC_DELETE		= 1
FSC_RENAME		= 2
FSC_ATTRIBUTES		= 3
FSC_NETCONNECT		= 4
FSC_NETDISCONNECT	= 5
FSC_REFRESH		= 6
FSC_MKDIR		= 7
FSC_RMDIR		= 8

;  MessageBox type flags

MB_OK			= 0000H
MB_OKCANCEL		= 0001H
MB_ABORTRETRYIGNORE	= 0002H
MB_YESNOCANCEL		= 0003H
MB_RETRYCANCEL		= 0005H
MB_ICONHAND		= 0010H
MB_ICONQUESTION		= 0020H
MB_ICONEXCLAMATION	= 0030H
MB_ICONASTERISK		= 0040H
MB_DEFBUTTON1		= 0000H
MB_DEFBUTTON2		= 0100H
MB_DEFBUTTON3		= 0200H
MB_SYSTEMMODAL		= 1000H
MB_TASKMODAL            = 2000H

;  Conventional dialog box and message box command IDs

IDOK		=   1
IDCANCEL	=   2
IDABORT 	=   3
IDRETRY 	=   4
IDIGNORE	=   5
IDYES		=   6
IDNO		=   7

; SysErrorBox type flags

SEB_OK		= 0001h ; Button with "OK".
SEB_CANCEL	= 0002h ; Button with "Cancel"
SEB_YES 	= 0003h ; Button with "&Yes"
SEB_NO		= 0004h ; Button with "&No"
SEB_RETRY	= 0005h ; Button with "&Retry"
SEB_ABORT	= 0006h ; Button with "&Abort"
SEB_IGNORE	= 0007h ; Button with "&Ignore"
SEB_CLOSE       = 0008h ; Button with "Close"
SEB_DEFBUTTON	= 8000h ; Mask to make this button default

; ExitKernel/ExitWindows flags
EW_REBOOTSYSTEM = 43h

; Kernel Flags[0]

kf_restore_CtrlC	EQU	01h	; A task switch has occured.
kf_restore_disk		EQU	02h	; A task switch has occured.
kf_mondrian		EQU	04h	; Windows was started under Mondrian.
kf_check_free		EQU	08h	; Free memory checking requested.
kf_pUID			EQU	10h	; Time to call pUserInitDone.
kf_EMS_debug		EQU	20h	; Tell symdeb about pseudo discards.
kf_search_inst_stacks	EQU	40h	; In patchstack search module stacks.
kf_useslim32		EQU	80h	; Uses LIM 3.2 API (Intel Above Board)

; Kernel Flags[1]

kf1_WIN386		EQU	01h	; we are running under Windows/386
kf1_WINOLDAP		EQU	02h	; the app being loaded is WinOldAp
kf1_ABORTION		EQU	04h	; loading the automatic data segment?
kf1_HAVEHMA		EQU	08h	; High Memory Area is available
kf1_GLOBALNOTIFY	EQU	10h	; We're calling the app's notify proc.
kf1_MEMORYMOVED 	EQU	20h	; global memory was moved by gmove
;
kf1_A20ON		EQU	80h	; We have A20 on

; Kernel Flags[2]

KF2_GH_NORIP		EQU	01h	; don't rip in gdref if invalid handle
KF2_WIN_EXIT		EQU	02h	; we're past ExitKernel
KF2_APP_EXIT		EQU	04h	; we're in DOS 4C quitting an app
KF2_SYMDEB		EQU	08h	; symdeb or somesuch in installed
KF2_PTRACE		EQU	10h	; ptrace.dll is installed
KF2_DOSX		EQU	20h	; running under 286 DOS extender
KF2_WIN386CRAZINESS	EQU	40h	; i hate async notification!
KF2_TOOLHELP            EQU     80h     ; TOOLHELP.DLL callback installed

; WinFlags[0]

WF_PMODE		EQU	01h	; Windows is running in Protected Mode
WF_CPU286		EQU	02h	; Windows is running on an 80286 cpu
WF_CPU386		EQU	04h	;    "     "	"     "  " 80386 cpu
WF_CPU486		EQU	08h	; Windows is running on an 80486 cpu
WF_STANDARD		EQU	10h	; Running Windows/286
WF_ENHANCED		EQU	20h	; Running Windows/386
WF_CPU086		EQU	40h	; Windows is running on an  8086 cpu
WF_CPU186		EQU	80h	; Windows is running on an 80186 cpu

; WinFlags[1]

WF1_LARGEFRAME		EQU	01h	; Running in EMS small frame
WF1_SMALLFRAME		EQU	02h	; Running in EMS large frame
WF1_80x87		EQU	04h	; There is a co-processor present
WF1_PAGING		EQU	08h	; Paging is enabled
ifdef WOW
WF1_WINNT		EQU	40h	; Running on Windows NT WOW layer
endif

ifdef WOW
; DebugWOW
DW_DEBUG                EQU     0001h   ; 32-bit Debugger debugging wow
endif

; Note, WF_WIN286 + WF_PMODE indicates running under the 286 DOS extender

;  Flags for OpenFile

OF_READ 	    = 0000H
OF_WRITE	    = 0001H
OF_READWRITE	    = 0002H
OF_SHARE_COMPAT	    = 0000H
OF_SHARE_EXCLUSIVE  = 0010H
OF_SHARE_DENY_WRITE = 0020H
OF_SHARE_DENY_READ  = 0030H
OF_SHARE_DENY_NONE  = 0040H
OF_NO_INHERIT	    = 0080H
OF_PARSE	    = 0100H
OF_DELETE	    = 0200H
OF_VERIFY	    = 0400H
OF_CANCEL           = 0800H
OF_CREATE           = 1000H
OF_PROMPT           = 2000H
OF_EXIST            = 4000H
OF_REOPEN           = 8000H

TF_FORCEDRIVE   = 80H

MaxFileLen      equ     128

OPENSTRUC	STRUC
opLen	db	?
opDisk	db	?
opXtra	dw	?
opDate	dw	?
opTime	dw	?
opFile	db	?
OPENSTRUC	ENDS

; GetAppCompatFlags/TDB_CompatFlags flag values

GACF_IGNORENODISCARD	EQU	0001h	; Ignore GA_NODISCARD on GlobalAlloc
GACF_HACKWINFLAGS       EQU     0400h   ; mask out new win31 flags ie. WF_PAGING
GACF_WINVER31           equ     00200000h ;Lie about windows version
HIW_GACF_WINVER31       equ     0020h
GACFE_INCREASESTACK	EQU     0040h   ; Increase the stack size for ALDUS
GACF_31VALIDMASK        EQU     0FFE484AFh       ; valid bits for 3.1+ apps
HIW_GACF_31VALIDMASK    EQU     0FFE4h
LOW_GACF_31VALIDMASK    EQU         084AFh
GACF_IGNOREFAULTS	EQU	002000000h
GACF_ALWAYSZEROINIT	EQU	000400000h ;Always do GA_ZEROINIT on GlobalAlloc (overloads GACF_INCREASESTACK)
GACF_MODULESPECIFIC     equ     000040000h ;Module-specific hack

; Look for module in Module Compatibilty section of win.ini
MCF_FIXEDSEGLOW       = 00001h  ; Win31 behaviour for FIXED segs
MCF_MODPATCH          = 00002h  ; Look for module patches in the registry
MCF_NODISCARD         = 00004h  ; Make all segments in the module not discardable
MCF_MODPATCH_X86      = 08000h  ; Apply this module patch on x86 only
MCF_MODPATCH_RISC     = 04000h  ; Apply this module patch on RISC only

ifdef	JAPAN
;
; INT 41H SIGNATURE
; Some Japanese OEM want to use interrupt vector other than 41h for
; debugger hook since this vector already used by system hardware.
; We won't disclose sources for Kernel, OEM should change vector
; number by 'patch'ing. The following macro appears below the 'INT 41H'
; instruction so that OEM can find the patch position by searching this
; signature string.
INT41SIGNATURE macro
	jmp	short @F
	db	'DEB41PATCH'
@@:
	endm
endif	;JAPAN

DebInt	macro	val
  ifnb	<val>
	mov	ax, val
  endif
	int	41h
  ifdef	JAPAN
	jmp	short @F
	db	'DEB41PATCH'
  @@:
  endif
endm


;
; Structure passed between user profile routines
;
PROINFO	struc
	lpProFile	dd	?	; Pointer to INI filename
	lpBuffer	dd	?	; Pointer to buffer containing file
	hBuffer		dw	?	; Handle of buffer
	BufferLen	dw	?	; Length of buffer
	FileHandle	dw	? 	; File handle - -1 if not open
	ProFlags	dw	?	; Open, writing etc
        wClusterSize    dw      ?       ; Bytes/cluster on current disk
	ProBuf		db	(SIZE OPENSTRUC + MaxFileLen - 1) dup(?)
PROINFO	ends

; -------------------------------------------------------
; This macro displays a string if DEBUG
;

Trace_Out MACRO String, nocrlf
  LOCAL a
IF KDEBUG
  _DATA SEGMENT PARA PUBLIC 'DATA' ;; (not jump around)
    a label byte
ifdef WOW
    db	"W16KERNEL: "
endif
    db  String
    IFB <nocrlf>
	    db	0dh, 0ah
    ENDIF
    db	0
  _DATA ENDS
	push	dataOffset a
	call    KOutDSStr
ENDIF
	ENDM

move	MACRO	reg,var
	mov	reg,var
	endm

WOWTrace MACRO	String,args
	LOCAL	String_Offset, Skip
IFDEF WOWDEBUGTRACE
	irp	arg,<args>
	move	arg
	endm

	jmps	Skip
String_Offset db	"W16KERNEL:",String,0Dh,0Ah,0
Skip:
	push	ds
	pushf
	pusha

	mov	ax,cs			; make sure string is addressable
	mov	ds,ax

	lea	si, String_Offset	; LEA to stop link whining
		
ifndef	KOutDebugStr
externFP KOutDebugStr
endif

	call	KOutDebugStr
	
	popa		
	popf
	pop	ds
ENDIF
	ENDM

; -------------------------------------------------------
; This macro displays a string and breaks if DEBUG
;

Debug_Out MACRO String
IF KDEBUG
	Trace_Out   <String>
	int	3
ENDIF
	ENDM

;
; Error reporting constants (from windows.h)
;
; Error option flags (set by [kernel] ErrorOptions win.ini variable)

ERO_PARAM_ERROR_BREAK	equ 0001h
ERO_BUFFER_FILL 	equ 0002h

; Debug fill constants

DBGFILL_ALLOC		equ 0fdh
DBGFILL_FREE		equ 0fbh
DBGFILL_BUFFER		equ 0f9h
DBGFILL_STACK		equ 0f7h

include winkern.inc

ifndef WINDEBUG
include ikernel.inc
endif

ifdef WOW
STIRET	MACRO
	LOCAL	Dont_Do_STI
	push	ax
	pushf
	pop	ax
	test	ah, 2
	pop	ax
	jnz	SHORT Dont_Do_STI
        FSTI
Dont_Do_STI:
	FIRET
	ENDM
else
STIRET	MACRO
	LOCAL	Dont_Do_STI
if PMODE32
	push	ax
	pushf
	pop	ax
	test	ah, 2
	pop	ax
	jnz	SHORT Dont_Do_STI
        FSTI
Dont_Do_STI:
endif
	FIRET
	ENDM
endif; WOW


ife ?RIPAUX
externFP 	LogError
endif

KernelLogError  macro   flags, errcode, msg
    krDebugOut <flags>,<msg>
    push    errcode
    push    0
    push    0
    call    LogError
endm

; Load Module error return codes
; Used by LD.asm, LDHEADER.asm, etc.
LME_MEM 	= 0	; Out of memory					;
LME_FNF		= 2	; File not found
LME_LINKTASK 	= 5	; can't link to task				;
LME_LIBMDS 	= 6	; lib can't have multiple data segments		;
LME_VERS 	= 10	; Wrong windows version				;
LME_INVEXE 	= 11	; Invalid exe					;
LME_OS2 	= 12	; OS/2 app					;
LME_DOS4 	= 13	; DOS 4 app					;
LME_EXETYPE 	= 14	; unknown exe type				;
LME_RMODE 	= 15	; not a pmode windows app 			;
LME_APPMDS 	= 16	; multiple data segments in app			;
LME_EMS 	= 17	; scum app in l-frame EMS 			;
LME_PMODE 	= 18	; not an rmode windows app			;
LME_COMP	= 19	; compressed EXE file				;
LME_INVCOMP 	= 20	; invalid DLL (component) caused EXE load fail	;
LME_PE		= 21	; Windows Portable EXE app - let them load it	;
LME_MAXERR      = 32    ; for comparisons                               ;

LME_WOAWOW32    = 23    ; For wow special handling of WOA

PEMAGIC = 4550h	; 'PE'


;
; Use these macros instead of a raw "int 3" and maybe we can tell
; later what is happening when we hit one!
;

; Put there by davidw or tonyg or even earlier.  Nobody knows
; what this is.
;
INT3_ANCIENT	macro
	int	3
endm


;
; Used find out what happens when a code path is executed.
; Should be ignoreable, but call a developer to make sure.
;
INT3_TEST	macro
	int	3
endm


;
; This code path should "never" be executed.
;
INT3_NEVER	macro
	int	3
endm


;
; Something strange, but not fatal.  Should be changed to output
; a message.
;
INT3_WARN	macro
	int	3
endm


;
; This is bad, real bad.
;
INT3_FATAL	macro
	int	3
endm


;
; Break in to debugger
;
INT3_DEBUG	macro
	int	3
endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\kernstub.asm ===
TITLE   KERNSTUB - Assembly stub program for KERNEL.EXE

.xlist
?DF = 1
SWAPPRO = 0

include cmacros.inc

; NOTE: This code is always assembled in real mode, so it'll run on any machine.
;

include newexe.inc
include protect.inc
ifdef WOW
include vint.inc
endif
.list

createSeg   _TEXT,CODE,PARA,PUBLIC,CODE
createSeg   STACK,STACK,PARA,STACK,STACK

sBegin  STACK
        DB  128 DUP (?)
stacktop    LABEL   BYTE
sEnd    STACK

sBegin  CODE
assumes CS,CODE
assumes DS,CODE


KERNSTUB        PROC    FAR
        push    cs
        pop     ds
        mov     si,codeOFFSET stacktop
        add     si,1FFh
        and     si,not 1FFh
	cmp	cs:[si].ne_magic,NEMAGIC
	je	@F
	jmp	ksfail
@@:

	mov	ax,ds

	cli
        mov     ss,ax
        mov     sp,si
	sti

        mov     bx,ds:[si].ne_autodata      ; Get number of automatic DS
        dec     bx
        jl      ksg11                       ; Continue if no DS
        shl     bx,1
        shl     bx,1
        shl     bx,1
	.errnz	8 - SIZE new_seg
        add     bx,ds:[si].ne_segtab        ; DS:BX -> seg. tab. entry for DS
        mov     ax,ds:[si+bx].ns_sector     ; Compute paragraph address of DS
        cmp     ds:[si].ne_align,0
        jne     ksg10
        mov     ds:[si].ne_align,NSALIGN    ; in DI
ksg10:
        mov     cx,ds:[si].ne_align         ; Convert sectors to paragraphs
        sub     cx,4
        shl     ax,cl
        mov     di,cs                       ; Add to paragraph address of old
        sub     di,20h                      ; exe header
        add     di,ax
ksg11:
	push	cx
	mov	bx,word ptr cs:[si].ne_csip+2	; Get number of CS
        dec     bx
        jl      ksfail                      ; Error if no CS
        shl     bx,1
        shl     bx,1
        shl     bx,1
	.errnz	8 - SIZE new_seg
	add	bx,cs:[si].ne_segtab	    ; DS:BX -> seg. tab. entry for CS
	mov	ax,cs:[si+bx].ns_sector     ; Compute paragraph address of CS
	mov	cx,cs:[si].ne_align	    ; Convert sectors to paragraphs
        sub     cx,4
        shl     ax,cl
	pop	bx

	mov	dx,cs			    ; Add to paragraph address of old
        sub     dx,20h                      ; exe header
        add     dx,ax
        push    dx                          ; Push far address of start proc
        push    word ptr cs:[si].ne_csip
        mov     ds,di                       ; DS:0 points to automatic DS
        mov     cx,si                       ; CX = file offset of new header
        add     cx,200h
        jmp     short ksgo
	org	0A0h
ksgo:

;!!! The old CS selector should be freed up at some point!

        mov	ax, "KO"
        ret                                 ; FAR return to start proc

ksfail:
        call    ks1
        DB      'KERNSTUB: Error during boot',13,10,'$'
ks1:    pop     dx
        push    cs
        pop     ds          ; DS:DX -> error message
        mov     ah,9        ; Print error message
        int     21h
        mov     ax,4C01h    ; Terminate program, exit code = 1
        int     21h

KERNSTUB        ENDP

sEnd    CODE

END KERNSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\lacheck.asm ===
.xlist
include kernel.inc
include gpfix.inc
.list

externW	pLocalHeap

DataBegin

externB kernel_flags
;externW MyCSDS

DataEnd

sBegin	CODE
assumes	CS,CODE

if KDEBUG

;-----------------------------------------------------------------------;
; CheckLocalHeap							;
; 									;
; 									;
; Arguments:								;
; 									;
; Returns:								;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Tue Jan 01, 1980 10:58:28p  -by-  David N. Weise   [davidw]          ;
; ReWrote it from C into assembly.					;
;-----------------------------------------------------------------------;

cProc	CheckLocalHeap,<PUBLIC,NEAR>,<di,si>

	localW	nrefhandles
	localW	nhandles
	localW	nfreehandles
	localW	nusedhandles
	localW	ndishandles
	localW  pbottom

cBegin
	beg_fault_trap  clh_trap
	xor	di,di
	xor	dx,dx			; For error codes.
	mov	bx,[di].pLocalHeap
	or	bx,bx
	jnz	have_a_heap
	jmp	clh_ret
have_a_heap:

        cmp     di,[bx].hi_check
	jnz	do_heap_check
	jmp	clh_ret
do_heap_check:

	mov	cx,[bx].hi_count
	mov	si,[bx].hi_first
	test	[si].la_prev,LA_BUSY
	jnz	first_should_be_busy
	or	dx,1			; Forward links invalid.
first_should_be_busy:

check_forward_links:
	mov	ax,[si].la_next
	cmp	ax,si
	jbe	end_of_line
	mov	si,ax
	loop	check_forward_links
end_of_line:

	cmp	ax,[bx].hi_last
	jnz	forward_bad
	cmp     cx,1
	jz      forward_good
;	jcxz	forward_good
forward_bad:
	or	dx,1			; Forward links invalid.
forward_good:

	mov	cx,[bx].hi_count
	mov	si,[bx].hi_last
	test	[si].la_prev,LA_BUSY
	jnz	last_should_be_busy
	or	dx,2			; Backward links invalid.
last_should_be_busy:

check_backward_links:
	mov	ax,[si].la_prev
	and	ax,0FFFCh
	cmp	ax,si
	jae	begin_of_line
	mov	si,ax
	loop	check_backward_links
begin_of_line:

	cmp	ax,[bx].hi_first
	jnz	backward_bad
	cmp	cx,1
	jz	backward_good
;	jcxz	backward_good
backward_bad:
	or	dx,2			; Backward links invalid.
backward_good:

	mov	cx,[bx].hi_count
	mov	si,[bx].hi_first
	mov	nrefhandles,0
count_referenced_handles:
	test	[si].la_prev,LA_BUSY
	jz	no_handle
	test	[si].la_prev,LA_MOVEABLE
	jz	no_handle
	mov	di,[si].la_handle
	cmp	[di].lhe_free,LHE_FREEHANDLE
	jnz	handle_not_free
	or	dx,4			; Block points to free handle.
	jmps	no_handle
handle_not_free:
	mov	ax,si
	add	ax,SIZE LocalArena
	cmp	ax,[di].lhe_address
	jz	handle_points_back
	or	dx,8			; Block -> handle but not vice versa
	jmps	no_handle
handle_points_back:
	inc	nrefhandles
no_handle:
	mov	si,[si].la_next
	loop	count_referenced_handles

	mov	di,[bx].hi_htable
	mov	nhandles,0
	mov	ndishandles,0
	mov	nusedhandles,0
	mov	nfreehandles,0

handle_block_loop:
	or	di,di
	jz	no_more_handle_blocks
	lea	si,[di].ht_entry[0]
	mov	cx,[di].ht_count
	add	nhandles,cx

handle_entry_loop:
	jcxz	next_handle_block
	dec	cx
	cmp	[si].lhe_free,LHE_FREEHANDLE
	jnz	not_free
	inc	nfreehandles
	jmps	next_handle_entry
not_free:
	test	[si].lhe_flags,LHE_DISCARDED
	jz	not_discarded
	inc	ndishandles
	jmps	next_handle_entry
not_discarded:
	inc	nusedhandles
next_handle_entry:
	add	si,SIZE LocalHandleEntry
	jmp	handle_entry_loop
next_handle_block:
	mov	di,[si].lhe_address
	jmp	handle_block_loop

no_more_handle_blocks:

	mov	ax,nusedhandles
	cmp	ax,nrefhandles
	jz	handles_match
	or	dx,10h			; allocated handles != used handles
handles_match:
	add	ax,nfreehandles
	add	ax,ndishandles
	cmp	ax,nhandles
	jz	total_number_okay
	or	dx,20h			; total number of handles dont add up
total_number_okay:

	xor	cx,cx
	mov	si,[bx].hi_hfree
count_free:
	or	si,si
	jz	counted_free
	inc	cx
	mov	si,[si].lhe_link
	jmp	count_free
counted_free:
	cmp	cx,nfreehandles
	jz	free_add_up
 	or	dx,40h			; total # of free handles dont add up
free_add_up:

; now check the free block list

	mov	si,[bx].hi_first
	mov	si,[si].la_free_next	; Sentinals not free.
	mov	ax,[bx].hi_last
	mov	pbottom,ax

check_free_list:
	cmp	si,[si].la_free_next
	jz	check_free_list_done
	mov	ax,[si].la_next
	sub	ax,si
	cmp	ax,[si].la_size
	jnz	free_list_corrupted	; invalid block size

        cmp     [bx].hi_check,2         ; if hi_check >= 2, check free.
        jb      dont_check_free

	mov	di,si
	add	di,SIZE LocalArenaFree
	mov	cx,[si].la_next
	sub	cx,di
        mov     al,DBGFILL_FREE
	smov	es,ds
	repz	scasb
	jnz	free_list_corrupted	; free block corrupted
dont_check_free:
	mov	ax,[si].la_free_next
	cmp	ax,si
	jbe	free_list_corrupted
	mov	si,ax
	cmp	ax,pbottom
	jbe	check_free_list

free_list_corrupted:
	krDebugOut	DEB_FERROR, "Local free memory overwritten at #ES:#DI"
	or	dx,80h

	end_fault_trap

check_free_list_done:
clh_ret:
	mov	ax,dx
cEnd
clh_trap:
	fault_fix_stack
	mov     dx, 80h
	jmp     clh_ret

endif

sEnd	CODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\lalloc.asm ===
TITLE	LALLOC - Local memory allocator

include kernel.inc

.errnz	 la_prev		; This code assumes la_prev = 0

externW pLocalHeap

DataBegin

externB Kernel_flags

DataEnd

sBegin	CODE
assumes CS,CODE

externNP lalign 	; LINTERF.ASM
externNP lnotify	; LINTERF.ASM
externNP lcompact	; LCOMPACT.ASM

if KDEBUG
externNP CheckLAllocBreak   ; LINTERF.ASM
endif

;-----------------------------------------------------------------------;
; ljoin									;
; 									;
; Join two blocks together, by removing one.				;
; 									;
; Arguments:								;
;	BX = address of block to remove					;
;	SI = address of block that points to the one to remove		;
; 									;
; Returns:								;
;	BX = address of block following [SI], after join		;
;	Updated hi_count field in the local arena info structure	;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Mon March 9, 1987  -by-  Bob Gunderson (bobgu)			;
; Added free list stuff.						;
;									;
;  Tue Oct 14, 1986 05:20:56p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

cProc	ljoin,<PUBLIC,NEAR>
cBegin nogen

    IncLocalStat    ls_ljoin

	push	di
	dec	[di].hi_count		; remove free block from arena
	mov	di,bx			; save ptr to block removing
	mov	bx,[bx].la_next		; Get address of block after
	and	[bx].la_prev,LA_ALIGN	; one we are removing.
	or	[bx].la_prev,si		; Change it's back link
	mov	[si].la_next,bx		; and change the forward link

; If it is free, remove the block at [DI] from the free list

	test	[di].la_prev,LA_BUSY
	jnz	join1
	xchg	bx,di
	call	lfreedelete		; delete from free list
	xchg	bx,di
join1:

; if the block at [SI] is free, set its new larger free block
; size.  If not free, then block at [DI] is about to become part
; of the previous busy block.

	test	[si].la_prev,LA_BUSY	; is it busy?
	jnz	joinexit		; yes

	push	ax
	mov	ax,bx
	sub	ax,si			; length of new free block
	mov	[si].la_size,ax
	pop	ax

if KDEBUG

; Fill new free block with DBGFILL_ALLOC

	xchg	si,bx
	call	lfillCC
	xchg	si,bx
endif

joinexit:
	pop	di
	ret
cEnd nogen


;-----------------------------------------------------------------------;
; lrepsetup                                                             ;
; 									;
; Sets up for a block store or move of words.				;
; 									;
; Arguments:								;
;	CX = #bytes							;
; 									;
; Returns:								;
;	CX = #words							;
;	ES = DS								;
;	DF = 0								;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Tue Oct 14, 1986 05:23:25p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

cProc	lrepsetup,<PUBLIC,NEAR>
cBegin nogen
	shr	cx,1
	push	ds
	pop	es
	cld
	ret
cEnd nogen


;-----------------------------------------------------------------------;
; lzero									;
; 									;
; Fills a block with zeros.						;
; 									;
; Arguments:								;
;	BX = address of last word +1 to zero				;
;	CX = address of first word to zero				;
; 									;
; Returns:								;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
;	CX,ES								;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Tue Oct 14, 1986 05:25:30p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

cProc	lzero,<PUBLIC,NEAR>
cBegin nogen
	push	di
	mov	di,cx		; DI = destination
	sub	cx,bx		; CX = - #bytes
	jae	zero1		; Do nothing if BX less than or equal to CX
	push	ax
	neg	cx
	xor	ax,ax
	call	lrepsetup	; Setup for stosw
	rep	stosw		; Zero it out
	pop	ax
zero1:
	pop	di
	ret
cEnd nogen


if KDEBUG
;-----------------------------------------------------------------------;
; lallocfill                                                            ;
; 									;
; Fills a block with DBGFILL_ALLOC                                      ;
; 									;
; Arguments:								;
;	BX = address of last word +1 to zero				;
;	CX = address of first word to zero				;
; 									;
; Registers Destroyed:							;
;	CX,ES								;
; 									;
;-----------------------------------------------------------------------;

cProc   lallocfill,<PUBLIC,NEAR>
cBegin  nogen
	push	di
	mov	di,cx		; DI = destination
	sub	cx,bx		; CX = - #bytes
        jae     @F              ; Do nothing if BX less than or equal to CX
	push	ax
	neg	cx
        mov     ax,(DBGFILL_ALLOC or (DBGFILL_ALLOC shl 8))
	call	lrepsetup	; Setup for stosw
	rep	stosw		; Zero it out
	pop	ax
@@:
	pop	di
	ret
cEnd    nogen

endif   ;KDEBUG

;-----------------------------------------------------------------------;
; lalloc								;
; 									;
; Actually allocates a local object.  Called from within the local	;
; memory manager's critical section.					;
; 									;
; Arguments:								;
;	AX = allocations flags						;
;	BX = #bytes							;
;	DI = address of local arena information structure		;
; 									;
; Returns:								;
;	AX = data address of block allocated or NULL			;
;	DX = allocation flags or size of largest free block		;
;	     if AX = 0							;
;	ZF = 1 if AX = 0						;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Mon March 9, 1986  -by- Bob Gunderson (bobgu)			;
; Changed the search algorithm to use the free list and added calls	;
; to add/remove blocks from the free list				;
;									;
;  Tue Oct 14, 1986 05:27:40p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

cProc	lalloc,<PUBLIC,NEAR>
cBegin nogen

if KDEBUG
        call    CheckLAllocBreak
        jnc     @F
        xor     ax,ax
        ret
@@:
endif

	push	si
	push	ax
	push	bx
	test	al,LA_MOVEABLE		; Moveable?
;	jnz	scanbwd 		; Yes, search backwards
	jz	@F
	jmp	scanbwd
@@:
    IncLocalStat    ls_falloc
	add	bx,la_fixedsize		; Room for fixed header
	call	lalign			; Get requested size in DX
	mov	bx,[di].hi_first	; No, start with first entry

; use free list to find a block to allocate
afwdloop:
	mov	ax,[bx].la_free_next	; get next free block
	cmp	ax,bx			; are we at end of arena ?
	jz	afwdcmp 		; yes try to compact....

    IncLocalStat    ls_fexamine
	mov	bx,ax
	cmp	dx,[bx].la_size 	; is it big enough?
	ja	afwdloop		; no, loop for next

; Here when we have a block big enough.
;   BX = address of block
;   DX = requested size, including fixed header

afwdfound:

if KDEBUG

; verify the block is filled with DBGFILL_FREE

	call	lcheckCC
	jz	afwdfound1		; all OK
        kerror  ERR_LMEM,<LocalAlloc: Local free memory overwritten>
afwdfound1:

endif

    IncLocalStat    ls_ffound
	mov	ax,la_fixedsize
	mov	cx,[bx].la_next 	; mov	cx,[bx].la_next
	sub	cx,LA_MINBLOCKSIZE	; CX = as low as we will go for free
	mov	si,bx			; Calculate address of new block
	add	si,dx			; (current block + requested size)
	cmp	si,cx			; Is it past the current next block
;;;;;;; jae	aexit1			; yes, use the whole block
	jb	afwdfound2
	jmp	aexit1
afwdfound2:

; Here with two blocks.
;   BX = address of existing block
;   SI = address of new block to add to arena as free space

    IncLocalStat    ls_ffoundne
	push	bx
	jmp	aexit


afwdcmp:
    IncLocalStat    ls_fcompact
	call	lcompact		; End of arena.	 Try compacting.
	cmp	ax,dx			; Room for requested size?
	jae	afwdfound		; Yes, exit search loop
afail:					; No, fail.
	push	ax			; Remember size of largest free block
	xor	bx,bx
	.errnz	LN_OUTOFMEM		; Notify client procedure
	xchg	ax,bx			; BX = size of largest free block
	mov	cx,dx			; CX = size we are looking for
	call	lnotify
	pop	dx			; DX = size of largest free block
	pop	bx			; BX = requested size
	pop	ax			; AX = flags
	pop	si			; Restore SI
;	jnz	lalloc			; Try again if notify procedure said to
	jz	@F
	jmp	lalloc
@@:
    IncLocalStat    ls_fail
	xor	ax,ax			; O.W. return zero, with Z flag set
	ret


scanbwd:
    IncLocalStat    ls_malloc
	add	bx,SIZE LocalArena	; Room for moveable header
	call	lalign			; Get requested size in DX
	mov	bx,[di].hi_last

; use free chain to find a block to aloocate

abwdloop:
    IncLocalStat    ls_mexamine
	mov	ax,[bx].la_free_prev	; previous free block
	cmp	ax,bx			; are we at beginning of arena ?
	jz	abwdcmp 		; yes try to compact....

	mov	bx,ax
	cmp	dx,[bx].la_size 	; Room for requested size?
	ja	abwdloop		; no, loop to previous free block
	jmps	abwdfound		; yes, alloocate the memory

; Beginning of arena.  Try compacting.	If that fails then too bad

abwdcmp:
    IncLocalStat    ls_mcompact
	call	lcompact
	cmp	ax,dx			; Room for requested size?
	jb	afail			; No, fail
	mov	si,ax			; Yes, get free size in SI

abwdfound:

if KDEBUG

; verify the block is filled with DBGFILL_FREE

	call	lcheckCC
	jz	abwdfound1		; all OK
        kerror  ERR_LMEM,<LocalAlloc: Local free memory overwritten>
abwdfound1:
endif

    IncLocalStat    ls_mfound
	mov	ax,SIZE LocalArena
	mov	si,[bx].la_size 	; size of block found
	sub	si,dx			; SI = size of free block = total size
					; less requested size (includes header)
	mov	cx,si			; save what's left over
	add	si,bx			; SI = address of new block
	cmp	cx,LA_MINBLOCKSIZE	; enough room for another?
	jb	aexit1			; no, use entire block
	push	si

    IncLocalStat    ls_mfoundne

; Here with two blocks, in following order
;   BX = address of existing free block to make smaller
;   SI = address of new block to add to arena as busy
;   CX = address of block after new block

aexit:
	mov	cx,si
	xchg	[bx].la_next,cx
	mov	[si].la_prev,bx
	mov	[si].la_next,cx

; Here with allocated block
;   BX = address of found block
;   SI = address of new block after found block
;   CX = address of block after new block

	xchg	si,cx			; SI = block after new block
	and	[si].la_prev,LA_ALIGN	; CX = new block
	or	[si].la_prev,cx		; Point to new block
	inc	[di].hi_count		; We added an arena entry
	mov	si,bx			; SI = previous free block
	mov	bx,cx			; BX = new block after found block
	call	lfreeadd		; add this new block to free list
	sub	bx,si
	mov	[si].la_size,bx 	; set new free block size
	pop	bx			; BX = block we are allocating

aexit1:
	call	lfreedelete		; remove this block from free list
	add	ax,bx
	or	byte ptr [bx].la_prev,LA_BUSY	; Mark block as busy
	pop	dx			; Flush requested size
	pop	dx			; Restore flags
if KDEBUG
        test    dl,LA_ZEROINIT
        jnz     @F
        mov     cx,ax
        mov     bx,[bx].la_next
        call    lallocfill
        jmp     short aexit2
@@:
endif
	test	dl,LA_ZEROINIT		; Want it zeroed?
	jz	aexit2			; No, all done
	mov	cx,ax			; Yes, CX = 1st word to zero
	mov	bx,[bx].la_next		; BX = last word+1 to zero
	call	lzero			; Zero them
aexit2:
	pop	si
	or	ax,ax			; Return AX points to client portion
	ret				; of block allocated or zero
cEnd nogen


;-----------------------------------------------------------------------;
; lfree                                                                 ;
; 									;
; Marks a block as free, coalescing it with any free blocks before	;
; or after it.								;
; 									;
; Arguments:								;
;	BX = block to mark as free.					;
;	DI = address of local arena information structure		;
; 									;
; Returns:								;
;	SI = 0 if freed a fixed block.  				;
;	SI = handle table entry, for moveable blocks.			;
;	ZF =1 if SI = 0							;
;	Updated hi_count field in local arena information structure	;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
; 									;
; History:								;
;									;
;  Mon March 9, 1987  -by- Bob Gunderson (bobgu)			;
; Freed blocks are placed back on the free list 			;
;									;
;  Tue Oct 14, 1986 05:31:52p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

cProc	lfree,<PUBLIC,NEAR>
cBegin nogen
	mov	si,bx
	or	si,si
	jz	free4
	push	dx

	push	[bx].la_handle		; push possible handle

; Add block to free list

	push	si
	xor	si,si
	call	lfreeadd		; add this block to free list
	pop	si

; Clear any existing LA_BUSY and LA_MOVEABLE bits

	mov	dx,LA_BUSY + LA_MOVEABLE
	and	dx,[bx].la_prev
	xor	[bx].la_prev,dx
	and	dl,LA_MOVEABLE		; Moveable?
	pop	dx			; restore handle
	jnz	free1			; Yes, return handle in DX
	xor	dx,dx			; No, return 0 in DX
free1:
	mov	si,[bx].la_next		; SI = next block
	test	byte ptr [si].la_prev,LA_BUSY	; Is it free?
	jnz	free2			; No, continue
	xchg	bx,si
	call	ljoin			; Yes, coelesce with block in BX
	mov	bx,si
free2:
	mov	si,[bx].la_prev		; SI = previous block
	test	byte ptr [si].la_prev,LA_BUSY	; Is it free?
	jnz	free3			; No, continue
	call	ljoin			; Yes, coelesce with block in BX
free3:
	mov	si,dx			; Return 0 or handle in BX
	pop	dx			; restore DX
free4:
	or	si,si			; Set Z flag if SI = zero
	ret
cEnd nogen



;-----------------------------------------------------------------------;
; lfreeadd								;
;									;
; Links a block onto the free block chain. This routine assumes that	;
; the block to add already has the la_next and la_prev fields set	;
; to their proper values.  An extended free block header is written	;
; into the block.							;
;									;
; Arguments:								;
;	BX = Address of block to add to free list			;
;	SI = 0 to search for insertion point, else contins the address	;
;	       of the previous free block.				;
;									;
; Returns:								;
;									;
; Error Returns:							;
;									;
; Registers Preserved:							;
;	All are preserved						;
;									;
; Registers Destroyed:							;
;									;
; Calls:								;
;									;
; History:								;
;									;
;  Mon March 9, 1987   -by-  Bob Gunderson (bobgu)			;
;Initail version							;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

cProc	lfreeadd,<PUBLIC,NEAR>
cBegin nogen
	push	si
	push	di
	push	ax
	push	cx

	or	si,si			; need to search for insertion point?
	jnz	lfa1			; no

; We first need to find the previous free block so that we can insert this
; block into the proper place.

	mov	si,ds:pLocalHeap	; get local arena info block address

if KDEBUG

; Range check the insertion point

	cmp	bx,[si].hi_first
	jb	lfadie
	cmp	bx,[si].hi_last
	jb	lfaok
lfadie:
	kerror	ERR_LMEM,<lfreeadd : Invalid local heap>
lfaok:
endif

	mov	si,[si].hi_first    ; get first block address (free list header)
lfaloop:
	mov	ax,[si].la_free_next ; get address of next free block
	cmp	bx,ax		    ; will next block be past new block?
	jb	lfa1		    ; yes, DI contains block to insert AFTER
	mov	si,ax
	jmp	lfaloop 	    ; loop on next block

; At this point, BX = block to insert, SI = block to insert after

lfa1:
	mov	di,[si].la_free_next	; get next free block
	mov	[bx].la_free_next,di	;
	mov	[si].la_free_next,bx	; set new next block

	mov	[bx].la_free_prev,si	; set new previous block
	mov	[di].la_free_prev,bx	; ditto

	mov	ax,[bx].la_next 	; next block (not necessarily free)
	sub	ax,bx
	mov	[bx].la_size,ax 	; set the size of this block

if KDEBUG

; now fill the new free block with DBGFILL_ALLOC

	call	lfillCC
endif

	pop	cx
	pop	ax
	pop	di
	pop	si
	ret
cEnd nogen



;-----------------------------------------------------------------------;
; lfreedelete								;
;									;
; Removes a specified block from the free list.  This routine assums	;
; that the specified block is indeed on the free list			;
;									;
; Arguments:								;
;	BX = Address of block to remove from the free list		;
;									;
; Returns:								;
;									;
; Error Returns:							;
;									;
; Registers Preserved:							;
;	All are preserved						;
;									;
; Registers Destroyed:							;
;									;
; Calls:								;
;									;
; History:								;
;									;
;  Mon March 9, 1987   -by-  Bob Gunderson (bobgu)			;
;Initail version							;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

cProc	lfreedelete,<PUBLIC,NEAR>
cBegin nogen
	push	di
	push	si

	mov	di,[bx].la_free_prev
	mov	si,[bx].la_free_next

	mov	[di].la_free_next,si
	mov	[si].la_free_prev,di

	pop	si
	pop	di
	ret
cEnd nogen



;-----------------------------------------------------------------------;
; lfillCC								;
;									;
; Fills all the bytes in the specified block with DBGFILL_FREE          ;
;									;
; Arguments:								;
;	BX = Address of block to fill					;
;									;
; Returns:								;
;									;
; Error Returns:							;
;									;
; Registers Preserved:							;
;	All are preserved						;
;									;
; Registers Destroyed:							;
;									;
; Calls:								;
;									;
; History:								;
;									;
;  Mon March 9, 1987   -by-  Bob Gunderson (bobgu)			;
;Initail version							;
;-----------------------------------------------------------------------;

if KDEBUG

	assumes	ds, nothing
	assumes	es, nothing

cProc	lfillCC,<PUBLIC,NEAR>
cBegin nogen
	push	di
	push	cx
	push	ax

; if heap free checking is off, don't fill the block.

	mov	di,pLocalHeap
        cmp     [di].hi_check,2         ; 2 -> checkfree
        jb      fillexit

	lea	di,[bx].la_freefixedsize
	mov	cx,[bx].la_next
	cmp	cx,bx			    ; marker block ?
	jz	fillexit
	sub	cx,di
        mov     al,DBGFILL_FREE
	push	ds
	pop	es
	cld
	rep	stosb

fillexit:
	pop	ax
	pop	cx
	pop	di
	ret
cEnd nogen

endif


;-----------------------------------------------------------------------;
; lcheckCC								;
;									;
; checks all bytes in the specified block for the value DBGFILL_FREE    ;
;									;
; Arguments:								;
;	BX = Address of block to check					;
;									;
; Returns:								;
;	ZF = 0 if block does not contain all 0CCh values, else ZF = 1	;
;									;
; Error Returns:							;
;									;
; Registers Preserved:							;
;	All are preserved						;
;									;
; Registers Destroyed:							;
;									;
; Calls:								;
;									;
; History:								;
;									;
;  Mon March 9, 1987   -by-  Bob Gunderson (bobgu)			;
;Initail version							;
;-----------------------------------------------------------------------;

if KDEBUG

	assumes	ds, nothing
	assumes	es, nothing

cProc	lcheckCC,<PUBLIC,NEAR>
cBegin nogen
	push	si
	push	cx
	push	ax

; if heap checking is off, don't check the block

	mov	si,pLocalHeap
        xor     cx,cx           ; cx == 0 for ok return
        cmp     [si].hi_check,2
        jb      testexit

	lea	si,[bx].la_freefixedsize
	mov	cx,[bx].la_next
        cmp     cx,bx           ; sentinel block ?
        jz      testexit2       ; yes: return ZF = 1 for success
	sub	cx,si
	push	ds
	pop	es
	cld
testloop:
	lodsb
        cmp     al,DBGFILL_FREE
	loope	testloop

testexit:
	or	cx,cx		; ZF = 1 if ok, ZF = 0 if failed test
testexit2:
	pop	ax
	pop	cx
	pop	si
	ret
cEnd nogen

endif

sEnd	CODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\layer.asm ===
title LAYER.ASM - Parameter validation layer

.xlist

ifdef WINDEBUG
DEBUG	equ <1>
endif

PMODE	equ <1>

include gpfix.inc
include klayer.inc

createSeg _DATA,DATA,WORD,PUBLIC,DATA,DGROUP
createSeg _GPFIX,GPFIX,WORD,PUBLIC,DATA,DGROUP

.list

LAYER_START

include kernel.api

LAYER_END

LAYER_EXPAND	TEXT
LAYER_EXPAND	NRESTEXT
LAYER_EXPAND	MISCTEXT

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\kthunks.asm ===
TITLE   KTHUNKS.ASM
    PAGE    ,132
;
; WOW v1.0
;
; Copyright (c) 1991, Microsoft Corporation
;
; KTHUNKS.ASM
; Thunks in 16-bit space to route Windows API calls to WOW32
;
; History:
;   02-Apr-1991 Matt Felton (mattfe)
;   Created.
;

ifndef WINDEBUG
    KDEBUG = 0
    WDEBUG = 0
else
    KDEBUG = 1
    WDEBUG = 1
endif


    .286p

    .xlist
    include cmacros.inc
    include wow.inc
    include wowkrn.inc
    .list

externFP WOW16Call

sBegin  CODE
assumes CS,CODE


; Internal WOW Thunks

    DKernelThunk WowInitTask        ; Task Creation
    DKernelThunk WowKillTask,0      ; Task Destruction
    DKernelThunk WOWFreeResource
    DKernelThunk WowFileRead
    DKernelThunk WowFileWrite
    DKernelThunk WowFileLSeek
    DKernelThunk WowKernelTrace
    DKernelThunk WOWOutputDebugString
    DKernelThunk WowCursorIconOp
    DKernelThunk WowFailedExec,0
    DKernelThunk WowCloseComPort
    DKernelThunk WowFileOpen
    DKernelThunk WowFileClose
    DKernelThunk WowIsKnownDLL
    DKernelThunk WowDdeFreeHandle
    DKernelThunk WowFileGetAttributes
    DKernelThunk WowFileGetDateTime
    DKernelThunk WowFileLock
    DKernelThunk WowFindFirst
    DKernelThunk WowFindNext
    DKernelThunk WowSetDefaultDrive
    DKernelThunk WowGetCurrentDirectory
    DKernelThunk WowSetCurrentDirectory
    DKernelThunk WowWaitForMsgAndEvent
    DKernelThunk WowMsgBox
    DKernelThunk WowGetCurrentDate,0
    DKernelThunk WowDeviceIOCTL
    DKernelThunk WowFileSetAttributes
    DKernelThunk WowFileSetDateTime
    DKernelThunk WowFileCreate
    DKernelThunk WowDosWowInit
    DKernelThunk WowCheckUserGdi
    DKernelThunk WowPartyByNumber
    DKernelThunk GetShortPathName
    DKernelThunk FindAndReleaseDib
    DKernelThunk WowReserveHtask
    DKernelThunk WOWLFNEntry, %(size WOWLFNFRAMEPTR16)
    DKernelThunk WowShutdownTimer
    DKernelThunk WowTrimWorkingSet, 0
    DKernelThunk SetAppCompatFlags
    DKernelThunk WowDivideOverflowEx, %(size WowDivideOverflow)
ifdef FE_SB ;Add GetSystemDefaultLangID()
    DKernelThunk GetSystemDefaultLangID,0
endif
    DKernelThunk TermsrvGetWindowsDir,%(size TERMSRVGETWINDIR16)
;-----------------------------------------------------------------------;
; WOWGetNexVdmCommand
;
; Returns the Next App Name for the Requested 32 Bit Exec
;
; Arguments:
;   FARP lpReturnedString = LPSTR points to the buffer that receives the character strin
;   int  nSize = Size of the lpReturnedString buffer
;
; Returns:
;   DX:AX = TRUE Success, sting is present
;   DX:AX = NULL, buffer size was not large enough
;
; Error Returns:
;
; Registers Preserved:
; Registers Destroyed:
;
; Calls:
;
; History:
;  Sun Jan 19, 1992 11:00:06a   -by-  Matthew Felton [MattFe]
;   New API for Multi Tasking Exec by 32 bit app of 16 bit app
;-----------------------------------------------------------------------;

    DKernelThunk WowGetNextVdmCommand

;-----------------------------------------------------------------------;
; WowRegisterShellWindowHandle
;
; Tells WOW the Windows Handle To Post Messages to For Execing 16 bit
; apps.   (see WOWEXEC and WK32NotifyThread)
;
; Arguments:
;   hwndShell = Shell Window Handle
;
; Returns:
;   nothing
;
; Error Returns:
;
; Registers Preserved:
; Registers Destroyed:
;
; Calls:
;
; History:
;  thu mar 19, 1992 11:11:06a   -by-  Matthew Felton [MattFe]
;   New API for Multi Tasking Exec by 32 bit app of 16 bit app
;-----------------------------------------------------------------------;

    DKernelThunk WowRegisterShellWindowHandle

;-----------------------------------------------------------------------;
; WOWLoadModule32
;
; Loads a module or creates a new instance of an existing module.
;
; Arguments:
;   FARP p   = name of module or handle of existing module
;   FARP lpPBlock = Parameter Block to pass to CreateTask
;   HWND hwndWinOldAp = hwnd to send WM_USER to when app exits.
;
; Returns:
;   AX = 32 if Successful
;
; Error Returns:
;   AX = Error from Win32 LoadModule
;
; Registers Preserved:
; Registers Destroyed:
;
; Calls:
;
; History:
;  Mon 16-Mar-1991 14:19:04  -by-  Matthew Felton  [mattfe}
;-----------------------------------------------------------------------;

    DKernelThunk WOWLoadModule

;-----------------------------------------------------------------------;
; WOWSetIdleHook
;
; Calls WK32SetIdleHook For 16 Bit App
;
; Arguments:
;   none
;
; Returns:
;   AX = 32 if Successful
;
; Error Returns:
;   AX = Error from Win32
;
; Registers Preserved:
; Registers Destroyed:
;
; Calls:
;
; History:
;  Mon 01-Dec-1992 16:30:00  -by-  Russ Blake  [russbl}
;-----------------------------------------------------------------------;

    DKernelThunk WOWSetIdleHook,0

;-----------------------------------------------------------------------;
; WOWQueryPerformanceCounter
;
; Calls NTQueryPerformanceCounter For 16 Bit App
;
; Arguments:
;   FARP p   = name of module or handle of existing module
;   FARP lpPBlock = Parameter Block to pass to CreateTask
;
; Returns:
;   AX = 32 if Successful
;
; Error Returns:
;   AX = Error from Win32
;
; Registers Preserved:
; Registers Destroyed:
;
; Calls:
;
; History:
;  Mon 16-Mar-1991 14:19:04  -by-  Matthew Felton  [mattfe}
;-----------------------------------------------------------------------;

    DKernelThunk WOWQueryPerformanceCounter

;-----------------------------------------------------------------------;
; WOWGetFastAddress
;
; Calls into WOW32 to determine the address of WOWBopEntry on the 32-bit side.
;
; Arguments:
;   none
;
; Returns:
;   AX = LOWORD of address
;   DX = HIWORD of address
;
; Error Returns:
;   AX = 0
;
; Registers Preserved:
; Registers Destroyed:
;
; Calls:
;
; History:
;  Mon 16-Mar-1991 14:19:04  -by-  Matthew Felton  [mattfe}
;-----------------------------------------------------------------------;

    DKernelThunk WOWGetFastAddress, 0

    DKernelThunk WOWGetFastCbRetAddress, 0
    DKernelThunk WOWGetTableOffsets

;-----------------------------------------------------------------------;
; WOWKillRemoteTask
;
; Tells the 32-bit thread to die and save its context so that later remote
; threads can be created to use this context.
;
; Arguments:
;   none
;
; Returns:
;   Nothing
;
; Error Returns:
;   AX = 0
;
; Registers Preserved:
; Registers Destroyed:
;
; Calls:
;
; History:
;  Mon 16-Mar-1991 14:19:04  -by-  Matthew Felton  [mattfe}
;-----------------------------------------------------------------------;

    DKernelThunk WOWKillRemoteTask

;-----------------------------------------------------------------------;
; WOWNotifyWOW32
;
; Tells the 32-bit world some cool stuff about the 16-bit world.
;
; Arguments:
;   none
;
; Returns:
;   Nothing
;
; Error Returns:
;   AX = 0
;
; Registers Preserved:
; Registers Destroyed:
;
; Calls:
;
; History:
;  Mon 16-Mar-1991 14:19:04  -by-  Matthew Felton  [mattfe}
;-----------------------------------------------------------------------;

    DKernelThunk WOWNotifyWOW32

    DKernelThunk KSYSERRORBOX

    DKernelThunk WOWDelFile
    DKernelThunk VirtualAlloc
    DKernelThunk VirtualFree
    DKernelThunk GlobalMemoryStatus
    DKernelThunk GetDriveType
    DKernelThunk LoadLibraryEx32W
    DKernelThunk FreeLibrary32W
    DKernelThunk GetProcAddress32W
    DKernelThunk GetVDMPointer32W
    DKernelThunk ICallProc32W,0

; 3.1 and earlier kernel APIs which are thunked (not many!)

    DKernelThunk Yield,0
    DKernelThunk OldYield,0
    KernelThunk  GetProfileString
    KernelThunk  GetProfileInt
    KernelThunk  GetPrivateProfileInt
    KernelThunk  GetPrivateProfileString
    KernelThunk  WritePrivateProfileString
    KernelThunk  WriteProfileString


; These Thunks Shouldn't be Called - They are Thunked to Trap Them.

    DKernelThunk PostEvent
    DKernelThunk WaitEvent
    DKernelThunk SetPriority
    DKernelThunk DirectedYield
    DKernelThunk LockCurrentTask
    DKernelThunk WriteOutProfiles,0

;
; ExitKernel is small wrapper which takes exit status in AX and pushes it
; for the convenience of ExitKernelThunk, a regular WOW stack-based thunk.
; The FUN_ aliasing below allows us to generate the thunk with the name
; ExitKernelThunk while using the arguments and thunk table entry already
; set up for ExitKernel.
;

    FUN_ExitKernelThunk equ FUN_ExitKernel
    DKernelThunk ExitKernelThunk, %(size EXITKERNEL16)

; FatalExitC is called by FatalExit and takes the same one word parameter
; indicating fatalexit code.

    FUN_FatalExitC equ FUN_FatalExit
    DKernelThunk FatalExitC, %(size FATALEXIT16)

; Thunk for WowGetModuleFileName reuses the GetModuleFileName slot.

    FUN_WowGetModuleFileName equ FUN_GetModuleFileName
    DKernelThunk WowGetModuleFileName, %(size GetModuleFileName16)

; Thunk for WowGetModuleHandle reuses the GetModuleHandle slot.

    FUN_WowGetModuleHandle equ FUN_GetModuleHandle
    DKernelThunk WowGetModuleHandle


;-----------------------------------------------------------------------;
; CallProc32W
;
; Generic Thunk Routine
; Transitions to 32 bits and calls specified routine
;
; Arguments:
;   Variable number of Parameters for function they want to call
;   up to 32.
;
;   DWORD fAddressConvert - Bit Field, for 16:16 address Convertion
;                           eg (bit 1 means convert parameter 1 from 16:16
;                               to flat address before calling routine)
;   DWORD cParams         - Number of DWORD parameters (so we can clean the stack
;                           and so 32 bit land know how many params to copy to
;                           32 bit stack before call.
;   DWORD lpProcAddress   - 32 bit native address to call (use LoadLibraryEx32W
;                           and GetProcAddress32W to figure this out).
;
; Returns:
;   What ever the API returned on 32 bit side in AX:DX
;
; Error Returns:
;   AX = 0, more than 32 parameters.
;
; Registers Preserved:
; Registers Destroyed:
;
; History:
;  Mon 12-Mar-1993 14:19:04  -by-  Matthew Felton  [mattfe}
;-----------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing

cProc   CallProc32W,<PUBLIC,FAR>
;       PARMD cParams
cBegin nogen
        push    bp
        mov     bp,sp

        ; Disable CDECL source bit
        and     word ptr [bp+8],NOT CPEX32_SOURCE_CDECL

        cCall   ICallProc32W

;   Clean Up Callers Stack to remove Parameters Passed

        mov  bx, WORD PTR [bp+6]    ; get the # of DWORDS this API took
        shl  bx, 2          ; convert it to offset into aRets table
        add  bx, codeoffset aRets
        pop  bp
        jmp  bx             ; dispatch to the right RETF n

CRETENTRIES equ 021h
; generate the retf n codetable

    bytes = 0
    REPT CRETENTRIES
        IFE  bytes
aRets:
        ENDIF
        retf bytes + 4*3    ; 4*3 - Always
        nop
    bytes = bytes + 4
    ENDM

cEnd

    public _CallProcEx32W

_CallProcEx32W PROC FAR
        push    bp
        mov     bp,sp

        ; Enable CDECL source bit
        or      word ptr [bp+8],CPEX32_SOURCE_CDECL

        cCall   ICallProc32W

        pop     bp
        ret
_CallProcEx32W ENDP

    ; get the address of the array containing the selector bases
    DKernelThunk WOWGetFlatAddressArray, 0


assumes CS,NOTHING
sEnd    CODE

;
; All the thunks above are in Kernel's primary code segment (IGROUP/TEXT),
; the ones below are in the second code segment, NRESTEXT.
;

_NRESTEXT SEGMENT WORD PUBLIC 'CODE'
assumes CS,_NRESTEXT
assumes DS,NOTHING
assumes ES,NOTHING


;
; New-for-NT5 thunks for Win95 compatibility.  Many of these are unimplemented.
;

    DKernelThunk GetVersionEx
    DKernelThunk GetPrivateProfileSectionNames
    DKernelThunk CreateDirectory
    DKernelThunk RemoveDirectory
    DKernelThunk DeleteFile
    DKernelThunk SetLastError
    DKernelThunk GetLastError,0
    DKernelThunk Local32Init
    DKernelThunk Local32Alloc
    DKernelThunk Local32ReAlloc
    DKernelThunk Local32Free
    DKernelThunk Local32Translate
    DKernelThunk Local32Size
    DKernelThunk Local32ValidHandle
    KernelThunk  RegEnumKey32
    KernelThunk  RegOpenKey32
    KernelThunk  RegCreateKey32
    KernelThunk  RegDeleteKey32
    DKernelThunk RegCloseKey32
    KernelThunk  RegSetValue32
    KernelThunk  RegDeleteValue32
    KernelThunk  RegEnumValue32
    KernelThunk  RegQueryValue32
    KernelThunk  RegQueryValueEx32
    KernelThunk  RegSetValueEx32
    KernelThunk  RegLoadKey32
    KernelThunk  RegUnloadKey32
    KernelThunk  RegSaveKey32
    DKernelThunk RegFlushKey32
    DKernelThunk ComputeObjectOwner
    DKernelThunk Local32GetSel
    DKernelThunk InvalidateNLSCache,0
    DKernelThunk GetProductName
    DKernelThunk IsSafeMode,0
    DKernelThunk OpenFileEx
    DKernelThunk FastAndDirtyGlobalFix
    DKernelThunk WritePrivateProfileStruct
    DKernelThunk GetPrivateProfileStruct
    DKernelThunk GetCurrentDirectory
    DKernelThunk SetCurrentDirectory
    DKernelThunk FindFirstFile
    DKernelThunk FindNextFile
    DKernelThunk FindClose
    DKernelThunk WritePrivateProfileSection
    DKernelThunk WriteProfileSection
    DKernelThunk GetPrivateProfileSection
    DKernelThunk GetProfileSection
    DKernelThunk GetFileAttributes
    DKernelThunk SetFileAttributes
    DKernelThunk GetDiskFreeSpace
    DKernelThunk IsPEFormat
    DKernelThunk FileTimeToLocalFileTime
    DKernelThunk UniToAnsi
    DKernelThunk CreateThread
    DKernelThunk LeaveEnterWin16Lock,0
    DKernelThunk GetWin16Lock,0
    DKernelThunk LoadLibrary32
    DKernelThunk GetProcAddress32
    DKernelThunk CreateWin32Event
    DKernelThunk SetWin32Event
    DKernelThunk ResetWin32Event
    DKernelThunk WaitForSingleObject
    DKernelThunk WaitForMultipleObjects
    DKernelThunk GetCurrentThreadID,0
    DKernelThunk GetThreadQueue
    DKernelThunk SetThreadQueue
    DKernelThunk NukeProcess
    DKernelThunk ExitProcess
    DKernelThunk GetCurrentProcessID,0
    DKernelThunk MapHINSTLS,0
    DKernelThunk MapHINSTSL,0
    DKernelThunk CloseWin32Handle
    DKernelThunk LoadSystemLibrary32
    DKernelThunk FreeLibrary32
    DKernelThunk GetModuleFilename32
    DKernelThunk GetModuleHandle32
    DKernelThunk RegisterServiceProcess
    DKernelThunk InitCB
    DKernelThunk GetStdCBLS
    DKernelThunk GetStdCBSL
    DKernelThunk GetExistingStdCBLS
    DKernelThunk GetExistingStdCBSL
    DKernelThunk GetFlexCBSL
    DKernelThunk GetStdCBLSEx
    DKernelThunk GetStdCBSLEx
    DKernelThunk Callback2
    DKernelThunk Callback4
    DKernelThunk Callback6
    DKernelThunk Callback8
    DKernelThunk Callback10
    DKernelThunk Callback12
    DKernelThunk Callback14
    DKernelThunk Callback16
    DKernelThunk Callback18
    DKernelThunk Callback20
    DKernelThunk Callback22
    DKernelThunk Callback24
    DKernelThunk Callback26
    DKernelThunk Callback28
    DKernelThunk Callback30
    DKernelThunk Callback32
    DKernelThunk Callback34
    DKernelThunk Callback36
    DKernelThunk Callback38
    DKernelThunk Callback40
    DKernelThunk Callback42
    DKernelThunk Callback44
    DKernelThunk Callback46
    DKernelThunk Callback48
    DKernelThunk Callback50
    DKernelThunk Callback52
    DKernelThunk Callback54
    DKernelThunk Callback56
    DKernelThunk Callback58
    DKernelThunk Callback60
    DKernelThunk Callback62
    DKernelThunk Callback64
    DKernelThunk WowPassEnvironment
    DKernelThunk WowSyncTask
_NRESTEXT ENDS

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\kflatstb.asm ===
TITLE   KFLATSTB.ASM
    PAGE    ,132
;
; WOW v1.0
;
; Copyright (c) 1991, Microsoft Corporation
;
; KTHUNKS.ASM
; Thunks in 16-bit space to route Windows API calls to WOW32
;
; History:
;   02-Apr-1991 Matt Felton (mattfe)
;   Created.
;

ifndef WINDEBUG
    KDEBUG = 0
    WDEBUG = 0
else
    KDEBUG = 1
    WDEBUG = 1
endif


    .386p

    .xlist
    include cmacros.inc
    include wow.inc
    include wowkrn.inc
    .list

externFP WOW16Call

sBegin  CODE
assumes CS,CODE


;---------------------------------------------------------------------
;
;  BOOL ThunkConnect16(LPSTR     pszDll16,
;                      LPSTR     pszDll32,
;                      HINSTANCE hInstance,
;                      DWORD     dwReason,
;                      LPVOID    lpThunkData16,
;                      LPSTR     pszThunkData32Name,
;                      WORD      hModuleCS)
;
;  Exported kernel routine: called from the DllEntryPoint()'s
;  of 16-bit dll's that depend on a 32-bit partner with which
;  they share thunks
;
;---------------------------------------------------------------------

cProc ThunkConnect16, <PUBLIC, FAR, PASCAL>, <ds,si,di>
        parmD pszDll16
        parmD pszDll32
        parmW hInstance
        parmD dwReason
        parmD lpThunkData16
        parmD pszThunkData32Name
        parmW hModuleCS



; ThunkConnect16  proc FAR PASCAL PUBLIC USES ds si di, pszDll16:DWORD,
;                                                      pszDll32:DWORD,
;                                                      hInstance:WORD,
;                                                      dwReason:DWORD,
;                                                      lpThunkData16:DWORD,
;                                                      pszThunkData32Name:DWORD,
;                                                      hModuleCS:WORD
cBegin nogen
        xor ax, ax
        ret
;ThunkConnect16 endp
cEnd nogen

;; C16ThkSL01
;
; This is the 16-bit rewriter code for orthogonal 16->32 thunks.
;
; Entry:
;   cx = offset in flat jump table
;   edx = linear address of THUNKDATA16
;   eax = cs:ip of common thunk entry point
;   bx  = NOT USED
;
; Exit:
;   This "routine" doesn't really exit. It jumps back to eax (which now
;   holds the rewritten code). When it does this, cx, di, si, bp, ds and the D
;   flag must all hold the same values they had on entry.
;
;
; This routine only runs when the 16-bit thunk entry point has been
; freshly loaded, or restored after a discard. This routine patches
; its caller code so that it jumps straight to C32ThkSL in kernel32.
;


cProc C16ThkSL01, <PUBLIC,FAR>
cBegin nogen
        ; just return
        ret
cEnd nogen

sEnd CODE


end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\kold.asm ===
; Kernel OLD routines, NOPs, but exist in KERNEL.DEF, so I can't kill them


.xlist
include kernel.inc
include tdb.inc
include newexe.inc
.list

sBegin  CODE
assumes cs,CODE

;-----------------------------------------------------------------------;
; LimitEmsPages                                                         ;
;                                                                       ;
; Limits the total number of EMS pages a task may have.                 ;
;                                                                       ;
; Arguments:                                                            ;
;       Maximum amount of memory in Kbytes that this task wants.        ;
;                                                                       ;
; Returns:                                                              ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;                                                                       ;
; Calls:                                                                ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Fri Jun 26, 1987 01:53:15a  -by-  David N. Weise   [davidw]          ;
; Wrote it.                                                             ;
;-----------------------------------------------------------------------;

cProc   LimitEmsPages,<PUBLIC,FAR>
;       parmD   amount
cBegin nogen
        xor     ax,ax

        cwd
        ret     4
cEnd nogen


;-----------------------------------------------------------------------;
; KbdReset                                                              ;
;                                                                       ;
; Keyboard driver calls here when Ctl+Alt+Del is happening.             ;
;                                                                       ;
; Arguments:                                                            ;
;                                                                       ;
; Returns:                                                              ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;                                                                       ;
; Calls:                                                                ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;-----------------------------------------------------------------------;

cProc   KbdRst,<PUBLIC,FAR>
cBegin nogen

        ret
cEnd nogen


;-----------------------------------------------------------------------;
; GetCurPID                                                             ;
;       A utility routine for EMS functions needed from user routines   ;
;                                                                       ;
;   function =                                                          ;
;       0 - return the current PID in ax                                ;
;       1 - copy the TDB_EEMSSave area into a new block and return      ;
;           the new block's handle in ax                                ;
;       2 - do not free the banks of the current app                    ;
;       3 - free the given PID's banks                                  ;
;       4 - do an HFree on the given handle                             ;
;       5 - get expanded memory sizes                                   ;
;       6 -                                                             ;
;       7 - do an EMS_save                                              ;
;       8 - do an EMS_restore                                           ;
;                                                                       ;
;                                                                       ;
; Arguments:                                                            ;
;       None                                                            ;
;                                                                       ;
; Returns:                                                              ;
;       see above                                                       ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;       ax,bx,cx,di,si,ds,es                                            ;
;                                                                       ;
; Calls:                                                                ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Fri Jul 17, 1987 11:02:23a  -by-  Rick N. Zucker [rickz]             ;
; Wrote it.                                                             ;
;-----------------------------------------------------------------------;

cProc   GetCurPID,<PUBLIC,FAR>,<di,si>
        parmW   function
        parmW   gcpArg
cBegin
        xor     ax,ax
        xor     dx,dx

cEnd

sEnd CODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\lcompact.asm ===
TITLE	LCOMPACT - Local memory allocator, compaction procedures

include kernel.inc

errnz	la_prev			; This code assumes la_prev = 0

sBegin	CODE
assumes CS,CODE

; These are all the external subroutines needed by this source file.
;
externNP    <henum>		; HANDLE.ASM
externNP    <ljoin,lfree,lfreeadd,lfreedelete>	; LALLOC.ASM
externNP    <lnotify,lalign>	; LINTERF.ASM
externFP    <GlobalHandle, GlobalRealloc>
;externFP    <LocalHeapSize>

; These are all of the internal subroutines defined in this source file.
;
	PUBLIC	lmove, lbestfit, lcompact

;-----------------------------------------------------------------------;
; lmove                                                                 ;
; 									;
; Moves a moveable block into the top part of a free block.		;
; 									;
; Arguments:								;
;	BX = address of free block					;
;	SI = address of busy block to move				;
; 									;
; Returns:								;
;	SI = old busy address (new free block)				;
;	DI = new busy address						;
;	BX = old free block						;
;	AX = block after old free block					;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
;	CX,DX,ES							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Tue Oct 14, 1986 06:22:28p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

cProc	lmove,<PUBLIC,NEAR>
cBegin nogen
	mov	cx,[si].la_next	    ; Calculate #bytes in busy block
	sub	cx,si

	add	si,cx		    ; SI = bottom of busy block
	mov	di,[bx].la_next	    ; DI = bottom of free block
	cmp	si,bx		    ; Are the busy and free blocks adjacent?
	je	move1		    ; Yes, always room for free header
	mov	ax,di		    ; Calculate the new busy block location
	sub	ax,cx
	sub	ax,LA_MINBLOCKSIZE  ; See if there is room for two blocks
	cmp	ax,bx		    ; in this free block
	jae	move1		    ; Yes, continue
	mov	ax,di		    ; No, AX = block after free block
	mov	di,bx		    ; New busy block will replace free block
	add	di,cx		    ; with some extra slop at end
	jmp	short move2
move1:
	mov	ax,di		    ; AX = block after free block
move2:
	dec	si		    ; Predecrement for moving backwards
	dec	si		    ; on bogus Intel hardware
	dec	di
	dec	di
	shr	cx,1		    ; Move words
	push	ds		    ; Initialize for rep movsw
	pop	es
	std			    ; Move down as may overlap
	rep	movsw
	cld			    ; Don't hose careless ones
	inc	si		    ; More bogosity.
	inc	si		    ; SI = old busy address (new free block)
	inc	di		    ; DI = new busy address
	inc	di		    ; BX = old free block
movex:				    ; AX = block after old free block
	ret
cEnd nogen

;-----------------------------------------------------------------------;
; lbestfit                                                              ;
; 									;
; Searches backwards for the largest moveable block that will fit	;
; in the passed free block.						;
;									;
; Arguments:								;
;	BX = free block							;
;	CX = #arena entries left to examine				;
; 									;
; Returns:								;
;	SI = address of moveable block or zero				;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Tue Oct 14, 1986 06:25:46p  -by-  David N. Weise   [davidw]          ;
; Wrote it.								;
;-----------------------------------------------------------------------;

cProc	lbestfit,<PUBLIC,NEAR>
cBegin nogen
	push	bx
	push	cx
	push	dx
	xor	si,si		    ; Have not found anything yet
	push	si
	mov	dx,[bx].la_next	    ; Compute max size to look for
	sub	dx,bx
bfloop:
	mov	ax,[bx].la_prev	    ; Get previous block pointer
	test	al,LA_BUSY	    ; Is this block busy?
	jz	bfnext		    ; No, continue
	test	al,LA_MOVEABLE	    ; Is this block moveable?
	jz	bfnext		    ; No, continue
	mov	si,[bx].la_handle   ; Yes, is this block locked?
	cmp	[si].lhe_count,0
	jne	bfnext		    ; No, continue
	mov	ax,[bx].la_next	    ; Yes, compute size of this moveable block
	sub	ax,bx		    ; Compare to size of free block
	cmp	ax,dx		    ; Is it bigger?
	ja	bf2		    ; Yes, continue
	pop	si		    ; No, Recover largest block so far
	or	si,si		    ; First time?
	jz	bf0		    ; Yes, special case
	add	ax,si		    ; No, is this block better than
	cmp	ax,[si].la_next	    ; ...the best so far?
	jbe	bf1		    ; No, continue
bf0:	mov	si,bx		    ; Yes, remember biggest block
bf1:	push	si		    ; Save largest block so far
bf2:	mov	ax,[bx].la_prev	    ; Skip past this block
bfnext:
	and	al,LA_MASK
	mov	bx,ax
	loop	bfloop
bfexit:
	pop	si
	pop	dx
	pop	cx
	pop	bx
	ret
cEnd nogen

;-----------------------------------------------------------------------;
; lcompact                                                              ;
; 									;
; Compacts the local heap.						;
; 									;
; Arguments:								;
;	DX = minimum #contiguous bytes needed				;
;	DI = address of local heap information				;
; 									;
; Returns:								;
;	AX = size of largest contiguous free block			;
;	BX = arena header of largest contiguous free block		;
;	DX = minimum #contiguous bytes needed				;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
;	CX,SI,ES							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Wed March 11, 1987  -by- Bob Gunderson [bobgu]			;
; Added code to maintain free list while compacting.			;
;									;
;  Tue Oct 14, 1986 06:27:37p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

cProc	lcompact,<PUBLIC,NEAR>
cBegin nogen
x = LHE_DISCARDABLE+1
x = x shl 8
x = x or 1
    IncLocalStat    ls_lcompact
	push	si
	mov	word ptr [di].hi_ncompact,x
	errnz	<hi_ncompact-hi_dislevel+1>
	cmp	[di].hi_freeze,0    ; Is the heap frozen?
	je	compact1	    ; No, continue
	dec	[di].hi_ncompact    ; Yes, prevent discarding
compact1:
    IncLocalStat    ls_cloop
	push	dx		    ; Save what we are looking for
	xor	ax,ax		    ; Haven't found a free block yet
	push	ax		    ; Remember what we have found here
	mov	bx,[di].hi_last	    ; Start at end of arena
	mov	cx,[di].hi_count
; Loop to find the next free block
;
cfreeloop:
    IncLocalStat    ls_cexamine
	mov	ax,[bx].la_prev
	test	al,LA_BUSY
	jz	cfreefound
	and	al,LA_MASK
	mov	bx,ax
cflnext:
	loop	cfreeloop

compact2:
	pop	bx		    ; Recover largest free block so far
	pop	dx		    ; Recover size needed
	mov	ax,bx		    ; Compute size in AX
	or	ax,ax		    ; Did we find a free block?
	jz	cexit1		    ; No, done
	sub	ax,[bx].la_next	    ; Yes, compute size of largest free block
	neg	ax
	dec	[di].hi_ncompact    ; Any other possibilities?
	jl	cexit		    ; No, get out now
	cmp	ax,dx		    ; Yes, Did we get size we needed?
	jb	compact3	    ; No, try next possibility
cexit:
cexit1:
	pop	si
	ret			    ; Yes, return to caller

compact3:
	push	dx
	push	bx

	dec	[di].hi_dislevel    ; Down to next discard level
	jz	compact2	    ; Ooops, no more, try next step
	inc	[di].hi_ncompact    ; Still discarding
	xor	si,si		    ; Start enumerating handle table entries
cdloop:
	call	henum		    ; Get next discardable handle
	jz	cdexit		    ; No, more see if we discarded anything
	push	cx		    ; Got one, see if okay to discard
	mov	cl,LN_DISCARD	    ; AX = LN_DISCARD
	xchg	ax,cx		    ; CX = discardable flags
	mov	bx,si		    ; BX = handle
	call	lnotify
	pop	cx
	or	ax,ax		    ; Is it still discardable?
	jz	cdloop		    ; No, skip this handle
	mov	bx,[si].lhe_address  ; Get true address of a block
	sub	bx,SIZE LocalArena  ; BX = address of block to free
	call	lfree		    ; Free the block associated with this handle
	xor	ax,ax		    ; Zero the true address field in the
	mov	[si].lhe_address,ax
	or	[si].lhe_flags,LHE_DISCARDED  ; and mark as discarded
	or	[di].hi_ncompact,80h	; Remember we discarded something
	jmp	cdloop
cdexit:
	test	[di].hi_ncompact,80h	; No, did we discarded something?
	jz	compact2
	xor	[di].hi_ncompact,80h	; Yes, clear flag
	pop	bx
	pop	dx
	jmp	compact1		; and try compacting again

; Here when we have a free block.  While the preceeding block is
; moveable, then move it down and put the free space in it place.
; When the preceeding block is not moveable, then search backwards
; for one or more moveable blocks that are small enough to fit
; in the remaining free space.	Advance to previous block when
; no more blocks to examine.
cfreefound:
    IncLocalStat    ls_cfree
	cmp	[di].hi_freeze,0    ; Is the heap frozen?
	jne	cffexit		    ; No, continue

;	and	al,LA_MASK	    ; Already clear for free blocks
	mov	si,ax		    ; SI = previous block
	test	byte ptr [si].la_prev,LA_MOVEABLE
	jz	cfreefill	    ; Skip if not moveable
	mov	si,[si].la_handle   ; Point to handle table entry
	cmp	[si].lhe_count,0    ; Is it locked?
	jne	cfreefill	    ; Yes, skip this block

; Here if previous block is moveable.  Slide it up to the top of the
; free block and make the old busy block free.	This is easy as
; we are not really adding or taking anything away from the arena
;
	push	cx		    ; Save loop state regs
	push	di
	mov	si,ax		    ; SI = busy block before free block
	call	lfreedelete	    ; remove [BX] from free list
	call	lmove		    ; Move busy block down
	mov	[di].la_prev,si	    ; Link in new busy block
	or	byte ptr [di].la_prev,LA_MOVEABLE+LA_BUSY
	mov	bx,ax
	mov	[di].la_next,bx	    ; la_next field from old free block
	and	[bx].la_prev,LA_ALIGN
	or	[bx].la_prev,di

	mov	[si].la_next,di	    ; Link in old busy block (new free block)
	and	byte ptr [si].la_prev,LA_MASK	; mark it free

	push	si
	push	bx
	mov	bx,si
	xor	si,si
	call	lfreeadd	    ; add new free block to free list
	pop	bx
	pop	si

	mov	bx,[di].la_handle   ; Modify handle table entry to point
	lea	ax,[di].SIZE LocalArena
	mov	[bx].lhe_address,ax  ; to new location of client data

	pop	di		    ; Restore arena info pointer
    IncLocalStat    ls_cmove
	mov	al,LN_MOVE	    ; Tell client we moved it
	lea	cx,[si].SIZE LocalArena	    ; CX = old client data
	call	lnotify		    ; BX = handle

	pop	cx		    ; restore #arena entries left
	mov	bx,si		    ; BX = address of free block
	mov	si,[bx].la_prev	    ; SI = previous block
	test	byte ptr [si].la_prev,LA_BUSY	; Is it free?
	jnz	cffnext		    ; No, continue
	call	ljoin		    ; Yes, coelesce with block in BX
;;; DO NOT change cx, ljoin leaves BX pointing after the free block
;;;	dec	cx		    ; ...keep CX in sync
cffnext:
	jmp	cflnext		    ; Go process next free block

; Here when done with a free block.  Keep track of the largest free block
; seen so far.
;
cffexit:
	pop	si		    ; Recover largest free block so far
	cmp	si,bx		    ; Same as current?
	je	cff1		    ; Yes, no change then
	test	[bx].la_prev,LA_BUSY	; No, is current free?
	jnz	cff1			; No, ignore it then
	or	si,si		    ; Yes, First time?
	jz	cff0		    ; Yes, special case
	mov	ax,[si].la_next	    ; No, compute size of largest free block
	sub	ax,si
	add	ax,bx		    ; Compare to size of this free block
	cmp	[bx].la_next,ax	    ; Is it bigger?
	jbe	cff1		    ; No, do nothing
cff0:	mov	si,bx		    ; Yes, remember biggest free block
cff1:	push	si		    ; Save largest free block so far
cff2:	mov	bx,[bx].la_prev	    ; Skip past this free block
	and	bl,LA_MASK	    ; (it might not be a free block)
	jmp	cffnext

; Here if previous block is NOT moveable.  Search backwards for the
; largest moveable block that will fit in this free block.  As long
; as a block is found, move it to the top of the free block, free it
; from it's old location and shrink the current free block to accomodate
; the change.
;
cfreefill:
	call	lbestfit	    ; Search for best fit
	or	si,si		    ; Find one?
	jz	cffexit		    ; No, all done with this free block
	push	cx		    ; Save loop state regs
	push	di
	push	[bx].la_prev	    ; Save busy block before free block
	call	lfreedelete	    ; remove [BX] from free list
	call	lmove		    ; Move it down
	; SI = old busy address (new free block)
	; DI = new busy address
	; BX = old free block
	; AX = block after old free block
	pop	cx		    ; Recover la_prev field of old free block
	cmp	bx,di		    ; Did we consume the free block?
	je	cff		    ; Yes, then CX has what we want
	mov	cx,bx		    ; No, then busy block will point to what
	mov	[bx].la_next,di	    ; is left of the free block and vs.
cff:
	mov	[di].la_prev,cx	    ; Link in new busy block
	or	byte ptr [di].la_prev,LA_MOVEABLE+LA_BUSY
	mov	[di].la_next,ax	    ; la_next field from old free block
	xchg	di,ax
	and	[di].la_prev,LA_ALIGN
	or	[di].la_prev,ax
	xchg	di,ax

	lea	cx,[di].SIZE LocalArena

	cmp	bx,di		    ; Did we create a free block?
	je	cffff
	push	si
	xor	si,si
	call	lfreeadd	    ; Add [BX] to free list
	pop	si
cffff:

	cmp	bx,di		    ; Did we create a free block?

	    mov	    bx,di		; Current block is busy block
	    mov	    di,[di].la_handle	; Modify handle table entry to point
	    xchg    [di].lhe_address,cx	; to new location of client data
	    pop	    di			; Restore arena info pointer
	    pop	    ax			; restore #arena entries left
	je	cfff		    ; No, arena count okay
	inc	ax		    ; Keep arena count on target
	inc	[di].hi_count
cfff:
	push	bx		    ; Save current block pointer
	push	ax		    ; Save #arena entries left
	mov	al,LN_MOVE	    ; Tell client we moved it (CX = old addr)
	mov	bx,[bx].la_handle   ; BX = handle
	call	lnotify
	pop	cx		    ; restore #arena entries left
	and	byte ptr [si].la_prev,not LA_MOVEABLE	; Clear moveable bit
	mov	bx,si		    ; BX = address of old busy block to free
	push	[di].hi_count
	call	lfree		    ; Mark it as free
	pop	si
	sub	si,[di].hi_count
	sub	cx,si		    ; Keep arena count on target
	pop	bx		    ; BX = current block
	jmp	cff2		    ; Move to previous block.
cEnd nogen

;-----------------------------------------------------------------------;
; lshrink								;
; 									;
; Shrinks the local heap.						;
; 									;
; Arguments:								;
;	DS:DI = address of local heap information block 		;
;	BX = Minimum size to shrink heap				;
; 									;
; Returns:								;
;	AX = New size of local heap					;
; 									;
; Error Returns:							;
;	None.								;
;									;
; Registers Preserved:							;
;	None								;
; Registers Destroyed:							;
;	All								;
; Calls:								;
; 									;
; History:								;
;									;
;   Fri July 17, 1987 -by- Bob Gunderson [bobgu]			;
;	Changed logic so we don't call lcompact every time we move      ;
;	a block, just call it whenever we can't find room.              ;
;									;
;   Fri June 12, 1987 -by- Bob Gunderson [bobgu]			;
; Wrote it.								;
;-----------------------------------------------------------------------;

cProc	lshrink,<PUBLIC,NEAR>
cBegin nogen

    ; Bound the minimum size to the size specified at LocalInit() time.
	mov	ax,[di].li_minsize
	cmp	ax,bx		    ; specified smaller than min ?
	jbe	lshr_around	    ; no - use what's specified
	mov	bx,ax		    ; yes - use real min.
lshr_around:
	push	bx		    ; Save minimum heap size
	mov	ax,[di].hi_last
	add	ax,SIZE LocalArenaFree
	sub	ax,[di].hi_first    ; ax = current heap size
	cmp	ax,bx		    ; already small enough ?
	ja	lshr_around1
	jmp	lshr_exit	    ; yes - that was quick...
lshr_around1:

    ; local compact to get as much contiguous free space as possible.
	stc
	call	lalign
	call	lcompact	    ; compact everything
	xor	dx,dx		    ; start with null flag

    ; Start with last block in heap.
	mov	si,[di].hi_last

loop1:

    ; SI = address of block just moved.

    ; This section moves moveable blocks (one at a time) up
    ; into free blocks below (higher addresses) all fixed blocks.
    ; The blocks they vacate are freed.  The sentenal block is then
    ; moved, the heap is re-compacted.	Then a test is made to see if
    ; the heap has shrunk enough, if not
    ; we start this loop again.  We continue this until we can't
    ; move anything or we have moved enough to satisfy the minimum
    ; size specified by BX when called.

	mov	si,[si].la_prev 	; get next block to move
	and	si,LA_MASK		; zap the flag bits
	mov	ax,[si].la_prev 	; get this blocks flags
	test	ax,LA_BUSY		; is this block free?
	jz	lshr_gobblefree 	; yes - gobble this free block
	test	ax,LA_MOVEABLE		; is it moveable ?
	jz	lshr_cantmove		; no - exit
	mov	bx,[si].la_handle	; get its handle
	cmp	[bx].lhe_count,0	; is it locked ?
	jnz	lshr_cantmove		; yes - exit

	mov	cx,[si].la_next
	sub	cx,si			; get block size in cx

    ; Find the first free block (after fixed blocks) that is big
    ; enough for this block
loop2:
	call	lfirstfit
	jnc	lshr_gotblock		; got one - continue

    ; If we have already tried compacting, nothing more to do
	or	dx,dx
	jnz	lshr_cantmove		; nothing more to do...

    ; Not enough room found, recompact the local heap and test again
	push	si
	push	cx
	stc
	call	lalign
	call	lcompact		; compact everything
	pop	cx
	pop	si
	mov	dx,1			; flag to say we have done this
	jmp	loop2			; try again

    ;	DI = local arena info block address
    ;	SI = block we didn't move (next is last block moved)
lshr_cantmove:
	mov	si,[si].la_next 	; get last block moved
	jmp	lshr_alldone		; cleanup and exit

lshr_gobblefree:
    ; SI = address of free block
    ; Block to move is already free, remove it from the free list and mark
    ; it a busy.
	mov	bx,si
	call	lfreedelete
	or	[bx].la_prev,LA_BUSY
	jmps	lshr_shiftup

lshr_gotblock:
    ;	DI - Arena info block address
    ;	SI - Address of block to move
    ;	BX - Address of free block to use
    ;	CX - Size of block to move

	call	lfreedelete		; remove it from the free list
	xchg	di,bx
	mov	ax,[di].la_next
	sub	ax,cx
	sub	ax,LA_MINBLOCKSIZE	; Room to split free block into
	cmp	ax,di			; two blocks ?
	jb	lshr_nosplit		; no - don't split the block
	push	bx
	push	si
	mov	bx,cx
	lea	bx,[bx+di]		; bx = address of new free block to add
	; link this new block in
	mov	[bx].la_prev,di
	mov	ax,[di].la_next
	mov	[bx].la_next,ax
	mov	[di].la_next,bx
	xchg	ax,bx
	and	[bx].la_prev,LA_ALIGN	; Zap only high bits
	or	[bx].la_prev,ax 	; and set new previous pointer
	mov	bx,ax
	mov	si,[di].la_free_prev	; previous free block
	call	lfreeadd		; add the new smaller free block
	pop	si
	pop	bx
	inc	[bx].hi_count		; bump the block count (we added
					;   a block)
lshr_nosplit:
    ;	BX - Arena info block address
    ;	SI - Address of block to move
    ;	DI - Address of free block to use
    ;	CX - Size of block to move

    ; copy the flags from the old block
	mov	ax,[si].la_prev
	and	ax,LA_ALIGN
	or	[di].la_prev,ax

	push	si
	push	di
    ; don't copy the block headers (but do copy the handle)
	add	si,la_fixedsize
	add	di,la_fixedsize
	sub	cx,la_fixedsize
    ; We can take # bytes/2 as # words to move because all blocks
    ; start on even 4 byte boundary.
	shr	cx,1			; bytes / 2 = words
	push	ds
	pop	es			; same segment
	cld				; auto-increment
	rep	movsw			; Head 'em up!  Move 'em out!
	pop	di
	pop	si
    ;	BX - Arena info block address
    ;	SI - Address of block to move
    ;	DI - Address of free block to use

    ; Fixup the handle table pointer
	push	bx
	mov	bx,[si].la_handle
	lea	ax,[di].SIZE LocalArena
	mov	[bx].lhe_address,ax
	pop	di			; DI = info block address

    ; Mark the old block as busy fixed
	and	[si].la_prev,LA_MASK	; clear old bits
	or	[si].la_prev,LA_BUSY	; put in busy fixed bit
	jmps	lshr_shiftup

    ; Time to shift the setenal block up, recompact and look for more
    ; space...
    ;	DI = local arena info block address
    ;	SI = block just freed
    public foo
foo:
lshr_shiftup:
	mov	ax,[di].hi_last
	mov	bx,ax
	sub	bx,si			; less what is already removed
	sub	ax,bx
	add	ax,SIZE LocalArenaFree	; size of sentenal block
	sub	ax,[di].hi_first	; ax = current heap size
	pop	bx			; get min size
	push	bx			; and put it back on stack
	cmp	ax,bx			; already small enough ?
	jbe	lshr_alldone		; yes - exit
	xor	dx,dx			; localcompact flag
	jmp	loop1			; and back for more

lshr_alldone:
    ;	DI = local arena info block address
    ;	SI = last block moved

    ; Time to shift the sentenal block up and realloc our heap
	pop	bx		    ; Minimum size of the heap
	push	bx
	call	slide_sentenal	    ; slide the sentenal block up

    ; get our data segment handle
	push	ds
	call	GlobalHandle	    ; ax = handle of DS
	or	ax,ax
	jz	lshr_exit	    ; this can't happen.....
	push	ax		    ; hMem

    ; determine how big we should be
	mov	ax,[di].hi_last
	add	ax,SIZE LocalArenaFree
	xor	cx,cx
	push	cx
	push	ax		    ; # bytes in DS
	push	cx		    ; no wFlags
	call	GlobalRealloc

    ; local compact to get as much contiguous free space as possible.
lshr_exit:
	stc
	call	lalign
	call	lcompact		; compact everything
	pop	ax			; clean the stack
	mov	ax,[di].hi_last
	add	ax,SIZE LocalArenaFree
	sub	ax,[di].hi_first	; ax = current heap size
	ret
cEnd nogen

;-------------------------------------------------------------------------
; Find first free block after last fixed block.  We do this by scanning
; through the free list looking for a free block with the next physical
; block being moveable (remember we just did a compact...).  Then, starting
; with this free block, find the first free block that is at least
; CX bytes long.
;
; Entry:
;	DI = local arena header info block address
;	CX = # bytes needed
;
; Exit:
;	BX = Address of free block to use
;
; Error Return:
;	Carry set if no free block big enough
;
; History:
;
;   Fri June 12, 1987 -by- Bob Gunderson [bobgu]
; Wrote it.
;-------------------------------------------------------------------------

cProc	lfirstfit,<PUBLIC,NEAR>
cBegin nogen
	push	ax

	mov	bx,[di].hi_last
	mov	bx,[bx].la_free_prev
;	mov	bx,[di].hi_first
;	mov	bx,[bx].la_free_next
lffloop:
	cmp	bx,[bx].la_free_prev
;	cmp	bx,[bx].la_free_next
	jz	lff_err_exit
	cmp	cx,[bx].la_size
	jbe	lff_exit
	mov	bx,[bx].la_free_prev
;	mov	bx,[bx].la_free_next
	jmp	lffloop
lff_err_exit:
	stc
	jmps	lff_done
lff_exit:
	clc			    ; good return
lff_done:
	pop	ax
	ret
cEnd nogen


;-------------------------------------------------------------------------
;   slide_sentenal
;	This routine is called during the LocalShrink() operation.
;	Make all the blocks between the one at SI and the sentenal go
;	away.  Then check to see if we have shrunk the heap too much.  If
;	so, then add a free block at SI big enough to bump the size up (this
;	will be moved later by LocalCompact).  Now move the sentenal block
;	up after the last block.
;
; Entry:
;	BX = requested minimum size of the heap
;	SI = last block actually moved (put sentenal here)
;	DI = local arena info block address
;
; Exit:
;
; Error Return:
;
; History:
;
;   Fri Aug 14, 1987 -by- Bob Gunderson [bobgu]
; Changed things again to insure we don't shrink to heap too much.
;
;   Fri July 17, 1987 -by- Bob Gunderson [bobgu]
; Was too slow, so changed the logic.
;
;   Fri June 12, 1987 -by- Bob Gunderson [bobgu]
; Wrote it.
;-------------------------------------------------------------------------

cProc	slide_sentenal,<PUBLIC,NEAR>
cBegin nogen

	push	bx

    ; Get sentenal block
	mov	bx,[di].hi_last

    ; Insure that we aren't trying to move to ourselves
	cmp	si,bx
	jz	slide_exit	    ; nothing to do....

    ; count the number of block we are removing so that we can update
    ; the block count in the arena header.
	push	si
	xor	cx,cx
slide_loop:
	cmp	si,bx
	jz	slide_loop_exit
	inc	cx
	mov	si,[si].la_next
	jmp	slide_loop
slide_loop_exit:
	pop	si

	sub	[di].hi_count,cx    ; decrement the count of blocks

    ; Would the heap be too small if the sentenal were moved to the block
    ; pointed to by si?  If so, add a free block at SI to make up the
    ; difference.
	mov	ax,si
	sub	ax,[di].hi_first
	add	ax,la_freefixedsize ; size of heap in ax
	pop	bx		    ; minimum in bx
	cmp	ax,bx
	ja	slide_ok	    ; everything is ok...
	sub	bx,ax		    ; bx = size to grow
	cmp	bx,LA_MINBLOCKSIZE
	jbe	slide_ok	    ; not enough for a block
	clc
	call	lalign		    ; make it even 4 byte boundary
	mov	bx,dx
    ; add a free block of bx bytes
	lea	ax,[si+bx]	    ; address of new "next" block
	mov	[si].la_next,ax     ; make block point at "next"
	and	[si].la_prev,LA_MASK  ; make it a free block
	xor	bx,bx
	xchg	si,bx		    ; bx = block to add, si = 0
	call	lfreeadd	    ; preserves ax
	inc	[di].hi_count	    ; bump block count
	mov	si,ax		    ; and bump si to "next" block
	mov	[si].la_prev,bx     ; set new block's previous pointer

slide_ok:
    ; move the sentenal block up by copying the words.
	mov	bx,[di].hi_last 	; old sentenal block
	mov	[si].la_next,si 	; new sentenal points to self
	and	[si].la_prev,LA_MASK	; remove any old flags
	or	[si].la_prev,LA_BUSY	; make it busy
	mov	ax,[bx].la_size
	mov	[si].la_size,ax 	; move in the size
	mov	bx,[bx].la_free_prev
	mov	[si].la_free_prev,bx	; move in previous free block
	mov	[bx].la_free_next,si	; point prev free block to this one
	mov	[si].la_free_next,si	; point to itself

    ; Now fixup the arena header block to point to the new setenal
    ; position.

	mov	[di].hi_last,si

    ; And we are done...
	jmps	slide_exit1

slide_exit:
	pop	bx
slide_exit1:
	ret
cEnd nogen

sEnd	CODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\ldcache.asm ===
TITLE	LDCACHE - Segment and File Handle Caching procedures

.xlist
include kernel.inc
include newexe.inc
include tdb.inc

.list

DataBegin

externW  hExeHead

externW	 topPDB
externW	 Win_PDB
externW	 curTDB
externW	 cur_dos_PDB
externB	 fhCache
externW	 fhCacheLen
externW	 fhCacheEnd
externW	 fhcStealNext

DataEnd

externFP MyOpenFile
externFP Int21Handler

sBegin	CODE
assumes CS,CODE
assumes DS,NOTHING
assumes ES,NOTHING

externNP real_DOS

;-----------------------------------------------------------------------;
; GetCachedFileHandle							;
;									;
; Look for the file handle for an EXE file in the cache of file 	;
; handles.  Sets current PDB to that of KERNEL to access the file.	;
; A handle NOT to free in order to satisfy the request can also 	;
; be given.								;
;									;
; Arguments:								;
;	parmW	hExe		handle of EXE file			;
;	parmW	keepfh		file handle not to change		;
;	parmW	fh		file handle if file already open	;
; 					    				;
; Returns:								;
;	AX == file handle						;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
;									;
; Registers Destroyed:							;
;									;
; Calls:								;
;	real_DOS							;
; 									;
; History:								;
;  Wed 18-Oct-1989 20:40:51  -by-  David N. Weise  [davidw]		;
; Added the feature of not closing a specified handle.			;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing
ifdef WOW
	.286
else
endif

cProc	FarGetCachedFileHandle,<PUBLIC,FAR>
	parmW	hExe
	parmW	keepfh
	parmW	fh
cBegin		  
	cCall	GetCachedFileHandle,<hExe,keepfh,fh>
cEnd


cProc	GetCachedFileHandle,<PUBLIC,NEAR>,<bx,di,ds,es>
	parmW	hExe
	parmW	keepfh
	parmW	fh			; -1 if file not open
	localW	fhcFreeEntry
cBegin
	SetKernelDS
	mov	fhcFreeEntry, 0

	mov	bx, topPDB

;;;	cmp	bx, Win_PDB
;;;	je	gcfh_okPDB		; Don't bother setting if already this
;;;	mov	cur_dos_PDB, bx
;;;	mov	Win_PDB, bx		; Run on kernel's PDB for a while
;;;	mov	ah, 50h			; set PDB
;;;	call	real_DOS
;;;gcfh_okPDB:

	mov	Win_PDB, bx		; Run on kernel's PDB for a while

	mov	ax, hExe		; look for this EXE in the file
	mov	es, ax			; handle cache
	mov	cx, fhCacheLen
	mov	di, dataOffset fhCache
gcfh_searchfh:
	mov	bx, [di.CacheExe]
	cmp	ax, bx
	jne	@F
	jmps	gcfh_found
@@:
	or	bx, bx			; Free entry?
	jnz	gcfh_searchnext
	cmp	fhcFreeEntry, bx	; already have a free entry?
	jne	gcfh_searchnext
	mov	fhcFreeEntry, di	; Save index for free entry
gcfh_searchnext:
	add	di, size fhCacheStruc
	loop	gcfh_searchfh
					; EXE not already in the cache
	mov	di, fhcFreeEntry	; Did we find a free entry?
	or	di, di
	jz	gcfh_stealone		;  no, steal one
	mov	fhcFreeEntry, -1	; Flag to steal one if the open fails
	jmps	gcfh_openit		; (due to out of file handles)
	
gcfh_stealone:				; No free entry, pick one on first come,
	mov	cx, fhcStealNext	; first served basis
gcfh_stealnext:
	mov	di, cx
	add	cx, 4			; Calculate next index in CX
	cmp	cx, fhCacheEnd
	jb	gcfh_oknext
	mov	cx, dataoffset fhCache	; Start back at the beginning
gcfh_oknext:	       		      
	mov	bx, [di.Cachefh]
	or	bx, bx			; If no file handle,
	jz	gcfh_stealnext		;  on to next cache entry
	cmp	bx, keepfh		; If handle not to free
	jz	gcfh_stealnext		;  on to next cache entry
	mov	fhcStealNext, cx

	mov	ah, 3Eh
	DOSCALL				; Close this file handle
	mov	fhcFreeEntry, di

gcfh_openit:
	push	ds
	mov	ax, fh
	cmp	ax, -1			; File already open?
	jne	gcfh_opened		;   yes, just put in cache

	mov	dx,es:[ne_pfileinfo]
	regptr	esdx,es,dx
;	mov	bx,OF_SHARE_DENY_WRITE or OF_REOPEN or OF_PROMPT or OF_VERIFY or OF_CANCEL
;;;	mov	bx,OF_REOPEN or OF_PROMPT or OF_VERIFY or OF_CANCEL
if 1
	smov	ds,es
	add	dx, opFile
;;;	test	es:[ne_flags],NEAPPLOADER
;;;	jnz	@F
if SHARE_AWARE
	mov	ax, 3DA0h		; open for read, deny write, no inherit
else
	mov	ax, 3D80h		; open for read, no inherit
endif
	DOSCALL
	jnc	gcfh_opened
;;;@@:
	mov	ax, 3DC0h		; try share deny none 
	DOSCALL				      
	jnc	gcfh_opened
else
	mov	bx,OF_REOPEN or OF_VERIFY
	push	es
	cCall	MyOpenFile,<esdx,esdx,bx>
	pop	es
	cmp	ax, -1
	jne	gcfh_opened
endif
	pop	ds
	cmp	fhcFreeEntry, -1	; This was a free cache entry?
	je	gcfh_stealone		;  yes, have run out of file handles
	mov	ax, -1			; fix bug #6774 donc
	jmps	gcfh_exit		;  no, a real failure
gcfh_found:
	mov	ax, [di.Cachefh]
	jmps	gcfh_exit
gcfh_opened:
	pop	ds
	mov	[di.Cachefh], ax
	mov	[di.CacheExe], es

gcfh_exit:
cEnd


;-----------------------------------------------------------------------;
; CloseCachedFileHandle							;
;									;
; Close the EXE file with the given file handle.			;
; Actually does delays closing the file until the handle is needed.	;
; Resets the current PDB to that of the current task.			;
;									;
; Arguments:								;
;	parmW	fh		file handle being 'closed'		;
; 									;
; Returns:								;
;	none								;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
;									;
; Registers Destroyed:							;
;	AX								;
;									;
; Calls:								;
;	real_DOS							;
; 									;
; History:								;
; 									;
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	CloseCachedFileHandle,<PUBLIC,NEAR>,<bx,ds,es>
	parmW	fh
cBegin
;;;	SetKernelDS
;;;	mov	es, curTDB
;;;	mov	bx, es:[TDB_PDB]
;;;	cmp	bx, Win_PDB
;;;	je	ccfh_okPDB
;;;	mov	Win_PDB, bx
;;;	mov	cur_dos_PDB, bx
;;;	mov	ah, 50h
;;;	call	real_DOS
;;;ccfh_okPDB:
cEnd

;-----------------------------------------------------------------------;
; FlushCachedFileHandle							;
;									;
; Look for the file handle for an EXE file in the cache of file handles	;
; If it is found, close the file.					;
;									;
; Arguments:								;
;	parmW	hExe		handle of EXE file			;
; 									;
; Returns:								;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
;									;
; Registers Destroyed:							;
;									;
; Calls:								;
;	real_DOS							;
; 									;
; History:								;
; 									;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

cProc	FlushCachedFileHandle,<PUBLIC,FAR>,<ax,bx,cx,di>
	parmW	hExe
cBegin
	SetKernelDS
	mov	ax, hExe
	or	ax, ax				; make sure we really
	jz      fcfh_exit			; have a hExe
	mov	cx, fhCacheLen
	mov	di, dataOffset fhCache
fcfh_search:
	cmp	ax, [di.CacheExe]
	je	fcfh_found
	add	di, size fhCacheStruc
	loop	fcfh_search
	jmps	fcfh_exit			; Not cached, nothing to do
fcfh_found:

;;;	mov	bx, topPDB
;;;	cmp	bx, cur_dos_PDB
;;;	je	fcfh_okPDB
;;;	mov	cur_dos_PDB, bx
;;;	mov	ah, 50h			; set PDB
;;;	call	real_DOS
;;;fcfh_okPDB:

	push	Win_PDB			; Save 'current' PDB

	mov	bx, topPDB
	mov	Win_PDB, bx		; Run on kernel's PDB for a while

	mov	bx, [di.Cachefh]
	mov	ah, 3Eh			; Close the file
	DOSCALL
	xor	ax, ax
	mov	[di.Cachefh], ax	; mark cache entry free
	mov	[di.CacheExe], ax

;;;	push	es
;;;	mov	es, curTDB		; and reset the PDB
;;;	mov	bx, es:[TDB_PDB]
;;;	pop	es
;;;	cmp	bx, Win_PDB
;;;	je	fcfh_exit
;;;	mov	Win_PDB, bx
;;;	mov	cur_dos_PDB, bx
;;;	mov	ah, 50h
;;;	call	real_DOS

	pop	Win_PDB			; Restore original PDB

fcfh_exit:
cEnd


;-----------------------------------------------------------------------;
; CloseCachedFiles							;
;									;
; Close all the cached files on a duplicate PDB				;
; Leaves PDB set to new PDB						;
;									;
; Arguments:								;
;	parmW	pdb		new PDB					;
; 									;
; Returns:								;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
;									;
; Registers Destroyed:							;
;									;
; Calls:								;
;	real_DOS							;
; 									;
; History:								;
; 									;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

cProc	CloseCachedFiles,<PUBLIC,FAR>,<ax,bx,cx,di,ds>
	parmW	pdb
cBegin
	SetKernelDS
	mov	bx, pdb
	mov	Win_PDB, bx
;;;	mov	ah, 50h
;;;	call	real_DOS		; Run on the new guy

	mov	dx, bx
	mov	cx, fhCacheLen
	mov	di, dataOffset fhCache
ccf_search:
	mov	bx, [di.Cachefh]
	or	bx, bx
	je	ccf_next
	mov	ah, 3Eh			; Close the file
	call	real_DOS

	cmp	dx,topPDB		; If closing cached files on
	jne	ccf_next		;   the kernel's PDB, mark the
	xor	ax,ax			;   cache entry as free
	mov	[di.Cachefh], ax
	mov	[di.CacheExe], ax

ccf_next:
	add	di, size fhCacheStruc
	loop	ccf_search

cEnd

sEnd	CODE

	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\ldboot.asm ===
PAGE    ,132
    TITLE   LDBOOT - BootStrap procedure
?DFSTACK = 1
.xlist
include kernel.inc
include newexe.inc
include tdb.inc
include pdb.inc
include protect.inc
include gpcont.inc
ifdef WOW
include vint.inc
include doswow.inc
endif
.list

if 0; KDEBUG
ifdef  WOW
  BootTraceOn = 1
  BootTrace macro   char
    push ax
    mov ax,char
    int 3
    pop ax
  endm
else
  BootTraceOn = 1
  BootTrace macro   char
    push    char
    call    BootTraceChar
  endm
endif
else
  BootTrace macro   char
  endm
  BootTraceOn = 0
endif

; Note that the following public constants require special handling
; for ROM Windows.  If you add, delete, or change this list of constants,
; you must also check the ROM Image Builder.

public  __ahshift
public  __ahincr
public  __0000h
public  __0040h
public  __A000h
public  __B000h
public  __B800h
public  __C000h
public  __D000h
public  __E000h
public  __F000h
public  __ROMBIOS
public  __WinFlags
public  __flatcs
public  __flatds

public  __MOD_KERNEL
public  __MOD_DKERNEL
public  __MOD_USER
public  __MOD_DUSER
public  __MOD_GDI
public  __MOD_DGDI
public  __MOD_KEYBOARD
public  __MOD_SOUND
public  __MOD_SHELL
public  __MOD_WINSOCK
public  __MOD_TOOLHELP
public  __MOD_MMEDIA
public  __MOD_COMMDLG
ifdef FE_SB
public  __MOD_WINNLS
public  __MOD_WIFEMAN
endif ; FE_SB

    __ahshift = 3
    __ahincr  = 1 shl __ahshift
    __0000h     = 00000h
    __0040h     = 00040h
    __A000h     = 0A000h
    __B000h     = 0B000h
    __B800h     = 0B800h
    __C000h     = 0C000h
    __D000h     = 0D000h
    __E000h     = 0E000h
    __F000h     = 0F000h
    __ROMBIOS   = 0F000h
    __WinFlags  = 1
    __flatcs    = 1Bh
    __flatds    = 23h

    __MOD_KERNEL     = 0h
    __MOD_DKERNEL    = 0h
    __MOD_USER       = 0h
    __MOD_DUSER      = 0h
    __MOD_GDI        = 0h
    __MOD_DGDI       = 0h
    __MOD_KEYBOARD   = 0h
    __MOD_SOUND      = 0h
    __MOD_SHELL      = 0h
    __MOD_WINSOCK    = 0h
    __MOD_TOOLHELP   = 0h
    __MOD_MMEDIA     = 0h
    __MOD_COMMDLG    = 0h
ifdef FE_SB
    __MOD_WINNLS     = 0h    ; for IME
    __MOD_WIFEMAN    = 0h    ; for WIFEMAN
endif ; FE_SB

BOOTSTACKSIZE   =  512
EXTRASTACKSIZE  = (4096-BOOTSTACKSIZE)

MultWIN386      EQU 16h ; Reserved to Win386
MW3_ReqInstall      EQU 00h ; Installation check
MW3_ReqInstall_Ret_1    EQU 0FFh    ; Return number 1
MW3_ReqInstall_Ret_2    EQU 01h ; Return number 2
MW3_ReqInstall_Ret_3    EQU 02h ; Return number 3
MW3_ReqInstall_Ret_4    EQU 03h ; Return number 4
DOS_FLAG_OFFSET         EQU 086h

externFP lstrlen
externFP lstrcat
externFP lstrcpy
externFP IGlobalAlloc
externFP IGlobalFree
externFP IGlobalRealloc
externFP LoadModule
externFP IOpenFile
externFP lrusweep
externFP GetExePtr
externFP GetProfileInt
externFP GetPrivateProfileString
externFP GetPrivateProfileInt
externFP GetProcAddress
externFP GetTempDrive
externFP ExitKernel
externFP InternalEnableDOS
externFP FlushCachedFileHandle
externFP SetHandleCount
externFP IPrestoChangoSelector
externFP GPFault
externFP StackFault
externFP invalid_op_code_exception
externFP page_fault
ifdef WOW
externFP divide_overflow
externFP single_step
externFP breakpoint
endif
externFP DiagInit

ifdef WOW
externFP StartWOWTask
externFP AllocSelector_0x47
externW MOD_KERNEL
externW ModCount
externFP WOWGetTableOffsets
externFP WOWDosWowInit
externFP GetShortPathName
endif

if KDEBUG
externFP ValidateCodeSegments
endif

ifdef FE_SB
externFP GetSystemDefaultLangID
endif

externFP TermsrvGetWindowsDir


externW pStackBot
externW pStackMin
externW pStackTop

sBegin  CODE
externFP Int21Handler
externFP Int10Handler
externD  prevInt10proc
sEnd    CODE

;------------------------------------------------------------------------
;  Data Segment Variables
;------------------------------------------------------------------------

DataBegin
if SHERLOCK
  externW gpEnable
endif

externB graphics
externB fBooting
externB Kernel_flags
externB fChkSum
externB fCheckFree
externB WOAName
externB grab_name
ifndef WOW
externB szUserPro
endif
externB szBootLoad
externB szCRLF
externB szMissingMod
externB szPleaseDoIt
externB fPadCode
;externW EMScurPID
;externW PID_for_fake
externW cBytesWinDir
externW cBytesSysDir
externW pGlobalHeap
externW hExeHead
externW MaxCodeSwapArea
externW curTDB
externW f8087
externB fastFP
externW topPDB
externW headTDB
externW winVer
externD Dos_Flag_Addr

ifndef WOW
externB WinIniInfo
externB PrivateProInfo
endif
externW gmove_stack
externW prev_gmove_SS
externW BaseDsc
externW WinFlags
externW hUser
externW hShell
externW MyCSSeg
externW MyDSSeg
externW MyCSAlias
externB fhCache
externW fhCacheEnd
externW fhCacheLen
externB fPokeAtSegments
externB fExitOnLastApp
externW segLoadBlock
externD pKeyProc
externD pKeyProc1
externW wDefRIP

externW cpShrunk
externW cpShrink
externW hLoadBlock

externD pTimerProc
externD pExitProc
externD pDisableProc
externD lpWindowsDir
externD lpSystemDir

;if KDEBUG and SWAPPRO
;externD prevIntF0proc
;endif

externD lpInt21     ; support for NOVELL stealing int 21h

ifdef WOW
externD pFileTable
externW cBytesSys16Dir
externD lpSystem16Dir
externB Sys16Suffix
externW cBytesSys16Suffix
externW cBytesSysWx86Dir
externD lpSystemWx86Dir
externB SysWx86Suffix
externW cBytesSysWx86Suffix
externD pPMDosCURDRV
externD pPMDosCDSCNT
externD pPMDosPDB
externD pPMDosExterr
externD pPMDosExterrLocus
externD pPMDosExterrActionClass
externD pDosWowData

globalW cbRealWindowsDir,0

WINDIR_BUFSIZE equ 121

achWindowsDir     DB WINDIR_BUFSIZE DUP(?)
achRealWindowsDir DB WINDIR_BUFSIZE DUP(?)
achSystem16Dir    DB 128 DUP(?)
achSystemWx86Dir  DB 128 DUP(?)

public cbRealWindowsDir, achRealWindowsDir, achWindowsDir, achSystem16Dir
externB achTermSrvWindowsDir           ; windows directory path (for win.ini)


endif

DataEnd


;------------------------------------------------------------------------
;  INITDATA Variables
;------------------------------------------------------------------------

DataBegin INIT

ifndef WOW
; WOW doesn't muck with the WOAName buffer -- we just leave it
; as WINOLDAP.MOD
externB  woa_286
externB  woa_386
endif
externB  bootExecBlock
externW  oNRSeg
externW  oMSeg
externW  win_show
externD  lpBootApp

staticW  initTDBbias,0
staticW  initSP,0
staticW  initSSbias,0
staticW  segNewCS,0

app_name db 68 dup(0)

DataEnd INIT


;------------------------------------------------------------------------
;  EMSDATA Variables
;------------------------------------------------------------------------


;------------------------------------------------------------------------

externNP LoadSegment
externNP genter
externNP gleave
externNP GlobalInit
externNP DeleteTask
externNP BootSchedule
externNP InitFwdRef

externNP SaveState
externNP LKExeHeader
externNP GetPureName
externNP SegmentNotPresentFault

externNP LDT_Init
externNP alloc_data_sel
externNP get_physical_address
externNP set_physical_address
externNP set_sel_limit
externNP free_sel
externFP set_discarded_sel_owner
externNP SelToSeg
externNP DebugDefineSegment
externNP DebugFreeSegment

externNP SwitchToPMODE
externNP LKAllocSegs

ifdef WOW
externFP WOWFastBopInit
endif


if KDEBUG
if SWAPPRO
externB fSwapPro
externW hSwapPro
externW cur_dos_pdb
endif
endif

ifdef FE_SB
externFP FarMyIsDBCSTrailByte
endif



;------------------------------------------------------------------------

sBegin  INITCODE
assumes cs,CODE


externD prevIntx6proc
externD prevInt0Cproc
externD prevInt0Dproc
externD prevInt0Eproc
externD prevInt21proc
externD prevInt3Fproc
ifdef WOW
externD prevInt01proc
externD prevInt03proc
externD oldInt00proc
externFP GlobalDosAlloc
externFP GlobalDosFree
endif

externNP TextMode
externNP InitDosVarP
externNP GrowSFTToMax
ifndef WOW
externNP SetUserPro
endif
externNP MyLock
externNP Shrink
externNP DebugDebug
externNP NoOpenFile
externNP NoLoadHeader

if SDEBUG
externNP DebugInit
endif

;if SWAPPRO
;externNP INTF0Handler
;endif


if SDEBUG
szModName   db  'KERNEL',0
endif

ifdef WOW
externNP SetOwner
endif

;-----------------------------------------------------------------------;
; Bootstrap                             ;
;                                   ;
; Determines whether we should initialize in a smaller amount of    ;
; memory, leaving room for an EEMS swap area.  If so, we rep-move the   ;
; code to a lower address, and tell the PSP to report less memory ;
; available.  It then does lots more of stuff.              ;
;                                   ;
; Arguments:                                ;
;   DS:0 = new EXE header                       ;
;   ES:0 = Program Segment Prefix block (PSP)           ;
;   SS:SP = new EXE header                      ;
;   CX = file offset of new EXE header (set by KernStub)        ;
;   DS = automatic data segment if there is one         ;
;                                   ;
; Returns:                              ;
;                                   ;
; Error Returns:                            ;
;                                   ;
; Registers Preserved:                          ;
;                                   ;
; Registers Destroyed:                          ;
;                                   ;
; Calls:                                ;
;                                   ;
; History:                              ;
;                                   ;
;  Sat Jun 20, 1987 06:00:00p  -by-  David N. Weise   [davidw]      ;
; Made fast booting work with real EMS.                 ;
;                                   ;
;  Tue Apr 21, 1987 06:31:42p  -by-  David N. Weise   [davidw]      ;
; Added some more EMS support.                      ;
;                                   ;
;  Thu Apr 09, 1987 02:52:37p  -by-  David N. Weise   [davidw]      ;
; Put back in the movement down if EMS.                 ;
;                                   ;
;  Sat Mar 14, 1987 05:55:29p  -by-  David N. Weise   [davidw]      ;
; Added this nifty comment block.                   ;
;-----------------------------------------------------------------------;

    assumes ds,DATA
    assumes es,nothing
    assumes ss,nothing


cProc   BootStrap,<PUBLIC,NEAR>
cBegin  nogen
if KDEBUG
    jmp short Hello_WDEB_End
Hello_WDEB:
    db  'Windows Kernel Entry',13,10,0
Hello_WDEB_End:
    push    ax
    push    es
    push    si
    xor ax, ax
    mov es, ax
    mov ax, es:[68h*4]
    or  ax, es:[68h*4+2]
    jz  @F
    mov ax,cs
    mov es,ax
    lea si,Hello_WDEB
    mov ah,47h
    int 68h
@@:
    pop si
    pop es
    pop ax
endif
    BootTrace   'a'

    cmp ax, "KO"    ; OK to boot; set by kernstub.asm
    je  @F
    xor ax, ax
    retf
@@:

; Set up addressibility to our code & data segments

    mov MyCSSeg, cs
    mov MyDSSeg, ds

ifdef WOW
; Get pointer to sft so that I can find do direct protect mode
; file IO operations

    mov CS:MyCSDS, ds

    push es
    mov     ah,52h                  ; get pointer to internal vars
    int     21h

        mov     ax, es
        shl     ax, 4
        add     ax, DOS_FLAG_OFFSET
        sub     ax, 400h
        mov     Dos_Flag_Addr.off, ax
        mov     Dos_Flag_Addr.sel, 40h

;
;       Retrieve some pointers from the DosWowData structure in DOS.
;
        push    di
        push    dx
        mov     di, es:[bx+6ah]                 ;kernel data pointer

        mov     pDosWowData.off, di
        mov     pDosWowData.sel, es

        mov     ax, word ptr es:[di].DWD_lpCurPDB
;       mov     dx, word ptr es:[di].DWD_lpCurPDB+2
        mov     pPMDosPDB.off,ax
        mov     pPMDosPDB.sel,0                 ;to force gpfault if not ready

        mov     ax, word ptr es:[di].DWD_lpCurDrv
;       mov     dx, word ptr es:[di].DWD_lpCurDrv+2
        mov     pPMDosCURDRV.off,ax
        mov     pPMDosCURDRV.sel,0              ;to force gpfault if not ready

        mov     ax, word ptr es:[di].DWD_lpCDSCount
;       mov     dx, word ptr es:[di].DWD_lpCDSCount+2
        mov     pPMDosCDSCNT.off,ax
        mov     pPMDosCDSCNT.sel,0              ;to force gpfault if not ready

        mov     ax, word ptr es:[di].DWD_lpExterr
        mov     pPMDosExterr.off, ax
        mov     pPMDosExtErr.sel, 0

        mov     ax, word ptr es:[di].DWD_lpExterrLocus
        mov     pPMDosExterrLocus.off, ax
        mov     pPMDosExtErrLocus.sel, 0

        mov     ax, word ptr es:[di].DWD_lpExterrActionClass
        mov     pPMDosExterrActionClass.off, ax
        mov     pPMDosExtErrActionClass.sel, 0

        pop     dx
        pop     di

    lea     bx,[bx+sftHead]
    mov     pFileTable.off,bx
    mov pFileTable.sel,es
    pop es

endif   ; WOW

    BootTrace   'b'
    call    SwitchToPMODE   ; BX -> LDT, DS -> CS(DS), SI start of memory
    BootTrace   'c'

    ReSetKernelDS

    mov BaseDsc,si
    call    LDT_Init
    BootTrace   'd'

ifdef WOW
        call    AllocSelector_0x47
        call    WOWFastBopInit
endif

if SDEBUG

; In protected mode, initialize the debugger interface NOW.  Only real mode
; needs to wait until the global heap is initialized.

    cCall   DebugInit

; In protected mode, define where our temp Code & Data segments are

    mov ax,codeOffset szModName
    cCall   DebugDefineSegment,<cs,ax,0,cs,0,0>

    mov ax,codeOffset szModName
    cCall   DebugDefineSegment,<cs,ax,3,ds,0,1>
endif
    BootTrace   'e'

    BootTrace   'f'

ifdef WOW
        push    ax
        push    bx
        mov     bx, pDosWowData.sel             ;use this segment
        mov     ax, 2
        int     31h
        mov     pPMDosPDB.sel,ax                ;make this a PM pointer
        mov     pPMDosCURDRV.sel,ax             ;make this a PM pointer
        mov     pPMDosCDSCNT.sel,ax             ;make this a PM pointer
        mov     pPMDosExterr.sel,ax
        mov     pPMDosExterrLocus.sel,ax
        mov     pPMDosExterrActionClass.sel,ax
        pop     bx
        pop     ax

        push    pDosWowData.sel
        push    pDosWowData.off
        call    WOWDosWowInit
endif

; InitDosVarP just records a few variables, it does no hooking.
;  It does dos version checking and other fun stuff that
;  must be done as soon as possible.

    call    InitDosVarP
    or  ax,ax
    jnz inited_ok
    Debug_Out "KERNEL: InitDosVarP failed"
    mov ax,4CFFh        ; Goodbye!
    INT21
inited_ok:
    BootTrace   'g'

    push    bx

    mov bx, WinFlags
ifndef  JAPAN   ; should be removed because of IBM dependent code.
        ; InitFwdRef routine will set 80x87 status bit in WinFlags
        ; and exported location #178.

; Determine if there is a co-processor present.

    int 11h         ; get equipment word
    test    al,2            ; this is the IBM approved method
    jz  no_80x87        ;   to check for an 8087
    or  bh,WF1_80x87
no_80x87:
endif   ;NOT JAPAN

ifdef WOW
    or  bh,WF1_WINNT    ; Set NT flag ON
endif

    mov WinFlags,bx

    pop bx

; Determine if running under Windows/386 or the 286 DOS Extender

    push    bx
    mov ax,(MultWin386 SHL 8) OR MW3_ReqInstall ; Win/386 install check
    int 2Fh
    BootTrace   'h'
    cmp al,MW3_ReqInstall_Ret_4     ; Under WIN386 in pmode?
    or  Kernel_flags[1],kf1_Win386
    or  byte ptr WinFlags,WF_PMODE or WF_ENHANCED
    jmps    InstallChkDone

NotUnderWin386:
    or  Kernel_flags[2],KF2_DOSX
    or  byte ptr WinFlags,WF_PMODE or WF_STANDARD

InstallChkDone:
    BootTrace   'i'
    pop bx

ifndef WOW
    ; WOW doesn't muck with the WOAName buffer -- we just leave it
    ; as WINOLDAP.MOD

    push    cx
    push    di
    push    si
    cld
    mov cx,8
    smov    es,ds
    mov di,dataOffset WOAName
    mov si,dataOffset woa_286
    test    Kernel_flags[2],KF2_DOSX
    jnz @F
    mov si,dataOffset woa_386
@@: rep movsb
    pop si
    pop di
    pop cx
endif
    BootTrace   'j'

    mov ax,cx
    mov cl,4
    shr ax,cl
    mov cpShrunk,ax

; Compute paragraph address of new EXE header from SS:SP

    mov bx,sp           ; SS:SP -> new EXE header

    cCall   get_physical_address,<ss>
    add ax,bx
    adc dx,0
    BootTrace   'k'
    cCall   alloc_data_sel,<dx,ax,0,0FFFFh>
    BootTrace   'l'

    mov segLoadBlock,ax     ; hinitexe:0 -> new EXE header

; calculate the TDB bias

    mov bx,dataOffset boottdb
    mov initTDBbias,bx

; calculate the SS bias

    mov bx,dataOffset stackbottom
    mov initSSbias,bx

; calculate the initial SP

    mov si,dataOffset stacktop
    sub si,dataOffset stackbottom
    mov initSP,si

    cCall   get_physical_address,<ds>
    add ax,bx
    adc dx,0
    BootTrace   'm'
    FCLI
    mov prev_gmove_SS, ss   ; Switch stack while we set up new SS
    smov    ss, ds
    mov sp, dataOFFSET gmove_stack
    cCall   set_physical_address,<prev_gmove_SS>
    xor ax, ax
    xchg    ax, prev_gmove_SS
    BootTrace   'n'
    mov ss,ax           ; switch to new stack
    mov sp,si
    FSTI

    xor bp,bp           ; zero terminate BP chain.
    sub si,BOOTSTACKSIZE
    mov ss:[pStackBot],sp
    mov ss:[pStackMin],sp
    mov ss:[pStackTop],si

    cld
    mov es,topPDB

externB szNoGlobalInit

    BootTrace   'o'
    mov ax, BaseDsc     ; Free memory starts after this
    mov bx,segLoadBlock     ; Make boot image be first busy block
    mov cx,es:[PDB_block_len]   ; cx is end of memory
    mov dx,MASTER_OBJECT_SIZE
    cCall   GlobalInit,<dx,bx,ax,cx>

    jc  @F          ; passed through from ginit
    or  ax,ax
    jnz mem_init_ok
@@:
    mov dx, codeoffset szNoGlobalInit
    smov    ds, cs
    mov ah, 9
    int 21h         ; Whine
    mov ax, 4CFFh
    int 21h         ; And exit
;NoGlobalInit   db  "KERNEL: Unable to initialise heap",13,10,'$'

mem_init_ok:
    mov hLoadBlock,ax       ; Save handle to first busy block

    BootTrace   'p'

    mov pExitProc.sel,cs
    mov pExitProc.off,codeOffset ExitKernel

; Find out where we live, and where win.com lives.

    mov ds,topPDB
    UnSetKernelDS
    mov bx,ds
    mov ds,ds:[PDB_environ]
    xor si,si
    cld
envloop1:
    lodsb
    or  al,al           ; end of item?
    jnz envloop1
    lodsb
    or  al,al           ; end of environment?
    jnz envloop1
    lodsw               ; ignore argc, DS:SI -> kernel path

ifdef WOW
    smov    es, ds          ; now ES:SI -> kernel path
else
    call    get_windir      ; on return, DS:DI -> windir= value

    smov    es,ds

; Record where to find the 'windows' directory.
    BootTrace   'q'

    SetKernelDS
    or  di,di
    jz  no_win_dir_yet
    mov lpWindowsDir.sel,es
    mov lpWindowsDir.off,di
    mov cBytesWinDir,cx

                    ; Now set pointer to WIN.INI to be
                    ; in the Windows directory
    push    si
    push    es
    smov    es, ds
    mov si, dataoffset szUserPro+6
    mov di, si
    inc cx
    add di, cx          ; Move up the string WIN.INI
    std
    mov cx, 4
    rep movsw
                    ; Now copy Windows directory
    cld
    mov cx, cBytesWinDir
    mov di, dataoffset szUserPro
    lds si, lpWindowsDir
    UnSetKernelDS
    rep movsb
    mov byte ptr es:[di], '\'
    pop es
    pop si
endif
    SetKernelDS
    BootTrace   'r'
no_win_dir_yet:

    sub sp,SIZE OPENSTRUC + 127
    mov di,sp
    regptr  ssdi,ss,di
    mov bx,OF_EXIST
    cCall   IOpenFile,<essi,ssdi,bx>
    BootTrace   's'
    inc ax          ; Test for -1
    jnz opn1            ; Continue if success
    mov dx, codeoffset NoOpenFile
fail1:
    push    dx                      ; Save string pointer
    call    textmode                ; Switch to text mode
    pop     dx
    smov    ds, cs
    mov ah, 9
    int 21h         ; Tell user why we're bailing out
    mov ax,4CFFh        ; Goodbye!
    INT21
opn1:

; Now simulate loading ourselves from memory

; Load new EXE header for KERNEL.EXE from memory

    cCall   LKExeHeader,<segLoadBlock,ssdi>
    BootTrace   't'
    add sp,SIZE OPENSTRUC + 127
    or  ax,ax
    jnz     @F
    mov dx, codeoffset NoLoadHeader
    jmp     SHORT fail1
@@:

    mov hExeHead,ax
    mov es,ax

ifndef WOW
; Record where to find the 'system' directory.

    mov di,es:[ne_pfileinfo]
    lea di,es:[di].opFile
    mov lpSystemDir.sel,es
    mov lpSystemDir.off,di
    mov dx,di
    call    GetPureName
    sub di,dx
    dec di
    mov cBytesSysDir,di

    BootTrace   'u'
endif
   ; ndef WOW


; Make room at end of kernel data segment for stack--NOTE:  DGROUP is
; assumed to be segment 4!

    mov bx,es:[ne_segtab]
    add es:[bx+(3*size NEW_SEG1)].ns_minalloc,EXTRASTACKSIZE


; Determine size of kernel's largest discardable code segment

; don't bother with swap area's anymore. Its fixed 192k (3segs)
; picked this up from Win95

    xor     ax,ax                           ; No max
    mov es:[ne_swaparea],ax
    BootTrace   'v'


; Allocate memory for kernel segments

    cCall   LKAllocSegs,<es>
    mov oNRSeg,ax
    mov oMSeg, bx       ; Misc segment
    mov es,hExeHead


; If this is a pMode debug version, the code and data segments have already
; been defined to the debugger once.  We're about to LoadSegment and define
; these segments again in their final location.  Use a special form of
; DebugFreeSegment to force the debugger to pull out any breakpoints in these
; segments.  If we don't do this, any existing breakpoints become INT 3's
; in the new copy of the segment and the code has to be patched by hand.
; If only the debugger was smart enough to 'move' the breakpoints when it
; saw a second define for an already loaded segment...

if SDEBUG

    cCall   DebugFreeSegment,<cs,-1>
    cCall   DebugFreeSegment,<MyCSDS,-1>
endif

; Load kernel code segment 1 (resident code)

    mov si,1
    mov ax,-1           ; Indicate loading from memory
    cCall   LoadSegment,<es,si,cs,ax>
    or  ax,ax
    jnz ll1
fail2:  jmp bootfail
ll1:
    mov segNewCS,ax     ; Save new CS value


; Load kernel data segment (segment 4)

    mov si,4
    mov ax,-1
    cCall   LoadSegment,<hExeHead,si,ds,ax>
    or  ax,ax
    jz  fail2

    BootTrace   'w'


; locate the stack in the new segment

    mov bx,ax
    mov si,initSP
    add si,EXTRASTACKSIZE

    cCall   get_physical_address,<ax>
    add ax,initSSbias
    adc dx,0
    sub ax,10h
    sbb dx,0
    or  ax,10h
    FCLI
    mov prev_gmove_SS, ss   ; Switch stack while we set up new SS
    smov    ss, ds
    mov sp, OFFSET gmove_stack
    cCall   set_physical_address,<prev_gmove_SS>
    push    bx
    mov bx, si
    xor cx, cx          ; cx:bx=stack len (for set_sel_limit)
    cCall   set_sel_limit,<prev_gmove_SS>
    pop bx
    xor ax, ax
    xchg    ax, prev_gmove_SS
    mov ss,ax           ; Switch to new stack location
    mov sp,si
    FSTI
    mov ax,bx


; zero the new TDB

    push    ax

    cCall   get_physical_address,<ax>
    add ax,initTDBbias
    adc dx,0
YAH_WELL =  (SIZE TDB+15) and NOT 15
    cCall   alloc_data_sel,<dx,ax,0,YAH_WELL>
    mov es,ax
    xor ax,ax
    mov di,ax
    mov cx,SIZE TDB
    cld
    rep stosb
    pop ax

; put the limits in the stack

    xor bp,bp               ; zero terminate BP chain.
    mov ss:[pStackBot],sp
    mov ss:[pStackMin],sp
    mov ss:[pStackTop],10h
    mov ss:[0],bp       ; To mark this stack as NOT linked
    mov ss:[2],bp       ;  to another, see PatchStack.
    mov ss:[4],bp

; initialize the new TDB

    sub sp,SIZE TASK_REGS
    mov es:[TDB_taskSS],ss
    mov es:[TDB_taskSP],sp
    mov cx,topPDB
    mov es:[TDB_PDB],cx         ; save new PDB
    mov es:[TDB_DTA].off,80h        ; set initial DTA
    mov es:[TDB_DTA].sel,cx
    mov bx,1                ; BX = 1
    mov es:[TDB_nEvents],bx     ; Start this guy up!
    mov es:[TDB_pModule],-1     ; EMS requires -1
    mov bx,winVer
    mov es:[TDB_ExpWinVer],bx       ; Windows Version #
    mov es:[TDB_sig],TDB_SIGNATURE  ; Set signature word.

; initialize the task BP and DS

    push    es
    les bx,dword ptr es:[TDB_taskSP]
    mov es:[bx].TASK_BP,bp      ; initial BP = 0
    mov es:[bx].TASK_DS,bp      ; initial DS = 0
    pop es

    mov ds,ax           ; switch to new DS segment
    mov ax,segNewCS     ; recover new CS value

    push    cs          ; to free the selector

; do a far return to the new code segment

    push    ax
    mov ax,codeOffset new_code
    push    ax
    ret_far             ; FAR return to new code segment

    public new_code
new_code:

    pop ax
    push    es
    cCall   free_sel,<ax>           ; Free old CS selector
    cCall   IPrestoChangoSelector,<cs,MyCSAlias>    ; Change our CS Alias

    mov es,MyCSAlias            ; Change MyCSDS to new DS
    assumes es,CODE
    mov ax,ds
    xchg    ax,es:MyCSDS
    assumes es,nothing
    cCall   free_sel,<ax>           ; Free old DS selector

    call    DebugDebug      ; do after MyCSDS changes

    mov pExitProc.sel,cs    ; reset this!!

;;; pusha
;;; cCall   get_physical_address,<cs>
;;; add ax, codeOffset end_page_locked
;;; adc dx, 0
;;; mov bx, dx
;;; mov cx, ax
;;; mov di, cs
;;; lsl di, di
;;; sub di, codeOffset end_page_locked
;;; xor si, si
;;; mov ax, 0601h
;;; int 31h             ; Unlock some of Kernel!
;;; popa

    cCall   SelToSeg,<ds>       ; Save DS segment value
    mov MyDSSeg,ax

    cCall   SelToSeg,<cs>       ; Set segment equivalent
    mov MyCSSeg, ax

; calculate the maximum amount that we will allow SetSwapAreaSize to set

    mov ax,-1           ; They can only harm themselves.

    mov MaxCodeSwapArea,ax

ifndef WOW              ; WOW uses 32 bit profile api's

; Allocate a handle for WIN.INI

    xor ax,ax
    mov bx,GA_SHAREABLE shl 8 OR GA_MOVEABLE
    cCall   IGlobalAlloc,<bx,ax,ax>
    mov [WinIniInfo.hBuffer], ax
    or  ax,ax
    jz  nowinini
    mov bx,ax           ; put handle into base register
    mov ax,hExeHead
    mov es,ax
    call    set_discarded_sel_owner
                    ; Set up the filename
    mov word ptr [WinIniInfo.lpProFile], dataoffset szUserPro
    mov word ptr [WinIniInfo.lpProFile][2], ds
nowinini:

; Allocate a handle for Private Profiles

    xor ax,ax
    mov bx,GA_SHAREABLE shl 8 OR GA_MOVEABLE
    cCall   IGlobalAlloc,<bx,ax,ax>
    mov [PrivateProInfo.hBuffer],ax
    or  ax,ax
    jz  noprivate
    mov bx,ax           ; put handle into base register
    mov ax,hExeHead
    mov es,ax
    call    set_discarded_sel_owner
noprivate:
endif; WOW

ifdef WOW
    ; Allocate a ~128K discardable code selector to hide the
    ; GrowHeap - heap not sorted bugs, also present in Win 3.1.
    ;
    ; Since our system DLLs (like krnl386, user, gdi etc) contain a few
    ; discardable codesgements (of approx 40K), we need not be precise
    ;
    push    es
    mov     ax, 0C000H ; hiword is 01h , totalsize 0x1c000 bytes
    mov     bx, GA_MOVEABLE OR GA_DISCCODE
    cCall   IGlobalAlloc,<bx,01h,ax>
    or      ax,ax
    jz      short nogrowheap
    cCall   SetOwner, <ax, hExeHead>
nogrowheap:
    pop     es
endif; WOW

; Now shrink off exe header and segment 1 of KERNEL.EXE

    mov si,2            ; Segment number
    xor ax,ax
    xchg    oNRSeg,ax
nofastboot:
    sub ax,cpShrunk
    mov cpShrink,ax     ; Amount to shrink by
    cCall   MyLock,<hLoadBlock>
    mov bx,ax
    xchg    segLoadBlock,ax
    cCall   get_physical_address,<ax>
    mov cx,dx
    xchg    bx,ax
    cCall   get_physical_address,<ax>
    sub bx,ax
    sbb cx,dx
    REPT    4
    shr cx,1
    rcr bx,1
    ENDM
    mov ax,bx
    add cpShrink,ax
    push    ax
    cCall   Shrink
    pop ax
    sub cpShrunk,ax

; Load kernel code segment 2 (non-resident code)

    cCall   MyLock,<hLoadBlock>
    mov bx,-1           ; Indicate loading from memory
    cCall   LoadSegment,<hExeHead,si,ax,bx>
    or  ax,ax
    jnz ll2
    pop es
    jmp bootfail
ll2:

    inc si          ; On to segment 3
    xor ax, ax
    xchg    ax, oMSeg       ; Once back only!
    or  ax, ax
    jnz nofastboot

    pop es


    call    genter
    smov    ds, es
    UnSetKernelDS
    SetKernelDS es
     ;;;mov ax,EMScurPID           ; In case an EMS fast boot is going down.
     ;;;mov ds:[TDB_EMSPID],ax

     ;;;mov ax,ds:[TDB_EMSPID]
     ;;;mov PID_for_fake,ax
     ;;;mov EMScurPID,ax
    mov curTDB,ds
    mov headTDB,ds
    push    es

                    ; vectors
SaveVec MACRO   vec
    mov ax, 35&vec
    DOSCALL
    mov [di.off], bx
    mov [di.sel], es
    add di, 4
    ENDM

    push    di
    mov di, TDB_INTVECS
    SaveVec 00h
    SaveVec 02h
    SaveVec 04h
    SaveVec 06h
    SaveVec 07h
    SaveVec 3Eh
    SaveVec 75h

ifdef WOW
;;  Hook Int10 so we can filter calls in WOW (see intnn.asm)
    push    es
    push    ds
    mov     ax,3510h
    INT21
    mov     ax,codeOffset prevInt10proc
    SetKernelCSDword        ax,es,bx
    mov     ax,2510h
    smov    ds,cs
    mov     dx,codeOFFSET Int10Handler
    INT21
    pop     ds
    pop     es
endif

    pop di

    cCall   SaveState,<ds>
    pop es
    mov ds,pGlobalHeap
    call    gleave
    UnSetKernelDS   es

    mov ax, 32          ; Kernel wants a big handle table
    cCall   SetHandleCount,<ax>

    SetKernelDS

;
; The following variable initialization is done here to avoid having
; relocations in Kernel's data segment.
;
    mov lpInt21.off,codeOFFSET Int21Handler
    mov lpInt21.sel,cs

;
; Before we hook exception handlers, make sure the DPMI exception
; handler stack is set up the way Windows likes it.
;
    mov bl,6
    mov ax,0202h        ; DPMI get exception handler vector
    int 31h
    push    cx
    push    dx

    mov cx,cs
    lea dx,fixing_stack
    mov bl,6
    mov ax,0203h        ; DPMI set exception handler vector
    int 31h

    pop dx
    pop cx
;
; Generate an invalid opcode exception fault.  This causes DPMI to call
; our "exception handler."
;
    db  0fh,0ffh
fixing_stack:
    push    bp
    mov bp,sp       ; BP -> BP RETIP RETCS EC IP CS FL SP SS
;
; Restore the previous invalid exception handler vector.
;
    mov bl,6
    mov ax,0203h
    int 31h
;
; Replace the return address on the DPMI fault handler routine with
; our exit code.
;
    lea ax,done_fixing_stack
    mov [bp+8],ax
    mov [bp+10],cs

    lea ax,[bp+16]
    mov ss:[pStackBot],ax
    mov ss:[pStackMin],sp
    mov ss:[pStackTop],offset pStackBot + 150

    mov sp,bp
    pop bp
    retf

done_fixing_stack:

    mov es, MyCSAlias
    assumes es, CODE


; Hook not present fault for segment reloader.

    mov ax,0202h        ; Record old not present fault.
    mov bl,0Bh
    int 31h
    mov prevInt3Fproc.off,dx
    mov prevInt3Fproc.sel,cx

    mov ax,0203h        ; Hook not present fault.
    mov cx,cs
    mov dx,codeOffset SegmentNotPresentFault
    int 31h

; Hook GP fault in order to terminate app.

    mov bl, 0Dh         ; GP Fault
    mov ax, 0202h
    int 31h
    mov prevInt0Dproc.off, dx
    mov prevInt0Dproc.sel, cx

    mov ax, 0203h
    mov cx, cs
    mov dx, codeOffset GPFault
    int 31h

; Hook invalid op-code in order to terminate app.

    mov bl, 06h         ; invalid op-code
    mov ax, 0202h
    int 31h
    mov prevIntx6proc.off, dx
    mov prevIntx6proc.sel, cx

    mov ax, 0203h
    mov cx, cs
    mov dx, codeOffset invalid_op_code_exception
    int 31h

; Hook stack fault in order to terminate app.

    mov bl, 0Ch         ; stack fault
    mov ax, 0202h
    int 31h
    mov prevInt0Cproc.off, dx
    mov prevInt0Cproc.sel, cx

    mov ax, 0203h
    mov cx, cs
    mov dx, codeOffset StackFault
    int 31h

; Hook bad page fault in order to terminate app.

    mov bl, 0Eh         ; page fault
    mov ax, 0202h
    int 31h
    mov prevInt0Eproc.off, dx
    mov prevInt0Eproc.sel, cx

    mov ax, 0203h
    mov cx, cs
    mov dx, codeOffset page_fault
    int 31h

ifdef WOW

; Hook divide overflow trap in order to get better WOW debugging.

    mov bl, 00h         ; divide overflow
    mov ax, 0202h
    int 31h
    mov oldInt00proc.off, dx
    mov oldInt00proc.sel, cx

    mov ax, 0203h
    mov cx, cs
    mov dx, codeOffset divide_overflow
    int 31h

; Hook single step trap in order to get better WOW debugging.

    mov bl, 01h         ; single step
    mov ax, 0202h
    int 31h
    mov prevInt01proc.off, dx
    mov prevInt01proc.sel, cx

    mov ax, 0203h
    mov cx, cs
    mov dx, codeOffset single_step
    int 31h

; Hook breakpoint trap in order to get better WOW debugging.

    mov bl, 03h         ; page fault
    mov ax, 0202h
    int 31h
    mov prevInt03proc.off, dx
    mov prevInt03proc.sel, cx

    mov ax, 0203h
    mov cx, cs
    mov dx, codeOffset breakpoint
    int 31h

endif

    assumes es, nothing

; Do a slimy fix-up of __WinFlags containing processor and protect mode flags

    xor ax,ax
    mov dx,178
    cCall   GetProcAddress,<hExeHead,ax,dx>
    mov ax,WinFlags
    mov es:[bx],ax

ifdef WOW
    ; get WOW32 thunk table offsets and do fixups

    ; WARNING: WOW32 has a dependency on this being called after
    ; kernel is done booting and addresses are fixed
    push    ds
    push    dataoffset MOD_KERNEL
    call    far ptr WOWGetTableOffsets

    mov     si, dataoffset MOD_KERNEL
    mov     cx, ModCount ; # fixups to do
    mov     di, 570      ; first ordinal of the group (DANGER hardcoded from kernel.def)

Mexico:

    push    si
    push    di
    push    cx

    push    hExeHead
    push    0
    push    di
    call    GetProcAddress

    pop     cx
    pop     di
    pop     si
    mov     ax,[si]
    mov     es:[bx],ax

    inc     si  ; point to next word
    inc     si
    inc     di  ; get next ordinal

    loop    Mexico
endif

; Do a very slimy fix-up of the runtime constant __0000h

    cCall   GetProcAddress,<hExeHead,0,183>
    mov si,bx
    mov bx,00000h
    mov ax,2
    int 31h
    mov es:[si],ax

; Do a very slimy fix-up of the runtime constant __0040h

    cCall   GetProcAddress,<hExeHead,0,193>
    mov si,bx
    mov bx,00040h
    mov ax,2
    int 31h
    mov es:[si],ax

; Do a very slimy fix-up of the runtime constant __ROMBIOS

    cCall   GetProcAddress,<hExeHead,0,173>
    mov si,bx
    mov bx,0F000h
    mov ax,2
    int 31h
    mov es:[si],ax

; Do a very slimy fix-up of the runtime constant __F000h

    cCall   GetProcAddress,<hExeHead,0,194>
    mov si,bx
    mov bx,0F000h
    mov ax,2
    int 31h
    mov es:[si],ax

; Do a very slimy fix-up of the runtime constant __A000h

    cCall   GetProcAddress,<hExeHead,0,174>
    mov si,bx
    mov bx,0A000h
    mov ax,2
    int 31h
    mov es:[si],ax

; Do a very slimy fix-up of the runtime constant __B000h

    cCall   GetProcAddress,<hExeHead,0,181>
    mov si,bx
    mov bx,0B000h
    mov ax,2
    int 31h
    mov es:[si],ax

; Do a very slimy fix-up of the runtime constant __B800h

    cCall   GetProcAddress,<hExeHead,0,182>
    mov si,bx
    mov bx,0B800h
    mov ax,2
    int 31h
    mov es:[si],ax

; Do a very slimy fix-up of the runtime constant __C000h

    cCall   GetProcAddress,<hExeHead,0,195>
    mov si,bx
    mov bx,0C000h
    mov ax,2
    int 31h
    mov es:[si],ax

; Do a very slimy fix-up of the runtime constant __D000h

    cCall   GetProcAddress,<hExeHead,0,179>
    mov si,bx
    mov bx,0D000h
    mov ax,2
    int 31h
    mov es:[si],ax

; Do a very slimy fix-up of the runtime constant __E000h

    cCall   GetProcAddress,<hExeHead,0,190>
    mov si,bx
    mov bx,0E000h
    mov ax,2
    int 31h
    mov es:[si],ax

ifndef WOW
    cCall   SetUserPro      ; Get WIN.INI filename from environment
endif

    CheckKernelDS

; Free high memory copy of KERNEL.EXE

    cCall   IGlobalFree,<hLoadBlock>
    mov hLoadBlock,ax

        .386
    mov fs, ax
    mov gs, ax
        .286p

ifndef WOW
    cmp lpWindowsDir.sel,ax
    jnz got_win_dir
    mov si,dataOffset szUserPro
    mov di,dataOffset [WinIniInfo.ProBuf]
    cCall   IOpenFile,<dssi,dsdi,OF_PARSE>
    lea di,[di].opfile
    mov lpWindowsDir.sel,ds
    mov lpWindowsDir.off,di
    mov dx,di
    call    GetPureName
    sub di,dx
    dec di
    mov cBytesWinDir,di
got_win_dir:
endif

ifdef WOW
; Regular Windows kernel sets up the Windows directory very early in
; boot, before WOW kernel loads WOW32.DLL.
;
; It turns out we can delay setting up the 16-bit copy of the
; windows directory (referred by lpWindowsDir) until here, where
; we're in protected mode and about to set up the system directories
; as well.  This allows us to call a GetShortPathName thunk in
; WOW32.
;

    mov ds,topPDB
    UnSetKernelDS
    mov ds,ds:[PDB_environ]

    call    get_windir      ; on return, DS:DI -> windows dir

    smov    es,ds
    SetKernelDS

; Record where to find the 'windows' directory.
    BootTrace   'q'

    mov lpWindowsDir.sel,es
    mov lpWindowsDir.off,di
    mov cBytesWinDir,cx

; Record where to find the 'system32' directory.

    mov ax,hExeHead
    mov es,ax
    mov di,es:[ne_pfileinfo]
    lea di,es:[di].opFile
    mov lpSystemDir.sel,es
    mov lpSystemDir.off,di
    mov dx,di
    call    GetPureName
    sub di,dx
    dec di
    mov cBytesSysDir,di

    BootTrace   'u'

;
; Under WOW there are two system directories: \nt\system and \nt\system32.
; lpSystemDir points to \nt\system32, while lpSystem16Dir points to
; \nt\system.  We return the latter from GetSystemDirectory, since we want
; applications to install their shared stuff in \nt\system, but we want
; to search \nt\system32 before \nt\system when loading modules.
; Set up lpSystem16Dir using the Windows dir + \system.
; Note that the string pointed to by lpSystem16Dir is not null terminated!

    mov lpSystem16Dir.sel,ds
    mov lpSystem16Dir.off,dataoffset achSystem16Dir

    cld
    mov si,dataoffset achRealWindowsDir
    mov es,lpSystem16Dir.sel
    mov di,lpSystem16Dir.off
    mov cx,cbRealWindowsDir
    rep movsb                      ; copy Windows dir

    mov si,dataoffset Sys16Suffix
    mov cx,cBytesSys16Suffix
    rep movsb                      ; tack on "\system"

    mov cx,cbRealWindowsDir
    add cx,cBytesSys16Suffix
    mov cBytesSys16Dir,cx


;
; build the Wx86 system directory "Windir\Sys32x86"
;
    mov lpSystemWx86Dir.sel,ds
    mov lpSystemWx86Dir.off,dataoffset achSystemWx86Dir

    mov es,lpSystemWx86Dir.sel
    mov di,lpSystemWx86Dir.off
    mov cx,cbRealWindowsDir
    mov si,dataoffset achRealWindowsDir
    rep movsb                      ; copy System dir (Windows\System32)

    mov si,dataoffset SysWx86Suffix
    mov cx,cBytesSysWx86Suffix
    rep movsb                      ; tack on "\Wx86"

    mov cx,cbRealWindowsDir
    add cx,cBytesSysWx86Suffix
    mov cBytesSysWx86Dir,cx


@@:
;   WOW DPMI Supports wants to call GlobalDosAlloc and GlobalDosFree so that
;   We don't have to write the same code for DPMI support.   So we call DPMI
;   Here with the addresses of those routines so he can call us back.

    mov     bx,cs
    mov     si,bx

    mov     dx,codeOffset GlobalDosAlloc
    mov     di,codeOffset GlobalDosFree

    mov     ax,4f3h
    int     31h

; Now that we've built up the system dir from the windows dir, set
; the windows dir to where it should be for this user.
    push  es
    cld
    mov   di,offset achTermsrvWindowsDir
    cCall TermsrvGetWindowsDir,<ds, di, MaxFileLen>
    or    ax, ax
    jz    @F                    ; ax = 0 -> error, just leave windows dir

    smov es,ds
    mov  cx,-1
    xor  ax,ax
    repnz scasb
    not  cx
    dec  cx                     ; length of windows directory

    mov lpWindowsDir.sel,ds
    mov lpWindowsDir.off,offset achTermsrvWindowsDir
    mov cBytesWinDir,cx
@@:
    pop  es

endif


; Under win 2.11 we allowed the ":" syntax to replace the shell.
;  We no longer allow this, however to avoid messing up people
;  with batch files that have ":" in them we will strip the
;  ":" out of the command line.  But we retain the :: syntax
;  for the OS/2 VM!!

; We also do the check for the /b switch here.  This puts us in "diagnostic
;  mode and we set a flag to say this.  Later, we will call the DiagInit()
;  function to open the log file, etc.

    push    ds
    cld
    mov ds,topPDB
    UnSetKernelDS
    push    ds
    pop es
    mov si,80h
    xor ax,ax
    lodsb
    or  al,al
    jz  no_colon
    mov cx,ax
@@: lodsb
    cmp al,' '
    loopz   @B
    cmp al,':'
    jnz no_colon
    cmp byte ptr [si],':'
    jz  no_colon
    mov byte ptr [si][-1],' '
no_colon:
        cmp     al,'/'                  ;Switch character?
        je      CheckSwitch             ;Yes
        cmp     al,'-'                  ;Other switch character?
        jne     NoSwitch                ;Nope.
CheckSwitch:
        lodsb                           ;Get next char
        or      al,32                   ;Convert to lowercase if necessary
        cmp     al,'b'                  ;Diagnostic mode?
        jnz     NoSwitch                ;Nope
        cCall   DiagInit                ;Initialize diagnostic mode
        mov     WORD PTR [si-2],2020h   ;Blank out the switch
NoSwitch:
    pop ds
    ReSetKernelDS

        ;** Reset secret flag for memory manager.  Fixed segments will go
        ;** >1MB after this
        and     fBooting, NOT 2

        ;** We want to grow the SFT *before* loading the modules,
        ;**     not after, like was the case previous to win3.1
    call    GrowSFTToMax        ;add to SFT chain in p mode

if 1
; old ldinit.c

    cld
    push    ds
    smov    es,ds
    xor ax,ax
    xor cx,cx
    mov ds,topPDB
    UnSetKernelDS
    mov si,80h
    lodsb
    or  al,al
    jz  gwaphics_done
    mov cl,al
    lodsb
    cmp al,' '
    mov al,ah
    jnz gwaphics_done
    lodsb
    cmp al,':'
    mov al,ah
    jnz gwaphics_done
    lodsb
    cmp al,':'
    mov al,ah
    jnz gwaphics_done

    mov di,dataOffset app_name

find_delineator:
    lodsb
    stosb
    cmp al,' '
    ja  find_delineator
    mov es:[di][-1],ah
    mov ds:[80h],ah     ; assume no arguments
    jnz gwaphics_done

    add cx,82h
    sub cx,si
    smov    es,ds
    mov di,80h
    mov al,cl
    stosb
    rep movsb

gwaphics_done:
    pop ds
    ReSetKernelDS
    or  ax,ax
    jz  @F
    mov graphics,0
@@:
else
    cld
    xor ax,ax
    xor bx,bx
endif
    jmps    SlowBoot


bootfail:
    mov al,1
    cCall   ExitKernel,<ax>
cEnd nogen

sEnd    INITCODE

;-----------------------------------------------------------------------;
; SlowBoot                              ;
;                                   ;
;                                   ;
; Arguments:                                ;
;                                   ;
; Returns:                              ;
;                                   ;
; Error Returns:                            ;
;                                   ;
; Registers Preserved:                          ;
;                                   ;
; Registers Destroyed:                          ;
;                                   ;
; Calls:                                ;
;                                   ;
; History:                              ;
;                                   ;
;  Sat Mar 14, 1987 05:52:22p  -by-  David N. Weise   [davidw]      ;
; Added this nifty comment block.                   ;
;-----------------------------------------------------------------------;

DataBegin INIT

BootSect    db  'BOOT',0
BootFile    db  'SYSTEM.INI',0
FilesCached db  'CACHEDFILEHANDLES',0
IdleSegLoad db  'LOADSEGMENTSATIDLE',0
ifdef WOW
ExitLastApp db  'CLOSEONLASTAPPEXIT',0
endif

if SHERLOCK
  szGPC     db  'GPCONTINUE',0
endif

szDebugSect db  'DEBUG',0
szOutputTo  db  'OUTPUTTO', 0
szAux       db  0 ;'AUX', 0     ; don't return a default

if KDEBUG
szKRInfo    db  'KERNELINFO', 0
szKRBreak   db  'KERNELBREAK', 0
szWin3Info  db  'WIN3INFO', 0
szWin3Break db  'WIN3BREAK', 0
endif

BootBufLen  equ     80
BootBuf     db  BootBufLen dup (?)

bootmods label  byte
    DB  'SYSTEM.DRV',0
winmods label   byte
ifdef WOW
    DB  'KEYBOARD.DRV',0
szAfterKeyboardDriver label byte        ;Used so we can tell key driver loaded
    DB  'MOUSE.DRV',0

ifdef   FE_SB
szBeforeWifeMan label byte  ;Used so we can tell key driver loaded
    DB  'WIFEMAN.DLL', 0    ;WIFE manager has to be loaded before display driver
endif
    DB  'VGA.DRV',0
        DB      'SOUND.DRV',0
        DB      'COMM.DRV',0
        DB      'USER.EXE',0
        DB      'GDI.EXE',0
ifdef   FE_SB
szBeforeWinNls label byte   ;Used so we can tell key driver loaded
    DB  'WINNLS.DLL', 0     ;bug #112335
endif

else
        DB      'KEYBOARD.DRV',0
szAfterKeyboardDriver label byte    ;Used so we can tell key driver loaded
    DB  'MOUSE.DRV',0
ifdef   FE_SB
szBeforeWifeMan label byte  ;Used so we can tell key driver loaded
    DB  'WIFEMAN.DLL', 0    ;WIFE manager has to be loaded before
                    ;display driver
endif
    DB  'DISPLAY.DRV',0
    DB  'SOUND.DRV',0
    DB  'COMM.DRV',0
    DB  'FONTS.FON',0
    DB  'OEMFONTS.FON',0    ; For Internationals use.
    DB  'GDI.EXE',0
    DB  'USER.EXE',0
ifdef   FE_SB
szBeforeWinNls label byte   ;Used so we can tell key driver loaded
    DB  'WINNLS.DLL', 0
endif

endif

ifdef WOW
defapp  label   byte
    DB  'WOWEXEC.EXE',0
else
defapp  label   byte
    DB  'PROGMAN.EXE',0
endif

Shell   label   byte
    DB  'WOWSHELL',0

;** Ordinal strings for two of the Keyboard driver exports
keymodstr   DB  'KEYBOARD',0
keyprocstr  DB  '#5',0      ; keyprocstr = AnsiToOem
keyprocstr1 DB  '#6',0      ; keyprocstr = OemToAnsi

DataEnd INIT

sBegin  INITCODE
assumes cs,CODE
assumes ds,nothing
assumes es,nothing

if BootTraceOn
cProc   BootTraceChar,<PUBLIC,NEAR,NODATA>, <ax, dx>
    parmW   char
cBegin
    mov dx, 3fdh
@@: in  al, dx
    test    al, 20h
    jz  @B
    mov ax, char
    mov dx, 3f8h
    out dx, al
cEnd

endif   ; BootTraceOn



cProc   ttywrite,<PUBLIC,NEAR,NODATA>, <ds, si>
    parmD   s
cBegin
;   cCall   lstrlen,<s>
;   mov cx, ax
;   lds bx, s
;   mov bx,1
;   mov ah,40h
;   int 21h
    lds si, s
    cld
    mov ah, 2
tty1:
    lodsb
    mov dl, al
    or  dl, dl
    jz  tty2
    int 21h
    jmps    tty1
tty2:
cEnd

ifdef WOW
cProc   LoadFail,<PUBLIC,NEAR,NODATA>, <ds,si,di,cx>
    parmD   s
cBegin
    ;** Put Up a Dialog Box If we can't load a module

    ; since szPleaseDoIt resides in protected cs we can't concat the module
    ; name to it -- so we need to copy it to the stack

    ;szPleaseDoIt db "Please re-install the following module to your system32
    ;                 directory: ",13,10,9,9,0
    mov     di,sp      ; save current stack pointer
    sub     sp,100h    ; allocate for new concat'd string on the stack
    mov     si,sp      ; save the start of the stack string

    push    ss         ; copy szPleaseDoIt to the stack buffer
    push    si
    push    cs
    push    codeOFFSET szPleaseDoIt
    call    lstrcpy

    push    ss         ; concat module name to string on stack
    push    si
    lds     cx, s      ; get the module name
    push    ds
    push    cx
    call    lstrcat

    push    ss         ;push finished stack string now
    push    si
    push    cs         ;szMissingMod db "KERNEL: Missing 16-bit module:",0
    push    codeOFFSET szMissingMod      ; Set Caption
    push    0                            ;No left button
    push    SEB_CLOSE + SEB_DEFBUTTON    ;Button 1 style
    push    0                            ;No right button
externFP kSYSERRORBOX
    call    kSYSERRORBOX                 ;Put up the system message

    mov     sp,di                        ; restore sp
cEnd
else  // non-WOW
cProc   LoadFail,<PUBLIC,NEAR,NODATA>, <ds>
    parmD   s
cBegin
    SetKernelDS
    cCall   TextMode
    mov bx, dataoffset szCRLF
    cCall   ttywrite, dsbx
    mov bx, dataoffset szCRLF
    cCall   ttywrite, dsbx
    mov bx, dataoffset szBootLoad
    cCall   ttywrite, dsbx
    cCall   ttywrite, s
    mov bx, dataoffset szCRLF
    cCall   ttywrite, dsbx
cEnd
endif

cProc   SlowBoot,<PUBLIC,NEAR>
cBegin nogen

    CheckKernelDS
    ReSetKernelDS

GPPI    macro   sect, key, defval, file, storeit
    push    ds
    push    dataoffset sect

    push    ds
    push    dataoffset key

    push    defval

    push    ds
    push    dataoffset file

    call    GetPrivateProfileInt
ifb <storeit>
    mov defval, ax
endif
endm


GPPS    macro   sect, key, defval, here, hereLen, file
    push    ds
    push    dataoffset sect

    push    ds
    push    dataoffset key

    push    ds
    push    dataoffset defval

    push    ds
    push    dataoffset here

    push    hereLen

    push    ds
    push    dataoffset file

    call    GetPrivateProfileString
endm

GPPS1   macro   sect, key, defval, here, hereLen, file
    push    ds
    push    dataoffset sect

    push    ds
    push    key

    push    ds
    push    defval

    push    ds
    push    dataoffset here

    push    hereLen

    push    ds
    push    dataoffset file

    call    GetPrivateProfileString
endm

GPI macro   sect, key, defval, storeit
    push    ds
    push    dataoffset sect

    push    ds
    push    dataoffset key

    push    defval

    call    GetProfileInt
ifb <storeit>
    mov defval, ax
endif
endm

if SHERLOCK
    GPI szKernel, szGPC, gpEnable
endif

if KDEBUG
ifdef DISABLE
    GPPI    szDebugSect, szKRInfo, _krInfoLevel, BootFile

    GPPI    szDebugSect, szKRBreak, _krBreakLevel, BootFile

    GPPI    szDebugSect, szWin3Info, _Win3InfoLevel, Bootfile

    GPPI    szDebugSect, szWin3Break, _Win3BreakLevel, Bootfile
endif
endif   ;KDEBUG

    GPPS    szDebugSect, szOutputTo, szAux, BootBuf, BootBufLen, BootFile
    or  ax, ax
    jz  @F
    cmp ax, BootBufLen-2
    jz  @F

    mov ah, 3ch     ; creat file (zero length)
    xor cx, cx
    mov dx, dataOffset BootBuf
    DOSCALL
    jc  @F

    mov bx, ax
    mov ah, 3eh     ; now close it
    DOSCALL
    jc  @F

    mov ax, 3d42h   ; open inherit, deny none, read/write
    DOSCALL
    jc  @F

    mov bx, ax      ; dup handle
    mov cx, 3       ; force AUX to be this file
    mov ah, 46h
    DOSCALL

    mov ah, 3eh     ; close temp file
    DOSCALL
    mov wDefRIP, 'i'    ; since AUX is redirected, assume Ignore RIP
@@:

    GPPI    BootSect, FilesCached, MAXFHCACHELEN, BootFile, nostore
    cmp ax, MINFHCACHELEN       ; Validate length
    jae @F
    mov ax, MINFHCACHELEN
@@: cmp ax, MAXFHCACHELEN
    jbe @F
    mov ax, MAXFHCACHELEN
@@: mov fhCacheLen, ax      ; Adjust # of cached file handles
    shl ax, 1
    shl ax, 1
    add ax, dataoffset fhCache
    mov fhCacheEnd, ax

    GPPI    BootSect, IdleSegLoad, 1, BootFile, nostore
    mov fPokeAtSegments, al

ifdef WOW
    GPPI    BootSect, ExitLastApp, 0, BootFile, nostore
    mov fExitOnLastApp, al
endif

    mov bootExecBlock.lpfcb1.off,dataOffset win_show
    mov bootExecBlock.lpfcb1.sel,ds
    mov es,topPDB

    mov bootExecBlock.lpcmdline.off,80h
    mov bootExecBlock.lpcmdline.sel,es

    mov lpBootApp.off,dataOffset app_name
    mov lpBootApp.sel,ds
    cmp graphics,1
    jnz sb1

    mov lpBootApp.off,dataOffset defapp
    mov lpBootApp.sel,ds

sb1:    mov di,dataOffset bootMods

sbloop1:
    cCall   LoadNewExe,<di>
    SetKernelDS es
    mov cx,-1
    xor ax,ax
    cld
    repnz   scasb
    cmp di,dataOffset winmods
    jb  sbloop1

    cmp graphics,1
    jz  sbloop2
;    cCall   InitFwdRef
    jmps    sb4
    UnSetKernelDS   es

sbloop2:                ; load USER.EXE, GDI.EXE
ifdef   FE_SB
        ;** If we just load the fae east modules, we want to
        ;**     checks the system locale vale which is far east
        ;**     locale.
        ;**     If system locale is not far east, then we skip
        ;**     to load far east module.
        cmp     di,dataOffset szBeforeWifeMan
        je      SB_DoFarEastModule
        cmp     di,dataOffset szBeforeWinNls
        jne     SB_DoLoadModule

SB_DoFarEastModule:
                cCall   GetSystemDefaultLangID
                ; return: ax is system locale value
                cmp     ax,411h
                je      SB_DoLoadModule
                cmp     ax,412h
                je      SB_DoLoadModule
                cmp     ax,404h
                je      SB_DoLoadModule
                cmp     ax,804h
                je      SB_DoLoadModule
                cmp     ax,0c04h
                je      SB_DoLoadModule

                        ; skip to next module
                        mov cx,-1
                        xor ax,ax
                        cld
                        repnz   scasb
                        jmp     SB_NotKeyboardDriver
SB_DoLoadModule:
endif
    cCall   LoadNewExe,<di>
        push    ax                      ; Save hInst return value
    SetKernelDS es
    mov cx,-1
    xor ax,ax
    cld
    repnz   scasb
        pop     si                      ; Get hInst of latest module in SI

        ;** If we just loaded the keyboard driver, we want to
        ;**     point our explicit link variables to the AnsiToOem and
        ;**     OemToAnsi functions so OpenFile can use them for the
        ;**     remaining boot modules
        cmp     di,dataOffset szAfterKeyboardDriver
        jne     SB_NotKeyboardDriver

        push    ds                      ; Save regs we care about
        push    di
    regptr  pStr,ds,bx

    mov bx,dataOffset keyprocstr
    cCall   GetProcAddress,<si,pStr>
    mov pKeyProc.off,ax
    mov pKeyProc.sel,dx

    mov bx,dataOffset keyprocstr1
    cCall   GetProcAddress,<si,pStr>
    mov pKeyProc1.off,ax
    mov pKeyProc1.sel,dx

    pop     di
    pop     ds

SB_NotKeyboardDriver:
    cmp di,dataOffset defapp
    jb  sbloop2

; OPTIMIZE BEGIN

; OPTIMIZE END

sb4:
    cCall   InitFwdRef              ; Gets stuff we can't dynalink to
    cCall   InternalEnableDOS   ; Enable int21 hooks
;sb4:
    call    check_TEMP

; Get the shell name from SYSTEM.INI

    mov     ax,dataoffset Shell
    GPPS1   BootSect, ax, lpBootApp.off, BootBuf, BootBufLen, BootFile

    ;** Here we need to convert the command line to ANSI
    cmp     WORD PTR pKeyProc1[2],0 ; Paranoia...
    jz      @F

    ;** Zero terminate the string before passing to OemToAnsi
    mov     es,bootExecBlock.lpcmdline.sel
    mov     bl,es:[80h]             ; Get length byte
    xor     bh,bh
    xchg    BYTE PTR es:[bx+81h],bh ; Replace terminator char with zero

    ;** Call the keyboard driver
    push    es                      ; Save the seg reg
    push    bx                      ; Save offset and char saved
    push    es
    push    81h                     ; Always starts here (fixed offset)
    push    es
    push    81h
    cCall   [pKeyProc1]             ; Call OemToAnsi in keyboard driver
    pop     bx                      ; Get saved info
    pop     es
    mov     al,bh                   ; Saved char from string
    xor     bh,bh
    mov     BYTE PTR es:[bx+81h],al ; Replace the character
@@:

    mov ax,dataOffset bootExecBlock
    regptr  dsax,ds,ax
    cmp graphics,1
    jz  @F

    cCall   LoadModule,<lpBootApp,dsax>
    jmps    asdf

@@: cCall   FlushCachedFileHandle,<hUser>   ; in case 100 fonts are loaded
    farptr  lpBootBuf,ds,di
    mov di, dataoffset BootBuf
    cCall   LoadModule,<lpBootBuf,dsax>

asdf:
    cmp ax,32
    jbe sb6

    cCall   GetExePtr,<ax>
    mov hShell, ax
    jmp bootdone

sb6:
    ReSetKernelDS
    les bx, lpBootApp
    krDebugOut DEB_ERROR, "BOOT: unable to load @ES:BX"
    cCall   LoadFail,<lpBootApp>

;   cmp pDisableProc.sel,0  ; Is there a USER around yet?
;   jz  @F
;   cCall   pDisableProc
;@@:
    jmp bootfail
    UnSetKernelDS
cEnd nogen


;------------------------------------------------------------------------

    assumes ds,nothing
    assumes es,nothing

cProc   LoadNewExe,<PUBLIC,NEAR>,<si,di>
    parmW   pname
cBegin
    farptr  lpparm,ax,ax
    farptr  lpBootBuf,ds,di
    mov di, dataoffset BootBuf

    CheckKernelDS
    ReSetKernelDS
ifdef WOW
;   ATM Alters system.ini registry boot section to load its own SYSTEM.DRV
;   However on WOW this causes us to fail to load correctly.   Also we
;   would be hard pushed to support the current 16 bit ATM since it relies
;   on internals of 16 bit GDI which are not present in WOW.
;   For this Beta I'm going to ignore the bootsection of the registry
;   when loading drivers and thus ATM will not get installed.
;   At least the user will be protected from not being able to boot WOW
;   BUGBUG - Consider
;   MattFe Oct9 92

    mov     di,pname
else
    GPPS1   BootSect, pname, pname, BootBuf, BootBufLen, BootFile
endif
    xor ax,ax
    cCall   LoadModule,<lpBootBuf,lpparm>
    cmp ax,2
    jne lne1
    krDebugOut DEB_ERROR, "Can't find @DS:DI"
;   kerror  ERR_LDBOOT,<BOOT: Unable to find file - >,ds,di
    jmps    lne4
lne1:
    cmp ax,11
    jne lne2
    krDebugOut DEB_ERROR, "Invalid EXE file @DS:DI"
;   kerror  ERR_LDBOOT,<BOOT: Invalid .EXE file - >,ds,di
    jmps    lne4
lne2:
    cmp ax,15
    jnz lne3
    krDebugOut DEB_ERROR, "Invalid protect mode EXE file @DS:DI"
;   kerror  ERR_LDBOOT,<BOOT: Invalid protect mode .EXE file - >,ds,di
    jmps    lne4

lne3:
    cmp ax, 4
    jne lne3a
    krDebugOut DEB_ERROR, "Out of files (set FILES=30 in CONFIG.SYS) @DS:DI"
;   kerror  ERR_LDFILES,<BOOT: Out of files, (set FILES=30 in CONFIG.SYS) loading - >,ds,di
    jmps    lne4

lne3a:
    cmp ax, 32
    jae lnex

NoLoadIt:
;   kerror  ERR_LDBOOT,<BOOT: Unable to load - >,ds,pname
    krDebugOut DEB_ERROR, "Unable to load @DS:DI (#ax)"
lne4:
    cCall   LoadFail,dsdi
    mov ax,1
    cCall   ExitKernel,<ax>
lnex:
    UnSetKernelDS
cEnd

sEnd    INITCODE

;-----------------------------------------------------------------------;
; BootDone                              ;
;                                   ;
; Boot is done when all of modules are loaded.  Here we do a bit of ;
; clean up, such as validating code segments, initing free memory to    ;
; CCCC, freeing up the fake TDB, and finally reallocating the init  ;
; code away.                                ;
;                                   ;
; Arguments:                                ;
;   none                                ;
;                                   ;
; Returns:                              ;
;   nothing                             ;
;                                   ;
; Error Returns:                            ;
;                                   ;
; Registers Preserved:                          ;
;                                   ;
; Registers Destroyed:                          ;
;   all                             ;
;                                   ;
; Calls:                                ;
;                                   ;
; History:                              ;
;                                   ;
;  Wed Apr 15, 1987 08:53:23p  -by-  David N. Weise   [davidw]      ;
; Added this nifty comment block.                   ;
;-----------------------------------------------------------------------;


DataBegin INIT

externB beg_initdata

szKernel    DB  'KERNEL',0
szWindows       DB  'WINDOWS',0

if KDEBUG
szDebugOptions  DB  'DebugOptions',0
szDebugFilter   DB  'DebugFilter',0

szChecksum  DB  'EnableSegmentChecksum',0
szSweepFreak    DB  'LRUSweepFrequency',0
sz80x87     DB  'NoUse80x87',0
szFastFP    DB  'FastFP', 0

externW DebugOptions
externW DebugFilter

ifdef DISABLE
externB fLoadTrace
endif

endif   ; KDEBUG

ifdef SDEBUG
szEMSDebug  DB  'EnableEMSDebug',0
endif
szgrab_386  DB  '386GRABBER',0

if SWAPPRO
szSwapPro   DB  'SwapProfile',0
szSwapFile  DB  'SWAPPRO.DAT',0
endif

DataEnd INIT


sBegin  INITCODE
assumes cs,CODE
assumes ds,nothing
assumes es,nothing

externB beg_initcode


cProc   BootDone,<PUBLIC,NEAR>
cBegin  nogen

    SetKernelDS

if KDEBUG

; Get win.ini [Windows] DebugOptions
        GPI     szWindows, szDebugOptions, DebugOptions
; Get win.ini [Windows] DebugFilter
        GPI     szWindows, szDebugFilter, DebugFilter

; Now set various internal flags based on DebugOptions

        xor     ax,ax
        test    DebugOptions,DBO_CHECKHEAP
        jz      @F
        inc     ax
@@:
    mov es,pGlobalHeap
    mov es:[hi_check],ax

        test    DebugOptions,DBO_CHECKFREE
        jz      @F
    or  Kernel_flags,kf_check_free
@@:
ifdef DISABLE
        xor     ax,ax
        test    DebugOptions,DBO_LOADTRACE
        jz      @F
    mov fLoadTrace, al
@@:
endif ; DISABLE
        test    DebugOptions,DBO_DISABLEGPTRAPPING
        jz      wants_trapping

    mov ax,0203h        ; Reset GP fault.
    mov bl,0Dh
    mov cx,prevInt0Dproc.sel
    mov dx,prevInt0Dproc.off
    int 31h

    mov ax,0203h        ; Reset invalid op-code exception.
    mov bl,06h
    mov cx,prevIntx6proc.sel
    mov dx,prevIntx6proc.off
    int 31h

    mov ax,0203h        ; Reset page fault.
    mov bl,0Eh
    mov cx,prevInt0Eproc.sel
    mov dx,prevInt0Eproc.off
    int 31h
wants_trapping:

if SWAPPRO
    GPI szKernel, szSwapPro, 1, nostore
    mov fSwapPro, al

    mov bx,TopPDB
    mov ah,50h
    pushf
    FCLI
    call    prevInt21Proc

    lea dx,szSwapFile
    xor cx,cx
    mov ah,3Ch
    pushf
    FCLI
    call    prevInt21Proc
    mov hSwapPro,ax

    mov bx,cur_dos_pdb
    mov ah,50h
    pushf
    FCLI
    call    prevInt21Proc
endif
    GPI szKernel, szChecksum, 1, nostore
    mov fChkSum,al

    GPI szKernel, sz80x87, 0, nostore
    or  ax,ax
    jz  wants_8087
    mov f8087,0
    and     WinFlags,NOT WF1_80x87  ;Turn off corresponding WinFlags bit
wants_8087:
    GPI szKernel, szFastFP, 1, nostore
    mov fastFP, al

    GPI szKernel, szSweepFreak, 500, nostore
else
    mov ax, 500
endif   ; KDEBUG

ifdef WOW
    xor ax,ax
endif

    or  ax,ax
    jz  nolrusweep

    test    WinFlags[1], WF1_PAGING
    jnz short nolrusweep

    mov bx,codeOffset lrusweep
    regptr  csbx,cs,bx
    xor dx,dx
    cCall   pTimerProc,<dx,ax,csbx>
nolrusweep:

if SDEBUG
    GPI szKernel, szEMSDebug, 0, nostore
    or  ax,ax
    jz  no_EMS_debug_wanted
    or  Kernel_flags,kf_EMS_debug
no_EMS_debug_wanted:
endif

if LDCHKSUM
    cCall   ValidateCodeSegments
endif

if KDEBUG
    mov fCheckFree,0
endif

; Get the shell name from SYSTEM.INI

    GPPS    BootSect, szgrab_386, szgrab_386, grab_name, 128, BootFile

    mov es,curTDB       ; ES = TDB of fake task
    push    es
    cCall   DeleteTask,<es>     ; Flush bogus task
    pop es
    xor dx,dx
    mov es:[TDB_sig],dx     ; Clear signature word.
    mov curTDB,dx       ; Let someone else be current task

; switch to the temp stack since we're about to Realloc the present one away

    mov ax, ss

    FCLI
    SetKernelDS ss
    mov sp,dataOffset gmove_stack
    FSTI

    cCall   free_sel,<ax>


; Shrink DGROUP down to its post initialization size

    mov     cx,dataOFFSET beg_initdata   ; don't need init data

    ; dx doubles as high word and specifies fixed
    ; reallocation
    xor     dx,dx
    cCall   IGlobalReAlloc,<ds,dx,cx,dx>     ; Realloc DGROUP

    xor     dx,dx


; Now shrink the resident CODE segment

    mov cx,codeOFFSET beg_initcode   ; dont need init code

;   cCall   IGlobalReAlloc,<cs,dxcx,dx>
;   jmps    BootSchedule          ; Jump to schedule first app

    push    cs      ; Arguments to GlobalReAlloc
    push    dx
    push    cx
    push    dx
    push    cs      ; Where GlobalReAlloc will eventually return
    mov ax,codeOFFSET BootSchedule
    push    ax
    jmp near ptr IGlobalReAlloc  ; Jump to GlobalReAlloc

    UnSetKernelDS   ss
    UnSetKernelDS
cEnd    nogen


;-----------------------------------------------------------------------;
; check_TEMP
;
; If the environment variable TEMP points to garbage then GetTempFile
; screws up.  We fix it by wiping out the TEMP string if it points
; to garbage.
;
; Entry:
;   none
;
; Returns:
;
; Registers Preserved:
;   all
;
; History:
;  Thu 11-May-1989 16:39:34  -by-  David N. Weise  [davidw]
; Wrote it.
;-----------------------------------------------------------------------;

    assumes ds,nothing
    assumes es,nothing

cProc   check_TEMP,<PUBLIC,NEAR>,<ds,es>
ifdef   FE_SB
    localW  pMyBuf
endif
cBegin
    pusha
    SetKernelDS
    sub sp,130
    mov di,sp
    CheckKernelDS
    mov ds,TopPDB
    UnSetKernelDS
    mov ds,ds:[PDB_environ]
    xor si, si          ; assume DS:SI points to environment
    cCall   GetTempDrive,<si>
    smov    es,ss
    cld
    stosw
ifdef   FE_SB
    mov pMyBuf,di       ; save string offset(exclude D:)
endif
stmp2:
    lodsw
    or  al,al           ; no more enviroment
ifdef   FE_SB
    jnz @F          ; I hate this
    jmp stmpNo1
@@:
else
    jz  stmpNo1
endif
    cmp ax,'ET'         ; Look for TEMP=
    jne stmp3
    lodsw
    cmp ax,'PM'
    jne stmp3
    lodsb
    cmp al,'='
    je  stmpYes
stmp3:  lodsb
    or  al,al
    jnz stmp3
    jmp stmp2
stmpYes:
    push    si          ; save pointer to TEMP
    push    ds

    push    si          ; spaces are legal, but they
lookForSpace:               ; confuse too many apps, so
    lodsb               ; we treat them as illegal
    cmp al, ' '
    jz  stmpFoundSpace
    or  al, al
    jnz lookForSpace
    pop si
    cmp byte ptr [si+1],':'
    jne stmpnodrive
    and byte ptr [si],NOT 20h   ; springboard needs this!
    dec di
    dec di
stmpnodrive:
    lodsb
    or  al,al
    jz  stmpNo
    stosb
    jmp stmpnodrive

stmpNo:
    mov ax,'~\'
    cmp es:[di-1],al        ; does it already end in \
    jnz stmpNoF         ; no, just store it
    dec di          ; override it
ifdef   FE_SB
    push    si
    mov si,pMyBuf
    call    FarMyIsDBCSTrailByte    ;is that '\' a DBCS trailing byte?
    cmc
    adc di,0            ;skip it if yes.
    pop si
endif
stmpNoF:
    stosw
    xor ax,ax
    stosb               ; zero terminate it
    pop es          ; recover pointer to TEMP
    pop di
    smov    ds,ss
    mov dx,sp
    mov ax,5B00h
    xor cx,cx
    DOSCALL
    jnc stmpClose
    cmp al,80           ; Did we fail because the file
    jz  stmpNo1         ;  already exists?
stmpNukeIt:
    sub di,5            ; Get the TEMP= part.
@@: mov al,'x'
    xchg    al,es:[di]
    inc di
    or  al,al
    jnz @B
    mov byte ptr es:[di-1],0
    jmps    stmpNo1

stmpClose:
    mov bx,ax
    mov ah,3Eh
    DOSCALL
    mov ah,41h
    DOSCALL

stmpNo1:
    add sp,130
    popa
cEnd
stmpFoundSpace:
    pop si
    pop     es
    pop di
    jmps    stmpNukeIt


;-----------------------------------------------------------------------;
; get_windir
;
; Get a pointer to the 'windows' directory.
;
; Entry:
;   DS => environment string
;
; Returns:
;   CX = length of string
;   DI => WFP of 'windows' directory
;
; Registers Preserved:
;   all
;
; History:
;  Mon 16-Oct-1989 23:17:23  -by-  David N. Weise  [davidw]
; Wrote it!
;-----------------------------------------------------------------------;

    assumes ds,nothing
    assumes es,nothing

ifdef WOW
;-----------------------------------------------------------------------;
; original get_windir looks for the environment variable 'windir' (all
; lowercase) to set the 'windows' directory.
;
; On NT the equivalent environment variable is 'SystemRoot' (all
; uppercase). Hence the code is different.
;
;                                             - nanduri
;
; There are some customers that used the undocumented trick on win31
; of moving windir to some network location by putting win.com there.
; The result would be that the "Windows Directory" would point
; to the network location, and the system directory would be local.
; Currently, the way WINDIR is supported involves hacks in a couple
; of different places. What would be best is if you could do a
; "set windir=xxxx" in your autoexec.nt and we would look for windir
; here and we would code it to emulate win31 behavior. However, that's
; broken right now, and windir is only regenerated after krnlx86.exe
; has finished booting. So the approach taken here is to look for
; a new environment variable called win16dir, and if it exists, make
; the windows directory point to it. Systemroot is still used to
; generate the system directory.
;
; We want to allow NT to be installed into a directory with a long
; name, so we use GetShortPathName on the directory we get from
; either SystemRoot or Win16Dir variables.
; -- DaveHart 9-Feb-96
;-----------------------------------------------------------------------;

szSystemRoot  DB  'SYSTEMROOT=',0
szWin16Dir    DB  'WIN16DIR=',0

cProc   get_windir,<PUBLIC,NEAR>
cBegin nogen

    push  es
    mov   ax, cs        ; the string is in 'cs', see above
    mov   es, ax
    mov   di, codeoffset szSystemRoot
    call  get_env_var_ptr

    push  dx
    mov   dx, ds
    mov   es, dx
    SetKernelDS
    mov   si, dataoffset achRealWindowsDir
    regptr esdi,es,di
    regptr dssi,ds,si
    mov   cx, WINDIR_BUFSIZE
    push  dx
    cCall GetShortPathName, <esdi, dssi, cx>
    pop   dx
    mov   cbRealWindowsDir,ax
    mov   ds, dx                         ;restore ds
    pop   dx
    assumes ds,nothing

    push  cx
    push  di

    mov   ax, cs        ; the string is in 'cs', see above
    mov   es, ax
    mov   di, codeoffset szWin16Dir
    call  get_env_var_ptr
    or    di, di                         ;does win16dir exist?
    jz    gw_not
    add   sp, 4                          ;throw away systemroot
    jmp   short gw_cont

gw_not:
    pop   di
    pop   cx

gw_cont:
    ; Now ds:di points to the Windows directory string in
    ; the environment block.  It may be a long pathname,
    ; so fix it up.
    smov  es, ds
    SetKernelDS
    mov   si, dataoffset achWindowsDir
    regptr esdi,es,di
    regptr dssi,ds,si
    mov   cx, WINDIR_BUFSIZE
    cCall GetShortPathName, <esdi, dssi, cx>
    mov   cx, ax
    smov  ds, es
    assumes ds,nothing

    pop es
    ret

cEnd nogen

cProc   get_env_var_ptr,<PUBLIC,NEAR>
cBegin nogen
    cld
    push si
    xor si,si

    push di
    mov  cx,-1
    xor  ax,ax
    repnz scasb
    not  cx
    dec  cx            ; length of szSystemRoot
    pop  di

gw_cmp:
    mov  al, [si]
    or   al, al
    jz   gw_exit

    push di
    push cx
    repz cmpsb         ; compare the inputstring with szSystemRoot
    pop  cx
    pop  di

    jnz  gw_next       ; not szSystemRoot
    xor  cx,cx         ; yes szSystemRoot, cx=0 indicates so
    mov  di,si

gw_next:
    lodsb
    or al,al
    jnz gw_next        ; skip to the terminating NULL.
    or  cx,cx          ; cx==0 implies... found szSystemRoot
    jnz gw_cmp         ; compare with the next environment string
    mov cx,si          ; here if found szSystemRoot.
    sub cx,di
    mov ax,di
    dec cx


gw_exit:
    mov di,ax
    pop si
    ret
cEnd nogen


;-----------------------------------------------------------------------;
; original get_windir is within the 'else' 'endif' block
;
;-----------------------------------------------------------------------;

else

cProc   get_windir,<PUBLIC,NEAR>
cBegin nogen
    cld
    push    si
    xor di,di
    xor si,si
gw: lodsw
    or  al,al           ; no more enviroment
    jz  gw_exit
    cmp ax,'iw'         ; Look for windir=
    jne @F
    lodsw
    cmp ax,'dn'
    jne @F
    lodsw
    cmp ax,'ri'
    jne @F
    lodsb
    cmp al,'='
    je  gw_got_it
@@: lodsb
    or  al,al
    jnz @B
    jmp gw
gw_got_it:
    mov di,si
@@: lodsb
    or  al,al
    jnz @B
    mov cx,si
    sub cx,di
    dec cx
gw_exit:
    pop si
    ret
cEnd nogen

endif


sEnd    INITCODE

;------------------------------------------------------------------------

sBegin  STACK

; Boot TDB

boottdb     equ this byte
    DB  SIZE TDB dup (0)

; do a clumsy paragraph alignment

    rept    16
if  ($ - boottdb) and 0Fh
    db  0
endif
    endm

; Dummy arena entry so boot SS looks like a valid object

    DB  'M'
    DW  -1
    DW  (BOOTSTACKSIZE + 31)/16
    DB  0
    DW  5 DUP (0)

; Another in case we have to tweek the low order bit of SS

    DB  'M'
    DW  -1
    DW  (BOOTSTACKSIZE + 15)/16
    DB  0
    DW  5 DUP (0)

; Boot stack

stackbottom equ this word
    DB  BOOTSTACKSIZE DUP (0)
stacktop    equ this word

    DW  -1

sEnd    STACK

end BootStrap
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\ld.asm ===
.xlist
include kernel.inc
include newexe.inc
include tdb.inc
include pdb.inc
include protect.inc
.list

NEWEPME = NEPRIVLIB                     ; flag saying Call WEP on exit

externW pLocalHeap
externW pStackTop

DataBegin

externB num_tasks
externB graphics
externB fBooting
externB Kernel_flags
externD Dos_Flag_Addr
externB WOAName
externW fLMdepth
externW headPDB
externW curTDB
externW loadTDB
externW Win_PDB
externW topPDB
externW hExeHead
;externW EMS_calc_swap_line
externW WinFlags
externW hGDI
externW hUser
ifdef WOW
externW OFContinueSearch
endif
externD pMBoxProc
externD pGetFreeSystemResources
externD dressed_for_success
externD lpGPChain

;** Diagnostic mode stuff
externW fDiagMode
externB szLoadStart
externB szCRLF
externB szLoadSuccess
externB szLoadFail
externB szFailCode
externB szCodeString

; Look for module in Module Compatibilty section of win.ini
szModuleCompatibility   DB  'ModuleCompatibility',0
DataEnd

externFP Yield
externFP CreateTask
externFP GlobalAlloc
externFP GlobalSize
externFP GlobalLock
externFP GlobalUnlock
externFP GlobalFree
externFP LocalAlloc
externFP LocalFree
externFP LocalCountFree
externFP LoadModule
externFP lstrlen
externFP _lclose
externFP FreeModule
externFP GetModuleHandle
externFP LoadExeHeader
externFP GetExePtr
externFP GetProcAddress
externFP MyOpenFile
externFP FarGetCachedFileHandle
externFP FarEntProcAddress
externFP FlushCachedFileHandle
externFP FarMyLock
externFP FarMyFree
externFP FarMyUpper
externFP FarLoadSegment
externFP FarDeleteTask
externFP FarUnlinkObject
externFP Far_genter
externFP AllocSelector
externFP FreeSelector
externFP LongPtrAdd
externFP GetProfileInt

ifdef WOW
externFP StartWOWTask
externFP WowIsKnownDLL
externFP LongPtrAddWOW
externFP AllocSelectorWOW
externFP WOWLoadModule
externFP WowShutdownTimer
externB  fShutdownTimerStarted
externB  fExitOnLastApp
externFP WowSyncTask
endif

ifdef FE_SB
externFP FarMyIsDBCSLeadByte
endif

externFP FreeTDB

;** Diagnostic mode
externFP DiagOutput

sBegin  CODE
assumes CS,CODE
assumes DS,NOTHING
assumes ES,NOTHING

sEnd    CODE

sBegin  NRESCODE
assumes CS,NRESCODE
assumes DS,NOTHING
assumes ES,NOTHING

externB szProtectCap
externB msgRealModeApp1
externB msgRealModeApp2

externNP MapDStoDATA
externNP FindExeFile
externNP FindExeInfo
externNP AddModule
externNP DelModule
externNP GetInstance
externNP IncExeUsage
externNP DecExeUsage
externNP AllocAllSegs
externNP PreloadResources
externNP StartProcAddress
externNP StartLibrary
externNP GetStackPtr
externNP StartTask

IFNDEF NO_APPLOADER
externNP BootAppl
ENDIF ;!NO_APPLOADER

DOS_FLAG_EXEC_OPEN      equ     1

SET_DOS_FLAG_EXEC_OPEN macro
        push    es
        push    bx
        mov     es, Dos_Flag_Addr.sel
        mov     bx, Dos_Flag_Addr.off
        or      BYTE PTR es:[bx], DOS_FLAG_EXEC_OPEN
        pop     bx
        pop     es
endm

RESET_DOS_FLAG_EXEC_OPEN macro
        push    es
        push    bx
        mov     es, Dos_Flag_Addr.sel
        mov     bx, Dos_Flag_Addr.off
        and     BYTE PTR es:[bx], NOT DOS_FLAG_EXEC_OPEN
        pop     bx
        pop     es
endm

;-----------------------------------------------------------------------;
; OpenApplEnv                                                           ;
;       Calls CreateTask                                                ;
;       Allocates temporary stack                                       ;
; Arguments:                                                            ;
;                                                                       ;
; Returns:                                                              ;
;       ax = selector of load-time stack                                ;
; Error Returns:                                                        ;
;       ax = 0                                                          ;
; Registers Preserved:                                                  ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;                                                                       ;
; Calls:                                                                ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Tue 16-Jan-1990 21:13:51  -by-  David N. Weise  [davidw]             ;
; Ya know, it seems to me that most of the below ain't necessary        ;
; for small frame EMS.  But it's too late to change it now.             ;
;                                                                       ;
;  Fri 07-Apr-1989 23:15:42  -by-  David N. Weise  [davidw]             ;
; Added support for task ExeHeaders above The Line in Large             ;
; Frame EMS.                                                            ;
;                                                                       ;
;  Tue Oct 20, 1987 07:48:51p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.                                       ;
;-----------------------------------------------------------------------;

LOADSTACKSIZE = 2048

        assumes ds,nothing
        assumes es,nothing

cProc   OpenApplEnv,<PUBLIC,NEAR>,<ds,si,di>
        parmD   lpPBlock
        parmW   pExe
        parmW   fWOA
;       localW  myCodeDS
;       localW  myCurTDB
;       localW  myLoadTDB
cBegin
        ReSetKernelDS                   ; Assume DS:KRNLDS

        cCall   CreateTask,<lpPBlock,pExe,fWOA>
        or      ax,ax
        jz      oae_done

        test    kernel_flags,KF_pUID    ; All done booting?
        jz      oae_done

        xor     ax,ax
        mov     bx,LOADSTACKSIZE
        mov     cx,(GA_ALLOC_LOW or GA_SHAREABLE) shl 8 or GA_ZEROINIT or GA_MOVEABLE
        cCall   GlobalAlloc,<cx,ax,bx>
        or      ax,ax
        jz      oae_done
        cCall   GlobalLock,<ax>
        mov     ax,dx
        push    es                      ; added 13 feb 1990
        mov     es,loadTDB
        mov     es:[TDB_LibInitSeg],ax
        mov     es:[TDB_LibInitOff],10h
        mov     es,dx
        mov     es:[pStackTop],12h
        pop     es
oae_done:
cEnd


;-----------------------------------------------------------------------;
; CloseApplEnv                                                          ;
;                                                                       ;
;                                                                       ;
; Arguments:                                                            ;
;                                                                       ;
; Returns:                                                              ;
;       AX = hExe                                                       ;
;       BX = ?                                                          ;
;       DX = TDB                                                        ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;       ..., ES, ...                                                    ;
;                                                                       ;
; Calls:                                                                ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Fri 07-Apr-1989 23:15:42  -by-  David N. Weise  [davidw]             ;
; Added support for task ExeHeaders above The Line in Large             ;
; Frame EMS.                                                            ;
;                                                                       ;
;  Tue Oct 20, 1987 07:48:51p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.                                       ;
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   CloseApplEnv,<PUBLIC,NEAR>,<ds,si,di>
        parmW   hResult
        parmW   hExe
        localW  myCurTDB
        localW  cae_temp
        localW  myLoadTDB
cBegin

        ReSetKernelDS

; Copy DS variables to stack, since we may need DS
        mov     cx,curTDB
        mov     myCurTDB,cx
        mov     cx,loadTDB
        mov     myLoadTDB,cx
        mov     cae_temp, si

        mov     ax, myLoadTDB
        or      ax, ax                  ; Not set if LMCheckHeap failed
        jz      cae_done
        mov     ds, ax
        mov     ax, ds:[TDB_LibInitSeg]
        or      ax, ax
        jz      cae_free_stack1
        mov     ds, ax
        cmp     ds:[pStackTop], 12h
        jne     cae_free_stack1
        mov     ds,myLoadTDB
        push    ax
        cCall   GlobalUnlock,<ax>
        call    GlobalFree                      ; parameter pushed above
cae_free_stack1:
        mov     ds,myLoadTDB
        mov     ds:[TDB_LibInitSeg],ax
        mov     ds:[TDB_LibInitOff],10h

; Copy correct return address

cae_done:
        SetKernelDSNRES
        xor     dx,dx
        xchg    loadTDB,dx              ; Done loading this guy

        mov     ax,hResult              ; if hResult < 32, it's not a real
        cmp     ax,LME_MAXERR           ;  handle, and in fact is the invalid
        jb      cae_cleanup             ;  format return code. (11).

        mov     es,dx

; Start this guy up!  TDB_nEvents must be set here, and not before
; because message boxes may be put up if we can't find libraries,
; which would have caused this app to prematurely start.

        push    es
ifdef WOW
        cmp     num_tasks, 1            ; First task? (except wowexec)
        jne     @F                      ; branch if not first task
        cmp     fExitOnLastApp, 0       ; Shared WOW?
        jne     @F                      ; branch if not shared WOW
        cmp     fShutdownTimerStarted, 1; Is the timer running?
        jne     @F                      ; branch if not running
        cCall   WowShutdownTimer, <0>   ; stop shutdown timer
        mov     fShutdownTimerStarted, 0
@@:
endif
        mov     es:[TDB_nEvents],1
        inc     num_tasks               ; Do this here or get it wrong.

        test    es:[TDB_flags],TDBF_OS2APP
        jz      @F
        cmp     dressed_for_success.sel,0
        jz      @F
        call    dressed_for_success

ifdef WOW
        ; Start Up the New Task
@@:     cCall   StartWOWTask,<es,es:[TDB_taskSS],es:[TDB_taskSP]>
        or      ax,ax                   ; Success ?
        jnz     @f                      ; Yes

        mov     hResult,ax              ; No - Fake Out of Memory Error 0
                                        ;      No error matches failed to create thread
        pop     dx                      ; restore TDB
        dec     num_tasks               ;
        jmps    cae_cleanup             ;

endif; WOW

@@:     test    kernel_flags,KF_pUID    ; All done booting?
        jz      @F                      ; If booting then don't yield.
        cCall   WowSyncTask

@@:
        assumes ds,nothing
        pop     dx                      ; return TDB
        jmps    cae_exit

; Failure case - undo the damage
cae_cleanup:
        or      dx,dx                   ; Did we even get a TDB?
        jz      cae_exit                ; No.
        mov     ds,dx
        assumes ds,nothing
        mov     ds:[TDB_sig],ax         ; mark TDB as invalid
        cCall   FarDeleteTask,<ds>
        mov     es,ds:[TDB_PDB]
        mov     dx,PDB_Chain
        mov     bx,dataOffset HeadPDB   ; Kernel PDB
        cCall   FarUnlinkObject
        cCall   FreeTDB

cae_exit:
        xor     ax,ax
        mov     es,ax                   ; to avoid GP faults in pmode
.386
        mov     fs, ax
        mov     gs, ax
.286
        mov     ax,hResult
        mov     bx, cae_temp
cEnd


;-----------------------------------------------------------------------;
; StartModule                                                           ;
;                                                                       ;
;                                                                       ;
; Arguments:                                                            ;
;                                                                       ;
; Returns:                                                              ;
;       AX = hExe or StartLibrary                                       ;
;                                                                       ;
; Error Returns:                                                        ;
;       AX = 0                                                          ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       BX,DI,SI,DS                                                     ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;                                                                       ;
; Calls:                                                                ;
;       FarLoadSegment                                                  ;
;       StartProcAddress                                                ;
;       StartLibrary                                                    ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Tue Jan 01, 1980 03:04:49p  -by-  David N. Weise   [davidw]          ;
; ReWrote it from C into assembly and added this nifty comment block.   ;
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   StartModule,<PUBLIC,NEAR>,<di,si>
        parmW   hPrev
        parmD   lpPBlock
        parmW   hExe
        parmW   fh
        localD  pf
cBegin
        mov     ax,hExe
        mov     es,ax
        assumes es,nothing
        cmp     es:[ne_csip].sel,0
        jz      start_it_up

; Make sure DGROUP loaded before we need to load the start segment.

        mov     cx,es:[ne_autodata]
        jcxz    start_it_up             ; no automatic data segment
        cCall   FarLoadSegment,<es,cx,fh,fh>
        or      ax,ax
        jnz     start_it_up             ; auto DS loaded OK
        mov     ax,fh
        inc     ax
        jz      sm_ret1                 ; return NULL
        dec     ax
        cCall   _lclose,<ax>
        xor     ax,ax
sm_ret1:
        jmps    sm_ret                  ; return NULL

start_it_up:
        cCall   StartProcAddress,<hExe,fh> ; just because it's preloaded
        mov     pf.sel,dx                  ;  doesn't mean it's still around!
        mov     pf.off,ax
        or      dx,ax
        push    dx
        mov     ax,fh
        cmp     ax,-1
        jz      sm_nothing_to_close
        cCall   _lclose,<ax>
sm_nothing_to_close:
        pop     dx
        mov     es,hExe
        assumes es,nothing
        test    es:[ne_flags],NENOTP
        jnz     start_library
        or      dx,dx
        jz      nothing_to_start
        cCall   GetStackPtr,<es>
        cCall   StartTask,<hPrev,hExe,dx,ax,pf>
        jmps    sm_ret

start_library:
        mov     es, hExe
        or      es:[ne_flags], NEWEPME  ; Need to call my WEP on exit
        cCall   StartLibrary,<hExe,lpPBlock,pf>
        jmps    sm_ret

nothing_to_start:
        mov     ax,hExe
        test    es:[ne_flags],NENOTP
        jnz     sm_ret
        xor     ax,ax
sm_ret:
cEnd

if 0    ; too late to include in 3.1, add for next Windows release (donc)
cProc   GetProcAddressRes, <PUBLIC, FAR>, <ds, si, di>
parmW   hExe
parmD   pname   ; pass in Pascal string
cBegin
        les     di, [pname]             ; ES:DI = name to find

        mov     cx, 255                 ; CH = 0
        xor     ax, ax
        push    di
        repne   scasb
        pop     di
        jnz     GPAR_fail
        not     cl
        dec     cl
        mov     al, cl                  ; AX = length of name

        mov     ds, [hExe]              ; DS:SI = res name table
        mov     bx, ds:[ne_restab]      ; (actually DS:BX first time through)

GPAR_nextsym:
        mov     si, bx                  ; next entry to check
        mov     cl, [si]                ; string length
        jcxz    GPAR_fail
        lea     bx, [si+3]
        add     bx, cx                  ; BX points to next (last + len + 3)
        cmp     cx, ax
        jnz     GPAR_nextsym            ; length diff - no match
        inc     si                      ; skip length byte
        push    di
        rep     cmpsb
        pop     di
        jnz     GPAR_nextsym
        lodsw                           ; get ordinal number
;if     KDEBUG
;       cCall   FarEntProcAddress,<ds,ax,1>
;else
        cCall   FarEntProcAddress,<ds,ax>       ; I hate conditional assembly....
;endif
        mov     cx, ax
        or      cx, dx
        jmps    GPAR_exit

GPAR_fail:
        xor     ax, ax
        cwd
GPAR_exit:
cEnd
endif

;-----------------------------------------------------------------------;
; CallWEP                                                               ;
;                                                                       ;
; Call WEP of DLL if appropriate                                        ;
;                                                                       ;
; Arguments:                                                            ;
;       HANDLE hExe = HEXE of module about to close                     ;
;       WORD WEPVal = 0, 1 pass to WEP, 2 check for WEP                 ;
;                                                                       ;
; Returns:                                                              ;
;       AX = status                                                     ;
;                                                                       ;
; Error Returns:                                                        ;
;       AX =            Not a DLL                                       ;
;       AX =            No WEP                                          ;
;       AX =            Module not started                              ;
;-----------------------------------------------------------------------;

cProc   CallWEP, <PUBLIC,FAR>, <ds>
        parmW   hExe
        parmW   WEPVal
        localV  szExitProc,4
        localD  pExitProc
        localW  bogusIBMAppSp
cBegin
        mov     ds, hExe                ; Robustify this!

        CWErr = 1
        mov     ax, 1                   ; exit code
        cmp     ds:[ne_expver], 300h    ; 3.0 libraries only
        jb      CW_noWEP

        CWErr = CWErr+1
        inc     ax
        test    ds:[ne_flags], NENOTP   ; is it a DLL?
        jz      CW_noWEP

        CWErr = CWErr+1
        inc     ax                      ; Font, etc
        cmp     ds:[ne_cseg],0
        jz      CW_noWEP

        CWErr = CWErr+1
        inc     ax
        mov     bx, ds:[ne_pautodata]   ; Make sure auto data loaded
        or      bx, bx
        jz      @F
        test    ds:[bx].ns_flags, NSLOADED
        jz      CW_noWEP
@@:

        CWErr = CWErr+1
        inc     ax
        NoWepErr = CWErr
        mov     [szExitProc].lo, 'EW'   ; If the module has a procedure
        mov     [szExitProc].hi, 'P'    ; named 'WEP', call it.
        lea     bx, szExitProc
        push    ax
        cCall   GetProcAddress, <ds, ss, bx>
        mov     [pExitProc].off, ax
        mov     [pExitProc].sel, dx
        or      ax, dx
        pop     ax
        jnz     CW_WEP
CW_noWEP:
        jmps    CW_noWEP1

CW_WEP:
        cmp     WEPVAL,2                ; If I'm just looking for WEP
        jz      CW_OK                   ; return 0

        inc     ax
        test    ds:[ne_flags], NEWEPME  ; don't call wep if libmain
        jz      CW_noWEP                ; wasn't called

        and     ds:[ne_flags], NOT NEWEPME ; only call WEP once

        SetKernelDSNRES                 ; Save old GP chaine
        pusha
        push    lpGPChain.sel
        push    lpGPChain.off
        push    cs
        push    offset cw_BlowChunks
        mov     lpGPChain.sel, ss       ; and insert self in the chain
        mov     lpGPChain.off, sp
        UnSetKernelDS

        mov     ax, ss
        mov     ds, ax
        mov     es, ax
        mov     bogusIBMAppSP,sp        ; Save sp cause some apps (Hollywood)
                                        ; don't retf 2 correctly when we
                                        ; call their wep
        cCall   pExitProc, <WEPVal>     ; fSystemExit

        mov     sp,bogusIBMAppSp

        add     sp, 4                   ; remove the CS:IP for error handler
cw_BlowChunks:
        SetKernelDSNRES
        pop     lpGPChain.off   ; restore GPChain
        pop     lpGPChain.sel
        popa
        UnSetKernelDS
CW_OK:
        xor     ax, ax

CW_noWEP1:
        cmp     WEPVAL, 2               ; if we checked for whining
        jnz     CW_done
        or      ax, ax                  ; if we found, then OK
        jz      CW_done
        cmp     ax, NoWepErr            ; anything other than NoWep is OK
        jz      CW_done
        xor     ax, ax

CW_done:
cEnd


;-----------------------------------------------------------------------;
; LoadModule                                                            ;
;                                                                       ;
; Loads a module or creates a new instance of an existing module.       ;
;                                                                       ;
; Arguments:                                                            ;
;       FARP p   = name of module or handle of existing module          ;
;       FARP lpPBlock = Parameter Block to pass to CreateTask           ;
;                                                                       ;
; Returns:                                                              ;
;       AX = instance handle or module handle                           ;
;                                                                       ;
; Error Returns:                                                        ;
;LME_MEM        = 0     ; Out of memory                                 ;
;LME_FNF        = 2     ; File not found
;LME_LINKTASK   = 5     ; can't link to task                            ;
;LME_LIBMDS     = 6     ; lib can't have multiple data segments         ;
;LME_VERS       = 10    ; Wrong windows version                         ;
;LME_INVEXE     = 11    ; Invalid exe                                   ;
;LME_OS2        = 12    ; OS/2 app                                      ;
;LME_DOS4       = 13    ; DOS 4 app                                     ;
;LME_EXETYPE    = 14    ; unknown exe type                              ;
;LME_RMODE      = 15    ; not a pmode windows app                       ;
;LME_APPMDS     = 16    ; multiple data segments in app                 ;
;LME_EMS        = 17    ; scum app in l-frame EMS                       ;
;LME_PMODE      = 18    ; not an rmode windows app                      ;
;LME_INVCOMP    = 20    ; invalid DLL caused fail of EXE load           ;
;LME_PE32       = 21    ; Windows Portable EXE app - let them load it   ;
;LME_MAXERR     = 32    ; for comparisons                               ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       DI, SI, DS                                                      ;
; Registers Destroyed:                                                  ;
;       BX, CX, DX, ES                                                  ;
;                                                                       ;
; Calls:                                                                ;
;       AllocAllSegs                                                    ;
;       CreateInsider                                                   ;
;       DecExeUsage                                                     ;
;       DelModule                                                       ;
;       FindExeFile                                                     ;
;       FindExeInfo                                                     ;
;       FreeModule                                                      ;
;       GetExePtr                                                       ;
;       GetInstance                                                     ;
;       GetStringPtr                                                    ;
;       IncExeUsage                                                     ;
;       LoadExeHeader                                                   ;
;       LoadModule                                                      ;
;       FarLoadSegment                                                  ;
;       lstrlen                                                         ;
;       FarMyFree                                                       ;
;       MyOpenFile                                                      ;
;       PreloadResources                                                ;
;       StartModule                                                     ;
;       _lclose                                                         ;
;                                                                       ;
; History:                                                              ;
;  Sun 12-Nov-1989 14:19:04  -by-  David N. Weise  [davidw]             ;
; Added the check for win87em.                                          ;
;                                                                       ;
;  Fri 07-Apr-1989 23:15:42  -by-  David N. Weise  [davidw]             ;
; Added support for task ExeHeaders above The Line in Large             ;
; Frame EMS.                                                            ;
;                                                                       ;
;  Tue Oct 13, 1987 05:00:00p  -by-  David J. Habib [davidhab]          ;
; Added check for FAPI applications.                                    ;
;                                                                       ;
;  Sat Jul 18, 1987 12:04:15p  -by-  David N. Weise   [davidw]          ;
; Added support for multiple instances in different EMS banks.          ;
;                                                                       ;
;  Tue Jan 01, 1980 06:57:01p  -by-  David N. Weise   [davidw]          ;
; ReWrote it from C into assembly.                                      ;
;                                                                       ;
;  Wed Sep 17, 1986 03:31:06p  -by-  Charles Whitmer  [chuckwh]         ;
; Modified the original LoadModule code to only allow INSIDERs to       ;
; allocate segments for a new process.  An INSIDER is a new process     ;
; stub which bootstraps up a new instance of an application.            ;
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   ILoadLibrary,<PUBLIC,FAR>
        parmD   pLibName
        localV  szExitProc,4
cBegin
        mov     ax,-1
        cCall   <far ptr LoadModule>,<pLibName,ax,ax>
        cmp     ax, LME_INVEXE          ; Invalid format?
        jnz     @F
        mov     ax, LME_INVCOMP         ; Invalid component
@@:
if KDEBUG
        SetKernelDSNRes
        cmp     fBooting, 0
        jne     ll_fail                 ; No check while booting
        cmp     ax, LME_MAXERR
        jb      ll_fail                 ; No library, so no WEP()

        push    ax                      ; Now check for WEP
        cCall   GetExePtr,<ax>
        mov     es, ax
        test    es:[ne_flags],NEPROT    ; ignore for OS/2 apps
        jnz     ll_noWhine
        cmp     es:[ne_usage], 0
        jne     ll_noWhine              ; Only check on first load!
        push    dx
        push    ax
        cCall   CallWEP,<ax,2>          ; Just check for WEP, don't call it
        or      ax, ax
        pop     ax
        pop     dx
        jz      ll_noWhine
        trace_out "No WEP in library - > %AX0 %AX1"
;       fkerror 0,<No WEP in library - >,ax,dx
ll_noWhine:
        pop     ax                      ; return value of LoadModule

ll_fail:
endif   ; KDEBUG
cEnd



os2calls DB 'DOSCALLS'          ; Used for FAPI detection
mgxlib   DB 'MGXLIB'            ; Used for lib large entry table detection
win87em  DB 'WIN87EM.DLL',0     ; Used for win87em.exe detection

        assumes ds,nothing
        assumes es,nothing

?SAV5   =       ?DOS5           ; Adobe Type Manager check the LoadModule
?DOS5   =       0               ;   prolog and expects to see INC BP there...

public  LMAlreadyLoaded, LMLoadExeFile, LMCheckHeader, LMRamNMods
public  LMImports, LMSegs, LMLetsGo, LMPrevInstance, LMCleanUp

cProc   ILoadModule,<PUBLIC,FAR>,<di,si>
        parmD   lpModuleName
        parmD   lpPBlock
        localW  fh                      ; close if failed
        localW  pExe                    ; point to NE header in RAM
;       localW  hExe                    ; prev module if already loaded
        localW  hResult                 ; temp return value
        localW  hDepFail                ; return of implicit link loads
        localW  abortresult             ; temp return value
        localW  ffont                   ; flag if loading a *.fon
        localW  fexe                    ; flag if loading a *.exe
ifdef notyet
        localW  dll                     ; flag if loading a *.dll
endif
        localW  hBlock                  ; fastload block from LoadExeHeader
        localW  AllocAllSegsRet
        localW  exe_type                ; from LoadExeHeader
        localW  hTDB                    ; dx from CloseApplEnv
        localW  SavePDB                 ; save caller's pdb, switch to krnl's
        localW  fWOA                    ; save flag if we're loading WOA
ifdef WOW
        LocalD  pszKnownDLLPath
        LocalW  fKnownDLLOverride
        localW  RefSelector
        localW  LMHadPEDLL
        localW  hPrevInstance           ; previous 16-bit module handel with the same name
endif
        localD  FileOffset              ; offset to start of ExeHdr
        localW  OnHardDisk              ; don't cache FH if on floppy
        localV  namebuf,136             ; SIZE OPENSTRUC + 127
    localW  fModCompatFlags     ; used by LMRamNMods


cBegin
        SetKernelDSNRES

        mov     al,Kernel_Flags[1]      ; solve re-entrancy #10759
        and     ax,KF1_WINOLDAP
        mov     fWOA,ax
        and     Kernel_Flags[1],NOT KF1_WINOLDAP

        inc     fLMdepth                ; # current invocations

        ;** Log this entry only if in diagnostic mode
        mov     ax, fDiagMode           ; Only log if booting and diag mode
        and al, fBooting
        jz  @F

        ;** Write out the string
        mov     ax,dataOFFSET szLoadStart ; Write the string
        cCall   DiagOutput, <ds,ax>
        push    WORD PTR lpModuleName[2]
        push    WORD PTR lpModuleName[0]
        cCall   DiagOutput
        mov     ax,dataOFFSET szCRLF
        cCall   DiagOutput, <ds,ax>

; Zero out flags and handles
@@:
ifdef WOW
        mov     LMHadPEDLL,0
        mov     hPrevInstance,0
lm_restart:
endif
        xor     ax,ax
;       mov     hExe,ax
        mov     pExe,ax
        mov     abortresult,ax          ; default 0 == out of memory
        mov     ffont,ax
        mov     fexe,ax
ifdef notyet
        mov     dll,ax
endif
        mov     hBlock,ax
        mov     hTDB,ax

; Set DOS_FLAG to EXEC_OPEN
        SET_DOS_FLAG_EXEC_OPEN

; Some flags are default -1
        dec     ax
        mov     fh, ax
        mov     SavePDB, ax

; First, see if we were passed in a handle in the filename
        les     si,lpModuleName         ; point to the file name
        mov     ax,es
        or      ax,ax                   ; Was a  handle passed in low word?
        jnz     @F
        cCall   GetExePtr,<si>          ; Valid handle?
        or      ax, ax
        jnz     prev_instance
        mov     al, LME_FNF             ; call this file not found??
        jmp     ilm_ret

; No handle, see if filename is already loaded
@@:     call    LMAlreadyLoaded         ; es:si -> modname on stack
        cmp     ax, LME_MAXERR
        jb      @F                      ; Not found, try to load it

; a 16-bit module with the same name is loaded
; if module is being loaded is a dll, use the loaded instance
; else if module is being loaded is a task
;         if it is a 32-bit task then load it from disk
;         else use the loaded instance


ifdef WOW
        mov     hPrevInstance, ax       ; store previous instance handle
        mov     ax,lpPBlock.off         ; check if this is a dll or a task
        and     ax,lpPBlock.sel
        inc     ax
        jnz     @F                      ; non-zero means it is a task
                                        ; so check first if it is a 16-bit task
prev_instance_16task:
        mov     ax, hPrevInstance
endif
prev_instance:
        call    LMPrevInstance
        jmp     ilm_ret

; Wasn't loaded, see if we can load it
@@:     call    LMLoadExeFile           ; fh in DI, AX = 0 or error code
        or      ax, ax
        jz      @F
        jmp     ilm_ret                 ; can't find it - return error
@@:

; Here to deal with a new library or task module.
; We found the file, now load and scan the header
@@:     lea     si,namebuf
        cCall   LoadExeHeader,<di,di,ss,si>
ifdef WOW
        cmp     ax,LME_PE
        jne     @F
; If we find the module is a Win32 binary (PE), check to see
; if we're trying to load a task or DLL.  If it's a DLL
; we will continue searching for a Win16 copy of this DLL
; on the path.  If we're unsuccessful we'll eventually
; munge the file not found error code back to LME_PE.

        mov     ax,lpPBlock.off
        and     ax,lpPBlock.sel
        inc     ax
        mov     ax,LME_PE
        jnz     @F  ; have a PBlock, must be doing LoadModule
        cmp     LMHadPEDLL,0
        je      lm_retry_pe
        mov     LMHadPEDLL,0
        mov     OFContinueSearch,0
        KernelLogError  <DBF_WARNING>,ERR_LOADMODULE,"Found Win32 DLL again after continuing search."
        jmps    ilm_ret
@@:     jmps    @F
lm_retry_pe:
; Tell OpenFile to restart last search at next search location.
        mov     OFContinueSearch,1
        mov     LMHadPEDLL,1
        KernelLogError  <DBF_WARNING>,ERR_LOADMODULE,"Found Win32 DLL, continuing search for Win16 copy."
; Close open Win32 DLL file handle
        cCall   My_lclose,<fh>
; Switch back to caller's PDB
        mov     si, -1
        xchg    si, SavePDB
        mov     Win_PDB, si
        or      fh, -1
        jmp     lm_restart
@@:
endif
        cmp     ax,LME_MAXERR
        jb      ilm_ret

ifdef WOW
        cmp     hPrevInstance, 0    ; if there is a previous 16-bit task
        je      @F                  ;
        cCall   My_lclose,<fh>      ; close opened file before invoking previous instance
        jmp     prev_instance_16task
endif
; Header is loaded, now see if valid for Windows
@@:     call    LMCheckHeader
        cmp     ax, LME_MAXERR
        jb      ilm_ret

; Now allocate segs, check for special modules, etc
@@:     call    LMRamNMods
        cmp     ax, LME_MAXERR
        jb      ilm_ret

; Load import libraries (scary code here)
@@:     call    LMImports
        cmp     ax, LME_MAXERR
        jb      ilm_ret

; Load and relocate segments
@@:     call    LMSegs
        cmp     ax, LME_MAXERR
        jb      ilm_ret

; Load resources, schedule execution
@@:     call    LMLetsGo

; Everyone comes through ILM_RET - we free the fastload block, etc
ilm_ret:
        call    LMCleanUp
        jmp     LoadModuleEnd


abort_load0:
        pop     fLMdepth
abort_load:
        cmp     fLMdepth, 1             ; If a recursive call, nothing
        jne     abort_load_A            ; has been incremented!
        cCall   DecExeUsage,<pExe>
abort_load_A:
        cCall   My_lclose,<fh>
        mov     es,pExe
        push    es:[ne_flags]
        cCall   DelModule,<es>
        mov     pExe, 0
        pop     bx
abort_load_B:                           ; If app, close environment
        test    bx,NENOTP
        jnz     lm_ab
        mov     si, -1
        xchg    si, SavePDB             ; Saved PDB?
        inc     si
        jz      @F                      ;  nope.
        dec     si
        mov     Win_PDB, si             ;  yes, restore it
@@:
        mov     si, fLMdepth
        mov     fLMdepth, 0
        cCall   CloseApplEnv,<abortresult,es>
        mov     fLMdepth, bx
lm_ab:  mov     ax, abortresult
        retn
;       add     sp, 2
;       jmps    ilm_ret                 ; ax = abortresult. (0 normal, 11 fapi)


ifdef WOW
winspool db     "WINSPOOL.EXE"              ; Trying to Load Winspool ?
size_winspool equ $-winspool
        db      0h                          ; NULL Terminate

endif ;WOW

;----------------------------------------------------------------------
;
;       LMAlreadyLoaded - internal routine for LoadModule
;       See if a module is already loaded by looking for the file name
;       or the module name.
;  Entry:
;       ES:SI points to filename
;  Exit:
;       AX = handle of previous instance
;       SS:SI -> uppercase filename
;  Error:
;       AX = error value < LME_MAXERR
;
;-----------------------------------------------------------------------
LMAlreadyLoaded:
; We check if this Module is already loaded.  To do so we get the
;  name off of the end of the string, omitting the extension.

        krDebugOut <DEB_TRACE OR DEB_KrLoadMod>, "Loading @ES:SI"
        cCall   lstrlen,<es,si>         ; Get the length of the string.
        or      ax,ax                   ; NULL string?
        jnz     @F
        mov     al,LME_FNF              ; return file not found error
        retn

ifdef FE_SB
;
; Backword search '\' or ':' is prohibited for DBCS version of
; Windows. Some DBCS 2nd byte may have '\' or ':'. So we search
; these characters from beginning of string.
;
@@:
        cld
        mov     bx,si
delinator_loop_DBC:
        lods    byte ptr es:[si]        ; fetch a character
        test    al,al
        jz      found_end_DBC
        cmp     al,"\"
        jz      found_delinator_DBC
        cmp     al,'/'
        jz      found_delinator_DBC
        cmp     al,":"
        jz      found_delinator_DBC
        call    FarMyIsDBCSLeadByte     ; see if char is DBC...
        jc      delinator_loop_DBC
        inc     si                      ; skip 2nd byte of DBC
        jmp     delinator_loop_DBC

found_delinator_DBC:
        mov     bx,si                   ; update delinator pointer
        jmp     delinator_loop_DBC
found_end_DBC:
        mov     si, bx                  ; ES:SI -> beginning of name..
else
@@:     mov     cx,ax
        add     si,ax
        dec     si                      ; ES:SI -> end of string
        std
delineator_loop:                        ; look for beginning of name
        lods    byte ptr es:[si]
        cmp     al,"\"
        jz      found_delineator
        cmp     al,'/'
        jz      found_delineator
        cmp     al,":"
        jz      found_delineator
        loop    delineator_loop
        dec     si
found_delineator:                       ; ES:SI -> before name
        cld
        inc     si
        inc     si                      ; ES:SI -> beginning of name
endif
        xor     di,di
        xor     bx,bx
copy_name_loop:
        lods    byte ptr es:[si]        ; Copy and capitalize to temp buffer.
        or      al,al
        jz      got_EXE_name
        cmp     al,"."
        jne     @F
        lea     bx,namebuf[di]
ifdef notyet
        cmp     dll, 0                  ; Was it .DLL and failed to open it?
        jz      @F                      ;  no, no hacking
        mov     byte ptr es:[si], 'E'   ;  yes, change it to .EXE
        mov     word ptr es:[si+1],'EX'
        mov     dll, 0
endif
@@:
ifdef   FE_SB
;
; Do not capitalize if a character is DBC.
;
        call    FarMyIsDBCSLeadByte
        jnc     @F
        call    FarMyUpper              ; capitalize if SBC..
        jmps    is_a_SBC
@@:
        mov     namebuf[di],al
        inc     di
        lods    byte ptr es:[si]        ; copy 2nd byte also
is_a_SBC:
        mov     namebuf[di],al
else
        call    FarMyUpper
        mov     namebuf[di],al
endif
        inc     di
        jmps    copy_name_loop

; Finally call FindExeInfo to see if it's already loaded!

got_EXE_name:
        cmp     namebuf[di][-2],'NO'    ; .fons are allowed to be
        jnz     @F                      ; non protect mode
        cmp     namebuf[di][-4],'F.'
        jnz     @F
        mov     ffont,bp                ; make non-zero
@@:
        cmp     namebuf[di][-2],'EX'    ; .exes will not get
        jnz     @F                      ;  prompted
        cmp     namebuf[di][-4],'E.'
        jnz     @F
        mov     fexe,bp                 ; make non-zero
@@:
ifdef   NOTYET
        cmp     namebuf[di][-2],'LL'
        jne     @F
        cmp     namebuf[di][-4],'D.'
        jne     @F
        mov     dll, di
@@:
endif
ifdef WOW

; apps will expect to find WINSPOOL.DRV, which is a 32-bit driver.
; we need to intercept this and change it WINSPOOL.EXE, which is our 16-bit
; stub that contains a few entrypoints.

if 0
        ; Bitstreams's MakeUp extracts the printer driver from the [devices]
        ; section of win.ini    the line looks like this:
        ;    HP Laserjet Series II=winspool,FILE:
        ; and then it calls LoadLibrary(drivername)  ie LoadLibrary("winspool")
        ; so we need to allow no extension when checking for "winspool"
endif

        cmp     namebuf[di][-2],'VR'
        jne     checkfornoext
        cmp     namebuf[di][-4],'D.'
        jne     @f

        jmp     short gotadrv

checkfornoext:
   ;     int     3
        cmp     di,8
        jc      @f
        cmp     namebuf[di][-2],'LO'
        jne     @f
        cmp     namebuf[di][-4],'OP'
        jne     @f
        cmp     namebuf[di][-6],'SN'
        jne     @f
        cmp     namebuf[di][-8],'IW'
        jne     @f

        ; the last 8 characters are 'WINSPOOL'.  tack on '.EXE' and proceed.

        add     di,4
        mov     namebuf[di][-2],'EX'    ; Changed Uppercased String
        mov     namebuf[di][-4],'E.'

        push    cx
        mov     lpModuleName.hi,cs
        lea     cx,winspool             ;
        mov     lpModuleName.lo,cx
        pop     cx
        jmp     short @f

gotadrv:
        push    es
        push    ds
        push    si
        push    cx
        push    di

        smov    es,ss
        lea     di,namebuf[di][-(size_winspool)]
        smov    ds,cs
        lea     si,winspool
        mov     cx,size_winspool-4      ; match WINSPOOL?
        rep     cmpsb

        pop     di
        jnz     not_winspool

        mov     namebuf[di][-2],'EX'    ; Changed Uppercased String
        mov     namebuf[di][-4],'E.'

        mov     lpModuleName.hi,cs      ; Used by Myopenfile below
        lea     cx,winspool             ;
        mov     lpModuleName.lo,cx

not_winspool:
        pop     cx
        pop     si
        pop     ds
        pop     es
@@:
endif; WOW
        mov     namebuf[di],al          ; Null terminate file name
        lea     si,namebuf
        push    bx
        cCall   FindExeFile,<ss,si>
        pop     bx
        or      ax,ax
        jnz     al_end
        or      bx,bx                   ; extension specified?
        jz      @F                      ; No, DI correct then
        sub     bx,si                   ; DI = length of name portion
        mov     di,bx
@@:
        cCall   FindExeInfo,<ss,si,di>
al_end:
        retn

;----------------------------------------------------------------------
;
;       LMLoadExeFile - internal routine for LoadModule
;       Try to open an EXE file
;  Enter:
;       SS:SI -> uppercase filename
;  Exit:
;       AX=0
;       DI = fh = handle of open EXE file
;  Error:
;       AX = error code
;  Effects:
;       Set Win_PDB to kernel PDB to open the file
;
;-----------------------------------------------------------------------
; if here then not yet loaded, see if we can open the file
LMLoadExeFile:
        mov     ax, topPDB
        xchg    Win_PDB, ax             ; Switch to Kernel's PDB,
        mov     SavePDB, ax             ; saving current PDB
        xor     ax,ax
ifdef notyet
        cmp     dll, ax                 ; Don't prompt for .DLL, if it fails we
        jnz     @F                      ; try for .EXE which we will prompt for
endif
        cmp     fexe,ax                 ; Don't prompt for EXE file
        jnz     @F
        mov     ax,OF_CANCEL            ; If DLL, let them cancel
        mov     es,curTDB
        test    es:[TDB_ErrMode],08000h ; did app say not to prompt??
        jnz     @F
        mov     ax,OF_CANCEL or OF_PROMPT
@@:
if SHARE_AWARE
        or      ax, OF_NO_INHERIT or OF_SHARE_DENY_WRITE
else
        or      ax, OF_NO_INHERIT
endif
ifdef WOW
        ; Ask WOW32 to check the filename to see if it is
        ; a Known DLL,
        ;
        ; If it is, WowIsKnownDLL will point pszKnownDLLPath
        ; at a just-allocated buffer with the full path to
        ; the DLL in the system32 directory and return with
        ; AX nonzero.  This buffer must be freed with a
        ; call to WowIsKnownDLL with the filename pointer
        ; zero, and pszKnownDLLPath as it was left by the
        ; first call to WowIsKnownDLL.
        ;
        ; If it's not a known DLL, pszKnownDLLPath will be
        ; NULL and AX will be zero.

        push    ax
        cmp     fBooting,0              ; Known DLLs take effect
        je      lef_look_for_known_dll  ; after booting is complete.

        mov     fKnownDLLOverride,0     ; We're booting, make sure
        jmps    lef_dll_not_known       ; we know not to call
                                        ; WowIsKnownDLL the second time.

lef_look_for_known_dll:
        push    si
        smov    es,ss
        lea     bx,pszKnownDLLPath
        cCall   WowIsKnownDLL,<lpModuleName,esbx>
        mov     fKnownDLLOverride,ax
        cmp     ax,0
        pop     si
        je      lef_dll_not_known

        pop     ax
        cCall   MyOpenFile,<pszKnownDLLPath,ss,si,ax>
        jmps    @f

lef_dll_not_known:
        pop     ax
        cCall   MyOpenFile,<lpModuleName,ss,si,ax>
@@:
else
        cCall   MyOpenFile,<lpModuleName,ss,si,ax>
endif

ifdef notyet
        mov     di, dll
        or      di, di
        jz      no_second_chance
        cmp     ax, -1
        jne     no_second_chance        ; open succeeded
        xchg    ax, SavePDB             ; Restore original PDB  (AX == -1)
        mov     Win_PDB, ax
        les     si, lpModuleName
        pop     ax
        jmp     pointer_to_name         ; Start again!
no_second_chance:
endif
        xor     dh, dh
        mov     dl, ss:[si].opDisk
        mov     OnHardDisk, dx
        mov     fh,ax
        mov     di,ax                   ; DI gets preserved, AX doesn't!
        inc     ax                      ; -1 means error or invalid parsed file
        mov     ax, 0
        jnz     @F                      ; OK, return 0
                                        ; MyOpenFile failed
        mov     ax,ss:[si].[opXtra]     ; SI = &namebuf
        or      ax,ax                   ; What is the error value?
        jnz     @F
        mov     ax,LME_FNF              ; unknown, call it file not found
@@:
ifdef WOW
        push    ax
        mov     ax,fKnownDLLOverride
        cmp     ax,0
        je      lef_no_need_to_free

        push    bx
        push    dx
        push    di

        smov    es,ss
        lea     bx,pszKnownDLLPath
        cCall   WowIsKnownDLL, <0,0,esbx>

        pop     di
        pop     dx
        pop     bx
lef_no_need_to_free:
        pop     ax
endif
        retn

;----------------------------------------------------------------------
;
;       LMCheckHeader - internal routine for LoadModule
;       Loading new module - see if header values are OK
;  Enter:
;       ax = exeheader in RAM
;       bx = 0 or FastLoad ram block selector
;       cx = file offset of header
;       dx = exe_type
;  Exit:
;
;
;-----------------------------------------------------------------------
LMCheckHeader:
        mov     exe_type,dx
        mov     hBlock,bx               ; fast-load block
        mov     pExe,ax                 ; exeheader in RAM
        mov     es,ax
        mov     ax, cx                  ; file offset of header
        mov     cx, es:[ne_align]
        mov     bx, ax                  ; BX:AX  <=  AX shl CL
        shl     ax, cl
        neg     cl
        add     cl, 16
        shr     bx, cl

        mov     FileOffset.sel, bx
        mov     FileOffset.off, ax

; Is this module PMode-compatible?
        cmp     es:[ne_expver],300h     ; by definition
        jae     @F
        test    dh,NEINPROT             ; by flag
        jnz     @F
        cmp     ffont,0                 ; are we loading a font?
        jnz     @F
        mov     cx,ss
        lea     bx,namebuf
        call    WarnRealMode
        cmp     ax,IDCANCEL
        jnz     @F                      ; yes, user says so
        mov     ax, LME_RMODE           ; no, die you pig
        retn

ifdef WOW
@@:
        ;
        ; if WOA invoked by app (not fWOA) fail it
        ;
        cmp     fWOA,0                  ; fWOA
        jnz     @F

        cld
        push    si
        push    di
        mov     di, es:[ne_restab]
        inc     di
        mov     si, dataOffset WOAName
        mov     cx, 4
        repe    cmpsw
        pop     di
        pop     si
        jnz     @F
        mov     ax, LME_WOAWOW32
        retn
endif

; Are we dynalinking to a task?
@@:


        test    es:[ne_flags],NENOTP
        jnz     ch_not_a_process
        or      es:[ne_flags],NEINST    ; for safety sake
        mov     ax,lpPBlock.off
        and     ax,lpPBlock.sel
        inc     ax
        jnz     ch_new_application      ; not linking
        mov     ax, LME_LINKTASK
        retn

; Error if multiple instance EXE is a library module.
ch_not_a_process:
        mov     ax, 33                  ; Any value > 32
        test    es:[ne_flags],NEPROT    ; is it an OS/2 exe?
        jnz     ch_ok                   ;  windows doesn't do this right
        test    es:[ne_flags],NEINST
        jz      ch_ok
        mov     ax, LME_LIBMDS          ; I think this error code is wrong
ch_ok:
        retn

; Create environment for new application task.
ch_new_application:
        call    LMCheckHeap
        or      ax,ax
        jz      @F
        cCall   OpenApplEnv,<lpPBlock,pExe,fWOA>
        mov     es,pExe
        or      ax,ax                   ; AX is a selector, therefor > 32
        jnz     ch_ok
@@:
        jmp     abort_load_A


;----------------------------------------------------------------------
;
;       LMRamNMods - internal routine for LoadModule
;       Load segments, check for special modules
;  Enter:
;       EX = pexe


;  Exit:
;       CX = number of import modules
;       AX = status
;
;
;-----------------------------------------------------------------------
LMRamNMods:
        push    es
        cCall   AddModule,<pExe>
        pop     es
        or      ax,ax
        jnz     @F
        push    es:[ne_flags]           ; AddModule failed - out of memory
        mov     dx,ne_pnextexe
        mov     bx,dataOffset hExeHead
        call    FarUnlinkObject
        pop     bx
        jmp     abort_load_B            ; clean this up

@@:
        cmp     es:[ne_expver],400h
        jae     rm_skip_modulecompat

    ; Look for Module in ModuleCompatibilty section
    ; and get its compat flags
    push    es          ; save es
    push    ds
    push    dataoffset szModuleCompatibility
    push    es
    mov bx,es:[ne_restab]   ; module name is 1st rsrc
    inc bx          ; Skip length byte
    push    bx
    xor ax, ax
    push    ax          ; default = 0
    call    GetProfileInt
@@:
    pop es          ; restore es
        ; Set the module's patch bit if the INI file says to.
if KDEBUG
        test    es:[ne_flagsothers], NEHASPATCH
        jz      @F
        push    ax
        mov     ax, es:[ne_restab]
        inc     ax
        krDebugOut  DEB_TRACE,"ILoadModule: module patch bit for @es:ax already set, clearing it"
        pop     ax
@@:
endif
        and     es:[ne_flagsothers], not NEHASPATCH     ; clear module patch bit
ifdef WOW_x86
        test    ax, MCF_MODPATCH + MCF_MODPATCH_X86
else
        test    ax, MCF_MODPATCH + MCF_MODPATCH_RISC
endif
        jz      rm_after_modpatch
if KDEBUG
        push    ax
        mov     ax, es:[ne_restab]
        inc     ax
        krDebugOut  DEB_WARN,"ILoadModule: setting module patch bit for @es:ax"
        pop     ax
endif
        or      es:[ne_flagsothers], NEHASPATCH
rm_after_modpatch:

        ; See if we need to make the module's segments not discardable
        test    ax, MCF_NODISCARD
        jz      rm_after_nodiscard

        mov     cx, es:[ne_cseg]                ; cx = number of segs
        jcxz    rm_after_nodiscard
        mov     bx, es:[ne_segtab]              ; es:bx = seg table start
rm_loop:
        and     es:[bx].ns_flags, not NSDISCARD ; clear the discard flag
        add     bx, SIZE NEW_SEG1               ; es:bx = seg table next entry
        loop    rm_loop
rm_after_nodiscard:

rm_skip_modulecompat:

    mov bx, -1
        cCall   FarGetCachedFileHandle,<es,bx,fh>       ; Set file handle cache up
        mov     fh, bx                  ; Use cached file handle from now
        xchg    SavePDB, bx             ; Back to original PDB (BX == -1)
        mov     Win_PDB, bx
@@:     xor     bx,bx
        mov     hDepFail,-1              ; Assume success
        mov     cx,es:[bx].ne_cmod
        jcxz    @F
        test    kernel_flags,KF_pUID    ; All done booting?
        jnz     @F                      ; Yes
        or      es:[bx].ne_flags,NEALLOCHIGH ; No, GDI and USER are party
                                             ; dynlinks that can alloc high
@@:     xor     ax,ax
IFNDEF NO_APPLOADER
        test    es:[ne_flags],NEAPPLOADER
        jnz     rm_no_segs_to_alloc
ENDIF
        cmp     ax,es:[ne_cseg]
        jz      rm_no_segs_to_alloc
        push    es
        mov     es:[ne_usage],1
        cCall   AllocAllSegs,<es>       ; AX is count of segs
        pop     es
        mov     es:[ne_usage],8000h
        inc     ax
        jnz     @F
        jmp     abort_load
@@:
        dec     ax
rm_no_segs_to_alloc:
        mov     AllocAllSegsRet, ax

        xor     bx, bx
        mov     di,es:[bx].ne_modtab     ; ES:DI = pModIdx
        mov     cx,es:[bx].ne_cmod
        or      cx,cx
        jz      lm_ret_ok

; this small chunk of code goes thru the imported names table
; and looks for DOSCALLS.  if DOSCALLS is found, then the app
; is an FAPI "bound" application and not a windows app, and
; loadmodule should return an error for "invalid format".
; This will force it to run in a DOS box
; coming in:
;   cx = cmod
;   di = modtab

        test    es:[bx].ne_flags,NENOTP ; only test apps, not libraries.
        jnz     lm_ret_ok
        mov     ax,exe_type             ; UNKNOWN may be OS/2 in disguise.
        cmp     al,NE_UNKNOWN
        jnz     @F
        push    ds
        smov    ds,cs
        mov     ax,8
        mov     si,NRESCODEoffset os2calls ; DS:SI = "DOSCALLS"
        call    search_mod_dep_list
        pop     ds
        jnc     @F
        mov     abortresult,LME_INVEXE  ; store invalid format code for return
        jmp     abort_load

; In order to make it easier on our ISV to migrate to pmode
;  we must deal with win87em specially because the win 2.x
;  version gp faults.  Since we have never shipped them a clean
;  one to ship with their apps we must compensate here.
; If we are loading a win 2.x app in pmode we force the load
;  of win87em.dll.  For compatibility in real mode we just load
;  the one they would have gotten anyway.

@@:     cmp     es:[bx].ne_expver,300h  ; no special casing win3.0 apps
        jae     rm_no_win87em_here

        push    ds
        smov    ds,cs
        mov     ax,7
        mov     si,NRESCODEoffset win87em ; DS:SI = "WIN87EM"
        call    search_mod_dep_list
        pop     ds
        jnc     rm_no_win87em_here
        push    bx                      ; Load Win87em.dll
        push    es
        cCall   ILoadLibrary,<cs,si>
        cmp     ax,LME_MAXERR
        jae     @F
        mov     hDepFail,ax
@@:     pop     es
        pop     bx
rm_no_win87em_here:
lm_ret_ok:
        mov     di,es:[bx].ne_modtab    ; ES:DI = pModIdx
        mov     cx,es:[bx].ne_cmod      ; What is AX?
        mov     ax, es
        retn

;----------------------------------------------------------------------
;
;       LMImports - internal routine for LoadModule
;
;-----------------------------------------------------------------------
LMImports:
        or      cx, cx
        jnz     im_inc_dependencies_loop
        jmp     im_end_dependency_loop
im_inc_dependencies_loop:
        push    cx
        mov     si,es:[di]
        push    es
        or      si,si
        jz      im_next_dependencyj
        add     si,es:[ne_imptab]       ; ES:SI = pname
        xor     ax,ax
        mov     al,es:[si]              ; get length of name
        inc     si
        mov     cx, ax
        mov     bx, es                  ; pExe

;;;; Load the imported library.

        push    ds                      ; Copy the name and .EXE to namebuf
        push    di
        smov    es,ss
        mov     ds,bx
        UnSetKernelDS
        lea     di,namebuf
        mov     bx,di
        cld
        rep     movsb
        mov     byte ptr es:[di], 0             ; Null terminate
        push    bx
        push    es
        cCall   GetModuleHandle,<es,bx>
        pop     es
        pop     bx
        or      ax, ax
        jz      @F
        pop     di
        pop     ds
        jmps    im_imported_exe_already_loaded

@@:     cmp     ds:[ne_expver], 300h    ; USE .DLL for 3.0, .EXE for lower
        jae     im_use_dll

        mov     es:[di][0],"E."
        mov     es:[di][2],"EX"
        jmps    im_done_extension
im_use_dll:
        mov     word ptr ss:[di][0],"D."
        mov     word ptr ss:[di][2],"LL"
im_done_extension:
        mov     byte ptr es:[di][4],0

        pop     di
        pop     ds
        ResetKernelDS
        cCall   ILoadLibrary,<ss,bx>
        cmp     ax,LME_MAXERR
        jae     im_imported_exe_loaded
        mov     hDepFail,ax
        xor     ax,ax
im_next_dependencyj:
        jmps    im_next_dependency

im_imported_exe_already_loaded:
;;;     push    ax
;;;     cCall   IncExeUsage,<ax>
;;;     pop     ax

im_imported_exe_loaded:
        cCall   GetExePtr,<ax>
        mov     es,ax
        assumes es,nothing                      ; assume that dep libraries
        or      es:[ne_flags],NEALLOCHIGH       ;  are smart

im_next_dependency:
        pop     es
        assumes es,nothing
        mov     es:[di],ax
        inc     di
        inc     di
        pop     cx
        dec     cx
        jz      im_end_dependency_loop
        jmp     im_inc_dependencies_loop

im_end_dependency_loop:
        mov     es:[ne_usage], 0
        cmp     fLMdepth, 1
        jne     @F
        push    es                              ; Now set usage count of this
        cCall   IncExeUsage,<es>                ; module and dependants
        pop     es
@@:
        mov     cx,hDepFail
        inc     cx
        jz      im_libs_ok
        dec     cx
        mov     abortresult,cx
im_abort_loadj:
        jmp     abort_load
im_libs_ok:
        retn

;----------------------------------------------------------------------
;
;       LMSegs - internal routine for LoadModule
;
;-----------------------------------------------------------------------
LMSegs:
; Do something about all those segments in the module.

IFNDEF NO_APPLOADER
        test    es:[ne_flags],NEAPPLOADER
        jz      @F
;*      * special boot for AppLoader
        push    Win_PDB
        push    fLMdepth
        mov     fLMdepth, 0
        mov     ax, -1
        cCall   FarGetCachedFileHandle,<es,ax,ax>
        Save    <es>
        cCall   BootAppl,<es, ax>       ;* returns BOOL
        cCall   FlushCachedFileHandle,<es>
        pop     fLMdepth
        pop     Win_PDB
        or      ax,ax
        jnz     lms_done
        jmp     abort_load
;       retn
@@:
ENDIF ;!NO_APPLOADER

        mov     cx, AllocAllSegsRet
        jcxz    lms_done

lms_preload_segments:

        mov     si,es:[ne_segtab]       ; ES:SI = pSeg
        mov     cx,es:[ne_cseg]
        xor     di,di
lms_ps_loop:
        inc     di
        test    es:[si].ns_flags,NSPRELOAD
        jz      lms_next_segment
        cmp     es:[ne_align], 4        ; Must be at least paragraph aligned
        jb      lms_ReadFromFile
        cmp     hBlock, 0
        jne     lms_ReadFromMemory
        jmps    lms_ReadFromFile

lms_next_segment:
        add     si,SIZE new_seg1
        loop    lms_ps_loop
lms_done:
        retn

lms_ReadFromFile:
        push    cx
        push    es
        cCall   FarLoadSegment,<es,di,fh,fh>
        jmps    lms_DoneLoad

lms_ReadFromMemory:
        push    cx
        push    es
        cCall   GlobalLock,<hBlock>
        or      dx, dx
        jnz     lms_still_here
        cCall   GlobalFree,<hBlock>
        mov     hBlock, 0
        pop     es
        pop     cx
        jmps    lms_ReadFromFile

lms_still_here:
ifdef WOW
        cCall   AllocSelectorWOW,<dx>  ; same as allocselector. but the
        mov     RefSelector, dx        ; new descriptor is not set.
else
        cCall   AllocSelector,<dx>
endif
        pop     es
        mov     bx, es:[si].ns_sector
        xor     dx, dx
        mov     cx, es:[ne_align]
        push    es
@@:
        shl     bx, 1
        rcl     dx, 1
        loop    @B

        sub     bx, off_FileOffset
        sbb     dx, seg_FileOffset
        push    ax
        push    es
ifdef WOW
        ; same as longptradd. but the descriptor 'RefSelector' is used
        ; to set the descriptor of 'ax'
        cCall   LongPtrAddWOW,<ax,cx,dx,bx, RefSelector, 1>     ; (cx is 0)
else
        cCall   LongPtrAdd,<ax,cx,dx,bx>        ; (cx is 0)
endif
        pop     es
        dec     cx
        cCall   FarLoadSegment,<es,di,dx,cx>
        pop     cx
        push    ax
        cCall   FreeSelector,<cx>
        cCall   GlobalUnlock,<hBlock>
        pop     ax
lms_DoneLoad:
        pop     es
        pop     cx
        or      ax,ax
        jz      lms_abort_load1
        jmp     lms_next_segment
lms_abort_load1:
        jmp     abort_load

;-----------------------------------------------------------------------
;
;       LMLetsGo -
;
;-----------------------------------------------------------------------
LMLetsGo:
        push    es
        push    Win_PDB                 ; Save current PDB
        push    topPDB                  ; Set it to Kernel's
        pop     Win_PDB
        mov     ax, -1
        cCall   FarGetCachedFileHandle,<es,ax,ax>
        cmp     hBlock,0
        je      lg_resFromFile

        cCall   PreloadResources,<es,ax,hBlock,FileOffset>
        jmps    lg_gotRes

lg_resFromFile:
        xor     dx, dx
        cCall   PreloadResources,<es,ax,dx,dx,dx>
lg_gotRes:
        pop     Win_PDB                 ; Restore PDB
        pop     es
        mov     ax,lpPBlock.off
        mov     dx,lpPBlock.sel
        and     ax,dx
        inc     ax
        jnz     lg_huh
        mov     lpPBlock.off,ax
        mov     lpPBlock.sel,ax
lg_huh: xor     ax,ax                   ; free 0
        push    fLMdepth
        mov     fLMdepth, 0
        push    es
        cCall   StartModule,<ax,lpPBlock,es,fh>
        pop     es
        mov     hResult,ax
        or      ax,ax
        jnz     @F
        jmp     abort_load0

@@:     test    es:[ne_flags],NENOTP
        jnz     lg_not_a_process2

        pop     si
        cCall   CloseApplEnv,<hResult,pExe>
        push    bx
        mov     hResult,ax
        mov     hTDB,dx
lg_not_a_process2:
        pop     fLMdepth
        retn


;----------------------------------------------------------------------
;
;  LMPrevInstance - internal routine for LoadModule
;       Load an app/dll if a previous instance in memory
;  Entry:
;       ax = handle of previous instance
;  Exit:
;       ax = status to return
;       dx = hTDB = TDB
;  Error:
;       ax < LME_MAXERR
;
;-----------------------------------------------------------------------
LMPrevInstance:
        mov     es,ax
        mov     dx,es:[ne_flags]
        mov     si,ax
        mov     pExe,ax                 ; why store in pExe and hExe?
        mov     hResult,0

; Error if dynamically linking to non-library module.
        mov     ax,lpPBlock.off
        and     ax,lpPBlock.sel
        inc     ax
        jnz     pi_app
        test    dx,NENOTP
        jnz     @F
        mov     ax, LME_LINKTASK        ; can't dynalink to a task
        retn

@@:     mov     lpPBlock.off,ax         ; AX == 0
        mov     lpPBlock.sel,ax
pi_app:
        test    dx,NEINST
        jnz     @F
        jmp     pi_not_inst
@@:     call    LMCheckHeap
        or      ax, ax
        jnz     @F
        mov     ax, LME_MEM             ; Out of (gdi/user) memory
        retn
@@:

ifdef WOW
        ;
        ; if WOA invoked by app (not fWOA) fail it
        ;
        cmp     fWOA,0                  ; fWOA
        jnz      pi_not_multiple_data

        cld
        push    si
        push    di
        mov     di, es:[ne_restab]
        inc     di
        mov     si, dataOffset WOAName
        mov     cx, 4
        repe    cmpsw
        pop     di
        pop     si
        jnz     @F
        mov     ax, LME_WOAWOW32
        retn
@@:
endif



; We refuse to load multiple instances of apps that have
;  multiple data segments.  This is because we cannot do
;  fixups to these other data segments.  What happens is
;  that the second copy of the app gets fixed up to the
;  data segments of the first application.  For the case
;  of read-only data segments we make an exception since
;  what does it matter who the segments belong to?

        mov     ax, 2                   ; if we have >= 2 dsegs we die
        mov     es,si
        mov     cx,es:[ne_cseg]
        mov     bx,es:[ne_segtab]
pi_next_seg:
        test    es:[bx].ns_flags,NSDATA ; scum! this barely works!
        jz      @F
        test    es:[bx].ns_flags,NSERONLY
        jnz     @F
        dec     ax
        jnz     @F                      ; two data segments is one too many!
pi_mds: mov     ax, LME_APPMDS
        retn

@@:     add     bx,SIZE NEW_SEG1
        loop    pi_next_seg

pi_not_multiple_data:                   ; Prepare the application
        cCall   OpenApplEnv,<lpPBlock,si,fWOA>
        cCall   GetInstance,<si>        ; Why do we call this?
        mov     di,ax
        cCall   IncExeUsage,<si>
        cCall   AllocAllSegs,<si>       ; Can we get memory?
        inc     ax
        jnz     @F
        cCall   DecExeUsage,<si>        ; AllocAllSegs failed, Dec Usage
        jmps    pi_mem                  ; Must have failed from no memory

@@:     mov     ax,-1
        cCall   StartModule,<di,lpPBlock,si,ax>
;       mov     hResult,ax
        or      ax,ax
        jnz     @F
        mov     es,si                   ; StartModule failed, FreeModule
        mov     si,es:[ne_pautodata]
        cCall   FreeModule,<es:[si].ns_handle>
pi_mem: mov     ax, LME_MEM
        retn

@@:     mov     si, fLMdepth
        mov     fLMdepth, 0
        cCall   CloseApplEnv,<ax,pExe>
        mov     fLMdepth, bx
        mov     hTDB,dx
        retn

pi_not_inst:
        mov     ax,es:[ne_autodata]     ; Make sure data segment is loaded.
        or      ax,ax
        jz      @F
        or      bx,-1
        push    es
        cCall   FarLoadSegment,<es,ax,bx,bx>
        pop     es
        or      ax,ax
        jz      pi_end                  ; yes, AX is already 0, but ...
@@:
        push    es                      ; for GetInstance
        cCall   IncExeUsage,<es>
        cCall   GetInstance             ; ,<pExe>
pi_end:
        retn

;----------------------------------------------------------------------
;
;       LMCleanUp - internal routine for LoadModule
;
;-----------------------------------------------------------------------
LMCleanUp:
ifdef WOW
        cmp     LMHadPEDLL,0
        je      @F
        cmp     ax, LME_MAXERR
        jae     @F
        mov     ax,LME_PE               ; Reflect real error we tried to mask
        KernelLogError  <DBF_WARNING>,ERR_LOADMODULE,"Could not find Win16 copy of Win32 DLL, returning LME_PE."
@@:
endif
        push    ax                      ; save status for future
        cmp     ax, LME_MAXERR
        jae     @F
        cCall   my_lclose,<fh>
        or      fh, -1

; Restore PDB if needed
@@:     mov     ax, -1
        xchg    SavePDB, ax
        inc     ax
        jz      @F
        dec     ax
        mov     Win_PDB, ax

; Free FastLoad block if allocated
@@:     cmp     hBlock,0
        je      @F
        cCall   GlobalFree,<hBlock>
        mov     hBlock,0

; Free app environment if failure and this was an app
@@:
        pop     ax
        cmp     ax,LME_MAXERR
        jae     @F
if KDEBUG
        cmp     ax, LME_INVEXE          ; invalid format (WinOldAp)
        jz      cu_fred
        cmp     ax, LME_PE              ; Win32 Portable Exe - try to load it
        jz      cu_fred
        push    ax
        push    bx
        push    es
        les     bx, lpModuleName
        KernelLogError  <DBF_WARNING>,ERR_LOADMODULE,"Error 0x#ax loading @ES:BX"
        pop     es
        pop     bx
        pop     ax
endif
cu_fred:
        cmp     loadTDB,0
        je      @F
        mov     bx,pExe
        cmp     bx,LME_MAXERR           ; Did we load an ExeHeader?
        jbe     @F
        mov     es,bx
        test    es:[ne_flags],NENOTP
        jnz     @F
        mov     si, fLMdepth
        mov     fLMdepth, 0
        cCall   CloseApplEnv,<ax,es>
        mov     fLMdepth, bx

; shouldn't cache file handles on removable devices cause it
; makes share barf when the user swaps disks.  this kills some
; install apps.  CraigC 8/8/91
@@:
        push    ax
        cmp     ax, LME_MAXERR          ; real?
        jbe     @F
        cmp     OnHardDisk, 0           ; is it on a removable device?
        jne     @F
        cCall   GetExePtr, <ax>         ; get module handle
        cCall   FlushCachedFileHandle, <ax> ; blow it off

;** Log this entry only if in diagnostic mode
@@:
        cmp     fDiagMode,0             ; Only log if in diag mode
        je      LM_NoDiagExit
    cmp     fBooting,0              ; Only log if booting
    je      LM_NoDiagExit

        pop     ax                      ; Get the return code early
        push    ax

        pusha                           ; Save all the registers
        push    ds
        push    es

        ;** Write out the appropriate string
        mov     si,ax                   ; Save the return value
        cmp     ax,LME_MAXERR
        jae     LM_DiagSuccess
        mov     ax,dataOFFSET szLoadFail ; Write the string
        jmp     SHORT LM_DiagOutput
LM_DiagSuccess:
        mov     ax,dataOFFSET szLoadSuccess ; Write the string
LM_DiagOutput:
        cCall   DiagOutput, <ds,ax>
        cCall   DiagOutput, <lpModuleName>
        cmp     si,LME_MAXERR           ; Don't do this on success
        jae     SHORT LM_DiagSuccessSkip

        ;** Log a message complete with the failure code
        mov     ax,si                   ; Get the failure code
        shr     al, 4
        mov     bx,dataOFFSET szCodeString ; Point to the second digit
        push    NREScodeOffset afterHex
        call    toHex
        mov     ax, si
        inc     bx
toHex:
        and     al,0fh                  ; Get low hex digit
        add     al,'0'                  ; Convert to ASCII
        cmp     al,'9'                  ; Letter?
        jbe     @F                      ; Yes
        add     al,'A' - '0'            ; Make it a letter
@@:     mov     [bx],al                 ; Save the digit
        retn
afterHex:
        mov     ax,dataOFFSET szFailCode ; Get the string 'Failure code is '
        cCall   DiagOutput, <ds,ax>
LM_DiagSuccessSkip:
        mov     ax,dataOFFSET szCRLF
        cCall   DiagOutput, <ds,ax>

        pop     es
        pop     ds
        popa

LM_NoDiagExit:
        pop     ax
        dec     fLMdepth
        mov     dx,hTDB
        retn

;@@end

;shl_ax16:                      ; shift AX into DX:AX by cl bits
;       mov     dx, ax
;       shl     ax, cl
;       neg     cl
;       add     cl, 16          ; cl = 16 - cl
;       shr     dx, cl
;       retn

LoadModuleEnd:                          ; jmp here to clean up stack and RET

ifdef WOW
        cmp     ax, LME_MAXERR
        jb      @F
lmntex:
        jmp     LoadModuleExit
@@:

;
;   Exec For Non 16 Bit Windows Apps
;
        ;
        ; WIN 32S App ?  yes -> let NT load it
        ;
        cmp     ax,LME_PE
        je      LM_NTLoadModule


        ;
        ; if an app is spawning WOA (NOT our internal load-fWOA),
        ; Patch lpModuleName to -1 let NT load it
        ;
        cmp     ax,LME_WOAWOW32
        jne     @F
        mov     word ptr lpModuleName[2], -1    ; patch lpModuleName
        mov     word ptr lpModuleName[0], -1
        jmp short LM_NTLoadModule
@@:

        ; Errors 11-15 -> let NT load it
        cmp     ax,LME_RMODE
        jae     lmntex

        cmp     ax,LME_VERS
        jbe     lmntex


        public  LM_NTLoadModule
LM_NTLoadModule:
;
; WOW Execs non-windows apps using WINOLDAP.
;

; First check for loading of a 32bit DLL. lpPBlock will be -1
; in such a case.

        push    ax
        mov     ax,lpPBlock.off
        and     ax,lpPBlock.sel
        inc     ax
        pop     ax
        jz      LoadModuleExit

;
; This is an EXE, but the LME_PE failure code might have come from
; an implicitly linked DLL.  If so, we don't want to try having
; Win32 lauch the win16 EXE, as it will just come back to us.
;
        cmp     ax,LME_PE
        jne     @F
        cmp     ax,hDepFail
        je      short LoadModuleExit
@@:
        sub     sp, 80                  ; alloc space for cmdline
        mov     di, sp
        smov    es, ss
        mov     word ptr es:[di], 0     ; set WindOldApp CmdLine to NULL
        regptr  esdi,es,di
        cCall   WowLoadModule,<lpModuleName, lpPBlock, esdi>

        ;
        ;  if ax < 33 an error occurred
        ;
        cmp     ax, 33
        jb      ex8

        or      Kernel_flags[1],KF1_WINOLDAP
        mov     ax, ss
        les     si,lpPBlock
        mov     es:[si].lpcmdline.off,di
        mov     es:[si].lpcmdline.sel,ax
        mov     si,dataOffset WOAName
        regptr  dssi,ds,si
        cCall   LoadModule,<dssi, lpPBlock>
        cmp     ax,32                   ; check for error...
        jae     ex8

        ;
        ; LoadModule of WinOldApp failed
        ; Call WowLoadModule to clean up process handle
        ;
        push    ax
        mov     ax, ss
        regptr  axdi,ax,di
        cCall   WowLoadModule,<0, lpPBlock, axdi>
        pop     ax

        cmp     ax,2                    ; file not found?
        jnz     ex7                     ; no, return error
        mov     al, LME_WOAWOW32        ; flag WINOLDAP error
ex7:
        or      ax,ax                   ; out of memory?
        jnz     ex8
        mov     ax,8h                   ; yes, return proper error code
ex8:
        add     sp,80                   ; free space for cmdline
endif; WOW

LoadModuleExit:
        RESET_DOS_FLAG_EXEC_OPEN
cEnd

?DOS5   =       ?SAV5

;-----------------------------------------------------------------------;
; My_lclose
;
; Close file handle if it isn't -1.
;
; Entry:
;
; Returns:
;
; Registers Destroyed:
;
; History:
;
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   My_lclose,<PUBLIC,NEAR>
        parmW   fh
cBegin
        mov     ax,fh
        inc     ax
        jz      mlc_exit

        cCall   _lclose,<fh>
mlc_exit:
cEnd

;-----------------------------------------------------------------------;
; WarnRealMode
;
; Trayf for files in the form "Insert WIN.EXE disk in drive A:"
;
; Entry:
;
; Returns:
;
; Registers Destroyed:
;
; History:
;  Sat 07-Oct-1989 17:12:43  -by-  David N. Weise  [davidw]
; Wrote it!  A month or so ago.
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   WarnRealMode,<PUBLIC,NEAR>
cBegin nogen
        ReSetKernelDS
        push    Win_PDB
        push    fLMDepth
        cld
        mov     ax,IDCANCEL             ; assume booting
        test    fBooting,1
        jnz     promptly_done
        cmp     pMBoxProc.sel,0         ; is there a USER around yet?
        jz      promptly_done
        push    di
        push    si
        push    es
        mov     es,cx
ifdef   FE_SB
;Japan and Korea declare that they need more space for DBCS msg.
;It sounds like this is one of common requirement for DBCS enabling
;although Taiwan doesn't claim she has the same requirement.
;I enclosed this code fragment under DBCS and it can be removed
;if somebody thinks it is not necessary.
        sub     sp, 530
else
        sub     sp,512
endif
        mov     di,sp
        mov     si,offset msgRealModeApp1
        push    ds
        smov    ds,cs
        UnSetKernelDS
        call    StartString
        smov    ds,cs
        mov     si,offset msgRealModeApp2
        call    Append
        pop     ds
        ReSetKernelDS

        mov     bx,sp
        xor     ax,ax
        push    ax                      ; Null hwnd
        push    ss
        push    bx                      ; (lpstr)text
        push    cs
        mov     ax,offset szProtectCap
        push    ax                      ; (lpstr)caption
        mov     ax,MB_OKCANCEL or MB_ICONEXCLAMATION or MB_DEFBUTTON2 or MB_SYSTEMMODAL
        push    ax                      ; wType
        call    [pMBoxProc]             ; Call USER.MessageBox
ifdef   FE_SB
        add     sp, 530
else
        add     sp,512
endif
        pop     es
        pop     si
        pop     di

promptly_done:
        pop     fLMDepth
        pop     Win_PDB
        ret

cEnd nogen


        assumes ds,nothing
        assumes es,nothing

StartString:
        call    Append                  ; append first string

; Now append the file name

        push    di
        lea     di,[bx].opFile          ; skip past length, date, time

        call    NResGetPureName         ; strip off drive and directory
        smov    ds,es
        mov     si,di
        pop     di

;  Append ASCIIZ string to output buffer, DS:DX points to string

        assumes ds,nothing
        assumes es,nothing

Append: lodsb
        stosb
        or      al,al
        jnz     Append
        dec     di
        ret


        assumes ds,nothing
        assumes es,nothing

;-----------------------------------------------------------------------;
; NResGetPureName
;
; Returns a pointer the the filename off the end of a path
;
; Entry:
;       ES:DI => path\filename
; Returns:
;       ES:DI => filename
; Registers Destroyed:
;
; History:
;  Wed 18-Oct-1989 20:01:25  -by-  David N. Weise  [davidw]
;
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   NResGetPureName,<PUBLIC,NEAR>
cBegin nogen

ifdef FE_SB
;
; It is not possible to search filename delimiter by backword search
; in case of DBCS version. so we use forword search instead.
;
        mov     bx,di
iup0:
        mov     al,es:[di]
        test    al,al                   ; end of string?
        jz      iup2                    ; jump if so
        inc     di
        cmp     al,'\'
        jz      iup1
        cmp     al,'/'
        jz      iup1
        cmp     al,':'
        jz      iup1
        call    FarMyIsDBCSLeadByte     ; see if char is DBC
        jc      iup0                    ; jump if not a DBC
        inc     di                      ; skip to detemine 2nd byte of DBC
        jmp     iup0
iup1:
        mov     bx,di                   ; update purename candidate
        jmp     iup0
iup2:
        mov     di,bx                   ; di points purename pointer
        ret
else
        cld
        xor     al,al
        mov     cx,-1
        mov     bx,di
        repne   scasb
        inc     cx
        inc     cx
        neg     cx
iup0:   cmp     bx,di                   ; back to beginning of string?
        jz      iup1                    ; yes, di points to name
        mov     al,es:[di-1]            ; get next char
        cmp     al,'\'                  ; next char a '\'?
        jz      iup1                    ; yes, di points to name
        cmp     al,'/'                  ; next char a '/'
        jz      iup1
        cmp     al,':'                  ; next char a ':'
        jz      iup1                    ; yes, di points to name
        dec     di                      ; back up one
        jmp     iup0
iup1:   ret
endif

cEnd nogen

;-----------------------------------------------------------------------;
; search_mod_dep_list
;
; Searches the dependent module list for the passed in name.
;
; Entry:
;       AX    = length of name to search for
;       CX    = count of modules
;       DS:SI => module name to search for
;       ES:DI => module table
; Returns:
;
; Registers Preserved:
;       AX,BX,CX,DI,SI,ES
;
; Registers Destroyed:
;
; History:
;  Sat 07-Oct-1989 17:12:43  -by-  David N. Weise  [davidw]
;
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   search_mod_dep_list,<PUBLIC,NEAR>
cBegin nogen

        push    bx
        push    cx
        push    di
        mov     bx,di

search_mod_loop:
        mov     di,es:[bx]              ; es:di = offset into imptable
        add     di,es:[ne_imptab]
        cmp     es:[di],al              ; does len of entry = sizeof(doscalls)
        jnz     get_next_entry

        push    cx                      ; cx holds count of module entries.
        push    si
        inc     di                      ; es:di = import module name
        mov     cx,ax
        rep     cmpsb
        pop     si
        pop     cx
        stc
        jz      got_it

get_next_entry:
        inc     bx
        inc     bx
        loop    search_mod_loop
        clc
got_it: pop     di
        pop     cx
        pop     bx
        ret

cEnd nogen


;-----------------------------------------------------------------------;
; LMCheckHeap
;
; This checks for 4K free space in both USER's and GDI's data
; segments.  If this space does not exist then we will not load
; the app.  This is better than the hose-bag way we did things
; under win 1 and 2.
;
; Entry:
;       nothing
;
; Returns:
;       AX != 0  lots o'space
;
; Registers Destroyed:
;       BX,CX
;
; History:
;  Sat 28-Oct-1989 17:49:09  -by-  David N. Weise  [davidw]
; Wrote it!
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

MIN_RSC = 10
cProc   LMCheckHeap,<PUBLIC,NEAR>,<ds>
cBegin
        SetKernelDSNRES
ifdef WOW
                                        ; USER32 and GDI32 can deal with memory alloc no need check heaps on WOW
        mov     ax,-1                   ; WOW doesn't have GDI or User heaps
else                                    ; so don't check them.
        mov     ax, MIN_RSC
        cmp     word ptr pGetFreeSystemResources[2],0
        jz      @F
        cCall   pGetFreeSystemResources,<0>
        cmp     ax, MIN_RSC
        jae     @F
if kdebug                               ; test low memory code if DEBUG
        krDebugOut      DEB_WARN, "Resources #ax% - this tests your error handling code"
        or      al, 1
else
        xor     ax, ax                  ; you failed - g'bye
endif
@@:
endif ; WOW
        ReSetKernelDS
cEnd

if 0
cProc   check_gdi_user_heap_space,<PUBLIC,NEAR>
cBegin nogen

        ReSetKernelDS

ifdef WOW
                                        ; USER32 and GDI32 can deal with memory alloc no need check heaps on WOW
        mov     ax,-1                   ; WOW doesn't have GDI or User heaps
else                                    ; so don't check them.
        cmp     graphics,0
        jz      c_ret
        push    dx
        push    es
        push    ds
        mov     ds,hGDI
        UnSetKernelDS
        call    checkit_bvakasha
        or      ax,ax
        jz      c_exit
        pop     ds
        ReSetKernelDS
        push    ds
        mov     ds,hUser
        UnSetKernelDS
        call    checkit_bvakasha
c_exit: pop     ds
        pop     es
        pop     dx
c_ret:  ret

        public  checkit_bvakasha
checkit_bvakasha:
        mov     bx,ds:[ne_pautodata]
        cCall   FarMyLock,<ds:[bx].ns_handle>
        mov     ds,ax
        call    LocalCountFree
        sub     ax,4095
        ja      cguhs_exit
        neg     ax
        mov     bx,LA_MOVEABLE
        cCall   LocalAlloc,<bx,ax>
        or      ax,ax
        jz      cguhs_exit
free_User_piece:
        cCall   LocalFree,<ax>
        mov     ax,sp                   ; return non-zero
cguhs_exit:
endif ;WOW
        ret
cEnd nogen
endif

;-----------------------------------------------------------------------;
; GetHeapSpaces
;
;
; Entry:
;       nothing
;
; Returns:
;       AX = free space (bytes) of User heap assuming heap can grow to 64K
;       DX = free space (bytes) of GDI  heap assuming heap can grow to 64K
; Registers Destroyed:
;
; History:
;  Wed 10-Jan-1990 22:27:38  -by-  David N. Weise  [davidw]
; Wrote it!
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   GetHeapSpaces,<PUBLIC,FAR>,<di,si>

        parmW   hInstance
cBegin
        call    MapDStoDATA
        ReSetKernelDS
        cCall   FarMyLock,<hInstance>
        or      ax,ax
        jz      ghs_exit
        mov     ds,ax
        cmp     ds:[ne_magic],NEMAGIC
        jnz     ghs_must_be_data
        mov     bx,ds:[ne_pautodata]
        cCall   FarMyLock,<ds:[bx].ns_handle>
        mov     ds,ax
ghs_must_be_data:
        call    LocalCountFree
        mov     si,ax
        cCall   GlobalSize,<ds>
        neg     ax
        add     ax,si                   ; AX = size of free assuming 64K
        mov     cx,si                   ; CX = size of free
        mov     dx,-1
        sub     dx,ds:[pLocalHeap]      ; DX = size of heap

ghs_exit:

cEnd

;-----------------------------------------------------------------------;
; IsROMModule
;
;   Determines if an app with a given name is a ROM application
;
; Entry:
; Returns:
; Registers Destroyed:
;
; History:
;  Wed 01-May-1991 13:11:38  -by-  Craig A. Critchley   [craigc]
; Wrote it!
;-----------------------------------------------------------------------;


cProc   IsROMModule, <FAR, PUBLIC>
cBegin  <nogen>
        xor     ax, ax
        retf    6
cEnd    <nogen>

;-----------------------------------------------------------------------;
; IsROMFile
;
;   Determines if a file is in ROM
;
; Entry:
; Returns:
; Registers Destroyed:
;
; History:
;  8/8/91 -- vatsanp -- adapted this for true-type files in ROM
;  from IsROMModule [ craigc]
;  Wed 01-May-1991 13:11:38  -by-  Craig A. Critchley   [craigc]
; Wrote it!
;-----------------------------------------------------------------------;

cProc   IsROMFile, <FAR, PUBLIC>
cBegin  <nogen>
        xor     ax, ax
        retf    6
cEnd    <nogen>

sEnd    NRESCODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\ldappl.asm ===
TITLE	LDAPPL - AppLoader Interface

IFNDEF NO_APPLOADER	;* entire file for AppLoader

.xlist
include kernel.inc
include newexe.inc
include tdb.inc
include appl.inc
include protect.inc
.list

DataBegin

externW  pGlobalHeap
	 
DataEnd

sBegin	CODE
externNP SetOwner
externFP set_discarded_sel_owner
sEnd	CODE

externFP MyOpenFile
externFP FarLoadSegment
externFP FarMyAlloc
externNP Int21Handler
IF KDEBUG		;See comment below where this function is used
externFP AppLoaderEntProcAddress
ELSE
externFP FarEntProcAddress
ENDIF
externFP GlobalHandle
externFP Far_get_temp_sel
externFP Far_free_temp_sel

sBegin	NRESCODE
assumes CS,NRESCODE
assumes DS,NOTHING
assumes ES,NOTHING

externNP MapDSToDATA

;-----------------------------------------------------------------------;
; BootAppl								;
; 									;
; Boots (i.e. starts) an AppLoader application				;
;  Loads (and relocates) first segment (must be CODE/FIXED/PRELOAD)	;
;  Validates the APPL magic word					;
;  Calls APPL boot procedure						;
;									;
; Arguments:								;
;	parmW   hexe (handle to exe header)				;
;	parmW	fh   (file handle)					;
; 									;
; Returns:								;
;	AX != 0 => ok							;
; 									;
; Error Returns:							;
;	AX == 0 => error						;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
;	various								;
; 									;
; History:								;
; 									;
;  Thu Oct 01, 1987 11:10:06a  -by-  David N. Weise	[davidw]	;
; Changed the return values to NOT return ZF.				;
; 									;
;  Thu Jul 30, 1987 11:56:34a  -by-  Scott A. Randell	[scottra]	;
; Created it.								;
;-----------------------------------------------------------------------;

cProc	BootAppl,<NEAR,PUBLIC>,<si>
	parmW   hexe
	parmW	fh
cBegin	BootAppl

	mov	es,hexe
	mov	si,es:[ne_segtab]		;* es:si => segtab
	mov	ax,es:[si].ns_flags		;* first segment
	test	ax,NSMOVE
	jnz	@f				;* PMode loader will set the
	jmp	bal_error			;*  moveable flag for us
@@:

	test	ax,NSPRELOAD
	jz	bal_error			;* must be preload

;*	* load in first segment (turn off Alloced/Loaded, and DS requirement)
	and	ax,not NSALLOCED+NSLOADED+NSUSESDATA
	mov	es:[si].ns_flags,ax		;* update flags
	mov	ax,1				;* first segment
	cCall	FarLoadSegment,<es,ax,fh,fh>
	jcxz	bal_fail			;* not enough memory

;*	* now validate APPL header
	mov	es,ax
	push	es
	cCall	Far_get_temp_sel
	xor	bx,bx				;* es:bx => first segment
	cmp	es:[bx].magicAppl,magicApplCur	;* current version ?
						;* (no backward compatibility)
	jne	bal_error_popes

;*	* fill in global information
	mov	word ptr es:[bx].lppsMob,dataOffset pGlobalHeap
	mov	ax,codeBase			;* segment address of FIXED KERNEL

	push	ds
	call	MapDStoData
	mov	word ptr es:[bx].lppsMob+2,ds	;* segment address of krnl data
	pop	ds

	mov	word ptr es:[bx].pfnKernelAlloc,codeOffset FarMyAlloc
	mov	word ptr es:[bx].pfnKernelAlloc+2,ax

        ; In DEBUG, we really want RIPs to be able to happen when we don't
        ;       find ordinals.  This saves an enormous amount of debugging
        ;       time!!  The entry point AppLoaderEntProcAddress only exists
        ;       in debug and allows RIPs to happen (unlike FarEntProcAddress
        ;       which is the same entry point used for GetProcAddress which
        ;       should not RIP).
IF KDEBUG
	mov	word ptr es:[bx].pfnEntProcAddress,codeOffset AppLoaderEntProcAddress
ELSE
	mov	word ptr es:[bx].pfnEntProcAddress,codeOffset FarEntProcAddress
ENDIF
	mov	word ptr es:[bx].pfnEntProcAddress+2,ax
;*	* extra entry for Protect Mode only
	mov	word ptr es:[bx].pfnSetOwner,codeOffset MySetOwner
	mov	word ptr es:[bx].pfnSetOwner+2,ax

	mov	ax,es
	pop	es
	cCall	Far_free_temp_sel,<ax>
;*	* call the start procedure
	cCall	es:[pfnBootAppl], <hexe, fh>	;* returns BOOL

bal_end:	;* ax
cEnd	BootAppl


bal_error_popes:	;* an error occured (pop es if in PMODE)
	mov	ax,es
	pop	es
	cCall	Far_free_temp_sel,<ax>
bal_error:	;* an error occured
if KDEBUG
	int	3
endif
bal_fail:	;* Boot failed (not enough memory)
	xor	ax,ax
	jmps	bal_end


;-----------------------------------------------------------------------;
; ExitAppl								;
; 									;
; Exit last instance of an APPLOADER application			;
;									;
; Arguments:								;
;	parmW   hexe (handle to exe header)				;
; 									;
; Returns:								;
;	N/A								;
; 									;
; History:								;
; 									;
;  Sat Sep 19, 1987 15:55:19 -by-  Scott A. Randell [scottra]		;
; Created it								;
;-----------------------------------------------------------------------;

cProc	ExitAppl,<NEAR,PUBLIC>
	parmW	hexe
cBegin	ExitAppl

; The apps with loaders don't do anything in their exit code except try
; to close a bogus file handle, so we just will not make this call
; anymore.  This call runs on the kernel PSP, so if the app picked a valid
; kernel file handle, that file got closed.  0 seems to be a popular
; handle to inadvertently close.  Newer apps do/will not have their own
; loaders.

ifdef DEAD_CODE ;--------------------------------------------------------

	mov	es,hexe
	mov	bx,es:[ne_segtab]		;* es:si => segtab

;*	* first segment is the AppLoader
	mov	ax,es:[bx].ns_handle		;* handle
	or	ax, ax				; Out of memory, couldn't load segment?
	jz	exa_error
	HtoS	ax	 			;* back to ring 1

	push	bx
	lar	bx, ax
	test	bh, DSC_PRESENT			; Fix a WinWord bug
	pop	bx
	jz	exa_error

	mov	es,ax
;*	* test to make sure that an APPL is there
	cmp	es:[magicAppl],magicApplCur
	jne	exa_error

; The following hack sets up SS to have a 64k limit before calling the
; app's exit procedure.  Added 12/18/90 to work around a bug in the
; Excel & WinWord app loader that references a bogus offset from SS.  In
; the past the stack segment at this point already had a large limit, but
; when the data segment was moved out of the kernel's code segment and
; the limit decreased to the actual DS size, the Excel/WinWord offset
; is now beyond the segment limit.

	push	ss				;save current SS
	push	es				;seg 1 handle
	smov	es,ss				;get temp selector takes
	cCall	far_get_temp_sel		;  and returns selector in ES
	smov	ss,es				;SS now has max limit
	pop	es				;seg 1 handle
	cCall	es:[pfnExitAppl], <hexe>

	mov	ax,ss				;return to original SS and
	pop	ss				;  free temp selector
	cCall	far_free_temp_sel,<ax>
exa_error:

endif	;DEAD_CODE	-------------------------------------------------

cEnd	ExitAppl

sEnd	NRESCODE


sBegin	CODE
assumes CS,CODE
;-----------------------------------------------------------------------;
; LoadApplSegment							;
; 									;
; Load an APPL segment							;
;  open file if not already open					;
;  tests to make sure 1st segment is an APPL loader			;
;  call the Apploader requesting segment be loaded			;
;  NOTE : never call for first segment					;
;									;
; Arguments:								;
;	parmW   hexe		(handle to exe header)			;
;	parmW	fh		(file handle (may be -1))		;
;	parmW	segno		(segment #)				;
; 									;
; Returns:								;
;	NZ, AX != 0 => ok, AX = segment where loaded, DX = handle of seg;
; 									;
; Error Returns:							;
;	Z, AX == 0 => error						;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
;	various								;
; 									;
; History:								;
; 									;
;  Thu Jul 30, 1987 11:56:34a  -by-  Scott A. Randell [scottra]		;
; Created it								;
;-----------------------------------------------------------------------;

cProc	LoadApplSegment,<NEAR,PUBLIC>,<si>
	parmW   hexe		       
	parmW	fh
	parmW	segno
	localW	myfh			;* private file handle
					;*  (if one shot open/close)
cBegin	LoadApplSegment

	mov	es,hexe
	mov	myfh,-1			;* try with what is open first
	mov	ax,fh

las_retry:	;* ax = file handle
	mov	si,es:[ne_segtab]		;* es:si => segtab
;*	* first segment is the AppLoader
	mov	si,es:[si].ns_handle		;* handle
	HtoS	si				;* back to ring 1
	mov	es,si
;*	* test to make sure that an APPL is there
	cmp	es:[magicAppl],magicApplCur	;* current version ?
						;* (no backward compatibility)
	jne	las_error

;*	* Try to reload with the handle Windows has (may be -1)
	cCall	es:[pfnReloadAppl], <hexe, ax, segno>
						;* returns AX = segment
	or	ax,ax
	jnz	las_end				;* return AX != 0
;*	* if the file handle was -1, open the file and try again
	cmp	myfh,-1
	jne	las_error			;* could not load with a file
;*	* file is not open, open up temporary file (put handle in myfh)
	mov	es,hexe
	mov	dx,es:[ne_pfileinfo]
	regptr	esdx,es,dx
if SHARE_AWARE
	mov	bx,OF_REOPEN or OF_PROMPT or OF_CANCEL or OF_VERIFY + OF_SHARE_DENY_WRITE
else
	mov	bx,OF_REOPEN or OF_PROMPT or OF_CANCEL or OF_VERIFY
endif
	push	dx
	Save	<es>
	cCall	MyOpenFile,<esdx,esdx,bx>
	pop	dx
	mov	myfh,ax
	cmp	ax,-1
	jne	las_retry

las_error:	;* an error occured
;*	* close file (if myfh != -1), then return error
	debug_out "LoadApplSegment failed - better find out why!"
	xor	ax,ax

las_end: ;* ax = return value
	mov	bx,myfh
	inc	bx
	jz	las_no_temp_file
	dec	bx
	push	ax
	mov	ah,3Eh				;* close file handle
	DOSCALL
	pop	ax
las_no_temp_file:	;* ax = return code
	or	ax,ax
cEnd	LoadApplSegment

;-----------------------------------------------------------------------;



;-----------------------------------------------------------------------;
; MySetOwner								;
; 									;
; Private version of SetOwner for present/non-present selectors		;
;									;
; Arguments:								;
;	selector = selector (present or non-present)			;
;	owner = new owner field						;
; 									;
; History:								;
; 									;
;  Mon 04-Dec-1989 10:03:25  -by-  David N. Weise  [davidw]		;
; Made it call set_discarded_sel_owner instead of set_sel_limit.	;
;									;
;  Mon Jul 03 20:37:22 1989	created -by- Scott A. Randell [scottra] ;
;-----------------------------------------------------------------------;

cProc	MySetOwner,<PUBLIC,FAR>, <SI, DI>
	parmW	selector
	parmW	owner
cBegin
	cCall	GlobalHandle,<selector>
	or	dx,dx				;* 0 => not present
	jz	set_owner_NP
;*	* set owner for present selectors
	cCall	SetOwner,<selector, owner>
	jmp	short end_set_owner

set_owner_NP:
	;* NP selectors store the owner in the segment limit
	mov	bx,selector
	mov	es,owner
	call	set_discarded_sel_owner

end_set_owner:
cEnd

sEnd	CODE

endif ;!NO_APPLOADER (entire file)

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\ldaux.asm ===
TITLE   LDAUX - Assembler side of LD.C

.xlist
include kernel.inc
include newexe.inc
include tdb.inc
include protect.inc
.list

DataBegin

externB  fChksum
externW  hExeHead
externW  curTDB
externW  PHTcount
externW  kr1dsc
szFake32BitModuleName DB 128 DUP(0)
cFake32BitModuleName DW SIZE szFake32BitModuleName

ifdef WOW
szWinGDllModule       DB 'WING', 0
szWinGDllFile         DB '\SYSTEM\WING.DLL',0
externD lpWindowsDir
externW cBytesWinDir
endif ; WOW

ifdef DBCS_KEEP
ifdef WOW
public hModNotepad
hModNotepad DW 0
NotepadName DB 'notepad.exe', 0
endif ; WOW
endif ; DBCS_KEEP
DataEnd

externFP GlobalAlloc
externFP GlobalFree
externFP GlobalHandle
externFP GetExePtr
externFP FarMyUpper
externFP FarFindOrdinal
externFP FarEntProcAddress
externFP FarMyLock

externFP FarGetOwner
externFP AllocSelector
externFP IPrestoChangoSelector
externFP FreeSelector
externFP lstrcpyn
ifdef WOW
ifdef DBCS_KEEP
externFP WowGetModuleUsage
externFP MyGetAppWOWCompatFlags
endif ; DBCS_KEEP
externFP WowGetModuleFileName
externFP HandleAbortProc
externFP WowGetModuleHandle
endif

ifdef FE_SB
externFP FarMyIsDBCSLeadByte
endif

sBegin  CODE
assumes CS,CODE

externNP LoadSegment
externNP MyLock

externNP GetOwner

if LDCHKSUM
externNP GetChksumAddr
endif

;-----------------------------------------------------------------------;
; GetSegPtr                                                             ;
;                                                                       ;
;                                                                       ;
; Arguments:                                                            ;
;       DS:SI = FARPROC or DS = hModule and SI = segment#               ;
;                                                                       ;
; Returns:                                                              ;
;       BX = 0                                                          ;
;       CX = segment# or zero if input invalid                          ;
;       DS:SI -> segment table entry                                    ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;                                                                       ;
; Calls:                                                                ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Sun 24-Dec-1989 22:49:50  -by-  David N. Weise  [davidw]             ;
; Added check for MPI thunk.                                            ;
;                                                                       ;
;  Wed Oct 07, 1987 12:59:54p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.                                       ;
;-----------------------------------------------------------------------;

        assumes ds, nothing
        assumes es, nothing

cProc   GetSegPtr,<PUBLIC,NEAR>
cBegin nogen

        xor     bx,bx                   ; For cheap indexed addressing
        cmp     ds:[bx].ne_magic,NEMAGIC; Is this a thunk address?
        jne     gspFixed                ; No, must be fixed procedure
        dec     si                      ; No, see if valid segment #
        cmp     si,ds:[bx].ne_cseg
        jb      @F
        jmps    gspfail                 ; No, fail
@@:     mov     cx,si                   ; Yes, load that segment
        inc     cx
        jmps    gspSegNo

; CX = segment number.  Convert to segment info pointer.

gspSegNo:
        push    cx
        dec     cx
        shl     cx,1
        mov     si,cx
        shl     cx,1
        shl     cx,1
        add     si,cx
        .errnz  10 - SIZE NEW_SEG1
        add     si,ds:[bx].ne_segtab
        pop     cx
        jmps    gspExit                 ; DS:SI -> segment info block

gspFixed:                               ; DS = code segment address

; check for MakeProcInstance thunk first because GetOwner in 386pmode
;  ain't robust enough

        cmp     byte ptr ds:[si].0,0B8h ; Maybe, is this a mov ax,XXXX inst?
        jnz     gsp_not_mpit
        cmp     byte ptr ds:[si].3,0EAh ; Followed by far jump inst?
        jnz     gsp_not_mpit
        cmp     ds:[2],MPIT_SIGNATURE   ; Is it in a mpi table?
        jz      gsp_yes_mpit
        cmp     ds:[TDB_MPI_THUNKS].2,MPIT_SIGNATURE
        jnz     gsp_not_mpit
gsp_yes_mpit:
        lds     si,ds:[si].4            ; get real procedure address
        jmp     GetSegPtr
gsp_not_mpit:

        push    ax
        mov     dx, ds                  ; Handle in dx
        StoH    dl                      ; Assume not fixed
        cCall   GetOwner,<ds>
        or      ax,ax
        mov     ds, ax
        pop     ax
        jz      gspfail

gspf1:
        cmp     ds:[bx].ne_magic,NEMAGIC; Is it a module DB?
        jnz     gspfail                 ;  Nope, fail.

getting_closer:
        mov     si,ds:[bx].ne_segtab    ; Yes, point to segment table
        mov     cx,ds:[bx].ne_cseg
gspLoop:
        cmp     dx,ds:[si].ns_handle    ; Scan stmen
        jz      gspFound
        HtoS    dx                      ; May be fixed seg???
        cmp     dx,ds:[si].ns_handle    ; Scan stmen
        jz      gspFound
        StoH    dx
        add     si,SIZE NEW_SEG1
        loop    gspLoop
gspfail:
        xor     cx,cx
        jmps    gspExit
gspFound:
        sub     cx,ds:[bx].ne_cseg      ; Compute segment# from remainder
        neg     cx                      ; of loop count
        inc     cx                      ; 1-based segment#
gspExit:
        ret

cEnd nogen

        assumes ds, nothing
        assumes es, nothing

cProc   IGetCodeInfo,<PUBLIC,FAR>,<si,di>
        parmD   lpProc
        parmD   lpSegInfo
cBegin
        lds     si,lpProc
        call    getsegptr
        mov     ax,cx
        jcxz    gciExit
        les     di,lpSegInfo
        mov     cx,SIZE NEW_SEG1
        cld
        rep     movsb
        mov     ax,ds:[bx].ne_align     ; Return segment aligment
        stosw
        sub     si,SIZE NEW_SEG1
        sub     di,SIZE NEW_SEG1+2
        cmp     si,ds:[bx].ne_pautodata
        jne     gciExit
        mov     ax,ds:[bx].ne_stack
        add     ax,ds:[bx].ne_heap
        add     es:[di].ns_minalloc,ax
gciExit:
        smov    es,ds ; put module handle (returned from getsegptr) into es
                      ; user depends on this
        mov     cx,ax   ; WHY IS THIS HERE?
;
; NOTE: USER assumes that AX == BOOL fSuccess and ES == hModule upon return
;
cEnd

        assumes ds, nothing
        assumes es, nothing

cProc   GetCodeHandle,<PUBLIC,FAR>,<si,di>
        parmD   lpProc
cBegin
        lds     si,lpProc
        call    getsegptr
        mov     dx,cx
        jcxz    gchExit
        mov     ax,ds:[si].ns_handle
;        test    ds:[si].ns_flags,NSLOADED
;        jnz     gchExit
        mov     dx,-1
        cCall   LoadSegment,<ds,cx,dx,dx>
        cCall   MyLock,<ax>
        xchg    ax,dx
        cmp     ax,dx
        je      gchExit
; %OUT Need pmode lru stuff here
gchExit:
cEnd


        assumes ds,nothing
        assumes es,nothing

cProc   CallProcInstance,<PUBLIC,FAR>
cBegin  nogen
        mov     ax,ds                   ; AX = caller's DS
        mov     cx,es:[bx]              ; CX = hInstance
        jcxz    cpx                     ; If zero, then use caller's DS
        xchg    ax,cx                   ; AX = hInstance,  CX = caller's DS
        test    al,GA_FIXED             ; Fixed?
        jnz     cpx                     ; Yes, all set
        xchg    bx,ax                   ; No, BX = hInstance, ES:AX ->
labelFP <PUBLIC,CallMoveableInstanceProc>   ; procedure address.
        HtoS    bx                      ; Get selector
        xchg    bx,ax                   ; AX = segment address
        mov     ds,cx                   ; Restore DS
cpx:    jmp     dword ptr es:[bx][2]    ; Jump to far procedure
cEnd    nogen


sEnd    CODE


sBegin  NRESCODE
assumes CS,NRESCODE

externNP MapDStoDATA
externNP FindExeInfo
externNP FindExeFile
externNP NResGetPureName

        assumes ds,nothing
        assumes es,nothing

cProc   CopyName,<PUBLIC,NEAR>,<si>
        parmD   pname
        parmW   pdst
        parmW   fUpper
cBegin
        les     si,pname
        mov     bx,pdst
        mov     cx,127
        mov     dx,fUpper
cn0:
        lods    byte ptr es:[si]
        or      al,al
        jz      cn1
        or      dx,dx
        jz      cn0a
ifdef FE_SB
        call    FarMyIsDBCSLeadByte     ; test if a char is lead byte of DBC
        jc      @F                      ; jump if not a DBC
        inc     bx
        mov     ss:[bx],al              ; store first byte of DBC
        dec     cx
        jcxz    cn1                     ; pay attention for counter exhaust...
        lods    byte ptr es:[si]        ; fetch a 2nd byte of DBC
        jmps    cn0a
@@:
endif
        call    FarMyUpper
cn0a:
        inc     bx
        mov     ss:[bx],al
        loop    cn0
cn1:
        mov     byte ptr ss:[bx+1],0
        mov     ax,bx
        mov     bx,pdst
        sub     ax,bx
        mov     ss:[bx],al
cEnd


        assumes ds,nothing
        assumes es,nothing

cProc   IGetProcAddress,<PUBLIC,FAR>,<ds,si>
        parmW   hinstance
        parmD   pname
        localV  namebuf,130
cBegin
        mov     cx,hinstance
        jcxz    use_current_module
        cCall   GetExePtr,<cx>
        xor     dx,dx
        jcxz    gpdone1
        mov     si,ax
        mov     es,ax
        test    es:[ne_flags],NENOTP
        jnz     have_module_address
        xor     bx,bx
if KDEBUG
        fkerror 00FFh,<Can not GetProcAddress a task.>,es,bx
endif
        xor     ax,ax
        xor     dx,dx
gpdone1:
        jmps    gpdone
use_current_module:
        cCall   MapDStoDATA
        ReSetKernelDS
        mov     es,curTDB
        UnSetKernelDS
        mov     si,es:[TDB_pModule]
have_module_address:
        cmp     seg_pname,0
        jne     gp0
        mov     ax,off_pname
        jmps    gpaddr
gp0:
        lea     bx,namebuf
        xor     dx,dx
        cCall   CopyName,<pname,bx,dx>
        lea     bx,namebuf
        mov     dx,-1
        cCall   FarFindOrdinal,<si,ssbx,dx>

        cwd                             ; set DX to 0 if no ordinal
        or      ax,ax
        jz      gpdone                  ; if no ordinal, leave with 0:0

gpaddr:
        cCall   FarEntProcAddress,<si,ax>
gpdone:
        mov     cx,ax
        or      cx,dx
cEnd


;-----------------------------------------------------------------------;
; GetModuleHandle
;
; Returns the module handle, AKA segment address, of the named
; module.  The pname should be a pointer to a name, however
; because we want FreeFontResource to take a file name we check
; for that one special case for file names.
;
; Entry:
;       parmW   pname
;            or 0:instance handle
; Returns:
;       AX = handle if loaded
;          = 0 if not loaded
;
; Registers Destroyed:
;       BX,CX,DX,ES
;
; History:
;  Sat 18-Nov-1989 21:57:24  -by-  David N. Weise  [davidw]
; Adding the handling of exeheaders above the line by calling
; off to EMS_GetModuleHandle.  A little while ago is when
; the checking for filenames was added.
;
;  Tue 04-Apr-1989 01:42:12  -by-  David N. Weise  [davidw]
; This used to return DX = ExeHead, this is now returned in CX.
;
;  Tue 28-Mar-1989 17:28:34  -by-  David N. Weise  [davidw]
; Put in the Excel hack and added this nifty comment block.
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   IGetModuleHandle,<PUBLIC,FAR>,<di,si>
        parmD   pname
        localV  nameBuf,130
cBegin
        cCall   MapDStoDATA
        ReSetKernelDS
        cmp     pname.sel,0
ifndef DBCS_KEEP
        jz      gm1
else ; DBCS_KEEP
ifdef WOW
        jnz      gm_chk
        jmp     gm1

 for Lotus Freelance Instration program
gm_chk:
        call    MyGetAppWOWCompatFlags
        test    ax, 4                       ; WOWCF_AUDITNOTEPAD
        jz      gm_ne

        lea     si,NotepadName
        les     di,pname
        mov     cx,11
        cmpsb
        jnz     gm_ne

        mov     ax,hModNotepad
        or      ax,ax
        jz      gm_ne

        cmp     ax,1
        jnz     gm_pe

        mov     bx,10
        xor     cx,cx
        cCall   GlobalAlloc,<cx,cx,bx>
        or      ax,ax
        jz      gm_hdl
        mov     hModNotepad,ax
gm_pe:
        jmp     short gmexit
gm_ne:
endif ; WOW
endif ; DBCS_KEEP

        lea     di,namebuf
        xor     dx,dx                   ; Try as is first
        cCall   CopyName,<pname,di,dx>
        inc     di                      ; point past count
        push    ax
        cCall   FindExeInfo,<ss,di,ax>
        pop     bx
        or      ax,ax
        jnz     gmexit

        lea     di,namebuf
        mov     dx,-1                   ; Now force upper case
        cCall   CopyName,<pname,di,dx>
        inc     di                      ; point past count
        push    ax
        cCall   FindExeInfo,<ss,di,ax>
        pop     bx
        or      ax,ax
        jnz     gmexit

        smov    es,ss
        call    NResGetPureName
        cCall   FindExeFile,<ss,di>
        jmps    gmexit

gm1:    cCall   GetExePtr,<OFF_pname>
gmexit:

ifdef WOW
;
; If we didn't find a matching module, call WOW32 to see if
; the module name matches the module name of a child app
; spawned via WinOldAp.  If it does, WOW32 will return
; that WinOldAp's hmodule.  If not, WOW32 will return zero.
;
        or      ax,ax
        jnz     @F
        lea     di,namebuf[1]
        cCall   WowGetModuleHandle, <ss,di>
@@:
endif

        mov     dx,hExeHead             ; return this as a freebie
cEnd

        assumes ds,nothing
        assumes es,nothing

cProc   IGetModuleName,<PUBLIC,FAR>,<si,di>
	parmW	hinstance
	parmD	lpname
	parmW	nbytes
cBegin
	mov	ax, nbytes
	or	ax, ax
        jnz     @f
        jmp     gfx
@@:     cCall   GetExePtr,<hinstance>
	or	ax,ax
	jz	gmn
	mov	ds,ax
	mov	si,ds:[ne_restab]	; Module name is first entry in Res Name Table
        xor     cx,cx
        mov     cl,ds:[si]		; Get Len of module name
        inc     cl                      ; Space for NULL
        inc     si			; Goto start of module name
        cmp     cx,nbytes
        jl      gmn1
        mov     cx,nbytes

gmn1:
        push    lpname
        push    ds
        push    si
        push    cx
        call    lstrcpyn

        mov     ax,0DDh			; Return a true value
gmn:
cEnd

;-----------------------------------------------------------------------
; IsWingModule                                                          
;    Checks if GetModuleFileHandle is called by Wing.dll                
;    on itself.
;    and fills lpname if it is so
;
; Arguments:
;     hinstance - GetModuleFileName's hinstance arg        
;     lpname    - GetModuleFileName's lpname arg
;     nbytes    - GetModuleFileName's lpname arg
;     exehdr    - ExeHdr of hinstance
;     rcsel     - Return Code Selector that called GMFH
; Returns:
;     AX = number of bytes copied if wing is calling GetModuleFileName on itself      
;     AX = 0 otherwise
;     
;------------------------------------------------------------------------

cProc   IsWingModule,<PUBLIC,FAR>,<si,di,ds,es>
        parmW hinstance
        parmD lpname
        parmW nbytes
        parmW exehdr
        parmW rcsel
cBegin  
        mov     es,exehdr
        mov     di,es:[ne_restab]
        inc     di                     ;got modulename 
cCall   MapDStoDATA
assumes DS, DATA
        lea     si, szWinGDllModule
        mov     cx,5
        repe    cmpsb
        jnz     short IWM_NoMatch
        cCall getexeptr,<rcsel>
        cmp     ax,exehdr
        jnz     short IWM_NoMatch
        mov     cx, cBytesWinDir
        add     cx, 17                 ;17=strlen("\system\wing.dll")+1;
        cmp     cx,nbytes
        ja      short IWM_NoMatch      ;return righ away if doesn't fit
        mov     ax,cx                  
        sub     cx,17
        les     di,lpname
        lds     si,lpWindowsDir
        cld
        rep     movsb
        mov     cx,17
        lea     si,szWinGDllFile
        rep     movsb
        jmp     short IWM_End
IWM_NoMatch:      
        mov     ax,0
IWM_End:  
cEnd


;
;NOTE: BX preserved because Actor 4.0 depends on this (bug 9078 - neilk)
;
cProc   IGetModuleFileName,<PUBLIC,FAR>,<si,di,bx>
        parmW   hinstance
        parmD   lpname
        parmW   nbytes
cBegin
ifdef WOW
        ; take care of 32bit hInstance. 32bit hInstance has GDT/LDT bit clear
        ; the validation layer will pass such handles as valid so that we can
        ; thunk to 32bit GetModuleFileName if needed.
        ;
        ; in win32 hInstances are not global. therefore fake success by
        ; returning a valid module name for compatibility sake. Naturally,
        ; we will use our module name.

        mov     ax, hInstance
        test    al, 0100b       ; Check for task aliases (see WOLE2.C) or BOGUSGDT
        jnz     GMFName_Normal
        or      ax, ax
        jz      GMFName_Normal
        cCall   MapDStoDATA
assumes DS, DATA
        mov     cx, cFake32BitModuleName
        lea     si, szFake32BitModuleName
        cCall   WowGetModuleFileName, <ax, ds, si, cx>
        mov     cx,ax
        jmps    GMF_CopyName32

GMFName_Normal:
endif
        mov     ax, nbytes
        or      ax, ax
        jz      gfx
        cCall   GetExePtr,<hinstance>
        or      ax,ax
        jz      gfx
        mov     ds,ax
        cCall   IsWinGModule,<hinstance,lpname,nbytes,ax,[bp+4]>
        or     ax, ax
        jnz     gfx
        mov     si,ds:[ne_pfileinfo]
        xor     cx,cx
        mov     cl,ds:[si].opLen
        sub     cx,opFile
        lea     si,[si].opFile
ifdef WOW
GMF_CopyName32:
endif
        les     di,lpname
        cmp     cx,nbytes
        jl      gf1
        mov     cx,nbytes
        dec     cx
gf1:
        cld
        mov     ax,cx
        rep     movsb
        mov     es:[di],cl
gfx:
        mov     cx,ax

        ;** Nasty hack to support QuickWin libs (Fortran, QCWin)
        ;**     The startup code assumes DX will be the segment of the
        ;**     lpname parameter
        mov     dx,WORD PTR lpname[2]
cEnd


        assumes ds,nothing
        assumes es,nothing

cProc   IGetModuleUsage,<PUBLIC,FAR>
        parmW   hinstance
cBegin
ifdef DBCS_KEEP
ifdef WOW
        cCall   MapDStoDATA
        ReSetKernelDS

        call    MyGetAppWOWCompatFlags
        test    ax, 4                       ; WOWCF_AUDITNOTEPAD
        jz      gu_ne

        mov     ax,hModNotepad
        or      ax,ax
        jz      gu_ne

        cmp     ax,hinstance
        jnz     gu_ne

        push    ax
        cCall   WowGetModuleUsage, <0>
        or      ax,ax
        pop     bx
        jnz     gux

        cCall   GlobalFree,<bx>
        jmp     short gux
gu_ne:
endif ; WOW
endif ; DBCS_KEEP
        cCall   GetExePtr,<hinstance>
        or      ax,ax
        jz      gux
got_one:
        mov     es,ax
        mov     ax,es:[ne_usage]
gux:    mov     cx,ax
cEnd


        assumes ds,nothing
        assumes es,nothing

cProc   IGetInstanceData,<PUBLIC,FAR>,<si,di>
        parmW   hinstance
        parmW   psrcdst
        parmW   nbytes
cBegin
        push    ds
        cCall   GlobalHandle,<hinstance>
        pop     es              ; Get caller's DS as destination
        or      dx,dx
        jz      gidone
        mov     ds,dx           ; Source is passed instance
        mov     si,psrcdst      ; Offsets are the same
        mov     di,si
        mov     ax,nbytes
        mov     cx,ax
        jcxz    gidone
        cld
        rep     movsb
        push    es
        pop     ds
gidone: mov     cx,ax
cEnd

sEnd    NRESCODE


sBegin MISCCODE
assumes cs, misccode
assumes ds, nothing
assumes es, nothing

externNP MISCMapDStoDATA

;-----------------------------------------------------------------------;
; MakeProcInstance                                                      ;
;                                                                       ;
; Cons together a far procedure address with a data segment address,    ;
; in the form                                                           ;
;                                                                       ;
;       mov     ax,DGROUP                                               ;
;       jmp     far pproc                                               ;
;                                                                       ;
; This procedure allocates a fixed segment for a set of thunks and      ;
; threads the thunks together on a free list within the segment.        ;
; When a thunk segment is full, a new one is allocated and pushed       ;
; onto the head of the list of thunk segments pointed to by             ;
; TDB_MPI_Thunks.                                                       ;
;                                                                       ;
; Arguments:                                                            ;
;       parmD   pproc                                                   ;
;       parmW   hinstance                                               ;
;                                                                       ;
; Returns:                                                              ;
;       DX:AX = ProcInstance                                            ;
;       CX   != 0                                                       ;
;                                                                       ;
; Error Returns:                                                        ;
;       DX:AX = NULL                                                    ;
;       CX    = 0                                                       ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       DI,SI,DS                                                        ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;       BX,ES                                                           ;
;                                                                       ;
; Calls:                                                                ;
;       MapDStoDATA                                                     ;
;       GlobalAlloc                                                     ;
;       FarMyLock                                                       ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Sat Sep 26, 1987 12:53:58p  -by-  David N. Weise   [davidw]          ;
; ReWrote it a while ago to work with EMS.                              ;
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   IMakeProcInstance,<PUBLIC,FAR>,<si,di>
        parmD   pproc
        parmW   hinstance
cBegin
        SetKernelDSMisc

; We try to prohibit tasks from calling into each other.
;  One way to do this is to not allow one app to MPI for
;  another.

        mov     bx,[bp-2]               ; Warning - assume DS pushed here!
        mov     ax,hinstance            ; if hInstance == NULL,
        or      ax,ax                   ; use caller's DS
        jz      mpi1
        push    bx
        cCall   GlobalHandle,<ax>
        pop     bx
        cmp     dx,bx
        jz      mpi1
        xor     cx,cx
        krDebugOut      DEB_ERROR, "%dx2 MakeProcInstance only for current instance. "
mpi1:   mov     hinstance,bx

; If this is a library DS then it makes absolutely no sense to make a
;  ProcInstance because library prologs setup DS already!  In addition
;  it is assumed in TestDSAX that only task DS's are in ProcInstances.

        cCall   FarGetOwner,<bx>
        mov     es, ax
        NE_check_ES
        mov     dx,pproc.sel
        mov     ax,pproc.off
        test    es:[ne_flags],NENOTP
        jz      @F
        jmp     mpexit                  ; It's a library - return its address
@@:

; now try to get a thunklet

        mov     ax,curTDB
        mov     si,TDB_MPI_Thunks
        mov     es,ax
        mov     ax,es:[TDB_MPI_Sel]
mp2:    mov     es,ax
        mov     bx,es:[si].THUNKSIZE-2
        or      bx,bx
        jz      @F
        jmp     got_a_thunk
@@:     mov     ax,es:[si]              ; Is there another block linked in?
        xor     si,si
        or      ax,ax
        jnz     mp2                     ; Yes, look at it.

; No thunks available, make a block.

        mov     bx,THUNKSIZE * THUNKELEM
        mov     cx,GA_ZEROINIT
        cCall   GlobalAlloc,<cx,ax,bx>
        or      ax,ax
;       jnz     mpx
;       cwd
        jz      mpfail
;mpx:
        mov     bx,ax
        mov     es,curTDB
        xchg    es:[TDB_MPI_Thunks],bx  ; Link the new block in.
        mov     es,ax

; Initialize the new block.

        mov     es:[0],bx
        mov     es:[2],MPIT_SIGNATURE
        mov     bx,THUNKSIZE-2
        mov     cx,THUNKELEM-1
mp1:    lea     dx,[bx+THUNKSIZE]
        .errnz  THUNKELEM and 0FF00h
        mov     es:[bx],dx
        mov     bx,dx
        loop    mp1
        mov     es:[bx],cx
        push    es                      ; make the block into a code segment
        cCall   AllocSelector,<es>
        pop     es
        or      ax, ax
        jnz     @F
                                        ; AllocSelector Failed! Back out.
        mov     bx, es:[0]              ; this is the old thunk val
        mov     ax, es                  ; this is the segment just allocated
        mov     es, curTDB
        mov     es:[TDB_MPI_Thunks], bx ; restore old value
        cCall   GlobalFree,<ax>
mpfail:
        krDebugOut DEB_IERROR, "MakeProcInstance failed.  Did you check return values?"
        xor     ax, ax
        cwd
        jmps    mpexit

@@:     mov     di,ax
        push    es
        cCall   IPrestoChangoSelector,<di,es>
        cCall   FreeSelector,<di>
        pop     ax
        xor     bx,bx
        jmp     mp2

got_a_thunk:

        push    es

; we need a data alias so we can write into this thing

        push    bx
        mov     bx, kr1dsc
        or      bl, SEG_RING
        cCall   IPrestoChangoSelector,<es,bx>
        mov     es,ax
        pop     bx
        mov     ax,es:[bx]
        mov     es:[si].THUNKSIZE-2,ax
        lea     di,[bx-THUNKSIZE+2]

        cld
        mov     dx,di                   ; save offset of thunk
        mov     al,0B8h                 ; mov ax,#
        stosb
        mov     ax,hInstance
        stosw
        mov     al,0EAh                 ; jmp far seg:off
        stosb
        mov     ax,pproc.off
        stosw
        mov     ax,pproc.sel
        stosw
        mov     ax,dx                   ; recover offset of thunk
        pop     dx                      ; recover sel of thunk
mpexit:
        mov     cx,ax
        or      cx,dx
cEnd


;-----------------------------------------------------------------------;
; FreeProcInstance                                                      ;
;                                                                       ;
; Frees the given ProcInstance.                                         ;
;                                                                       ;
; Arguments:                                                            ;
;       parmD   pproc                                                   ;
;                                                                       ;
; Returns:                                                              ;
;       AX != 0 Success                                                 ;
;       CX != 0 Success                                                 ;
;                                                                       ;
; Error Returns:                                                        ;
;       AX == 0 ProcInstance not found.                                 ;
;       CX == 0 ProcInstance not found.                                 ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       DX,DI,SI,DS                                                     ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;       BX                                                              ;
;                                                                       ;
; Calls:                                                                ;
;       nothing                                                         ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Sat Sep 26, 1987 12:25:42p  -by-  David N. Weise   [davidw]          ;
; ReWrote it a while ago to work with EMS.                              ;
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   IFreeProcInstance,<PUBLIC,FAR>,<di>
        parmD   pproc
cBegin

        cCall   MISCMapDStoDATA
        ReSetKernelDS
        mov     ax,curTDB
        mov     es,ax
        mov     ax,es:[TDB_MPI_Sel]
        mov     bx,TDB_MPI_Thunks       ; Point to start of first table.

fp0:    or      ax,ax                   ; Loop through linked tables.
        jz      fpdone
        mov     es,ax                   ; Point to table.
        cmp     ax,pproc.sel            ; This the right ProcInstance table?
        jz      fp1
        mov     ax,es:[bx]              ; No, get next table.
        xor     bx,bx
        jmp     fp0
fp1:

        push    bx
        mov     ax, kr1dsc
        or      al, SEG_RING
        cCall   IPrestoChangoSelector,<es,ax>
        mov     es,ax
        pop     bx
        mov     di,pproc.off            ; Pick off the specific Proc.
        xor     ax,ax
        cld
        stosw                           ; Clear it out!
        stosw
        stosw
        mov     ax,di
        xchg    es:[bx].THUNKSIZE-2,ax  ; Update free list.
        stosw
        mov     ax,-1                   ; Return success.

        cCall   HandleAbortProc, <pproc>
fpdone:
        mov     cx,ax
        UnSetKernelDS

cEnd


        assumes ds, nothing
        assumes es, nothing

cProc   DefineHandleTable,<PUBLIC,FAR>,<di>
        parmW   tblOffset
cBegin
        cCall   FarMyLock,<ds>
        or      ax,ax
        jz      dhtx
        mov     di,tblOffset
        call    MISCMapDStoDATA
        ReSetKernelDS
        push    ds
        mov     ds,curTDB
        UnSetKernelDS
        or      di,di                   ; resetting PHT?
        jnz     @F
        mov     dx,di
@@:     mov     word ptr ds:[TDB_PHT][2],dx
        mov     word ptr ds:[TDB_PHT][0],di
        pop     ds
        ReSetKernelDS
        or      di,di                   ; Is the app removing the PHT?
        jnz     @F                      ;  setting new
        dec     PHTcount                ;  resetting
        jmps    dhtx

@@:     inc     PHTcount                ; bump the count of tasks with PHT's
        assumes ds, nothing
        mov     es,ax
        mov     cx,es:[di]              ; Get word count
        add     di,2                    ; Point to first word

        xor     ax,ax
        inc     cx                      ; new handle table format (skip cwClear)
        cld
        rep     stosw                   ; Zero words in private handle table
        inc     ax
dhtx:
cEnd

sEnd MISCCODE
end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\lddebug.asm ===
TITLE	LDDEBUG - Debugger interface procedures

include kernel.inc
include newexe.inc
include tdb.inc
include protect.inc
include wow.inc
include dbgsvc.inc
include bop.inc
ifdef WOW
include vint.inc
endif

;.386p

HEAPDUMP	=	0

DEBUGOFFSET	equ	000FBH
INTOFFSET	equ	4*3+2

DEBUGCALL MACRO
	call	MyDebugCall
	ENDM

DataBegin

externW	 winVer
externW  wDefRip
externB  Kernel_Flags
externB  Kernel_InDOS
externB  fDW_Int21h
externW	 pGlobalHeap
externW  hGlobalHeap
externD  ptrace_dll_entry
externD  lpfnToolHelpProc
externD  pKeyboardSysReq
externW  curTDB
externW  wExitingTDB
externW	<Win_PDB, topPDB>

ifdef WOW
externD  FastBop
externW  DebugWOW
externW  hExeHead
externW  gdtdsc
endif; WOW

debugseg	dw	0

IF KDEBUG
externB fKTraceOut
ENDIF

DataEnd

ifdef WOW
externFP GetModuleFileName
externFP GetModuleHandle
externFP WOWOutputDebugString
externFP WOWNotifyTHHOOK
endif
ifdef FE_SB
; _TEXT code segment is over flow with debug 386 version
; GetOwnerName moves to _MISCTEXT from _TEXT segment with DBCS flag
externFP FarGetOwner
endif ; FE_SB

sBegin	CODE
assumes CS,CODE

externNP get_arena_pointer32


externNP GetOwner
externNP genter
externNP get_physical_address
externNP ValidatePointer

sEnd 	CODE


sBegin	INITCODE
assumes CS,CODE
assumes DS,NOTHING
assumes ES,NOTHING
			

;-----------------------------------------------------------------------;
; debuginit								;
;									;
; Returns a non zero value in AX if debugger is resident.		;
; If the debugger is present a distinquished string of "SEGDEBUG",0	;
; will be found at 100H off of the interrupt vector segment (int 3).	;
;									;
; Arguments:								;
;	None.								;
;									;
; Returns:								;
;	AX =! 0 if debugger resident.					;
;									;
; Error Returns:							;
;									;
; Registers Preserved:							;
;									;
; Registers Destroyed:							;
;									;
; Calls:								;
;									;
; History:								;
;									;
;  Thu Nov 13, 1986 02:03:51p  -by-  David N. Weise   [davidw]		;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	DebugInit,<PUBLIC,NEAR>,<es,si,di>
cBegin

	CheckKernelDS
	ReSetKernelDS

	DebInt	4fh

	cmp	ax, 0F386h
	jne	short no_debugger
	inc	debugseg
	or	Kernel_flags[2],KF2_SYMDEB
no_debugger:

cEnd


;-----------------------------------------------------------------------;
; DebugDebug
;
;
; Entry:
;
; Returns:
;
; Registers Destroyed:
;
; History:
;  Tue 21-Jun-1988 13:10:41  -by-  David N. Weise  [davidw]
;
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	DebugDebug,<PUBLIC,NEAR>

cBegin nogen

	push	ds
	SetKernelDS

ifdef WOW
        call    WOWNotifyTHHOOK

; Tell the debugger where it can poke around for kernel data structure info

        mov     cx, hGlobalHeap
        mov     dx, hExeHead
        push    DBG_WOWINIT
        FBOP    BOP_DEBUGGER,,FastBop
        add     sp,+2
else

	test	Kernel_Flags[2],KF2_SYMDEB or KF2_PTRACE
	jz	short dd_done

; Tell the debugger where it can poke around for kernel data structure info

	push	ax
	push	bx
	push	cx
	push	dx
	mov	bx,winVer
	mov	cx,dataOffset hGlobalHeap
	mov	dx,ds
	DebInt	5ah
	pop	dx
	pop	cx
	pop	bx
	pop	ax
	UnSetKernelDS
dd_done:
endif
	pop	ds
	ret

cEnd nogen

;-----------------------------------------------------------------------;
; DebugSysReq
;
; tell the keyboard driver to pass sys req through
;
; Entry:
;
; Returns:
;
; Registers Destroyed:
;
; History:
;  Tue 19-Sep-1989 21:42:02  -by-  David N. Weise  [davidw]
; Wrote it!
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	DebugSysReq,<PUBLIC,NEAR>
cBegin nogen

	CheckKernelDS
	ReSetKernelDS
	mov	ax,debugseg
	or	ax,ax
	jz	short dwr_ret
	cmp	pKeyboardSysReq.sel,0	; is there a keyboard driver?
	jz	short dwr_ret
	mov	ax,1			; use int 2
	cCall	pKeyboardSysReq,<ax>
dwr_ret:
	ret

cEnd nogen


sEnd	INITCODE


ifdef FE_SB
sBegin	MISCCODE
assumes CS,MISCCODE
else ; !FE_SB
sBegin	CODE
assumes CS,CODE
endif ; !FE_SB
assumes DS,NOTHING
assumes ES,NOTHING


; Copyright (c) Microsoft Coropration 1989-1990. All Rights Reserved.

;
; Stolen from DOSX\DXBUG.ASM
;


; -------------------------------------------------------
;           GENERAL SYMBOL DEFINITIONS
; -------------------------------------------------------

Debug_Serv_Int	equ	41h		;WDEB386 service codes
DS_Out_Char	equ	0
DS_Out_Symbol	equ	0fh


; Find owner of 'sel', copy name to buffer, zero terminate name
; return count of chars copied, or 0.

cProc	GetOwnerName,<PUBLIC,FAR>,<ds, si, di>
	parmW	obj
	parmD	buf
	parmW	buflen
cBegin
	push	[obj]
ifdef FE_SB
	call	FarGetOwner
else ; !FE_SB
	call	GetOwner
endif ; !FE_SB
	or	ax, ax
	jz	gon_exit

	mov	ds, ax			; DS:SI points to name
	xor	ax, ax
	cmp	word ptr ds:[0], NEMAGIC
	jnz	gon_exit
	mov	si, ds:[ne_restab]
	lodsb				; get length
	cmp	ax, [buflen]		; name must be smaller than buf
	jb	@F
	mov	ax, [buflen]
	dec	ax
@@:	mov	cx, ax
	cld
	les	di, [buf]
	rep	movsb
	mov	byte ptr es:[di], 0
gon_exit:
cEnd

ifdef FE_SB
sEnd MISCCODE

sBegin	CODE
assumes CS,CODE
assumes DS,NOTHING
assumes ES,NOTHING
endif ; FE_SB

;******************************************************************************
;
;   KOutputDebugStr
;
;   Basically stolen from Windows/386 code by Ralph Lipe -- hacked up for
;   286 instead of 386.  Here in RalphL's own words is the description:
;
;   DESCRIPTION:
;	The following code is not pretty but it does what it needs to.	It will
;	only be included in DEBUG versions of Kernel.  It accepts an ASCIIZ
;	string which it will output to the COM1 serial port.  If the string
;	contains #(Register) (for example #AX) then the value of that register
;	will be output.  It will not work for segment registers.
;
;	If the string contains ?(Register)[:(Register)] (for example ?AX or
;	?AX:BX) then the value of the register(s) is passed to the debugger
;	to display the label nearest to the given address.  (It, also, will
;	not work with segment registers.  If ?AX is given, then the segment is
;	assumed to be the DS data segment.
;
;	Lower case register forces skip leading zeros.
;
;   ENTRY:
;	DS:SI -> ASCIIZ string
;
;   EXIT:
;	All registers and flags trashed
;
;   ASSUMES:
;	This procedure was called by the Trace_Out macro.  It assumes that
;	the stack is a pusha followed by a FAR call to this procedure.
;
;------------------------------------------------------------------------------


Reg_Offset_Table LABEL WORD			; Order of PUSHA
	dw	"DI"
	dw	"SI"
	dw	"BP"
	dw	"SP"
	dw	"BX"
	dw	"DX"
	dw	"CX"
	dw	"AX"
	dw	"SS"
	dw	"ES"
	dw	"DS"
	dw	"CS"

OSC1_ModName:
	pop	ax
OSC1_ModName1:
	push	es
	mov	es, ax
	cmp	word ptr es:[0], NEMAGIC
	jz	@F
	pop	es
	jmps	is_pdb
@@:	mov	cx, es:[ne_restab]
	inc	cx			; skip length byte
	pop	es
	jmp	Show_String		; AX:CX -> string to print

OSC1_FileName:
	pop	ax
	push	es
	mov	es, ax
	mov	cx, word ptr es:[ne_crc+2]
	add	cx, 8
	pop	es
	jmp	Show_String

szUnk	db	'Unknown',0

OSC1_OwnerName:
	pop	ax
	push	ds
	push	ax
	cCall	GetOwner		; seg value already on stack
	pop	ds
	or	ax, ax
	jnz	OSC1_ModName1
is_pdb:	mov	ax, cs
	mov	cx, CodeOffset szUnk
	jmp	Show_String

OSC1_Custom:
	call	Get_Register
	jnc	short OSC1_not_special
	or	ax, ax
	jz	short OSC1_not_special
	push	ax
	lodsb
	cmp	al, '0'
	jz	short OSC1_ModName
	cmp	al, '1'
	jz	short OSC1_FileName
	cmp	al, '2'
	jz	short OSC1_OwnerName
	pop	ax
	jmps	OSC1_not_special



	public	KOutDebugStr

KOutDebugStr	proc	far
	push	bp
	mov	bp, sp			    ; Assumes BP+6 = Pusha
	sub	sp, 84			; local 80 char line + count
odslen	equ	word ptr [bp-2]
odsbuf	equ	byte ptr [bp-82]
odszero	equ	word ptr [bp-84]	; flag - true if skip leading zero
odsflag	equ	word ptr [bp-86]	; last local var - from pushf
	mov	odslen, 0
	pushf
	push	es

	push	cs			    ; Address our own data seg
	pop	es
	assumes	ds,NOTHING
	assumes	es,code

	cld
        FCLI

OSC1_Loop:
	lodsb				    ; Get the next character
	test	al, al			    ; Q: End of string?
	jz	short OSC1_Done 	    ;	 Y: Return
	push	codeoffset OSC1_Loop
	cmp	al, "#" 		    ;	 N: Q: Special register out?
	je	SHORT OSC1_Hex		    ;	       Y: Find out which one
	cmp	al, "?" 		    ;	    Q: special label out?
	je	short OSC1_Label	    ;	       Y: find out which one
	cmp	al, "@" 		    ;	    Q: special string out?
	je	short OSC1_Str
	cmp	al, "%"			; Custom value?
	je	short OSC1_Custom
OSC1_out:
	xor	ah, ah			    ;	       N: Send char to COM
	jmp	Out_Debug_Chr

OSC1_Hex:
	call	Get_Register
	jnc	short OSC1_not_special

	or	bh, bh 			    ; Q: Word output?
	jz	SHORT OSC1_Out_Byte	    ;	 N: display byte
OSC1_Out_Word:
	jmp	Out_Hex_4_test		; Display AX in hex

OSC1_Out_Byte:
	xchg	al, ah			    ; swap bytes to print just
        jmp     Out_Hex_2_test              ; the low one!

OSC1_Label:
	call	Get_Register
	jc	short show_label
OSC1_not_special:
	lodsb				    ; Get special char again
	jmp	OSC1_out		    ; display it, and continue

show_label:
	mov	cx, ax			    ; save first value
	cmp	byte ptr [si], ':'	    ;Q: selector separator?
	jne	short flat_offset	    ;  N:
	lodsb				    ;  Y: eat the ':'
	call	Get_Register		    ;	and attempt to get the selector
	jc	short sel_offset
flat_offset:
	mov	ax, cs			    ; default selector value
sel_offset:
	jmp	Show_Near_Label

OSC1_Str:
	call	Get_Register
	jnc	short OSC1_not_special
	mov	cx,ax
	cmp	byte ptr [si],':'
	jne	short no_selector
	lodsb
	push	cx
	call	Get_Register
	pop	cx
	xchg	ax,cx
	jc	short got_sel_off
	mov	cx,ax
no_selector:
	mov	ax,ds			    ; default selector for strings
got_sel_off:
	jmp	Show_String

OSC1_Done:				    ; The end
	xor	ax, ax			; flush buffer
	call	Out_Debug_Chr
	pop	es
	test	odsflag, 200h
	jz	short @F
        FSTI
@@:
	popf
	leave
	ret

KOutDebugStr	endp


;******************************************************************************
;
;   Get_Register
;
;   DESCRIPTION:
;
;   ENTRY:
;
;   EXIT:	    Carry set if register value found
;			AX = register value
;			BL = value size   (1, 2, 4) (no longer true - donc)
;
;   USES:
;
;==============================================================================


Get_Register	proc	near
	lodsw				; get next pair of letters
	mov	bx, ax
	and	bx, 2020h
	mov	[odszero], bx
	and	ax, 0dfdfh		; to upper case
	xchg	ah, al			; normal order (or change table?)
	or	bx, -1			; BH = -1
	cmp	al, 'L' 		; Q: "L" (ie AL, BL, etc)?
	jne short @F			;	 N: word reg
	mov	al, 'X' 		;	 Y: change to X for pos match
	inc	bh			; BH now 0 - will clear AH below
@@:
	xor	di, di			    ; DI = 0
	mov	cx, 12			    ; Size of a pusha + 4 seg regs

OSC1_Special_Loop:
	cmp	ax, Reg_Offset_Table[di]    ; Q: Is this the register?
	je	SHORT OSC1_Out_Reg	    ;	 Y: Output it
	add	di, 2			    ;	 N: Try the next one
	loop	OSC1_Special_Loop	    ;	    until CX = 0
	sub	si, 3			; restore pointer, clear carry
	ret

OSC1_Out_Reg:
	mov	ax, SS:[bp.6][di]	    ; AX = Value to output
	and	ah, bh			; if xL, zero out high byte
	stc
	ret

Get_Register	endp


;******************************************************************************
;
;   Out_Hex_Word
;
;   Outputs the value in AX to the COM port in hexadecimal.
;
;------------------------------------------------------------------------------

Out_Hex_2_test:				; Write two chars
	xor	ah, ah
	cmp	[odszero], 0		; skip leading 0's?
	je	Out_Hex_2		; no, show 2 chars
					; yes, fall through
Out_Hex_4_test:
	cmp	[odszero], 0
	je	Out_Hex_4
	test	ax, 0fff0h
	jz	Out_Hex_1
	test	ah, 0f0h
	jnz	Out_Hex_4
	test	ah, 0fh
	jz	Out_Hex_2
Out_Hex_3:
	xchg	al, ah
	call	Out_Hex_1
	xchg	al, ah
	jmps	Out_Hex_2

Out_Hex_4:
	xchg	al, ah
	call	Out_Hex_2
	xchg	al, ah
Out_Hex_2:
	push	ax
	shr	ax, 4
	call	Out_Hex_1
	pop	ax
Out_Hex_1:
	push	ax
	and	al, 0fh
	cmp	al, 10
	jb	@F
	add	al, '@'-'9'
@@:	add	al, '0'
	call	Out_Debug_Chr
	pop	ax
	ret

;******************************************************************************
;
;   Out_Debug_Chr
;
;   DESCRIPTION:
;
;   ENTRY:
;	AL contains character to output
;
;   EXIT:
;
;   USES:
;	Nothing
;
;==============================================================================

Out_Debug_Chr	proc	near

	push	di
	mov	di, odslen
	mov	odsbuf[di], al		; store in buffer (in stack)
	or	al, al
	jz short odc_flushit		; if null, flush buffer
	inc	odslen
	cmp	di, 79			; if full, flush buffer
	jnz short odc_ret

odc_flushit:
	mov	odsbuf[di], 0		; null terminate string
	lea	di, odsbuf
ifdef WOW
	cCall	<far ptr DebugWrite>,<ssdi,odslen>
else
	cCall	DebugWrite,<ssdi,odslen>
endif
	mov	odslen, 0
odc_ret:
	pop	di
	ret

Out_Debug_Chr	endp


;******************************************************************************
;
;   Show_Near_Label
;
;   DESCRIPTION:    call the debugger to display a label less than or equal
;		    to the given address
;
;   ENTRY:	    AX is selector, CX is offset of address to try to find
;		    a symbol for
;		    ES selector to DOSX data segment
;   EXIT:
;
;   USES:
;
;==============================================================================

Show_Near_Label proc	near

	push	ax				;on a 286, use 16 bit regs
	push	bx
	push	cx
	mov	bx,cx
	mov	cx,ax
	mov	ax,DS_Out_Symbol
	int	Debug_Serv_Int
	pop	cx
	pop	bx
	pop	ax
	ret

Show_Near_Label endp


;******************************************************************************
;
;   Show_String
;
;   DESCRIPTION:    Display an asciiz string
;
;   ENTRY:	    AX is selector, CX is offset of address to find string
;
;   EXIT:
;
;   USES:
;
;==============================================================================

Show_String	proc	near

	push	ax
	push	ds
	push	si

	mov	ds,ax
	mov	si,cx
	xor	ax,ax
	cmp	byte ptr ds:[si], ' '
	jbe	pascal_show_string
@@:
	lodsb
	or	al,al
	jz	short @f
	call	Out_Debug_Chr
	jmp	short @b
@@:
	pop	si
	pop	ds
	pop	ax

	ret

pascal_show_string:
	push	cx
	lodsb
	mov	cl, al
	xor	ch, ch
pss_1:	lodsb
	call	Out_Debug_Chr
	loop	pss_1
	pop	cx
	jmps	@B

Show_String endp

; END OF DXBUG STUFF



;-----------------------------------------------------------------------;
; CVWBreak
;
; This is part of the tortuous path from a Ctrl-Alt-SysReq to
; CVW.	In RegisterPtrace we tell the keyboard driver to jump
; here if Ctrl-Alt_SysReq is done.
;
; Entry:
;	none
;
; Returns:
;
; Registers Destroyed:
;	none
;
; History:
;  Mon 17-Jul-1989 14:34:21  -by-  David N. Weise  [davidw]
; Wrote it!
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	CVWBreak,<PUBLIC,FAR>
cBegin nogen

	push	ax
	push	di
	push	ds
	SetKernelDS
	test	Kernel_flags[2],KF2_PTRACE
	jz	short call_WDEB
	cmp	Kernel_InDOS,0		; not in DOS we don't
	jnz	short TVC15_exit
	.386p
	push	fs			; save current FS for debuggers
	.286p
	call	genter			; sets FS to kernel data seg
	UnSetKernelDS
	.386p
	pop	fs
	.286p
	dec	[di].gi_lrulock
	jz	short call_PTrace
	or	[di].gi_flags,GIF_INT2
	jmps	TVC15_exit

call_PTrace:
	SetKernelDS
	cmp	ptrace_DLL_entry.sel,0
	jnz	short yes_CVW

        ;** This is the only case where WINDEBUG gets first dibs something.
        ;*      Since we have no way of knowing if TOOLHELP wants the
        ;**     CtlAltSysRq, we always give it to CVW if it's there.
        test    Kernel_Flags[2],KF2_TOOLHELP
        jz      SHORT call_WDEB
        mov     ax,SDM_INT2             ;Notification number
        call    lpfnToolHelpProc        ;Give it to TOOLHELP
        jmp     SHORT TVC15_exit

        ;** Give it to the kernel debugger
call_WDEB:
	pop	ds
	UnSetKernelDS
	pop	di
	pop	ax

	int	1
	iret

        ;** Give it to CVW
yes_CVW:
	ReSetKernelDS
	mov	ax,SDM_INT2
	call	ptrace_DLL_entry
TVC15_exit:
	pop	ds
	UnSetKernelDS
	pop	di
	pop	ax
	iret

cEnd nogen



;-----------------------------------------------------------------------;
; DebugDefineSegment							;
;									;
; Informs debugger of physical address and type of a segment for the	;
; named module, that is informed of segment index and corresponding	;
; name and physical segment.						;
;									;
; Arguments:								;
;	ModName	    - Long pointer to module name.			;
;	SegNumber   - zero based segment index				;
;	LoadedSeg   - Physical seg address assigned by user to index.	;
;	InstanceNumber	- Windows instance number bound to physical seg.;
;	DataOrCodeFlag	- Whether segment is code or data.		;
;									;
; Returns:								;
;	None.								;
;									;
; Error Returns:							;
;									;
; Registers Preserved:							;
;									;
; Registers Destroyed:							;
;									;
; Calls:								;
;									;
; History:								;
;									;
;  Thu Nov 13, 1986 02:20:52p  -by-  David N. Weise   [davidw]		;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

default_buf_size    equ 130

cProc  DebugDefineSegment,<PUBLIC,NEAR>,<es>
	Parmd	ModName
	Parmw	SegNumber
	Parmw	LoadedSeg
	Parmw	InstanceNumber
        Parmw   DataOrCodeFlag
        localV  modBuf,default_buf_size
        localV  nameBuf,default_buf_size
cBegin
        SetKernelDS es
	test	Kernel_Flags[2],KF2_SYMDEB or KF2_PTRACE
	jz	short setdone
	push	bx
	push	cx
	push	dx
	push	si
	push	di
	les	di, ModName
	UnSetKernelDS es
	mov	bx, SegNumber
	mov	cx, LoadedSeg
	mov	dx, InstanceNumber
	mov	si, DataOrCodeFlag
	mov	ax,SDM_LOADSEG
	DEBUGCALL
	pop	di
	pop	si
	pop	dx
	pop	cx
	pop	bx
setdone:

ifdef WOW

	SetKernelDS es
        test    es:DebugWOW,DW_DEBUG
        jnz     @f
        jmp     dd_no_wdebug
	UnSetKernelDS es
@@:

        push    ds
	push	bx
	push	cx
	push	dx
	push	si
        push    di

        lds     si, ModName
        mov     cx,ds:[ne_magic]
        cmp     cx,NEMAGIC
        jz      @f
        jmp     not_yet

@@:     mov     cx,ss
        mov     es,cx
        lea     di,modBuf
        xor     cx,cx
        mov     cl,byte ptr [si-1]          ; Get length byte
        cmp     cx,default_buf_size
        jl      @f
        mov     cx,default_buf_size-1
@@:
        rep movsb                           ; Copy the string

        xor     ax,ax

        stosb

        mov     si,ds:[ne_pfileinfo]
        mov     cl,ds:[si].opLen
        sub     cx,opFile
        lea     si,[si].opFile
        lea     di,nameBuf
        cmp     cx,default_buf_size
        jl      @f
        mov     cx,default_buf_size-1
@@:
        rep movsb                           ; Copy the string

        stosb

	SetKernelDS es

        push    DataOrCodeFlag
        lea     si,nameBuf
        push    ss
        push    si
        lea     si,modBuf
        push    ss
        push    si
        push    SegNumber
        push    LoadedSeg
        push    DBG_SEGLOAD
	FBOP BOP_DEBUGGER,,FastBop
        add     sp,+16

not_yet:
        pop     di
        pop     si
        pop     dx
        pop     cx
        pop     bx
        pop     ds
	UnSetKernelDS

dd_no_wdebug:

endif

cEnd

;-----------------------------------------------------------------------;
; DebugMovedSegment							;
;									;
; Informs debugger of the old and new values for a physical segment.	;
;									;
; Arguments:								;
;	SourceSeg - Original segment value.				;
;	DestSeg	  - New segment value.					;
;									;
; Returns:								;
;	None.								;
;									;
; Error Returns:							;
;									;
; Registers Preserved:							;
;									;
; Registers Destroyed:							;
;									;
; Calls:								;
;									;
; History:								;
;									;
;  Thu Nov 13, 1986 02:29:15p  -by-  David N. Weise   [davidw]		;
; Wrote it.								;
;-----------------------------------------------------------------------;

cProc	DebugMovedSegment,<PUBLIC,NEAR>
	ParmW	SourceSeg
	ParmW	DestSeg
cBegin
cEnd


;-----------------------------------------------------------------------;
; DebugFreeSegment							;
;									;
; Informs debugger that a segment is being returned to the global	;
; memory pool and is no longer code or data.				;
;									;
; Arguments:								;
;	SegAddr - segment being freed					;
;	fRelBP	- flag indicating if breakpoints should be released,	;
;		  -1 means yes						;
;									;
; Returns:								;
;	None.								;
;									;
; Error Returns:							;
;									;
; Registers Preserved:							;
;									;
; Registers Destroyed:							;
;									;
; Calls:								;
;									;
; History:								;
;									;
;  Thu Nov 13, 1986 02:34:13p  -by-  David N. Weise   [davidw]		;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

cProc	DebugFreeSegment,<PUBLIC,NEAR>,<es>
	Parmw	SegAddr
	parmW	fRelBP
cBegin
	push	ds
	SetKernelDS
ifdef WOW
        test    DebugWOW,DW_DEBUG
        jz      df_no_wdebug

        push    SegAddr             ; Notify the Win32 debugger that
        push    fRelBP
        mov     ax,DBG_SEGFREE      ; the selector number needs to be freed
        push    ax
	FBOP BOP_DEBUGGER,,FastBop
        add     sp,+6

df_no_wdebug:
endif
	test	Kernel_Flags[2],KF2_SYMDEB or KF2_PTRACE
	pop	ds
	UnSetKernelDS
	jz	short killdone
	mov	bx, SegAddr
	mov	ax, SDM_FREESEG
	inc	fRelBP
	jnz	short @f
	mov	ax, SDM_RELEASESEG	;free but pulls out breakpoints 1st
@@:
	DEBUGCALL
killdone:
cEnd


;-----------------------------------------------------------------------;
; DebugWrite								;
;									;
; Prints the given string of the given length.	If a debugger is	;
; present tells the debugger to print the message.  Otherwise uses	;
; DOS Function 40h to the con device.					;
;									;
; Arguments:								;
;	lpBuf	long pointer to string to write				;
;	nBytes	# of bytes in string					;
;									;
; Returns:								;
;	None.								;
;									;
; Error Returns:							;
;									;
; Registers Preserved:							;
;									;
; Registers Destroyed:							;
;									;
; Calls:								;
;									;
; History:								;
;									;
;  Thu Nov 13, 1986 02:53:08p  -by-  David N. Weise   [davidw]		;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

ifdef WOW
cProc	DebugWrite,<PUBLIC,FAR>,<ds,si>
else
cProc	DebugWrite,<PUBLIC,NEAR>,<ds,si>
endif
	parmD   lpBuf
	parmW   nBytes
	localW  wHandled
	localW	SavePDB

cBegin
	;** Validate the pointer and number of bytes

	mov	ax,WORD PTR lpBuf[0]
	add	ax,nBytes
	jnc     SHORT @F
	jmp	DW_End		;Overflow: error
@@:
	.386
	push	eax		; 32 bit ValidatePointer destroys top half
	push	ecx		;   of eax, ecx which isn't nice in debug outs
	.286
	push	WORD PTR lpBuf[2]
	push	ax
	call	ValidatePointer ;Make sure pointer is OK
	or	ax,ax
	.386
	pop	ecx
	pop	eax
	.286
	jnz     SHORT @F
	jmp     DW_End          ;Bogus pointer: just return.
@@:     mov	cx,nBytes
	lds	dx,lpBuf        ;DS:DX points to string
	or      cx,cx           ;Zero length requires computing
	jnz     SHORT DW_GoodLen

	;** Compute string length if a valid length not passed in
	mov	si,dx
	cld
DW_LenLoop:
	lodsb
	or	al,al
	jnz	short DW_LenLoop
	mov	cx,si
	sub	cx,dx
	dec	cx
DW_GoodLen:

	;** Set up for the Int 41h, PTrace, and TOOLHELP interfaces
	mov     wHandled,0      ;Flag that we haven't handled yet
	mov     si,dx           ;Point to string with DS:SI
	push    ds              ;  and ES:SI
	pop     es

	;** Decide which debugger (if any) to send string to

	push	ds
	SetKernelDS
	test	Kernel_Flags[2],KF2_SYMDEB ;WDEB386 loaded?
	pop	ds
	UnSetKernelDS
	jz	SHORT DW_TryToolHelp  ;No, now try TOOLHELP

	;** Send to WDEB386
        push    si
	DebInt	SDM_CONWRITE
        pop     si
	mov     wHandled,1      ;Assume that WDEB386 handled it

        ;** Send it to TOOLHELP if it is there
DW_TryToolHelp:
        push    ds
        SetKernelDS
        test    Kernel_Flags[2],KF2_TOOLHELP ;ToolHelp around?
	pop     ds
	UnSetKernelDS
        jz      SHORT DW_TryPTrace      ;Nope, now try PTrace

        push    ds
        SetKernelDS

        push    Win_PDB                 ;Save current PDB
        cmp     curTDB,0
        jz      @F
        push    es                      ; and set to current task's PDB
        mov     es,curTDB               ; for toolhelp call.
        push    es:[TDB_PDB]
        pop     ds:Win_PDB
        pop     es
@@:
	mov	ax,SDM_CONWRITE 	;Notification ID
	call    lpfnToolHelpProc        ;String in ES:SI for TOOLHELP

        pop     Win_PDB                 ;Restore current PDB

	or      ax,ax                   ;TOOLHELP client say to pass it on?

	pop     ds
	UnSetKernelDS
	jnz     SHORT DW_End            ;No, we're done

	;** Handle PTrace
DW_TryPTrace:
	SetKernelDS es
	cmp	WORD PTR es:ptrace_dll_entry[2],0 ;WINDEBUG.DLL lurking around?
	jz      SHORT DW_WriteToCOM     ;No, try COM port

        ;** If we're exiting a task, don't send the debug write to PTrace.
        ;**     This is a gross hack for QCWin who chokes on these.  These
        ;**     were being sent because of parameter validation errors.
        push    ax                      ;Temp reg
        mov     ax,es:curTDB
        cmp     ax,es:wExitingTDB
        pop     ax
        je      DW_WriteToCOM           ;Write out directly

IF KDEBUG
        ;** If we're sending a KERNEL trace out, we don't want to send this
        ;**     to PTrace, either
        cmp     fKTraceOut, 0           ;Are we doing a KERNEL trace out?
        jne     DW_WriteToCOM           ;Yes, don't call PTrace
ENDIF

        ;** Now send to PTrace
	mov     wHandled,1              ;Assume WINDEBUG handles if present
	push    ax                      ;Save regs PTrace might trash
	push    si
	push    dx
	push    ds
	push    es
	mov	ax,SDM_CONWRITE ;Notification ID
	call    es:ptrace_DLL_entry        ;Do the PTrace thing
	pop     es
	pop     ds
	pop     dx
	pop     si
	pop     ax

	;** Write string to debug terminal
DW_WriteToCOM:
	cmp     wHandled,0              ;Handled?
	jnz	SHORT DW_End		;Yes

        inc     es:fDW_Int21h              ; Skip it if user has canceled
	jnz	SHORT DW_Skip_Write	;   a crit error on this before

        mov     ax, es:topPDB
        xchg    es:Win_PDB, ax          ; Switch to Kernel's PDB,
	mov	SavePDB, ax		; saving current PDB

ifdef WOW
	cCall	WOWOutputDebugString,<lpBuf>
else
	mov	bx,3                    ;Send to DOS AUX port
	mov	ah,40h
	int	21h
endif; WOW

	mov	ax, SavePDB
        mov     es:Win_PDB, ax          ; restore app pdb

DW_Skip_Write:
        dec     es:fDW_Int21h
DW_End:
        UnSetKernelDS
        UnSetKernelDS   es
cEnd

;-----------------------------------------------------------------------;
; OutputDebugString							;
;									;
; A routine callable from anywhere since it is exported.  It calls	;
; DebugWrite to do its dirty work.					;
;									;
; Arguments:								;
;	lpStr	long pointer to null terminated string			;
;									;
; Returns:								;
;	none								;
;									;
; Error Returns:							;
;									;
; Registers Preserved:							;
;	all								;
;									;
; Registers Destroyed:							;
;									;
; Calls:								;
;									;
; History:								;
;									;
;  Tue June 28, 1988	       -by-  Ken Shirriff     [t-kens]		;
; Made it save all the registers.					;
;									;
;  Thu Nov 13, 1986 02:54:36p  -by-  David N. Weise   [davidw]		;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

cProc	OutputDebugString,<PUBLIC,FAR,NODATA>,<es>
	parmD   lpStr
cBegin
	pusha
ifdef WOW
	cCall	<far ptr DebugWrite>,<lpStr, 0>
else
	cCall	DebugWrite,<lpStr, 0>
endif
	popa
cEnd


;-----------------------------------------------------------------------;
; DebugRead								;
;									;
; Gets a character from either the debugger (if one is present) or	;
; from the AUX.								;
;									;
; Arguments:								;
;	none								;
;									;
; Returns:								;
;	AL = character							;
;									;
; Error Returns:							;
;									;
; Registers Preserved:							;
;									;
; Registers Destroyed:							;
;									;
; Calls:								;
;									;
; History:								;
;									;
;  Thu Nov 13, 1986 02:55:09p  -by-  David N. Weise   [davidw]		;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

cProc	DebugRead,<PUBLIC,NEAR>
cBegin	nogen
	push	ds
	SetKernelDS

	;** Send it to the debugger(s) FIRST
	mov	ax,SDM_CONREAD  ;Get the notification ID


	; This sure is weird!  Goal is to ask if WDEB386 has a char
	; available.  If so, return.
	; We do the check here because MyDebugCall assumes INT41
	; doesn't modify registers, but the CONREAD call does.
	; This was hosing TOOLHELP, since we were passing a different
	; function to TOOLHELP based on what char a user was pressing.

	test	Kernel_Flags[2],KF2_SYMDEB	; WDEB386 loaded?
	jz	short dr_symdeb		; no - MyDebugCall
	DebInt				; Yes - read CON
	cmp	ax, SDM_CONREAD
	jnz	@F			; got a response - continue.

dr_symdeb:
	DEBUGCALL
@@:
	;** See if we should still hand it to the AUX port
	cmp     al,SDM_CONREAD  ;If not changed, we didn't get a character
	jne     SHORT DR_End

	mov	ax, wDefRIP	;Do we have a default value to use?
	or	ax, ax
	jnz	DR_End

        xor     cx,cx           ;Allocate WORD to read into
        push    cx
        mov     dx,sp           ;Point with DS:DX
	push    ss
        pop     ds
        inc     cx              ;Get one byte
DR_ConLoop:
ifdef WOW
	int 3			; BUGBUG mattfe 29-mar-92, should be thunked to 32 bit side.
endif
        mov     bx,3            ;Use AUX
	mov     ah,3fh          ;Read device
        int     21h             ;Call DOS
        cmp     ax,cx           ;Did we get a byte?
	jne     SHORT DR_ConLoop ;No, try again
        pop     ax              ;Get the byte read

DR_End:
	pop	ds
	ret

cEnd	nogen

;-----------------------------------------------------------------------;
; DebugDefineLine							;
;									;
; Notifies debugger of the location of The Line.			;
;									;
; Arguments:								;
;	None								;
;									;
; Returns:								;
;	None								;
;									;
; Registers Destroyed:							;
;									;
; History:								;
;  Mon 20-Jun-1988 13:17:41  -by-  David N. Weise  [davidw]		;
; Moved it here.							;
;-----------------------------------------------------------------------;
;
;	assumes ds,nothing
;	assumes es,nothing
;
;cProc	DebugDefineLine,<PUBLIC,NEAR>
;
;cBegin nogen
;	ret
;cEnd nogen
;
;cProc FarDebugNewTask,<PUBLIC,FAR>
;
;cBegin nogen
;	call	DebugNewTask
;	ret
;cEnd nogen
;
;
;-----------------------------------------------------------------------;
; DebugNewTask								;
;									;
;									;
; Arguments:								;
;	AX = EMS PID							;
;									;
; Returns:								;
;	None								;
;									;
; Error Returns:							;
;									;
; Registers Preserved:							;
;									;
; Registers Destroyed:							;
;									;
; Calls:								;
;									;
; History:								;
;									;
;-----------------------------------------------------------------------;
;
;cProc	DebugNewTask,<PUBLIC,NEAR>
;
;cBegin nogen
;	ret
;cEnd nogen
;
;cProc FarDebugFlushTask,<PUBLIC,FAR>
;
;cBegin nogen
;	call DebugFlushTask
;	ret
;cEnd nogen
;
;-----------------------------------------------------------------------;
; DebugFlushTask							;
;									;
;									;
; Arguments:								;
;	AX = EMS PID							;
;									;
; Returns:								;
;	None								;
;									;
; Error Returns:							;
;									;
; Registers Preserved:							;
;									;
; Registers Destroyed:							;
;									;
; Calls:								;
;									;
; History:								;
;									;
;-----------------------------------------------------------------------;
;
;cProc	DebugFlushTask,<PUBLIC,NEAR>
;
;cBegin nogen
;	ret
;cEnd nogen


;-----------------------------------------------------------------------;
; DebugSwitchOut							;
;									;
;									;
; Arguments:								;
;	DS = TDB							;
;									;
; Returns:								;
;	None								;
;									;
; Error Returns:							;
;									;
; Registers Preserved:							;
;	All								;
;									;
; Registers Destroyed:							;
;									;
; Calls:								;
;									;
; History:								;
;									;
;-----------------------------------------------------------------------;

cProc	DebugSwitchOut,<PUBLIC,NEAR>

cBegin nogen
	push	ds
	SetKernelDS
	test	Kernel_Flags[2],KF2_PTRACE
	pop	ds
	UnSetKernelDS
	jz	short dso_done

	push	ax
	mov	ax,SDM_SWITCHOUT
	DEBUGCALL
	pop	ax
dso_done:
	ret
cEnd nogen

;-----------------------------------------------------------------------;
; DebugSwitchIn								;
;									;
;									;
; Arguments:								;
;	DS = TDB							;
;									;
; Returns:								;
;	None								;
;									;
; Error Returns:							;
;									;
; Registers Preserved:							;
;	All								;
;									;
; Registers Destroyed:							;
;									;
; Calls:								;
;									;
; History:								;
;									;
;-----------------------------------------------------------------------;

cProc	DebugSwitchIn,<PUBLIC,NEAR>

cBegin nogen
	push	ds
	SetKernelDS
	test	Kernel_Flags[2],KF2_PTRACE
	pop	ds
	UnSetKernelDS
	jz	short dsi_done

	push	ax
	mov	ax,SDM_SWITCHIN
	DEBUGCALL
	pop	ax
dsi_done:
	ret
cEnd nogen


;-----------------------------------------------------------------------;
; DebugExitCall
;
; Notifies the debugger than an app is quitting.  This gets
; called at the top of ExitCall.
;
; Entry:
;
; Returns:
;
; Registers Preserved:
;	all
;
; History:
;  Thu 11-May-1989 08:58:40  -by-  David N. Weise  [davidw]
; Wrote it!
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	DebugExitCall,<PUBLIC,NEAR>
cBegin nogen
;
; Windebug knows where this is.  See MyDebugCall() comment.
;
ifdef WOW
	push	ds
	SetKernelDS
        test    DebugWOW,DW_DEBUG
        jz      de_no_wdebug

        push    ax
        push    es
        mov     es,bx               ; Get the current TDB
        push    es                      ; hTask
        mov     ax,es:[TDB_pModule] ; Get the module handle
        mov     es,ax

        push    es                      ; hModule

        push    es                      ; Pointer to module name
        push    es:ne_restab
        push    es                      ; Pointer to module path
        push    word ptr es:ne_crc+2

        mov     ax,DBG_TASKSTOP     ; the selector number needs to be freed
        push    ax
	FBOP BOP_DEBUGGER,,FastBop
        add     sp,+14

        pop     es                  ; Restore original ES
        pop     ax

de_no_wdebug:
        pop     ds
        UnSetKernelDS
endif

	push	ax
        mov     bl,al           ;Exit code in BL
	mov	ax,SDM_EXITCALL
	DEBUGCALL
        pop     ax


	ret
cEnd nogen


;-----------------------------------------------------------------------;
; FarDebugDelModule
;
; Notifies the debugger than a module is being deleted.  This gets
; called at the top of ExitCall.
;
; Entry:
;     ES = module handle
;
; Returns:
;
; Registers Reserved:
;     all
;
; History:
;  Mon 11-Sep-1989 18:34:06  -by-  David N. Weise  [davidw]
; Wrote it!
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	FarDebugDelModule,<PUBLIC,FAR>
ifdef WOW
	localV	nameBuf,130
        localV  ModName,64
endif
cBegin nogen
	push	es
ifdef WOW
        push    ds
        push    es

        SetKernelDS

        test    DebugWOW,DW_DEBUG
        jnz     @f
        jmp     fdd_no_wdebug

@@:     push    di
        push    si
        push    cx
        xor     cx,cx
        mov     ax,es
        mov     ds,ax
        mov     si,es:[ne_restab]
        mov     cl,[si]
        inc     si
        cmp     cl,64
        jb      @f
        mov     cl,63
@@:
        mov     ax,ss
        mov     es,ax
        lea     di,ModName
        rep movsb                           ; Copy module name from resource
        mov     byte ptr es:[di],0          ; table and null terminate it
        mov     ax,ds
        mov     es,ax

        lea     di,nameBuf
        push    ax
        push    ss
        push    di
        mov     ax, 130
        push    ax
        call    GetModuleFileName

        SetKernelDS
        lea     di,nameBuf
        push    ss
        push    di
        lea     di,ModName
        push    ss
        push    di
        push    DBG_MODFREE
	FBOP BOP_DEBUGGER,,FastBop
        add     sp,+10
        pop     cx
        pop     si
        pop     di
fdd_no_wdebug:
        pop     es
        pop     ds
        UnSetKernelDS
endif; WOW
	mov	ax,SDM_DELMODULE
	DEBUGCALL
	add	sp,2
	ret
cEnd nogen

;-----------------------------------------------------------------------;
; void DebugLogError(WORD err, VOID FAR* lpInfo);
;
; Notifies debugger of a LogError() call.
;
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	DebugLogError,<PUBLIC,NEAR>
;ParmW	err
cBegin	nogen
	pop	ax

	pop	bx	    ; dx:bx = lpInfo
	pop	dx

	pop	cx	    ; cx = error code

	push	ax
	mov	ax,SDM_LOGERROR
	jmp	short MyDebugCall
cEnd	nogen

;-----------------------------------------------------------------------;
; void DebugLogParamError(VOID FAR* param, FARPROC lpfn, WORD err);
;
; Notifies debugger of a LogParamError() call.
;
; NOTE: the parameters are passed in the REVERSE order than expected,
; so that the stack layout is natural when we do the DebugCall.
;
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	DebugLogParamError,<PUBLIC,NEAR>
;ParmD	param
;ParmD	lpfn
;ParmW	err
cBegin	nogen
;
; es:bx = pointer to struct containing args
;
	mov	bx,sp
	add	bx,2	    ; point past return addr.
	push	ss
	pop	es
	mov	ax,SDM_LOGPARAMERROR
	call	MyDebugCall
	ret	2+4+4
cEnd	nogen

;------------------------------------------------------------------------
;
;  MyDebugCall
;
;  Call the debugger interface.  Created to reduce references to kernel
;  data segment.
;
;------------------------------------------------------------------------

	assumes ds,nothing
	assumes es,nothing

cProc   MyFarDebugCall, <FAR,PUBLIC>
cBegin  nogen
	cCall   MyDebugCall
	retf
cEnd    nogen

cProc	MyDebugCall,<NEAR,PUBLIC>
cBegin	nogen

	push	ds
	SetKernelDS

	test	Kernel_Flags[2],KF2_SYMDEB
	jz	short no_symdeb

	cmp	ax,SDM_SWITCHOUT	; Don't give these to WDEB.
	je	no_symdeb
	cmp	ax,SDM_SWITCHIN
	je	no_symdeb

	pop	ds			; Too bad some Int 41h services
	UnSetKernelDS			;   require segment reg params

	DebInt

	push	ds
	SetKernelDS

no_symdeb:

        ;** Check for TOOLHELP's hook.  We always send it here first
        ;**     This callback does NOT depend on what's on the stack.
        test    Kernel_Flags[2],KF2_TOOLHELP ;TOOLHELP hook?
        jz      SHORT MDC_NoToolHelp    ;No

        push    ax

        push    Win_PDB                 ; Preserve Win_TDB across ToolHelp call
        cmp     curTDB,0
        jz      @F
        push    es
        mov     es,curTDB
        push    es:[TDB_PDB]
        pop     ds:Win_PDB
        pop     es
@@:

        ;** Just call the TOOLHELP callback.  It preserves all registers
        ;**     except AX where it returns nonzero if the notification
        ;**     was handled.
        call    lpfnToolHelpProc        ;Do it

        pop     Win_PDB                 ; Restore Win_TDB

        or      ax,ax                   ;Did the TOOLHELP client say to
                                        ;  pass it on?
        jz      SHORT @F                ;Yes
        add     sp,2                    ;No, so return TOOLHELP's return value
        jmp     SHORT no_ptrace
@@:     pop     ax                      ;Restore notification ID

MDC_NoToolHelp:

	;** Make sure we don't have a new notification.  If it's newer than
        ;*      CVW, CVW chokes on it so we can't send new notifications
        ;**     through PTrace.
        cmp     ax,SDM_DELMODULE        ;Last old notification
        ja      short no_ptrace         ;Don't send new notification
MDC_PTraceOk:
	cmp	WORD PTR ptrace_dll_entry[2],0 ;WINDEBUG.DLL lurking around?
        jz      SHORT no_ptrace

; !!!!!!!!!!!!!! HACK ALERT !!!!!!!!!!!!!!
;
; Windebug.DLL for Windows 3.0 knows exactly what is on the stack
; when Kernel makes a PTrace callout.  For this reason, we cannot
; change what is on the stack when we make one of these calls.
; This stuff below fakes a FAR return to our NEAR caller, and jumps
; to the PTrace DLL entry with all registers intact.
;
	; SP -> DS RET

	sub	sp,8
	push	bp
	mov	bp,sp

	; BP -> BP xx xx xx xx DS KERNEL_RET

	mov	[bp+2],ax			; save AX

	mov	ax,[bp+10]			; move saved DS
	mov	[bp+4],ax

	mov	ax,[bp+12]			; convert near RET to far
	mov	[bp+10],ax
	mov	[bp+12],cs

	mov	ax,word ptr ptrace_dll_entry[2]	; CS of Routine to invoke
	mov	[bp+8],ax
	mov	ax,word ptr ptrace_dll_entry	; IP of Routine to invoke
	mov	[bp+6],ax

	; SP -> BP AX DS PTRACE_IP PTRACE_CS KERNEL_RET KERNEL_CS

	pop	bp
	pop	ax
	pop	ds
	UnSetKernelDS
	retf

no_ptrace:
	pop	ds
	UnSetKernelDS

	ret
cEnd	nogen


if KDEBUG

dout	macro	var
	mov	byte ptr ss:[si],var
	inc	si
	endm


;-----------------------------------------------------------------------;
; hex									;
;									;
; Outputs byte in AL as two hex digits.					;
;									;
; Arguments:								;
;	AL    = 8-bit value to be output				;
;	SS:SI = where it's to be put					;
;									;
; Returns:								;
;									;
; Error Returns:							;
;									;
; Registers Preserved:							;
;									;
; Registers Destroyed:							;
;									;
; Calls:								;
;									;
; History:								;
;									;
;  Fri Nov 14, 1986 02:32:15p  -by-  David N. Weise   [davidw]		;
; Modified it from symdeb\debug.asm.					;
;-----------------------------------------------------------------------;

ifndef WOW
cProc	hex,<NEAR>
cBegin nogen

	mov	ah,al		; save for second digit

; shift high digit into low 4 bits

	mov	cl,4
	shr	al,cl

	and	al,0Fh		; mask to 4 bits
	add	al,90h
	daa
	adc	al,40h
	daa
	dout	al

	mov	al,ah		; now do digit saved in ah
	and	al,0Fh		; mask to 4 bits
	add	al,90h
	daa
	adc	al,40h
	daa
	dout	al
	ret
cEnd nogen



;-----------------------------------------------------------------------;
; pdref_norip								;
;									;
; Dereferences the given global handle, i.e. gives back abs. address.	;
;									;
; Arguments:								;
;	DX    = selector						;
;	DS:DI = BURGERMASTER						;
;									;
; Returns:								;
;	FS:ESI = address of arena header				;
;	AX = address of client data					;
;	CH = lock count or 0 for fixed objects				;
;	CL = flags							;
;	DX = handle, 0 for fixed objects				;
;									;
; Error Returns:							;
;	ZF = 1 if invalid or discarded					;
;	AX = 0								;
;	BX = owner of discarded object					;
;	SI = handle of discarded object					;
;									;
; Registers Preserved:							;
;									;
; Registers Destroyed:							;
;									;
; Calls:								;
;	ghdref								;
;									;
; History:								;
;									;
;-----------------------------------------------------------------------;

	.386p
	assumes ds,nothing
	assumes es,nothing

cProc	pdref_norip,<PUBLIC,NEAR>

cBegin nogen
					; DPMI - no LDT access
	mov	si, dx
	sel_check si
	or	si, si			; Null handle?
	jnz	short OK1
	mov	ax, si			; yes, return 0
	jmps	pd_exit
OK1:
	lar	eax, edx
	jnz	short pd_totally_bogus
	shr	eax, 8

; We should beef up the check for a valid discarded sel.

	xor	cx,cx
	test	ah, DSC_DISCARDABLE
	jz	short pd_not_discardable
	or	cl, GA_DISCARDABLE
						; Discardable, is it code?
	test	al, DSC_CODE_BIT
	jz	short pd_not_code
	or	cl,GA_DISCCODE
pd_not_code:

pd_not_discardable:
	test	al, DSC_PRESENT
	jnz	short pd_not_discarded

; object discarded

	or	cl,HE_DISCARDED
ifdef WOW
;   On WOW we don't copy the owner to the real LDT since it is slow to call
;   the NT Kernel, so we read our copy of it directly.
;   see set_discarded_sel_owner   mattfe mar 23 93

	mov	ax,es				; save es
	mov	bx,dx
	mov	es,cs:gdtdsc
	and	bl, not 7
	mov	bx,es:[bx].dsc_owner
	mov	es,ax				; restore
else
	lsl	bx, dx				; get the owner
endif
	or	si, SEG_RING-1			; Handles are RING 2
	xor	ax,ax
	jmps	pd_exit

pd_not_discarded:
	cCall	get_arena_pointer32,<dx>
	mov	esi, eax
	mov	ax, dx
	or	esi, esi			; Unknown selector
	jz	short pd_maybe_alias
	mov	dx, ds:[esi].pga_handle
	cmp	dx, ax				; Quick check - handle in header
	je	short pd_match			; matches what we were given?

	test	al, 1				; NOW, we MUST have been given
	jz	short pd_totally_bogus		; a selector address.
	push	ax
	StoH	ax				; Turn into handle
	cmp	dx, ax
	pop	ax
	jne	short pd_nomatch
pd_match:
	or	cl, ds:[esi].pga_flags
	and	cl, NOT HE_DISCARDED		; same as GA_NOTIFY!!
	mov	ax, dx				; Get address in AX
	test	dl, GA_FIXED			; DX contains handle
	jnz	short pd_fixed			; Does handle need derefencing?
	mov	ch, ds:[esi].pga_count
	HtoS	ax				; Dereference moveable handle
	jmps	pd_exit
pd_totally_bogus:
	xor	ax,ax
pd_maybe_alias:
pd_nomatch:					; Handle did not match...
	xor	dx, dx
pd_fixed:
pd_exit:
	or	ax,ax
	ret
cEnd nogen
	.286p

;-----------------------------------------------------------------------;
; xhandle_norip								;
; 									;
; Returns the handle for a global segment.				;
; 									;
; Arguments:								;
;	Stack = sp   -> near return return address			;
;		sp+2 -> far return return address of caller		;
;		sp+6 -> segment address parameter			;
; 									;
; Returns:								;
;	Old DS,DI have been pushed on the stack				;
;									;
;	ZF= 1 if fixed segment.						;
;	 AX = handle							;
;									;
;	ZF = 0								;
;	 AX = handle							;
;	 BX = pointer to handle table entry				;
;	 CX = flags and count word from handle table			;
;	 DX = segment address						;
;	 ES:DI = arena header of object					;
;	 DS:DI = master object segment address				;
; 									;
; Error Returns:							;
;	AX = 0 if invalid segment address				;
;	ZF = 1								;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Thu Oct 16, 1986 02:40:08p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;
	.386p
cProc	xhandle_norip,<PUBLIC,NEAR>
cBegin nogen
	pop	dx			; Get near return address
	mov	bx,sp			; Get seg parameter from stack
	mov	ax,ss:[bx+4]
	cmp	ax,-1			; Is it -1?
	jnz	short xh1
	mov	ax,ds			; Yes, use callers DS
xh1:	inc	bp
	push	bp
	mov	bp,sp
	push	ds			; Save DS:DI
	push	edi
	push	esi
	SetKernelDS
	mov	ds, pGlobalHeap 	; Point to master object
	UnSetKernelDS
	xor	edi,edi
	inc	[di].gi_lrulock
	push	dx
	mov	dx,ax
	call	pdref_norip

	xchg	dx,ax			; get seg address in DX
	jz	short xhandle_ret		; invalid or discarded handle
	test	al, GA_FIXED
	jnz	short xhandle_fixed
	or	ax, ax
	jmps	xhandle_ret
xhandle_fixed:
	xor	bx, bx			; Set ZF
xhandle_ret:
	ret
cEnd nogen
	.286p

endif    ;ifndef WOW

endif	;KDEBUG

cProc	ReplaceInst,<PUBLIC,FAR>

;;	parmD bpaddress
;;	parmW instruct

cBegin nogen
	ret	6
cEnd nogen


sEnd	CODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\ldfastb.asm ===
TITLE	LDFASTB - FastBoot  procedure

.xlist
include kernel.inc
include newexe.inc
include pdb.inc
include tdb.inc
.list

	.386

externA	 __ahincr

externFP GlobalReAlloc

sBegin	NRESCODE
assumes CS,NRESCODE
assumes DS,NOTHING
assumes ES,NOTHING

sEnd	NRESCODE

DataBegin

externB Kernel_flags
externW pGlobalHeap
externW win_show
externW hLoadBlock
externW segLoadBlock
externD lpBootApp

externW cpShrink
externW cpShrunk

DataEnd

sBegin	INITCODE
assumes CS,CODE
assumes DS,NOTHING
assumes ES,NOTHING

externNP MyLock

externNP get_arena_pointer32
externNP get_physical_address
externNP set_physical_address
externNP get_rover_2

;-----------------------------------------------------------------------;
; Shrink								;
;									;
; This shrinks what's left of win.bin.	The part at the front of win.bin;
; that has been loaded already is expendable.  The part of win.bin	;
; that has not been loaded yet is moved down over the expended part.	;
; This does not change the segment that win.bin starts at.  The		;
; partition is then realloced down in size.				;
;									;
; Arguments:								;
;	none								;
;									;
; Returns:								;
;									;
; Error Returns:							;
;									;
; Registers Preserved:							;
;	DI,SI,DS,ES							;
;									;
; Registers Destroyed:							;
;	AX,BX,CX,DX							;
;									;
; Calls:								;
;	BigMove								;
;	GlobalReAlloc							;
;	MyLock								;
;									;
; History:								;
;									;
;  Fri Feb 27, 1987 01:20:57p  -by-  David N. Weise   [davidw]		;
; Documented it and added this nifty comment block.			;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

cProc	Shrink,<PUBLIC,NEAR>
cBegin	nogen

	CheckKernelDS
	ReSetKernelDS
	push	es
	push	si
	push	di
	mov	ax,[segLoadBlock]		; Get current address
	mov	bx, ax
	mov	ds, pGlobalHeap
	UnSetKernelDS
	cCall	get_arena_pointer32,<ax>
	mov	edx, ds:[eax].pga_size
	shr	edx, 4
	SetKernelDS
	mov	ax,bx
	mov	es,ax			; es is destination
	xor	bx,bx
	xchg	[cpShrink],bx		; Get amount to shrink by
	add	[cpShrunk],bx		; Keep track of how much we have shrunk

	sub	dx,bx			; get new size
	push	dx			; save new size
	push	ds			; save kernel ds

	mov	ds, ax
	movzx	esi, bx
	shl	esi, 4			; Start of new block
	xor	edi, edi		; Where it will go
	movzx	ecx, dx
	shl	ecx, 2			; Dwords
	cld				; Move it down.
	rep movs dword ptr es:[edi], dword ptr ds:[esi]
	db	67h			; 386 BUG, DO NOT REMOVE
	nop				; 386 BUG, DO NOT REMOVE

	pop	ds
	CheckKernelDS
	ReSetKernelDS
	pop	ax			; get back size in paragraphs
	mov	cx,4
	xor	dx,dx			; convert to bytes
il3e:
	shl	ax,1
	rcl	dx,1
	loop	il3e
	cCall	GlobalReAlloc,<hLoadBlock,dxax,cx>
	cCall	MyLock,<hLoadBlock>
	mov	[segLoadBlock],ax
	pop	di
	pop	si
	pop	es

	ret
cEnd	nogen

sEnd	INITCODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\ldfile.asm ===
TITLE	LDFILE - Loader file I/O procedures

.xlist
include kernel.inc
include newexe.inc
.list

externFP GlobalAlloc
externFP GlobalFree
externFP MyOpenFile
externFP Int21Handler

sBegin	CODE
assumes CS,CODE

externNP MyLock

;-----------------------------------------------------------------------;
; LoadNRTable								;
; 									;
; Returns the segment address of the non-resident name table.		;
; 									;
; Arguments:								;
;	parmW	hexe		exeheader to load NRTable from		;
;	parmW	fh		file handle, -1 if none 		;
;	parmD	oNRTable	if batching, this is where we left off	;
;	parmD	lpNRbuffer	if batching, this is buffer to use	;
;	parmW	cbNRbuffer	if batching, this is size of buffer	;
; 									;
; Returns:								;
;	DX:AX = pointer to non-resident table				;
;	CX:BX = if batching this is where to pick up from		;
;									;
; Error Returns:							;
;	DX:AX = NULL							;
;									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
;	MyOpenFile							;
;	GlobalAlloc							;
;	MyLock								;
; 									;
; History:								;
; 									;
;  Tue 09-May-1989 18:38:04  -by-  David N. Weise  [davidw]		;
; Added the batching if out of memory.					;
;									;
;  Thu Oct 08, 1987 10:11:42p  -by-  David N. Weise   [davidw]		;
; Added this nifty comment block and fixed it for fastboot.		;
;-----------------------------------------------------------------------;

cProc	LoadNRTable,<PUBLIC,NEAR>,<si,di>
	parmW	hexe
	parmW	fh
	parmD	oNRTable
	parmD	lpNRbuffer
	parmW	cbNRbuffer

	localD	lt_ExeoNRTable		; the real offset in the Exe
	localD	lt_oNRTable
	localB	fBatching
	localB	fFirstTime
	localW	cbnrestab
	localW	pfileinfo		; used for debugging only
cBegin
	mov	cx,oNRTable.hi		; Are we batching?
	or	cx,oNRTable.lo
	or	cl,ch
	mov	fBatching,cl
	xor	di,di
	mov	fFirstTime,0

if KDEBUG
	mov	pfileinfo,di
endif
	mov	es,hexe
	mov	si,ne_nrestab
	mov	bx,fh
	mov	dx,es:[si][2]		; Get potential segment address
	mov	ax,es:[si][0]
	inc	bx			; Were we passed a file handle
	jnz	ltopen			; Yes, go read then
	mov	dx,es:[di].ne_pfileinfo ; No, then open the file
if SHARE_AWARE
	mov	bx,OF_REOPEN or OF_PROMPT or OF_CANCEL or OF_VERIFY or OF_NO_INHERIT or OF_SHARE_DENY_WRITE
else
	mov	bx,OF_REOPEN or OF_PROMPT or OF_CANCEL or OF_VERIFY or OF_NO_INHERIT
endif
if KDEBUG
	mov	pfileinfo,dx
	krDebugOut <DEB_TRACE or DEB_krLoadSeg>, "Non-Res name table of @ES:DX"
endif
	regptr	esdx,es,dx
	push	dx
	push	es
	cCall	MyOpenFile,<esdx,esdx,bx>
	pop	es
	pop	dx
;;;	cmp	ax, -1
;;;	jne	@F
;;;
;;;	mov	bx,OF_REOPEN or OF_VERIFY or OF_NO_INHERIT
;;;	cCall	MyOpenFile,<esdx,esdx,bx>		   
;;;
;;;@@:
	mov	es,hexe
	inc	bx
	jnz	ltopen
	jmp	ltfail
ltopen:
	krDebugOut <DEB_TRACE or DEB_krLoadSeg>, "Loading %es2 Nonresident name table"
	dec	bx
	mov	dx,es:[si][0]		; AX:DX = file address of table
	mov	ax,es:[si][2]
	cmp	es:[di].ne_pfileinfo,di ; Is the NRTable in WIN200.OVL?
	jnz	lt_seek
	mov	cx,4			; Shift left AX:DX by 4.
lt_winovl:
	shl	dx,1
	rcl	ax,1
	loop	lt_winovl
lt_seek:
	mov	lt_ExeoNRTable.hi,ax
	mov	lt_ExeoNRTable.lo,dx
	cmp	fBatching,0		; Are we batching?
	jz	lt_not_batching
	mov	ax,oNRTable.hi
	mov	dx,oNRTable.lo
lt_not_batching:
	mov	lt_oNRTable.hi,ax
	mov	lt_oNRTable.lo,dx
	mov	cx,ax			; CX:DX = file address of table
	mov	ax,4200h		; Seek to beginning of the table
	DOSCALL
	jnc	@F
	jmp	ltfail
@@:	push	es
	push	bx
	cmp	fBatching,0
	jz	lt_first_time
lt_got_no_space:
	mov	es,hexe
	mov	dx,oNRTable.hi
	mov	ax,oNRTable.lo
	sub	ax,lt_ExeoNRTable.lo	; compute the bytes read so far
	sbb	dx,lt_ExeoNRTable.hi
	sub	ax,es:[di].ne_cbnrestab
	neg	ax
	cmp	ax,cbNRbuffer
	jbe	@F
	mov	ax,cbNRbuffer
@@:	mov	cbnrestab,ax

	les	di,lpNRbuffer
	mov	ax,es
	mov	dx,ax
	jmps	lt_share_your_space

lt_first_time:
	mov	fFirstTime,1		; make non-zero
	mov	ax,es:[ne_cbnrestab]	; first time through
	mov	cbnrestab,ax
	add	ax,4
	mov	bx,GA_MOVEABLE or GA_NODISCARD
	xor	cx,cx

	cCall	 GlobalAlloc,<bx,cx,ax>
	xor	dx,dx
	or	ax,ax
	jnz	lt_got_space

	mov	ax,lt_oNRTable.hi
	mov	oNRTable.hi,ax
	mov	ax,lt_oNRTable.lo
	mov	oNRTable.lo,ax
	mov	fBatching,1
	jmp	lt_got_no_space

lt_got_space:
	cCall	MyLock,<ax>
	xor	di,di
lt_share_your_space:
	pop	bx
	mov	cx,ds			; Save DS
	pop	ds
	push	cx			; after alloc
	mov	es,ax
	cmp	fBatching,0
	jnz	@F
	xor	ax,ax			; Set table loaded indicator
	xchg	ds:[si],ax
	cld
	stosw				; Save file offset
	mov	ax,dx
	xchg	ds:[si+2],ax		; Set segment handle
	stosw				; Save file offset
@@:	mov	cx,cbnrestab
	smov	ds,es
	push	dx
	mov	dx,di
	mov	ah,3Fh			; Read in the table
	DOSCALL
	pop	dx
	pop	ds
	jc	ltfail			; did the DOS call fail?
	cmp	ax,cx			; did we get all the bytes?
	jne	ltfail

	cmp	fBatching,0		; are we batching?
	jz	ltdone
	std				; truncate to whole strings
	push	bx
	xor	ax,ax
	xor	bx,bx
	mov	dx,cbNRbuffer
	dec	dx
@@:	cmp	byte ptr es:[di][bx],0	; are we at end of NRTable?
	jnz	lt_not_buffer_end
	xor	ax,ax
	mov	oNRTable.hi,ax
	mov	oNRTable.lo,ax
	jmps	lt_return_buffer
lt_not_buffer_end:
	mov	cx,bx
	mov	al,byte ptr es:[di][bx]
	add	bx,ax
	add	bx,3
	cmp	bx,dx
	jb	@B
	mov	bx,cx
	mov	byte ptr es:[di][bx],0
	add	oNRTable.lo,bx
	adc	oNRTable.hi,0
lt_return_buffer:
	pop	bx
	les	ax,lpNRbuffer
	mov	dx,es
	cmp	fFirstTime,0
	jnz	ltdone_0
	jmps	ltexit

ltdone:
	push	bx
	cCall	MyLock,<dx>
	pop	bx
	mov	dx,ax
	mov	ax,4
ltdone_0:
	mov	es,dx
	mov	si,ax
	xor	ax,ax
	mov	al,es:[si]
	add	ax,si
	add	ax,3
	jmps	ltexit
ltfail:
if KDEBUG
        push    bx
ifdef WOW
        mov     bx, hexe
        krDebugOut      DEB_ERROR, "Unable to load non-resident name table from mod #BX. "
else
        kerror  ERR_LDNRTABLE,<Unable to load non-resident name table from >,hexe,pfileinfo
;;;     kerror  ERR_LDNRTABLE,<(TRY FILES=30 to fix this) Unable to load non-resident name table from >,hexe,pfileinfo
endif
	pop	bx
endif
	xor	ax,ax
	xor	dx,dx

ltexit: cmp	bx,fh
	je	ltx1
	push	ax
	mov	ah,3Eh
	DOSCALL
	pop	ax
ltx1:
	mov	cx,oNRTable.hi
	mov	bx,oNRTable.lo
	cld				; we'll be polite
cEnd


;
; GetStringPtr( hExe, offset ) - Procedure to return the far address of a
; string in the passed new EXE file's string table
;
cProc	GetStringPtr,<PUBLIC,NEAR>,<si,di>
	parmW	hExe
	parmW	fh
	parmW	soffset
cBegin
	mov	es,hExe
	mov	dx,es
	mov	ax,es:[ne_imptab]
	add	ax,soffset
cEnd


; FreeNRTable( lptable ) - Procedure to free table allocated by LoadNRTable
; and restore the new EXE header information.

cProc	FreeNRTable,<PUBLIC,FAR>,<si,di>
	parmW	hexe
	parmW	tblid
cBegin
	mov	es,hexe
	mov	di,tblid
	xor	ax,ax
	mov	cx,es:[di+2]
	cmp	word ptr es:[di],0
	jne	lfexit
	jcxz	lfexit
	push	cx
	cCall	MyLock,<cx>
	pop	cx
	mov	es,hexe
	push	ds
	mov	ds,ax
	xor	si,si
	cld
	movsw
	movsw
	pop	ds
	cCall	GlobalFree,<cx>
lfexit:
cEnd

sEnd	CODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\ldheader.asm ===
TITLE   LDHEADER - Load Exe Header procedure

.xlist
include gpfix.inc
include kernel.inc
include newexe.inc
.list

externA  __AHINCR

externFP IGlobalAlloc
externFP IGlobalFree
externFP FarSetOwner
externFP Int21Handler
externFP FarMyUpper
externFP IsBadStringPtr
externFP _hread

DataBegin

externB fBooting
externB szBozo
externW winVer
externD pSErrProc

DataEnd
          
externFP IGlobalLock
externFP IGlobalUnLock

sBegin  NRESCODE
assumes CS,NRESCODE

externNP NResGetPureName


;-----------------------------------------------------------------------;
; LoadExeHeader                                                         ;
;                                                                       ;
; Routine to read an EXE header and check for a new format EXE file.    ;
; Returns NULL if not a new format EXE.  Otherwise reads the resident   ;
; portion of the new EXE header into allocated storage and returns      ;
; the segment address of the new EXE header.                            ;
;                                                                       ;
; Arguments:                                                            ;
;       parmW   fh                                                      ;
;       parmW   isfh                                                    ;
;       parmD   pfilename                                               ;
;                                                                       ;
; Returns:                                                              ;
;       AX = segment of exe header                                      ;
;       DL = ne_exetyp                                                  ;
;       DH = ne_flagsothers                                             ;
;                                                                       ;
; Error Returns:                                                        ;
;LME_MEM        = 0     ; Out of memory                                 ;
;LME_VERS       = 10    ; Wrong windows version                         ;
;LME_INVEXE     = 11    ; Invalid exe                                   ;
;LME_OS2        = 12    ; OS/2 app                                      ;
;LME_DOS4       = 13    ; DOS 4 app                                     ;
;LME_EXETYPE    = 14    ; unknown exe type                              ;
;LME_COMP       = 19    ; Compressed EXE file                           ;
;LME_PE         = 21    ; Portable EXE                                  ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       DI,SI                                                           ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;       AX,BX,CX,DS,ES                                                  ;
; Calls:                                                                ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Thu Mar 19, 1987 08:35:32p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.                                       ;
;-----------------------------------------------------------------------;

cProc   LoadExeHeader,<PUBLIC,FAR>,<si,di>
        parmW   fh
        parmW   isfh
        parmD   pfilename
        localW  pnewexe
        localW  exetype
        localW  nchars
        localW  pseg
        localW  psegsrc
        localW  hBlock
        localW  pBlock
        localW  NEFileOffset
        localD  PreloadLen
        localW  NEBase
        localW  exeflags
        localW  expver
        localW  saveSP
        localB  fast_fail               ; 1 if we can't use fastload block
        localV  hdrbuf,<SIZE EXE_HDR>

.errnz  SIZE EXE_HDR - SIZE NEW_EXE

cBegin
        xor     ax,ax
        mov     pseg,ax
        mov     hBlock, ax
        mov     fast_fail, al
        cmp     SEG_pfilename,ax
        je      re0

IF      KDEBUG                          ; LoadExeHeader is internal
        cCall   IsBadStringPtr, <pfilename, 128> ; so we assume file pointer is OK
        or      ax, ax
        jnz     refailj
ENDIF
        lds     si,pfilename
        mov     al,ds:[si].opLen
        inc     ax                      ; include null byte
re0:
        mov     nchars,ax
        mov     bx,fh                   ; No, seek backwards over what
        cmp     isfh,bx
        je      refile
        mov     ds,bx
        xor     si,si
        jmp     remem

refile:                                 ; Here to load from a file
        push    ss                      ; DS:SI points to I/O buffer
        pop     ds
        lea     si,hdrbuf               ; Read beginning of file
        mov     dx,si
        mov     cx,SIZE EXE_HDR
        mov     bx,fh
        mov     ah,3Fh
        DOSFCALL
        jnc     @F
refailj:
        jmps    refail
@@:
        cmp     ax,cx                   ; Old EXE file, look for offset
        jb      refailj                 ; to new exe header
        cmp     ds:[si].e_magic,EMAGIC  ; Check for old exe file
        je      @F
        cmp     ds:[si], 'ZS'           ; Is it compressed?
        jne     refail
        cmp     ds:[si][2],'DD'
        jne     refail
        cmp     ds:[si][4],0F088h
        jne     refail
        cmp     ds:[si][6],03327h
        jne     refail
        mov     ax, LME_COMP            ; Compressed EXE
        jmp     reexit
@@:
        mov     ax,ds:[si].e_lfanew.hi
        mov     dx,ds:[si].e_lfanew.lo
        mov     pnewexe,dx              ; To check for bound OS/2 apps.
        or      ax,dx
        jz      refail                  ; Fail if not there.

        mov     cx,ds:[si].e_lfanew.hi
        mov     dx,ds:[si].e_lfanew.lo
        mov     bx, fh
        mov     ax,4200h
        DOSFCALL
        jc      refail
        mov     cx,SIZE NEW_EXE
        mov     dx,si
        mov     ah,3Fh
        DOSFCALL
        jc      refail
        cmp     ax,cx
        jne     refail
        cmp     ds:[si].ne_magic,NEMAGIC ; Did we get a valid new EXE header?
        je      remem
        cmp     ds:[si].ne_magic,PEMAGIC ; Did we find a Portable EXE (WIN32)
        jne     refail
        mov     ax, LME_PE
        jmps    rej
refail:
        mov     ax, LME_INVEXE          ; invalid NEW EXE file format
rej:    jmp     reexit

remem:
        mov     psegsrc,bx              ; bx has either fh or seg address
        mov     di,ds:[si].ne_enttab    ; Compute size of resident new header
        add     di,ds:[si].ne_cbenttab
        add     di, 6                   ; null entry space (bug #8414)

        mov     cx, ds:[si].ne_cbenttab
        mov     bx, ds:[si].ne_cmovent
        shl     bx, 1
        sub     cx, bx
        shl     bx, 1
        sub     cx, bx                  ; Number of bytes not moveable entries
        shl     cx, 1                   ; Allow triple these bytes
        add     di, cx

        mov     cx,ds:[si].ne_cseg      ; + 3 * #segments

; Reserve space for ns_handle field in segment table

        shl     cx,1
        add     di,cx

        .errnz  10 - SIZE NEW_SEG1

; Reserve space for file info block at end

        add     di,nchars               ; + size of file info block

        xor     ax,ax                   ; Allocate a fixed block for header
        mov     bx,GA_ZEROINIT or GA_MOVEABLE
        cCall   IGlobalAlloc,<bx,ax,di>  ;  that isn't code or data.
        or      ax,ax
        jnz     @F
        jmps    badformat
@@:
        push    ax
        cCall   IGlobalLock,<ax>
        pop     ax
        push    dx
        cCall   IGlobalUnlock,<ax>
        pop     ax
        sub     di,nchars
        mov     pseg,ax
        mov     es,ax                   ; ES:0 -> new header location
        cld                             ; DS:SI -> old header
        mov     bx,psegsrc
        cmp     isfh,bx                 ; Is header in memory?
        jne     remem1                  ; Yes, continue
        mov     ax,ds:[si].ne_enttab    ; No, read into high end
        add     ax,ds:[si].ne_cbenttab  ; of allocated block
        sub     di,ax
        mov     cx,SIZE NEW_EXE         ; Copy part read so far
        sub     ax,cx
        rep     movsb
        mov     cx,ax
        smov    ds,es                   ; Read rest of header from file
        mov     dx,di
        mov     ah,3fh
        DOSFCALL
        mov     bx,ax
        jc      refail1
        lea     si,[di-SIZE NEW_EXE]    ; DS:SI -> old header
        cmp     bx,cx
        je      remem1
badformat:
        mov     ax, LME_INVEXE          ; don't change flags
refail1:                                ; Here if error reading header
        push    ax
        SetKernelDSNRes                 ; DS may be = pseg, prevent
        cCall   IGlobalFree,<pseg>       ;  GP faults in pmode.
        pop     ax
        jmp     reexit

remem1:
        UnsetKernelDS
        test    ds:[si].ne_flags,NEIERR ; Errors in EXE image?
        jnz     badformat               ; Yes, fail

        cmp     ds:[si].ne_ver,4        ; No, built by LINK4 or above?
        jl      badformat               ; No, error
        mov     bx,ds:[si].ne_flags     ; Make local copies of ne_flags &
        and     bl,NOT NEPROT           ;   ne_expver which can be modified
        mov     exeflags,bx             ;   (can't change ROM exe headers).
        mov     bx,ds:[si].ne_expver
        mov     expver,bx
        mov     bx,word ptr ds:[si].ne_exetyp   ; get exetyp and flagsothers
        mov     exetype,bx

        cmp     bl,NE_UNKNOWN
        jz      windows_exe
        cmp     bl,NE_WINDOWS           ; is it a Windows exe?
        jz      windows_exe
        mov     ax,LME_OS2
        cmp     bl,NE_OS2               ; is it an OS|2 exe?
        jnz     not_os2
        test    bh,NEINPROT             ; can it be run under Windows?
        jz      @F
        and     exeflags,NOT NEAPPLOADER
        or      exeflags,NEPROT
        mov     expver,0300h
        jmps    windows_exe
@@:
        cmp     pnewexe,0800h           ; is it a bound
        jb      refail1
        jmp     badformat
not_os2:
        inc     ax                      ; AX = 13 - LME_DOS4
        cmp     bl,NE_DOS4              ; is it a DOS 4 exe?
        jz      refail1
        inc     ax                      ; AX = 14 - LME_EXETYPE
        jmp     refail1

mgxlib DB 'MGXLIB'

windows_exe:

        mov     NEBase, si              ; Offset of Source header
        xor     di,di                   ; ES:DI -> new header location
        mov     cx,SIZE NEW_EXE         ; Copy fixed portion of header
        cld
        rep     movsb
        mov     ax,exeflags
        mov     es:[ne_flags],ax
        mov     ax,expver
        mov     es:[ne_expver],ax
        mov     si, NEBase
        add     si, es:[ne_segtab]      ; Real location of segment table
        mov     cx,es:[ne_cseg]         ; Copy segment table, adding
        mov     es:[ne_segtab],di
        jcxz    recopysegx
recopyseg:

        movsw                           ; ns_sector
        movsw                           ; ns_cbseg
        lodsw                           ; ns_flags

        .errnz  4 - ns_flags

        and     ax,not (NS286DOS XOR NSGETHIGH) ; Clear 286DOS bits
; record in the segment flags if this module is a process, this is for EMS

        test    ax,NSTYPE               ; NSCODE
        jnz     not_code
        or      ax,NSWINCODE
not_code:
        or      ax,NSNOTP
        test    es:[ne_flags],NSNOTP
        jnz     not_a_process
        xor     ax,NSNOTP
        or      ax,NSMOVE
not_a_process:
        stosw                           ; ns_flags
        movsw                           ; ns_minalloc
        .errnz  8 - SIZE NEW_SEG
        xor     ax,ax
        stosw                           ; one word for ns_handle field
        .errnz  10 - SIZE NEW_SEG1
        loop    recopyseg

recopysegx:
        test    es:[ne_flagsothers], NEGANGLOAD
        jz      no_gang_loadj
        mov     bx, fh
        cmp     bx, isfh
        jne     no_gang_loadj

        mov     ax, es:[ne_gang_start]
        or      ax, ax
        jz      no_gang_loadj
        mov     NEFileOffset, ax        ; file offset of gang load area
        mov     ax, es:[ne_gang_length]
        or      ax, ax
        jz      no_gang_loadj
        mov     cx, es:[ne_align]
        xor     dx, dx
gl_len:                                 ; find length of Gang Load area
        shl     ax, 1
        adc     dx, dx
        loop    gl_len

        cmp     dx, 10h                 ; Greater than 1Mb, forget it!!
        jb      alloc_it                ; PS: NEVER go bigger than 1Mb
no_gang_loadj:
        jmp     no_gang_load            ; since LongPtrAdd is limited...

alloc_it:
        mov     word ptr PreloadLen[0], ax
        mov     word ptr PreloadLen[2], dx
        mov     ch, GA_DISCARDABLE
        mov     cl, GA_MOVEABLE+GA_NODISCARD+GA_NOCOMPACT
        push    es
        cCall   IGlobalAlloc,<cx,dx,ax>  ; Allocate this much memory
        pop     es
        or      ax, ax
        jz      no_gang_loadj
        mov     hBlock, ax              ; Have memory to read file into
        push    es
        cCall   IGlobalLock,<ax>
        pop     es
        mov     pBlock, dx
        mov     dx, NEFileOffset
        mov     cx, es:[ne_align]
        xor     bx, bx
gl_pos:                                 ; find pos of Gang Load start
        shl     dx, 1
        adc     bx, bx
        loop    gl_pos

        mov     cx, bx

        mov     bx, fh
        mov     ax,4200h
        DOSFCALL                        ; Seek to new exe header
        jc      refailgang

        mov     ax, pBlock
        xor     bx, bx
        farptr  memadr,ax,bx
        cCall   _hread, <fh, memadr, PreloadLen>
        cmp     dx, word ptr PreloadLen[2]
        jnz     refailgang
        cmp     ax, word ptr PreloadLen[0]
        jz      no_gang_load            ; We're OK now
;       push    ds
;       xor     dx, dx
;       mov     ax, pBlock

;       push    si
;       push    di
;       mov     si, word ptr PreloadLen[2]
;       mov     di, word ptr PreloadLen[0]
;read_file:
;       mov     cx, 08000h              ; Must be factor 64k DON'T CHANGE THIS
;       or      si, si
;       jnz     big_read
;       cmp     cx, di
;       jbe     big_read
;       mov     cx, di                  ; all that's left
;       jcxz    done_read               ; Nothing left, quit.
;big_read:
;       mov     ds, ax
;       mov     ah, 3Fh
;       DOSFCALL                        ; Read chunk from file
;       jc      refailgang
;       cmp     ax, cx                  ; All we asked for?
;       jne     refailgang              ;  no, file corrupted
;       sub     di, cx
;       sbb     si, 0
;       mov     ax, ds
;       add     dx, cx                  ; On to next block
;       jnc     read_file
;       add     ax, __AHINCR
;       jmps    read_file
;
refailgang:
;       pop     di
;       pop     si
;       pop     ds
        cCall   IGlobalUnlock,<hBlock>
        cCall   IGlobalFree,<hBlock>
        mov     hBlock, 0
        jmps    no_gang_load

BadExeHeader:                           ; GP fault handler!!!
        mov     sp, saveSP
;       fix_fault_stack
        jmp     refail1                 ; corrupt exe header (or our bug)


;done_read:
;       pop     di
;       pop     si
;       pop     ds

no_gang_load:
        mov     saveSP, sp
beg_fault_trap  BadExeHeader
        mov     cx,es:[ne_restab]       ; Copy resource table
        sub     cx,es:[ne_rsrctab]
        mov     si, NEBase              ; Get correct source address
        add     si, es:[ne_rsrctab]
        mov     es:[ne_rsrctab],di
        rep     movsb

rerestab:
        mov     cx,es:[ne_modtab]       ; Copy resident name table
        sub     cx,es:[ne_restab]
        mov     es:[ne_restab],di
        rep     movsb

        push    di
        mov     di, es:[ne_restab]      ; Make the module name Upper Case
        xor     ch, ch
        mov     cl, es:[di]
        inc     di
uppercaseit:
        mov     al, es:[di]
        call    farMyUpper
        stosb
        loop    uppercaseit
        pop     di

        mov     cx,es:[ne_imptab]       ; Copy module xref table
        sub     cx,es:[ne_modtab]
        mov     es:[ne_modtab],di
        rep     movsb

        mov     es:[ne_psegrefbytes],di ; Insert segment reference byte table
        mov     es:[ne_pretthunks],di   ; Setup return thunks
        mov     cx,es:[ne_enttab]       ; Copy imported name table
        sub     cx,es:[ne_imptab]
        mov     es:[ne_imptab],di
        jcxz    reenttab
        rep     movsb

reenttab:
        mov     es:[ne_enttab],di
                                        ; Scan current entry table
        xor     ax, ax                  ; First entry in block
        mov     bx, di                  ; Pointer to info for this block
        stosw                           ; Starts at 0
        stosw                           ; Ends at 0
        stosw                           ; And is not even here!

copy_next_block:
        lodsw                           ; Get # entries and type
        xor     cx, cx
        mov     cl, al
        jcxz    copy_ent_done

        mov     al, ah
        cmp     al, ENT_UNUSED
        jne     copy_used_block

        mov     ax, es:[bx+2]           ; Last entry in current block
        cmp     ax, es:[bx]             ; No current block?
        jne     end_used_block

        add     es:[bx], cx
        add     es:[bx+2], cx
        jmps    copy_next_block

end_used_block:
        mov     es:[bx+4], di           ; Pointer to next block
        mov     bx, di
        add     ax, cx                  ; Skip unused entries
        stosw                           ; First in new block
        stosw                           ; Last in new block
        xor     ax, ax
        stosw                           ; End of list
        jmps    copy_next_block

copy_used_block:
        add     es:[bx+2], cx           ; Add entries in this block
        cmp     al, ENT_MOVEABLE
        je      copy_moveable_block

; absolutes end up here as well

copy_fixed_block:
        stosb                           ; Segno
        movsb                           ; Flag byte
        stosb                           ; segno again to match structure
        movsw                           ; Offset
        loop    copy_fixed_block
        jmps    copy_next_block

copy_moveable_block:
        stosb                           ; ENT_MOVEABLE
        movsb                           ; Flag byte
        add     si, 2                   ; Toss int 3Fh
        movsb                           ; Copy segment #
        movsw                           ; and offset
        loop    copy_moveable_block
        jmps    copy_next_block

copy_ent_done:
        xor     bx,bx
        cmp     es:[bx].ne_ver,5        ; Produced by version 5.0 LINK4
        jae     remem2a                 ; or above?
        mov     es:[bx].ne_expver,bx    ; No, clear uninitialized fields
        mov     es:[bx].ne_swaparea,bx

; TEMPORARY BEGIN

        push    ax
        push    cx
        push    di
        push    si
        mov     si,es:[bx].ne_rsrctab
        cmp     si,es:[bx].ne_restab
        jz      prdone
        mov     di,es:[si].rs_align
        add     si,SIZE new_rsrc
prtype:
        cmp     es:[si].rt_id,0
        je      prdone
        mov     cx,es:[si].rt_nres
        add     si,SIZE rsrc_typeinfo
prname:
        push    cx
        mov     ax,es:[si].rn_flags
        test    ah,0F0h                 ; Is old discard field set?
        jz      @F
        or      ax,RNDISCARD            ; Yes, convert to bit
@@:
        and     ax,not RNUNUSED         ; Clear unused bits in 4.0 LINK files
        mov     es:[si].rn_flags,ax
        pop     cx
        add     si,SIZE rsrc_nameinfo
        loop    prname

        jmp     prtype

prdone: pop     si
        pop     di
        pop     cx
        pop     ax

; TEMPORARY END

FixFlags:                               ; label for debugging
public FixFlags, leh_slow
public leh_code, leh_patchnext, leh_code_fixed, leh_patchdone, leh_data
remem2a:                                ; (bx == 0)
        mov     es:[bx].ne_usage,bx
        mov     es:[bx].ne_pnextexe,bx
        mov     es:[bx].ne_pfileinfo,bx
        cmp     es:[bx].ne_align,bx
        jne     @F
        mov     es:[bx].ne_align,NSALIGN
@@:
        mov     cx,nchars
        jcxz    @F
        mov     es:[bx].ne_pfileinfo,di
        lds     si,pfilename
        rep     movsb
@@:                                     ; Save pointer to seginfo record
        mov     bx,es:[bx].ne_autodata  ; of automatic data segment
        or      bx,bx
        jz      @F
        dec     bx
        shl     bx,1
        mov     cx,bx
        shl     bx,1
        shl     bx,1
        add     bx,cx
        .errnz  10 - SIZE NEW_SEG1
        add     bx,es:[ne_segtab]
@@:
        mov     es:[ne_pautodata],bx

        SetKernelDSNRes

; Scan seg table, marking nonautomatic DATA segments fixed, preload

        mov     ax,es:[ne_expver]       ; Default expected version to
        or      ax,ax
        jnz     @F
        mov     ax,201h
        mov     es:[ne_expver],ax       ; 2.01
@@:
        cmp     ax,winVer
        jbe     @F
        cCall   IGlobalFree,<pseg>
        mov     ax, LME_VERS
        jmp     reexit
@@:
        mov     bx,es:[ne_segtab]
        xor     cx,cx
        sub     bx,SIZE NEW_SEG1
        jmps    leh_patchnext

leh_test_preload:
        test    byte ptr es:[bx].ns_flags, NSPRELOAD
        jnz     leh_patchnext

        or      byte ptr es:[bx].ns_flags, NSPRELOAD

        cmp     es:[bx].ns_sector, 0    ; don't whine about empty segments
        je      leh_patchnext

        krDebugOut      DEB_WARN, "Segment #CX of %ES0 must be preload"
        mov     fast_fail, 1

leh_patchnext:
        add     bx,SIZE NEW_SEG1
        inc     cx
        cmp     cx,es:[ne_cseg]
        ja      leh_patchdone
        test    byte ptr es:[bx].ns_flags,NSDATA ; Is it a code segment?
        jz      leh_code                        ; Yes, next segment
        .errnz  NSCODE
leh_data:       ; Data must be non-discardable, preload
if KDEBUG
        test    es:[bx].ns_flags, NSDISCARD
        jz      @F
        krDebugOut DEB_WARN, "Data Segment #CX of %ES0 can't be discardable"
@@:
endif
        and     es:[bx].ns_flags,not NSDISCARD  ; Data segments not discardable
        jmps    leh_test_preload

leh_code:
        test    byte ptr es:[bx].ns_flags,NSMOVE; Moveable code?
        jz      leh_code_fixed

                ; moveable code must be discardable, or must be preload
if      KDEBUG
        test    es:[ne_flags],NENOTP            ; for 3.0 libraries can't have
        jz      @F                              ;  moveable only code
        cmp     fBooting,0                      ; If not booting
        jne     @F
        test    es:[bx].ns_flags,NSDISCARD
        jnz     @F
        krDebugOut DEB_WARN, "Segment #CX of %ES0 was discardable under Win 3.0"
@@:
endif
        test    es:[bx].ns_flags,NSDISCARD      ; Is it discardable?
        jnz     leh_patchnext
        jmp     leh_test_preload

leh_code_fixed: ; fixed code must be preload
        cmp     fBooting,0                      ; If not booting
        jne     leh_patchnext
        jmp     leh_test_preload

leh_patchdone:
        mov     bx,word ptr es:[ne_csip+2]      ; Is there a start segment?
        or      bx,bx
        jz      @F                              ; No, continue
        dec     bx
        shl     bx,1
        mov     si,bx
        shl     si,1
        shl     si,1
        add     si,bx
        .errnz  10 - SIZE NEW_SEG1
        add     si,es:[ne_segtab]       ; Mark start segment as preload
if kdebug
        test    byte ptr es:[si].ns_flags,NSPRELOAD
        jnz     scs_pre
        krDebugOut DEB_WARN, "Starting Code Segment of %ES0 must be preload"
        mov     fast_fail, 1
scs_pre:
endif
        or      byte ptr es:[si].ns_flags,NSPRELOAD

        cmp     es:[ne_autodata],0      ; Is there a data segment?
        je      @F
        or      es:[si].ns_flags,NSUSESDATA ; Yes, then it needs it
        mov     si,es:[ne_pautodata]
if kdebug
        test    byte ptr es:[si].ns_flags,NSPRELOAD
        jnz     sds_pre
        cmp     es:[bx].ns_sector, 0    ; don't whine about empty segments
        je      sds_pre
        krDebugOut DEB_WARN, "Default Data Segment of %ES0 must be preload"
        mov     fast_fail, 1
sds_pre:
endif
        or      byte ptr es:[si].ns_flags,NSPRELOAD ; Mark DS as preload
@@:
        test    es:[ne_flags],NENOTP    ; No stack if not a process
        jnz     @F
        cmp     es:[ne_stack],4096+1024
        jae     @F
        mov     es:[ne_stack],4096+1024 ; 4k stack is not enough (raor)
@@:        
        mov     cx, es:[ne_heap]        ; If the module wants a heap
        jcxz    leh_heapadjdone         ;   make sure it's big enough                                                                                                                       
        mov     ax, 800h                ; ; Environment variables have                                                                    
        cmp     cx, ax                  ; grown, so we need more heap 
        jae     leh_heapadjdone         ; space for apps so we use 800h              
        mov     dx, ax
        test    es:[ne_flags],NENOTP
        jnz     @F
        add     dx, es:[ne_stack]
        jc      leh_heapadjmin     
@@:
        mov     bx,es:[ne_autodata]  ; set if no autodata segment
        or      bx,bx                ; we have to do this here
        jz      leh_heapadjset       ; because for certain dlls
        dec     bx                   ; pautodata is not initialized
        shl     bx,1
        mov     cx,bx
        shl     bx,1
        shl     bx,1
        add     bx,cx
        add     bx,es:[ne_segtab]
        add     dx, es:[bx].ns_minalloc        
        jnc     leh_heapadjset
                
leh_heapadjmin:
                                        ; if 800h is too big fallback to
if KDEBUG                               ; what win9x code used as minimum
        mov     ax, 100h + SIZE LocalStats ; heap size 100h
else                                       
        mov     ax, 100h               
endif           
        mov     cx, es:[ne_heap]                       
        cmp     cx, ax
        jae     leh_heapadjdone
leh_heapadjset:
        mov     es:[ne_heap], ax
leh_heapadjdone:

        mov     ax,es                   ; Set owner to be itself
        cCall   FarSetOwner,<ax,ax>

        mov     dx,exetype
        test    dh,NEINFONT             ; save the font bit in exehdr
        jz      reexit                  ;  somewhere
        or      es:[ne_flags],NEWINPROT
end_fault_trap

reexit:
;       cmp     ax, 20h                 ; translate error messages for ret
;       jae     @F
;       mov     bx, ax
;       xor     ax, ax
;       cmp     bl, 1                   ; bx is 0, 1, 2, 19, other
;       jz      @F                      ; 1 -> 0 (out of memory)
;       mov     al, 11
;       jb      @F                      ; 0 -> 11 (invalid format)
;       cmp     bl, 3                   ;
;       mov     al, 10
;       jb      @F                      ; 2 -> 10 (windows version)
;       mov     al, 19                  ; 3 -> 19 (compressed EXE)
;       jz      @F                      ; others left alone
;       mov     al, bl
;@@:
        push    dx
        mov     bx, hBlock
        or      bx, bx
        je      noUnlock                ; No block to unlock
        push    ax
        cCall   IGlobalUnlock,<bx>
        push    ss
        pop     ds                      ; might be freeing DS
        cmp     fast_fail, 1            ; is fastload area invalid?
        jne     @F
leh_slow:
        krDebugOut      DEB_WARN, "FastLoad area ignored due to incorrect segment flags"
        cCall   IGlobalFree,<hBlock>    ; yes - free it, force slow-load
        mov     hBlock, 0
@@:
        pop     ax
        cmp     ax, LME_MAXERR
        jae     noFree                  ; Success, return memory block in bx
        push    ax
        cCall   IGlobalFree,<hBlock>
        pop     ax
noFree:
        mov     cx, NEFileOffset        ; Return offset of header in CX
        mov     bx, hBlock
noUnlock:
        pop     dx
        UnSetKernelDS
cEnd

sEnd    NRESCODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\ldopen.asm ===
TITLE   LDOPEN - Open and Delete Pathname primitives

.xlist
include kernel.inc
include newexe.inc
include tdb.inc
include pdb.inc
.list

externFP AnsiUpper
externFP Int21Handler
externFP <lstrcpy>
ifdef FE_SB
externFP FarMyIsDBCSLeadByte
externFP FarMyIsDBCSTrailByte
endif
ifdef WOW
externFP GetDriveType
endif

;** Equates for the Directory Table code
DT_CURDIR       EQU     1
DT_WINDIR       EQU     2
ifndef WOW
DT_SYSDIR       EQU     3
DT_APPDIR       EQU     4
MAX_SEARCH      EQU     4
else
DT_SYS16DIR     EQU     3
DT_SYSDIR       EQU     4
DT_SYSWX86DIR   EQU     5
DT_APPDIR       EQU     6
MAX_SEARCH      EQU     6
endif


DataBegin

externB fInt21
externB OutBuf
externB szCannotFind1
externB szCannotFind2
externB szDiskCap
externB LastDriveSwapped
externB fNovell
externB fBooting
externW bufpos
externW cBytesWinDir
externW cBytesSysDir
externW TopPDB
externW curTDB
externD lpWindowsDir
externD lpSystemDir
externD pSysProc
externD pKeyProc
externD pKeyProc1
externD pSErrProc
externW wMyOpenFileReent

;** These variables needed to implement the app dir searching
externW loadTDB
externW fLMDepth

staticW myofint24,0

ifdef WOW
externD lpSystem16Dir
externW cBytesSys16Dir
externD lpSystemWx86Dir
externW cBytesSysWx86Dir
endif

;** Directory table for different search orders.  Pgm Management-aware!!

; DIRTABLE struc holds pointers to previously searched paths so we don't
;       repeat the path searches
DIRTABLE STRUC
dt_lpstr        DD      ?
dt_wLen         DW      ?
DIRTABLE ENDS

dtDirTable LABEL DWORD
        public dtDirTable

        DB      (SIZE DIRTABLE) * MAX_SEARCH DUP (0)

; These tables drive the search order loops, determining which paths
;       to search in which order.  The DOS/Novell path is always searched
;       last.

BootOrder LABEL BYTE
        DB      DT_SYSDIR
        DB      DT_WINDIR
        DB      0
DefaultOrder LABEL BYTE
        DB      DT_CURDIR
        DB      DT_WINDIR
ifdef WOW                          ; Search 16-bit system dir (\windir\system)
        DB      DT_SYS16DIR
endif
        DB      DT_SYSDIR
ifdef WOW                          ; Search Wx86 system dir (\windir\system32\Wx86)
        DB      DT_SYSWX86DIR
endif
        DB      DT_APPDIR
        DB      0
        public BootOrder, DefaultOrder

        ;** Static variables
szCurDir        DB      128 DUP (0)     ;Points to fully qualified current dir
pCurDirName     DW      0               ;Points to 8.3 filename
wCurDirLen      DW      0               ;Length of path minus 8.3 filename
        public pCurDirName, wCurDirLen, szCurDir

ifdef WOW
LastOFSearchEntry DW    0               ;Addr of last search table entry used
                                        ;for continuing the search.
OFContinueSearch DW     0               ;1 means continue last search
        public LastOFSearchEntry, OFContinueSearch
endif

DataEnd

sBegin  CODE
assumes CS,CODE
assumes DS,NOTHING
assumes ES,NOTHING

externNP MyUpper
externNP PathDrvDSDX
externNP real_DOS

ifdef FE_SB
externNP MyIsDBCSLeadByte
externNP MyIsDBCSTrailByte
endif

;  These constants are the same as the OF_* values, but are a single byte
;       for efficiency
fReOpen equ     10000000b
fExist  equ     01000000b
fPrompt equ     00100000b
fCreate equ     00010000b
fCancel equ     00001000b
fVerify equ     00000100b
fSearch equ     00000100b
fDelete equ     00000010b
fParse  equ     00000001b

;** Flags to InternalOpenFile
IOF_SYSTEM      EQU     1

;!!!!!! Everything from here to the next !!!!! rewritten Aug 2-5 1991 [jont]

;-----------------------------------------------------------------------;
; OpenFile
;                                                                       ;
; OpenFile:  Opens the given file (with LOTS of options)                ;
;       The search order is defined above in the data section and is    ;
;       table-driven.                                                   ;
;                                                                       ;
; Arguments:                                                            ;
;       ParmD   lpstrSourceName                                         ;
;       ParmD   lpOFStruct                                              ;
;       ParmW   Command                                                 ;
;                                                                       ;
; Returns:                                                              ;
;       AX = file handle                                                ;
;                                                                       ;
; Error Returns:                                                        ;
;       AX = error code                                                 ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       DI,SI,DS                                                        ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;                                                                       ;
; Calls:                                                                ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Mon Oct 12, 1987 09:06:05p  -by-  David N. Weise   [davidw]          ;
; Added this nifty coment block.                                        ;
;                                                                       ;
;  August 5, 1991 -by- Jon Thomason [jont]                              ;
;       Rewrote large sections.  Made it table-driven to allow          ;
;       changing search paths.  Made it return extended error codes     ;
;       for all file not found errors.  Generally made it into a        ;
;       humanly-readable module.                                        ;
;                                                                       ;
;-----------------------------------------------------------------------;


cProc   IOpenFile, <PUBLIC,FAR>, <si,di,ds>
        parmD   lpSrcFile               ;String pointing to filename
        parmD   lpOFStruct              ;Points to OFSTRUCT
        parmW   wFlags                  ;LowB is DOS flags, High is OF flags
        localD  lpDestDir               ;Points to dest dir in OFSTRUCT
cBegin
        SetKernelDS

        ;** If the file is to be reopened, do it
        test    BYTE PTR wFlags[1],fReopen ;Reopen file?
        jz      IOF_NoReopen            ;No
        les     di,lpOFStruct           ;Point to structure
        cCall   ReOpenFile, <es,di,wFlags> ;Reopen the file
        jmp     IOF_End                 ;Done
IOF_NoReopen:

ifdef WOW
        ; Reset LastOFSearchEntry if we're not continuing an earlier search
        cmp     OFContinueSearch,0
        jne     @F
        mov     LastOFSearchEntry,0
@@:
endif

        ;** Get a pointer into the OFSTRUCT
        mov     di,WORD PTR lpOFStruct[0] ;Point to structure
        lea     di,[di].opFile          ;Point to string
        mov     WORD PTR lpDestDir[0],di ;Save in temp variable
        mov     di,WORD PTR lpOFStruct[2] ;Get the selector
        mov     WORD PTR lpDestDir[2],di


        ;** Parse the filename and prepare for searching
        mov     bx,dataOFFSET szCurDir  ;Point to dest string
        les     si,lpSrcFile            ;Point to source string
if 0
        krDebugOut DEB_WARN,"WOW16 IOpenFile:Filename @ES:SI"
endif
        cCall   ParseFileName, <es,si,ds,bx,wFlags>

        ;** Check for error
        or      ax,ax                   ;Error?
        jnz     @F                      ;No

        mov     ax,0                    ;Flag that this is a parse error
        mov     bx,dataOFFSET szCurDir  ;pass lpSrcFile as error string
        cCall   ErrorReturn, <lpOFStruct,ds,bx,lpSrcFile,wFlags,ax>
        jmp     IOF_End                 ;Get out
@@:
        ;** If they just wanted to parse, fill in the structure and return
        test    BYTE PTR wFlags[1],fParse ;Parse only?
        jz      @F                      ;No, skip this
        mov     bx,dataOFFSET szCurDir  ;Point to full pathname with DX:BX
        mov     dx,ds
        xor     ax,ax                   ;No file handle
        jmp     IOF_DoCopy              ;Mimic successful file open
@@:
        ;** Save return values for future use
        mov     pCurDirName,bx          ;Points to 8.3 name
        mov     wCurDirLen,cx           ;Length of path portion

        ;** See if we should path search (flag returned in DX)
        or      dx,dx
        jz      IOF_InitSearch          ;Do the search

        ;** Try to open the file without searching any other dirs
        les     bx,lpDestDir            ;Point to dest dir
        mov     di,dataOFFSET dtDirTable ;Point to the start of the DirTable
        cCall   GetPath, <DT_CURDIR,di,es,bx> ;Dest dir returned in ES:BX
        cCall   OpenCall, <es,bx,wFlags> ;Try to open it
        jc      @F
        jmp     IOF_Success
@@:     jmp     IOF_Error         ;File found but problem opening

        ;** Point to the proper search order
IOF_InitSearch:
        SetKernelDS
ifdef WOW
        cmp     OFContinueSearch,0
        je      @F
        mov     OFContinueSearch,0      ;consumed the flag, reset it
        mov     si,LastOFSearchEntry
        or      si,si                   ;Were we searching at all?
        jnz     IOF_WereSearching       ;Yes
        jmp     short IOF_FileNotFound  ;No searching, so give up now.
IOF_WereSearching:
        cmp     si,-1                   ;Already tried SearchPath?
        jne     IOF_RestartSearch       ;No, pick up where we left off in order
IOF_FileNotFound:
        mov     ax,2                    ;SearchPath found it last time, so
        jmp     IOF_Error               ;it won't find a different one this
                                        ;time, se we return File not found
IOF_RestartSearch:
        inc     si
        mov     LastOFSearchEntry,si
        mov     al,[si]
        cbw
        or      al,al
        mov     di,dataOFFSET dtDirTable;Point to the start of the DirTable
        jnz     IOF_SearchLoop          ;Pick up with next in search order
        jmp     short IOF_SearchPath    ;Restarting after last in search
                                        ;order, so try DOS/Novell path.
@@:
endif
        mov     si,dataOFFSET DefaultOrder
        cmp     fBooting,0              ;Booting?
        jz      IOF_DoSearch            ;No
        mov     si,dataOFFSET BootOrder
IOF_DoSearch:
ifdef WOW
        mov     LastOFSearchEntry,si
endif
        mov     al,[si]                 ;Get the first search code
        cbw
        mov     di,dataOFFSET dtDirTable ;Point to the start of the DirTable

        ;** Loop through until we have no more directories to search or
        ;**     until the file is found
IOF_SearchLoop:
        
        ;** Get the path and filename for this index entry
        les     bx,lpDestDir            ;Point to dest dir
        cCall   GetPath, <ax,di,es,bx>  ;Returns pointer to dest dir in ES:BX
        or      bx,bx                   ;Duplicate dir?
        jz      IOF_Continue            ;Yes, skip this

        ;** Try to open the file
        cCall   OpenCall, <es,bx,wFlags> ;Try to open it
        jnc     IOF_Success             ;File was found
        cmp     ax,3                    ;Errors 3 or less mean file not found
        ja      IOF_Error               ;File found but problem opening

        ;** File not found, so try next path if any
IOF_Continue:
        add     di,SIZE DIRTABLE        ;Bump to next DirTable entry
        inc     si                      ;Bump to next code in list
ifdef WOW
        mov     LastOFSearchEntry,si
endif
        mov     al,[si]                 ;Get this code
        cbw                             ;Make it a WORD
        or      al,al                   ;Done?
        jnz     IOF_SearchLoop          ;No

        ;** Try the DOS/Novell path next
ifdef WOW
IOF_SearchPath:
        xor     si,si
        dec     si
        mov     LastOFSearchEntry,si
endif
        les     di,lpDestDir            ;Point to the dest dir
        mov     si,pCurDirName          ;Point to the 8.3 name
        cCall   SearchFullPath, <ds,si,es,di,wFlags>
        jc      IOF_Error               ;Not found here either

        ;** On SUCCESS, we come here.  Delete the file and close if
        ;**     necessary
IOF_Success:
        mov     bx,WORD PTR lpDestDir[0] ;Point to filename with DX:BX
        mov     dx,WORD PTR lpDestDir[2]
IOF_DoCopy:
        les     si,lpOFStruct           ;Point to OFSTRUCT
        cCall   SuccessCleanup, <dx,bx,es,si,wFlags,ax> ;Finish up
        jmp     SHORT IOF_End

        ;** On ERROR, complete the structure and return the error code
IOF_Error:
        les     si,lpOFStruct
        mov     bx,dataOFFSET szCurDir  ;Point to current dir
        cCall   ErrorReturn, <es,si,ds,bx,ds,pCurDirName,wFlags,ax>
IOF_End:

cEnd


;---------------------------------------------------------------------------
;  ReOpenFile
;
;       Does a fast reopen of a file that has already been opened.
;       Returns proper value in AX for return from OpenFile
;
;       Trashes everything but si,di,ds
;
;---------------------------------------------------------------------------

cProc   ReOpenFile, <PUBLIC,NEAR>, <si,di,ds>
        parmD   lpStruct                ;LPOFSTRUCT parameter
        parmW   wFlags                  ;OpenFile flags
        localW  hFile
cBegin
        ;** Set up for the reopen
        lds     si,lpStruct             ;Point to the OFSTRUCT
        lea     dx,[si].opFile          ;DS:DX -> path
        call    PathDrvDSDX             ;Make sure DRV letter is valid
        jc      ROF_SetDrvErr

        ;** Set up for either an OPEN or a CREATE
        mov     al,BYTE PTR wFlags[0]   ;Get the access bits
        test    BYTE PTR wFlags[1],fCreate ;Create file or open
        jnz     ROF_CreateIt            ;In create case, we just do it
        mov     ah,3dh                  ;Open file call
        jmp     SHORT @F
ROF_CreateIt:
        mov     ah,3ch                  ;Create file call
@@:     xor     cx,cx                   ;Default file attributes
        call    real_DOS                ;Skip overhead of Int21Handler
        jnc     ROF_10                  ;Continue on no error
        jmp     SHORT ROF_GetError      ;Get out on error

ROF_SetDrvErr:
        lds     si,lpStruct             ;Point to the OFSTRUCT
        mov     [si].opXtra,ax          ;In OFSTRUCT, this is the error code
        mov     ax,-1                   ;Error return
        jmp     ROF_End                 ;Error

ROF_10: mov     bx,ax                   ;Get handle
        mov     hFile,ax                ;Save handle for later
ifdef WOW
        xor     cx,cx
        xor     dx,dx
        push    ds
        SetKernelDS ds
        cmp     fLMdepth,cx             ; Called From Loader ?
        pop     ds
        UnSetKernelDS ds
        jnz      @f                     ; Yes -> Ignore Date/Time
endif
        mov     ax,5700h                ;Get time and date of file
        DOSCALL
@@:
        mov     ax,bx                   ;Put file handle back in ax
        test    BYTE PTR wFlags[1],fVerify ;Should we test time/date?
        jz      ROF_VerifyOK
        cmp     [si].opDate,dx          ;Same date as original?
        jnz     ROF_ErrorClose          ;No
        cmp     [si].opTime,cx          ;Same time as original?
        jnz     ROF_ErrorClose          ;No
ROF_VerifyOK:
        mov     es:[si].opTime,cx       ;Save the date and time
        mov     es:[si].opDate,dx

        ;** See if we were supposed to just get the name, or find file
        test    BYTE PTR wFlags[1],fDelete or fExist
        jz      ROF_Done                ;Nope, we're done

        ;** If the user specified OF_DELETE, we don't want
        ;**     the file open, so close it here.
        ;**     NOTE: THIS CODE IS DUPLICATED IN FillOFStruct()!!!!
        mov     bx,hFile                ;Get handle
        mov     ah,3Eh                  ;Close the file
        DOSCALL

        ;** See if we should delete the file
        test    BYTE PTR wFlags[1],fDelete
        jz      ROF_Done                ;Nope, we're done
        smov    ds,es                   ;DS:DX points to full pathname
        UnSetKernelDS
        lea     dx,[si].opFile
        mov     ah,41h                  ;Delete the file
        DOSCALL
        jnc     ROF_Done                ;Return the file handle for compat.

        ;** Get extended error always
ROF_GetError:
        mov     ah,59h                  ;See if there is an extended error
        xor     bx,bx
        push    bp                      ;GetExtendedError trashes regs
        push    si
        push    es
        DOSCALL
        pop     es
        pop     si
        pop     bp
        mov     [si].opXtra,ax          ;In OFSTRUCT, this is the error code
        mov     ax,-1                   ;Error return
        jmp     SHORT ROF_End

ROF_ErrorClose:
        mov     bx,hFile                ;Get the file handle
        mov     ah,3Eh                  ;Close the bogus file
        DOSCALL
        mov     ax,-1                   ;Error return value
        lds     si,lpStruct             ;Point to the OFSTRUCT
        mov     [si].opXtra,0           ;Non-DOS error
        jmp     SHORT ROF_End           ;Get out

ROF_Done:
        mov     ax,hFile                ;Proper return value for OpenFile
ROF_End:
cEnd


;----------------------------------------------------------------------------
;  ParseFileName
;
;       Prepares to do the various file searches by returning a pointer
;       to the fully qualified path  and to the "pure" filename
;       (just the 8.3 name).
;
;       Returns:
;               AX = TRUE/FALSE function successful (if F, nothing else valid)
;               BX points to start of 8.3 filename
;               CX = Length of path portion of filename
;               DX = TRUE/FALSE: Indicates whether path should be searched
;
;----------------------------------------------------------------------------

cProc   ParseFileName, <PUBLIC,NEAR>, <si,di,ds>
        parmD   lpSrcName               ;Passed in pathname
        parmD   lpDestName              ;String to receive pathname
        parmW   wFlags                  ;Command WORD to OpenFile
        localW  wPathLen                ;Length of path portion of filename
cBegin
        ;** Get the fully qualified pathname in lpDestName
        lds     si,lpSrcName            ;DS:SI points to source file
        les     di,lpDestName           ;ES:DI points to file buffer
        call    ParseFile               ;Form a complete name in buffer
                                        ;  Returns dir len in CX when failing
        or      ax,ax                   ;Successful?
        jz      PFN_End                 ;No, get out
        mov     wPathLen,dx             ;Save length of path (no 8.3)

        ;** This section handles the fSearch flag.  This flag is used to
        ;**     do a path search even when we have a path in front of
        ;**     the filename.
        test    BYTE PTR wFlags[1],fSearch ;Do search even with path?
        jz      PF_NoSearch             ;No.
        xor     di,di                   ;Indicate no slashes
PF_NoSearch:         

        ;** Convert the filename to OEM
        lds     si,lpDestName           ;Point to full path
        cCall   MyAnsiToOem,<ds,si,ds,si>

        ;** Return arguments
        mov     ax,1                    ;Success
        mov     bx,WORD PTR lpDestName[0] ;Get the offset of the string
        mov     cx,wPathLen             ;Length of path portion of name
        add     bx,cx                   ;Point to start of string
        inc     bx                      ;Skip slash
        mov     dx,di                   ;Slashes/path search flag

PFN_End:
cEnd


;----------------------------------------------------------------------------
;  GetPointer
;
;       Given an index number, returns a pointer to the path associated
;       with this index and its length
;
;       Returns the lpstr in ES:BX, length in CX
;
;       Depends on the order of the DT_* indices
;       Depends on Kernel's DS being set, does not trash it
;
;----------------------------------------------------------------------------

cProc   GetPointer, <PUBLIC,NEAR>, <si,di>
        parmW   wIndex                  ;Index is from search order table
cBegin
        CheckKernelDS
        ReSetKernelDS

        ;** Decode the index numbers
        mov     ax,wIndex               ;Get the index
        dec     ax                      ;DT_CURDIR?
        jz      GT_CURDIR
        dec     ax                      ;DT_WINDIR?
        jz      GT_WINDIR
ifndef WOW
        dec     ax                      ;DT_SYSDIR?
        jz      GT_SYSDIR
else
        dec     ax                      ;DT_SYS16DIR?
        jz      GT_SYS16DIR
        dec     ax                      ;DT_SYSDIR?
        jz      GT_SYSDIR
        dec     ax                      ;DT_SYSWX86DIR?
        jz      GT_SYSWX86DIR
endif
        ; Must be DT_APPDIR

        ;** Find the app's dir
IF KDEBUG
        cmp     fBooting,0              ;Booting?
        jz      @F                      ;No, whew!
        int     1                       ;No app dir during boot process
        int     1
@@:
ENDIF
        ;** Figure out if we should use curTDB or loadTDB.  This is
        ;**     determined by the number of times LoadModule has recursed.
        ;**     We only use the loadTDB pointer if we're in LoadModule the
        ;**     second time and the pointer is not zero.  Otherwise, we
        ;**     use the curTDB pointer.  If we don't do this check, we
        ;**     end up getting the path of the app calling LoadModule
        cmp     fLMDepth,2              ;In LoadModule 2 times?
        jb      GT_UseCurTDB            ;Yes, use curTDB
        mov     ax,LoadTDB              ;Get loadTDB
        or      ax,ax                   ;NULL?
        jnz     GT_UseLoadTDB           ;No, assume it's OK

        ;** Get a pointer to the path stored in the module database
GT_UseCurTDB:
        mov     ax,curTDB               ;Get the TDB pointer
GT_UseLoadTDB:
        mov     es,ax                   ;Point with DS
        mov     es,es:[TDB_pModule]     ;Point to the module database

; BUGBUG ROM was always define (either 1 or 0) so this code always made
; it even in 9X sources
;
;IFDEF ROM
        ; if this is in ROM, then return  0 in CX
        ; makes no sense to get the app's dir, if app is in ROM
        test    es:[ne_flags], NEMODINROM
        jz      @f
        xor     cx, cx
        jmp     SHORT GT_Done
@@:
;ENDIF
        mov     di,es:[0ah]             ;Points to EXE path string (sort of)
                                        ;  (High word of CRC in exe hdr)
        ;** Copy the entire string into the buffer
        add     di,8                    ;Move past data garbage
        push    di                      ;Save start of string
        cCall   GetPureName             ;ES:DI points just after the '\'
        dec     di                      ;ES:DI points to '\'
        pop     bx                      ;ES:BX points to start of string
        mov     cx,di                   ;Compute length of path, not filename
        sub     cx,bx                   ;  (not including \)
        jmp     SHORT GT_Done

        ;** Get the current directory pointer and length
GT_CURDIR:
        smov    es,ds                   ;ES:BX points to szCurDir
        mov     bx,dataOFFSET szCurDir
        mov     cx,wCurDirLen           ;Get path length
        jmp     SHORT GT_Done

GT_WINDIR:
        les     bx,lpWindowsDir         ;Point to windir
        mov     cx,cBytesWinDir
        jmp     SHORT GT_Done

GT_SYSDIR:
        les     bx,lpSystemDir          ;Point to sysdir
        mov     cx,cBytesSysDir
ifdef WOW
        jmp     SHORT GT_Done

GT_SYS16DIR:
        les     bx,lpSystem16Dir        ;Point to sys16dir
        mov     cx,cBytesSys16Dir
        jmp     SHORT GT_Done

GT_SYSWX86DIR:
        les     bx,lpSystemWx86Dir
        mov     cx,cBytesSysWx86Dir
        ;jmp     SHORT GT_Done
endif ;WOW

GT_Done:
        
cEnd


;----------------------------------------------------------------------------
;  GetPath
;
;       Gets the path associated with the given index.  The 8.3 filename
;       is appended to the end of the path and this is copied into the
;       destination directory.  A pointer to this directory is returned
;       in ES:BX or BX is NULL if the directory to be searched would be
;       a duplicate.
;
;       Assumes (and does not trash) kernel's DS
;
;       Calls: GetPointer
;
;----------------------------------------------------------------------------

cProc   GetPath, <PUBLIC,NEAR>, <si,di>
        parmW   wIndex                  ;Index from search order table
        parmW   pDirTable               ;Points to current DIRTABLE entry
        parmD   lpDest                  ;Place to copy filename
cBegin
        CheckKernelDS

        ;** Gets the pointer and length of the requested string
        cCall   GetPointer, <wIndex>    ;lpstr in ES:BX, len in CX
; BUGBUG ROM was always define (either 1 or 0) so this code always made
; it even in 9X sources
;
;IFDEF ROM
        or      cx, cx                  ; if in ROM && APPDIR
        jnz     @f
        xor     bx, bx
        jmp     SHORT GP_End
@@:
;ENDIF
        ;** Save it in the table
        mov     di,pDirTable            ;Point to the table entry
        mov     WORD PTR [di].dt_lpstr[0],bx
        mov     WORD PTR [di].dt_lpstr[2],es
        mov     [di].dt_wLen,cx

        ;** Check for duplicates
        mov     si,bx                   ;Point to string with SI
        mov     bx,dataOFFSET dtDirTable ;Point to the start of the table
GP_Loop:
        cmp     bx,di                   ;Checked everything before us yet?
        je      GP_Done                 ;Yes
        
        ;** Compare the strings
        cmp     cx,[bx].dt_wLen         ;Compare lengths
        jne     GP_Continue             ;No dup here
        mov     dx,cx                   ;Save len in DX
        push    si
        push    di
        push    ds
        les     di,ds:[di].dt_lpstr     ;Point to the strings to be compared
        lds     si,ds:[bx].dt_lpstr
        repe    cmpsb                   ;Compare the strings
        pop     ds
        pop     di
        pop     si
        or      cx,cx                   ;At end of string?
        jz      GP_FoundMatch           ;Yes, we matched so ignore this string
        mov     cx,dx                   ;Get len back in CX
GP_Continue:
        add     bx,SIZE DIRTABLE        ;Bump to next table entry
        jmp     GP_Loop

GP_FoundMatch:
        mov     WORD PTR [di].dt_lpstr[0],0 ;Null out this entry
        mov     WORD PTR [di].dt_lpstr[2],0
        mov     [di].dt_wLen,0
        xor     bx,bx                   ;Return NULL
        jmp     SHORT GP_End

GP_Done:
        ;** Copy the string in
        push    ds                      ;Save DS around this
        lds     si,[di].dt_lpstr        ;Return ES:BX pointing to string
        les     di,lpDest               ;Point to buffer to copy string to
        mov     bx,di                   ;Point with BX to struct
        rep     movsb                   ;Copy the strings
        pop     ds                      ;Restore KERNEL's DS

        ;** Put a '\' only if needed
IFDEF FE_SB
        push    si
        push    di
        mov     si,word ptr lpDest[0]       ;es:si -> string address
        dec     di                          ;di points to the last valid byte
        call    MyIsDBCSTrailByte           ;the last byts a DBCS trailing byte?
        pop     di
        pop     si
        jnc     GP_DoSlash                  ;yes, go ahead to append a '\'
                                            ;no, fall through
ENDIF
        cmp     BYTE PTR es:[di - 1],'\';Terminating slash?
        je      GP_SkipSlash            ;Yes
        cmp     BYTE PTR es:[di - 1],'/';Terminating slash?
        je      GP_SkipSlash            ;Yes
GP_DoSlash:
        mov     al,'\'                  ;Get the slash
        stosb                           ;  and write it
GP_SkipSlash:

        ;** Copy the filename
        mov     si,pCurDirName          ;Point to the 8.3 filename
        call    strcpyreg
;GP_83Loop:
;       lodsb                           ;Get the char
;        stosb                           ;  and write it
;        or      al,al                   ;Done?
;        jnz     GP_83Loop               ;Nope
                                        ;Returns ES:BX points to filename
GP_End:
cEnd


;----------------------------------------------------------------------------
;  OpenCall
;
;       Does the open/create file call.  The file is either opened
;       or created.  The handle or the error code is returned.
;       The extended error code is returned only if the error was not
;       that the file or path was not found (errors 2 & 3).
;       Carry is set on error.
;
;----------------------------------------------------------------------------

cProc   OpenCall, <PUBLIC,NEAR>, <si,di,ds>
        parmD   lpString                ;String to open
        parmW   wFlags                  ;OpenFile flags
        localW  wInt21AX                ;Int 21 AX value
cBegin
        ;** HACK to allow SearchPath to use this call.
        ;**     If wFlags is -1, look for flags preset in AX
        cmp     wFlags,-1               ;wFlags?
        jnz     OC_Normal               ;Yes, proceed normally
        mov     wInt21AX,ax             ;Save these flags
        jmp     SHORT OC_10             ;  and go on

        ;** Set up for either an OPEN or a CREATE
OC_Normal:
        mov     al,BYTE PTR wFlags[0]   ;Get the access bits
        test    BYTE PTR wFlags[1],fCreate ;Create file or open
        jnz     OC_CreateIt             ;In create case, we just do it
        mov     ah,3dh                  ;Open file call
        mov     wInt21AX,ax             ;Save in temp var
        jmp     SHORT OC_10
OC_CreateIt:
        mov     ah,3ch                  ;Create file call
        and     al,3                    ;Strip incompatbile share bits, etc.
        mov     wInt21AX,ax             ;Save it
        jmp     SHORT OC_DoDOSCall      ;Just do it in create case

OC_10:  SetKernelDS
        cmp     fNovell,0               ;On Novell?
        je      OC_DoDOSCall            ;No, just do normal stuff

        ;** We do a Get Attribute call instead of trying to open the file
        ;**     because doing a normal file open on Novell causes them
        ;**     to search their entire path.
        lds     dx,lpString             ;Get the pathname
        mov     ax,4300h                ;Get file attributes
        DOSCALL                         ;Does the file exist?
        jc      OC_NotThere             ;No

        ;** Try to open the file here.  In case of Novell, we already know
        ;**     it's here, so now open it
OC_DoDOSCall:
        xor     cx,cx                   ;Normal files ONLY!!
        mov     ax,wInt21AX             ;Get function code + access flags
        lds     dx,lpString             ;Get the pathname
        DOSCALL                         ;Try to open the file
        jc      OC_NotThere             ;File can't be opened
        jmp     SHORT OC_FileOpened     ;Success

OC_NotThere:
        cmp     ax,3                    ;Errors 2 & 3 are file not found
        jbe     OC_NoExtError           ;No extended error for file not found
        SetKernelDS
        cmp     wMyOpenFileReent, 0     ;No ext err for MyOpenFile
        jnz     OC_NoExtError
        mov     ah,59h                  ;See if there is an extended error
        xor     bx,bx
        push    bp                      ;GetExtendedError trashes bp
        DOSCALL
        pop     bp
OC_NoExtError:
        stc                             ;Return error

OC_FileOpened:                          ;CY must be clear here on success

cEnd


;----------------------------------------------------------------------------
;  SearchFullPath
;
;       Searches the full DOS/Novell path for the file
;
;       Returns the file handle on success or the error code on failure
;       Carry set on error
;
;----------------------------------------------------------------------------

cProc   SearchFullPath, <PUBLIC,NEAR>, <si,di,ds>
        parmD   lpSource                ;8.3 filename
        parmD   lpDest                  ;Place to copy pathname
        parmW   wFlags                  ;OpenFile flags
        localW  wInt21AX
cBegin
        ;** Get the AX WORD for the DOS call
        mov     al,BYTE PTR wFlags[0]   ;Get the access bits
        test    BYTE PTR wFlags[1],fCreate ;Create file or open?
        mov     ah,3dh                  ;Default to open
        jz      @F
        mov     ah,3ch                  ;Create call
@@:     mov     wInt21AX,ax             ;Save it for later

        ;** Use SearchPath() to find the file for us
        push    ds                      ;Save DS across this
        les     di,lpDest               ;Point to usable dest buffer
        lds     si,lpSource             ;Point to source string
        UnsetKernelDS
        cCall   <FAR PTR SearchPath>,<ds,si,es,di,ax>
        pop     ds
        ResetKernelDS
        cmp     ax,-1
        jne     SFP_FoundIt             ;Found the file
        mov     ax,bx                   ;Get error code from SearchPath
        cmp     ax,3                    ;Not found?
        ja      SFP_Error               ;Found but error

        ;** Now try the Novell path if it's there
        cmp     fNovell,0               ;On Novell?
        je      SFP_Error               ;Nope.  Nothing more to try so error
        lds     dx,lpSource             ;Point to 8.3 filename
        UnsetKernelDS
        xor     cx,cx                   ;Normal file type
        mov     ax,wInt21AX             ;Get open or create call plus attrs
        DOSCALL                         ;Do it
        jc     SFP_Error                ;Didn't find it

SFP_FoundIt:
        clc
        jmp     SHORT SFP_End

SFP_Error:
        stc

SFP_End:                                ;Carry should be set/clear correctly
cEnd


;----------------------------------------------------------------------------
;  SuccessCleanup
;
;       Builds the OFSTRUCT structure on a successful open.
;       Closes and deletes file if requested.
;
;----------------------------------------------------------------------------

cProc   SuccessCleanup, <PUBLIC,NEAR>, <si,di,ds>
        parmD   lpGoodPathName          ;Successful path name        
        parmD   lpOFStruct              ;OFSTRUCT param to OpenFile
        parmW   wFlags                  ;OpenFile flags
        parmW   hFile                   ;File handle
cBegin
        ;** Compute the length of the string and OFSTRUCT
        les     di,lpGoodPathName       ;Point to the new pathname
        xor     al,al                   ;Get a zero byte
        xor     cx,cx                   ;Up to 64K
        dec     cx
        repne   scasb                   ;Search for the zero byte
        neg     cx
        mov     ax,cx                   ;Get a copy in AX
        add     ax,(SIZE OPENSTRUC) - 3 ;Length of structure including string

        ;** Copy the successful pathname into the OFSTRUCT if necessary
        dec     cx                      ;This now is string + zero byte len
        les     di,lpOFStruct           ;Point to dest buffer
        lea     di,[di].opFile
        cmp     di,WORD PTR lpGoodPathName[0] ;Offsets the same?
        jne     FOF_DoCopy              ;No, do it
        mov     dx,es                   ;Compare sels
        cmp     dx,WORD PTR lpGoodPathName[2] ;Same?
        je      FOF_NoCopy              ;Yes, no copy needed
FOF_DoCopy:
        lds     si,lpGoodPathName       ;Point to successful path again
        UnSetKernelDS
        rep     movsb                   ;Copy it
FOF_NoCopy:

        ;** Fill out remainder of OFSTRUCT
        les     si,lpOFStruct           ;Point to OFSTRUCT with ES:SI
        lea     di,[si].opFile          ;  and to the pathname with ES:DI
        mov     es:[si].opXtra,0        ;Zero the error
        mov     es:[si].opLen,al        ;Save structure length
        call    AreBooting              ;AreBooting checks Int21 hooks inst
        mov     ah,1                    ;Always booting from hard drive
        jz      FO_NoCheckDrive         ;Int 21 hooks NOT installed yet
        mov     al,es:[di]              ;ES:DI points to string
        or      al,20H                  ;Force it lowercase
        sub     al,'a'                  ;Drive number, zero based
        cbw
        mov     di,ax                   ;Drive number in DI
        call    IsFloppy                ;Returns floppy status in ZF
        mov     ah,0                    ;Zero in case it's a floppy
        jz      FO_NoCheckDrive         ;Must be a floppy disk
        inc     ah                      ;Non-removable media
FO_NoCheckDrive:
        mov     es:[si].opDisk,ah       ;Tell 'em the type of disk
        ;** Get the current file date and time
        mov     bx,hFile                ;Get file handle
        mov     ax,5700h                ;Get date and time
ifdef WOW
        xor     cx,cx
        xor     dx,dx
        push    ds
        SetKernelDS ds
        cmp     fLMdepth,cx             ; Called From Loader ?
        pop     ds
        UnSetKernelDS ds
        jnz      @f                     ; Yes -> Ignore Date/Time
endif
        DOSCALL
@@:
        mov     es:[si].opTime,cx       ;Save the date and time
        mov     es:[si].opDate,dx

        ;** See if we were supposed to just get the name, or find file
        test    BYTE PTR wFlags[1],fExist OR fDelete
        jz      FO_Done                 ;Nope, we're done

        ;** If the user specified OF_EXIST or OF_DELETE, we don't want
        ;**     the file open, so close it here
        ;**     NOTE: THIS CODE IS DUPLICATED IN ReopenFile()!!!!
        mov     bx,hFile                ;Get the handle
        mov     ah,3Eh                  ;Close the file
        DOSCALL
                                        ;We leave the bogus value in hFile
                                        ;  for 3.0 compatibility

        ;** If OF_DELETE is set, we simply delete the file
        test    BYTE PTR wFlags[1],fDelete
        jz      FO_Done
        smov    ds,es                   ;DS:DX points to full pathname
        UnSetKernelDS
        lea     dx,[si].opFile
        mov     ah,41h                  ;Delete the file
        DOSCALL
        mov     ax,1                    ;TRUE return value
        jnc     FO_Done                 ;For 3.0 compatiblity

        mov     ah,59h                  ;See if there is an extended error
        xor     bx,bx
        push    bp                      ;GetExtendedError trashes regs
        push    si
        DOSCALL
        pop     si
        pop     bp
        mov     [si].opXtra,ax          ;In OFSTRUCT, this is the error code
        mov     ax,-1                   ;Error return
        jmp     SHORT FO_END

FO_Done:
        mov     ax,hFile                ;Proper return value for OpenFile

FO_End:
cEnd
        

;----------------------------------------------------------------------------
;  ErrorReturn
;
;       Fills in the return information for error conditions.
;       Returns the proper return value for OpenFile
;
;----------------------------------------------------------------------------

cProc   ErrorReturn, <NEAR,PUBLIC>,<si,di,ds>
        parmD   lpOFStruct              ;OFSTRUCT given to OpenFile
        parmD   lpPath                  ;Path returned, even when invalid
        parmD   lpError                 ;Text for error box
        parmW   wFlags                  ;OpenFile flags
        parmW   wErrCode                ;Error code already computed
cBegin
        UnSetKernelDS
        cmp     wErrCode,0              ;Parse error?
        jnz     @F                      ;No
        mov     wErrCode,2              ;Mimic "File not found" error
        jmp     SHORT ER_ReturnError    ;Never prompt on parse error
@@:     test    BYTE PTR wFlags[1],fPrompt ;Should we do the dialog?
        jz      ER_ReturnError          ;No, return error code
        call    AreBooting              ;if we're still booting, don't prompt
        jz      ER_ReturnError
        lds     di,lpError
        cmp     BYTE PTR ds:[di],0      ;Don't prompt with NULL string.
        je      ER_ReturnError

        cCall   Prompt, <ds,di>         ;Prompt with error string.

ER_ReturnError:
        SetKernelDS
        les     si,lpOFStruct           ;Point to structure again
        mov     ax,wErrCode             ;Get the error code
        mov     es:[si].opXtra,ax       ;In OFSTRUCT, this is the error code
        lea     di,[si].opFile          ;Point to dest string
        lds     si,lpPath               ;Point to the path
        call    strcpyreg
;ER_Copy:
;       lodsb                           ;Copy the sz string for PowerPoint
;        stosb
;        or      al,al                   ;Done?
;        jnz     ER_Copy                 ;No
        UnSetKernelDS
        mov     ax,-1
cEnd


;!!!!!!!!!!!!!! Everything after this is old


;---------------------------------------------------------------------------
;  AreBooting
;
;       Check to see if DOS hook available
;
;---------------------------------------------------------------------------
AreBooting  PROC        NEAR
        push    ds
        SetKernelDS
        cmp     fInt21,0
        pop     ds
        UnSetKernelDS
        ret
AreBooting  ENDP

;---------------------------------------------------------------------------
;  FarGetEnv
;
;       Gets the correct environment, boot time or no
;
;---------------------------------------------------------------------------

FarGetEnv       PROC    FAR
        SetKernelDS
        mov     si,curTDB
        or      si,si
        jz      boot_time
        mov     ds,si
        UnSetKernelDS
        mov     ds,ds:[TDB_PDB]
not_boot_time:
        mov     ds,ds:[PDB_environ]
        xor     si,si
        ret
boot_time:
        ReSetKernelDS
        mov     ds,TopPDB
        UnSetKernelDS
        jmps    not_boot_time
FarGetEnv       ENDP


;-----------------------------------------------------------------------;
; SearchPath                                                            ;
;                                                                       ;
; Searches the PATH as defined in the environment for the given file.   ;
;                                                                       ;                                                                       ;
; Arguments:                                                            ;
;       ParmD   pName    Pointer to name                                ;
;       ParmD   pBuffer  Pointer to temporary buffer                    ;
;       ParmW   Attr     AX paramter for DOS (Open, etc.)               ;
;                                                                       ;
; Returns:                                                              ;
;       AX != 0                                                         ;
;                                                                       ;
; Error Returns:                                                        ;
;       AX = -1, BX is error code                                       ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       DS                                                              ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;       BX,CX,DX,DI,SI,ES                                               ;
;                                                                       ;
; Calls:                                                                ;
;       GetPureName                                                     ;
;       GetFarEnv                                                       ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Mon Oct 12, 1987 08:57:48p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.                                       ;
;-----------------------------------------------------------------------;

cProc   SearchPath,<PUBLIC,FAR>
        ParmD   pName                   ; Pointer to name
        ParmD   pBuffer                 ; Pointer to temporary buffer
        ParmW   Attr                    ; AX paramter for DOS (Open, etc.)

        LocalD  pPureName               ; pointer to stripped name
cBegin
        les     di,pName
        call    GetPureName
        mov     pPureName.off,di
        mov     pPureName.sel,es

        push    cs
        call    near ptr FarGetEnv
        mov     bx, 3                   ; preset error to "path not found"
spth2:  cmp     byte ptr [si],0         ; no more enviroment
        jz      spthNo

        lodsw
        cmp     ax,'AP'                 ; Look for PATH=
        jnz     spth3
        lodsw
        cmp     ax,'HT'
        jnz     spth3
        lodsb
        cmp     al,'='
        jz      spth4
spth3:  lodsb
        or      al,al
        jnz     spth3
        jmp     spth2

spth4:  les     di,pBuffer
spth5:  lodsb
        stosb
        cmp     al,";"
        jz      spth6
        or      al,al
        jnz     spth5
        dec     si

spth6:  mov     al,'\'
ifdef   FE_SB
        push    si
        push    di
        mov     si,word ptr pBuffer     ; buffer address
        dec     di                      ; point di to the byte before ';'
        call    MyIsDBCSTrailByte       ; is it a DBCS trailing byte?
        pop     di
        pop     si
        jnc     spth6a                  ;yes, overwrite ';' with '\'
endif
        cmp     es:[di-2],al            ; path terminated with '\'
        jnz     spth6a
        dec     di
spth6a: mov     es:[di-1],al
        push    ds
        push    si
        cCall   MyAnsiToOem,<pPureName,es,di>

        ;** Call the OpenCall function to search for the file.  It calls
        ;**     the extended error function on failure
        les     si,pBuffer              ;Point to buffer
        mov     ax,Attr                 ;Get the AX word here and flag
        cCall   OpenCall, <es,si,-1>    ;  OpenCall with -1
        mov     bx,ax                   ;Save the error code if any
        pop     si
        pop     ds
        jnc     spthYes
        cmp     byte ptr [si],0         ;At end of path?
        jnz     spth4

spthNo: mov     ax,-1
        ;** Bug 14960:  If the last error code was path not found, the user
        ;**     has a bogus directory in their path.  Since we were unable
        ;**     to find the file, return file not found instead of path not
        ;**     found.   2 November 1991      Clark R. Cyr
        cmp     bx, 3                   ;Path Not Found?
        jne     spthYes
        mov     bx, 2                   ;Make it File Not Found
spthYes:
cEnd


;  MyAnsiToOem
;       Used to do ANSI to OEM conversions.  This function allows routines
;       here to call freely without worrying if the keyboard driver can
;       be called with this yet.  At boot time, we can't call the
;       keyboard driver where these functions reside, so no translation
;       is done.

cProc   MyAnsiToOem, <PUBLIC,NEAR>, <si,di,ds>
        parmD pSrc
        parmD pDst
cBegin
        SetKernelDS
        cmp     pKeyProc.sel,0          ; is there a keyboard yet?
        jnz     mao1                    ; Yes, so do translation
        lds     si, pSrc                ; No, so just copy the strings
        UnSetKernelDS
        les     di, pDst
        call    strcpyreg
;mao0:
;       lodsb
;       stosb
;       or      al, al
;       jnz     mao0
        jmps    mao2
                                        ; Not booting, we can call the
mao1:                                   ; translation routine
        ReSetKernelDS
        cCall   [pKeyProc],<pSrc,pDst>  ; convert string from AnsiToOem
mao2:
cEnd


;  MyOemToAnsi
;       Matching function for MyAnsiToOem.  See comments above

cProc   MyOemToAnsi,<PUBLIC,NEAR>,<si,di,ds>
        parmD pSrc
        parmD pDst
cBegin
        SetKernelDS
        cmp     pKeyProc.sel,0          ; is there a keyboard yet?
        jnz     moa1                    ; Yes, do normal conversion
        lds     si, pSrc                ; No, so just copy the string
        UnSetKernelDS
        les     di, pDst
        call    strcpyreg
;moa0:
;       lodsb
;       stosb
;       or      al, al
;       jnz     moa0
        jmps    moa2

moa1:                                   ; Call the translation routine
        ReSetKernelDS
        cCall   [pKeyProc1],<pSrc,pDst> ; convert string from AnsiToOem
moa2:
cEnd


;---------------------------------------------------------------------
;
;  Is Drive number in DI a floppy? A=0, etc.  ZF = yes, it is a floppy
;
        public  IsFloppy
IsFloppy:
ifdef WOW
        push    dx
        cCall   GetDriveType,<di>
        pop     dx
else
        mov     bx,1            ; 1 = Get Drive Info from InquireSystem
        push    es
        push    ds
        SetKernelDS
        cCall   [pSysProc],<bx,di>
        pop     ds
        UnSetKernelDS
        pop     es
endif
        cmp     al,2            ; 2 = removable media
        ret

FarIsFloppy PROC        FAR
        call    IsFloppy
        ret
FarIsFloppy ENDP


;----------------------------------------------------------------------------
;  Prompt
;
;       Puts up the system error box telling the user the file can't be found
;
;----------------------------------------------------------------------------

cProc   Prompt, <NEAR,PUBLIC>, <si,di,ds>
        parmD   lpstr
cBegin
        SetKernelDS
        mov     ax,3                    ;Assume CANCEL
        cmp     pSErrProc.sel,0         ;Is there a USER yet?
        jz      P_End                   ;No

        ;** Format the string <szCannotFind1><lpstr><szCannotFind2>
        push    ds
        pop     es
        mov     di, dataOffset OutBuf   ; ES:DI points to dest
        mov     si, dataOffset szCannotFind1
        call    strcpyreg

        lds     si, [lpstr]
        mov     al, byte ptr ds:[si]
        UnSetKernelDS
        mov     es:[LastDriveSwapped], al
        call    strcpyreg

        push    es
        pop     ds
        ReSetKernelDS
        mov     si, dataOffset szCannotFind2
        call    strcpyreg

        ;** Prepare the dialog box
        push    ds                      ;In our DS
        push    dataOFFSET OutBuf       ;Point to "Cannot find" string

        push    ds
        push    dataOffset szDiskCap    ;Caption

        push    0                       ;No left button

        push    SEB_CLOSE + SEB_DEFBUTTON ;Button 1 style

        push    0                       ;No right button

        call    [pSErrProc]             ;Put up the system error message

P_End:
        xor     ax,ax
cEnd


;----------------------------------------------------------------------------
;  StartString
;
;       Prepares the start of the string for the sys error box
;
;       ES:BX is the pointer to the full pathname
;       DS:DX is the string "Can't find file X:"
;
;----------------------------------------------------------------------------

cProc   strcpyreg, <NEAR,PUBLIC>
cBegin  nogen
        cld
@@:     lodsb                           ; copy from DS:SI
        stosb                           ; to ES:DI
        or      al, al
        jnz     @B                      ; including 0
        dec     di                      ; point to trailing 0
        ret
cEnd    nogen


;cProc   StartString, <NEAR,PUBLIC>
;cBegin  NOGEN
;       CheckKernelDS
;       ReSetKernelDS
;
;       ;** Copy the first part of the string
;       cld
;       push    es                      ;Save the parameter
;       push    bx
;       mov     dx,dataOffset szCannotFind1 ;Point to Can't Find string
;       call    AppendFirst             ;Put in OutBuf
;       pop     bx
;       pop     es
;
;       ;** Save the drive letter for compatibility with ancient disk swaps
;       mov     al,es:[bx]              ;Get drive letter
;       mov     [LastDriveSwapped],al   ;Save it for GetLastDiskChange
;
;       ;** Append the filename portion
;       smov    ds,es
;       mov     dx,bx
;       jmps    Append
;
;cEnd    NOGEN


;  AppendFirst & Append
;       Append ASCIIZ string to the static string OutBuf
;
;       ENTRY:  DS:DX points to a string to append to the static buffer
;
;       AppendFirst clears the static string and appends the new string
;       as the first part of the string.
;       Append just appends the new string on the end of the current string.

cProc   AppendFirst, <PUBLIC,NEAR>
cBegin  NOGEN
        CheckKernelDS
        ReSetKernelDS
        mov     [BufPos],dataOffset OutBuf
        UnSetKernelDS

;Append:
        push    si                      ;Save some registers
        push    di
        SetKernelDS     es
        mov     di,[BufPos]
        mov     si,dx
        call    strcpyreg
;ap1:   lodsb
;       stosb
;       or      al,al
;       jnz     ap1
        dec     di
        mov     [BufPos],di
        pop     di
        pop     si
        ret
cEnd    NOGEN
        UnSetKernelDS   es


;  GetPureName
;       Strips the drive and directory portions of a pathname off.
;       ENTRY:  ES:DI points to pathname
;       EXIT:   ES:DI points to "pure" name in same string

cProc   GetPureName, <NEAR,PUBLIC>
cBegin

        ;** Do FE_SB version:
        ;*      It is not possible to search filename delimiter by backward
        ;**     search in case of FE_SB version, so we use forward search.
IFDEF FE_SB
        mov     bx,di
iup0:
        mov     al,es:[di]
        test    al,al                   ; end of string?
        jz      iup2                    ; jump if so
        inc     di
        cmp     al,'\'
        jz      iup1
        cmp     al,'/'
        jz      iup1
        cmp     al,':'
        jz      iup1
        call    MyIsDBCSLeadByte        ; see if char is DBC
        jc      iup0                    ; jump if not a DBC
        inc     di                      ; skip to detemine 2nd byte of DBC
        jmp     iup0
iup1:
        mov     bx,di                   ; update purename candidate
        jmp     iup0
iup2:
        mov     di,bx                   ; di points purename pointer

        ;** Do normal version:
        ;**     Here we can just back up until we find the proper char
ELSE
        cld
        xor     al,al
        mov     cx,-1
        mov     bx,di
        repne   scasb
        inc     cx
        inc     cx
        neg     cx
iup0:   cmp     bx,di                   ; back to beginning of string?
        jz      iup1                    ; yes, di points to name
        mov     al,es:[di-1]            ; get next char
        cmp     al,'\'                  ; next char a '\'?
        jz      iup1                    ; yes, di points to name
        cmp     al,'/'                  ; next char a '/'
        jz      iup1
        cmp     al,':'                  ; next char a ':'
        jz      iup1                    ; yes, di points to name
        dec     di                      ; back up one
        jmp     iup0
iup1:
ENDIF

cEnd


;  ParseFile
;       
;       ENTRY:  DS:SI points to unqualified pathname
;               ES:DI points to buffer to be used for qualified name
;       EXIT:   Buffer previously pointed to by ES:DI now has full
;               unambiguous pathname
;               DX is length of path portion of entered pathname
;               AX is total length of pathname
;               DI is number of slashes
;               CX is length of path ON ERROR ONLY!!! (for PowerPoint)

LONG_UNC_NAMES equ 1

cProc   ParseFile, <NEAR,PUBLIC>
        localW  cSlash                  ;Word ptr [bp][-2]
        localW  cchPath                 ;Word ptr [bp][-4]
        localW  fUNC                    ;Flag for UNC name (\\foo\bar)
if LONG_UNC_NAMES
        localW  fCountUNC               ;Indicates we are parsing UNC name
else
        localW  fFirstUNC               ;Indicates we are parsing UNC name
endif

cBegin
        mov     cSlash,0                ;Zero the local variables
        mov     cchPath,0
        mov     fUNC,0                  ;Assume it's not UNC
        cld

        ;** If a drive is on the path, parse it.  Otherwise, get the current
        ;**     drive.
        cmp     byte ptr ds:[si+1],':'
        jne     nodrive
        lodsb
        inc     si
        or      al,20h                  ; convert to lower case
        sub     al,'a'                  ; convert to number
        jb      @F                      ;Not valid, so return error
        cmp     al,'z'-'a'
        jbe     gotdrive
@@:     jmp     gpFail2
nodrive:
        mov     ah,19h
        DOSCALL
gotdrive:
        mov     dl,al
        inc     dl
        add     al,'A'                  ; convert to ascii
        mov     ah,':'

        ;** If this is a UNC name, we don't want to copy the drive letter
        ;**     as it is legal but unnecessary for a full path
        mov     fUNC, 1
if LONG_UNC_NAMES
        mov     fCountUNC, 2
else
        mov     fFirstUNC, 1
endif
        cmp     WORD PTR ds:[si], '\\'  ;Is this a UNC? (\\foo\bar)
        je      PF_DriveOK              ;Yes, don't insert drive
        cmp     WORD PTR ds:[si], '//'  ;Is this a UNC? (//foo/bar)
        je      PF_DriveOK              ;Yes, don't insert drive
        mov     fUNC, 0                 ;Nope, not UNC
if LONG_UNC_NAMES
        mov     fCountUNC, 0
else
        mov     fFirstUNC, 0
endif

        stosw                           ;Write drive letter and colon
        add     cchPath,2               ;Add two chars to path len
PF_DriveOK:
        push    di                      ; Save beginning of path

        ;** If we start with a slash, we have a qualified path here
        ;*      so we don't have to search to find the current path.
        ;**     Otherwise, we have to find where we are and make the path.
        mov     bx,'/' shl 8 + '\'      ;Separator characters
        mov     al,ds:[si]              ;Get first character
        cmp     al,bh                   ;If it's either one, we have a
        je      getpath0                ;  full path, so don't search
        cmp     al,bl
        je      getpath0
        mov     al,bl                   ;Get a '\'
        stosb                           ;  and put in the buffer
        inc     cchPath                 ;Bump path count
        mov     cx,ds                   ;Prepare for DOS call:  Save DS
        xchg    si,di                   ;DS:SI needs to point to buffer
        mov     ax,es
        mov     ds,ax
        mov     ah,47h                  ;DOS #47:  Get Current Directory
        DOSCALL
        jnc     @F
        jmp     gpfail
@@:
        push    cx                      ;DOS returns OEM characters
        push    bx                      ;  so convert to ANSI
        cCall   MyOemToAnsi,<ds,si,ds,si>
        pop     bx
        pop     ds
        xchg    si,di                   ;Get pointer back
        xor     al,al
        mov     cx,-1
        repnz   scasb                   ;Find the end of the string
        neg     cx
        dec     cx                      ;Don't count the terminator
        dec     cx
        add     cchPath,cx              ;Add into path count
        dec     di                      ;Don't leave DI past the zero byte
ifdef   FE_SB                           ;Check for trailing slash, DBCS-style
        push    si
        push    di
        mov     si,di
        sub     si,cx                   ;es:si->string address
        dec     di                      ;es:di->last byte
        call    MyIsDBCSTrailByte       ;is the last byte a DBCS trailing byte?
        pop     di
        pop     si
        jnc     loopGD3                 ;yes, append a '\'
                                        ;no, fall through
endif
        mov     al,es:[di-1]            ;Check for trailing slash.  Non-DBCS
        cmp     al,bh                   ;If there is one, we're done here
        je      getpath0
        cmp     al,bl
        je      getpath0
IFDEF FE_SB
loopGD3:
ENDIF
        mov     al,bl                   ;Put a trailing slash on
        stosb
        inc     cchPath

        ;** Parse the pathname the user gave us
getpath0:
PF_GetPath label NEAR
        public PF_GetPath
        xor     cx,cx                   ;CL=# of chars, CH=# of '.'
        mov     dx,di                   ;DX points to start of user chars
gp0:
        lodsb                           ;Get a character
        cmp     al,bl                   ;Slash?
        je      gp1                     ;Yes
        cmp     al,bh
ifdef FE_SB
        je      gp1                     ;Too far if DBCS enable....
        jmp     gp2
else
        jne     gp2                     ;No, skip this
endif
gp1:                                    ;Character is a slash

        ;** If we have a UNC name, two slashes are OK
        ;**     (just at the start of the filename)
        cmp     cchPath, 0              ;Start of path?
        jne     PF_NotUNC               ;No, even if UNC, not valid here
        cmp     fUNC, 0                 ;UNC pathname?
        je      PF_NotUNC               ;No, handle normally
        stosb                           ;Store the first slash
        lodsb                           ;Get the second slash
        inc     cchPath                 ;Another character in string
        jmp     SHORT gp1f              ;Skip double slash failure
PF_NotUNC:
        
        cmp     ds:[si],bl              ; if double slash, bad file name
        jz      gp1SkipSlash            ; so we skip the extra slashes
        cmp     ds:[si],bh              ; to be compatible with win32
        jnz     gp1DoneSlash            ; MonkeyIsland bug 220764
        
gp1SkipSlash: 
        inc     si
        jmp     SHORT PF_NotUNC         ; check for more slashes
gp1DoneSlash:        
               
if LONG_UNC_NAMES
        dec     fCountUNC               ; Move to next portion of path
        jns     @f
        mov     fCountUNC,0
@@:
else
        ;** When we get here, we will be on the first slash AFTER the
        ;**     UNC slashes:  (\\foo\bar) (or any succeeding slash)
        ;**                         ^
        ;**     So, we want clear the fFirstUNC flag so we don't allow
        ;**     more than 8 characters before a dot.
        mov     fFirstUNC, 0
endif
gp1f:
        inc     cSlash                  ; we found a slash
        cmp     cl,ch                   ; number of chars = number of '.'
        jne     gp1b                    ; nope....

        or      cx,cx
        jnz     gp001
ifdef   FE_SB
        jmp     gp2b                    ; We need 16 bits branch
else
        jmp     SHORT gp2b
endif
gp001:

        cmp     cl,2                    ; if more than 2 '.'
        ja      gpFail                  ; then we are bogus

        dec     di
ifdef   FE_SB
        dec     cchPath                 ; adjust path string length
endif
        dec     cl
        jz      getpath0
ifdef   FE_SB
        dec     di
        dec     di
        mov     dx, di
        sub     di, cchPath
        add     di, 4
        cmp     di, dx
        jnc     gpfail          ; illegal path such as "c:.." or "c:\.."
        mov     cchPath, 3
gp1a:
        xor     cx, cx
gp1bb:
        inc     di
        inc     cx
        mov     al, es:[di]
        cmp     al, bl
        jz      gp1c
        call    MyIsDBCSLeadByte
        jc      gp1bb
        inc     di
        inc     cx
        jmp     gp1bb
gp1c:
        cmp     di, dx
        jz      gp1d
        add     cchPath, cx
        jmp     gp1a
gp1d:
        sub     di, cx
        inc     di                  ; new di points previous '\'+1
        jmp     getpath0
else
        mov     di,dx
gp1a:
        dec     di
        mov     al,es:[di-1]
        cmp     al,bl
        je      getpath0
        cmp     al,':'
        jne     gp1a
endif
gpfail:
        pop     ax
gpFail2:
        xor     ax,ax
        jmp     gpexit
gp1b:
        mov     al,bl
        stosb
        inc     cchPath
        jmp     getpath0
gp2:
        or      al,al
        jnz     gp002
ifdef FE_SB
        jmp     gpx
else ; !FE_SB
        jmp     short gpx
endif ; !FE_SB

gp002:
        cmp     al,' '
        jb      gpFail
        ja      gp20

gp2x:   lodsb                   ; if space encountered continue scanning...
        or      al,al           ; if end of string, all ok
ifdef   FE_SB
        jnz     gp2x_01
        jmp     gpx
gp2x_01:
else
        jz      gpx
endif
        cmp     al,' '          ; if space, keep looking...
        jz      gp2x
        jmps    gpFail          ; otherwise error

gp20:   cmp     al,';'
        jz      gpFail
        cmp     al,':'
        jz      gpFail
        cmp     al,','
        jz      gpFail
        cmp     al,'|'
        jz      gpFail
        cmp     al,'+'
        jz      gpFail
        cmp     al,'<'
        jz      gpFail
        cmp     al,'>'
        jz      gpFail
        cmp     al,'"'
        jz      gpFail
        cmp     al,'['
        jz      gpFail
        cmp     al,']'
        jz      gpFail
        cmp     al,'='
        jz      gpFail

        inc     cl                      ; one more char
ifdef FE_SB
        call    MyIsDBCSLeadByte        ; First byte of 2 byte character?
        jc      gp2a                    ; No, convert to upper case
        stosb                           ; Yes, copy 1st byte
        inc     cchPath
        lodsb                           ; Fetch second byte
        inc     cl
        jmps    gp2a1                   ; with no case conversion
gp2a:
endif
        call    MyUpper
gp2a1:
        cmp     cchPath,127             ; DOS pathmax is 128, room for null.
        ja      gpFail
gp2b:
        stosb
        inc     cchPath
        cmp     al,'.'
        jne     gp2c
        inc     ch
        mov     ah,cl
        dec     ah
gp2c:
if LONG_UNC_NAMES
        ;** If this is a UNC name, don't bother checking lengths
        cmp     fCountUNC,0             ; Past \\foo\bar yet?
        je      PF_NotUNCPart
else
        cmp     fFirstUNC, 0            ;First UNC name?
        je      PF_NotFirstUNC          ;Nope
        or      ch,ch                   ;'.' encountered yet?
        jnz     PF_NotFirstUNC          ;Yes, treat like normal name
        cmp     cl, 11                  ;11 chars allowed with no '.'
        ja      gpFv                    ;Too many
endif
        jmp     gp0                     ;Ok

if LONG_UNC_NAMES
PF_NotUNCPart:
else
PF_NotFirstUNC:
endif

        ;** Check other lengths
        cmp     ch,0                    ; did we find a . yet?
        jz      gpT1                    ; no, max count is 8
        cmp     cl,12                   ; otherwise check for 12 chars
        ja      gpFv                    ; if more, no good
        mov     al,cl
        sub     al,ah
        cmp     al,3+1                  ; more than 3 chars in extension?
        ja      gpFv
        jmp     gp0                     ; continue

gpT1:   cmp     cl,8                    ; did we find 8 chars between / and .
        ja      gpFv                    ; if more, we fail
        jmp     gp0
gpx:
        ;** UNC names are invalid if they are SHORTER than the following:
        ;**     \\server\share\f
        cmp     fUNC,0                  ;UNC name?
        jz      PF_EnoughSlashes        ;No
        cmp     cSlash,3                ;We count \\ as one slash
        jb      gpFv                    ;Not enough, so fail it
PF_EnoughSlashes:

        cmp     ch,1
        je      gpx1
        ja      gpFv                    ; if more than 1 we fail
        mov     ah,cl                   ; No extension given
gpx1:
        mov     es:[di],al              ; Zero terminate destination
        xchg    al,ah                   ; Get length of name in CX

        or      ax,ax
        jnz     gpx2
gpFv:   jmp     gpFail
gpx2:
        cmp     ax,8                    ; but no more than 8
        ja      gpFv

        pop     ax
        sub     dx,ax                   ;Get length of path in DX
        inc     dx                      ;Add drive letter and :, less one

        ;** Never a drive letter or colon for the UNC name case
        cmp     fUNC,0                  ;UNC name?
        jz      @F                      ;Yes, don't do this
        dec     dx                      ;UNC names ALWAYS have >=3 slashes
        dec     dx
@@:     mov     ax,dx                   ;AX = length of entire path
        xor     ch,ch                   ;Clear high byte for 16 bit add
        add     ax,cx
        cmp     dx,1                    ;If length is one, we have C:\ case
        jne     @F                      ;Nope
        inc     dx                      ;Bump it
@@:
gpexit:
        mov     di,cSlash               ;DI retured as cSlash
cEnd

;---------------------------------------------------------------
;
; Return the drive letter of last drive a disk was swapped in
;
cProc   GetLastDiskChange, <PUBLIC,FAR>
cBegin  nogen
        xor     ax,ax
        push    ds
        SetKernelDS
        xchg    al,[LastDriveSwapped]
        pop     ds
        UnSetKernelDS
        ret
cEnd    nogen

        assumes ds,nothing
        assumes es,nothing

cProc   MyOpenFile,<PUBLIC,FAR>,<si,di>
        ParmD   srcFile
        ParmD   dstFile
        ParmW   Command
cBegin
        SetKernelDS
        xor     ax,ax
        cmp     [wMyOpenFileReent], ax  ; Prevent reentering this procedure
        jne     myoffail

ifdef WOW
        and     Command, NOT OF_VERIFY  ; Don't Bother with verify for internal
                                        ; It slows us down
endif
        mov     es,[CurTDB]
        mov     ax,es:[TDB_ErrMode]     ; Enable INT 24h processing
        and     es:[TDB_ErrMode],NOT 1
        mov     [myofint24],ax          ; Save old INT 24h flag
        mov     [wMyOpenFileReent],1

        cCall   IOpenFile,<srcFile,dstFile,Command>

        mov     es,[CurTDB]             ; Restore old INT 24h processing flag
        mov     dx,[myofint24]
        mov     es:[TDB_ErrMode],dx

        mov     [wMyOpenFileReent],0
        jmps    mof_ret

myoffail:
        krDebugOut DEB_ERROR, "MyOpenFile not reentrant"
        dec     ax
mof_ret:
        UnSetKernelDS
cEnd

sEnd    CODE

sBegin  MISCCODE
assumes CS,MISCCODE
assumes ds,nothing
assumes es,nothing

externNP MISCMapDStoDATA
externFP GetWindowsDirectory

cProc   DeletePathname,<PUBLIC,FAR>
;       ParmD   path
cBegin  nogen
        pop     bx
        pop     cx
        mov     ax,4100h                ; dos delete file function
        push    ax
        push    cx
        push    bx
        errn$   OpenPathname
cEnd    nogen

cProc   OpenPathname,<PUBLIC,FAR>,<ds,si,di>
        ParmD   path
        ParmW   attr

        LocalV  Buffer,MaxFileLen
cBegin
        mov     ax,attr         ; get attribute
        or      ah,ah           ; function code already set...
        jnz     opn0            ; ...yes, otherwise...
        mov     ah,3dh          ; ...default to open
opn0:   mov     di,ax

; We don't use open test for existance, rather we use get
; file attributes.  This is because if we are using Novell
; netware, opening a file causes Novell to execute its
; own path searching logic, but we want our code to do it.

        call    MISCMapDStoDATA
        ReSetKernelDS
        cmp     fNovell, 0
        lds     dx,path                 ; get pointer to pathname
        UnSetKernelDS
        je      opnNoNovell
        mov     ax,4300h                ; Get file attributes
        DOSFCALL                        ; Does the file exist?
        jc      opnnov                  ; No, then dont do the operation
opnNoNovell:
        mov     ax,di                   ; Yes, restore operation to AX
        DOSFCALL
        jnc     opn2
opnnov:
        lea     ax,Buffer
        regptr  dsdx,ds,dx
        regptr  ssax,ss,ax
        cCall   SearchPath,<dsdx,ssax,di>
opn2:   mov     bx,ax
cEnd

;---------------------------------------------------------------
;
; Return the drive letter of a good disk to put a temp file on
;
;
cProc   GetTempDrive,<PUBLIC,FAR>
;       ParmB   Drive
cBegin  nogen
        mov     bx,sp
        push    si
        push    di
        mov     ax,ss:[bx+4]
        and     al,not TF_FORCEDRIVE
        jnz     gtd1
        mov     ah,19h          ; get the current disk
        DOSFCALL
        add     al,'A'
gtd1:   and     al,01011111b    ; convert to upper case (always a-z)
        test    byte ptr ss:[bx+4],TF_FORCEDRIVE        ; Forcing drive letter?
        jnz     gtdz            ; Yes, all done
        sub     al,'A'          ; A: = 0, etc.
        cbw
        mov     si,ax           ; SI = drive to return if no hard disk
        xor     di,di           ; start with drive A
gtd2:   call    FarIsFloppy     ; while drive = floppy, keep looking
        cmp     al,3            ; did we find a hard disk?
        mov     dx,1            ; return we have a hard disk
        jz      gtdx            ; yes, return it
        inc     di
        cmp     di,"Z"-"A"
        jbe     gtd2
        xor     dx,dx           ; indicate its a floppy
        mov     di,si           ; return default disk

gtdx:   mov     ax,di
        add     al,"A"

gtdz:   mov     ah,":"
        pop     di
        pop     si
        ret     2
cEnd    nogen

cProc   hextoa,<PUBLIC,NEAR>
cBegin  nogen
        mov     ah,al
        mov     cl,4
        shr     al,cl
        and     ah,0Fh
        add     ax,3030h
        cmp     al,39h
        jbe     hextoa1
        add     al,7
hextoa1:
        cmp     ah,39h
        jbe     hextoa2
        add     ah,7
hextoa2:
        ret
cEnd    nogen

;---------------------------------------------------------------
;
cProc   IGetTempFileName,<PUBLIC,FAR>,<si,di>
        parmW   drive
        parmD   lpPrefix
        parmW   nUnique
        parmD   lpBuf
        localW  myUnique
        localW  mydx
        localW  mybuf
cBegin
        sub     sp, 128                 ; local buffer for buiding lpBuf
        mov     di, sp
        mov     mybuf, sp               ; save
        cCall   GetTempDrive,<drive>
        mov     mydx,dx
        ;les    di,lpBuf
        smov    es, ss
        stosw                           ; AX = 'drive:'
        mov     ax,drive
        test    al,TF_FORCEDRIVE
        jnz     stmpForce
        call    FarGetEnv               ; look for environ TEMP=
stmp2:
        lodsw
        or      al,al                   ; no more enviroment
        jz      stmpNo

        cmp     ax,'ET'                 ; Look for TEMP=
        jne     stmp3
        lodsw
        cmp     ax,'PM'
        jne     stmp3
        lodsb
        cmp     al,'='
        je      stmpYes
stmp3:  lodsb                           ; find end of string
        or      al,al
        jnz     stmp3
        jmp     stmp2

stmpYes:
ifdef FE_SB
        mov     al,[si]
        mov     ah,0
        call    FarMyIsDBCSLeadByte
        jnc     stmpnodrive
endif
        cmp     byte ptr [si+1],':'     ; TEMP has drive?
        jne     stmpnodrive
        dec     di
        dec     di
stmpnodrive:                            ; copy path to ES:DI
        lodsb
        or      al,al
        jz      stmpPath
        stosb
        jmp     stmpnodrive

stmpForce:
        mov     al,'~'
        stosb
        jmps    stmpNo1

stmpNo:                                 ; ES:DI points to "drive:"
        dec     di
        dec     di
        cCall   GetWindowsDirectory, <esdi, 144>
        add     di, ax

stmpPath:                               ; ES:DI points to "drive:path"
        mov     ax,'~\'
        cmp     es:[di-1],al            ; does it already end in \
        jnz     stmpNoF                 ; no, just store it
        dec     di                      ; override it
stmpNoF:
        stosw
stmpNo1:
        lds     si,lpPrefix
        mov     cx,3
stmpPfx:
        lodsb
        or      al,al
        jz      stmpPfx1
        stosb
        loop    stmpPfx
stmpPfx1:
        mov     dx,nUnique
        or      dx,dx
        jnz     stmpNum
        mov     ah,2Ch
        DOSFCALL
        xor     dx,cx
stmpNum:
        mov     myUnique,dx
        jnz     stmpNum1
        inc     dx                      ; Dont ever use 0 as the unique num.
        jmp     stmpNum
stmpNum1:
        mov     al,dh
        call    hextoa
        stosw
        mov     al,dl
        call    hextoa
        stosw
        mov     ax,'T.'
        stosw
        mov     ax,'PM'
        stosw
        xor     ax,ax
        stosb

; Don't call AnsiUpper on this string because it has OEM characters
; in it (from the app and the temp environment variable).

        cmp     nUnique,0
        jne     stmpDone
        ;lds    dx,lpBuf
        mov     dx, mybuf
        smov    ds, ss
        mov     ax,5B00h
        xor     cx,cx
        DOSFCALL
        jnc     stmpClose
        cmp     al,80                   ; Did we fail because the file
        jnz     stmpfail                ;  already exists?
        sub     di,9
        mov     dx,myUnique
        inc     dx
        jmp     stmpNum

stmpClose:
        mov     bx,ax
        mov     ah,3Eh
        DOSFCALL
        jmps    stmpdone

stmpfail:
        xor     ax,ax
        mov     myunique,ax
stmpdone:
        mov     di, mybuf               ; robustness crap
        smov    es, ss                  ; bug #15493 ami pro
        RegPtr  esdi, es, di
        cCall   lstrcpy <lpBuf,esdi>    ; now copy to user spc
        mov     ax,myunique
        mov     dx,mydx
        add     sp, 128
cEnd

;-----------------------------------------------------------------------;
; GetDriveType
;
; Entry:
;       parmW   drive    Disk Drive Information (Drive A = 0)
;
; Returns:
;       ax = 0 means the drive does not exist.  if dx != 0 then the drive
;           maps to the drive in dx instead (A = 1) AND the drive is
;           REMOVEABLE.
;       ax = 1 means the drive does not exist.  if dx != 0 then the drive
;           maps to the drive in dx instead (A = 1) AND the drive is
;           FIXED.
;       ax = 2 means the drive is removable media
;       ax = 3 means the drive is fixed media
;       ax = 4 means the drive is fixed media and remote
;
; Registers Destroyed:
;
; History:
;  Mon 16-Oct-1989 21:14:27  -by-  David N. Weise  [davidw]
; Wrote it!
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

ifndef WOW - We thunk this API its too slow

cProc   GetDriveType,<PUBLIC,FAR>
;       parmW   drive
cBegin nogen
        mov     bx,sp
        push    ds
        call    MISCMapDStoDATA
        ResetKernelDS
        mov     ax,1            ; 1 = Get Drive Info from InquireSystem
        mov     bx,ss:[bx+4]
        cCall   pSysProc,<ax,bx>
        pop     ds
        ret     2
cEnd nogen
endif; WOW


sEnd    MISCCODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\ldstack.asm ===
TITLE	LDSTACK - stack walking procedure

.xlist
include kernel.inc
include newexe.inc
include tdb.inc
.list

;externFP GlobalHandle
;externFP FarLoadSegment

;externW pStackTop
;externW pStackBot

DataBegin

;externB Kernel_flags
;externW segSwapArea
;externW oOldSP
;externW hOldSS
;externW pGlobalHeap
;externW curTDB
;externW headTDB

DataEnd

sBegin	CODE
assumes CS,CODE

;externNP MyLock
;externNP LoadSegment

sEnd	CODE

sBegin MISCCODE
assumes cs, MISCCODE
assumes ds, nothing
assumes es, nothing

jmpbuf	struc
jb_ret	DD  ?
jb_sp	DW  ?
jb_bp	DW  ?
jb_si	DW  ?
jb_di	DW  ?
jb_hds	DW  ?
jb_ip	DW  ?
jb_hss	DW  ?
jmpbuf	ends

savedSI = -4
savedDI = -6

cProcVDO Catch,<PUBLIC,FAR>,<ds,si,di>
	parmD   lpJmpBuf
cBegin
	push	[bp].savedCS
	push	[bp].savedIP
	push	[bp].savedBP
	les	bx,lpJmpBuf
	mov	es:[bx].jb_hss,ss
	mov	es:[bx].jb_hds,ds
	mov	es:[bx].jb_di,di
	mov	es:[bx].jb_si,si
	pop	es:[bx].jb_bp
	pop	word ptr es:[bx].jb_ret[0]
	pop	word ptr es:[bx].jb_ret[2]
	mov	es:[bx].jb_sp,sp
	xor	ax,ax
CatchRet:
cEnd

cProcVDO Throw,<PUBLIC,FAR>
;	parmD   lpJmpBuf
;	parmW   AXvalue
cBegin	nogen
	mov	bx,sp
	mov	di,ss:[bx+4]
	lds	si,ss:[bx+6]

	mov	ss,ds:[si].jb_hss
	mov	sp,ds:[si].jb_sp
	mov	bp,sp
	add	bp,-savedDI
	push	ds:[si].jb_bp
	pop	ss:[bp].savedBP
	push	ds:[si].jb_si
	pop	ss:[bp].savedSI
	push	ds:[si].jb_di
	pop	ss:[bp].savedDI
	push	ds:[si].jb_hds
	pop	ss:[bp].savedDS
	mov	ax,word ptr ds:[si].jb_ret[2]
	mov	ss:[bp].savedCS,ax
	mov	ax,word ptr ds:[si].jb_ret[0]
	mov	ss:[bp].savedIP,ax
	mov	ax,di
	jmp	CatchRet
cEnd	nogen

sEnd MISCCODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\ldself.asm ===
TITLE	LDSELF - BootStrap procedure for KERNEL.EXE

.xlist
?NODATA=1
?TF=1
include kernel.inc
include newexe.inc
include tdb.inc
.list

externFP IGlobalAlloc
externFP IGlobalLock
externFP IGlobalUnlock
	       
DataBegin

externW winVer
;externW pGlobalHeap

DataEnd

sBegin	CODE
assumes CS,CODE
assumes DS,NOTHING
assumes ES,NOTHING

;externW MyCSDS

externNP SetOwner

externFP set_discarded_sel_owner

; extra debugging parameter for EntProcAddress to avoid RIPing if all 
; we are doing is a GetProcAddress to something that isn't there.
externNP EntProcAddress
cProc	FarEntProcAddress,<PUBLIC,FAR,NODATA>
    parmW   hExe
    parmW   entno
cBegin
if KDEBUG
	mov	cx,1
	cCall	EntProcAddress,<hExe,entno,cx>
else
	cCall	EntProcAddress,<hExe,entno>
endif
cEnd

if KDEBUG

;  AppLoaderEntProcAddress
;       This call added for the app loader.  The above call (FarEntProcAddress)
;       forces no RIPs.  When we're using the app loader, we really want
;       RIPs, so in debug we add this entry point.
;       This call ONLY exists in debug.

cProc	AppLoaderEntProcAddress,<PUBLIC,FAR,NODATA>
    parmW   hExe
    parmW   entno
cBegin
        xor     cx,cx           ;Force RIPs on this one
	cCall	EntProcAddress,<hExe,entno,cx>
cEnd

endif ; KDEBUG


externNP FindOrdinal
cProc	FarFindOrdinal,<PUBLIC,FAR,NODATA>
    parmW   hExe
    parmD   lpname
    parmW   fh
cBegin
	cCall	FindOrdinal,<hExe,lpName,fh>
cEnd


externNP LoadSegment
cProc	FarLoadSegment,<PUBLIC,FAR,NODATA>
    parmW   hExe
    parmW   segno
    parmW   fh
    parmW   isfh
cBegin
	cCall	LoadSegment,<hExe,segno,fh,isfh>
cEnd


externNP AllocSeg
cProc	FarAllocSeg,<PUBLIC,FAR,NODATA>
    parmD   pSegInfo
cBegin
	cCall	AllocSeg,<pSegInfo>
cEnd


externNP DeleteTask
cProc	FarDeleteTask,<PUBLIC,FAR,NODATA,ATOMIC>
    parmW taskID
cBegin
	cCall	DeleteTask,<taskID>
cEnd


externNP UnlinkObject
cProc	FarUnlinkObject,<PUBLIC,FAR,NODATA,ATOMIC>
cBegin
	cCall	UnlinkObject
cEnd


externNP MyLower
cProc	FarMyLower,<PUBLIC,FAR,NODATA,ATOMIC>
cBegin
	cCall	MyLower
cEnd


externNP MyUpper
cProc	FarMyUpper,<PUBLIC,FAR,NODATA,ATOMIC>
cBegin
	cCall	 MyUpper
cEnd


externNP MyAlloc
cProc	FarMyAlloc,<PUBLIC,FAR,NODATA>
    parmW   aflags
    parmW   nsize
    parmW   nelem
cBegin
	cCall	MyAlloc,<aflags,nsize,nelem>
cEnd


externNP MyAllocLinear
cProc	FarMyAllocLinear,<PUBLIC,FAR,NODATA>
    parmW   aflags
    parmD   dwBytes
cBegin
	cCall	MyAllocLinear,<aflags,dwBytes>
cEnd


externNP MyLock
cProc	FarMyLock,<PUBLIC,FAR,NODATA>
    parmW   h1
cBegin
	cCall	MyLock,<h1>
cEnd


externNP MyFree
cProc	FarMyFree,<PUBLIC,FAR,NODATA>
    parmW   h2
cBegin
	cCall	MyFree,<h2>
cEnd

externNP genter
cProc	Far_genter,<PUBLIC,FAR,NODATA,ATOMIC>
cBegin
	cCall	genter
cEnd

externNP gleave
cProc   Far_gleave,<PUBLIC,FAR,NODATA,ATOMIC>
cBegin
    cCall   gleave
cEnd

externNP lalign
cProc	Far_lalign,<PUBLIC,FAR,NODATA,ATOMIC>
cBegin
	cCall	lalign
cEnd


externNP lrepsetup
cProc	Far_lrepsetup,<PUBLIC,FAR,NODATA,ATOMIC>
cBegin
	cCall	lrepsetup
cEnd


if KDEBUG

externNP lfillCC
cProc	Far_lfillCC,<PUBLIC,FAR,NODATA,ATOMIC>
cBegin
	cCall	 lfillCC
cEnd
endif

sEnd	CODE




sBegin	INITCODE

;-----------------------------------------------------------------------;
; LKExeHeader								;
; 									;
; Copy of LoadExeHeader (from LDHEADER.ASM) that has been stripped	;
; down to the minimum needed to load the new format .EXE header for	;
; KERNEL.EXE.								;
; 									;
; Arguments:								;
;	parmW	pMem							;
;	parmD	pfilename						;
; 									;
; Returns:								;
;	AX = segment of exe header					;
; 									;
; Error Returns:							;
;	AX = 0								;
; 									;
; Registers Preserved:							;
;	DI,SI,DS							;
; 									;
; Registers Destroyed:							;
;	AX,BX,CX,DX,ES							;
; Calls:								;
; 									;
; History:								;
; 									;
;  Thu Mar 19, 1987 08:35:32p  -by-  David N. Weise   [davidw]		;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

cProc	LKExeHeader,<PUBLIC,NEAR>,<si,di,ds>
	parmW	pMem
	parmD   pfilename
	localW	nchars
cBegin
	lds	si,pfilename
	xor	ax,ax
	mov	al,ds:[si].opLen
	inc	ax			; include null byte
	mov	nchars,ax

	mov	ds,pMem
	xor	si,si
	mov	di,ds:[si].ne_enttab	; Compute size of resident new header
	add	di, 6			; Room for one block of entries
	push	si
	mov	si, ds:[si].ne_enttab	; Scan current entry table

calc_next_block:
	lodsw
	xor	cx, cx
	mov	cl, al
	jcxz	calc_ent_sized

	cmp	ah, ENT_UNUSED		; 6 bytes per unused block
	jne	calc_used_block
	add	di, 6
	jmps	calc_next_block

calc_used_block:
	errnz	<5-SIZE PENT>
	mov	bx, cx
	shl	bx, 1
	add	di, bx
	add	di, bx			; 5 bytes per entry
	add	di, cx

	add	si, bx
	add	si, cx			; Skip the block
	cmp	ah, ENT_MOVEABLE
	jne	calc_next_block

calc_moveable_block:
	add	si, bx
	add	si, cx			; Skip the block
	jmps	calc_next_block

calc_ent_sized:
	pop	si
	mov	cx,ds:[si].ne_cseg	; + 3 * #segments

; Reserve space for segment reference bytes

	add	di,cx
	shl	cx,1

; Reserve space for ns_handle field in segment table

	add	di,cx
	errnz	<10-SIZE NEW_SEG1>

if LDCHKSUM

; Reserve space for segment chksum table (2 words per segment)

	add	di,cx
	add	di,cx
endif


; Reserve space for file info block at end

	add	di,16			; 16 bytes of slop
	add	di,nchars		; + size of file info block

	xor	ax,ax			; Allocate a block for header
	cCall	IGlobalAlloc,<GA_MOVEABLE,ax,di>
	push	ax
	cCall	IGlobalLock,<ax>
	pop	ax
	push	dx
	cCall	IGlobalUnlock,<ax>
	pop	ax
	mov	es,ax			; ES:DI -> new header location
	xor	di,di
	cld				; DS:SI -> old header
	mov	cx,SIZE NEW_EXE		; Copy fixed portion of header
	cld
	rep	movsb
	mov	cx,es:[ne_cseg] 	; Copy segment table
	mov	es:[ne_segtab],di
recopyseg:

	movsw				; ns_sector
	movsw				; ns_cbseg
	lodsw				; ns_flags
	errnz	<4-ns_flags>
	and	ax,not NS286DOS 	; Clear 286DOS bits
	or	ax,NENOTP+4000h 	; Mark library code segments
	stosw
	movsw				; ns_minalloc
	errnz	<8-SIZE NEW_SEG>
	xor	ax,ax
	stosw				; one word for ns_handle field
	errnz	<10-SIZE NEW_SEG1>
	loop	recopyseg

recopysegx:
	mov	cx,es:[ne_restab]	; Copy resource table
	sub	cx,es:[ne_rsrctab]
	mov	es:[ne_rsrctab],di
	rep	movsb
rerestab:
	mov	cx,es:[ne_modtab]	; Copy resident name table
	sub	cx,es:[ne_restab]
	mov	es:[ne_restab],di
	rep	movsb

	mov	cx,es:[ne_imptab]	; Copy module xref table
	sub	cx,es:[ne_modtab]
	mov	es:[ne_modtab],di
	rep	movsb

	mov	es:[ne_psegrefbytes],di ; Insert segment reference byte table
	mov	cx,es:[ne_cseg]
	mov	al,0FFh
	rep	stosb			; initialize to not-loaded condition

	mov	es:[ne_pretthunks],di	; Setup return thunks

if LDCHKSUM
	mov	es:[ne_psegcsum],di	; Setup segment chksum table
	mov	cx,es:[ne_cseg]
	jcxz	resetsegcsumexit
	xor	ax,ax
	shl	cx,1			; Two words per segment
	rep	stosw
resetsegcsumexit:
endif
	mov	cx,es:[ne_enttab]	; Copy imported name table
	sub	cx,es:[ne_imptab]
	mov	es:[ne_imptab],di
	jcxz	reenttab
	rep	movsb

reenttab:
	mov	es:[ne_enttab],di
					; Scan current entry table
	xor	ax, ax			; First entry in block
	mov	bx, di			; Pointer to info for this block
	stosw				; Starts at 0
	stosw				; Ends at 0
	stosw				; And is not even here!

copy_next_block:
	lodsw				; Get # entries and type
	xor	cx, cx
	mov	cl, al
	jcxz	copy_ent_done

	mov	al, ah
	cmp	al, ENT_UNUSED
	jne	copy_used_block

	mov	ax, es:[bx].PM_EntEnd	; Last entry in current block
	cmp	ax, es:[bx].PM_EntStart	; No current block?
	jne	end_used_block

int 3
	add	es:[bx].PM_EntStart, cx
	add	es:[bx].PM_EntEnd, cx
	jmps	copy_next_block

end_used_block:
	mov	es:[bx].PM_EntNext, di	; Pointer to next block
	mov	bx, di
	add	ax, cx			; Skip unused entries
	stosw				; First in new block
	stosw				; Last in new block
	xor	ax, ax
	stosw				; End of list
	jmps	copy_next_block

copy_used_block:
	add	es:[bx].PM_EntEnd, cx	; Add entries in this block
	cmp	al, ENT_MOVEABLE
	je	copy_moveable_block

copy_fixed_block:
	stosb				; Segno
	movsb				; Flag byte
	stosb				; segno again to match structure
	movsw				; Offset
	loop	copy_fixed_block
	jmps	copy_next_block

copy_moveable_block:
	stosb				; ENT_MOVEABLE
	movsb				; Flag byte
	add	si, 2			; Toss int 3Fh
	movsb				; Copy segment #
	movsw				; and offset
	loop	copy_moveable_block
	jmps	copy_next_block

copy_ent_done:


	xor	bx,bx
	mov	es:[bx].ne_usage,1
	mov	es:[bx].ne_pnextexe,bx
	mov	es:[bx].ne_pautodata,bx

	mov	cx,nchars
	mov	es:[bx].ne_pfileinfo,di
	lds	si,pfilename
	rep	movsb

	SetKernelDS
	mov	ax,winVer
	mov	es:[bx].ne_expver,ax
	or	es:[bx].ne_flags,NENONRES ; Remember that we have
						; discardable code
	UnSetKernelDS
	cCall	SetOwner,<es,es>
	mov	ax,es
reexit:
cEnd

cProc	LKAllocSegs,<PUBLIC,NEAR>,<si,di,ds>
	parmW	hExe

	localW	fixed_seg
	localW	SegCount
cBegin
	mov	ds,hExe
	mov	si,ds:[ne_segtab]
	mov	di,ds:[si].ns_minalloc
	xor	ax,ax
	mov	bx,(GA_ALLOC_LOW or GA_CODE_DATA) shl 8
	cCall	IGlobalAlloc,<bx,ax,di>
	or	ax,ax
	jz	lkallocfail
	mov	fixed_seg,ax
	mov	ds:[si].ns_handle,ax
	and	byte ptr ds:[si].ns_flags,not NSLOADED
	or	byte ptr ds:[si].ns_flags,NSALLOCED

	cCall	SetOwner,<ax,ds>

	add	si,SIZE NEW_SEG1	; NRES segment
	mov	di,ds:[si].ns_sector
	mov	SegCount, 0		; NRES and MISC segments

;;	  SetKernelDS	  es
;;	  cmp	  fWinX,0
;;	  UnSetKernelDS   es
;;	  je	  lk1
;;	  mov	  di,ds:[si].ns_cbseg
;;	  xchg	  ds:[si].ns_minalloc,di
;;	  xchg	  ds:[si].ns_sector,di
;;lk1:

SegLoop:
	inc	SegCount
	xor	ax,ax
	mov	bh,GA_DISCARDABLE + GA_SHAREABLE + GA_CODE_DATA
	mov	bl,GA_MOVEABLE + GA_DISCCODE
	cCall	IGlobalAlloc,<bx,ax,ax>
	or	ax,ax
	jz	lkallocfail
	mov	ds:[si].ns_handle,ax	; Handle into seg table
	and	byte ptr ds:[si].ns_flags,not NSLOADED
	or	byte ptr ds:[si].ns_flags,NSALLOCED
	mov	bx,ax			; put handle into base register
	smov	es,ds
	call	set_discarded_sel_owner
	smov	es,0
	mov	bx,ds:[si].ns_sector	; Save MiscCode sector
	add	si,SIZE NEW_SEG1	; Next segment
	cmp	SegCount, 2
	jnz	SegLoop


; Allocate fixed block for kernel's data segment

	push	bx			; Save MisCode sector
	mov	bx,ds:[si].ns_minalloc
	xor	ax,ax
	cCall	IGlobalAlloc,<ax,ax,bx>
	pop	bx
	or	ax,ax
	jz	lkallocfail
	mov	ds:[ne_pautodata], si
	mov	ds:[si].ns_handle,ax
	and	byte ptr ds:[si].ns_flags,not NSLOADED
	or	byte ptr ds:[si].ns_flags,NSALLOCED

	cCall	SetOwner,<ax,ds>

	mov	ax,di			; Return offset to NR segment
lkallocfail:
cEnd

	nop				; Stop linker from padding segment

sEnd	INITCODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\ldint.asm ===
TITLE   LDINT - Loader interrupt procedure

.xlist
include kernel.inc
include newexe.inc
include tdb.inc
include	protect.inc
include dbgsvc.inc
include bop.inc
include	kdos.inc
include gpcont.inc	; SHERLOCK
ifdef WOW
include vint.inc
include softpc.inc
endif

NOTEXT		= 1
NOGDICAPMASKS	= 1
NOMB		= 1
NOVK		= 1
NOWH		= 1
NOMST		= 1
NORASTOPS	= 1
NOMETAFILE	= 1
NOMDI		= 1
NOWINMESSAGES	= 1
NOSYSMETRICS	= 1
NOCOLOR		= 1
NOCOMM		= 1
NOKERNEL	= 1

include	windows.inc		; YIKES!!!

.list

FAULTSTACKFRAME struc

fsf_BP		dw	?	; Saved BP
fsf_msg		dw	?	; Near pointer to message describing fault
fsf_prev_IP	dw	?	; IP of previous fault handler
fsf_prev_CS	dw	?	; CS of previous fault handler
fsf_ret_IP	dw	?	; DPMI fault handler frame follows
fsf_ret_CS	dw	?
fsf_err_code	dw	?
fsf_faulting_IP dw	?
fsf_faulting_CS dw	?
fsf_flags	dw	?
fsf_SP		dw	?
fsf_SS		dw	?

FAULTSTACKFRAME ends

fsf_OFFSET = fsf_ret_IP - fsf_msg

UAE_STRING_LEN	equ	192d
MIN_SP		equ	256d

externFP ExitKernel
externFP WowDivideOverflowEx


DataBegin

;externB syserr
externB	szAbort
externB szAbortCaption
externB szNukeApp
externB szWillClose
externB szBlame
externB szSnoozer
externB szInModule
externB szAt
externB szII
externB szGP
externB szSF
externB szNP
externB	szLoad
;externB szDiscard
externB szPF
externB Kernel_Flags
externB fBooting
externW curTDB
;externW pGlobalHeap
externW DemandLoadSel
externD	pSErrProc
externD pUserGetFocus
externD pUserGetWinTask
externD pUserIsWindow
externD	lpGPChain

if kdebug
globalw	wFaultSegNo,0
endif

if KDEBUG
staticW INT3Fcs,0
endif

globalW	FaultHandler,<codeOffset HandleFault>

externD  pPostMessage

ifdef WOW
externD FastBop
externD prevInt01proc
externD prevInt03proc
externD oldInt00proc
externW DebugWOW
externW gdtdsc

endif

DataEnd

sBegin	DATA
externW gmove_stack
externW TraceOff
sEnd    DATA

sBegin	CODE
assumes CS,CODE

if SHERLOCK
externNP GPContinue
endif

externD  prevIntx6proc
externD  prevInt0Cproc
externD  prevInt0Dproc
externD  prevInt0Eproc
externD  prevInt3Fproc

externNP LoadSegment
;externNP MyLock

ifndef WOW
externNP htoa
endif

externNP GetOwner
externNP GetPureName
externNP TextMode
externNP Int21Handler
	    
;externNP DebugPostLoadMessage
externFP GlobalLRUNewest
externFP GlobalHandleNorip
externFP HasGPHandler
externFP AllocSelector
externFP IFreeSelector

	assumes	ds, nothing
	assumes	es, nothing

ifdef WOW
Entry   macro name
    public name
    align 2
    name&:
    endm
endif

;-----------------------------------------------------------------------;
; Display_Box_of_Doom -- Display the Unrecoverable Application Error
;			 box that everyone seems to dislike so much.
;
; Entry:
;	Action		Reserved, must be zero
;	lpText		String to display, NULL for default
;
; Returns:
;	AX = 1		Cancel
;	AX = 2		OK
;
; Registers Destroyed:
;	AX, BX, CX, DX, SI, DI
;
; History:
;  Thu 16-May-1991 -by- Earle R. Horton
;
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	Display_Box_of_Doom,<PUBLIC,NEAR>

	parmW	action
	parmD	lpText
cBegin
	SetKernelDS
if KDEBUG
	xor	bx,bx
	or	action,bx
	jz	@F
	kerror	00FFh,<Action not 0 in FatalAppExit>,bx,bx
@@:
endif
	push	es			; added 10 feb 1990
	mov	es,curTDB		; did app disable exception
	test	es:[TDB_ErrMode],02h	;  message box?
	pop	es
	jnz	nf_dont_ask

	cmp	pSErrProc.sel, 0	; Can we put up message box?
	jnz	short nf_ask		;   yes, do it
					;   no, have debugger?
nf_dont_ask:
	mov	ax,1
	test	Kernel_Flags[2],KF2_SYMDEB
	jnz	nf_ret			;     yes, call debugger
	inc	ax
	jmps	nf_ret			;     no, have to nuke the app

nf_ask:	 	
	push	es
	mov	ax,lpText.sel
	or	ax,ax
	jz	nf_default_string
	push	ax
	push	lpText.off
	jmps	nf_pushed_string

nf_default_string:
	push	ds
	mov	ax,dataOffset szAbort	; lpText
	push	ax

nf_pushed_string:
	push	ds			; lpCaption
	mov	ax, dataOffset szAbortCaption
	push	ax

	xor	ax,ax		; Assume no debugger, blank first button
	mov	cx,ax
	test	Kernel_Flags[2],KF2_SYMDEB	; Debugger?
	jz	@F				; No
	mov	cx,SEB_CANCEL			; Yes, use Cancel button
@@:
	push	cx
;	push	SEB_OK+SEB_DEFBUTTON
	push	SEB_CLOSE + SEB_DEFBUTTON
	push	ax

	call	ds:[pSErrProc]		; Put up the system error message
	pop	es

nf_ret:

cEnd

;-----------------------------------------------------------------------;
; FatalAppExit -- Called by apps. to request an application error
;		  message box.
;
; Entry:
;	Action		Reserved, must be zero
;	lpText		String to display, NULL for default
;
; Returns:
;	Returns to caller if Cancel button pressed
;
; Registers Destroyed:
;
; History:
;  Sun 22-Oct-1989 15:18:57  -by-  David N. Weise  [davidw]
; Tonyg wrote it!
;  Fri 24-May-1991 EarleH totally rewrote it, so there!
;  
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	IFatalAppExit,<PUBLIC,FAR>

	parmW	action
	parmD	lpText
cBegin

	cmp	seg_lpText,0
	jne	fae_string
	mov	off_lpText,offset szAbort
	mov	seg_lpText,seg szAbort
fae_string:
	cCall	Display_Box_of_Doom,<action,lpText>
	cmp	ax,1			; Cancel pressed?
	je	fae_ret
	jmp	KillApp
fae_ret:
cEnd

; ------------------------------------------------------------------
;
; FormatFaultString -- Special purpose "sprintf()"
;	Only used for the Box of Doom
;
; ------------------------------------------------------------------

cProc	FormatFaultString,<PUBLIC,NEAR>,<si,di,ds,es>
	parmD	lpstr
	parmW	pStr			; Assumed in Kernel's DS
	parmD	csip
cBegin
	SetKernelDS
	cld
	les	di, lpstr		; Form string in ES:DI
	call	CurApName
	lea	si, szSnoozer		; " has caused an error in Windows"
	call	strcpy
	mov	si, pStr		; Copy the fault string
	call	strcpy
	lea	si, szInModule		; "in Module: <unknown>"
	call	strcpy

	push	es
	push	di

	cCall	GetOwner,<seg_csip>	; Can we find a module to blame?
	or	ax, ax
	jz	NoOwner
	mov	es, ax
	cmp	es:[ne_magic], NEMAGIC
	jne	NoOwner
	
	mov	bx, seg_csip		; Have the module, can we get the
	and	bl, not SEG_RING	; segment number?
	mov	di,es:[ne_segtab]
	mov	ax,1   
	mov	cx, es:[ne_cseg]
getsegno:	    
	mov	dx, es:[di].ns_handle
	and	dl, not SEG_RING
	cmp	dx, bx
	jz	gotsegno
	add	di,SIZE NEW_SEG1
	inc	ax
	loop	getsegno
	jmps	nosegno			; No, report the selector instead
gotsegno:
	mov	seg_csip, ax		; Print Segment #
nosegno:						       	
      
	mov	di, es:[ne_pfileinfo]	; Now blame the module
	add	di, opFile
	call	GetPureName
	mov	si, di
	smov	ds, es
	UnSetKernelDS
	pop	di
	pop	es
ifdef FE_SB
find_space:
	cmp	byte ptr es:[di-1],' '		; prepare space before mod name
	jz	copy_name
	dec	di
	jmps	find_space
copy_name:
else ; !FE_SB
	sub	di, 9			; Get rid of <unknown>
endif ; !FE_SB

	call	strcpy
	SetKernelDS
	jmps	GotOwner
	
NoOwner:
	pop	di
	pop	es
GotOwner:
	lea	si, szAt
	call	strcpy
ifdef WOW
	cCall	<far ptr Far_htoa>,<es,di,seg_csip>
else
	cCall	htoa,<es,di,seg_csip>
endif
	mov	di, ax
	mov	es, dx
	mov	byte ptr es:[di], ':'
	inc	di
ifdef WOW
	cCall	<far ptr Far_htoa>,<es,di,off_csip>
else
	cCall	htoa,<es,di,off_csip>
endif
	mov	es, dx
	mov	di, ax
	lea	si, szNukeApp
	call	strcpy
	call	CurApName
	lea	si, szWillClose
	call	strcpy
cEnd

CurApName proc	near
	SetKernelDS
	lea	si, szBlame		; Default task to blame
	cmp	curTDB, 0		; Have a task to blame?
	je	DefaultCaption		; nope, use default
	mov	ds, curTDB
	UnSetKernelDS
	mov	si, TDB_ModName
DefaultCaption:
	mov	cx, 8
copy_appname:
	lodsb
	stosb
	or	al, al			; Null padded in TDB
	loopne	copy_appname
	jne	no_null
	dec	di 			; Toss extra space
no_null:

	SetKernelDS
	ret
CurApName endp

	public	strcpy
strcpy	proc	near
	lodsb
	stosb
	or	al, al
	jnz	strcpy
	dec	di			; Ignore Null
	ret
strcpy	endp

;-----------------------------------------------------------------------;
;
; KillApp -- Calls USER to tell it that the application is going away,
; 	     then tells DOS to kill it.
;
; ENTRY: None
; EXIT: None, doesn't
;
; Registers modified: Huh?
;
;-----------------------------------------------------------------------;

KillApp proc near

	SetKernelDS

                test    fBooting, 1
                jz      @F

	mov	ax, 1
	cCall	ExitKernel,<ax>

@@:	mov	ax,4CFFH		; They said OK to Nuke app.
	DOSCALL

	UnSetKernelDS
KillApp endp

;-----------------------------------------------------------------------;
; FaultFilter -- Called by HandleFault, NestedFault, and routines that
; use the same stack frame.  Look at the faulting CS:IP on the exception
; handler frame, and make sure that CS is Ring 3, LDT.  If it is not
; pop the near return address from the stack and chain the exception
; to the next handler.  This will be the DPMI server, which will crash
; Windows back to DOS.  We ought to try to close up a few things first.
;-----------------------------------------------------------------------;
	ReSetKernelDS

	public	FaultFilter
FaultFilter	proc	near


    mov al,byte ptr [bp].fsf_faulting_CS
	and	al, SEG_RING_MASK		; Check it was Ring 3, LDT
	cmp	al, SEG_RING

	je	@F
;
; The faulting CS's ring bits do not match up.  We will not handle
; this fault, because we assume it happened in the DPMI provider,
; and is a Real Bad one.  Since the default handler is going to
; abort here, it would be nice to let the user down real easy.
; Restoring the display to text mode would be nice, at the very
; minimum.
;
	cCall	TextMode
	ret					; Hypocrite!
@@:
;
; Check for faults on POP FS and POP GS. If found, fix them up. We need to
; fix up faults in the register restoration of both KRNL386 (WOW16Return) and
; MMSYSTEM (MULTI_MEDIA_ISR386). Monty Pythons Complete Waste of Time is an app
; which frees selectors in FS across message boundries.
;
ifdef WOW
        push    ds
        mov     ax, word ptr [bp].fsf_faulting_CS
        mov     ds, ax
        mov     si, word ptr [bp].fsf_faulting_IP
        cmp     word ptr [si], 0A10Fh  ; pop  fs
        je      HandFSGSflt
        cmp     word ptr [si], 0A90Fh  ; pop  gs
        je      HandFSGSflt
        jmp short NoFSGSflt
HandFSGSflt:
if KDEBUG
    Trace_Out "POP GS/FS fault fixed up!"
endif
        mov     ds, [bp].fsf_SS
        mov     si, [bp].fsf_SP
        mov     word ptr [si], 0
        pop     ds                      ; restore kernel DS
        pop     ax                      ; don't do EH_Chain
        push    codeOffset EH_ret       ; use "handled it" return instead
        ret
NoFSGSflt:
        pop     ds
endif

    pop ax              ; toss chain return
	push	codeOffset EH_ret		; use "handled it" return

	mov	si,word ptr FaultHandler	; SI = Handler
	push	si
	mov	word ptr FaultHandler,codeOffset NestedFault

if KDEBUG
	test	byte ptr [bp].fsf_flags+1,2	; IF set in faulting frame?
	jnz	@F
	Trace_Out "Fault with interrupts disabled!"
@@:
endif
	cmp	[bp].fsf_SP,128d
	jb	ff_stack

	cCall	HasGPHandler, <[bp].fsf_faulting_CS, [bp].fsf_faulting_IP>
	or	ax, ax
	jz	ff_real_fault
	mov	ds, [bp].fsf_SS
	mov	bx, [bp].fsf_SP
	sub	[bp].fsf_SP, 4
	mov	cx, [bp].fsf_err_code		; put error code on stack
	mov	[bx-2],cx
	mov	dx, [bp].fsf_faulting_IP
	mov	[bx-4],dx			; and faulting IP
	mov	[bp].fsf_faulting_IP, ax	; continue at gp fault handler
	jmps	ff_ret

ff_real_fault:

ifdef WOW
        test    DebugWOW,DW_DEBUG
        jz      ff_no_wdebug

        xor     ax,ax                           ; 0 in AX defaults to not handled
        push    DBG_GPFAULT2

	FBOP BOP_DEBUGGER,,FastBop

        add     sp,+2
        or      ax, ax

        jnz     ff_ret                  ; Alright! they handled the exception!
                                        ; Get us back to the app please!

        ; Otherwise, they chose to continue the exception

ff_no_wdebug:

endif

if	SHERLOCK
	cCall	GPContinue			; We know BP points to
	or	ax, ax				; the fault frame!
	jnz	ff_ret
endif

ff_stack:
	call	si				; call our fault handler

ff_ret:
	SetKernelDS
	pop	FaultHandler
	ret
FaultFilter     endp

ifdef WOW
;-----------------------------------------------------------------------;
;
; single_step
;
;-----------------------------------------------------------------------;
Entry single_step
        push    ds
        SetKernelDS ds

        push    ax

; QCWIN traces through code which it has no source code for.  This means
; its ends up tracing through the 16-bit to 32-bit transition code and
; when it traces on the call fword instruction, it cause  32-bit trace
; interrupt which breaks into the kd>  On a retail build with no
; debugger attached, it might work.
; To work around the problem we turn off the TraceFlag here if wow16cal
; has requested it.

        test    TraceOff,1h
        jnz     ss_turn_off_trace_flag

        test    DebugWOW,DW_DEBUG
        jz      ss_no_wdebug

        xor     ax,ax                           ; 0 in AX defaults to not handled
        push    DBG_SINGLESTEP

	FBOP BOP_DEBUGGER,,FastBop

        add     sp,+2
        or      ax, ax

        jnz     ss_ret                  ; Alright! they handled the exception!
                                        ; Get us back to the app please!

ss_no_wdebug:

        ; Otherwise, they chose to continue the exception
        pop     ax
        pop     ds
        jmp     cs:[prevInt01proc]


; Tell api code (wow16cal) to turn on trace flag at end of next api

ss_turn_off_trace_flag:
        sub     sp,2                    ; Make it look like "normalized" fault frame
	push	bp
	mov	bp,sp
        or      TraceOff,2h
        and     [bp].fsf_flags,NOT FLG_TRAP     ; turn off the trap flag
        pop     bp
        add     sp,2
ss_ret:
        pop     ax
        pop     ds
        UnSetKernelDS ds
        retf







;-----------------------------------------------------------------------;
;
; breakpoint
;
;-----------------------------------------------------------------------;
Entry breakpoint
        push    ds
        SetKernelDS ds
        push    ax

        test    DebugWOW,DW_DEBUG
        jz      br_no_wdebug

        xor     ax,ax                           ; 0 in AX defaults to not handled
        push    DBG_BREAK

	FBOP BOP_DEBUGGER,,FastBop

        add     sp,+2
        or      ax, ax

        jnz     bp_ret                  ; Alright! they handled the exception!
                                        ; Get us back to the app please!

br_no_wdebug:

        ; Otherwise, they chose to continue the exception
        pop     ax
        pop     ds
        jmp     cs:[prevInt03proc]

bp_ret:
        pop     ax
        pop     ds
        UnSetKernelDS ds
        retf

;-----------------------------------------------------------------------;
;
; divide_overflow
;
;-----------------------------------------------------------------------;
Entry divide_overflow
        ; at this point all of the registers contain the same values as they did
        ; at the time the faulting instruction was hit 
        ;    -- except for: cs:ip and ss:sp
        push    ds
        SetKernelDS ds  
        push    ax

        test    DebugWOW,DW_DEBUG
        jz      di_no_wdebug

        xor     ax,ax                         ; 0 in AX defaults to not handled
        push    DBG_DIVOVERFLOW


	FBOP BOP_DEBUGGER,,FastBop
.286p
        add     sp,+2
        or      ax, ax

        jnz     do_ret                  ; Alright! they handled the exception!
                                        ; Get us back to the app please!

di_no_wdebug:

        ; Otherwise, they chose to continue the exception

        ; check to see if we want to hack this exception for them
        push    es
        mov     es, curTDB
        mov     ax, es:[TDB_WOWCompatFlagsEx2]
        pop     es
        test    ax, 2   ; HIWORD(WOWCFEX_DIVIDEOVERFLOWPATCH)
        jz      di_no_patch1

.386p
        pop     ax  ; get the original ax
        ; push    ax  ; restore the stack (don't need to do this since we exit
                      ; via do_ret2  -- we want to preserve our *change* to AX

        push    ebx   ; preserve ebx
        mov     bx, sp

        push    eax ; make room for two dword local vars local[1]
        push    eax ; local[0]


        push    eax ; push original dividend registers
        push    edx
        push    word ptr ss:[bx+14]  ;get segment of faulting instruction
        push    word ptr ss:[bx+12]  ;get offset of faulting instruction
        
        mov     bx,sp ; push pointer to local[0]
        add     bx,12 ; point to local[0]
        push    ss   
        push    bx    

        ;call into wow32 returns with new divisor in al, ax, or dx:ax -- 
        ;depending on the instruction
        cCall   WowDivideOverflowEx  

        or      ax,ax     ; if both ax & dx are 0, it was an edx:eax form
        jnz     di_got_it ; so we have to get eax & edx from local[]
        or      dx,dx 
        jnz     di_got_it
        
        pop     eax  ; get eax & edx from local[]
        pop     edx

        pop     ebx  ; restore original ebx
        jmp     do_ret2

di_got_it:
        pop     ebx  ; get rid of local[] dwords
        pop     ebx

        pop     ebx  ; restore original ebx
        jmp     do_ret2;
.286p

di_no_patch1:
        pop     ax
        pop     ds
        jmp     cs:[oldInt00proc]

do_ret:
        pop     ax

do_ret2:  ; AX already popped -- we want to preserve our change to AX
        pop     ds
        UnSetKernelDS ds
        retf

endif

;-----------------------------------------------------------------------;
;
; Set_GO_BP
;
;-----------------------------------------------------------------------;
	public	Set_GO_BP
Set_GO_BP proc near
	mov	cx, [bp].fsf_faulting_CS	; Faulting CS
	mov	bx, [bp].fsf_faulting_IP	; Faulting IP
	DebInt	40h
;	mov	ax, 40h				; 16 bit forced go command
;	int	41h				; Call debugger
;ifdef	JAPAN
;	INT41SIGNATURE
;endif
	ret
Set_GO_BP endp

;-----------------------------------------------------------------------;
;
; ExitFault -- Fault at Exit Time!!!
;
; ENTRY:	BP points to fault frame described above
;
; EXIT:		Returns to DPMI.
;
; Registers Modified: None
;
;-----------------------------------------------------------------------;
	ReSetKernelDS

	public	ExitFault
ExitFault	proc	near
if KDEBUG
	Trace_Out "Fault at Exit Time!!!"
endif
;
; If a kernel debugger is loaded, pop out at the nested fault, and
; take no prisoners.
;
	test	Kernel_Flags[2],KF2_SYMDEB	; Debugger?
	jz	@F
	jmp	Set_GO_BP
@@:
	jmps	HandleFault
ExitFault	endp

	public	BUNNY_351
BUNNY_351	proc	far
	push	ds
	SetKernelDS
	mov	FaultHandler,codeOffset ExitFault
	pop	ds
	ret
BUNNY_351	endp

;-----------------------------------------------------------------------;
;
; MY_RETF -- Executes a far return.
;
;-----------------------------------------------------------------------;

MY_RETF proc near
	retf
MY_RETF	endp

;-----------------------------------------------------------------------;
;
; NestedFault -- Called when a fault handler Faults!!!
;
; ENTRY:	BP points to fault frame described above
;
; EXIT:		Returns to DPMI.
;
; Registers Modified: None
;
;-----------------------------------------------------------------------;
	ReSetKernelDS

	public	NestedFault
NestedFault	proc	near
if KDEBUG
	Trace_Out "Nested Fault!!!"
endif
;
; If a kernel debugger is loaded, pop out at the nested fault, and
; take no prisoners.
;
	test	Kernel_Flags[2],KF2_SYMDEB	; Debugger?
	jz	@F
	jmp	Set_GO_BP
@@:
	jmps	HandleFault
NestedFault	endp

;-----------------------------------------------------------------------;
;
; HandleFault -- Puts up the System Error box for a Fault.  Terminates
;		 the application or enters the debugger.
;
; ENTRY:	BP points to fault frame described above
;
; EXIT:		Returns to DPMI.  If Cancel is pressed, we tell
;		WDEB to set a GO breakpoint at the faulting instruction
;		first.  If OK is pressed, then the CS:IP on the DPMI
;		fault frame is modified to point to KillApp, and the
;		SS:SP points to a temp. stack owned by Kernel.
;
; Registers Modified: None
;
;-----------------------------------------------------------------------;
	ReSetKernelDS

	public	HandleFault
HandleFault	proc	near

	mov	ax, lpGPChain.sel	; Do we have a private GP handler?
	mov	lpGPChain.sel, 0	; Prevent re-entrancy
	cmp	ax, [bp].fsf_SS
	jnz	We_Can_Handle_It

	test	Kernel_Flags[2],KF2_SYMDEB	; Debugger?
	jz	@F
	mov	lpGPChain.sel,ax

	jmp	Set_GO_BP
@@:
					; If we want to chain back for any
	mov	bx, lpGPChain.off	; faults, then set up the stack of
	mov	[bp].fsf_SP, bx		; the handler, and continue execution
	mov	[bp].fsf_faulting_CS, cs ; at a RETF in Kernel
	mov	[bp].fsf_faulting_IP, offset MY_RETF

	cmp	[pPostMessage.sel],0	; is there a USER around yet?
	je	@F
	pusha
	push	es
	cCall	[pPostMessage],<-1,WM_SYSTEMERROR,1,0,0>
	pop	es
	popa
@@:

if kdebug
	mov	es, ax
	mov	ax, es:[bx+2]
	mov	bx, es:[bx]
	krDebugOut DEB_ERROR, "Fault detected - handled by %AX2 #AX:#BX"
endif

	jmp	HandleFault_Exit

We_Can_Handle_It:
	sub	sp, UAE_STRING_LEN	; Room for string
	mov	si, sp

	cCall	FormatFaultString,<ss,si,[bp].fsf_msg,[bp].fsf_faulting_CS,[bp].fsf_faulting_IP>

	push	bp
	xor	bp,bp			; Some people are picky...
	cCall	Display_Box_of_Doom,<0,ss,si>
	pop	bp

	add	sp, UAE_STRING_LEN

	or	ax, ax
	jne	@F
	INT3_DEBUG			; Failed call - no USER
@@:
	cmp	ax, 1			; Button 1 (Cancel) pressed?
	jne	@F
	jmp	Set_GO_BP
@@:

                test    fBooting, 1             ; No, they said to Nuke app.
                jnz     no_signal_proc

	mov	ds, curTDB

	UnSetKernelDS

	cmp	ds:[TDB_USignalProc].sel,0
	jz	no_signal_proc
	mov	bx,0666h
	mov	di, -1

	cCall	ds:[TDB_USignalProc],<ds,bx,di,ds:[TDB_Module],ds:[TDB_Queue]>

;
; Since we are on a nice big fat juicy fault handler stack now, we can call
; Windows to clean up after the task.
;
	mov	bx,SG_EXIT
	cCall	ds:[TDB_USignalProc],<ds,bx,di,ds:[TDB_Module],ds:[TDB_Queue]>
	mov	ds:[TDB_USignalProc].sel,0

no_signal_proc:

	mov	[bp].fsf_SP,dataOffset gmove_stack
	mov	[bp].fsf_SS,seg gmove_stack
	mov	[bp].fsf_faulting_CS,cs

	lea	ax,KillApp
	mov	[bp].fsf_faulting_IP,ax
HandleFault_Exit:
	ret

HandleFault endp

; ------------------------------------------------------------------
;
; ExceptionHandlerProc -- Common entry point for exception handlers
;
; ------------------------------------------------------------------
	public	ExceptionHandlerProc
ExceptionHandlerProc proc far

	push	bp
	mov	bp,sp
	pusha
	push	ds
	SetKernelDS
	push	es
EH_Popup:
	call	FaultFilter
EH_Chain:
	pop	es
	pop	ds
	UnsetKernelDS
	popa
	pop	bp
	add	sp,2			; remove message from stack
	retf				; chain to prev handler
EH_ret:
	pop	es
	pop	ds
	popa
	pop	bp
	add	sp,fsf_OFFSET
	retf

ExceptionHandlerProc endp


; ------------------------------------------------------------------
;
; This macro sets up the stack frame for entry to the generic
; exception handler.
;
; ------------------------------------------------------------------
ExceptionHandlerPrologue	macro name,msg,chain
	public	name
name:
	push	word ptr chain + 2
	push	word ptr chain
	push	offset msg
endm

; ------------------------------------------------------------------
;
; This macro sets up the stack frame, then jumps to the generic
; exception handler.
;
; ------------------------------------------------------------------
ExceptionHandler	macro name,msg,chain
	ExceptionHandlerPrologue	name,msg,chain
	jmp	ExceptionHandlerProc
	assumes	ds, nothing
	assumes	es, nothing
endm

; ------------------------------------------------------------------
;
; Four fatal ones.
;
; ------------------------------------------------------------------
	ExceptionHandler	StackFault,szSF,prevInt0Cproc
	ExceptionHandler	GPFault,szGP,prevInt0Dproc
	ExceptionHandler	invalid_op_code_exception,szII,prevIntx6proc
	ExceptionHandler	page_fault,szPF,prevInt0Eproc
        ExceptionHandler        LoadSegFailed,szLoad,prevInt3Fproc

; ------------------------------------------------------------------
;
; The not present fault is used to demand-load segments from newexe
; files.  If we find out that something bogus has happened, then
; we just jump into the fault handler.
;
; ------------------------------------------------------------------
	ExceptionHandlerPrologue SegmentNotPresentFault,szNP,prevInt3Fproc
	
	push	bp
	mov	bp,sp
	pusha
	push	ds
	SetKernelDS
	push	es

	mov	al,byte ptr [bp].fsf_faulting_CS
	and	al, SEG_RING_MASK		; Check it was Ring 1, LDT
	cmp	al, SEG_RING
	
	je	@F
	jmp	EH_Chain
@@:
	mov	al,byte ptr [bp].fsf_err_code
	test	al, SEL_LDT			; Check it was LDT
	
	jne	@F
	jmp	EH_Chain
@@:

if KDEBUG
	test	byte ptr [bp].fsf_flags+1,2	; IF set in faulting frame?
	jnz	@F
	Trace_Out "Segment not present fault with interrupts disabled!"
@@:
endif
        FSTI
;
; Don't discard the segment that we have to return to!!!
;
	cCall	GlobalHandleNorip,<[bp].fsf_faulting_CS>
	test	cl,GA_DISCARDABLE
	jz	@F	
	cCall	GlobalLRUNewest,<ax>
@@:

	mov	bx,[bp].fsf_err_code
seg_reload:
	and	bx, NOT 7h		; get the not present selector
	or	bl, SEG_RING		; Correct RING bits
if KDEBUG
	mov	INT3Fcs, bx		; Save in case of error
endif

;   On WOW we don't copy the owner to the real LDT since it is slow to call
;   the NT Kernel, so we read our copy of it directly.
;   see set_discarded_sel_owner   mattfe mar 23 93

	mov	es,cs:gdtdsc
	mov	cx,bx			; save bx
	and	bl, not 7
	mov	es,es:[bx].dsc_owner
	mov	bx,cx			; restore
	StoH	bl			; Need handle

	cmp	es:[ne_magic],NEMAGIC	; If owner is not a module
	jnz	bad_seg_load		; (i.e., an instance or garbage)
					; get out of here.
	mov	di,es:[ne_segtab]
	mov	ax,1
	mov	cx, es:[ne_cseg]
	jcxz	bad_seg_load
dorten:
	cmp	es:[di].ns_handle,bx
	jz	got_seg_no
	add	di,SIZE NEW_SEG1
	inc	ax
	loop	dorten

; program has referenced garbage...

bad_seg_load:
	jmp	EH_Popup

got_seg_no:

;
; If we already are on the exception handler stack, then we want to make
; sure that we don't overwrite the original stack frame.  Copy our
; stack frame variables down by the difference between SP and SP before
; we got called.
;
	push	ax
	mov	ax,ss
	cmp	ax,word ptr [bp].fsf_SS
	pop	ax
	jne	stack_OK
	push	ax
	push	bx
	push	bp
	lea	bp,word ptr [bp].fsf_SS
	mov	ax,sp
	dec	ax
	dec	ax
@@:
	push	word ptr [bp]
	dec	bp
	dec	bp
	cmp	bp,ax
	jne	@B
	pop	bp
	pop	bx
	pop	ax
;
; Figured out what this was supposed to be by tracing up to here
; in the debugger.
;
	sub	bp,32h

stack_OK:
	push	es
	mov	bx,ax
	UnsetKernelDS
	mov	ax,ss
	mov	ds,ax
	les	di,dword ptr [bp].fsf_SP
	dec	di
	dec	di
	std
;
; Push an IRET frame on the faulting stack.
;
	lea	si,[bp].fsf_flags
	mov	cx,3
	rep	movsw
;
; Push our saved registers on the faulting stack.
;
	lea	si,[bp]
	mov	cx,11		; BP + PUSHA + ES + DS
	rep	movsw

	pop	ax
;
; Push arguments to LoadSegment on the faulting stack.
;
	stosw			; hExe
	mov	ax,bx
	stosw			; segno
	mov	ax,-1
	stosw
	stosw
	inc	di
	inc	di
;
; Point the faulting stack at the new location.
;
	mov	[bp].fsf_SP,di
;
; Tell DPMI to return to us instead of the faulting code.
;
	mov	[bp].fsf_faulting_CS,cs
	mov	[bp].fsf_faulting_IP,offset let_them_do_it
	lea	sp,[bp].fsf_ret_IP

if kdebug
	SetKernelDS
	mov	wFaultSegNo, bx
	UnSetKernelDS
endif
	retf
let_them_do_it:
	SetKernelDS

	xor	cx, cx			; we try to keep a selector reserved
	xchg	cx, DemandLoadSel	;   for scratch use while demand
	jcxz	@f			;   loading segments--free it to make
	cCall	IFreeSelector,<cx>	;   it available now
@@:
	cCall	LoadSegment

	push	ax			; reserve a selector for the next
        cCall   AllocSelector,<0>      ;   time we demand load a segment
	mov	DemandLoadSel, ax
	pop	cx			; LoadSegment result
	jcxz	SegLoaderFailure

if kdebug
	push	bx
	mov	bx, wFaultSegNo
	krDebugOut	<DEB_TRACE or DEB_krLoadSeg>, "Demand load %CX2(#bx) on %SS2"
	pop	bx
endif
	pop	es
	pop	ds
	UnsetKernelDS
	popa
	pop	bp

        ;** Check to see if we're about to restart an instruction in
        ;**     a not present segment.  This would only occur if the
        ;**     segment was discarded because of the segment load we
        ;**     just did.
IF KDEBUG
        push    bp              ;Make a stack frame
        mov     bp,sp
        push    ax
        mov     bp,[bp + 4]     ;Get the CS
        lar     ax,bp           ;See if the CS is valid
        test    ax,8000h        ;Is it present?
        jnz     @F              ;Yes, don't complain
	mov	ax,bp
        Trace_Out <'LDINT: Trying to restart discarded caller (#AX)'>
@@:
        pop     ax
        pop     bp
ENDIF
	iret

	public	SegLoaderFailure
SegLoaderFailure	proc near
;
; segment loader was unable to load the segment!!!
; Restore all the registers, create a fake DPMI frame, then
; complain about the problem.  Lets the user break into the
; debugger, if installed, on Cancel.  Creating and destroying
; the fake DPMI frame is inconvenient and messy, but it lets
; us handle the problem in common fault code.
;
	pop	es
	pop	ds
	UnsetKernelDS
	popa

	sub	sp,4
	mov	bp,sp			; BP -> xx xx BP IP CS FL
	push	word ptr [bp+4]		; push app's BP
	push	ax			; get a temporary register
	mov	ax,[bp+6]		; IP
	mov	[bp+2],ax
	mov	ax,[bp+8]		; CS
	mov	[bp+4],ax
	mov	ax,[bp+10]		; Flags
	mov	[bp+6],ax
	mov	[bp+10],ss
	lea	ax,[bp+12]
	mov	[bp+8],ax
	pop	ax
	pop	bp	
	
	call	far ptr LoadSegFailed	; BP -> RETIP RETCS EC IP CS FL SP SS

	push	bp
	mov	bp,sp			; BP -> BP EC IP CS FL SP SS
	mov	[bp+2],ax
	mov	ax,[bp+8]		; Flags
	mov	[bp+12],ax
	mov	ax,[bp+6]		; CS
	mov	[bp+10],ax
	mov	ax,[bp+4]		; IP
	mov	[bp+8],ax
	pop	bp
	pop	ax
	add	sp,4
	iret

SegLoaderFailure	endp

;ENDIF

;-----------------------------------------------------------------------;
; default_sig_handler
;
;
; Entry:
;
; Returns:
;
; Registers Destroyed:
;
; History:
;  Wed 10-Jan-1990 22:32:34  -by-  David N. Weise  [davidw]
; Wrote it!
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	default_sig_handler,<PUBLIC,FAR>

cBegin nogen

	ret

cEnd nogen

;-----------------------------------------------------------------------;
;
; Panic -- Called by ToolHelp when it gets a bad stack fault or any
;	   other fault with SP suspiciously low.
;
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	Panic,<PUBLIC,NEAR>
cBegin
if KDEBUG
	Trace_Out "KERNEL: Panic called!!!"
endif
	int	1
	jmp	KillApp
cEnd

;-----------------------------------------------------------------------;
; DoSignal
;
;
; Entry:
;
; Returns:
;
; Registers Destroyed:
;
; History:
;  Wed 10-Jan-1990 22:52:52  -by-  David N. Weise  [davidw]
; Wrote it!
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	DoSignal,<PUBLIC,FAR>,<ax,bx,cx,dx,di,si,es>
cBegin
	SetKernelDS
	cmp	pUserGetFocus.sel,0	; is there a USER yet?
	jz	ds_exit
	call	pUserGetFocus
	or	ax,ax
	jz	ds_exit
	mov	si,ax
	cCall	pUserIsWindow,<ax>
	or	ax,ax
	jz	ds_exit
	cCall	pUserGetWinTask,<si>
	mov	ds,ax
	TDB_check_DS
	cmp	ds:[TDB_SigAction],2	; send it on?
	jnz	ds_exit
	mov	ax,1
	xor	bx,bx
	cCall	ds:[bx].TDB_ASignalProc,<bx,ax>
ds_exit:

cEnd



sEnd	CODE

sBegin MISCCODE
assumes	cs, misccode
assumes ds, nothing
assumes es, nothing

externNP MISCMapDStoDATA

ifdef WOW
externFP htoa

	assumes ds,nothing
	assumes es,nothing

;-----------------------------------------------------------------------;
; allows htoa to be called from _TEXT code segment
cProc	Far_htoa,<PUBLIC,FAR>
    parmD   lpstr
    parmW   val
cBegin
    push    [bp+10]
    push    [bp+8]
    push    [bp+6]
    call    far ptr htoa
cEnd

endif  ;; WOW


;-----------------------------------------------------------------------;
; SetSigHandler
;
; SetSigHandler notifies Windows of a handler for a signal.
; It may also be used to ignore a signal or install a default
; action for a signal.
;
; Entry:
;	parmD	lpprocRoutine	Signal handler
;	parmD	lpDPrevAddress	Previous handler (returned)
;	parmD	lpWPrevAction	Previous action (returned)
;	parmW	Action		Indicate request type
;	parmW	SigNumber	Signal number of interest
;
; Returns:
;
; Registers Destroyed:
;
; History:
;  Mon 25-Dec-1989 00:36:01  -by-  David N. Weise  [davidw]
; Wrote it!
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	SetSigHandler,<PUBLIC,FAR>,<di,si,ds>

	parmD	lpprocRoutine
	parmD	lpDPrevAddress
	parmD	lpWPrevAction
	parmW	Action
	parmW	SigNumber
cBegin
	call	MISCMapDStoDATA
	ReSetKernelDS
	cmp	SigNumber,1		; is it SIGINTR?
	jnz	dssh_return_success	;  ignore if not

	cmp	Action,4		; is it reset Signal?
	jz	@F

	push	ds
	mov	ds,curTDB
	assumes ds,nothing
	mov	ax,Action
	xchg	ax,ds:[TDB_SigAction]
	les	bx,lpWPrevAction
	mov	cx,es
	or	cx,bx
	jz	@F
	mov	es:[bx],ax
@@:
	mov	dx,lpprocRoutine.sel
	mov	ax,lpprocRoutine.off
	cmp	Action,0		; put in default handler?
	jnz	ssg_stick_it_in
	mov	dx,SEG default_sig_handler
	mov	ax,codeOffset default_sig_handler
ssg_stick_it_in:
	xchg	dx,ds:[TDB_ASignalProc].sel
	xchg	ax,ds:[TDB_ASignalProc].off
	cmp	Action,4		; is it reset Signal?
	jz	@F
	les	bx,lpDPrevAddress
	mov	cx,es
	or	cx,bx
	jz	@F
	mov	es:[bx].sel,dx
	mov	es:[bx].off,ax
	pop	ds
@@:

dssh_return_success:
	xor	ax,ax			; return success

dssh_exit:

cEnd

;----------------------------------------------------------------------------
;
;  SwapRecording(Flag)
;
;	Flag = 0  => Stop recording
;	     = 1  => Start recording only Swaps, Discards and Returns
;	     = 2  => Start recording Calls in addition to Swaps, Discards and 
;				returns.
;  Destroys AL register
;----------------------------------------------------------------------------

; Retail Version

cProc  ISwapRecording,<PUBLIC, FAR>
;	parmW  Flag
cBegin nogen
	retf  2
cEnd nogen

sEnd MISCCODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\ldseg.asm ===
TITLE   LDSEG - SegAlloc procedure

.xlist
include kernel.inc
include newexe.inc
include tdb.inc
include protect.inc             ; Handle_To_Sel
.list

NSHUGESEG       = NSKCACHED             ; not first seg of huge segment
; A huge segment (data object larger than 64K) requires more than one
; selector, but is part of a single memory allocation block.  The first
; selector is a handle, like any other segment.  Subsequent selectors of
; the huge memory block are _not_ handles, so we can't call MyLock() on
; them, as the consistency check will fail.  We mark these selectors with
; the NSHUGESEG bit in the flags word.  TonyG suggested this.
; Note that data segments are already loaded, locked, etc, so the call to
; MyLock is redundant anyway.
;  Thu Feb 28, 1991 01:39:00p  -by-  Don A. Corbitt   [donc]            ;



externFP IGlobalFree
externFP IGlobalAlloc
externFP IGlobalReAlloc
externFP IGlobalLock
externFP MyOpenFile
externFP FlushCachedFileHandle
externFP Int21Handler
externFP set_discarded_sel_owner
externFP GetPatchAppRegKey
externFP PatchAppSeg

if KDEBUG
externFP OutputDebugString
endif

DataBegin

externB  Kernel_flags
;externB  fBooting
externB  fPadCode
;externW  pGlobalHeap
;externW  MyCSDS
externW  Win_PDB

if KDEBUG
externB  fLoadTrace
externB  fPreloadSeg
endif

externD FreeArenaCount
extrn   CountFreeSel:WORD

DataEnd

sBegin  CODE
assumes CS,CODE
assumes DS,NOTHING
assumes ES,NOTHING

;externNP MyFree
externNP SegReloc
externNP MyAlloc
externNP MyAllocLinear                  ; MyAlloc with useful parameters
externNP MyLock
externNP GetCachedFileHandle
externNP CloseCachedFileHandle
externNP GetOwner
externNP SetOwner
externNP get_selector_length16

externNP get_rover_2
externNP DiscardTheWorld

IFNDEF NO_APPLOADER
externNP LoadApplSegment
endif ;!NO_APPLOADER

if LDCHKSUM
;externNP GetChksumAddr
externNP CheckSegChksum
externNP ZeroSegmentChksum
endif

if SDEBUG
externNP DebugDefineSegment
endif

ifdef WOW_x86
externNP get_physical_address
endif

;-----------------------------------------------------------------------;
; AllocSeg                                                              ;
;                                                                       ;
; Allocates memory for a segment.  Does not load the segment.  Puts     ;
; the handle of the segment into the segment descriptor structure       ;
; in the module database, and updates the flags there to mark the       ;
; segment as allocated but not loaded.  Put the segment number into     ;
; the BurgerMaster handle entry.  It also changes the .ga_owner to be   ;
; the module database.                                                  ;
;                                                                       ;
; Arguments:                                                            ;
;       parmD   pSegInfo                                                ;
;                                                                       ;
; Returns:                                                              ;
;       AX = handle for segment                                         ;
;                                                                       ;
; Error Returns:                                                        ;
;       AX = 0                                                          ;
;       ZF = 1                                                          ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       SI,DS,ES                                                        ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;       BX,CX,DX                                                        ;
;                                                                       ;
; Calls:                                                                ;
;       MyAlloc                                                         ;
;                                                                       ;
; History:                                                              ;
;  Thu Feb 28, 1991 01:39:00p  -by-  Don A. Corbitt   [donc]            ;
; Handle 64K (big/huge) data segments                                   ;
;                                                                       ;                                                                       ;
;  Mon Feb 09, 1987 10:29:16p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.                                       ;
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   AllocSeg,<PUBLIC,NEAR>,<si,es>
        parmD   pSegInfo
cBegin
        SetKernelDS
        les     si,pSegInfo

; Get size into AX (max of file size and minimum allocation).

        mov     bx,es:[si].ns_flags

        test    bl,NSALLOCED            ; Already allocated?
        jz      as0                     ;  No, allocate it
        jmp     SHORT as3
as0:    mov     ax,es:[si].ns_minalloc
        xor     dx, dx                  ; if AX == 0
        cmp     ax, 1                   ; then it is really 64K
        adc     dx, dx
        add     ax, 2           ; We may have a 1 byte entry point at the
        adc     dx, 0           ;  very end of a segment.  PatchCodeHandle
                                ;  will GP trying to decipher the prolog.
                                ; Also allow space for reading relocation word

        cmp     si,es:[ne_pautodata]
        jne     as1
        add     ax,es:[ne_stack]        ; Include stack and heap for data.
        jc      asfail                  ; Don't need to handle big auto segs
        add     ax,es:[ne_heap]
        jnc     as1
asfail:
        krDebugOut      DEB_ERROR, "%es2 Automatic Data Segment larger than 64K."
        xor     ax,ax
asxj:   jmp     SHORT asx
as1:

; Allocate space for segment
        push    bx
        push    es
        cCall   MyAllocLinear,<bx,dxax>
        pop     es
        pop     bx
        or      ax,ax
        jz      asxj


as2:
        mov     es:[si].ns_handle,dx    ; Handle into seg table
        and     byte ptr es:[si].ns_flags,not NSLOADED
        or      byte ptr es:[si].ns_flags,NSALLOCED

        mov     bx,dx
        cCall   SetOwner,<ax,es>

as3:    mov     ax,es:[si].ns_handle
asx:
        or      ax,ax

cEnd

;-----------------------------------------------------------------------;
; LoadSegment                                                           ;
;                                                                       ;
; Loads a segment and performs any necessary relocations.               ;
;                                                                       ;
; Arguments:                                                            ;
;       parmW   hExe                                                    ;
;       parmW   segno                                                   ;
;       parmW   fh                                                      ;
;       parmW   isfh                                                    ;
;                                                                       ;
; Returns:                                                              ;
;       AX = handle of segment                                          ;
;       CX = handle of segment                                          ;
;       DX = handle of segment                                          ;
;                                                                       ;
; Error Returns:                                                        ;
;       AX = 0                                                          ;
;       CX = 0                                                          ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       DI,SI,DS                                                        ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;       BX,ES                                                           ;
;                                                                       ;
; Calls:                                                                ;
;       LoadSegment                                                     ;
;       AllocSeg                                                        ;
;       LoadApplSegment                                                 ;
;       MyOpenFile                                                      ;
;       SegLoad                                                         ;
;       GlobalAlloc                                                     ;
;       MyLock                                                          ;
;       SegReloc                                                        ;
;       GlobalFree                                                      ;
;       ZeroSegmentChksum                                               ;
;       CheckSegChksum                                                  ;
;                                                                       ;
; History:                                                              ;
;  Thu Feb 28, 1991 01:39:00p  -by-  Don A. Corbitt   [donc]            ;
;                                                                       ;
;  Tue Oct 27, 1987 06:10:31p  -by-  David N. Weise   [davidw]          ;
; Wrote it.                                                             ;
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   LoadSegment,<PUBLIC,NEAR>,<si,di>
        parmW   hExe
        parmW   segno
        parmW   fh
        parmW   isfh
        localW  myfh
        localW  hrleseg
        localD  pseginfo
        localW  creloc
        localW  hseg
        localW  fdataseg
        localW  retries
        localW  SavePDB
        localB  fReload
        localW  pleaseNoLock            ; 1 if shouldn't lock seg
cBegin
        mov     retries, 2
        xor     ax,ax
        mov     hrleseg,ax
        mov     hseg,ax
        mov     SavePDB, ax
        mov     pleaseNoLock, ax
        mov     fReload, al
        not     ax
        mov     myfh,ax
        mov     es,hexe
        mov     si,segno
        dec     si
        cmp     es:[ne_cseg],si
        jg      ls_not_done             ; wish we had auto jump sizing...
        jmp     lsdone
ls_not_done:
        shl     si,1
        mov     bx,si
        shl     si,1
        shl     si,1
        add     si,bx
        .errnz  10 - SIZE NEW_SEG1
        add     si,es:[ne_segtab]
        mov     SEG_pseginfo, es        ; Save segment info pointer
        mov     OFF_pseginfo, si

IFNDEF NO_APPLOADER
        test    es:[ne_flags],NEAPPLOADER
        jnz     ls_special_load
ls_not_special_load:
ENDIF ;!NO_APPLOADER

        mov     bx,es:[si].ns_flags
        mov     ax, bx
        and     ax, NSHUGESEG
        mov     pleaseNoLock, ax

        test    bl,NSALLOCED
        jnz     ls1
        push    bx
        cCall   AllocSeg,<essi>         ; No, so try allocating the segment
        pop     bx
        or      ax,ax
        jnz     ls1b
ls1:    mov     ax,es:[si].ns_handle
        mov     hseg,ax
        test    bl,NSLOADED
        jz      ls1b
        mov     fReload,1
        jmp     lsexit                  ; so MyLock at lsexit can swap them in

IFNDEF NO_APPLOADER
ls_special_load:
        mov     ax,segno
        cmp     ax,1
        je      ls_not_special_load     ;* first segment normal load
        test    es:[si].ns_flags,NSLOADED
        jnz     ls_already_loaded
        cCall   LoadApplSegment, <hExe, fh, ax>
        jmp     lsx

ls_already_loaded:
        mov     ax,es:[si].ns_handle
        mov     hseg,ax
        mov     fReload,1
        jmp     lsexit
endif ;!NO_APPLOADER

ls1b:
        mov     ax,fh
        inc     ax                      ; Already have file handle?
        jz      ls2                     ; No, then get one and load segment
        dec     ax
        cmp     isfh,ax                 ; Yes, loading from memory?
        jne     lsdoit                  ; Yes, load it now
        jmps    ls2b                    ; No, load it now
ls2:
        SetKernelDS
        mov     ax, Win_PDB             ; Save what PDB is supposed to be
        mov     SavePDB, ax             ; since we will set it to kernel's PDB
        mov     ax,-1
        cCall   GetCachedFileHandle,<hExe,ax,ax> ; Get file handle from cache
ls2b:
        mov     myfh,ax
        mov     isfh,ax
        inc     ax
        jnz     lsdoit0
        cmp     SavePDB, ax             ; If we saved the PDB, (ax=0)
        je      @F
        push    SavePDB                 ; better restore it!
        pop     Win_PDB
@@:
        jmp     lsdone
lsdoit0:
        dec     ax
lsdoit:
        push    es
        cCall   SegLoad,<essi,segno,ax,isfh>
        pop     es
        mov     hseg,0
        or      ax,ax
        jz      lsexit1

        inc     ax                              ; Did we get a file error?
        jnz     lsloaded
        mov     bx, myfh
        inc     bx                              ; Reading from memory?
        jz      lsexit1                         ;  no, fail
        dec     bx
        cmp     bx, fh                          ; We opened the file?
        je      lsexit1                         ;  no, fail
;;;     cCall   CloseCachedFileHandle,<bx>
        mov     bx, SavePDB
        mov     Win_PDB, bx
        cCall   FlushCachedFileHandle,<hExe>    ; Close it
        dec     retries
        jz      lsbadfile
        jmps    ls2                             ; and try to re-open it.
        UnSetKernelDS
lsbadfile:
        krDebugOut      DEB_ERROR, "%ES2 I/O error reading segment"
lsexit1:
        jmp     lsexit

lsloaded:
        mov     hseg,bx
        mov     bx,es:[si].ns_flags
        test    bx,NSRELOC
        jnz     lm1x
        jmp     lschksum
lm1x:
        and     bx,NSDATA
        mov     fdataseg,bx
        mov     bx,myfh                 ; Loading from memory?
        inc     bx
        jnz     lm1                     ; No, continue
        mov     es,dx                   ; Yes, point to relocation info
        mov     si,cx
        cld
        lods    word ptr es:[si]
        mov     creloc,ax
        jmps    lm2
lm1:
        dec     bx
        mov     creloc,cx
        shl     cx,1
        shl     cx,1
        shl     cx,1
        .errnz  8 - SIZE new_rlc
        push    bx
        push    cx
        mov     ax,GA_MOVEABLE+GA_NODISCARD     ; DO NOT WANT FIXED!!
        xor     bx,bx
        regptr  xsize,bx,cx
.386
; We don't really want to cause an attempt to grow the global arena
; table or the LDT here!
        push    ds
        SetKernelDS
        cmp     FreeArenaCount,0        ; free arena?
        jz      NoFreeArenas            ; No
        cmp     CountFreeSel,0          ; free selector?
NoFreeArenas:
        pop     ds
        UnsetKernelDS
        jz      lm1a                    ; No, then read one at a time
.286
        cCall   IGlobalAlloc,<ax,xsize>
        mov     hrleseg,ax      ; Save handle
        or      ax,ax           ; Did we get the memory
        jz      lm1a            ; No, then read one at a time

        cCall   IGlobalLock,<ax> ; Get the address of the relocation info
        mov     si, ax
        mov     es, dx
        pop     cx              ; Restore byte count
        pop     bx              ; Restore file handle
        push    ds
        mov     ds,dx
        assumes ds,nothing
        xor     dx,dx
        mov     ah,3Fh          ; Read in relocation information
        DOSCALL
        pop     ds
        assumes ds,nothing
        jc      lserr2
        cmp     ax,cx
        jne     lserr2
        jmps    lm2

lm1a:
        pop     cx              ; Restore byte count
        pop     bx              ; Restore file handle
        xor     si,si
        mov     es,si           ; Signal no records read
lm2:
                                ; Pass pseginfo, not hseg
        cCall   SegReloc,<hexe,essi,creloc,pseginfo,fdataseg,myfh>
lm2a:
        mov     cx,hrleseg
        jcxz    no_hrleseg
        push    ax
        cCall   IGlobalFree,<hrleseg>
        pop     ax
no_hrleseg:
        les     si,pseginfo
        or      ax,ax
        jnz     lschksum
lsdone2:
        jmps    lsdone

lserr2:
        krDebugOut DEB_ERROR, "Error reading relocation records from %es2"
        xor     ax,ax
        jmp     lm2a

lschksum:
        mov     ax, hseg                ; in case we aren't locking
        Handle_To_Sel   al
        cmp     pleaseNoLock, 0
        jnz     lschksum1
        cCall   MyLock,<hseg>
lschksum1:

if LDCHKSUM
        push    ax
        push    si
        mov     si,ax
        cCall   ZeroSegmentChksum
        pop     si
        cCall   CheckSegChksum          ; destroys ax, bx, cx, dx, es
        pop     ax
endif

        les     si, pseginfo

if SDEBUG                               ; Tell debugger about new segment
        cmp     pleaseNoLock, 0
        jnz     keep_secrets
        mov     bx,es:[ne_restab]
        inc     bx
        mov     dx,es:[si].ns_flags
        mov     si, ax  
        xor     ax, ax
        test    dx,NSDATA               ; test to pass NSKCACHED too
        jz      sa8
        test    byte ptr es:[ne_flags],NEINST
        jz      sa8
        mov     ax,es:[ne_usage]
        dec     ax
sa8:
        mov     cx,segno
        dec     cx

        cCall   DebugDefineSegment,<esbx,cx,si,ax,dx>
keep_secrets:
endif

lsexit:
        mov     cx,hseg
        jcxz    lsdone
        mov     ax, cx                  ; in case we don't lock
        mov     dx, ax
        Handle_To_Sel    al
        cmp     pleaseNoLock, 0
        jnz     lsdone
        cCall   MyLock,<cx>
lsdone:
        mov     cx,myfh
        inc     cx
        jz      lsx
        dec     cx
        cmp     fh,cx
        je      lsx
        push    ax
        SetKernelDS
;;;     cCall   CloseCachedFileHandle,<cx>
        mov     ax, SavePDB
if KDEBUG
        or      ax, ax
        jnz     @F
        int 3
@@:
endif
        mov     Win_PDB, ax
        UnSetKernelDS
        pop     ax
public lsx
lsx:
        mov     es, hExe
        test    es:[ne_flagsothers], NEHASPATCH
        jz      ls_exeunt
        cmp     fReload, 0
        jne     ls_exeunt

        push    dx
        push    ax

        cCall   GetPatchAppRegKey,<hExe>
        mov     cx, dx
        or      cx, ax
        jnz     @F

        ; MCF_MODPATCH is set, but there are no patches
        ; in the registry for this module. Turn off the patch flag.
        and     es:[ne_flagsothers], not NEHASPATCH
        jmp short ls_after_patch
@@:
        ; reg key in dx:ax
        cCall   PatchAppSeg,<dx,ax,segno,hseg>
        test    ax, ax
        jz      ls_after_patch

        ; One or more patches applied, so mark the segment not discardable.
        ; PatchAppSeg already cleared GA_DISCARDABLE or GA_DISCCODE in the
        ; global arena record.
        mov     si, pseginfo.off
        and     es:[si].ns_flags, not NSDISCARD     ; mark not discardable
ls_after_patch:
        pop     ax
        pop     dx
ls_exeunt:
        mov     cx,ax
cEnd


GETSEGLEN macro segval
        local   not_huge_386
.386p
        xor     eax, eax                ; since we now have huge segments,
        mov     ax, segval              ; we need to be able to handle limit
        lsl     eax, eax                ; values > 64K.  On a 386 we just
        inc     eax                     ; execute the lsl instruction.
        test    eax, 0ffff0000h
.286
        jz      not_huge_386
        mov     ax, 0                   ; 0 == 64K
not_huge_386:
endm

;-----------------------------------------------------------------------;
; SegLoad                                                               ;
;                                                                       ;
; Reads in the data portion of a code or data segment.                  ;
;                                                                       ;
; It can be confusing decoding how various values of ns_cbseg,          ;
; ns_minalloc, and ns_sector define the size of disk files.  I hope     ;
; this table is accurate for all combinations....                       ;
;                                                                       ;
;       sector  cbseg   minalloc- Sector in memory is ...               ;
;       0       0       0       - 64K segment, all 0's                  ;
;       0       0       m       - 'm' bytes, all 0's                    ;
;       0       c       0       - illegal (sector = 0 when cbseg != 0)  ;
;       0       c       m       - illegal (sector = 0 when cbseg != 0)  ;
;       s       0       0       - 64K segment on disk at given sector   ;
;       s       0       m       - illegal (cbseg > minalloc)            ;
;       s       c       0       - 64K, 'c' from file, 64K-'c' 0's       ;
;       s       c       m       - 'm' bytes, 'c' from file, 'm-c' 0's   ;
;                                                                       ;
;  In other words, cbseg == 0 means 64K when a sector value is given,   ;
;  else it means 0 bytes from the file                                  ;
;                                                                       ;
; Arguments:                                                            ;
;       parmD   pseginfo                                                ;
;       parmW   segno                                                   ;
;       parmW   psegsrc                                                 ;
;       parmW   isfh                                                    ;
;                                                                       ;
; Returns:                                                              ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;                                                                       ;
; Calls:                                                                ;
;                                                                       ;
; History:                                                              ;
;  Thu Feb 28, 1991 01:39:00p  -by-  Don A. Corbitt   [donc]            ;
; Add support for big/huge segments                                     ;
;                                                                       ;
;  Tue Oct 27, 1987 06:17:07p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.                                       ;
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   SegLoad,<NEAR,PUBLIC>,<si,di>
        parmD   pseginfo
        parmW   segno
        parmW   psegsrc
        parmW   isfh
        localW  hseg
        localW  pseg
        localW  psegdest
        localD  prleinfo
        localW  retry
        localW  segoffset
        localW  pleaseNoLock            ;1 if segment is 64K
        localW  allocTwice              ;if first alloc fails, FreeTheWorld
ifdef WOW_x86
        localD  rover_2
endif
cBegin
        mov     retry,1
        mov     segoffset, 0
        mov     allocTwice, 1
        les     si,pseginfo
        mov     ax,es:[si].ns_handle
        mov     hseg,ax
        Handle_To_Sel   al                      ; in case we don't lock
        mov     pleaseNoLock, 1
        test    es:[si].ns_flags, NSHUGESEG
        jnz     dont_touch              ;big segs are always locked and present
        mov     pleaseNoLock, 0
        push    es
        cCall   MyLock,<ax>
        pop     es
        or      ax,ax
        jz      try_alloc       ; wish I could "jnz saalloced"
dont_touch:
        jmps    saalloced

try_alloc:
        push    es
        xor     ax,ax
        mov     bx, es:[si].ns_minalloc
        xor     dx, dx
        cmp     bx, 1
        adc     dx, dx
        add     bx, 2           ; We may have a 1 byte entry point at the
        adc     dx, 0           ;  very end of a segment.  PatchCodeHandle
                                ;  will GP trying to decipher the prolog.
                                ; Allow room to read relocation word
        cCall   IGlobalReAlloc,<hseg,dx,bx,ax>
        pop     es
        cmp     hseg,ax
        jz      sarealloced
saerr2:
        test    es:[si].ns_flags,NSDISCARD
        jz      dont_scream
        push    es
        cCall   DiscardTheWorld         ; Maybe if we try again
        pop     es
        dec     allocTwice
        jz      try_alloc
        krDebugOut DEB_ERROR, "Out of mem loading seg %es2"
dont_scream:
        jmp     saerr1

sarealloced:                            ; ax == handle
        Handle_To_Sel   al
        cmp     pleaseNoLock, 0
        jnz     saalloced
        push    es
        cCall   MyLock,<hseg>
        pop     es
        or      ax,ax
        jz      saerr2

saalloced:
        mov     pseg,ax
        mov     psegdest,ax

sareread:
        push    es
        push    si
        push    ds                              ; We are going to trash this

        cld
        cmp     es:[si].ns_sector,0     ; if sector == 0, then just init
        jnz     sa_read_from_disk       ; segment to all 0's
;       mov     cx, es:[si].ns_minalloc ; convert minalloc == 0 to 64K
        GETSEGLEN pseg
        mov     cx, ax
ifdef WOW_x86 ;
.386
;; WOW we can use the magic flat selector 23h to write to any segment
;; This saves us calling get_rover_2 which makes an NT system call to set
;; a temp selector
        cCall   get_physical_address,<pseg>
        shl     edx,16
        mov     dx,ax
        mov     ax,FLAT_SEL
        mov     es,ax

    xor eax, eax
        mov     edi,edx                 ; es:edi -> pseg:0

        cmp     cx, 1                   ; Need to handle case where CX == 0
        mov     dx, cx
        rcr     cx, 1
        shr     cx, 1
        movzx   ecx,cx
        rep     stos dword ptr [edi]
        mov     cx, dx
        and     cx, 3
        rep     stos byte ptr [edi]
        jmp     sa_after_read

else ; 286
        cmp     cx, 1                   ; set CF if 0000
        rcr     cx, 1                   ; this sets CF for odd byte of size
        xor     ax, ax
        xor     di, di
        mov     es, pseg                ; start at pseg:0000
        call    get_rover_2
        rep     stosw
        adc     cx, cx
        rep     stosb                   ; this case now handled
        jmp     sa_after_read
endif;

sa_read_from_disk:
        mov     di,es:[si].ns_cbseg     ; #bytes in segment to read

; If source segment address given then copy segment contents

        mov     bx,psegsrc              ; Get source handle
        cmp     isfh,bx                 ; Is source a file handle?
        je      sa_read_file            ; Yes, go read segment from file

; We are reading from preload buffer, bx == src seg address, di == len
        push    di                      ; No, set up for fast copy
        mov     OFF_prleinfo,di
        mov     SEG_prleinfo,bx
        pop     cx

        mov     ds,bx
ifdef WOW_x86 ;
.386
;; For WOW on NT we don't want to set the selector unesssarily
        cCall   get_physical_address,<pseg>
        shl     edx,16
        mov     dx,ax
        mov     rover_2,edx

        mov     ax,FLAT_SEL
        mov     es,ax

        mov     edi,edx                 ; es:edi -> pseg:0
        xor     esi,esi

        cmp     cx, 1                   ; set carry if 0 for big/huge segs
        mov     ax, cx
        rcr     cx, 1
        shr     cx, 1
        movzx   ecx,cx
        rep     movs dword ptr [edi], dword ptr [esi]
        mov     cx, ax
        and     cx, 3
        rep     movs byte ptr [edi], dword ptr [esi]

        sub     edi,edx                 ; make di correct for rest of code
else
        mov     es,pseg                 ; Writing to pseg
        call    get_rover_2
        xor     si,si
        xor     di,di

        ; need to handle case where seg size is 64K (cx == 0)
        cmp     cx, 1                   ; set carry if 0 for big/huge segs
.386
        mov     ax, cx
        rcr     cx, 1
        shr     cx, 1
        rep     movsd
        mov     cx, ax
        and     cx, 3
        rep     movsb
.286
endif; WOW_x86


        ; we have now read 'cbseg' bytes from preload buffer, di == cbseg
        jmp     sa_zero_fill_rest
           
saerr1:
        xor     ax,ax
        jmp     sax

sa_read_file:
        ; read segment contents from disk file, bx == file handle
        ; ax = disk file sector

if 0    ;KDEBUG
        push    ax
        push    ds
        SetKernelDS

        cmp     fPreloadSeg, 0
        jne     SHORT SkipDebugTrace

        mov     ax, segno
        krDebugOut      <DEB_TRACE or DEB_krLoadSeg>, "%ES0: reading segment #ax"
SkipDebugTrace:
        pop     ds
        UnSetKernelDS
        pop     ax
endif

; Get offset to data portion of segment in DX:AX
        mov     ax, es:[si].ns_sector
        xor     dx,dx
        mov     cx,es:[ne_align]
sa4a:
        shl     ax,1
        adc     dx, dx
        loop    sa4a                    ; DX:AX = file offset to segment

        mov     cx,dx                   ; Seek to beginning of segment data
        mov     dx,ax
        mov     ax,4200h                ; lseek(bx, sector << align, SEEK_SET)
        DOSCALL
        jc      saerr
        mov     cx,di                   ; Get #bytes to read
        test    es:[si].ns_flags,NSRELOC
        jz      no_read_extra_word
        add     cx, 2                   ; Relocation word
no_read_extra_word:
        mov     ds,pseg                 ; Read segment from file
        xor     dx,dx
        mov     ah,3Fh
        test    es:[si].ns_flags,NSITER
        jz      @F
        call    iterated_data_seg
        jmps    sa_iter_done
@@:
        or      cx, cx                  ; if cx == 0 at this point, it is 64K
        jnz     not_huge_read

        cmp     es:[si].ns_minalloc,0   ; If minalloc isn't zero too, then the
        jnz     not_huge_read           ; segment is too small.  Case should't
                                        ; happen but does for dbwindow, mimic Win 3.0.

        mov     cx, 8000h
        DOSCALL                         ; read first 32K from disk
        jc      saerr
        add     dx, cx                  ; update destination address
        mov     ah, 3fh                 ; restore AX (doscall trashes it)
        DOSCALL                         ; read second 32K
        jc      saerr
        cmp     ax, cx
        jnz     saerr
        jmp     short sa_zero_fill_rest

not_huge_read:
        DOSCALL
sa_iter_done:
        jc      saerr                   ; Continue if no errors
        cmp     ax,cx                   ; Read ok, did we get what we asked for?
        jne     saerr                   ; No, fail
        test    es:[si].ns_flags,NSRELOC        ; Relocation records?
        jz      sa_zero_fill_rest       ; No, continue
        mov     ax, ds:[di]             ; Extra word was read here
        mov     OFF_prleinfo, ax
        jmps    sa_zero_fill_rest
saerr:
        pop     ds
        pop     si
        pop     es
        mov     ax, -1                  ; File error
        jmp     sax

sa_zero_fill_rest:                      ; di == bytes written so far
        GETSEGLEN       pseg            ; seg len to ax, 0 == 64K

        sub     ax,di                   ; Any uninitialized portion?
        jz      sa_after_read           ; No, continue
ifdef WOW_x86;
.386
;; WOW we don't want to call NT to set the selector
        push    ax
        cCall   get_physical_address,<psegdest>
        shl     edx,16
        mov     dx,ax
        mov     ax,FLAT_SEL
        mov     es,ax

        and     edi,0000ffffh
        add     edi,edx                 ; es:edi -> pseg:0
        pop     cx

        push    edx

    xor eax,eax
        cld
        mov     dx,cx
        shr     cx, 2
        movzx   ecx,cx
        rep     stos dword ptr [edi]
        mov     cx, dx
        and     cx, 3
        rep     stos byte ptr [edi]

        pop     edx
        sub     edi,edx

else
        mov     es,psegdest             ; Yes, set it to zero
        call    get_rover_2
        mov     cx,ax
        xor     ax,ax
        cld
        shr     cx, 1
        rep     stosw
        adc     cx, cx
        rep     stosb
endif

sa_after_read:
        les     si, pseginfo

if LDCHKSUM
        mov     ds,psegdest
        xor     si,si
        mov     cx,di
        shr     cx,1
        xor     dx,dx
        cld
sa5b:
        lodsw
        xor     dx,ax
        loop    sa5b
endif
        cmp     pleaseNoLock, 0
        jnz     dont_patch
        push    dx
        cCall   <far ptr PatchCodeHandle>,<hseg>
        pop     dx
dont_patch:
        pop     ds                      ; Restore DS
        pop     si                      ; segment info pointer
        pop     es
        mov     ax,es:[si].ns_flags     ; Are we loading a code segment?
        and     ax,NSDATA
        .errnz  NSCODE
        jnz     sa9

; Here when loading a code segment

if LDCHKSUM
        mov     cx,segno
        dec     cx
        shl     cx,1
        shl     cx,1
        mov     di,es:[ne_psegcsum]
        add     di,cx
        mov     cx,dx
        xchg    es:[di],cx
        jcxz    sa6a0
        cmp     cx,dx
        je      sa6a0
        dec     retry
        jl      sa6a1
        public  badsegread
badsegread:
        mov     ah,0Dh                  ; Disk Reset
        DOSCALL
        jmp     sareread
sa6a1:
        krDebugOut DEB_ERROR, "Segment contents invalid %es2"
        xor     ax,ax
        jmps    sax
sa6a0:
        mov     word ptr es:[di+2],0
endif

sa9:
        mov     dx,SEG_prleinfo
        mov     cx,OFF_prleinfo
        mov     bx,hseg
        mov     ax,pseg
sax:    or      ax,ax
cEnd



.286

;-----------------------------------------------------------------------;
; iterated_data_seg
;
; This expands out iterated data segments (specifically for the
; OS/2 m.exe).  Due to the late date this is being sleazed in
; instead of being done right.  To be done right, the read would
; go into the last part of the present block, and expanded in place,
; the stack used for the next record count because the last record
; never fits.
;
; Entry:
;       CX    = number of bytes to read
;       DS:DX = place to put them
;       DS:DI = place where #relocs will magically appear
;       ES:SI = module exe header:seg info
;
; Returns:
;       CF = 1
;       DS:DI = updated magic place where #relocs will magically appear
;
; Error Return:
;       CX = 0
;
; Registers Destroyed:
;
; History:
;  Sun 28-Jan-1990 12:25:02  -by-  David N. Weise  [davidw]
; Wrote it!
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   iterated_data_seg,<PUBLIC,NEAR>,<bx,dx,si,ds,es>

        localW  temp_buf
        localW  freloc
cBegin

; deal with that extra relocation word!

        xor     ax,ax
        test    es:[si].ns_flags,NSRELOC ; Relocation records?
        jz      @F
        inc     ax
@@:     mov     freloc,ax

; first get a temp buffer

        push    bx
        push    cx
        cCall   IGlobalAlloc,<0,0,cx>
        mov     temp_buf,ax
        pop     cx
        pop     bx
        or      ax,ax
        stc                             ; assume failure
        jz      ids_exit
        push    dx
        push    ds

; read into the temp buffer

        mov     ds,ax
        xor     dx,dx
        mov     ah,3Fh
        DOSCALL
        pop     ds
        pop     dx
        jc      ids_exit1
        cmp     ax,cx
        jnz     ids_exit1

; expand the buffer, yes we should special case strings of length 1

        cmp     freloc,0                ; was an extra word read?
        jz      @F
        sub     cx,2
@@:     mov     dx,cx
        smov    es,ds
        xor     di,di
        mov     ds,temp_buf
        xor     si,si
        cld
ids_next_group:
        lodsw                           ; get the # interations
        mov     cx,ax
        lodsw                           ; get the # bytes
@@:     push    cx
        push    si
        mov     cx,ax
        rep     movsb
        pop     si
        pop     cx
        loop    @B
        add     si,ax                   ; get past group
        cmp     si,dx
        jb      ids_next_group

; data segment now processed, deal with reloc word

        cmp     freloc,0                ; was an extra word read?
        jz      @F
        movsw
        sub     di,2
        add     dx,2
@@:     mov     ax,dx
        mov     cx,dx
        clc

ids_exit1:
        pushf                           ; preserve the carry flag
        push    ax
        push    cx
        smov    ds,0
        cCall   IGlobalFree,<temp_buf>
        pop     cx
        pop     ax
        popf

ids_exit:

cEnd


;-----------------------------------------------------------------------;
; PatchCodeHandle                                                       ;
;                                                                       ;
; Patches the prologs of the procedures in the given code segment.      ;
;                                                                       ;
; Arguments:                                                            ;
;       parmW   hseg                                                    ;
;                                                                       ;
; Returns:                                                              ;
;       AX = hseg                                                       ;
;       DX = pseg                                                       ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       DI,SI,DS                                                        ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;       BX,CX,ES                                                        ;
;                                                                       ;
; Calls:                                                                ;
;       MyLock                                                          ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Sun 17-Sep-1989 10:45:24  -by-  David N. Weise  [davidw]             ;
; Added support for symdeb to understand segments in himem.             ;
;                                                                       ;
;  Tue Oct 27, 1987 06:19:12p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.                                       ;
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing
cProc   PatchCodeHandle,<PUBLIC,FAR>,<si,di>
        parmW   hseg
        localW  pseg
        localW  hexe
        localW  segno
        localW  segoffset
ifdef WOW_x86
.386
        localD  rover_2
endif
cBegin
        SetKernelDS
        cCall   MyLock,<hseg>
        mov     pseg,ax                 ; Save physical addresss
        or      ax,ax                   ; All done if discarded
        jz      pcsDone1

        xor     si,si
        mov     segoffset, si

        push    ax
        cCall   GetOwner,<pseg>
        mov     es, ax
        pop     ax


        cmp     es:[si].ne_magic,NEMAGIC
if KDEBUG
        jz      good_boy
bad_boy:
        krDebugOut DEB_ERROR "PatchCodeHandle, owner not NewExe %es2"
        jmps    pcsDone1
good_boy:
endif
        jne     pcsDone1
        mov     hexe,es
        mov     cx,es:[si].ne_cseg      ; We need si to point to entry
        mov     si,es:[si].ne_segtab    ;  anyway so do it the slow way
pcsLoop:
        cmp     es:[si].ns_handle,dx    ; Scan table for handle
        je      pcsFound
        add     si,SIZE NEW_SEG1
        loop    pcsLoop
pcsDone1:
        jmp     pcsDone
pcsExit1:
        jmp     pcsExit
pcsFound:
        sub     cx,es:[ne_cseg]         ; Compute segment# from remainder
        neg     cx                      ; of loop count
        inc     cx                      ; 1-based segment#
        mov     segno,cx

        test    es:[si].ns_flags,NSDATA
        jnz     pcsExit1
        .errnz  NSCODE

        push    si
        mov     di,es:[ne_pautodata]
        or      di,di
        jz      sa6a
        cCall   MyLock,<es:[di].ns_handle>
        mov     di,ax
sa6a:                                   ; DI:0 points to data segment (or 0)
ifdef WOW_x86
;; For WOW we use the NT Magic data selector, since all 16 bit code is DATA
        cCall   get_physical_address,<pseg>
        assumes es,nothing
        shl     edx,16
        mov     dx,ax                   ; ES:EDX -> pseg:0
        mov     rover_2,edx

        mov     ax,FLAT_SEL
        mov     es,ax
else
        mov     es,pseg                 ; ES:0 points to code segment
        call    get_rover_2
endif
        mov     ds,hexe                 ; DS:SI points to entry table
        assumes ds,nothing
        mov     si,ds:[ne_enttab]
        cld

        or      di, di                  ; Anything to do?
        jz      sa6x
sa6b:
        lods    word ptr ds:[si]
        mov     dx, ax
        lods    word ptr ds:[si]
        sub     ax, dx                  ; Get # entries in this block
        or      ax,ax
        jz      sa6x                    ; Done if zero
        push    word ptr ds:[si]        ; Next block
        add     si, 2                   ; Skip Next
        mov     cx,ax

sa6c:
        mov     al,ds:[si].pentsegno    ; Get segment# from int instruction
        cmp     byte ptr segno,al       ; Does this moveable segment match ES?
        jne     sa6e                    ; No, advance to next entry

ifdef WOW_x86

        movzx   ebx, word ptr ds:[si].pentoffset ; Get entry point offset
        add     ebx,rover_2
        mov     al, ds:[si].pentflags   ; Get entry point flags

        cmp     byte ptr es:[ebx+2],90h  ; Yes, followed by nop?
        jne     sa6e                    ; No, can;t patch prolog then
        cmp     word ptr es:[ebx],0581Eh ; Is it a push ds, pop ax?
        jne     @F                      ; Yes, take care of prolog

        mov     word ptr es:[ebx],0D88Ch
        jmps    sa6d1
@@:
        cmp     word ptr es:[ebx],0D88Ch ; Is it a mov ax,ds?
        jne     sa6e                    ; No, can't patch prolog then
sa6d1:
        test    al,ENT_DATA             ; Valid prolog.  shared data?
        jnz     sa6d2                   ; Yes, patch mov ax,DGROUP into prolog
        test    byte ptr ds:[ne_flags],NEINST    ; No, multiple instances?
        jz      sa6e                    ; No, do nothing
        test    al,ENT_PUBLIC           ; Public entry point?
        jz      sa6e                    ; No, do nothing
        mov     word ptr es:[ebx],09090h ; Yes, set nop, nop in prolog
        jmps    sa6e
sa6d2:
        mov     byte ptr es:[ebx],0B8h   ; Set mov ax,
        mov     es:[ebx+1],di            ;            DGROUP

else ; NOT WOW_x86

        mov     bx, ds:[si].pentoffset  ; Get entry point offset
        mov     al, ds:[si].pentflags   ; Get entry point flags

        cmp     byte ptr es:[bx+2],90h  ; Yes, followed by nop?
        jne     sa6e                    ; No, can;t patch prolog then
        cmp     word ptr es:[bx],0581Eh ; Is it a push ds, pop ax?
        jne     @F                      ; Yes, take care of prolog

        mov     word ptr es:[bx],0D88Ch
        jmps    sa6d1
@@:
        cmp     word ptr es:[bx],0D88Ch ; Is it a mov ax,ds?
        jne     sa6e                    ; No, can't patch prolog then
sa6d1:
        test    al,ENT_DATA             ; Valid prolog.  shared data?
        jnz     sa6d2                   ; Yes, patch mov ax,DGROUP into prolog
        test    byte ptr ds:[ne_flags],NEINST    ; No, multiple instances?
        jz      sa6e                    ; No, do nothing
        test    al,ENT_PUBLIC           ; Public entry point?
        jz      sa6e                    ; No, do nothing
        mov     word ptr es:[bx],09090h ; Yes, set nop, nop in prolog
        jmps    sa6e
sa6d2:
        mov     byte ptr es:[bx],0B8h   ; Set mov ax,
        mov     es:[bx+1],di            ;            DGROUP
endif; WOW_x86
sa6e:
        add     si,SIZE PENT            ; Advance to next entry in
        loop    sa6c                    ; this block
        pop     si
        or      si, si
        jnz     sa6b
sa6x:
        mov     es,hexe
        pop     si
pcsExit:
        or      byte ptr es:[si].ns_flags,NSLOADED  ; Mark segment as loaded


;;;if SDEBUG                            ; Tell debugger about new segment
;;;     mov     bx,es:[ne_restab]
;;;     inc     bx
;;;     mov     dx,es:[si].ns_flags
;;;     mov     ax,segoffset            ; tell symdeb how to fixup symbols
;;;     test    dx,NSDATA               ; test to pass NSKCACHED too
;;;     jz      sa8
;;;     test    byte ptr es:[ne_flags],NEINST
;;;     jz      sa8
;;;     mov     ax,es:[ne_usage]
;;;     dec     ax
;;;sa8:
;;;     mov     cx,segno
;;;     dec     cx
;;;     cCall   DebugDefineSegment,<esbx,cx,pseg,ax,dx>
;;;endif
pcsDone:
        mov     ax,hseg
        mov     dx,pseg
cEnd

sEnd    CODE

externFP FarAllocSeg
externFP FarMyAlloc
externFP FarMyAllocLinear
externFP FarMyFree
externFP FarSetOwner

sBegin  NRESCODE
assumes CS,NRESCODE
assumes DS,NOTHING
assumes ES,NOTHING

externNP MapDStoDATA

externA __AHINCR

;-----------------------------------------------------------------------;
; AllocAllSegs                                                          ;
;                                                                       ;
; "Allocates" for all segments of the module being loaded and stores    ;
; the addresses in the segment table.  By allocate we mean:             ;
;                                                                       ;
; AUTOMATIC DATA gets space, but not yet loaded,                        ;
; PRELOAD FIXED  get global mem allocated , but not yet loaded,         ;
; MOVEABLE  get a handle for later use,                                 ;
; FIXED  get nothing.                                                   ;
;                                                                       ;
; If this is not the first instance, then just allocate space for       ;
; the new instance of the automatic data segment.                       ;
;                                                                       ;
; Arguments:                                                            ;
;       parmW   hexe                                                    ;
;                                                                       ;
; Returns:                                                              ;
;                                                                       ;
; Error Returns:                                                        ;
;       AX =-1 not enough memory                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;                                                                       ;
; Calls:                                                                ;
;       FarAllocSeg                                                     ;
;       FarMyAlloc                                                      ;
;       FarMyFree                                                       ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Tue Feb 24, 1987 01:04:12p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.                                       ;
;-----------------------------------------------------------------------;

cProc   AllocAllSegs,<NEAR,PUBLIC>,<si,di,ds>
        parmW   hexe
        localW  cSegs
        localD  hugeLen                 ; cum length of huge segment
        localW  hugeIndex               ; index of first segment of huge
        localW  hugeOffs                ; offset of first segment desc of huge
        localW  hugeCnt                 ; segments making up huge seg
        localW  hugeFlags               ; flags of huge segment (needed?)

cBegin
        call    MapDStoDATA
        ReSetKernelDS
        mov     es,hexe
        mov     si,es:[ne_segtab]
        xor     di,di
        mov     cSegs,di
        inc     di
        cmp     es:[ne_usage],di
        je      paloop
        mov     si,es:[ne_pautodata]
        and     byte ptr es:[si].ns_flags,not NSALLOCED+NSLOADED
        mov     di,es:[si].ns_handle
        cCall   FarAllocSeg,<essi>
        or      ax,ax
        jz      aa_nomem
        inc     cSegs
outahere:
        jmp     pagood

aa_nomem:
        mov     es,hexe
        or      byte ptr es:[si].ns_flags,NSALLOCED+NSLOADED
        mov     es:[si].ns_handle,di
        jmp     pafail3

paloop:
        cmp     di,es:[ne_cseg]
        jbe     more_to_go
        jmp     pagood

more_to_go:

        mov     bx,es:[si].ns_flags
        test    bl,NSPRELOAD            ; Are we preloading?
        jz      not_preload
        test    bl,NSDATA               ; Preload data although moveable
        jnz     paalloc
        test    bl,NSMOVE               ; Fixed segment?
        jz      paalloc                 ; Yes, allocate segment
not_preload:

        test    bl,NSALLOCED            ; Already allocated?
        jnz     panext                  ; Yes, then nothing to do
        test    bl,NSMOVE               ; Fixed segment?
        jz      panext                  ; Yes, then nothing to do

        xor     cx,cx                   ; No, allocate zero length
        push    es                      ; object so that we guarantee
        cCall   FarMyAlloc,<bx,cx,cx>   ; we will have a handle.
        pop     es
        or      dx,dx                   ; Fail if we cant get a handle
        jz      pafail
        mov     es:[si].ns_handle,dx    ; Handle into seg table
        and     byte ptr es:[si].ns_flags,not NSLOADED
        or      byte ptr es:[si].ns_flags,NSALLOCED

        mov     bx,dx                   ; put handle into base register
        call    set_discarded_sel_owner
        jmps    panext

paalloc:

        cmp     es:[si].ns_minalloc, 0
        jnz     paalloc_fer_shure
        jmps    PAHugeAlloc

paalloc_fer_shure:
        cCall   FarAllocSeg,<essi>
        or      ax,ax
        jz      pafail
        inc     cSegs
panext:
        add     si,size NEW_SEG1
        inc     di
        jmp     paloop

; only gets here if not enough memory, free up all previous segments

pafail:
        mov     si,es:[ne_segtab]
        mov     cx,es:[ne_cseg]
pafail1:
        push    cx
        mov     cx,es:[si].ns_handle
        jcxz    pafail2
        push    es
                                ;Need to handle freeing huge segments!!!
        cCall   FarMyFree,<cx>
        pop     es
        mov     es:[si].ns_handle, 0    ; Necessary for EntProcAddress
pafail2:
        and     byte ptr es:[si].ns_flags,not (NSALLOCED+NSLOADED)
        add     si,size NEW_SEG1
        pop     cx
        loop    pafail1
pafail3:
        mov     cSegs,-1
        jmp     pagood

PAHugeAlloc:
        ; at this point, es:si -> current seg record
        ; di is segment index (range from 1 to es:[ne_cseg])
        mov     off_hugeLen, 0
        mov     seg_hugeLen, 0          ; init length to 0K

        mov     hugeOffs, si
        mov     hugeCnt, 1
        mov     ax, es:[si].ns_flags
        or      ax, NSHUGESEG
        mov     hugeFlags, ax
PAHugeLoop:
        mov     ax, es:[si].ns_minalloc ; add current segment to group
        cmp     ax, 1
        sbb     dx, dx
        neg     dx
        add     off_hugeLen, ax
        adc     seg_hugeLen, dx
        or      es:[si].ns_flags, NSHUGESEG

        cmp     es:[si].ns_minalloc, 0  ;
        jnz     PAHugeEndLoop

        cmp     di, es:[ne_cseg]
        jae     PAHugeEndLoop

        mov     ax, si
        add     ax, size NEW_SEG1
        cmp     ax, es:[ne_pautodata]
        jz      PAHugeEndLoop

        mov     ax, hugeFlags           ; do flags have to be identical?
        cmp     ax, es:[si].ns_flags
        jnz     PAHugeEndLoop

        inc     hugeCnt
        inc     di
        add     si, size NEW_SEG1
        jmp     PAHugeLoop

PAHugeEndLoop:
        inc     di
        push    es
        or      hugeFlags, NSMOVE
        cCall   FarMyAllocLinear, <hugeFlags, hugeLen>
        pop     es
        or      ax, ax                  ; check for error
        jnz     Not_pafail
        jmp     pafail
Not_pafail:

        mov     si, hugeOffs            ; fix up segment(s)
        and     es:[si].ns_flags, NOT NSHUGESEG
PAHugeSegLoop:
        mov     es:[si].ns_handle, dx
        and     byte ptr es:[si].ns_flags, not NSLOADED
        or      byte ptr es:[si].ns_flags, NSALLOCED
        cCall   FarSetOwner, <ax, es>
        add     si, size NEW_SEG1
        add     dx, __AHINCR
        dec     hugeCnt
        jnz     PAHugeSegLoop

        ; continue with rest of allocations

        jmp     paloop

pagood:
        mov     ax,cSegs
cEnd

sEnd    NRESCODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\ldreloc.asm ===
PAGE    ,132
        TITLE   LDRELOC - SegReloc procedure

.xlist
include gpfix.inc
include kernel.inc
include newexe.inc
include protect.inc
.list

;externFP FatalExit
externFP GlobalLock
externFP GlobalUnLock
externFP Int21Handler
externFP IFatalAppExit

DataBegin

externW f8087
externB fastFP
;externW WinFlags
ifndef WINDEBUG
externB szUndefDyn
endif
DataEnd

sBegin  CODE
assumes CS,CODE

externNP GetStringPtr
externNP FindOrdinal
externNP EntProcAddress
externNP LoadSegment
externNP GetOwner

externW  gdtdsc

externNP GetAccessWord
externNP DPMIProc

DPMICALL        MACRO   callno
        mov     ax, callno
        call    DPMIProc
        ENDM

ifdef WOW_x86
externNP get_physical_address
endif



;-----------------------------------------------------------------------;
; UndefDynlink
;
; If an application has a dynamic link to a loaded library that
; we can't find we fix up to this think.  This way the app
; will blow up only if it tries to call the entry point.
;
; Entry:
;
; Returns:
;
; Registers Destroyed:
;
; History:
;  Wed 10-May-1989 19:28:50  -by-  David N. Weise  [davidw]
; Added this nifty comment block!
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   UndefDynlink,<PUBLIC,FAR>,<ds>
        localW  foo                     ; force stack frame
cBegin
        SetKernelDS
if KDEBUG
        cCall   GetOwner,<[bp].savedCS>
        mov     es,[bp].savedCS
        mov     bx,[bp].savedIP
        sub     bx,5
        krDebugOut DEB_FERROR, "%AX1 #ES:#BX called undefined dynalink"
;       kerror  ERR_LDNAME,<Call to undefined dynlink entry point at >,es,bx
else
        push    0
        push    ds
        push    dataOffset szUndefDyn
        cCall   IFatalAppExit   ;,<0, ds, dataOffset szUndefDyn>
endif
cEnd


;-----------------------------------------------------------------------;
; SegReloc
;
;
; Entry:
;
; Returns:
;
; Registers Destroyed:
;
; History:
;  Thu 25-May-1989 20:16:09  -by-  David N. Weise  [davidw]
; Removed the special case code for version 1.01 (linker or windows?) that
; If BASE fixup for moveable code segment within a DATA segment (V1.01 only)
; Then force to be PTR fixup.
;
;  Wed 10-May-1989 19:28:50  -by-  David N. Weise  [davidw]
; Added this nifty comment block!
;-----------------------------------------------------------------------;

        assumes ds, nothing
        assumes es, nothing

ifdef WOW_x86
.386
cProc   SegReloc,<NEAR,PUBLIC>,<si,edi,ds>
else
cProc   SegReloc,<NEAR,PUBLIC>,<si,di,ds>
endif
        parmW   hexe
        parmD   prleinfo
        parmW   creloc
        parmD   pseginfo
        parmW   fdataseg
        parmW   fh
        localW  himpexe
        localW  hseg
        localW  pseg
        localW  hifileoff
        localW  lofileoff
        localV  rlerec,<SIZE NEW_RLC>
        localW  fOsfixup                ;bool set if a floating-pt osfixup.
        localW  old_access
ifdef WOW_x86
        localD  rover_2
endif
cBegin
        les     si, pseginfo
        mov     dx, es:[si].ns_handle   ; Get handle to segment
        mov     hseg, dx
        test    dl, GA_FIXED
        jnz     sr_nolock
        cCall   GlobalLock,<dx>
sr_nolock:

        mov     pseg, dx

;; WOW - refer to original win 3.1 code on \\pucus, there were too many ifdefs
;; in the code.   It would have become unreadable to add any more.   mattfe
;; mar 29 93
;;; Restored the "too many ifdef's" because this code doesn't just
;;; assemble right for all our platform permutations. I also tried to make it 
;;; readable by adding comments. -neilsa

;; For 386 version of WOW we use selector 23h to write to vdm memory without
;; worrying about setting up a selector.

ifndef WOW 
;------------------Original win31 source--------------------------------
.386p
        lar     eax, edx
        shr     eax, 8
.286
        mov     old_access, ax
        test    al, DSC_CODE_BIT
        jz      short access_ok
        mov     al, DSC_PRESENT+DSC_DATA
        mov     bx, dx

        push    ds
        mov     ds, gdtdsc
        and     bl, not 7
        mov     word ptr ds:[bx].dsc_access, ax
        pop     ds

else ; ******** WOW ADDED SOURCE

ifdef WOW_x86
;------------------WOW source for X86 platforms-------------------------

else; WOW_x86
;------------------WOW source for NON-X86 platforms---------------------
.386p
        lar     eax, edx
        shr     eax, 8
.286
        mov     old_access, ax
        test    al, DSC_CODE_BIT
        jz      short access_ok
        mov     al, DSC_PRESENT+DSC_DATA
        mov     bx, dx
        push    ds
        mov     ds, gdtdsc
        and     bl, not 7
        mov     word ptr ds:[bx].dsc_access, ax
        pop     ds
endif; WOW_x86
endif; ******** WOW ADDED SOURCE
;----------------------End of WOW changes-------------------------------

access_ok:

        mov     fOsfixup,0              ; set flag initially to false.
        mov     si,OFF_prleinfo
        mov     ax,SEG_prleinfo
        or      ax,ax
        jz      @F
        jmp     srloop1
@@:

        xor     dx,dx
        xor     cx,cx
        mov     bx,fh
        mov     ax,4201h
        DOSCALL                         ; Get current file offset
        jnc     @F
        krDebugOut <DEB_ERROR or DEB_krLoadSeg>, "Get file offset failed"
;       Debug_Out "Get file offset failed."
        jmps    srbadrle1
@@:
        mov     hifileoff,dx
        mov     lofileoff,ax
srloop:
        mov     ax,SEG_prleinfo
        or      ax,ax                   ; Did we get a handle to RLE?
        jnz     srloop1                 ; No, continue


        mov     cx,hifileoff            ; OPTIMIZE this to read in more
        mov     dx,lofileoff            ;  than one record at a time!!
        mov     bx,fh
        mov     ax,4200h
        DOSCALL                         ; Seek to current offset
        jnc     @F
        krDebugOut DEB_ERROR, "Seek failed."
;       Debug_Out "Seek failed."
srbadrle1:
        jmp     srbadrle
@@:
        push    ss
        pop     ds
        lea     dx,rlerec
        mov     cx,SIZE NEW_RLC
        add     lofileoff,cx
        adc     hifileoff,0
        mov     ah,3Fh
        DOSCALL                         ; Read next record
        jnc     @F
        krDebugOut DEB_ERROR, "Read record failed"
;       Debug_Out "Read record failed"
        jmps    srbadrle1
@@:
        cmp     ax,cx
        je      @F
        krDebugOut DEB_ERROR, "Read #AX bytes, expecting #CX."
        jmp     srbadrle

srosfijmp:
        jmp     srosfixup

@@:
        mov     ax,ss
        mov     si,dx

srloop1:
        mov     ds,ax
        mov     ax,ds:[si].nr_proc
        mov     cx,NRRTYP
        and     cl,ds:[si].nr_flags
        or      cx,cx
        jz      srint                   ; Internal Reference
        cmp     cl,OSFIXUP
        je      srosfijmp
        .errnz  NRRINT
        mov     bx,ds:[si].nr_mod       ; Here if Import Ordinal/Name
        sub     bx,1
        jnc     @F
        krDebugOut DEB_ERROR, "Zero import module."
        jmps    srbadrle
@@:
        shl     bx,1
        mov     es,hexe
        add     bx,es:[ne_modtab]
        mov     bx,es:[bx]
        mov     himpexe,bx
        or      bx,bx
        jz      srbadimp
        dec     cx                      ; (sleaze) if cx == 2, then Import Name
        jz      srrord                  ; else Import Ordinal
        .errnz  NRRORD - 1
        .errnz  NRRNAM - 2

srrnam:                                         ; Convert name to ordinal
        cCall   GetStringPtr,<hexe,fh,ax>
        cCall   FindOrdinal,<himpexe,dxax,fh>
        mov     bx,himpexe
        or      ax,ax
        jz      srbadimp
srrord:
if KDEBUG
        cCall   EntProcAddress,<bx,ax,0>; we do want to RIP for failure
else
        cCall   EntProcAddress,<bx,ax>
endif
        jcxz    srbadimp
        jmp     dorle

srbadimp:
if kdebug
        mov     dx, hExe
        mov     ax, himpexe
        krDebugOut <DEB_WARN or DEB_krLoadSeg>, "%dx1 failed implicit link to %ax0"
endif
        mov     dx,cs
        mov     ax,codeOFFSET UndefDynlink
        jmp     dorle

srbadrle:
        jmp     srfail

srdone1:
        jmp     srdone

srint:
        mov     dl,NRSTYP               ; DL = fixup type
        and     dl,ds:[si].nr_stype
        mov     cl,ds:[si].nr_segno
        or      cx,cx
        jnz     @F
        krDebugOut DEB_ERROR, "NULL segment in fixup."
        jmp     srbadrle
@@:
        mov     bx,hexe
        cmp     cl,ENT_MOVEABLE
        je      srrord
        mov     es,bx
        mov     bx,cx
        dec     bx
        cmp     es:[ne_cseg],bx
        jnbe    @F
        krDebugOut DEB_ERROR, "Invalid segment in fixup."
        jmp     srbadrle                ; Error if invalid segno
@@:
        push    ax                      ; Save offset
        shl     bx,1
        mov     ax,bx
        shl     bx,1
        shl     bx,1
        add     bx,ax                   ; BX *= 10
        .errnz  10 - SIZE NEW_SEG1
        add     bx,es:[ne_segtab]
        cmp     dl,NRSOFF               ; Offset only fixup?
        je      srint2                  ; Yes, go do it then (DX ignored then)
        test    byte ptr es:[bx].ns_flags, NSALLOCED
        jz      srint1
        mov     ax, es:[bx].ns_handle
        or      ax,ax
        jnz     @F
        krDebugOut DEB_ERROR, "NULL handle."
        jmp     srbadrle
@@:

        test    al,GA_FIXED
        jnz     srint2
        HtoS    ax
        mov     cx,ax                   ; for the jcxz below
        jmps    srint2

srbadrlej:
        jmp     srbadrle

srint1:
int 3
int 3
        cCall   LoadSegment,<es,cx,fh,fh>
srint2:
        mov     dx,ax
        pop     ax
        or      cx,cx
        jnz     @F
        krDebugOut DEB_ERROR, "Can't load segment."
        jmp     srbadrlej

@@:
dorle:
        push    ax
        push    dx
        mov     ax,SEG_prleinfo
        or      ax,ax                   ; Did we get a handle to RLE?
        jnz     @F                      ; No, continue
        mov     ax,ss                   ; Assume reading from stack
@@:
        mov     ds,ax
        mov     bl,NRSTYP
        and     bl,ds:[si].nr_stype
        mov     cx,NRADD
        and     cl,ds:[si].nr_flags
        mov     di,ds:[si].nr_soff

ifdef WOW_x86
.386
;; WOW selector optimiaztion
        cCall   get_physical_address,<pseg>
        shl     edx,16
        mov     dx,ax
        mov     rover_2,edx

        mov     ax,FLAT_SEL
        mov     ds,ax

        movzx   edi,di
        add     edi,edx                 ; es:edi -> pseg:0
else
        mov     ds, pseg
endif
        pop     dx
        pop     ax
        cmp     bl,NRSSEG
        je      srsseg
        cmp     bl,NRSPTR
        je      srsptr
        cmp     bl,NRSOFF
        je      srsoff
        cmp     bl,NRSBYTE
        je      srsbyte

        krDebugOut DEB_ERROR, "Unknown fixup #BX"
ife     KDEBUG
        jmps    nextrle
endif

nextrlenz:                              ; if NZ at this point, something broke
        jz      nextrle
;       jnz     srfail
        jmp     srfail

nextrle:
        mov     ax,1
        add     si,SIZE NEW_RLC
        dec     creloc
        jle     srdone2
        jmp     srloop

srdone2:jmp     srdone

; Lo-byte fixup chain (always additive)



beg_fault_trap  srfailGP
srsbyte:
ifdef WOW_x86
        add     ds:[edi],al
else
        add     ds:[di],al
endif
        jmp     nextrle

; Offset fixup chain
srsoff:
        cmp     fOsfixup,0              ; is it a floating-pt. osfixup?
        jnz     srsosfixup              ; yes, goto special case code.

        mov     dx, ax                  ; fall through into segment fixup

; Segment fixup chain
srsseg:
        jcxz    srsseg1
ifdef WOW_x86
        add     ds:[edi],dx
else
        add     ds:[di],dx
endif
        jmp     nextrle

srsseg1:
        or      cx, -1
srsseg2:
        mov     bx,dx
ifdef WOW_x86
        xchg    word ptr ds:[edi],bx
        movzx   edi,bx
        add     edi,rover_2
else
        xchg    ds:[di],bx
        mov     di,bx
endif
        inc     bx
        loopnz  srsseg2                 ; if CX == 0, we're broken
        jmp     nextrlenz

; Segment:Offset fixup chain
srsptr:
        jcxz    srsptr1
ifdef WOW_x86
        add     word ptr ds:[edi],ax
        add     word ptr ds:[edi+2],dx
else
        add     ds:[di],ax
        add     ds:[di+2],dx
endif
        jmp     nextrle

srsptr1:
        or      cx, -1
srsptr2:
        mov     bx,ax
ifdef WOW_x86
        xchg    word ptr ds:[edi],bx
        mov     word ptr ds:[edi+2],dx
        movzx   edi,bx
        add     edi,rover_2
else
        xchg    ds:[di],bx
        mov     ds:[di+2],dx
        mov     di,bx
endif
        inc     bx
        loopnz  srsptr2
        jmp     nextrlenz

; osfixup for floating-point instructions

fINT    EQU     0CDH
fFWAIT  EQU     09BH
fESCAPE EQU     0D8H
fFNOP   EQU     090H
fES     EQU     026H
fCS     EQU     02Eh
fSS     EQU     036h
fDS     EQU     03Eh
BEGINT  EQU     034h

FIARQQ  EQU     (fINT + 256*(BEGINT + 8)) - (fFWAIT + 256*fDS)
FISRQQ  EQU     (fINT + 256*(BEGINT + 8)) - (fFWAIT + 256*fSS)
FICRQQ  EQU     (fINT + 256*(BEGINT + 8)) - (fFWAIT + 256*fCS)
FIERQQ  EQU     (fINT + 256*(BEGINT + 8)) - (fFWAIT + 256*fES)
FIDRQQ  EQU     (fINT + 256*(BEGINT + 0)) - (fFWAIT + 256*fESCAPE)
FIWRQQ  EQU     (fINT + 256*(BEGINT + 9)) - (fFNOP  + 256*fFWAIT)
FJARQQ  EQU     256*(((0 shl 6) or (fESCAPE and 03Fh)) - fESCAPE)
FJSRQQ  EQU     256*(((1 shl 6) or (fESCAPE and 03Fh)) - fESCAPE)
FJCRQQ  EQU     256*(((2 shl 6) or (fESCAPE and 03Fh)) - fESCAPE)

osfixuptbl  label word                  ; table has 12 entries - six for int
        DW      FIARQQ, FJARQQ
        DW      FISRQQ, FJSRQQ
        DW      FICRQQ, FJCRQQ
        DW      FIERQQ, 0h
        DW      FIDRQQ, 0h
        DW      FIWRQQ, 0h
osfixuptbllen = $-osfixuptbl            ; six to convert FWAIT to NOP
        DW      fFNOP - fFWAIT, 0
        DW      fFNOP - fFWAIT, 0
        DW      fFNOP - fFWAIT, 0
        DW      fFNOP - fFWAIT, 0
        DW      fFNOP - fFWAIT, 0
        DW      FIWRQQ, 0h              ; leave this one in for emulator

srsosfixup:
ifdef WOW_x86
        add     word ptr ds:[edi][0],ax
        add     word ptr ds:[edi][1],dx
else
        add     ds:[di][0],ax
        add     ds:[di][1],dx
endif
        mov     fOsfixup,0              ; clear flag for next record.
        jmp     nextrle
end_fault_trap

srfailGP:
;       fault_fix_stack
        pop     ax
        pop     dx
        krDebugOut DEB_ERROR, "Fault in SegReloc #AX #DX"
srfail:
if KDEBUG
        mov     bx,hexe
;       xor     bx,bx
        krDebugOut DEB_ERROR, "%BX1 has invalid relocation record"
;       kerror  ERR_LDRELOC,<Invalid relocation record in >,es,bx
endif
        xor     ax,ax
        jmps    srdone


; OSFIXUPs for floating-point instructions.
;
; The fixup is applied by adding the first word (ax) to the
; coprocessor intruction, and for fixups 1-3 also adding the
; second word (dx) to the instruction+1. Generalize, by having
; dx=0 for fixups 4-6 and always adding dx to instruction+1.
;
; Note: the relocation type is marked NRSOFF by the linker,
; but we must apply these fixups differently.  Here we know
; it is an osfixup, so set the flag fOsfixup so that later
; when we test the type, we can apply the fixup correctly.
;
; 06-Oct-1987. davidhab.

; Wed 10-May-1989 19:28:50  -by-  David N. Weise  [davidw]
;
; Actually, due to the way the emulator does fwait polling
; of exceptions we must send the NOP FWAIT pairs to the
; emulator even if a math coprocessor is available.

srosfixup:
        mov     es,hexe
        test    es:[ne_flags],NEPROT    ; OS/2 app
        jnz     srosf_skip              ;  then never fix up!
        SetKernelDS     es
        mov     bx,ds:[si].nr_mod       ; get OSFIXUP id
        cmp     bx,6                    ; is it NOP, FWAIT?
        jz      srosfixup1              ;  if so always fix up!
        cmp     f8087,94                ; 8087 installed?
        jnz     srosfixup1              ; No, do OSFIXUP processing
        cmp     fastFP,0
        je      srosf_skip
        dec     bx
        shl     bx, 2
        cmp     bx, osfixuptbllen
        jae     srosfixup2
        add     bx, osfixuptbllen
        jmps    fast


srosf_skip:
        jmp     nextrle                 ; Yes, skip OSFIXUP processing

srosfixup1:
        dec     bx                      ; offset into table is (n-1) * 4
        shl     bx,1
        shl     bx,1
        cmp     bx,osfixuptbllen        ; Make sure it is within table bounds
        jae     srosfixup2              ; No, bad relocation
fast:   mov     ax,osfixuptbl[bx+0]     ; Yes, get relocation value from table
        mov     dx,osfixuptbl[bx+2]     ; get second part of fixup
        mov     fOsfixup,1              ; set flag to mark our special type.
        jmp     dorle                   ; Go apply relocation

srosfixup2:
        jmp     srbadrle
        UnSetKernelDS   es

srdone:
        push    ax

ifndef WOW 
;------------------Original win31 source--------------------------------
        mov     cx, old_access
        test    cl, DSC_CODE_BIT
        jz      short no_reset_access
        mov     bx, pseg

        push    ds
        mov     ds, gdtdsc
        and     bl, not 7
        mov     word ptr ds:[bx].dsc_access, cx
        pop     ds

else ; ******** WOW ADDED SOURCE

ifdef WOW_x86
;------------------WOW source for X86 platforms-------------------------

else; WOW_x86
;------------------WOW source for NON-X86 platforms---------------------
        mov     cx, old_access
        test    cl, DSC_CODE_BIT
        jz      short no_reset_access
        mov     bx, pseg

        push    ds
        mov     ds, gdtdsc
        and     bl, not 7
        mov     word ptr ds:[bx].dsc_access, cx
        pop     ds

endif; WOW_x86
endif; ******** WOW ADDED SOURCE
;----------------------End of WOW changes-------------------------------

no_reset_access:
        mov     ax, hseg
        test    al, 1
        jnz     srdone_nounlock
        cCall   GlobalUnLock,<ax>
srdone_nounlock:
        pop     ax
cEnd


sEnd    CODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\ldutil.asm ===
TITLE	LDUTIL - Loader support procedures

.xlist
include kernel.inc
include newexe.inc
include tdb.inc
include protect.inc
.list

;externFP GetCurrentPDB

DataBegin

;externB Kernel_Flags
;externW AltfEEMS
externW headTDB
externW hExeHead
;externW pGlobalHeap
;externW MyCSDS
externW topPDB
externW cur_dos_pdb
externW Win_PDB
externW curTDB
;externW segSwapArea

DataEnd

externFP CallWEP

sBegin	CODE
assumes CS,CODE
assumes DS,NOTHING
assumes ES,NOTHING

externNP MyUpper
externNP MyLock
externNP LoadNRTable
externNP LoadSegment
externNP GetOwner
externNP GetCachedFileHandle

if SDEBUG
externNP DebugFreeSegment
endif

externFP IGlobalAlloc
externFP IGlobalFree
;externFP IGlobalLock
externFP IGlobalUnfix
externFP IGlobalHandle
externFP GlobalFlags
externFP FreeNRTable
externFP Int21Handler

ifdef	FE_SB			;declare it.
externNP MyIsDBCSLeadByte	;Use near one as we are in the same seg
endif

cProc	SafeCall,<PUBLIC,FAR>
	parmD	Addr
cBegin
	call	Addr
cEnd

;-----------------------------------------------------------------------;
; GetExePtr								;
; 									;
; Returns the exe header pointer for the passed handle.			;
; 									;
; Arguments:								;
;	parmW   hinstance						;
; 									;
; Returns:								;
; 									;
; Error Returns:							;
;	AX = 0								;
;									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Mon Aug 03, 1987 04:40:45p  -by-  David N. Weise   [davidw]          ;
; Rewrote it to work with expanded memory.  Note that if the handle	;
; passed is truly bogus we could still catch a page fault under		;
; Win386.								;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

cProc	GetExePtr,<PUBLIC,FAR>
	parmW   hinstance
cBegin
	mov	ax,hinstance
	test	ax,GA_FIXED		; Passed a segment address?
	jz	not_module
	mov	es,ax
	cmp	es:[ne_magic],NEMAGIC	;  Yes, does it point to a Module?
	jz	gxdone

not_module:
	SetKernelDS	es
	mov	cx,headTDB
	assumes	es, nothing
find_TDB:
	jcxz	last_chance
	mov	es,cx
	cmp	ax,es:[TDB_module]
	jz	found_it
	mov	cx,es:[TDB_next]
	jmp	find_TDB
found_it:
	mov	ax,es:[TDB_pModule]
	jmps	gxdone

last_chance:				; The problem here is that USER
	cCall	MyLock,<ax>		;  KNOWS that hinstance is but
	or	ax,ax			;  the handle to his data segment.
	jz	gxdone
	mov	es,ax
	cmp	es:[ne_magic],NEMAGIC
	je	gxdone

	cCall	GetOwner,<ax>
	or	ax,ax
	jz	gxfail
	mov	es,ax
	cmp	es:[ne_magic],NEMAGIC
	je	gxdone

	; The owner,ax, is now a PDB. We gotta find the TDB
	SetKernelDS	es
	mov	cx,headTDB
	assumes	es, nothing
find_PDB:
	jcxz	gxfail
	mov	es,cx
	cmp	ax,es:[TDB_PDB]
	jz	found_PDB
	mov	cx,es:[TDB_next]
	jmp	find_PDB
found_PDB:
	mov	ax,es:[TDB_pModule]
	jmps	gxdone


gxfail:
if KDEBUG
	xor	cx,cx
	kerror	ERR_LDMODULE,<Invalid module handle>,cx,hinstance
endif
	xor	ax,ax
gxdone:	mov	cx,ax

cEnd

;-----------------------------------------------------------------------;
;									;
;  GetExpWinVer - return the expected Windows version for a given	;
;		  module handle						;
;									;
; Arguments:								;
;	parmW   hinstance						;
; 									;
; Returns:								;
;	AX = expected windows version					;
;	DX = BOOL proportional font flag				;
;									;
; Error Returns:							;
;	AX = 0								;
;									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
; Fri 06 Jan 1989  -- Written by Sankar.				;
;									;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

cProc	GetExpWinVer,<PUBLIC,FAR>, <si,di>
	parmW   hInstance
cBegin	
	cCall	GetExePtr,<hInstance>
	or	ax,ax
	jz	err_GetExpWinVer
	mov	es,ax
	mov	ax,es:[ne_expver]
	mov	dx,es:[ne_flags]
	and	dx,NEWINPROT
; error if offsets don't match our defines - In which case find the right
; offsets and changes the defines in mvdm\inc\tdb16.h

.erre (NE_LOWINVER_OFFSET EQ ne_expver)
.erre (NE_HIWINVER_OFFSET EQ ne_flags)

err_GetExpWinVer:

cEnd	


;-----------------------------------------------------------------------;
; MyAlloc								;
;									;
; Private interface to memory manager                                   ;
; 									;
; Arguments:								;
;	parmW   aflags							;
;	parmW   nsize							;
;	parmW   nelem							;
; 									;
; Returns:								;
; 									;
; Error Returns:							;
;	AX = Handle							;
;	DX = Seg Address						;
; 									;
; Registers Preserved:							;
;	DI,SI,DS							;
; 									;
; Registers Destroyed:							;
;	BX,CX,ES							;
; 									;
; Calls:								;
;	GlobalAlloc							;
;	MyLock								;
; 									;
; History:								;
; 									;
;  Wed Apr 08, 1987 06:22:57a  -by-  David N. Weise   [davidw]          ;
; Wrote it.								;
;-----------------------------------------------------------------------;
	assumes	ds, nothing
	assumes	es, nothing


cProc	MyAllocLinear,<PUBLIC,NEAR>
	; Same as MyAlloc, except for size parameter
	parmW   aflags
	parmD   dwBytes
cBegin
	jmps	MyAllocNBD
cEnd


	assumes	ds, nothing
	assumes	es, nothing

cProc	MyAlloc,<PUBLIC,NEAR>
	parmW   aflags
	parmD	dwBytes
;	parmW   nsize
;	parmW   nelem
cBegin
	xor	dx,dx
	mov	ax,seg_dwBytes	;nsize
	mov	cx,off_dwBytes	;nelem
	jcxz	ma3
ma2:
	shl	ax,1
	rcl	dx,1
	loop	ma2
ma3:
	mov	seg_dwBytes, dx
	mov	off_dwBytes, ax
MyAllocNBD:
	SetKernelDS	es
	mov	cx,aflags
	mov	al,NSTYPE
	and	al,cl			; al has SEGTYPE
	mov	bx,NSDISCARD
	and	bx,cx
	jz	@F
	shr	bx,1
	shr	bx,1
	shr	bx,1
	shr	bx,1			; BX has GA_DISCARDABLE
	cmp	al,NSCODE
	jne	@F
	or	bl,GA_DISCCODE		; Allocating discardable code
@@:

	cmp	al,NSDATA
	jne	@F
	and	cx,NOT NSWINCODE	; undo Excel bogusness
	or	bl,GA_DGROUP		; Allocating automatic data segment
@@:

	test	cl,NSMOVE
	jz	@F
	or	bl,GA_MOVEABLE
@@:

	cmp	al,NSTYPE
	jz	@F
	or	bh,GA_CODE_DATA
@@:

	cCall	IGlobalAlloc,<bx,dwBytes>	 ;dxax>

	assumes	es, nothing
	push	ax
	test	al,GA_FIXED
	jnz	@F
	cCall	MyLock,<ax>
@@:
	pop	dx
cEnd


;
; MyLock( hseg ) - Procedure to return the physical segment address of
; the passed handle.
;
;;;cProc	MyLock,<PUBLIC,NEAR>
;;;	parmW   hseg
;;;cBegin
;;;	cCall	IGlobalHandle,<hseg>
;;;	xchg	dx,ax
;;;cEnd


;-----------------------------------------------------------------------;
; MyFree								;
; 									;
; Frees a segment allocated by MyAlloc.					;
; 									;
; Arguments:								;
; 									;
; Returns:								;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Tue Dec 09, 1986 12:48:43p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

cProc	MyFree,<PUBLIC,NEAR>
	parmW   hseg
	localW  pseg
cBegin
	mov	bx,hseg
	or	bx,bx
	jz	mf3
	mov	ax,bx
	xor	cx,cx
	test	bl,GA_FIXED
	jnz	mf0a

	push	bx
	cCall	GlobalFlags,<bx>
	mov	cx, ax
	xor	ax, ax
	pop	bx
	xchg	ch, cl
	test	cl, HE_DISCARDED
	jnz	mf0a
	mov	ax, bx
	HtoS	ax

mf0a:
if KDEBUG
	push	cx
endif
	mov	pseg,ax
	or	ax,ax
	jz	mf1
mf0:
if SDEBUG
	cCall	DebugFreeSegment,<pseg,0>
endif
mf1:
if KDEBUG
	pop	cx
	or	ch,ch
	jz	mf2
mf1a:
	push	cx
	cCall	IGlobalUnfix,<hseg>	 ; Prevent RIP if freeing locked DS
	pop	cx
	dec	ch
	or	ch,ch			; If still lock, do it again
	jnz	mf1a
endif
mf2:
	cCall	IGlobalFree,<hseg>
mf3:
cEnd

;-----------------------------------------------------------------------;
; EntProcAddress
;
; Returns the fixed address of a procedure.
;
; Entry:
;
; Returns:
;	DX:AX = thunk for moveable
;	DX:AX = procedure for fixed
;	AX = constant, ES:BX => constant for absolutes
; Registers Destroyed:
;
; History:
;  Wed 30-Nov-1988 19:39:05  -by-  David N. Weise  [davidw]
;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

cProc	EntProcAddress,<PUBLIC,NEAR>,<si,di>
	parmW	hExe
	parmW	entno
if KDEBUG
	parmW	bNoRip		; if 1 don't RIP for error, 0 -> do the RIP
endif

cBegin
	mov	es,hExe
	mov	cx,entno
	and	cx,7fffh		; clear ResidentName bit (#5108 donc)
	jcxz	entfail
	dec	cx
	mov	si,es:[ne_enttab]

entloop:
	mov	ax, es:[si.PM_entstart]
	cmp	cx, ax			; Below this block?
	jb	entfail			;   yes, must be invalid!
	cmp	cx, es:[si.PM_entend]	; Above this block?
	jae	entnext			;  yes, go to next block
	sub	cx, ax			; Found the right block, get offset
	mov	bx, cx
	shl	cx, 1
	add	bx, cx
	add	bx, cx			; bx = cx*5
	lea	si, [si+bx+size PM_entstruc]
	mov	bx, si
	jmps	gotent
entnext:
	mov	si, es:[si.PM_entnext]	; Next block
	or	si, si
	jnz	entloop
	jmps	entfail

entfail:
if KDEBUG
	cmp	bNoRip,0
	jnz	dont_rip_here
	mov	bx,entno
	krDebugOut <DEB_WARN or DEB_krLoadSeg>, "Invalid ordinal reference (##BX) to %ES1"
;	kerror	ERR_LDORD,<Invalid ordinal reference to >,es,bx
dont_rip_here:
endif
	xor	dx,dx
	xor	ax,ax
	jmps	entdone

; Here if the current block has the entry we want

gotabs:
	add	bx,pentoffset		; make ES:BX point to constant (SLIME!)
	mov	dx,-1			; make != 0 since abs might be!
	jmps	gotent1			; Offset is symbol value

gotent:
	xor	ax, ax
	mov	al, es:[bx].penttype 	; Get segno/type field
	mov	si,es:[bx].pentoffset
	cmp	al,ENT_ABSSEG		; If segno field absoulute segment
	je	gotabs			; Yes, have absolute symbol

	cmp	al, ENT_MOVEABLE
	je	gotmoveable

	.errnz	10 - SIZE NEW_SEG1
	; ax = segno
	push	bx
	mov	bx, es:[ne_segtab]	; see if really fixed
	mov	cx, ax			; look up in seg table
	dec	cx
	shl	cx, 1			; get segtable + (segno-1)*10
	add	bx, cx
	shl	cx, 2
	add	bx, cx
	test	es:[bx].ns_flags, NSMOVE + NSALLOCED
	pop	bx
	jnz	gotmoveable

	mov	cx,-1			; Fixed, make sure it's loaded
	cCall	LoadSegment,<es,ax,cx,cx>
	or	ax,ax
	mov	dx,ax
	jnz	gotent1
	jmp	entfail

gotmoveable:
	xor	ax,ax
	mov	al,es:[bx].pentsegno	; Segment number
	dec	ax
	shl	ax,1
	mov	di,ax
	shl	ax,2
	add	di,ax
	.errnz	10 - SIZE NEW_SEG1
	add	di,es:[ne_segtab]

	mov	dx,es:[di].ns_handle
	or	dx, dx
	jnz	ok
	mov	ax, dx			; No handle, probably from an aborted
	jmps	entdone			; LoadModule - just return 0:0
ok:

	Handle_To_Sel	dl

gotent1:
	mov	ax,si

entdone:
	mov	cx,ax
	or	cx,dx
cEnd


;-----------------------------------------------------------------------;
; FindOrdinal								;
; 									;
; Searches the resident and non-resident name tables for a procedure	;
; name and return its corresponding entry ordinal.			;
; 									;
; Arguments:								;
;	parmW   hExe							;
;	parmD	lpname	pointer name, strings starts with length	;
;	parmW	fh	file handle NOT to be discarded from cache	;
; 									;
; Returns:								;
;	AX = ordinal number						;
;									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
;	MyUpper								;
;	LoadNRTable							;
;	FreeNRTable							;
; 									;
; History:								;
; 									;
;  Tue 09-May-1989 18:38:04  -by-  David N. Weise  [davidw]		;
; Added the batching if out of memory.					;
;									;
;  Thu Sep 17, 1987 08:55:05p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block and fixed it.				;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

CLNRBUFFER	equ	150

cProc	FindOrdinal,<PUBLIC,NEAR>,<si,di>
	parmW   hExe
	parmD	lpname
	parmW	fh

	localD	oNRTable		; if batching, continue here
	localV	LoadNRbuffer,CLNRBUFFER ; if batching this is temp buffer
cBegin
	xor	ax,ax
	mov	oNRTable.hi,ax
	mov	oNRTable.lo,ax
	les	si,lpname
	cmp	byte ptr es:[si+1],'#'
	je	foint

fonorm:	push	ds
	mov	ds,hExe
	mov	si,ds:[ne_restab]
	cld

foinit:	xor	ax,ax			; Skip module name or description
	lodsb
	add	si,ax
	inc	si
	inc	si

foloop: lodsb				; get length of entry
	les	di,lpname
	mov	cx,ax
	jcxz	fodone			; no more entries?
	cmp	es:[di],al		; do lengths match?
	jne	noteq
	inc	di
fo_find:
	mov	al,es:[di]
	call	MyUpper
	mov	bl,ds:[si]
	inc	si
	inc	di
	cmp	al,bl
	jne	noteq1
	loop	fo_find
;	repe	cmpsb
;	jne	noteq
	lodsw				; get ordinal number!
	mov	bx,ds
	pop	ds
	cmp	hExe,bx 		; did we load the nrtable?
	jnz	foexit_j
	jmp	foexit1
foexit_j:
	jmp	foexit

noteq1:	dec	cx
noteq:	add	si,cx
	inc	si
	inc	si
	jmps	foloop

; Here if pName points to string of the form:  #nnnn

foint:	lods	byte ptr es:[si]	; nbytes = *pName++
	mov	cl,al
	xor	ch,ch

	dec	cx			; ignore #
	inc	si

	xor	ax,ax			; sum = 0
foint0:	mov	dx,ax
	lods	byte ptr es:[si]	; c = *pName++
	sub	al,'0'			; if (!isdigit(c))
	cmp	al,9
	ja	fonorm			;	treat like normal
	xor	ah,ah
	mov	bx,ax			; sum = (sum * 10) + (c - '0')
	mov	al,10
	mul	dx
	add	ax,bx
	loop	foint0
	jmp	foexit1

fodone:	mov	bx,ds
	pop	ds
;%out help me				; what was this line for?
	mov	cx,oNRTable.hi
	cmp	cx,oNRTable.lo
	jnz	fo_batching
	cmp	hExe,bx 		; have we looked at NRTable yet?
	jne	foexit

fo_batching:
	xor	bx,bx
	mov	ax,fh
;;;	cmp	ax,-1
;;;	jz	no_file_handle

	SetKernelDS	ES
;;;	mov	dx, topPDB
;;;	mov	es, curTDB
;;;	UnSetKernelDS	es
;;;	mov	ax, es:[TDB_PDB]
;;;
;;;	cmp	dx, cur_dos_pdb
;;;	jz	@F
;;;	mov	bx,ax
;;;@@:
	mov	bx, Win_PDB
	UnSetKernelDS

	mov	dx, -1
	cCall	GetCachedFileHandle,<hexe,ax,dx>
no_file_handle:
	push	bx
	lea	cx,LoadNRbuffer
	mov	dx,CLNRBUFFER
	cCall	LoadNRTable,<hexe,ax,oNRTable,ss,cx,dx>
if KDEBUG
	push	es
	push	di
	les	di, [lpName]
	krDebugOut	<DEB_TRACE or DEB_krLoadSeg>, "    looking for @ES:DI"
	pop	di
	pop	es
endif
	pop	si
	or	si,si
	jz	@F
;;;	push	ax
;;;	push	bx
;;;	mov	bx,si
;;;	mov	ah,50h
;;;	DOSCALL
;;;	pop	bx
;;;	pop	ax
	push	es
	SetKernelDS	ES
	mov	Win_PDB, si
	pop	es
	UnSetKernelDS	ES
@@:	mov	oNRTable.hi,cx
	mov	oNRTable.lo,bx
	push	ds
	mov	ds,dx
	mov	si,ax
	or	ax,dx			; did we get a table?
	jz	@F
	xor	ax,ax
	jmp	foloop
@@:	pop	ds
foexit: push	ax
	mov	ax,ne_nrestab
	cCall	FreeNRTable,<hExe,ax>
foexit0:
	pop	ax
foexit1:

;??? commented out 3/7/88 by rong
;??? we should put this back in once everyone has the new keyboard driver
;if KDEBUG
;	or	ax,ax
;	jnz	foexit2
;	les	bx,lpname
;	inc	bx
;	kerror	ERR_LDNAME,<Invalid procedure name >,es,bx
;	xor	ax,ax
;foexit2:
;endif
cEnd

; Search the list of new EXE headers for the passed executable file name
; (no path)
;
; this must be resident so we can search for modules in the file handle
; cache from the int 21 handler -- craigc
;

cProc	ResidentFindExeFile,<PUBLIC,FAR>,<ds,si,di>
    parmD   pname
cBegin
	SetKernelDS

	mov	ax,hExeHead
ffloop:
	or	ax,ax
	jz	ffdone
	mov	es,ax
	mov	di,es:[ne_pfileinfo]
	or	di,di
	jz	ffnext

;
;	Double Byte Character is not able to search from the end of string,
;	so this function must search from the top of string.
;
ifdef FE_SB
	lea	si,[di.opFile]		; get address of file name
	mov	cl,es:[di.opLen]	; get structure length
	xor	ch,ch
	add	cx,di
	mov	di,cx			; save end address
	sub	cx,si			; get length of file name
	mov	bx,si			; save top address of file name
	cld
delineator_loop:
	lods	byte ptr es:[si]
	call	MyIsDBCSLeadByte
	jc	delineator_notlead	; if not DBCS lead byte
	dec	cx
	jcxz	delineator_next
	inc	si
	loop	delineator_loop
	jmp	delineator_next
delineator_notlead:
	cmp	al,"\"
	jz	found_delineator
	cmp	al,":"
	jz	found_delineator
	loop	delineator_loop
	jmp	delineator_next
found_delineator:
	mov	bx,si			; save delineator address
	loop	delineator_loop
delineator_next:
	xchg	bx,di			; set address of file name to di
	sub	bx,di			; get lenfth of file name
else
	mov	si,di
	xor	cx,cx
	mov	cl,es:[di]
	add	si,cx
	dec	si
	std
	xor	bx,bx
delineator_loop:			; look for beginning of name
	lods	byte ptr es:[si]
	cmp	al,"\"
	jz	found_delineator
	cmp	al,":"
	jz	found_delineator
	inc	bx
	loop	delineator_loop
	dec	si
found_delineator:			; ES:SI -> before name
	mov	di,si
	inc	di
	inc	di
endif

	lds	si,pname
	UnSetKernelDS
	mov	cx,bx
	cld
	repe	cmpsb
	mov	ax,es
	je	ffdone
ffnext:
	mov	ax,word ptr es:[ne_pnextexe]
	jmp	ffloop
ffdone:
cEnd

sEnd	CODE

externFP FarLoadSegment

sBegin	NRESCODE
assumes CS,NRESCODE
assumes DS,NOTHING
assumes ES,NOTHING

externNP DelModule
externNP MapDStoDATA

cProc	FindExeFile,<PUBLIC,NEAR>
    parmD   pFile
cBegin
    cCall   ResidentFindExeFile, <pFile>
cEnd


; Search the list of new EXE headers for the passed executable name

cProc	FindExeInfo,<PUBLIC,NEAR>,<ds,si,di>
    parmD   pname
    parmW   nchars
cBegin

	cCall	MapDStoDATA
	ReSetKernelDS

	mov	bx,nchars
	mov	ax,hExeHead
feloop:
	or	ax,ax
	jz	fedone
	mov	es,ax
	mov	di,es:[ne_restab]
	cmp	es:[di],bl
	jne	fenext
	inc	di
	lds	si,pname
	UnSetKernelDS
	mov	cx,bx
	repe	cmpsb
	je	fedone
fenext:
	mov	ax,word ptr es:[ne_pnextexe]
	jmp	feloop
fedone:
cEnd

cProc	FarFindExeInfo,<PUBLIC,FAR>
	parmD	pname
	parmW	nchars
cBegin
	cCall	FindExeInfo,<pname,nchars>
cEnd


;
; IncExeUsage( hExe ) - procedure to increment the usage count of this
; EXE header.  Indirectly increments the usage count of all the EXE
; headers it points to.
;
cProc	IncExeUsage,<PUBLIC,NEAR>,<ax,di>
	parmW   hexe
cBegin
	mov	cx,hexe
	jcxz	iexj
	mov	es,cx
	cmp	es:[ne_magic],NEMAGIC
	jne	iexj
	test	es:[ne_usage],8000h
	jz	iego
iexj:
	krDebugOut	<DEB_ERROR or DEB_KRLOADMOD>, "IncExeUsage(#ES) not DLL"
	jmp	iex
iego:

	cmp	es:[ne_usage], 4000h
	jb	OKusage
	krDebugOut	DEB_FERROR, "IncExeUsage: ne_usage overflow"
OKusage:

		;
		; Save time and space by saving stuff on stack
		; rather than recursing.
		;

	or	es:[ne_usage], 8000h
NextExe0:
	or	es:[ne_usage], 4000h		; Mark node visited
	inc	es:[ne_usage]
;if kdebug
;	push	ax
;	mov	ax, es:[ne_usage]
;	krDebugOut <DEB_TRACE or DEB_krLoadMod>, "IncExeUsage(%ES0) #ax"
;	pop	ax
;endif
	mov	cx,es:[ne_cmod]
	jcxz	NoDeps0
	mov	di,es:[ne_modtab]
ieloop:
	push	es
	cmp	word ptr es:[di], 0
	je	ieloop1
	lar	ax, es:[di]			; Make sure valid selector
	jnz	ieloop1
	mov	es, es:[di]
	cmp	es:[ne_magic],NEMAGIC
	jne	ieloop1
	test	es:[ne_usage], 0C000h
	jnz	ieloop1
	push	cx
	push	di				; Fake recursion
	jmp	NextExe0
NextExeDone0:					; Return from fake recursion
	pop	di
	pop	cx
ieloop1:
	pop	es
	add	di,2
	loop	ieloop

NoDeps0:
	mov	cx, es
	cmp	cx, hExe
	jne	NextExeDone0

NextExe1:
	and	es:[ne_usage], NOT 4000h	; Mark node visited
	mov	cx,es:[ne_cmod]
	jcxz	NoDeps1
	mov	di,es:[ne_modtab]
UnMarkLoop:
	push	es
	cmp	word ptr es:[di], 0
	je	UnMarkLoop1
	lar	ax, es:[di]			; Make sure valid selector
	jnz	UnMarkLoop1
	mov	es, es:[di]
	cmp	es:[ne_magic],NEMAGIC
	jne	UnMarkLoop1
	test	es:[ne_usage], 08000h
	jnz	UnMarkLoop1
	test	es:[ne_usage], 04000h
	jz	UnMarkLoop1
	push	cx
	push	di				; Fake recursion
	jmp	NextExe1
NextExeDone1:					; Return from fake recursion
	pop	di
	pop	cx
UnMarkLoop1:
	pop	es
	add	di,2
	loop	UnMarkLoop

NoDeps1:
	mov	cx, es
	cmp	cx, hExe
	jne	NextExeDone1

	xor	es:[ne_usage], 8000h
iex:
cEnd

;-----------------------------------------------------------------------;
; DecExeUsage								;
; 									;
; Decrements the usage count of the given EXE header.  Indirectly	;
; decrements the usage count of all the EXE headers it points to.	;
; 									;
; Arguments:								;
;	parmW   hexe							;
; 									;
; Returns:								;
;	ZF = 1 if usage count is now zero.				;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
;	DI,SI,DS							;
;									;
; Registers Destroyed:							;
; 	AX,BX,CX,DX,ES							;
;									;
; Calls:								;
;	DecExeUsage							;
;	DelModule							;
; 									;
; History:								;
; 									;
;  Mon Sep 21, 1987 01:21:00p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

cProc	DecExeUsage,<PUBLIC,NEAR>,<ds,di,si>
	parmW   hexe
cBegin
	call	MapDStoDATA
	ReSetKernelDS

	xor	si,si
	mov	cx,hexe
	xor	ax,ax
	jcxz	dexj
	mov	es,cx
	cmp	es:[si].ne_magic,NEMAGIC
	jne	dexj
	test	es:[si].ne_usage,8000h
	jz	dego
dexj:
	krDebugOut	<DEB_ERROR or DEB_KRLOADMOD>, "DecExeUsage(#ES) not DLL"
	jmp	dex
dego:

		;
		; Save time and space by saving stuff on stack
		; rather than recursing.
		;

	dec	es:[si].ne_usage
	or	es:[si].ne_usage, 8000h
;if kdebug
;	push	ax
;	mov	ax, es:[si].ne_usage
;	krDebugOut <DEB_TRACE or DEB_krLoadMod>, "DecExeUsage(%ES0) #ax"
;	pop	ax
;endif
NextExe2:
	or	es:[si].ne_usage, 4000h		; Mark node visited
	mov	cx,es:[si].ne_cmod
	jcxz	NoDeps2
	mov	di,es:[si].ne_modtab
MarkLoop2:
	push	es
	cmp	si, es:[di]
	je	MarkLoop3
	lar	ax, es:[di]			; Make sure valid selector
	jnz	MarkLoop3
	mov	es, es:[di]
	cmp	es:[si].ne_magic,NEMAGIC
	jne	MarkLoop3
	test	es:[si].ne_usage, 0C000h
	jnz	MarkLoop3
	push	cx
	push	di				; Fake recursion
	jmp	NextExe2
NextExeDone2:					; Return from fake recursion
	pop	di
	pop	cx
MarkLoop3:
	pop	es
	add	di,2
	loop	MarkLoop2

NoDeps2:
	mov	cx, es
	cmp	cx, hExe
	jne	NextExeDone2

        xor     cx, cx
        push    cx                              ; End of list of Exes to delete
	mov	di, hExeHead			; Scan Exes once to dec them
scan_exes:
	or	di, di
	jz	de_done
	mov	es, di
	mov	di, es:[si].ne_pnextexe
	test	es:[si].ne_usage, 4000h
	jz	scan_exes
	and	es:[si].ne_usage, NOT 4000h	; Remove the mark
	test	es:[si].ne_usage, 8000h		; Skip this one?
	jnz	scan_exes
;	krDebugOut <DEB_TRACE or DEB_krLoadMod>, "DecExeUsage dependent %ES0"
	dec	es:[si].ne_usage
        jnz     scan_exes
        push    es                              ; We will delete this one
        jmps    scan_exes


de_done:				; Call WEP each module before
	mov	bx, sp			; we free any modules
de_done0:
	mov	cx, ss:[bx]
	add	bx, 2
	jcxz	de_done1
	push	bx
	cCall	CallWEP, <cx, 0>
	pop	bx
	jmps	de_done0


de_done1:
        pop     cx                              ; Get next module to delete
        jcxz    all_deleted
        cCall   DelModule,<cx>                  ; Delete him
	jmps    de_done1

all_deleted:
	mov	es, hExe
	and	es:[si].ne_usage,NOT 0C000h
dex:
cEnd


;
; StartProcAddress( hExe ) - procedure to return the fixed address of
; a new EXE start procedure
;
cProc	StartProcAddress,<PUBLIC,NEAR>,<di>
	parmW   hexe
	parmW   fh
cBegin
	mov	es,hexe
	mov	di,ne_csip
	xor	dx,dx
	mov	ax,es:[di+2]
	or	ax,ax
	jz	sp1
	mov	di,es:[di]
	cCall	FarLoadSegment,<es,ax,fh,fh>
	jcxz	sp1
	mov	ax,di			; DX:AX is start address of module
sp1:					; (DX is really a handle)
	mov	cx,ax
	or	cx,dx
cEnd



; GetStackPtr - returns the initial SS:SP for a module.
;
cProc GetStackPtr,<PUBLIC,NEAR>,<si>
	parmW   hExe
cBegin
	mov	es,hExe
if KDEBUG
	cmp	es:[ne_sssp].sel,0
	jnz	@F
	mov	cx,ne_sssp
	fkerror 0,<Invalid stack segment>,es,cx
@@:
endif
	cmp	es:[ne_sssp].off,0
	jne	re3
	mov	dx,es:[ne_stack]
	mov	bx,es:[ne_pautodata]
	or	bx,bx
	jz	re2
	add	dx,es:[bx].ns_minalloc
re2:	and	dx,0FFFEh		; Word aligned stack
	mov	word ptr es:[ne_sssp],dx

re3:	mov	dx,es:[ne_sssp].sel
	mov	ax,es:[ne_sssp].off
	push	ax
	mov	cx,-1
	cCall	FarLoadSegment,<es,dx,cx,cx>
	pop	ax			; Handle in DX and offset in AX
cEnd




;
; GetInstance( hExe ) - Procedure to return the instance handle for
; the current automatic data segment associated with the passed exe
;
cProc	GetInstance,<PUBLIC,NEAR>
	parmW   hexe
cBegin
	mov	es,hexe
	mov	ax,es:[ne_flags]
	test	ax,NEINST+NESOLO
	mov	ax,es
	jz	gidone
	mov	bx,es:[ne_pautodata]
	or	bx,bx
	jz	gidone
	mov	ax,es:[bx].ns_handle
gidone:
	mov	cx,ax
cEnd

sEnd	NRESCODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\mapdata.asm ===
TITLE	MAPDATA - Map DS to kernel's data segment

include kernel.inc


; This code could go almost anywhere, but didn't really belong in kdata.asm


sBegin	NRESCODE
assumes CS,NRESCODE
assumes DS,NOTHING
assumes ES,NOTHING
assumes SS,NOTHING

KDataSeg	dw	seg _DATA
public	KDataSeg

cProc	MapDStoDATA,<PUBLIC,NEAR>
cBegin	nogen
;;;	push	ax
;;;	mov	ax,seg _DATA
;;;	mov	ds,ax
;;;	pop	ax
	mov	ds, cs:KDataSeg
	ret
cEnd	nogen

sEnd	NRESCODE



sBegin	MISCCODE
assumes	cs, misccode
assumes	ds, nothing
assumes	es, nothing
assumes	ss, nothing

MKDataSeg	dw	seg _DATA
public	MKDataSeg

cProc	MISCMapDStoDATA,<PUBLIC,NEAR>
cBegin	nogen
;;;	push	ax
;;;	mov	ax,seg _DATA
;;;	mov	ds,ax
;;;	pop	ax
	mov	ds, cs:MKDataSeg
	ret
cEnd	nogen


if 0	;----------------------------------------------------------------
cProc	MISCMapEStoDATA,<PUBLIC,NEAR>
cBegin	nogen
;;;	push	ax
;;;	mov	ax,seg _DATA
;;;	mov	es,ax
;;;	pop	ax
	mov	es, cs:MKDataSeg
	ret
cEnd	nogen
endif	;----------------------------------------------------------------

sEnd	MISCCODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\linterf.asm ===
TITLE	LINTERF - Local memory allocator, interface procedures

.xlist
include tdb.inc
include kernel.inc
.list

.errnz	 la_prev		; This code assumes la_prev = 0

if KDEBUG
CheckHeap  MACRO n
local	a
	extrn	CheckLocalHeap:NEAR
	cCall	CheckLocalHeap
	or	ax,ax
	jz	a
	or	ax,ERR_LMEM
	kerror	<>,<&n: Invalid local heap>
a:
	endm
else
CheckHeap  MACRO n
	endm
endif

externW pLocalHeap

externFP <GlobalHandle,GlobalReAlloc,GlobalSize,GlobalCompact,GlobalFlags>
externFP <GlobalLock,GlobalUnlock>
externFP <GlobalMasterHandle,GetCurrentTask>
externFP FarValidatePointer
externFP DibRealloc

DataBegin

externW curTDB
;externW MyCSDS

if KDEBUG
externW DebugOptions
endif

DataEnd

sBegin	CODE
assumes CS,CODE
assumes DS,NOTHING
assumes ES,NOTHING

externNP <halloc,lhfree,lhdref,hthread>		; LHANDLE.ASM
externNP <ljoin,lrepsetup,lzero>		; LALLOC.ASM
externNP <lalloc,lfree,lfreeadd,lfreedelete>	; LALLOC.ASM
externNP <lcompact,lshrink>			; LCOMPACT.ASM

if KDEBUG
externNP <CheckLAllocBreak>
endif   ;KDEBUG

;-----------------------------------------------------------------------;
; lenter								;
;									;
; Enters a critical region for the local heap.				;
;									;
; Arguments:								;
;	DS = automatic data segment containing local heap		;
;									;
; Returns:								;
;	DS:DI = address of LocalInfo for local heap			;
;	(li_lock field has been incremented)				;
;									;
; Error Returns:							;
;	CX == 1 if heap is busy						;
;									;
; Registers Preserved:							;
;	AX,BX,DX,SI,ES							;
;									;
; Registers Destroyed:							;
;	CX								;
;									;
; Calls:								;
;	nothing								;
;									;
; History:								;
;									;
;  Sun Oct 13, 2086 09:27:27p  -by-  David N. Weise   [davidw]		;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

cProc	lenter,<PUBLIC,NEAR>
cBegin nogen
	mov	di,pLocalHeap
	mov	cx,1
	xchg	[di].li_lock,cx
	jcxz	enter1

; Should really do a WaitEvent

if KDEBUG
	xor	bx,bx
	kerror	ERR_LMEMCRIT,<lenter: local heap is busy>,bx,cx
endif

enter1: ret

cEnd nogen

;-----------------------------------------------------------------------;
; lleave								;
;									;
; Leaves a critical region for the local heap.				;
;									;
; Arguments:								;
;	DS = automatic data segment containing local heap		;
;									;
; Returns:								;
;	DS:DI = address of LocalInfo for local heap			;
;	(li_lock field has been cleared)				;
;									;
; Error Returns:							;
;									;
; Registers Preserved:							;
;	AX,BX,DX,SI,ES							;
;									;
; Registers Destroyed:							;
;	CX								;
;									;
; Calls:								;
;	nothing								;
;									;
; History:								;
;									;
;  Sun Oct 13, 2086 09:30:01p  -by-  David N. Weise   [davidw]		;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

cProc	lleave,<PUBLIC,NEAR>
cBegin nogen
	mov	di,pLocalHeap
	xor	cx,cx
	xchg	ds:[di].li_lock,cx
	jcxz	leave1
	ret
leave1:

; Should really do a PostEvent
if KDEBUG
	kerror	ERR_LMEMCRIT,<lleave: local heap was not busy>
endif

cEnd nogen

;-----------------------------------------------------------------------;
; lhexpand								;
; 									;
; Expands a local handle table.						;
; 									;
; Arguments:								;
;	CX    = #handle entries to allocate				;
;	DS:DI = local info structure					;
; 									;
; Returns:								;
;	AX = address of handle table block of requested size		;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
;	BX,CX,DX,ES							;
; 									;
; Calls:								;
;	lalloc								;
;	hthread 							;
; 									;
; History:								;
; 									;
;  Tue Oct 14, 1986 01:48:21p  -by-  David N. Weise   [davidw]		;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

cProc	lhexpand,<PUBLIC,NEAR>
cBegin nogen
	xor	ax,ax			; Allocate fixed local block
	mov	bx,cx
	inc	bx			; plus 1 for word at beginning & end
	shl	bx,1
	shl	bx,1
	errnz	<4-SIZE LocalHandleEntry>
	push	cx
	call	lalloc
	pop	cx
        or      ax,ax
	jz	lhfail
	mov	bx,ax
	xchg	[di].hi_htable,bx
	push	di			; Save DI
	mov	di,ax
	mov	ds:[di],cx
	inc	di
	inc	di
	call	hthread
	mov	ds:[di],bx		; Store pointer to next block
	pop	di			; Restore DI
lhfail:	mov	cx,ax
	ret
cEnd nogen


;-----------------------------------------------------------------------;
; lalign								;
; 									;
; Aligns the size request for a local item to a multiple of 4 bytes.	;
; 									;
; Arguments:								;
;	CF = 0								;
;	  BX = #bytes							;
;	CF = 1	get max amount						;
; 									;
; Returns:								;
;	DX = #bytes aligned to next higher multiple of 4		;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
;	nothing								;
; 									;
; History:								;
; 									;
;  Tue March 10, 1987 -by- Bob Gunderson [bobgu]			;
; To accomidate free list, must impose a minimum block size to prevent	;
; allocating a block on top of the extended header of previous block.	;
;									;
;  Tue Oct 14, 1986 01:56:42p  -by-  David N. Weise   [davidw]		;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

cProc	lalign,<PUBLIC,NEAR>
cBegin nogen
	jnc	align0
	mov	bx,LA_MASK
align0:	cmp	bx,SIZE LocalArenaFree
	jae	align2
	mov	bx,SIZE LocalArenaFree	; Must impose a minimum size
align2:	lea	dx,[bx+LA_ALIGN]
	and	dl,LA_MASK
	cmp	dx,bx			; Test for overflow
	jae	align1			; No, continue
	mov	dx,LA_MASK		; Yes, return largest possible size
align1:	ret
cEnd nogen


;-----------------------------------------------------------------------;
; ldref									;
; 									;
; Dereferences a local handle.						;
; 									;
; Arguments:								;
;	SI = handle							;
; 									;
; Returns:								;
;	AX = address of client data					;
;	BX = address of arena header					;
;	CH = lock count or zero for fixed objects			;
;	SI = handle table entry address or zero for fixed objects	;
;	ZF = 1 if NULL handle passed in					;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
;	CL 								;
;									;
; Calls:								;
;	lhdref								;
; 									;
; History:								;
; 									;
;  Tue Oct 14, 1986 01:58:58p  -by-  David N. Weise   [davidw]		;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

cProc	ldref,<PUBLIC,NEAR>
cBegin nogen
	xor	cx,cx			; Zero lock count
	mov	ax,si			; Return handle if fixed object
	test	al,LA_MOVEABLE		; Is it moveable?
	jnz	dref3			; Yes, go dereference handle
	xor	si,si			; Set SI to zero for fixed objects
	or	ax,ax			; No, were we passed NULL?
	jz	dref2			; Yes, then all done
dref1:	mov	bx,ax			; No, return BX pointing
	and	bl,LA_MASK		; ...to arena header
	sub	bx,la_fixedsize		; Leaving ZF = 0
dref2:	ret

dref3:	call	lhdref			; Get true address in AX
					;  and lock count in CH
ife KDEBUG
	jz	done			; Compute arena header if valid true address
	mov	bx,ax			; See if arena header points to
	sub	bx,SIZE LocalArena
done:	ret				; No, return with ZF = 1
else
	test	cl,LHE_DISCARDED	; Discarded?
	jnz	dref5			; Yes, all done
	or	ax,ax			; Is there a true address?
	jz	dref4			; No, then must be error
	mov	bx,ax			; See if arena header points to
	sub	bx,SIZE LocalArena
	cmp	[bx].la_handle,si	; handle table entry?
	je	dref5			; Yes, continue
dref4:	xor	bx,bx
	kerror	ERR_LMEMHANDLE,<LDREF: Invalid local handle>,bx,si
	xor	ax,ax
dref5:	or	ax,ax
	ret
endif

cEnd nogen


;-----------------------------------------------------------------------;
; lnotify								;
; 									;
; Calls the local heap's notify proc (if any).				;
; 									;
; Arguments:								;
;	AL = message code						;
;	BX = handle or largest free block				;
;	CX = optional argument 		 				;
; 									;
; Returns:								;
;	AX = return value from notify proc or AL			;
;	ZF = 1 if AX = 0						;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
;	BX,CX,DX,ES							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Tue Oct 14, 1986 02:03:14p  -by-  David N. Weise   [davidw]		;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

cProc	lnotify,<PUBLIC,NEAR>
cBegin nogen
	cmp	word ptr [di+2].li_notify,0
	je	notify1
	xor	ah,ah
	cCall	[di].li_notify,<ax,bx,cx>
notify1:
	or	ax,ax
	ret
cEnd nogen


; The remainder of this file implements the exported interface to the
; local memory manager.  A summary follows:
;
;   HANDLE  far PASCAL LocalAlloc( WORD, WORD );
;   HANDLE  far PASCAL LocalReAlloc( HANDLE, WORD, WORD );
;   HANDLE  far PASCAL LocalFree( HANDLE );
;   WORD    far PASCAL LocalSize( HANDLE );
;   char *  far PASCAL LocalLock( HANDLE );
;   BOOL    far PASCAL LocalUnlock( HANDLE );
;   WORD    far PASCAL LocalCompact( WORD );
;   WORD    far PASCAL LocalShrink( HANDLE , WORD );
;   FARPROC far PASCAL LocalNotify( FARPROC );
;   #define LocalDiscard( h ) LocalReAlloc( h, 0, LMEM_MOVEABLE )
;   BOOL    far PASCAL LocalInit( char *, char * );
;
;   extern WORD * PASCAL pLocalHeap;
;
;   #define dummy 0
;   #define LocalFreeze( dummy ) ( *(pLocalHeap+1) += 1 )
;   #define LocalThaw( dummy )	 ( *(pLocalHeap+1) -= 1 )
;

cProc	ILocalAlloc,<PUBLIC,FAR>,<si,di>
	parmW   flags
	parmW   nbytes
cBegin
	WOWTrace "LocalAlloc(#AX,#BX)",<<ax,flags>,<bx,nbytes>>
	CheckHeap LocalAlloc
	call	lenter			; About to modify memory arena
	jcxz	la_ok
	xor	ax, ax
	jmp	la_crit
la_ok:
	mov	ax,flags		; Allocate space for object
	test	al,LA_NOCOMPACT
	jz	all0
	inc	[di].hi_freeze
all0:	mov	bx,nbytes
	or	bx,bx			; Zero length?
	jnz	alloc0			; No, continue
	and	ax,LA_MOVEABLE		; Yes, moveable?
	jz	alloc1			; No, return error
	call	halloc			; Yes, allocate handle
	or	ax,ax			; failure??
	jz	alloc1			; yep... return a NULL
	xor	byte ptr [bx].lhe_address,LA_MOVEABLE ; and zero address field
	or	byte ptr [bx].lhe_flags,LHE_DISCARDED ; and mark as discarded
	jmps	alloc1			; all done

alloc0:	test	al,LA_MOVEABLE		; Is this a moveable object?
	jz	dont_need_handle
	push	ax
	push	bx
	call	halloc			; Allocate handle first.

	or	ax,ax
	jnz	all2			; error?
	pop	bx			; yes, DON'T destroy the NULL in AX
	pop	bx
	jmps	alloc1
all2:
	pop	bx
	pop	ax

;	pop	bx
;	pop	ax
;	jcxz	alloc1

	push	cx			; this is handle
	call	lalloc
	pop	si			; get handle in index register
	jnz	got_space
	call	lhfree			; free the allocated handle
	jmps	alloc1

got_space:
	mov	[si].lhe_address,ax	; Store address away.
	mov	bx,ax			; Store back link to handle in header
	mov	[bx-SIZE LocalArena].la_handle,si  ; Mark as moveable block
	or	byte ptr [bx-SIZE LocalArena].la_prev,LA_MOVEABLE
	mov	ax,si			; return the handle
	and	dh,LHE_DISCARDABLE	; Discardable object?
	jz	alloc1			; No, continue
	mov	[si].lhe_flags,dh	; Yes, save discard level in handle
	jmps	alloc1			;  table entry

dont_need_handle:
	call	lalloc
alloc1:	test	byte ptr flags,LA_NOCOMPACT
	jz	all1
	dec	[di].hi_freeze
all1:	call	lleave			; Arena is consistent now
la_crit:
ifdef WOW
        ; We don't want this debug spew
else
        or      ax,ax
        jnz     @F
        KernelLogError DBF_WARNING,ERR_LALLOC,"LocalAlloc failed"  ; LocalAlloc failure
        xor     ax, ax                  ; preserve the return value
@@:
endif
        mov     cx,ax                   ; Let caller do jcxz to test failure
	WOWTrace "LocalAlloc: #AX"
cEnd


cProc	ILocalReAlloc,<PUBLIC,FAR>,<si,di>
	parmW   h
	parmW   nbytes
	parmW   rflags
cBegin
	WOWTrace "LocalReAlloc(#AX,#BX,#CX)",<<ax,h>,<bx,nbytes>,<cx,rflags>>
	CheckHeap   LocalReAlloc
	call	lenter			; About to modify memory arena
	jcxz	lr_ok
	xor	ax, ax
	jmp	lr_crit
lr_ok:
	test	byte ptr rflags,LA_NOCOMPACT
	jz	rel0
	inc	[di].hi_freeze
rel0:
	mov	si,h			; Dereference handle
	call	ldref
	jz	racreate		; If zero handle, check for re-creation.
	test	byte ptr rflags,LA_MODIFY   ; Want to modify handle table flags
	jnz	ramodify		; Yes, go do it
	mov	si,bx			; SI = arena header
	mov	bx,ax			; Compute address of new next header
	mov	dx,nbytes		;  assuming there is room.
	cmp	dx,SIZE LocalArenaFree	; Minimum size must be large enough
	jae	@F			;  to a hold free header.
	mov	dx,SIZE LocalArenaFree
@@:	add	bx,dx
	call	lalign
	mov	bx,[si].la_next		; Get address of current next header
	cmp	nbytes,0		; Are we reallocing to zero length?
	jne	raokay			; No, continue
	jcxz	radiscard		; Yes, discard if not locked
rafail:
ifdef WOW
        ; We don't want this debug spew
else
        KernelLogError  DBF_WARNING,ERR_LREALLOC,"LocalReAlloc failed"
endif
        xor     ax,ax
        jmp     raexit

radiscard:

; Here to discard object, when reallocating to zero size.  This
;  feature is only enabled if the caller passes the moveable flag

	test	byte ptr rflags,LA_MOVEABLE	; Did they want to discard?
	jz	rafail			; No, then return failure.
	mov	al,LN_DISCARD		; AL = discard message code
	xor	cx,cx			; CX = disc level of 0 (means realloc)
	mov	bx,h			; BX = handle
	call	lnotify			; See if okay to discard
	jz	rafail			; No, do nothing
	xor	ax,ax			; Yes, free client data
	mov	bx,si
	call	lfree
	jz	rax			; Return NULL if freed a fixed block
	mov	[si].lhe_address,ax	; No, zero addr in handle table entry
	or	[si].lhe_flags,LHE_DISCARDED  ; and mark as discarded
	jmps	rasame			; Return original handle, except
					; LocalLock will now return null.

ramodify:
	mov	ax,rflags		; Get new flags
	or	si,si			; Moveable object?
	jz	rasame			; No, all done
	and	[si].lhe_flags,not LHE_USERFLAGS ; Clear old flags
	and	ah,LHE_USERFLAGS; Get new flags
	or	[si].lhe_flags,ah	; Store new flags in handle table entry
	jmps	rasame

racreate:
	test	cl,LHE_DISCARDED	; Is this a discarded handle?
	jz	rasame			; No, return original value
	mov	bx,nbytes		; BX = new requested size
	push	si			; save handle
	mov	ax,LA_MOVEABLE		; Reallocating a moveable object
	or	ax,rflags		; ...plus any flags from the caller
	call	lalloc			; Allocate a new block
	pop	si			; restore existing handle
	jz	rafail
	xor	[si].lhe_flags,LHE_DISCARDED  ; and mark as not discarded
	jmp	ram2

raokay:
; Here if not trying to realloc this block to zero
; SI = arena header of current block
; AX = client address of current block
; BX = arena header of next block
; CH = lock count of current block
; DX = new next block, based on new requested size
	cmp	dx,bx			; Are we growing or shrinking?
	ja	ragrow			; We are growing
rashrink:				; We are shrinking
; Here to shrink a block
; SI = arena header of current block
; BX = arena header of next block
; DX = new next block, based on new requested size
	push	si
	mov	si,dx			; SI = new next block
	add	dx,LA_MINBLOCKSIZE	; Test for small shrinkage
        jnc     @F                      ;   No overflow
        pop     bx			;   Overflowed, obviously no room!
	jmp     rasame                  ;   Clear stack and return same handle
@@:	cmp	dx,bx		  	; Is there room from for free block?
	pop	bx			; BX = current block
	jae	rasame			; No, then no change to make
					; Splice extra free space into arena
	mov	cx,si			; [si].la_next = [bx].la_next
	xchg	[bx].la_next,cx		; [bx].la_next = si
	mov	[si].la_prev,bx		; [si].la_prev = bx
	xchg	si,cx
	and	[si].la_prev,LA_ALIGN
	jz	splice1			; If free then coelesce
	inc	[di].hi_count		; No, adding new arena entry
	jmps	splice2
splice1:

; next block is free, must make the new block a larger free block

; first remove the current free block [SI] from the free list

	xchg	bx,si
	call	lfreedelete
	xchg	bx,si
	mov	si,[si].la_next
	and	[si].la_prev,LA_ALIGN

splice2:
	or	[si].la_prev,cx		; [[si].la_next].la_prev = si
	xchg	si,cx
	mov	[si].la_next,cx
	mov	bx,si			; BX = new block
	xor	si,si			; don't know where to insert
	call	lfreeadd		; add to free list
rasame:
	mov	ax,h			; Return the same handle
rax:	jmps	raexit			; All done

; Here to try to grow the current block
; AX = client address of current block
; SI = arena header of current block
; BX = arena header of next block
; DX = new next block, based on new requested size
ragrow:
if KDEBUG
        call    CheckLAllocBreak
        jc      rafail1
endif

	test	byte ptr [bx].la_prev,LA_BUSY	; Is next block free?
	jnz	ramove			; No, try to move the current block
	cmp	dx,[bx].la_next		; Yes, is free block big enough?
	ja	ramove			; No, try to move the current block
	mov	cx,bx			; Yes, save free block address in CX
	call	ljoin			; and attach to end of current block
	test	rflags,LA_ZEROINIT	; Zero fill extension?
	jz	ranz			; No, continue
	call	lzero			; Yes, zero fill
ranz:
	jmp	rashrink		; Now shrink block to correct size

; Here to try to move the current block
; AX = client address of current block
; SI = arena header of current block
; CH = lock count of current block
ramove:
	mov	dx,rflags		; get the passed in flags
	mov	bx,LA_MOVEABLE		; Determine if okay to move this guy
	jcxz	ramove1			; Continue if this handle not locked
	test	dx,bx			; Locked.  Did they say move anyway?
	jnz	ramove1			; Yes, go do it
rafail1:jmp	rafail
ramove1:
	or	dx,bx			; make sure moveable bit set
	test	h,bx			; Is it a moveable handle?
	jnz	ram1			; Yes, okay to move
	test	rflags,bx		; No, did they say it's okay to move?
	jz	rafail1			; No, then fail
	xor	dx,bx			; turn off moveable bit
ram1:
;   We do this because the lalloc can move the old block to a
;   block that is larger than the requested new block.	This can
;   happen if we LocalCompact durring the lalloc call.	(bobgu 8/27/87)
	mov	bx,[si].la_next
	sub	bx,ax			; # client bytes in current block
	push	bx			; save it for later

	mov	ax,dx			; AX = allocation flags
	mov	bx,nbytes		; BX = new requested size
	call	lalloc			; Allocate a new block

	pop	cx			; CX = client size of old block
	jz	rafail1
	push	cx			; save it away again

	push	ax			; Call notify proc
	mov	cx,ax			; with new location
	mov	bx,h			; handle
	mov	al,LN_MOVE
	call	lnotify			; Notify client of new location
	mov	si,h
	call	ldref			; BX = old arena header address
	mov	si,ax			; SI = old client address
	pop	ax			; AX = new client address

	pop	cx			; get back size of old client
;	mov	cx,[bx].la_next 	; Compute length of old client data
;	sub	cx,si
	call	lrepsetup		; Setup for copy of words
	push	di
	mov	di,ax			; DI = new client data address
	rep	movsw			; Copy old client data to new area
	pop	di			; Restore DI
	call	lfree			; Free old block
	jz	raexit
ram2:
	mov	[si].lhe_address,ax	; Set new client data address
	xchg	ax,si			; Return original handle
					; Set back link to handle in new block
	or	byte ptr [si-SIZE LocalArena].la_prev,LA_MOVEABLE
	mov	[si-SIZE LocalArena].la_handle,ax
raexit:
	test	byte ptr rflags,LA_NOCOMPACT
	jz	rel1
	dec	[di].hi_freeze
rel1:
	call	lleave			; Arena is consistent now
lr_crit:
	mov	cx,ax			; Let caller do jcxz to test failure
	WOWTrace "LocalReAlloc: #AX"
cEnd


cProc	ILocalFree,<PUBLIC,FAR>,<si,di>
	parmW   h
cBegin
	WOWTrace "LocalFree(#AX)",<<ax,h>>
	call	lenter			; About to modify memory arena
	jcxz	lf_ok
	xor	ax, ax
	jmp	lf_crit
lf_ok:
	CheckHeap   LocalFree
	mov	si,h			; Dereference handle
	call	ldref
	jz	free1			; Free handle if object discarded
if KDEBUG
	push	ds
	SetKernelDS
	mov	ds,curTDB
	assumes	ds, nothing
	cmp	ds:[TDB_ExpWinVer],201h
	pop	ds
	jb	dont_do_error_checking

	or	ch,ch			; No, is the handle locked?
	jz	freeo			; Yes, then don't free
	xor	bx,bx
	kerror	ERR_LMEMUNLOCK,<LocalFree: freeing locked object>,bx,h
	mov	si,h			; Dereference handle again
	call	ldref
freeo:
dont_do_error_checking:
endif
	call	lfree			; No, free the object
free1:	call	lhfree			; and any handle
freex:	call	lleave			; Arena is consistent now
lf_crit:
	WOWTrace "LocalFree: #AX"
cEnd

cProc	ILocalSize,<PUBLIC,FAR>
;	parmW   h
cBegin	nogen
;	CheckHeap   LocalSize
	push	si
	mov	si,sp
	mov	si,ss:[si+6]		; Dereference handle
	call	ldref			; into BX
	jz	size1			; Done if AX = zero
	sub	ax,[bx].la_next		; Otherwise size =
	neg	ax			;  - (client address - next block address)
size1:	mov	cx,ax			; Let caller do jcxz to test failure
	pop	si
	ret	2
cEnd	nogen


cProc	ILocalFlags,<PUBLIC,FAR>
;	parmW   h
cBegin	nogen
;	CheckHeap   LocalFlags
	push	si
	mov	si,sp
	mov	si,ss:[si+6]		; Dereference handle
	call	ldref			; into BX
	mov	cx,si
	jcxz	flags1			; Done if not moveable
	mov	cx,word ptr [si].lhe_flags   ; Return flags and lock count
flags1:
	xchg	cl,ch			; Return lock count in low half
	mov	ax,cx			; Let caller do jcxz to test failure
	pop	si
	ret	2
cEnd	nogen



if KDEBUG
cProc	ILocalLock,<PUBLIC,FAR>,<si>
	parmW   h
cBegin
	WOWTrace "LocalLock(#AX)",<<ax,h>>
;	CheckHeap   LocalLock
	mov	si,h
	call	ldref			; SI = handle table entry
	jz	lock2			; Done if invalid handle or discarded
	or	si,si
	jz	lock2			; or if not moveable

	inc	[si].lhe_count		; Increment usage count
	jnz	lock1
	xor	cx,cx
	kerror	ERR_LMEMLOCK,<LocalLock: Object usage count overflow>,cx,h
	dec	[si].lhe_count		; Keep pinned at max value
lock1:	mov	ax,[si].lhe_address	; Return true address in AX
lock2:	
	or	ax, ax
	jnz	@F
        KernelLogError  DBF_WARNING,ERR_LLOCK,"LocalLock failed"
        xor     ax,ax                   ; Get back the NULL value in ax
@@:	mov	cx,ax			; Let caller do jcxz to test failure
	WOWTrace "LocalLock: #AX"
cEnd

else
cProc	ILocalLock,<PUBLIC,FAR>
;	parmW   h
cBegin	nogen
	mov	bx,sp			; Get handle parameter from stack
	mov	bx,SS:[bx+4]
	mov	ax,bx			; Return in AX
	test	bl,LA_MOVEABLE		; Test for moveable (also null)
	jz	lock2			; Return if not moveable or null
	test	[bx].lhe_flags,LHE_DISCARDED  ; Return zero if discarded
	jnz	lock1
	inc	[bx].lhe_count		; Increment usage count
	jz	lock3			; Special case if overflow
lock1:
	mov	ax,[bx].lhe_address	; Return true address in AX or zero
lock2:	mov	cx,ax			; Let caller do jcxz to test failure
	ret	2
lock3:
	dec	[bx].lhe_count		; Ooops, keep pinned at max value
	jmp	lock1

cEnd nogen
endif


if KDEBUG
cProc	ILocalUnlock,<PUBLIC,FAR>,<si>
	parmW   h
cBegin
	WOWTrace "LocalUnlock(#AX)",<<ax,h>>
;	CheckHeap   LocalUnlock
	mov	si,h
	call	ldref			; SI = handle table entry
	jz	unlock1			; Done if invalid handle or discarded
	xor	ax,ax
	or	si,si
	jz	unlock1			; or if not moveable

	or	ch, ch
	jz	unlockerr
	dec	ch			; Decrement usage count
	cmp	ch,0FFh-1		; 0 -> ff, ff -> fe
	jae	unlock1			; Return if pinned or already unlocked
	mov	[si].lhe_count,ch
;	mov	ax,bx
	mov	al,ch
	cbw
	jmps	unlock1
unlockerr:
	xor	cx,cx
	kerror	ERR_LMEMUNLOCK,<LocalUnlock: Object usage count underflow>,cx,h
	xor	ax,ax
unlock1:
	mov	cx,ax			; Let caller do jcxz to test failure
	WOWTrace "LocalUnlock: #AX"
cEnd

else
cProc	ILocalUnlock,<PUBLIC,FAR>
;	parmW   h
cBegin	nogen
	mov	bx,sp			; Get handle parameter from stack
	mov	bx,SS:[bx+4]
	xor	ax,ax
	test	bl,LA_MOVEABLE		; Test for moveable (also null)
	jz	unlock1			; Return if not moveable or null
	mov	cx,word ptr [bx].lhe_flags
	errnz	<2-lhe_flags>
	errnz	<3-lhe_count>
	and	cl,LHE_DISCARDED
	jnz	unlock1			; Return if discarded
	dec	ch			; Decrement usage count
	cmp	ch,0FFh-1		; 0 -> ff, ff -> fe
	jae	unlock1			; Return if pinned or already unlocked
	mov	[bx].lhe_count,ch
;	mov	ax,bx
	mov	al,ch
	cbw
unlock1:
	mov	cx,ax			; Let caller do jcxz to test failure
	ret	2
cEnd nogen
endif



cProc	LocalHandle,<PUBLIC,FAR>
;	parmW   h
cBegin	nogen
	mov	bx,sp
	mov	bx,SS:[bx+4]
	test	bl,LA_MOVEABLE
	jz	lh1
	mov	ax,bx
	mov	bx,[bx-SIZE LocalArena].la_handle
	cmp	[bx].lhe_address,ax
	je	lh1
	xor	bx,bx
lh1:
	mov	ax,bx
	ret	2
cEnd	nogen


cProc	LocalCompact,<PUBLIC,FAR>,<si,di>
	parmW   minBytes
cBegin
	CheckHeap   LocalCompact
	call	lenter			; About to modify memory arena
	jcxz	lc_ok
	xor	ax, ax
	jmp	lc_crit
lc_ok:
	mov	bx,minBytes
	clc
	call	lalign
	call	lcompact
	or	ax,ax
	jz	compact1
	sub	ax,SIZE LocalArena	; Reduce available size by header size
compact1:
	call	lleave			; Arena is consistent now
lc_crit:
cEnd


cProc	LocalShrink,<PUBLIC,FAR>,<si,di>
	parmW  hseg
	parmW  wsize
cBegin
	mov	ax,hseg
	or	ax,ax			; use heap in current DS ?
	jz	ls_useds		; yes

; Use the segment handle passed
	push	ax
	call	GlobalHandle
	or	ax,ax			; valid handle ?
	jz	ls_errexit		; no....
	mov	ds,dx			; set the proper DS
ls_useds:
; check the heap and lock it
	CheckHeap   LocalShrink
	call	lenter			; About to modify memory arena
	jcxz	ls_ok
	xor	ax, ax
	jmp	short ls_crit
ls_ok:

	mov	bx,wsize		; get requested min size
	call	lshrink 		; Let's get small
; AX = new local heap size
	call	lleave			; Arena is consistent now
ls_crit:
ls_errexit:

cEnd


cProc	LocalNotifyDefault,<PUBLIC,FAR>,<si,di>
	parmW   msg
	parmW	handle		; or largest free block
	parmW   arg1
cBegin
	mov	ax,msg
	or	ax,ax
	jnz	dlnexit1
	cCall	GlobalHandle,<ds>
	or	ax,ax
	jz	dlnexit1
			; Fix for FORMBASE who uses a fixed
			; segment for a local heap.  This blows
			; up if we cause the calling segment
			; to be discarded since the DS saved by
			; Local???? is a fixed segment which
			; SearchStack can't handle.  Confused?
			; This was not a problem in 2.x because
			; 2.x failed to grow a fixed object.
			; Using a fixed segment for a local heap
			; is not valid and this is really a problem
			; with FORMBASE.
	mov	si,ax
	cCall	GlobalFlags,<si>	; Get flags
	xchg	ah, al
	push	ax
	cCall	GlobalSize,<si>
	sub	ax, handle		; Temorarily subtract out largest free
	pop	bx			; Get flags in BX
	xor	cx,cx
	add	ax,arg1
	adc	dx,cx			; Fail if DS attempts to grow
	jnz	dln_too_large		;  beyond 64k.
	add	ax,18h			; since li_extra isn't guaranteed
	adc	dx,cx
	jnz	dln_too_large
	add	ax,[di].li_extra
	adc	dx,cx			; Fail if DS attempts to grow
	jnz	@F			;  beyond 64k.
	add	ax, handle		; add back largest free
	adc	dx, cx					       
	jnz	@F
	cmp	ax,0FFF0h
	jbe	dln0
@@:	mov	ax,0FFF0h
	xor	dx,dx
	jmps	dln0
dln_too_large:
	xor	ax,ax
dlnexit1:
	jmp	dlnexit
dln0:
	test	si,GA_FIXED		; Is DS fixed?
	jnz	dln1			; Yes, must grow in place
	cmp	bh,1			; No, is lock count 1?
	jne	dln1			; No must grow in place if locked
	or	cl,GA_MOVEABLE		; Yes, okay to move even though locked
dln1:
	push	bx
grow_DS:
	cCall	GlobalReAlloc,<si,dxax,cx>
	pop	bx
	jcxz	dlnexit
	push	bx
	cCall	GlobalSize,<ax>

	or	dx,dx			; Did we get rounded up >= 64K?
	jz	@F			; No, OK
	mov	ax,0FFFFh		 ; This only happens under 386pmode
@@:
	mov	bx,ax
	sub	bx,la_freefixedsize
	and	bl,LA_MASK
	mov	di,ds:[pLocalHeap]
	mov	si,[di].hi_last
	mov	[bx].la_next,bx
	mov	[bx].la_prev,si
	or	byte ptr [bx].la_prev,LA_BUSY
	mov	[si].la_next,bx

; Maintain the free list.

	mov	ax,[si].la_free_prev
	mov	[bx].la_free_prev,ax
	mov	[bx].la_free_next,bx
	mov	[bx].la_size,WORD PTR la_freefixedsize
	push	si
	mov	si,ax
	mov	[si].la_free_next,bx
	pop	si

	mov	[di].hi_last,bx
	inc	[di].hi_count
	mov	bx,si
	call	lfree

;   Don't do this... (bobgu 8/4/87)
;	stc
;	call	lalign
;	call	lcompact

	mov	ax,1
	pop	bx
	mov	ax,1
dlnexit:
cEnd

cProc   LocalNotifyDib,<PUBLIC,FAR>,<si,di>
	parmW   msg
	parmW	handle		; or largest free block
	parmW   arg1
cBegin
	mov	ax,msg
	or	ax,ax
        jnz     dlnexit1dib
	cCall	GlobalHandle,<ds>
	or	ax,ax
        jz      dlnexit1dib
			; Fix for FORMBASE who uses a fixed
			; segment for a local heap.  This blows
			; up if we cause the calling segment
			; to be discarded since the DS saved by
			; Local???? is a fixed segment which
			; SearchStack can't handle.  Confused?
			; This was not a problem in 2.x because
			; 2.x failed to grow a fixed object.
			; Using a fixed segment for a local heap
			; is not valid and this is really a problem
			; with FORMBASE.
	mov	si,ax
	cCall	GlobalFlags,<si>	; Get flags
	xchg	ah, al
	push	ax
	cCall	GlobalSize,<si>
	sub	ax, handle		; Temorarily subtract out largest free
	pop	bx			; Get flags in BX
	xor	cx,cx
	add	ax,arg1
	adc	dx,cx			; Fail if DS attempts to grow
        jnz     dib_too_large           ;  beyond 64k.
	add	ax,18h			; since li_extra isn't guaranteed
	adc	dx,cx
        jnz     dib_too_large
	add	ax,[di].li_extra
	adc	dx,cx			; Fail if DS attempts to grow
	jnz	@F			;  beyond 64k.
	add	ax, handle		; add back largest free
	adc	dx, cx					       
	jnz	@F
	cmp	ax,0FFF0h
        jbe     dln0dib
@@:	mov	ax,0FFF0h
	xor	dx,dx
        jmps    dln0dib
dib_too_large:
	xor	ax,ax
dlnexit1Dib:
        jmp     dlnexitdib
dln0dib:
	test	si,GA_FIXED		; Is DS fixed?
        jnz     dln1dib                 ; Yes, must grow in place
	cmp	bh,1			; No, is lock count 1?
        jne     dln1dib                 ; No must grow in place if locked
	or	cl,GA_MOVEABLE		; Yes, okay to move even though locked
dln1dib:
	push	bx
        cCall   DibReAlloc,<ds,ax>
        or      ax,ax
        jz      dlnexitdib0
        cCall   GlobalSize,<si>

	or	dx,dx			; Did we get rounded up >= 64K?
	jz	@F			; No, OK
	mov	ax,0FFFFh		 ; This only happens under 386pmode
@@:
	mov	bx,ax
	sub	bx,la_freefixedsize
	and	bl,LA_MASK
	mov	di,ds:[pLocalHeap]
	mov	si,[di].hi_last
	mov	[bx].la_next,bx
	mov	[bx].la_prev,si
	or	byte ptr [bx].la_prev,LA_BUSY
	mov	[si].la_next,bx

; Maintain the free list.

	mov	ax,[si].la_free_prev
	mov	[bx].la_free_prev,ax
	mov	[bx].la_free_next,bx
	mov	[bx].la_size,WORD PTR la_freefixedsize
	push	si
	mov	si,ax
	mov	[si].la_free_next,bx
	pop	si

	mov	[di].hi_last,bx
	inc	[di].hi_count
	mov	bx,si
	call	lfree

;   Don't do this... (bobgu 8/4/87)
;	stc
;	call	lalign
;	call	lcompact


        mov     ax,1
dlnexitdib0:
	pop	bx
dlnexitdib:
cEnd

sEnd	CODE

externFP Far_lalign
externFP Far_lrepsetup
if KDEBUG
externFP Far_lfillCC
endif

sBegin	NRESCODE
assumes CS,NRESCODE
assumes DS,NOTHING
assumes ES,NOTHING

cProc	ILocalNotify,<PUBLIC,FAR>
;	parmD   lpProc
cBegin	nogen
	mov	bx,sp
	mov	ax,SS:[bx+4]
	mov	dx,SS:[bx+6]
	mov	bx,ds:[pLocalHeap]
	xchg	word ptr [bx].li_notify,ax
	xchg	word ptr [bx].li_notify+2,dx
	ret	4
cEnd	nogen


cProc	LocalInit,<PUBLIC,FAR>,<ds,si,di>
	parmW	pseg
	parmW	pstart
	parmW	pend
cBegin

; Init current DS if none passed.

	mov	cx,pseg
	jcxz	li1
	mov	ds,cx
li1:

; Place local arena info at the beginning

	mov	bx,pstart
	or	bx,bx
	jnz	li2
	cCall	GlobalSize,<ds>

; Here we must do a little checking... The global memory manager may have
;  rounded up the size on us so that the DS is >=64K! If this has happened,
;  we can simply ignore the extra (since app can't look  at it anyway) and
;  pretend the DS is actually 0000FFFFH bytes big.

	or	dx,dx			; Did we get rounded up >= 64K?
	jz	li1a			; No, OK
	mov	ax,0FFFFH		; Pretend heap is 64K-1
li1a:
	mov	bx,ax
	dec	bx
	xchg	pend,bx
	sub	bx,pend
	neg	bx			; BX = first byte in arena
li2:
	clc
	call	Far_lalign
	mov	bx,dx			; DX = addr of first block to use

; OK, so here's how it works... In order to keep a free block list, there
; are 4 blocks allocated initially.  First is a dummy marker block that is
; free but marked busy.  Second is the local arena information block which
; is a standard busy block.  Third is the really big free block.  And lastly
; is another busy type free block.  All free blocks have an extended header
; in order to keep a free block list.

; Reserve room for the first free busy block.

	lea	bx,[bx].la_freefixedsize ; move over first free block
	push	dx			; preserve first free block address
	clc
	call	Far_lalign
	mov	bx,dx			; BX = arena info block address
	pop	dx			; DX = first block address
	push	dx			; * Save the address of the first
	push	bx			; * two block on the stack for later

; DI = client address of info block.

	lea	di,[bx].la_fixedsize
	xor	ax,ax			; Zero local arena info
	mov	cx,pend
	cmp	bx,cx			; start > end?

;;;;;;; jae	lix
	jb	li21
	pop	dx			; clean up the stack first
	pop	dx
	jmp	lix
li21:
	sub	cx,di
	call	Far_lrepsetup
	push	di
	rep	stosw
	pop	di
	lea	bx,[di].SIZE LocalInfo
if KDEBUG
	mov	[di].hi_pstats,bx
	add	bx,SIZE LocalStats

ifdef DISABLE

; Set the heap checking flag.

	push	es
	push	dx
	cCall	GlobalMasterHandle
	mov	es,dx
	mov	ax,es:[hi_check]
	pop	dx
	pop	es
else
        push    es
        push    _DATA
        pop     es
assumes es,DATA
;
; hi_check = 0;
; if (DebugOptions & DBO_CHECKHEAP)
; {
;    hi_check = 1
;    if (DebugOptions & DBO_CHECKFREE)
;       hi_check = 2;
; }
;
        xor     ax,ax
        test    es:DebugOptions,DBO_CHECKHEAP
        jz      @F
        inc     ax
        test    es:DebugOptions,DBO_CHECKFREE
        jz      @F
        inc     ax
@@:
assumes es,NOTHING
        pop     es
endif
	mov	[di].hi_check,ax
endif

; set the rest of the heap info

	mov	byte ptr [di].hi_hdelta,32
	mov	byte ptr [di].hi_count,4
	mov	[di].hi_first,dx
	mov	word ptr [di].li_notify,codeOFFSET LocalNotifyDefault
	mov	word ptr [di].li_notify+2,codeBASE
	mov	word ptr [di].hi_hexpand,codeOFFSET lhexpand
	mov	[di].li_extra,512
	mov	[di].li_sig,LOCALHEAP_SIG

; Move SI to first aligned block after info record

	clc
	call	Far_lalign
	mov	si,dx

; Move BX to last aligned block at end of local heap

	mov	bx,pend			; BX = end address
	sub	bx,la_freefixedsize	; Make room for an arena header
	and	bl,LA_MASK		; Align downwards to 4 byte boundary

	cmp	bx, si			; If heap is too small, the
	ja	@f			;   supposed free block could be
	xor	ax, ax			;   beyond the end block
	jmp	lix
@@:

; Setup reserved pointer in DS to point to LocalInfo

	mov	[di].hi_last,bx
	mov	ds:[pLocalHeap],di

; Finish linking entries in the local heap.
;
;	DX = address of the first arena block.	Free busy marker.
;	DI = address of the element which contains the local heap
;	 information struc.
;	SI = address of large free block that is the initial heap.
;	BX = address of a zero length arena element that is used to
;	     mark the end of the local heap.
;
;
; This last arena element is always busy, with a length of
; zero.  This allows us to always calculate the length of an
; arena entry by subtracting the address of the arena element
; from the hi_next field of the arena element (see lsize subr)

	pop	di			; Get the address of the first two
	pop	dx			; ... blocks off the stack

; Setup first block in arena, busy free block.

	xchg	bx,dx			;bx = first block (temporarily)
	lea	ax,[bx+LA_BUSY]		; ...as a busy block
	mov	[bx].la_prev,ax		; point to self
	mov	[bx].la_next,di		; point to next
	mov	[bx].la_free_prev,bx	; previous free block is self
	mov	[bx].la_free_next,si	; next free is large block
	mov	[bx].la_size,WORD PTR la_freefixedsize ; set the block size
	xchg	bx,dx			; back to normal

; Setup block that contains info structure.

	xchg	dx,bx
	lea	ax,[bx+LA_BUSY]		; ...as a busy block
	xchg	dx,bx
	mov	[di].la_prev,ax		; point to previous block
	mov	[di].la_next,si		; point to next block

; Setup large free block with extended free block header.

	mov	[si].la_prev,di		; Point middle block to first and
	mov	[si].la_next,bx		;  last blocks
	mov	[si].la_free_prev,dx	; previous free block
	mov	[si].la_free_next,bx	; next free block
	mov	ax,bx
	sub	ax,si
	mov	[si].la_size,ax		; length of free block

if KDEBUG
	xchg	si,bx			; BX = large free block
	call	Far_lfillCC		; Fill with 0CCh
	xchg	si,bx
endif

; Setup last free block with extended header.

	mov	[bx].la_next,bx		; Point last block to middle and itself
	lea	ax,[si+LA_BUSY]		; ...as a busy block
	mov	[bx].la_prev,ax
	mov	[bx].la_free_prev,si	; previous free block
	mov	[bx].la_free_next,bx	; next free block is self
	mov	[bx].la_size,WORD PTR la_freefixedsize ; set the block size

; Set the minimum size in arena header.

	mov	bx,ds:[pLocalHeap]
	mov	ax,[bx].hi_last
	add	ax,SIZE LocalArenaFree
	sub	ax,[bx].hi_first
	mov	[bx].li_minsize,ax

	cCall	GlobalLock,<ds>		; Make moveable DS initially locked.
					; (see LocalNotifyDefault)
	mov	al,1
lix:
	mov	cx,ax
cEnd


;-----------------------------------------------------------------------;
; LocalCountFree							;
; 									;
; Return the count of free bytes in the local heap.  This was motivated	;
; by the InitApp routines that want at least 4K available to continue	;
; the app running.							;
; 									;
; Arguments:								;
;	DS = heap segment						;
;									;
; Returns:								;
;	AX = free bytes in local heap					;
;									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
;	all								;
;									;
; Registers Destroyed:							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Sat Aug 15, 1987 04:35:55p  -by-  Bob Gunderson [bobgu]		;
; Wrote it.								;
;-----------------------------------------------------------------------;


cProc	LocalCountFree,<PUBLIC,FAR>
cBegin nogen
	push	di
	push	si
	mov	di,pLocalHeap
	lea	si, [di].li_sig
	cCall	FarValidatePointer,<ds,si>
	or	ax, ax			; OK pointer?
	jz	countexit		;   no, just exit
	xor	ax,ax			; start with 0 bytes free
	cmp	[di].li_sig, LOCALHEAP_SIG	
	jne	countexit		;   No local heap!!
	mov	si,[di].hi_last 	; sentenal block
	mov	di,[di].hi_first	; arena header
	mov	di,[di].la_free_next	; first free block
countloop:
	cmp	di,si
	jz	countexit
	add	ax,[di].la_size 	; count size of this block
	sub	ax,SIZE LocalArenaFree	; less block overhead
	mov	di,[di].la_free_next	; next free block
	jmp	countloop
countexit:
	pop	si
	pop	di
	ret
cEnd nogen



;-----------------------------------------------------------------------;
; LocalHeapSize								;
; 									;
; Return the # bytes allocated to the local heap.			;
; 									;
; Arguments:								;
;	DS = heap segment						;
; 									;
; Returns:								;
;	AX = size of local heap						;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
;	CX,DX,SI,SI,DS,ES						;
; 									;
; Registers Destroyed:							;
; 	BX								;
;									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Sat Aug 15, 1987 04:35:55p  -by-  Bob Gunderson [bobgu]		;
; Wrote it.								;
;-----------------------------------------------------------------------;


cProc	LocalHeapSize,<PUBLIC,FAR>
cBegin nogen
	mov	bx,pLocalHeap
	mov	ax,[bx].hi_last
	sub	ax,[bx].hi_first
	ret
cEnd nogen


;-----------------------------------------------------------------------;
; LocalHandleDelta							;
; 									;
; Change the number of handles to allocate each time			;
; 	     								;
; Arguments:								;
;	delta = new # of handles or 0					;
;	DS = heap segment      						;
; 									;
; Returns:								;
;	AX = new number of handles					;
; 	     								;
; Error Returns:							;
; 									;
; Registers Preserved:							;
;	CX,DX,SI,SI,DS,ES						;
; 									;
; Registers Destroyed:							;
; 	BX								;
;									;
; Calls:								;
; 									;
; History:								;
; 									;
;-----------------------------------------------------------------------;


cProc	LocalHandleDelta,<PUBLIC,FAR>
	parmW 	delta
cBegin
	mov	bx,pLocalHeap
	mov	ax, delta
	or	ax, ax			; Zero means return present value
	jz	return_present_value
	mov	ax, delta
	mov	[bx].hi_hdelta, ax	; Set new value
return_present_value:
	mov	ax, [bx].hi_hdelta
cEnd
    
sEnd	NRESCODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\lstring.asm ===
TITLE   LSTRING

include kernel.inc
include gpfix.inc
include wowcmpat.inc

DataBegin

externB fFarEast		; non zero if far eastern keyboard
externB KeyInfo			; Info returned by KEYBOARD.Inquire
ifdef	FE_SB
externB fDBCSLeadTable	    ; DBCS Lead byte flag array
endif

DataEnd

sBegin  CODE
assumes CS,CODE
assumes DS,NOTHING
assumes ES,NOTHING

ifdef WOW
externNP MyGetAppWOWCompatFlags
endif
externD pStringFunc	    ; Entry point of string functions in USER.


; Function codes for all the string functions in USER
;
ANSINEXT_ID	equ	1
ANSIPREV_ID	equ	2
ANSIUPPER_ID	equ	3
ANSILOWER_ID	equ	4

;
; lstrlen: Same as strlen except for taking long ptrs
;

cProcVDO lstrlen,<PUBLIC,FAR>
;       parmD   pStr
cBegin  nogen
	mov     bx,sp
	push    di
beg_fault_trap  sl_trap
	les     di,ss:[bx+4]
	cld
	xor     ax,ax			; get zero in ax
	mov     cx,-1			; at most 64 k to move
	repnz   scasb			; look for end
	mov     ax,cx
	neg     ax
	dec     ax
	dec     ax
end_fault_trap
sl_exit:
	pop     di
	ret     4
cEnd    nogen

sl_trap:
	fault_fix_stack
	xor     ax,ax
	jmp     sl_exit

lstr_trap:
	fault_fix_stack

lstrfinish  proc    far
	pop     di
	pop     si
	pop     ds
	ret     8
lstrfinish  endp


; lstrcpyn - lstrcpy with a limit length -- NEVER null-padded, but ALWAYS
; null-terminated.
cProc   lstrcpyn,<PUBLIC,FAR>,<ds,si,di>
        parmD   pDst
        parmD   pSrc
        parmW   wLen
cBegin
        xor     dx,dx
        jmp     lstrn
cEnd	nogen

; lstrcatn - lstrcat with a limit length -- NEVER null-padded, but ALWAYS
; wLen is the pDst buffer size
cProc	lstrcatn,<PUBLIC,FAR>,<ds,si,di>
        parmD   pDst
        parmD   pSrc
        parmW   wLen
cBegin
        mov     dx,1
lstrn:
        mov     bx, [wLen]
        or	bx, bx
        jz	lstrn_err1
beg_fault_trap  lstrn_err
        cld
        les     di, [pSrc]              ; Find length of source string
        mov     cx, -1
        xor     ax, ax
        repnz   scasb
        not     cx                      ; length now in CX (incl null term)

        lds     si, [pSrc]              ; Set up for copy
        les     di, [pDst]

        cmp     dx,0                    ; check for lstrcatn or lstrcpyn
        je      lstrn_prepcopy
        push    cx                      ; Store source string length
        xor     ax,ax                   ; get zero in ax
        mov     cx,-1                   ; at most 64 k to look
        repnz   scasb                   ; look for end
        not     cx
        mov     ax, cx
        pop     cx
        cmp     bx, ax
        jle     lstrn_finish
        dec     di                      ; Point at null byte
        dec     ax                      ; remove null terminator
        sub     bx, ax
lstrn_prepcopy:
        cmp     cx, bx                  ; Check destination length
        jbe     lstrn_copy
        mov     cx, bx
lstrn_copy:
        xor     ax,ax           ; do we really need this ??
        dec     cx                      ; save space for null
        shr     cx, 1                   ; Copy the string
        rep     movsw
        adc     cx, cx
        rep     movsb

        stosb                           ; null terminate string

end_fault_trap
lstrn_finish:
        mov     ax, [OFF_pDst]          ; ptr to dest in DX:AX
        mov     dx, es
lstrn_exit:
cEnd

lstrn_err:
        fault_fix_stack
        krDebugOut      DEB_ERROR, "GP fault in lstrcatn / lstrcpyn"
lstrn_err1:
        xor     ax, ax
        cwd
        jmps    lstrn_exit


lstrsetup:
	pop     dx
	mov     bx,sp

	push    ds
	push    si
	push    di

beg_fault_trap  lstr_trap
	lds     si,ss:[bx+4]
	les     di,ss:[bx+8]
	cld
	jmp     dx
;
;lstrcpy: strcpy with long pointers
;
cProcVDO lstrcpy,<PUBLIC,FAR>
;       parmD   pDst			; [bx+8]
;       parmD   pSrc			; [bx+4]

cBegin  nogen
	call    lstrsetup
        mov     dx,di                   ; save for return

lcp1:   lodsb
	stosb
	or      al,al
	jnz     lcp1

        xchg    ax,dx                   ; return ds:ax = original dest
        mov     dx,es
	jmp     lstrfinish
cEnd    nogen


;
;lstrcat: Same as strcat except with long ptrs.
;
cProcVDO lstrcat,<PUBLIC,FAR>
;   parmD   pDst
;   parmD   pSrc

cBegin  nogen
	call    lstrsetup
        mov     dx,di                   ; save original dest for return
	xor     ax,ax			; get zero in ax
	mov     cx,-1			; at most 64 k to look
	repnz   scasb			; look for end
	dec     di			; Point at null byte
ifndef WOW
	jmp     lcp1			; jump to lstrcpy loop
else
lcp1_wow:   lodsb
	stosb
	or      al,al
	jnz     lcp1_wow

        ; normal lstrcat is now complete.
        ;
        ; Now begins a GROSS HACK HACK HACK for fixing wordperfect
        ; For compatibility reasons we want to check if the function call
        ; was of type lstrcat(lpsz, ".WRS");
        ;
        ; the checks are:
        ;                 let lpDest = ".WRS"
        ;                 if (lstrlen(lpDest)+NULLCHAR == 5) &&
        ;                     !lstrcmp(lpDest, ".WRS")) {
        ;                     if (wordperfect) {
        ;                        remove all backslashes in lpsz
        ;                     }
        ;                 }
        ;
        ; we do these checks after the concatenation 'cause it means that
        ; source string is valid and we wont GP fault while accessing the
        ; source string
        ;                                                - Nanduri

        sub     si, 5
        cmp     si, ss:[bx+4]
        jnz     @F
        cmp     [si], 'W.'    ; ".W"
        jnz     @F
        cmp     [si+2], 'SR'  ; "RS"
        jnz     @F

lscat_DOTWRS:
        ; here if lstrcat (lpString, ".WRS")
        ; now make sure that it is wordperfect. this is a gross hack so
        ; why care for efficiency.

        push dx
        call MyGetAppWOWCompatFlags
        test dx, word ptr cs:[gacf_dotwrs+2]
        pop  dx
        jz   @F
        jmp  short replace_slashes

gacf_dotwrs:
        DD WOWCF_SANITIZEDOTWRSFILES

replace_slashes:

        ; yes it is. strip backslashes if any.
        ; if there are any backslashes the lpString would be of the form
        ; \\blahblah or \\blah\blah. note that 'blah' is not important, the
        ; backslashes are.
        ;

        push    es
        pop     ds
        mov     si, dx
        mov     di, dx
slash_a_slash:
        lodsb
        cmp al, '\'
        je slash_a_slash
        stosb
        or  al, al
        jnz slash_a_slash
@@:
        xchg    ax,dx                   ; return ds:ax = original dest
        mov     dx,es
	jmp     lstrfinish
endif


cEnd    nogen

;
;lstrOriginal: This is language independent version of lstrcmp
;  specially made for kernel.
;           (i made it case insensitive...chrisp)
;
cProcVDO lstrOriginal,<PUBLIC,FAR>
;       parmD   ps1
;       parmD   ps2
cBegin  nogen
	call    lstrsetup
lcmploop:
	xor     ax,ax
	cmp     es:byte ptr [di],al
	jz      ldidone			; left hand side finished <=
	cmp     byte ptr [si],al
	jz      lsismall		; right hand side finished, >
	lodsb
ifdef FE_SB
	call    MyIsDBCSLeadByte
	jc      cmp1
	mov     ah,ds:[si]
	inc     si
	jmp     short cmp2
endif
cmp1:   call    MyLower
	xor     ah,ah

cmp2:   mov     bx,ax
	mov     al,es:[di]
	inc     di
ifdef FE_SB
	call    MyIsDBCSLeadByte
	jc      cmp3
	mov     ah,es:[di]
	inc     di
	jmp     short cmp4
endif
cmp3:   call    MyLower
	xor     ah,ah

cmp4:   cmp     ax,bx			; effectlively es:[di],ds:[si]
	jz      lcmploop		; still equal
	mov     ax,0			; preverve flags
	jb      ldismall		; di is less than si
lsismall:
	inc     ax
	jmp     short lstrcmpend
ldidone:
	cmp     byte ptr ds:[si],0
	jz      lequal
ldismall:
	dec     ax
lequal:
lstrcmpend:
	jmp     lstrfinish
cEnd    nogen

end_fault_trap

;--------------------------------------------------------
;
;  ANSI compatible string routines
;

	public	AnsiUpper, AnsiLower, AnsiPrev, AnsiNext

AnsiUpper:
	mov     cl,ANSIUPPER_ID
	jmpnext
AnsiLower:
	mov     cl,ANSILOWER_ID
	jmpnext
AnsiPrev:
	mov     cl,ANSIPREV_ID
	jmpnext
AnsiNext:
	mov     cl,ANSINEXT_ID
	jmpnext end

	xor	ch,ch
	cmp	pStringFunc.sel,0	; Is there a USER around?
	jz	no_user_function
	jmp	pStringFunc

no_user_function:
if KDEBUG
	int	3
endif
	cmp	cl,ANSIPREV_ID
	jz	@F
	retf	4
@@:	retf	8

;----------------------------------------------------------------------------
; MyUpper: Called from LDSelf.ASM
; convert lower case to upper, must preserve es,di,cx
;---------------------------------------------------------------------------

	public  MyUpper
MyUpper:
	cmp     al,'a'
	jb      myu2
	cmp     al,'z'
	jbe     myu1
ifdef FE_SB
	push	ds
	SetKernelDS
	cmp	[fFarEast],1	; Far east ?
	pop	ds
	UnSetKernelDS
	jge	myu2		; yes do nothing to the Microsoft fonts.
endif
	cmp     al,0E0H		; this is lower case a with a back slash
	jb      myu2
	cmp	al, 0F7H ; This is division mark in Microsoft fonts; So, don't
	je	myu2	 ; convert this; Fix for Bug #1356 -SANKAR-08-28-89;
	cmp     al,0FEH
	ja      myu2
myu1:   sub     al,'a'-'A'
myu2:   ret

;----------------------------------------------------------------------------
; MyLower:  Called from Atom.asm, LdOpen.asm, ldUtil.asm, ldself.asm
; convert upper case to lower, must preserve es,di,cx
;----------------------------------------------------------------------------
	public  MyLower
MyLower:
	cmp     al,'A'
	jb      myl2
	cmp     al,'Z'
	jbe     myl1

	push	ds
	SetKernelDS
	cmp	[fFarEast],1	; this is a far east kbd 1/12/87 linsh
	pop	ds
	UnSetKernelDS
	jge	myl2		; yes do nothing to the 0C0H - 0DEH range

	cmp     al,0C0H		; this is lower case a with a back slash
	jb      myl2

	cmp	al, 0D7H ; This is multiply mark in Microsoft fonts; So, don't
	je	myl2	 ; translate this; Fix for Bug #1356;-SANKAR-08-28-89;

	cmp     al,0DEH
	ja      myl2
myl1:   add     al,'a'-'A'
myl2:   ret


;-----------------------------------------------------------------------;
; IsDBCSLeadByte							;
;
; This Function will be exist on US Windows, but it
; returns FALSE always.
;
;-----------------------------------------------------------------------;

cProc	IsDBCSLeadByte,<PUBLIC,FAR>
;	parmW	char	ss:[bx+04]
cBegin	nogen
ifdef FE_SB
	mov	bx,sp
	push	ds
	SetKernelDS
;;	push	di
;;
;;	mov	ax,ss:[bx+04]
;;	call	MyIsDBCSLeadByte
;;	jnc	id1
;;	xor	ax,ax
;;	jmp	idx
;;id1:	mov	ax,1
;;idx:
;;
;;	pop	di
	mov	al, byte ptr ss:[bx+4]
	mov	bx, offset fDBCSLeadTable
	xlat
	xor	ah,ah
	pop	ds
	UnSetKernelDS
else
	xor	ax,ax
endif
	ret	2
cEnd	nogen


ifdef FE_SB

; This API returns DBCS lead byte table for applications which
; in turn can speed up DBCS checking without making calls to
; IsDBCSLeadByte.
;-----------------------------------------------------------------------;
; GetDBCSEnv								;
;
; int GetDBCSEnv(LPSTR lpsz, int cbMax)
; lpsz: long ptr points to buffer to receive DBCS lead byte table
; cbMax: how many bytes the buffer pointed to by lpsz.
;	 0 if inquire buffer size required to receive the table
; return (ax) 0 if failed else the size of the table.
; use:	AX, BX, CX, DX
;
;
;-----------------------------------------------------------------------;

;
cProc	GetDBCSEnv,<PUBLIC,FAR>
;	parmD	ss:[bx+6]		    ;lpsz
;	parmW	ss:[bx+4]		    ;cbMax
cBegin	nogen
	mov	bx,sp			    ;frame ptr
	push	es
	push	di
	push	si
;;; 12 bytes should be enough to accumulate our result.
;;; However, if fDBCSLeadTable corrupt then we are dead!!!!
	sub	sp,12			    ;temp private storage
	mov	si,sp			    ;
	SetKernelDS	es		    ;
	mov	di, offset fDBCSLeadTable   ;
	cld
	mov	al,1			    ;
	mov	cx,256			    ;256 bytes in table
GDE_loop:
	xor	al,1			    ;toggle the match pattern (0/1)
	repe	scasb			    ;
	jz	GDE_done		    ;not found then CX must be 0
	mov	ah,cl			    ;calc the index
	sub	ah,255
	neg	ah
	sub	ah,al			    ;
	mov	ss:[si],ah		    ;save it
	inc	si
	jmps	GDE_loop
GDE_done:
	mov	word ptr ss:[si],0	    ;terminated with 0,0
	mov	ax,si
	sub	ax,sp			    ;how many bytes we got?
	jz	GDE_Exit		    ;none, return
	add	ax,2			    ;count the terminated bytes
	inc	si			    ;and advance ptr to the last 0
	mov	cx,ss:[bx+4]		    ;get cbMax
	jcxz	GDE_Exit		    ;return if inquire buffer size
	cmp	cx,ax			    ;enough buffer provided ?
	jge	@F
	xor	ax,ax			    ;no, return error
	jmps	GDE_Exit

@@:
beg_fault_trap	GDE_gp
	les	di, ss:[bx+6]		    ;lpsz
	mov	cx,ax			    ;how many bytes to copy
	add	di,ax
	dec	di			    ;offset started from 0
	std
rep	movs	byte ptr [di],ss:[si]

end_fault_trap

GDE_Exit:
	cld
	UnSetKernelDS	es
	add	sp, 12
	pop	si
	pop	di
	pop	es
	ret	6
cEnd	nogen

GDE_gp:
	fault_fix_stack
	xor	ax, ax			    ;invalide lpsz, return ax=0
	jmps	GDE_Exit


;--------------------------------------------------------------------------
;
; return carry clear if character in AL is first byte of DBCS
;
;--------------------------------------------------------------------------
	public  MyIsDBCSLeadByte
MyIsDBCSLeadByte:
	push	ds
	SetKernelDS
	push	ax		; Save AX for caller
	push    bx		; Save BX for caller
	mov	bx, offset fDBCSLeadTable
	xlat
	shr	al,1		; refrect to carry flag
	cmc
	pop	bx
	pop	ax
;;	cmp	[fFarEast],1	; not in far east?
;;	jb	ikx		; carry set if not far east keyboard
;;	mov	cx,[KeyInfo].kbRanges.lo
;;	cmp	cl,ch
;;	ja	iknk		; lower range invalid, not kanji
;;	cmp	al,cl
;;	jb	ik1		; below lower range, try second range
;;	cmp	al,ch
;;	jbe	ikgk		; inside lower range, valid kanji char
;;
;;ik1:	mov	cx,[KeyInfo].kbRanges.hi
;;	cmp     cl,ch                                   ; valid upper range?
;;	ja      iknk                                    ; no, not kanji
;;	cmp     al,cl           ; is it within range?
;;	jb      ikx             ; trick...carry already set
;;	cmp     al,ch
;;	ja      iknk
;;ikgk:   clc                     ; within range...valid kanji char
;;	jmp     short ikx
;;
;;iknk:   stc
;;ikx:
;;	pop     cx
	pop	ds
	UnSetKernelDS
	ret

	public	FarMyIsDBCSLeadByte
FarMyIsDBCSLeadByte proc far
	call	MyIsDBCSLeadByte
	ret
FarMyIsDBCSLeadByte endp


	public	MyIsDBCSTrailByte
MyIsDBCSTrailByte   proc    near
;----------------------------------------------------------
; IsDBCSTrailByte
; Check if the indexed byte is a DBCS char trailing byte.
;
; Input:
; ES:SI = char	*ach[]
; ES:DI -> position of character of interested.
;
; Output:
; Carry flag clear if it is a DBCS trailing byte
; Carry flag set if it is a SBCS or DBCS leading byte
;
; Use:
; flags
;
;----------------------------------------------------------
	cmp	si,di			    ;if beginning >= index?
	jae	IDTB_Exit		    ;yes, SBCS or DBCS 1st (CF=1)

	push	si
	push	ax
	cld				    ;no chance
@@:
	lods	byte ptr es:[si]	    ;
	call	MyIsDBCSLeadByte
	cmc
	adc	si,0			    ;si++ if DBCS
	cmp	di,si			    ;hit the target yet?
	ja	@B			    ;go to loop if not yet
	pop	ax			    ;di=si, we have a SBCS or DBCS 1st
	pop	si			    ;di < si, we have a DBCS 2nd
IDTB_Exit:
	cmc
	ret
MyIsDBCSTrailByte   endp

;---------------------------------------------------------------
	public	FarMyIsDBCSTrailByte
FarMyIsDBCSTrailByte proc far
	call	MyIsDBCSTrailByte
	ret
FarMyIsDBCSTrailByte endp
endif	; FE_SB

sEnd    CODE
end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\lhandle.asm ===
TITLE	HANDLE - Handle Table Manager

include kernel.inc

; This code assumes the following conditions
;
errnz	<lhe_address>

DataBegin

;externW <pGlobalHeap,hGlobalHeap>

DataEnd

sBegin	CODE
assumes CS,CODE

; These are all of the internal subroutines defined in this source file.
;
;	PUBLIC	halloc, lhdref, henum


;-----------------------------------------------------------------------;
; halloc								;
;									;
; Allocates a local handle for a block.					;
;									;
; Arguments:								;
;	AX = block that needs a handle					;
;	DS:DI = address of local arena infomation structure		;
;									;
; Returns:								;
;	AX,BX,CX = handle for that block				;
;	DX preserved							;
;									;
; Error Returns:							;
;	AX = 0	if no handles available					;
;	DX = original AX						;
;									;
; Registers Preserved:							;
;	DI,SI,DS,ES							;
;									;
; Registers Destroyed:							;
;									;
; Calls:								;
;	nothing								;
;									;
; History:								;
;									;
;  Wed Oct 01, 1986 05:44:44p  -by-  David N. Weise   [davidw]		;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

cProc	halloc,<PUBLIC,NEAR>
cBegin nogen
	mov	bx,[di].hi_hfree
	or	bx,bx
	jnz	have_a_handle
	push	ax
	push	dx
	mov	cx,[di].hi_hdelta
	jcxz	hafail
	push	si
	push	es
	call	[di].hi_hexpand
	pop	es
	pop	si
	jcxz	hafail
	mov	bx,ax
	pop	dx
	pop	ax
have_a_handle:
	xor	cx,cx
	errnz	<lhe_flags - he_flags>
	mov	word ptr [bx].lhe_flags,cx	; Zero lock count and flags
	errnz	<lhe_count-lhe_flags-1>
	errnz	<lhe_link - he_link>
	xchg	[bx].lhe_link,ax		; Remove handle from head of chain
	errnz	<lhe_address-lhe_link>	; and store true address of object
	mov	[di].hi_hfree,ax	; Update head of handle free list
	mov	ax,bx			; Return handle to caller
	mov	cx,ax
	ret

hafail:
	xor	ax,ax
	pop	dx			; Flush stack
	pop	dx			; Return original AX in DX
	ret				; return error
cEnd nogen

;-----------------------------------------------------------------------;
; lhfree 								;
; 									;
; Frees the given local handle and returns a handle to the freelist.	;
; 									;
; Arguments:								;
;	SI = handle to free						;
; 									;
; Returns:								;
;	AX =  0 if valid handle						;
; 									;
; Error Returns:							;
;	AX = -1 if handle already free					;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
;	nothing								;
; 									;
; History:								;
; 									;
;  Tue Oct 14, 1986 04:14:25p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

cProc	lhfree,<PUBLIC,NEAR>
cBegin nogen
	or	si,si			; Ignore zero handles
	jz	hf1
	mov	ax,HE_FREEHANDLE	; Mark handle as free
	xchg	word ptr [si].lhe_flags,ax
	errnz	<2-lhe_flags>
	inc	ax			; Already free?
	jz	hf2			; Yes, return error
	errnz	<1+HE_FREEHANDLE>
	mov	ax,si			; Push handle on head of freelist
	xchg	[di].hi_hfree,ax
	mov	[si].lhe_link,ax
hf1:
	xor	ax,ax			; Return zero
	ret
hf2:
	dec	ax
	ret
cEnd nogen


;-----------------------------------------------------------------------;
; lhdref								;
; 									;
; Dereferences a local handle.						;
; 									;
; Arguments:								;
;	SI = handle							;
; 									;
; Returns:								;
;	AX = address of client data or zero for discarded objects	;
;	CH = lock count							;
;	CL = zero or LHE_DISCARDED flag					;
;	ZF = 1 AX = 0 and CL != 0					;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
;	nothing								;
; 									;
; History:								;
; 									;
;  Tue Oct 14, 1986 04:16:49p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

cProc	lhdref,<PUBLIC,NEAR>
cBegin nogen
	xor	ax,ax
	mov	cx,word ptr [si].lhe_flags
	errnz	<2-lhe_flags>
	errnz	<3-lhe_count>
	inc	cx
	jz	lhdref1
	errnz	<1+LHE_FREEHANDLE>
	dec	cx
	and	cl,LHE_DISCARDED
	jnz	lhdref1
	mov	ax,[si].lhe_address
lhdref1:
	or	ax,ax
	ret
cEnd nogen


;-----------------------------------------------------------------------;
; henum									;
; 									;
; Enumerates the allocated handles in the local handle table with the	;
; specified discard level.						;
; 									;
; Arguments:								;
;	SI = zero first time called.  Otherwise contains a pointer	;
;	     to the last handle returned.				;
;	CX = #handles remaining.  Zero first time called.		;
;	DI = address of local arena information structure.		;
; 									;
; Returns:								;
;	SI = address of handle table entry				;
;	CX = #handles remaining, including the one returned.		;
;	ZF = 1 if SI = 0 and no more handle table entries.		;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
;	AX								;
;									;
; Calls:								;
;	nothing								;
; 									;
; History:								;
; 									;
;  Tue Oct 14, 1986 04:19:15p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

cProc	henum,<PUBLIC,NEAR>
cBegin nogen
	or	si,si		    ; Beginning of enumeration?
	jnz	lcdhenext	    ; No, return next handle
	mov	ax,[di].hi_htable   ; Yes, start with last handle table block

lcdhtloop:
	mov	si,ax		    ; SI = address of handle table block
	or	si,si		    ; Any more handle table blocks?
	jz	lcdheall	    ; No, return zero
	lodsw			    ; Get # handles in this block
	errnz	ht_count
	mov	cx,ax		    ; into CX
lcdheloop:			    ; Loop to process each handle table entry
	mov	ax,word ptr [si].lhe_flags
	errnz	<lhe_flags - he_flags>
	errnz	<2-lhe_flags>
	errnz	<3-lhe_count>

	inc	ax		    ; Free handle?
	jz	lcdhenext	    ; Yes, skip this handle
	errnz	<1+LHE_FREEHANDLE>
	errnz	<LHE_FREEHANDLE - HE_FREEHANDLE >
	dec	ax

	cmp	[di].hi_dislevel,0  ; Enumerating all allocated handles?
	je	lcdheall	    ; Yes, return this handle

	test	al,LHE_DISCARDED    ; No, handle already discarded?
	jnz	lcdhenext	    ; Yes, skip this handle

	and	al,LHE_DISCARDABLE  ; Test if DISCARDABLE
	cmp	[di].hi_dislevel,al ; at the current discard level
	jne	lcdhenext	    ; No, skip this handle

	or	ah,ah		    ; Is handle locked?
	jnz	lcdhenext	    ; Yes, skip this handle

lcdheall:
	or	si,si		    ; No, then return handle to caller
	ret			    ; with Z flag clear

lcdhenext:
	lea	si,[si].SIZE LocalHandleEntry    ; Point to next handle table entry
	errnz	<LocalHandleEntry - HandleEntry>
	loop	lcdheloop	    ; Process next handle table entry
	lodsw			    ; end of this block, go to next
	jmp	lcdhtloop
cEnd nogen

sEnd	CODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\newexe.h ===
/*static char *SCCSID = "@(#)newexe.h:2.9";*/
/*
 *  Title
 *
 *      newexe.h
 *      Pete Stewart
 *      (C) Copyright Microsoft Corp 1984
 *      17 August 1984
 *
 *  Description
 *
 *      Data structure definitions for the DOS 4.0/Windows 2.0
 *      executable file format.
 *
 *  Modification History
 *
 *      84/08/17        Pete Stewart    Initial version
 *      84/10/17        Pete Stewart    Changed some constants to match OMF
 *      84/10/23        Pete Stewart    Updates to match .EXE format revision
 *      84/11/20        Pete Stewart    Substantial .EXE format revision
 *      85/01/09        Pete Stewart    Added constants ENEWEXE and ENEWHDR
 *      85/01/10        Steve Wood      Added resource definitions
 *      85/03/04        Vic Heller      Reconciled Windows and DOS 4.0 versions
 *      85/03/07        Pete Stewart    Added movable entry count
 *      85/04/01        Pete Stewart    Segment alignment field, error bit
 */

#define EMAGIC          0x5A4D          /* Old magic number */
#define ENEWEXE         sizeof(struct exe_hdr)
                                        /* Value of E_LFARLC for new .EXEs */
#define ENEWHDR         0x003C          /* Offset in old hdr. of ptr. to new */
#define ERESWDS         0x0010          /* No. of reserved words in header */
#define ECP             0x0004          /* Offset in struct of E_CP */
#define ECBLP           0x0002          /* Offset in struct of E_CBLP */
#define EMINALLOC       0x000A          /* Offset in struct of E_MINALLOC */

struct exe_hdr                          /* DOS 1, 2, 3 .EXE header */
  {
    unsigned short      e_magic;        /* Magic number */
    unsigned short      e_cblp;         /* Bytes on last page of file */
    unsigned short      e_cp;           /* Pages in file */
    unsigned short      e_crlc;         /* Relocations */
    unsigned short      e_cparhdr;      /* Size of header in paragraphs */
    unsigned short      e_minalloc;     /* Minimum extra paragraphs needed */
    unsigned short      e_maxalloc;     /* Maximum extra paragraphs needed */
    unsigned short      e_ss;           /* Initial (relative) SS value */
    unsigned short      e_sp;           /* Initial SP value */
    unsigned short      e_csum;         /* Checksum */
    unsigned short      e_ip;           /* Initial IP value */
    unsigned short      e_cs;           /* Initial (relative) CS value */
    unsigned short      e_lfarlc;       /* File address of relocation table */
    unsigned short      e_ovno;         /* Overlay number */
    unsigned short      e_res[ERESWDS]; /* Reserved words */
    long                e_lfanew;       /* File address of new exe header */
  };

#define E_MAGIC(x)      (x).e_magic
#define E_CBLP(x)       (x).e_cblp
#define E_CP(x)         (x).e_cp
#define E_CRLC(x)       (x).e_crlc
#define E_CPARHDR(x)    (x).e_cparhdr
#define E_MINALLOC(x)   (x).e_minalloc
#define E_MAXALLOC(x)   (x).e_maxalloc
#define E_SS(x)         (x).e_ss
#define E_SP(x)         (x).e_sp
#define E_CSUM(x)       (x).e_csum
#define E_IP(x)         (x).e_ip
#define E_CS(x)         (x).e_cs
#define E_LFARLC(x)     (x).e_lfarlc
#define E_OVNO(x)       (x).e_ovno
#define E_RES(x)        (x).e_res
#define E_LFANEW(x)     (x).e_lfanew

#define NEMAGIC         0x454E          /* New magic number */
#define NERESBYTES      0

struct new_exe                          /* New .EXE header */
  {
    unsigned short int  ne_magic;       /* Magic number NE_MAGIC */
    char                ne_ver;         /* Version number */
    char                ne_rev;         /* Revision number */
    unsigned short int  ne_enttab;      /* Offset of Entry Table */
    unsigned short int  ne_cbenttab;    /* Number of bytes in Entry Table */
    long                ne_crc;         /* Checksum of whole file */
    unsigned short int  ne_flags;       /* Flag word */
    unsigned short int  ne_autodata;    /* Automatic data segment number */
    unsigned short int  ne_heap;        /* Initial heap allocation */
    unsigned short int  ne_stack;       /* Initial stack allocation */
    long                ne_csip;        /* Initial CS:IP setting */
    long                ne_sssp;        /* Initial SS:SP setting */
    unsigned short int  ne_cseg;        /* Count of file segments */
    unsigned short int  ne_cmod;        /* Entries in Module Reference Table */
    unsigned short int  ne_cbnrestab;   /* Size of non-resident name table */
    unsigned short int  ne_segtab;      /* Offset of Segment Table */
    unsigned short int  ne_rsrctab;     /* Offset of Resource Table */
    unsigned short int  ne_restab;      /* Offset of resident name table */
    unsigned short int  ne_modtab;      /* Offset of Module Reference Table */
    unsigned short int  ne_imptab;      /* Offset of Imported Names Table */
    long                ne_nrestab;     /* Offset of Non-resident Names Table */
    unsigned short int  ne_cmovent;     /* Count of movable entries */
    unsigned short int  ne_align;       /* Segment alignment shift count */
    unsigned short int  ne_cres;        /* Count of resource segments */

#ifdef NEVER
    unsigned short int  ne_psegcsum;    /* offset to segment chksums */
#else
    unsigned char	ne_exetyp;	/* Target Operating system */
    unsigned char	ne_flagsothers;	/* Other .EXE flags */
#endif
    unsigned short int  ne_pretthunks;  /* offset to return thunks */
    unsigned short int  ne_psegrefbytes;/* offset to segment ref. bytes */
    unsigned short int  ne_swaparea;    /* Minimum code swap area size */
    unsigned short int  ne_expver;      /* Expected Windows version number */
  };

#define NE_MAGIC(x)     (x).ne_magic
#define NE_VER(x)       (x).ne_ver
#define NE_REV(x)       (x).ne_rev
#define NE_ENTTAB(x)    (x).ne_enttab
#define NE_CBENTTAB(x)  (x).ne_cbenttab
#define NE_CRC(x)       (x).ne_crc
#define NE_FLAGS(x)     (x).ne_flags
#define NE_AUTODATA(x)  (x).ne_autodata
#define NE_HEAP(x)      (x).ne_heap
#define NE_STACK(x)     (x).ne_stack
#define NE_CSIP(x)      (x).ne_csip
#define NE_SSSP(x)      (x).ne_sssp
#define NE_CSEG(x)      (x).ne_cseg
#define NE_CMOD(x)      (x).ne_cmod
#define NE_CBNRESTAB(x) (x).ne_cbnrestab
#define NE_SEGTAB(x)    (x).ne_segtab
#define NE_RSRCTAB(x)   (x).ne_rsrctab
#define NE_RESTAB(x)    (x).ne_restab
#define NE_MODTAB(x)    (x).ne_modtab
#define NE_IMPTAB(x)    (x).ne_imptab
#define NE_NRESTAB(x)   (x).ne_nrestab
#define NE_CMOVENT(x)   (x).ne_cmovent
#define NE_ALIGN(x)     (x).ne_align
#define NE_RES(x)       (x).ne_res
#define NE_EXETYPE(x)	(x).ne_exetyp

#define NE_USAGE(x)     (WORD)*((WORD FAR *)(x)+1)
#define NE_PNEXTEXE(x)  (WORD)(x).ne_cbenttab
#define NE_PAUTODATA(x) (WORD)(x).ne_crc
#define NE_PFILEINFO(x) (WORD)((DWORD)(x).ne_crc >> 16)

#ifdef DOS5
#define NE_MTE(x)   (x).ne_psegcsum /* DOS 5 MTE handle for this module */
#endif


/*
 *  Format of NE_FLAGS(x):
 *
 *  p                                   Not-a-process
 *   c                                  Non-conforming
 *    e                                 Errors in image
 *     xxxxxxxxx                        Unused
 *              P                       Runs in protected mode
 *               r                      Runs in real mode
 *                i                     Instance data
 *                 s                    Solo data
 */
#define NENOTP          0x8000          /* Not a process */
#define NENONC          0x4000          /* Non-conforming program */
#define NEIERR          0x2000          /* Errors in image */
#define NEPROT          0x0008          /* Runs in protected mode */
#define NEREAL          0x0004          /* Runs in real mode */
#define NEINST          0x0002          /* Instance data */
#define NESOLO          0x0001          /* Solo data */

struct new_seg                          /* New .EXE segment table entry */
  {
    unsigned short      ns_sector;      /* File sector of start of segment */
    unsigned short      ns_cbseg;       /* Number of bytes in file */
    unsigned short      ns_flags;       /* Attribute flags */
    unsigned short      ns_minalloc;    /* Minimum allocation in bytes */
  };

struct new_seg1                         /* New .EXE segment table entry */
  {
    unsigned short      ns_sector;      /* File sector of start of segment */
    unsigned short      ns_cbseg;       /* Number of bytes in file */
    unsigned short      ns_flags;       /* Attribute flags */
    unsigned short      ns_minalloc;    /* Minimum allocation in bytes */
    unsigned short      ns_handle;      /* Handle of segment */
  };

#define NS_SECTOR(x)    (x).ns_sector
#define NS_CBSEG(x)     (x).ns_cbseg
#define NS_FLAGS(x)     (x).ns_flags
#define NS_MINALLOC(x)  (x).ns_minalloc

/*
 *  Format of NS_FLAGS(x):
 *
 *  xxxx                                Unused
 *      DD                              286 DPL bits
 *        d                             Segment has debug info
 *         r                            Segment has relocations
 *          e                           Execute/read only
 *           p                          Preload segment
 *            P                         Pure segment
 *             m                        Movable segment
 *              i                       Iterated segment
 *               ttt                    Segment type
 */
#define NSTYPE          0x0007          /* Segment type mask */
#define NSCODE          0x0000          /* Code segment */
#define NSDATA          0x0001          /* Data segment */
#define NSITER          0x0008          /* Iterated segment flag */
#define NSMOVE          0x0010          /* Movable segment flag */
#define NSPURE          0x0020          /* Pure segment flag */
#define NSPRELOAD       0x0040          /* Preload segment flag */
#define NSEXRD          0x0080          /* Execute-only (code segment), or
                                        *  read-only (data segment)
                                        */
#define NSRELOC         0x0100          /* Segment has relocations */
#define NSDEBUG         0x0200          /* Segment has debug info */
#define NSDPL           0x0C00          /* 286 DPL bits */
#define NSDISCARD       0x1000          /* Discard bit for segment */

#define NSALIGN 9       /* Segment data aligned on 512 byte boundaries */

struct new_segdata                      /* Segment data */
  {
    union
      {
        struct
          {
            unsigned short      ns_niter;       /* number of iterations */
            unsigned short      ns_nbytes;      /* number of bytes */
            char                ns_iterdata;    /* iterated data bytes */
          } ns_iter;
        struct
          {
            char                ns_data;        /* data bytes */
          } ns_noniter;
      } ns_union;
  };

struct new_rlcinfo                      /* Relocation info */
  {
    unsigned short      nr_nreloc;      /* number of relocation items that */
  };                                    /* follow */

struct new_rlc                          /* Relocation item */
  {
    char                nr_stype;       /* Source type */
    char                nr_flags;       /* Flag byte */
    unsigned short      nr_soff;        /* Source offset */
    union
      {
        struct
          {
            char        nr_segno;       /* Target segment number */
            char        nr_res;         /* Reserved */
            unsigned short nr_entry;    /* Target Entry Table offset */
          }             nr_intref;      /* Internal reference */
        struct
          {
            unsigned short nr_mod;      /* Index into Module Reference Table */
            unsigned short nr_proc;     /* Procedure ordinal or name offset */
          }             nr_import;      /* Import */
      }                 nr_union;       /* Union */
  };

#define NR_STYPE(x)     (x).nr_stype
#define NR_FLAGS(x)     (x).nr_flags
#define NR_SOFF(x)      (x).nr_soff
#define NR_SEGNO(x)     (x).nr_union.nr_intref.nr_segno
#define NR_RES(x)       (x).nr_union.nr_intref.nr_res
#define NR_ENTRY(x)     (x).nr_union.nr_intref.nr_entry
#define NR_MOD(x)       (x).nr_union.nr_import.nr_mod
#define NR_PROC(x)      (x).nr_union.nr_import.nr_proc

/*
 *  Format of NR_STYPE(x):
 *
 *  xxxxx                               Unused
 *       sss                            Source type
 */
#define NRSTYP          0x07            /* Source type mask */
#define NRSSEG          0x02            /* 16-bit segment */
#define NRSPTR          0x03            /* 32-bit pointer */
#define NRSOFF          0x05            /* 16-bit offset */

/*
 *  Format of NR_FLAGS(x):
 *
 *  xxxxx                               Unused
 *       a                              Additive fixup
 *        rr                            Reference type
 */
#define NRADD           0x04            /* Additive fixup */
#define NRRTYP          0x03            /* Reference type mask */
#define NRRINT          0x00            /* Internal reference */
#define NRRORD          0x01            /* Import by ordinal */
#define NRRNAM          0x02            /* Import by name */
#define OSFIXUP 	0x03		/* Floating point fixup */


/* Resource type or name string */
struct rsrc_string
    {
    char rs_len;            /* number of bytes in string */
    char rs_string[ 1 ];    /* text of string */
    };

#define RS_LEN( x )    (x).rs_len
#define RS_STRING( x ) (x).rs_string

/* Resource type information block */
struct rsrc_typeinfo
    {
    unsigned short rt_id;
    unsigned short rt_nres;
    long rt_proc;
    };

#define RT_ID( x )   (x).rt_id
#define RT_NRES( x ) (x).rt_nres
#define RT_PROC( x ) (x).rt_proc

/* Resource name information block */
struct rsrc_nameinfo
    {
    /* The following two fields must be shifted left by the value of  */
    /* the rs_align field to compute their actual value.  This allows */
    /* resources to be larger than 64k, but they do not need to be    */
    /* aligned on 512 byte boundaries, the way segments are           */
    unsigned short rn_offset;   /* file offset to resource data */
    unsigned short rn_length;   /* length of resource data */
    unsigned short rn_flags;    /* resource flags */
    unsigned short rn_id;       /* resource name id */
    unsigned short rn_handle;   /* If loaded, then global handle */
    unsigned short rn_usage;    /* Initially zero.  Number of times */
                                /* the handle for this resource has */
                                /* been given out */
    };

#define RN_OFFSET( x ) (x).rn_offset
#define RN_LENGTH( x ) (x).rn_length
#define RN_FLAGS( x )  (x).rn_flags
#define RN_ID( x )     (x).rn_id
#define RN_HANDLE( x ) (x).rn_handle
#define RN_USAGE( x )  (x).rn_usage

#define RSORDID     0x8000      /* if high bit of ID set then integer id */
                                /* otherwise ID is offset of string from
                                   the beginning of the resource table */

                                /* Ideally these are the same as the */
                                /* corresponding segment flags */
#define RNMOVE      0x0010      /* Moveable resource */
#define RNPURE      0x0020      /* Pure (read-only) resource */
#define RNPRELOAD   0x0040      /* Preloaded resource */
#define RNDISCARD   0x1000      /* Discard bit for resource */

#define RNLOADED    0x0004	/* True if handler proc return handle */

//#define RNCOMPR     0x0200	/* Resource is compressed in ROM */

/* Resource table */
struct new_rsrc
    {
    unsigned short rs_align;    /* alignment shift count for resources */
    struct rsrc_typeinfo rs_typeinfo;
    };

#define RS_ALIGN( x ) (x).rs_align

/* Target operating systems:  Possible values of ne_exetyp field */

#define NE_UNKNOWN	0	/* Unknown (any "new-format" OS) */
#define NE_OS2		1	/* Microsoft/IBM OS/2 (default)  */
#define NE_WINDOWS	2	/* Microsoft Windows		 */
#define NE_DOS4 	3	/* Microsoft MS-DOS 4.x		 */
#define NE_DEV386	4	/* Microsoft Windows 386	 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\module.asm ===
.xlist
include kernel.inc
include newexe.inc
include tdb.inc
.list

;externFP GlobalCompact
externFP GlobalFreeAll
externFP GetExePtr
externFP FarMyFree
externFP Far_genter
externFP FlushCachedFileHandle
externFP GetProcAddress
externFP FarUnlinkObject
externFP CallWEP
externFP lstrcpy


if SDEBUG
externFP FarDebugDelModule
endif

DataBegin

externB fBooting
;externW EMScurPID
externW curTDB
externW loadTDB
externW headTDB
externW hExeHead
externW pGlobalHeap
externW MyCSDS
externD pSignalProc

ifdef WOW
externW hWinnetDriver
externW hUser
endif ; WOW

DataEnd

sBegin	CODE
assumes CS,CODE
assumes DS,NOTHING
assumes ES,NOTHING

;-----------------------------------------------------------------------;
; UnlinkObject								;
;									;
; Removes an object from a singly linked list of objects.		;
;									;
; Arguments:								;
;	CS:BX = head of chain						;
;	ES    = object to delete					;
;	DX    = offset of next pointer in object			;
;									;
; Returns:								;
;	AX = deleted object						;
;									;
; Error Returns:							;
;	none								;
;									;
; Registers Preserved:							;
;	BX,DI,SI,BP,DS							;
;									;
; Registers Destroyed:							;
;	CX,DX,ES							;
;									;
; Calls:								;
;									;
; History:								;
;									;
;  Mon Sep 29, 1986 11:29:32a  -by-  Charles Whitmer  [chuckwh]		;
; Wrote it to remove this code from the three different places where	;
; it was included inline.						;
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	UnlinkObject,<PUBLIC,NEAR>
cBegin	nogen
	push	di
	mov	di,dx

; keep DX = next object

	mov	dx,es:[di]

; see if the object is at the head

	push	ds
	SetKernelDS
	mov	cx,ds:[bx]		; start CX at head
	mov	ax,es			; AX = object to delete
	cmp	ax,cx
	jnz	not_at_head
	mov	ds:[bx],dx
	pop	ds
	UnSetKernelDS
	jmp	short unlink_done
not_at_head:
	pop	ds
	UnSetKernelDS

; run down the chain looking for the object

unlink_loop:
	jcxz	unlink_done
	mov	es,cx
	mov	cx,es:[di]
	cmp	ax,cx
	jnz	unlink_loop
	mov	es:[di],dx
unlink_done:
	pop	di
	ret
cEnd	nogen


sEnd	CODE

sBegin	NRESCODE
assumes CS,NRESCODE
assumes DS,NOTHING
assumes ES,NOTHING

externNP MapDStoDATA
externNP DecExeUsage
externNP FlushPatchAppCache
IFNDEF NO_APPLOADER
externNP ExitAppl
ENDIF ;!NO_APPLOADER


;-----------------------------------------------------------------------;
; KillLibraries								;
;									;
; Scans the list of EXEs looking for Libraries.  For all Libraries	;
; it looks for a procedure called 'WEP'.  If found, WEP is called with	;
; fSystemExit set.							;
;									;
; Arguments:								;
;	None								;
;									;
; Returns:								;
;	None								;
;									;
; Error Returns:							;
;	none								;
;									;
; Registers Preserved:							;
;	DI,SI,BP,DS							;
;									;
; Registers Destroyed:							;
;	BX,CX,DX,ES							;
;									;
; Calls:								;
;	GetProcAddress							;
;									;
; History:								;
;									;
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	KillLibraries,<PUBLIC,FAR>,<DS>
	localW	hExe
cBegin
	SetKernelDSNRes
	mov	cx, hExeHead
kl_NextExe:
	UnSetKernelDS
	mov	ds, cx			; This skips first module (kernel)
	mov	cx, ds:[ne_pnextexe]
	jcxz	kl_done
	push	cx
	cCall	CallWEP, <cx, 1>	; Call for any module (call is fast)
	pop	cx
	jmp	kl_NextExe
kl_done:
cEnd

;-----------------------------------------------------------------------;
; AddModule								;
; 									;
; Adds a module to the end of the list of modules.			;
; 									;
; Arguments:								;
;	parmW   hExe	seg of module to add				;
; 									;
; Returns:								;
;	AX != 0 if successful						;
;									;
; Error Returns:							;
;	AX == 0 if error detected					;
;									;
; Registers Preserved:							;
;	DI,SI,DS							;
; 									;
; Registers Destroyed:							;
;	AX,BX,CX,DX,ES 							;
;									;
; Calls:								;
;	GlobalCompact							;
;	CalcMaxNRSeg							;
;	FarRedo_library_entries 					;
; 									;
; History:								;
;  Wed 24-Jul-1991 -by- Don Corbitt [donc]				;
; Finish removal of Real mode code, dead code.  Remove module from 	;
; list if insufficient memory.  Directly set DS on entry.		;
; 									;
;  Thu 23-Mar-1989 23:00:40  -by-  David N. Weise  [davidw]		;
; Made tasks and libraries be separate on the module chain.		;
;									;
;  Thu Feb 25, 1988 08:00:00a  -by-  Tim Halvorsen    [iris]            ;
; Check new error return from Redo_library_entries, returned when	;
; we totally run out of space for another library's entry table		;
; in EMS (the entry table is for ALL tasks, not just this task).	;
; Fix comments above to reflect correct returns from this routine.	;
; 									;
;  Wed May 06, 1987 00:07:20a  -by-  David N. Weise      [davidw]	;
; Added support for EMS and library entrys.				;
; 									;
;  Thu Dec 11, 1986 12:10:26p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block, and made it set calculate and set	;
; ne_swaparea.								;
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	AddModule,<PUBLIC,NEAR>,<ds>
	parmW   hExe
	localW	hLast			; last module in current list
cBegin
	SetKernelDSNRes
	xor	bx,bx
	mov	cx,hExeHead

am0:	mov	es,cx			; find end of linked list of exe's
	mov	cx,es:[bx].ne_pnextexe
	or	cx, cx
	jnz	am0

; Here to add a module to the end of the chain.  BX == 0.

	mov	hLast, es		; so we can remove hExe on failure
	mov	ax,hExe
	mov	es:[bx].ne_pnextexe,ax
	mov	es,ax
	mov	es:[bx].ne_pnextexe,bx

        xor     bx,bx
am_done:
	mov	ax,hExe
am_exit:
cEnd


;-----------------------------------------------------------------------;
; DelModule								;
; 									;
; Deletes a module from the list of modules.				;
; 									;
; Arguments:								;
;	parmW   hExe	seg of module to delete				;
; 									;
; Returns:								;
;	AX = 0								;
;									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
;	DI,SI,DS							;
; 									;
; Registers Destroyed:							;
;	AX,BX,CX,DX,ES							;
; 									;
; Calls:								;
;	FarUnlinkObject 						;
;	GlobalFreeAll							;
;	CalcMaxNRSeg							;
;	EMSDelModule							;
;									;
; History:								;
; 									;
;  Wed May 06, 1987 00:07:20a  -by-  David N. Weise      [davidw]	;
; Added support for EMS and library entrys.				;
; 									;
;  Tue May 05, 1987 10:36:29p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	DelModule,<PUBLIC,NEAR>,<ds,di>
	parmW	pExe
cBegin
	SetKernelDSNRes

if SDEBUG
	mov	es, pExe
	call	FarDebugDelModule	; is ES preserved?
endif

	cCall	CallWEP,<pExe,0>

	mov	es, pExe
	test	es:[ne_flags],NENOTP
	jz	dm_not_a_lib


; call user to clean up any stuff
	test	es:[ne_flags],NEPROT	; OS/2 app?  is this necessary???
	jnz	no_user_yet
	cmp	pSignalProc.sel,0
	jz	no_user_yet
	xor	ax,ax
	mov	bx,80h
	mov	es:[ne_usage],1
	push	es
	cCall	pSignalProc,<pExe,bx,ax,ax,ax>
	pop	es
	mov	es:[ne_usage],0
no_user_yet:

dm_not_a_lib:
					; Following code moved here
					; from FreeModule  1/18/89
	mov	es,pExe
	mov	bx,es:[ne_pautodata]
	or	bx,bx
	jz	fm00
	cCall	FarMyFree,<es:[bx].ns_handle>	; Free DS separately to free thunks
fm00:
IFNDEF NO_APPLOADER
	mov	es,pExe
	test	es:[ne_flags],NEAPPLOADER
	jz	normal_unload
;*	* special unload for AppLoader
	cCall	ExitAppl,<es>
normal_unload:
ENDIF ;!NO_APPLOADER			; END code from FreeModule
    cCall   FlushPatchAppCache, <pExe>      ; Flush out Module Patch  cache
    cCall   FlushCachedFileHandle,<pExe>    ; Flush out of file handle cache
	cCall	Far_genter		; so we don't interfere with lrusweep
	SetKernelDSNRes
	mov	es,pExe
	mov	dx,ne_pnextexe
	mov	bx,dataOffset hExeHead
	call	FarUnlinkObject
	mov	es,pGlobalHeap
	xor	di,di
	dec	es:[di].gi_lrulock

	mov	es,pExe 		; Make sure no one mistakes this for
	mov	es:[di].ne_magic,di	; an exe header anymore.
	cCall	GlobalFreeAll,<pExe>
        xor     ax,ax
cEnd





;-----------------------------------------------------------------------;
; FreeModule								;
; 									;
; Deletes the given module from the system.  First it decs the usage	;
; count checking to see if this is the last instance, ( this may 	;
; indirectly free other modules).  If this is the last instance then	;
; it frees the automatic data segment to free any thunks associated	;
; with this module.  Then the module is deleted.  If this was not the	;
; last instance then the ns_handle for the automatic data seg may have	;
; to be updated.							;
;									;
; Arguments:								;
;	parmW   hInstance						;
; 									;
; Returns:								;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Mon 03-Apr-1989 22:22:01  -by-  David N. Weise  [davidw]		;
; Removed the GlobalCompact at the end of this routine. 		;
;									;
;  Fri Jul 10, 1987 11:54:51p  -by-  David N. Weise   [davidw]		;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

labelFP <PUBLIC, IFreeLibrary>

	assumes ds,nothing
	assumes es,nothing

cProc	IFreeModule,<PUBLIC,FAR>,<si,di>
	parmW   hInstance
cBegin
	cCall	GetExePtr,<hInstance>	; Get exe header address
	or	ax,ax
	jz	fmexit1
	mov	si,ax

ifdef WOW
    ; we can't allow anybody except user.exe take the ref count for 16-bit net 
    ; driver down to 0 (see pNetInfo in user16\net.c winnet.asm) bug #393078
	mov	es,si
	cmp	es:[ne_usage],1
    jnz  fmNoProb  ; if usage ref count isn't 1 -- no worries
    
    mov dx,word ptr [bp+4]   ; selector of calling module

    ; See if it is user.exe freeing the net driver.
    cCall <far ptr IsOKToFreeThis>,<dx,ax> 
    or   ax,ax            ; Will be 0 if & only if the module being freed is 
                          ; 16-bit net driver & the module freeing it is NOT 
                          ; user.exe. Otherwise ax will = si
	jz   fmexit1   ; lie & say we freed 16-bit net driver & return ref count = 0
    
fmNoProb:
endif  ; WOW

    cCall   DecExeUsage,<si>        ; Decrement usage count
	jnz	fmfree			; If non-zero, then just free inst.
ifdef WOW
        ; Word Perfect v5.2 needs DX to contain a number >= 0x17 inorder
        ; to print properly.  Since on Win 3.1, the DX value came from
        ; this point, lets save it for them.  (On Win 3,1, the printer
        ; driver was being free'd here, but not deleted, GDI or spooler
        ; still has it open).
        push    dx
endif
        cCall   DelModule,<si>          ; If zero, free entire module
ifdef WOW
        pop     dx
endif

fmexit1:
	jmps	fmexit
fmfree:
	mov	es,si
	test	byte ptr es:[ne_flags],NEINST
	jz	fmexit			; All done if not a multiple inst
	mov	bx,es:[ne_pautodata]
	push	es:[bx].ns_handle
	cCall	FarMyFree,<hInstance>	; Free instance
	pop	dx
	cmp	dx,hInstance		; Did we free current instance?
	jne	fmexit			; No, then continue

	cCall	MapDStoDATA
	ReSetKernelDS
	xor	ax,ax
	xor	bx,bx
	mov	cx,headTDB		; Yes, search TDBs looking for
	UnSetKernelDS
fm0:	jcxz	fm1			;  another instance handle
	mov	es,cx
	cmp	si,es:[bx].TDB_pModule
	mov	cx,es:[bx].TDB_next
	jnz	fm0

	mov	ax,es:[bx].TDB_module
	cmp	ax,hInstance		; Is this the instance we're quitting?
	jz	fm0

fm1:	mov	es,si
	mov	bx,es:[bx].ne_pautodata
	mov	es:[bx].ns_handle,ax	; Remember handle of data seg
fmexit:

cEnd

sEnd	NRESCODE



ifdef WOW
sBegin	CODE
assumes CS,CODE
assumes DS,NOTHING
assumes ES,NOTHING

;
; called by user.exe\net.c\LW_InitNetInfo()
;
; Arguments:
;	parmW   hInstNetDrv - hInstance of net driver library loaded by user.exe
;
; Returns:
;    nothing
;
cProc   TellKrnlWhoNetDrvIs, <PUBLIC,FAR>,<si,di>
    parmW   hInstNetDrv
cBegin
	SetKernelDS
    cCall getexeptr,<hInstNetDrv> 
    mov hWinnetDriver,ax     ; save hMod of net driver
	UnSetKernelDS
cEnd


;
; Should only be called if the ref (usage) count for module being freed is 1.
; (ie. about to go to zero)
;
; Arguments:
;	parmW   modsel   - selector of code calling FreeModule
;   parmW   hModFree - hModule of module being freed
;
; Returns:
;    0  if & only if the module being freed is hWinnetDriver as set by user.exe
;       AND the module calling FreeModule is NOT user.exe
;    Otherwise: the hMod of the module being freed
;
cProc   IsOKToFreeThis, <PRIVATE,FAR>,<si,di>
    parmW modsel
    parmW hModFree
cBegin
	SetKernelDS
    mov  ax,hModFree
    cmp  ax,hWinnetDriver               ; is hMod of the net driver module?
    jnz  IOKExit                        ; Exit if not -- no worries

    ; Danger! hMod being freed is the net driver
    cCall getexeptr,<modsel>             ; get hMod of caller
     
    cmp ax,hUser                        ; See if caller is user.exe
    jz  IOK2FT1                         ; yep, that's OK   

    xor ax,ax                           ; ret 0 so we don't free the net driver
    jmp IOKExit

IOK2FT1:
    mov  ax,hModFree
IOKExit:
	UnSetKernelDS
cEnd
    
endif  ; WOW

sEnd	CODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\miscapi.asm ===
.xlist
include kernel.inc
include pdb.inc
include tdb.inc
include newexe.inc
.list

externFP GlobalDOSAlloc
externFP GlobalDOSFree
externFP GetProfileString

DataBegin

externB kernel_flags
externW MyCSAlias
externW curTDB
externW headTDB
if 0 ; EarleH
externW LastCriticalError
endif
externW LastExtendedError

externD FatalExitProc

DataEnd

sBegin	CODE
assumes CS,CODE
assumes	ds, nothing
assumes	es, nothing

externD PrevInt21Proc

externNP SetOwner

;-----------------------------------------------------------------------;
; A20Proc								;
; 	Enable / Disable the A20 line by calling an XMS driver		;
;									;
; Arguments:								;
; 									;
; Returns:								;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Thu Mar 31, 1988 -by-  Tony Gosling					;
; 									;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

cProc	A20Proc,<PUBLIC,FAR>,<si,di>
	parmW	enable
cBegin
cEnd


;**
;
; NETBIOSCALL -- Issue an INT 5C for caller
;
;	This call is provided as a Kernel service to applications that
;	wish to issue NETBIOS INT 5Ch calls WITHOUT coding an INT 5Ch, which
;	is incompatible with protected mode.
;
;   ENTRY:
;	All registers as for INT 5Ch
;
;   EXIT:
;	All registers as for particular INT 5Ch call
;
;   USES:
;	As per INT 5Ch call
;
;
cProc	NETBIOSCALL,<PUBLIC,FAR>
cBegin
	int	5Ch
cEnd


;**
;
; SetHandleCount -- Set the handle count in the PDB
;
;	Sets the per process handle count to a new value
;	and allocates space for these file handles
;
;   ENTRY:
;	nFiles - new number of file handles required
;
;   EXIT:
;	returns new number of file handles
;
;   USES:
;	C call
;
;
cProc	ISetHandleCount,<PUBLIC,FAR>,<di,si>
	parmW	nFiles
cBegin
	SetKernelDS
	mov	si, CurTDB
	mov	ds, si
	UnSetKernelDS
	mov	ds, ds:[TDB_PDB]

        ;** We allow no more than 255.  Also, if something smaller than what
        ;**     we have, we just do nothing and respond with the number we
        ;**     already have.
	mov	ax, ds:[PDB_JFN_Length]	; How many now
        cmp     nFiles,255              ;Validate the parameter
        jbe     SHC_OK                  ;Parm OK

IF KDEBUG
	push	ax
	kerror	ERR_PARAMETER,<SetHandleCount:  Too many files requested:>,nFiles,0
	pop	ax
ENDIF
	mov     nFiles,255              ;Force it to do no more than 255
SHC_OK:	mov	bx, nFiles
	cmp	ax, bx			; Don't want more?
        jae     no_change

        ;** Allocate memory for a new file handle table
	add	bx, 2
	cCall	GlobalDOSAlloc, <0, bx>
	or	ax, ax
	jnz	ok_we_got_it
	mov	ax, ds:[PDB_JFN_Length]	; Return original number
	jmp     SHORT no_change
ok_we_got_it:

        ;** Prepare the new table and update the PDB for the new table
	cCall	SetOwner,<ax,si>	;Hide it from GlobalFreeAll
        mov     es, ax                  ;Point to new table with ES
	mov	WORD PTR ds:[PDB_JFN_Pointer][2], dx ;Save seg address
	xor	di, di
	mov	si, word ptr ds:[PDB_JFN_Pointer] ;Offset of old table
	mov	cx, ds:[PDB_JFN_Length] ;Bytes to copy (one byte per handle)
	mov	WORD PTR ds:[PDB_JFN_Pointer][0], di ;Save new offset
	mov	bx, nFiles              ;Save new number of files
	mov	ds:[PDB_JFN_Length], bx
	push	ds                      ;Save PDB selector for later

        ;** We use the PDB selector to copy if we're copying the original
        ;**     table which is always in the PDB.  Note that we only have a
        ;**     non-zero offset if the table is in the PDB.  We can't save
        ;**     the selector in the table in this case until AFTER
        or      si, si                  ;Table in PDB?
        jnz     @F                      ;Yes
	mov     ds, WORD PTR ds:[PDB_JFN_Table] ;Get old selector to copy from
@@:

        ;** Copy the existing table into the new one
	cld
	rep	movsb			;Copy existing files
	mov	al, -1
	mov	cx, nFiles
	sub	cx, di
	rep	stosb                   ;Pad new files with -1
	mov	ax, ds
	pop	bx			;Retrieve PDB selector
	mov	ds, bx
        mov     WORD PTR ds:[PDB_JFN_Table], es ;Save new selector

        ;** We only free the old table if it wasn't in the PDB
        cmp     ax, bx                  ;Were we using the PDB selector?
        je      SHC_OldTableInPDB       ;Yes.  Don't free it
	cCall	GlobalDOSFree, <ax>     ;Free old table
SHC_OldTableInPDB:

	mov	ax, nFiles
no_change:
cEnd

;-----------------------------------------------------------------------;
; GetSetKernelDOSProc							;
;	Set the address kernel calls for DOS				;
;									;
; Arguments:								;
; 									;
; Returns:								;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Fri Dec 31, 1990 -by-  Tony Gosling					;
;      		 							;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

cProc	GetSetKernelDOSProc,<PUBLIC,FAR>
	parmD	NewProc
cBegin
	SetKernelDS
	mov	ds, MyCSAlias
	assumes ds, CODE
	mov	ax, word ptr NewProc[0]
	xchg	ax, word ptr PrevInt21Proc[0]
	mov	dx, word ptr NewProc[2]
	xchg	dx, word ptr PrevInt21Proc[2]
cEnd				


;-----------------------------------------------------------------------;
; FatalExitHook								;
; 	Hooks FatalExit							;
;									;
; Arguments:								;
; 									;
; Returns:								;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Fri Dec 31, 1990 -by-  Tony Gosling					;
;      		 							;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

cProc	FatalExitHook,<PUBLIC,FAR>
	parmD	NewProc
cBegin
	SetKernelDS
	mov	ax, word ptr NewProc[0]
	xchg	ax, word ptr FatalExitProc[0]
	mov	dx, word ptr NewProc[2]
	xchg	dx, word ptr FatalExitProc[2]
cEnd			     	

if 0		; EarleH

;-----------------------------------------------------------------------;
; GetLastCriticalError							;
;    	Get the last int 24h error and extended error code		;
;									;
; Arguments:								;
; 									;
; Returns:								;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Fri Dec 31, 1990 -by-  Tony Gosling					;
;      		 							;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

cProc	GetLastCriticalError,<PUBLIC,FAR>
cBegin	
	SetKernelDS
	mov	ax, -1
	mov	dx, ax
	xchg	ax, LastExtendedError
	xchg	dx, LastCriticalError
cEnd				
endif ;0		      	

;-----------------------------------------------------------------------;
; DWORD GetAppCompatFlags(HTASK hTask)                                  ;
;                                                                       ;
; Returns win.ini [Compatibility] flags for hTask (or current task      ;
; if hTask is NULL).                                                    ;
;									;
; Arguments:								;
; 									;
; Returns:								;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
;   All but DX:AX                                                       ;
; 									;
; Registers Destroyed:							;
; 									;
;   DX, AX                                                              ;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

cProc   GetAppCompatFlags,<PUBLIC,FAR>,<DS>
parmW   hTask
cBegin
        SetKernelDS
        mov     ax,hTask
        or      ax,ax
        jnz     got_tdb
        mov     ax,curTDB               ; If no current task (e.g., during boot)
        cwd                             ; just return 0L.
        or      ax,ax
        jz      gacf_exit
got_tdb:
        mov     ds,ax
        UnSetKernelDS
        mov     ax,ds:[TDB_CompatFlags]
        mov     dx,ds:[TDB_CompatFlags2]
gacf_exit:
        UnSetKernelDS
cEnd

; Simpler (faster) NEAR version for Kernel -- only works for current task!
;
; Preserves all regs except dx:ax
;
cProc	MyGetAppCompatFlags,<PUBLIC,NEAR>
cBegin	nogen
	push	ds
	SetKernelDS

	mov	ax, curTDB
	cwd
	or	ax, ax			; No current task while booting
	jz	mygacf_exit

	mov	ds, ax
	UnSetKernelDS
	mov	ax, ds:[TDB_CompatFlags]
	mov	dx, ds:[TDB_CompatFlags2]

mygacf_exit:
	pop	ds
	UnSetKernelDS
	ret

cEnd	nogen

ifdef WOW
cProc   MyGetAppWOWCompatFlags,<PUBLIC,NEAR>
cBegin	nogen
	push	ds
	SetKernelDS

	mov	ax, curTDB
	cwd
	or	ax, ax			; No current task while booting
	jz	wow_mygacf_exit

	mov	ds, ax
	UnSetKernelDS
	mov	ax, ds:[TDB_WOWCompatFlags]
	mov	dx, ds:[TDB_WOWCompatFlags2]

wow_mygacf_exit:
	pop	ds
	UnSetKernelDS
	ret

cEnd	nogen

;
; Returns WOW extended compatiblity flags
;
; Preserves all regs except dx:ax
;
cProc   MyGetAppWOWCompatFlagsEx,<PUBLIC,FAR>
cBegin	nogen
	push	ds
	SetKernelDS

	mov	ax, curTDB
	cwd
	or	ax, ax			; No current task while booting
        jz      wow_mygacfex_exit

	mov	ds, ax
	UnSetKernelDS
	mov	ax, ds:[TDB_WOWCompatFlagsEx]
	mov	dx, ds:[TDB_WOWCompatFlagsEx2]

wow_mygacfex_exit:
	pop	ds
	UnSetKernelDS
        retf

cEnd	nogen


;---------------------------------------------------------------------------
; This gets called from FreeProcInstance. If the proc being freed is an
; AbortProc that was set by the app, we reset it to NULL. This way we dont
; callback to a proc that's garbage.
;
; This case happens with Aldus Pagemaker ver 5.0 when one prints to EPS file.
; The app sets the AbortProc and then later calls freeprocinstance.
; Subsequently when it make the call Escape(..OPENCHANNEL..) the callback
; occurs and we die randomly.
;
; This solution is a general solution.
;                                                           - Nanduri
;---------------------------------------------------------------------------

cProc	HandleAbortProc, <PUBLIC,FAR>, <ds, ax>
     ParmD pproc
cBegin	
	SetKernelDS

	mov	ax, curTDB
	or	ax, ax			; No current task while booting
	jz	wow_aproc_exit

	mov	ds, ax
	UnSetKernelDS
	mov     ax, ds:[TDB_vpfnAbortProc+2]
        or      ax, ax
        je      wow_aproc_exit          ; sel = 0 - no abort proc. done
        cmp     ax, word ptr [pproc+2]
        jnz     wow_aproc_exit          ; selectors don't match
	mov     ax, ds:[TDB_vpfnAbortProc]
        cmp     ax, word ptr [pproc]
        jnz     wow_aproc_exit          ; offsets don't match

	mov     ds:[TDB_vpfnAbortProc], 0          ; set abort proc to NULL.
	mov     ds:[TDB_vpfnAbortProc+2], 0
wow_aproc_exit:
	UnSetKernelDS
cEnd	

endif ; WOW

sEnd	CODE

sBegin NRESCODE
assumes CS,NRESCODE

ifndef WOW          ; WOW thunks SetAppCompatFlags for special processing
CompatSection	DB  'Compatibility'
DefVal		DB	0

cProc	SetAppCompatFlags, <PUBLIC, NEAR>, <ds, es, si, di>
	localV	szHex,12			; read string to here
	localV	key, <SIZE TDB_Modname + 2>	; ModName of loading app
cBegin
	xor	ax, ax
	cwd
        cmp     es:[TDB_ExpWinVer], 400h ; Hacks don't apply to 4.0 or above
        jae     sa_exit

	push	es			; Copy ModName to zero-terminate it
	pop	ds
	lea	si, es:[TDB_ModName]
	push	ss
	pop	es
	lea	di, key
	mov	cx, SIZE TDB_Modname
	cld
	rep	movsb
	stosb

	push	cs
	push	NREScodeoffset CompatSection

	push	ss
	lea	ax, key
	push	ax

	push	cs
	push	NREScodeoffset DefVal

	push	ss
	lea	ax, szHex
	push	ax

        push    12

	call	GetProfileString
	cwd
	or	ax, ax
	jz	sa_exit
        xor     dx,dx                   ; zero our value in dx:bx
        xor     bx,bx
	push	ss
	pop	ds
	lea	si, szHex

	lodsw				; String starts with '0x'
	and	ah, not 20h
	cmp	ax, 'X0'
	jnz	sa_done
sa_again:
	lodsb
	sub	al, '0'
	jc	sa_done
        cmp     al, '9'-'0'
	jbe	@F
        add     al, '0'-'A'+10          ; map 'A'..F' to 10..15
                                        ; (lower case guys are 0x20 apart!)
@@:
        add     bx,bx                   ; value << 4;
        adc     dx,dx
        add     bx,bx
        adc     dx,dx
        add     bx,bx
        adc     dx,dx
        add     bx,bx
        adc     dx,dx

        and     al,0fh                  ; value |= (al & 0x0f);
        or      bl,al
        jmps    sa_again

sa_done:	; DX:BX contains flags
        mov     ax, bx
        cmp     es:[TDB_ExpWinVer], 30Ah ; SOME hacks don't apply to 3.1 or above
        jb      sa_end
        and     dx, HIW_GACF_31VALIDMASK
        and     ax, LOW_GACF_31VALIDMASK
sa_end:

sa_exit:	; DX:AX contains flags, or 0x00000000
cEnd
endif  ; WOW

cProc	ValidateCodeSegments,<PUBLIC,FAR>
cBegin	nogen
	ret
cEnd	nogen

sEnd	NRESCODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\patch.asm ===
.xlist
include kernel.inc
include gpfix.inc
include pdb.inc
include tdb.inc
include newexe.inc
include protect.inc
.list

.386

ERROR_NO_MORE_ITEMS        EQU     259

;-----------------------------------------------------------------------
;-----------------------------------------------------------------------
; App patching defines


externFP RegCloseKey32
externFP RegOpenKey32
externFP RegEnumKey32
externFP RegEnumValue32

externFP FarGetCachedFileHandle
externFP GlobalRealloc
externFP GlobalSize
externFP Far_genter
externFP Far_gleave
externFP Far_htoa0
externFP Far_pdref
externFP FreeSelector

; MultiThreading version of change PDB
;externFP GetCurPDB
;externFP SetCurPDB
;externFP TopPDB
; MultiThreading version of change PDB

externW topPDB
externW Win_PDB
externW gdtdsc

REG_BINARY           equ     3

HKEY_LOCAL_MACHINE      equ 80000002h
HKEY_LOCAL_MACHINE_HI   equ 8000h
HKEY_LOCAL_MACHINE_LO   equ 0002h

; Under HKEY_LOCAL_MACHINE
REGSTR_PATH_APPPATCH equ <"System\CurrentControlSet\Control\Session Manager\AppPatches">
; There is one value for each modification to a given segment.
; The values for a segment are stored under the key
;     REGSTR_PATH_APPPATCH\<AppName>\<AppVersion>\<signature>
; where <signature> lists bytes in the module to match.


BY_HANDLE_FILE_INFORMATION STRUC
bhfi_dwFileAttributes       DD  ?
bhfi_ftCreationTime         DD  2 dup (?)
bhfi_ftLastAccessTime       DD  2 dup (?)
bhfi_ftLastWriteTime        DD  2 dup (?)
bhfi_dwVolumeSerialNumber   DD  ?
bhfi_nFileSizeHigh          DD  ?
bhfi_nFileSizeLow           DD  ?
bhfi_nNumberOfLinks         DD  ?
bhfi_nFileIndexHigh         DD  ?
bhfi_nFileIndexLow          DD  ?
BY_HANDLE_FILE_INFORMATION ENDS


;-----------------------------------------------------------------------
; Signature definitions
;
AP_SIG STRUC
sig_format      DB      ?       ; formatType for the struc
; rest of the data depends on the value in the sig_format field
AP_SIG ENDS

; Supported values for the sig_format field
AP_SIG_FORMAT_HEXE      equ     01h   ; match hExe bytes, 1B offset
AP_SIG_FORMAT_HEXE2     equ     02h   ; match hExe bytes, 2B offset
AP_SIG_FORMAT_FILE2     equ     03h   ; match file bytes, 2B offset
AP_SIG_FORMAT_FILE3     equ     04h   ; match file bytes, 3B offset
AP_SIG_FORMAT_FILE4     equ     05h   ; match file bytes, 4B offset
AP_SIG_FORMAT_FILESIZE2 equ     06h   ; match file size, 2B size
AP_SIG_FORMAT_FILESIZE3 equ     07h   ; match file size, 3B size
AP_SIG_FORMAT_FILESIZE4 equ     08h   ; match file size, 4B size
AP_SIG_FORMAT_META      equ    0ffh   ; contains other signatures

;AP_SIG_FORMAT_HEXE
AP_SIG_HEXE STRUC
es_format           DB      ?       ; AP_SIG_FORMAT_HEXE
; There can be multiple signature strings, packed one after the other.
; All must match to give a match.
; cb==0 signals the end.
es_cb               DB      ?       ; number of bytes to compare
es_offset           DB      ?       ; offset to begin signature compare
es_abSignature      DB      ?       ; cb DUP (?) ; signature bytes
AP_SIG_HEXE ENDS

;AP_SIG_FORMAT_HEXE2
AP_SIG_HEXE2 STRUC
es2_format          DB      ?       ; AP_SIG_FORMAT_HEXE2
; There can be multiple signature strings, packed one after the other.
; All must match to give a match.
; cb==0 signals the end.
es2_cb              DB      ?       ; number of bytes to compare
es2_offset          DW      ?       ; offset to begin signature compare
es2_abSignature     DB      ?       ; cb DUP (?) ; signature bytes
AP_SIG_HEXE2 ENDS

;AP_SIG_FORMAT_FILE2
AP_SIG_FILE2 STRUC
fs2_format          DB      ?       ; AP_SIG_FORMAT_FILE2
; There can be multiple signature strings, packed one after the other.
; All must match to give a match.
; cb==0 signals the end.
fs2_cb              DB      ?       ; number of bytes to compare
fs2_offset          DB 2    DUP (?) ; offset to begin signature compare
fs2_abSignature     DB      ?       ; cb DUP (?) ; bytes to match
AP_SIG_FILE2 ENDS

;AP_SIG_FORMAT_FILE3
AP_SIG_FILE3 STRUC
fs3_format          DB      ?       ; AP_SIG_FORMAT_FILE3
; There can be multiple signature strings, packed one after the other.
; All must match to give a match.
; cb==0 signals the end.
fs3_cb              DB      ?       ; number of bytes to compare
fs3_offset          DB 3    DUP (?) ; offset to begin signature compare
fs3_abSignature     DB      ?       ; cb DUP (?) ; bytes to match
AP_SIG_FILE3 ENDS

;AP_SIG_FORMAT_FILE4
AP_SIG_FILE4 STRUC
fs4_format          DB      ?       ; AP_SIG_FORMAT_FILE4
; There can be multiple signature strings, packed one after the other.
; All must match to give a match.
; cb==0 signals the end.
fs4_cb              DB      ?       ; number of bytes to compare
fs4_offset          DB 4    DUP (?) ; offset to begin signature compare
fs4_abSignature     DB      ?       ; cb DUP (?) ; bytes to match
AP_SIG_FILE4 ENDS

;AP_SIG_FORMAT_FILESIZE
AP_SIG_FILESIZE STRUC
fss_format          DB      ?       ; AP_SIG_FORMAT_FILESIZE[2,3,4]
fss_cbFile          DB      ?       ; file size in bytes
AP_SIG_FILESIZE ENDS

;AP_SIG_FORMAT_FILESIZE2
AP_SIG_FILESIZE2 STRUC
fss2_format         DB      ?       ; AP_SIG_FORMAT_FILESIZE2
fss2_cbFile         DB 2    DUP (?) ; file size in bytes
AP_SIG_FILESIZE2 ENDS

;AP_SIG_FORMAT_FILESIZE3
AP_SIG_FILESIZE3 STRUC
fss3_format         DB      ?       ; AP_SIG_FORMAT_FILESIZE3
fss3_cbFile         DB 3    DUP (?) ; file size in bytes
AP_SIG_FILESIZE3 ENDS

;AP_SIG_FORMAT_FILESIZE4
AP_SIG_FILESIZE4 STRUC
fss4_format         DB      ?       ; AP_SIG_FORMAT_FILESIZE4
fss4_cbFile         DB 4    DUP (?) ; file size in bytes
AP_SIG_FILESIZE4 ENDS

;AP_SIG_FORMAT_META
AP_SIG_META STRUC
ms_format           DB      ?       ; AP_SIG_FORMAT_META
; There can be multiple sub-signatures, packed one after the other.
; All must match to give a match.
; cb==0 signals the end.
ms_cb               DB      ?       ; number of bytes in the sub-signature
ms_abSubSignature   DB      ?       ; the sub-signature
AP_SIG_META ENDS

;-----------------------------------------------------------------------
; Patch definitions
;
AP_COMMON STRUC
ap_format       DB      ?       ; formatType for the struc
ap_cbSize       DB      ?       ; number of bytes in the whole struct
; rest of the data depends on the value in the ap_format field
AP_COMMON ENDS

; Supported values for the ap_format field:
AP_FORMAT_REPLACE         equ     1
AP_FORMAT_ADD             equ     2

;AP_FORMAT_REPLACE
AP_REPLACE STRUC
apr_format      DB      ?       ; AP_FORMAT_REPLACE
apr_cbSize      DB      ?       ; number of bytes in the whole struct
apr_offset      DW      ?       ; offset within the segment
apr_cb          DB      ?       ; number of bytes to replace
apr_abOld       DB      ?       ; cb DUP (?) ; old bytes
apr_abNew       DB      ?       ; cb DUP (?) ; new bytes
AP_REPLACE ENDS

;AP_FORMAT_ADD
AP_ADD STRUC
apa_format      DB      ?       ; AP_FORMAT_ADD
apa_cbSize      DB      ?       ; number of bytes in the whole struct
apa_offset      DW      ?       ; offset within the segment
apa_cb          DB      ?       ; number of bytes to replace
apa_abNew       DB      ?       ; cb DUP (?) ; new bytes
AP_ADD ENDS



DataBegin

szREGSTR_PATH_APPPATCH  db      REGSTR_PATH_APPPATCH, "\", 0

; app-patching cache
globalW  hExePatchAppCache    0
globalD  hkeyPatchAppCache    0


DataEnd



sBegin NRESCODE
assumes CS,NRESCODE

;  GetPatchAppCache
;
;	Gets an hkeyReg from the PatchApp cache if hExe in cache.
;
; Arguments:
;	hExe
;
; Returns:
;       dx:ax   -1 if cache miss
;               registry key associated with hExe if cache hit
;
; Registers Preserved:
;	DI, SI, DS

	assumes ds,nothing
	assumes es,nothing

;HKEY
cProc	GetPatchAppCache, <PUBLIC, NEAR>, <ds>
        parmW   hExe
cBegin
        SetKernelDSNRes

        ; Set up dx==ax==-1 (indicates cache miss)
        sub     ax, ax
        dec     ax
        mov     dx, ax

        mov     cx, hExe
        cmp     cx, hExePatchAppCache
        jne short gpac_exeunt

        mov     dx, hkeyPatchAppCache.hi
        mov     ax, hkeyPatchAppCache.lo
        krDebugOut  DEB_WARN,"GetPatchAppCache: hit (#cx, #dx#ax)"
gpac_exeunt:
        UnSetKernelDS
cEnd


;  AddPatchAppCache
;
;	Adds an (hExe,hkeyReg) pair to the PatchApp cache.
;
; Arguments:
;	hExe
;       hkeyReg
;
; Returns:
;
;
; Registers Preserved:
;	DI, SI, DS

	assumes ds,nothing
	assumes es,nothing

;VOID
cProc	AddPatchAppCache, <PUBLIC, NEAR>, <ds>
        parmW   hExe
        parmD   hkeyReg
cBegin
        SetKernelDSNRes

        mov     ax, hExe
        mov     hExePatchAppCache, ax

        mov     edx, hkeyReg
        mov     hkeyPatchAppCache, edx
if KDEBUG
        push    cx
        mov     cx, hkeyPatchAppCache.hi
        krDebugOut  DEB_WARN,"AddPatchAppCache: (#ax, #cx#dx)"
        pop     cx
endif

        UnSetKernelDS
cEnd


;  FlushPatchAppCache
;
;	Flushes an hExe from the PatchApp cache.
;       If the cache has a reg key for the hExe, closes the key.
;
; Arguments:
;	hExe
;
; Returns:
;
; Remarks:
;       called by DelModule
;
; Registers Preserved:
;	DI, SI, DS

	assumes ds,nothing
	assumes es,nothing

;VOID
cProc	FlushPatchAppCache, <PUBLIC, NEAR>, <>
        parmW   hExe
cBegin
;        CheckKernelDS
        ReSetKernelDS

        mov     ax, hExe
        krDebugOut  DEB_TRACE,"FlushPatchAppCache: (hExe #ax)"
        cmp     ax, hExePatchAppCache
        jne short fpac_exeunt

        sub     eax, eax
        cmp     eax, hkeyPatchAppCache
        je short fpac_after_close_key
        cCall  RegCloseKey32, <hkeyPatchAppCache>
if KDEBUG
        mov     cx, hExe
        mov     bx, hkeyPatchAppCache.lo
        mov     dx, hkeyPatchAppCache.hi
        krDebugOut  DEB_WARN,"FlushPatchAppCache: flushing (hExe #cx) (hkey #dx#bx)"
endif

fpac_after_close_key:
        mov     hExePatchAppCache, ax
if KDEBUG
        mov     hkeyPatchAppCache, eax          ; a little extra for debug
endif

fpac_exeunt:
        UnSetKernelDS
cEnd


;  PatchGetFileSize
;
;	Get the size of a file, given the DOS file handle.
;
; Arguments:
;	dfh     - DOS file handle
;
; Returns:
;	DWORD file size
;
; Remarks:
;       Since these patches are only for old (<4.0) apps, only support
;       DWORD file size.
;
; Registers Preserved:
;	DI, SI, DS

	assumes ds,nothing
	assumes es,nothing

;DWORD
cProc   PatchGetFileSize, <PUBLIC, NEAR>, <ds,si,di>
        parmW   dfh

        localV  FileInformation,<SIZE BY_HANDLE_FILE_INFORMATION>
        localW  HiPosition
        localW  LoPosition

        localW  SavePDB

cBegin
; MultiThreading version of change PDB
;        cCall   GetCurPDB
;        mov     SavePDB, ax
;        SetKernelDSNRes
;        cCall   SetCurPDB,<topPDB>              ; kernel's PSP
;        UnSetKernelDS
; MultiThreading version of change PDB
        SetKernelDSNRes                 ; ds is a scratch reg -> no need restore
        mov     ax, topPDB
        xchg    Win_PDB, ax             ; Switch to Kernel's PDB,
        UnSetKernelDS
        mov     SavePDB, ax             ; saving current PDB

	mov	bx, dfh
        smov    ds, ss
        lea     dx, FileInformation
        stc                         ; Real-mode drivers don't set CY on error
	mov	ax, 71a6h
        int     21h
        jc short gfs_try_offsets

        mov     dx, FileInformation.bhfi_nFileSizeLow.hi
        mov     ax, FileInformation.bhfi_nFileSizeLow.lo
        jmp short gfs_exeunt

gfs_try_offsets:
        ; Real-mode drivers don't support 71a6, so we do it the hard way.
        ; Move from current by 0 to get the current postion
	mov	bx, dfh
        sub     cx, cx
        mov     dx, cx
        mov     ax, 4201h
        int     21h
        jc short gfs_fail

        ; Save current position
        mov     HiPosition, dx
        mov     LoPosition, ax

        ; Get file size by moving from end by 0
        sub     cx, cx
        mov     dx, cx
        mov     ax, 4202h
        int     21h
        jc short gfs_fail

        push    dx
        push    ax

        ; Restore current position
        mov     cx, HiPosition
        mov     dx, LoPosition
        mov     ax, 4200h
        int     21h
        ; Don't check for error, since we can't recover any more anyway...

        pop     ax
        pop     dx
        jmp short gfs_exeunt

gfs_fail:
        sub     ax, ax
        mov     dx, ax
gfs_exeunt:
; MultiThreading version of change PDB
        push    ax
        mov     ax, SavePDB
        SetKernelDSNRes                  ; ds restored on proc exit
        mov     Win_PDB, ax
        UnSetKernelDS
;        cCall   SetCurPDB,<SavePDB>     ; preserves dx
        pop     ax
; MultiThreading version of change PDB

cEnd


;  CompareFileBytes
;
;	Compares a sequence of bytes with those at a given offset in a file.
;
; Arguments:
;	dfh
;       lpBytes
;       cb
;       dwFileOffset
;
; Returns:
;	WORD, zero iff match
;
; Remarks:
;       The caller is responsible for preserving the offset in the file.
;
; Registers Preserved:
;	DI, SI, DS

	assumes ds,nothing
	assumes es,nothing

;WORD
cProc   CompareFileBytes, <PUBLIC, NEAR>, <si,di,ds>
        parmW   dfh
        parmD   lpBytes
        parmW   cb
        parmD   dwFileOffset
cBegin
        ; Seek to dwFileOffset.
        mov     bx, dfh
        mov     cx, dwFileOffset.hi
        mov     dx, dwFileOffset.lo
        mov     ax, 4200h
        int     21h
        jc short cfb_fail

if KDEBUG
        ; The high byte of cb _must_ be 0.
        mov     cx, cb
        cmp     ch, 0
        je short @F
        krDebugOut  DEB_FERROR,"CompareFileBytes: cb (#cx) > 0ffh"
@@:
endif
        mov     byte ptr [cb].1, 0      ; force cb < 100h

        ; Read from file.
        mov     cx, cb
        smov    ds, ss
        sub     sp, cx
        mov     dx, sp                  ; ds:dx = read buffer
        mov     ah, 3fh
        int     21h
        jc short cps_fail_restore_stack

        ; Make sure we filled the buffer.
        cmp     ax, cx
        jne short cps_fail_restore_stack

        ; Compare the bytes.
        les     di, lpBytes             ; es:di = signature bytes
        smov    ds, ss
        mov     si, sp                  ; ds:si = read buffer
        rep     cmpsb
        jne short cps_fail_restore_stack

        sub     ax, ax
        add     sp, cb
        jmp short cfb_exit

cps_fail_restore_stack:
        add     sp, cb
cfb_fail:
        or      al, 1
cfb_exit:
cEnd


;  ComparePatchSignature
;
;	Tests a patch signature against an hExe.
;
; Arguments:
;	hExe
;       lpPatchSignature
;
; Returns:
;	WORD, zero iff match
;
; Registers Preserved:
;	DI, SI, DS

	assumes ds,nothing
	assumes es,nothing

;WORD
cProc   ComparePatchSignature, <PUBLIC, NEAR>, <si,di,ds>
        parmW   hExe
        parmD   lpPatchSignature

        localW  SavePDB
        localW  dfh
        localW  cbNonZero
        localD  dwFileOffset
cBegin
beg_fault_trap cps_fault
        mov     es, hExe
        lds     si, lpPatchSignature

        cld
        .errnz  AP_SIG.sig_format
        lodsb
;---------------------------------------------------
        cmp     al, AP_SIG_FORMAT_META
        jne short cps_maybe_hexe

        .errnz  (AP_SIG_HEXE.ms_cb - AP_SIG_HEXE.ms_format) - 1
cps_loop_meta:
        lodsb
        mov     ah, 0
        mov     cx, ax          ; cx = size of sub-signature
        jcxz    cps_meta_exeunt ; end of list. must be match.

        mov     di, si
        add     di, cx          ; ds:di = next sub-signature
        cCall   ComparePatchSignature,<hExe,ds,si>
        test    ax, ax
        jnz     cps_fail
        ; Got a match. Try the next one.
        mov     si, di          ; ds:si = next sub-signature
        jmp     cps_loop_meta

cps_meta_exeunt:
        jmp     cps_exeunt

;---------------------------------------------------
; AP_SIG_FORMAT_HEXE
; AP_SIG_FORMAT_HEXE2
cps_maybe_hexe:
        .errnz (AP_SIG_FORMAT_HEXE2-AP_SIG_FORMAT_HEXE)-1
        cmp     al, AP_SIG_FORMAT_HEXE
        jb short cps_maybe_filesize
        cmp     al, AP_SIG_FORMAT_HEXE2
        ja short cps_maybe_filesize

        ; Compute number of bytes in offset after first byte.
        mov     dl, al
        sub     dl, AP_SIG_FORMAT_HEXE

        .errnz  (AP_SIG_HEXE.es_cb - AP_SIG_HEXE.es_format) - 1
        mov     ah, 0
cps_hexe_loop:
        lodsb
        mov     cx, ax          ; cx = size of signature block
        jcxz    cps_hexe_match  ; end of list. must be match.

        ; Set up bx with the offset in the hExe
        sub     bx, bx          ; bx = default offset (0)
        lodsb
        mov     bl, al          ; bl = low byte of offset
        test    dl, dl          ; more bytes?
        jz short @F
        lodsb
        mov     bh, al          ; bh = high byte of offset
@@:
        mov     di, bx          ; es:di points to bytes in hExe
        rep     cmpsb
        jne     cps_fail
        jmp     cps_hexe_loop

cps_hexe_match:
        ; ax already 0
        jmp     cps_exeunt

;---------------------------------------------------
; AP_SIG_FORMAT_FILESIZE2
; AP_SIG_FORMAT_FILESIZE3
; AP_SIG_FORMAT_FILESIZE4
cps_maybe_filesize:
        .errnz (AP_SIG_FORMAT_FILESIZE3-AP_SIG_FORMAT_FILESIZE2)-1
        .errnz (AP_SIG_FORMAT_FILESIZE4-AP_SIG_FORMAT_FILESIZE3)-1
        cmp     al, AP_SIG_FORMAT_FILESIZE2
        jb short cps_maybe_file
        cmp     al, AP_SIG_FORMAT_FILESIZE4
        ja short cps_maybe_file

        ; Compute number of non-zero bytes in file size high word
        mov     cl, al
        sub     cl, AP_SIG_FORMAT_FILESIZE2
        push    cx

; MultiThreading version of change PDB
;        cCall   GetCurPDB
;        mov     SavePDB, ax
;        SetKernelDSNRes es
;        cCall   SetCurPDB,<topPDB>              ; kernel's PSP
;        UnSetKernelDS es
; MultiThreading version of change PDB
        push    ds
        SetKernelDSNRes
        mov     ax, topPDB
        xchg    Win_PDB, ax             ; Switch to Kernel's PDB,
        UnSetKernelDS
        pop     ds
        mov     SavePDB, ax             ; saving current PDB

        ; Since these patches are only for old (<4.0) apps, only support
        ; DWORD file size.
        or      ax, -1
        cCall   FarGetCachedFileHandle,<hExe,ax,ax>
        cmp     ax, -1
        je short cps_filesize_fh_cache_miss

        cCall   PatchGetFileSize,<ax>
        pop     cx              ; cl = non-zero bytes in file size high word

        ; Low word of file size must match.
        ; [si] = low byte of signature file size
        cmp     ax, [si]
        jne short cps_filesize_fail

        mov     ch, 0
        sub     bx, bx          ; bx = default high word of file size (0)
        jcxz    cps_filesize_compare_high

        ; [si] = low word of signature file size
        inc     si
        inc     si
        ; [si] = low byte of high word of signature file size (if exists)
        ; bx = 0
        ; cx = [1|2], non-zero bytes in file size high word
        lodsb
        mov     bl, al
        dec     cl
        jcxz    cps_filesize_compare_high
        lodsb
        mov     bh, al
cps_filesize_compare_high:
        cmp     bx, dx
        jne short cps_filesize_fail

cps_filesize_match:
        ; File size matches.
; MultiThreading version of change PDB
;        cCall   SetCurPDB,<SavePDB>
; MultiThreading version of change PDB
        mov     ax, SavePDB
        push    ds
        SetKernelDSNRes
        mov     Win_PDB, ax
        UnSetKernelDS
        pop     ds

        sub     ax, ax
        jmp     cps_exeunt

cps_filesize_fh_cache_miss:
        krDebugOut DEB_ERROR,"ComparePatchSignature: filesize fh cache miss"

cps_filesize_fail:
; MultiThreading version of change PDB
;        cCall   SetCurPDB,<SavePDB>
; MultiThreading version of change PDB
        mov     ax, SavePDB
        push    ds
        SetKernelDSNRes
        mov     Win_PDB, ax
        UnSetKernelDS
        pop     ds

        jmp     cps_fail

;---------------------------------------------------
; AP_SIG_FORMAT_FILE2
; AP_SIG_FORMAT_FILE3
; AP_SIG_FORMAT_FILE4
cps_maybe_file:
        .errnz (AP_SIG_FORMAT_FILE3-AP_SIG_FORMAT_FILE2)-1
        .errnz (AP_SIG_FORMAT_FILE4-AP_SIG_FORMAT_FILE3)-1
        cmp     al, AP_SIG_FORMAT_FILE2
        jb      cps_bad_format
        cmp     al, AP_SIG_FORMAT_FILE4
        ja      cps_bad_format

        ; Compute number of non-zero bytes in file offset high word
        mov     cl, al
        sub     cl, AP_SIG_FORMAT_FILE2
        mov     ch, 0
        mov     cbNonZero, cx

; MultiThreading version of change PDB
;        cCall   GetCurPDB
;        mov     SavePDB, ax
;        SetKernelDSNRes es
;        cCall   SetCurPDB,<topPDB>              ; kernel's PSP
;        UnSetKernelDS es
; MultiThreading version of change PDB
        push    ds
        SetKernelDSNRes
        mov     ax, topPDB
        xchg    Win_PDB, ax             ; Switch to Kernel's PDB,
        UnSetKernelDS
        pop     ds
        mov     SavePDB, ax             ; saving current PDB

        mov     es, hExe

        or      ax, -1
        push    es
        cCall   FarGetCachedFileHandle,<es,ax,ax>
        pop     es
        cmp     ax, -1
        je short cps_file_fh_cache_miss

        mov     bx, ax          ; bx = dos file handle
        mov     dfh, ax
        sub     cx, cx
        mov     dx, cx
        mov     ax, 4201h
        int     21h
        jc      cps_fail

        mov     dwFileOffset.hi, dx
        mov     dwFileOffset.lo, ax

cps_file_loop:
        lodsb
        mov     ah, 0
        mov     cx, ax          ; cx = size of signature block
        jcxz    cps_file_match  ; end of list. must be match.

        mov     di, cx          ; di = number of bytes to match

        ; Get the file offset into dx:bx
        ; First get the low word.
        lodsw
        mov     bx, ax          ; bx = low word of file offset

        ; Get one or both bytes of the high word.
        sub     dx, dx          ; dx = default high word of file offset (0)
        mov     cx, cbNonZero
        jcxz    cps_file_compare
        ; [si] = low byte of high word of file offset
        ; dx = 0
        ; cx = [1|2], non-zero bytes in file offset high word
        lodsb
        mov     dl, al
        dec     cl
        jcxz    cps_file_compare
        lodsb
        mov     dh, al

cps_file_compare:
        ; ds:[si] = bytes to match in file
        ; di      = byte count
        ; dx:bx   = offset in file
        cCall   CompareFileBytes,<dfh,ds,si,di,dx,bx>
        test    ax, ax
        jnz short cps_file_fail

        add     si, di          ; ds:si = next signature block
        jmp     cps_file_loop

cps_file_fh_cache_miss:
        krDebugOut DEB_ERROR,"ComparePatchSignature: file fh cache miss"

cps_file_fail:
        or      al, 1
        jmp short cps_file_exit

cps_file_match:
        sub     ax, ax

cps_file_exit:
        mov     si, ax          ; si = return value

        ; Restore file position
        mov     bx, dfh         ; bx = dos file handle
        mov     cx, dwFileOffset.hi
        mov     dx, dwFileOffset.lo
        mov     ax, 4200h
        int     21h
        ; Don't check error, since we can't do anything anyway.
if KDEBUG
        jnc short @F
        krDebugOut DEB_ERROR,"ComparePatchSignature: failure restoring file position"
@@:
endif
; MultiThreading version of change PDB
;        cCall   SetCurPDB,<SavePDB>
; MultiThreading version of change PDB
        mov     ax, SavePDB
        push    ds
        SetKernelDSNRes
        mov     Win_PDB, ax
        UnSetKernelDS
        pop     ds

        mov     ax, si
        jmp short cps_exeunt

;---------------------------------------------------
end_fault_trap
cps_fault:
        fault_fix_stack
        krDebugOut  DEB_ERROR,"ComparePatchSignature: trapped fault"

cps_bad_format:
        krDebugOut  DEB_ERROR,"ComparePatchSignature: invalid format"
cps_fail:
        or      al, 1           ; ensure we return "no_match"
cps_exeunt:
cEnd


;  GetPatchAppRegKey
;
;	Determines if we patch an app at load time, gets reg key if so.
;
; Arguments:
;	hExe
;
; Returns:
;	HKEY, non-zero iff we segment-patch info in the registry for this app.
;
; Registers Preserved:
;	DI, SI, DS, ES

	assumes ds,nothing
	assumes es,nothing

;HKEY
cProc	GetPatchAppRegKey, <PUBLIC, FAR>, <si,di,ds,es>
        parmW   hExe

szKey_size             = 200
abPatchSignature_size  = 100

        localD  hkeyModule
        localD  hkeySignature
        localD  dwIndex
        localV  szKey,szKey_size                          ; BUGBUG need a better size
        localV  abPatchSignature,abPatchSignature_size    ; BUGBUG need a better size

cBegin
        ; We must refuse to patch system modules.
        ; Should be ok because of version check (in caller).
if KDEBUG
        mov     es, hExe
        cmp     es:[ne_expver], 400h    ; Hacks don't apply to 4.0 or above
        jb short @F
        ; Should never get here since the caller should have already checked.
        krDebugOut  DEB_ERROR,"GetPatchAppRegKey: (#es) version later than 4.0"
@@:
endif
        cCall   GetPatchAppCache,<hExe>
        ; ffff:ffff means a cache miss
        or      cx, -1
        cmp     cx, dx
        jne     gpark_exeunt
        cmp     cx, ax
        jne     gpark_exeunt

        ; Not in the cache. Get it from the registry and add to the cache.

        ; Copy the subkey prefix to the buffer.
        lea     di, szKey
        smov    es, ss
        SetKernelDSNRes
        lea     si, szREGSTR_PATH_APPPATCH
	mov	cx, szKey_size
@@:
	lodsb
	stosb
	test	al, al
	loopnz	@B
if KDEBUG
        jz short @F
        krDebugOut  DEB_ERROR,"GetPatchAppRegKey: len(szREGSTR_PATH_APPPATCH) > szKey_size"
@@:
endif
        dec     di
        UnSetKernelDS

        ; Append the module's base name (pascal format).
        mov     ds, hExe
        mov     si, ds:[ne_restab]
        lodsb
if KDEBUG
        mov     ah, 0
        cmp     cx, ax
        ja short @F
        krDebugOut  DEB_ERROR,"GetPatchAppRegKey: len(reg path) > szKey_size"
@@:
endif
        movzx   cx, al
        rep     movsb
        sub     al, al
        stosb                           ; NULL terminator

        ; Get the key for this module.
        mov     hkeySignature, 0        ; In case we fail.
        mov     eax, HKEY_LOCAL_MACHINE
        lea     si, szKey
        lea     di, hkeyModule
        ccall   RegOpenKey32, <eax, ss, si, ss, di>
        or      ax,dx
        jnz     gpark_fail2

        or      dwIndex, -1             ; == mov dwIndex,-1 (but smaller)
gpark_loop:
        inc     dwIndex
        lea     si, szKey
        ccall   RegEnumKey32, <hkeyModule, dwIndex, ss, si, 0, szKey_size>
        or      ax, dx
        jnz short gpark_loop_done

        ; First, convert string to binary.
        ; Reuse szKey since we don't need path any more (we have hKeyModule).
        lea     si, abPatchSignature
        lea     di, szKey
        krDebugOut  DEB_WARN,"GetPatchAppRegKey: checking signature (@ss:di)"
        cCall   ConvertPatchStringToBinary,<ss,si,abPatchSignature_size,ss,di>
        ; Skip a badly formatted patch signature.
        test    ax, ax
if KDEBUG
        jnz short @F
        lea     cx, szKey
        krDebugOut  DEB_ERROR,"PatchAppSeg: bad patch signature in registry, @ss:cx"
@@:
endif
        jz      gpark_loop

        cCall   ComparePatchSignature,<hExe,ss,si>
        test    ax, ax
        jne     gpark_loop

if KDEBUG
        mov     ax, hExe
        krDebugOut  DEB_WARN,"GetPatchAppRegKey: (#ax) sig matches (@ss:di)"
endif
        ; We have a match. Get the corresponding key.
        lea     si, szKey
        lea     di, hkeySignature
        ccall   RegOpenKey32, <hkeyModule, ss, si, ss, di>
        or      ax,dx
        jz short gpark_add

        krDebugOut  DEB_ERROR,"GetPatchAppRegKey: RegOpenKey failed, #dx#ax"
        jmp short gpark_fail

gpark_loop_done:

if KDEBUG
        test    dx, dx
        jnz short @F
        cmp     ax, ERROR_NO_MORE_ITEMS
        je short gpark_after_loop_done_err
@@:
        krDebugOut  DEB_ERROR,"GetPatchAppRegKey: unexpected error #dx#ax"
gpark_after_loop_done_err:
endif

gpark_fail:
        ; Mark that there are no patches in the registry.
        mov     hkeySignature, 0
gpark_add:
        ; Close the reg key for the path to the end of the module name
        cCall  RegCloseKey32, <hkeyModule>

gpark_fail2:
        ; Add hkeySignature to the cache and set up return regs.
        cCall   AddPatchAppCache,<hExe, hkeySignature>

        mov     ax, hkeySignature.lo
        mov     dx, hkeySignature.hi
gpark_exeunt:
cEnd

;  ConvertPatchStringToBinary
;
;	Convert a string of [0-9,A-F] with nibble-swapped bytes to binary.
;
; Arguments:
;	lpBinary - output buffer
;	cbBinary - size of output buffer in bytes
;       lpString - input NULL-terminated string
;
; Returns:
;	Boolean, TRUE iff we convert the entire string.
;
; Registers Preserved:
;	DI, SI, DS, ES

	assumes	ds, nothing
	assumes	es, nothing

;BOOL
cProc   ConvertPatchStringToBinary, <PUBLIC, NEAR>,<di,si,ds>
        parmD   lpBinary
        parmW   cbBinary
        parmD   lpString
cBegin
        krDebugOut  DEB_WARN,"ConvertPatchStringToBinary: enter"
        mov     cx, cbBinary
        jcxz    cpstb_bad

        les     di, lpBinary
        lds     si, lpString
        sub     ah, ah

cpstb_loop:
        lodsb
        cmp     al, 0
        je short cpstb_maybe_good
        cmp     al, ' '
        je      cpstb_loop
        cmp     al, ','
        je      cpstb_loop
        cmp     al, '0'
        jb short cpstb_bad
        cmp     al, '9'
        ja short cpstb_maybe_lower

        ; digit
        sub     al, '0'
        jmp short cpstb_have_nibble

cpstb_maybe_lower:
        or      al, 20h                 ; map upper-case to lower-case
        cmp     al, 'f'
        ja short cpstb_bad
        cmp     al, 'a'
        jb short cpstb_bad

        ; lower-case
        sub     al, 'a'-10

cpstb_have_nibble:
        cmp     ah, 0
        jne short cpstb_store_byte
        mov     ah, al
        or      ah, 80h
        jmp     cpstb_loop

cpstb_store_byte:
        shl     ah, 4
        or      al, ah
        stosb
        sub     ah, ah
        loop    cpstb_loop
cpstb_bad:
        krDebugOut DEB_ERROR, "ConvertPatchStringToBinary: bad char #al, or bad buffer size"
        sub     ax, ax
        jmp short cpstb_end
cpstb_maybe_good:
        cmp     ah, 0           ; odd-length input string ?
        jne     cpstb_bad
cpstb_good:
        or      al, 1
cpstb_end:
cEnd


;  PatchAppSegWorker
;
;	Do the work of patching an app segment.
;
; Arguments:
;	wSeg            - the segment we are about to patch
;   wPartySeg       - a data aliase of the segment we are about to patch
;   cbOriginalSeg   - the value returned by GlobalSize(wSeg)
;	lpcbCurrentSeg  - ptr to the current size of the segment
;       lpBinaryPatch   - the APPPATCH struct to apply to wSeg
;
; Returns:
;	VOID
;
; Registers Preserved:
;	DI, SI, DS

	assumes	ds, nothing
	assumes	es, nothing

;VOID
cProc   PatchAppSegWorker, <PUBLIC, NEAR>,<si,di,ds>
        parmW   wSeg
        parmW   wPartySeg
        parmW   cbOriginalSeg
        parmD   lpcbCurrentSeg
        parmD   lpBinaryPatch

        localW  wAddPartySeg

cBegin
        lds     si, lpBinaryPatch
        mov     es, wPartySeg
        krDebugOut  DEB_WARN,"PatchAppSegWorker: applying patch to party seg #es"

        mov     al, [si].AP_COMMON.ap_format
        cmp     al, AP_FORMAT_REPLACE
        jne short pasw_maybe_add

        ; Replace some code in a segment.
        krDebugOut  DEB_WARN,"PatchAppSegWorker: type==replace"

        ; Check size
        mov     ch, 0
        mov     cl, [si].AP_REPLACE.apr_cb
        mov     al, (AP_REPLACE.apr_abOld - AP_REPLACE.apr_format)
        add     al, cl
        add     al, cl
        cmp     al, [si].AP_REPLACE.apr_cbSize

if KDEBUG
        je short @F
        mov     ah, ch
        mov     dh, ch
        mov     dl, [si].AP_REPLACE.apr_cbSize
        krDebugOut  DEB_ERROR,"PatchAppSegWorker: actual size (#ax) != apa_cbSize (#dx)"
@@:
endif
        jne     pasw_end
        mov     di, [si].AP_REPLACE.apr_offset
        add     di, cx
        cmp     di, cbOriginalSeg
        ja      pasw_replace_offset_too_large

        sub     di, cx
        add     si, (AP_REPLACE.apr_abOld - AP_REPLACE.apr_format)
        repe    cmpsb                   ; compare old bytes to hExe bytes
        jne     pasw_repl_no_match

        mov     si, lpBinaryPatch.lo
        mov     ch, 0
        mov     cl, [si].AP_REPLACE.apr_cb
        add     si, (AP_REPLACE.apr_abOld - AP_REPLACE.apr_format)
        add     si, cx                  ; skip over the old bytes
        sub     di, cx                  ; rewind to the patch area start
        rep     movsb                   ; replace the bytes
        jmp     pasw_end
pasw_maybe_add:
        cmp     al, AP_FORMAT_ADD
        jne pasw_bad_format

        ; Add some code to the segment.
        krDebugOut  DEB_WARN,"PatchAppSegWorker: type==add"

        ; Check size
        mov     ch, 0
        mov     cl, [si].AP_ADD.apr_cb
        mov     al, (AP_ADD.apa_abNew - AP_ADD.apa_format)
        add     al, cl
        cmp     al, [si].AP_ADD.apa_cbSize
if KDEBUG
        je short @F
        mov     ah, ch
        mov     dh, ch
        mov     dl, [si].AP_ADD.apa_cbSize
        krDebugOut  DEB_ERROR,"PatchAppSegWorker: actual size (#ax) != apa_cbSize (#dx)"
@@:
endif
        jne     pasw_end

        ; Make sure the add is beyond the original segment.
        mov     di, [si].AP_ADD.apa_offset
        cmp     di, cbOriginalSeg
        jb short pasw_offset_too_small

        ; Grow the segment if necessary.
        mov     ah, 0
        mov     al, [si].AP_ADD.apa_cb
        add     di, ax

        ; See if the segment is already big enough.
        les     bx, lpcbCurrentSeg
        cmp     di, es:[bx]
        jbe short pasw_do_add

        ; Segment too small. Grow it.
        cCall   GlobalRealloc,<wSeg,0,di,0>
        ; Make sure we got the same sel back.
        mov     cx, wSeg
        and     al, not 1
        and     cl, not 1
        cmp     ax, cx
        jne short pasw_repl_realloc_failed

        ; Save the new size of the segment.
        les     bx, lpcbCurrentSeg
        mov     es:[bx], di

pasw_do_add:
        mov     ch, 0
        mov     cl, [si].AP_ADD.apa_cb

        ;Since wSeg may have grown, create a new party seg.
        mov     bx, wSeg
        mov     ax, 000Ah               ;DPMI, Create Code Segment Alias
        int     031h
        mov     es, ax

        sub     di, cx
        add     si, (AP_ADD.apa_abNew - AP_ADD.apa_format)
        rep     movsb                   ; add the bytes
        cCall   FreeSelector, <es>

if KDEBUG
        jmp short  pasw_end
endif

pasw_bad_format:
if KDEBUG
        sub     ah, ah
        krDebugOut  DEB_ERROR,"PatchAppSegWorker: unknown format #ax"
        jmp short  pasw_end
endif
pasw_repl_realloc_failed:
if KDEBUG
        mov     ax, wSeg
        krDebugOut  DEB_ERROR,"PatchAppSegWorker: realloc failed on seg #ax"
        jmp short  pasw_end
endif
pasw_repl_no_match:
if KDEBUG
        krDebugOut  DEB_WARN,"PatchAppSegWorker: replace failed in seg #es"
        jmp short  pasw_end
endif
pasw_offset_too_small:
if KDEBUG
        mov     cx, cbOriginalSeg
        krDebugOut  DEB_ERROR,"PatchAppSegWorker: add offset (#di) < size (#cx)"
        jmp short  pasw_end
endif
pasw_replace_offset_too_large:
if KDEBUG
        mov     cx, cbOriginalSeg
        krDebugOut  DEB_ERROR,"PatchAppSegWorker: replace offset (#di) > size (#cx)"
endif
pasw_end:

cEnd


;  PatchAppSeg
;
;	Apply any patches for the given segment.
;
; Arguments:
;       hkeyPatchApp - reg key containing patches for this app
;	wSegNo       - number of the segment in the module
;       wSeg         - selector of the segment
;
; Returns:
;	BOOL - ax!=0 iff one or more patches applied
;
; Registers Preserved:
;	CX, DI, SI, DS, ES

	assumes	ds, nothing
	assumes	es, nothing

;BOOL
cProc   PatchAppSeg, <PUBLIC, FAR>,<cx,si,di,ds,es>
        parmD   hkeyPatchApp
        parmW   wSegNo
        parmW   wSeg

szKey_size          =   5
szValString_size    =  32
abValData_size      = 100
abBinaryPatch_size  = 100

        localD  hkey
        localV  szKey,szKey_size                    ; BUGBUG need a better size
        localV  szValString,szValString_size        ; BUGBUG need a better size
        localV  abValData,abValData_size            ; BUGBUG need a better size
        localV  abBinaryPatch,abBinaryPatch_size    ; BUGBUG need a better size
        localD  cbValString
        localD  cbValData
        localD  dwType
        localD  dwIndex
        localW  cbOriginalSeg
        localW  cbCurrentSeg
        localW  wPartySeg

cBegin
if KDEBUG
        mov     ax, wSegNo
        mov     bx, wSeg
        krDebugOut  DEB_WARN,"PatchAppSeg: enter, (wSegNo #ax) (wSeg #bx)"
endif
        push    wSeg
        call    GlobalSize
        mov     cbOriginalSeg,ax
        mov     cbCurrentSeg,ax

        ; Segment number is the subkey.

        lea     si, szKey
        cCall   Far_htoa0, <ss, si, wSegNo>
        mov     bx, ax
        mov     byte ptr ss:[bx], 0     ; NULL terminator

        ; Get the key for this module/seg pair.
        lea     si, szKey
        lea     di, hKey
        cCall   RegOpenKey32, <hkeyPatchApp, ss, si, ss, di>
        or      ax,dx
        jnz     pas_no_patches

        ; Turn off the code bit for the seg to make it writeable.
        ; NB - Bail if this is a data segment.



        mov     bx, seg gdtdsc
        mov     ds, bx
        assume  ds:nothing
        mov     ds, ds:gdtdsc
        mov     bx, wSeg
        and     bl, not 7
        test    byte ptr ds:[bx+5], DSC_CODE_BIT
        jz      pas_no_patches                  ; bail if data seg

        mov     bx, wSeg
        mov     ax, 000Ah               ;DPMI, Create Code Segment Alias
        int     031h
        mov     wPartySeg, ax

        ; Mark this code segment not discardable so we don't have to deal
        ; with patching it again.
        call    Far_genter
        mov dx, wSeg
        call    Far_pdref
        ; ds:esi = arena record
        and ds:[esi].pga_flags, not (GA_DISCARDABLE or GA_DISCCODE)
        call    Far_gleave

        or      dwIndex, -1
pas_loop:
        sub     ecx, ecx
        inc     dwIndex

        push    dword ptr hkey
        push    dword ptr dwIndex
        mov     cbValString, szValString_size
        mov     cbValData, abValData_size
        push    ss
        lea     ax, szValString
        push    ax
        push    ss
        lea     ax, cbValString
        push    ax
        push    ecx
        push    ss
        lea     ax, dwType
        push    ax
        push    ss
        lea     ax, abValData
        push    ax
        push    ss
        lea     ax, cbValData
        push    ax
        cCall   RegEnumValue32
        or      ax, dx
        jnz     pas_loop_done
if KDEBUG
        lea     bx, szValString
        krDebugOut  DEB_WARN,"PatchAppSeg: found patch @ss:bx"
endif

        cmp     dwType, REG_BINARY
        jne short pas_bad_type

        lea     bx, abValData                   ; ss:bx points to patch
        movzx   ecx, ss:[bx].AP_COMMON.ap_cbSize
        cmp     cbValData, ecx
if KDEBUG
        je short @F
        push    bx
        mov     eax, cbValData
        mov     edx, eax
        ror     edx, 16
        mov     ebx, ecx
        ror     ebx, 16
        krDebugOut  DEB_ERROR,"PatchAppSeg: actual size (#dx:#ax) != ap_cbSize (#bx:#cx)"
        pop     bx
@@:
endif
        jne     pas_loop

pas_apply_patch:
        lea     ax, cbCurrentSeg                ; ss:ax points to curr seg size
        ; Now apply the patch.

        cCall   PatchAppSegWorker,<wSeg,wPartySeg,cbOriginalSeg,ss,ax,ss,bx>
        jmp     pas_loop

pas_bad_type:
if KDEBUG
        mov     eax, dwType
        mov     edx, eax
        ror     edx, 16
        krDebugOut  DEB_WARN,"PatchAppSeg: unimplemented type #dx:#ax"
endif
        jmp     pas_loop

pas_no_patches:
        sub     ax, ax
        jmp short pas_end

pas_loop_done:
if KDEBUG
        test    dx, dx
        jnz short @F
        cmp     ax, ERROR_NO_MORE_ITEMS
        je short  pas_cleanup
@@:
        krDebugOut  DEB_WARN,"PatchAppSeg: unexpected error #dx#ax"
endif
pas_cleanup:
        cCall   FreeSelector, <wPartySeg>

        cCall   RegCloseKey32, <hkey>
        or      al, 1                       ; ax!=0 marks patch found in reg
pas_end:
cEnd

sEnd	NRESCODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\ripaux.asm ===
;-----------------------------------------------------------------------;
;									;
;   RIPAUX.ASM -							;
;									;
;	Debugging Support Routines					;
;									;
;-----------------------------------------------------------------------;

		TITLE	RIPAUX.ASM - Debugging Support Routines

;-----------------------------------------------------------------------;
;   INCLUDES								;
;-----------------------------------------------------------------------;

?RIPAUX = 1
.xlist
win3deb = 1
include kernel.inc
include newexe.inc
.list

;-----------------------------------------------------------------------;
;   DATA SEGMENT DEFINITION						;
;-----------------------------------------------------------------------;

DataBegin

externD  pDisableProc

if KDEBUG

externW  fWinX
externW  hExeHead
externB  szDebugStr

externW  DebugOptions
externW  DebugFilter
externB  fKTraceOut                ; Used by DebugWrite to ignore traces
else

externB  szExitStr1
externB  szExitStr2
externB  szFatalExit

endif

DataEnd

ifdef WOW
externFP FatalExitC
endif

;-----------------------------------------------------------------------;
;   CODE SEGMENT DEFINITION						;
;-----------------------------------------------------------------------;

sBegin	CODE

assumes CS,CODE
assumes DS,NOTHING
assumes ES,NOTHING


;-----------------------------------------------------------------------;
;   EXTERNS								;
;-----------------------------------------------------------------------;

externFP ExitKernel
externFP FatalAppExit

if KDEBUG

externFP KOutDebugStr
externNP DebugOutput2
externNP LogParamError2

else

externD  prevInt21Proc
externFP InternalDisableDOS

endif

externNP DebugLogError
externNP DebugLogParamError


; SAVEREGS - Preserve all registers
;
SAVEREGS    macro
.386
	push	ds	  ; preserve all registers
	push    es
	push    fs
	push    gs
	pushad
.286p
endm

; RESTOREREGS - Restore registeres preserved with SAVEREGS
;
RESTOREREGS macro
.386
	popad
	pop	gs
	pop	fs
	pop	es
	pop	ds
.286p
endm

; In Win3.1, different code is used for FatalExit on retail
; and debug builds.  WOW uses the code below derived from the
; debug wrapper for FatalExitC.  FatalExitC is a thunk to
; WOW32's WK32FatalExit thunk.


cProc FatalExit,<PUBLIC,FAR>
	parmW	errCode
cBegin nogen
	push	bp
	mov	bp, sp
	push	ds
	pusha
	setkernelds
        push    [bp+6]
        cCall   FatalExitC
        popa
	pop	ds
        INT3_DEBUG      ; Stop here so WDEB386 can generate same stack trace.
        pop     bp
	ret     2
cEnd nogen

if KDEBUG

BegData
szCRLF  db      13,10,0
EndData

; trashes ES - but caller saves it
cProc	KOutDSStr,<PUBLIC,FAR>,<ds>
	parmW	string
cBegin

.386p
	pushad				; save upper 16 bits of EAX, etc
	push	fs
	push	gs
.286p
	pushf
	push	cs
	push	ds
	push	es
	push	ss
	pusha
	SetKernelDS

	mov	si,string
	call	KOutDebugStr		; expects pusha right before call
	popa
	add	sp, 8			; don't need to restore seg regs
	popf
.386p
	pop	gs
	pop	fs
	popad
.286p
cEnd

cProc   _krDebugTest,<PUBLIC, FAR, NONWIN>,<DS>
	ParmW   flags
	ParmW	psz
	LocalW	axSave
	LocalW	bxSave
	LocalW	esSave
	LocalB	fBreakPrint
cBegin
	assumes ds,NOTHING
	mov	axSave,ax	; save these regs before they're trashed
	mov	bxSave,bx
	mov	esSave,es

;
; If this .exe hasn't been relocated yet, just call FatalExit.
;
	mov     ax,cs:MyCSDS
	cmp     ax,1000h        ;; DATA should be selector, not addr
	jc      @F
	jmp     kdtnobreak
@@:
	mov     es,ax
assumes es,DATA
;
; First use DebugOptions to determine whether we should print anything
; and/or break with a fatalexit.
;
	errnz   low(DBF_SEVMASK)
	errnz   low(DBF_TRACE)
	errnz   low(DBF_WARNING)
	errnz   low(DBF_ERROR)
	errnz   low(DBF_FATAL)

	mov     bx,es:DebugOptions
	mov     ax,flags
	and     ah,high(DBF_SEVMASK)
	mov     al,2                ; fBreak = FALSE, fPrint = TRUE
	cmp     ah,high(DBF_TRACE)
	jnz     notrace

	push    ax
	mov     es:fKTraceOut, 1    ; Set flag for DebugWrite
	mov     ax,flags            ; if (!((flags & DBF_FILTERMASK) & DebugFilter))
	and     ax,DBF_FILTERMASK
	test    ax,es:DebugFilter
	pop     ax
	jnz     @F
	and     al,not 2            ;    fPrint = FALSE
	jmp     short kdtnobreak
@@:
	test    bx,DBO_TRACEBREAK   ; else if (DebugOptions & DBO_TRACEBREAK)
	jnz     kdtbreak            ;    fBreak = TRUE
	jmp     short kdtnobreak

notrace:
	cmp     ah,high(DBF_WARNING)
	jnz     nowarn
	test    bx,DBO_WARNINGBREAK
	jnz     kdtbreak
	jmp     short kdtnobreak
nowarn:
	cmp     ah,high(DBF_ERROR)
	jnz     dofatal
	test    bx,DBO_NOERRORBREAK
	jnz     kdtnobreak
	jmp     short kdtbreak
dofatal:
	test    bx,DBO_NOFATALBREAK
	jnz     kdtnobreak
	errn$   kdtbreak
kdtbreak:
	or      al,1            ; fBreak = TRUE
kdtnobreak:
;
; If DBO_SILENT, then fPrint = FALSE
;
	test    bx,DBO_SILENT
	jz      @F
	and     al,not 2
@@:
	mov     fBreakPrint,al
;
; if (fBreak || fPrint)
;    print out the string
;
	or      al,al           ; if !(fBreak | fPrint)
	jz      kdtnoprint

assumes es,NOTHING
	mov	es,esSave	; restore registers
	mov	ax,axSave
	mov	bx,bxSave
	push    psz
	call    KOutDSStr       ; output the string

ifndef WOW
	push    offset szCRLF
        call    KOutDSStr
endif

kdtnoprint:
	test    fBreakPrint,1   ; if fBreak, then FatalExit
	jz      kdtexit
kdtdobreak:
	cCall   FatalExit,<flags>
kdtexit:
	SetKernelDS es
	mov	es:fKTraceOut,0 ; Clear DebugWrite flag

	mov	ax, axSave
	mov	bx, bxSave
	mov	es, esSave
cEnd

ifdef DISABLE

flags	equ	word ptr [bp+6]
msg	equ	word ptr [bp+8]
appDS	equ	word ptr [bp-2]
appAX	equ	word ptr [bp-4]
;myDS	equ	word ptr [bp-6]
_krDebugTest proc far			;Per-component - check right flags
public _krDebugTest
	push	bp
	mov	bp, sp
	push	ds			; at BP-2
	push	ax			; at BP-4
	mov	ax, _DATA
	cmp	ax, 1000h		;; DATA should be selector, not addr
	jnc	skip
	mov	ds, ax
	assume	ds:_DATA

	mov	ax, [flags]		; See if component enabled
	and	ax, [_krInfoLevel]
	and	al, byte ptr [_Win3InfoLevel] ; See if system enabled
	cmp	ax, [flags]
	jnz	skip

	push	bx            		; Print it, so format message
	test	al, DEB_ERRORS
	mov	bx, dataoffset STR_krError
	jnz	@F
	test	al, DEB_WARNS
	mov	bx, dataoffset STR_krWarn
	jnz	@F
	test	al, DEB_TRACES
	mov	bx, dataoffset STR_krTrace
	jz	short deb_no_msg_type

@@:	push	bx
	call	KOutDSStr

deb_no_msg_type:
	mov	bx, dataoffset STR_krTable
	or	ah, ah
	jz	deb_show_it
@@:     add	bx, 2			; get next string table entry
	shr	ah, 1			; find which category
	jnz	@B

deb_show_it:
	push	[bx]			;; push parameter
	call	KOutDSStr
	pop	bx			;; restore reg

	mov	ax, [appAX]		; print message passed in
	push	ds
	mov	ds, appDS               ; restore App ds for error strings
	push	[msg]
	call	KOutDSStr
	pop	ds			; restore kernel DS

	mov	ax, [flags]		; shall we have a breakpoint?
	and	ax, [_krBreakLevel]
	and	al, byte ptr _Win3BreakLevel
	cmp	ax, [flags]
	jnz	skip

	INT3_DEBUG
skip:
	test    byte ptr [flags], DEB_FERRORS
	jz	@F

        push    0
        push    cs:MyCSDS
	push	word ptr [bp+8]
	cCall	FatalAppExit	;,<0,DGROUP,[bp+8]>
@@:
	pop	ax
	pop	ds
	pop	bp
	retf
_krDebugTest endp
endif;  DISABLE

endif;  KDEBUG

ife KDEBUG			; RETAIL ONLY SECTION STARTS HERE!

ifndef WOW                      ; WOW uses only the "debug" version
                                ; of FatalExit which calls FatalExitC.
                                ; FatalExitC is thunked in WOW, the
                                ; version in rip.c is disabled.

;-----------------------------------------------------------------------;
;									;
;   FatalExit() -							;
;									;
;-----------------------------------------------------------------------;

; Retail version.  The Debug version is in RIP.C.

	assumes	ds, nothing
	assumes	es, nothing

cProc FatalExit,<PUBLIC,FAR>
	parmW	errCode
cBegin
	SetKernelDS
        push    0
	push    ds
	push    dataOffset szFatalExit
	cCall   IFatalAppExit   ;,<0, ds, dataOffset szUndefDyn>
cEnd

cProc FatalExitDeath,<PUBLIC,FAR>

	parmW	errCode

	localD	pbuf
	localV	buf,6
cBegin

if 0
	mov	ax,4CFFh
	int	21h
else
	SetKernelDS
	cCall	TextMode		; Is USER started?

;	cmp	pDisableProc.sel,0
;	je	fex1
;	cCall	pDisableProc		; Yes, Call USER's DisableOEMLayer()
;					;  to get to the text screen
;	jmps	fex1a
;fex1:
;	mov	ax, 6			; set text mode
;	int	10h
;fex1a:

; Is Int 21h hooked?

	cmp	prevInt21Proc.sel,0
	je	fex2
	cCall	InternalDisableDOS	; Yes, disable Int 21h

fex2:
	mov	cx,errCode		; No output if error code is zero
	jcxz	fe4

; Write "FatalExit = " message to STDOUT.

	mov	bx,1
	mov	dx,dataOffset szExitStr1
	mov	cx,20
	mov	ah,40h
	int	21h

; Error code of FFFF means Stack Overflow.

	mov	dx,errCode
	inc	dx
	jnz	fe1
	mov	dx,dataOffset szExitStr2 ; "Stack Overflow" message
	mov	cx,17
	mov	ah,40h
	int	21h
	jmps	fe4

	UnSetKernelDS
fe1:

; Write out error code in Hex.

	dec	dx
	push	ss
	pop	es
	lea	di,buf
	mov	ax,'x' shl 8 OR '0'
	stosw
	mov	cx,4
	rol	dx,cl			    ; Rotate most significant into view
fe2:
	mov	ax,dx
	and	ax,0Fh
	push	cx
	mov	cl,4
	rol	dx,cl			    ; Rotate next byte into view
	pop	cx
	add	al,'0'
	cmp	al,'9'
	jbe	fe3
	add	al,'A'-':'
fe3:
	stosb
	loop	fe2
	mov	ax,10 shl 8 OR 13
	stosw
	xor	ax,ax
	stosb
	lea	dx,buf
	push	ss
	pop	ds
	mov	cx,8
	mov	bx,1
	mov	ah,40h
	int	21h			    ; Write it out
fe4:
	mov	ax,errcode
	cCall	ExitKernel,<ax>
endif
cEnd

endif       ; ifndef WOW

else				    ; DEBUG ONLY SECTION STARTS HERE!

;-----------------------------------------------------------------------;
;									;
;   GetSymFileName() -							;
;									;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

ifdef WOW
cProc GetSymFileName,<PUBLIC,FAR>,<ds,si,di>
else
cProc GetSymFileName,<PUBLIC,NEAR>,<ds,si,di>
endif

ParmW hExe
ParmD lpName

cBegin
	cld
	les	di,lpName
	SetKernelDS
;;	cmp	fWinX,0
;;	je	slowboot
;;	mov	ax,hExe
;;	cmp	hExeHead,ax
;;	mov	ds,ax
;;	UnSetKernelDS
;;	je	makename
;;	mov	si,ds:[ne_pfileinfo]
;;	or	si,si
;;	jnz	havename
;;makename:
;;	mov	si,ds:[ne_restab]
;;	xor	ax,ax
;;	lodsb
;;	mov	cx,ax
;;	rep	movsb
;;appendext:
;;	mov	ax,'S.'
;;	stosw
;;	mov	ax,'MY'
;;	stosw
;;	xor	ax,ax
;;	stosb
;;	jmps	namedone
;;
;;slowboot:
	mov	ds,hExe
	mov	si,ds:[ne_pfileinfo]
havename:
	add	si,opFile
nameloop:
	lodsb
	cmp	al,'.'
	je	appendext
	stosb
	jmp	nameloop
appendext:
	mov	ax,'S.'
	stosw
	mov	ax,'MY'
	stosw
	xor	ax,ax
	stosb
	les	ax,lpName
	mov	dx,es
cEnd


;-----------------------------------------------------------------------;
;									;
;   OpenSymFile() -							;
;									;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

ifdef WOW
cProc OpenSymFile,<PUBLIC,FAR>,<ds,si,di>
else
cProc OpenSymFile,<PUBLIC,NEAR>,<ds,si,di>
endif

ParmD	path

LocalV	Buffer,MaxFileLen

cBegin
	lds	dx,path		; get pointer to pathname
	mov	di,3D40h	; open file function code (SHARE_DENY_NONE)

	; We don't use open test for existance, rather we use get
	; file attributes.  This is because if we are using Novell
	; netware, opening a file causes Novell to execute its
	; own path searching logic, but we want our code to do it.

	mov	ax,4300h		; Get file attributes
	int	21h			; Does the file exist?
	jc	opnnov			; No, then don't do the operation
	mov	ax,di			; Yes, open the file then
	int	21h
	jnc	opn2
opnnov:
	mov	ax, -1
opn2:	mov	bx,ax
cEnd




;-----------------------------------------------------------------------;
;									;
;   GetDebugString() -							;
;									;
;-----------------------------------------------------------------------;

; Finds the 'strIndex'-th string in 'szDebugStr'.  The strings are defined
;  in STRINGS.ASM.

	assumes	ds, nothing
	assumes	es, nothing

ifdef WOW
cProc GetDebugString,<PUBLIC,FAR>,<di>
else
cProc GetDebugString,<PUBLIC,NEAR>,<di>
endif

parmW	strIndex

cBegin
	SetKernelDS	es
	mov	di,dataOffset szDebugStr
	mov	bx,strIndex
	cld
gds1:
	dec	bx
	jl	gdsx
	xor	ax,ax
	mov	cx,-1
	repne	scasb
	cmp	es:[di],al
	jne	gds1
	xor	di,di
	mov	es,di
gdsx:
	mov	ax,di
	mov	dx,es
	UnSetKernelDS	es
cEnd


;-----------------------------------------------------------------------;
;									;
;   GetExeHead() -							;
;									;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

ifdef WOW
cProc GetExeHead,<PUBLIC,FAR>
else
cProc GetExeHead,<PUBLIC,NEAR>
endif

cBegin	nogen
	push	ds
	SetKernelDS
	mov	ax,[hExeHead]
	pop	ds
	UnSetKernelDS
	ret
cEnd	nogen


;-----------------------------------------------------------------------;
;									;
;   LSHL() -								;
;									;
;-----------------------------------------------------------------------;
ifdef WOW
if KDEBUG
sEnd	CODE
sBegin  MISCCODE
assumes cs, MISCCODE
endif
endif

	assumes	ds, nothing
	assumes	es, nothing

cProc LSHL,<PUBLIC,NEAR>
cBegin	nogen
	pop	bx
	pop	cx
	pop	ax
	xor	dx,dx
lshl1:
	shl	ax,1
	rcl	dx,1
	loop	lshl1
	jmp	bx
cEnd	nogen

ifdef WOW
if KDEBUG
sEnd    MISCCODE
sBegin	CODE
assumes CS,CODE
endif
endif

;-----------------------------------------------------------------------;
;									;
;   FarKernelError() -							;
;									;
;	05-09-91 EarleH modified to save and restore all registers.	;
;									;
;-----------------------------------------------------------------------;

; Far entry point for KernelError().  Allows the multitude of calls to
; KernelError() be made as near calls.

	assumes	ds, nothing
	assumes	es, nothing

cProc FarKernelError,<PUBLIC,FAR,NODATA>

cBegin nogen
	push	bp
	mov	bp,sp

	SAVEREGS
	mov	ax, _DATA
	mov	ds, ax
;	push	[bp+14]
	push	[bp+12]
	push	ds		; seg of string
	push	[bp+10]
	push	[bp+8]
	push	[bp+6]
	mov	bp,[bp]
ifdef WOW
    cCall	<far ptr Far_KernelError>
else
    call    KernelError
endif
	or	ax, ax
	RESTOREREGS
	pop	bp
	jz	@F
	INT3_DEBUG
@@:
	ret	10
cEnd	nogen

;-----------------------------------------------------------------------;
;									;
;   NearKernelError() -							;
;									;
;	05-09-91 EarleH modified to save and restore all registers.	;
;									;
;-----------------------------------------------------------------------;
ifndef WOW

cProc NearKernelError,<PUBLIC,NEAR,NODATA>

cBegin nogen
	push	bp
	mov	bp,sp

	SAVEREGS
	mov	ax, _DATA
	mov	ds, ax

;	push	[bp+12]		; only pass 4 words now
	push	[bp+10]		; err code
	push	ds		    ; seg of string
	push	[bp+8]		; offset of string
	push	[bp+6]
	push	[bp+4]
	mov	bp,[bp]		; hide this stack frame
	call	KernelError
	or	ax, ax
	RESTOREREGS
	pop	bp
	jz	@F
	INT3_DEBUG
@@:
	ret	8
cEnd	nogen
endif  ;; ! WOW


;-----------------------------------------------------------------------;
;									;
;   IsCodeSelector() -							;
;									;
;-----------------------------------------------------------------------;

ifdef WOW
cProc IsCodeSelector,<PUBLIC,FAR>
else
cProc IsCodeSelector,<PUBLIC,NEAR>
endif

parmW Candidate

cBegin
	mov	ax,Candidate
	lar	dx,ax
	jz	lar_passed
	xor	ax,ax
	jmp	ics_ret
lar_passed:
	xor	ax,ax
	test	dh,00001000b		; Executable segment descriptor?
	jz	ics_ret			; No
	push	cs			; Yes
	pop	dx
	and	dx,3
	and	Candidate,3		; RPL matches that of CS?
	cmp	dx,Candidate
	jne	ics_ret			; No
	inc	ax			; Yes
ics_ret:
cEnd

endif;  DEBUG                           ; DEBUG ONLY SECTION ENDS HERE


;-----------------------------------------------------------------------;
;									;
;   DebugBreak() -							;
;									;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

if KDEBUG
db_tab	dw	db_t, db_w, db_e, db_f, db_k, db_3
db_len	equ	($ - db_tab) / 2
endif

cProc	DebugBreak,<PUBLIC,FAR>

cBegin	nogen
if KDEBUG
	cmp	ax, 0DACh
	jnz	db_3
	cmp	bx, db_len
	jae	db_3
	shl	bx, 1
	jmp	db_tab[bx]
db_t:	krDebugOut DEB_TRACE, "Test trace"
	jmps	db_end
db_w:	krDebugOut DEB_WARN, "Test warning"
	jmps	db_end
db_e:	krDebugOut DEB_ERROR, "Test error"
	jmps	db_end
db_f:	krDebugOut DEB_FERROR, "Test fatal error"
	jmps	db_end
db_k:	kerror	0, "This is a kernel error"
	jmps	db_end
db_3:
endif

	INT3_DEBUG		    ; Jump to debugger if installed
db_end:
	ret
cEnd	nogen

;-----------------------------------------------------------------------;
;									;
;   TextMode() - Enter text mode for debugging load failure		;
;									;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

cProc TextMode,<PUBLIC,NEAR,NODATA>,<ds>
cBegin
	SetKernelDS
	cmp	word ptr [pDisableProc+2],0
	je	tm1
	cCall	[pDisableProc]
	jmps	tm2
tm1:
	mov	ax, 3
	int	10h
tm2:
cEnd




;-----------------------------------------------------------------------;
;									;
;   DoAbort() - 							;
;									;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

cProc DoAbort,<PUBLIC,NEAR>

cBegin	nogen
	SetKernelDS
	cCall	TextMode
;	cmp	word ptr [pDisableProc+2],0
;	je	doa1
;	cCall	[pDisableProc]
;doa1:
	mov	ax,1
	cCall	ExitKernel,<ax>
	UnSetKernelDS
cEnd	nogen

;-----------------------------------------------------------------------;
;
; HandleParamError
;
; This entry point is jumped to by the parameter validation code of
; USER and GDI (and KERNEL).  Its job is to parse the error code
; and, if necessary, RIP or jmp to the error handler routine
;
; Stack on entry:   Far return addr to validation code
;                   Saved error handler offset
;                   Saved BP
;                   API far ret addr
;
;-----------------------------------------------------------------------;

ERR_WARNING             equ 08000h      ; from error.h/windows.h/layer.inc

LabelFP <PUBLIC, HandleParamError>
	push	bp
	mov	bp,sp
	push    bx          ; save err code

	push	bx	    ; push err code

        push    [bp+4]      ; push err return addr as place where error occured
        push    [bp+2]

	push	cx	    ; push parameter
	push	ax
        call    far ptr LogParamError   ; yell at the guy

	pop	bx
	pop	bp

	test	bh,high(ERR_WARNING)  ; warn or fail?
	errnz	low(ERR_WARNING)
	jnz	@F

        pop     bx
        pop     ax          ; pop far return addr

        pop     bx          ; get error handler address

	pop	bp	    ; restore BP
	and	bp,not 1    ; Make even in case "inc bp" for ATM

        push    ax
        push    bx          ; far return to handler

        xor     ax,ax       ; set dx:ax == 0 for default return value
	cwd
        xor     cx,cx       ; set cx == 0 too, for kernel error returns

        mov     es,ax       ; clear ES just in case it contains
                            ; a Windows DLL's DS...
@@:
        retf

cProc   DebugFillBuffer,<PUBLIC, FAR, PASCAL, NONWIN>,<DI>
ParmD   lpb
ParmW   cb
cBegin
if KDEBUG
assumes ES,data
        mov     ax,_DATA
        mov     es,ax
        test    es:DebugOptions,DBO_BUFFERFILL
assumes ES,nothing
        jz      dfbexit
        les     di,lpb
        mov     cx,cb
        mov     ax,(DBGFILL_BUFFER or (DBGFILL_BUFFER shl 8))
        cld
        shr     cx,1
        rep     stosw
        rcl     cx,1
        rep     stosb
dfbexit:
endif;  KDEBUG
cEnd

;========================================================================
;
; void FAR _cdecl DebugOutput(UINT flags, LPCSTR lpszFmt, ...);
;
; NOTE: there is a CMACROS bug with C that causes the parameter offsets
;       to be calculated incorrectly.  Offsets calculated by hand here.
;
cProc   DebugOutput,<PUBLIC, FAR, C, NONWIN>
flags   equ <[bp+2+4]>      ; parmW flags   point past ret addr & saved bp
lpszFmt equ <[bp+2+4+2]>    ; parmD lpszFmt
cBegin
if KDEBUG
        push    bp          ; generate a stack frame
        mov     bp,sp

        SAVEREGS            ; save all registers

        push    ds
        SetKernelDS

        lea     ax,flags    ; point at flags, lpszFmt, and rest of arguments
        push    ss
        push    ax
        call    DebugOutput2

        UnsetKernelDS
        pop     ds
        or      ax,ax       ; test break flag
        RESTOREREGS

        pop     bp

        jz      @F          ; break if needed
        INT3_DEBUG
@@:
endif
cEnd

;========================================================================
;
; void WINAPI LogError(UINT err, void FAR* lpInfo);
;
cProc   LogError,<PUBLIC, FAR, PASCAL, NONWIN>
ParmD   err
ParmW   lpInfo
cBegin
        SAVEREGS
assumes ds,NOTHING

        cCall   DebugLogError,<err, lpInfo>

        RESTOREREGS
cEnd

;========================================================================
;
; void WINAPI LogParamError(UINT err, FARPROC lpfn, void FAR* param);
;
cProc   LogParamError,<PUBLIC, FAR, PASCAL, NONWIN>
ParmW   err
ParmD   lpfn
ParmD   param
cBegin
assumes ds,NOTHING
        SAVEREGS

        ; Call debugger hook (note the reversed parameter order)
	;
	cCall   DebugLogParamError,<param, lpfn, err>

if KDEBUG
	push    ds
	SetKernelDS
assumes ds,DATA
	mov	bx, [bp+0]		; address of faulting code
	mov	bx, ss:[bx+0]
;	mov	bx, ss:[bx+0]
	mov	bx, ss:[bx+4]
	cCall   LogParamError2,<err, lpfn, param, bx>
	UnsetKernelDS
	pop     ds
assumes ds,NOTHING
        or      ax,ax               ; test break flag
endif
	RESTOREREGS
if KDEBUG
        jz      @F                  ; break if needed
        INT3_DEBUG
@@:
endif
cEnd


;-----------------------------------------------------------------------

sEnd	CODE

if KDEBUG
ifdef WOW
sBegin MISCCODE

assumes cs, MISCCODE
assumes ds, nothing
assumes es, nothing

externFP KernelError

;-----------------------------------------------------------------------;
; allows KernelError to be called from _TEXT code segment
cProc   Far_KernelError,<PUBLIC,FAR>
    parmW   errcode
    parmD   lpmsg1
    parmD   lpmsg2
cBegin
    push  [bp+14]
    push  [bp+12]
    push  [bp+10]
    push  [bp+8]
    push  [bp+6]
    call  far ptr KernelError
cEnd

sEnd MISCCODE

endif  ;; WOW
endif  ;; KDEBUG

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\protect.inc ===
ifdef WOW
DPMICALL MACRO	callno
        mov     ax, callno
        call    DPMIProc
        ENDM
else
DPMICALL	MACRO	func
	mov	ax, func
	int	31h
		ENDM
endif; WOW


RING		equ	3		; RING 1 we be

SEL_LDT		equ	4
SEG_RING	equ	(RING+SEL_LDT)
SEG_RING_MASK	equ	7

IS_SELECTOR	equ	1		; Selectors are odd, handles even

					; Bits in dsc_access
DSC_PRESENT	equ	80h
DSC_CODEDATA	equ	10h		; Code or data descriptor
DSC_RING	equ	(RING SHL 5)
DSC_CODE	equ	(1Bh+DSC_RING)	; Code, readable, accessed
DSC_CODE_BIT	equ	08h		; Identifies code
DSC_RW_BIT	equ	02h		; Code readable, data writable bit
DSC_DATA	equ	(13h+DSC_RING)	; Data, writable, accessed
DSC_ACCESSED	equ	01h		; Segment was accessed

DSC_USED	equ	0Fh		; Access rights to mark descriptor used

					; Bits in dsc_hlimit
DSC_GRANULARITY	equ	80h		; Page granularity segment
DSC_DEFAULT	equ	40h		; Default word size
DSC_DISCARDABLE	equ	10h		; Available bit in descriptor
					; (using access as a word)

GDT_FREEDSC	equ	-1
GDT_NPDSC	equ	07FFFh

if PMODE
GA_ALIGN_BYTES = (((GA_ALIGN+1) SHL 4) - 1)
GA_MASK_BYTES = (NOT GA_ALIGN_BYTES)
endif

DscPtr	struc			;Descriptor
dsc_limit	dw	?	;Descriptor max length
dsc_lbase	dw	?	;Descriptor base bits 15-0
dsc_mbase	db	?	;Descriptor base bits 23-16
dsc_access	db	?	;Descriptor access byte
dsc_hlimit	db	?	;High limit, granularity and 2 custom bits
dsc_hbase	db	?	;Descriptor base bits 31-24
DscPtr	ends


DSC_LEN		equ	(size DscPtr)
.ERRNZ		DSC_LEN-8		; Paranoia

dsc386		equ	word ptr dsc_hlimit
dsc_owner	equ	word ptr dsc_limit

if PMODE
GENTER32	MACRO

	push	esi
	push	edi
	call	genter
	mov	gs, di

		ENDM


GLEAVE32	MACRO

	mov	es, di		; Zero ES for now
	mov	fs, di		; And FS
	call	gleave
	pop	edi
	pop	esi

		ENDM

MIN_FREE_ARENAS		equ	30h	; Minimum number of free arenas desired
ARENA_INCR_BYTES	equ	8192	; Space for more arenas
endif

if PMODE
ife RING-3

;
; Change selector or handle to a handle
;	Handles are RING 2
;	Selectors are RING 3
;
Sel_To_Handle	MACRO	xsel
	and	xsel, NOT 1
		ENDM

;
; Change handle or selector to a selector
;
Handle_To_Sel	MACRO	xsel
	or	xsel, 1
		ENDM

;
; Change known selector into corresponding handle
;
StoH			MACRO	sel
	dec	sel
		ENDM

;
; Change known handle into corresponding selector
;
HtoS			MACRO	h
	inc	h
		ENDM

;
; Given a segment limit, calculate the
; number of selectors in the array
;
Limit_To_Selectors	MACRO	reg
	shr	reg, 16		; Now divide by 64k to get # of selectors - 1
	inc	reg
		ENDM

endif

ife RING-1
;
; Change selector or handle to a handle
;	Handles are RING 2
;	Selectors are RING 1
;
Sel_To_Handle	MACRO	xsel
	test	xsel, 1
	jz	short @F
	inc	xsel	
@@:
		ENDM

;
; Change handle or selector to a selector
;
Handle_To_Sel	MACRO	xsel
	test	xsel, 1
	jnz	short @F
	dec	xsel
@@:
		ENDM

;
; Change known selector into corresponding handle
;
StoH			MACRO	sel
	inc	sel
		ENDM

;
; Change known handle into corresponding selector
;
HtoS			MACRO	h
	dec	h
		ENDM

endif


IsFixed		MACRO	xh
	test	xh, 1
		ENDM

endif	; PMODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\reboot.asm ===
;***************************************************************************
;*  REBOOT.ASM
;*
;*      Contains routines used to support a local reboot in the Sys
;*      VM.  To do this, we interact with USER and the Reboot VxD.
;*
;*      This functionality is only present in the 386 KERNEL.
;*
;*      The KRebootInit function is called just after USER is loaded.
;*
;*      The Reboot VxD calls the local reboot proc to terminate an app.
;*      The local reboot proc may fail and cause the VxD to trace until
;*      it is able to kill the task.  See comments in the local reboot
;*      proc for more details.
;*
;*      This code must be located in KERNEL due to the internal KERNEL
;*      information it must access.
;*
;*      Created by JonT starting 12 July 1991
;*
;***************************************************************************

	TITLE	REBOOT - Local Reboot Routines

.xlist
include kernel.inc
include tdb.inc
include protect.inc
include newexe.inc
.list

.386p

MAX_TRACE       EQU     5000h

HookInt1 MACRO
        mov     ax,0204h                ;;Tell VxD to hook/unhook Int 1
        mov     cx,cs                   ;;Point to ISR
        mov     dx,codeOFFSET TraceOut
        movzx   edx,dx
        call    [lpReboot]              ;;Call the VxD API
ENDM

UnhookInt1 MACRO
        mov     ax,0204h                ;;Tell VxD to hook/unhook Int 1
        xor     cx,cx                   ;;Pass a zero in CX to unhook
        call    [lpReboot]              ;;Call the VxD API
ENDM

DataBegin

externD lpReboot
externW curTDB
externW hExeHead
externW hUser
externB Kernel_Flags
externB fTaskSwitchCalled
externW wMyOpenFileReent
externB OutBuf
externW pGlobalHeap

EVEN
globalW wLastSeg, 0
globalW wTraceCount, 0
lpOldInt1       DD      0
szUser          DB      'USER'

DataEnd

externFP Int21Handler
externFP GetPrivateProfileInt
IFDEF FE_SB
externFP FarMyIsDBCSLeadByte
ENDIF

;** Note that this goes in the fixed code segment
sBegin	CODE
assumes CS,CODE

;  KRebootInit
;       Initializes the KERNEL Local Reboot functionality and talks with
;       the Reboot VxD.

cProc   KRebootInit, <FAR,PUBLIC>, <si,di,ds>
cBegin
        SetKernelDS

        ;** Get the reboot device entry point if it exists
        xor     di,di                   ;Get a NULL pointer
        mov     es,di                   ;  in case there's no reboot device
        mov     bx,0009h            
        mov     ax,1684h                ;Get device entry point
        int     2fh
        mov     ax,es
        or      ax,di
        jz      SHORT RI_NoRebootDev
        mov     WORD PTR lpReboot[0],di
        mov     WORD PTR lpReboot[2],es

        ;** Set the reboot device call back
        mov     ax, 0201h               ;Reboot VxD #201:  Set callback addr
        mov     di,cs
        mov     es,di
        lea     di,KRebootProc
        lea     si, fTaskSwitchCalled   ;DS:SI points to task switch flag
        call    [lpReboot]

RI_NoRebootDev:

cEnd


;  LocalRebootProc
;
;       Called by the Reboot VxD to cause the current Windows app to be
;       terminated.

cProc   KRebootProc, <FAR,PUBLIC>
cBegin  nogen

        ;** Save all the registers so we can restart if necessary
        pusha                           ;16 bytes
        push    ds                      ;2 bytes
        push    es                      ;2 bytes
        SetKernelDS
        mov     bp,sp                   ;Point with BP

        ;** If the KERNEL debugger is installed, DON'T trace!
	test	Kernel_Flags[2],KF2_SYMDEB ;Debugger installed
IF KDEBUG
        jz      SHORT RP_CheckSeg       ;No debugger, try to trace
        Trace_Out <'LocalReboot:  Debugger installed, nuking app without tracing'>
	jmp	SHORT RP_NukeIt         ;Just try to nuke it here!
ELSE
	jnz	SHORT RP_NukeIt         ;Just try to nuke it here!
ENDIF

        ;** Get the code segment we were executing in
RP_CheckSeg:
        mov     ax,[bp + 22]            ;Get CS from stack (IRET frame)

        ;** See if the owner of the code segment was loaded before USER
        cCall   IsBootSeg               ;Returns TRUE if owned by boot mod
        or      ax,ax                   ;Ok to nuke?
        jnz     RP_TraceOut             ;No, must trace out

RP_NukeIt:

        ;** First, we need to get the filename of the .EXE we're about to
        ;**     nuke.  We do this by getting the name out of the module
        ;**     database.  Module databases are not page locked and also
        ;**     have the fully qualified pathname.  So, we copy just the
        ;**     module name into a buffer in our pagelocked data segment
        cld
        push    ds
        pop     es
        mov     di, dataOFFSET OutBuf   ;Point to start of buffer
        mov     ds, curTDB              ;Get the current TDB
        UnSetKernelDS
        mov     ds, ds:[TDB_pModule]    ;Point to the module database
        mov     si, WORD PTR ds:[ne_crc + 2] ;Points to length byte of module EXE
        mov     cl, [si]                ;Get length byte
        xor     ch, ch
        sub     cl, 8                   ;8 bytes of garbage
        add     si, 8
        mov     bx, si                  ;In case we don't find a slash (bad)
RP_SlashLoop:
        lodsb                           ;Get this char
IFDEF FE_SB
        call    FarMyIsDBCSLeadByte
        jc      SHORT RP_NoDBCSChar
        lodsb
        dec     cx
        jmp     SHORT RP_NoSlash        ;It is, can't be a slash
RP_NoDBCSChar:
ENDIF
        cmp     al, '\'                 ;Is this a slash?
        je      SHORT RP_Slash          ;Yes
        cmp     al, '/'
        jne     SHORT RP_NoSlash
RP_Slash:
        mov     bx, si                  ;BX points after last slash
RP_NoSlash:
        loop    RP_SlashLoop
        mov     cx, si                  ;Compute count of characters in 8.3 name
        sub     cx, bx
        mov     si, bx                  ;Point to 8.3 name
        rep     movsb                   ;Copy the string into OutBuf
        xor     al, al                  ;Zero byte
        stosb

        ;** Call the VxD to put up the app name
        push    es                      ;ES points to kernel DS
        pop     ds
        ReSetKernelDS
        mov     di, dataOFFSET OutBuf   ;Point to module name with ES:DI
        mov     ax, 203h                ;Display message through VxD
        call    [lpReboot]
        or      ax, ax                  ;If non-zero, we nuke it
        jz      SHORT RP_NoNuke

IF KDEBUG
        krDebugOut DEB_WARN, <'LocalReboot:  Trying to nuke @ES:DI'>
ENDIF

        ;** Clean out some static info
        mov     wMyOpenFileReent, 0     ;Clear reentrant flag for MyOpenFile

        ;** Call USER's signal proc for the task
        mov     es,curTDB               ;Get the current TDB
        cmp     WORD PTR es:[TDB_USignalProc] + 2,0 ;USER signal proc?
        jz      SHORT @F                ;No
        mov     bx,0666h                ;Death knell
        mov     di,-1
        cCall   es:[TDB_USignalProc],<es,bx,di,es:[TDB_Module],es:[TDB_Queue]>
@@:

        ;** Nuke the app.  Does not return
        mov     ax,4c00h
        DOSCALL

        ;** We're somewhere in a boot module.  Try to trace out by telling
        ;**      VxD to do another instruction
RP_TraceOut:
        mov     ax,[bp + 22]            ;Get CS from stack (IRET frame)
IF KDEBUG
        krDebugOut DEB_WARN, <'LocalReboot:  Tracing out of boot module %AX2'>
ENDIF
        mov     wLastSeg,ax             ;Save for next time
        mov     wTraceCount,0           ;Clear the trace count
        HookInt1

        ;** Set the trace flag
        or      WORD PTR [bp + 24],0100h
        jmp     SHORT RP_SetFlag
        
        ;** Force the trap flag clear on the no nuke case
RP_NoNuke:
        and     WORD PTR [bp + 24],NOT 0100h
        
RP_SetFlag:
        pop     es
        pop     ds
        popa
        STIRET                          ;VxD calls as an interrupt
cEnd    nogen


;  TraceOut
;
;       This routine continues to trace until it traces out of a boot module
;       or until the trace count is up.  If it needs to nuke the app,
;       it jumps to RP_NukeIt which depends only on DS being set.  This
;       call returns via an IRET since it is called as an INT 1 handler.

cProc   TraceOut, <FAR,PUBLIC>
cBegin  nogen

        ;** Save all the registers so we can restart if necessary
        pusha                           ;16 bytes
        push    ds                      ;2 bytes
        push    es                      ;2 bytes
        SetKernelDS
        mov     bp,sp                   ;Point with BP

        ;** We keep tracing forever if the heap is locked
        push    es
	mov	es, pGlobalHeap         ;Point to GlobalInfo structure
	cmp     es:[gi_lrulock], 0      ;Is the global heap busy
        pop     es
        jne     SHORT TO_10             ;Force the trace out
        
        ;** See if the CS is the same as last time
        inc     wTraceCount             ;Bump the count
        cmp     wTraceCount,MAX_TRACE   ;Too many instructions?
IF KDEBUG
        jb      SHORT TO_10             ;Count not exceeded
        mov     cx,MAX_TRACE            ;Get trace count
        Trace_Out <'LocalReboot:  Trace count (#CXh instructions) exceeded'>
        jmp     SHORT TO_Reboot
ELSE
        jae     SHORT TO_Reboot         ;Yes, too many, nuke it
ENDIF

TO_10:  mov     ax,[bp + 22]            ;Get the CS from the IRET frame
        cmp     ax,wLastSeg             ;Same as last time?
        je      SHORT TO_StillBad       ;Yes, don't bother looking up
        mov     wLastSeg,ax             ;Save as last executed segment
        mov     bx,cs                   ;Get our CS
        cmp     ax,bx                   ;Our segment?
        je      SHORT TO_StillBad       ;Yes, can't nuke here!
        cCall   IsBootSeg               ;Returns TRUE if owned by boot mod
        or      ax,ax                   ;Ok to nuke?
        jnz     SHORT TO_StillBad       ;No, must continue tracing
IF KDEBUG
        mov     cx,wTraceCount          ;Get trace count
        Trace_Out <'LocalReboot:  Traced out after #CXh instructions'>
ENDIF

        ;** Unhook the interrupt handler and kill the app now
TO_Reboot:
        UnhookInt1
        jmp     RP_NukeIt               ;Try to nuke the app

        ;** Restore the registers and restart
TO_StillBad:
        or      WORD PTR [bp + 24],0100h ;Set the trace flag
        pop     es
        pop     ds
        popa
        iret                            ;VxD calls as an interrupt

cEnd    nogen


;  IsBootSeg
;
;       Tries to find a code segment somewhere in the initial segments
;       loaded before USER.  The CS value is passed in AX.  Returns
;       TRUE iff the CS was found in a boot module.

cProc   IsBootSeg, <NEAR,PUBLIC>
cBegin  nogen
        SetKernelDS
        mov     dx,ax                   ;Put CS in DX for call
        mov     es,hExeHead             ;Get the first module on chain

IBS_Loop:
        cCall   IsModuleOwner           ;See if we can find the owner
        or      ax,ax                   ;Found?
        jnz     SHORT IBS_End           ;Yes, return TRUE
        mov     ax,es                   ;Get the module handle
        cmp     ax,hUser                ;If we just tried USER, we're done
        je      SHORT IBS_NotFound      ;Not found
        mov     es,es:[6]               ;Nope, get next module to try
        jmp     IBS_Loop

IBS_NotFound:
        xor     ax,ax                   ;Return FALSE

IBS_End:
cEnd


;  IsModuleOwner
;
;       Checks in the EXE header to see if the given segment is in this
;       module.
;       DX is the segment, ES points to the module database
;       Returns TRUE/FALSE in AX.  Doesn't trash DX.

cProc   IsModuleOwner, <NEAR,PUBLIC>
cBegin  nogen
        xor     ax,ax                   ;Get a FALSE just in case
        mov     cx,es:[ne_cseg]         ;Get max number of segments
        jcxz    SHORT IMO_End           ;No segments
        mov     di,es:[ne_segtab]       ;Point to the segment table
IMO_SegLoop:
        cmp     dx,es:[di].ns_handle    ;Is this the correct segment entry?
        jz      SHORT IMO_FoundIt       ;Yes, get out
        add     di,SIZE new_seg1        ;Bump to next entry
        loop    IMO_SegLoop             ;Loop back to check next entry
        jmp     SHORT IMO_End           ;Didn't find it

IMO_FoundIt:
        mov     ax,1                    ;Return that we found it here

IMO_End:

cEnd

sEnd

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\resaux.asm ===
TITLE	RESAUX - support routines for resource manager

.xlist
include kernel.inc
include newexe.inc
include tdb.inc
include	protect.inc
.list

ifdef WOW
     WOW_OPTIMIZE_PRELOADRESOURCE = 1
endif

externA	 __AHINCR
externFP _lclose
externFP GlobalFree
externFP GlobalLock
externFP GlobalUnlock
externFP GlobalFlags
externFP GlobalReAlloc
externFP GlobalHandle
externFP GetExePtr
externFP MyOpenFile
externFP FarMyUpper
;externFP GlobalAlloc
externFP lstrlen
externFP lstrOriginal
externFP Int21Handler

externFP AllocSelector
externFP FreeSelector
externFP LongPtrAdd
ifdef WOW
externFP WOWFreeResource
endif

ifdef WOW_OPTIMIZE_PRELOADRESOURCE
externFP LongPtrAddWOW
externFP AllocSelectorWOW
endif

if KDEBUG
externFP OutputDebugString
endif
	 
DataBegin

externW  Win_PDB

if KDEBUG
externB  fLoadTrace
endif

DataEnd

sBegin	CODE
assumes CS,CODE
assumes DS,NOTHING
assumes ES,NOTHING

externNP MyAlloc
externNP MyLock
externNP GetOwner
externNP SetOwner
externNP GetCachedFileHandle
externNP CloseCachedFileHandle

externFP AllocSelectorArray
externFP set_discarded_sel_owner
externNP SetResourceOwner
externNP AllocResSelArray
ifdef WOW
externFP hMemCpy
externFP _HREAD
externW  gdtdsc
endif


;-----------------------------------------------------------------------;
;									;
;  DirectResAlloc - This allocates memory for creating cursors and icons;
;	"on the fly".							;
;									;
; Arguments:								;
;	parmW   hinstance ; Identifies the instance that allocates	;
;	parmW	resFlags  ; Flags to be used in memory allocation	;
;	parmW	nBytes	  ; The size of the memory to be allocated	;
; 									;
; Returns:								;
; 									;
; Error Returns:							;
;	AX = 0								;
;									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
; Fri 06 Jan 1989  -- Written by Sankar.				;
;									;
;-----------------------------------------------------------------------;

cProc	DirectResAlloc, <PUBLIC, FAR>, <si,di>
	parmW	hInstance
	parmW	resFlags
	parmW	nBytes

cBegin
	cCall	GetExePtr, <hInstance>
	or	ax, ax
	jz	err_end
        push    ax	 ; Save ptr to EXE header
	
	xor	bx, bx
	cCall	MyResAlloc, <ax, resFlags, nBytes, bx>
	xchg	ax,dx
	pop	cx			; restore exe header address
	or	ax,ax
	jz	err_end
	cCall	SetOwner,<ax,cx>
	xchg	ax,dx
 err_end:
cEnd


cProc	MyResAlloc,<PUBLIC,NEAR>
	parmW   hExe
	parmW   resFlags
	parmW   nBytes
	parmW   nAlign
cBegin
	mov	bx,resFlags		; Allocate memory for
	or	bl,NSTYPE or RNMOVE	; non-code, non-data segment
	cCall	MyAlloc,<bx,nBytes,nAlign>
	test	dl,GA_FIXED
	jnz	mysox
	mov	bx,dx

	HtoS	bx			; Make it ring 1
	lar	cx, bx
	jnz	mysox
	test	ch, 80h			; Present?
	jnz	mysox
int 3
	mov	es, hExe		; Set limit to the owner ie. hExe.
	cCall	set_discarded_sel_owner

mysox:
	xchg	ax,dx
cEnd

cProc	IAllocResource,<PUBLIC,FAR>,<si>
	parmW   hResFile
	parmW   hResInfo
	parmD   newSize
cBegin
	cCall	GetExePtr,<hResFile>
	or	ax,ax
	jz	arx
	mov	es,ax
	push	es			; Save exe header address
	mov	si,hResInfo
	push	es			; push hexe
	mov	bx,es:[si].rn_flags
	or	bl,NSTYPE		; non-code, non-data segment
	push	bx			; push flags
	push	es:[si].rn_length	; push default size
	mov	bx,es:[ne_rsrctab]
	mov	cx,es:[bx].rs_align
	mov	dx,OFF_newSize
	or	dx,SEG_newSize		; Want a different size?
	jz	ar1			; No, continue
	pop	dx			; Yes discard default size
	push	cx			; Save alignment shift
	mov	dx,newSize.hi		; Round up new size by alignment
	xor	ax,ax
	not	ax
	shl	ax,cl
	not	ax
	add	ax,newSize.lo
	adc	dx, 0
ar0:
	shr	dx,1			; convert to alignment units
	rcr	ax,1
	loop	ar0
	pop	cx			; Restore alignment shift
	push	ax			; Push new size
ar1:
	cmp	es:[si].rn_handle,0	; Already a handle?
	je	ar2			; No, continue
	pop	ax			; AX = length
	add	sp,4			; ignore flags and hExe
	xor	dx,dx
	jcxz	ma3
ma2:
	shl	ax,1
	rcl	dx,1
	loop	ma2
ma3:
	xor	cx,cx
	cCall	GlobalReAlloc,<es:[si].rn_handle,dxax,cx>
	cwd				; zero dx (may not be needed)
	or	ax,ax			; did it fail?
	jz	ar3

	cCall	GlobalHandle,<ax>
	jmps	ar3
ar2:
	push	cx			; push alignment shift count
	cCall	MyResAlloc		; rn_flags, rn_length, rs_align
ar3:
	xchg	ax,dx
	pop	cx			; restore exe header address
	or	ax,ax
	jz	arx
	cCall	SetOwner,<ax,cx>
	xchg	ax,dx
arx:
	or	ax, ax
	jnz	@F
        KernelLogError  DBF_WARNING,ERR_ALLOCRES,"AllocResource failed"
	xor	ax, ax			; Restore the NULL value in ax
@@:
	mov	cx,ax
cEnd


cProc	ResAlloc,<PUBLIC,FAR>,<si,di>
	parmD   pResInfo
	parmW   fh
	parmW   isfh
ifdef WOW_OPTIMIZE_PRELOADRESOURCE
        parmW    hiResOffset
        parmW    loResOffset
endif
	localW  hres
cBegin
	xor	ax,ax
	cCall	IAllocResource,<pResInfo,ax,ax>
	les	si,pResInfo
	mov	hres,ax			; Returns handle in AX
	mov	ax,dx			; Segment address in DX
	mov	bx,es:[ne_rsrctab]
	mov	cx,es:[bx].rs_align
	mov	dx,es:[si].rn_length
	xor	bx,bx
	cmp	hres,bx
;	jnz	ra1
	jz	rax

ra1:	shl	dx,1
	rcl	bx,1
	loop	ra1
	push	ds
	mov	cx,dx
	mov	si, bx			; Save hi word of length
	mov	bx,fh
	cmp	isfh,bx			; is bx a file handle?
	je	ra2			; if so, load from file
ifdef WOW
ifdef WOW_OPTIMIZE_PRELOADRESOURCE
        cmp     hiResOffset, 0
        jz      @F
        push    ax
        mov     al, __AHINCR
        mul     byte ptr hiResOffset
        add     bx,ax
        pop     ax
@@:
	cCall	hMemCpy,<ax,0,bx,loResOffset,si,cx>
else
	cCall	hMemCpy,<ax,0,bx,0,si,cx>
endif
	jmps	ra3
ra2:
	cCall	_hRead,<bx,ax,0,si,cx>
	cmp	dx, si			; If we didn't read what we wanted
	jnz	rafail			; then fail
	cmp	ax, cx
	jnz	rafail
else ; NOT WOW
	cCall	CopyResource,<ax,bx,si,cx>
	jmps	ra3
ra2:
	cCall	ReadResource,<ax,bx,si,cx>
	jc	rafail
endif ; WOW
ra3:
	pop	ds
ra4:
	mov	ax,hres
	jmps	rax
rafail:
	mov	bx,ds
	pop	ds
rafail2:
	cCall	GlobalFree,<hres>
if KDEBUG
        push    es
        mov     bx,SEG_pResInfo
        mov     es,bx
        xor     bx,bx
        KernelLogError <DBF_WARNING>,ERR_BADRESREAD,"Unable to read resource from @ES:BX"
        pop     es
endif
	xor	ax,ax
rax:
cEnd

cProc	CopyResource,<PUBLIC,NEAR>
	parmW	DestSeg
	parmW	SrcSeg
	parmD	nBytes
cBegin
	push	es
	mov	ds, SrcSeg			; bx is segment of resource
	mov	es, DestSeg
	xor	si, si
	xor	di, di
	cld
rc_next:
	mov	cx, 8000h
	cmp	word ptr [nBytes+2], 0
	clc					; No odd byte to copy
	jne	big_copy
	mov	cx, word ptr [nBytes]
	shr	cx, 1				; Word count
big_copy:
	rep	movsw
	rcl	cx, 1				; Rescue low bit
	rep	movsb				; Any odd byte

	dec	word ptr [nBytes+2]
	js	rc_done

	mov	ax, ds
	add	ax, __AHINCR
	mov	ds, ax
	mov	ax, es
	add	ax, __AHINCR
	mov	es, ax
	jmp	rc_next

rc_done:
	pop	es
cEnd

cProc	ReadResource,<PUBLIC,NEAR>
	parmW	DestSeg
	parmW	fh
	parmD	nBytes
cBegin
	mov	bx, fh
	xor	dx, dx
	mov	ds, DestSeg
	mov	di, word ptr nBytes
	mov	si, word ptr [nBytes+2]
around_again:
	mov	cx, 8000h
	or	si, si
	jnz	big_xfer
	cmp	di, cx
	jae	big_xfer
	mov	cx, di
big_xfer:
	mov	ah, 3Fh
	DOSCALL
	jc	rrfail
	cmp	ax, cx
	jne	rrfail

	sub	di, cx
	sbb	si, 0
	jnz	incr_address
	or	di, di
	jz	rrdone
incr_address:
	add	dx, cx
	jnc	around_again
	mov	ax, ds
	add	ax, __AHINCR
	mov	ds, ax
	jmp	around_again

rrfail:
	stc
	jmps	rrx
rrdone:
	clc
rrx:
cEnd

cProc	IAccessResource,<PUBLIC,FAR>
	parmW   hResFile
	parmW   hResInfo
cBegin
	xor	ax, ax
	cCall	InternalAccessResource,<hResFile,hResInfo,ax>
cEnd

cProc	InternalAccessResource,<PUBLIC>
	parmW   hResFile
	parmW   hResInfo
	parmW	CachedFile
cBegin
	cCall	GetExePtr,<hResFile>
	mov	es,ax
	mov	bx, hResInfo
	mov	ax,es:[bx].rn_flags
	push	es:[bx].rn_length
	push	es:[bx].rn_offset
	mov	dx,es:[ne_pfileinfo]
	mov	bx,es:[ne_rsrctab]
	mov	cx,es:[bx].rs_align
	push	cx
	push	es
	cmp	CachedFile, 0
	je	open_it
	mov	cx, -1
	cCall	GetCachedFileHandle,<es,cx,cx>
	mov	bx, ax
	jmps	got_fh
open_it:
if SHARE_AWARE
	mov	bx,OF_REOPEN or OF_VERIFY or OF_NO_INHERIT or OF_SHARE_DENY_WRITE
else
	mov	bx,OF_REOPEN or OF_VERIFY or OF_NO_INHERIT
endif
	regptr	esdx,es,dx
	push	es
	push	dx
	cCall	MyOpenFile,<esdx,esdx,bx>	; returns handle in ax & bx
	pop	dx
	pop	es
;;;	cmp	ax, -1				; Success?
;;;	jne	got_fh				;  yes.
;;;						;  no, try compatibility mode
;;;	mov	bx,OF_REOPEN or OF_VERIFY or OF_NO_INHERIT
;;;	regptr	esdx,es,dx				   
;;;	cCall	MyOpenFile,<esdx,esdx,bx>	; returns handle in ax & bx
got_fh:
	pop	es
	pop	cx
	pop	dx
	inc	ax
	jnz	ra2c
	pop	dx
ra2b:
	mov	bx,-1
	jmps	ra2x
ra2c:
	xor	ax,ax
	push	cx
AR_shift:
	shl	dx,1
	rcl	ax,1
	loop	AR_shift
	mov	cx,ax
	mov	ax,4200h
	DOSCALL
	pop	cx
	pop	dx
	jc	ra2b
	xor	ax,ax
AR_shift1:
	shl	dx,1
	rcl	ax,1
	loop	AR_shift1
	mov	cx,ax			; CX:DX is size of resource
ra2x:
	mov	ax,bx			; AX and BX are file handle
cEnd

cProc	ILockResource,<PUBLIC,FAR>,<si>
	parmW   hres
	localD	lpfn
cBegin
	mov	ax,hres			; Get object handle
	or	ax,ax
	jnz	short_rel
lrfail0:
	jmp	lrfail
short_rel:

ifdef WOW
	test	ax, GA_WOWHANDLE	; should we call WOW32 FreeResource?
	jnz	@f
        jmp     lrfail

@@:
endif; WOW

	cCall	GlobalLock,<ax>		; Attempt to lock it
	jcxz	yawn
	jmp	lrx
yawn:
	mov	bx,hres 		; Failed, is it fixed?
	test	bl,GA_FIXED
	jnz	lrfail0			; Yes, fail all the way

	HtoS	bx
;   On WOW we don't copy the owner to the real LDT since it is slow to call
;   the NT Kernel, so we read our copy of it directly.
;   see set_discarded_sel_owner   mattfe mar 23 93

        push    cx
        lar     cx, bx
        pop     cx
        jnz     lrfail0                 ; NZ -> LAR failed
	mov	es,cs:gdtdsc
	and	bl, not 7
	mov	bx,es:[bx].dsc_owner
	mov	es,bx
	assumes es,nothing
	cmp	es:[ne_magic],NEMAGIC	; Does owner point to EXE header?
	jne	lrfail			; No, fail.
	mov	bx,es:[ne_rsrctab]	; Yes, scan resource table
	cmp	es:[ne_restab],bx	; Is there a resource table?
	je	lrfail			; No, just free the global object
	push	ds
	SetKernelDS
	pop	ds
	assumes	ds, nothing
	mov	dx,hres			; Yes, look for this handle
	add	bx,SIZE NEW_RSRC	; Point to first resource type
lrloop0:
	cmp	es:[bx].rt_id,ax	; End of table?
	je	lrfail			; Yes, just return failure
	lea	si,[bx].rt_proc		; Remember address of type proc.
	mov	cx,es:[bx].rt_nres
	add	bx,SIZE RSRC_TYPEINFO	; Point to first resource of this type
lrloop:
	cmp	es:[bx].rn_handle,dx	; Is this the one?
	je	lr3			; Yes, go see if type proc to call
	add	bx,SIZE RSRC_NAMEINFO	; No, point to next resource
	loop	lrloop			; Any more resources for this type?
	jmps	lrloop0			; No, advance to next type
lr3:
	cmp	word ptr es:[si+2],0	; Was there a proc defined for this type
	je	lrfail			; No, return failure.

if KDEBUG
	jmp	PrintInfo
PrintedInfo:
endif
	push	ds			; preserve these registers across call
	push	es
	push	bx

	mov	ax,word ptr es:[si]	; set up proc addr to call on stack
	mov	word ptr lpfn,ax
	mov	ax,word ptr es:[si]+2
	mov	word ptr lpfn+2,ax

	mov	cx,es			; cx = es for later push

	mov	ax,ss			; Zap segment registers so he can't
	mov	es,ax			; diddle DS
	mov	ds,ax

	cCall	lpfn,<dx,cx,bx> 	; Yes, call proc to reload

	xchg	ax,cx			; cx = result
	jcxz	@F			; skip lock if NULL

	cCall	GlobalLock,<cx> 	; Attempt to lock result
@@:
	pop	bx
	pop	es
	pop	ds
	jcxz	lrfail
	or	byte ptr es:[bx].rn_flags,RNLOADED  ; Mark loaded
	jmps	lrx
lrfail:					; Here to return failure.
        KernelLogError  DBF_WARNING,ERR_LOCKRES,"LockResource failed"
	xor	ax,ax
	cwd
lrx:
cEnd

if KDEBUG
RCTypes:
	db	'Custom', 0
	db	'Cursor', 0
	db	'Bitmap', 0
	db	'Icon', 0
	db	'Menu', 0
	db	'Dialog', 0
	db	'String', 0
	db	'FontDir', 0
	db	'Font', 0
	db	'Accelerator', 0
	db	'RCData', 0
	db	'Type11', 0
	db	'GroupCursor', 0
	db	'Type13', 0
	db	'GroupIcon', 0
	db	0
PrintInfo:
	pusha
	mov	cx, word ptr es:[si][rt_id-rt_proc]
	and	ch, not 80h
	mov	si, offset RCTypes
pi_1:	inc	si
pi_2:	cmp	byte ptr cs:[si], 0
	jnz	pi_1
	inc	si
	cmp	byte ptr cs:[si], 0
	loopnz	pi_2
	jnz	@F
	mov	si, offset RCTypes
@@:
	mov	ax, es:[bx].rn_id
;	test    ah, 80h
;	jz      pi_name
	and	ah, not 80h
	krDebugOut	<DEB_TRACE or DEB_krLoadSeg>, "%es0: reading resource @CS:SI.#ax"
;	jmps    pi_done
;pi_name:
;	int 3
;	krDebugOut      <DEB_TRACE or DEB_krLoadSeg>, "%es0: reading resource @CS:SI.@ES:AX"
;pi_done:
        popa
	jmp	PrintedInfo
endif	   


cProc	IFreeResource,<PUBLIC,FAR>,<ds,si>
	parmW   hres
cBegin
	mov	ax,hres			; Get segment address of resource
	or	ax,ax
	jz	frxj
ifdef WOW
	test	ax, GA_WOWHANDLE	; should we call WOW32 FreeResource?
	jnz	@f
	cCall	WOWFreeResource,<ax>	; you bet !
	xor	ax, ax
	jmp	frxx

@@:
endif; WOW
	cCall	MyLock,<ax>
	or	ax,ax			; Discarded or invalid handle?
	jnz	fr0a			; No, continue
	mov	bx,hres

	test	bl,GA_FIXED
	jnz	fr2			; Return NULL
	HtoS	bx			; Fix RPL so we can do LAR
	lar	cx, bx
	jnz	fr2			; LAR failed, return NULL
	test	ch, 80h			; Present?
	jnz	fr2			;  yes, return NULL
;   On WOW we don't copy the owner to the real LDT since it is slow to call
;   the NT Kernel, so we read our copy of it directly.
;   see set_discarded_sel_owner   mattfe mar 23 93

	mov	ds,cs:gdtdsc
	and	bl, not 7
	mov	cx,ds:[bx].dsc_owner
	mov	ds,cx
	jmps	fr0b
frxj:
	jmps	frx

fr0a:
	cCall	GetOwner,<ax>
	mov	ds,ax
	xor	ax,ax

fr0b:
	cmp	ds:[ne_magic],NEMAGIC	; Is it an exe header?
	jne	fr1			; No, just free the handle
	mov	bx,ds:[ne_rsrctab]
	cmp	ds:[ne_restab],bx	; Is there a resource table?
	je	fr1			; No, just free the handle
	mov	dx,hres
	add	bx,SIZE NEW_RSRC	; Point to first resource type
frloop0:
	cmp	ds:[bx].rt_id,ax	; End of table?
	je	fr1			; Yes, just free the handle
	mov	cx,ds:[bx].rt_nres
	add	bx,SIZE RSRC_TYPEINFO	; Point to first resource of this type
frloop:
	cmp	ds:[bx].rn_handle,dx	; Is this the one?
	je	fr0			; Yes, go decrement usage count
	add	bx,SIZE RSRC_NAMEINFO	; No, point to next resource
	loop	frloop			; Any more resources for this type?
	jmps	frloop0			; No, advance to next type
fr0:
	cmp	ds:[bx].rn_usage,ax	; Already zero?
	je	fr1a			; Yes, then free this resource now
	dec	ds:[bx].rn_usage	; Decrement use count
	jg	frx			; Positive means still in use
	test	ds:[bx].rn_flags,RNDISCARD  ; Discardable?
	jnz	fr2			; Yes, let discard logic toss it
fr1a:
	mov	ds:[bx].rn_handle,ax	; o.w. free memory now
	and	byte ptr ds:[bx].rn_flags,not RNLOADED	; Mark not loaded
fr1:
	cCall	GlobalFree,<hres>	; Free global object
fr2:
	mov	hres,ax
frx:
	mov	ax,hres			; Return zero if freed, hres o.w.
frxx:
cEnd


cProc	ISizeofResource,<PUBLIC,FAR>
	parmW   hResFile
	parmW   hResInfo
cBegin
	cCall	GetExePtr,<hResFile>
	mov	es,ax
	mov	bx,hResInfo
	mov	ax,es:[bx].rn_length
	xor	dx,dx
	mov	bx,es:[ne_rsrctab]
	mov	cx,es:[bx].rs_align
sr0:	shl	ax,1
	rcl	dx,1
	loop	sr0
cEnd


cProc	DefaultResourceHandler,<PUBLIC,FAR>,<si,di>
	parmW   hRes
	parmW   hResFile
	parmW   hResInfo
	localW	SavePDB
cBegin
	cCall	GetExePtr,<hResFile>
	or	ax,ax
	jz	drhx
	mov	si,ax
	mov	cx,hRes 	; if hRes == NULL, we need to allocate.
	jcxz	@F
	cCall	GlobalHandle,<cx>
	or	dx,dx		; Nothing to do for allocated resources
	jnz	drhx
@@:
	SetKernelDS
	mov	ax, Win_PDB	; Save current PDB
	mov	SavePDB, ax
	mov	ax, 1
	cCall	InternalAccessResource,<si,hResInfo,ax>
	mov	di,ax
	inc	ax
	jz	drhx
ifdef WOW_OPTIMIZE_PRELOADRESOURCE
	cCall	ResAlloc,<si,hResInfo,di,di, 0, 0>
else
	cCall	ResAlloc,<si,hResInfo,di,di>
endif
	push	ax
;;;	cCall	_lclose,<di>
	push	bx
	cCall	CloseCachedFileHandle,<di>
	mov	bx, SavePDB
	mov	Win_PDB, bx	; Restore PDB
	pop	bx
	pop	ax
drhx:
cEnd

;-----------------------------------------------------------------------;
; LoadResource								;
; 									;
; Called by each task ONCE to load a resource.				;
; If this is the VERY FIRST time this resource is loaded		;
;   AND it is fixed, then the resource handler proc is called.		;
;   AND it is discardable then only a handle is allocated.  We wait	;
;    until LockResource to actually load the resource.			;
;									;
; If the resource had been loaded by a previous task			;
;  then we load it if it has been discarded.				;
;									;
; Arguments:								;
;	HANDLE hResFile							;
;	HANDLE hResInfo							;
; 									;
; Returns:								;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Tue Jan 01, 1980 07:23:34p  -by-  David N. Weise   [davidw]          ;
; ReWrote it from C into assembly and added this nifty comment block.	;
;-----------------------------------------------------------------------;

cProc	ILoadResource,<PUBLIC,FAR>,<di,si>

	parmW	hResFile
	parmW	hResInfo
	localV	DscBuf,DSC_LEN
	localD	lpfn
cBegin
	mov	di,hResInfo		; DI = pName
	or	di,di
	jnz	got_a_hResInfo
	jmp	lr_error_ret
got_a_hResInfo:

	cCall	GetExePtr,<hResFile>
	or	ax,ax
	jnz	got_a_resource_file
	jmp	lr_error_ret
got_a_resource_file:

	mov	ds,ax			; DS = pExe
	mov	si,ds:[ne_rsrctab]	; DS:SI = pRes
	cmp	si,ds:[ne_restab]
	jnz	got_a_resource_table
	jmp	lr_error_ret
got_a_resource_table:

; If first LoadResource on resource, then call resource handler proc
;  associated with resource type.

	mov	ax,[di].rn_usage
	or	ax,ax
	jz	maybe_load_it
got_it:	inc	[di].rn_usage
	mov	ax,[di].rn_handle
	jmp	lr_ret

; IF
;    1) the resource is discardable
;    2) and has been loaded before
;    3) and has been FreeResource'd
;    4) but not yet discarded (See FreeResource for this madness!)
; THEN
;    1) the usage count is zero
;    2) it's still marked loaded
;    3) it's still in memory 

maybe_load_it:
	cmp	ax,[di].rn_handle	; we know that ax == rn_usage == 0
	jz	not_loaded_before
	test	[di].rn_flags,RNLOADED
	jz	load_it
	cCall	GlobalFlags,<[di].rn_handle>
	test	ah,HE_DISCARDED
	jz	got_it
	jmps	load_it

not_loaded_before:
	test	[di].rn_flags,RNDISCARD
	jz	load_it

; Allocate a zero length object to get a handle.

	push	si
	mov	ax, [di].rn_length
	xor	dx, dx
	mov	bx, ds:ne_rsrctab
	mov	cx, [bx].rs_align
fred:
	shl	ax, 1
	rcl	dx, 1
	loop	fred

	add	ax, 15
	adc	dx, 0
	mov	cx, dx
	inc	cx			; # selectors
;; WOW x86 only
	cCall	AllocResSelArray,<cx,ds>
	jz	no_sel
	StoH	al
no_sel:
	pop	si
	mov	[di].rn_handle,ax
	jmp	got_it
load_it:
	lea	si,[si].SIZE new_rsrc	; DS:SI = pType
lr_type_loop:
	cmp	[si].rt_id,0
	jz	lr_error_ret
	lea	bx,[si].SIZE rsrc_typeinfo	; BX =pName1
	mov	ax,word ptr [si].rt_proc[0]
	or	ax,word ptr [si].rt_proc[2]
	jz	lr_skip_name
	mov	cx,[si].rt_nres
	jcxz	lr_next_type
lr_name_loop:
	cmp	bx,di
	jnz	lr_next_name

	push	ds		; Zap segment registers to prevent

	mov	ax,word ptr [si].rt_proc
	mov	word ptr lpfn,ax
	mov	ax,word ptr [si].rt_proc+2
	mov	word ptr lpfn+2,ax

	push	[di].rn_handle
	push	hResFile
	push	hResInfo

	mov	ax,ss		; callee from trashing our DS.
	mov	ds,ax
	mov	es,ax

	call	lpfn

	pop	ds

	or	ax,ax
	jz	lr_ret
	mov	[di].rn_handle,ax
	or	[di].rn_flags,RNLOADED
	jmp	got_it

lr_next_name:
	add	bx,SIZE rsrc_nameinfo
	loop	lr_name_loop
	jmps	lr_next_type

lr_skip_name:
	mov	ax,[si].rt_nres
	mov	cx,SIZE rsrc_nameinfo
	mul	cx
	add	bx,ax

lr_next_type:
	mov	si,bx
	jmp	lr_type_loop


lr_error_ret:
if KDEBUG
	xor	bx,bx
	kerror	ERR_BADRESFILE,<Error loading from resource file - >,ds,bx
endif
	xor	ax,ax
lr_ret:

cEnd

sEnd	CODE


sBegin	MISCCODE
assumes CS,MISCCODE
assumes DS,NOTHING
assumes ES,NOTHING

externNP MISCMapDStoDATA

cProc	GetResOrd,<PUBLIC,NEAR>,<si,di>
	parmW	hResFile
	parmD	lpszType
        parmD   lpszName
        localW  hRes
cBegin
	cCall	OrdinalOrString, <lpszType>
        mov	si,ax
	cCall	OrdinalOrString, <lpszName>
	mov	di,ax

gro_maybe_search_nametable:
;	
; First see if we need to search the name table at all (if we have ordinals
; already, we don't need to do the search).
;
	xor	ax,ax
        cmp	si,ax
        jz	gro_do_search_nametable
	or	ax,di
        jnz	gro_exit1	; Both are ordinals - just exit
	or	ax,seg_lpszName	; If lpszName is NULL, exit because
	jnz	gro_do_search_nametable ; we have the type ordinal.

gro_exit1:
	jmp	gro_exit

gro_do_search_nametable:
	cCall	GetExePtr,<hResFile>
        mov	es,ax
        mov	bx,es:[ne_rsrctab]
	cmp	bx,es:[ne_restab]
        jz	gro_exit1

	add	bx,SIZE new_rsrc

gro_check_resource_type:
	cmp	es:[bx].rt_id,0
	jz	gro_exit1
	cmp	es:[bx].rt_id,(RT_NAMETABLE OR RSORDID)
	jz	gro_found_resource_table_entry

	mov	cx,es:[bx].rt_nres
	add	bx,SIZE RSRC_TYPEINFO

	; add 12*nres to bx (12*size of resource)

	.errnz	((SIZE RSRC_NAMEINFO) - 12)

	shl	cx,1
	shl	cx,1
	add	bx,cx
	shl	cx,1
	add	bx,cx
	jmps	gro_check_resource_type


gro_found_resource_table_entry:
	add	bx,SIZE RSRC_TYPEINFO
	mov	ax,es:[bx].rn_handle
	or	ax,ax
        jnz	gro_have_handle_nametable

	xor	ax,ax
        mov	dx,1
	mov	bx,RT_NAMETABLE
	cCall	<far ptr IFindResource>,<hResFile,ax,dx,ax,bx>
        or	ax,ax
	jz	gro_exit1

	push	ds		; DS not even really used probably
	cCall	MISCMapDStoDATA ; Hack, need DS pointing to something
	cCall	ILoadResource,<hResFile,ax>    ;  with a handle
	pop	ds
	or	ax,ax
	jnz	gro_have_handle_nametable
gro_exit2:
	jmp	gro_exit

gro_have_handle_nametable:

	mov	hRes,ax
	push	ds		; DS not even really used probably
	cCall	MISCMapDStoDATA ; Hack, need DS pointing to something
	cCall	ILockResource,<ax> ;  with a handle
	pop	ds

	mov	cx,ax
        or	cx,dx
	jcxz	gro_exit2

	mov	es,dx	; es:bx is a pointer to resource
        mov	bx,ax

;
; Now we have a pointer to the resource. Scan through the name table and
; find a match in the table with the passed type/name.
; SI = type ordinal, 0 if string type
; DI = name ordinal, 0 if string name
;
gro_nametable_loop:
	
	or	si,si
        jz	gro_do_type_string_match

	cmp	si,es:[bx].ntbl_idType
        jnz	gro_next_nametable_entry
	jmps	gro_do_name_match

gro_do_type_string_match:

	push	es	; Save pntbl
        push	bx

	lea	ax,es:[bx].ntbl_achTypeName
	push	es
        push	ax
	push	seg_lpszType
        push	off_lpszType
	call	lstrOriginal	; compare against type name

	pop	bx	; Restore pntbl
        pop	es

	or	ax,ax
        jnz	gro_next_nametable_entry

gro_do_name_match:

	or	di,di
        jz	gro_do_name_string_match

        cmp	di,es:[bx].ntbl_idName
        jnz	gro_next_nametable_entry
	jmps	gro_found_nametable_match

gro_do_name_string_match:

	cmp	seg_lpszName, 0
	jne	want_name
        mov	si,es:[bx].ntbl_idType		; Hey man, can't check name!
	jmps	gro_unlock_resource

want_name:
	push	es	; push pntbl for later restoration
        push	bx

	push	es	; push pntbl for later strcmp
        push	bx
	lea	ax,es:[bx].ntbl_achTypeName
	
        push	es
        push	ax
        call	lstrlen	; get string length

	mov	bx,sp	; Adjust pointer on stack to point
	add	ss:[bx],ax	; past first string
        add	word ptr ss:[bx],ntbl_achTypeName + 1
	push	seg_lpszName
        push	off_lpszName
        call	lstrOriginal

	pop	bx
        pop	es

        or	ax,ax
	jz	gro_found_nametable_match

gro_next_nametable_entry:

	add	bx,es:[bx].ntbl_cbEntry
	cmp	es:[bx].ntbl_cbEntry,0
        jnz	gro_nametable_loop        
	jmps	gro_unlock_resource

gro_found_nametable_match:

	mov	ax,es:[bx].ntbl_idType
	test	ax,RSORDID
        jz	gro_try_replace_name
        mov	si,ax

gro_try_replace_name:

	mov	ax,es:[bx].ntbl_idName
        test	ax,RSORDID
        jz	gro_unlock_resource
        mov	di,ax

gro_unlock_resource:

	push	hRes
        call	GlobalUnlock

gro_exit:
	xor	ax,ax
        cwd
	or	ax,si
	jz	gro_test_name_ordinal
	or	ax,RSORDID

gro_test_name_ordinal:
	or	dx,di
        jz	gro_leave
	or	dx,RSORDID	

gro_leave:
cEnd

cProc OrdinalOrString, <PUBLIC, NEAR>, <si>
	parmD	s
cBegin
	les	si,s
	mov	cx,si
	mov	ax,es
	or	ax,ax
	jz	codone
	xor	cx,cx			; sum = zero
	cld
	lods	byte ptr es:[si]	; c = *pName++
	cmp	al,'#'
	jne	codone
coloop:
	lods	byte ptr es:[si]	; c = *pName++
	or	al,al			; if (!c) break;
	jz	codone
	sub	al,'0'			; if (!isdigit(c))
	cmp	al,9
	ja	codone			;
	xor	ah,ah
	mov	bx,ax			; sum = (sum * 10) + (c - '0')
	mov	al,10
	mul	cx
	add	ax,bx
	mov	cx,ax
	jmp	coloop
codone:
	mov	ax,cx
coexit:
cEnd

cProc	CmpResStr,<PUBLIC,NEAR>,<ds,si>
	parmD pRes
	parmW id
	parmD s
cBegin
	mov	ax,id
	test	ax,RSORDID
	jnz	crsneq
	lds	si,pRes
	add	si,ax
	xor	ax,ax
	cld
	lodsb
	mov	cx,ax
	les	bx,s
crsloop:
	mov	al,es:[bx]
	inc	bx
	or	al,al
	jz	crsneq
	call	FarMyUpper
	mov	ah,al
	lodsb
	cmp	ah,al
	jne	crsneq
	loop	crsloop
	xor	ax,ax
	cmp	es:[bx],al
	jne	crsneq
	not	ax
	jmps	crsexit
crsneq:
	xor	ax,ax
crsexit:
cEnd


;-----------------------------------------------------------------------;
; SetResourceHandler							;
; 									;
; Sets the resource handler for the given type.				;
;									;
; Note that the string pointed to can be the resource ID.  In this	;
; case the string should have the form #ID.				;
;									;
; If the seg of pointer = 0, then the offset is	taken as the ID.	;
;									;
; Arguments:								;
;	HANDLE hResFile							;
;	char far *lpszType						;
;	FARPROC lpHandler						;
; 									;
; Returns:								;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
;	GetExePtr							;
;	GetResOrd							;
;	CmpResStr							;
;									;
; History:								;
; 									;
;  Tue Jan 01, 1980 04:13:03p  -by-  David N. Weise   [davidw]          ;
; ReWrote it from C into assembly and added this nifty comment block.	;
;-----------------------------------------------------------------------;

cProc	ISetResourceHandler,<PUBLIC,FAR>,<di,si>

	parmW	hResFile
	parmD	lpszType
	parmD	lpHandler
cBegin
	cCall	GetExePtr,<hResFile>
	mov	ds,ax			; DS  = pExe
	mov	si,ds:[ne_rsrctab]	; DS:SI = pRes
	cmp	si,ds:[ne_restab]
	jz	srh_type_not_found	; No resources in this module!

;
; Pass the type string and NULL for the name string. AX = type ordinal, 0
; if it doesn't exist.
;
	push	hResFile
        push	seg_lpszType
        push	off_lpszType
        xor	ax,ax
        push	ax
        push	ax
	call	GetResOrd

	lea	di,[si].SIZE new_rsrc	; DS:DI = pType
srh_type_loop:
	mov	cx,[di].rt_id
	jcxz	srh_type_not_found
	push	ax			; typeord
	or	ax,ax
	jz	srh_compare_string
	cmp	ax,cx
	jz	srh_type_found
	jmps	srh_next_type
srh_compare_string:
	cCall	CmpResStr,<ds,si,cx,lpszType>
	or	ax,ax
	jnz	srh_type_found
srh_next_type:
	mov	ax,[di].rt_nres
	mov	cx,SIZE rsrc_nameinfo
	mul	cx
	add	ax, SIZE rsrc_typeinfo
	add	di,ax
	pop	ax
	jmp	srh_type_loop

srh_type_found:
	pop	ax			; clean stack
	mov	dx,word ptr lpHandler[2]
	mov	ax,word ptr lpHandler[0]
	xchg	dx,word ptr [di].rt_proc[2]
	xchg	ax,word ptr [di].rt_proc[0]
	jmps	srh_ret

srh_type_not_found:
	xor	ax,ax
	xor	dx,dx
srh_ret:

cEnd


;-----------------------------------------------------------------------;
; FindResource								;
; 									;
; Returns a near pointer (into the module database) to the resource	;
; description structure.						;
;									;
; Note that the string pointed to can be the resource ID.  In this	;
; case the string should have the form #ID.				;
;									;
; If the seg of pointer = 0, then the offset is	taken as the ID.	;
;									;
; Arguments:								;
;	HANDLE hResFile							;
;	char far *lpszName						;
;	char far *lpszType						;
; 									;
; Returns:								;
;	AX = near pointer to resource description structure.		;
;									;
; Error Returns:							;
;	AX = 0								;
;									;
; Registers Preserved:							;
;	DI,SI,DS							;
;									;
; Registers Destroyed:							;
;	BX,CX,DX,ES							;
;									;
; Calls:								;
;	GetExePtr							;
;	GetResOrd							;
;	CmpResStr							;
;									;
; History:								;
; 									;
;  Tue Jan 01, 1980 10:00:15p  -by-  David N. Weise   [davidw]          ;
; ReWrote it from C into assembly and added this nifty comment block.	;
;  Wed May 31, 1989 09:17:00a  -by-  Scott R. Ludwig  [scottlu]		
; Rewrote so that string identifiers map to ordinals through an indirection
; table called a 'name table'. For OS/2 .EXE Compatibility.
;-----------------------------------------------------------------------;

cProc	IFindResource,<PUBLIC,FAR>,<di,si>

	parmW	hResFile
	parmD	lpszName
	parmD	lpszType
	localW	typeord
	localW	nameord
cBegin
	cCall	GetExePtr,<hResFile>
	mov	ds,ax	; DS = pExe
	mov	si,ds:[ne_rsrctab]	; DS:SI = pRes
	cmp	si,ds:[ne_restab]
	jz	fr_error_ret

;
; Get resource ordinals. ax = type ordinal, dx = name ordinal. (0 if not
; ordinals).
;
	cCall	GetResOrd,<hResFile, lpszType, lpszName>
	mov	typeord,ax
        mov	nameord,dx

; First find the resource type.

	lea	di,[si].SIZE new_rsrc	; DS:DI = pType
fr_type_loop:
	mov	cx,[di].rt_id
	jcxz	fr_error_ret
	mov	ax,typeord
	or	ax,ax
	jz	fr_compare_type_string
	cmp	ax,cx
	jz	fr_found_type
	jmps	fr_next_type
fr_compare_type_string:
	cCall	CmpResStr,<ds,si,cx,lpszType>
	or	ax,ax
	jnz	fr_found_type
fr_next_type:
	mov	ax,[di].rt_nres
	mov	cx,SIZE rsrc_nameinfo
	mul	cx
	add	ax,SIZE rsrc_typeinfo
	add	di,ax
	jmp	fr_type_loop
fr_found_type:

; Now find the resource name.

	mov	cx,[di].rt_nres
	lea	di,[di].SIZE rsrc_typeinfo	; DS:DI = pName
fr_name_loop:
	mov	bx,nameord
	or	bx,bx
	mov	ax,[di].rn_id
	jz	fr_compare_name_string
	cmp	ax,bx
	jz	fr_found_name
	jmps	fr_next_name
fr_compare_name_string:
	push	cx
	cCall	CmpResStr,<ds,si,ax,lpszName>
	pop	cx
	or	ax,ax
	jnz	fr_found_name
fr_next_name:
	add	di,SIZE rsrc_nameinfo
	loop	fr_name_loop
fr_error_ret:
	xor	ax,ax
	jmps	fr_ret

fr_found_name:
	mov	ax,di
fr_ret:
cEnd

sEnd MISCCODE


sBegin	NRESCODE
assumes CS,NRESCODE
assumes DS,NOTHING
assumes ES,NOTHING


cProc	PreloadResources,<PUBLIC,NEAR>,<si,di>
	parmW   hExe
	parmW   fh
	parmW	hBlock
	parmD	FileOffset
ifdef WOW_OPTIMIZE_PRELOADRESOURCE
        localW  hiResOffset
        localW  loResOffset
endif

cBegin
	mov	es,hExe
	xor	bx,bx
	mov	si,es:[bx].ne_rsrctab
	cmp	es:[bx].ne_restab,si
	jne	prnotdone
prdonej:
	jmp	prdone
prnextj:
	jmp	prnext

prnotdone:
	mov	di,es:[si].rs_align
	add	si,SIZE new_rsrc
prtype:
	cmp	es:[si].rt_id,0
	je	prdonej
	mov	cx,es:[si].rt_nres
	mov	word ptr es:[si].rt_proc[0],codeOffset DefaultResourceHandler
	mov	word ptr es:[si].rt_proc[2],codeBase
	add	si,SIZE rsrc_typeinfo
prname:
	push	cx
	mov	ax,es:[si].rn_flags
;	cmp	word ptr es:[ne_ver],4	; Produced by version 4.0 LINK?
;	ja	prname2
;	test	ah,0Fh			; Is old discard field set?
;	jz	prname1
;	or	ax,RNDISCARD		; Yes, convert to bit
;prname1:
;	and	ax,not RNUNUSED		; Clear unused bits in 4.0 LINK files
prname2:
	or	ax,NENOTP
	errnz	<NENOTP - 8000h>
	test	es:[ne_flags],NENOTP
	jnz	prname4			; Mark as EMSable if resource belongs
	xor	ax,NENOTP		;  to a task.
prname4:
	mov	es:[si].rn_flags,ax
	test	al,RNPRELOAD
	jz	prnextj

	mov	cx, seg_FileOffset
	or	cx, off_FileOffset
	jcxz	PL_file

	cmp	di, 4			; Must be at least paragraph aligned
	jb	PL_file

	push	es
	cCall	GlobalLock,<hBlock>
ifdef WOW_OPTIMIZE_PRELOADRESOURCE
        mov     ax,dx          ; no need to alloc a selector. we will use the
                               ; the current one.
if KDEBUG                      
        or      ax, ax
        jnz     @F
        int     3 ;           // should never happen
@@:
endif

else
	cCall	AllocSelector,<dx>
endif
       
	pop	es
	mov	bx,es:[si].rn_offset
	xor	dx,dx
	mov	cx,di
PL_shift:
	shl	bx,1
	rcl	dx,1
	loop	PL_shift

	sub	bx, off_FileOffset
	sbb	dx, seg_FileOffset
ifdef WOW_OPTIMIZE_PRELOADRESOURCE
        ; call to longptraddwow basically is a nop. it doesn't set the 
        ; descriptor. it is called 'cause it sets some registers.

        mov     hiResOffset, dx
        mov     loResOffset, bx
	push	ax
	push	es
	cCall	LongPtrAddWOW,<ax,cx,dx,bx, 0, 0>	; (cx is 0)
	pop	es
	dec	cx
	cCall	ResAlloc,<essi,dx,cx, hiResOffset, loResOffset>
	pop	cx
	push	ax
else
	push	ax
	push	es
	cCall	LongPtrAdd,<ax,cx,dx,bx>	; (cx is 0)
	pop	es
	dec	cx
	cCall	ResAlloc,<essi,dx,cx, 0, 0>
	pop	cx
	push	ax
	cCall	FreeSelector,<cx>
endif
	cCall	GlobalUnlock,<hBlock>
	pop	ax
	jmps	PL_loaded

PL_file:
	mov	dx,es:[si].rn_offset
	xor	ax,ax
	mov	cx,di
PL_shift1:
	shl	dx,1
	rcl	ax,1
	loop	PL_shift1
	mov	cx,ax
	mov	ax,4200h
	mov	bx,fh
	DOSFCALL
ifdef WOW_OPTIMIZE_PRELOADRESOURCE
	cCall	ResAlloc,<essi,bx,bx, 0, 0>
else
	cCall	ResAlloc,<essi,bx,bx>
endif

PL_loaded:
	mov	es,hExe
	mov	es:[si].rn_handle,ax
prnext:
	pop	cx
	add	si,SIZE rsrc_nameinfo
	dec	cx
	jz	prtypej
	jmp	prname
prtypej:
	jmp	prtype
prdone:
cEnd

sEnd	NRESCODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\rip.c ===
/****************************************************************************/
/*									    */
/*  RIP.C -								    */
/*									    */
/*	Debugging Support Routines					    */
/*									    */
/****************************************************************************/

#include "kernel.h"
#include "newexe.h"

#ifdef WOW
// Note:  The functions in this file were moved to the _MISCTEXT code segment
//        because _TEXT was exceeding the 64K segment limit   a-craigj
LPSTR htoa(LPSTR, WORD);
LPSTR htoa0(LPSTR, WORD);
LPSTR FAR far_htoa0(LPSTR, WORD);
#pragma alloc_text(_MISCTEXT,far_htoa0)
#pragma alloc_text(_MISCTEXT,htoa0)
#pragma alloc_text(_MISCTEXT,htoa)
#endif

#if KDEBUG

#include "logerror.h"
#define API	_far _pascal _loadds

extern unsigned int DebugOptions;

/* Defines for debug strings in STRINGS.ASM. */
#define DS_LOADFAIL	    0
#define DS_NEWINSTLOADFAIL  1
#define DS_RESLOADERR	    2
#define DS_CRLF 	    3
#define DS_FATALEXITCODE    4
#define DS_STACKOVERFLOW    5
#define DS_STACKTRACE	    6
#define DS_ABORTBREAKIGNORE 7
#define DS_INVALIDBPCHAIN   8
#define DS_COLON	    9
#define DS_REENTERFATALEXIT 10

#ifndef WOW
LPSTR htoa(LPSTR, WORD);
LPSTR htoa0(LPSTR, WORD);
#endif

char DebugRead(void);
void DoAbort(void);
void EnterBreak(int);
HANDLE FAR GetExeHead(void);
#ifdef WOW
LONG NEAR PASCAL LSHL(WORD, int);
#pragma alloc_text(_MISCTEXT,LSHL)
int  FAR DebugWrite(LPSTR, int);
int  FAR OpenSymFile(LPSTR);
void FAR GetSymFileName(HANDLE, LPSTR);
int  FAR FarValidatePointer(LPSTR);
BOOL FAR PASCAL IsCodeSelector(WORD);
#else
LONG PASCAL LSHL(WORD, int);
int  OpenSymFile(LPSTR);
void GetSymFileName(HANDLE, LPSTR);
int  ValidatePointer(LPSTR);
BOOL PASCAL IsCodeSelector(WORD);
#endif
WORD (far PASCAL *FatalExitProc)(WORD, WORD);
int FAR FatalExitC(WORD);
void FAR FatalAppExit(WORD, LPSTR);

#ifdef WOW
int FAR KernelError(int errCode, LPSTR lpmsg1, LPSTR lpmsg2);
static char far *GetModName(char far *exeName);
void API GetProcName(FARPROC lpfn, LPSTR lpch, int cch);
WORD far *NextFrame(WORD far *lpFrame);
void StackWalk(WORD arg);
#pragma alloc_text(_MISCTEXT,KernelError)
#pragma alloc_text(_MISCTEXT,GetModName)
#pragma alloc_text(_MISCTEXT,GetProcName)
#pragma alloc_text(_MISCTEXT,NextFrame)
#pragma alloc_text(_MISCTEXT,StackWalk)
#endif  // WOW

/* Debug Symbol Table Structures:
 *
 * For each symbol table (map): (MAPDEF)
 * -------------------------------------------------------------------------------------------------
 * | map_ptr | lsa | pgm_ent | abs_cnt | abs_ptr | seg_cnt | seg_ptr | nam_max | nam_len | name... |
 * -------------------------------------------------------------------------------------------------
 */

typedef struct tagMAPDEF
{
	unsigned	  map_ptr;    /* 16 bit ptr to next map (0 if end)    */
	unsigned	  lsa	 ;    /* 16 bit Load Segment address	      */
	unsigned	  pgm_ent;    /* 16 bit entry point segment value     */
	int 	  abs_cnt;    /* 16 bit count of constants in map     */
	unsigned	  abs_ptr;    /* 16 bit ptr to	 constant chain       */
	int 	  seg_cnt;    /* 16 bit count of segments in map      */
	unsigned	  seg_ptr;    /* 16 bit ptr to	 segment chain	      */
	char	  nam_max;    /*  8 bit Maximum Symbol name length    */
	char	  nam_len;    /*  8 bit Symbol table name length      */
}
MAPDEF;

typedef struct tagMAPEND
{
	unsigned	  chnend;     /* end of map chain (0) */
	char	  rel;	      /* release	      */
	char	  ver;	      /* version	      */
}
MAPEND;


/* For each segment/group within a symbol table: (SEGDEF)
 * --------------------------------------------------------------
 * | nxt_seg | sym_cnt | sym_ptr | seg_lsa | name_len | name... |
 * --------------------------------------------------------------
 */

typedef struct tagSEGDEF
{
	unsigned	  nxt_seg;    /* 16 bit ptr to next segment(0 if end) */
	int 	  sym_cnt;    /* 16 bit count of symbols in sym list  */
	unsigned	  sym_ptr;    /* 16 bit ptr to symbol list	      */
	unsigned	  seg_lsa;    /* 16 bit Load Segment address	      */
	unsigned	  seg_in0;    /* 16 bit instance 0 physical address   */
	unsigned	  seg_in1;    /* 16 bit instance 1 physical address   */
	unsigned	  seg_in2;    /* 16 bit instance 2 physical address   */
	unsigned	  seg_in3;    /* 16 bit instance 3 physical address   */
	unsigned	  seg_lin;    /* 16 bit ptr to line number record     */
	char	  seg_ldd;    /*  8 bit boolean 0 if seg not loaded   */
	char	  seg_cin;    /*  8 bit current instance	      */
	char	  nam_len;    /*  8 bit Segment name length	      */
}
SEGDEF;
typedef SEGDEF FAR  *LPSEGDEF;


/*  Followed by a list of SYMDEF's..
 *  for each symbol within a segment/group: (SYMDEF)
 * -------------------------------
 * | sym_val | nam_len | name... |
 * -------------------------------
 */

typedef struct tagSYMDEF
{
	unsigned	  sym_val;    /* 16 bit symbol addr or const	      */
	char	  nam_len;    /*  8 bit symbol name length	      */
}
SYMDEF;


typedef struct tagRIPINFO
{
	char	  symName[128];
	LPSTR	  pSymName;
	DWORD	  symFPos;
	int 	  symFH;
}
RIPINFO;
typedef RIPINFO FAR *LPRIPINFO;



/*--------------------------------------------------------------------------*/
/*									    */
/*  KernelError() -							    */
/*									    */
/*--------------------------------------------------------------------------*/

/* Print out the module name, the message which 'lpmsg1' points to, and the
 *   value of 'lpmsg2' in hex.	Then call FatalExit.
 */

int FAR KernelError(int errCode, LPSTR lpmsg1, LPSTR lpmsg2) {
	int	n;
	char	buf[16];
	LPSTR pbuf;
	WORD	hExe;
	WORD	pfileinfo;

	struct new_exe far *pExe;

	/* Write out 'lpmsg1'. */
	if (lpmsg1)
		DebugWrite(lpmsg1, 0);

	/* Is the second pointer non-NULL? */
	if (lpmsg2)
	{
		/* Is the segment value non-NULL? */
		if ( (hExe = (WORD)((DWORD)lpmsg2 >> 16))
#ifdef WOW
		     && FarValidatePointer(lpmsg2) )
#else
		     && ValidatePointer(lpmsg2) )
#endif
		{
			/* Does it point anywhere inside a New EXE Header? */
			pExe = (struct new_exe far *)((DWORD)hExe << 16);
			if (pExe->ne_magic == NEMAGIC)
			{
				/* Write out the module name (1st in the resident names table).*/
				pbuf = (LPSTR)(((DWORD)hExe << 16) | pExe->ne_restab);
				if (n = (int)((BYTE)*pbuf++))
				{
					DebugWrite(pbuf, n);
					DebugWrite(GetDebugString(DS_COLON), 0);
				}

				/* Is the offset NULL? */
				if (!LOWORD(lpmsg2))
				{
					/* Get the pointer to the full-path name which we stuck in
					   * the checksum a long time ago.
					   */
					if (pfileinfo = NE_PFILEINFO(*pExe))
						(DWORD)lpmsg2 |= (DWORD)pfileinfo;
					else
					{
						pExe = (struct new_exe far *)((DWORD)GetExeHead() << 16);
						pfileinfo = NE_PFILEINFO(*pExe);
						lpmsg2 = (LPSTR)(((DWORD)hExe << 16) | pfileinfo);
					}
					lpmsg2 += 8;	/* HERE???? */
				}
			}

			/* Write out the full-path name. */
			pbuf = lpmsg2;
			n = 0;
			while ((BYTE)*pbuf++ >= ' ')
				n++;

			if (n && n < 64)
				DebugWrite(lpmsg2, n);
		}

		/* Write out the second pointer in hex. */
		pbuf = (LPSTR)buf;
		*pbuf++ = ' ';
		pbuf = htoa(pbuf, HIWORD(lpmsg2));
		*pbuf++ = ':';
		pbuf = htoa(pbuf, LOWORD(lpmsg2));
		*pbuf++ = '\r';
		*pbuf++ = '\n';
		*pbuf++ = 0;
		DebugWrite((LPSTR)buf, 0);
	}

	/* Print errCode and dump the stack. */
	return FatalExitC(errCode);
}


static char far *GetModName(char far *exeName) {
	int delim, dot, len, i;
	delim = 0;
	dot = 0;
	for (i=0; i<80 && exeName[i]; i++) {
		if (exeName[i] == '.')
			dot = i;
		if (exeName[i] == ':' || exeName[i] == '\\')
			delim = i+1;
	}
	if (!dot) dot = i;
	len = dot - delim;
	for (i=0; i<len; i++)
		exeName[i] = exeName[i+delim];
	exeName[len] = 0;
	return exeName+len;
} /* GetModName */


/*--------------------------------------------------------------------------*/
/*									    */
/*  FindSegSyms() -							    */
/*									    */
/*--------------------------------------------------------------------------*/

#ifdef WOW
int FindSegSyms(LPRIPINFO lpRipInfo, LPSEGDEF lpSegDef, WORD CSvalue);
#pragma alloc_text(_MISCTEXT,FindSegSyms)
#endif
int FindSegSyms(LPRIPINFO lpRipInfo, LPSEGDEF lpSegDef, WORD CSvalue) {
	HANDLE	      hExe;
	struct new_exe far  *pExe;
	struct new_seg1 far *pSeg;
	MAPDEF	      MapDef;
	MAPEND	      MapEnd;
	LPSTR 	      pFileName;
	BYTE		      c;
	int		      i;
	int		      j;
	WORD		      seg_ptr;

	if (lpRipInfo->symFH != -1)
	{
		_lclose(lpRipInfo->symFH);
		lpRipInfo->symFH = -1;
	}

	hExe = GetExeHead();
	while (hExe)
	{
		pExe = (struct new_exe far *)((DWORD)hExe << 16);
		pSeg = (struct new_seg1 far *)(((DWORD)hExe << 16) | pExe->ne_segtab);

		for (i=0; i < pExe->ne_cseg; i++, pSeg++)
		{
#if 1
			if (HIWORD(GlobalHandleNoRIP((HANDLE)pSeg->ns_handle)) == CSvalue)
#else
				if (MyLock((HANDLE)pSeg->ns_handle) == CSvalue)
#endif
				{
					lpRipInfo->pSymName = (LPSTR)lpRipInfo->symName;
					GetSymFileName(hExe, lpRipInfo->pSymName);
					if ((lpRipInfo->symFH = OpenSymFile(lpRipInfo->pSymName)) != -1)
					{
						_lread(lpRipInfo->symFH, (LPSTR)&MapDef, sizeof(MAPDEF));
						_lread(lpRipInfo->symFH, lpRipInfo->pSymName, (int)((BYTE)MapDef.nam_len));

						if (i > MapDef.seg_cnt)	/* Too much assembly */
							goto ModName;

						lpRipInfo->pSymName += MapDef.nam_len;
						*lpRipInfo->pSymName++ = '!';
						*lpRipInfo->pSymName = 0;
						seg_ptr = (WORD)MapDef.seg_ptr;
						_llseek(lpRipInfo->symFH, -(long)sizeof(MAPEND), 2);
						_lread(lpRipInfo->symFH, (LPSTR)&MapEnd, sizeof(MAPEND));
						if (MapEnd.ver != 3) goto ModName;

						j = i + 1;
						while (j--)
						{
							if (MapEnd.rel >= 10)
								_llseek(lpRipInfo->symFH, LSHL(seg_ptr, 4), 0);
							else
								_llseek(lpRipInfo->symFH, (long)seg_ptr, 0);
							_lread( lpRipInfo->symFH, (LPSTR)lpSegDef, sizeof(*lpSegDef));
							seg_ptr = (WORD)lpSegDef->nxt_seg;
						}

						_lread(lpRipInfo->symFH, lpRipInfo->pSymName, (int)((BYTE)lpSegDef->nam_len));
						lpRipInfo->pSymName += lpSegDef->nam_len;
						*lpRipInfo->pSymName++ = ':';
						*lpRipInfo->pSymName = 0;
						lpRipInfo->symFPos = (DWORD)_llseek(lpRipInfo->symFH, 0L, 1);

						return(TRUE);
					} /* if opened file */
ModName:
					/* Put Module on line:  USER(0033)XXXX:XXXX */
					GetSymFileName(hExe, lpRipInfo->symName);
					lpRipInfo->pSymName = GetModName(lpRipInfo->symName);
					*lpRipInfo->pSymName++ = '(';
                                        lpRipInfo->pSymName = htoa0(lpRipInfo->pSymName, i+1);
					*lpRipInfo->pSymName++ = ')';
					*lpRipInfo->pSymName = 0;
					goto TermName;
				}
		}
		hExe = (HANDLE)NE_PNEXTEXE(*pExe);
	}
	lpRipInfo->pSymName = lpRipInfo->symName;
TermName:	/* Add segment:offset to line */
	lpRipInfo->pSymName = htoa((LPSTR)lpRipInfo->pSymName, CSvalue);
	*lpRipInfo->pSymName++ = ':';
	*lpRipInfo->pSymName	 = 0;
	if (lpRipInfo->symFH != -1) {
		_lclose(lpRipInfo->symFH);
		lpRipInfo->symFH = -1;
	}
	return(FALSE);
}


/*--------------------------------------------------------------------------*/
/*									    */
/*  FindSymbol() -							    */
/*									    */
/*--------------------------------------------------------------------------*/

#ifdef WOW
int FindSymbol(LPRIPINFO lpRipInfo, LPSEGDEF lpSegDef, WORD offset);
#pragma alloc_text(_MISCTEXT,FindSymbol)
#endif
int FindSymbol(LPRIPINFO lpRipInfo, LPSEGDEF lpSegDef, WORD offset) {
	WORD		i;
	DWORD	symPos, curPos;
	LPSTR 	s;
	SYMDEF	SymDef;

	if (lpRipInfo->symFH != -1)
	{
		curPos = symPos = (DWORD)_llseek(lpRipInfo->symFH, (long)lpRipInfo->symFPos, 0);
		i = (WORD)lpSegDef->sym_cnt;
		while (i--)
		{
			_lread(lpRipInfo->symFH, (LPSTR)&SymDef, sizeof(SYMDEF));
			if ((WORD)SymDef.sym_val > offset)
			    break;

			symPos = curPos;

			curPos = _llseek(lpRipInfo->symFH, (long)SymDef.nam_len, 1);
		}
		_llseek(lpRipInfo->symFH, (long)symPos, 0);
		_lread(lpRipInfo->symFH, (LPSTR)&SymDef, sizeof(SYMDEF));
		s = lpRipInfo->pSymName;
		_lread(lpRipInfo->symFH, s, (int)((BYTE)SymDef.nam_len));
		s += SymDef.nam_len;
		if ((WORD)SymDef.sym_val < offset)
		{
			*s++ = '+';
                        s = htoa0(s, offset - SymDef.sym_val);
		}
		*s = 0;
		return(TRUE);
	}

        s = htoa(lpRipInfo->pSymName, offset);
	*s = 0;
	return(FALSE);
}




void API GetProcName(FARPROC lpfn, LPSTR lpch, int cch)
{
    RIPINFO RipInfo;
    SEGDEF  SegDef;
    static char lastName[128] = "test";
    static FARPROC lastfn = 0;

    if (lastfn == lpfn) {	/* cache last symbol name looked up */
      lstrcpy(RipInfo.symName, lastName);
    } else {
      RipInfo.pSymName = 0L;
      RipInfo.symFH    = -1;

      FindSegSyms((LPRIPINFO)&RipInfo, (LPSEGDEF)&SegDef, HIWORD(lpfn));
      FindSymbol((LPRIPINFO)&RipInfo, (LPSEGDEF)&SegDef, LOWORD(lpfn));

      if (RipInfo.symFH != -1) {
	  _lclose(RipInfo.symFH);
	  RipInfo.symFH = -1;
      }
      lstrcpy(lastName, RipInfo.symName);
      lastfn = lpfn;
    }

    if (cch > 1)
    {
	if (cch > sizeof(RipInfo.symName))
	    cch = sizeof(RipInfo.symName);

	RipInfo.symName[cch-1] = 0;
	lstrcpy(lpch, RipInfo.symName);
    }
}


/*--------------------------------------------------------------------------*/
/*									    */
/*  NextFrame() -							    */
/*									    */
/*--------------------------------------------------------------------------*/

WORD far *NextFrame(WORD far *lpFrame) {
	WORD w;

	/* Force BP even. */
	w = *lpFrame & 0xFFFE;

	/* Are we at the end of the BP chain? */
	if (w)
	{
		/* BPs should decrease as we move down the chain. */
		if (w <= LOWORD(lpFrame))
			goto BadBP;

		/* Are we above the top of the stack (SS:000A contains pStackTop)? */
		lpFrame = (WORD far *)(((DWORD)lpFrame & 0xFFFF0000L) | 0x0A);

		if (w < *lpFrame++)
			goto BadBP;

		/* Are we below the bottom of the stack (SS:000C contains pStackMin)? */
		if (w > *++lpFrame)
			goto BadBP;

		/* Return the address of the next BP. */
		return((WORD far *)(((DWORD)lpFrame & 0xFFFF0000L) | w));
	}
	else
		return((WORD far *)0L);

BadBP:
	DebugWrite(GetDebugString(DS_INVALIDBPCHAIN), 0);
	return((WORD far *)0L);
}


/*--------------------------------------------------------------------------*/
/*									    */
/*  StackWalk() -							    */
/*									    */
/*--------------------------------------------------------------------------*/

void StackWalk(WORD arg) {

/* WORD arg;	    /* NOTE: 'arg' is only used as a pointer into the frame. */
/*	     If we subtract 2 words from 'arg's location, we */
/*	     get the address of the previous frame's BP!!!   */
	WORD far	 *lpFrame;
	WORD		 wCurBP;
	WORD		 wCurRetOffset;
	WORD		 curCS;
	RIPINFO	 RipInfo;
	SEGDEF	 SegDef;

	RipInfo.pSymName = 0L;
	RipInfo.symFH    = -1;

	/* Have 'lpFrame' point to the previous frame's BP. */
	lpFrame = &arg - 2;

	curCS = 0;
	while (lpFrame = NextFrame(lpFrame))
	{
		/* Get the next BP.  Stop if it is zero. */
		wCurBP = *lpFrame;
		if (!wCurBP)
			break;

		/* Get the current frame's return address offset. */
		wCurRetOffset = lpFrame[1];

		/* Have we changed code segments (Far call && Different CS)? */
		if (((wCurBP & 1) || IsCodeSelector(lpFrame[2])) && (curCS != lpFrame[2]))
		{
			/* Yes, get the new segment's name. */
			curCS = lpFrame[2];
			FindSegSyms((LPRIPINFO)&RipInfo, (LPSEGDEF)&SegDef, curCS);
		}

		/* Move back to the address of the actual call instruction. */
		if ((wCurBP & 1) || IsCodeSelector(lpFrame[2]))
								/* Near or Far call? */
			wCurRetOffset -= 5;
		else
			wCurRetOffset -= 3;

		FindSymbol((LPRIPINFO)&RipInfo, (LPSEGDEF)&SegDef, wCurRetOffset);

		DebugWrite((LPSTR)RipInfo.symName, 0);

		DebugWrite(GetDebugString(DS_CRLF), 0);
	}
	if (RipInfo.symFH != -1)
		_lclose(RipInfo.symFH);
}

#ifndef WOW 

/*--------------------------------------------------------------------------*/
/*									    */
/*  FatalExit() -							    */
/*									    */
/*--------------------------------------------------------------------------*/

/* Debugging version.  Retail version in RIPAUX.ASM. */
/* Kernel DS setup by prolog code */

int FAR FatalExitC(WORD errCode) {	/* return 1 to break execution */
	char	c;
	char	buf[7];
	LPSTR pbuf;
	int rep=0;

    /* This calls the TOOLHELP RIP hook */
	if ( FatalExitProc )
    {
        _asm
        {
            push    errCode
	    push    bp
	    call    DWORD PTR FatalExitProc
	    or      ax,ax
	    jz      NoReturn
	}
	return 0;

	_asm NoReturn:;
	}

#if 0
	static BOOL fInsideFatalExit = FALSE;

	if (fInsideFatalExit)
	{
		DebugWrite(GetDebugString(DS_REENTERFATALEXIT), 0);
		return 0;
	}

	fInsideFatalExit = TRUE;
#endif

ReRip:
	/* Display "FatalExit Code =" */
	DebugWrite(GetDebugString(DS_FATALEXITCODE), 0);

	/* Did the stack overflow? */
	if (errCode == -1)
		DebugWrite(GetDebugString(DS_STACKOVERFLOW), 0);
	else
	{
		/* Display the error code in hex. */
		pbuf = (LPSTR)buf;
		*pbuf++ = '0';
		*pbuf++ = 'x';
		pbuf = htoa(pbuf, (WORD)errCode);
		*pbuf++ = 0;
		DebugWrite((LPSTR)buf, 0);
	}

	/* Display the Stack Trace. */
        if (rep /* || (DebugOptions & DBO_RIP_STACK) */) {
	    DebugWrite(GetDebugString(DS_STACKTRACE), 0);
	    StackWalk(0);
	}

	while (TRUE)
	{
		/* Display "Abort, Break, Ignore" */
		DebugWrite(GetDebugString(DS_ABORTBREAKIGNORE), 0);

		/* Get and process the user's response. */
		c = DebugRead();

		DebugWrite(GetDebugString(DS_CRLF), 0);

		if (c >= 'a' && c <= 'z')
			c += 'A' - 'a';

		switch (c)
		{
		case 'A':
			DoAbort();

		case 'B':
			/*	      fInsideFatalExit = FALSE;  */
			/* EnterBreak(2); */
			return 1;

		case 0 :
		case 'I':
			/*	      fInsideFatalExit = FALSE;  */
			return 0;

                case 'X':
                case 'E':
			FatalAppExit(0, "Terminating Application");
			break;

		case ' ':
		case 13:
			rep = 1;
			goto ReRip;
		default:
			;
		}
	}

}

#endif // ifndef WOW

#endif // if KDEBUG

/*--------------------------------------------------------------------------*/
/*									    */
/*  htoa() -								    */
/*									    */
/*--------------------------------------------------------------------------*/

/* Converts 'w' into a hex string in 's'. */

LPSTR htoa(s, w)

LPSTR s;
WORD  w;

{
	int  i;
	char c;

	i = 4;
	s += i;
	while (i--)
	{
		c = (char)(w & (WORD)0x000F);
		w >>= 4;
		if (c > 9)
			c += 'A' - 10;
		else
			c += '0';
		*--s = c;
	}

	return(s+4);
}



/* skip leading 0's */
LPSTR htoa0(LPSTR s, WORD w)
{
	int  i;
	char c;
	int flag = 0;

	i = 4;
	while (i--)
	{
		c = (char)((w>>12) & (WORD)0x000F);
		w <<= 4;
		if (c > 9)
			c += 'A' - 10;
		else
			c += '0';
		if (c > '0' || flag || !i) {
			*s++ = c;
			flag = 1;
		}
	}

	return s;
}

LPSTR FAR far_htoa0( LPSTR s, WORD w)
{
    return htoa0( s, w);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\pdb.inc ===
;
; MSDOS 2.xx Process Data Block
;
;   Contains all DOS specific data.
;

FilPerProc      EQU     20

; Process Data located in the Program Segment Prefix, just before the
; code and data for the loaded program.
;
PDB             STRUC
PDB_Exit_Call   DW  ?
PDB_block_len   DW  ?
                DB  ?
PDB_CPM_Call    DB  5 DUP (?)
PDB_Exit        DD  ?
PDB_Ctrl_C      DD  ?
PDB_Fatal_Abort DD  ?
PDB_Parent_PID  DW  ?
PDB_JFN_Table   DB  FilPerProc DUP (?)
PDB_environ     DW  ?
PDB_User_stack  DD  ?
PDB_JFN_Length	DW  ?			; DOS 3.x only
PDB_JFN_Pointer DD  ?			; DOS 3.x only
PDB_Next_PDB	DD  ?			; DOS 3.x only
PDB_InterCon	DB  ?			; DOS 4.x only
PDB_Append	DB  ?			; DOS 4.x only
PDB_Novell_Used	DB  02h DUP (?)
PDB_Version	DW  ?			; DOS 5.x only
PDB_Chain	DW  ?			; Windows only
PDB_Partition	DW  ?			; Windows only
PDB_NextPDB	DW  ?			; Windows only
PDB_GlobalHeap	DD  ?			; Windows only
PDB_Entry_stack DD  ?			; Windows only
PDB_Call_system DB  5h DUP (?)
PDB_PAD2        DB  7h DUP (?)
PDB_5C_FCB      DB  10h DUP (?)
PDB_6C_FCB      DB  14h DUP (?)
PDB_DEF_DTA     DB  80h DUP (?)
PDB             ENDS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\selman.asm ===
include	kernel.inc
include gpfix.inc
ifdef WOW
include protect.inc
endif

sBegin	DATA
globalW	sels, <1>			; end of list is 1 to fool DOS386 DPMI
globalW selscount, <0>			; length of selman16 list 
IF KDEBUG
externW  ArenaSel
externW  SelTableLen
externD  SelTableStart
ENDIF
sEnd    DATA

sBegin  CODE
assumes CS,CODE
assumes DS,NOTHING
assumes ES,NOTHING
assumes FS,NOTHING
assumes GS,NOTHING

externFP AllocSelectorArray
externFP IFreeSelector
externW  gdtdsc
ifdef WOW
externNP DPMIProc
endif

	.386p


IF 0  ;KDEBUG - WOW doesn't have FastAndDirty... routines from win95 krn32.asm
extern	FastAndDirtyIsMovableHandle:far16
ENDIF

WOW_DPMIFUNC_0C equ 04f2h

;*********************************************************************
; MapSL - Maps a selector:offset pair to a linear address
;
; Arguments:	dAddrFar16 - selector:offset to map
;
; Returns:	eax   = linear address
;		dx:ax = linear address
;
; Register Usage: eax,ebx,edx
;
; *Must preserve es*. Some win32s thunking code depends on this.
;*********************************************************************
cProc   MapSL, <PUBLIC, FAR>
cBegin  nogen
        mov     bx,sp
	mov	bx, ss:[bx+4+2]		;Get selector
	test	bl, 4
	jz	MapSL_mightbegdt

IF 0  ;KDEBUG - WOW doesn't have FastAndDirty... routines from win95 krn32.asm
        push    bx
	push	es
	xor	cx,cx
	mov	es,cx

	push	bx
	call	FastAndDirtyIsMovableHandle
	or	ax,ax
	jz	MapSL_memok
	
	mov	bx,sp
	add	bx, 4
	mov	ax, ss:[bx+4+2]	;Get offending selector
	mov	dx, ss:[bx+2]	;Get return address seg
	mov	bx, ss:[bx]	;Get return address off
	krDebugOut	DEB_ERROR, "*** MapSL(16) called on unfixed selector #ax. Ret addr: #dx:#bx"

MapSL_memok:


	pop	cx
beg_fault_trap	MapSL_bad_es
MapSL_restore_es:
	mov	es,cx
end_fault_trap
	pop	bx
	jmp	MapSL_memchkdone


MapSL_bad_es:
	fault_fix_stack
	xor	cx,cx
	jmp	MapSL_restore_es

	
MapSL_memchkdone:

	
ENDIF  ;KDEBUG

        mov     gs, [gdtdsc]
        and     bl, not 7       ;Mask ring bits

	beg_fault_trap MapSL_fault_Trap
	test	byte ptr gs:[bx+5], 80h
	end_fault_trap
	jz	MapSL_invalid

	mov	ah, gs:[bx+7]		; get upper 8 bits base
	mov	al, gs:[bx+4]		; get next byte of base
	shl	eax, 16			; move to proper place
	mov	ax, gs:[bx+2]		; get lower 16 bits of base
	xor	edx, edx
	mov	bx, sp
	mov	dx, ss:[bx+4]		; get offset of current pointer
	add	eax, edx		; find complete 32 bit base


MapSL_exit2:
	xor	cx,cx		;Don't give apps access to the LDT
	mov	gs,cx
MapSL_exit:
	;; dx:ax <- eax
	shld	edx, eax, 16	;dx <- hiword of eax
        retf    4


;;--------------------------------------------------------------
;; Error case: Selector out of range.
;;--------------------------------------------------------------
MapSL_fault_trap:
	fault_fix_stack
IF KDEBUG
	mov	bx, sp
	mov	bx, ss:[bx+4+2]
	krDebugOut	DEB_ERROR, "MapSL(#bx): out of range selector"
ENDIF
	xor	eax,eax
	jmp	MapSL_exit2


;;--------------------------------------------------------------
;; Error case: Selector not present
;;--------------------------------------------------------------
MapSL_invalid:
IF KDEBUG
	mov	bx, sp
	mov	bx, ss:[bx+4+2]
	krDebugOut	DEB_ERROR, "MapSL(#bx): selector not present."
ENDIF
	xor	eax,eax
	jmp	MapSL_exit2


;;--------------------------------------------------------------
;; Potential error case: GDT selector or NULL?
;;--------------------------------------------------------------
MapSL_mightbegdt:
	or	bx,bx
	jnz	MapSL_gdt
;; Special case: Return original argument.
	mov	bx,sp
	mov	eax, ss:[bx+4]
	shld	edx, eax, 16	;dx <- hiword of eax
	retf	4


;;--------------------------------------------------------------
;; Error case: GDT selector
;;--------------------------------------------------------------
MapSL_gdt:
IF KDEBUG
	krDebugOut DEB_ERROR, "***MapSL(16) called on GDT selector #bx"
ENDIF
	xor	eax,eax
	jmp	MapSL_exit

cEnd    nogen






;****************************************************************
; MapLS - Allocate a new 64k limit selector that maps to linear address.
;
; Returns: Selector:offset in eax & dx:ax (offset is always zero).
; *Must preserve es because some win32s thunking code depends on it.*
;****************************************************************
cProc   MapLS, <PUBLIC, FAR>
cBegin  nogen
        mov     bx, sp
	mov	dx, ss:[bx+4+2]
	or	dx,dx
	jz	MapLS_special

        mov     gs, [gdtdsc]
	SetKernelDS fs
	mov	eax, ss:[bx+2]		;put lo-word in hi-half of eax
	mov	bx, fs:[sels]
	cmp	bx, 1
	jz	MapLS_moresel		;cache is empty: go to slow case
	
	mov	cx, gs:[bx]		;remove from linked list
	mov	fs:[sels], cx
	dec	fs:[selscount]

MapLS_gotit:
	and	bl, not 7
	or	ax, -1			;Set limit to 64k
	mov	gs:[bx], eax		;Init low half of descriptor

	xchg	dh, dl
	shl	edx, 16			;Put high 16 bits of base up hi
	mov	dl, 1+2+16+32+64+128	;accessed, write, app, ring3, present
	rol	edx, 8
	mov	gs:[bx+4], edx		;init upper half of descriptor
        mov     cx, 1
        DPMICALL  WOW_DPMIFUNC_0C ; Write shadow LDT entry thru to system LDT.
        mov     dx, bx
	or	dl, 7
	mov	ax, dx
        shl     eax, 16                 ;EAX = DX:AX = NEWSEL:0 = alias
MapLS_exit2:
	xor	cx,cx
	mov	gs,cx			;Don't give apps access to LDT
MapLS_exit:
	retf	4
	UnsetKernelDS fs

MapLS_special:
	mov	eax, ss:[bx+4]
	;; dx already has correct value
	retf	4

	UnsetKernelDS fs

;------------------------------------------------------------------------
; K16 selman cache is empty. Time to get more from krnl386.
;------------------------------------------------------------------------
MapLS_moresel:				; we need some more selectors here
	push	es
;Don't use more than one here. get_sel always takes
; multi-selector requests from DPMI, and these
; usually won't be given back because we'll free
; them one by one.
	cCall	AllocSelectorArray, <1>
	or	ax,ax
	jnz	MapLS_moreselendloop

;Uh oh.
	krDebugOut	DEB_ERROR, "MapLS(16): Couldn't get any more selectors!"
	xor	ax,ax
; Fall thru.

MapLS_moreselendloop:
 	krDebugOut	DEB_TRACE, "Selman(16) allocated selector #AX from KRNL386."
	pop	cx
beg_fault_trap MapLS_bades
MapLS_restore_es:
	mov	es,cx
end_fault_trap
	cwd				; put possible failure code in DX
	cwde				; and in EAX
	or	ax, ax
	jz	MapLS_exit2

	mov	gs, [gdtdsc]
	SetKernelDS fs

	xchg	bx,ax
	and	bl, not 7 

	push	bx
	mov	bx,sp
	add	bx, 2
	mov	dx, ss:[bx+4+2]
	mov	eax, ss:[bx+2]
	pop	bx
	jmp	MapLS_gotit

MapLS_bades:
	fault_fix_stack
	xor	cx,cx
	jmp	MapLS_restore_es


	UnsetKernelDS fs
cEnd    nogen

;***********************************************************************
; UnMapLS
;***********************************************************************

cProc   UnMapLS, <PUBLIC, FAR>
cBegin  nogen

if KDEBUG	
	mov	bx, sp
	push	ds
	mov	bx, ss:[bx+4+2]
	or	bx,bx
	jz	UnMapLS_ok
	test	bl, 4
	jz	UnMapLS_gdt
	or	bl, 7
	SetKernelDS
	mov	ax, [gdtdsc]
	lsl	dx,ax
	cmp	bx,dx
	ja	UnMapLS_pastldt
	mov	ds,ax
	UnsetKernelDS
	test	byte ptr ds:[bx-2], 080h
	jz	UnMapLS_notpresent
	SetKernelDS
	and	bl, not 7
	shr	bx, 1
	cmp	bx, [SelTableLen]
	jae	UnMapLS_notgh
	movzx	ebx,bx
	add	ebx, [SelTableStart]
	mov	ds, [ArenaSel]
	UnsetKernelDS
	mov	eax, ds:[ebx]
	or	eax,eax
	jnz	UnMapLS_gh
UnMapLS_notgh:
	;Fallthru
UnMapLS_ok:
	pop	ds
endif
	mov	bx, sp
	mov	bx, ss:[bx+4+2]
	and	bl, not 7			; point to LDT entry
	jz	UnMapLS_null
		

	xor	eax,eax
	mov	es,eax		;In case es contains selector we're trashing
				; fs and gs are loaded below.

if KDEBUG
	mov	ax, ss
	and	al, not 7
	cmp	ax, bx
	je	UnMapLS_inuse
	xor	ax, ax
endif

	SetKernelDS fs
	mov	gs, [gdtdsc]
if KDEBUG
        test    WORD PTR gs:[bx+5], 80h
	jz	UnMapLS_invalid
endif
	mov	ax, fs:[sels]
	mov	gs:[bx], eax			; linked list of avail sels
	xor	eax,eax
	mov	gs:[bx+4], eax			; zero out entry
	mov	fs:[sels], bx			; new list head sel
	inc	fs:[selscount]

UnMapLS_checkcount:
if KDEBUG
	cmp	fs:[selscount], 4
else
	cmp	fs:[selscount], 42
endif
	jb	UnMapLS_Null

	dec	fs:[selscount]
	mov	bx, fs:[sels]
	mov	ax, gs:[bx]	
	mov	fs:[sels],ax

; Make it look like a valid limit-1 selector so FreeSelector doesn't
; free the ones after it.
	mov	dword ptr gs:[bx], 1
	mov	dword ptr gs:[bx+4], 0000f300h
	or	bx, 7
	push	ds
	push	es
	push	fs
	push	gs
	push	bx
	xor	cx,cx	;Just in case of one these registers contained
	mov	ds,cx	;the segment being freed.
	mov	es,cx
        cCall   IFreeSelector,<bx>
	pop	bx
	pop	gs
	pop	fs
	pop	cx
beg_fault_trap	UnMapLS_bades
UnMapLS_restore_es:
	mov	es,cx
end_fault_trap
	pop	cx
beg_fault_trap	UnMapLS_badds
UnMapLS_restore_ds:
	mov	ds,cx
end_fault_trap
	krDebugOut DEB_TRACE, "Selman(16) returning selector #BX to KRNL386"

	jmp	UnMapLS_checkcount

UnMapLS_null:
	xor	eax, eax			; EAX = DX:AX = 0 (OK)
	cwd
	mov	gs,ax				; Cut off access to LDT
UnMapLS_exit:
	retf	4

UnMapLS_bades:
	fault_fix_stack
	xor	cx,cx
	jmp	UnMapLS_restore_es

UnMapLS_badds:
	fault_fix_stack
	xor	cx,cx
	jmp	UnMapLS_restore_ds

if KDEBUG
UnMapLS_invalid:
	krDebugOut	DEB_ERROR, "UnMapLS(#bx) invalid selector"
	or	al, 1				; AX != 0
	jmps	UnMapLS_exit

UnMapLS_inuse:
	krDebugOut	DEB_ERROR, "UnMapLS(#bx) attempting to free ss"
	or 	al, 1                           ; AX != 0
	jmps	UnMapLS_exit
UnMapLS_gdt:
	mov	bx,sp
	add	bx,2
	mov	bx, ss:[bx+4+2]
	krDebugOut	DEB_ERROR, "UnMapLS(#bx) GDT selector. Type 'k'"
	jmp	UnMapLS_ok  ;in trouble if ignores this.

UnMapLS_pastldt:
	mov	bx,sp
	add	bx,2
	mov	bx, ss:[bx+4+2]
	krDebugOut	DEB_ERROR, "UnMapLS(#bx) Selector out of range. Type 'k'"
	jmp	UnMapLS_ok  ;in trouble if ignores this.

UnMapLS_notpresent:
	mov	bx,sp
	add	bx,2
	mov	bx, ss:[bx+4+2]
	krDebugOut	DEB_ERROR, "UnMapLS(#bx) Selector not present. Probably part of a freelist! Type 'k' and '.wl'"
	jmp	UnMapLS_ok  ;in trouble if ignores this.

UnMapLS_gh:
	mov	bx,sp
	add	bx,2
	mov	bx, ss:[bx+4+2]
	krDebugOut	DEB_ERROR, "UnMapLS(#bx) Selector is a global handle! Type 'k' and '.dg'"
	jmp	UnMapLS_ok  ;in trouble if ignores this.


endif

	

cEnd    nogen


sEnd	CODE
	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\schedule.asm ===
title	SCHEDULE - task scheduler

.xlist
include kernel.inc
include tdb.inc
include newexe.inc
.list

.386

externFP WriteOutProfiles
externFP GlobalCompact
externFP GetFreeSpace

;if KDEBUG
;externFP OutputDebugString
;endif
      	 
DataBegin

externB Kernel_InDOS
externB Kernel_flags
externB InScheduler
externB fProfileDirty
externB fProfileMaybeStale
externB fPokeAtSegments
externW WinFlags
;externW EMSCurPID
;externW cur_drive_owner
externW curTDB
externW Win_PDB
externW LockTDB
externW headTDB
externW hShell
externW	pGlobalHeap
externW hExeHead
externW f8087
externW 
externW PagingFlags
externD pDisplayCritSec
externD pIsUserIdle

if KDEBUG
externB fPreloadSeg
endif

staticW	PokeCount,0

DataEnd

sBegin	CODE
assumes cs,CODE
assumes ds,NOTHING
assumes es,NOTHING

externNP LoadSegment
externNP DeleteTask
externNP InsertTask
externNP DiscardFreeBlocks
externNP ShrinkHeap

if SDEBUG
externNP DebugSwitchOut
externNP DebugSwitchIn
endif

;-----------------------------------------------------------------------;
; Reschedule								;
;									;
; This routine does the task switching.					;
;									;
; Arguments:								;
;	none								;
; Returns:								;
;	nothing								;
; Error Returns:							;
;	nothnig								;
; Registers Preserved:							;
;	AX,BX,CX,DX,DI,SI,BP,DS,ES					;
; Registers Destroyed:							;
;	none								;
; Calls:								;
;	DeleteTask							;
;	InsertTask							;
;	SaveState							;
;									;
; History:								;
;									;
;  Mon 07-Aug-1989 21:53:42  -by-  David N. Weise  [davidw]		;
; Removed the WinOldApp support and DEC rainbow support.		;
;									;
;  Fri 07-Apr-1989 22:16:02  -by-  David N. Weise  [davidw]		;
; Added support for task ExeHeaders above The Line in Large		;
; Frame EMS.								;
;									;
;  Sat Aug 15, 1987 11:41:35p  -by-  David N. Weise	 [davidw]	;
; Commented out the cli and sti around the swapping of states.		;
; Sweet Lord, what will this break?					;
; 									;
;  Fri Feb 06, 1987 00:09:20a  -by-  David N. Weise   [davidw]		;
; Put in support for DirectedYield.					;
; 									;
;  Tue Feb 03, 1987 08:21:53p  -by-  David N. Weise   [davidw] 		;
; Got rid of going inside of DOS for InDOS and ErrorMode.  Task		;
; switching should be much better under Windows386 now.			;
; 									;
;  Mon Sep 29, 1986 05:27:29p  -by-  Charles Whitmer  [chuckwh]		;
; Made it recognize threads.  It now does a fast context switch if	;
; just switching between two threads in the same process.		;
;									;
;  Mon Sep 29, 1986 05:24:16p  -by-  Charles Whitmer  [chuckwh]		;
; Documented it.							;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

cProc	Reschedule,<PUBLIC,FAR>
cBegin	nogen

; get all the registers up on the stack

	inc	bp
	push	bp
	mov	bp,sp
	push	ds
	push	si
	push	di
	push	ax
	push	cx
	push	es
	push	bx
	push	dx

	public	BootSchedule
BootSchedule:
	call	TaskSwitchProfileUpdate ;Update profile information

	public	ExitSchedule
ExitSchedule:

; see if we're supposed to do a directed yield
		    
	SetKernelDS	es
	mov	cx,curTDB
	jcxz	search_the_queue	; this happens first after boot time!
	mov	ds,cx
	cmp	ds:[TDB_sig],TDB_SIGNATURE
	jnz	short search_the_queue	; task may have suicided
	xor	cx,cx
	xchg	ds:[TDB_Yield_to],cx
	jcxz	search_the_queue	; nope
	mov	ds,cx
	cmp	ds:[TDB_nevents],0	; anything for this guy?
	jnz	found_one
		
; run down the task queue looking for someone with events

search_the_queue:
	CheckKernelDS	es
	mov	ax,HeadTDB
keep_searching:
	or	ax,ax			; Anyone to schedule?
	jnz	short try_this_one		; Yes, go do it

; if no one is dispatchable, do an idle interrupt

	xor	PagingFlags, 4
	test	PagingFlags, 4
	jnz	short NoDiscarding	; Every other time through!

	test	PagingFlags, 8		; An app has exited?
	jz	short NoShrink
	push	es
	call	ShrinkHeap
	pop	es
NoShrink:
	
;;;	or	PagingFlags, 2		; Causes early exit from GlobalCompact
;;;	mov	ax, -1
;;;	push	es
;;;	cCall	GlobalCompact,<ax,ax>
;;;	pop	es
;;;	and	PagingFlags, not 2

	test	byte ptr WinFlags[1], WF1_PAGING
	jz	short NoDiscarding
	test	PagingFlags, 1
	jz	short NoDiscarding
	call	DiscardFreeBlocks
	jmps	search_the_queue
NoDiscarding:

	mov	ax, 1			; Assume User is idle
	cmp	word ptr pIsUserIdle[2], 0
	je	short go_idle
	call	pIsUserIdle
	SetKernelDS	es
go_idle:

	cmp	fPokeAtSegments, 0	; Disabled?
	je	short @F	 	;  yep, skip
	or	ax, ax			; Only if USER is idle
	jz	short @F
	inc	PokeCount
	test	PokeCount, 1Fh		; Only every 32 times through
	jnz	short @F
	call	PokeAtSegments
	jc	search_the_queue
@@:
	push	ax			; Ralph's paranoia
	int	28h			; No, generate DOS idle int
	pop	ax
	xor	bx, bx
	or	ax, ax
	jnz	short tell_ralph
	or	bl, 1
tell_ralph:
	mov	ax,1689h		; Do an idle to Win386.
	int	2fh
	jmp	search_the_queue

get_out_fast:
	jmp	reschedule_done

; see if the given task has events

try_this_one:
	mov	ds,ax
	mov	ax,ds:[TDB_next]
	cmp	ds:[TDB_nevents],0	; anything for this guy?
	jz	keep_searching
		
; is this the guy we're already running?

found_one:
	mov	di,ds			; DI = handle of new task
	cmp	di,curTDB
	jz	short get_out_fast

; is there a locked task?

	mov	cx,LockTDB		; are any tasks super priority?
	jcxz	no_locked_task
	cmp	cx,di			; are we it?
	jnz	short get_out_fast		; No => don't switch
no_locked_task:

; don't switch if in DOS or int 24 handler

	cmp	Kernel_InDOS,0		; if inside INT2[0,4] handler
	jnz	keep_searching		; ...don't reschedule
		
	inc	InScheduler		; set flag for INT 24...

	inc	ds:[TDB_priority]	; lower task priority
	push	es
	UnSetKernelDS	es
	cCall	DeleteTask,<ds>		; remove him from queue
	cCall	InsertTask,<ds>		; put him back further down
	dec	ds:[TDB_priority]	; restore former priority
	pop	es
	ReSetKernelDS	es

; Around saving state and restoring state go critical on memory
;  heap access because of EMS.

	push	es
	mov	es,pGlobalHeap
	UnSetKernelDS	es
	inc	es:[gi_lrulock]
	pop	es
	ReSetKernelDS	es

; Signature is trashed when we suicide so we dont save state
;   for the non-existant task.

	mov	di,ds			; DI = destination task
	xor	si,si			; SI is an argument to RestoreState
	mov	es,curTDB		; ES = current TDB
	UnSetKernelDS	es
	mov	ax,es
	or	ax,ax
	jz	short dont_save_stack
	cmp	es:[TDB_sig],TDB_SIGNATURE
	jnz	short dont_save_stack
	mov	si,es			; SI = current task

; save the present stack

	mov	es:[TDB_taskSS],ss
	mov	es:[TDB_taskSP],sp
dont_save_stack:

; get onto a temporary stack while we switch the EEMS memory

	mov	ax,es
	or	ax,ax
	jz	short dont_save_state
	cmp	es:[TDB_sig],TDB_SIGNATURE
	jnz	short dont_save_state

	cCall	SaveState,<si>
	push	ds
	mov	ds,ax
if SDEBUG
	call	DebugSwitchOut
endif
	pop	ds
dont_save_state:
	SetKernelDS	es
	mov	curTDB,di

	mov	ax, ds:[TDB_PDB]	; Set our idea of the PDB
	mov	Win_PDB, ax
     ;;;mov	ax,ds:[TDB_EMSPID]
     ;;;mov	EMSCurPID,ax
	cmp	f8087, 0
	je	short no_fldcw
	.8087
	fnclex
	fldcw	ds:[TDB_FCW]
no_fldcw:

	or	Kernel_flags,kf_restore_CtrlC OR kf_restore_disk
if SDEBUG
	call	DebugSwitchIn
endif

fast_switch:
	mov	cx,ds:[TDB_taskSS]	; Switch to new task stack.
	mov	ax,ds:[TDB_taskSP]
	mov	ss,cx
	mov	sp,ax
	mov	curTDB,di
	dec	InScheduler		; reset flag for INT 24

	mov	al,Kernel_Flags[2]
	and	Kernel_Flags[2],NOT KF2_WIN386CRAZINESS

; Tell the display driver to speak its mind. added 20 feb 1990

	test	al,KF2_WIN386CRAZINESS
	jz	short @F
	xor	ax,ax
        push    es                      ; preserve es
	cCall	pDisplayCritSec,<ax>
        pop     es
@@:

; Around saving state and restoring state go critical on memory
;  arena access because of EMS.

	mov	es,pGlobalHeap
	UnSetKernelDS	es
	dec	es:[gi_lrulock]

; pop the task's registers off the stack

reschedule_done:
	pop	dx
	pop	bx
	pop	es
	pop	cx
	pop	ax
	pop	di
	pop	si
	pop	ds
	pop	bp
	dec	bp
	public	dispatch
dispatch:
	ret

cEnd nogen

;-----------------------------------------------------------------------;
; LockCurrentTask							;
; 									;
; Hack procedure to make the current task god if the passed boolean	;
; is true.								;
; If false, then demotes the current god to a mere mortal. Self		;
; inflicted by definition.						;
; 									;
; DavidDS: Note, the USER function, LockMyTask should be called for	;
; Windows apps instead of this if you expect the input queue to work    ;
; properly.                                                             ;
;                                                                       ;
; Arguments:								;
;	ParmW	lock							; 									;
; Returns:								;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
;	CX,DX,DI,SI,DS,ES						;
; 									;
; Registers Destroyed:							;
;	AX,BX								;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Sun Jan 04, 1987 04:37:11p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

cProc	LockCurrentTask,<PUBLIC,FAR>
;	ParmW	lock
cBegin	nogen				; Crock to save space
	mov	bx,sp
	mov	ax,ss:[bx][4]		; get the argument
	push	ds
	SetKernelDS
	or	ax,ax
	jz	short lct1
	mov	ax,curTDB
lct1:
	mov	LockTDB,ax
	pop	ds
	UnSetKernelDS
	ret	2
cEnd	nogen


;-----------------------------------------------------------------------;
; IsTaskLocked								;
; 									;
; Another hack procedure to determine if the current task is locked.	;
; A non-NULL value is returned if the task is locked and NULL is	;
; returned is the task is not locked.					;
; 									;
; Arguments:								;
;									;									;
; Returns:								;
;	The value of LockTDB						;
; Error Returns:							;
; 									;
; Registers Preserved:							;
;	All but AX							;
; 									;
; Registers Destroyed:							;
;	AX								;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;   (Tue 20-Oct-1987 : bobgu)	    Created this thing. 		;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

cProc	IsTaskLocked,<PUBLIC,FAR>
cBegin	nogen
	push	ds
	SetKernelDS
	mov	ax,LockTDB
	pop	ds
	UnSetKernelDS
	ret
cEnd	nogen


;-----------------------------------------------------------------------;
; SaveState                                                             ;
; 									;
; Saves the state of the current MS-DOS process.  This means the per	;
; task interrupt vectors, the drive and directory, EEMS land if any,	;
; and old app stuff if any.						;
; 									;
; Arguments:								;
;	parmW	destination						;
; 									;
; Returns:								;
; 	DS returned in AX.						;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Mon 07-Aug-1989 21:53:42  -by-  David N. Weise  [davidw]		;
; Removed the WinOldApp support.					;
;									;
;  Tue Feb 03, 1987 08:21:53p  -by-  David N. Weise   [davidw] 		;
; Got rid of the rest of the DOS version dependencies.			;
; 									;
;  Thu Jan 22, 1987 03:15:15a  -by-  David N. Weise   [davidw]		;
; Took out the saving of the ^C state, DTA address, and ErrorMode.	;
; 									;
;  Sun Jan 04, 1987 04:40:44p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

cProc	SaveState,<PUBLIC,NEAR>,<si,di,ds>
	parmW	destination
cBegin
	cld
	SetKernelDS
	mov	ax,f8087
	UnSetKernelDS
	mov	ds,destination
	or	ax,ax
	jz	short no_fstcw
	.8087
	fstcw	ds:[TDB_FCW]
no_fstcw:
	test	ds:[TDB_Drive],10000000b; if hi bit set....
	jnz	short ss_ret			; ...no need to get dir
	mov	ah,19h
	int	21h
	mov	dl,al
	inc	dl
	or	al,10000000b
	mov	ds:[TDB_Drive],al	; save it (A=0, B=1, etc.)
	mov	si,TDB_Directory
	mov	byte ptr [si],'\'	; set "\"
	inc	si
	mov	ah,47h			; get current directory...
	int	21h
	jnc	short ss_ret
	mov	byte ptr [si-1],0	; indicate error with null byte
ss_ret:	mov	ax,ds
cEnd


cProc	TaskSwitchProfileUpdate,<PUBLIC,NEAR>
cBegin
	SetKernelDS es

        ;** See if we need to write out the profile string cache.  We
        ;**     do this at task switch time.
      	cmp	es:fProfileDirty, 0
      	je	short PU_NoFlushProfiles
        push    es
	call	WriteOutProfiles
        pop     es
PU_NoFlushProfiles:

        ;** Set the flag saying that the profile cache MAY be invalid.
        ;**     If a task switch occurs, on the next Get/SetProfileXXX() we
        ;**     will have to see if the file has been modified by this
        ;**     (or any other) task
        mov     es:fProfileMaybeStale,1
cEnd

assumes	ds, nothing
assumes	es, nothing
	
.386

cProc	PokeAtSegments,<PUBLIC,NEAR>
cBegin
	push	ds
	push	es
	pusha

	cCall	GetFreeSpace,<2>		; Ignore discardable
	or	dx, dx				; Insist on > 64k free
if KDEBUG
	jz	never_again
else
	jz	short never_again
endif

	SetKernelDS

	test	WinFlags[1], WF1_PAGING
	jz	short have_room

	sub	sp, 30h				; Room for info
	smov	es, ss
	mov	di, sp
	mov	ax, 0500h			; Get Paging Info
	int	31h
	mov	eax, es:[di][14h]		; Free pages
	add	sp, 30h
	cmp	eax, 16				; Insist on 64k
	jb	short never_again

have_room:
	smov	es, ds
	ResetKernelDS	es

	mov	ds, hExehead
	UnsetKernelDS

next_exe:
	mov	cx, ds:[ne_cseg]		; Module has segments?
	jcxz	no_segs				;  no, on to next module
	mov	di, 1				; Segment number
	mov	si, ds:[ne_segtab]		; Pointer to segment table

next_seg:
	test	ds:[si].ns_flags, NSLOADED	; This segment in memory?
	jnz	short seg_here			;  yes, look at next one
	test    ds:[si].ns_flags, NSDISCARD     ; Only load if discardable
	jz	short seg_here			; Skip this one
if KDEBUG
	push	ds
	SetKernelDS
	mov	fPreloadSeg, 1
	pop	ds
	UnsetKernelDS
endif
	cCall	LoadSegment,<ds,di,-1,-1>
if KDEBUG
	push	ds
	SetKernelDS
	mov	fPreloadSeg, 0
	pop	ds
	UnsetKernelDS
endif
	stc					; We loaded something!
	jmps	all_done

seg_here:
	lea	si, [si + size NEW_SEG1]	; On to next segment
	inc	di
	loop	next_seg			; looked at all in this module?

no_segs:
	mov	cx, ds:[ne_pnextexe]		; On to next module
	jcxz	all_done			; End of list?
	mov	ax, ds
	mov	ds, cx
	cmp	ax, hShell			; Only boot time modules
	jne	short next_exe
	UnSetKernelDS es
never_again:
	SetKernelDS
	mov	fPokeAtSegments, 0		; That's all folks
	clc
all_done:
	popa
	pop	es
	pop	ds
cEnd

sEnd	CODE
end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\stack.asm ===
TITLE	STACK - Kernel stack switching code


include kernel.inc
ifdef WOW
include vint.inc
endif


;------------------------------------------------------------------------
;	T M P S T A C K    S E G M E N T   V A R I A B L E S
;------------------------------------------------------------------------

sBegin	DATA
assumes CS,CODE
assumes DS,NOTHING
assumes ES,NOTHING
assumes SS,NOTHING

	EVEN

if KDEBUG
externW gmove_stack_sig
endif			

externW	gmove_stack

externW	prev_gmove_SP
externW	prev_gmove_SS
externW	ss_sel

sEnd	DATA


;------------------------------------------------------------------------

sBegin	CODE
assumes CS,CODE
assumes SS,NOTHING

	assumes ds,nothing
	assumes es,nothing

cProc	Enter_gmove_stack,<PUBLIC,NEAR>
cBegin	nogen
	mov	ax,ds
	SetKernelDS
	cmp	prev_gmove_SS,0
	jne	gs_fail
    FCLI
	pop	gmove_stack
	mov	prev_gmove_SS,cx
	mov	prev_gmove_SP,sp
if KDEBUG
	mov	gmove_stack_sig,STACK_SIGNATURE
endif
	smov	ss,ds
	mov	sp,dataOffset gmove_stack
    FSTI
	mov	ds,ax
	ret
cEnd	nogen

gs_fail:
	kerror	ERR_GMEM,<gmove_stack usage error>,prev_gmove_SS,prev_gmove_SP
	jmp	gs_fail

	assumes ds,nothing
	assumes es,nothing

cProc	Leave_gmove_stack,<PUBLIC,NEAR>
cBegin	nogen
	mov	ax,ds
	SetKernelDS
	cmp	prev_gmove_SS,0
	je	gs_fail
if KDEBUG
	push	ax
	push	cx
	push	es
	push	di
	lea	di, gmove_stack_sig
	smov	es, ss
	mov	ax, STACK_SIGNATURE
	mov	cx, 16
	cld
	repe	scasw
	pop	di
	pop	es
	pop	cx
	pop	ax
	jne	gs_fail
	cmp	sp,dataOffset gmove_stack
	jne	gs_fail
endif

    FCLI
	mov	ss,prev_gmove_SS
	mov	sp,prev_gmove_SP
	push	gmove_stack
	mov	prev_gmove_SS,0
    FSTI
	mov	ds,ax
	ret
cEnd	nogen

sEND	CODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\userpro.asm ===
TITLE   USERPRO - interface to WIN.INI file

include kernel.inc
include pdb.inc

externFP GlobalFree
externFP GlobalAlloc
externFP GlobalLock
externFP GlobalUnlock
externFP GlobalReAlloc
externFP GlobalSize
externFP OpenFile
externFP FarMyLower
;externFP _lopen
externFP _lcreat
externFP _lclose
externFP _lread
externFP _lwrite
externFP _llseek

ifdef FE_SB                             ;Apr.26,1990 by AkiraK
externFP AnsiPrev
externFP FarMyIsDBCSLeadByte
endif

ifdef WOW
externFP FarMyUpper
externFP GetPrivateProfileSectionNames
endif

externFP TermsrvGetWindowsDir


DataBegin

externB szUserPro
externB fBooting
externW cBytesWinDir
externD lpWindowsDir
ifndef WOW
externW cBytesSysDir
externD lpSystemDir
else
externW cBytesSys16Dir
externD lpSystem16Dir
endif
if 0
externB fUserPro
externB UserProBuf
externB PrivateProBuf
externW hBuffer
ifndef PHILISAWEENIE
externW hWBuffer
externW hPBuffer
endif
externW hFile
externD BufAddr
externD lpszUserPro
endif
externW TopPDB
;externW MyCSDS

LeftSect    DB '['
; these next two must stay together
RightSect   DB ']'
CarRetLF    DB 13,10
EquStr      DB '='

externB achTermsrvWindowsDir

DataEnd

sBegin  MISCCODE
assumes CS,MISCCODE
assumes DS,NOTHING
assumes ES,NOTHING

externNP MISCMapDStoDATA

; WOW thunks most of these APIs.
ifndef WOW

SECT_LEFT       equ     byte ptr '['
SECT_RIGHT      equ     byte ptr ']'
CARRETURN       equ     byte ptr 13
LINEFEED        equ     byte ptr 10
SPACE           equ     byte ptr ' '
TAB             equ     byte ptr 09
CRLF            equ     0A0Dh
NEWRESULT       equ     1
NOSECTION       equ     2
NOKEY           equ     4
REMOVESECTION   equ     5
REMOVEKEY       equ     6

PROUNKN         EQU     0               ; Profile unknown
PROWININI       EQU     1               ; Profile WIN.INI
PROPRIVATE      EQU     2               ; Profile specified by app
PROWASPRIVATE   EQU     3               ; Buffer contains private profile data

ScanTo  MACRO   StopAt
        mov     al, StopAt
        mov     cx, -1
        repne   scasb
ENDM

ScanBack MACRO  StopAt
        std
        mov     al, StopAt
        mov     cx, di
        inc     cx
        repne   scasb
        inc     di                      ; Leave pointing to StopAt
        cld
ENDM


;-----------------------------------------------------------------------;
; SetDefaultPro                                                         ;
;                                                                       ;
; Set lpszUserPro to point to WIN.INI if it is not already set          ;
; to point to a private file                                            ;
;                                                                       ;
; Arguments:                                                            ;
;                                                                       ;
; Returns:                                                              ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;                                                                       ;
; Calls:                                                                ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;-----------------------------------------------------------------------;

        assumes ds,code
        assumes es,nothing

cProc   SetDefaultPro,<PUBLIC,NEAR>
cBegin nogen
        cmp     fUserPro, PROWASPRIVATE
        je      SDF_SetIt
        cmp     fUserPro, PROUNKN               ; No file specified
        jne     SDF_Done
SDF_SetIt:
        mov     ax, dataOffset szUserPro
        mov     word ptr [lpszUserPro], ax
        mov     word ptr [lpszUserPro+2], ds
        mov     fUserPro, PROWININI
ifndef PHILISAWEENIE
        mov     si,[hWBuffer]
        mov     [hBuffer],si
else
        mov     si,[hBuffer]
        call    FreeBuffer              ; free up any buffer we may have
endif
SDF_Done:
        ret
cEnd nogen


;-----------------------------------------------------------------------;
; SetPrivatePro                                                         ;
;                                                                       ;
; Sets lpszUserPro to point to a private file                           ;
;                                                                       ;
; Arguments:                                                            ;
;       parmD   lpFile                                                  ;
;                                                                       ;
; Returns:                                                              ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;                                                                       ;
; Calls:                                                                ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;-----------------------------------------------------------------------;

        assumes ds,code
        assumes es,nothing

cProc   SetPrivatePro,<PUBLIC,NEAR>,<di>
        parmD   lpszProfile
        localV  NewFileBuf, 80h
cBegin
ifndef PHILISAWEENIE
        mov     si, [hPBuffer]
        mov     [hBuffer], si
else
        cmp     fUserPro, PROWASPRIVATE
        jne     SPP_SetIt
endif
        les     di,lpszProfile
        test    fBooting,1
        jnz     spr_booting
        smov    es, ss
        lea     di, NewFileBuf
        mov     byte ptr es:[di.opFile], 0      ; Zap junk on stack
        mov     ax,OF_EXIST                     ; OF_EXIST searches path!
        cCall   OpenFile,<lpszProfile,es,di,ax>
        lea     di, [di.opFile]
spr_booting:
        lea     si, [PrivateProBuf]
        xor     cx, cx
        mov     cl, [si.opLen]
        lea     si, [si.opFile]
        sub     cx, 8
        cld
ifndef PHILISAWEENIE
        test    fBooting, 1
        jz      @F
        xor     bl, bl                  ; Terminate on null
        call    strcmpi
        je      SPP_KeepBuffer
        jmps    SPP_SetIt
@@:
endif
        rep     cmpsb
        je      SPP_KeepBuffer
SPP_SetIt:
        mov     si,[hBuffer]
        call    FreeBuffer              ; free up any buffer we may have
SPP_KeepBuffer:
        mov     fUserPro, PROPRIVATE
        mov     ax, lpszProfile.off
        mov     [lpszUserPro].off, ax
        mov     ax, lpszProfile.sel
        mov     [lpszUserPro].sel, ax
cEnd

;-----------------------------------------------------------------------;
; ResetPrivatePro                                                       ;
;                                                                       ;
; Sets lpszUserPro to point to nothing                                  ;
;                                                                       ;
; Arguments:                                                            ;
;                                                                       ;
; Returns:                                                              ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;                                                                       ;
; Calls:                                                                ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;-----------------------------------------------------------------------;

        assumes ds,code
        assumes es,nothing

cProc   ResetPrivatePro,<PUBLIC,NEAR>
cBegin nogen
        mov     fUserPro, PROWASPRIVATE
        ret
cEnd nogen


;-----------------------------------------------------------------------;
; GetProfileInt                                                         ;
;                                                                       ;
; Gets the integer value for the keyword field.                         ;
;                                                                       ;
; Arguments:                                                            ;
;       parmD   lpApplicationName                                       ;
;       parmD   lpKeyName                                               ;
;       parmW   nDefault                                                ;
;                                                                       ;
; Returns:                                                              ;
;       AX = nKeyValue                                                  ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       DI,SI,DS                                                        ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;       BX,CX,DX,ES                                                     ;
;                                                                       ;
; Calls:                                                                ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Sat Oct 10, 1987 04:32:04p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.                                       ;
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc GetProfileInt,<PUBLIC,FAR>,<si,di>
        parmD   section
        parmD   keyword
        parmW   defint
cBegin
        cCall   MISCMapDStoDATA         ; point at data segment
        ReSetKernelDS

        cCall   SetDefaultPro

        cCall   GetString, <section,keyword>

; DX:AX contains pointer to return string
; CX is the length of the string, -1 if none

        mov     si,ax                   ; save pointer offset
        mov     ax,defint               ; if so, return default integer
        cmp     cx,-1                   ; was there no string?
        jz      intdone                 ; if none, use default
        push    ds                      ; save DS
        mov     ds,dx                   ; DS:SI has string

; AtoI function, CX has count of characters, AX is result, DS:SI is string.

        xor     ax,ax
AtoI:   mov     dx,10
        mov     bl,[si]
        sub     bl,'0'
        jc      AtoIDone
        cmp     bl,10
        jnc     AtoIDone
        inc     si
        mul     dx
        xor     bh,bh
        add     ax,bx
        loop    AtoI
AtoIdone:
        pop     ds                      ; restore DS
intdone:
        push    ax
        call    UnlockBuffer
        pop     ax                      ; get result to return
cEnd


;-----------------------------------------------------------------------;
; GetProfileString                                                      ;
;                                                                       ;
; Returns the string for the keyword field.                             ;
;                                                                       ;
; Arguments:                                                            ;
;       parmD   lpApplicationName                                       ;
;       parmD   lpKeyName                                               ;
;       parmD   lpDefault                                               ;
;       parmD   lpReturnedString                                        ;
;       parmW   nSize                                                   ;
;                                                                       ;
; Returns:                                                              ;
;       AX = nLength                                                    ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       DI,SI,DS                                                        ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;       BX,CX,DX,ES                                                     ;
;                                                                       ;
; Calls:                                                                ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Sat Oct 10, 1987 04:45:20p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.                                       ;
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc GetProfileString,<PUBLIC,FAR>,<si,di>
        parmD   section
        parmD   keyword
        parmD   defString
        parmD   resString
        parmW   cchMax
cBegin
        cCall   MISCMapDStoDATA         ; point at data segment
        ReSetKernelDS

        cCall   SetDefaultPro

if KDEBUG
        mov     dx, off_defString
        or      dx, seg_defString       ; Catch those NULL pointers
        jnz     ok_def
        mkerror ERR_BADDEFAULT,<GetProfileString: NULL lpDefault>,dx,dx
ok_def:
endif
        mov     ax,off_keyword
        mov     dx,seg_keyword
        or      ax,dx
        jnz     GPS_Normal
        cCall   GetKeys,<section,resString,cchMax>

; Carry if the section not found, AX has length of "string".

        jnc     GPS_End
        jmps    GPS_DefString

GPS_Normal:
        cCall   GetString,<section,keyword>

; DX:AX contains pointer to return string
; CX has length, -1 if string not found

        cmp     cx,-1                   ; see if there is any string
        jz      GPS_DefString
        mov     SEG_defstring,dx
        mov     OFF_defstring,ax
GPS_DefString:
        xor     ax, ax                  ; bug fixed.
        cmp     SEG_defstring, 0
        je      GPS_End                 ; Save us from the GP fault
        les     di,defString            ; DI = front of string
ifdef FE_SB                             ;Apr.26,1990 by AkiraK
        call    strlen                  ; CX = strlen, di = end of string
        ;get last character behind terminater
        push    si
        les     si,defString            ; SI = front of string
gps_dbcs_l1:
        mov     al,es:[si]
        call    FarMyIsDBCSLeadByte
        cmc
        adc     si,1
        cmp     si,di
        jb      gps_dbcs_l1
        pop     si
else
        call    strlen                  ; CX = strlen, di = end of string
        mov     al,es:[di-1]            ; AL = last character of string
endif
        les     di,defString            ; DI = front of string
                                        
                                        ; Strip off single and double quotes
        cmp     cx,2                    ; strlen < 2?
        jb      strdone                 ; yes, skip
        mov     ah,es:[di]              ; AH = first character in the string
        cmp     ah,al                   ; first char = last char?
        jnz     strdone                 ; if no match, then no quotes
        cmp     al,"'"
        jz      strq
        cmp     al,'"'
        jnz     strdone
strq:   sub     cx,2                    ; string is really two smaller
        inc     di                      ; and starts here
strdone:

; CX now has length of return string, use it for copying.

        mov     dx,cchMax
        dec     dx
        cmp     cx,dx
        jbe     GPS1
        mov     cx,dx
GPS1:
        push    ds                      ; save DS
        push    es
        pop     ds
        mov     si,di                   ; ds:si has string
        push    cx                      ; save length for return
        les     di,ResString
        rep     movsb                   ; copy string
        mov     byte ptr es:[di], 0     ; null terminate
        pop     ax
        pop     ds                      ; restore DS
GPS_End:
        push    ax
        call    UnlockBuffer
        pop     ax                      ; get length of returned string
cEnd

cProc GetKeys,<PUBLIC,NEAR>,<si,di,ds>
        parmD   section
        parmD   resstr
        parmW   cchMax
cBegin

        xor     di,di                   ; make sure buffer is ready
        call    BufferInit

; DX:AX has buffer address, NULL if it didn't work.

        mov     di,ax                   ; save offset
        or      ax,dx                   ; see if no address
ifdef FE_SB
        jnz     skip1
        jmp     GetKeysNone             ; if no address, done
skip1:
else
        jz      GetKeysNone             ; if no address, done
endif
        dec     cchMax                  ; Leave room for terminating null byte
        mov     es,dx

        cCall   FindSection, <section>
        jc      GetKeysNone

        lds     si,resstr
        xor     dx,dx
GK3:                                    ; Key name loop
        mov     bx,di
GK3a:
        mov     al,es:[di]
ifdef FE_SB                             ;Apr.26,1990 by AkiraK
        call    FarMyIsDBCSLeadByte
        cmc                             ;if the char is lead byte of DBCS,
        adc     di,1                    ; then di += 2 else di += 1
else
        inc     di
endif
        cmp     al,'='
        je      GK3c
        cmp     al,LINEFEED             ; Ignore lines without =
        je      GK3
        cmp     al,SECT_LEFT            ; Done if it's a section header
        je      GK4
        or      al,al                   ; or null.
        jnz     GK3a
        jmps    GK4
GK3c:
        mov     di,bx
GK3d:
        mov     al,es:[di]
        inc     di
        cmp     al,'='
        jne     GK3e
        xor     al,al
GK3e:
        mov     [si],al
        inc     dx
        inc     si
        cmp     dx,cchMax
        jb      GK3f
        dec     si
        dec     dx
GK3f:
ifdef FE_SB                             ;Apr.26,1990 by AkiraK
        call    FarMyIsDBCSLeadByte
        jc      GK3_s1
        mov     al,es:[di]
        inc     di

        mov     [si],al
        inc     dx
        inc     si
        cmp     dx,cchMax
        jb      GK3f2
        dec     si
        dec     dx
GK3f2:

GK3_s1:
endif
        or      al,al
        jnz     GK3d
        ScanTo  LINEFEED
        jmp     GK3

GetKeysNone:
        stc
        jmps    GetKeysDone

GK4:
        mov     byte ptr [si], 0        ; Terminating null
        or      dx, dx                  ; No extra zapping if nothing found
        jz      GK4x
ifdef FE_SB                             ;Apr.26,1990 by AkiraK
        push    dx

        cCall   AnsiPrev,<resstr,ds,si>
        mov     si,ax
        mov     byte ptr [si], 0
        mov     byte ptr [si+1], 0

        pop     dx
else
        mov     byte ptr [si-1], 0      ; [si-1] already zero unless we hit
                                        ; cchMax above in which case, we must
                                        ; zap the previous character.
endif
GK4x:
        mov     ax,dx
        clc

GetKeysDone:
cEnd


; Scan through buffer, looking for section.

cProc FindSection, <PUBLIC, NEAR>
        parmD   section
cBegin

SS1:
        cmp     byte ptr es:[di],SECT_LEFT ; see if it's a section header
        jne     SS2
        inc     di
        lds     si,section
        mov     bl,SECT_RIGHT
        call    strcmpi                 ; case insensitive compare
        je      SSfound                 ;  terminate on SECT_RIGHT
SS2:
        ScanTo  LINEFEED
        cmp     byte ptr es:[di], 0
        jne     SS1

; If it gets here, there wasn't a match.

        stc                             ; Fail
        jmps    SSdone

SSfound:
        ScanTo  LINEFEED                ; read to beginning of first keyline
        clc                             ; Success

SSdone:
cEnd

cProc FindKey, <PUBLIC, NEAR>
        parmD   keyword
cBegin

        mov     ax, SEG_keyword
        or      ax, OFF_keyword         ; Do we have something to look for?
        jz      FK_NoMatch
FK_Next:
        mov     al,es:[di]
        or      al,al
        jz      FK_NoMatch
        cmp     al,SECT_LEFT
        jz      FK_NoMatch

        lds     si,keyword
        mov     bl,'='                  ; term on =.
        call    strcmpi                 ; case insensitive compare, term on 0
        je      FK_Found                ; es:di has result string

        ScanTo  LINEFEED
        jmp     FK_Next

FK_NoMatch:
        stc
        jmps    FK_Done
FK_Found:
        clc
FK_Done:

cEnd

cProc GetString,<PUBLIC,NEAR>,<si,di,ds>
        parmD   section
        parmD   key
cBegin
        xor     di,di                   ; make sure buffer is ready
        call    BufferInit

; DX:AX has buffer address, NULL if it didn't work.

        mov     di,ax                   ; save offset
        or      ax,dx                   ; see if no address
        jz      NoMatch                 ; no address, nothing to match against

        mov     es,dx

; DX:DI now has the buffer address, buffer is locked down.

        cCall   FindSection, <section>  ; Look for the section
        jc      NoMatch
        cCall   FindKey, <key>
        jnc     HaveKey

NoMatch:
        mov     cx,-1                   ; string was not found
        jmps    GetStrDone

; if it gets here, it matched

HaveKey:
        inc     di                      ; pointing at =
        mov     dx,es
        mov     bx,di
        ScanTo  CARRETURN               ; traverse string until reach end
        inc     cx
        inc     cx
        neg     cx                      ; will now contain string length
        mov     ax,bx
GetStrDone:
cEnd

; make sure the buffer has been filled


        public  BufferInit              ; this is for the debugger
BufferInit:
assumes DS,CODE
        mov     ax,[hBuffer]
        or      ax,ax
        jnz     bf0
        xor     dx,dx
        ret
bf0:
        call    LockBuffer
        mov     bx,ax
        or      bx,dx
        jz      bf1
        ret
bf1:
        mov     bx,GA_MODIFY            ; make block not discardable
        cCall   GlobalReAlloc,<hBuffer,ax,ax,bx>
        mov     ax,di
        les     dx, lpszUserPro
        cmp     fUserPro, PROPRIVATE
        jne     bf1a1
        mov     bx,codeOffset PrivateProBuf     ; Private ie not WIN.INI
        cCall   OpenFile,<es,dx,dsbx,ax>
        cmp     ax, -1                  ; File not found?
        jne     bf1a2
        or      di, di
        jz      bf1a2                   ; Don't create if we want to read it.
        mov     ax, di
        or      ax, OF_CREATE           ; Writing it, create it silently.
        les     dx, lpszUserPro
        mov     bx,codeOffset PrivateProBuf
        jmps    bf1a
bf1a1:
        or      di,di
        jz      bf1a0
        or      ax,OF_CREATE
bf1a0:
        mov     bx,codeOffset UserProBuf
        cmp     byte ptr [bx],0
        jz      bf1a
        mov     dx,dataOffset szUserPro
        and     ax,NOT OF_CREATE
        or      ax,OF_REOPEN or OF_PROMPT
bf1a:
        cCall   OpenFile,<es,dx,dsbx,ax>
bf1a2:
        mov     [hFile],ax
        inc     ax
        jnz     @F
        jmp     bf3                     ; if file not found, return 0:0
@@:     mov     ax,0002h
        call    Rewind2                 ; seek to end of file
        add     ax,3                    ; tack on room for cr,lf and 0
        adc     dx,0
        jz      bf1aa                   ; ok if less than 64k
        mov     ax, -1                  ; Limit memory used
        xor     dx, dx
bf1aa:
        push    ax                      ; Length to read
        mov     bx,GA_ZEROINIT
        regptr  LONGINT,DX,AX
        cCall   GlobalReAlloc,<hBuffer,LONGINT,bx>  ; global block
        pop     bx                      ; Stand on our head to preserve length
        or      ax,ax
        jz      bf3
        mov     hBuffer, ax
        push    bx
        call    LockBuffer
        call    Rewind                  ; rewind to beginning of file
        les     bx,[BufAddr]
        mov     es:[bx],2020h           ; space space
        pop     cx                      ; read in the whole file
        sub     cx, 3                   ; don't fill extra space in the buffer
        jcxz    bf1zz                   ; Don't bother if nothing to read
        cCall   _lread,<hFile,esbx,cx>
        inc     ax
        jz      bf2
        dec     ax
        mov     cx,ax                   ; cx has file size
bf1zz:
        cmp     cx,2
        jae     bf1z
        mov     cx,2
bf1z:
        jmps    PackBuffer
bf2:    call    UnlockBuffer
FreeBuffer:
        xor     ax,ax
        mov     dx,GA_DISCARDABLE shl 8 OR GA_MODIFY
        cCall   GlobalReAlloc,<si,ax,ax,dx>
        xor     ax,ax
        mov     dx,(GA_SHAREABLE) shl 8 OR GA_MOVEABLE
        cCall   GlobalReAlloc,<si,ax,ax,dx>

bf3:    xor     ax,ax
        xor     dx,dx
        mov     word ptr [BufAddr][0],ax
        mov     word ptr [BufAddr][2],dx
        ret

        public  packbuffer
PackBuffer:
        push    ds
        mov     dx,di
        les     di,[BufAddr]
        lds     si,[BufAddr]

pb1:
ifdef FE_SB                             ;Apr.26,1990 by AkiraK
;TAB or SPACE are never found in lead byte of DBCS.
;so, this loop is safe in DBCS.
endif
        jcxz    pb9                     ; while leading space or tab
        mov     bx, di                  ; Initialize first valid character

        lodsb
        dec     cx
        cmp     al, SPACE               ; remove leading spaces
        jz      pb1
        cmp     al, TAB                 ; and tabs
        jz      pb1

        dec     si                      ; refetch last character
        inc     cx
pb2:
        lodsb
        dec     cx
        or      dx,dx                   ; Are we writing?
        jnz     pb20                    ; Yes, leave comments in
        cmp     al,';'                  ; No, is this a comment?
        jne     pb20                    ; No, continue
        jcxz    pb9                     ; if done
pb2loop:
ifdef FE_SB                             ;Apr.26,1990 by AkiraK
;LINEFEED is never found in lead byte of DBCS.
;so, this loop is safe in DBCS.
endif
        lodsb
        dec     cx
        jz      pb9                     ; if done
        cmp     al, LINEFEED            ; if end of line, go on
        jz      pb1
        jmps    pb2loop
pb20:
        stosb                           ; first character of line
ifdef FE_SB                             ;Apr.26,1990 by AkiraK
        call    FarMyIsDBCSLeadByte
        jc      pb_dbcs_s1
        movsb
        dec     cx
        jz      pb9
pb_dbcs_s1:
endif
        cmp     al,'='                  ; if '=', then end of left hand side
        jz      pb2a
        jcxz    pb9
        cmp     al, SPACE               ; if space, might be trailing space
        jz      pb2
        cmp     al, TAB
        jz      pb2
        cmp     al, LINEFEED            ; if end of line, go on
        jz      pb1
        mov     bx,di                   ; ow save last valid character+1
        jmp     pb2

pb2a:
        mov     di,bx                   ; remove trailing spaces on left
        stosb                           ; resave '='
pb3:                                    ; now work on right hand side
        jcxz    pb9                     ; while leading space or tab
        lodsb                           ; remove leading spaces
        dec     cx
        cmp     al, SPACE
        jz      pb3                     ; and tabs
        cmp     al, TAB
        jz      pb3

        dec     si                      ; refetch last character
        inc     cx
pb5:
ifdef FE_SB                             ;Apr.26,1990 by AkiraK
;LINEFEED is never found in lead byte of DBCS.
;so, this loop is safe in DBCS.
endif
        lodsb
        stosb                           ; store character
        dec     cx
        jz      pb9
        cmp     al, LINEFEED            ; at end of line?
        jz      pb1                     ; yes, go on
        jmp     pb5

pb9:
        or      di, di
        jz      pb9a                    ; NOTHING THERE!!
        dec     di                      ; remove trailing ^Z's
        cmp     byte ptr es:[di],"Z"-"@"
        jz      pb9
        inc     di
pb9a:

        mov     ax,CRLF
        stosw                           ; make sure there is a final
        xor     ax,ax                   ;   CARRETURN and NULL
        stosb
        pop     ds                      ; restore DS
        mov     si,[hBuffer]
        cCall   GlobalUnlock,<si>

        xor     ax,ax
        regptr  xsize,ax,di
        cCall   GlobalReAlloc,<si,xsize,ax>

        public  lockbuffer
LockBuffer:
        mov     si,ax
        cCall   GlobalLock,<ax>
        mov     word ptr BufAddr[0],ax
        mov     word ptr BufAddr[2],dx
        ret

        public  unlockbuffer
UnlockBuffer:
        mov     si,hBuffer
        cCall   GlobalUnlock,<si>
        xor     ax,ax
        mov     dx,(GA_MODIFY + (GA_DISCARDABLE SHL 8)) ; make block discardable
        cCall   GlobalReAlloc,<si,ax,ax,dx>
        mov     bx,-1
        xchg    bx,[hFile]
        inc     bx
        jz      ulbdone
        dec     bx
        cCall   _lclose,<bx>            ; close file
ulbdone:
        ret

Rewind:
        xor     ax,ax                   ; rewind the tape
Rewind2:
        xor     cx,cx
        cCall   _llseek,<hFile,cx,cx,ax>
        ret


; this proc calculates the length of the string pointed to by es:di
; and returns it in cx.  It searches for a CR and then backs thru any
; trailing spaces.
; it uses cx, es, and di

        public  strlen
strlen  PROC    NEAR
ifdef FE_SB                             ;Apr.26,1990 by AkiraK
; Space, Carridge Return, NULL are never in lead byte of DBCS.
; So, we don't need to enable here.
endif
        push    ax                      ; Save ax
        mov     cx,di                   ; cx = start of string
        dec     di                      
str1:   inc     di                      ; Search for CR or NULL
        mov     al,es:[di]              ;  AL has CR or NULL
        cmp     al,CARRETURN
        ja      str1                    
str2:   dec     di                      ; Remove trailing blanks
        cmp     di,cx                   ; Check for start of string
        jb      str3
        cmp     byte ptr es:[di],SPACE
        jz      str2
str3:   inc     di                      ; Restore CR or NULL
        cmp     es:[di],al
        jz      maybe_in_code
        mov     es:[di],al
maybe_in_code:
        neg     cx
        add     cx,di
        pop     ax                      ; Restore ax
        ret
strlen  ENDP

        public  strcmpi
strcmpi PROC    NEAR
; es:di and ds:si have strings
; es:di should be terminated by the char in bl
; ds:si is null terminated
ifdef FE_SB                             ;Apr.26,1990 by AkiraK
sti_l1:
        mov     al,es:[di]
        cmp     al,bl
        jz      sti_s1

        call    FarMyLower
        mov     cl,al

        mov     al,ds:[si]
        call    FarMyLower

        inc     si
        inc     di

        cmp     al,cl
        jnz     sti_exit

        call    FarMyIsDBCSLeadByte
        jc      sti_l1

        mov     al,es:[di]
        cmp     al,ds:[si]
        jnz     sti_exit

        inc     si
        inc     di
        jmp     short sti_l1


sti_exit:
        ret

sti_s1:
        mov     al,ds:[si]
        or      al,al
        ret
else
stci10:
        mov     al,es:[di]
        cmp     al,bl                   ; At the end?
        jnz     stci15                  ; yes, get out of here.
        mov     al,[si]                 ; are we at the end of the string
        or      al,al
        jmps    stciex
stci15:
        call    FarMyLower
stci30:
        mov     cl,[si]
        xchg    al,cl
        call    FarMyLower
        xchg    cl,al
stci40:
        inc     si
        inc     di
        cmp     al,cl                   ; Still matching chars?
        jz      stci10                  ; Yes, go try the next char.
stciex:
        ret
endif
strcmpi ENDP


;-----------------------------------------------------------------------;
; WriteProfileString                                                    ;
;                                                                       ;
; Copies the given character string to WIN.INI.                         ;
;                                                                       ;
; Arguments:                                                            ;
;       parmD   lpApplicationName                                       ;
;       parmD   lpKeyName                                               ;
;       parmD   lpString                                                ;
;                                                                       ;
; Returns:                                                              ;
;       AX = bResult                                                    ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       DI,SI,DS                                                        ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;       BX,CX,DX,ES                                                     ;
;                                                                       ;
; Calls:                                                                ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Sat Oct 10, 1987 05:12:51p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.                                       ;
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc WriteProfileString,<PUBLIC,FAR>,<si,di,ds>
        parmD   section
        parmD   keyword
        parmD   result
 
        localD  ptrTmp
        localW  WhatIsMissing
        localW  nBytes
        localW  fh
cBegin
        cCall   MISCMapDStoDATA         ; point at data segment
        ReSetKernelDS

        cCall   SetDefaultPro

;make sure buffer is ready

        mov     si,[hBuffer]
        call    FreeBuffer              ; free up any buffer we may have
        cmp     ax,SEG_section
        jne     WPS0
        cmp     ax,SEG_keyword
        jne     WPS0
        cmp     ax,SEG_result
        jne     WPS0
        jmp     WriteDone
WPS0:
        mov     di,2                    ; write
        call    BufferInit              ; read in a fresh copy

; DX:AX has buffer address, NULL if it didn't work

        mov     di,ax
        or      ax,dx
        jnz     WPS1
        jmp     WriteDone

WPS1:   push    dx                      ; save buffer selector

        cCall   GlobalSize, <hBuffer>   ; how big is he?
        or      dx, dx                  ; more than 64k, icky
        jnz     WPS_TooBig
        cmp     ax, 0FF00h              ; more than 64K-256, icky
        jb      WPS_SmallEnough

WPS_TooBig:
        pop     ax                      ; throw away saved buffer selector
        xor     ax, ax                  ; return FALSE if file too big
        jmp     WriteDone

WPS_SmallEnough:

        pop     es                      ; selector of buffer popped into es
        push    ds
        call    Rewind

; ES:DI now has the buffer address, buffer is locked down
; scan through buffer, looking for section

        cCall   FindSection, <section>
        jc      WPS5

        mov     ax, SEG_keyword
        or      ax, OFF_keyword
        jnz     WPS2
        mov     WhatIsMissing, REMOVESECTION
        ScanBack SECT_LEFT
        jmps    WPS9
WPS2:
        cCall   FindKey, <keyword>
        jnc     WPS7

; if it gets here, there wasn't a match

        mov     WhatIsMissing,NOKEY
        jmps    WPS8

; if it gets here, there wasn't a match

WPS5:
        mov     WhatIsMissing,NOSECTION
        jmps    WPS8

WPS7:
        inc     di                      ; di now points to result
        mov     WhatIsMissing,NEWRESULT
        mov     ax, SEG_result
        or      ax, OFF_result
        jnz     WPS9                    ; NEWRESULT

        ScanBack LINEFEED
        inc     di                      ; Now points to the keyword
        jmps    WPS9
WPS8:

        cmp     WhatIsMissing,NEWRESULT
        jz      WPS9
WPS14:                                  ; get rid of extra CRLF
        or      di, di
        jz      WPS9
        dec     di
        mov     al,es:[di]
        cmp     al,CARRETURN
        jz      WPS14
        cmp     al,LINEFEED
        jz      WPS14
        add     di,3
WPS9:

; write out up to here in file

        pop     ds
        push    ds
        mov     bx,[hFile]
        cmp     bx,-1
        jnz     WPS10

        lds     dx,lpszUserPro ; create win.ini
        xor     cx,cx                   ; no special attributes
        cCall   _lcreat,<ds,dx,cx>      ; create the file
        pop     ds
        push    ds
        mov     [hFile],ax
        mov     bx,ax                   ; bx has file handle
        inc     ax
        jz      WPSError                ; -1 means didn't work
        xor     dx,dx
        cCall   _lwrite,<bx,dsdx,dx>    ; Zero length write to reset file
        or      ax,ax
        jz      WPS10                   ; size on a network file (3.0 bug)
WPSError:
        pop     ds
        call    UnlockBuffer
        xor     ax,ax
        jmp     WriteDone
WPS10:
        mov     bx,[hFile]
        mov     fh,bx                   ; save file handle in local variable
        xor     cx,cx
        mov     nBytes,cx
; write file
        mov     off_ptrTmp,di
        mov     seg_ptrTmp,es
        mov     cx,di                   ; cx has file size
        push    es
        pop     ds
        xor     dx,dx
        call    WriteCheck              ; write and check the write

        cmp     WhatIsMissing,NOSECTION
        jnz     WPS11
        mov     ax, SEG_keyword         ; Wanted to delete it?
        or      ax, OFF_keyword
        jnz     WPS10a
        jmp     WPS13                   ; Yes, don't do anything
WPS10a:
        pop     ds
        push    ds
        mov     dx,codeOffset CarRetLF
        mov     cx,2
        call    WriteCheck
        mov     dx,codeOffset LeftSect
        mov     cx,1
        call    WriteCheck
        les     di,section
        call    strlen
        lds     dx,section
        call    WriteCheck
        pop     ds
        push    ds
        mov     dx,codeOffset RightSect
        mov     cx,3
        call    WriteCheck
WPS11:
        cmp     WHatIsMissing, REMOVESECTION
        jne     WPS11a
        
WPS11b:
        ScanTo  LINEFEED                ; Skip Current Line
WPS11c:
        mov     al, es:[di]
        or      al, al
        jz      WPS13
        cmp     al, SECT_LEFT
        je      WPS13
        cmp     al, ';'
        jne     WPS11b                  ; Skip this line
                                        ; Preserve Comment lines
        smov    ds, es                  ; Write from ds:dx
        mov     dx, di
        ScanTo  LINEFEED
        mov     cx, di
        sub     cx, dx
        call    WriteCheck
        jmps    WPS11c

WPS11a:
        cmp     WhatIsMissing,NEWRESULT
        jz      WPS15
                                        ; WhatIsMissing == NOKEY
        mov     ax, SEG_result          ; Delete keyword?
        or      ax, OFF_result
        jz      WPS13                   ; Yes, do nothing since not there!

        les     di,keyword
        call    strlen
        lds     dx,keyword
        call    WriteCheck
        pop     ds
        push    ds
        mov     dx,codeOffset EquStr
        mov     cx,1
        call    WriteCheck
        jmps    WPS15a                  ; and write out result

WPS15:                                  ; Found keyword, have new result
        mov     ax, SEG_result
        or      ax, OFF_result          ; Have result to set?
        jnz     WPS15a
        ScanTo  LINEFEED                ; No result, delete line
        jmps    WPS13
WPS15a:
        les     di,result
        call    strlen
        lds     dx,result
        call    WriteCheck
        pop     ds
        push    ds
        mov     dx,codeOffset CarRetLF
        mov     cx,2
        call    WriteCheck
WPS12:
        les     di,ptrTmp
        cmp     WhatIsMissing,NEWRESULT
        jnz     WPS13
                                        ; get rid of old result
        ScanTo  LINEFEED
WPS13:
        mov     dx,di
        xor     al,al
        mov     cx,-1
        repne   scasb
        sub     di,3                    ; one past end, plus extra CRLF
        sub     di,dx
if 1
        jbe     WPS23                   ; if di points before dx blow it off
endif
        mov     cx,di
if 0
        or      cx,cx                   ; if <= 0 then nothing to write
        jle     WPS23
endif
        mov     si,dx
        mov     dx,cx                   ; We are growing the file. Seek
        add     dx,nBytes
        xor     cx,cx                   ; to new EOF and set file size
        cCall   _llseek,<fh,cx,dx,cx>
                                        ; with zero length write (DOS 2.X
                                        ; BIOS bug with writes past current
        xor     cx,cx                   ; EOF with DTA near end of memory)
        call    WriteCheck
        mov     dx,nBytes               ; Now backup to write rest of file
        xor     cx,cx
        cCall   _llseek,<fh,cx,dx,cx>
        push    es
        pop     ds
        mov     cx,di
        mov     dx,si
        call    WriteCheck
WPS23:
        xor     cx,cx
        call    WriteCheck
        pop     ds

        call    UnlockBuffer
        call    FreeBuffer
        mov     ax,1
WriteDone:
cEnd

        public  WriteCheck
WriteCheck:
        cCall   _lwrite,<fh,dsdx,cx>
        mov     cx,ax
        inc     ax
        jz      WC1
        dec     ax
        add     [nBytes],cx
        ret
WC1:
        pop     ax                      ; return address
        jmp     WPSError


;-----------------------------------------------------------------------;
; GetPrivateProfileInt                                                  ;
;                                                                       ;
; Gets the integer value for the keyword field from a private file      ;
;                                                                       ;
; Arguments:                                                            ;
;       parmD   lpApplicationName                                       ;
;       parmD   lpKeyName                                               ;
;       parmW   nDefault                                                ;
;       parmD   lpFile                                                  ;
;                                                                       ;
; Returns:                                                              ;
;       AX = nKeyValue                                                  ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       DI,SI,DS                                                        ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;       BX,CX,DX,ES                                                     ;
;                                                                       ;
; Calls:                                                                ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Sat Oct 10, 1987 04:32:04p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.                                       ;
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   GetPrivateProfileInt,<PUBLIC,FAR>,<si>
        parmD   Section
        parmD   keyword
        parmW   defint
        parmD   lpFile
        localV  Buffer,80h
cBegin
        cCall   MISCMapDStoDATA         ; Safety
        lea     si,Buffer
        cCall   ForcePrivatePro,<ss,si,lpFile>
        cCall   SetPrivatePro,<ss,si>
        cCall   GetProfileInt,<section, keyword, defint>
        cCall   ResetPrivatePro
cEnd


;-----------------------------------------------------------------------;
; GetPrivateProfileString                                               ;
;                                                                       ;
; Returns the string for the keyword field from a private file          ;
;                                                                       ;
; Arguments:                                                            ;
;       parmD   lpApplicationName                                       ;
;       parmD   lpKeyName                                               ;
;       parmD   lpDefault                                               ;
;       parmD   lpReturnedString                                        ;
;       parmW   nSize                                                   ;
;       parmD   lpFile                                                  ;
;                                                                       ;
; Returns:                                                              ;
;       AX = nLength                                                    ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       DI,SI,DS                                                        ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;       BX,CX,DX,ES                                                     ;
;                                                                       ;
; Calls:                                                                ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Sat Oct 10, 1987 04:45:20p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.                                       ;
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc GetPrivateProfileString,<PUBLIC,FAR>,<si>
        parmD   section
        parmD   keyword
        parmD   defString
        parmD   resString
        parmW   cchMax
        parmD   lpFile
        localV  Buffer,80h
cBegin
        cCall   MISCMapDStoDATA         ; Safety
        lea     si,Buffer
        cCall   ForcePrivatePro,<ss,si,lpFile>
        cCall   SetPrivatePro,<ss,si>
        cCall   GetProfileString,<section,keyword,defString,resString,cchMax>
        cCall   ResetPrivatePro
cEnd


;-----------------------------------------------------------------------;
; WritePrivateProfileString                                             ;
;                                                                       ;
; Copies the given character string to a private file                   ;
;                                                                       ;
; Arguments:                                                            ;
;       parmD   lpApplicationName                                       ;
;       parmD   lpKeyName                                               ;
;       parmD   lpString                                                ;
;       parmD   lpFile                                                  ;
;                                                                       ;
; Returns:                                                              ;
;       AX = bResult                                                    ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       DI,SI,DS                                                        ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;       BX,CX,DX,ES                                                     ;
;                                                                       ;
; Calls:                                                                ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Sat Oct 10, 1987 05:12:51p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.                                       ;
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc WritePrivateProfileString,<PUBLIC,FAR>,<si>
        parmD   section
        parmD   keyword
        parmD   result
        parmD   lpFile
        localV  Buffer,80h
cBegin
        cCall   MISCMapDStoDATA         ; Safety
        lea     si,Buffer
        cCall   ForcePrivatePro,<ss,si,lpFile>
        cCall   SetPrivatePro,<ss,si>
        cCall   WriteProfileString,<section, keyword, result>
        cCall   ResetPrivatePro
cEnd

;-----------------------------------------------------------------------;
; ForcePrivatePro
;
; If the file pointed to is not qualified then we force
; the file into the Windows directory.
;
; Entry:
;       BX = buffer on stack
;
; Returns:
;
; Registers Destroyed:
;
; History:
;  Tue 14-Nov-1989 20:30:48  -by-  David N. Weise  [davidw]
; Wrote it!
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   ForcePrivatePro,<PUBLIC,NEAR>,<di,si,ds>
        parmD   lpDest
        parmD   lpSource
cBegin
ifdef FE_SB                             ;Apr.26,1990 by AkiraK
        cld
        xor     ax,ax
        mov     bx,'/' shl 8 + '\'
        xor     dx,dx
        lds     si,lpSource             ; first get length of string
        mov     cx,si
        mov     al,ds:[si]
        call    FarMyIsDBCSLeadByte
        jnc     fpp_s1
        cmp     byte ptr ds:[si].1,':'  ; is it qualified with a drive?
        jnz     fpp_s1
        inc     dx
fpp_s1:

fpp_l1:
        lodsb
        or      al,al
        jz      fpp_got_length
        cmp     al,bh
        jz      fpp_qualified
        cmp     al,bl
        jz      fpp_qualified
fpp_s2:
        call    FarMyIsDBCSLeadByte
        jc      fpp_l1
        inc     si
        jmp     fpp_l1

fpp_qualified:
        inc     dx
        jmp     fpp_s2
else
        cld
        xor     ax,ax
        mov     bx,'/' shl 8 + '\'
        xor     dx,dx
        lds     si,lpSource             ; first get length of string
        mov     cx,si
        cmp     byte ptr ds:[si].1,':'  ; is it qualified with a drive?
        jnz     @F
        inc     dx
@@:     lodsb
        or      al,al
        jz      fpp_got_length
        cmp     al,bh
        jz      fpp_qualified
        cmp     al,bl
        jnz     @B
fpp_qualified:
        inc     dx
        jmp     @B
endif

fpp_got_length:
        sub     si,cx
        xchg    si,cx
        les     di,lpDest
        or      dx,dx
        jnz     fpp_copy_name
        push    cx
        cCall   MISCMapDStoDATA
        ResetKernelDS
        mov     cx,cBytesWinDir
        lds     si,lpWindowsDir
        rep     movsb
        mov     al,'\'
        stosb
        pop     cx
        lds     si,lpSource
fpp_copy_name:
        rep     movsb
cEnd

endif
; ndef WOW

;-----------------------------------------------------------------------;
; GetWindowsDirectory
;
;
; Entry:
;       parmD   lpBuffer   pointer to buffer
;       parmW   cbBuffer   size of buffer
;
; Returns:
;       AX = size of string copied
;
; Registers Destroyed:
;
; History:
;  Sun 24-Sep-1989 16:18:46  -by-  David N. Weise  [davidw]
; Wrote it!
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   IGetWindowsDirectory,<PUBLIC,FAR>,<di,si>
        parmD   lpBuf
        parmW   cbBuffer
cBegin
        cCall   MISCMapDStoDATA         ; point at data segment
        ResetKernelDS
if 1 ;HYDRA
; Get the current windows directory, since it depends on the state of ini-file
; mapping (assumes lpWindowsDir already points to achCtxWindowsDir - ldboot.asm).
        mov     si, offset achTermsrvWindowsDir
        cCall   TermsrvGetWindowsDir,<ds, si, MaxFileLen>
        or      ax, ax                  ; ax != 0 -> success
        jz      short gwd_exit  

        push    es
        smov    es,ds
        mov     di, si                 ; es:di points to windows path
        mov     cx,-1
        xor     ax,ax
        repnz   scasb
        not     cx
        dec     cx
        mov     cBytesWinDir, cx
        pop     es
else    ; HYDRA
        mov     cx,cBytesWinDir
        lds     si,lpWindowsDir
endif        
        inc     cx                      ; Room for NULL
        mov     ax, cx
        cmp     cx, 3                   ; Just 3 bytes implies <drive>:
        jne     gwd_notroot
ifdef FE_SB                             ;Apr.26,1990 by AkiraK
        mov     al,ds:[si+0]            ;Make sure the 1st byte is not
        call    FarMyIsDBCSLeadByte     ; DBCS lead byte.
        jnc     gwd_notroot
endif
        cmp     byte ptr ds:[si+1], ':' ; Make sure
        jne     gwd_notroot
        inc     ax                      ; Allow for \
gwd_notroot:
        cmp     ax,cbBuffer             ; is there enough room in buffer?
        ja      gwd_exit
        dec     cx                      ; don't copy null
        les     di,lpBuf
        cld
ifdef WOW
;; For WOW we might be running on a file system that supports lower case
;; however some apps can't cope with lowercase names so we uppercase it here
        push    ax
gwd_loop:
        lodsb
;; LATER
;;      call    FarMyUpper                 ; Convert char to UpperCase
        stosb
ifdef FE_SB
;;      call    MyIsDBCSLeadByte
;;      jc      gwd_loop                ; copy second byte in east
;;      movsb
endif
        loop    gwd_loop
        pop     ax
else ; WOW
        rep     movsb
endif; WOW
        mov     es:[di],cl
        dec     ax
        cmp     ax, 3
        jne     gwd_exit
        mov     di, word ptr lpBuf      ; Get pointer to dest again
ifdef FE_SB                             ;Apr.26,1990 by AkiraK
        mov     al,ds:[di+0]            ;Make sure the 1st byte is not
        call    FarMyIsDBCSLeadByte     ; DBCS lead byte.
        jnc     gwd_exit
endif
        cmp     byte ptr es:[di+1], ':'
        jne     gwd_exit
        mov     byte ptr es:[di+2], '\'
        mov     byte ptr es:[di+3], cl
gwd_exit:
cEnd
;-----------------------------------------------------------------------;
; GetSystemDirectory
;
; Entry:
;       parmD   lpBuf   pointer to buffer
;       parmW   cbBuffer   size of buffer
;
; Returns:
;       AX = size of string copied
;
; Registers Destroyed:
;
; History:
;  Sun 24-Sep-1989 16:18:46  -by-  David N. Weise  [davidw]
;
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   IGetSystemDirectory,<PUBLIC,FAR>,<di,si>
        parmD   lpBuf
        parmW   cbBuffer
cBegin
        cCall   MISCMapDStoDATA         ; point at data segment
        ResetKernelDS
ifndef WOW
        mov     cx,cBytesSysDir
        lds     si,lpSystemDir
else
        mov     cx,cBytesSys16Dir
        lds     si,lpSystem16Dir
endif
        inc     cx                      ; Room for NULL
        mov     ax, cx
        cmp     cx, 3                   ; Just 3 bytes implies <drive>:
        jne     gsd_notroot
ifdef FE_SB                             ;Apr.26,1990 by AkiraK
        mov     al,ds:[si+0]            ;Make sure the 1st byte is not
        call    FarMyIsDBCSLeadByte     ; DBCS lead byte.
        jnc     gsd_notroot
endif
        cmp     byte ptr ds:[si+1], ':' ; Make sure
        jne     gsd_notroot
        inc     ax                      ; Allow for \
gsd_notroot:
        cmp     ax,cbBuffer             ; is there enough room in buffer?
        ja      gsd_exit
        dec     cx                      ; don't copy null
        les     di,lpBuf
        cld
ifdef WOW
;; For WOW we might be running on a file system that supports lower case
;; however some apps can't cope with lowercase names so we uppercase it here
        push    ax
gsd_loop:
        lodsb
        call    FarMyUpper                 ; Convert char to UpperCase
        stosb
ifdef FE_SB
;;      call    MyIsDBCSLeadByte
;;      jc      gsd_loop                ; copy second byte in east
;;      movsb
endif
        loop    gsd_loop
        pop     ax
else ; WOW
        rep     movsb
endif; WOW
        mov     es:[di],cl
        dec     ax                      ; return number of bytes in string
        cmp     ax, 3
        jne     gsd_exit
        mov     di, word ptr lpBuf      ; Get pointer to dest again
ifdef FE_SB                             ;Apr.26,1990 by AkiraK
        mov     al,ds:[di+0]            ;Make sure the 1st byte is not
        call    FarMyIsDBCSLeadByte     ; DBCS lead byte.
        jnc     gsd_exit
endif
        cmp     byte ptr es:[di+1], ':'
        jne     gsd_exit
        mov     byte ptr es:[di+2], '\'
        mov     byte ptr es:[di+3], cl
gsd_exit:
cEnd

;-----------------------------------------------------------------------;
; GetProfileSectionNames
;
; Entry:
;       parmD   lpBuf   pointer to buffer for section names
;       parmW   cbBuffer   size of buffer
;
; Returns:
;
; Registers Destroyed:
;
; History:
;
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   GetProfileSectionNames,<PUBLIC,FAR>,<di,si>
        parmD   lpBuf
        parmW   cbBuffer
cBegin
        cCall   MISCMapDStoDATA         ; point at data segment
        ResetKernelDS
        mov     si, dataoffset szUserPro
        regptr  xWinDotIni,ds,si
        cCall GetPrivateProfileSectionNames, <lpBuf, cbBuffer, xWinDotIni>
cEnd

sEnd    MISCCODE

ifndef WOW

sBegin  INITCODE
assumes cs, CODE
assumes ds, nothing
assumes es, nothing

szWININI        db      'WININI='
lenWININI       equ     $-codeoffset szWININI

;-----------------------------------------------------------------------;
; SetUserPro                                                            ;
;                                                                       ;
; Set szUserPro to the string given in the environment variable WININI  ;
; The default is WIN.INI                                                ;
;                                                                       ;
; Arguments:                                                            ;
;                                                                       ;
; Returns:                                                              ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;                                                                       ;
; Calls:                                                                ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;-----------------------------------------------------------------------;

cProc   SetUserPro,<PUBLIC,NEAR>,<ax,cx,si,di,ds,es>
cBegin
        SetKernelDS     es
        mov     ds, TopPDB
        mov     ds, ds:[PDB_environ]
        cld
        xor     si, si

        smov    es,cs
        assumes es,CODE

FindWinIni:
        cmp     byte ptr ds:[si], 0
        je      EndEnv
        mov     di, codeoffset szWININI
        mov     cx, lenWININI
        rep     cmpsb
        je      FoundEntry
        dec     si
SkipEntry:
        lodsb
        or      al, al
        jnz     SkipEntry
        jmps    FindWinIni
FoundEntry:

        SetKernelDS     es

        mov     di, dataoffset szUserPro
CopyEntry:
        lodsb
        stosb
        or      al, al
        jnz     CopyEntry
EndEnv:
        assumes es, nothing
cEnd

sEnd    INITCODE

endif
; ndef WOW

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\task.asm ===
page	,132
	title	TASK - task create/destroy procedures
.xlist
include kernel.inc
include tdb.inc
include pdb.inc
include newexe.inc
include dbgsvc.inc
include bop.inc
.list

outd	macro	msg,n
%out msg n
endm
if2
; outd <TDBsize =>,%TDBsize
endif

externW pStackBot
externW pStackMin
externW pStackTop

externFP SafeCall
externFP BuildPDB
externFP LockSegment
externFP UnlockSegment
;externFP Yield
externFP LocalInit
externFP GlobalAlloc
externFP GlobalFree
;externFP GlobalLock
externFP GlobalUnLock
externFP GlobalCompact
externFP IGlobalHandle
externFP GlobalLRUOldest
externFP AllocDStoCSAlias
;;;externFP FarMyLock
externFP FarSetOwner
externFP default_sig_handler
externFP CVW_Hack
externFP GlobalDOSAlloc
externFP GlobalDOSFree
externFP AllocSelector
externFP LongPtrAdd
externFP MyFarDebugCall
externFP Int21Handler
externFP far_get_arena_pointer32
externFP FarAssociateSelector32
externFP KRebootInit

if KDEBUG
externFP SetupAllocBreak
endif

ifdef WOW
externFP SetAppCompatFlags
externFP WowReserveHtask
externFP FreeSelector
externFP WowPassEnvironment
externFP ExitCall
endif

DataBegin

;externB fEMM
externB fBooting
externB kernel_flags
externB num_tasks
;externW hexehead
externW pGlobalHeap
externW curTDB
externW loadTDB
externW headTDB
externW headPDB
externW topPDB
externW cur_DOS_PDB
externW Win_PDB
externW MyCSAlias
externD pUserInitDone
externD ptrace_app_entry
externD ptrace_DLL_entry
externD pSignalProc

if KDEBUG
globalW allocTask,0
globalD allocCount,0
globalD allocBreak,0
globalB allocModName,0,8
endif   ;KDEBUG

ifdef WOW
externD FastBop
externW DebugWOW
endif

DataEnd

sBegin	CODE
assumes CS,CODE
assumes DS,NOTHING
assumes ES,NOTHING

externD prevInt00proc

externNP SaveState
externNP UnlinkObject
externNP genter
externNP gleave

nullcomline	DB  0,0Dh

;-----------------------------------------------------------------------;
; GetCurrentTask							;
; 									;
; Returns the current task.						;
;									;
; Arguments:								;
;	none								;
; 									;
; Returns:								;
;	AX = curTDB							;
;	DX = headTDB							;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
;	all								;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
;	nothing								;
; 									;
; History:								;
; 									;
;  Sun Feb 01, 1987 07:45:40p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	GetCurrentTask,<PUBLIC,FAR>
cBegin	nogen
	push	es
	SetKernelDS ES
	mov	ax,curTDB
	mov	dx,headTDB
;	 mov	 bx,codeOffset headTDB
;	 mov	 cx,codeOffset curTDB
	pop	es
	ret
	assumes es,nothing
cEnd	nogen


;-----------------------------------------------------------------------;
; InsertTask								;
; 									;
; Inserts a task into the task list.					;
; 									;
; Arguments:								;
;	parmW	hTask							;
; 									;
; Returns:								;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
;	CX,DX,DI,SI,DS							;
; 									;
; Registers Destroyed:							;
; 	AX,BX,ES							;
;									;
; Calls:								;
;	nothing								;
; 									;
; History:								;
; 									;
;  Sun Feb 01, 1987 09:41:24p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	InsertTask,<PUBLIC,NEAR>,<ds>
	parmW	hTask
cBegin
	mov	es,hTask		; get task handle
	SetKernelDS
	mov	ax,headTDB		; get head of task list
	UnSetKernelDS
	or	ax,ax			; anybody here?
	jz	ins1			; no, just do trivial case

ins0:	mov	ds,ax			; point to head TDB
	mov	bl,es:[TDB_priority]	; get insert priority
	cmp	bl,ds:[TDB_priority]	; is it less than head task?
	jg	ins2			; no, insert elsewhere
	mov	es:[TDB_next],ax
ins1:	SetKernelDS
	mov	headTDB,es
	UnSetKernelDS
	jmps	ins4

ins2:	mov	ds,ax			; save segment of previous TDB
	mov	ax,ds:[TDB_next]	; get segment of next tdb
	or	ax,ax			; if zero, insert now
	jz	ins3
	mov	es,ax			; point to new TDB
	cmp	bl,es:[TDB_priority]
	jg	ins2
ins3:	mov	es,hTask
	mov	ds:[TDB_next],es
	mov	es:[TDB_next],ax
ins4:
cEnd


;-----------------------------------------------------------------------;
; DeleteTask								;
; 									;
; Deletes a task from the task list.					;
; 									;
; Arguments:								;
;	parmW	hTask							;
; 									;
; Returns:								;
;	AX = hTask							;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
;	UnlinkObject							;
; 									;
; History:								;
; 									;
;  Sun Feb 01, 1987 09:41:24p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	DeleteTask,<PUBLIC,NEAR>
	parmW	hTask
cBegin
	mov	es,hTask
	mov	bx,dataOffset headTDB
	mov	dx,TDB_next
	call	UnlinkObject		; returns AX = hTask
cEnd


cProc	FarCreateTask,<PUBLIC,FAR>	; Called from CreateTask
;	parmW	fPrev			; Calls several 'near' CODE funcs
cBegin
	cCall	SaveState,<ds>
	SetKernelDS	es
	mov	loadTDB,ds
	cCall	InsertTask,<ds>
	clc
cEnd

if KDEBUG

;-----------------------------------------------------------------------
;
; CheckGAllocBreak
;
; Checks to see if the allocation break count has been reached.
; Returns CARRY SET if the allocation should fail, CLEAR otherwise.
; Increments the allocation count.
;
;-----------------------------------------------------------------------

LabelNP <PUBLIC, CheckGAllocBreak>
        errn$   CheckLAllocBreak

cProc   CheckLAllocBreak,<PUBLIC,NEAR>,<DS,AX>
cBegin
	SetKernelDS
assumes ds,DATA

        mov     ax,allocTask        ; if allocTask != curTDB, exit.
        or      ax,ax               ; curTDB may be NULL during boot.
        jz      cab_nofail
        cmp     ax,curTDB
        jnz     cab_nofail

        mov     ax,word ptr allocBreak
        cmp     ax,word ptr allocCount   ; if allocBreak != allocCount
        jnz     cab_increment       ;   inc allocCount
        mov     ax,word ptr allocBreak+2
        cmp     ax,word ptr allocCount+2
        jnz     cab_increment

        or      ax,word ptr allocBreak   ; if allocBreak is 0L, just inc.
        jz      cab_increment

	krDebugOut <DEB_ERROR>, "Alloc break: Failing allocation"

        stc                         ; return carry set
        jmp     short cab_exit

cab_increment:
        inc     word ptr allocCount      ; increment allocCount
        jnz     cab_nofail
        inc     word ptr allocCount+2
cab_nofail:
        clc
cab_exit:
assumes ds,NOTHING
cEnd

endif   ;KDEBUG

sEnd	CODE

sBegin  NRESCODE
assumes CS,NRESCODE
assumes DS,NOTHING
assumes ES,NOTHING

externNP MapDStoDATA
externNP GetInstance
externNP StartProcAddress

;-----------------------------------------------------------------------;
; CreateTask								;
; 									;
; "Creates" a new task.  It allocates the memory for the TDB+PDB struc,	;
; builds the PDB, constructs the TDB, initializes the EEMS memory	;
; arena, and sets the signature word in the TDB.  TDB actually added	;
; to task queue by StartTask.						;
;									;
; Arguments:								;
;	parmD	pParmBlk						;
;	parmW	pExe							;
;	parmW	hPrev instance						;
;	parmW	fWOA							;
; 									;
; Returns:								;
;	AX = segment of TDB						;
; 									;
; Error Returns:							;
;	AX = 0								;
; 									;
; Registers Preserved:							;
;	DI,SI,DS							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Thu 04-Jan-1990 21:18:25  -by-  David N. Weise  [davidw]		;
; Added support for OS/2 apps.						;
;									;
;  Mon 07-Aug-1989 23:28:15  -by-  David N. Weise  [davidw]		;
; Added support for long command lines to winoldap.			;
;									;
;  Thu Apr 09, 1987 03:53:16p  -by-  David N. Weise   [davidw]		;
; Added the initialization for EMS a while ago, recently added the	;
; switching of stacks to do it.						;
; 									;
;  Sun Feb 01, 1987 07:46:53p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	CreateTask,<PUBLIC,FAR>,<si,di>
	parmD	pParmBlk
	parmW	pExe
;	parmW	fPrev
	parmW	fWOA

	localW	env_seg
	localW	comline_start
cBegin
	call	MapDStoDATA
	ReSetKernelDS
	cld
	xor	si,si
	mov	env_seg,si
	mov	comline_start,si
	cmp	si,pParmBlk.sel
	jz	parm_block_considered
	cCall	pass_environment,<pExe,pParmBlk>
	inc	ax
	jnz	@F
	jmp	ats6
@@:	dec	ax
	mov	env_seg,ax
	mov	comline_start,dx
	mov	si,size PDB		; start with size of PDB
	cmp	fWOA,0
	jz	parm_block_considered
	les	di,pParmBlk
	les	di,es:[di].lpcmdline
	mov	cx,es:[di]
	sub	cx,127			; account for terminating 0Dh
	jbe	parm_block_considered
	add	si,cx
	add	si,15
	and	si,NOT 15
parm_block_considered:
	add	si,TDBsize+15		; Room for task data and paragraph aligned.
;	xor	ax,ax			; Room for EMM save area if needed.
;	mov	al,fEMM
;	add	si,ax
	and	si,0FFF0h
	mov	di,si
	mov	cl,4
	shr	si,cl
ifdef WOW
; We need to ensure task handles are unique across multiple WOW VDMs
; on Windows NT, so that for example the undocumented feature of
; passing a 16-bit htask to Win32 Post(App|Thread)Message instead
; of a thread ID will work reliably with multiple WOW VDMs.
;
; To accomplish this we call WowReserveHtask, which will return
; the htask if the htask (ptdb) was previously unused and has
; been reserved for us.  If it returns 0 another VDM is already
; using that value and so we need to allocate another and try again.
; To avoid risking exhausting low memory, we allocate memory for the
; TDB once using GlobalDOSAlloc, then clone it using AllocSelector.
; We test this cloned selector value using WowReserveHtask, if it
; fails we get another clone until one works.  Then we free all but
; the clone we'll return, and magically swap things around so that
; the cloned selector owns the TDB memory and then free the original
; selector from GlobalDOSAlloc
;

        xor     dx,dx                   ; Make size of allocation a dword
        regptr  xsize,dx,di
        cCall   GlobalDOSAlloc,<xsize>
        or      ax,ax
        jnz     @f
        jmp     ats6                    ; Return zero for failure.

@@:     push    di                      ; save TDB size on stack
        push    ax                      ; save GlobalDOSAlloc selector on stack
        mov     di,ax                   ; and in DI
        cCall   WowReserveHtask,<ax>    ; returns htask or 0
        or      ax,ax                   ; Is this selector value avail as htask?
        jz      MustClone               ; no, start cloning loop
        pop     ax                      ; htask to return
        pop     di                      ; TDB size
        jmps    NoClone
MustClone:
        xor     cx,cx                   ; count of clone selectors
        xor     si,si                   ; no selector to return yet
AnotherHtask:
        push    cx
        cCall   AllocSelector,<di>      ; clone the selector
        pop     cx
        or      ax,ax
        jz      FreeAnyHtasks           ; Out of selectors cleanup and exit
        push    ax                      ; save cloned selector on stack
        inc     cx
        push    cx
        cCall   WowReserveHtask,<ax>    ; returns htask or 0
        pop     cx
        or      ax,ax
        jz      AnotherHtask            ; conflict
        mov     si,ax                   ; SI = selector to return
        pop     bx                      ; pop the selector we're returning
        dec     cx
        jcxz    @f
FreeLoop:
        pop     bx                      ; pop an allocated selector from stack
        push    cx
        cCall   FreeSelector,<bx>
        pop     cx
        dec     cx
FreeAnyHtasks:
        jcxz    @f                      ; have we popped all the allocated selectors? Yes
        jmps    FreeLoop                ; No

@@:     mov     ax,si
        or      si,si
        jnz     @f
        pop     ax                      ; original selector from GlobalDOSAlloc
        cCall   GlobalDOSFree,<ax>
        pop     di
        jmp     ats6

@@:
        ; SI is selector to return, top of stack is original GlobalDOSAlloc
        ; selector.  We need to free the original selector and make the clone
        ; selector "own" the memory so it will be freed properly by GlobalDOSFree
        ; during task cleanup.

        pop     di                              ; DI = original GlobalDOSAlloc selector
        push    ds
        mov     ds, pGlobalHeap
        UnSetKernelDS
        .386
        cCall   far_get_arena_pointer32,<di>
        push    eax
        cCall   FarAssociateSelector32,<di,0,0>
        pop     eax
        mov     ds:[eax].pga_handle, si
        cCall   FarAssociateSelector32,<si,eax>
        .286p
        pop     ds
        ReSetKernelDS
        cCall   FreeSelector,<di>
        mov     ax,si                           ; AX is the final TDB selector/handle.
        pop     di                              ; TDB size
NoClone:

else
        xor     dx,dx                   ; Make size of allocation a dword
        regptr  xsize,dx,di
	cCall	GlobalDOSAlloc,<xsize>
	or	ax,ax
	jnz	@f
	jmp	ats6			; Return zero for failure.
@@:
endif
	mov	es, ax
	xor	ax, ax			; zero allocated block
	mov	cx, di
	shr	cx, 1
	xor	di, di
	rep	stosw

	mov	ax, es

ats2a:
	cCall	FarSetOwner,<ax,ax>	; Set TDB owner to be itself
	cmp	fWOA,0			; Is this WinOldApp?
	mov	ds,ax
	UnSetKernelDS
	jz	no_it_isnt
	or	ds:[TDB_flags],TDBF_WINOLDAP
no_it_isnt:

; Initialize the task stack.

	mov	si,1			; 1 for show means open window
	les	di,pParmBlk
	mov	ax,es
	or	ax,di
	jnz	@F
	jmp	ats4			; AX = DI = 0 if no parmblock

@@:	xor	ax,ax			; Skip past EMM save area and
	push	ds
	xor	dx, dx
	push	es
	mov	es,pExe
	mov	dx,es:[ne_flags]
	pop	es
	test	dx,NEPROT
	jz	@F
	or	ds:[TDB_flags],TDBF_OS2APP
	or	ds:[TDB_ErrMode],08000h ; don't prompt for .DLL's
@@:
	call	MapDStoDATA
	ReSetKernelDS
	test	dx,NEPROT		; OS/2 app?
	mov	dx,TopPDB		; DX has segment of parent PDB
	jz	use_kernel_TDB
; %OUT This should probably be Win_PDB
	mov	dx,cur_DOS_PDB		; inherit parent's stuff
use_kernel_TDB:
	pop	ds
	UnSetKernelDS

	push	dx			; yes, get address of PDB
	push	es
	mov	si,(TDBsize+15) and not 15	; Round up TDB size

	cCall	AllocSelector,<ds>	; Get us an alias selector
	or	ax, ax			;   did we get it?
	jnz	ats_gotsel
	mov	bx, ds			; No, tidy up
	mov	ds, ax			; We will current ds, so zero it
	cCall	GlobalDOSFree,<bx>	; Free the memory
	pop	es
	pop	dx
	xor	ax, ax
	jmp	ats6

ats_gotsel:
	xor	dx, dx
	cCall	LongPtrAdd,<ax,dx,dx,si>
	mov	si, dx			; SI = selector of new PDB
	pop	es
	pop	dx
	regptr	esbx,es,bx		; es:bx points at parm block
	mov	bx,di
	mov	cx,256			; just include enough room for PDB
	cCall	BuildPDB,<dx,si,esbx,cx,fWOA>; go build it
	mov	ax,si			; link on another PDB
	push	ds
	call	MapDStoDATA
	ReSetKernelDS
	xchg	HeadPDB,ax
	mov	es,si
	mov	es:[PDB_Chain],ax

	les	di,pParmBlk
	push	si
	lds	si,es:[di].lpfcb1
	UnSetKernelDS
	mov	di,PDB_5C_FCB
	pop	es
	mov	cx,ds
	or	cx,si
	jz	ats3b
	mov	cx,ds:[si]
	inc	cx
	inc	cx
	cmp	cx,24h
	jbe	ats3a
	mov	cx,24h
ats3a:	rep	movsb
ats3b:	mov	si,es
	pop	ds

	mov	ax,env_seg
	or	ax,ax
	jz	no_new_env
	mov	es:[PDB_environ],ax
no_new_env:

ats4:	mov	es,pExe
	mov	ds:[TDB_pModule],es	; Do this before InitTaskEMS

	mov	ax,comline_start	;!!! just for now os2
	mov	ds:[TDB_Validity],ax

	push	si
	push	ds
	push	ds
	push	es
	pop	ds
	pop	es

	mov	di,TDB_ModName
	mov	si,ds:[ne_restab]
	lodsb				; get no of bytes in name
	cbw
	cmp	ax,8
	jbe	@F
	mov	ax, ds
	krDebugOut <DEB_WARN or DEB_krLoadMod>, "Module Name %AX0 (%AX1) too long"
	mov	ax,8
@@:	mov	cx,ax
	cld
	rep	movsb

ifdef WOW
;  (see other bug #74369 note)
; Load the App compatibility flags
;  This ifdef WOW chunk is the same place as Win'95 task.asm to help get compat
;  flags loaded sooner
    mov cx,ds:[ne_expver]
    mov es:[TDB_ExpWinVer],cx

    cCall   SetAppCompatFlags, <es>
    mov es:[TDB_CompatFlags], ax
    mov es:[TDB_CompatFlags2], dx
if KDEBUG
    mov	bx, ax
    or	bx, dx
    jz      @F
    krDebugOut DEB_WARN, "Backward compatibility hack enabled: #dx#AX"
@@:
endif
endif

; initialize the interrupt vectors

	mov	di,TDB_INTVECS
	call	MapDStoDATA
	ReSetKernelDS
	mov	ds,MyCSAlias
	assumes ds,CODE
	mov	si,codeOffset prevInt00proc
	mov	cx,(4 * numTaskInts)/2
	rep	movsw
	assumes ds,nothing
	pop	ds
	pop	si

	cCall	FarCreateTask	;,<fPrev>
	jnc	@F
	jmp	ats6
@@:
	push	ds
	call	MapDStoDATA
	ReSetKernelDS
	mov	es,curTDB		; inherit the parents
	pop	ds
	UnSetKernelDS

	mov	ds:[TDB_PDB],si		; save new PDB
	or	si,si			; do we have a new PDB?
	jnz	@F			; zero means no
	mov	si,es:[TDB_PDB]
	mov	ds:[TDB_PDB],si
@@:	mov	ds:[TDB_Parent],es
;
; Inherit parent's wow compatibiltiy flags
; Special code is required in wkman.c to exploit this
	mov	ax,es:[TDB_WOWCompatFlags]
	mov	ds:[TDB_WOWCompatFlags],ax
	mov	ax,es:[TDB_WOWCompatFlags2]
	mov	ds:[TDB_WOWCompatFlags2],ax
	mov	ax,es:[TDB_WOWCompatFlagsEx]
	mov	ds:[TDB_WOWCompatFlagsEx],ax
	mov	ax,es:[TDB_WOWCompatFlagsEx2]
	mov	ds:[TDB_WOWCompatFlagsEx2],ax

	mov	ds:[TDB_thread_tdb],ds
	mov	ds:[TDB_DTA].off,80h	; set initial DTA
	mov	ds:[TDB_DTA].sel,si
	mov	ds:[TDB_sig],TDB_SIGNATURE	; Set signature word.

	mov	ax,SEG default_sig_handler
	mov	ds:[TDB_ASignalProc].sel,ax
	mov	ax,codeOffset default_sig_handler
	mov	ds:[TDB_ASignalProc].off,ax

; Initialize the MakeProcInstance Thunks.

	cCall	AllocDStoCSAlias,<ds>
	mov	ds:[TDB_MPI_Sel],ax
	mov	ds:[TDB_MPI_Thunks],0
	mov	ds:[TDB_MPI_Thunks].2,MPIT_SIGNATURE
	mov	bx,TDB_MPI_Thunks + THUNKSIZE-2
	mov	cx,THUNKELEM-1
	mov	dx,bx
mp1:	add	dx,THUNKSIZE
	.errnz	THUNKELEM and 0FF00h
	mov	ds:[bx],dx
	mov	bx,dx
	loop	mp1
	mov	ds:[bx],cx

	mov	si, ds
	mov	di, ax
	call	MapDStoDATA
	ReSetKernelDS
	mov	ds, pGlobalHeap
	UnSetKernelDS
	.386
	cCall	far_get_arena_pointer32,<si>
	cCall	FarAssociateSelector32,<di, eax>
	.286p
	mov	ax, si
	mov	ds, si
ats6:
cEnd

;-----------------------------------------------------------------------;
; pass_environment
;
;
; Entry:
;
; Returns:
;	AX = seg of new env if any
;	DX = start of comline
;
; Error Return:
;	AX = -1
;
; Registers Destroyed:
;
; History:
;  Wed 27-Dec-1989 23:36:25  -by-  David N. Weise  [davidw]
; Wrote it!
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

ifdef WOW
cProc   pass_environment,<PUBLIC,NEAR>,<di,si,ds>
        parmW pExe
        parmD pParmBlk
cBegin
        ReSetKernelDS
        test    fBooting,1
        jz      @F
	xor	ax,ax
	jmp	pe_exit
@@:
        cCall   WowPassEnvironment,<cur_DOS_PDB, pParmBlk, pExe>
        or      ax,ax
        jz      pe_error_exit
        cCall   FarSetOwner,<ax,pExe>   ; Make this new guy the owner
        jmps    pe_exit

pe_error_exit:
        mov     ax, -1
pe_exit:
cEnd

else

cProc	pass_environment,<PUBLIC,NEAR>,<di,si,ds>

	parmW	pExe
	parmD	pParmBlk

	localW	myEnv
cBegin

	ReSetKernelDS

	cld
        test    fBooting,1
        jz      @F
	xor	ax,ax
	jmp	pe_exit
@@:

        cCall   WowPassEnvironment,<Win_PDB, cur_DOS_PDB, pParmBlk, pExe>

	mov	es,curTDB
	mov	bl,es:[TDB_flags]

@@:


; massage environment

	les	di,pParmBlk
	mov	ax,es:[di].envseg
	or	ax,ax
	jnz	pe_given_env
; %OUT This should probably be Win_PDB
	mov	ds,cur_DOS_PDB
	UnsetKernelDS
	mov	ax,ds:[PDB_environ]

pe_given_env:
	mov	myEnv,ax
	mov	es,ax			; ES => environment
	xor	ax,ax
	mov	cx,-1
	xor	di,di
@@:	repnz	scasb
	cmp	es:[di],al
	jnz	@B
	neg	cx
;	dec	cx			; include space for extra 0
	push	cx			; length of environment
        mov     dx,cx

; MORE TEST CODE TO SEE IF IT FIXES THE PROBLEM.
        mov     es,pExe
        test    es:[ne_flags],NEPROT
        jnz     @f

        mov     cx,3                    ; Save room for magic word and nul
        add     dx,cx
        push    8000h                   ; No command line after the env.

        jmps    pe_got_com_len

@@:
	les	di,pParmBlk
	test	bl,TDBF_OS2APP		; execer an OS/2 app?
	jz	pe_execer_dos_app
	les	di,es:[di].lpCmdLine
	mov	cx,-1
	repnz	scasb
	repnz	scasb			; get both strings
	neg	cx
	add	dx,cx
        dec     cx                      ; length of command line
	or	ch,80h			; mark special
	push	cx
	jmps	pe_got_com_len

pe_execer_dos_app:
	inc	es:[di].lpCmdLine.off
	les	di,es:[di].lpCmdLine
	xor	cx,cx
        mov     cl,es:[di][-1]          ; length of command line
	add	dx,cx
        inc     dx                      ; We add a '\0' when we move it anyway
	push	cx

pe_got_com_len:
	mov	es,pExe
	mov	di,es:[ne_pfileinfo]
	lea	di,[di].opfile
	mov	cx,-1
	repnz	scasb
	neg	cx
	dec	cx
	push	cx			; length of file name
	shl	cx,1			; for program pointer and arg 1
	add	dx,cx

        cCall   GlobalAlloc,<ax,ax,dx>
	or	ax,ax
	jz	@f
	push	ax
        cCall   FarSetOwner,<ax,pExe>   ; Make this new guy the owner
	pop	ax
@@:
	mov	es,ax
	pop	dx			; length of filename
	pop	bx			; length of command line
	pop	cx			; length of environment
	or	ax,ax
        jz      pe_error_exit

	mov	ds,myEnv
	xor	di,di
	xor	si,si
	rep	movsb

        mov     ds,pExe

; MORE TEST CODE TO SEE IF IT FIXED THE PROBLEM

        test    ds:[ne_flags],NEPROT
        jnz     @f

        mov     ax,1
        stosw

@@:
	mov	si,ds:[ne_pfileinfo]
	lea	si,[si].opfile
	mov	cx,dx			; length of filename
        rep     movsb
	mov	ax,di			; save position of comline start

	test	bh,80h			; if OS/2 execer comline is correct
	jnz	@F
	mov	si,ds:[ne_pfileinfo]
	lea	si,[si].opfile
	mov	cx,dx			; length of filename
	rep	movsb

@@:	and	bh,NOT 80h
	lds	si,pParmBlk
	lds	si,ds:[si].lpCmdLine
	mov	cx,bx
	rep	movsb
	mov	byte ptr es:[di],0	; zero terminate
	mov	dx,ax			; comline start
	mov	ax,es
	jmps	pe_exit

pe_error_exit:
	mov	ax,-1

pe_exit:

cEnd

endif

;-----------------------------------------------------------------------;
; StartLibrary								;
; 									;
; Initialize library registers.						;
; 									;
; Arguments:								;
;	parmW   hExe							;
;	parmD   lpParms							;
;	parmD   startAddr						;
; 									;
; Returns:								;
; 									;
; Error Returns:							;
;	AX = 0								;
; 	DS = data segment						;
;									;
; Registers Preserved:							;
;	DI,SI								;
; 									;
; Registers Destroyed:							;
;	BX,CX,DX,ES							;
; 									;
; Calls:								;
;	GetInstance							;
;	FarMyLock							;
; 									;
; History:								;
; 									;
;  Thu 04-Jan-1990 22:48:25  -by-  David N. Weise  [davidw]		;
; Added support for OS/2 apps.						;
;									;
;  Sat Apr 18, 1987 08:54:50p  -by-  David N. Weise   [davidw]		;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	StartLibrary,<PUBLIC,NEAR>,<ds,si,di>
	parmW   hExe
	parmD   lpParms
	parmD   startAddr
	localW	hStartSeg
cBegin
	cCall	MapDStoDATA
	ReSetKernelDS
	cmp	loadTDB,0
	je	notloading
	test	kernel_flags,KF_pUID	; All done booting?
	jz	notloading
	mov	es,loadTDB
	test	es:[TDB_Flags],TDBF_OS2APP
	jnz	notloading
	mov	ax,hExe
	mov	es,es:[TDB_LibInitSeg]
	mov	bx,es:[pStackTop]
	xchg	es:[bx-2],ax
	mov	es:[bx],ax
	add	es:[pStackTop],2
	mov	ax,hExe
	jmp	slxx

notloading:
	mov	si,hExe
	mov	es,si
	test	es:[ne_flags],NEPROT
	jnz	no_user_yet
	cmp	pSignalProc.sel,0
	jz	no_user_yet
	xor	ax,ax
	mov	bx,40h
	cCall	pSignalProc,<hExe,bx,ax,ax,ax>	; SignalProc(hModule,40h,wParam,lParam)
no_user_yet:
	cCall	GetInstance,<si>
	mov	di,ax
	cCall	IGlobalHandle,<SEG_startAddr>
	xchg	startAddr.sel,dx
	mov	hStartSeg,ax

        ;** Send the SDM_LOADDLL notification
	mov	bx,startAddr.off
	mov	cx,startAddr.sel
	mov	ax,SDM_LOADDLL
        cCall   MyFarDebugCall

	cmp	SEG_startAddr, 0
	jnz	HaveStart
	mov	ax, di
        jmps    slxx
HaveStart:
	cCall	IGlobalHandle,<di>
	mov	ds,si
	UnSetKernelDS
	mov	cx,ds:[ne_heap]
	mov	ds,dx
	les	si,lpParms
	mov	ax,es
	or	ax,ax
	jz	dont_fault
	les	si,es:[si].lpcmdline
dont_fault:
	mov	ax,1			; An Arts & Letters lib init doesn't
        push    di                      ;  touch AX!!
ifdef WOW
        push    cs
        push    offset RetAddr
        pushf
        push    startAddr.sel
        push    startAddr.off

        push    ax

        push    ds

        push    ax
        mov     ax,hExe
        mov     ds,ax
        pop     ax

        push    0                       ; hTask (meaningless for a DLL)

        push    ds                      ; hModule

        push    ds                      ; Pointer to module name
        push    ds:ne_restab
        push    ds                      ; Pointer to module path
        push    word ptr ds:ne_crc+2

        cCall   MapDStoDATA
        ReSetKernelDS ds
        push    DBG_DLLSTART

        test    DebugWOW,DW_DEBUG
        jz      skip_bop

	FBOP BOP_DEBUGGER,,FastBop
.286p

skip_bop:
        add     sp,+14

        pop     ds
        UnSetKernelDS ds
        pop     ax
        iret

RetAddr equ $

else
        cCall   SafeCall,<startAddr>
endif
	pop	di			; USER.EXE didn't save DI, maybe others
	or	ax,ax
	jz	slx
	mov	ax,di
slx:
	push	ax
	pop	ax
slxx:
cEnd


;-----------------------------------------------------------------------;
; StartTask								;
;									;
; Sets up the standard register values for a Windows task.		;
;									;
; Arguments:								;
;	HANDLE hPrev   = a previous instance				;
;	HANDLE hExe    = the EXE header					;
;	FARP stackAddr = the normal task stack address (initial SS:SP)	;
;	FARP startAddr = the normal task start address (initial CS:IP)	;
; 									;
; Returns:								;
;	AX = HANDLE							;
; 									;
; Error Returns:							;
;	AX = NULL							;
;									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
;	GetInstance							;
;	FarMyLock							;
; 									;
; History:								;
;									;
;  Tue Apr 21, 1987 06:41:05p  -by-  David N. Weise      [davidw]	;
; Added the EMS initialization of the entry tables in page 0.		;
; 									;
;  Thu Dec 11, 1986 11:38:53a  -by-    David N. Weise     [dnw]		;
; Removed the superfluous call to calculate the largesr NR seg.		;
; 									;
;  Fri Sep 19, 1986 12:08:23p  -by-    Charles Whitmer	  [cxw]		;
; Made it return 0000 on error rather than terminate.			;
;									;
;  Thu Sep 18, 1986 02:33:39p  -by-  Charles Whitmer	[cxw]		;
; Wrote it.								;
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	StartTask,<PUBLIC,NEAR>,<si,di>
	parmW   hPrev
	parmW   hExe
	parmD   stackAddr
	parmD   startAddr
cBegin
	cCall	MapDStoDATA
	ReSetKernelDS
	xor	di,di
	cmp	loadTDB,di
	jnz	st1
	jmp	stx

stfail0:
	xor	ax,ax
	pop	ds
	jmp	stfail

st1:	push	ds
	cmp	stackAddr.sel,di
	jz	stfail0

	cmp	startAddr.sel,di
	jz	stfail0

	mov	ds,loadTDB
	UnSetKernelDS
	cmp	ds:[TDB_sig],TDB_SIGNATURE
	jnz	stfail0

; Get new task stack

	cCall	IGlobalHandle,<SEG_stackAddr>
	mov	ds:[TDB_taskSS],dx
	mov	ax,stackAddr.off
	sub	ax,(SIZE TASK_REGS)
	mov	ds:[TDB_taskSP],ax

; get my instance

        cCall   GetInstance,<hExe>
        mov     di,ax
	mov	ds:[TDB_Module],ax

; find my real code segment

	cCall	IGlobalHandle,<SEG_startAddr>
        or      dx,dx
	jz	stfail0
	mov	startAddr.sel,dx

; find my real data segment

        cCall   IGlobalHandle,<di>      ; DI = handle of DGROUP
	mov	si,dx			; SI = address of DGROUP

if KDEBUG

; Set up the allocBreak globals if needed

        cCall   SetupAllocBreak,<ds>

endif   ;KDEBUG

; copy junk from hExe -> TDB

	mov	es,hExe
	mov	cx,es:[ne_expver]
	mov	ds:[TDB_ExpWinVer],cx
	mov	cx,es:[ne_stack]	; CX = STACKSIZE
	mov	dx,es:[ne_heap] 	; DX = HEAPSIZE



; set up the task registers

	test	es:[ne_flags],NEPROT
	jnz	st_OS2_binary

	les	bx,dword ptr ds:[TDB_TaskSP]
	mov	es:[bx].TASK_AX,0	; Task AX = NULL
	mov	ax,ds:[TDB_PDB]
	mov	es:[bx].TASK_ES,ax	; Task ES = PDB
	mov	es:[bx].TASK_DI,di	; Task DI = hInstance or hExe
	mov	es:[bx].TASK_DS,si	; Task DS = data segment
	mov	ax,hPrev
	mov	es:[bx].TASK_SI,ax	; Task SI = previous instance
	mov	es:[bx].TASK_BX,cx	; Task BX = STACKSIZE
	mov	es:[bx].TASK_CX,dx	; Task CX = HEAPSIZE
	mov	es:[bx].TASK_BP,1	; Task BP = 1 (far frame)
	jmps	st_regs_set

st_OS2_binary:
	push	di
	mov	es,ds:[TDB_PDB]
	mov	di,es:[PDB_environ]
	les	bx,dword ptr ds:[TDB_TaskSP]
	mov	es:[bx].TASK_AX,di	; Task AX = environment
	mov	es:[bx].TASK_DX,cx	; Task DX = STACKSIZE
	lsl	cx,si
	inc	cx
	mov	es:[bx].TASK_CX,cx	; Task CX = Length of data segment
	mov	ax,ds:[TDB_pModule]
	mov	es:[bx].TASK_DI,ax	; Task DI = hExe
	mov	es:[bx].TASK_SI,dx	; Task SI = HEAPSIZE
	mov	es:[bx].TASK_DS,si	; Task DS = data segment
	mov	es:[bx].TASK_ES,0	; Task ES = 0
	mov	es:[bx].TASK_BP,1	; Task BP = 1 (far frame)
	xor	ax,ax
	xchg	ax,ds:[TDB_Validity]
	mov	es:[bx].TASK_BX,ax	; Task BX = offset in env of comline
	pop	di

st_regs_set:

        pop     ds
	push	ds
	ReSetKernelDS

        test    Kernel_Flags[2],KF2_PTRACE ;TOOLHELP.DLL and/or WINDEBUG.DLL?
        jz      st_NoPTrace

	mov	ax,startAddr.sel
	mov	ptrace_app_entry.sel,ax
	mov	ax,startAddr.off
	mov	ptrace_app_entry.off,ax

	mov	ax,SEG CVW_HACK
	mov	ds,ax
	UnSetKernelDS
	mov	ax,codeOffset CVW_Hack
	jmps	st_PTraceHere

st_NoPTrace:
	lds	ax,startAddr		; Task CS:IP = start address
	UnSetKernelDS
st_PTraceHere:
	mov	es:[bx].TASK_CS,ds
	mov	es:[bx].TASK_IP,ax
        pop     ds
	ReSetKernelDS

stx:	mov	ax,di
stfail:
cEnd

;-----------------------------------------------------------------------;
; InitTask								;
; 									;
; This should be the first thing called by app when first started.	;
; It massages the registers, massages the command line and inits	;
; the heap.								;
;									;
; Arguments:								;
;									;
;  When a windows application starts up the registers look		;
;  like this:								;
;									;
;  AX = 0								;
;  BX = stack size							;
;  CX = heap size							;
;  DX = ?								;
;  DI = hInstance							;
;  SI = hPrevInstance							;
;  BP = 0								;
;  ES = Segment of Program Segment Prefix (see page E-8)		;
;  DS = Applications DS							;
;  SS = DS								;
;  SP = stack area							;
;									;
;  FCB1 field at PSP:5CH contains up to 24h bytes of binary data.	;
;  Windows apps get their ShowWindow parameter in the first word of	;
;  of this data.							;
; 									;
; Returns:								;
;	AX	= PSP address						;
;	CX	= stack limit						;
;	DX	= command show						;
;	ES:BX	= command line						;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
;	LocalInit							;
;	FarEMS_FirstTime						;
; 									;
; History:								;
; 									;
;  Mon 11-Sep-1989 19:13:52  -by-  David N. Weise  [davidw]		;
; Remove entry of AX = validity check.					;
;									;
;  Wed Mar 16, 1988 22:45:00a  -by-  T.H.	      [    ]		;
; Fix bug in exit path.  It was not popping the saved DS from the	;
; far call frame properly.  Normally, this is not a problem (since	;
; it does indeed save the DS register across the entire routine),	;
; but if the RET has to go through a RetThunk, the saved DS is not	;
; really the original DS value, but a special value needed by the	;
; INT3F RetThunk code.  This causes a crash when something in this	;
; routine (like the call to UserInitDone) causes our calling code	;
; segment to be discarded.						;
; 									;
;  Sat Apr 18, 1987 08:43:54p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

STACKSLOP   equ	    150		; stack slop for interrupt overhead

	assumes ds,nothing
	assumes es,nothing

; ES = TDB

	public	do_libinit
do_libinit  proc    near
	push	si
	push	es
	mov	si,es:[TDB_LibInitOff]
	mov	es,cx
libinit_loop:
	cld
	lods	word ptr es:[si]
	or	ax,ax
	jz	libinit_done
	push	es
	mov	es,ax
	cmp	es:[ne_magic],NEMAGIC
	jne	libinit_loop1
	mov	ax,-1
	push	es
	cCall	StartProcAddress,<es,ax>
	pop	es
;;;	jcxz	libinit_loop1
	xor	cx,cx
	cCall	StartLibrary,<es,cx,cx,dx,ax>
	or	ax,ax
        jnz     libinit_loop1
        mov     ax,4CF0h
        DOSFCALL
libinit_loop1:
	pop	es
	jmp	libinit_loop
libinit_done:

	mov	si,es
	cCall	GlobalUnlock,<si>
	cCall	GlobalFree,<si>
	pop	es
	mov	es:[TDB_LibInitSeg],0
	mov	es:[TDB_LibInitOff],0
	pop	si
	ret
do_libinit  endp


	assumes ds,nothing
	assumes es,nothing

cProc	InitTask,<PUBLIC,FAR>
cBegin	nogen
	pop	ax			; Get return address
	pop	dx
	mov	ss:[pStackMin],sp	; Save bottom of stack
	mov	ss:[pStackBot],sp
	sub	bx,sp			; Compute top of stack
	neg	bx
	add	bx,STACKSLOP
	mov	ss:[pStackTop],bx	; Setup for chkstk

	xor	bp,bp			; Initial stack frame
	push	bp			; is not a far frame as there
	mov	bp,sp			; is no return address
	push	dx			; Push return address back on
	push	ax
	inc	bp
	push	bp
	mov	bp,sp
	push	ds
	jcxz	noheap			; Initialize local heap if any
	xor	ax,ax
	push	es
	cCall	LocalInit,<ax,ax,cx>
	pop	es
	or	ax,ax
	jnz	noheap
	push	ds
	jmp	noinit
noheap:
	push	es
	cCall	GetCurrentTask
	mov	es,ax
	mov	cx,es:[TDB_LibInitSeg]
	jcxz	no_libinit
	call	do_libinit
no_libinit:
ifdef WOW
;  (see other bug #74369 note)
;  App compatibility flags are set during CreateTask time to make them avilable
;  to .dll's that are loaded by do_libinit (this is the same as Win'95)
else
   call	SetAppCompatFlags
   mov	es:[TDB_CompatFlags], ax
   mov	es:[TDB_CompatFlags2], dx
if KDEBUG
   mov	bx, ax
   or	bx, dx
   jz      @F
   krDebugOut DEB_WARN, "Backward compatibility hack enabled: #dx#AX"
@@:
endif
endif

	pop	es

	push	ds
	cCall	MapDStoDATA
	ReSetKernelDS
	test	kernel_flags,KF_pUID	; All done booting?
	jnz	noboot			; Yes, continue
	or	kernel_flags,KF_pUID
	mov	fBooting,0
	mov	cx,ds

	pop	ds			; DS = caller's data segment
	UnSetKernelDS
	push	es			; Save ES
	push	ax
	push	cx
	cCall	IGlobalHandle,<ds>
	push	ax
	cCall	UnlockSegment,<ds>
        xor     dx,dx
        cCall   GlobalCompact,<dx,dx>   ; Compact memory
        xor     dx,dx
        cCall   GlobalCompact,<dx,dx>   ; Once more for completeness
	cCall	IGlobalHandle		 ; ,<ax> from above
	mov	ds,dx
        cCall   LockSegment,<ds>

	pop	cx
	push	ds
	mov	ds,cx
	ReSetKernelDS
	cmp	pUserInitDone.sel,0	; for Iris's server
	jz	no_User_to_call
	call	pUserInitDone		; Let USER lock down stuff.
no_USER_to_call:
	pop	ds
	UnSetKernelDS
	pop	ax
	pop	es
	push	ds

        ;** Initialize the reboot stuff here
        push    es                      ; Save across call
        cCall   KRebootInit             ; Local reboot init code
        pop     es


noboot:
	mov	bx,PDB_DEF_DTA		; point at command line
	mov	cx,bx			; save copy in cx
	cmp	bh,es:[bx]		; any chars in command line?
	je	ws3a			; no - exit
ws1:	inc	bx			; point to next char
	mov	al,es:[bx]		; get the char
	cmp	al,' '			; SPACE?
	je	ws1
	cmp	al,9			; TAB?
	je	ws1
	mov	cx,bx			; save pointer to beginning
	dec	bx			; compensate for next inc
ws2:	inc	bl			; move to next char
	jz	ws3a			; bailout if wrapped past 0FFh
	cmp	byte ptr es:[bx],13	; end of line?
	jne	ws2
ws3:
	mov	byte ptr es:[bx],0	; null terminate the line
ws3a:
	mov	bx,cx			; ES:BX = command line
	mov	cx,ss:[pStackTop]	; CX = stack limit
	mov	dx,1			; DX = default cmdshow
	cmp	word ptr es:[PDB_5C_FCB],2	; Valid byte count?
	jne	wsa4			; No, use default
	mov	dx,word ptr es:[PDB_5C_FCB][2]	; Yes, DX = passed cmdshow
wsa4:
	mov	ax,es			; AX = PSP address
noinit:
	pop	ds

; THIS is correct way to pop the call frame.  Must pop the saved
; DS properly from stack (might have been plugged with a RetThunk).

	sub	bp,2
	mov	sp,bp
	pop	ds
	pop	bp
	dec	bp
	ret
cEnd	nogen


;-----------------------------------------------------------------------;
; InitLib								;
; 									;
; Does what it says.							;
;									;
; Arguments:								;
;	CX = # bytes wanted for heap					;
; 									;
; Returns:								;
;	ES:SI => null command line					;
; 									;
; Error Returns:							;
;	CX = 0								;
; 									;
; Registers Preserved:							;
;	DI,DS								;
; 									;
; Registers Destroyed:							;
;	AX,BX,DX							;
; 									;
; Calls:								;
;	LocalInit							;
; 									;
; History:								;
; 									;
;  Sat Apr 18, 1987 08:31:27p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	InitLib,<PUBLIC,FAR>
cBegin	nogen
	xor	ax,ax
	jcxz	noheap1			; Done if no heap
	mov	si,cx
	cCall	LocalInit,<ax,ax,cx>
	jcxz	noheap1			; Done if no heap
	mov	cx,si
noheap1:
	push	ds
	cCall	MapDStoDATA
	push	ds
	pop	es
	pop	ds
	mov	si,codeOFFSET nullcomline
	ret
cEnd	nogen

if KDEBUG

if 0
;-----------------------------------------------------------------------
;   SetupAllocBreak
;
; Initializes the allocation break globals
; from the ALLOCBRK environment variable.
;
; ALLOCBRK=MODULE,0x12345678
;
; Assumes:
;   DS = loadTDB
;
; Trashes:
;   ES, SI, AX, BX, CX, DX
;
szALLOCBRK  db  "ALLOCBRK="
cchALLOCBRK equ $-szALLOCBRK

cProc   SetupAllocBreak,<NEAR, PUBLIC>,<SI>
cBegin
        mov     es,ds:[TDB_PDB]
        mov     es,es:[PDB_environ]

        lea     bx,szALLOCBRK
        mov     dx,cchALLOCBRK
        call    LookupEnvString
        or      bx,bx
        jz      nomatch
;
; See if TDB_ModName is the same as the ALLOCBRK= module.
;
        mov     si,TDB_ModName
modloop:
        mov     al,es:[bx]          ; get next environment char
        or      al,al
        jz      nomatch             ; if at end of environment, no match
        cmp     al,','
        jz      match               ; if at comma, then they might match
        cmp     al,ds:[si]
        jnz     nomatch
        inc     bx                  ; advance ptrs and try next char
        inc     si
        jmp     modloop
match:
        cmp     byte ptr ds:[si],0  ; at end of module name string?
        jnz     nomatch

        inc     bx                  ; skip past comma.
        call    ParseHex            ; parse hex constant into dx:ax

        SetKernelDSNRes es
        mov     word ptr es:allocBreak,ax
        mov     word ptr es:allocBreak+2,dx

        or      ax,dx               ; if allocBreak is 0, clear allocTask
        jz      @F
        mov     ax,ds               ; otherwise allocTask = loadTDB.
@@:
        mov     es:allocTask,ax

        xor     ax,ax               ; reset allocCount
        mov     word ptr es:allocCount,ax
        mov     word ptr es:allocCount+2,ax
nomatch:
cEnd

;-----------------------------------------------------------------------
; LookupEnvString
;
; ES -> environment segment
; CS:BX -> string to search for (which must include trailing '=')
; DX -> length of string to search for
;
; returns:
;   es:bx = pointer to environment string past '='
;
cProc   LookupEnvString,<NEAR, PUBLIC>,<SI,DI,DS>
cBegin
        push    cs                      ; ds = cs
        pop     ds

	cld
        xor     di,di                   ;start at beginning of environment seg
lenv_nextstring:
        mov     si,bx                   ;si = start of compare string
        mov     cx,dx                   ;cx = string length
        mov     ax,di                   ;Save current position in env seg
        repe    cmpsb
        je      lenv_foundit

        mov     di,ax                   ; start at beginning again
        xor     ax,ax                   ; and skip to end.
        xor     cx,cx
        dec     cx                      ; cx = -1
        repne   scasb
        cmp     es:[di],al              ;End of environment?
        jne     lenv_nextstring         ;No, try next string
        xor     bx,bx                   ; BX == NULL == not found.
        jmp     short lenv_exit

lenv_foundit:
        mov     bx,di
lenv_exit:
cEnd

;---------------------------------------------------------------------------
;
; ParseHex
;
; Assumes:
;   es:bx - pointer to hex string of form 0x12345678
;
; Returns:
;   Hex value in dx:ax, es:bx pointing to char past constant.
;
; Trashes:
;   cx
;
cProc   ParseHex,<NEAR, PUBLIC>
cBegin
        xor     dx,dx               ; zero break count
        xor     ax,ax
        xor     cx,cx               ; clear hi byte of char
hexloop:
        mov     cl,es:[bx]          ; get first digit
        jcxz    parse_exit
        inc     bx
        cmp     cl,' '              ; skip spaces
        jz      hexloop
        cmp     cl,'x'              ; skip 'x' or 'X'
        jz      hexloop
        cmp     cl,'X'
        jz      hexloop

        cmp     cl,'0'              ; '0'..'9'?
        jb      parse_exit
        cmp     cl,'9'
        jbe     hexdigit

        or      cl,'a'-'A'          ; convert to lower case

        cmp     cl,'a'              ; 'a'..'f'?
        jb      parse_exit
        cmp     cl,'f'
        ja      parse_exit

        sub     cl,'a'-'0'-10
hexdigit:
        sub     cl,'0'

        add     ax,ax               ; dx:ax *= 16
        adc     dx,dx
        add     ax,ax
        adc     dx,dx
        add     ax,ax
        adc     dx,dx
        add     ax,ax
        adc     dx,dx

        add     ax,cx               ; add in the new digit
        adc     dx,0

        jmp     hexloop
parse_exit:
cEnd
endif;  0

endif   ;KDEBUG

sEnd	NRESCODE


if KDEBUG

sBegin  CODE
assumes cs,CODE
;------------------------------------------------------------------------
;
; char FAR* GetTaskModNamePtr(HTASK htask)
;
; Returns a far pointer to a task's module name
; Used by SetupAllocBreak to access the task module name.
;
; Coded in assembly because no C header file that describes
; the TDB exists (and it's a little late to create one now)
;
cProc   GetTaskModNamePtr,<NEAR, PUBLIC>
ParmW   htask
cBegin
	mov     dx,htask
	mov     ax,TDB_ModName
cEnd

sEnd    CODE
endif;  KDEBUG


sBegin	MISCCODE
assumes	cs, misccode
assumes	ds, nothing
assumes	es, nothing

externNP MISCMapDStoDATA

;-----------------------------------------------------------------------;
; GetDOSEnvironment
;
; Gets a pointer to the current task's starting environment string.
; Basically used by DLL's to find the environment.
;
; Entry:
;	none
;
; Returns:
;	DX:AX = pointer to current task's starting environment string
;
; Registers Destroyed:
;
; History:
;  Tue 13-Jun-1989 20:52:58  -by-  David N. Weise  [davidw]
; Wrote it!
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	GetDOSEnvironment,<PUBLIC,FAR>
cBegin nogen

	push	ds
	call	GetCurrentTask
	mov	ds,ax
	mov	ds,ds:[TDB_PDB]
	mov	dx,ds:[PDB_environ]
	xor	ax,ax
	pop	ds
	ret

cEnd nogen


;-----------------------------------------------------------------------;
; GetNumTasks								;
; 									;
; Gets the number of tasks (AKA TDB) in the system.			;
;									;
; Arguments:								;
;	none								;
; 									;
; Returns:								;
;	AX = number of tasks						;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
;	all								;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
;	nothing								;
; 									;
; History:								;
; 									;
;  Thu Apr 09, 1987 11:34:30p  -by-  David N. Weise   [davidw]          ;
; Wrote it.								;
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	GetNumTasks,<PUBLIC,FAR>
cBegin	nogen
	xor	ax,ax
	push	ds
	call	MISCMapDStoDATA
	ReSetKernelDS
	mov	al,num_tasks
	pop	ds
	UnSetKernelDS
	ret
cEnd	nogen

sEnd	MISCCODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\up.c ===
/*
 * UP.C
 *
 * User Profile routines
 *
 * These are the routines which read and write INI files.
 *
 * Exported routines:
 *
 *	GetProfileString
 *	GetPrivateProfileString
 *	GetProfileInt
 *	GetPrivateProfileInt
 *	WriteProfileString
 *	WritePrivateProfileString
 *
 * Note the parameter "lpSection" used to be known as "lpApplicationName".
 * The code always referred to sections, so the parameter has been changed.
 *
 * Rewritten 6/90 for C 6.0.
 */

#include	"kernel.h"

		/*
		 * Required definitions for exported routines:
		 */

#define API	_far _pascal _loadds

HANDLE API IGlobalAlloc(WORD, DWORD);
HANDLE API IGlobalFree(HANDLE);
LPSTR  API IGlobalLock(HANDLE);
HANDLE API IGlobalReAlloc(HANDLE, DWORD, WORD);
BOOL   API IGlobalUnlock(HANDLE);

/* #pragma optimize("t", off) */

	/* This ensures that only one selector is required in PMODE */
#define	MAXBUFLEN	0xFFE0L

#define	SPACE		' '
#define	TAB		'\t'
#define	LINEFEED	'\n'
#define	CR		'\r'
#define	SECT_LEFT	'['
#define	SECT_RIGHT	']'
#define	CTRLZ		('Z'-'@')

	/* Constants for WriteProfileString - DON'T CHANGE THESE */
#define	NOSECTION	0
#define	NOKEY		1
#define	NEWRESULT	2
#define	REMOVESECTION	3
#define	REMOVEKEY	4

	/* Flags about a file kept in ProInfo
         * If the PROUNCLEAN label is changed, its value must also be
         *      changed in I21ENTRY.ASM, where it is assumed to be 2.
         */
#define	PROCOMMENTS	1		/* contains comments */
#define	PROUNCLEAN	2		/* has not been written */
#define PROMATCHES	4		/* buffer matches disk copy */
#define PROREADONLY	8		/* Read only file */
#define PRO_CREATED     16		/* File was just created */

	/* Sharing violation. */
#define	SHARINGVIOLATION        0x0020

	/* For forcing variables into the current code segment */
#define	CODESEG		_based(_segname("_CODE"))
	/* Hide disgusting _based syntax */
#define BASED_ON_LP(x)	_based((_segment)x)
#define BASED_ON_SEG(x)	_based(x)
#define	SEGMENT		_segment

	/* Externals assumed to be in DGROUP */
extern PROINFO	WinIniInfo;
extern PROINFO	PrivateProInfo;
extern LPSTR	lpWindowsDir;
extern int	cBytesWinDir;
extern int	WinFlags;
extern char	fBooting;
extern char	fProfileDirty;
extern char fProfileMaybeStale;
extern char	fAnnoyEarle;
extern char     fBooting;
extern LPSTR    curDTA;
extern BYTE fWriteOutProfilesReenter;

	/* Forward definitions to keep compiler happy */
	/* _fastcall may save some space on internal routines */
LPSTR _fastcall	BufferInit(PROINFO *, int);
LPSTR _fastcall LockBuffer(PROINFO *);
void  _fastcall	UnlockBuffer(PROINFO *);
LPSTR _fastcall	FreeBuffer(PROINFO *);
LPSTR _fastcall	PackBuffer(PROINFO *, int, int);
void  _fastcall FlushDirtyFile(PROINFO *);
int		GetInt(PROINFO *, LPSTR, LPSTR, int);
int		GetString(PROINFO *, LPSTR, LPSTR, LPSTR, LPSTR, int);
LPSTR		FindString(PROINFO *, LPSTR, LPSTR);
LPSTR		FindSection(LPSTR, LPSTR);
LPSTR		FindKey(LPSTR, LPSTR);
int		WriteString(PROINFO *, LPSTR, LPSTR, LPSTR);
void		strcmpi(void);
int		MyStrlen(void);
void API WriteOutProfiles(void);
PROINFO	* 	SetPrivateProInfo(LPSTR,LPSTR);
int GetSection(PROINFO*, LPSTR, LPSTR, int);
int IsItTheSame(LPSTR, LPSTR);
int Cstrlen(LPSTR);
int MakeRoom(LPSTR, int, int*);
int InsertSection(LPSTR, LPSTR, short);
int InsertKey(LPSTR, LPSTR, short);
int InsertResult(LPSTR, LPSTR, short);
int DeleteSection(LPSTR, PROINFO*);
int DeleteKey(LPSTR, PROINFO*);

	/* External KERNEL routines */
void _far _pascal FarMyLower();

int  API lstrOriginal(LPSTR,LPSTR);	/* lstrcmp in disguise */

#ifdef FE_SB
// Delacred in kernel.h already
// void _far _pascal AnsiPrev(LPSTR,LPSTR);
void _far _pascal FarMyIsDBCSLeadByte();
#endif

char CODESEG WinIniStr[] = "WIN.INI";

/* DOS FindFirst/FindNext structure (43h, 44h) */
typedef struct tagFILEINFO
{
        BYTE fiReserved[21];
        BYTE fiAttribute;
        WORD fiFileTime;
        WORD fiFileDate;
        DWORD fiSize;
        BYTE fiFileName[13];
} FILEINFO;

/*
 * Get[Private]ProfileInt
 *
 * Parameters:
 *	lpSection		Pointer to section to match in INI file
 *	lpKeyName		Pointer to key string to match in file
 *	nDefault		Default value to return if not found
 *	[lpFile			File to use for Private INI]
 *
 * Returns:
 *	nDefault		section/keyname not found
 *	number found in file if section/keyname found
 */
int API
IGetProfileInt(lpSection, lpKeyName, nDefault)
LPSTR	lpSection;
LPSTR	lpKeyName;
int	nDefault;
{
        int nReturn;

        /* Make sure we don't try to flush INI files on DOS calls */
        ++fWriteOutProfilesReenter;

        /* Reread INI file first if necessary */
        FlushDirtyFile(&WinIniInfo);

	nReturn = GetInt(&WinIniInfo, lpSection, lpKeyName, nDefault);

        --fWriteOutProfilesReenter;

        return nReturn;
}


int API
IGetPrivateProfileInt(lpSection, lpKeyName, nDefault, lpFile)
LPSTR	lpSection;
LPSTR	lpKeyName;
int	nDefault;
LPSTR	lpFile;
{
	PROINFO	*pProInfo;
	char	Buffer[128];
        int nReturn;

        /* Make sure we don't try to flush INI files on DOS calls */
        ++fWriteOutProfilesReenter;

	pProInfo = SetPrivateProInfo(lpFile, (LPSTR)Buffer);

        /* Reread INI file first if necessary */
        FlushDirtyFile(pProInfo);

	nReturn = GetInt(pProInfo, lpSection, lpKeyName, nDefault);
        --fWriteOutProfilesReenter;

        return nReturn;
}


/*
 * Get[Private]ProfileString
 *
 * Parameters:
 *	lpSection		Pointer to section to match in INI file
 *	lpKeyName		Pointer to key string to match in file
 *	lpDefault		Default string to return if not found
 *	lpResult		String to fill in
 *	nSize			Max number of characters to copy
 *	[lpFile]		File to use for Private INI
 *
 * Returns:
 *	string from file or lpDefault copied to lpResult
 *	< nSize - 2		Number of characters copied to lpResult
 *	nSize - 2		lpResult was not big enough
 */
int API
IGetProfileString(lpSection, lpKeyName, lpDefault, lpResult, nSize)
LPSTR lpSection;
LPSTR lpKeyName;
LPSTR lpDefault;
LPSTR lpResult;
int	 nSize;
{
        int nReturn;

        /* Make sure we don't try to flush INI files on DOS calls */
        ++fWriteOutProfilesReenter;

        /* Reread INI file first if necessary */
        FlushDirtyFile(&WinIniInfo);

	nReturn = GetString(&WinIniInfo, lpSection, lpKeyName, lpDefault,
                lpResult, nSize);
        --fWriteOutProfilesReenter;

        return nReturn;
}


int API
IGetPrivateProfileString(lpSection, lpKeyName, lpDefault, lpResult, nSize, lpFile)
LPSTR lpSection;
LPSTR lpKeyName;
LPSTR lpDefault;
LPSTR lpResult;
int	nSize;
LPSTR lpFile;
{
	PROINFO	*pProInfo;
	char	Buffer[128];
        int nReturn;

        /* Make sure we don't try to flush INI files on DOS calls */
        ++fWriteOutProfilesReenter;

	pProInfo = SetPrivateProInfo(lpFile, (LPSTR)Buffer);

        /* Reread INI file first if necessary */
        FlushDirtyFile(pProInfo);

	nReturn = GetString(pProInfo, lpSection, lpKeyName, lpDefault,
                lpResult, nSize);

        --fWriteOutProfilesReenter;

        return nReturn;
}


/*
 * Write[Private]ProfileString
 *
 * Parameters:
 *	lpSection		Pointer to section to match/add to INI file
 *	lpKeyName		Pointer to key string to match/add to file
 *	lpString		String to add to file
 *	[lpFile]		File to use for Private INI
 *
 * Returns:
 *	0			Failed
 *	1			Success
 */
int API
IWriteProfileString(lpSection, lpKeyName, lpString)
LPSTR lpSection;
LPSTR lpKeyName;
LPSTR lpString;
{
        int nReturn;

        /* Make sure we don't try to flush INI files on DOS calls */
        ++fWriteOutProfilesReenter;

        /* Reread INI file first if necessary */
        FlushDirtyFile(&WinIniInfo);

	nReturn = WriteString(&WinIniInfo, lpSection, lpKeyName, lpString);

        --fWriteOutProfilesReenter;

        return nReturn;
}


int API
IWritePrivateProfileString(lpSection, lpKeyName, lpString, lpFile)
LPSTR lpSection;
LPSTR lpKeyName;
LPSTR lpString;
LPSTR lpFile;
{
	PROINFO	*pProInfo;
	char	Buffer[128];
        int nReturn;

        /* Make sure we don't try to flush INI files on DOS calls */
        ++fWriteOutProfilesReenter;

	pProInfo = SetPrivateProInfo(lpFile, (LPSTR)Buffer);

        /* Reread INI file first if necessary */
        FlushDirtyFile(pProInfo);

	nReturn = WriteString(pProInfo, lpSection, lpKeyName, lpString);

        --fWriteOutProfilesReenter;

        return nReturn;
}


/*  FlushDirtyFile
 *      Rereads a file if it has been "dirtied" by another task.  To
 *      see if the file has been dirtied, we check the time/date
 *      stamp.
 */

void _fastcall FlushDirtyFile(PROINFO *pProInfo)
{
        FILEINFO FileInfo;
        DWORD dwSaveDTA;

        /* We only have to do this if the file COULD have changed and
         *      that we already have something cached.  Also, there's
         *      no need to do this at boot time because this is a
         *      safeguard against the USER doing something bad!
         */
        if (fBooting || !fProfileMaybeStale || !pProInfo->lpBuffer)
                return;

        /* The OFSTRUCT in the PROINFO buffer should have the most recent
         *  date and time when the file was opened.  We just compare the
         *  current date and time to this.
         */
        _asm
        {
        ;** Save old DTA and point to our structure
        mov     ah,2fh                  ;Get DTA.  Int21 code calls DOS only
        int     21h                     ;  if necessary.  DTA in ES:BX
        jc      RDF_FlushIt             ;Problem, so better flush it
        mov     WORD PTR dwSaveDTA[2],es ;Save for later
        mov     WORD PTR dwSaveDTA[0],bx
        mov     ah,1ah                  ;Set DTA
        push    ds                      ;Can't do a SetKernelDS so push/pop
        push    ss                      ;Get SS=DS
        pop     ds
        lea     dx,FileInfo             ;Point DTA to our structure
        int     21h                     ;Set the DTA
        pop     ds
        jc      RDF_FlushIt             ;Problem, so just flush it

        ;** Do a FindFirst on the file to get date and time reliably
        xor     cx,cx                   ;Normal file
        mov     si,pProInfo             ;Point to pathname with DS:DX
        lea     dx,[si].ProBuf
        add     dx,8                    ;(offset of szPathName)
        mov     ah,4eh                  ;Find first
        int     21h                     ;Call DOS
        jc      RDF_FlushIt             ;Can't find, so better flush it

        ;** Put DTA back
        push    ds
        lds     dx,dwSaveDTA            ;DS:DX points to old DTA
        mov     ah,1ah
        int     21h
        pop     ds

        ;** Compare the date and time
        lea     bx,FileInfo             ;Point to FILEINFO
        mov     dx,ss:[bx + 24]         ;Date in FILEINFO structure
        mov     cx,ss:[bx + 22]         ;Tile in FILEINFO structure
        mov     si,pProInfo             ;Point to OFSTRUCT with DS:SI
        lea     si,[si].ProBuf
    	cmp	[si + 4],dx		;Same date as original?
	jne	RDF_FlushIt             ;No
    	cmp	[si + 6],cx		;Same time as original?
	je	RDF_NoFlush             ;No
        }

        /* Force a file reread */
RDF_FlushIt:
        FreeBuffer(pProInfo);
RDF_NoFlush:

        /* Clear the dirty flag */
        fProfileMaybeStale = 0;
}


/*
 * SetPrivateProInfo
 *
 * Force a private profile into the windows directory if necessary.
 * Check if it is the same file as is currently cached.
 * If not, discard the cached file.
 * Sets up the PrivateProInfo data structure.
 *
 * Parameters:
 *	lpFile		Pointer to filename to be used as a profile
 *	Buffer		Buffer to parse filename into
 *
 * Returns:
 *	PROINFO *	Pointer to information about ini file
 */
PROINFO *
SetPrivateProInfo(lpFile, Buffer)
LPSTR lpFile;
LPSTR Buffer;
{
	OFSTRUCT NewFileBuf;
	char	c;
	char	fQualified = 0;
	char	BASED_ON_LP(lpFile) *psrc;
	int	Count = 0;

        /* Get rid of annoying warnings with this ugly cast */
        psrc = (char BASED_ON_LP(lpFile)*)(WORD)(DWORD)lpFile;

		/* For those who insist on using private routines for WIN.INI */
	if ( lstrOriginal(lpFile, (LPSTR)WinIniStr) == 0
	     || lstrOriginal(lpFile, WinIniInfo.ProBuf.szPathName) == 0 ) {
		return(&WinIniInfo);
	}

	/*
	 * Following code is from ForcePrivatePro
	 *
 	 * If the filename given is not qualified, we force
	 * it into the windows directory.
	 */
#ifdef FE_SB
_asm {
					;Apr.26,1990 by AkiraK
	cld
	push	ds			;save kernel DS
	xor	ax,ax
	mov	bx,'/' shl 8 + '\\'	; '/' or '\'
	xor	dx,dx
	lds	si,lpFile		; first get length of string
	mov	cx,si
	mov	al,ds:[si]
	call	FarMyIsDBCSLeadByte
	jnc	fpp_s1
	cmp	byte ptr ds:[si+1],':'	 ;
	jnz	fpp_s1
	inc	dx
fpp_s1:

fpp_l1:
	lodsb
	or	al,al
	jz	fpp_got_length
	cmp	al,bh
	jz	fpp_qualified
	cmp	al,bl
	jz	fpp_qualified
fpp_s2:
	call	FarMyIsDBCSLeadByte
	jc	fpp_l1
	inc	si
	jmp	fpp_l1

fpp_qualified:
	inc	dx
	jmp	fpp_s2
fpp_got_length:
;;	  mov	  fQualified, dx
	mov	fQualified, dl		    ; a byte variable
	sub	si, cx
	mov	Count, si
	pop	ds			    ;recover kernel DS
}
#else
			/* Drive specified? */
	if ( *(psrc+1) == ':' )
		fQualified++;
	while ( c = *psrc++ ) {
			/* Look for path separators */
		if ( c == '/' || c == '\\' )
			fQualified++;
		Count++;
	}
#endif

	/*
	 * Now copy filename to buffer.
	 * Prepend Windows directory if not qualified.
	 */
	_asm {
		cld
		push	ds
		les	di, Buffer		; Destination is Buffer
		cmp	fQualified, 0
		jnz	Qualified
		mov	cx, cBytesWinDir	; Pick up Windows directory
		lds	si, lpWindowsDir
		rep	movsb			; Copy it
		mov	al, '\\'
		cmp	es:[di-1], al		; BUG FIX: if in root, don't
		je	Qualified		;	   add separator
		stosb				; Add path separator
	Qualified:
		lds	si, lpFile		; Now add Filename we were given
		mov	cx, Count
		inc	cx			; Allow for NULL
		rep	movsb
		pop	ds
	}
#ifdef NOTNOW
	if ( !fBooting && fQualified ) {
			/*
			 * Use OpenFile to generate pathname for
			 * comparison with the cached pathname.
			 * OF_EXIST ensures we get a complete pathname
			 * We cannot use OF_PARSE, it does not search the path.
			 * We only do this if the pathname we were given was
			 * qualified since in other cases we force the file
			 * into the windows directory and therefore know
			 * that Buffer contains the complete pathname.
			 */
		NewFileBuf.szPathName[0] = 0;
		OpenFile(Buffer, &NewFileBuf, OF_EXIST);
	}
#endif
		/* Now see if the filename matches the cached filename */
	_asm {
		cld
		xor	cx, cx
		lea	si, word ptr [PrivateProInfo.ProBuf]	; Cached INI OFSTRUCT
		mov	cl, [si].cBytes
		lea	si, word ptr [si].szPathName	; Cached filename
		sub	cx, 8				; Get its length
	UseOriginal:				; Use the filename they gave us
		les	di, Buffer		; while booting
		xor	bl, bl
		call	strcmpi			; Ignore case while booting
		jmp	short DoWeDiscardIt
	JustCompare:
					; Not booting, compare OFSTRUCTS
					; Note OpenFile forced upper case
		push	ss
		pop	es		; NewFileBuf is on SS
		lea	di, word ptr NewFileBuf.szPathName[0];
		rep	cmpsb			; Compare filenames
	DoWeDiscardIt:
		jz	WeHaveItCached		; Don't discard if names match
	}
	/*
	 * The cached file is not the right one,
	 * so we discard the saved file.
	 */
	FreeBuffer(&PrivateProInfo);

WeHaveItCached:
		/* Save pointer to FileName - buffer may have been discarded */
	PrivateProInfo.lpProFile = Buffer;
	return(&PrivateProInfo);
}


/*
 * GetInt - search file and return an integer
 *
 * Parameters:
 *	pProInfo		Pointer to information on the INI file
 *	lpSection		Pointer to section to match in INI file
 *	lpKeyName		Pointer to key string to match in file
 *	nDefault		Default value to return if not found
 *
 * Returns:
 *	see GetProfileInt
 */
int
GetInt(pProInfo, lpSection, lpKeyName, nDefault)
PROINFO	*pProInfo;
LPSTR	lpSection;
LPSTR	lpKeyName;
int	nDefault;
{
	LPSTR lpResult;

	lpResult = FindString(pProInfo, lpSection, lpKeyName);
	if (lpResult) {
			/* We found a string, convert to int */
		register int c;
		int radix = 10;
		BOOL fNeg = FALSE;

        // Skip spaces
        while (*lpResult == ' ' || *lpResult == '\t')
            ++lpResult;

		nDefault = 0;

		while ((c = *lpResult++) != 0) {

			// Watch for change in sign
			//
			if (c == '-') {
				fNeg = !fNeg;
				continue;
			}

			// Lower case the character if it's a letter.
			//
			if (c >= 'A' && c <= 'Z')
				c += ('a' - 'A');

			// deal with hex constants
			//
			if (c == 'x') {
				radix = 16;
				continue;
			}

			c -= '0';
			if (c > 9)
			    c += '0' - 'a' + 10;

			if (c < 0 || c >= radix)
			    break;

			nDefault = nDefault * radix + c;
		}
		if (fNeg)
		    nDefault = -nDefault;
	}
	UnlockBuffer(pProInfo);
	return(nDefault);
}


/*
 * GetString -  Search file for a specific Section and KeyName
 *
 * Parameters:
 *	pProInfo		Pointer to information on the INI file
 *	lpSection		Pointer to section to match in INI file
 *	lpKeyName		Pointer to key string to match in file
 *	lpDefault		Default string to return if not found
 *	lpResult		String to fill in
 *	nSize			Max number of characters to copy
 *
 * Returns:
 *	see GetProfileString
 */
GetString(pProInfo, lpSection, lpKeyName, lpDefault, lpResult, nSize)
PROINFO	*pProInfo;
LPSTR	lpSection;
LPSTR	lpKeyName;
LPSTR	lpDefault;
LPSTR	lpResult;
int	nSize;
{
	int	nFound;
	LPSTR	lpFound;

	if ( !lpKeyName ) {
		nFound = GetSection(pProInfo, lpSection, lpResult, nSize);
		if ( nFound == -1 )
			goto	CopyDefault;	/* Yes, I know! */
	} else {
		lpFound = FindString(pProInfo, lpSection, lpKeyName);
		if ( lpFound )
			lpDefault = lpFound;
	CopyDefault:
	_asm	{
		xor	ax, ax				; Return value
		cmp	word ptr lpDefault[2], 0	; Check for null default
		je	SavedMe
		les	di, lpDefault
		call	MyStrlen		; Returns length in CX

                ; Fix for #10907  --  Used to GP fault on zero length str.
                or      cx,cx                   ; No characters in string?
                je      strdone

#ifdef	FE_SB
		; Get last character behind terminator
		push	si
		les	si, lpDefault		; SI = front of string
	gps_dbcs_l1:
		mov	al, es:[si]
		call	FarMyIsDBCSLeadByte
		cmc
		adc	si, 1
		cmp	si, di
		jb	gps_dbcs_l1
		pop	si
#else
		add	di, cx
		mov	al, es:[di-1]		; Final character in string
#endif
		les	di, lpDefault
		cmp	cx, 2		; strlen > 2
		jb	strdone
    					; Strip off single and double quotes
		mov	ah, es:[di]
		cmp	ah, al		; First character == last character?
		jne	strdone
		cmp	al, '\''
		je	strq
		cmp	al, '"'
		jne	strdone
	strq:
		sub	cx, 2		; Lose those quotes
		inc	di
	strdone:
					; CX has length of string
		mov	dx, nSize
		dec	dx		; Allow for null
		cmp	cx, dx		; See if enough room
		jbe	HaveRoom
		mov	cx, dx
	HaveRoom:
		cld
		push	ds
		push	es
		pop	ds
		mov	si, di		; DS:SI has string to return
		les	di, lpResult
		mov	ax, cx		; Save length of string
		rep	movsb		; Copy the string
		mov	byte ptr es:[di], 0	; Null terminate the string
		pop	ds
	SavedMe:
		mov	nFound, ax	; We will return this
		}
	}

	UnlockBuffer(pProInfo);
	return(nFound);
}


/*
 * GetSection - find a section and copy all KeyNames to lpResult
 *
 * Parameters:
 *	pProInfo		pointer to info on the file
 *	lpSection		pointer to the section name we want
 *	lpResult		where the KeyNames will go
 *	nSize			size of lpResult buffer
 *
 * Returns:
 *	int			Number of characters copied, -1 for failure
 */
int
GetSection(pProInfo, lpSection, lpResult, nSize)
PROINFO	*pProInfo;
LPSTR	lpSection;
LPSTR	lpResult;
int	nSize;
{
	LPSTR	lp;

	lp = BufferInit(pProInfo, READ);
	if ( !lp )
		return(-1);	/* No buffer, (no file, no memory etc.) */

	nSize--;		/* Room for terminating NULL */

	lp = FindSection(lp, lpSection);
	if ( !lp )
		return(-1);

	_asm {
		push	ds
		lds	si, lpResult	; DS:SI is where we store the result
		les	di, lp		; ES:DI points to the section in buffer
		xor	dx, dx		; Count of characters in the result
	KeyNameLoop:
		mov	bx, di		; Save start of line
		cmp	es:[di], ';'	; Is this a comment line?
		jne	KeyNameNextCh	;   no, check this line out
		cld
		mov	cx, -1
		mov	al, LINEFEED
		repne	scasb		; Skip to end of the line
		jmp	KeyNameLoop
	KeyNameNextCh:
		mov	al, es:[di]	; Get next character
#ifdef FE_SB
		call	FarMyIsDBCSLeadByte
		cmc			; if the char is lead byte of DBCS,
		adc	di, 1		;  then di += 2, else di += 1
#else
		inc	di
#endif
		cmp	al, '='
		je	FoundEquals
		cmp	al, LINEFEED
		je	KeyNameLoop	; Ignore lines without an '='
		cmp	al, SECT_LEFT
		je	EndSection	; Done if end of section
		or	al, al		;  or if end of buffer (NULL)
		jne	KeyNameNextCh	; On to the next character
		jmp	EndSection
	FoundEquals:
		mov	di, bx		; Back to the start of the line
	CopyLoop:
		mov	al, es:[di]	; Pick up next character in line
		inc	di
		cmp	al, '='		; Is it the '='?
		jne	LeaveItAlone
		xor	al, al		;   yes, replace with NULL
	LeaveItAlone:
		mov	[si], al	; Put it in the result string
		inc	dx		; Number of characters in the result
		inc	si
		cmp	dx, nSize	; Overflowed?
		jb	NoProblem
		dec	dx		;   yes, ignore this character
		dec	si
	NoProblem:
#ifdef FE_SB
		call	FarMyIsDBCSLeadByte
		jc	NoProblem1
		mov	al, es:[di]
		inc	di
		mov	[si], al
		inc	dx
		inc	si
		cmp	dx, nSize
		jb	NoProblem1
		dec	si
		dec	dx
	NoProblem1:
#endif
		or	al, al		; Was this the '='
		jne	CopyLoop
	SkipLine:
		mov	al, es:[di]	; Skip the rest of the line
		inc	di
		cmp	al, LINEFEED
		jne	SkipLine
		jmp	KeyNameLoop

	EndSection:
		mov	byte ptr [si], 0	; Terminate with NULL
		or	dx, dx			; Did we copy anything?
		jz	NothingFound		;  no, no hack
#ifdef FE_SB
;AnsiPrev API has been moved to USER and it is not the
;right time to invoke any USER's APIs as we might be called
;while USER is still on the bed.
;		push	dx
;		push	word ptr lpResult[2]
;		push	word ptr lpResult[0]
;		push	ds
;		push	si
;		call	AnsiPrev
;		mov	si, ax
;		mov	byte ptr [si], 0
;		mov	byte ptr [si+1], 0
;		pop	dx
;-----------------------------------------------------------
		push	es
		push	di
		push	bx
		les	di,lpResult		;string head
ScanLoop:
		mov	bx,di			;"prev" char position
		mov	al,es:[di]
                call    FarMyIsDBCSLeadByte
                cmc
		adc	di, 1			;+2 if DBCS, +1 if not
		cmp	di,si			;have we hit the point yet?
		jb	ScanLoop		;nope,
;The output of this routine looks like:
;<name 1>,0,<name2>,0,.... <name n>,0,0
; the very last 0 tells the end of story.
		mov	es:[bx],0		;this is safe
		mov	es:[bx+1],0		;Hmmmmm
		pop	bx
		pop	di
		pop	es
#else
		mov	byte ptr [si-1], 0	; Hack - if we hit nSize, we
#endif
						; and extra NULL
	NothingFound:
		pop	ds
		mov	nSize, dx
		}
	return(nSize);
}


/*
 * FindString - look for section name and key name
 *
 * Parameters:
 *	pProInfo		Pointer to info on the file
 *	lp			Pointer to the buffer containing the file
 *	lpSection		Pointer to the section name we are looking for
 *	lpKeyName		Pointer the the KeyName we want
 *
 * Returns:
 *	LPSTR			Pointer to the start of the result string
 *				NULL for failure
 */
LPSTR
FindString(pProInfo, lpSection, lpKeyName)
PROINFO	*pProInfo;
LPSTR	lpSection;
LPSTR	lpKeyName;
{
	LPSTR	lp;

	if ( lp = BufferInit(pProInfo, READ) )
		if ( lp = FindSection(lp, lpSection) )
			lp = FindKey(lp, lpKeyName);
	return(lp);
}


/*
 * FindSection - look for a section name enclosed in '[' and ']'
 *
 * Parameters:
 *	lp			Pointer to the buffer containing the file
 *	lpSection		Pointer to the section name we are looking for
 *
 * Returns:
 *	LPSTR			Pointer to the start of the section for success
 *				NULL for failure
 */
LPSTR
FindSection(lp, lpSection)
LPSTR	lp;
LPSTR	lpSection;
{
        WORD wCount;
        WORD wTrailCount;
        WORD fLead;
        LPSTR lpstr;
        WORD wSegLen;

        /* Remove leading whitespace from section names and compute
         *      a length count that doesn't include trailing whitespace.
         *      We use this below to force a TRUE compare even though
         *      the program put garbage on the end.
         */
        for (lpstr = lpSection, fLead = 1, wCount = wTrailCount = 0 ;
                *lpstr ; ++lpstr)
        {
                /* If we haven't passed leading space yet... */
                if (fLead)
                {
                        if (*lpstr == SPACE || *lpstr == TAB)
                                ++lpSection;
                        else
                        {
                                fLead = 0;
                                ++wCount;
                                ++wTrailCount;
                        }
                }

                /* Otherwise this might be trailing space... */
                else
                {
                        /* wCount always has correct count, wTrailCount
                         *      never counts whitespace until another
                         *      character is encountered.  This allows
                         *      a count of characters excluding trailing
                         *      whitespace.
                         */
                        ++wCount;
                        if (*lpstr != SPACE && *lpstr != TAB)
                                wTrailCount = wCount;
                }
        }
        wCount = wTrailCount;

	_asm {
                lsl     cx,WORD PTR lp[2] ; Get max possible search len
                mov     wSegLen,cx      ; Save for quick access later
		push	ds
		les	di, lp
	SectionLoop:
		cmp	byte ptr es:[di], SECT_LEFT	; ie '['
		jne	NotThisLine
		inc	di				; Skip the '['

                ;** Check the length of the string
                push    di              ; Save because we're going to trash
                mov     cx,wSegLen      ; Get segment length
                sub     cx,di           ; Subtract off the distance into seg
                mov     dx,cx           ; Save in DX
                mov     al,SECT_RIGHT   ; Stop when we encouter this
#ifdef	 FE_SB
;SECT_RIGHT is a legal DBCS second byte
;and we have to emulate DBCS "repne scasb" here.
        fsScanSectRight:
		dec	cx		;
                jz      fsScanFinish    ; reach to end of segment
		scasb			;
                je      fsScanFinish    ; find it!
                call    FarMyIsDBCSLeadByte
                jc      fsScanSectRight
                inc     di              ; skip DBCS 2nd byte
                dec     cx
                jnz     short fsScanSectRight
        fsScanFinish:

#else
                repne   scasb           ; Compare until we find it
#endif
                sub     dx,cx           ; Get true string len
                dec     dx
                pop     di
                cmp     dx,wCount       ; Same length?
                jne     NotThisLine

                ;** Now compare the strings.  Note that strcmpi returns a
                ;**     pointer just past the failed char
		lds	si, lpSection
                mov     bl, SECT_RIGHT                  ; Compare up to '['
		call	strcmpi
                je      HereItIs

                ;** Even if we failed, it might match less trailing whitespace
                sub     ax,di           ; Get length at first mismatch
                cmp     ax,wCount       ; Make sure we mismatched at end
                jne     NotThisLine     ; We didn't so get out
                add     di,ax           ; Bump pointers to end
                add     si,ax
                mov     al,es:[di - 1]  ; Compare last chars
                cmp     al,ds:[si - 1]  ; Do they match?
                jne     NotThisLine     ; Yes

        HereItIs:
		mov	al, LINEFEED	; Skip the rest of the line
		mov	cx, -1
		repne	scasb		; Scans ES:[DI]

		mov	ax, di
		mov	dx, es		; Return pointer to section
		jmp	FoundIt

	NotThisLine:
		mov	al, LINEFEED	; Skip the rest of the line
		mov	cx, -1		; Scans ES:[DI]
		repne	scasb

		cmp	byte ptr es:[di], 0		; End of the file?
		jne	SectionLoop			;  nope, continue
		xor	ax, ax
		xor	dx, dx				; Return 0
	FoundIt:
		pop	ds
		}
}


/*
 * FindKey - Find a KeyName given a pointer to the start of a section
 *
 * Parameters:
 *	lp			Pointer to start of a section
 *	lpKeyName		Pointer the the KeyName we want
 *
 * Returns:
 *	LPSTR			Pointer to the string following the KeyName
 *				NULL if KeyName not found
 */
LPSTR
FindKey(lp, lpKeyName)
LPSTR	lp;
LPSTR	lpKeyName;
{
        WORD wCount;
        WORD wTrailCount;
        WORD fLead;
        LPSTR lpstr;
        WORD wSegLen;

        /* Remove leading whitespace from key names and compute
         *      a length count that doesn't include trailing whitespace.
         *      We use this below to force a TRUE compare even though
         *      the program put garbage on the end.
         */
        for (lpstr = lpKeyName, fLead = 1, wCount = wTrailCount = 0 ;
                *lpstr ; ++lpstr)
        {
                /* If we haven't passed leading space yet... */
                if (fLead)
                {
                        if (*lpstr == SPACE || *lpstr == TAB)
                                ++lpKeyName;
                        else
                        {
                                fLead = 0;
                                ++wCount;
                                ++wTrailCount;
                        }
                }

                /* Otherwise this might be trailing space... */
                else
                {
                        /* wCount always has correct count, wTrailCount
                         *      never counts whitespace until another
                         *      character is encountered.  This allows
                         *      a count of characters excluding trailing
                         *      whitespace.
                         */
                        ++wCount;
                        if (*lpstr != SPACE && *lpstr != TAB)
                                wTrailCount = wCount;
                }
        }
        wCount = wTrailCount;

	_asm	{
		push	ds
		mov	ax, word ptr lpKeyName
		or	ax, word ptr lpKeyName[2]
		jz	NoMatch		; Return zero if lpKeyName is 0
                lsl     cx,WORD PTR lp[2] ; Get max possible search len
                mov     wSegLen,cx      ; Save for quick access later
		les	di, lp

                ;** See if we're at the end of the section
	FindKeyNext:
		mov	al,es:[di]	; Get next character
		or	al,al
		jz	NoMatch		; End of the file
		cmp	al,SECT_LEFT
		je	NoMatch		; End of the section
                cmp     al,CR           ; Blank line?
                je      NotThisKey      ; Yes, skip this one

                ;** Check the length of the string
                push    di              ; Save because we're going to trash
                mov     cx,wSegLen      ; Get segment length
                sub     cx,di           ; Subtract off the distance into seg
                mov     dx,cx           ; Save in DX
                mov     al,'='          ; Stop when we encouter this
                repne   scasb           ; Compare until we find it
                sub     dx,cx           ; Get true string len
                dec     dx
                pop     di
                cmp     dx,wCount       ; Same length?
                jne     NotThisKey

                ;** Now compare the strings.  Note that strcmpi returns a
                ;**     pointer just past the failed char.
                mov     bl,'='          ; Compare until we hit this
		lds	si,lpKeyName
		call	strcmpi
                mov     bx,di           ; Save DI value for below
                mov     di,ax
                je      FoundKey

                ;** Even if we failed, it might match less trailing whitespace
                sub     ax,bx           ; Get length at first mismatch
                cmp     ax,wCount       ; Make sure we mismatched at end
                jne     NotThisKey      ; Lengths at mismatch must match
                add     bx,ax           ; Bump pointers to end
                add     si,ax
                mov     al,es:[bx - 1]  ; Get last char that should match
                cmp     al,ds:[si - 1]  ; Does it match?
                je      FoundKey        ; Yes

        NotThisKey:
		mov	al, LINEFEED
		mov	cx, -1
		repne	scasb		; Scan to the end of the line
		jmp	FindKeyNext

	NoMatch:
		xor	ax, ax
		xor	dx, dx
		jmp	AndReturn
	FoundKey:
		inc	di		; Skip the '='
		mov	ax, di		; Return the pointer
		mov	dx, es
	AndReturn:
		pop	ds
		}
}


/*
 * MyStrlen - returns length of a string excluding trailing spaces and CR
 *
 * Paremeters:
 *	ES:DI			pointer to string
 *
 * Returns:
 *	CX			number of characters in string
 *
 */
int
MyStrlen()
{
_asm	{
; SPACE, CR, NULL never in DBCS lead byte, so we are safe here
	push	ax
	mov	cx, di		; CX = start of string
	dec	di
str1:
	inc	di
	mov	al, es:[di]	; Get next character
	cmp	al, CR
	ja	str1		; Not CR or NULL
str2:
	cmp	di, cx		; Back at the start?
	jbe	str3		;  yes
	dec	di		; Previous character
	cmp	byte ptr es:[di], SPACE
	je	str2		; skip spaces
	inc	di		; Back to CR or NULL
str3:
	cmp	es:[di], al
	je	maybe_in_code	; PMODE hack
	mov	es:[di], al	; Zap trailing spaces
maybe_in_code:
	neg	cx		; Calculate length
	add	cx, di
	pop	ax
	}
}


/*
 * Cstrlen - returns length of a string excluding trailing spaces and CR
 *	     This is a C callable interface to MyStrLen
 *
 * Paremeters:
 *	lp			pointer to string
 *
 * Returns:
 *	number of characters in string
 *
 */
int
Cstrlen(lp)
LPSTR	lp;
{
_asm	{
	xor	di, di		; Persuade compiler to save DI
	les	di, lp
	call	MyStrlen
	mov	ax, cx
	}
}


/*
 * strcmpi - internal case insensitive string compare
 *
 * Parameters:
 *	ES:DI & DS:SI		Strings to be compared
 *	BL			Character to terminate on
 *				DS:SI is null terminated
 *
 * Returns:
 *	ZF			indicates strings equal
 *	AX			pointer to next character in ES:DI string
 *                              or failed character in case of mismatch
 */
void
strcmpi()
{
_asm	{
#ifdef FE_SB
					;Apr.26,1990 by AkiraK
					; Copied directly from USERPRO.ASM
sti_l1:
	mov	al,es:[di]
	cmp	al,bl
	jz	sti_s1

	call	FarMyLower
	mov	cl,al

	mov	al,ds:[si]
	call	FarMyLower

	inc	si
	inc	di

	cmp	al,cl
	jnz	sti_exit

	call	FarMyIsDBCSLeadByte
	jc	sti_l1

	mov	al,es:[di]
	cmp	al,ds:[si]
	jnz	sti_exit

	inc	si
	inc	di
	jmp	short sti_l1

sti_s1:
	mov	al,ds:[si]
	or	al,al
sti_exit:
	mov	ax, di
#else
stci10:
	mov	al,es:[di]		; Get next character
	cmp	al,bl			; Character to terminate on?
	jnz	stci15			;  no, compare it
	mov	al,[si]			;  yes, strings equal if at end
	or	al,al
	jmp	stciex
stci15:
	call	FarMyLower		; Ensure both characters lower case
	mov	cl,[si]
	xchg	al,cl
	call	FarMyLower
	inc	si
	inc	di
	cmp	al,cl			; Still matching chars?
	jz	stci10			; Yes, go try the next char.
stciex:
	mov	ax,di			; Return pointer to next character
#endif
	}
}


/*
 * BufferInit
 *
 * Parameters:
 *	pProInfo		Pointer to structure describing an INI file
 *	OpenFlags		READ_WRITE if we are writing to the file
 *
 * Returns:
 *	Pointer to start of buffer on success
 *	(LPSTR)0		Failure
 *
 * Open or create the INI file as necessary
 * Get a buffer in memory for the file
 * Read the INI file into the buffer
 * Strip unwanted spaces comments and ^Zs from the buffer
 */
LPSTR _fastcall
BufferInit(pProInfo, OpenFlags)
PROINFO *pProInfo;
int	OpenFlags;
{
	LPSTR	BufAddr;
	long	llen;
	unsigned short	len;
	int	fh;
	int	hNew;
        BYTE byLastDrive;               /* Cache last drive read from */

		/* Ensure we have a handle for the buffer */
	if ( pProInfo->hBuffer == 0 )
		return(0L);
		/* If the buffer is already filled, return */
	if ( (BufAddr = LockBuffer(pProInfo)) != (LPSTR)NULL )
		return(BufAddr);

	pProInfo->ProFlags = 0;

        /* Remember the last drive read from to see if we have to reread
	 * the cluster size.
	 */
	byLastDrive = *pProInfo->ProBuf.szPathName;

	if ( pProInfo == &PrivateProInfo ) {
		/* Open a PRIVATE profile */
		fh = OpenFile(pProInfo->lpProFile, &pProInfo->ProBuf, READ_WRITE+OF_SHARE_DENY_WRITE);
		if ( fh == -1 ) {
			/* Attempt to open for read. */
			if ( !OpenFlags ){
				pProInfo->ProFlags |= PROREADONLY;
				fh = OpenFile(pProInfo->lpProFile, &pProInfo->ProBuf, READ+OF_SHARE_DENY_WRITE);
				/* If this fails, try compatibility mode. */
				if ( (fh == -1) && (pProInfo->ProBuf.nErrCode == SHARINGVIOLATION) ){
					fh = OpenFile(pProInfo->lpProFile, &pProInfo->ProBuf, READ);
				}
			}else{
			/* If the open failed and we are writing, silently create the file.
			 * If the open failed because of sharing violation, try compatibility mode instead.
			 */
				if ( pProInfo->ProBuf.nErrCode != SHARINGVIOLATION ){
					OpenFlags |= OF_CREATE;
				}
				fh = OpenFile(pProInfo->lpProFile, &pProInfo->ProBuf, OpenFlags);
			}
		}
	} else {
		/* Open WIN.INI */
		if ( OpenFlags )
			OpenFlags |= OF_CREATE;
		if ( pProInfo->ProBuf.cBytes ) {
				/* If previously found, reopen, don't create */
			OpenFlags |= OF_REOPEN+OF_PROMPT|OF_CANCEL|OF_SHARE_DENY_WRITE;
			OpenFlags &= ~OF_CREATE;
		}
		fh = OpenFile(pProInfo->lpProFile, &pProInfo->ProBuf, OpenFlags|READ_WRITE);
		if ( (fh == -1) && !(OpenFlags & (READ_WRITE|OF_CREATE)) ) {
			pProInfo->ProFlags |= PROREADONLY;
			fh = OpenFile(pProInfo->lpProFile, &pProInfo->ProBuf, OpenFlags+OF_SHARE_DENY_WRITE);
		}
		/* Sharing violation.  Let's try compatibility mode. */
		if ( (fh == -1) && ( pProInfo->ProBuf.nErrCode == SHARINGVIOLATION ) ){
			OpenFlags &= ~OF_SHARE_DENY_WRITE;
			fh = OpenFile(pProInfo->lpProFile, &pProInfo->ProBuf, OpenFlags);
		}
	}
	pProInfo->FileHandle = fh;

	/* If we are using a different drive than the last call or this is
	 *      the first time, clear cluster size so we reread it on next
	 *      call to WriteString.
	 */
	if (byLastDrive != *pProInfo->ProBuf.szPathName)
		pProInfo->wClusterSize = 0;

	if ( fh == -1 )
		goto ReturnNull;

		/* Seek to end of file, allow for CR, LF and NULL */
	llen = _llseek(fh, 0L, 2);
	if (!llen)
		pProInfo->ProFlags |= PRO_CREATED;
	llen += 3;
	if ( llen > MAXBUFLEN )
		llen = MAXBUFLEN;	/* Limit to plenty less than 64k */

			/* Now get a buffer */
	hNew = IGlobalReAlloc(pProInfo->hBuffer, llen, GMEM_ZEROINIT);
	if ( !hNew ) {
	ReturnNull:
		return( pProInfo->lpBuffer = (LPSTR)0 );
	}

		/* And now read in the file */
	pProInfo->hBuffer = hNew;
	LockBuffer(pProInfo);
	_llseek(fh, 0L, 0);			/* Seek to beginning of file */
	*(int _far *)pProInfo->lpBuffer = 0x2020;	/* Bogus spaces */

	len = _lread(fh, pProInfo->lpBuffer, (short)llen-3);
	if ( len == -1 ) {
		UnlockBuffer(pProInfo);
		return( FreeBuffer(pProInfo) );
	}
	if ( len < 2 )
		len = 2;		/* Prevent faults in PackBuffer */
	return( PackBuffer(pProInfo, len, OpenFlags & READ_WRITE) );
}


/*
 * LockBuffer - Lock the buffer containing the file.  Make it
 *		moveable and non-discardable.
 *      Instead of locking the buffer, we're just going to make it
 *      non-discardable and moveable.  This is preferable to locking it
 *      because all we really care about is that it doesn't get discarded.
 *
 * Parameter:
 *	pProInfo		Pointer to info describing INI file
 *
 * Returns:
 *	LPSTR			Pointer to buffer containing file
 */
LPSTR _fastcall
LockBuffer(pProInfo)
PROINFO *pProInfo;
{
    /* We only have to lock the block if it's marked dirty.  Otherwise
     *  it's already unlocked.
     */
    if (!(pProInfo->ProFlags & PROUNCLEAN))
    {
        /* Make the block non-discardable */
        IGlobalReAlloc(pProInfo->hBuffer, 0L,
            GMEM_MODIFY + GMEM_MOVEABLE);

        /* All we need here is to dereference the handle.  Since
         *  this block is now non-discardable, this is all that
         *  IGlobalLock() really does.
         */
        pProInfo->lpBuffer = IGlobalLock(pProInfo->hBuffer);
        IGlobalUnlock(pProInfo->hBuffer);
    }

    return pProInfo->lpBuffer;
}


/*
 * UnlockBuffer - unlock the buffer, make it discardable and close the file.
 *    We don't really have to unlock the buffer (we weren't before anyway
 *    even though the comment says so)
 *
 * Parameter:
 *	pProInfo		Pointer to info describing INI file
 *
 * Returns:
 *	nothing
 */
void _fastcall
UnlockBuffer(pProInfo)
PROINFO *pProInfo;
{
    int fh;

    if (!(pProInfo->ProFlags & PROUNCLEAN))
        IGlobalReAlloc(pProInfo->hBuffer, 0L, GMEM_DISCARDABLE+GMEM_MODIFY);
    fh = pProInfo->FileHandle;
    pProInfo->FileHandle = -1;
    if (fh != -1)
        _lclose(fh);
}


/*
 * FreeBuffer - discards the CONTENTS of a buffer containing an INI file
 *
 * Parameter:
 *	pProInfo		Pointer to info describing INI file
 *
 * Returns:
 *	(LPSTR)0
 */
LPSTR _fastcall
FreeBuffer(pProInfo)
PROINFO *pProInfo;
{
	if ( pProInfo->ProFlags & PROUNCLEAN )
		WriteOutProfiles();
		/* Make the buffer discardable */
	IGlobalReAlloc(pProInfo->hBuffer, 0L, GMEM_DISCARDABLE+GMEM_MODIFY);

		/* Make it zero length, shared, moveable and below the line */
	IGlobalReAlloc(pProInfo->hBuffer, 0L, GMEM_MOVEABLE);

	pProInfo->ProFlags = 0;
	return( pProInfo->lpBuffer = (LPSTR)0 );
}


/*
 * PackBuffer - strip blanks comments and ^Zs from an INI file
 *
 * Parameters:
 *	pProInfo		Pointer to info describing INI file
 *	Count			Number of characters in the buffer
 *	writing			Flag indicating we are writing to the file
 *
 * Returns:
 *	LPSTR			Pointer to the packed buffer
 *
 * NOTE: The use of Count here is DUMB.  We should stick a NULL
 *	 at the end, check for it and toss all the checks on Count.
 */
LPSTR _fastcall
PackBuffer(pProInfo, Count, fKeepComments)
PROINFO	*pProInfo;
int	Count;
int	fKeepComments;
{
        LPSTR	Buffer;
	char	BASED_ON_LP(Buffer) *psrc;
	char	BASED_ON_LP(Buffer) *pdst;
	char	BASED_ON_LP(Buffer) *LastValid;
	char	nextc;

        Buffer = pProInfo->lpBuffer;
	psrc = pdst = (char BASED_ON_LP(Buffer)*)(WORD)(DWORD)Buffer;

	if ( WinFlags & WF_PMODE )
		fKeepComments = 1;

	if ( fKeepComments )
		pProInfo->ProFlags |= PROCOMMENTS;

	while ( Count ) {
			/* Strip leading spaces and tabs */
		nextc = *psrc;
		if ( nextc == SPACE || nextc == TAB ) {
/* TAB or SPACE never in lead byte of DBCS, so loop is safe */
			Count--;
			psrc++;
			continue;
		}

			/* Process non-blanks */
		LastValid = pdst;
		do {
			nextc = *psrc++;
			Count--;
				/* Strip comments if real mode and not writing */
			if ( nextc == ';' && !fKeepComments ) {
				while ( Count && nextc != LINEFEED ) {
/* LINEFEED never in lead byte of DBCS, so loop is safe */
					nextc = *psrc++;
					Count--;
				}
				break;
			}
				/* Copy this character */
			*pdst++ = nextc;
#ifdef	FE_SB
			if ( Count && CIsDBCSLeadByte(nextc) ) {
				*pdst++ = *psrc++;
				Count--;
			}
#endif
			if ( nextc ==  '=' ) {
					/* Skip preceeding spaces and tabs */
				pdst = LastValid;
					/* New home for the '=' */
				*pdst++ = nextc;
					/* Skip spaces and tabs again */
				while ( Count ) {
					nextc = *psrc;
					if ( nextc != SPACE && nextc != TAB )
						break;
					Count--;
					psrc++;
				}
					/* Copy remainder of line */
				while ( Count ) {
					Count--;
/* LINEFEED never in lead byte of DBCS, so loop is safe */
					if ( (*pdst++ = *psrc++) == LINEFEED )
						break;
				}
				break;
			}

				/* End of file or line? */
			if ( Count == 0 || nextc == LINEFEED )
				break;

				/* Strip trailing spaces */
			if ( nextc == SPACE || nextc == TAB )
				continue;

			LastValid = pdst;
		} while ( Count );
			/* Here if end of line or file */
	}
		/* Here if end of file; skip trailing ^Zs */
	for ( ; ; ) {
		if ( pdst == Buffer )
			break;
		if ( *--pdst != CTRLZ ) {
			pdst++;
			break;
		}
	}

	*pdst++ = CR;
	*pdst++ = LINEFEED;
	*pdst++ = 0;

	IGlobalUnlock(pProInfo->hBuffer);
	IGlobalReAlloc(pProInfo->hBuffer, (long)((LPSTR)pdst - Buffer), 0);
	Buffer = LockBuffer(pProInfo);
	pProInfo->BufferLen = (unsigned)pdst;
	return(Buffer);
}


#ifdef FE_SB
/*
 * C interface to FarMyIsDBCSLeadByte
 *
 * Parameter:
 *	c		character to be tested
 *
 * Returns:
 *	1		It is a lead byte
 *	0		It isn't a lead byte
 */
CIsDBCSLeadByte(c)
char c;
{
_asm {
	mov	al, c
	call	FarMyIsDBCSLeadByte
	cmc			; Set carry if lead byte
	mov	ax, 0		; Set return value to 0, preserve flags
	adc	al, 0		; Set to one if carry set
}
}
#endif


/*
 * WriteString
 *
 * Adds/deletes sections/lines in an INI file
 *
 * Parameters:
 *	pProInfo		pointer to info on the file
 *	lpSection		pointer to the section name we want
 *	lpKeyName		key name to change or add
 *				NULL means delete section
 *	lpString		string to add to file
 *				NULL means delete line
 *
 * Returns:
 *	bResult			Success/Fail
 */
WriteString(pProInfo, lpSection, lpKeyName, lpString)
PROINFO	*pProInfo;
LPSTR	lpSection;
LPSTR	lpKeyName;
LPSTR	lpString;
{
	LPSTR	ptrTmp;
	short	WhatIsMissing;
	short	nchars;
	short	fh;
	long	fp;
	short	SectLen = 0;
	short	KeyLen = 0;
	short	ResultLen = 0;
	SEGMENT BufferSeg;
	register char BASED_ON_SEG(BufferSeg) *bp;

	/* Debugging noise */
		/* Assert that we have something to do! */
	if ( (SEGMENT)lpSection == NULL && (SEGMENT)lpKeyName == NULL
	     && (SEGMENT)lpString == NULL ) {
		FreeBuffer(pProInfo);	/* FEATURE! */
		return(0);
	}

		/* If buffer does not already contain comments, free it */
	if ( !(pProInfo->ProFlags & PROCOMMENTS) )
		FreeBuffer(pProInfo);

		/* Read the file into a buffer, preserving comments */
	ptrTmp = BufferInit(pProInfo, READ_WRITE);
	if ( !ptrTmp )
		return(0);

		/* Abort now if read only file */
	if ( pProInfo->ProFlags & PROREADONLY )
                goto GrodyError;

		/* Set bp to point in buffer where we will add stuff */
	BufferSeg = (SEGMENT)ptrTmp;
	bp = pProInfo->BufferLen + (char BASED_ON_SEG(BufferSeg)*)
                (WORD)(DWORD)ptrTmp - 1;

	/*
	 * Now see what we have to do to the file by
	 * searching for section and keyname.
	 */
	nchars = 0;

		/* See if section exists */
	if ( !(ptrTmp = FindSection(ptrTmp, lpSection)) ) {
			/* No Section. If deleting anything, stop now */
		if ( !lpKeyName || !lpString )
			goto NothingToDo;
			/* Need to add section and keyname */
		WhatIsMissing = NOSECTION;
	} else {
			/* Found the section, save pointer to it */
		bp = (char BASED_ON_SEG(BufferSeg)*)(WORD)(DWORD)ptrTmp;
			/* If lpKeyName NULL, delete the section */
		if ( !lpKeyName ) {
			WhatIsMissing = REMOVESECTION;
		} else {
				/* Look for the keyname in the section */
			if ( !(ptrTmp = FindKey(bp, lpKeyName)) ) {
					/* No KeyName, stop if deleting it */
				if ( !lpString )
					goto NothingToDo;
				WhatIsMissing = NOKEY;
					/* Insert new keyname
					   at the end of the section */
				while ( *bp && (*bp != SECT_LEFT || *(bp-1) != LINEFEED) )
					bp++;
			} else {
					/* Found the keyname, save pointer */
				bp = (char BASED_ON_SEG(BufferSeg)*)
                                        (WORD)(DWORD)ptrTmp;
					/* NULL lpString means delete it */
				if ( !lpString )
					WhatIsMissing = REMOVEKEY;
				else {
					/*
					 * Compare the existing string with the
					 * string we are supposed to replace it
					 * with.  If they are the same, there
					 * is no need to rewrite the file, so
					 * we abort now.
					 */
					if ( !IsItTheSame((LPSTR)bp, lpString) )
						goto NothingToDo;

					/*
					 * Count characters in old result.
					 * The file will be shrinking by
					 * this many characters.
					 */
					while ( *bp++ != CR )
						nchars--;
					bp = (char BASED_ON_SEG(BufferSeg)*)
                                                (WORD)(DWORD)ptrTmp;
					WhatIsMissing = NEWRESULT;
				}
			}
		}
	}

	/*
	 * If we will be adding to the file, grow the buffer
	 * to the size we will need, then make an appropriate
	 * sized hole in the buffer.
	 */
	switch ( WhatIsMissing ) {

	case NOSECTION:
			/* Need to add section */
		SectLen = Cstrlen(lpSection);
		nchars = SectLen + 4;	/* for []<CR><LF> */
			/* Fall through for KeyName and result */

	case NOKEY:
			/* Need to add key name */
		KeyLen = Cstrlen(lpKeyName);
		nchars += KeyLen + 3;	/* for =<CR><LF> */

			/* For new key or section, skip back to previous line */
		while ( bp > pProInfo->lpBuffer ) {
			bp--;
			if ( *bp != CR && *bp != LINEFEED )
				break;
		}
		if ( bp != pProInfo->lpBuffer )
			bp += 3;
			/* Fall through for result */

                /* If not at start of buffer, add room for extra CR/LF */
                if ((WORD)bp && WhatIsMissing == NOSECTION)
                        nchars += 2;

	case NEWRESULT:
			/* Need to change/add result */
			/* nchars may be -<current length of result> */
		ResultLen = Cstrlen(lpString);
		nchars += ResultLen;

			/* Grow the buffer if necessary */
		if ( nchars > 0 ) {
			IGlobalUnlock(pProInfo->hBuffer);

			fp = nchars + (long)pProInfo->BufferLen;
				/* Ensure buffer will be plenty less than 64k */
				/* and grow to new size */
			if ( fp > MAXBUFLEN || !IGlobalReAlloc(pProInfo->hBuffer, fp, 0) ) {
				/* Undo above Unlock */
				IGlobalLock(pProInfo->hBuffer);
                                goto GrodyError;
			}
			pProInfo->lpBuffer = IGlobalLock(pProInfo->hBuffer);
			BufferSeg = (SEGMENT)pProInfo->lpBuffer;
		}

                /* In order to fix bug #4672 and other ugly things
                 *      that happen when we run out of disk space,
                 *      we want to see if there is room to write the
                 *      buffer.  We know that the file can actually only
                 *      grow on cluster boundaries, but rather than get
                 *      the cluster size.  If we don't have the cluster
                 *      size yet, we have to get it from DOS.
                 */
                if (!pProInfo->wClusterSize)
                {
                        WORD wTemp;

                        /* Get drive letter */
                        wTemp = *pProInfo->ProBuf.szPathName - 'A' + 1;
                        _asm
                        {
                                mov     ah,1ch  ;Drive parameters
                                mov     dl,BYTE PTR wTemp
                                push    ds
                                int     21h
                                pop     ds
                                cmp     al,0ffh ;Error?
                                jnz     DPOk    ;No
                                mov     al,1
                                mov     cx,512  ;Default
                        DPOk:   cbw             ;Secs per cluster WORD
                                mul     cx      ;AX = bytes/cluster
                                mov     wTemp,ax
                        }
                        if (!wTemp)
                                pProInfo->wClusterSize = 512;
                        else
                                pProInfo->wClusterSize = wTemp;
                }

                /* Now see if we're going past a cluster length */
                if ((pProInfo->ProFlags & PRO_CREATED) ||
                        (((pProInfo->BufferLen + nchars) ^ pProInfo->BufferLen)
                        & ~(pProInfo->wClusterSize - 1)))
                {
                        int fh;

                        /* Make sure that we only do this once for a newly-
			 *      created file because this will handle the
                         *      growing to one cluster case.
                         */
                        pProInfo->ProFlags &= ~PRO_CREATED;
                        fh = pProInfo->FileHandle;

                        /* Make sure the file is open and exists.  If not,
                         *      we have to open the file.  We are guaranteed
                         *      at least that the file exists in this case.
                         *      Note that UnlockBuffer closes the file
                         *      that we open here.
                         */
                        if (fh == -1)
                        {
				fh = OpenFile(pProInfo->lpProFile,&pProInfo->ProBuf,OF_REOPEN+READ_WRITE+OF_SHARE_DENY_WRITE);
                                /* Sharing violation.  Let's try compabitility mode. */
				if ( (fh == -1) && (pProInfo->ProBuf.nErrCode == SHARINGVIOLATION ) ){
					fh = OpenFile(pProInfo->lpProFile,&pProInfo->ProBuf,OF_REOPEN+READ_WRITE);
				}
				pProInfo->FileHandle = fh;
                        }

                        /* Try to grow the file to the right length */
                        if(_llseek(fh, pProInfo->BufferLen + nchars, 0) !=
                                pProInfo->BufferLen + nchars ||
                                _lwrite(fh, " ", 1) != 1)
                                goto GrodyError;
                }

                /* Now, make room in the buffer for this new stuff */
		if ( nchars )
			MakeRoom((LPSTR)bp, nchars, &pProInfo->BufferLen);

			/* Now copy in the new info */
		switch ( WhatIsMissing ) {
		case NOSECTION:
				/* Create the new section */
			(int)bp = InsertSection((LPSTR)bp, lpSection, SectLen);
			/* FALL THROUGH */

		case NOKEY:
			(int)bp = InsertKey((LPSTR)bp, lpKeyName, KeyLen);
			/* FALL THROUGH */

		case NEWRESULT:
			(int) bp = InsertResult((LPSTR)bp, lpString, ResultLen);
		}
		break;

		/* Handle deleting sections or KeyNames */
	case REMOVESECTION:
		DeleteSection((LPSTR)bp, pProInfo);
		break;

	case REMOVEKEY:
		DeleteKey((LPSTR)bp, pProInfo);
		break;
	}

	pProInfo->ProFlags |= PROUNCLEAN;
	fProfileDirty = 1;

NothingToDo:
	UnlockBuffer(pProInfo);
	return(1);

        /* I really hate the GOTO, but in order to clean up, this is much
         *      more efficient...
         */
GrodyError:
        UnlockBuffer(pProInfo);
        return 0;
}


/*
 * WriteOutProfiles
 *
 * Called on a task switch or at exit time
 *
 * If we have a dirty profile buffer, write it.
 */
void API
WriteOutProfiles(void)
{
	LPSTR	ptrTmp;
	int	fh;
	PROINFO	*pProInfo;
     	int	nwritten;

        /* Make sure that we don't get called through a DOS call.  This
         *      flag is tested in I21ENTRY.ASM in the Int 21h hook to see
         *      if the profiles should be flushed.
         */
        ++fWriteOutProfilesReenter;

	for ( pProInfo = &WinIniInfo; ; pProInfo = &PrivateProInfo ) {
		if ( !(pProInfo->ProFlags & PROUNCLEAN) )
			goto NoWrite;
		if (
/* Try read/write with sharing flags, then try compabitility mode, then try to create it. */
			( (fh = OpenFile(NULL, &pProInfo->ProBuf, OF_REOPEN | READ_WRITE | OF_SHARE_DENY_WRITE)) == -1)
			&& ( (fh = OpenFile(NULL, &pProInfo->ProBuf, OF_REOPEN | READ_WRITE)) == -1)
			&& ( (fh = OpenFile(NULL, &pProInfo->ProBuf, OF_REOPEN | OF_CREATE)) == -1) ){
				goto NoWrite;
			}
		pProInfo->FileHandle = fh;

			/* Finally write the file */
		ptrTmp = pProInfo->lpBuffer;
		nwritten = _lwrite(fh, ptrTmp, pProInfo->BufferLen-3);
		if ( nwritten == pProInfo->BufferLen-3 ) {
			_lwrite(fh, ptrTmp, 0);		/* Mark end of file */
			pProInfo->ProFlags &= ~(PROUNCLEAN | PRO_CREATED);
			UnlockBuffer(pProInfo);
		} else {
			_lclose(fh);
		}
	NoWrite:
		if ( pProInfo == &PrivateProInfo )
			break;
	}
	fProfileDirty = 0;

	--fWriteOutProfilesReenter;
}


/*
 * See if two character strings are the same.
 * Special routine since one is terminated with <CR>.
 * Returns zero if the strings match.
 */
IsItTheSame(CRstring, NullString)
LPSTR CRstring;
LPSTR NullString;
{
_asm {
	push	ds
	les	di, CRstring		; CR terminated string
	lds	si, NullString		; Null terminated string
	xor	ah, ah			; High byte of return value
stci10:
	mov	al,es:[di]		; Get next character
	cmp	al,0Dh			; CR?
	jnz	stci15			;  no, compare it
	mov	al,[si]			;  yes, strings equal if at end
	jmp	stciex
stci15:
	mov	cl,[si]
	inc	si
	inc	di
	cmp	al,cl			; Still matching chars?
	jz	stci10			; Yes, go try the next char.
	mov	al, 1			; Didn't match
stciex:
	pop	ds
}
}


/*
 * Create or close a hole in the buffer.
 * Used to create room for a new section,
 * keyname or result and to remove unwanted
 * sections, keynames or results.
 *
 * Parameters:
 *	lp		position in buffer to add/remove characters
 *	nchars		number of characters to add/remove
 *	pAdjust		pointer to variable containing current
 *			size of the buffer
 *
 * Side effects:
 *	*pAdjust is changed by nchars
 *
 * Returns:
 *	nothing
 */
MakeRoom(lp, nChars, pAdjust)
LPSTR	lp;
short	nChars;
int	*pAdjust;
{
	short	BufLen = *pAdjust;

	if ( nChars < 0 )
	_asm {
		push	ds
		les	di, lp			; Where characters will be taken
		push	es
		pop	ds
		mov	si, di			; End of area
		sub	si, nChars		; Remember nChars is negative
		mov	cx, BufLen
		sub	cx, si			; Calculate # characters to move
		cld
		rep	movsb			; Copy characters down
		pop	ds
	} else _asm {
		push	ds
		mov	es, word ptr lp[2]	; Get segment to copy in
		mov	ds, word ptr lp[2]
		mov	si, BufLen		; We will be moving backwards
		mov	cx, si
		dec	si			; Adjust pointer for move
		mov	di, si			; so start at end of the buffer
		sub	cx, word ptr lp		; Number of characters to move
		add	di, nChars
		std				; Backwards move
		rep	movsb			; Copy characters up
		cld
		pop	ds
	}
	*pAdjust += nChars;
}


/*
 * Delete a section from the buffer,
 * preserving comments since they may
 * relate to the next section
 *
 * Parameters:
 *	lp			pointer to section returned by FindSection
 *	pProInfo		pointer to INI file info
 *
 * Returns:
 *	nothing
 */
DeleteSection(lp, pProInfo)
LPSTR	lp;
PROINFO *pProInfo;
{
	int	nRemoved;
	char BASED_ON_LP(lp) *SectEnd;

	_asm {
		cld
		push	ds
		lds	si, lp
	BackToStart:
		dec	si		; Skip backwards to start of the section
		cmp	ds:[si], SECT_LEFT
		jne	BackToStart

		mov	di, si
		push	ds
		pop	es		; ES:DI points to start of section
		inc	si		; DS:SI points to the '[', skip it
	RemoveLoop:
		lodsb			; Get next character in section
		cmp	al, ';'		; Is it a comment
		jne	NotComment

	CopyComment:
		stosb			; Save this character
		cmp	al, LINEFEED	; Copy to end of the line
		je	RemoveLoop
		lodsb			; And get the next one
		jmp	CopyComment

	NotComment:
		cmp	al, SECT_LEFT	; So is it the next section?
		je	EndSection
		or	al, al		; or the end of the buffer?
		jne	SkipLine
		sub	si, 2		; Extra CR & LF at end of buffer
		jmp	short EndSection

	SkipLine:
		cmp	al, LINEFEED	; Nothing interesting, so skip line
		je	RemoveLoop
		lodsb
		jmp	SkipLine

	EndSection:
		dec	si		; Back to the character
		mov	SectEnd, si	; where the search stopped
		mov	word ptr lp, di	; End of copied comments (if any)
		sub	si, di
		mov	nRemoved, si	; Number of characters removed
		pop	ds
	}

	MakeRoom(lp, -nRemoved, &pProInfo->BufferLen);
}


/*
 * Delete a keyname from the buffer
 *
 * Parameters:
 *	lp			pointer to keyname returned by FindKey
 *	pProInfo		pointer to INI file info
 *
 * Returns:
 *	nothing
 */
DeleteKey(lp, pProInfo)
LPSTR	lp;
PROINFO *pProInfo;
{
	int	nRemoved;
	char BASED_ON_LP(lp) *KeyEnd;

	_asm {
		cld
		les	di, lp
	BackToStart:
		dec	di		; Skip backwards to start of the line
		cmp	es:[di], LINEFEED
		jne	BackToStart
		inc	di
		mov	word ptr lp, di	; Save start of the line

		mov	cx, -1
		mov	al, LINEFEED
		repne	scasb		; Scan to end of the line
		sub	di, word ptr lp
		mov	nRemoved, di	; Length of line
	}
	MakeRoom(lp, -nRemoved, &pProInfo->BufferLen);
}


/*
 * Insert a new section in the buffer.
 * A hole has already been created for it.
 * This merely copies the string, places
 * '[]'s around it and a CR, LF after it.
 * Returns a pointer to immediately
 * after the section header in the buffer.
 *
 * Parameters:
 *	lpDest			pointer to where to add the section
 *	lpSrc			pointer to the section name
 *	count			length of lpSrc
 */
InsertSection(lpDest, lpSrc, count)
LPSTR	lpDest;
LPSTR	lpSrc;
short	count;
{
_asm {
	cld
	push	ds
	les	di, lpDest
	lds	si, lpSrc
        or      di,di                   ; If at start of buffer, no prefix
        jz      IS_SkipPrefix
	mov	ax, LINEFEED SHL 8 + CR	; Prefix with CR/LF
	stosw
IS_SkipPrefix:
	mov	al, SECT_LEFT		; '[' first
	stosb
	mov	cx, count		; Now the section name
	rep	movsb
	mov	al, SECT_RIGHT		; and the ']'
	stosb
	mov	ax, LINEFEED SHL 8 + CR	; finally, CR, LF
	stosw
	pop	ds
	mov	ax, di			; Return pointer to char after header
}
}


/*
 * Insert a new keyname in the buffer.
 * This copies the keyname and adds
 * an '='.  It is assumed that InsertResult()
 * will terminate the line.
 * A pointer to the buffer immediately after
 * the '=' is returned.
 *
 * Parameters:
 *	lpDest			pointer to where to add the keyname
 *	lpSrc			pointer to the keyname
 *	count			length of lpSrc
 */
InsertKey(lpDest, lpSrc, count)
LPSTR	lpDest;
LPSTR	lpSrc;
short	count;
{
_asm {
	cld
	push	ds
	les	di, lpDest
	lds	si, lpSrc
	mov	cx, count		; Copy the KeyName
	rep	movsb
	mov	al, '='			; add the '='
	stosb
	mov	ax, di			; Pointer to char after the '='
	pop	ds
}
}


/*
 * Add a new result string to the buffer.
 * It assumes that the keyname and '=' are
 * already there.  This routine may be
 * overwriting an existing result.  The result
 * is terminated with a CR, LR.
 *
 * Parameters:
 *	lpDest			pointer to where to add the result
 *	lpSrc			pointer to the result
 *	count			length of lpSrc
 */
InsertResult(lpDest, lpSrc, count)
LPSTR	lpDest;
LPSTR	lpSrc;
short	count;
{
_asm {
	cld
	push	ds
	les	di, lpDest
	lds	si, lpSrc
	mov	cx, count		; Copy the result
	rep	movsb
	mov	ax, LINEFEED SHL 8 + CR	; finally, CR, LF
	stosw				; This may overwrite existing CR, LF
	mov	ax, di
	pop	ds
}
}

/*
 * GetFileAttr
 *
 * DOS call to Get file attributes
GetFileAttr(szFile)
LPSTR szFile;
{
_asm {
	int 3
	xor	cx, cx			; In case of failure
	lds	dx, szFile
	mov	ax, 4300h
	int	21h
	mov	ax, cx
}
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\tasking.asm ===
TITLE   TASKING.ASM - WOW Tasking Support
    PAGE    ,132
;
; WOW v1.0
;
; Copyright (c) 1991, Microsoft Corporation
;
; TASKING.ASM
; WOW Tasking Support on 16 bit side - also see wkman.c
;
; History:
;   23-May-91   Matt Felton (mattfe) Created
;   12-FEB-92   Cleanup
;

.xlist
include kernel.inc
include tdb.inc
include newexe.inc
include wow.inc
include vint.inc
.list

.386


if KDEBUG
externFP OutputDebugString
endif

DataBegin

externB Kernel_InDOS
externB Kernel_flags
externB InScheduler
ifndef WOW
externB fProfileDirty
endif
externW WinFlags
externW cur_drive_owner
externW curTDB
externW Win_PDB
externW LockTDB
externW headTDB
externW hShell
externW pGlobalHeap
externW hExeHead
externW f8087
externD pIsUserIdle
externW wCurTaskSS
externW wCurTaskBP

globalw gwHackpTDB,0
globalw gwHackTaskSS,0
globalw gwHackTaskSP,0

externW PagingFlags

DataEnd


ifdef WOW
externFP ExitKernelThunk
externFP WowInitTask
externFP Yield
externFP WOW16CallNewTaskRet
externFP WowKillTask
externFP WOW16DoneBoot
externFP WOWGetCurrentDirectory
externFP ExitCall
externFP WowSyncTask
endif


sBegin  CODE
assumes cs,CODE
assumes ds,NOTHING
assumes es,NOTHING

externNP LoadSegment
externNP DeleteTask
externNP InsertTask
externNP ShrinkHeap

ifdef WOW
externNP Int21Handler
endif

if SDEBUG
externNP DebugSwitchOut
externNP DebugSwitchIn
endif

;-----------------------------------------------------------------------;
; StartWOWTask                              ;
;                                   ;
; Start a WOW 32 Task                           ;
;                                   ;
; Arguments:                                ;
;   Parmw1 -> TDB Of New Task                   ;
;   Parmw2    New Task SS                       ;
;   Parmw3    New Task SP                       ;
; Returns:                              ;
;   AX - TRUE/FALSE if we we able to create a new WOW task      ;
; Error Returns:                            ;
;   none                                ;
; Registers Preserved:                          ;
;                                   ;
; Registers Destroyed:                          ;
;   BX,CX,DX                            ;
; Calls:                                ;
;   See Notes                           ;
; History:                              ;
;                                   ;
;  Fre 24-May-1991 14:30  -by-  Matthew A. Felton [mattfe]      ;
; Created                               ;
;-----------------------------------------------------------------------;

;   The 16-Bit Kernel has created the new task and its ready to go
;   1.  Temporarily Switch to New Task Stack S2
;   2.  Fake Far Return from Thunk to point to StartW16Task
;   3.  Thunk to WOW32 - This will create a new Thread and call Win32 InitTask()
;   Note InitTask() will not return from the non-preemptive scheduler until
;   This thread does a Yield.
;   4.  When the thunk returns is jmps to WOW16TaskStarted on S2 leaving
;   S2 ready for the new task when it returns
;   5.  Restore S1 - Original Task Stack
;   6.  Return Back to LoadModule who will Yield and start T2 going.

    assumes ds, nothing
    assumes es, nothing

cProc   StartWOWTask,<PUBLIC,FAR>
    parmW pTDB
    parmW wTaskSS
    parmW wTaskSP

cBegin
    SetKernelDS ds

    mov es,pTDB     ; Get New Task TDB, will use later
    push    curTDB      ; Save our TDB
    push    bp      ; save BP (we don't exit wow16cal directly)
    mov di,ss       ; Save Current Task Stack
    mov cx,sp       ; di=ss cx=sp

; switch to new task stack temporarily

    FCLI         ; Disable Ints Till We get Back
                ; To presever new fram
    mov si,wTaskSP  ; Grab this before SS goes away
    mov ss,wTaskSS  ; Switch to new task stack.
    mov sp,si       ;

    mov curTDB,es   ; Set curTDB to new task
                ;
    pushf
    pop ax
    or ax,0200h     ; Re-enable interrupts
    push ax

    push    es                      ; hTask

    mov es, es:[TDB_pModule]   ; exehdr

    mov ax, es:[ne_expver]
    mov dx, es:[ne_flags]
    and dx, NEWINPROT          ; prop. font bit

    push    es                      ; hModule
    push    es                      ; Pointer to module name
    push    es:ne_restab
    push    es                      ; Pointer to module path
    push    word ptr es:ne_crc+2

    push dx                    ; expwinver. argument for WOWINITTASK
    push ax

    mov es, curTDB             ; resotre es, just being safe


; thunk to wow32 to create a thread and task

    push    cs          ; Fake Out FAR Return to StartW16Task
    push    offset StartW16Task

    jmp WowInitTask     ; Start Up the W32 Thread

    public WOW16TaskStarted
WOW16TaskStarted:
    mov ss,di           ; Restore Calling Task Stack
    mov sp,cx
    pop bp
    pop curTDB          ; Restore real CurTDB
    FSTI             ; OK we look like old task

cEnd


;
;   First code executed By New Task - Setup Registers and Go
;

StartW16Task:
    add sp,+12
    pop ax              ; Flags
    mov bp,sp
    xchg ax,[bp+20]     ; Put flags down & pick up cs
    xchg ax,[bp+18]     ; Put cs down & pick up ip
    xchg ax,[bp+16]     ; Put ip down & pick up bp
    mov  bp,ax
    dec  bp
    pop dx
    pop bx
    pop es
    pop cx
    pop ax
    pop di
    pop si
    pop ds
    call SyncTask
    iret                ; App Code Starts From Here

;   ExitKernel
;
;   Enter When the 16 bit Kernel is going away -- never returns.
;   In WOW this is a register-args wrapper for the stack-args
;   thunk ExitKernelThunk.

    public  ExitKernel
    ExitKernel:

    cCall   ExitKernelThunk, <ax>

    INT3_NEVER                ; ExitKernel never returns.


;   BootSchedule
;
;   Entered When Bogus Boot Task goes Away - treated same as task exit.

    public  BootSchedule
BootSchedule:
    CheckKernelDS   DS      ; Make Sure we Address Kernel DS
    mov [curTDB],0      ; Make No Task the Current Task
    jmp WOW16DONEBOOT

;   ExitSchedule
;
;   We get here when a 16 bit task has exited - go kill this task
;   Win32 non-preemptive scheduler will wake someone else to run.

    public  ExitSchedule
ExitSchedule:
    CheckKernelDS   DS	    ; Make Sure we Address Kernel DS

    mov     ax,[LockTDB]    ; If I am the locked TDB then clear flag
    cmp     ax,[curTDB]
    jnz     @f
    mov     [LockTDB],0
@@:
    mov [curTDB],0	; Make No Task the Current Task
    call    ShrinkHeap
    jmp WowKillTask     ; Go Kill Myself (NEVER RETURNS)



;-----------------------------------------------------------------------;
; SwitchTask - This is NOT a subroutine DO NOT CALL IT
;
; This routine does a Win 3.1 compatible task switch.
;
; Arguments:
;   AX == Next Tasks TDB pointer
; Returns:
;   nothing
; Error Returns:
;   nothing
; Registers Preserved:
;
; Registers Destroyed:
;
; Calls:
;   SaveState
;   RestoreState
;
; History:
;   22-May-91	Matt Felton (MattFe) Created
;   Using idea's from Win 3.1 Schedule.Asm
;
;-----------------------------------------------------------------------;

    assumes ds, nothing
    assumes es, nothing

    public  SwitchTask
SwitchTask:
    CheckKernelDS ds
    ReSetKernelDS ds

    inc InScheduler	; set flag for INT 24...

    cmp curTDB,0        ; Previous Task Gone Away ?
    jnz @f		; No ->

			; Yes
    mov di,ax           ; DI = New TDB
    mov ds,ax           ; DS = New TDB
    jmps    dont_save_state     ; Get Set for this new guy

@@:
    push    ax          ; Save Next Tasks TDB pointer

; COMPAT 22-May-91 Mattfe, Idle callout for funky screen drivers is done by
; the Windows scheduler - that will not happen either from WOW. INT 28
; and Win386 1689 int2f call

; There was PokeAtSegments code which during idle time brought back segments !

; Do Debuggers Care that the stack frame of registers looks like a Windows stack frame
; when we do the debugger callout ? - check with someone in CVW land.

    mov es,curTDB       ; ES = Previous Task TDB

    mov ax,es           ; Don't SS,SP For DEAD Task
    or  ax,ax
    jz  @F

    mov ax,wCurTaskSS       ; FAKE Out TDB_taskSS,SP so that
    mov es:[TDB_taskSS],ax  ; The Old Task Task_BP looks right
    mov ax,wCurTaskBP
    sub ax,(Task_BP-Task_DX)
    mov es:[TDB_taskSP],ax

@@:
    pop ds          ; DS = Next Task TDB
    UnSetKernelDS   ds

if KDEBUG

; Assertion Check TDB_taskSS == SS for current Task

    mov ax,ds:[TDB_taskSS]
    mov di,ss
    cmp di,ax
    jz  @F

;   int 3
@@:
endif; KDEBUG

    mov di,ds           ; DI = destination task
    xor si,si           ; SI is an argument to RestoreState

    mov ax,es           ; NOTE TDB_SS,SP Are note Correct
    or  ax,ax           ; might affect debugger compatability.
    jz  short dont_save_state

    cmp es:[TDB_sig],TDB_SIGNATURE
    jnz short dont_save_state
    mov si,es           ; SI = Old Task


    cCall   SaveState,<si>
if SDEBUG
    push    ds
    mov ds,ax
    call    DebugSwitchOut      ; Note Stack Frame is not Compatible
    pop ds                      ; Do we care ?
endif
dont_save_state:
    SetKernelDS es
    mov curTDB,di

    mov ax, ds:[TDB_PDB]    ; Set our idea of the PDB
    mov Win_PDB, ax

    SetKernelDS es

    cmp di,0            ; the first task, will never get 0
    jz  dont_restore_state

    or  Kernel_flags,kf_restore_CtrlC OR kf_restore_disk
if SDEBUG
    call    DebugSwitchIn
endif

dont_restore_state:
    ; Switch to new task stack.
    mov curTDB,di
    dec InScheduler     ; reset flag for INT 24

    SetKernelDS ds          ; Set the Kernel DS again

;the word at [vf_wES] is a selector that's about to be popped into
;the ES in WOW16CallNewTaskRet.  this selector could be the TDB of
;a task that just died, in which case it's invalid.  so let's
;shove something in there that won't cause a GP when we do the POP ES.
;
; In some cases we are switching tasks while returning to a callback.
; When this happens our stack is a CBVDMFRAME instead of a VDMFRAME.
; We only want to shove a safe ES,FS,GS value when it's a VDMFRAME and
; we're returning from an API call rather than calling back to
; 16-bit code.
;
; Regardless of which frame we're using, ss:sp points to wRetID.


    mov     bx, sp
    cmp     WORD PTR ss:[bx], RET_DEBUGRETURN  ; if (wRetID > RET_DEBUGRETURN)
    ja      dont_stuff_regs                    ;     goto dont_stuff_regs

    sub     bx,vf_wTDB + 2       ;bx is now start of VDMFRAME struct
    mov     ss:[bx+vf_wES],es    ;put something safe in there
;Win31 does not save fs, gs over task switches, so we zero them out here
    mov     word ptr ss:[bx+vf_wFS],0    ;put something safe in there
    mov     word ptr ss:[bx+vf_wGS],0    ;put something safe in there
dont_stuff_regs:


if KDEBUG
    mov     bx, sp
    cmp     WORD PTR ss:[bx], RET_TASKSTARTED
    jne     @f
    INT3_NEVER ; We need to stuff ES for RET_TASKSTARTED
               ; if we hit this breakpoint.
@@:
endif

; Hung App Support
; If the new task is the one we want to kill then force it to exit

    mov     bx,curTDB	    ; if ( curTDB == LockTDB )
    cmp     bx,LockTDB
    jnz     SW_DontKillIt

    mov     ax,4CFFH	    ;	YES -> Exit
    DOSCALL
    INT3_NEVER

SW_DontKillIt:
    jmp WOW16CallNewTaskRet ; Continue with the new task.


;-----------------------------------------------------------------------;
; SaveState                                                             ;
;                                   ;
; Saves the state of the current MS-DOS process.  This means the per    ;
; task interrupt vectors, the drive and directory, EEMS land if any,    ;
; and old app stuff if any.                     ;
;                                   ;
; Arguments:                                ;
;   parmW   destination                     ;
;                                   ;
; Returns:                              ;
;   DS returned in AX.                      ;
;                                   ;
; Error Returns:                            ;
;                                   ;
; Registers Preserved:                          ;
;                                   ;
; Registers Destroyed:                          ;
;                                   ;
; Calls:                                ;
;                                   ;
; History:                              ;
;                                   ;
;  Mon 07-Aug-1989 21:53:42  -by-  David N. Weise  [davidw]     ;
; Removed the WinOldApp support.                    ;
;                                   ;
;  Tue Feb 03, 1987 08:21:53p  -by-  David N. Weise   [davidw]      ;
; Got rid of the rest of the DOS version dependencies.          ;
;                                   ;
;  Thu Jan 22, 1987 03:15:15a  -by-  David N. Weise   [davidw]      ;
; Took out the saving of the ^C state, DTA address, and ErrorMode.  ;
;                                   ;
;  Sun Jan 04, 1987 04:40:44p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.                   ;
;-----------------------------------------------------------------------;

    assumes ds, nothing
    assumes es, nothing

cProc   SaveState,<PUBLIC,NEAR>,<si,di,ds>
    parmW   destination
cBegin
    cld
    SetKernelDS
    mov ax,f8087
    UnSetKernelDS
    mov ds,destination
    or  ax,ax
if 0
    jz  short no_fstcw
    .8087
    fstcw   ds:[TDB_FCW]
endif
no_fstcw:
    test    ds:[TDB_Drive],10000000b; if hi bit set....
    jnz short ss_ret            ; ...no need to get dir
    mov ah,19h
    DOSCALL
    mov dl,al
    inc dl
    or  al,10000000b
    mov ds:[TDB_Drive],al   ; save it (A=0, B=1, etc.)

    mov si,TDB_LFNDirectory
    mov byte ptr [si],'\'   ; set "\"
    inc si
    ; get Long path
    cCall WowGetCurrentDirectory,<80h, ds, si>
    or  dx, dx
    jz  short ss_ret
    mov byte ptr [si-1],0   ; indicate error with null byte
ss_ret: mov ax,ds
cEnd


;-----------------------------------------------------------------------;
; RestoreState                              ;
;                                   ;
; Restores the MS-DOS interrupt vectors in real mode.           ;
;                                   ;
; Arguments:                                ;
;   none                                ;
; Returns:                              ;
;   none                                ;
; Error Returns:                            ;
;   none                                ;
; Registers Preserved:                          ;
;   BX,CX,DX,DI,SI,DS,ES                        ;
; Registers Destroyed:                          ;
;   AX                              ;
; Calls:                                ;
;   nothing                             ;
; History:                              ;
;                                   ;
;  Mon 07-Aug-1989 21:53:42  -by-  David N. Weise  [davidw]     ;
; Removed the WinOldApp support.                    ;
;                                   ;
;  Tue Feb 03, 1987 08:21:53p  -by-  David N. Weise   [davidw]      ;
; Got rid of the rest of the DOS version dependencies.          ;
;                                   ;
;  Thu Jan 22, 1987 03:15:15a  -by-  David N. Weise   [davidw]      ;
; Took out the restoring of the ^C state, DTA address, and ErrorMode.   ;
;                                   ;
;  Sun Jan 04, 1987 04:45:31p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.                   ;
;-----------------------------------------------------------------------;

;   SyncTask
;
;   Enter: when new task starts
;          check if the new task is blocked by appshelp
cProc   SyncTask,<PUBLIC,NEAR> <ax,bx,cx,dx,di,si,es,ds>
cBegin
STL:
        cCall   WowSyncTask
        cmp     ax, 0
        je      @F
        jg      STL
        call    ExitCall
@@:
cEnd

sEnd    CODE
end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\tdb.inc ===
;
; Task Data Block
;
;   Contains all task specific data.
;

;
; The following macros allow saving and restoring hardware interrupt
; vectors inline.

numTaskInts = 0
?hinum = 0

?higen  macro   x,i,r,t

if r LE 3

  ?hisav&x &macro
    ife t
      mov si,4*i
    else
      mov si,i
    endif
    rept 2*r
      movsw
    endm
  &endm

  ?hires&x &macro
    ife t
      mov di,4*i
    else
      mov di,i
    endif
    rept 2*r
      movsw
    endm
  &endm

else

  ?hisav&x &macro
    ife t
      mov si,4*i
    else
      mov si,i
    endif
    mov cx,2*r
    rep movsw
  &endm

  ?hires&x &macro
    ife t
      mov di,4*i
    else
      mov di,i
    endif
    mov cx,2*r
    rep movsw
  &endm

endif
endm

DefTaskIntGroup macro   i,r,t
?higen %?hinum,i,r,t
?hinum = ?hinum + 1
numTaskInts = numTaskInts + r
endm

?hiexp  macro   n,x
        n&x
endm


SaveTaskInts    macro   destination
mov es,destination
xor ax,ax
mov ds,ax
mov di,TDB_INTVECS
?hicnt = 0
rept ?hinum
?hiexp  &?hisav,%?hicnt
?hicnt = ?hicnt + 1
endm
endm

RestTaskInts    macro  source
mov ds,source
mov si,TDB_INTVECS
xor ax,ax
mov es,ax
?hicnt = 0
rept ?hinum
?hiexp  &?hires,%?hicnt
?hicnt = ?hicnt + 1
endm
endm

; Define the hardware interrupts we will keep on a task specific basis.
; We only save on a per task basis those interrupts related to arithmetic.
; So we save 0, 2, 4, 6, 7, 10h, 3Eh, and 75h.
;  Int 0 is divide by 0
;  Int 2 is Coprocessor Error
;  Int 4 is overflow
;  Int 6 is invalid op-code
;  Int 7 is no coprocessor,
;  Int 3Eh is use by the C compiler for 8087 emulation.
;  Int 75h is use by the C compiler for 8087 emulation.
; In Windows 1.03 we saved 0h, 1h, 2h, 3Eh.
; For DOS5 compatibility we should save 0, 4, 6, and 7.


DefTaskIntGroup (00h),1,0
DefTaskIntGroup (02h),1,0
DefTaskIntGroup (04h),1,0
DefTaskIntGroup (06h),2,0
DefTaskIntGroup (3Eh),1,0
DefTaskIntGroup (75h),1,0

ifdef WOW
    include tdb16.inc
else  ; original TDB

THUNKELEM   EQU         8       ; (62*8) = 512-16 (low arena overhead)
THUNKSIZE   EQU         8

; Task data structure


;
; DON'T YOU DARE CHANGE ANYTHING IN HERE
; OR RAOR WILL KILL YOU
; OLE DEPENDS ON THIS                           3/25/91
;

TDB             STRUC

TDB_next        DW  ?           ; next task in dispatch queue
TDB_taskSP      DW  ?           ; Saved SS:SP for this task
TDB_taskSS      DW  ?           ;
TDB_nEvents     DW  ?           ; Task event counter
TDB_priority    DB  ?           ; Task priority (0 is highest)

TDB_thread_ordinal DB ?         ; ordinal number of this thread
TDB_thread_next DW  ?           ; next thread
TDB_thread_tdb  DW  ?           ; the real TDB for this task

TDB_thread_list DW  ?           ; list of allocated thread structures
TDB_thread_free DW  ?           ; free list of availble thread structures
TDB_thread_count DW ?           ; total count of tread structures

TDB_FCW         DW  ?           ; Floating point control word

TDB_flags       DB  ?           ; Task flags
TDB_filler      DB  ?           ; keep word aligned

TDB_ErrMode     DW  ?           ; Error mode for this task
TDB_ExpWinVer   DW  ?           ; Expected Windows version for this task
TDB_Module      DW  ?           ; Task module handle to free in killtask
TDB_pModule     DW  ?           ; Pointer to the module database.
TDB_Queue       DW  ?           ; Task Event Queue pointer
TDB_Parent      DW  ?           ; TDB of the task that started this up

TDB_SigAction   DW  ?           ; Action for app task signal
TDB_ASignalProc DD  ?           ; App's Task Signal procedure address
TDB_USignalProc DD  ?           ; User's Task Signal procedure address
TDB_GNotifyProc DD  ?           ; Task global discard notify proc.

TDB_INTVECS DD  numTaskInts DUP (?) ; Task specfic hardware interrupts

if 0
        ; EMS fields are OBSOLETE!

TDB_LIMSave     DW  ?           ; Offset within TDB of LIM save area
TDB_EMSPID      DW  ?           ; EMS PID for this task
TDB_EEMSSave    DD  ?           ; LPTR to EEMS save area (in a TDB)
TDB_EMSBCnt     DW  ?           ; number of EMS banks allocated so far
TDB_EMSMaxBCnt  DW  ?           ; Maximum # banks this task wants.
TDB_EMSRegSet   DB  ?       ; The register set this TDB lives in.

else

TDB_CompatFlags DW  ?       ; Compatibility flags
TDB_CompatFlags2 DW ?       ; Upper 16 bits
        DB  9 DUP (?)   ; Filler to keep TDB size unchanged
endif

TDB_cLibrary    DB  ?           ; tracks  add/del of ALL libs in system EMS
TDB_PHT         DD  ?           ; (HANDLE:OFFSET) to private handle table
TDB_PDB         DW  ?           ; MSDOS Process Data Block (PDB)
TDB_DTA         DD  ?           ; MSDOS Disk Transfer Address
TDB_Drive       DB  ?           ; MSDOS current drive
TDB_Directory   DB 65 DUP (?)   ; MSDOS current directory
TDB_Validity    DW  ?           ; initial AX to be passed to a task
TDB_Yield_to    DW  ?           ; DirectedYield arg stored here
TDB_LibInitSeg  DW  ?           ; segment address of libraries to init
TDB_LibInitOff  DW  ?
                                ; MakeProcInstance thunks live here.
TDB_MPI_Sel     DW  ?           ; Code selector for thunks
TDB_MPI_Thunks  DW  ((THUNKELEM*THUNKSIZE)/2) dup (?)

TDB_ModName     DB  8 DUP (?)   ; Name of Module.
TDB_sig         DW  ?           ; Signature word to detect bogus code
TDB             ENDS
endif    ; original TDB_

TDBsize = SIZE TDB


; signature word used to check validity of a TDB

TDB_SIGNATURE  equ     'DT'

; TDB flags

TDBF_WINOLDAP   EQU     01h     ; This app is WinOldAp.
TDBF_EMSSHARE   EQU     02h     ; This app shares EMS banks with MSDOS EXEC.
TDBF_CACHECHECK EQU     04h     ; Used in CacheCompact to prevent revisitation.
TDBF_OS2APP     EQU     08h     ; This is an OS/2 app.
TDBF_WIN32S     EQU     10h     ; This is Win32S app.

Task_Regs       struc
Task_DX         dw      ?
Task_BX         dw      ?
Task_ES         dw      ?
Task_CX         dw      ?
Task_AX         dw      ?
Task_DI         dw      ?
Task_SI         dw      ?
Task_DS         dw      ?
Task_BP         dw      ?
Task_IP         dw      ?
Task_CS         dw      ?
Task_Regs       ends
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\chp\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DFE_SB -DDBCS -DPRC"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\chs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd ..
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DFE_SB -DDBCS -DPRC"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\w32sys.asm ===
TITLE   w32sys - Win32S support

.xlist
include kernel.inc
include tdb.inc
.list

DataBegin

externW curTDB

DataEnd


sBegin  CODE
assumes CS,CODE


	assumes ds,nothing
	assumes es,nothing

	public   GetW32SysInfo

cProc   GetW32SysInfo,<PUBLIC,FAR>
cBegin  nogen
	SetKernelDS ES

	mov     dx, es
	lea     ax, curTDB

	ret
	assumes es,nothing
cEnd    nogen

sEnd    CODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\cht\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DFE_SB -DDBCS -DTAIWAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\winexec.asm ===
;-----------------------------------------------------------------------;
;
;  WINEXEC.ASM -
;
;      Windows Exec Function
;
;-----------------------------------------------------------------------;

include kernel.inc
ifdef WOW
include wowcmpat.inc
;The following defines come from winerror.inc, which is new in the
;win95 source tree, but hasn't been merged into wow
ERROR_FILE_NOT_FOUND equ 2
ERROR_BAD_LENGTH     equ 24
endif


ifdef FE_SB
externFP FarMyIsDBCSLeadByte
endif

ifdef WOW
externFP MyGetAppWOWCompatFlagsEx
endif

	externW		WinFlags		; (kdata.asm)
	externD		WinAppHooks		; (kdata.asm)

sBegin NRESCODE

assumes cs,NRESCODE


;-----------------------------------------------------------------------;
;
;  WinExec() -
;
;-----------------------------------------------------------------------;

; HANDLE PASCAL WinExec(lpszFile,wShow)

cProc IWinExec, <FAR,PUBLIC>,<si,di>

	parmD lpszFile			; Pathname ptr
	parmW wShow			; Mode flag
;
; szCmdLine buffer must be big enough for passed in path & parms, plus
; .EXE, null terminator, and newline terminator.
; So we add a little room for good measure here.
;
        LocalV szCmdLine,260+256+8      ; Path and command line (to account for .exe)
        LocalW pszParm                  ; Ptr to start of parameters

	LocalB bDotFound		; Non-zero if a period is in the string
	LocalB bDblQFound		; Non-zero if the string starts with "

	LocalV loadparams, %(SIZE EXECBLOCK)
	LocalD FCB1
cBegin

; Copy first part of line into szCmdLine.

	lds	si,lpszFile
	smov	es,ss
        lea     di,szCmdLine
        mov     cx,260                  ; MAX_PATH

	xor	al,al
	mov	bDotFound,al
	mov	bDblQFound,al
	; The Dbl-quote is used as a delimiter for cmdname as in
	; winexec("\"c:\fldr with spaces\" cmd line", ..);
	mov	al, ds:[si]		; get Ist char
	cmp	al,'"'			; is it a "
	jne	WELoop1			; N:
	mov	bDblQFound,al		; Y: remember that
	lodsb				; skip the dblQ

; Loop until a blank or NULL is found.
WELoop1:
	lodsb
	cmp	bDblQFound, 0		; If str didn't start with dblQ
	je	WESpaceCheck		; then SPACE is a delimiter
					; otherwise " is the delimiter
	cmp	al,'"'			; look for second DblQ
	jne	WESkipSpaceCheck
	and	bDblQFound,0		; reset this, so space is the delimiter
	lodsb				; skip past the dbl Q
WESpaceCheck:
	cmp	al,' '			; Exit loop if blank or NULL
	je	WECont1
WESkipSpaceCheck:
	cmp	al,9
	je	WECont1
	or	al,al
	je	WECont1
	cmp	al,'.'
	jne	WELoopCont
	mov	bDotFound,al
WELoopCont:
        ;** We have to check to see if the dot we found was actually in
        ;**     a directory name, not in the filename itself.
        cmp     al, '\'                 ; Separator?
        je      WE_Separator
        cmp     al, '/'
        jne     WE_Not_Separator
WE_Separator:
        mov     bDotFound,0             ; No dots count yet
WE_Not_Separator:
	stosb
        dec     cx
        jz      WE_filename_too_long
ifdef FE_SB				;Apr.26,1990 by AkiraK
        push    cx
	call	FarMyIsDBCSLeadByte
        pop     cx
	jc	WELoop1
	movsb
        dec     cx
        jz      WE_filename_too_long
endif
	jmp	short WELoop1

WE_filename_too_long:
	krDebugOut DEB_TRACE, "WinExecEnv: filename too long, > 259"
	mov	ax,ERROR_FILE_NOT_FOUND
	jmp	WinExecEnvExit

WECont1:
	mov	dx,ax			; Store final char in DX

; Does the command have an extention?

	cmp	bDotFound,0
	jne	WEHasExt

	mov	ax,0452Eh		;'.E'
	stosw
	mov	ax,04558h		;'XE'
	stosw

WEHasExt:
	xor	ax,ax			; NULL terminate string
	stosb

        mov     pszParm,di              ; Store pointer to parm string
        stosb                           ; length = 0
        mov     al,0dh                  ; line feed terminator
        stosb
        dec     di                      ; back up

	or	dl,dl			; Exec if lpszFile was null terminated
	jz	WEExec

; Copy everything else into szParm.

        mov     cx,255                  ; Max length of cmd tail +1
WELoop2:
        lodsb
        or      al,al
ifdef WOW
        jz      WEDoneParm
else
        jz      WECont2
endif
        stosb
        dec     cx
        jnz     WELoop2

ifdef WOW
        jmps    @F

;
; On NT we have a compatibility flag, WOWCFEX_LONGWINEXECTAIL which is
; set for applications such as TSSETUP, the setup program for Intergraph's
; NT-only Transcend app.  This app uses a command tail on the order of
; 143 bytes for a Win32 worker app, and it worked on 3.5 and 3.51,
; so we need to continue to let at least this app cheat.
;

WEDoneParm:
        sub     cx, 128
        ja      WECont2

; tail was longer than 126 characters

        call    MyGetAppWOWCompatFlagsEx
        test    dx, word ptr cs:[WE_GACFEX_LONGWINEXECTAIL+2]
        jz      @F
        jmps    WECont2

WE_GACFEX_LONGWINEXECTAIL:
        DD WOWCFEX_LONGWINEXECTAIL

@@:
endif

; Cmd tail too long to fit in PSP !!!
; Fail the call.
; We _could_ alloc some memory to hold the cmd tail and make its
;   owner be the new hTask. However InitTask is documented to return 
;   es=PSP, es:bx=cmd_tail. So we're in trouble. Could truncate the cmd line.
;   Cleaner to fail the exec.
;   Could grow the PSP and tack the big cmd tail on at the end. Scary!
; Unfortunately, kernel32.ExecWin16Program maps ERROR_BAD_LENGTH to
; ERROR_GEN_FAILURE.
        krDebugOut DEB_TRACE, "WinExecEnv: command tail too long, > 126"
	mov	ax,ERROR_BAD_LENGTH
        jmps    WinExecEnvExit

WECont2:

; Terminate it with a carriage return.

	mov	al,0Dh
	stosb

; Prefix the parameter string with its length.

        mov     bx,pszParm              ; ax = length + 2
        mov     ax,di
        sub     ax,bx
        dec     ax                      ; don't include line feed char or length
        dec     ax
        mov     ss:[bx],al

; Set up the FCBs.

WEExec:
	mov	word ptr FCB1[0],2	    ; FCB1[0] = 2;
	mov	ax,wShow		    ; FCB1[1] = wShow;
	mov	word ptr FCB1[2],ax
	xor	ax,ax
	mov	loadparams.envseg,ax	    ; loadparms.segEnv = 0;
	mov	loadparams.lpfcb2.lo,ax     ; loadparms.lpFCB2 = (LPSTR)NULL;
	mov	loadparams.lpfcb2.hi,ax
        mov     ax,pszParm                  ; loadparms.lpCmdLine = (LPSTR)pszParm;
	mov	loadparams.lpCmdLine.lo,ax
	mov	loadparams.lpCmdLine.hi,ss
	lea	ax,FCB1 		    ; loadparms.lpFCB1 = (LPSTR)fcb1buf;
	mov	loadparams.lpfcb1.lo,ax
	mov	loadparams.lpfcb1.hi,ss

; Exec the progam.

	smov	ds,ss
        lea     dx,szCmdLine                ; ds:ax == ptr to file to exec
	lea	bx,loadparams		    ; es:bx == ptr to param block
	mov	ax,4B00h		    ; dos exec
	int	21h

WinExecEnvExit:
cEnd

;**************************************************************************
; RegisterWinoldapHook(Addr,Opcode):
; 
; Description:  (Opcode == 1) => hook, (Opcode == 0) => unhook.
;  Addr is a ptr to struct of the form WinoldapHookList
;  struct WinoldapHookList { struct WinoldapHookList *ptr; DWORD Hook;};
;**************************************************************************

cProc	RegisterWinoldapHook,<FAR,PUBLIC,PASCAL>,<ds,es,di,si,dx>
	parmD	Address
	parmB	Opcode
cBegin
	SetKernelDSNRes			; set kernel's DS
	mov	ax, WinFlags
	test	ax, WF_STANDARD
	mov	ax,0
	jz	RWH_Call
	lea	si,WinAppHooks
	les	di,Address
	cmp	Opcode,0		; unhook ?
	jz	RWH_Unhook
RWH_Exchange:
	mov	ax,ds:[si]		; old
	mov	es:[di],ax		; next of new
	mov	ax,ds:[si+2]
	mov	es:[di+2],ax		; next set
	mov	ds:[si],di
	mov	di,es
	mov	ds:[si+2],di		; new one becomes first
	mov	ax,1
	jmp	SHORT RWH_Call

RWH_Unhook:
	mov	dx,es
RWH_Compare:
	cmp	di,ds:[si]
	jnz	RWH_Nexthook
	cmp	dx,ds:[si+2]
	jnz	RWH_NextHook
	mov	ax,es:[di]
	mov	ds:[si],ax
	mov	ax,es:[di+2]
	mov	ds:[si+2],ax
	mov	ax,1
	jmp	SHORT RWH_Call
RWH_NextHook:
	lds	si,ds:[si]
	mov	ax,ds
	or	ax,si
	jnz	short RWH_Compare
RWH_Call:
	UnSetKernelDS			; unset it
cEnd

;**********************************************************************
;
; GetWinoldapHooks:
; Description: Called exclusively by winoldap to get a pointer to a list
;		of WinoldapHookList.
; Entry: None
; EXIT: DX:AX -> WinoldapHookList...
; USES: Flags.
;**********************************************************************
 
cProc	GetWinoldapHooks,<FAR,PUBLIC,PASCAL>,<ds,si>
cBegin
	SetKernelDSNRes			; set kernel DS
	lea	si,WinAppHooks
	mov	ax, word ptr ds:[si]
	mov	dx, word ptr ds:[si+2]
	UnSetKernelDS			; unset it
cEnd

sEnd NRESCODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\da\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET)  \
	 DBCS_FLAGS="-DFE_SB" 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\br\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET)  \
	 DBCS_FLAGS="-DFE_SB" 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\cs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET)  \
	 DBCS_FLAGS="-DFE_SB" 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\wowdeb.asm ===
TITLE	WOWDEB.ASM
	PAGE	,132
;
; WOW v1.0
;
; Copyright (c) 1991, Microsoft Corporation
;
; wowdeb.ASM
; Debug Routines
;
; History:
;   19-June-91	 Matt Felton (mattfe) Created
;
	.xlist
	include kernel.inc
	include cmacros.inc
	.list

.286p

externFP WOWKernelTrace

DataBegin
externW curTDB
DataEnd


sBegin	CODE
assumes	CS,CODE
assumes DS,NOTHING
assumes ES,NOTHING

;-----------------------------------------------------------------------;
; KdDbgOut								;
;									;
; Cmacros.inc has been modified so in the debug kernel all far public	;
; routines have a preamble compiled so they call this routine with a	;
; a count of the number of arguements and a pointer to a charater string;
; with the name of the routine. 					;
; This routine then thunks to 32 bit WOW to output the paramters to the ;
; log.									;
; It assumes that if the callers CS != Our CS then its not the kernel	;
; Calling this routine							;
; Cmacros doesn't compile in the preamble for some internal routines 	;
; that are called all the time. 					;
; For retail Kernel the preamble and this routine are omitted.		;
;									;
; Arguments:								;
;	lpStr	long pointer to null terminated string			;
;	cparms	count of parameters					;
; Returns:								;
;	none								;
;									;
; Error Returns:							;
;									;
; Registers Preserved:							;
;	all								;
;									;
; Registers Destroyed:							;
;	WOWKernelTrace Thunk to 32 bits 				;
;									;
; History:								;
;									;
;   June 19 1991 Create Matt Felton [mattfe]
;-----------------------------------------------------------------------;

ifdef KDEBUG

	assumes	ds, nothing
	assumes	es, nothing

cProc KdDbgOut,<PUBLIC,FAR>,<ax,bx,dx>
	parmW	cParms
	parmD  lpRoutineName
cBegin
	SetKernelDS DS
	mov ax,curTDB		    ; if there is no CurrentTDB forget it.
	cmp ax,0
	jz  KdDbgOut_Exit

; Get the iLogLevel From ROMBIOS Hard Disk Area

	push	0040h
	pop	ds
	UnSetKernelDS ds

	iLogLevel equ 0042h	    ; use fixed disk status area
	cmp	word ptr ds:[iLogLevel],"00" ;No Output if Zero
	jz	KdDbgOut_Exit

; Log Application Calls Only

	mov	ax,cs
	mov	bx,word ptr [bp]	; (follow BP chain to user CS)
	add	bx,3

	cmp	word ptr ds:[iloglevel],"61"	; LOG IT ALL at Level 16
	jz	@f

	cmp	ax,word ptr ss:[bx]	;If Users CS != KERNEL CS
	jz	KdDbgOut_Exit		;  then ignore tracing

@@:
	sub	bx,2			; Point to Callers Return Address IP:CS Args
	cCall WOWKernelTrace,<lpRoutineName,cParms,SSBX>

KdDbgOut_Exit:
cEnd

endif

sEND	CODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\winkern.inc ===
MASTER_OBJECT_SIZE  equ 512

LOCALHEAP_SIG   EQU 'HL'
GLOBALHEAP_SIG  EQU 'HG'

; Debug fill constants

DBGFILL_ALLOC   equ     0fdh
DBGFILL_FREE    equ     0fbh
DBGFILL_BUFFER  equ     0f9h
DBGFILL_STACK   equ     0f7h

ife PMODE32

; Data structure that describes an allocation arena.  Both the local
; and global allocators use this structure at the beginning of their
; information structures.
;
HeapInfo    STRUC
hi_check    DW  ?   ; arena check word (non-zero enables heap checking)
hi_freeze   DW  ?   ; arena frozen word (non-zero prevents compaction)
hi_count    DW  ?   ; #entries in arena
hi_first    DW  ?   ; first arena entry (sentinel, always busy)
hi_last     DW  ?   ; last arena entry (sentinel, always busy)
hi_ncompact DB  ?   ; #compactions done so far (max of 3)
hi_dislevel DB  ?   ; current discard level
hi_distotal DW  ?   ; total amount discarded so far
hi_htable   DW  ?   ; head of handle table list
hi_hfree    DW  ?   ; head of free handle table list
hi_hdelta   DW  ?   ; #handles to allocate each time
hi_hexpand  DW  ?   ; address of near procedure to expand handles for
            ; this arena
hi_pstats   DW  ?   ; address of statistics table or zero
HeapInfo    ENDS

else    ; PMODE32

; Data structure that describes an allocation arena.  Both the local
; and global allocators use this structure at the beginning of their
; information structures.
;
HeapInfo    STRUC
hi_check    DW  ?   ; arena check word (non-zero enables heap checking)
hi_freeze   DW  ?   ; arena frozen word (non-zero prevents compaction)
hi_count    DW  ?   ; #entries in arena
hi_first    DW  ?   ; first arena entry (sentinel, always busy)
        DW  ?
hi_last     DW  ?   ; last arena entry (sentinel, always busy)
        DW  ?
hi_ncompact DB  ?   ; #compactions done so far (max of 3)
hi_dislevel DB  ?   ; current discard level
hi_distotal DD  ?   ; total amount discarded so far
hi_htable   DW  ?   ; head of handle table list
hi_hfree    DW  ?   ; head of free handle table list
hi_hdelta   DW  ?   ; #handles to allocate each time
hi_hexpand  DW  ?   ; address of near procedure to expand handles for
            ; this arena
hi_pstats   DW  ?   ; address of statistics table or zero
HeapInfo    ENDS

phi_first   equ dword ptr hi_first
phi_last    equ dword ptr hi_last

endif   ; PMODE32

; Handle table entry.

HandleEntry STRUC
he_address  DW  ?   ; actual address of object
he_flags    DB  ?   ; flags and priority level
he_seg_no   DB  ?   ; 0-based segment number for discardable code
HandleEntry ENDS
he_EMSPID_no    equ byte ptr he_seg_no

FreeHandleEntry STRUC
he_link     DW  ?
he_free     DW  ?
FreeHandleEntry ENDS

LocalHandleEntry STRUC
lhe_address DW  ?   ; actual address of object
lhe_flags   DB  ?   ; flags and priority level
lhe_count   DB  ?   ; lock count
LocalHandleEntry ENDS

LocalFreeHandleEntry STRUC
lhe_link    DW  ?
lhe_free    DW  ?
LocalFreeHandleEntry ENDS

he_owner    EQU he_address  ; Discarded objects contain owner field
                ; here so we know when to free handle
                ; table entries of discarded objects.

HE_DISCARDABLE  EQU 00Fh    ; Discard level of this object
HE_DISCARDED    EQU 040h    ; Marks objects that have been discarded.

HE_FREEHANDLE   EQU 0FFFFh  ; Use -1 to mark free handle table entries


LHE_DISCARDABLE EQU 00Fh    ; Discard level of this object
LHE_DISCARDED   EQU 040h    ; Marks objects that have been discarded.
LHE_USERFLAGS   EQU 01Fh    ; Mask for user setable flags

LHE_FREEHANDLE  EQU 0FFFFh  ; Use -1 to mark free handle table entries


HE_ALIGN    = 4-1
HE_MASK     = NOT HE_ALIGN

; Handles are allocated in blocks of N, where N is the hi_hdelta field
; in the local heap information structure.  The last word of each block
; of handles is used to thread the blocks together, allowing all handles
; to be enumerated.  The first word of every block is the number of
; handle table entries in the block.  Not only does it save us code
; in henum, but it also has the convenient property of placing all
; handle entries on 2 byte boundaries (i.e. 2, 6, 10, 14), since the
; LA_MOVEABLE bit is 02h.  Thus the address of the he_address field of
; a handle table entry is also the address of the handle table entry
; itself.

HandleTable STRUC
ht_count    DW  ?       ; # handletable entries in this block
ht_entry    DB SIZE HandleEntry DUP (?)
HandleTable ENDS

LocalHandleTable STRUC
lht_count    DW  ?      ; # handletable entries in this block
lht_entry    DB  SIZE LocalHandleEntry DUP (?)
LocalHandleTable ENDS

; Local arena objects are kept in a doubly linked list.

LocalArena  STRUC
la_prev     DW  ?   ; previous arena entry (first entry points to self)
la_next     DW  ?   ; next arena entry  (last entry points to self)
la_handle   DW  ?   ; back link to handle table entry
LocalArena  ENDS
la_fixedsize    = la_handle    ; Fixed arena headers stop here

LA_MINBLOCKSIZE = la_fixedsize*4  ;*** This must be larger than LocalArenaFree

; free blocks have these extra items.
la_size     = la_handle ; size of block (includes header data)
LocalArenaFree  STRUC
        DB  SIZE LocalArena DUP (?)
la_free_prev    DW  ?   ; previous free entry
la_free_next    DW  ?   ; next free entry
LocalArenaFree  ENDS
la_freefixedsize = SIZE LocalArenaFree ; Free block header stops here

; Local arena objects are aligned on 4 byte boundaries, leaving the
; low order two bits always zero.

LA_ALIGN    = 4-1
LA_MASK     = NOT LA_ALIGN
LA_FREE     = 00h
LA_BUSY     = 01h       ; Saved in la_prev field of header
errnz   <LA_ALIGN - LA_MOVEABLE - LA_BUSY>


; Flags passed to LocalAlloc (zero is the default case)

LA_MOVEABLE EQU 02h     ; Saved in la_prev field of header
LA_NOCOMPACT    EQU 10h
LA_ZEROINIT EQU 40h
LA_MODIFY   EQU 80h


; Data structure that describes the local arena.  Allocated as the first
; object in each local heap.  _pLocalHeap is a reserved location each
; automatic data segment that contains the pointer to this structure.

LocalInfo   STRUC
        DB  SIZE HeapInfo DUP (?)
li_notify   DD  ?   ; Far proc to call whenever a local block is moved
li_lock     DW  ?   ; arena lock word
li_extra    DW  ?   ; minimum amount to grow DS by
li_minsize  DW  ?   ; minimum size of heap
li_sig      DW  ?   ; signature for local heap
LocalInfo   ENDS

; Notify procedure message codes

LN_OUTOFMEM = 0     ; Out of memory - arg1 = #bytes needed
LN_MOVE     = 1     ; Object moved - arg1 = handle arg2 = old location
LN_DISCARD  = 2     ; Object discard? - arg1 = handle, arg2 = discard flags
            ; Returns new discard flags in AX

LocalStats  STRUC
ls_ljoin    DW  ?   ; #calls to ljoin
ls_falloc   DW  ?   ; #calls to lalloc with forward search
ls_fexamine DW  ?   ;   #arena entries examined by ls_falloc calls
ls_fcompact DW  ?   ;   #calls to lcompact by ls_falloc calls
ls_ffound   DW  ?   ;   #ls_falloc calls that found a block
ls_ffoundne DW  ?   ;   #ls_falloc calls that failed to find a block
ls_malloc   DW  ?   ; #calls to lalloc with backward search
ls_mexamine DW  ?   ;   #arena entries examined by ls_malloc calls
ls_mcompact DW  ?   ;   #calls to lcompact by ls_malloc calls
ls_mfound   DW  ?   ;   #ls_malloc calls that found a block
ls_mfoundne DW  ?   ;   #ls_malloc calls that failed to find a block
ls_fail     DW  ?   ; #times lalloc failed because unable to grow DS
ls_lcompact DW  ?   ; #calls to lcompact
ls_cloop    DW  ?   ; #repeated compacts after discarding
ls_cexamine DW  ?   ; #entries examined in compaction loop
ls_cfree    DW  ?   ; #free entries examined in compaction loop
ls_cmove    DW  ?   ; #moveable entries moved by compaction
LocalStats  ENDS


IncLocalStat    MACRO   n
if KDEBUG
inc ds:&n[di+SIZE LocalInfo]
endif
ENDM

; Global arena objects are kept in a doubly linked list.
;
ifdef WOWJUNK
GlobalArena STRUC
ga_count    DB  ?   ; lock count for movable segments
ga_flags    DB  ?   ; 1 byte available for flags
ga_owner    DW  ?   ; DOS 2.x 3.x owner field (current task)
ga_size     DW  ?   ; DOS 2.x 3.x size, in paragraphs, not incl. header
ga_prev     DW  ?   ; previous arena entry (first points to self)
ga_next     DW  ?   ; next arena entry (last points to self)
ga_handle   DW  ?   ; back link to handle table entry
ga_lruprev  DW  ?   ; Previous handle in lru chain
ga_lrunext  DW  ?   ; Next handle in lru chain
GlobalArena ENDS
else
GlobalArena STRUC
ga_count    DB  ?   ; lock count for movable segments
ga_owner    DW  ?   ; DOS 2.x 3.x owner field (current task)
ga_size     DW  ?   ; DOS 2.x 3.x size, in paragraphs, not incl. header
ga_flags    DB  ?   ; 1 byte available for flags
ga_prev     DW  ?   ; previous arena entry (first points to self)
ga_next     DW  ?   ; next arena entry (last points to self)
ga_handle   DW  ?   ; back link to handle table entry
ga_lruprev  DW  ?   ; Previous handle in lru chain
ga_lrunext  DW  ?   ; Next handle in lru chain
GlobalArena ENDS
endif; WOW
ga_sig       = byte ptr ga_count ; DOS =< 3.x signature byte for fixed segs

ga_freeprev = word ptr ga_lruprev   ; links for free segs
ga_freenext = word ptr ga_lrunext   ; links for free segs

if PMODE32

DEFAULT_ARENA_SIZE  equ 8000h   ; Initial length of arena array
;
;   32 bit Protect Mode Arena
;
GlobalArena32 STRUC
pga_next    DD  ?   ; next arena entry (last points to self)
pga_prev    DD  ?   ; previous arena entry (first points to self)
pga_address DD  ?   ; 32 bit linear address of memory
pga_size    DD  ?   ; 32 bit size in bytes
pga_handle  DW  ?   ; back link to handle table entry
pga_owner   DW  ?   ; Owner field (current task)
pga_count   DB  ?   ; lock count for movable segments
pga_pglock  DB  ?   ; # times page locked
pga_flags   DB  ?   ; 1 word available for flags
pga_selcount    DB  ?   ; Number of selectors allocated
pga_lruprev DD  ?   ; Previous entry in lru chain
pga_lrunext DD  ?   ; Next entry in lru chain
GlobalArena32 ENDS

.ERRNZ  32-size GlobalArena32

pga_sig      = word ptr pga_count

pga_freeprev    = dword ptr pga_lruprev ; links for free segs
pga_freenext    = dword ptr pga_lrunext ; links for free segs

endif   ; PMODE32

GA_SIGNATURE    = 04Dh
GA_ENDSIG   = 05Ah

; there are many special kinds of blocks, marked in the owner word

GA_SENTINAL = -1        ; a sentinal block
GA_BOGUS_BLOCK  = -7        ; a block temporary marked allocated
GA_BURGERMASTER = -3        ; the master object
GA_NOT_THERE    = -4        ; used with EEMS to link out unallocatable
                ; memory such as the EGA etc.
GA_PHANTOM  = -5        ; A block that has no EMS banks banked in.
GA_WRAITH   = -6        ; A block used to hold up partition headers.

; Global arena objects are aligned on 2 para. boundaries, leaving the
; low order bit always zero.

GA_ALIGN    = 2-1
GA_MASK     = NOT GA_ALIGN
GA_FIXED    = 1

; It is specific to WOW only. This handle was generated by WIN32, ChandanC.

GA_WOWHANDLE = 3

errnz   <GA_FIXED-GA_ALIGN>

; Low byte of flags passed to GlobalAlloc (zero is the default case)

GA_ALLOCHIGH    EQU 01h     ; Flag to indicate allocate high
GA_MOVEABLE EQU 02h
GA_SEGTYPE  EQU 0Ch     ; These 2 bits stored in he_flags field
GA_DGROUP   EQU 04h
GA_DISCCODE EQU 08h
GA_NOCOMPACT    EQU 10h
GA_NODISCARD    EQU 20h
GA_ZEROINIT EQU 40h
GA_MODIFY   EQU 80h

GA_NEWEXPANDED  EQU 80h     ; Use new EMS allocation scheme

; These flags for use by KERNEL only (caller's CS must match)

GA_INTFLAGS = GA_ALLOCHIGH+GA_SEGTYPE or (GA_CODE_DATA+GA_ALLOC_DOS) shl 8

; High byte of flags remembered in handle table (he_flags field)

GA_DISCARDABLE  EQU 01h     ; Boolean flag for global object, not a level.
GA_CODE_DATA    EQU 02h     ; CODE or DATA seg that belongs to a task.
;GA_DGROUP  EQU 04h
;GA_DISCCODE    EQU 08h
GA_ALLOC_LOW    EQU 10h     ; Alloc in Lower land, overrides GA_ALLOC_EMS
GA_SHAREABLE    EQU 20h     ; Shareable object
GA_DDESHARE EQU 20h     ; A shared memory object used for DDE.
;HE_DISCARDED   EQU 40h     ; Marks objects that have been discarded.
;GAH_NOTIFY EQU 40h
GA_ALLOC_DOS    EQU 80h     ; Alloc in DOS land if protected mode

GA_USERFLAGS    = GA_SHAREABLE + GA_DISCARDABLE

; Flags stored in the global arena header

GAH_PHANTOM EQU 01h     ; This block is either a phantom or a wraith
GAH_DONT_GROW   EQU 02h     ; Don't grow this data segment.
GAH_DGROUP  EQU GA_DGROUP
GAH_DISCCODE    EQU GA_DISCCODE
GAH_NOTIFY  EQU 40h
GAH_FIXED   EQU 80h

GAH_CURSORICON EQU 10h     ; WOW uses this flag

;
; GAH_PHANTOM is unused in Win 3.0 and Win 3.1
; ChandanC
;
GAH_WOWDDEFREEHANDLE EQU GAH_PHANTOM ; This is used to mark the DDE handle

;
; Global Memory Stats definitions
; Offsets in array
;
cGLOBALALLOC    EQU 0
cGLOBALREALLOC  EQU 4
cGLOBALFREE EQU 8
cGLOBALFREEALL  EQU 12
cGLOBALLOCK EQU 16
cGLOBALUNLOCK   EQU 20
cGLOBALSIZE EQU 24
cGLOBALCOMPACT  EQU 28
cLOCKSEGMENT    EQU 32
cUNLOCKSEGMENT  EQU 36
cGLOBALFIX  EQU 40
cGLOBALUNFIX    EQU 44
cGLOBALHANDLE   EQU 48
cGLOBALFLAGS    EQU 52
NGLOBALSTATS    EQU (56/4)

; Data structure that describes the global arena.  Allocated at the end
; of the local heap information structure.  DO NOT CHANGE THE ORDER OF
; THE ENTRIES!  The alt sequence and normal sequence must match!

GlobalInfo  STRUC
        DB  SIZE HeapInfo DUP (?)
gi_lrulock  DW  ?   ; Lock out access to LRU chain from interrupt level
ife PMODE32
gi_lruchain DW  ?   ; First handle in lru chain (most recently used)
else
gi_lruchain DD  ?   ; First handle in lru chain (most recently used)
endif
gi_lrucount DW  ?   ; #entries in LRU chain
ife PMODE32
gi_reserve  DW  ?   ; #paras to reserve for disc code, 0 => not enabled
gi_disfence DW  ?   ; Fence for discardable code.
else
gi_reserve  DD  ?   ; #paras to reserve for disc code, 0 => not enabled
gi_disfence DD  ?   ; Fence for discardable code.
endif
gi_free_count   DW  ?   ; Count of all the free partitions.

gi_alt_first    DW  ?   ; first entry in alternate arena
gi_alt_last DW  ?   ; last entry in alternate arena
gi_alt_count    DW  ?   ; count of entries in alternate arena
gi_alt_lruchain DW  ?   ; First handle in lru chain (most recently used)
gi_alt_lrucount DW  ?   ; #entries in LRU chain
gi_alt_reserve  DW  ?   ; alternate reserve
gi_alt_disfence DW  ?   ; Fence for discardable code.
gi_alt_free_count   DW  ?   ; Count of all the free partitions.
gi_alt_pPhantom DW  ?   ; Pointer to the first pPhantom block.
gi_disfence_hi  DW  ?   ; High word of fence
gi_flags    DW  ?   ; some flags!   !!! should merge with freeze and check
gi_stats    DD NGLOBALSTATS dup(?)
GlobalInfo  ENDS
gi_cmpflags = byte ptr hi_dislevel  ; Flags to control gcompact
gi_disfence_lo = word ptr gi_disfence

GIF_INT2    EQU 01h

BOOT_COMPACT    EQU 80h
COMPACT_ALLOC   EQU 40h     ; Fast abort in gcompact for allocations

CMP_FLAGS   EQU GA_NODISCARD or GA_NOCOMPACT or GA_DISCCODE or COMPACT_ALLOC

; Notify procedure message codes

GN_MOVE     = 1 ; Object moved - arg1 = handle arg2 = old location
GN_DISCARD  = 2 ; Object discard? - arg1 = handle, arg2 = discard flags
        ; Returns new discard flags in AX

SASTRUC     STRUC
sa_size     dw  0   ; size, in bytes, of the alias list
sa_allocated    dw  0   ; number of allocated entries
SASTRUC     ENDS

SAENTRY     STRUC
sae_sel     dw  0   ; selector of the object
sae_alias   dw  0   ; alias of the object
SAENTRY     ENDS

MAXFHCACHELEN = 12          ; Max number of file handles cached
MINFHCACHELEN = 2           ; Min number of file handles cached

fhCacheStruc    struc
    Cachefh     dw  ?   ; File handle
    CacheExe    dw  ?   ; Exe handle
fhCacheStruc    ends

; NAMETBL is a structure defining a private resource called a name table.
; It is a resource that maps string resource types and names into unique
; ordinal ids - this way all resources identified by name or type with
; a string can actually be loaded by id. This is for OS/2 compatibility
; with named resources.
;
; typedef struct nametbl {   /* ntbl */
;    int cbEntry;            /* size of structure */
;    int idType;             /* type id or string replc if (idType & RSORDID) */
;    int idName;             /* name id or string replc if (idName & RSORDID) */
;    char achTypeName[1];    /* 0 term type followed by 0 term name */
; } NAMETBL;
ntbl    struc
    ntbl_cbEntry     dw ?
    ntbl_idType      dw ?
    ntbl_idName      dw ?
    ntbl_achTypeName db ?
ntbl    ends

RT_NAMETABLE equ 15

ifdef WOW
if PMODE32
PAGE_READWRITE	EQU 0004h
MEM_COMMIT	EQU 1000h
MEM_RESERVE	EQU 2000h
MEM_RELEASE	EQU 8000h
MEM_COMMIT_RESERVE EQU 3000h
endif
endif

ifdef WOW
ife PMODE32
DpmiBlock struc
    DBSize dw 0
    DBSel dw 0
    DBHandleLow dw 0
    DBHandleHigh dw 0
DpmiBlock ends
NUM_DPMI_BLOCKS equ 20
endif
endif

ifdef WOW_x86
FLAT_SEL equ 23H
endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\el\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET)  \
	 DBCS_FLAGS="-DFE_SB" 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\wow16cal.asm ===
TITLE   WOW16CAL.ASM
    PAGE    ,132
;
; WOW v1.0
;
; Copyright (c) 1991, Microsoft Corporation
;
; WOW16CAL.ASM
; Thunk router in 16-bit space to route Windows API calls to WOW32
;
; History:
;   25-Jan-1991 Jeff Parsons (jeffpar) Created.
;   24-Apr-91   Matt Felton (mattfe) Incorporated into Kernel
;   29-May-91   Matt Felton (mattfe) Added Multi-Tasking
;   30-Apr-1992 Mike Tricker (MikeTri) Added MultiMedia callbacks
;
;   .xlist
    include kernel.inc
    include tdb.inc
    include dbgsvc.inc
    include wow.inc
    include dpmi.inc
    include cmacros.inc

; include NEW_SEG1 struc used in GetProcModule

    include newexe.inc

    .list

    HACK16  equ 1           ;enable hacks

.286p

Entry   macro name
    ;align 16
    public name
    name&:
    endm

externFP SETCURSORICONFLAG
externFP SETDDEHANDLEFLAG
externFP LOCALALLOC
externFP LOCALREALLOC
externFP LOCALLOCK
externFP LOCALHANDLE
externFP LOCALUNLOCK
externFP LOCALSIZE
externFP LOCALFREE
externFP LOCALINIT
externFP LOCKSEGMENT
externFP UNLOCKSEGMENT
externFP GLOBALALLOC
externFP GLOBALLOCK
externFP GLOBALHANDLE
externFP GLOBALUNLOCK
externFP GLOBALSIZE
externFP GLOBALFREE
externFP FINDRESOURCE
externFP LOADRESOURCE
externFP FREERESOURCE
externFP LOCKRESOURCE
externFP SIZEOFRESOURCE
externFP Int21Handler
externFP IsBadReadPtr
externFP GetSelectorLimit
externFP GetExpWinVer
externNP SwitchTask
externNP WOW16TaskStarted
externFP GetExePtr
externFP GetModuleUsage
externFP WOWGetFastAddress
externFP WOWGetFastCbRetAddress
externFP WowGetFlatAddressArray
externFP WOWNotifyWOW32
externFP GETMODULEHANDLE
externFP GETPROCADDRESS
externFP PrestoChangoSelector
externFP GetModuleFileName
externFP WinExec
externW  gdtdsc
externW  pLocalHeap
externW  hUser
externNP SetOwner
externFP WowCheckUserGdi
externFP GetExePtr
externFP FatalExit

sBegin  NRESCODE
externFP get_sel_flags
externFP set_sel_for_dib
externFP RestoreDib
sEnd    NRESCODE

DataBegin
externW wCurTaskSS
externW wCurTaskBP
externW Win_PDB              ;MikeTri - extracting DOS PDB and SFT
externD pFileTable
externB fExitOnLastApp
externD plstrcmp

externW THHOOK
externD FastBop
externD FastWOW
externW FastWOWCS
externD FastWOWCbRet
externW FastWOWCbRetCS
externD FlatAddressArray
externW WOWFastBopping
externW curTDB
externW cur_drive_owner
externW LockTDB
externB num_tasks
externW DebugWOW
externW topPDB
externW TraceOff
externD pDosWowData
;ifdef FE_SB
;externW hModNotepad
;endif ; FE_SB

UserModuleName DB 'USER.EXE', 0

DataEnd


sBegin  CODE
assumes CS,CODE
assumes DS,NOTHING
assumes ES,NOTHING

        public  apfnWOW16Func       ;make public to help debugging
apfnWOW16Func   dw  WOW16Return     ;order MUST match RET_* (wow.h)
        dw  WOW16DebugReturn
        dw  WOW16Debug
        dw  WOW16WndProc
        dw  WOW16EnumFontProc
        dw  WOW16EnumWindowProc
        dw  WOW16LocalAlloc
        dw  WOW16LocalReAlloc
        dw  WOW16LocalLock
        dw  WOW16LocalUnlock
        dw  WOW16LocalSize
        dw  WOW16LocalFree
        dw  WOW16GlobalAllocLock
        dw  WOW16GlobalLock
        dw  WOW16GlobalUnlock
        dw  WOW16GlobalUnlockFree
        dw  WOW16FindResource
        dw  WOW16LoadResource
        dw  WOW16FreeResource
        dw  WOW16LockResource
        dw  WOW16GlobalUnlock   ;there is no UnlockResource
        dw  WOW16SizeofResource
        dw  WOW16LockSegment
        dw  WOW16UnlockSegment
        dw  WOW16EnumMetaFileProc
        dw  WOW16TaskStartedTmp        ; in Tasking.asm
        dw  WOW16HookProc
        dw  WOW16SubClassProc
        dw  WOW16LineDDAProc
        dw  WOW16GrayStringProc
        dw  WOW16ForceTaskExit
        dw  WOW16SetCurDir
        dw  WOW16EnumObjProc
        dw  WOW16SetCursorIconFlag
        dw  WOW16SetAbortProc
        dw  WOW16EnumPropsProc
        dw  WOW16ForceSegmentFault
        dw  WOW16lstrcmp
        dw  0                           ;FREE
        dw  0                           ;FREE
        dw  0                           ;FREE
        dw  0                           ;FREE
        dw  WOW16GetExePtr
        dw  0                          ; WOW16GetModuleUsage removed
        dw  WOW16ForceTaskFault
        dw  WOW16GetExpWinVer
        dw  WOW16GetCurDir
        dw  WOW16GetDosPDB
        dw  WOW16GetDosSFT
        dw  WOW16ForegroundIdle
        dw  WOW16WinsockBlockHook
        dw  WOW16SetDdeHandleFlag
        dw  WOW16ChangeSelector
        dw  WOW16GetModuleFilename
        dw  WOW16WordBreakProc
        dw  WOW16WinExec
        dw  WOW16WOWCallback16
        dw  WOW16GetDibSize
        dw  WOW16GetDibFlags
        dw  WOW16SetDibSel
        dw  WOW16FreeDibSel
;ifdef FE_SB
;        dw  WOW16SetFNotepad           ; for Lotus Freelance for Win
;endif ; FE_SB

functableend equ $

; the aRets table looks like this: ...retf, ...retf 2, ...retf 4,  ...

CRETENTRIES equ 020h
; generate the retf n codetable

    bytes = 0
    REPT CRETENTRIES
        align 8
        IFE  bytes
aRets:
        ENDIF
        pop  bx             ;restore app BX
        pop  bp
        add  sp, 0ah          ;pop thunk ret address, wCallID/lpfn, wArgs
        retf bytes
    bytes = bytes + 2
    ENDM
align 8
rettableend equ $
RETFCODESIZE equ (rettableend - aRets) / CRETENTRIES
.errnz ((rettableend - aRets) AND 01h)  ; complain if odd
.erre (RETFCODESIZE EQ 08h)
                                   ; if the size is not 8 bytes need to
                                   ; change the code that indexes 'aRets'

;----------------------------------------------------------------------------
; these comments are a result of hard labour (so called  'fruits'
; of hard labour)
;
; 1. If you make a change in VDMFRAME or similar such change, make sure
;    tasking.asm is in sync. pay attention to the labels wow16doneboot,
;    wow16taskstarted and the resetting of vf_wES (all in tasking.asm)
;
; 2. The general purpose registers es, bx, cx which are saved around the
;    the api thunks. LATER these have to be removed with care and caution.
;    If you just remove the push/pop of these, kernel31 won't boot.
;    These registers will have to be saved around certain calls in krnl286/386
;    for it to  boot.
;
;                                            - nanduri ramakrishna
;
;-----------------------------------------------------------------------------


;-----------------------------------------------------------------------------
; NOTES:
;
; the frame at time of bop is of type VDMFRAME
; the frame at the time of a callback is CBVDMFRAME.
; VDMFRAME and CBVDMFRAME share the first few fields (the order is important)
; but the structures don't overlap.
;
;   ie stack looks like this
;
;               ss:sp = VDMFRAME
;               ...  BOP ....
;  if return from BOP:
;               ss:sp = VDMFRAME
;  if from callback16:
;               ss:sp = CBVDMFRAME
;                .....callback function...
;                                               - nanduri ramakrishna
;-----------------------------------------------------------------------------

    assumes ds, nothing
    assumes es, nothing

align 16
cProc WOW16Call,<PUBLIC,FAR>
    ; parmW   wArgs       ; # paramater bytes pushed for this API
    ; parmW   wCallID


; note that 'bp' of api thunk and callback differ

    pFrame    equ [bp-vf_wBP]
    wAppBX    equ [pFrame].vf_wBX
    wApiRetID equ [pFrame].vf_wRetID
    wAX       equ [pFrame].vf_wAX
    wArgs     equ [pFrame].vf_cbArgs

; for callback16

    pCBFrame  equ [bp-cvf_Parm16];
    vpfnProc  equ [pCBFrame].cvf_vpfnProc
    hInst     equ [pCBFrame+cvf_Parm16].wp_hInst
    hwnd      equ [pCBFrame+cvf_Parm16].wp_hwnd
    wMsg      equ [pCBFrame+cvf_Parm16].wp_wMsg
    wParam    equ [pCBFrame+cvf_Parm16].wp_wParam
    lParam    equ [pCBFrame+cvf_Parm16].wp_lParam

    vpfnWndProc equ [di-cvf_Parm16].cvf_vpfnProc

    lpstr1     equ [pCBFrame+cvf_Parm16].lstrcmpParms.lstrcmp16_lpstr1
    lpstr2     equ [pCBFrame+cvf_Parm16].lstrcmpParms.lstrcmp16_lpstr2

    cbackAX equ [pCBFrame].cvf_wAX   ;
    cbackDX equ [pCBFrame].cvf_wDX
    wGenUse1   equ [pCBFrame].cvf_wGenUse1
    wGenUse2   equ [pCBFrame].cvf_wGenUse2
    vfSP       equ [pCBFrame].cvf_vpStack   ; lo word is sp = ptr to vdmframe

; The stack frame here is defined in wow.h make sure they match
; the order is very important.

cBegin nogen

wc_set_vdmframe:
    push bp
    mov  bp, sp                     ; standard frame
    push bx                         ; REMOVE LATER APPs BX
    push es                         ; REMOVE LATER
    push cx                         ; REMOVE LATER
.386
    ; %OUT building 386
    push fs
    push gs
.286
    push ds
    sub  sp, 4                      ; room for api dword return value
    push si                         ; standard regs
    push di

WOW16ApiCall:
    push bp
    push    RET_RETURN  ;push default wRetID (do not move see tasking.asm)
    SetKernelDS ds
    push    [curTDB]        ;save current 16bit task handle (see tasking.asm)
    mov di,ss
    mov [wCurTaskSS],di     ;save current task SS
    mov [wCurTaskBP],bp     ;save current task BP

;   We don't want to allow debuggers to trace into 32 bit land, since they
;   will get lost.

    mov     TraceOff,1h

    test    [WOWFastBopping], 0ffffh
    jz      WOW16SlowVector

WOW16FastVector:

.386
    call    fword ptr [FastWOW]
.286
    jmp     short WOW16CallContinue

    public WOW16SlowVector
Entry   WOW16SlowVector
    BOP BOP_WOW

    public WOW16CallContinue
WOW16CallContinue:  ; don't move this label!  see comment below

    SetKernelDS ds

    xor     ax,ax
    xchg    TraceOff,ax
    test    ax,2h                        ; Turn Tracing Back on ?
    jnz     turn_on_trace_bit

W16C_010:
;   Check for Task Switch
    pop ax                               ; retrieve current task ID
    cmp ax, [curTDB]                     ; Task Switch ?
    jnz jmpSwitchTask                    ; Yes -> Perform Task Switch

    public WOW16CallNewTaskRet           ; from tasking.asm
WOW16CallNewTaskRet:

    pop bx                               ;retrieve wRetID
    pop bp                               ;localbp
    cmp bx, RET_RETURN
    jnz WOW16_From_CallBack16

    public WOW16Return
WOW16Return:

    ; we don't want to return to the thunk, that's just going to
    ; do a RETF n  where n is the # of parameters to the API.
    ; doing this takes about half the time of a RETF on a 486
    ; according to the clock counts in the book.  but RETF also flushes
    ; the instruction prefetch queue, and we're touching one less page
    ; (probably a TLB miss if we're coming back from a call with a long
    ; code path).

wc_restore_regs:

    pop  di
    pop  si
    pop  ax             ;
    pop  dx
    pop  ds
.386
    pop  gs
    pop  fs
.286

    pop  cx                         ; REMOVE LATER
    pop  es                         ; REMOVE LATER
    mov  bx,wArgs       ; get the # of bytes this API took
if KDEBUG
    or   bx, bx
    jz   @F
    test bx, 01h
    jz   @F
    int 3               ; error. odd #bytes to pop
@@:
    cmp  bx, CRETENTRIES * 2
    jl   @F
    int 3               ; error. outside aRets tablerange
@@:
endif
    shl  bx, 2          ; convert it to offset into aRets table
    add  bx, codeoffset aRets
    jmp  bx             ; dispatch to the right RETF n


;
;   If a debugger was tracing the app then reenable on the 16 bit side again
;

turn_on_trace_bit:
    pushf
    pop     ax
    or      ax,FLG_TRAP
    push    ax
    popf
    jmps    W16C_010


    public WOW16_From_CallBack16
WOW16_From_CallBack16:      ; exception RET_DEBUGRETURN and RET_TASKSTARTED
    mov si, bp              ; save bp, dont push on stack
    mov bp, sp              ; for convenience.

    mov ax, ss
    mov es, ax
    mov ds, ax

    mov ax, cbackAX         ; for prolog initialization
    add bx,bx
    jmp apfnWOW16Func[bx]   ;route to appropriate function handler


    public WOW16DebugReturn
Entry   WOW16DebugReturn
     ; undo the 'callback' munging
    mov bp, si
    int 3               ;that's all folks
    jmps WOW16Return

jmpSwitchTask:
    jmp SwitchTask  ; Go perform a Task Switch

    public WOW16TaskStartedTmp
Entry  WOW16TaskStartedTmp
     ; undo the 'callback' munging
    mov  bp, si

    pop  di
    pop  si
    pop  ax             ;
    pop  dx
    pop  ds

.386
    pop  gs
    pop  fs
.286
    pop  cx                         ; REMOVE LATER
    pop  es                         ; REMOVE LATER
    pop  bx                         ; pop  bx  ; REMOVE LATER;
    mov  wApiRetID, RET_RETURN
    jmp  WOW16TaskStarted

;
; Call Back Routines
; On entry, SS:SP points to PARM16 structure
; Assumes PARM16 is followed by vpfn
;

    public WOW16WOWCallback16
Entry   WOW16WOWCallback16    ; 32-bit generic callback

    call    [vpfnProc]        ; call the target proc
    mov     si, [wGenUse1]    ; si = cbArgs
    sub     sp, si            ; undo effect of "RET cbArgs"
    jmp WOW16Done

    public WOW16WndProc
Entry   WOW16WndProc

; don't expect si and di to be saved by the callback function - so save the
; critical info elsewhere like on stack.

; we set 'si' to 'hwnd'. this fixes a bug in QuickCase (qcasew.exe) where
; options.tools.add doesn't bring up a dialog box.
;
    mov     cx,hwnd         ;for later use
    mov     di,bp           ;MSAccess debug version walks BP chain.  they're
    mov     bp,si           ; testing it for us, let's make it easier for them.
    mov     wAX,di          ;save current bp in vdmframe.wAX - temporary
                            ;note:
                            ;   current 'bp (ie di) = 'sp' ,also vdmFrame can be
                            ;   accessed with the new 'bp' (ie 'si').
    mov     si,cx           ;si has hwnd
    call    [vpfnWndProc]   ;call the window proc (AX already set)
    mov     bp,wAX          ;restore pre-callback bp
    mov     sp,bp           ;restore pre-callback sp
    jmp     WOW16Done       ;call back to WOW32

    public WOW16EnumFontProc
Entry   WOW16EnumFontProc

    call    [vpfnProc]      ;call the font proc
ifdef FE_SB  ; HACK for Golf , MS-GolfJ has ( retf  0x34 )!!!
    mov     sp,bp
else
    sub     sp,size PARMEFP ;undo the effect of the proc's RET 0Eh
endif ;FE_SB
    jmp     WOW16Done       ;call back to WOW32

    public WOW16EnumObjProc
Entry   WOW16EnumObjProc
    call    [vpfnProc]      ;call the obj proc
    sub     sp,size PARMEOP ;undo the effect of the proc's RET 0Eh
    jmp     WOW16Done       ;call back to WOW32

    public WOW16EnumWindowProc
Entry   WOW16EnumWindowProc
    call    [vpfnProc]      ;call the font proc
    sub     sp,size PARMEWP ;undo the effect of the proc's RET 06h
    jmp     WOW16Done       ;call back to WOW32

    public WOW16LineDDAProc
Entry   WOW16LineDDAProc
    call    [vpfnProc]      ;call the Line DDA proc
    sub     sp,size PARMDDA     ;undo the effect of the proc's RET 0Eh
    jmp     WOW16Done       ;call back to WOW32

    public WOW16GrayStringProc
Entry   WOW16GrayStringProc
    call    [vpfnProc]      ;call the Graystring proc
    sub     sp,size PARMGST     ;undo the effect of the proc's RET 0Eh
    jmp     WOW16Done       ;call back to WOW32

    public WOW16EnumPropsProc
Entry   WOW16EnumPropsProc
    call    [vpfnProc]      ;call the obj proc
    sub     sp,size PARMEPP ;undo the effect of the proc's RET
    jmp     WOW16Done       ;call back to WOW32

    public WOW16WordBreakProc
Entry   WOW16WordBreakProc
    call    [vpfnProc]      ;call the wordbreak proc
    sub     sp,size PARMWBP ;undo the effect of the proc's RET
    jmp     WOW16Done       ;call back to WOW32

if 0
;
; MultiMedia callbacks - MikeTri 30-Apr-1992
;

Entry   WOW16MidiInFunc
    call    [vpfnProc]      ;call the MidiIn proc
    sub sp,size PARMMIF     ;undo the effect of the proc's RET 12h
    jmp WOW16Done           ;call back to WOW32

Entry   WOW16MidiOutFunc
    call    [vpfnProc]      ;call the MidiOut proc
    sub sp,size PARMMOF     ;undo the effect of the proc's RET 12h
    jmp WOW16Done           ;call back to WOW32

Entry   WOW16IOProc
    call    [vpfnProc]      ;call the MMIO proc
    sub sp,size PARMIOP     ;undo the effect of the proc's RET 0Eh
    jmp WOW16Done           ;call back to WOW32

Entry   WOW16TimeFunc
    call    [vpfnProc]      ;call the Time proc
    sub sp,size PARMTIF     ;undo the effect of the proc's RET 10h
    jmp WOW16Done           ;call back to WOW32

Entry   WOW16WaveInFunc
    call    [vpfnProc]      ;call the WaveIn proc
    sub sp,size PARMWIF     ;undo the effect of the proc's RET 12h
    jmp WOW16Done           ;call back to WOW32

Entry   WOW16WaveOutFunc
    call    [vpfnProc]      ;call the WaveOut proc
    sub     sp,size PARMWOF ;undo the effect of the proc's RET 12h
    jmp     WOW16Done       ;call back to WOW32
endif

Entry   WOW16LocalAlloc
    mov     ax,wMsg         ; set up DS with hInstance
    mov     ds,ax

    cmp     ds:[pLocalHeap], 0  ; already have a local heap in this DS?
    jnz     @f                  ;   yes

    ; we need to LocalInit this segment
    ; note: Win3.1 doesn't check return codes on GlobalSize, LocalInit

    push    ds
    call    far ptr GLOBALSIZE
    sub     ax, 64

    push    ds
    push    0
    push    ax
    call    far ptr LOCALINIT

    push    ds
    call    far ptr UNLOCKSEGMENT

@@:

    push    wParam          ;push wFlags
    push    lParam.lo       ;push wBytes
    call    far ptr LOCALALLOC  ;get hmem in AX
    mov     dx,ds           ; return DS in hiword of handle
    jmp     WOW16Done       ;

Entry   WOW16LocalReAlloc
    mov     ax,lParam.hi    ; set up DS with value from alloc
    mov     ds,ax

    push    lParam.lo       ;push hMem
    push    wMsg            ;push wBytes
    push    wParam          ;push wFlags
    call    far ptr LOCALREALLOC;get hmem in AX
    mov     dx,ds           ;hiword of handle=DS
    jmp     WOW16Done

Entry   WOW16LocalLock

if  0

; HACK32   remove this!

    mov     ax,lParam.hi    ; set up DS with value from alloc
    mov     ds,ax

    push    lParam.lo       ;push hMem
    call    far ptr LOCALLOCK   ;
    sub     dx,dx       ;
    or      ax,ax           ;
    jz      short lalock_done   ;
    IFDEF   HACK16
    push    ax
    push    -1
    call    far ptr LOCKSEGMENT
    pop     ax
    ENDIF
    mov dx,ds           ;if success, return full address in DX:AX
lalock_done:                ;

endif

    jmp WOW16Done       ;

Entry   WOW16LocalUnlock
if  0

; HACK32   remove this!

    mov     ax,lParam.hi    ; set up DS with value from alloc
    mov     ds,ax

    push    lParam.lo       ;push hMem
    call    far ptr LOCALUNLOCK ;
    or      ax,ax       ;
    jnz     short lufree_done   ;
    IFDEF   HACK16
    push    -1
    call    far ptr UNLOCKSEGMENT
    sub     ax,ax   ;
    ENDIF
lufree_done:                ;
    cwd             ;

endif

    jmp WOW16Done       ;

Entry   WOW16LocalSize
    mov     ax,lParam.hi    ; set up DS with value from alloc
    mov     ds,ax

    push    lParam.lo       ;push hMem
    call    far ptr LOCALSIZE   ;
    sub     dx,dx
    jmp     WOW16Done

Entry   WOW16LocalFree
    push    es              ; IsBadReadPtr can trash ES and BX
    push    bx
    mov     ax,lParam.hi    ; get selector of current local heap
    push    ax              ; set up for call to IsBadReadPtr
    push    0
    push    1
    call    far ptr IsBadReadPtr  ; is selector still valid?
    pop     bx
    pop     es
    or      ax,ax
    jnz     wlf_done              ; ax != 0 -> nope!

    mov     ax,lParam.hi    ; set up DS with value from alloc
    mov     ds,ax

    push    lParam.lo       ;push hMem
    call    far ptr LOCALFREE   ;
wlf_done:
    jmp WOW16Done       ;


Entry   WOW16GlobalAllocLock
    push    wParam          ;push wFlags
    push    lParam.hi       ;push dwBytes
    push    lParam.lo       ;
    call    far ptr GLOBALALLOC ;get hmem in AX
    sub     dx,dx           ;
    or      ax,ax           ;
    jz      short galock_done   ;
    push    ax          ;save hmem
    push    ax          ;push hmem
    call    far ptr GLOBALLOCK  ;get seg:off in DX:AX
    pop     bx          ;recover hmem in BX
galock_done:                ;
    mov     wGenUse1, bx
    jmp     WOW16Done       ;

Entry   WOW16GlobalLock
    push    wParam          ;push hMem
    call    far ptr GLOBALLOCK  ;
    push    ax          ;save return value
    push    dx          ;
    or      ax,dx
    jz      glock_exit
    push    wParam          ;push hMem
    call    far ptr GLOBALSIZE  ;
glock_exit:
    mov     wGenUse2,ax           ;save size
    mov     wGenUse1,dx           ;
    pop     dx          ;
    pop     ax          ;
    jmp     WOW16Done       ;

Entry   WOW16GlobalUnlock
    push    wParam          ;push hMem
    call    far ptr GLOBALUNLOCK;
    cmp     ax,1            ;
    sbb     ax,ax           ;
    cwd             ;make return code a full 32-bits
    jmp WOW16Done       ;

Entry   WOW16GlobalUnlockFree
    push    lParam.hi       ;push segment of address to free
    call    far ptr GLOBALHANDLE;
    or      dx,ax           ;valid handle?
    jz      short gufree_done   ;no
    push    ax          ;save a copy of hmem for the free
    push    ax          ;push hmem to unlock
    call    far ptr GLOBALUNLOCK;
    pop     cx          ;recover copy of hmem
    or      ax,ax           ;is lock count now zero?
    jnz     short gufree_err    ;no
    push    cx          ;push hmem to free
    call    far ptr GLOBALFREE  ;
gufree_exit:                ;
    or      ax,ax           ;
    mov     ax,1            ;if success, return TRUE; otherwise, FALSE
    jz      short gufree_done   ;
gufree_err:             ;
    sub     ax,ax           ;
gufree_done:                ;
    cwd             ;
    jmp     WOW16Done       ;

Entry   WOW16FindResource
    push    wParam          ;push hTask
    call    far ptr GetExpWinVer
    push    ax              ;save expwinver

    push    wParam          ;push hTask
    push    lParam.hi       ;push vpName
    push    lParam.lo       ;
    push    hwnd            ;push vpType
    push    wMsg            ;
    call    far ptr FINDRESOURCE;
;    or  ax,ax              ;
;    jz  short findres_done ;
;findres_done:              ;
    cwd                     ;make return code a full 32-bits
    pop     cx              ; expwinver
    mov     wGenUse1, cx
    jmp  WOW16Done     ;

Entry   WOW16LoadResource
    push    wParam          ;push hTask
    push    lParam.lo       ;push hResInfo
    call    far ptr LOADRESOURCE;
    cwd             ;make return code a full 32-bits
    jmp  WOW16Done     ;

Entry   WOW16FreeResource
    push    wParam          ;push hResData
    call    far ptr FREERESOURCE;
    cmp ax,1
    sbb ax,ax
    cwd              ;make return code a full 32-bits
    jmp WOW16Done

Entry   WOW16LockResource
    push    wParam       ;hResData
    call    far ptr LOCKRESOURCE;
    push    ax          ; save res pointer
    push    dx
    or      dx,dx

; I commented out the following code because it is breaking the US builds
; in the case where hResData is bad.  If you put code like this in, please
; comment in *detail* (with bug number perhaps) why you did.
; In this case, jz lres_err isn't accounting for the push ax, push dx
; instructions above.  If there is a case where the stack is off by 4 bytes
; please put a note in as to how & why.  - cmjones
;
;ifdef FE_SB             ;avoid to break stack
;    jz      lres_err
;else
    jz      lres_exit
;endif ; FE_SB
    push    wParam       ;push hResData
    call    far ptr GLOBALSIZE
lres_exit:
    mov     wGenUse2,ax           ;save size
    mov     wGenUse1,dx           ;
    pop     dx
    pop     ax
    jmp     WOW16Done

; see "I commented out..." note above
;ifdef FE_SB            ;avoid to break stack
;lres_err:
;    xor     ax,ax
;    jmp     WOW16Done
;endif ; FE_SB

Entry   WOW16SizeofResource
    push    wParam       ;push hTask
    push    lParam.lo        ;push hResInfo
    call    far ptr SIZEOFRESOURCE          ; DX:AX is DWORD size
    jmp     WOW16Done

Entry   WOW16LockSegment
    push    wParam       ;push wSeg
    call    far ptr LOCKSEGMENT
    sub     dx,dx
    jmp     WOW16Done

Entry   WOW16UnlockSegment
    push    wParam          ;push wSeg
    call    far ptr UNLOCKSEGMENT
    cmp ax,1
    sbb ax,ax
    cwd              ;make return code a full 32-bits
    jmp  WOW16Done

;MikeTri Beginning of temporary hack for testing - 17-Aug-1992

Entry   WOW16GetDosPDB
    push ds                     ;Save DS
    SetKernelDS                 ;Pick up Kernel DS
    mov  dx, Win_PDB            ;Copy Windows PDB to DX (selector)
    mov  ax,0                   ;Move 0 to AX (offset)
    UnSetKernelDS               ;Get rid of kernel DS
    pop  ds                     ;Restore callers DS
    jmp  WOW16Done              ;Exit

Entry   WOW16GetDosSFT
    push ds                     ;Save DS
    SetKernelDS                 ;Pick up Kernel DS
    mov  dx,pFileTable.sel      ;Move SFT selector value to DX
    mov  ax,pFileTable.off      ;Move SFT offset value to AX
    UnSetKernelDS               ;Get rid of kernel DS
    pop  ds                     ;Restore callers DS
    jmp  WOW16Done

;MikeTri End of temporary hack for testing - 17-Aug-1992

Entry   WOW16EnumMetaFileProc
    call    [vpfnProc]          ;call the apps MetaFile proc
    sub     sp,size PARMEMP     ;undo the effect of the proc's RET 0x10h
    jmp     WOW16Done   ;call back to WOW32

Entry   WOW16HookProc

    call    [vpfnProc]          ;call the apps Hook Proc.
    sub     sp,size PARMHKP      ;undo the effect of the proc's RET 0x08h
    jmp     WOW16Done   ;call back to WOW32


Entry   WOW16SetAbortProc
    call    [vpfnProc]          ;call the apps abort proc
;   sub     sp,size PARMSAP     ;undo the effect of the proc's RET 0x04h
;
;   Use 'bp' to restore 'sp' instead of subtracting 4bytes from sp. this is
;   because Wordperfect's Informs doesn't pop the arguments off the stack.
;   However it preserves 'bp'.
;
;   Here in wow, sp is same as bp .  The correct value  is in 'bp' - see
;   WOW16_From_CallBack16
;
;   Similar fix can also be found in win31 - core\gdi, function queryabort()
;
;                                   - nandurir
;

    mov     sp, bp
    jmp     WOW16Done           ;call back to WOW32


Entry   WOW16SubClassProc

    push    ds
    SetKernelDS ds
    mov     ax, hUser
    pop     ds                       ; restore ds
    UnSetKernelDS ds
    pop     cx                       ; cx = the ordinal number
    push    cx                       ; restore stack pointer
    push    ax                       ; hModule
    push    0                        ; hiword of ordinal number
    push    cx                       ; the ordinal
    call    GetProcAddress
    jmp     WOW16Done   ;call back to WOW32

Entry   WOW16SetCurDir
    call    SetCurrentDrive           ; on the stack is drive number;
    call    WOW16SetCurrentDirectory  ; on the stack is directory name;
    sub     sp,size PARMDIR           ; restore stack
    jmp     WOW16Done   ;call back to WOW32


Entry   WOW16SetDdeHandleFlag
    push    wParam          ;push hMem
    push    wMsg            ;push fSet
    call    far ptr SETDDEHANDLEFLAG
    jmp     WOW16Done       ;


Entry   WOW16SetCursorIconFlag
    push    wParam          ;push hMem
    push    wMsg            ;push fSet
    call    far ptr SETCURSORICONFLAG
    jmp     WOW16Done       ;


Entry   WOW16GetExePtr
    push    wParam          ;push hInstance
    call    GetExePtr
    jmp     WOW16Done

;ifdef FE_SB
;Entry   WOW16SetFNotepad
;    push    ds
;    SetKernelDS                 ; pick up Kernel DS
;    mov     ax,wParam
;    mov     hModNotepad,ax      ; handle of notepad32
;    pop     ds                  ; restore ds
;    UnSetKernelDS ds
;    jmp     WOW16Done
;endif ; FE_SB

Entry   WOW16ForceTaskExit
    mov     ax,4CFFH        ; Hung App Support Forces Current Task to Exit
    DOSCALL
    INT3_NEVER

Entry   WOW16GetModuleFilename
    push    wParam      ; hInstance
    push    lParam.hi   ; selector of filename buffer
    push    lParam.lo   ; offset   of filename buffer
    push    wMsg        ; bytes    in filename buffer
    call    far ptr GetModuleFileName
    jmp     WOW16Done       ; Just return return value

Entry   WOW16WinExec
    push    lParam.hi   ; selector of lpszCmdLine
    push    lParam.lo   ; offset   of lpszCmdLine
    push    wParam      ; fuCmdShow
    call    far ptr WinExec
    jmp    WOW16Done       ; Just return return value

Entry   WOW16GetExpWinVer
    push    wParam          ;push hInstance
    call    GetExpWinVer
    jmp     WOW16Done

Entry   WOW16GetCurDir
    call    WOW16GetCurrentDirectory
    sub     sp,size PARMDIR           ; restore stack
    jmp     WOW16Done   ;call back to WOW32


Entry   WOW16ForceTaskFault
    ; %OUT    Ignore Impure warning A4100 its required for Forcing a GP Fault
    mov     cs:gdtdsc,0     ; Force a GP Fault - Write to our CS
    jmp     WOW16ForceTaskFault

Entry   WOW16ForceSegmentFault
    push    es          ; IsBadReadPtr can trash ES & BX
    push    bx
    push    lParam.hi   ; selector of lp
    push    lParam.lo   ; offset   of lp
    push    1           ; min byte size
    call    far ptr IsBadReadPtr  ; force segment fault or handle GPF
    pop     bx
    pop     es
    jmps    WOW16Done

Entry   WOW16lstrcmp
    push ds                     ;Save DS
    SetKernelDS                 ;Pick up Kernel DS
    push    word ptr lpstr1[2]
    push    word ptr lpstr1[0]
    push    word ptr lpstr2[2]
    push    word ptr lpstr2[0]
    call    [plstrcmp]
    UnSetKernelDS               ;Get rid of kernel DS
    pop  ds                     ;Restore callers DS
    jmps    WOW16Done

Entry   WOW16ForegroundIdle
    mov     ax,1689h        ;notify application that the foreground
    int     2fh             ;task has gone idle
    jmps    WOW16Done

Entry   WOW16WinsockBlockHook
    call    [vpfnProc]          ;call the apps Hook Proc.
    jmps    WOW16Done           ;call back to WOW32

Entry   WOW16ChangeSelector
    push    wParam          ;push wSeg
    push    wParam          ;push wSeg
    call    far ptr PRESTOCHANGOSELECTOR;
    cCall   SetOwner,<wParam,-1>   ; Make this new guy the owner
    jmps    WOW16Done       ; Just return return value

Entry   WOW16GetDibSize
    push    wParam      ; selector for which size is being queryed
    call    far ptr GetSelectorLimit
    jmps    WOW16Done       ; Just return return value

Entry   WOW16GetDibFlags
    cCall   get_sel_flags,<wParam>
    jmps    WOW16Done       ; Just return return value

Entry   WOW16SetDibSel
    cCall   set_sel_for_dib,<wParam,wMsg,lParam.lo,lParam.hi,hwnd>
    jmps    WOW16Done       ; Just return return value

Entry   WOW16FreeDibSel
    cCall   RestoreDib,<wParam,wMsg,lParam.hi,lParam.lo>
    jmps    WOW16Done       ; Just return return value

Entry   WOW16Debug
    int 3               ;that's all folks
    ;fall into WOW16Done

Entry   WOW16Done
    mov     cbackAX, ax      ; set return value
    mov     cbackDX, dx

    mov     bp, word ptr vfSP    ; verify the saved ES is still valid
.386p
    verr    [bp].vf_wES          ;    see bug #121760
    jz      @f                   ; jump if still valid
    mov     [bp].vf_wES, es      ; if not, update saved ES with a known good one
@@:                              ;    - cmjones  11/12/97
    mov     bp, [bp].vf_wLocalBP

    ; fall  thru. the return values are set for a 'real' callback only
    ; don't use 'entry' macro for wow16doneboot as it 'align 16s' the label
    ; thus putting extra instructions between cbackDx, dx and mov bp,si.

    public  WOW16DoneBoot           ; tasking.asm needs this label
WOW16DoneBoot:                      ; tasking.asm needs this label
    push    bp                   ;rebuild the frame
    push    RET_RETURN           ;push default wRetID (do not move see tasking.asm)
    SetKernelDS ds
    push    [curTDB]        ;save current 16bit task handle (see tasking.asm)
    mov [wCurTaskSS],ss     ;save current task SS
    mov [wCurTaskBP],bp     ;save current task BP
    mov     TraceOff,1h             ; Don't allow debuggers to trace to 32 bit land

    test    [FastWOWCbRetCS], 0ffffh
    jz      WOW16SlowCBReturn

.386
    call    fword ptr [FastWOWCbRet]
.286

    ; don't put any code here!!!
    ; when fastbopping, after kernel has booted we return
    ; directly to WOW16CallContinue

    jmp     WOW16CallContinue


WOW16SlowCBReturn:

    FBOP BOP_UNSIMULATE,,FastBop

    jmp     WOW16CallContinue

cEnd nogen ; WOW16Call



;
; Initialize address of fast Bop entry to monitor.
;
cProc WOWFastBopInit,<PUBLIC,FAR>
cBegin
    push    ds
    push    es
    push    bx
    push    dx

    DPMIBOP GetFastBopAddress
    CheckKernelDS   ds              ; On debug, check that DS is really kernels
    ReSetKernelDS   ds              ; Assume it otherwise.
    ;
    ; Set up FastBop address (for DPMI, and WOW without WOW16FastVector)

    mov     word ptr [FastBop],bx
    mov     word ptr [FastBop + 2],dx
    mov     word ptr [FastBop + 4],es
    or      bx,dx
    jz      NoFastWow

    call    far ptr WOWGetFastAddress
    mov     word ptr [FastWOW],ax
    mov     word ptr [FastWOW+2],dx

    or      ax,dx
    jz      NoFastWow

    mov     word ptr [FastWOWCS],es
    mov word ptr [WOWFastBopping],1

    call    far ptr WOWGetFastCbRetAddress
    mov     word ptr [FastWOWCbRet],ax
    mov     word ptr [FastWOWCbRet+2],dx

    or      ax,dx
    jz      NoFastCb

    mov     word ptr [FastWOWCbRetCS],es

NoFastCb:
NoFastWow:

    call    far ptr WowGetFlatAddressArray
    mov     word ptr [FlatAddressArray],ax
    mov     word ptr [FlatAddressArray + 2],dx

    pop     dx
    pop     bx
    pop     es
    pop     ds
    UnSetKernelDS ds
cEnd    WOWFastBopInit

cProc WOWNotifyTHHOOK,<PUBLIC,FAR>
cBegin
    CheckKernelDS ds
    ReSetKernelDS ds

    mov     DebugWOW,0

    push    1
    push    seg THHOOK
    push    offset THHOOK
    push    DBG_TOOLHELP
    FBOP BOP_DEBUGGER,,FastBop
    add     sp,+8

    push    seg cur_drive_owner
    push    offset cur_drive_owner

    push    topPDB
    push    0

    push    seg LockTDB
    push    offset LockTDB

    push    seg DebugWOW
    push    offset DebugWOW

    push    seg curTDB
    push    offset curTDB

    push    seg num_tasks
    push    offset num_tasks

    push    codeBase
    push    codeOffset Int21Handler

    call    WOWNotifyWOW32

    UnSetKernelDS ds
cEnd    WOWNotifyTHHOOK

cProc WOWQueryDebug,<PUBLIC,FAR>
cBegin
    push    ds

    SetKernelDS

    mov     ax,DebugWOW

    pop     ds
    UnSetKernelDS

cEnd WOWQueryDebug


;*--------------------------------------------------------------------------*
;*
;*  WOW16GetCurrentDirectory() -
;*
;*      - Drive =0 implies 'current' drive.
;*--------------------------------------------------------------------------*
cProc WOW16GetCurrentDirectory, <NEAR, PUBLIC>, <SI, DI>

ParmD lpDest
ParmW Drive

cBegin
        push    ds          ; Preserve DS
        les     di,lpDest       ; ES:DI = lpDest
        push    es
        pop     ds          ; DS:DI = lpDest
        cld
        mov     ax,Drive        ; AX = Drive
        or      al,al       ; Zero?
        jnz     CDGotDrive      ; Yup, skip
        mov     ah,19h      ; Get Current Disk
        DOSCALL
        inc     al          ; Convert to logical drive number
CDGotDrive:
        mov     dl,al       ; DL = Logical Drive Number
        add     al, 040h    ; drive letter
        mov     ah, 03Ah    ; ':'
        stosw
        mov     al,'\'      ; Start string with a backslash
        stosb
        mov     byte ptr es:[di],0  ; Null terminate in case of error
        mov     si,di       ; DS:SI = lpDest[1]
        mov     ah,47h      ; Get Current Directory
        DOSCALL
        jc      CDExit      ; Skip if error
        xor     ax,ax       ; Return FALSE if no error
CDExit:
        pop     ds          ; Restore DS
cEnd


;*--------------------------------------------------------------------------*
;*                                                                          *
;*  WOW16SetCurrentDirectory() -                                            *
;*                                                                          *
;*--------------------------------------------------------------------------*

cProc WOW16SetCurrentDirectory, <NEAR, PUBLIC>,<si,di>

ParmD lpDirName

cBegin
        push    ds          ; Preserve DS
        lds     dx,lpDirName    ; DS:DX = lpDirName
    mov ah,3Bh      ; Change Current Directory
    DOSCALL
        jc      SCDExit     ; Skip on error
        xor     ax,ax       ; Return FALSE if successful
SCDExit:
        pop     ds          ; Restore DS
cEnd


;*--------------------------------------------------------------------------*
;*                                      *
;*  SetCurrentDrive() -                             *
;*                                      *
;*--------------------------------------------------------------------------*

; Returns the number of drives in AX.

cProc SetCurrentDrive, <NEAR, PUBLIC>,<si,di>

ParmW Drive

cBegin
        mov     dx,Drive
    mov ah,0Eh      ; Set Current Drive
    DOSCALL
        sub     ah,ah       ; Zero out AH
cEnd


; --- GetTaskHandle0 ---
; ripped out piece of GetTaskHandle, taken from CONTEXT.ASM which was not
; part of WOW's kernel, so we copied this little piece out.
;

GetTaskHandle0:
        or      ax,ax
        jnz     gt1
        SetKernelDS     es
        mov     ax,curTDB
gt1:    mov     es,ax
        assumes es, nothing
;       cmp     es:[TDB_sig],TDB_SIGNATURE
;       jne     gt2
        ret
;gt2:   kerror  ERR_TASKID,<GetTaskHandle: Invalid task handle>
;       ret


;*--------------------------------------------------------------------------*
;*                                                                          *
;*  WowSetExitOnLastApp(WORD fExitOnLastApp)                                *
;*     Sets fExitOnLastApp variable which causes kernel to exit when the    *
;*     last app except WowExec exits.  Called by WowExec for seperate       *
;*     WOW VDMs, which need to exit after the last app closes.              *
;*                                                                          *
;*--------------------------------------------------------------------------*

cProc  WowSetExitOnLastApp, <PUBLIC, FAR>

ParmW fExit

cBegin
    SetKernelDS

    mov     ax, fExit
    mov     fExitOnLastApp, al
cEnd

;-----------------------------------------------------------------------;
; WowFixWin32CurDir
;
; Called by thunks for PrivateProfile APIs which need Win32 current
; directory to reflect Win16 current directory (imagine that!)
;
; Trashes AX, DX which shouldn't matter
;
; History:
;  Mon Dec 20, 1993  -by-  Dave Hart [DaveHart]
;   Don't ask me about current directories and WOW!  I'll deny it all!
;-----------------------------------------------------------------------;

Entry WowFixWin32CurDir
        push    ds
        SetKernelDS
        mov     ax,[CurTDB]
        or      ax,ax
        jz      WFW32CD_Exit
        mov     ds,ax                       ; DS points to TDB
        UnSetKernelDS
        cmp     ds:[TDB_sig],TDB_SIGNATURE
        jne     WFW32CD_Exit
        mov     dl,ds:[TDB_Drive]
        and     dl,7fh
        mov     ah,0Eh                      ; change drive
        DOSCALL
        mov     dx,TDB_LFNDirectory         ; DS:DX points to TDB curdir
        mov     ah,3Bh                      ; change directory
        DOSCALL
if KDEBUG
        jnc     WFW32CD_Exit
        krDebugOut DEB_WARN, "WowFixWin32CurDir: DOS fn 3B fails error #AX"
endif
WFW32CD_Exit:
        pop     ds
        ret

; sudeepb 11-May-1994
;
; This hackcheck is for simcity. Simcity does a GlobalSize on GDI.EXE and
; USER.EXE to figure out how much free resources are available. WOW's USER
; GDI have pretty small DGROUP, hence the size returns fails the check of
; this app. So we need to fake a bigger size.
;

cProc HackCheck,<PUBLIC,NEAR>
    parmW   handle
cBegin]
    push    es
    SetKernelDS es
    ; first check in the TDB that the currently running app is SCW.
    mov     ax,curtdb
    mov     es,ax
    xor     ax,ax
    cmp     word ptr es:[0f2h],4353h    ; SC (mod name in TDB at f2 offset)
    jne     hc5
    cmp     word ptr es:[0f4h],0057h    ; W
    jne     hc5

    ; Its SCW. Now get the module table for the given handle and check if its
    ; for USER.EXE and GDI.EXE
    cCall   GetExePtr,<handle>
    or      ax,ax
    jz      hc5
    mov     ds,ax
    mov     si,ds:[ne_pfileinfo]
    lea     dx,[si].opFile          ; DS:DX -> path
    cCall   WowCheckUserGdi,<ds,dx> ; Much easier to check this in 32bit land.
hc5:
    pop     es
cEnd

;-----------------------------------------------------------------------;
; WowSetCompatHandle
;
; This routine takes a single parameter and saves it in the TDB. It is
; used to take care of a bug in dBase where it confuses handle values.
; This is a private API called by USER.EXE.
;
; All registers must be saved. DS is saved automatically by cmacros.
; History:
;-----------------------------------------------------------------------;

cProc  WowSetCompatHandle, <PUBLIC, FAR>
ParmW handle
cBegin
        push    bx
        SetKernelDS
        mov     bx,[CurTDB]
        or      bx,bx
        jz      @f                              ;check for zero just in case
        mov     ds,bx                           ; DS points to TDB
        UnSetKernelDS
        mov     bx, handle
        mov     ds:[TDB_CompatHandle],bx        ;save it here
@@:
        pop     bx
cEnd

sEND    CODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\fr\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET)  \
	 DBCS_FLAGS="-DFE_SB" 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\es\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET)  \
	 DBCS_FLAGS="-DFE_SB" 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\hu\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET)  \
	 DBCS_FLAGS="-DFE_SB" 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\it\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET)  \
	 DBCS_FLAGS="-DFE_SB" 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\jpn\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DFE_SB -DDBCS -DJAPAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\fi\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET)  \
	 DBCS_FLAGS="-DFE_SB" 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\kor\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DFE_SB -DDBCS -DKOREA"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\messages\chp\strings.asm ===
TITLE	STRINGS - OEM dependent strings used by KERNEL
include gpcont.inc		; SHERLOCK

_DATA	SEGMENT PARA PUBLIC 'DATA'
_DATA	ENDS

DGROUP	GROUP	_DATA

_INITTEXT SEGMENT WORD PUBLIC 'CODE'
_INITTEXT ENDS

_NRESTEXT SEGMENT WORD PUBLIC 'CODE'
_NRESTEXT ENDS

ASSUME	DS:DGROUP


_DATA	SEGMENT PARA PUBLIC 'DATA'

; This is the caption string for the dialog box.

public	szDiskCap
IF 0
szDiskCap	db  'Change Disk',0
ELSE
szDiskCap	db  'File Error',0
ENDIF


; This is the text for the "Cannot find xxxxxx" dialog box.
; It is printed:
;
;       <szCannotFind1>filename<szCannotFind2>

public	szCannotFind1,szCannotFind2
szCannotFind1	db	"Cannot find ", 0
szCannotFind2	db	0

; This is the text for fatal errors at boot time
;	<szBootLoad>filename
public szBootLoad
szBootLoad	db	"Error loading ",0

; The following group of strings is used for the "Please insert disk with XXXX
;   in drive X:" dialog box.
;
; These two strings form the dialog message it is:
;
;	<szCannotFind1>filename<szInsert>

IF 0
public	szInsert
szInsert	db  ', Please insert in drive '
ENDIF
;public  drvlet
;drvlet		db  "X.",0

if SHERLOCK
public szGPCont		; GP fault continuation message
szGPCont	db	"An error has occurred in your application.",10
        db      "If you choose Ignore, you should save your work in a new file.",10
        db      "If you choose Close, your application will terminate.",0
endif

public	szDosVer
szDosVer	DB	'Incorrect MS-DOS version.  MS-DOS 3.1 or greater required.',13,10,'$'
; Text for exceptions and faults lead to app termination.

public szAbortCaption,szInModule,szAt
public szNukeApp,szSnoozer,szGP,szSF,szII,szPF,szNP,szBlame,szLoad,szWillClose
public szOutofSelectors
szAbortCaption	db	"Application Error"
		db	0
szBlame		db	"BOOT "
		db	0
szSnoozer	db	" caused "
		db	0
szInModule	db	" in", 10, "module <unknown>"
		db	0
szAt		db	" at "
		db	0
szNukeApp       db      ".", 10, 10, "Choose close. "
		db	0
szWillClose	db	" will close."
		db	0
szGP		db	"a General Protection Fault"
		db	0
szD0		db	"a Divide by Zero"	; not yet used
		db	0
szSF		db	"a Stack Fault"		; not spec'ed
		db	0
szII		db	"an Illegal Instruction"	; "Fault" ???
		db	0
szPF		db	"a Page Fault"
		db	0
szNP		db	"a Not Present Fault"
		db	0
szAF		db	"an Application Fault"	; not yet used
		db	0
szLoad		db	"Segment Load Failure"
		db	0
szOutofSelectors db	"Out of Selectors"
		db	0

; Text for dialog box when terminating an application

public szAbort
szAbort 	db	"Closing current application.",0

; Text for dialog box when trying to run a compressed file
			   
public szBozo
szBozo  	db	"Cannot load compressed files",0
			 	     		     
; This is the caption string for system error dialog boxes

public	syserr
syserr		db	"System Error",0

; The following group of messages forms all of the messages used
; in the INT 24 dialog box.
;
; There are 7 messages which can be translated individually. The
; location of drvlet? and devenam? can be moved to any location
; within the string.

public	msgWriteProtect,drvlet1
public	msgCannotReadDrv,drvlet2
public	msgCannotWriteDrv,drvlet3
public	msgShare,drvlet4
public	msgNetError,drvlet5
public	msgCannotReadDev,devenam1
public	msgCannotWriteDev,devenam2
public	msgNoPrinter
public	msgNetErrorDev,devenam3

msgWriteProtect         db      "Write-protected disk in drive "
drvlet1                 db      "X.",0

msgCannotReadDrv        db      "Cannot read from drive "
drvlet2                 db      "X.",0

msgCannotWriteDrv       db      "Cannot write to drive "
drvlet3                 db      "X.",0

msgShare		db	"Sharing violation on drive "
drvlet4                 db      "X.",0

msgNetError		db	"Network error on drive "
drvlet5 		db	"X.",0

msgCannotReadDev        db      "Cannot read from device "
devenam1                db      8 dup (?)
                        db      0

msgCannotWriteDev       db      "Cannot write to device "
devenam2                db      8 dup (?)
			db	0

msgNetErrorDev		db	"Network error on device "
devenam3		db	8 dup (?)
			db	0

msgNoPrinter            db      "Printer not ready",0


ifndef WINDEBUG
public szExitStr1,szExitStr2
szExitStr1  DB  7,13,10,'FatalExit code = ',0
szExitStr2  DB  ' stack overflow',13,10,0
public  szUndefDyn
szUndefDyn      db      "Call to Undefined Dynalink",0
public  szFatalExit
szFatalExit	db	"Application requested abnormal termination",0
else
public szDebugStr
szDebugStr  DB  'KERNEL: Failed loading - ',0                   ; 0
            DB  'KERNEL: Failed loading new instance of - ',0   ; 1
            DB  'Error loading from resource file - ',0         ; 2
            DB  13,10,0                                         ; 3
            DB  7,13,10,'FatalExit code = ',0                   ; 4
            DB  ' stack overflow',0                             ; 5
            DB  13,10,'Stack trace:',13,10,0                    ; 6
	    DB  7,13,10,'Abort, Break, Exit or Ignore? ',0      ; 7
            DB  'Invalid BP chain',7,13,10,0                    ; 8
	    DB	': ',0						; 9
	    DB	'Reentered FatalExit',7,13,10,0 		; 10
	    DB  0
public szFKE
szFKE	DB '*** Fatal Kernel Error ***',0
endif

;** Diagnostic mode messages
        public szDiagStart, szCRLF, szLoadStart, szLoadSuccess, szLoadFail
        public szFailCode, szCodeString
szDiagStart     db      '[boot]'      ;lpCRLF must follow
szCRLF          db      0dh, 0ah, 0
szLoadStart     db      'LoadStart = ',0
szLoadSuccess   db      'LoadSuccess = ', 0
szLoadFail      db      'LoadFail = ', 0
szFailCode      db      ' Failure code is ' ;szCodeString must follow
szCodeString    db      '00', 0dh, 0ah, 0
ifdef WINDEBUG
	public szInitSpew
szInitSpew      DB      'Diagnostic mode startup.  Log file is:  ', 0
endif

_DATA	ENDS


_INITTEXT SEGMENT WORD PUBLIC 'CODE'
public szInadequate, szNoPMode, szNoGlobalInit
public NoOpenFile, NoLoadHeader, szMissingMod, szPleaseDoIt

ifdef WOW
public szGenBootFail
szNoPMode db "The Win16 Subsystem was unable to enter Protected Mode, DOSX.EXE must be in your AUTOEXEC.NT and present in your PATH.",0
szMissingMod    db   "NTVDM KERNEL: Missing 16-bit system module",0
szPleaseDoIt    db   "Please re-install the following module to your system32 directory:",13,10,9,9,0
szInadequate	db   "NTVDM KERNEL: Inadequate DPMI Server",0
szNoGlobalInit	db   "NTVDM KERNEL: Unable to initialize heap",0
NoOpenFile	    db   "NTVDM KERNEL: Unable to open KERNEL executable",0
NoLoadHeader	db   "NTVDM KERNEL: Unable to load KERNEL EXE header",0
szGenBootFail   db   "NTVDM KERNEL: Win16 Subsystem Initialization Failure",0
else
szInadequate	db   'KERNEL: Inadequate DPMI Server',13,10,'$'
szNoPMode	db   'KERNEL: Unable to enter Protected Mode',13,10,'$'
szNoGlobalInit	db   "KERNEL: Unable to initialize heap",13,10,'$'
NoOpenFile      db   "KERNEL: Unable to open KERNEL executable"
                db   13, 10, '$'
NoLoadHeader    db   "KERNEL: Unable to load KERNEL EXE header"
		db   13, 10, '$'
endif

_INITTEXT ENDS




_NRESTEXT SEGMENT WORD PUBLIC 'CODE'

; This is the caption string for the protect mode dialog box.
;
; DO NOT CHANGE THE LENGTH OF THIS MESSAGE
;

public szProtectCap,msgRealModeApp1,msgRealModeApp2

szProtectCap		db	"Application Compatibility Warning",0

msgRealModeApp1 db	"The application you are about to run, ",0
msgRealModeApp2 db	", was designed for a previous version of Windows.",0Dh,0Dh
	db	"Obtain an updated version of the application that is compatible "
	db	"with Windows version 3.0 and later.",13,13
	db	"If you choose the OK button and start the application, compatibility "
	db	"problems could cause the application or Windows to close unexpectedly.",0

_NRESTEXT ENDS

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\messages\es\strings.asm ===
TITLE	STRINGS - OEM dependent strings used by KERNEL
include gpcont.inc		; SHERLOCK

_DATA	SEGMENT PARA PUBLIC 'DATA'
_DATA	ENDS

DGROUP	GROUP	_DATA

_INITTEXT SEGMENT WORD PUBLIC 'CODE'
_INITTEXT ENDS

_NRESTEXT SEGMENT WORD PUBLIC 'CODE'
_NRESTEXT ENDS

ASSUME	DS:DGROUP


_DATA	SEGMENT PARA PUBLIC 'DATA'

; This is the caption string for the dialog box.

public	szDiskCap
IF 0
szDiskCap	db  'Cambiar disco',0
ELSE
szDiskCap	db  'Error de archivo',0
ENDIF


; This is the text for the "Cannot find xxxxxx" dialog box.
; It is printed:
;
;       <szCannotFind1>filename<szCannotFind2>

public	szCannotFind1,szCannotFind2
szCannotFind1	db	"No se encuentra ", 0
szCannotFind2	db	0

; This is the text for fatal errors at boot time
;	<szBootLoad>filename
public szBootLoad
szBootLoad	db	"Error al cargar ",0

; The following group of strings is used for the "Please insert disk with XXXX
;   in drive X:" dialog box.
;
; These two strings form the dialog message it is:
;
;	<szCannotFind1>filename<szInsert>

IF 0
public	szInsert
szInsert	db  ', inserte en la unidad '
ENDIF
;public  drvlet
;drvlet		db  "X.",0

if SHERLOCK
public szGPCont		; GP fault continuation message
szGPCont	db	"Error en la aplicacin.",10
        db      "Si escoge Omitir, tendr que guardar sus datos en un archivo nuevo.",10
        db      "Si escoge Cerrar, su aplicacin terminar.",0
endif

public	szDosVer
szDosVer	DB	'Versin incorrecta de MS-DOS.  Se precisa MS-DOS 3.1 o posterior.',13,10,'$'
; Text for exceptions and faults lead to app termination.

public szAbortCaption,szInModule,szAt
public szNukeApp,szSnoozer,szGP,szSF,szII,szPF,szNP,szBlame,szLoad,szWillClose
public szOutofSelectors
szAbortCaption	db	"Error de aplicacin"
		db	0
szBlame		db	"BOOT "
		db	0
szSnoozer	db	" ha causado "
		db	0
szInModule	db	" en", 10, "mdulo <indefi.>"
		db	0
szAt		db	" en "
		db	0
szNukeApp       db      ".", 10, 10, "Escoja Cerrar. "
		db	0
szWillClose	db	" se cerrar."
		db	0
szGP		db	"un error de proteccin general"
		db	0
szD0		db	"una divisin entre cero"	; not yet used
		db	0
szSF		db	"un error de pila"		; not spec'ed
		db	0
szII		db	"una instruccin ilegal"	; "Fault" ???
		db	0
szPF		db	"un error de pgina"
		db	0
szNP		db	"un error de presencia"
		db	0
szAF		db	"un error de aplicacin"	; not yet used
		db	0
szLoad		db	"error de carga de segmento"
		db	0
szOutofSelectors db	"no quedan selectores"
		db	0

; Text for dialog box when terminating an application

public szAbort
szAbort 	db	"La aplicacin se est cerrando.",0

; Text for dialog box when trying to run a compressed file
			   
public szBozo
szBozo  	db	"No se puede cargar archivos comprimidos",0
			 	     		     
; This is the caption string for system error dialog boxes

public	syserr
syserr		db	"Error de sistema",0

; The following group of messages forms all of the messages used
; in the INT 24 dialog box.
;
; There are 7 messages which can be translated individually. The
; location of drvlet? and devenam? can be moved to any location
; within the string.

public	msgWriteProtect,drvlet1
public	msgCannotReadDrv,drvlet2
public	msgCannotWriteDrv,drvlet3
public	msgShare,drvlet4
public	msgNetError,drvlet5
public	msgCannotReadDev,devenam1
public	msgCannotWriteDev,devenam2
public	msgNoPrinter
public	msgNetErrorDev,devenam3

msgWriteProtect         db      "Disco protegido contra escritura en la unidad "
drvlet1                 db      "X.",0
			
msgCannotReadDrv        db      "No se puede leer de la unidad "
drvlet2                 db      "X.",0

msgCannotWriteDrv       db      "No se puede escribir en la unidad "
drvlet3                 db      "X.",0

msgShare		db	"Infraccin de recurso compartido en la unidad "
drvlet4                 db      "X.",0

msgNetError		db	"Error de red en la unidad "
drvlet5 		db	"X.",0

msgCannotReadDev        db      "No se puede leer del dispositivo "
devenam1                db      8 dup (?)
                        db      0

msgCannotWriteDev       db      "No se puede escribir en el dispositivo "
devenam2                db      8 dup (?)
			db	0

msgNetErrorDev		db	"Error de red en el dispositivo "
devenam3		db	8 dup (?)
			db	0

msgNoPrinter            db      "La impresora no est lista",0


ifndef WINDEBUG
public szExitStr1,szExitStr2
szExitStr1  DB  7,13,10,'FatalExit code = ',0
szExitStr2  DB  ' stack overflow',13,10,0
public  szUndefDyn
szUndefDyn      db      "Llamada indefinida a vnculo dinmico",0
public  szFatalExit
szFatalExit	db	"La aplicacin ha solicitado terminar de forma anormal",0
else
public szDebugStr
szDebugStr  DB  'NCLEO: error al cargar - ',0                   	; 0
            DB  'NCLEO: error al cargar una nueva instancia de - ',0 	; 1
            DB  'Error al cargar del archivo de recursos - ',0        	; 2
            DB  13,10,0                                         	; 3
            DB  7,13,10,'Cdigo de salida crtica = ',0                 ; 4
            DB  ' desbordamiento de pila',0                             ; 5
            DB  13,10,'Seguimiento de la pila:',13,10,0                 ; 6
	    DB  7,13,10,'Anular, Interrumpir, Salir u Omitir? ',0      	; 7
            DB  'Cadena BP no vlida',7,13,10,0                    	; 8
	    DB	': ',0							; 9
	    DB	'Salida crtica reentrante',7,13,10,0 			; 10
	    DB  0
public szFKE
szFKE	DB '*** Fatal Kernel Error ***',0
endif

;** Diagnostic mode messages
        public szDiagStart, szCRLF, szLoadStart, szLoadSuccess, szLoadFail
        public szFailCode, szCodeString
szDiagStart     db      '[boot]'      ;lpCRLF must follow
szCRLF          db      0dh, 0ah, 0
szLoadStart     db      'Inicio de carga = ',0
szLoadSuccess   db      'Carga correcta = ', 0
szLoadFail      db      'Carga errnea = ', 0
szFailCode      db      ' El cdigo de error es ' ;szCodeString must follow
szCodeString    db      '00', 0dh, 0ah, 0
ifdef WINDEBUG
	public szInitSpew
szInitSpew      DB      'Inicio de modo diagnstico.  El archivo de registro es:  ', 0
endif

_DATA	ENDS


_INITTEXT SEGMENT WORD PUBLIC 'CODE'
public szInadequate, szNoPMode, szNoGlobalInit
public NoOpenFile, NoLoadHeader, szMissingMod, szPleaseDoIt

ifdef WOW
public szGenBootFail
szNoPMode db "El subsistema Win16 no ha podido entrar en modo Protegido. DOSX.EXE debe estar en AUTOEXEC.NT y presente en la ruta (PATH).",0
szMissingMod    db   "NCLEO NTVDM: falta el mdulo del sistema de 16 bits",0
szPleaseDoIt    db   "Reinstale el siguiente mdulo en el directorio system32:",13,10,9,9,0
szInadequate	db   "NCLEO NTVDM: el servidor DPMI no es el adecuado",0
szNoGlobalInit	db   "NCLEO NTVDM: no se puede inicializar la pila heap",0
NoOpenFile	db   "NCLEO NTVDM: no se puede abrir el ejecutable del NCLEO",0
NoLoadHeader	db   "NCLEO NTVDM: no se puede cargar el encabezado ejecutable del NCLEO",0
szGenBootFail   db   "NCLEO NTVDM: error de inicializacin del Subsistema Win16",0
else
szInadequate	db   'NCLEO: el servidor DPMI no es el adecuado',13,10,'$'
szNoPMode	db   'NCLEO: no se puede entrar en modo Protegido',13,10,'$'
szNoGlobalInit	db   "NCLEO: No se puede inicializar la pila heap",13,10,'$'
NoOpenFile      db   "NCLEO: No se puede abrir el ejecutable del NCLEO"
                db   13, 10, '$'
NoLoadHeader    db   "NUCLEO: no se puede cargar el encabezado ejecutable del NCLEO"
		db   13, 10, '$'
endif

_INITTEXT ENDS




_NRESTEXT SEGMENT WORD PUBLIC 'CODE'

; This is the caption string for the protect mode dialog box.
;
; DO NOT CHANGE THE LENGTH OF THIS MESSAGE
;

public szProtectCap,msgRealModeApp1,msgRealModeApp2

szProtectCap		db	" Aviso de compatibilidad de aplicaciones  ",0

msgRealModeApp1 db	" La aplicacin que va a ejecutar, fue ",0
msgRealModeApp2 db	"diseada para una versin anterior de Windows.   ",0Dh,0Dh
	db	"Consiga una versin actualizada de la misma que sea compatible "
	db	"con Windows 3.0 o posterior.    ",13,13
	db	"Si escoge Aceptar e inicia la aplicacin, problemas de compatibilidad "
	db	"pueden causar que la aplicacin o Windows se cierren inesperadamente.",0

_NRESTEXT ENDS

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\messages\cs\strings.asm ===
TITLE   STRINGS - OEM dependent strings used by KERNEL
include gpcont.inc              ; SHERLOCK

_DATA   SEGMENT PARA PUBLIC 'DATA'
_DATA   ENDS

DGROUP  GROUP   _DATA

_INITTEXT SEGMENT WORD PUBLIC 'CODE'
_INITTEXT ENDS

_NRESTEXT SEGMENT WORD PUBLIC 'CODE'
_NRESTEXT ENDS

ASSUME  DS:DGROUP


_DATA   SEGMENT PARA PUBLIC 'DATA'

; This is the caption string for the dialog box.

public  szDiskCap
IF 0
szDiskCap       db  'Vmna diskety',0
ELSE
szDiskCap       db  'Chyba souboru',0
ENDIF


; This is the text for the "Cannot find xxxxxx" dialog box.
; It is printed:
;
;       <szCannotFind1>filename<szCannotFind2>

public  szCannotFind1,szCannotFind2
szCannotFind1   db      "Nelze nalzt soubor ", 0
szCannotFind2   db      0

; This is the text for fatal errors at boot time
;       <szBootLoad>filename
public szBootLoad
szBootLoad      db      "Chyba pi natn souboru ",0

; The following group of strings is used for the "Please insert disk with XXXX
;   in drive X:" dialog box.
;
; These two strings form the dialog message it is:
;
;       <szCannotFind1>filename<szInsert>

IF 0
public  szInsert
szInsert        db  ', vlote disk do jednotky '
ENDIF
;public  drvlet
;drvlet         db  "X.",0

if SHERLOCK
public szGPCont         ; GP fault continuation message
szGPCont        db      "V aplikaci se vyskytla chyba.",10
	db      "Pokud zvolte Ignorovat, ulote vae data do novho souboru.",10
	db      "Pokud zvolte Ukonit, bude dan aplikace ukonena.",0
endif

public  szDosVer
szDosVer        DB      'Chybn verze systmu MS-DOS. Vyaduje se verze 3.1 nebo vy.',13,10,'$'
; Text for exceptions and faults lead to app termination.

public szAbortCaption,szInModule,szAt
public szNukeApp,szSnoozer,szGP,szSF,szII,szPF,szNP,szBlame,szLoad,szWillClose
public szOutofSelectors
szAbortCaption  db      "Chyba aplikace"
		db      0
szBlame         db      "START "
		db      0
szSnoozer       db      " zpsobil "
		db      0
szInModule      db      " v", 10, "modulu <neznm>"
		db      0
szAt            db      " na adrese "
		db      0
szNukeApp       db      ".", 10, 10, "Zvolte ukonen aplikace. "
		db      0
szWillClose     db      " bude ukonen."
		db      0
szGP            db      "veobecnou chybu ochrany"
		db      0
szD0            db      "dlen nulou"  ; not yet used
		db      0
szSF            db      "chybu zsobnku"               ; not spec'ed
		db      0
szII            db      "ilegln instrukci"    ; "Fault" ???
		db      0
szPF            db      "chybu strnky"
		db      0
szNP            db      "chybu neptomnosti"
		db      0
szAF            db      "chybu aplikace"        ; not yet used
		db      0
szLoad          db      "chybu naten segmentu"
		db      0
szOutofSelectors db     "nedostatek selektor"
		db      0

; Text for dialog box when terminating an application

public szAbort
szAbort         db      "Aplikace bude ukonena.",0

; Text for dialog box when trying to run a compressed file

public szBozo
szBozo          db      "Nelze nast komprimovan soubory",0

; This is the caption string for system error dialog boxes

public  syserr
syserr          db      "Chyba systmu",0

; The following group of messages forms all of the messages used
; in the INT 24 dialog box.
;
; There are 7 messages which can be translated individually. The
; location of drvlet? and devenam? can be moved to any location
; within the string.

public  msgWriteProtect,drvlet1
public  msgCannotReadDrv,drvlet2
public  msgCannotWriteDrv,drvlet3
public  msgShare,drvlet4
public  msgNetError,drvlet5
public  msgCannotReadDev,devenam1
public  msgCannotWriteDev,devenam2
public  msgNoPrinter
public  msgNetErrorDev,devenam3

msgWriteProtect         db      "Disk chrnn proti zpisu v jednotce "
drvlet1                 db      "X.",0

msgCannotReadDrv        db      "Nelze st z jednotky "
drvlet2                 db      "X.",0

msgCannotWriteDrv       db      "Nelze zapisovat na jednotku "
drvlet3                 db      "X.",0

msgShare                db      "Pestupek sdlen na jednotce "
drvlet4                 db      "X.",0

msgNetError             db      "Chyba st na jednotce "
drvlet5                 db      "X.",0

msgCannotReadDev        db      "Nelze st ze zazen "
devenam1                db      8 dup (?)
			db      0

msgCannotWriteDev       db      "Nelze zapisovat na zazen "
devenam2                db      8 dup (?)
			db      0

msgNetErrorDev          db      "Chyba st na zazen "
devenam3                db      8 dup (?)
			db      0

msgNoPrinter            db      "Tiskrna nen pipravena",0


ifndef WINDEBUG
public szExitStr1,szExitStr2
szExitStr1  DB  7,13,10,'kd FatalExit = ',0
szExitStr2  DB  ' peteen zsobnku',13,10,0
public  szUndefDyn
szUndefDyn      db      "voln nedefinovanho Dynalinku",0
public  szFatalExit
szFatalExit     db      "aplikace si vydala abnormln ukonen",0
else
public szDebugStr
szDebugStr  DB  'JDRO: Selhalo naten - ',0                   ; 0
	    DB  'JDRO: Selhalo naten nov instance - ',0     ; 1
	    DB  'Chyba pi natn souboru zdroje - ',0        ; 2
	    DB  13,10,0                                         ; 3
	    DB  7,13,10,'FatalExit, kd = ',0                   ; 4
	    DB  ' peteen zsobnku',0                        ; 5
	    DB  13,10,'Stav zsobnku:',13,10,0                 ; 6
	    DB  7,13,10,'Peruit, Ukonit, Nvrat nebo Ignorovat? ',0      ; 7
	    DB  'Neplatn etzec BP',7,13,10,0                 ; 8
	    DB  ': ',0                                          ; 9
	    DB  'Nov vskyt chyby FatalExit',7,13,10,0         ; 10
	    DB  0
public szFKE
szFKE   DB '*** Fatln chyba jdra ***',0
endif

;** Diagnostic mode messages
	public szDiagStart, szCRLF, szLoadStart, szLoadSuccess, szLoadFail
	public szFailCode, szCodeString
szDiagStart     db      '[start]'      ;lpCRLF must follow
szCRLF          db      0dh, 0ah, 0
szLoadStart     db      'LoadStart = ',0
szLoadSuccess   db      'LoadSuccess = ', 0
szLoadFail      db      'LoadFail = ', 0
szFailCode      db      ' Kd selhn je ' ;szCodeString must follow
szCodeString    db      '00', 0dh, 0ah, 0
ifdef WINDEBUG
	public szInitSpew
szInitSpew      DB      'Start diagnostickho reimu. Soubor protokolu:  ', 0
endif

_DATA   ENDS


_INITTEXT SEGMENT WORD PUBLIC 'CODE'
public szInadequate, szNoPMode, szNoGlobalInit
public NoOpenFile, NoLoadHeader, szMissingMod, szPleaseDoIt

ifdef WOW
public szGenBootFail
szNoPMode db "Podsystm Win16 nemohl pejt do chrnnho reimu; DOSX.EXE mus bt uveden v souboru AUTOEXEC.NT a leet v cest (promnn PATH).",0
szMissingMod    db   "JDRO NTVDM: Nebyl nalezen 16bitov systmov modul",0
szPleaseDoIt    db   "Peinstalujte nsledujc modul do adrese system32:",13,10,9,9,0
szInadequate    db   "JDRO NTVDM: Neadekvtn server DPMI",0
szNoGlobalInit  db   "JDRO NTVDM: Nelze inicializovat haldu",0
NoOpenFile      db   "JDRO NTVDM: Nelze otevt spustiteln program JDRA",0
NoLoadHeader    db   "JDRO NTVDM: Nelze nast zhlav EXE JDRA",0
szGenBootFail   db   "JDRO NTVDM: Inicializace podsystmu Win16 se nezdaila",0
else
szInadequate    db   'JDRO: Neadekvtn server DPMI',13,10,'$'
szNoPMode       db   'JDRO: Nelze pejt do chrnnho reimu',13,10,'$'
szNoGlobalInit  db   "JDRO: Nelze inicializovat haldu",13,10,'$'
NoOpenFile      db   "JDRO: Nelze otevt spustiteln program JDRA"
		db   13, 10, '$'
NoLoadHeader    db   "JDRO: Nelze nast zhlav EXE JDRA"
		db   13, 10, '$'
endif

_INITTEXT ENDS




_NRESTEXT SEGMENT WORD PUBLIC 'CODE'

; This is the caption string for the protect mode dialog box.
;
; DO NOT CHANGE THE LENGTH OF THIS MESSAGE
;

public szProtectCap,msgRealModeApp1,msgRealModeApp2

szProtectCap            db      "Varovn - kompatibilita aplikac",0

msgRealModeApp1 db      "Aplikace, kter m bt sputna,  ",0
msgRealModeApp2 db      "byla navrena pro pedchoz verzi systmu Windows.",0Dh,0Dh
        db      "Opatete si aktualizovanou verzi aplikace, kter je kompatibiln "
        db      "se systmem Windows 3.0 nebo vym.",13,13
        db      "Pokud klepnete na tlatko OK a aplikaci spustte, me dojt k potm "
        db      "kompatibility ve form neoekvanho ukonen aplikace nebo systmu Windows. ",0

_NRESTEXT ENDS

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\messages\br\strings.asm ===
TITLE	STRINGS - OEM dependent strings used by KERNEL
include gpcont.inc		; SHERLOCK

_DATA	SEGMENT PARA PUBLIC 'DATA'
_DATA	ENDS

DGROUP	GROUP	_DATA

_INITTEXT SEGMENT WORD PUBLIC 'CODE'
_INITTEXT ENDS

_NRESTEXT SEGMENT WORD PUBLIC 'CODE'
_NRESTEXT ENDS

ASSUME	DS:DGROUP


_DATA	SEGMENT PARA PUBLIC 'DATA'

; This is the caption string for the dialog box.

public	szDiskCap
IF 0
szDiskCap	db  'Troque o disco',0
ELSE
szDiskCap	db  'Erro de arquivo',0
ENDIF


; This is the text for the "Cannot find xxxxxx" dialog box.
; It is printed:
;
;       <szCannotFind1>filename<szCannotFind2>

public	szCannotFind1,szCannotFind2
szCannotFind1	db	"No foi possvel encontrar ", 0
szCannotFind2	db	0

; This is the text for fatal errors at boot time
;	<szBootLoad>filename
public szBootLoad
szBootLoad	db	"Erro de carregamento ",0

; The following group of strings is used for the "Please insert disk with XXXX
;   in drive X:" dialog box.
;
; These two strings form the dialog message it is:
;
;	<szCannotFind1>filename<szInsert>

IF 0
public	szInsert
szInsert	db  ', insira na unidade '
ENDIF
;public  drvlet
;drvlet		db  "X.",0

if SHERLOCK
public szGPCont		; GP fault continuation message
szGPCont	db	"Ocorreu um erro no aplicativo.",10
        db      "Se escolher 'Ignorar', ter que salvar os dados em um novo arquivo.",10
        db      "Se escolher 'Fechar', o aplicativo ser finalizado.",0
endif

public	szDosVer
szDosVer	DB	'Verso incorreta do MS-DOS.  necessrio o MS-DOS 3.1 ou uma verso posterior.',13,10,'$'
; Text for exceptions and faults lead to app termination.

public szAbortCaption,szInModule,szAt
public szNukeApp,szSnoozer,szGP,szSF,szII,szPF,szNP,szBlame,szLoad,szWillClose
public szOutofSelectors
szAbortCaption	db	"Erro de aplicativo"
		db	0
szBlame		db	"BOOT "
		db	0
szSnoozer	db	" foi causado "
		db	0
szInModule	db	" em", 10, "mdulo <descon.>"
		db	0
szAt		db	" em "
		db	0
szNukeApp       db      ".", 10, 10, "Escolha fechar. "
		db	0
szWillClose	db	" ser fechado."
		db	0
szGP		db	"uma falha de proteo geral"
		db	0
szD0		db	"uma diviso por zero"	; not yet used
		db	0
szSF		db	"uma falha na pilha"		; not spec'ed
		db	0
szII		db	"uma instruo invlida"	; "Fault" ???
		db	0
szPF		db	"um erro de pgina"
		db	0
szNP		db	"uma falha de presena"
		db	0
szAF		db	"uma falha de aplicativo"	; not yet used
		db	0
szLoad		db	"falha no carregamento de segmento"
		db	0
szOutofSelectors db	"sem seletores"
		db	0

; Text for dialog box when terminating an application

public szAbort
szAbort 	db	"O aplicativo est sendo fechado.",0

; Text for dialog box when trying to run a compressed file
			   
public szBozo
szBozo  	db	"No foi possvel carregar arquivos compactados",0
			 	     		     
; This is the caption string for system error dialog boxes

public	syserr
syserr		db	"Erro de sistema",0

; The following group of messages forms all of the messages used
; in the INT 24 dialog box.
;
; There are 7 messages which can be translated individually. The
; location of drvlet? and devenam? can be moved to any location
; within the string.

public	msgWriteProtect,drvlet1
public	msgCannotReadDrv,drvlet2
public	msgCannotWriteDrv,drvlet3
public	msgShare,drvlet4
public	msgNetError,drvlet5
public	msgCannotReadDev,devenam1
public	msgCannotWriteDev,devenam2
public	msgNoPrinter
public	msgNetErrorDev,devenam3

msgWriteProtect         db      "Disco protegido contra gravao na unidade "
drvlet1                 db      "X.",0

msgCannotReadDrv        db      "No foi possvel ler a unidade "
drvlet2                 db      "X.",0

msgCannotWriteDrv       db      "No foi possvel gravar na unidade "
drvlet3                 db      "X.",0

msgShare		db	"Violao de compartilhamento na unidade "
drvlet4                 db      "X.",0

msgNetError		db	"Ocorreu um erro de rede na unidade "
drvlet5 		db	"X.",0

msgCannotReadDev        db      "No foi possvel ler o dispositivo "
devenam1                db      8 dup (?)
                        db      0

msgCannotWriteDev       db      "No foi possvel gravar no dispositivo "
devenam2                db      8 dup (?)
			db	0

msgNetErrorDev		db	"Ocorreu um erro de rede no dispositivo "
devenam3		db	8 dup (?)
			db	0

msgNoPrinter            db      "A impressora no est pronta",0


ifndef WINDEBUG
public szExitStr1,szExitStr2
szExitStr1  DB  7,13,10,'FatalExit code = ',0
szExitStr2  DB  ' stack overflow',13,10,0
public  szUndefDyn
szUndefDyn      db      "Chamada a um vnculo dinmico indefinido",0
public  szFatalExit
szFatalExit	db	"O aplicativo foi encerrado de forma anormal",0
else
public szDebugStr
szDebugStr  DB  'KERNEL: Erro ao carregar - ',0                   	 ; 0
            DB  'KERNEL: Erro ao carregar uma nova cpia de - ',0 ; 1
            DB  'Erro ao carregar o arquivo de recursos - ',0        ; 2
            DB  13,10,0                                         ; 3
            DB  7,13,10,'Cdigo de sada fatal = ',0                   ; 4
            DB  ' estouro de pilha',0                             ; 5
            DB  13,10,'Segmento da pilha:',13,10,0                    ; 6
	    DB  7,13,10,'Anular, Interromper, Sair ou Ignorar? ',0      ; 7
            DB  'Cadeia BP invlida',7,13,10,0                    ; 8
	    DB	': ',0						; 9
	    DB	'Sada fatal fornecida outra vez',7,13,10,0 		; 10
	    DB  0
public szFKE
szFKE	DB '*** Erro fatal de ncleo ***',0
endif

;** Diagnostic mode messages
        public szDiagStart, szCRLF, szLoadStart, szLoadSuccess, szLoadFail
        public szFailCode, szCodeString
szDiagStart     db      '[boot]'      ;lpCRLF must follow
szCRLF          db      0dh, 0ah, 0
szLoadStart     db      'Incio de carregamento = ',0
szLoadSuccess   db      'Carregamento correto = ', 0
szLoadFail      db      'Carregamento incorreto = ', 0
szFailCode      db      ' O cdigo de erro  ' ;szCodeString must follow
szCodeString    db      '00', 0dh, 0ah, 0
ifdef WINDEBUG
	public szInitSpew
szInitSpew      DB      'Inicializao do modo de diagnstico. O arquivo de log : ', 0
endif

_DATA	ENDS


_INITTEXT SEGMENT WORD PUBLIC 'CODE'
public szInadequate, szNoPMode, szNoGlobalInit
public NoOpenFile, NoLoadHeader, szMissingMod, szPleaseDoIt

ifdef WOW
public szGenBootFail
szNoPMode db "O Subsistema Win16 no conseguiu entrar no modo protegido. DOSX.EXE deve estar no arquivo AUTOEXEC.NT e em seu PATH.",0
szMissingMod    db   "NTVDM KERNEL: O mdulo do sistema de 16 bits est faltando",0
szPleaseDoIt    db   "Reinstale o seguinte mdulo na pasta system32:",13,10,9,9,0
szInadequate	db   "NTVDM KERNEL: Servidor DPMI inadequado",0
szNoGlobalInit	db   "NTVDM KERNEL: No foi possvel inicializar a pilha",0
NoOpenFile	db   "NTVDM KERNEL: No foi possvel abrir o executvel KERNEL",0
NoLoadHeader	db   "NTVDM KERNEL: No foi possvel carregar o cabealho do executvel KERNEL",0
szGenBootFail   db   "NTVDM KERNEL: Falha na inicializao do subsistema Win16",0
else
szInadequate	db   'KERNEL: O servidor DPMI no  adequado',13,10,'$'
szNoPMode	db   'KERNEL: No foi possvel entrar no modo protegido',13,10,'$'
szNoGlobalInit	db   "KERNEL: No foi possvel inicializar a pilha",13,10,'$'
NoOpenFile      db   "KERNEL: No foi possvel abrir o executvel KERNEL"
                db   13, 10, '$'
NoLoadHeader    db   "KERNEL: No foi possvel carregar o cabealho do executvel KERNEL"
		db   13, 10, '$'
endif

_INITTEXT ENDS




_NRESTEXT SEGMENT WORD PUBLIC 'CODE'

; This is the caption string for the protect mode dialog box.
;
; DO NOT CHANGE THE LENGTH OF THIS MESSAGE
;

public szProtectCap,msgRealModeApp1,msgRealModeApp2

szProtectCap		db	"Aviso sobre a compatibilidade do aplicativo",0

msgRealModeApp1 db	"O aplicativo que voc vai executar foi ",0
msgRealModeApp2 db	"desenvolvido para uma verso anterior do Windows.",0Dh,0Dh
	db	"Obtenha uma verso atualizada do aplicativo que seja compatvel "
	db	"com o Windows 3.0 ou posterior.    ",13,13
	db	"Se for escolhido OK e o aplicativo for inicializado, problemas de compatibilidade "
	db	"podero fazer com que o aplicativo ou o Windows sejam encerrados inesperadamente.",0

_NRESTEXT ENDS

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\messages\cht\strings.asm ===
TITLE	STRINGS - OEM dependent strings used by KERNEL
include gpcont.inc		; SHERLOCK

_DATA	SEGMENT PARA PUBLIC 'DATA'
_DATA	ENDS

DGROUP	GROUP	_DATA

_INITTEXT SEGMENT WORD PUBLIC 'CODE'
_INITTEXT ENDS

_NRESTEXT SEGMENT WORD PUBLIC 'CODE'
_NRESTEXT ENDS

ASSUME	DS:DGROUP


_DATA	SEGMENT PARA PUBLIC 'DATA'

; This is the caption string for the dialog box.

public	szDiskCap
IF 0
szDiskCap	db  'Change Disk',0
ELSE
szDiskCap	db  'File Error',0
ENDIF


; This is the text for the "Cannot find xxxxxx" dialog box.
; It is printed:
;
;       <szCannotFind1>filename<szCannotFind2>

public	szCannotFind1,szCannotFind2
szCannotFind1	db	"Cannot find ", 0
szCannotFind2	db	0

; This is the text for fatal errors at boot time
;	<szBootLoad>filename
public szBootLoad
szBootLoad	db	"Error loading ",0

; The following group of strings is used for the "Please insert disk with XXXX
;   in drive X:" dialog box.
;
; These two strings form the dialog message it is:
;
;	<szCannotFind1>filename<szInsert>

IF 0
public	szInsert
szInsert	db  ', Please insert in drive '
ENDIF
;public  drvlet
;drvlet		db  "X.",0

if SHERLOCK
public szGPCont		; GP fault continuation message
szGPCont	db	"An error has occurred in your application.",10
        db      "If you choose Ignore, you should save your work in a new file.",10
        db      "If you choose Close, your application will terminate.",0
endif

public	szDosVer
szDosVer	DB	'Incorrect MS-DOS version.  MS-DOS 3.1 or greater required.',13,10,'$'
; Text for exceptions and faults lead to app termination.

public szAbortCaption,szInModule,szAt
public szNukeApp,szSnoozer,szGP,szSF,szII,szPF,szNP,szBlame,szLoad,szWillClose
public szOutofSelectors
szAbortCaption	db	"Application Error"
		db	0
szBlame		db	"BOOT "
		db	0
szSnoozer	db	" caused "
		db	0
szInModule	db	" in", 10, "module <unknown>"
		db	0
szAt		db	" at "
		db	0
szNukeApp       db      ".", 10, 10, "Choose close. "
		db	0
szWillClose	db	" will close."
		db	0
szGP		db	"a General Protection Fault"
		db	0
szD0		db	"a Divide by Zero"	; not yet used
		db	0
szSF		db	"a Stack Fault"		; not spec'ed
		db	0
szII		db	"an Illegal Instruction"	; "Fault" ???
		db	0
szPF		db	"a Page Fault"
		db	0
szNP		db	"a Not Present Fault"
		db	0
szAF		db	"an Application Fault"	; not yet used
		db	0
szLoad		db	"Segment Load Failure"
		db	0
szOutofSelectors db	"Out of Selectors"
		db	0

; Text for dialog box when terminating an application

public szAbort
szAbort 	db	"Closing current application.",0

; Text for dialog box when trying to run a compressed file
			   
public szBozo
szBozo  	db	"Cannot load compressed files",0
			 	     		     
; This is the caption string for system error dialog boxes

public	syserr
syserr		db	"System Error",0

; The following group of messages forms all of the messages used
; in the INT 24 dialog box.
;
; There are 7 messages which can be translated individually. The
; location of drvlet? and devenam? can be moved to any location
; within the string.

public	msgWriteProtect,drvlet1
public	msgCannotReadDrv,drvlet2
public	msgCannotWriteDrv,drvlet3
public	msgShare,drvlet4
public	msgNetError,drvlet5
public	msgCannotReadDev,devenam1
public	msgCannotWriteDev,devenam2
public	msgNoPrinter
public	msgNetErrorDev,devenam3

msgWriteProtect         db      "Write-protected disk in drive "
drvlet1                 db      "X.",0

msgCannotReadDrv        db      "Cannot read from drive "
drvlet2                 db      "X.",0

msgCannotWriteDrv       db      "Cannot write to drive "
drvlet3                 db      "X.",0

msgShare		db	"Sharing violation on drive "
drvlet4                 db      "X.",0

msgNetError		db	"Network error on drive "
drvlet5 		db	"X.",0

msgCannotReadDev        db      "Cannot read from device "
devenam1                db      8 dup (?)
                        db      0

msgCannotWriteDev       db      "Cannot write to device "
devenam2                db      8 dup (?)
			db	0

msgNetErrorDev		db	"Network error on device "
devenam3		db	8 dup (?)
			db	0

msgNoPrinter            db      "Printer not ready",0


ifndef WINDEBUG
public szExitStr1,szExitStr2
szExitStr1  DB  7,13,10,'FatalExit code = ',0
szExitStr2  DB  ' stack overflow',13,10,0
public  szUndefDyn
szUndefDyn      db      "Call to Undefined Dynalink",0
public  szFatalExit
szFatalExit	db	"Application requested abnormal termination",0
else
public szDebugStr
szDebugStr  DB  'KERNEL: Failed loading - ',0                   ; 0
            DB  'KERNEL: Failed loading new instance of - ',0   ; 1
            DB  'Error loading from resource file - ',0         ; 2
            DB  13,10,0                                         ; 3
            DB  7,13,10,'FatalExit code = ',0                   ; 4
            DB  ' stack overflow',0                             ; 5
            DB  13,10,'Stack trace:',13,10,0                    ; 6
	    DB  7,13,10,'Abort, Break, Exit or Ignore? ',0      ; 7
            DB  'Invalid BP chain',7,13,10,0                    ; 8
	    DB	': ',0						; 9
	    DB	'Reentered FatalExit',7,13,10,0 		; 10
	    DB  0
public szFKE
szFKE	DB '*** Fatal Kernel Error ***',0
endif

;** Diagnostic mode messages
        public szDiagStart, szCRLF, szLoadStart, szLoadSuccess, szLoadFail
        public szFailCode, szCodeString
szDiagStart     db      '[boot]'      ;lpCRLF must follow
szCRLF          db      0dh, 0ah, 0
szLoadStart     db      'LoadStart = ',0
szLoadSuccess   db      'LoadSuccess = ', 0
szLoadFail      db      'LoadFail = ', 0
szFailCode      db      ' Failure code is ' ;szCodeString must follow
szCodeString    db      '00', 0dh, 0ah, 0
ifdef WINDEBUG
	public szInitSpew
szInitSpew      DB      'Diagnostic mode startup.  Log file is:  ', 0
endif

_DATA	ENDS


_INITTEXT SEGMENT WORD PUBLIC 'CODE'
public szInadequate, szNoPMode, szNoGlobalInit
public NoOpenFile, NoLoadHeader, szMissingMod, szPleaseDoIt

ifdef WOW
public szGenBootFail
szNoPMode db "The Win16 Subsystem was unable to enter Protected Mode, DOSX.EXE must be in your AUTOEXEC.NT and present in your PATH.",0
szMissingMod    db   "NTVDM KERNEL: Missing 16-bit system module",0
szPleaseDoIt    db   "Please re-install the following module to your system32 directory:",13,10,9,9,0
szInadequate	db   "NTVDM KERNEL: Inadequate DPMI Server",0
szNoGlobalInit	db   "NTVDM KERNEL: Unable to initialize heap",0
NoOpenFile	    db   "NTVDM KERNEL: Unable to open KERNEL executable",0
NoLoadHeader	db   "NTVDM KERNEL: Unable to load KERNEL EXE header",0
szGenBootFail   db   "NTVDM KERNEL: Win16 Subsystem Initialization Failure",0
else
szInadequate	db   'KERNEL: Inadequate DPMI Server',13,10,'$'
szNoPMode	db   'KERNEL: Unable to enter Protected Mode',13,10,'$'
szNoGlobalInit	db   "KERNEL: Unable to initialize heap",13,10,'$'
NoOpenFile      db   "KERNEL: Unable to open KERNEL executable"
                db   13, 10, '$'
NoLoadHeader    db   "KERNEL: Unable to load KERNEL EXE header"
		db   13, 10, '$'
endif

_INITTEXT ENDS




_NRESTEXT SEGMENT WORD PUBLIC 'CODE'

; This is the caption string for the protect mode dialog box.
;
; DO NOT CHANGE THE LENGTH OF THIS MESSAGE
;

public szProtectCap,msgRealModeApp1,msgRealModeApp2

szProtectCap		db	"Application Compatibility Warning",0

msgRealModeApp1 db	"The application you are about to run, ",0
msgRealModeApp2 db	", was designed for a previous version of Windows.",0Dh,0Dh
	db	"Obtain an updated version of the application that is compatible "
	db	"with Windows version 3.0 and later.",13,13
	db	"If you choose the OK button and start the application, compatibility "
	db	"problems could cause the application or Windows to close unexpectedly.",0

_NRESTEXT ENDS

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\ger\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)  \
	 DBCS_FLAGS="-DFE_SB" 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\messages\chs\strings.asm ===
TITLE	STRINGS - OEM dependent strings used by KERNEL
include gpcont.inc		; SHERLOCK

_DATA	SEGMENT PARA PUBLIC 'DATA'
_DATA	ENDS

DGROUP	GROUP	_DATA

_INITTEXT SEGMENT WORD PUBLIC 'CODE'
_INITTEXT ENDS

_NRESTEXT SEGMENT WORD PUBLIC 'CODE'
_NRESTEXT ENDS

ASSUME	DS:DGROUP


_DATA	SEGMENT PARA PUBLIC 'DATA'

; This is the caption string for the dialog box.

public	szDiskCap
IF 0
szDiskCap	db  'Change Disk',0
ELSE
szDiskCap	db  'File Error',0
ENDIF


; This is the text for the "Cannot find xxxxxx" dialog box.
; It is printed:
;
;       <szCannotFind1>filename<szCannotFind2>

public	szCannotFind1,szCannotFind2
szCannotFind1	db	"Cannot find ", 0
szCannotFind2	db	0

; This is the text for fatal errors at boot time
;	<szBootLoad>filename
public szBootLoad
szBootLoad	db	"Error loading ",0

; The following group of strings is used for the "Please insert disk with XXXX
;   in drive X:" dialog box.
;
; These two strings form the dialog message it is:
;
;	<szCannotFind1>filename<szInsert>

IF 0
public	szInsert
szInsert	db  ', Please insert in drive '
ENDIF
;public  drvlet
;drvlet		db  "X.",0

if SHERLOCK
public szGPCont		; GP fault continuation message
szGPCont	db	"An error has occurred in your application.",10
        db      "If you choose Ignore, you should save your work in a new file.",10
        db      "If you choose Close, your application will terminate.",0
endif

public	szDosVer
szDosVer	DB	'Incorrect MS-DOS version.  MS-DOS 3.1 or greater required.',13,10,'$'
; Text for exceptions and faults lead to app termination.

public szAbortCaption,szInModule,szAt
public szNukeApp,szSnoozer,szGP,szSF,szII,szPF,szNP,szBlame,szLoad,szWillClose
public szOutofSelectors
szAbortCaption	db	"Application Error"
		db	0
szBlame		db	"BOOT "
		db	0
szSnoozer	db	" caused "
		db	0
szInModule	db	" in", 10, "module <unknown>"
		db	0
szAt		db	" at "
		db	0
szNukeApp       db      ".", 10, 10, "Choose close. "
		db	0
szWillClose	db	" will close."
		db	0
szGP		db	"a General Protection Fault"
		db	0
szD0		db	"a Divide by Zero"	; not yet used
		db	0
szSF		db	"a Stack Fault"		; not spec'ed
		db	0
szII		db	"an Illegal Instruction"	; "Fault" ???
		db	0
szPF		db	"a Page Fault"
		db	0
szNP		db	"a Not Present Fault"
		db	0
szAF		db	"an Application Fault"	; not yet used
		db	0
szLoad		db	"Segment Load Failure"
		db	0
szOutofSelectors db	"Out of Selectors"
		db	0

; Text for dialog box when terminating an application

public szAbort
szAbort 	db	"Closing current application.",0

; Text for dialog box when trying to run a compressed file
			   
public szBozo
szBozo  	db	"Cannot load compressed files",0
			 	     		     
; This is the caption string for system error dialog boxes

public	syserr
syserr		db	"System Error",0

; The following group of messages forms all of the messages used
; in the INT 24 dialog box.
;
; There are 7 messages which can be translated individually. The
; location of drvlet? and devenam? can be moved to any location
; within the string.

public	msgWriteProtect,drvlet1
public	msgCannotReadDrv,drvlet2
public	msgCannotWriteDrv,drvlet3
public	msgShare,drvlet4
public	msgNetError,drvlet5
public	msgCannotReadDev,devenam1
public	msgCannotWriteDev,devenam2
public	msgNoPrinter
public	msgNetErrorDev,devenam3

msgWriteProtect         db      "Write-protected disk in drive "
drvlet1                 db      "X.",0

msgCannotReadDrv        db      "Cannot read from drive "
drvlet2                 db      "X.",0

msgCannotWriteDrv       db      "Cannot write to drive "
drvlet3                 db      "X.",0

msgShare		db	"Sharing violation on drive "
drvlet4                 db      "X.",0

msgNetError		db	"Network error on drive "
drvlet5 		db	"X.",0

msgCannotReadDev        db      "Cannot read from device "
devenam1                db      8 dup (?)
                        db      0

msgCannotWriteDev       db      "Cannot write to device "
devenam2                db      8 dup (?)
			db	0

msgNetErrorDev		db	"Network error on device "
devenam3		db	8 dup (?)
			db	0

msgNoPrinter            db      "Printer not ready",0


ifndef WINDEBUG
public szExitStr1,szExitStr2
szExitStr1  DB  7,13,10,'FatalExit code = ',0
szExitStr2  DB  ' stack overflow',13,10,0
public  szUndefDyn
szUndefDyn      db      "Call to Undefined Dynalink",0
public  szFatalExit
szFatalExit	db	"Application requested abnormal termination",0
else
public szDebugStr
szDebugStr  DB  'KERNEL: Failed loading - ',0                   ; 0
            DB  'KERNEL: Failed loading new instance of - ',0   ; 1
            DB  'Error loading from resource file - ',0         ; 2
            DB  13,10,0                                         ; 3
            DB  7,13,10,'FatalExit code = ',0                   ; 4
            DB  ' stack overflow',0                             ; 5
            DB  13,10,'Stack trace:',13,10,0                    ; 6
	    DB  7,13,10,'Abort, Break, Exit or Ignore? ',0      ; 7
            DB  'Invalid BP chain',7,13,10,0                    ; 8
	    DB	': ',0						; 9
	    DB	'Reentered FatalExit',7,13,10,0 		; 10
	    DB  0
public szFKE
szFKE	DB '*** Fatal Kernel Error ***',0
endif

;** Diagnostic mode messages
        public szDiagStart, szCRLF, szLoadStart, szLoadSuccess, szLoadFail
        public szFailCode, szCodeString
szDiagStart     db      '[boot]'      ;lpCRLF must follow
szCRLF          db      0dh, 0ah, 0
szLoadStart     db      'LoadStart = ',0
szLoadSuccess   db      'LoadSuccess = ', 0
szLoadFail      db      'LoadFail = ', 0
szFailCode      db      ' Failure code is ' ;szCodeString must follow
szCodeString    db      '00', 0dh, 0ah, 0
ifdef WINDEBUG
	public szInitSpew
szInitSpew      DB      'Diagnostic mode startup.  Log file is:  ', 0
endif

_DATA	ENDS


_INITTEXT SEGMENT WORD PUBLIC 'CODE'
public szInadequate, szNoPMode, szNoGlobalInit
public NoOpenFile, NoLoadHeader, szMissingMod, szPleaseDoIt

ifdef WOW
public szGenBootFail
szNoPMode db "The Win16 Subsystem was unable to enter Protected Mode, DOSX.EXE must be in your AUTOEXEC.NT and present in your PATH.",0
szMissingMod    db   "NTVDM KERNEL: Missing 16-bit system module",0
szPleaseDoIt    db   "Please re-install the following module to your system32 directory:",13,10,9,9,0
szInadequate	db   "NTVDM KERNEL: Inadequate DPMI Server",0
szNoGlobalInit	db   "NTVDM KERNEL: Unable to initialize heap",0
NoOpenFile	    db   "NTVDM KERNEL: Unable to open KERNEL executable",0
NoLoadHeader	db   "NTVDM KERNEL: Unable to load KERNEL EXE header",0
szGenBootFail   db   "NTVDM KERNEL: Win16 Subsystem Initialization Failure",0
else
szInadequate	db   'KERNEL: Inadequate DPMI Server',13,10,'$'
szNoPMode	db   'KERNEL: Unable to enter Protected Mode',13,10,'$'
szNoGlobalInit	db   "KERNEL: Unable to initialize heap",13,10,'$'
NoOpenFile      db   "KERNEL: Unable to open KERNEL executable"
                db   13, 10, '$'
NoLoadHeader    db   "KERNEL: Unable to load KERNEL EXE header"
		db   13, 10, '$'
endif

_INITTEXT ENDS




_NRESTEXT SEGMENT WORD PUBLIC 'CODE'

; This is the caption string for the protect mode dialog box.
;
; DO NOT CHANGE THE LENGTH OF THIS MESSAGE
;

public szProtectCap,msgRealModeApp1,msgRealModeApp2

szProtectCap		db	"Application Compatibility Warning",0

msgRealModeApp1 db	"The application you are about to run, ",0
msgRealModeApp2 db	", was designed for a previous version of Windows.",0Dh,0Dh
	db	"Obtain an updated version of the application that is compatible "
	db	"with Windows version 3.0 and later.",13,13
	db	"If you choose the OK button and start the application, compatibility "
	db	"problems could cause the application or Windows to close unexpectedly.",0

_NRESTEXT ENDS

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\messages\fr\strings.asm ===
TITLE   STRINGS - OEM dependent strings used by KERNEL
include gpcont.inc              ; SHERLOCK

_DATA   SEGMENT PARA PUBLIC 'DATA'
_DATA   ENDS

DGROUP  GROUP   _DATA

_INITTEXT SEGMENT WORD PUBLIC 'CODE'
_INITTEXT ENDS

_NRESTEXT SEGMENT WORD PUBLIC 'CODE'
_NRESTEXT ENDS

ASSUME  DS:DGROUP


_DATA   SEGMENT PARA PUBLIC 'DATA'

; This is the caption string for the dialog box.

public  szDiskCap
IF 0
szDiskCap       db  'Changement de disque',0
ELSE
szDiskCap       db  'Erreur de fichier',0
ENDIF


; This is the text for the "Cannot find xxxxxx" dialog box.
; It is printed:
;
;       <szCannotFind1>filename<szCannotFind2>

public  szCannotFind1,szCannotFind2
szCannotFind1   db      "Impossible de trouver ", 0
szCannotFind2   db      0

; This is the text for fatal errors at boot time
;       <szBootLoad>filename
public szBootLoad
szBootLoad      db      "Erreur lors du chargement de ",0

; The following group of strings is used for the "Please insert disk with XXXX
;   in drive X:" dialog box.
;
; These two strings form the dialog message it is:
;
;       <szCannotFind1>filename<szInsert>

IF 0
public  szInsert
szInsert        db  ', Veuillez insrer dans le lecteur '
ENDIF
;public  drvlet
;drvlet         db  "X.",0

if SHERLOCK
public szGPCont         ; GP fault continuation message
szGPCont        db      "Une erreur s'est produite dans votre application.",10
	db      "Si vous choisissez Ignorer, vous devriez sauvegarder votre travail.",10
	db      "Si vous choisissez Fermer, votre application va se terminer.",0
endif

public  szDosVer
szDosVer        DB      'Version de MS-DOS incorrecte.  MS-DOS version 3.1 ou ultrieure est requis.',13,10,'$'
; Text for exceptions and faults lead to app termination.

public szAbortCaption,szInModule,szAt
public szNukeApp,szSnoozer,szGP,szSF,szII,szPF,szNP,szBlame,szLoad,szWillClose
public szOutofSelectors
szAbortCaption  db      "Erreur d'application"
		db      0
szBlame         db      "BOOT "
		db      0
szSnoozer       db      " a caus "
		db      0
szInModule      db      " dans le module <inconnu>"   ; Same French localization as in NT4 (, 10 missing)
		db      0
szAt            db      "  l'adresse "
		db      0
szNukeApp       db      ".", 10, 10, "Choisissez le bouton Fermer. "
		db      0
szWillClose     db      " va se fermer."
		db      0
szGP            db      "une faute de protection gnrale"
		db      0
szD0            db      "une division par zro" ; not yet used
		db      0
szSF            db      "une faute de pile"             ; not spec'ed
		db      0
szII            db      "une instruction illgale"      ; "Fault" ???
		db      0
szPF            db      "un dfaut de page"
		db      0
szNP            db      "une faute de non-prsence"
		db      0
szAF            db      "une faute d'une application"   ; not yet used
		db      0
szLoad          db      "Echec de chargement de segment"
		db      0
szOutofSelectors db     "Slecteurs puiss"
		db      0

; Text for dialog box when terminating an application

public szAbort
szAbort         db      "Fermeture de l'application en cours d'excution",0

; Text for dialog box when trying to run a compressed file
			   
public szBozo
szBozo          db      "Impossible de charger les fichiers compresss",0
						     
; This is the caption string for system error dialog boxes

public  syserr
syserr          db      "Erreur systme",0

; The following group of messages forms all of the messages used
; in the INT 24 dialog box.
;
; There are 7 messages which can be translated individually. The
; location of drvlet? and devenam? can be moved to any location
; within the string.

public  msgWriteProtect,drvlet1
public  msgCannotReadDrv,drvlet2
public  msgCannotWriteDrv,drvlet3
public  msgShare,drvlet4
public  msgNetError,drvlet5
public  msgCannotReadDev,devenam1
public  msgCannotWriteDev,devenam2
public  msgNoPrinter
public  msgNetErrorDev,devenam3

msgWriteProtect         db      "Disque protg en criture dans le lecteur "
drvlet1                 db      "X.",0

msgCannotReadDrv        db      "Impossible de lire depuis le lecteur "
drvlet2                 db      "X.",0

msgCannotWriteDrv       db      "Impossible d'crire sur le lecteur "
drvlet3                 db      "X.",0

msgShare                db      "Violation de partage sur le lecteur "
drvlet4                 db      "X.",0

msgNetError             db      "Erreur rseau sur le lecteur "
drvlet5                 db      "X.",0

msgCannotReadDev        db      "Impossible de lire depuis le priphrique "
devenam1                db      8 dup (?)
			db      0

msgCannotWriteDev       db      "Impossible d'crire sur le priphrique "
devenam2                db      8 dup (?)
			db      0

msgNetErrorDev          db      "Erreur rseau sur le priphrique "
devenam3                db      8 dup (?)
			db      0

msgNoPrinter            db      "Imprimante non prte",0


ifndef WINDEBUG
public szExitStr1,szExitStr2
szExitStr1  DB  7,13,10,'Code FatalExit = ',0
szExitStr2  DB  ' dpassement de pile',13,10,0
public  szUndefDyn
szUndefDyn      db      "Appel  un Dynalink non dfini",0
public  szFatalExit
szFatalExit     db      "L'application a demand une fin anormale",0
else
public szDebugStr
szDebugStr  DB  'NOYAU : Echec de chargement - ',0                   ; 0
	    DB  "NOYAU : Echec du chargement d'une nouvelle instance de - ",0   ; 1
	    DB  'Erreur de chargement depuis le fichier de ressources - ',0         ; 2
	    DB  13,10,0                                         ; 3
	    DB  7,13,10,'Code FatalExit = ',0                   ; 4
	    DB  ' dpassement de pile',0                             ; 5
	    DB  13,10,'Trace de la pile :',13,10,0                    ; 6
	    DB  7,13,10,'Abandonner, Interrompre, Quitter ou Ignorer ? ',0      ; 7
	    DB  'Chane BP non valide',7,13,10,0                    ; 8
	    DB  ': ',0                                          ; 9
	    DB  'FatalExit rentre',7,13,10,0          ; 10
	    DB  0
public szFKE
szFKE   DB '*** Erreur fatale du noyau ***',0
endif

;** Diagnostic mode messages
	public szDiagStart, szCRLF, szLoadStart, szLoadSuccess, szLoadFail
        public szFailCode, szCodeString
szDiagStart     db      '[boot]'      ;lpCRLF must follow
szCRLF          db      0dh, 0ah, 0
szLoadStart     db      'LoadStart = ',0
szLoadSuccess   db      'LoadSuccess = ', 0
szLoadFail      db      'LoadFail = ', 0
szFailCode      db      " Le code d'chec est " ;szCodeString must follow
szCodeString    db      '00', 0dh, 0ah, 0
ifdef WINDEBUG
	public szInitSpew
szInitSpew      DB      'Dmarrage du mode diagnostic.  Le fichier journal est :  ', 0
endif

_DATA   ENDS


_INITTEXT SEGMENT WORD PUBLIC 'CODE'
public szInadequate, szNoPMode, szNoGlobalInit
public NoOpenFile, NoLoadHeader, szMissingMod, szPleaseDoIt

ifdef WOW
public szGenBootFail
szNoPMode db "Le sous-systme Win16 n'a pas pu entrer en mode protg, DOSX.EXE doit tre dans votre AUTOEXEC.NT et prsent dans votre chemin PATH.",0
szMissingMod    db   "NOYAU NTVDM : Module systme 16 bits manquant",0
szPleaseDoIt    db   "Veuillez rinstaller le module suivant dans votre rpertoire system32 :",13,10,9,9,0
szInadequate	db   "NOYAU NTVDM : Serveur DPMI inadquat",0
szNoGlobalInit	db   "NOYAU NTVDM : Impossible d'initialiser le tas",0
NoOpenFile	    db   "NOYAU NTVDM : Impossible d'ouvrir l'excutable NOYAU",0
NoLoadHeader	db   "NOYAU NTVDM : Impossible de charger l'en-tte EXE du NOYAU",0
szGenBootFail   db   "NOYAU NTVDM : Dysfonctionnement de l'initialisation du sous-systme Win16",0
else
szInadequate    db   'NOYAU : Serveur DPMI inadquat',13,10,'$'
szNoPMode       db   "NOYAU : Impossible d'entrer en mode protg",13,10,'$'
szNoGlobalInit  db   "NOYAU : Impossible d'initialiser le tas",13,10,'$'
NoOpenFile      db   "NOYAU : Impossible d'ouvrir l'excutable NOYAU"
		db   13, 10, '$'
NoLoadHeader    db   "NOYAU : Impossible de charger l'en-tte EXE du NOYAU"
		db   13, 10, '$'
endif

_INITTEXT ENDS




_NRESTEXT SEGMENT WORD PUBLIC 'CODE'

; This is the caption string for the protect mode dialog box.
;
; DO NOT CHANGE THE LENGTH OF THIS MESSAGE
;

public szProtectCap,msgRealModeApp1,msgRealModeApp2

szProtectCap            db      "Avertissement de compatibilit d'application",0

msgRealModeApp1 db      "L'application que vous tes sur le point d'excuter, ",0
msgRealModeApp2 db      ", a t conue pour une version prcdente de Windows.",0Dh,0Dh
	db      "Procurez-vous une version mise  jour de l'application qui soit compatible "
	db      "avec Windows version 3.0 ou ultrieure.",13,13
	db      "Si vous choisissez OK pour lancer l'application, des problmes de "
	db      "compatibilit pourraient fermer Windows ou l'application de faon inattendue.",0

_NRESTEXT ENDS

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\messages\kor\strings.asm ===
TITLE	STRINGS - OEM dependent strings used by KERNEL
include gpcont.inc		; SHERLOCK

_DATA	SEGMENT PARA PUBLIC 'DATA'
_DATA	ENDS

DGROUP	GROUP	_DATA

_INITTEXT SEGMENT WORD PUBLIC 'CODE'
_INITTEXT ENDS

_NRESTEXT SEGMENT WORD PUBLIC 'CODE'
_NRESTEXT ENDS

ASSUME	DS:DGROUP


_DATA	SEGMENT PARA PUBLIC 'DATA'

; This is the caption string for the dialog box.

public	szDiskCap
IF 0
szDiskCap	db  'Change Disk',0
ELSE
szDiskCap	db  'File Error',0
ENDIF


; This is the text for the "Cannot find xxxxxx" dialog box.
; It is printed:
;
;       <szCannotFind1>filename<szCannotFind2>

public	szCannotFind1,szCannotFind2
szCannotFind1	db	"Cannot find ", 0
szCannotFind2	db	0

; This is the text for fatal errors at boot time
;	<szBootLoad>filename
public szBootLoad
szBootLoad	db	"Error loading ",0

; The following group of strings is used for the "Please insert disk with XXXX
;   in drive X:" dialog box.
;
; These two strings form the dialog message it is:
;
;	<szCannotFind1>filename<szInsert>

IF 0
public	szInsert
szInsert	db  ', Please insert in drive '
ENDIF
;public  drvlet
;drvlet		db  "X.",0

if SHERLOCK
public szGPCont		; GP fault continuation message
szGPCont	db	"An error has occurred in your application.",10
        db      "If you choose Ignore, you should save your work in a new file.",10
        db      "If you choose Close, your application will terminate.",0
endif

public	szDosVer
szDosVer	DB	'Incorrect MS-DOS version.  MS-DOS 3.1 or greater required.',13,10,'$'
; Text for exceptions and faults lead to app termination.

public szAbortCaption,szInModule,szAt
public szNukeApp,szSnoozer,szGP,szSF,szII,szPF,szNP,szBlame,szLoad,szWillClose
public szOutofSelectors
szAbortCaption	db	"Application Error"
		db	0
szBlame		db	"BOOT "
		db	0
szSnoozer	db	" caused "
		db	0
szInModule	db	" in", 10, "module <unknown>"
		db	0
szAt		db	" at "
		db	0
szNukeApp       db      ".", 10, 10, "Choose close. "
		db	0
szWillClose	db	" will close."
		db	0
szGP		db	"a General Protection Fault"
		db	0
szD0		db	"a Divide by Zero"	; not yet used
		db	0
szSF		db	"a Stack Fault"		; not spec'ed
		db	0
szII		db	"an Illegal Instruction"	; "Fault" ???
		db	0
szPF		db	"a Page Fault"
		db	0
szNP		db	"a Not Present Fault"
		db	0
szAF		db	"an Application Fault"	; not yet used
		db	0
szLoad		db	"Segment Load Failure"
		db	0
szOutofSelectors db	"Out of Selectors"
		db	0

; Text for dialog box when terminating an application

public szAbort
szAbort 	db	"Closing current application.",0

; Text for dialog box when trying to run a compressed file
			   
public szBozo
szBozo  	db	"Cannot load compressed files",0
			 	     		     
; This is the caption string for system error dialog boxes

public	syserr
syserr		db	"System Error",0

; The following group of messages forms all of the messages used
; in the INT 24 dialog box.
;
; There are 7 messages which can be translated individually. The
; location of drvlet? and devenam? can be moved to any location
; within the string.

public	msgWriteProtect,drvlet1
public	msgCannotReadDrv,drvlet2
public	msgCannotWriteDrv,drvlet3
public	msgShare,drvlet4
public	msgNetError,drvlet5
public	msgCannotReadDev,devenam1
public	msgCannotWriteDev,devenam2
public	msgNoPrinter
public	msgNetErrorDev,devenam3

msgWriteProtect         db      "Write-protected disk in drive "
drvlet1                 db      "X.",0

msgCannotReadDrv        db      "Cannot read from drive "
drvlet2                 db      "X.",0

msgCannotWriteDrv       db      "Cannot write to drive "
drvlet3                 db      "X.",0

msgShare		db	"Sharing violation on drive "
drvlet4                 db      "X.",0

msgNetError		db	"Network error on drive "
drvlet5 		db	"X.",0

msgCannotReadDev        db      "Cannot read from device "
devenam1                db      8 dup (?)
                        db      0

msgCannotWriteDev       db      "Cannot write to device "
devenam2                db      8 dup (?)
			db	0

msgNetErrorDev		db	"Network error on device "
devenam3		db	8 dup (?)
			db	0

msgNoPrinter            db      "Printer not ready",0


ifndef WINDEBUG
public szExitStr1,szExitStr2
szExitStr1  DB  7,13,10,'FatalExit code = ',0
szExitStr2  DB  ' stack overflow',13,10,0
public  szUndefDyn
szUndefDyn      db      "Call to Undefined Dynalink",0
public  szFatalExit
szFatalExit	db	"Application requested abnormal termination",0
else
public szDebugStr
szDebugStr  DB  'KERNEL: Failed loading - ',0                   ; 0
            DB  'KERNEL: Failed loading new instance of - ',0   ; 1
            DB  'Error loading from resource file - ',0         ; 2
            DB  13,10,0                                         ; 3
            DB  7,13,10,'FatalExit code = ',0                   ; 4
            DB  ' stack overflow',0                             ; 5
            DB  13,10,'Stack trace:',13,10,0                    ; 6
	    DB  7,13,10,'Abort, Break, Exit or Ignore? ',0      ; 7
            DB  'Invalid BP chain',7,13,10,0                    ; 8
	    DB	': ',0						; 9
	    DB	'Reentered FatalExit',7,13,10,0 		; 10
	    DB  0
public szFKE
szFKE	DB '*** Fatal Kernel Error ***',0
endif

;** Diagnostic mode messages
        public szDiagStart, szCRLF, szLoadStart, szLoadSuccess, szLoadFail
        public szFailCode, szCodeString
szDiagStart     db      '[boot]'      ;lpCRLF must follow
szCRLF          db      0dh, 0ah, 0
szLoadStart     db      'LoadStart = ',0
szLoadSuccess   db      'LoadSuccess = ', 0
szLoadFail      db      'LoadFail = ', 0
szFailCode      db      ' Failure code is ' ;szCodeString must follow
szCodeString    db      '00', 0dh, 0ah, 0
ifdef WINDEBUG
	public szInitSpew
szInitSpew      DB      'Diagnostic mode startup.  Log file is:  ', 0
endif

_DATA	ENDS


_INITTEXT SEGMENT WORD PUBLIC 'CODE'
public szInadequate, szNoPMode, szNoGlobalInit
public NoOpenFile, NoLoadHeader, szMissingMod, szPleaseDoIt

ifdef WOW
public szGenBootFail
szNoPMode db "The Win16 Subsystem was unable to enter Protected Mode, DOSX.EXE must be in your AUTOEXEC.NT and present in your PATH.",0
szMissingMod    db   "NTVDM KERNEL: Missing 16-bit system module",0
szPleaseDoIt    db   "Please re-install the following module to your system32 directory:",13,10,9,9,0
szInadequate	db   "NTVDM KERNEL: Inadequate DPMI Server",0
szNoGlobalInit	db   "NTVDM KERNEL: Unable to initialize heap",0
NoOpenFile	    db   "NTVDM KERNEL: Unable to open KERNEL executable",0
NoLoadHeader	db   "NTVDM KERNEL: Unable to load KERNEL EXE header",0
szGenBootFail   db   "NTVDM KERNEL: Win16 Subsystem Initialization Failure",0
else
szInadequate	db   'KERNEL: Inadequate DPMI Server',13,10,'$'
szNoPMode	db   'KERNEL: Unable to enter Protected Mode',13,10,'$'
szNoGlobalInit	db   "KERNEL: Unable to initialize heap",13,10,'$'
NoOpenFile      db   "KERNEL: Unable to open KERNEL executable"
                db   13, 10, '$'
NoLoadHeader    db   "KERNEL: Unable to load KERNEL EXE header"
		db   13, 10, '$'
endif

_INITTEXT ENDS




_NRESTEXT SEGMENT WORD PUBLIC 'CODE'

; This is the caption string for the protect mode dialog box.
;
; DO NOT CHANGE THE LENGTH OF THIS MESSAGE
;

public szProtectCap,msgRealModeApp1,msgRealModeApp2

szProtectCap		db	"Application Compatibility Warning",0

msgRealModeApp1 db	"The application you are about to run, ",0
msgRealModeApp2 db	", was designed for a previous version of Windows.",0Dh,0Dh
	db	"Obtain an updated version of the application that is compatible "
	db	"with Windows version 3.0 and later.",13,13
	db	"If you choose the OK button and start the application, compatibility "
	db	"problems could cause the application or Windows to close unexpectedly.",0

_NRESTEXT ENDS

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\messages\pl\strings.asm ===
TITLE   STRINGS - OEM dependent strings used by KERNEL
include gpcont.inc              ; SHERLOCK

_DATA   SEGMENT PARA PUBLIC 'DATA'
_DATA   ENDS

DGROUP  GROUP   _DATA

_INITTEXT SEGMENT WORD PUBLIC 'CODE'
_INITTEXT ENDS

_NRESTEXT SEGMENT WORD PUBLIC 'CODE'
_NRESTEXT ENDS

ASSUME  DS:DGROUP


_DATA   SEGMENT PARA PUBLIC 'DATA'

; This is the caption string for the dialog box.

public  szDiskCap
IF 0
szDiskCap       db  'Zmie dyskietk',0
ELSE
szDiskCap       db  'Bd pliku',0
ENDIF


; This is the text for the "Cannot find xxxxxx" dialog box.
; It is printed:
;
;       <szCannotFind1>filename<szCannotFind2>

public  szCannotFind1,szCannotFind2
szCannotFind1   db      "Nie mona odnale ", 0
szCannotFind2   db      0

; This is the text for fatal errors at boot time
;       <szBootLoad>filename
public szBootLoad
szBootLoad      db      "Bd adowania ",0

; The following group of strings is used for the "Please insert disk with XXXX
;   in drive X:" dialog box.
;
; These two strings form the dialog message it is:
;
;       <szCannotFind1>filename<szInsert>

IF 0
public  szInsert
szInsert        db  ', W do stacji '
ENDIF
;public  drvlet
;drvlet         db  "X.",0

if SHERLOCK
public szGPCont         ; GP fault continuation message
szGPCont        db      "W aplikacji wystpi bd.",10
	db      "Jeli wybierzesz Ignoruj, moliwe bdzie zapisanie wynikw pracy w nowym pliku.",10
	db      "Jeli wybierzesz Zamknij, aplikacja zostanie zakoczona.",0
endif

public  szDosVer
szDosVer        DB      'Niepoprawna wersja MS-DOS. Wymagany jest system MS-DOS 3.1 lub nowszy.',13,10,'$'
; Text for exceptions and faults lead to app termination.

public szAbortCaption,szInModule,szAt
public szNukeApp,szSnoozer,szGP,szSF,szII,szPF,szNP,szBlame,szLoad,szWillClose
public szOutofSelectors
szAbortCaption  db      "Bd aplikacji"
		db      0
szBlame         db      "BOOT "
		db      0
szSnoozer       db      " wywoaa "
		db      0
szInModule      db      " w", 10, "module <nieznany>"
		db      0
szAt            db      " pod adresem "
		db      0
szNukeApp       db      ".", 10, 10, "Wybierz zamknicie. "
		db      0
szWillClose     db      " ulegnie zamkniciu."
		db      0
szGP            db      "oglny bd ochrony"
		db      0
szD0            db      "dzielenie przez zero"  ; not yet used
		db      0
szSF            db      "bd stosu"            ; not spec'ed
		db      0
szII            db      "nieprawidow instrukcj"      ; "Fault" ???
		db      0
szPF            db      "bd strony"
		db      0
szNP            db      "bd braku"
		db      0
szAF            db      "bd aplikacji"        ; not yet used
		db      0
szLoad          db      "bd adowania segmentu "
		db      0
szOutofSelectors db     "za mao selektorw"
		db      0

; Text for dialog box when terminating an application

public szAbort
szAbort         db      "Zamykanie aplikacji.",0

; Text for dialog box when trying to run a compressed file
			   
public szBozo
szBozo          db      "Nie mona zaadowa plikw skompresowanych",0
						     
; This is the caption string for system error dialog boxes

public  syserr
syserr          db      "Bd systemu",0

; The following group of messages forms all of the messages used
; in the INT 24 dialog box.
;
; There are 7 messages which can be translated individually. The
; location of drvlet? and devenam? can be moved to any location
; within the string.

public  msgWriteProtect,drvlet1
public  msgCannotReadDrv,drvlet2
public  msgCannotWriteDrv,drvlet3
public  msgShare,drvlet4
public  msgNetError,drvlet5
public  msgCannotReadDev,devenam1
public  msgCannotWriteDev,devenam2
public  msgNoPrinter
public  msgNetErrorDev,devenam3

msgWriteProtect         db      "Dysk zabezpieczony przed zapisem w stacji "
drvlet1                 db      "X.",0

msgCannotReadDrv        db      "Nie jest moliwy odczyt z dysku "
drvlet2                 db      "X.",0

msgCannotWriteDrv       db      "Nie jest moliwy zapis na dysk "
drvlet3                 db      "X.",0

msgShare                db      "Bd wspuytkowania dysku "
drvlet4                 db      "X.",0

msgNetError             db      "Bd sieciowy dysku "
drvlet5                 db      "X.",0

msgCannotReadDev        db      "Nie jest moliwy odczyt z urzdzenia "
devenam1                db      8 dup (?)
			db      0

msgCannotWriteDev       db      "Nie jest moliwy zapis do urzdzenia "
devenam2                db      8 dup (?)
			db      0

msgNetErrorDev          db      "Bd sieci na urzdzeniu "
devenam3                db      8 dup (?)
			db      0

msgNoPrinter            db      "Drukarka nie jest gotowa",0


ifndef WINDEBUG
public szExitStr1,szExitStr2
szExitStr1  DB  7,13,10,'FatalExit code = ',0
szExitStr2  DB  ' przepenienie stosu',13,10,0
public  szUndefDyn
szUndefDyn      db      "wywoanie niezdefiniowanego cza Dynalink",0
public  szFatalExit
szFatalExit     db      "Aplikacja zadaa nietypowego zakoczenia",0
else
public szDebugStr
szDebugStr  DB  'KERNEL: Nieudane adowanie - ',0                   ; 0
	    DB  'KERNEL: Nieudane adowanie nowego wystpienia - ',0   ; 1
	    DB  'Bd adowania z pliku zasobw - ',0         ; 2
	    DB  13,10,0                                         ; 3
	    DB  7,13,10,'FatalExit code = ',0                   ; 4
	    DB  ' przepenienie stosu',0                             ; 5
	    DB  13,10,'ledzenie stosu:',13,10,0                    ; 6
	    DB  7,13,10,'Zakocz, Przerwij, Wyjd czy Ignoruj? ',0      ; 7
	    DB  'Nieprawidowy acuch BP',7,13,10,0                    ; 8
	    DB  ': ',0                                          ; 9
	    DB  'Ponowne wejcie do funkcji FatalExit',7,13,10,0   ; 10
	    DB  0
public szFKE
szFKE   DB '*** Krytyczny bd jdra ***',0
endif

;** Diagnostic mode messages
	public szDiagStart, szCRLF, szLoadStart, szLoadSuccess, szLoadFail
	public szFailCode, szCodeString
szDiagStart     db      '[boot]'      ;lpCRLF must follow
szCRLF          db      0dh, 0ah, 0
szLoadStart     db      'LoadStart = ',0
szLoadSuccess   db      'LoadSuccess = ', 0
szLoadFail      db      'LoadFail = ', 0
szFailCode      db      ' Kod bdu ' ;szCodeString must follow
szCodeString    db      '00', 0dh, 0ah, 0
ifdef WINDEBUG
	public szInitSpew
szInitSpew      DB      'Rozpoczcie trybu diagnostycznego. Plik wynikw:  ', 0
endif

_DATA   ENDS


_INITTEXT SEGMENT WORD PUBLIC 'CODE'
public szInadequate, szNoPMode, szNoGlobalInit
public NoOpenFile, NoLoadHeader, szMissingMod, szPleaseDoIt

ifdef WOW
public szGenBootFail
szNoPMode db "Podsystem Win16 nie mg uruchomi trybu chronionego, DOSX.EXE musi by w AUTOEXEC.NT oraz w ciece wyszukiwania.",0
szMissingMod    db   "NTVDM KERNEL: Brak 16-bitowego moduu systemowego",0
szPleaseDoIt    db   "Zainstaluj ponownie nastpujcy modu w katalogu system32:",13,10,9,9,0
szInadequate    db   "NTVDM KERNEL: Nieodpowiedni serwer DPMI",0
szNoGlobalInit  db   "NTVDM KERNEL: Nie mona zainicjowa sterty",0
NoOpenFile      db   "NTVDM KERNEL: Nie mona otworzy pliku wykonywalnego KERNEL",0
NoLoadHeader    db   "NTVDM KERNEL: Nie mona zaadowa nagwka KERNEL EXE",0
szGenBootFail   db   "NTVDM KERNEL: Bd inicjowania podsystemu Win16",0
else
szInadequate    db   'KERNEL: Nieodpowiedni serwer DPMI',13,10,'$'
szNoPMode       db   'KERNEL: Nie mona uruchomi trybu chronionego',13,10,'$'
szNoGlobalInit  db   "KERNEL: Nie mona zainicjowa sterty",13,10,'$'
NoOpenFile      db   "KERNEL: Nie mona otworzy pliku wykonywalnego KERNEL"
		db   13, 10, '$'
NoLoadHeader    db   "KERNEL: Nie mona zaadowa nagwka KERNEL EXE"
		db   13, 10, '$'
endif

_INITTEXT ENDS




_NRESTEXT SEGMENT WORD PUBLIC 'CODE'

; This is the caption string for the protect mode dialog box.
;
; DO NOT CHANGE THE LENGTH OF THIS MESSAGE
;

public szProtectCap,msgRealModeApp1,msgRealModeApp2

szProtectCap        db	"Ostrzeenie o zgodnoci aplikacji",0

msgRealModeApp1 db      "Aplikacja ktr chcesz uruchomi, ",0
msgRealModeApp2 db      ", zostaa zaprojektowana dla poprzedniej wersji Windows.",0Dh,0Dh
	db      "Uzyskaj uaktualnion wersj tej aplikacji, zgodn "
	db      "z systemem Windows w wersji 3.0 lub nowszej.",13,13
	db      "Jeli wybierzesz OK i uruchomisz aplikacj, problemy ze zgodnoci "
	db      "mog spowodowa niespodziewane zamknicie aplikacji lub systemu.",0

_NRESTEXT ENDS

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\messages\pt\strings.asm ===
TITLE	STRINGS - OEM dependent strings used by KERNEL
include gpcont.inc		; SHERLOCK

_DATA	SEGMENT PARA PUBLIC 'DATA'
_DATA	ENDS

DGROUP	GROUP	_DATA

_INITTEXT SEGMENT WORD PUBLIC 'CODE'
_INITTEXT ENDS

_NRESTEXT SEGMENT WORD PUBLIC 'CODE'
_NRESTEXT ENDS

ASSUME	DS:DGROUP


_DATA	SEGMENT PARA PUBLIC 'DATA'

; This is the caption string for the dialog box.

public	szDiskCap
IF 0
szDiskCap	db  'Trocar disco',0
ELSE
szDiskCap	db  'Erro de ficheiro',0
ENDIF


; This is the text for the "Cannot find xxxxxx" dialog box.
; It is printed:
;
;       <szCannotFind1>filename<szCannotFind2>

public	szCannotFind1,szCannotFind2
szCannotFind1	db	"No  possvel encontrar ", 0
szCannotFind2	db	0

; This is the text for fatal errors at boot time
;	<szBootLoad>filename
public szBootLoad
szBootLoad	db	"Erro a carregar ",0

; The following group of strings is used for the "Please insert disk with XXXX
;   in drive X:" dialog box.
;
; These two strings form the dialog message it is:
;
;	<szCannotFind1>filename<szInsert>

IF 0
public	szInsert
szInsert	db  ', Introduza na unidade  '
ENDIF
;public  drvlet
;drvlet		db  "X.",0

if SHERLOCK
public szGPCont		; GP fault continuation message
szGPCont	db	"Ocorreu um erro na aplicao.",10
        db      "Se escolher Ignorar, deve guardar o seu trabalho num novo ficheiro.",10
        db      "Se escolher Fechar, a aplicao terminar.",0
endif

public	szDosVer
szDosVer	DB	'Verso de MS-DOS incorrecta. Necessrio o MS-DOS 3.1 ou posterior.',13,10,'$'
; Text for exceptions and faults lead to app termination.

public szAbortCaption,szInModule,szAt
public szNukeApp,szSnoozer,szGP,szSF,szII,szPF,szNP,szBlame,szLoad,szWillClose
public szOutofSelectors
szAbortCaption	db	"Erro de aplicao"
		db	0
szBlame		db	"BOOT "
		db	0
szSnoozer	db	" causou "
		db	0
szInModule	db	" no", 10, "mdulo <unknown>"
		db	0
szAt		db	" em "
		db	0
szNukeApp       db      ".", 10, 10, "Escolha fechar. "
		db	0
szWillClose	db	" ser fechada."
		db	0
szGP		db	"uma falha geral de proteco"
		db	0
szD0		db	"uma diviso por zero"	; not yet used
		db	0
szSF		db	"uma falha de pilha"		; not spec'ed
		db	0
szII		db	"uma instruo ilegal"	; "Fault" ???
		db	0
szPF		db	"uma falha de pgina"
		db	0
szNP		db	"uma falha de no presente"
		db	0
szAF		db	"uma falha de aplicao"	; not yet used
		db	0
szLoad		db	"Falha de carregamento de segmento"
		db	0
szOutofSelectors db	"Sem selectores"
		db	0

; Text for dialog box when terminating an application

public szAbort
szAbort 	db	"A encerrar a aplicao actual.",0

; Text for dialog box when trying to run a compressed file
			   
public szBozo
szBozo  	db	"Impossvel carregar ficheiros comprimidos",0
			 	     		     
; This is the caption string for system error dialog boxes

public	syserr
syserr		db	"Erro de sistema",0

; The following group of messages forms all of the messages used
; in the INT 24 dialog box.
;
; There are 7 messages which can be translated individually. The
; location of drvlet? and devenam? can be moved to any location
; within the string.

public	msgWriteProtect,drvlet1
public	msgCannotReadDrv,drvlet2
public	msgCannotWriteDrv,drvlet3
public	msgShare,drvlet4
public	msgNetError,drvlet5
public	msgCannotReadDev,devenam1
public	msgCannotWriteDev,devenam2
public	msgNoPrinter
public	msgNetErrorDev,devenam3

msgWriteProtect         db      "Disco protegido contra escrita na unidade "
drvlet1                 db      "X.",0

msgCannotReadDrv        db      "Impossivel ler da unidade "
drvlet2                 db      "X.",0

msgCannotWriteDrv       db      "Impossivel escrever na unidade "
drvlet3                 db      "X.",0

msgShare		db	"Violao de partilha na unidade "
drvlet4                 db      "X.",0

msgNetError		db	"Erro de rede na unidade "
drvlet5 		db	"X.",0

msgCannotReadDev        db      "Impossvel ler do dispositivo "
devenam1                db      8 dup (?)
                        db      0

msgCannotWriteDev       db      "Impossvel escrever no dispositivo "
devenam2                db      8 dup (?)
			db	0

msgNetErrorDev		db	"Erro de rede no dispositivo "
devenam3		db	8 dup (?)
			db	0

msgNoPrinter            db      "Impressora no preparada",0


ifndef WINDEBUG
public szExitStr1,szExitStr2
szExitStr1  DB  7,13,10,'Cd. FatalExit = ',0
szExitStr2  DB  ' excesso de pilha',13,10,0
public  szUndefDyn
szUndefDyn      db      "Chamada a dynalink no definida",0
public  szFatalExit
szFatalExit	db	"A aplicao requisitou concluso anormal.",0
else
public szDebugStr
szDebugStr  DB  'KERNEL: Falhou a carregar - ',0                   ; 0
            DB  'KERNEL: Falhou a carregar nova instncia de - ',0   ; 1
            DB  'Erro a carregar de ficheiro de recursos - ',0         ; 2
            DB  13,10,0                                         ; 3
            DB  7,13,10,'Cd. FatalExit = ',0                   ; 4
            DB  ' excesso de pilha',0                             ; 5
            DB  13,10,'Rastreio da pilha:',13,10,0                    ; 6
	    DB  7,13,10,'Abortar, Suspender, Sair ou Ignorar? ',0      ; 7
            DB  'Cadeia BP invlida',7,13,10,0                    ; 8
	    DB	': ',0						; 9
	    DB	'FatalExit reentrou',7,13,10,0 		; 10
	    DB  0
public szFKE
szFKE	DB '*** Erro fatal de Kernel ***',0
endif

;** Diagnostic mode messages
        public szDiagStart, szCRLF, szLoadStart, szLoadSuccess, szLoadFail
        public szFailCode, szCodeString
szDiagStart     db      '[boot]'      ;lpCRLF must follow
szCRLF          db      0dh, 0ah, 0
szLoadStart     db      'LoadStart = ',0
szLoadSuccess   db      'LoadSuccess = ', 0
szLoadFail      db      'LoadFail = ', 0
szFailCode      db      ' Cdigo de falha  ' ;szCodeString must follow
szCodeString    db      '00', 0dh, 0ah, 0
ifdef WINDEBUG
	public szInitSpew
szInitSpew      DB      'Arranque em modo diagnstico. Ficheiro de registo :  ', 0
endif

_DATA	ENDS


_INITTEXT SEGMENT WORD PUBLIC 'CODE'
public szInadequate, szNoPMode, szNoGlobalInit
public NoOpenFile, NoLoadHeader, szMissingMod, szPleaseDoIt

ifdef WOW
public szGenBootFail
szNoPMode db "O subsistema Win16 no conseguiu entrar em modo protegido. O DOSX.EXE tem de estar no AUTOEXEC.NT e presente em PATH.",0
szMissingMod    db   "NTVDM KERNEL: Falta mdulo de sistema a 16-bits",0
szPleaseDoIt    db   "Reinstale o mdulo seguinte no directrio system32:",13,10,9,9,0
szInadequate	db   "NTVDM KERNEL: Servidor DPMI inadequado",0
szNoGlobalInit	db   "NTVDM KERNEL: Impossvel inicializar a pilha local",0
NoOpenFile	    db   "NTVDM KERNEL: Impossvel abrir um executvel de KERNEL",0
NoLoadHeader	db   "NTVDM KERNEL: Impossvel carregar um cabealho de EXE de KERNEL",0
szGenBootFail   db   "NTVDM KERNEL: Falha na inicializao de subsistema Win16",0
else
szInadequate	db   'KERNEL: Servidor DPMI inadequado',13,10,'$'
szNoPMode	db   'KERNEL: Impossvel entrar em modo protegido',13,10,'$'
szNoGlobalInit	db   "KERNEL: Impossvel inicializar a pilha local",13,10,'$'
NoOpenFile      db   "KERNEL: Impossvel abrir um executvel de KERNEL"
                db   13, 10, '$'
NoLoadHeader    db   "KERNEL: Impossvel carregar um cabealho de EXE de KERNEL"
		db   13, 10, '$'
endif

_INITTEXT ENDS




_NRESTEXT SEGMENT WORD PUBLIC 'CODE'

; This is the caption string for the protect mode dialog box.
;
; DO NOT CHANGE THE LENGTH OF THIS MESSAGE
;

public szProtectCap,msgRealModeApp1,msgRealModeApp2

szProtectCap		db	"Aviso de compatibilidade de aplicaes",0

msgRealModeApp1 db	"A aplicao que est prestes a executar, ",0
msgRealModeApp2 db	", foi concebida para uma verso anterior do Windows.",0Dh,0Dh
	db	"Obtenha uma verso actualizada da aplicao que seja compatvel "
	db	"com o Windows verso 3.0 e posteriores. ",13,13
	db	"Se escolher o boto OK e iniciar a aplicao, problemas de compatibilidade"
	db	"podero fechar inesperadamente a aplicao ou o Windows.",0

_NRESTEXT ENDS

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\messages\ger\strings.asm ===
TITLE	STRINGS - OEM dependent strings used by KERNEL
include gpcont.inc		; SHERLOCK

_DATA	SEGMENT PARA PUBLIC 'DATA'
_DATA	ENDS

DGROUP	GROUP	_DATA

_INITTEXT SEGMENT WORD PUBLIC 'CODE'
_INITTEXT ENDS

_NRESTEXT SEGMENT WORD PUBLIC 'CODE'
_NRESTEXT ENDS

ASSUME	DS:DGROUP


_DATA	SEGMENT PARA PUBLIC 'DATA'

; This is the caption string for the dialog box.

public	szDiskCap
IF 0
szDiskCap	db  'Diskette wechseln',0
ELSE
szDiskCap	db  'Dateifehler',0
ENDIF


; This is the text for the "Cannot find xxxxxx" dialog box.
; It is printed:
;
;       <szCannotFind1>filename<szCannotFind2>

public	szCannotFind1,szCannotFind2
szCannotFind1	db	"Folgende Datei kann nicht gefunden werden: ", 0
szCannotFind2	db	0

; This is the text for fatal errors at boot time
;	<szBootLoad>filename
public szBootLoad
szBootLoad	db	"Fehler beim Laden der Datei: ",0

; The following group of strings is used for the "Please insert disk with XXXX
;   in drive X:" dialog box.
;
; These two strings form the dialog message it is:
;
;	<szCannotFind1>filename<szInsert>

IF 0
public	szInsert
szInsert	db  ', Bitte legen Sie die Diskette ein in Laufwerk '
ENDIF
;public  drvlet
;drvlet		db  "X:. ",0

if SHERLOCK
public szGPCont		; GP fault continuation message
szGPCont	db	"In Ihrer Anwendung ist ein Fehler aufgetreten.",10
	db	"Falls Sie 'Ignorieren' whlen, sollten Sie Ihre Arbeit",10
	db	"in einer neuen Datei sichern. Falls Sie 'Schlieen' ",10
	db	"whlen, wird Ihre Anwendung beendet. ",0

endif

public	szDosVer
szDosVer	DB	'Falsche MS-DOS-Version. MS-DOS, Version 3.1 oder hher erforderlich. ',13,10,'$'
; Text for exceptions and faults lead to app termination.

public szAbortCaption,szInModule,szAt
public szNukeApp,szSnoozer,szGP,szSF,szII,szPF,szNP,szBlame,szLoad,szWillClose
public szOutofSelectors
szAbortCaption	db	"Anwendungsfehler"
		db	0
szBlame		db	"START "
		db	0
szSnoozer	db	" verursachte "
		db	0
szInModule	db	" in", 10, "Modul <NO_NAME>"
		db	0
szAt		db	" bei "
		db	0
szNukeApp	db	". ", 10, 10, "Whlen Sie 'Schlieen'. "
		db	0
szWillClose	db	" wird schlieen. "
		db	0
szGP		db	"eine allgemeine Schutzverletzung"
		db	0
szD0		db	"eine Division durch Null"	; not yet used
		db	0
szSF		db	"ein Stapelspeicherfehler"	; not spec'ed
		db	0
szII		db	"eine unzulssige Anweisung"	; "Fault" ???
		db	0
szPF		db	"ein Seitenfehler"
		db	0
szNP		db	"ein nicht vorhandener Fehler"
		db	0
szAF		db	"ein Anwendungsfehler"	; not yet used
		db	0
szLoad		db	"Segmentladefehler"
		db	0
szOutofSelectors db	"Nicht gengend Selektoren"
		db	0

; Text for dialog box when terminating an application

public szAbort
szAbort 	db	"Schliet aktuelle Anwendung. ",0

; Text for dialog box when trying to run a compressed file
			   
public szBozo
szBozo  	db	"Komprimierte Dateien knnen nicht geladen werden. ",0
			 	     		     
; This is the caption string for system error dialog boxes

public	syserr
syserr		db	"Systemfehler",0

; The following group of messages forms all of the messages used
; in the INT 24 dialog box.
;
; There are 7 messages which can be translated individually. The
; location of drvlet? and devenam? can be moved to any location
; within the string.

public	msgWriteProtect,drvlet1
public	msgCannotReadDrv,drvlet2
public	msgCannotWriteDrv,drvlet3
public	msgShare,drvlet4
public	msgNetError,drvlet5
public	msgCannotReadDev,devenam1
public	msgCannotWriteDev,devenam2
public	msgNoPrinter
public	msgNetErrorDev,devenam3

msgWriteProtect         db      "Schreibgeschtzte Diskette in Laufwerk "
drvlet1                 db      "X:. ",0

msgCannotReadDrv        db      "Fehler beim Lesen von Laufwerk "
drvlet2                 db      "X:. ",0

msgCannotWriteDrv       db      "Fehler beim Schreiben auf Laufwerk "
drvlet3                 db      "X:. ",0

msgShare                db      "Fehler beim gleichzeitigen Zugriff auf Laufwerk "
drvlet4                 db      "X:. ",0

msgNetError             db      "Netzwerkfehler auf Laufwerk "
drvlet5                 db      "X:. ",0

msgCannotReadDev        db      "Fehler beim Lesen von Gert "
devenam1                db      8 dup (?)
                        db      0

msgCannotWriteDev       db      "Fehler beim Schreiben auf Gert "
devenam2                db      8 dup (?)
                        db      0

msgNetErrorDev          db      "Netzwerkfehler bei Gert "
devenam3                db      8 dup (?)
                        db      0

msgNoPrinter            db      "Drucker ist nicht bereit. ",0


ifndef WINDEBUG
public szExitStr1,szExitStr2
szExitStr1  DB  7,13,10,'FatalExit Code = ',0
szExitStr2  DB  ' Stapelberlauf',13,10,0
public  szUndefDyn
szUndefDyn      db      "Aufruf zu nicht definierten Dynalink. ",0
public  szFatalExit
szFatalExit	db	"Anwendung verlangte besondere Terminierung. ",0
else
public szDebugStr
szDebugStr  DB  'KERNEL: Fehlgeschlagenes Laden - ',0                ; 0
            DB  'KERNEL: Fehler beim Laden einer neuen Instanz von - ',0; 1
            DB  'Fehler beim Laden von der Quelldatei - ',0             ; 2
            DB  13,10,0                                                 ; 3
            DB  7,13,10,'FatalExit Code = ',0                           ; 4
            DB  ' Stapelspeicherberlauf',0                             ; 5
            DB  13,10,'Stapelablaufverfolgung:',13,10,0                 ; 6
            DB  7,13,10,'Abbrechen, unterbrechen, beenden oder ignorieren?',0 ; 7
            DB  'Unzulssige BP-Kette',7,13,10,0                        ; 8
            DB  ': ',0                                                  ; 9
            DB  'Zurckgegangen zu FatalExit',7,13,10,0                 ; 10
            DB  0
public szFKE
szFKE	DB '*** Schwerwiegender Kernel-Fehler ***',0
endif

;** Diagnostic mode messages
        public szDiagStart, szCRLF, szLoadStart, szLoadSuccess, szLoadFail
        public szFailCode, szCodeString
szDiagStart     db      '[boot]'      ;lpCRLF must follow
szCRLF          db      0dh, 0ah, 0
szLoadStart     db      'LoadStart = ',0
szLoadSuccess   db      'LoadSuccess = ', 0
szLoadFail      db      'LoadFail = ', 0
szFailCode      db      ' Fehler-Code ist: ' ;szCodeString must follow
szCodeString    db      '00', 0dh, 0ah, 0
ifdef WINDEBUG
	public szInitSpew
szInitSpew      DB      'Starten im Diagnosemodus. Protokolldatei ist:  ', 0
endif

_DATA	ENDS


_INITTEXT SEGMENT WORD PUBLIC 'CODE'
public szInadequate, szNoPMode, szNoGlobalInit
public NoOpenFile, NoLoadHeader, szMissingMod, szPleaseDoIt

ifdef WOW
public szGenBootFail
szNoPMode db "Das Win16-Teilsystem konnte nicht im Protected Mode gestartet werden. DOSX.EXE muss in AUTOEXEC.NT vorhanden und ber PATH aufrufbar sein.",0
szMissingMod    db   "NTVDM KERNEL: Fehlendes 16-Bit-Systemmodul",0
szPleaseDoIt    db   "Installieren Sie erneut folgendes Modul in das Verzeichnis 'System32':",13,10,9,9,0
szInadequate	db   "NTVDM KERNEL: Unzulssiger DPMI-Server",0
szNoGlobalInit	db   "NTVDM KERNEL: Heap konnte nicht initialisiert werden.",0
NoOpenFile	db   "NTVDM KERNEL: Ausfhrbare KERNEL-Datei konnte nicht geffnet werden.",0
NoLoadHeader	db   "NTVDM KERNEL: KERNEL EXE-Vorspann konnte nicht geladen werden.",0
szGenBootFail   db   "NTVDM KERNEL: Initialisierungsfehler des Win 16-Teilsystems.",0
else
szInadequate	db   'KERNEL: Unzulssiger DPMI-Server',13,10,'$'
szNoPMode	db   'KERNEL: Kein Starten im Protected Mode mglich. ',13,10,'$'
szNoGlobalInit	db   "KERNEL: Heap konnte nicht initialisiert werden.",13,10,'$'
NoOpenFile	db   "KERNEL: Ausfhrbare KERNEL-Datei konnte nicht geffnet werden."
			db   13, 10, '$'
NoLoadHeader	db   "KERNEL: KERNEL EXE-Vorspann konnte nicht geladen werden."
			db   13, 10, '$'
endif

_INITTEXT ENDS




_NRESTEXT SEGMENT WORD PUBLIC 'CODE'

; This is the caption string for the protect mode dialog box.
;
; DO NOT CHANGE THE LENGTH OF THIS MESSAGE
;

public szProtectCap,msgRealModeApp1,msgRealModeApp2

szProtectCap		db	"Hinweis zur Kompatibilitt der Anwendung",0

msgRealModeApp1 db	"Die Anwendung, die Sie ausfhren mchten, ",0
msgRealModeApp2 db	"ist fr eine frhere Windows-Version entwickelt worden. ",0Dh,0Dh
	db	"Verwenden Sie eine aktualisierte Version der Anwendung, die mit"
	db	"Windows, Version 3.0 oder hher, kompatibel ist. ",13,13
	db	"Wenn Sie OK whlen und die Anwendung starten, knnen Kompatibilitts-"
	db	"probleme ein unerwartetes Beenden des Windows-Teilsystems verursachen. ",0

_NRESTEXT ENDS

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\messages\hu\strings.asm ===
TITLE   STRINGS - OEM dependent strings used by KERNEL
include gpcont.inc              ; SHERLOCK

_DATA   SEGMENT PARA PUBLIC 'DATA'
_DATA   ENDS

DGROUP  GROUP   _DATA

_INITTEXT SEGMENT WORD PUBLIC 'CODE'
_INITTEXT ENDS

_NRESTEXT SEGMENT WORD PUBLIC 'CODE'
_NRESTEXT ENDS

ASSUME  DS:DGROUP


_DATA   SEGMENT PARA PUBLIC 'DATA'

; This is the caption string for the dialog box.

public  szDiskCap
IF 0
szDiskCap       db  'Lemezcsere',0
ELSE
szDiskCap       db  'Fjlhiba',0
ENDIF


; This is the text for the "Cannot find xxxxxx" dialog box.
; It is printed:
;
;       <szCannotFind1>filename<szCannotFind2>

public  szCannotFind1,szCannotFind2
szCannotFind1   db      "A(z) ", 0
szCannotFind2   db      " nem tallhat.", 0

; This is the text for fatal errors at boot time
;       <szBootLoad>filename
public szBootLoad
szBootLoad      db      "Hiba a kvetkez komponens betltse kzben: ",0

; The following group of strings is used for the "Please insert disk with XXXX
;   in drive X:" dialog box.
;
; These two strings form the dialog message it is:
;
;       <szCannotFind1>filename<szInsert>

IF 0
public  szInsert
szInsert        db  ' nem tallhat. Helyezze be a kvetkez meghajtba: '
ENDIF
;public  drvlet
;drvlet         db  "X.",0

if SHERLOCK
public szGPCont         ; GP fault continuation message
szGPCont        db      "Hiba trtnt az alkalmazsban.",10
        db      "Ha a Tovbb gombra kattint, azonnal mentse el adatait egy j fjlba.",10
        db      "Ha a Bezrst vlasztja, az alkalmazs befejezdik.",0
endif

public  szDosVer
szDosVer        DB      'Nem megfelel MS-DOS verzi.  MS-DOS 3.1 vagy jabb szksges.',13,10,'$'
; Text for exceptions and faults lead to app termination.

public szAbortCaption,szInModule,szAt
public szNukeApp,szSnoozer,szGP,szSF,szII,szPF,szNP,szBlame,szLoad,szWillClose
public szOutofSelectors
szAbortCaption  db      "Alkalmazshiba"
                db      0
szBlame         db      "BOOT "
                db      0
szSnoozer       db      "  "
                db      0
szInModule      db      " -", 10, "modul: <unknown>"
                db      0
szAt            db      " - "
                db      0
szNukeApp       db      ".", 10, 10, "Vlassza a Bezrs gombot. "
                db      0
szWillClose     db      " be lesz zrva."
                db      0
szGP            db      "ltalnos vdelmi hiba (GPF)"
                db      0
szD0            db      "nullval val oszts " ; not yet used
                db      0
szSF            db      "veremhiba"             ; not spec'ed
                db      0
szII            db      "illeglis utasts"    ; "Fault" ???
                db      0
szPF            db      "laphiba "
                db      0
szNP            db      "'objektum nem tallhat' hiba"
                db      0
szAF            db      "alkalmazshiba "    ; not yet used
                db      0
szLoad          db      "szegmensbetltsi hiba"
                db      0
szOutofSelectors db     "a szelektorok elfogytak "
                db      0

; Text for dialog box when terminating an application

public szAbort
szAbort         db      "Az aktulis alkalmazs bezrsa.",0

; Text for dialog box when trying to run a compressed file
                           
public szBozo
szBozo          db      "Tmrtett fjlokat nem lehet betlteni.",0
                                                     
; This is the caption string for system error dialog boxes

public  syserr
syserr          db      "Rendszerhiba",0

; The following group of messages forms all of the messages used
; in the INT 24 dialog box.
;
; There are 7 messages which can be translated individually. The
; location of drvlet? and devenam? can be moved to any location
; within the string.

public  msgWriteProtect,drvlet1
public  msgCannotReadDrv,drvlet2
public  msgCannotWriteDrv,drvlet3
public  msgShare,drvlet4
public  msgNetError,drvlet5
public  msgCannotReadDev,devenam1
public  msgCannotWriteDev,devenam2
public  msgNoPrinter
public  msgNetErrorDev,devenam3

msgWriteProtect         db      "A kvetkez meghajtban lv lemez rsvdett: "
drvlet1                 db      "X.",0

msgCannotReadDrv        db      "A kvetkez meghajtrl nem lehet olvasni: "
drvlet2                 db      "X.",0

msgCannotWriteDrv       db      "A kvetkez meghajtra nem lehet rni: "
drvlet3                 db      "X.",0

msgShare                db      "Megosztsmegsrtsi hiba a kvetkez meghajtn: "
drvlet4                 db      "X.",0

msgNetError             db      "Hlzati hiba a kvetkez meghajtn: "
drvlet5                 db      "X.",0

msgCannotReadDev        db      "A kvetkez eszkzrl nem lehet olvasni: "
devenam1                db      8 dup (?)
                        db      0

msgCannotWriteDev       db      "A kvetkez eszkzre nem lehet rni: "
devenam2                db      8 dup (?)
                        db      0

msgNetErrorDev          db      "Hlzati hiba a kvetkez eszkzn: "
devenam3                db      8 dup (?)
                        db      0

msgNoPrinter            db      "A nyomtat nem zemksz.",0


ifndef WINDEBUG
public szExitStr1,szExitStr2
szExitStr1  DB  7,13,10,'FatalExit code = ',0
szExitStr2  DB  ' stack overflow',13,10,0
public  szUndefDyn
szUndefDyn      db      "Nem definilt Dynalink-hvs.",0
public  szFatalExit
szFatalExit     db      "Az alkalmazs nem a szablyos mdon fejezdtt be",0
else
public szDebugStr
szDebugStr  DB  'KERNEL: nem tlthet be - ',0                                     ; 0
            DB  'KERNEL: az objektum j pldnya nem tlthet be - ',0             ; 1
            DB  'Az objektum nem tlthet be az erforrsfjlbl  - ',0    ; 2
            DB  13,10,0                                                            ; 3
            DB  7,13,10,'FatalExit kd = ',0                                       ; 4
            DB  ' veremtr tlcsorduls',0                                         ; 5
            DB  13,10,'A verem tartalma:',13,10,0                                  ; 6
            DB  7,13,10,'Megszakts, Trspont, Kilps vagy Folytats? ',0         ; 7
            DB  'rvnytelen BP lnc.',7,13,10,0                                   ; 8
            DB  ': ',0                                          ; 9
            DB  'jra bert FatalExit',7,13,10,0                 ; 10
            DB  0
public szFKE
szFKE   DB '*** Slyos kernelhiba ***',0
endif

;** Diagnostic mode messages
        public szDiagStart, szCRLF, szLoadStart, szLoadSuccess, szLoadFail
        public szFailCode, szCodeString
szDiagStart     db      '[boot]'      ;lpCRLF must follow
szCRLF          db      0dh, 0ah, 0
szLoadStart     db      'LoadStart = ',0
szLoadSuccess   db      'LoadSuccess = ', 0
szLoadFail      db      'LoadFail = ', 0
szFailCode      db      ' Hibakd: ' ;szCodeString must follow
szCodeString    db      '00', 0dh, 0ah, 0
ifdef WINDEBUG
        public szInitSpew
szInitSpew      DB      'Indts diagnosztikai zemmdban. Naplfjl:  ', 0
endif

_DATA   ENDS


_INITTEXT SEGMENT WORD PUBLIC 'CODE'
public szInadequate, szNoPMode, szNoGlobalInit
public NoOpenFile, NoLoadHeader, szMissingMod, szPleaseDoIt

ifdef WOW
public szGenBootFail
szNoPMode db "A Win16 alrendszer nem tudott vdett mdba kapcsolni. A DOSX.EXE programnak szerepelnie kell az AUTOEXEC.NT fjlban, vagy PATH vltozval megadott elrsi ton.",0
szMissingMod    db   "NTVDM KERNEL: Hinyz 16 bites rendszermodul.",0
szPleaseDoIt    db   "Teleptse jra a kvetkez modult a system32 knyvtrba:",13,10,9,9,0
szInadequate    db   "KERNEL: Nem megfelel DPMI-kiszolgl.",0
szNoGlobalInit  db   "KERNEL: A heap nem inicializlhat.",0
NoOpenFile      db   "KERNEL: A kernel futtathat fjljt nem sikerlt megnyitni.",0
NoLoadHeader    db   "KERNEL: A KERNEL EXE-fejlce nem tlthet be.",0
szGenBootFail   db   "KERNEL: Win16 alrendszer - inicializcis hiba.",0
else
szInadequate    db   'KERNEL: Nem megfelel DPMI-kiszolgl.',13,10,'$'
szNoPMode       db   'KERNEL: Nem sikerlt vdett mdba kapcsolni.',13,10,'$'
szNoGlobalInit  db   "KERNEL: Nem sikerlt inicializlni a heapet.",13,10,'$'
NoOpenFile      db   "KERNEL: A kernel futtathat fjljt nem sikerlt megnyitni."
                db   13, 10, '$'
NoLoadHeader    db   "KERNEL: a KERNEL EXE-fejlce nem tlthet be."
                db   13, 10, '$'
endif

_INITTEXT ENDS




_NRESTEXT SEGMENT WORD PUBLIC 'CODE'

; This is the caption string for the protect mode dialog box.
;
; DO NOT CHANGE THE LENGTH OF THIS MESSAGE
;

public szProtectCap,msgRealModeApp1,msgRealModeApp2

szProtectCap            db      "Alkalmazs-kompatibilitsi zenet",0

msgRealModeApp1 db      "A futtatni kvnt alkalmazst a Windows korbbi ",0
msgRealModeApp2 db      ", verzijhoz terveztk.",0Dh,0Dh
        db      "Szerezze be az alkalmazs jabb, legalbb Windows 3.0-val kompatibilis "
        db      "vltozatt.",13,13
        db      "Ha az OK gombra kattint s elindtja az alkalmazst, akkor nem vrt "
        db      "problmk lphetnek fel, illetve a Windows bezrhatja az alkalmazst.",0

_NRESTEXT ENDS

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\messages\it\strings.asm ===
TITLE   STRINGS - OEM dependent strings used by KERNEL
include gpcont.inc              ; SHERLOCK

_DATA   SEGMENT PARA PUBLIC 'DATA'
_DATA   ENDS

DGROUP  GROUP   _DATA

_INITTEXT SEGMENT WORD PUBLIC 'CODE'
_INITTEXT ENDS

_NRESTEXT SEGMENT WORD PUBLIC 'CODE'
_NRESTEXT ENDS

ASSUME  DS:DGROUP


_DATA   SEGMENT PARA PUBLIC 'DATA'

; This is the caption string for the dialog box.

public  szDiskCap
IF 0
szDiskCap       db  'Cambiare disco',0
ELSE
szDiskCap       db  'Errore nel file',0
ENDIF


; This is the text for the "Cannot find xxxxxx" dialog box.
; It is printed:
;
;       <szCannotFind1>filename<szCannotFind2>

public  szCannotFind1,szCannotFind2
szCannotFind1   db      "Impossibile trovare ", 0
szCannotFind2   db      0

; This is the text for fatal errors at boot time
;       <szBootLoad>filename
public szBootLoad
szBootLoad      db      "Errore nel caricamento di ",0

; The following group of strings is used for the "Please insert disk with XXXX
;   in drive X:" dialog box.
;
; These two strings form the dialog message it is:
;
;       <szCannotFind1>filename<szInsert>

IF 0
public  szInsert
szInsert        db  ', inserire nell''unit '
ENDIF
;public  drvlet
;drvlet         db  "X.",0

if SHERLOCK
public szGPCont         ; GP fault continuation message
szGPCont        db      "Errore dell'applicazione.",10
	db      "Scegliendo Ignora, si deve salvare in un nuovo file.",10
	db      "Scegliendo Chiudi, l'applicazione verr terminata.",0
endif

public  szDosVer
szDosVer        DB      'Versione MS-DOS errata.  E'' richiesto MS-DOS 3.1 o una versione successiva.',13,10,'$'
; Text for exceptions and faults lead to app termination.

public szAbortCaption,szInModule,szAt
public szNukeApp,szSnoozer,szGP,szSF,szII,szPF,szNP,szBlame,szLoad,szWillClose
public szOutofSelectors
szAbortCaption  db      "Errore dell'applicazione"
		db      0
szBlame         db      "AVVIO "
		db      0
szSnoozer       db      " ha causato "
		db      0
szInModule      db      " in", 10, "modulo <sconosciuto>"
		db      0
szAt            db      " su "
		db      0
szNukeApp       db      ".", 10, 10, "Scegliere chiudi. "
		db      0
szWillClose     db      " verr terminata."
		db      0
szGP            db      "un errore di protezione generale"
		db      0
szD0            db      "una divisione per zero"        ; not yet used
		db      0
szSF            db      "uno Stack Fault"               ; not spec'ed
		db      0
szII            db      "un'istruzione non consentita"  ; "Fault" ???
		db      0
szPF            db      "un Page Fault"
		db      0
szNP            db      "un errore di non presenza"
		db      0
szAF            db      "un errore dell'applicazione"   ; not yet used
		db      0
szLoad          db      "fallimento di caricamento del segmento"
		db      0
szOutofSelectors db     "selettori esauriti"
		db      0

; Text for dialog box when terminating an application

public szAbort
szAbort         db      "Chiusura dell'applicazione corrente.",0

; Text for dialog box when trying to run a compressed file
			   
public szBozo
szBozo          db      "Impossibile caricare i file compressi",0
						     
; This is the caption string for system error dialog boxes

public  syserr
syserr          db      "Errore di sistema",0

; The following group of messages forms all of the messages used
; in the INT 24 dialog box.
;
; There are 7 messages which can be translated individually. The
; location of drvlet? and devenam? can be moved to any location
; within the string.

public  msgWriteProtect,drvlet1
public  msgCannotReadDrv,drvlet2
public  msgCannotWriteDrv,drvlet3
public  msgShare,drvlet4
public  msgNetError,drvlet5
public  msgCannotReadDev,devenam1
public  msgCannotWriteDev,devenam2
public  msgNoPrinter
public  msgNetErrorDev,devenam3

msgWriteProtect         db      "Disco protetto da scrittura nell'unit "
drvlet1                 db      "X.",0

msgCannotReadDrv        db      "Impossibile leggere l'unit "
drvlet2                 db      "X.",0

msgCannotWriteDrv       db      "Impossibile scrivere sull'unit "
drvlet3                 db      "X.",0

msgShare                db      "Violazione di condivisione sull'unit "
drvlet4                 db      "X.",0

msgNetError             db      "Errore di rete sull'unit "
drvlet5                 db      "X.",0

msgCannotReadDev        db      "Impossibile leggere dalla periferica "
devenam1                db      8 dup (?)
			db      0

msgCannotWriteDev       db      "Impossibile scrivere sulla periferica "
devenam2                db      8 dup (?)
			db      0

msgNetErrorDev          db      "Errore di rete sulla periferica "
devenam3                db      8 dup (?)
			db      0

msgNoPrinter            db      "Stampante non pronta",0


ifndef WINDEBUG
public szExitStr1,szExitStr2
szExitStr1  DB  7,13,10,'Codice di FatalExit = ',0
szExitStr2  DB  ' overflow dello stack',13,10,0
public  szUndefDyn
szUndefDyn      db      "Chiamata ad un collegamento dinamico indefinito",0
public  szFatalExit
szFatalExit     db      "L'applicazione ha richiesto una terminazione anormale",0
else
public szDebugStr
szDebugStr  DB  'KERNEL: Caricamento non riuscito - ',0                     ; 0
	    DB  'KERNEL: Caricamento non riuscito di una nuova istanza di - ',0      ; 1
	    DB  'Errore nel caricamento del file risorsa - ',0      ; 2
	    DB  13,10,0                                         ; 3
	    DB  7,13,10,'Codice di FatalExit = ',0                       ; 4
	    DB  ' overflow dello stack',0                                 ; 5
	    DB  13,10,'Traccia dello stack:',13,10,0                     ; 6
	    DB  7,13,10,'Termina, Interrompi, Esci o Ignora? ',0            ; 7
	    DB  'Catena BP non valida',7,13,10,0                         ; 8
	    DB  ': ',0                                          ; 9
	    DB  'FatalExit reimmesso',7,13,10,0         ; 10
	    DB  0
public szFKE
szFKE   DB '*** Fatal Kernel Error ***',0
endif

;** Diagnostic mode messages
	public szDiagStart, szCRLF, szLoadStart, szLoadSuccess, szLoadFail
	public szFailCode, szCodeString
szDiagStart     db      '[avvio]'           ;lpCRLF must follow
szCRLF          db      0dh, 0ah, 0
szLoadStart     db      'LoadStart = ',0
szLoadSuccess   db      'LoadSuccess = ', 0
szLoadFail      db      'LoadFail = ', 0
szFailCode      db      ' Codice Failure: ' ;szCodeString must follow
szCodeString    db      '00', 0dh, 0ah, 0
ifdef WINDEBUG
	public szInitSpew
szInitSpew      DB      'Avvio modalit diagnostica. File registro:  ', 0
endif

_DATA   ENDS


_INITTEXT SEGMENT WORD PUBLIC 'CODE'
public szInadequate, szNoPMode, szNoGlobalInit
public NoOpenFile, NoLoadHeader, szMissingMod, szPleaseDoIt

ifdef WOW
public szGenBootFail
szNoPMode db "Il sottosistema Win16 non ha potuto avviare la modalit protetta, DOSX.EXE deve essere in AUTOEXEC.NT e presente in PATH.",0
szMissingMod    db   "NTVDM KERNEL: modulo di sistema a 16 bit mancante",0
szPleaseDoIt    db   "Reinstallare il modulo seguente nella directory system32:",13,10,9,9,0
szInadequate    db   "NTVDM KERNEL: Server DPMI non adatto",0
szNoGlobalInit  db   "NTVDM KERNEL: Impossibile inizializzare la memoria",0
NoOpenFile          db   "NTVDM KERNEL: Impossibile aprire l'eseguibile KERNEL",0
NoLoadHeader    db   "NTVDM KERNEL: Impossibile caricare l'intestazione KERNEL EXE",0
szGenBootFail   db   "NTVDM KERNEL: Inizializzazione del sottosistema Win16 non riuscita",0
else
szInadequate    db   'KERNEL: Server DPMI non adatto',13,10,'$'
szNoPMode       db   'KERNEL: Impossibile operare in modalit protetta',13,10,'$'
szNoGlobalInit  db   "KERNEL: Impossibile inizializzare la memoria",13,10,'$'
NoOpenFile      db   "KERNEL: Impossibile aprire l'eseguibile KERNEL"
		db   13, 10, '$'
NoLoadHeader    db   "KERNEL: Impossibile caricare l'intestazione KERNEL EXE"
		db   13, 10, '$'
endif

_INITTEXT ENDS




_NRESTEXT SEGMENT WORD PUBLIC 'CODE'

; This is the caption string for the protect mode dialog box.
;
; DO NOT CHANGE THE LENGTH OF THIS MESSAGE
;

public szProtectCap,msgRealModeApp1,msgRealModeApp2

szProtectCap            db      "Avviso di compatibilit dell'applicazione",0

msgRealModeApp1 db      "L'applicazione che si sta per eseguire, ",0
msgRealModeApp2 db      ",  scritta per una versione precedente di Windows.",0Dh,0Dh
	db      "Ottenere una versione aggiornata dell'applicazione che sia compatibile "
	db      "con Windows versione 3.0 o successive.",13,13
	db      "Se si sceglie OK e si avvia l'applicazione, i problemi di compatibilit"
	db      "potrebbero causare la chiusura inattesa dell'applicazione o di Windows.",0

_NRESTEXT ENDS

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\messages\nl\strings.asm ===
TITLE   STRINGS - OEM dependent strings used by KERNEL
include gpcont.inc              ; SHERLOCK

_DATA   SEGMENT PARA PUBLIC 'DATA'
_DATA   ENDS

DGROUP  GROUP   _DATA

_INITTEXT SEGMENT WORD PUBLIC 'CODE'
_INITTEXT ENDS

_NRESTEXT SEGMENT WORD PUBLIC 'CODE'
_NRESTEXT ENDS

ASSUME  DS:DGROUP


_DATA   SEGMENT PARA PUBLIC 'DATA'

; This is the caption string for the dialog box.

public  szDiskCap
IF 0
szDiskCap       db  'Kies andere schijf',0
ELSE
szDiskCap       db  'Bestandsfout',0
ENDIF


; This is the text for the "Cannot find xxxxxx" dialog box.
; It is printed:
;
;       <szCannotFind1>filename<szCannotFind2>

public  szCannotFind1,szCannotFind2
szCannotFind1   db      "Kan ",0
szCannotFind2   db      " niet vinden",0

; This is the text for fatal errors at boot time
;       <szBootLoad>filename
public szBootLoad
szBootLoad      db      "Fout tijdens laden van ",0

; The following group of strings is used for the "Please insert disk with XXXX
;   in drive X:" dialog box.
;
; These two strings form the dialog message it is:
;
;       <szCannotFind1>filename<szInsert>

IF 0
public  szInsert
szInsert        db  ', plaats deze in station '
ENDIF
;public  drvlet
;drvlet         db  "X.",0

if SHERLOCK
public szGPCont         ; GP fault continuation message
szGPCont        db      "Er is een fout opgetreden in uw toepassing.",10
	db      "Als u Negeren kiest, kunt u uw werk het beste opslaan in een nieuw bestand.",10
	db      "Als u Sluiten kiest, zal uw toepassing beindigd worden.",0
endif

public  szDosVer
szDosVer        DB      'Onjuiste MS-DOS-versie.  MS-DOS 3.1 of hoger is benodigd.',13,10,'$'
; Text for exceptions and faults lead to app termination.

public szAbortCaption,szInModule,szAt
public szNukeApp,szSnoozer,szGP,szSF,szII,szPF,szNP,szBlame,szLoad,szWillClose
public szOutofSelectors
szAbortCaption  db      "Toepassingsfout"
		db      0
szBlame         db      "OPSTARTEN "
		db      0
szSnoozer       db      " veroorzaakte "
		db      0
szInModule      db      " in", 10, "module <onbekend>"
		db      0
szAt            db      " op "
		db      0
szNukeApp       db      ".", 10, 10, "Kies sluiten. "
		db      0
szWillClose     db      " zal sluiten."
		db      0
szGP            db      "een algemene beschermingsfout"
		db      0
szD0            db      "een deling door nul"   ; not yet used
		db      0
szSF            db      "een stapelfout"                ; not spec'ed
		db      0
szII            db      "een ongeldige opdracht"        ; "Fault" ???
		db      0
szPF            db      "een wisselfout"
		db      0
szNP            db      "een is-niet-aanwezig-fout"
		db      0
szAF            db      "een toepassingsfout"   ; not yet used
		db      0
szLoad          db      "Segment laden mislukt"
		db      0
szOutofSelectors db     "Geen selectors meer"
		db      0

; Text for dialog box when terminating an application

public szAbort
szAbort         db      "Huidige toepassing wordt gesloten.",0

; Text for dialog box when trying to run a compressed file
			   
public szBozo
szBozo          db      "Kan geen gecomprimeerde bestanden laden",0
						     
; This is the caption string for system error dialog boxes

public  syserr
syserr          db      "Systeemfout",0

; The following group of messages forms all of the messages used
; in the INT 24 dialog box.
;
; There are 7 messages which can be translated individually. The
; location of drvlet? and devenam? can be moved to any location
; within the string.

public  msgWriteProtect,drvlet1
public  msgCannotReadDrv,drvlet2
public  msgCannotWriteDrv,drvlet3
public  msgShare,drvlet4
public  msgNetError,drvlet5
public  msgCannotReadDev,devenam1
public  msgCannotWriteDev,devenam2
public  msgNoPrinter
public  msgNetErrorDev,devenam3

msgWriteProtect         db      "Schrijfbeveiligde diskette in station "
drvlet1                 db      "X.",0

msgCannotReadDrv        db      "Kan niet lezen van station "
drvlet2                 db      "X.",0

msgCannotWriteDrv       db      "Kan niet schrijven naar station "
drvlet3                 db      "X.",0

msgShare                db      "Schending van gemeensch. gebruik op station "
drvlet4                 db      "X.",0

msgNetError             db      "Netwerkfout op station "
drvlet5                 db      "X.",0

msgCannotReadDev        db      "Kan niet lezen van apparaat "
devenam1                db      8 dup (?)
			db      0

msgCannotWriteDev       db      "Kan niet schrijven van apparaat "
devenam2                db      8 dup (?)
			db      0

msgNetErrorDev          db      "Netwerkfout op apparaat "
devenam3                db      8 dup (?)
			db      0

msgNoPrinter            db      "Printer niet gereed",0


ifndef WINDEBUG
public szExitStr1,szExitStr2
szExitStr1  DB  7,13,10,'FatalExit code = ',0
szExitStr2  DB  ' stack overflow',13,10,0
public  szUndefDyn
szUndefDyn      db      "Aanroep van een niet-gedefinieerde Dynalink",0
public  szFatalExit
szFatalExit     db      "De toepassing heeft gevraagd om uitzonderlijke beindiging",0
else
public szDebugStr
szDebugStr  DB  'KERNEL: Failed loading - ',0                   ; 0
	    DB  'KERNEL: Failed loading new instance of - ',0   ; 1
	    DB  'Error loading from resource file - ',0         ; 2
	    DB  13,10,0                                         ; 3
	    DB  7,13,10,'FatalExit code = ',0                   ; 4
	    DB  ' stack overflow',0                             ; 5
	    DB  13,10,'Stack trace:',13,10,0                    ; 6
	    DB  7,13,10,'Abort, Break, Exit or Ignore? ',0      ; 7
	    DB  'Invalid BP chain',7,13,10,0                    ; 8
	    DB  ': ',0                                          ; 9
	    DB  'Reentered FatalExit',7,13,10,0                 ; 10
	    DB  0
public szFKE
szFKE   DB '*** Fatal Kernel Error ***',0
endif

;** Diagnostic mode messages
	public szDiagStart, szCRLF, szLoadStart, szLoadSuccess, szLoadFail
	public szFailCode, szCodeString
szDiagStart     db      '[boot]'      ;lpCRLF must follow
szCRLF          db      0dh, 0ah, 0
szLoadStart     db      'LoadStart = ',0
szLoadSuccess   db      'LoadSuccess = ', 0
szLoadFail      db      'LoadFail = ', 0
szFailCode      db      ' Failure code is ' ;szCodeString must follow
szCodeString    db      '00', 0dh, 0ah, 0
ifdef WINDEBUG
	public szInitSpew
szInitSpew      DB      'Diagnostic mode startup.  Log file is:  ', 0
endif

_DATA   ENDS


_INITTEXT SEGMENT WORD PUBLIC 'CODE'
public szInadequate, szNoPMode, szNoGlobalInit
public NoOpenFile, NoLoadHeader, szMissingMod, szPleaseDoIt

ifdef WOW
public szGenBootFail
szNoPMode db "Het Win16-subsysteem kan de 'protected' modus niet gebruiken, DOSX.EXE moet aanwezig zijn in uw AUTOEXEC.NT en in uw PAD.",0
szMissingMod    db   "NTVDM KERNEL: 16-bit systeemmodule ontbreekt",0
szPleaseDoIt    db   "Installeer de volgende module opnieuw in de map system32:",13,10,9,9,0
szInadequate    db   "NTVDM KERNEL: Inadequate DPMI-server",0
szNoGlobalInit  db   "NTVDM KERNEL: Kan opslag niet initialiseren",0
NoOpenFile          db   "NTVDM KERNEL: Kan KERNEL.EXE niet openen",0
NoLoadHeader    db   "NTVDM KERNEL: Kan het beginrecord van KERNEL.EXE niet laden",0
szGenBootFail   db   "NTVDM KERNEL: Fout bij initialisatie van het Win16-subsysteem",0
else
szInadequate    db   'KERNEL: Inadequate DPMI-server',13,10,'$'
szNoPMode       db   'KERNEL: Kan protected modus niet starten',13,10,'$'
szNoGlobalInit  db   "KERNEL: Kan opslag niet initialiseren",13,10,'$'
NoOpenFile      db   "KERNEL: Kan KERNEL.EXE niet openen"
		db   13, 10, '$'
NoLoadHeader    db   "KERNEL: Kan het beginrecord van KERNEL.EXE niet laden"
		db   13, 10, '$'
endif

_INITTEXT ENDS




_NRESTEXT SEGMENT WORD PUBLIC 'CODE'

; This is the caption string for the protect mode dialog box.
;
; DO NOT CHANGE THE LENGTH OF THIS MESSAGE
;

public szProtectCap,msgRealModeApp1,msgRealModeApp2

szProtectCap            db      "Waarschuwing: toepassing is niet compatibel",0

msgRealModeApp1 db      "De toepassing die u wilt gaan gebruiken, ",0
msgRealModeApp2 db      ", is bedoeld voor een oudere versie van Windows.",0Dh,0Dh
	db      "Gebruik een nieuwere versie van de toepassing die compatibel is "
	db      "met Windows-versie 3.0 en hoger.",13,13
	db      "Als u de knop OK kiest en de toepassing start, kunnen compatibiliteits-"
	db      "problemen de toepassing of Windows onverwacht beindigen.",0

_NRESTEXT ENDS

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\messages\jpn\strings.asm ===
TITLE   STRINGS - OEM dependent strings used by KERNEL
include gpcont.inc              ; SHERLOCK

_DATA   SEGMENT PARA PUBLIC 'DATA'
_DATA   ENDS

DGROUP  GROUP   _DATA

_INITTEXT SEGMENT WORD PUBLIC 'CODE'
_INITTEXT ENDS

_NRESTEXT SEGMENT WORD PUBLIC 'CODE'
_NRESTEXT ENDS

ASSUME  DS:DGROUP


_DATA   SEGMENT PARA PUBLIC 'DATA'

; This is the caption string for the dialog box.

public  szDiskCap
IF 0
szDiskCap       db  'fBXNX',0
ELSE
szDiskCap       db  't@C G[',0
ENDIF


; This is the text for the "Cannot find xxxxxx" dialog box.
; It is printed:
;
;       <szCannotFind1>filename<szCannotFind2>

public  szCannotFind1,szCannotFind2
szCannotFind1   db      "t@C: ", 0
szCannotFind2   db      "  "0

; This is the text for fatal errors at boot time
;       <szBootLoad>filename
public szBootLoad
szBootLoad      db      "[h G[: ",0

; The following group of strings is used for the "Please insert disk with XXXX
;   in drive X:" dialog box.
;
; These two strings form the dialog message it is:
;
;       <szCannotFind1>filename<szInsert>

IF 0
public  szInsert
szInsert        db  'Bt@CfBXNhCu}: '
ENDIF
;public  drvlet
;drvlet         db  "X",0

if SHERLOCK
public szGPCont         ; GP fault continuation message
szGPCont        db      "AvP[VG[B",10
        db      "[] IAeVt@CB",10
        db      "[] IAAvP[VIB",0
endif

public  szDosVer
szDosVer        DB      'o[WMS-DOSWindowssBo[W3.1~MS-DOSKvB',13,10,'$'
; Text for exceptions and faults lead to app termination.

public szAbortCaption,szInModule,szAt
public szNukeApp,szSnoozer,szGP,szSF,szII,szPF,szNP,szBlame,szLoad,szWillClose
public szOutofSelectors
ifndef PM386
ifdef JAPAN
; RISC x86 emulation for JAPAN 
public szRISC386
endif ; for JAPAN
endif ; not PM386
szAbortCaption  db      "AvP[V G["
                db      0
szBlame         db      "u[g"
                db      0
szSnoozer       db      "  "
                db      0
szInModule      db      " B", 10, "AW[ <s>"
                db      0
szAt            db      "  "
                db      0
szNukeApp       db      " nB", 10, 10, "[] IB"
                db      0
szWillClose     db      " IB"
                db      0
szGP            db      ""
                db      0
szD0            db      "0Z"        ; not yet used
                db      0
szSF            db      "X^bN"                ; not spec'ed
                db      0
szII            db      "s" ; "Fault" ???
                db      0
ifndef PM386
ifdef JAPAN
; RISC x86 emulation for JAPAN 
szRISC386       db      "RISC VXeT|[g x86 " ; "Fault" ???
                db      0
endif ; for JAPAN
endif ; not PM386
szPF            db      "y[W"
                db      0
szNP            db      "s"
                db      0
szAF            db      "AvP[V" ; not yet used
                db      0
szLoad          db      "ZOg[hs"
                db      0
szOutofSelectors db     "ZN^s"
                db      0

; Text for dialog box when terminating an application

public szAbort
szAbort         db      "sAvP[VIB",0

; Text for dialog box when trying to run a compressed file

public szBozo
szBozo          db      "kt@C[h",0

; This is the caption string for system error dialog boxes

public  syserr
syserr          db      "VXe G[",0

; The following group of messages forms all of the messages used
; in the INT 24 dialog box.
;
; There are 7 messages which can be translated individually. The
; location of drvlet? and devenam? can be moved to any location
; within the string.

public  msgWriteProtect,drvlet1
public  msgCannotReadDrv,drvlet2
public  msgCannotWriteDrv,drvlet3
public  msgShare,drvlet4
public  msgNetError,drvlet5
public  msgCannotReadDev,devenam1
public  msgCannotWriteDev,devenam2
public  msgNoPrinter
public  msgNetErrorDev,devenam3
IFDEF   JAPAN                           ; For FontAssoc 92/09/29 yasuho
public  SIZE_INT24_MESSAGES
;
;       ATTENTION: msgWriteProtect is must be first label of int24 messages.
;
ENDIF   ; was DB_FA DNT

msgWriteProtect         db      "~fBXN: hCu "
drvlet1                 db      "X",0

msgCannotReadDrv        db      "o: hCu "
drvlet2                 db      "X",0

msgCannotWriteDrv       db      ": hCu "
drvlet3                 db      "X",0

msgShare                db      "L: hCu "
drvlet4                 db      "X",0

msgNetError             db      "lbg[N G[: hCu "
drvlet5                 db      "X",0

msgCannotReadDev        db      "o: foCX "
devenam1                db      8 dup (0)
                        db      0

msgCannotWriteDev       db      ": foCX "
devenam2                db      8 dup (0)
                        db      0

msgNetErrorDev          db      "lbg[N G[: foCX "
devenam3                db      8 dup (0)
                        db      0

msgNoPrinter            db      "v^",0

IFDEF   JAPAN                           ; For FontAssoc 92/09/29 yasuho
SIZE_INT24_MESSAGES     equ     $ - offset msgWriteProtect
ENDIF   ; was DB_FA - now JAPAN DNT

ifndef WINDEBUG
public szExitStr1,szExitStr2
szExitStr1  DB  7,13,10,'FatalExitR[h = ',0
szExitStr2  DB  'X^bN I[o[t[',13,10,0
public  szUndefDyn
szUndefDyn      db      "`_Ci~bN No",0
public  szFatalExit
szFatalExit     db      "AvP[VIv",0
else
public szDebugStr
szDebugStr  DB  'J[l: [hs - ',0                   ; 0
            DB  'J[l: VCX^X[hs - ',0   ; 1
            DB  '\[X t@C[hs - ',0      ; 2
            DB  13,10,0                                         ; 3
            DB  7,13,10,'FatalExitR[h = ',0                  ; 4
            DB  'X^bN I[o[t[',0                     ; 5
            DB  13,10,'X^bN g[X:',13,10,0              ; 6
            DB  7,13,10,'Abort, Break, Exit or Ignore? ',0      ; 7
            DB  'BP`F[',7,13,10,0                    ; 8
            DB  ': ',0                                          ; 9
            DB  'FatalExit',7,13,10,0               ; 10
            DB  0
public szFKE
szFKE   DB '*** Fatal Kernel Error ***',0
endif

;** Diagnostic mode messages
        public szDiagStart, szCRLF, szLoadStart, szLoadSuccess, szLoadFail
        public szFailCode, szCodeString
szDiagStart     db      '[boot]'      ;lpCRLF must follow
szCRLF          db      0dh, 0ah, 0
szLoadStart     db      'LoadStart = ',0
szLoadSuccess   db      'LoadSuccess = ', 0
szLoadFail      db      'LoadFail = ', 0
szFailCode      db      ' G[ R[h ' ;szCodeString must follow
szCodeString    db      '00', 0dh, 0ah, 0
ifdef WINDEBUG
        public szInitSpew
szInitSpew      DB      'ff[hNBO t@C:  ', 0
endif

_DATA   ENDS


_INITTEXT SEGMENT WORD PUBLIC 'CODE'
public szInadequate, szNoPMode, szNoGlobalInit
public NoOpenFile, NoLoadHeader, szMissingMod, szPleaseDoIt
	
szMissingMod    db   "NTVDM KERNEL: Missing 16-bit system module",0
szPleaseDoIt    db   "Please re-install the following module to your system32 directory:",13,10,9,9,0
szInadequate    db   'J[l: DPMIT[o[sK',13,10,'$'
szNoPMode       db   'J[l: veNg [h',13,10,'$'
szNoGlobalInit  db   "J[l: q[v",13,10,'$'

NoOpenFile      db   "J[l: KERNELs\t@CI[v"
                db   13, 10, '$'
NoLoadHeader    db   "J[l: KERNELEXEwb_[[h"
                db   13, 10, '$'

_INITTEXT ENDS




_NRESTEXT SEGMENT WORD PUBLIC 'CODE'

; This is the caption string for the protect mode dialog box.
;
; DO NOT CHANGE THE LENGTH OF THIS MESSAGE
;

public szProtectCap,msgRealModeApp1,msgRealModeApp2

szProtectCap            db      "AvP[Vx",0

msgRealModeApp1 db      "sAvP[V ",0
msgRealModeApp2 db      " AOo[WWindowspJB",0Dh,0Dh
        db      "o[W3.0~WindowsAVAvP[V"
        db      "B",13,13
        db      " [OK] IAvP[VNA"
        db      "AvP[VWindowsRN[Y\B",0

_NRESTEXT ENDS

end

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\messages\ru\strings.asm ===
TITLE   STRINGS - OEM dependent strings used by KERNEL
include gpcont.inc              ; SHERLOCK

_DATA   SEGMENT PARA PUBLIC 'DATA'
_DATA   ENDS

DGROUP  GROUP   _DATA

_INITTEXT SEGMENT WORD PUBLIC 'CODE'
_INITTEXT ENDS

_NRESTEXT SEGMENT WORD PUBLIC 'CODE'
_NRESTEXT ENDS

ASSUME  DS:DGROUP


_DATA   SEGMENT PARA PUBLIC 'DATA'

; This is the caption string for the dialog box.

public  szDiskCap
IF 0
szDiskCap       db  ' ',0
ELSE
szDiskCap       db  '    ',0
ENDIF


; This is the text for the "Cannot find xxxxxx" dialog box.
; It is printed:
;
;       <szCannotFind1>filename<szCannotFind2>

public  szCannotFind1,szCannotFind2
szCannotFind1   db      "   ", 0
szCannotFind2   db      0

; This is the text for fatal errors at boot time
;       <szBootLoad>filename
public szBootLoad
szBootLoad      db      "   ",0

; The following group of strings is used for the "Please insert disk with XXXX
;   in drive X:" dialog box.
;
; These two strings form the dialog message it is:
;
;       <szCannotFind1>filename<szInsert>

IF 0
public  szInsert
szInsert        db  ',    '
ENDIF
;public  drvlet
;drvlet         db  "X.",0

if SHERLOCK
public szGPCont         ; GP fault continuation message
szGPCont        db      "  .",10
	db      "  ,         .",10
	db      "  ,   .     .",0
endif

public  szDosVer
szDosVer        DB      '  MS-DOS.  MS-DOS 3.1    .',13,10,'$'
; Text for exceptions and faults lead to app termination.

public szAbortCaption,szInModule,szAt
public szNukeApp,szSnoozer,szGP,szSF,szII,szPF,szNP,szBlame,szLoad,szWillClose
public szOutofSelectors
szAbortCaption  db      "  "
		db      0
szBlame         db      "BOOT "
		db      0
szSnoozer       db      "  "
		db      0
szInModule      db      " ", 10, " <unknown>"
		db      0
szAt            db      "  "
		db      0
szNukeApp       db      ".", 10, 10, "  . "
		db      0
szWillClose     db      "  ."
		db      0
szGP            db      "  "
		db      0
szD0            db      "  "       ; not yet used
		db      0
szSF            db      "   "                ; not spec'ed
		db      0
szII            db      " "  ; "Fault" ???
		db      0
szPF            db      "  "
		db      0
szNP            db      " "
		db      0
szAF            db      " "     ; not yet used
		db      0
szLoad          db      "  "
		db      0
szOutofSelectors db     " "
		db      0

; Text for dialog box when terminating an application

public szAbort
szAbort         db      "  .",0

; Text for dialog box when trying to run a compressed file
			   
public szBozo
szBozo          db      "   ",0
						     
; This is the caption string for system error dialog boxes

public  syserr
syserr  db      " ",0

; The following group of messages forms all of the messages used
; in the INT 24 dialog box.
;
; There are 7 messages which can be translated individually. The
; location of drvlet? and devenam? can be moved to any location
; within the string.

public  msgWriteProtect,drvlet1
public  msgCannotReadDrv,drvlet2
public  msgCannotWriteDrv,drvlet3
public  msgShare,drvlet4
public  msgNetError,drvlet5
public  msgCannotReadDev,devenam1
public  msgCannotWriteDev,devenam2
public  msgNoPrinter
public  msgNetErrorDev,devenam3

msgWriteProtect         db      "     "
drvlet1                 db      "X.",0

msgCannotReadDrv        db      "      "
drvlet2                 db      "X.",0

msgCannotWriteDrv       db      "      "
drvlet3                 db      "X.",0

msgShare                db      "     "
drvlet4                 db      "X.",0

msgNetError             db      "    "
drvlet5                 db      "X.",0

msgCannotReadDev        db      "      "
devenam1                db      8 dup (?)
			db      0

msgCannotWriteDev       db      "      "
devenam2                db      8 dup (?)
				db      0

msgNetErrorDev          db      "    "
devenam3                db      8 dup (?)
			db      0

msgNoPrinter            db      "  ",0


ifndef WINDEBUG
public szExitStr1,szExitStr2
szExitStr1  DB  7,13,10,'   = ',0
szExitStr2  DB  '  ',13,10,0
public  szUndefDyn
szUndefDyn              db      "    ",0
public  szFatalExit
szFatalExit             db      "   ",0
else
public szDebugStr
szDebugStr  DB  ':    - ',0                   ; 0
	    DB  ':      - ',0   ; 1
	    DB  '     - ',0         ; 2
	    DB  13,10,0                                         ; 3
	    DB  7,13,10,'   = ',0        ; 4
	    DB  '  ',0                         ; 5
	    DB  13,10,' :',13,10,0                    ; 6
	    DB  7,13,10,'Abort, Break, Exit  Ignore? ',0      ; 7
	    DB  '  BP',7,13,10,0                    ; 8
	    DB  ': ',0                                          ; 9
	    DB  '   ',7,13,10,0               ; 10
	    DB  0
public szFKE
szFKE   DB '***    ***',0
endif

;** Diagnostic mode messages
	public szDiagStart, szCRLF, szLoadStart, szLoadSuccess, szLoadFail
	public szFailCode, szCodeString
szDiagStart     db      '[boot]'      ;lpCRLF must follow
szCRLF          db      0dh, 0ah, 0
szLoadStart     db      'LoadStart = ',0
szLoadSuccess   db      'LoadSuccess = ', 0
szLoadFail      db      'LoadFail = ', 0
szFailCode      db      '   - ' ;szCodeString must follow
szCodeString    db      '00', 0dh, 0ah, 0
ifdef WINDEBUG
	public szInitSpew
szInitSpew      DB      '  .   :  ', 0
endif

_DATA   ENDS


_INITTEXT SEGMENT WORD PUBLIC 'CODE'
public szInadequate, szNoPMode, szNoGlobalInit
public NoOpenFile, NoLoadHeader, szMissingMod, szPleaseDoIt

ifdef WOW
public szGenBootFail
szNoPMode       db " Win16      , DOSX.EXE    AUTOEXEC.NT,     -  PATH.",0
szMissingMod    db   " NTVDM:  16-  ",0
szPleaseDoIt    db   "     SYSTEM32:",13,10,9,9,0
szInadequate    db   " NTVDM:    DPMI",0
szNoGlobalInit  db   " NTVDM:   heap-",0
NoOpenFile      db   " NTVDM:    KERNEL.EXE",0
NoLoadHeader    db   " NTVDM:    KERNEL.EXE",0
szGenBootFail   db   " NTVDM:    Win16",0
else
szInadequate    db   ':    DPMI',13,10,'$'
szNoPMode       db   ':     ',13,10,'$'
szNoGlobalInit  db   ":   heap-",13,10,'$'
NoOpenFile      db   ":    KERNEL.EXE"
		db   13, 10, '$'
NoLoadHeader    db   ":    KERNEL.EXE"
		db   13, 10, '$'
endif

_INITTEXT ENDS




_NRESTEXT SEGMENT WORD PUBLIC 'CODE'

; This is the caption string for the protect mode dialog box.
;
; DO NOT CHANGE THE LENGTH OF THIS MESSAGE
;

public szProtectCap,msgRealModeApp1,msgRealModeApp2

szProtectCap    db      "   ",0

msgRealModeApp1 db      ",    , ",0
msgRealModeApp2 db      ",      Windows.",0Dh,0Dh
	db      "   ,  "
	db      " Windows  3.0   .",13,13
	db      "    OK   ,    "
	db      "       Windows.",0

_NRESTEXT ENDS

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\messages\usa\strings.asm ===
TITLE	STRINGS - OEM dependent strings used by KERNEL
include gpcont.inc		; SHERLOCK

_DATA	SEGMENT PARA PUBLIC 'DATA'
_DATA	ENDS

DGROUP	GROUP	_DATA

_INITTEXT SEGMENT WORD PUBLIC 'CODE'
_INITTEXT ENDS

_NRESTEXT SEGMENT WORD PUBLIC 'CODE'
_NRESTEXT ENDS

ASSUME	DS:DGROUP


_DATA	SEGMENT PARA PUBLIC 'DATA'

; This is the caption string for the dialog box.

public	szDiskCap
IF 0
szDiskCap	db  'Change Disk',0
ELSE
szDiskCap	db  'File Error',0
ENDIF


; This is the text for the "Cannot find xxxxxx" dialog box.
; It is printed:
;
;       <szCannotFind1>filename<szCannotFind2>

public	szCannotFind1,szCannotFind2
szCannotFind1	db	"Cannot find ", 0
szCannotFind2	db	0

; This is the text for fatal errors at boot time
;	<szBootLoad>filename
public szBootLoad
szBootLoad	db	"Error loading ",0

; The following group of strings is used for the "Please insert disk with XXXX
;   in drive X:" dialog box.
;
; These two strings form the dialog message it is:
;
;	<szCannotFind1>filename<szInsert>

IF 0
public	szInsert
szInsert	db  ', Please insert in drive '
ENDIF
;public  drvlet
;drvlet		db  "X.",0

if SHERLOCK
public szGPCont		; GP fault continuation message
szGPCont	db	"An error has occurred in your application.",10
        db      "If you choose Ignore, you should save your work in a new file.",10
        db      "If you choose Close, your application will terminate.",0
endif

public	szDosVer
szDosVer	DB	'Incorrect MS-DOS version.  MS-DOS 3.1 or greater required.',13,10,'$'
; Text for exceptions and faults lead to app termination.

public szAbortCaption,szInModule,szAt
public szNukeApp,szSnoozer,szGP,szSF,szII,szPF,szNP,szBlame,szLoad,szWillClose
public szOutofSelectors
szAbortCaption	db	"Application Error"
		db	0
szBlame		db	"BOOT "
		db	0
szSnoozer	db	" caused "
		db	0
szInModule	db	" in", 10, "module <unknown>"
		db	0
szAt		db	" at "
		db	0
szNukeApp       db      ".", 10, 10, "Choose close. "
		db	0
szWillClose	db	" will close."
		db	0
szGP		db	"a General Protection Fault"
		db	0
szD0		db	"a Divide by Zero"	; not yet used
		db	0
szSF		db	"a Stack Fault"		; not spec'ed
		db	0
szII		db	"an Illegal Instruction"	; "Fault" ???
		db	0
szPF		db	"a Page Fault"
		db	0
szNP		db	"a Not Present Fault"
		db	0
szAF		db	"an Application Fault"	; not yet used
		db	0
szLoad		db	"Segment Load Failure"
		db	0
szOutofSelectors db	"Out of Selectors"
		db	0

; Text for dialog box when terminating an application

public szAbort
szAbort 	db	"Closing current application.",0

; Text for dialog box when trying to run a compressed file
			   
public szBozo
szBozo  	db	"Cannot load compressed files",0
			 	     		     
; This is the caption string for system error dialog boxes

public	syserr
syserr		db	"System Error",0

; The following group of messages forms all of the messages used
; in the INT 24 dialog box.
;
; There are 7 messages which can be translated individually. The
; location of drvlet? and devenam? can be moved to any location
; within the string.

public	msgWriteProtect,drvlet1
public	msgCannotReadDrv,drvlet2
public	msgCannotWriteDrv,drvlet3
public	msgShare,drvlet4
public	msgNetError,drvlet5
public	msgCannotReadDev,devenam1
public	msgCannotWriteDev,devenam2
public	msgNoPrinter
public	msgNetErrorDev,devenam3

msgWriteProtect         db      "Write-protected disk in drive "
drvlet1                 db      "X.",0

msgCannotReadDrv        db      "Cannot read from drive "
drvlet2                 db      "X.",0

msgCannotWriteDrv       db      "Cannot write to drive "
drvlet3                 db      "X.",0

msgShare		db	"Sharing violation on drive "
drvlet4                 db      "X.",0

msgNetError		db	"Network error on drive "
drvlet5 		db	"X.",0

msgCannotReadDev        db      "Cannot read from device "
devenam1                db      8 dup (?)
                        db      0

msgCannotWriteDev       db      "Cannot write to device "
devenam2                db      8 dup (?)
			db	0

msgNetErrorDev		db	"Network error on device "
devenam3		db	8 dup (?)
			db	0

msgNoPrinter            db      "Printer not ready",0


ifndef WINDEBUG
public szExitStr1,szExitStr2
szExitStr1  DB  7,13,10,'FatalExit code = ',0
szExitStr2  DB  ' stack overflow',13,10,0
public  szUndefDyn
szUndefDyn      db      "Call to Undefined Dynalink",0
public  szFatalExit
szFatalExit	db	"Application requested abnormal termination",0
else
public szDebugStr
szDebugStr  DB  'KERNEL: Failed loading - ',0                   ; 0
            DB  'KERNEL: Failed loading new instance of - ',0   ; 1
            DB  'Error loading from resource file - ',0         ; 2
            DB  13,10,0                                         ; 3
            DB  7,13,10,'FatalExit code = ',0                   ; 4
            DB  ' stack overflow',0                             ; 5
            DB  13,10,'Stack trace:',13,10,0                    ; 6
	    DB  7,13,10,'Abort, Break, Exit or Ignore? ',0      ; 7
            DB  'Invalid BP chain',7,13,10,0                    ; 8
	    DB	': ',0						; 9
	    DB	'Reentered FatalExit',7,13,10,0 		; 10
	    DB  0
public szFKE
szFKE	DB '*** Fatal Kernel Error ***',0
endif

;** Diagnostic mode messages
        public szDiagStart, szCRLF, szLoadStart, szLoadSuccess, szLoadFail
        public szFailCode, szCodeString
szDiagStart     db      '[boot]'      ;lpCRLF must follow
szCRLF          db      0dh, 0ah, 0
szLoadStart     db      'LoadStart = ',0
szLoadSuccess   db      'LoadSuccess = ', 0
szLoadFail      db      'LoadFail = ', 0
szFailCode      db      ' Failure code is ' ;szCodeString must follow
szCodeString    db      '00', 0dh, 0ah, 0
ifdef WINDEBUG
	public szInitSpew
szInitSpew      DB      'Diagnostic mode startup.  Log file is:  ', 0
endif

_DATA	ENDS


_INITTEXT SEGMENT WORD PUBLIC 'CODE'
public szInadequate, szNoPMode, szNoGlobalInit
public NoOpenFile, NoLoadHeader, szMissingMod, szPleaseDoIt

ifdef WOW
public szGenBootFail
szNoPMode db "The Win16 Subsystem was unable to enter Protected Mode, DOSX.EXE must be in your AUTOEXEC.NT and present in your PATH.",0
szMissingMod    db   "NTVDM KERNEL: Missing 16-bit system module",0
szPleaseDoIt    db   "Please re-install the following module to your system32 directory:",13,10,9,9,0
szInadequate	db   "NTVDM KERNEL: Inadequate DPMI Server",0
szNoGlobalInit	db   "NTVDM KERNEL: Unable to initialize heap",0
NoOpenFile	    db   "NTVDM KERNEL: Unable to open KERNEL executable",0
NoLoadHeader	db   "NTVDM KERNEL: Unable to load KERNEL EXE header",0
szGenBootFail   db   "NTVDM KERNEL: Win16 Subsystem Initialization Failure",0
else
szInadequate	db   'KERNEL: Inadequate DPMI Server',13,10,'$'
szNoPMode	db   'KERNEL: Unable to enter Protected Mode',13,10,'$'
szNoGlobalInit	db   "KERNEL: Unable to initialize heap",13,10,'$'
NoOpenFile      db   "KERNEL: Unable to open KERNEL executable"
                db   13, 10, '$'
NoLoadHeader    db   "KERNEL: Unable to load KERNEL EXE header"
		db   13, 10, '$'
endif

_INITTEXT ENDS




_NRESTEXT SEGMENT WORD PUBLIC 'CODE'

; This is the caption string for the protect mode dialog box.
;
; DO NOT CHANGE THE LENGTH OF THIS MESSAGE
;

public szProtectCap,msgRealModeApp1,msgRealModeApp2

szProtectCap		db	"Application Compatibility Warning",0

msgRealModeApp1 db	"The application you are about to run, ",0
msgRealModeApp2 db	", was designed for a previous version of Windows.",0Dh,0Dh
	db	"Obtain an updated version of the application that is compatible "
	db	"with Windows version 3.0 and later.",13,13
	db	"If you choose the OK button and start the application, compatibility "
	db	"problems could cause the application or Windows to close unexpectedly.",0

_NRESTEXT ENDS

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\nl\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET)  \
	 DBCS_FLAGS="-DFE_SB" 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\no\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET)  \
	 DBCS_FLAGS="-DFE_SB" 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\pl\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET)  \
	 DBCS_FLAGS="-DFE_SB" 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\pt\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET)  \
	 DBCS_FLAGS="-DFE_SB" 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\psu\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET)  \
	 DBCS_FLAGS="-DFE_SB" 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\sv\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET)  \
	 DBCS_FLAGS="-DFE_SB" 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\ru\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET)  \
	 DBCS_FLAGS="-DFE_SB" 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\tr\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET)  \
	 DBCS_FLAGS="-DFE_SB" 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\tst\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET)  \
	 DBCS_FLAGS="-DFE_SB" 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\killwow\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\killwow\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\lib\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\lib\chp\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DPRC"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\lib\chs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd ..
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DPRC"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\lib\cht\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DTAIWAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\lib\jpn\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DJAPAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\lib\kor\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DKOREA"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\lib\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\messages\tr\strings.asm ===
TITLE	STRINGS - OEM dependent strings used by KERNEL
include gpcont.inc		; SHERLOCK

_DATA	SEGMENT PARA PUBLIC 'DATA'
_DATA	ENDS

DGROUP	GROUP	_DATA

_INITTEXT SEGMENT WORD PUBLIC 'CODE'
_INITTEXT ENDS

_NRESTEXT SEGMENT WORD PUBLIC 'CODE'
_NRESTEXT ENDS

ASSUME	DS:DGROUP


_DATA	SEGMENT PARA PUBLIC 'DATA'

; This is the caption string for the dialog box.

public	szDiskCap
IF 0
szDiskCap       db  'Diski Deitir',0
ELSE
szDiskCap       db  'Dosya Hatas',0
ENDIF


; This is the text for the "Cannot find xxxxxx" dialog box.
; It is printed:
;
;       <szCannotFind1>filename<szCannotFind2>

public	szCannotFind1,szCannotFind2
szCannotFind1   db      "Bulunamyor ", 0
szCannotFind2	db	0

; This is the text for fatal errors at boot time
;	<szBootLoad>filename
public szBootLoad
szBootLoad      db      "Ykleme hatas ",0

; The following group of strings is used for the "Please insert disk with XXXX
;   in drive X:" dialog box.
;
; These two strings form the dialog message it is:
;
;	<szCannotFind1>filename<szInsert>

IF 0
public	szInsert
szInsert        db  ', Srcye yerletirin '
ENDIF
;public  drvlet
;drvlet		db  "X.",0

if SHERLOCK
public szGPCont		; GP fault continuation message
szGPCont        db      "Uygulamanzda bir hata olutu.",10
        db      "Yoksay'' seerseniz almalarnz yeni bir dosyaya kaydetmelisiniz.",10
        db      "Kapat'' seerseniz uygulamanz sona erecek.",0
endif

public	szDosVer
szDosVer        DB      'Yanl MS-DOS srm.  MS-DOS 3.1 veya yukars gerekli.',13,10,'$'
; Text for exceptions and faults lead to app termination.

public szAbortCaption,szInModule,szAt
public szNukeApp,szSnoozer,szGP,szSF,szII,szPF,szNP,szBlame,szLoad,szWillClose
public szOutofSelectors
szAbortCaption  db      "Uygulama Hatas"
		db	0
szBlame         db      "NYKLEME YAP "
		db	0
szSnoozer	db	" neden oldu "
		db	0
szInModule	db	" ", 10, "birim <bilinmiyor>"
		db	0
szAt		db	" konum "
		db	0
szNukeApp       db      ".", 10, 10, "Kapat'' sein. "
		db	0
szWillClose	db	" kapanacak."
		db	0
szGP            db      "Genel Koruma Hatas"
		db	0
szD0            db      "Sfra Blnme"        ; not yet used
		db	0
szSF            db      "Yn Hatas"          ; not spec'ed
		db	0
szII            db      "Geersiz Komut"        ; "Hatas" ???
		db	0
szPF            db      "Sayfa Hatas"
		db	0
szNP            db      "Yok Hatas"
		db	0
szAF            db      "Uygulama Hatas"       ; not yet used
		db	0
szLoad          db      "Blt Ykleme Hatas"
		db	0
szOutofSelectors db     "Seiciler Bitti"
		db	0

; Text for dialog box when terminating an application

public szAbort
szAbort         db      "Geerli uygulama kapatlyor.",0

; Text for dialog box when trying to run a compressed file
			   
public szBozo
szBozo          db      "Sktrlm dosyalar yklenemez",0
			 	     		     
; This is the caption string for system error dialog boxes

public	syserr
syserr          db      "Sistem Hatas",0

; The following group of messages forms all of the messages used
; in the INT 24 dialog box.
;
; There are 7 messages which can be translated individually. The
; location of drvlet? and devenam? can be moved to any location
; within the string.

public	msgWriteProtect,drvlet1
public	msgCannotReadDrv,drvlet2
public	msgCannotWriteDrv,drvlet3
public	msgShare,drvlet4
public	msgNetError,drvlet5
public	msgCannotReadDev,devenam1
public	msgCannotWriteDev,devenam2
public	msgNoPrinter
public	msgNetErrorDev,devenam3

msgWriteProtect         db      "Srcde yazma korumal disk "
drvlet1                 db      "X.",0

msgCannotReadDrv        db      "Srcden okunamyor "
drvlet2                 db      "X.",0

msgCannotWriteDrv       db      "Srcye yazlamIyor "
drvlet3                 db      "X.",0

msgShare                db      "Srcde paylam ihlali "
drvlet4                 db      "X.",0

msgNetError             db      "Srcde a hatas "
drvlet5 		db	"X.",0

msgCannotReadDev        db      "Aygttan okunamyor "
devenam1                db      8 dup (?)
                        db      0

msgCannotWriteDev       db      "Aygta yazlamyor "
devenam2                db      8 dup (?)
			db	0

msgNetErrorDev          db      "Aygtta a hatas "
devenam3		db	8 dup (?)
			db	0

msgNoPrinter            db      "Yazc hazr deil",0


ifndef WINDEBUG
public szExitStr1,szExitStr2
szExitStr1  DB  7,13,10,'FatalExit code = ',0
szExitStr2  DB  ' stack overflow',13,10,0
public  szUndefDyn
szUndefDyn      db      "Tanmsz Dynalink ars",0
public  szFatalExit
szFatalExit     db      "Uygulama anormal sonlandrma istedi",0
else
public szDebugStr
szDebugStr  DB  'KERNEL: Ykleme baarsz - ',0                   ; 0
            DB  'KERNEL: Yeni kopya ykleme baarsz - ',0   ; 1
            DB  'Kaynak dosyadan yklemede hata - ',0         ; 2
            DB  13,10,0                                         ; 3
            DB  7,13,10,'FatalExit kodu = ',0                   ; 4
            DB  ' yn tamas',0                             ; 5
            DB  13,10,'Yn izleme:',13,10,0                    ; 6
            DB  7,13,10,'ptal et, Kes, Ik veya Yoksay? ',0      ; 7
            DB  'Geersiz BP zinciri',7,13,10,0                    ; 8
	    DB	': ',0						; 9
	    DB	'Yeniden girildi FatalExit',7,13,10,0 		; 10
	    DB  0
public szFKE
szFKE   DB '*** nemli ekirdek Hatas ***',0
endif

;** Diagnostic mode messages
        public szDiagStart, szCRLF, szLoadStart, szLoadSuccess, szLoadFail
        public szFailCode, szCodeString
szDiagStart     db      '[boot]'      ;lpCRLF must follow
szCRLF          db      0dh, 0ah, 0
szLoadStart     db      'LoadStart = ',0
szLoadSuccess   db      'LoadSuccess = ', 0
szLoadFail      db      'LoadFail = ', 0
szFailCode      db      ' Hata kodu ' ;szCodeString must follow
szCodeString    db      '00', 0dh, 0ah, 0
ifdef WINDEBUG
	public szInitSpew
szInitSpew      DB      'Tan modu balangc.  Gnlk dosyas:  ', 0
endif

_DATA	ENDS


_INITTEXT SEGMENT WORD PUBLIC 'CODE'
public szInadequate, szNoPMode, szNoGlobalInit
public NoOpenFile, NoLoadHeader, szMissingMod, szPleaseDoIt

ifdef WOW
public szGenBootFail
szNoPMode db "Win16 Alt sistemi KorumalI Kipe giremedi, DOSX.EXE "
          db "AUTOEXEC.NT''nizde ve YOL''unuzda olmal.",0
szMissingMod    db   "NTVDM EKRDEK: Eksik 16-bit sistem modl",0
szPleaseDoIt    db   "Aadaki modl system32 dizininize yeniden ykleyin:",13,10,9,9,0
szInadequate    db   "NTVDM EKRDEK: Yetersiz DPMI Sunucusu",0
szNoGlobalInit  db   "NTVDM EKRDEK: Kme alan hazrlanamad",0
NoOpenFile          db   "NTVDM EKRDEK: EKRDEK altrlabilir alamyor",0
NoLoadHeader    db   "NTVDM EKRDEK: EKRDEK EXE bal yklenemiyor",0
szGenBootFail   db   "NTVDM EKRDEK: Win16 Alt sistemi Balatma Hatas",0
else
szInadequate    db   'EKRDEK: Yetersiz DPMI Sunucusu',13,10,'$'
szNoPMode       db   'EKRDEK: Korumal Kipe girilemedi',13,10,'$'
szNoGlobalInit  db   "EKRDEK: Kme hazrlanamad",13,10,'$'
NoOpenFile      db   "EKRDEK: EKRDEK altrlabilir alamyor"
                db   13, 10, '$'
NoLoadHeader    db   "EKRDEK: EKRDEK EXE bal yklenemiyor"
		db   13, 10, '$'
endif

_INITTEXT ENDS




_NRESTEXT SEGMENT WORD PUBLIC 'CODE'

; This is the caption string for the protect mode dialog box.
;
; DO NOT CHANGE THE LENGTH OF THIS MESSAGE
;

public szProtectCap,msgRealModeApp1,msgRealModeApp2

szProtectCap            db      "Uygulama Uyumluk Uyars",0

msgRealModeApp1 db      "altrmak zere olduunuz uygulama, ",0
msgRealModeApp2 db      ", Windows''un nceki bir srm iin tasarlanm.",0Dh,0Dh
        db      "Uygulamann gncelletirilmi, Windows srm 3.0 ve sonras ile "
        db      "uyumlu bir srmn edinin.",13,13
        db      "Tamam dmesini seip uygulamay balatrsanz uyumluluk sorunlar uygulamann "
        db      "veya Windows''un beklenmedik bir ekilde kapanmasna neden olabilir.",0

_NRESTEXT ENDS

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DFE_SB" 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\messages\sv\strings.asm ===
TITLE   STRINGS - OEM dependent strings used by KERNEL
include gpcont.inc              ; SHERLOCK

_DATA   SEGMENT PARA PUBLIC 'DATA'
_DATA   ENDS

DGROUP  GROUP   _DATA

_INITTEXT SEGMENT WORD PUBLIC 'CODE'
_INITTEXT ENDS

_NRESTEXT SEGMENT WORD PUBLIC 'CODE'
_NRESTEXT ENDS

ASSUME  DS:DGROUP


_DATA   SEGMENT PARA PUBLIC 'DATA'

; This is the caption string for the dialog box.

public  szDiskCap
IF 0
szDiskCap       db  'Byt diskett',0
ELSE
szDiskCap       db  'Filfel',0
ENDIF


; This is the text for the "Cannot find xxxxxx" dialog box.
; It is printed:
;
;       <szCannotFind1>filename<szCannotFind2>

public  szCannotFind1,szCannotFind2
szCannotFind1   db      "Det gr inte att hitta ", 0
szCannotFind2   db      0

; This is the text for fatal errors at boot time
;       <szBootLoad>filename
public szBootLoad
szBootLoad      db      "Fel vid inlsning av ",0

; The following group of strings is used for the "Please insert disk with XXXX
;   in drive X:" dialog box.
;
; These two strings form the dialog message it is:
;
;       <szCannotFind1>filename<szInsert>

IF 0
public  szInsert
szInsert        db  ', stt in i enhet '
ENDIF
;public  drvlet
;drvlet         db  "X.",0

if SHERLOCK
public szGPCont         ; GP fault continuation message
szGPCont        db      "Det har uppsttt ett fel i programmet.",10
	db      "Om du vljer att Ignorera, br du frst spara arbetet i en ny fil.",10
	db      "Om du vljer Stng, kommer programmet att avslutas.",0
endif

public  szDosVer
szDosVer        DB      'Felaktig MS-DOS-version.  MS-DOS 3.1 eller nyare krvs.',13,10,'$'
; Text for exceptions and faults lead to app termination.

public szAbortCaption,szInModule,szAt
public szNukeApp,szSnoozer,szGP,szSF,szII,szPF,szNP,szBlame,szLoad,szWillClose
public szOutofSelectors
szAbortCaption  db      "Programfel"
		db      0
szBlame         db      "BOOT "
		db      0
szSnoozer       db      " orsakade "
		db      0
szInModule      db      " i", 10, "modul <oknd>"
		db      0
szAt            db      " p "
		db      0
szNukeApp       db      ".", 10, 10, "Vlj Stng. "
		db      0
szWillClose     db      " kommer att stngas."
		db      0
szGP            db      "ett allmnt skyddsfel"
		db      0
szD0            db      "nolldivision"  ; not yet used
		db      0
szSF            db      "ett stackfel"          ; not spec'ed
		db      0
szII            db      "en ogiltig instruktion"        ; "Fel" ???
		db      0
szPF            db      "ett sidfel"
		db      0
szNP            db      "ett fel pga att ngot saknas"
		db      0
szAF            db      "ett programfel"        ; not yet used
		db      0
szLoad          db      "segmentinlsningsfel"
		db      0
szOutofSelectors db     "slut p selectors"
		db      0

; Text for dialog box when terminating an application

public szAbort
szAbort         db      "Programmet avslutas.",0

; Text for dialog box when trying to run a compressed file
			   
public szBozo
szBozo          db      "Det gr inte att lsa in komprimerade filer",0
						     
; This is the caption string for system error dialog boxes

public  syserr
syserr          db      "Systemfel",0

; The following group of messages forms all of the messages used
; in the INT 24 dialog box.
;
; There are 7 messages which can be translated individually. The
; location of drvlet? and devenam? can be moved to any location
; within the string.

public  msgWriteProtect,drvlet1
public  msgCannotReadDrv,drvlet2
public  msgCannotWriteDrv,drvlet3
public  msgShare,drvlet4
public  msgNetError,drvlet5
public  msgCannotReadDev,devenam1
public  msgCannotWriteDev,devenam2
public  msgNoPrinter
public  msgNetErrorDev,devenam3

msgWriteProtect         db      "Skrivskyddad diskett i enhet "
drvlet1                 db      "X.",0

msgCannotReadDrv        db      "Det gr inte att lsa frn enhet "
drvlet2                 db      "X.",0

msgCannotWriteDrv       db      "Det gr inte att skriva till enhet "
drvlet3                 db      "X.",0

msgShare                db      "Delningsfel p enhet "
drvlet4                 db      "X.",0

msgNetError             db      "Ntverksfel p enhet "
drvlet5                 db      "X.",0

msgCannotReadDev        db      "Det gr inte att lsa frn enhet "
devenam1                db      8 dup (?)
			db      0

msgCannotWriteDev       db      "Det gr inte att skriva till enhet "
devenam2                db      8 dup (?)
			db      0

msgNetErrorDev          db      "Ntverksfel p enhet "
devenam3                db      8 dup (?)
			db      0

msgNoPrinter            db      "Skrivaren r inte klar",0


ifndef WINDEBUG
public szExitStr1,szExitStr2
szExitStr1  DB  7,13,10,'FatalExit code = ',0
szExitStr2  DB  ' stack overflow',13,10,0
public  szUndefDyn
szUndefDyn      db      "Call to Undefined Dynalink",0
public  szFatalExit
szFatalExit     db      "Application requested abnormal termination",0
else
public szDebugStr
szDebugStr  DB  'KERNEL: Failed loading - ',0                   ; 0
	    DB  'KERNEL: Failed loading new instance of - ',0   ; 1
	    DB  'Error loading from resource file - ',0         ; 2
	    DB  13,10,0                                         ; 3
	    DB  7,13,10,'FatalExit code = ',0                   ; 4
	    DB  ' stack overflow',0                             ; 5
	    DB  13,10,'Stack trace:',13,10,0                    ; 6
	    DB  7,13,10,'Abort, Break, Exit or Ignore? ',0      ; 7
	    DB  'Invalid BP chain',7,13,10,0                    ; 8
	    DB  ': ',0                                          ; 9
	    DB  'Reentered FatalExit',7,13,10,0                 ; 10
	    DB  0
public szFKE
szFKE   DB '*** Fatal Kernel Error ***',0
endif

;** Diagnostic mode messages
	public szDiagStart, szCRLF, szLoadStart, szLoadSuccess, szLoadFail
	public szFailCode, szCodeString
szDiagStart     db      '[boot]'      ;lpCRLF must follow
szCRLF          db      0dh, 0ah, 0
szLoadStart     db      'LoadStart = ',0
szLoadSuccess   db      'LoadSuccess = ', 0
szLoadFail      db      'LoadFail = ', 0
szFailCode      db      ' Failure code is ' ;szCodeString must follow
szCodeString    db      '00', 0dh, 0ah, 0
ifdef WINDEBUG
	public szInitSpew
szInitSpew      DB      'Diagnostic mode startup.  Log file is:  ', 0
endif

_DATA   ENDS


_INITTEXT SEGMENT WORD PUBLIC 'CODE'
public szInadequate, szNoPMode, szNoGlobalInit
public NoOpenFile, NoLoadHeader, szMissingMod, szPleaseDoIt

ifdef WOW
public szGenBootFail
szNoPMode db "Undersystemet Win16 kunde inte verg i skyddat lge. DOSX.EXE mste",13,10,"finnas i  AUTOEXEC.NT och i skvgsinstllningen (PATH).",0
szMissingMod    db   "NTVDM KERNEL: 16-bitars systemmodul saknas",0
szPleaseDoIt    db   "Installera om fljande modul till system32-katalogen:",13,10,9,9,0
szInadequate    db   "KERNEL: Felaktig DPMI-server",0
szNoGlobalInit  db   "KERNEL: Det gr inte att initiera denna heap",0
NoOpenFile      db   "KERNEL: Det gr inte att ppna KERNEL.EXE",0
NoLoadHeader    db   "KERNEL: Det gr inte att lsa in huvudet (header) fr KERNEL EXE ",0
szGenBootFail   db   "KERNEL: Initieringsfel fr undersystemet Win16",0
else
szInadequate    db   'KERNEL: Felaktig DPMI-server',13,10,'$'
szNoPMode       db   'KERNEL: Det gr inte att verg i skyddat lge',13,10,'$'
szNoGlobalInit  db   "KERNEL: Det gr inte att initiera denna heap",13,10,'$'
NoOpenFile      db   "KERNEL: Det gr inte att ppna KERNEL.EXE"
		db   13, 10, '$'
NoLoadHeader    db   "KERNEL: Det gr inte att lsa in huvudet (header) fr KERNEL EXE"
		db   13, 10, '$'
endif

_INITTEXT ENDS




_NRESTEXT SEGMENT WORD PUBLIC 'CODE'

; This is the caption string for the protect mode dialog box.
;
; DO NOT CHANGE THE LENGTH OF THIS MESSAGE
;

public szProtectCap,msgRealModeApp1,msgRealModeApp2

szProtectCap            db      "Kompatibilitetsvarning",0

msgRealModeApp1 db      "Programmet som skulle kras, ",0
msgRealModeApp2 db      ", r utvecklat fr en tidigare version av Windows.",0Dh,0Dh
	db      "Skaffa en uppdaterad version av programmet som r kompatibel "
	db      "med Windows version 3.0 och senare.",13,13
	db      "Om du trycker p OK och startar programmet, kan det leda till kompatibilitets-"
	db      "problem som kan orsaka att programmet eller Windows ovntat stngs.",0

_NRESTEXT ENDS

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\killwow\killwow.c ===
/****************************************************************************

	PROGRAM: KillWOW.c

	PURPOSE: KillWOW Close WOW

	COMMENTS:
		 This app will NUKE WOW if it is able to run


****************************************************************************/

#include <windows.h>		/* required for all Windows applications */

HANDLE hInst;	/* current instance */

/****************************************************************************

	FUNCTION: WinMain(HANDLE, HANDLE, LPSTR, int)

	PURPOSE: calls initialization function, processes message loop

	COMMENTS:


****************************************************************************/

int PASCAL WinMain(HANDLE hInstance, HANDLE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
        ExitKernelThunk(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\swappro\swap.c ===
/* Chris Peters
 * CHANGED:	Fritz Knabe, 7/28/87
 *		mikedr, 8/8/88 - read offset bytes after 0xff seg no on swap
 *				 allow specification of data file location
 *    c-chrisc [Christine Comaford], 10/31/89 - added "-i" flag to 
 *            allow symbol file path spec on command line, added "-m" 
 *            flag to precede module spec, rewrote module parser,
 *            added usage display, misc other enhancements.
 *
 * Copyright Microsoft Corporation, 1985-1990
 */

#include <string.h>
#include <stdio.h>
#include <ctype.h>
#include <assert.h>
#include <memory.h>
#include <malloc.h>
#include <stdlib.h>

/* standard stuff */
typedef unsigned char BYTE;
typedef unsigned short	WORD;
typedef unsigned long  DWORD;
typedef int BOOL;
#define TRUE 1
#define FALSE 0

BOOL FModuleMatch(BYTE *, BYTE);
int GetSymbolString(BYTE *, BYTE *, WORD, WORD);
int GetSegNum(char *, char *);
BYTE *htoa(BYTE *, WORD);
char *ProcessArguments(int, char **);

/* Debug Symbol Table Structures
   -----------------------------
For each symbol table (map): (MAPDEF)
-------------------------------------------------------------------------------------------------
| map_ptr | lsa | pgm_ent | abs_cnt | abs_ptr | seg_cnt | seg_ptr | nam_max | nam_len | name... |
------------------------------------------------------------------------------------------------- */
struct  mapdef
{
	unsigned    map_ptr;    /* 16 bit ptr to next map (0 if end)    */
	unsigned    lsa    ;    /* 16 bit Load Segment address          */
	unsigned    pgm_ent;    /* 16 bit entry point segment value     */
	int         abs_cnt;    /* 16 bit count of constants in map     */
	unsigned    abs_ptr;    /* 16 bit ptr to   constant chain       */
	int         seg_cnt;    /* 16 bit count of segments in map      */
	unsigned    seg_ptr;    /* 16 bit ptr to   segment chain        */
	char        nam_max;    /*  8 bit Maximum Symbol name length    */
	char        nam_len;    /*  8 bit Symbol table name length      */
};

struct  mapend
{
	unsigned        chnend;         /* end of map chain (0) */
	char            rel;            /* release              */
	char            ver;            /* version              */
};

/* For each segment/group within a symbol table: (SEGDEF)
--------------------------------------------------------------
| nxt_seg | sym_cnt | sym_ptr | seg_lsa | name_len | name... |
-------------------------------------------------------------- */
struct  segdef
{
	unsigned    nxt_seg;    /* 16 bit ptr to next segment(0 if end) */
	int         sym_cnt;    /* 16 bit count of symbols in sym list  */
	unsigned    sym_ptr;    /* 16 bit ptr to symbol list            */
	unsigned    seg_lsa;    /* 16 bit Load Segment address          */
	unsigned    seg_in0;    /* 16 bit instance 0 physical address   */
	unsigned    seg_in1;    /* 16 bit instance 1 physical address   */
	unsigned    seg_in2;    /* 16 bit instance 2 physical address   */
	unsigned    seg_in3;    /* 16 bit instance 3 physical address   */
	unsigned    seg_lin;    /* 16 bit ptr to line number record     */
	char        seg_ldd;    /*  8 bit boolean 0 if seg not loaded   */
	char        seg_cin;    /*  8 bit current instance              */
	char        nam_len;    /*  8 bit Segment name length           */
};

/*  Followed by a list of SYMDEF's..
    for each symbol within a segment/group: (SYMDEF)
-------------------------------
| sym_val | nam_len | name... |
------------------------------- */
struct  symdef
{
	unsigned    sym_val;    /* 16 bit symbol addr or const          */
	char        nam_len;    /*  8 bit symbol name length            */
};

typedef struct tagMODSEG		/* Structure for saving information */
{					/* about cmd line arguments */
	int segno;	/* Special values:
			   -1	information about all segments in the module
				is supplied
			   -2	an invalid segment name was supplied, i.e.
				nothing matches this record/argument
			   >=0	valid segment number
			*/
	char szModule[32];	/* Name of module */
} MODSEG, *PMODSEG;


/*----------------------------------------------------------------------------
|	Global Variables
|
----------------------------------------------------------------------------*/

#define MAX_ARGS  34		      /* arbitrary (but reasonable) values */
#define MAX_PATHS	16

char curpath_buffer[65];      /* buffer holding current sym file path */
char path_buffer[132];        /* buffer holding cmd line sym path string */
char *path_table[MAX_PATHS];  /* table of sym file buffers */

int  num_paths = 0;           /* index into path_table[] */
int nNumArgs;		            /* Number of command line arguments */

char *ModSegTab[MAX_ARGS];	   /* Table of MODSEG records */

BOOL bModule = FALSE;   /* is module specified on command line? */
BOOL bSymPath = FALSE;  /* is symbol file path specified on command line? */

int  num_mods = 0;      /* index into module table */


char usage[] = "\nUSAGE: SWAP [-Ipath1;path2;...] [-Fswapfile] [-Mmod1[:seg];mod2[:seg];...]\n\n"
	       "      -Ipath1;path2;...           -- Path list for .SYM files.\n\n"
	       "      -Fswapfile                  -- Name and path of swap file,\n"
          "                                     default: swappro.dat.\n\n"
	       "      -Mmod1[:seg];mod2[:seg];... -- Name of module or module:segment\n"
          "                                     pairs to return swap data for.\n";


/*----------------------------------------------------------------------------
|	Main Program
|
|
----------------------------------------------------------------------------*/

/* Structure of swappro.dat records:
	BYTE type;	0 = Call, 1 = Swap, 2 = Discard, 3 = Return
	WORD time;
	BYTE nam_len;	Length of following name (not null terminated)
	BYTE name[];
	BYTE segno;	This is the end of the record for DISCARD records
			or resources (segno == 0xFF)
	WORD offset;	This is the end of the record for types 2 and 3
	BYTE nam2_len;	If 0, the next field missing, and the name is the
			same as the previous one
	BYTE name2[];
	BYTE segno2;
	BYTE offset2;
*/


main(argc, argv)
int argc;
char *argv[];
{
	register FILE *pfIn;
	BYTE rgch1[256];
	BYTE rgch2[256];
	register BYTE stModule[32], stModule2[32];
	BYTE rt;
	BYTE cch;
	WORD t;
	WORD segno = 0, segno2 = 0;
	WORD offset, offset2;
	BOOL fFirst = TRUE;
	long time, timePrev, timeBase;
	char *filepath;


   /* sign on */

   printf("Microsoft (R) Swap File Analyzer  Version 3.00\n");
   printf("Copyright (C) Microsoft Corp 1990.  All rights reserved.\n\n");

	filepath = ProcessArguments(argc, argv);
	if (filepath == NULL)
		filepath = "swappro.dat";

	pfIn = fopen(filepath,"rb");
	if (pfIn == NULL)
	{
		printf("\nFile %s not found.\n",filepath);
		exit(2);
	}

	printf("\nType\tTime\tSegment\tOffset\tSegment\tOffset");
	printf("\n----\t----\t-------\t------\t-------\t------");

	while(!feof(pfIn))
	{
		fread(&rt, 1, 1, pfIn); 	/* Get the record type */

		timePrev = time;
		fread(&t, 2, 1, pfIn);		/* Get the time */
		time = t;
		if (fFirst)
		{
			timePrev = 0;
			timeBase = time;
			fFirst = FALSE;
		}
		time -= timeBase;
		if (time < timePrev)
		{
			time += 65536;
			timeBase -= 65536;
		}

		switch (rt)
		{
		default:
			printf("\n **** Invalid swap record ****");
			break;

		case 0:			/* Call */
		case 1:			/* Swap */
			fread(stModule, 1, 1, pfIn);
			fread(stModule+1, 1, stModule[0], pfIn);
			fread(&segno, 1, 1, pfIn);
			if (segno != 0xFF)
				fread(&offset, 2, 1, pfIn);

			else	/* We have a RESOURCE, so we don't fread */
				offset = 0xFFFF;

			fread(stModule2, 1, 1, pfIn);
				/* Check if this module name is the same as
				   stModule */
			if (stModule2[0])
				fread(stModule2+1, 1, stModule2[0], pfIn);
			else
				memcpy(stModule2, stModule, 1 + stModule[0]);

			/* read segment and offset */
			fread(&segno2, 1, 1, pfIn);
			fread(&offset2, 2, 1, pfIn);
			if (segno2 == 0xFF)
				offset2 = 0xFFFF;

         if (bModule)
         {

   			if (!FModuleMatch(stModule, segno) &&
	   			!FModuleMatch(stModule2, segno2))
		   			break;
         }

			GetSymbolString(rgch1, stModule, segno, offset);
			GetSymbolString(rgch2, stModule2, segno2, offset2);

			if (rt == 1)
				printf("\nSwap");
			else
				printf("\nCall");
			printf("\t%ld\t%s\t%s",time, rgch1, rgch2);
			break;

		case 2:			/* Discard */
		case 3:			/* Return */
			fread(stModule, 1, 1, pfIn);
			fread(stModule+1, 1, stModule[0], pfIn);
			fread(&segno, 1, 1, pfIn);
			if (rt == 2 || segno == 0xFF)
				offset = 0xFFFF;
			else
					/* Only read offset if not a DISCARD
					   record or a resource */
				fread(&offset, 2, 1, pfIn);


         if (bModule)
         {

   			if (!FModuleMatch(stModule, segno))
	   			break;

         }

			GetSymbolString(rgch1, stModule, segno, offset);
			if (rt == 2)
				printf("\nDiscard");
			else
				printf("\nReturn");
			printf("\t%ld\t%s",time,rgch1);
			break;
		}
	}
}


/* returns pointer to swap data file name, NULL if none given */
char *ProcessArguments(argc, argv)
int argc;
char *argv[];
{
	PMODSEG pms;
	int i,j;
	int nArgSep = 0;
	int n = 0;
	char *filepath = NULL;
	char *curpath;
	char ch;
	char *opt;
   char module_buffer[132];
   char *curmodule;
   
   #define MAX_MODULES 20
   char *module_table[MAX_MODULES];


	nNumArgs = (int) min(argc,MAX_ARGS);

	if (nNumArgs < 2)	/* No arguments */
		return(filepath);

	for (i = 1; i < argc; i++)
	{
		if ((*argv[i] == '-' || *argv[i] == '/')) 
		{
			ch = tolower(argv[i][1]);

			switch (ch) {

				case 'f':
					/* create swap data file spec */
					filepath = &argv[i][2];  /* first char past flag */
					if (!*filepath) 	 /* skip white space */
					{
						i++;	      /* adjust command line variables */
						nNumArgs--;
						filepath = argv[i]; /* get file name from next arg */
					}

					nNumArgs--;
					break;
	
				case 'i':
               bSymPath = TRUE;

               /* place the current directory at the head of the symbol 
                  table path */
               getcwd(curpath_buffer, 132);
               path_table[num_paths++] = curpath_buffer;

					/* create symbol file spec */
					strcpy(path_buffer, &argv[i][2]); 

					if (!*path_buffer)
					{
						/* space after flag, so increment index */
						i++;	      

						/* adjust command line arg count */
						nNumArgs--;

						/* get all symbol file path names from next arg */
						strcpy (path_buffer, argv[i]);  
					}

	   		   strcat(path_buffer, ";");

	      		curpath = strtok(path_buffer, ";");

	       		do {
	         		 path_table[num_paths++] = curpath;
	      	 		 } while (curpath = strtok(NULL, ";"));

	       		break;
		      

            case 'm':

               /* create module and/or module:_segment file spec */

               bModule = TRUE;
                     
               strcpy(module_buffer, &argv[i][2]);
                     
               if (!*module_buffer)
               {
                  i++;
                  nNumArgs--;
                  strcpy(module_buffer, argv[i]);
                     
               }
                  
	   		   strcat(module_buffer, ";");

               /* fill module table with mod names */
	      		curmodule = strtok(module_buffer, ";");

	       		do {
	         		 module_table[num_mods++] = curmodule;
	      	 		 } while (curmodule = strtok(NULL, ";"));


               /* for each module, assign segno if applicable */
               for (j = 0; j < num_mods; j++)
               {
            		if (!(pms = (PMODSEG) malloc(sizeof(MODSEG))))
                  {
                     printf ("MEMORY ALLOCATION FAILED!!!!");
                     exit (1);
                  }
               
                  /* determine whether a segment has been specified
                     (i.e., GDI:_FONTRES), look for a ':' */

              		nArgSep = strcspn(module_table[j], ":");
                  strncpy(pms->szModule, module_table[j], nArgSep);

   		         pms->szModule[nArgSep] = '\0';

		            /* Get segment number */

   	   		   /* First case: no segment specified; e.g. format of
   			         arg would be "user" */
            		if (nArgSep == strlen(module_table[j]) || 
                           module_table[j][nArgSep+1] == '\0')
            			pms->segno = -1;

      	   		/* Second case: decimal segment number supplied; e.g.
   			         "user:10" */
         		   else if (isdigit(module_table[j][nArgSep+1]))
         			   pms->segno = atoi(module_table[j]+nArgSep+1);

         			/* Third case: the segment name is "resource" */
            		else if (strcmpi(module_table[j]+nArgSep+1, "RESOURCE") == 0)
            			pms->segno = 0xFF;

            		/* Fourth case: a segment name is supplied; get
                     it's number */
         	   	else
                  {
         		   	pms->segno = GetSegNum(pms->szModule, 
                                          module_table[j]+nArgSep+1);
   
                  }

            		ModSegTab[n++] = (char *) pms;

               }
               break;

            default:

               /* Display cmd line args and quit */
            	fprintf(stderr, usage);
               exit(1);
			}			

		}

	}

	return(filepath);
}



/* Determines whether module specified on command line is equal to
current module read in.  No called if no mod, mod/seg is specified on
command line.  If false is returned, record won't be displayed. */

BOOL FModuleMatch(stModule, segno)
register BYTE stModule[];
BYTE segno;
{
	register int i;
	PMODSEG pms;


	if (nNumArgs < 2)
		return TRUE;

	stModule[stModule[0]+1] = '\0';

	for (i = 0; i < num_mods; i++)
	{
		pms = (PMODSEG) ModSegTab[i];

		if (strcmpi(stModule+1, pms->szModule) == 0 &&
			(pms->segno == -1 || pms->segno == segno))
				return(TRUE);
	}
	return(FALSE);
}


int GetSegNum(szModule, szSegment)
char *szModule;
char *szSegment;
{
/* Gets the number of the named segment in the named module, if it exists.
   This is a "stripped" version of GetSymbolString. */

	char buf[50];
	FILE *pfSym;
	struct mapdef MAPDEF;
	struct mapend MAPEND;
	struct segdef SEGDEF;
	WORD seg_ptr, fstseg_ptr;
	int i;
   register int pathcnt;
   char symfile[65];


	strcpy(symfile, szModule);
	strcat(symfile, ".SYM");


   if (bSymPath)
   {
      /* Loop through all symbol file paths until file is found */

      for (pathcnt=0; pathcnt <num_paths; pathcnt++) 
      {
         strcpy(buf, path_table[pathcnt]);
         strcat(buf, "\\");
         strcat(buf, symfile);

         if (pfSym = fopen(buf, "rb"))
            break;
      }
   }
   else
      pfSym = fopen(symfile, "rb");

	if (!pfSym)
		return -1;

	fread(&MAPDEF, 1, sizeof(MAPDEF), pfSym);
	fstseg_ptr = seg_ptr = (WORD)MAPDEF.seg_ptr;
	fseek(pfSym, (long)-sizeof(MAPEND), 2);
	fread(&MAPEND, 1, sizeof(MAPEND), pfSym);
	if (MAPEND.ver != 3)
	{
		fclose(pfSym);
		return -1;
	}
	i = 0;
	do
	{
		if (MAPEND.rel >= 10)
			fseek(pfSym, (long)(seg_ptr * 16), 0);
		else
			fseek(pfSym, (long)seg_ptr, 0);
		fread(&SEGDEF, 1, sizeof(SEGDEF), pfSym);
		seg_ptr = (WORD)SEGDEF.nxt_seg;
		fread(buf, 1, SEGDEF.nam_len, pfSym);
		buf[SEGDEF.nam_len] = '\0';
		if (strcmpi(buf, szSegment) == 0)
		{
			fclose(pfSym);
			return i;
		}
		i++;
	}
	while (seg_ptr && seg_ptr != fstseg_ptr);
	fclose(pfSym);
	return -2;
}


int GetSymbolString(pchOut, stModule, segno, offset)
BYTE *pchOut;			/* output buffer       */
BYTE stModule[];		/* module name	       */
WORD segno;			/* segment number      */
WORD offset;			/* offset into segment */
{
	int cch;
	register int i;
	register BYTE *pch;
	FILE *pfSym;
	WORD seg_ptr;
	long symPos1, symPos2;
	struct mapdef MAPDEF;
	struct mapend MAPEND;
	struct segdef SEGDEF;
	struct symdef SYMDEF;
	BYTE *htoa();
   register int pathcnt;
   char symfile[65];
   int len;


	pch = stModule;
   
	cch = *pch++;
	pch = (BYTE *) memcpy(pchOut, pch, cch) + cch;

   if((len = strlen(pchOut)) < 2)
      return (-1);


	pch[0] = '.';
	pch[1] = 'S';
	pch[2] = 'Y';
	pch[3] = 'M';
	pch[4] = 0;

   if (bSymPath) 
   {
      for (pathcnt=0; pathcnt <num_paths; pathcnt++) 
      {
         strcpy(symfile, path_table[pathcnt]);
         strcat(symfile, "\\");
         strcat(symfile, pchOut);

         if (pfSym = fopen(symfile, "rb"))
            break;
      }
   }
   else
      	pfSym = fopen(pchOut, "rb");


	/* If symbol file not found, insert/append () around name */
	if (pfSym == NULL)
	{
		pch = stModule;
		cch = *pch++;
		pch = (BYTE *) memcpy(pchOut+1, pch, cch) + cch;
		*pchOut = '(';
		*pch++ = ')';
		if (offset != 0xFFFF)
			*pch++ = '\t';
		*pch = 0;
		return(-1);
	}

	fread(&MAPDEF, 1, sizeof(MAPDEF), pfSym);

	*pch++ = '!';
	if (segno == 0xFF)
	{
		*pch++ = 'R';
		*pch++ = 'E';
		*pch++ = 'S';
		*pch++ = 'O';
		*pch++ = 'U';
		*pch++ = 'R';
		*pch++ = 'C';
		*pch++ = 'E';
		*pch = 0;
		fclose(pfSym);
		return(1);
	}

	if (segno >= MAPDEF.seg_cnt)
		goto lbNoSeg;

	seg_ptr = (WORD)MAPDEF.seg_ptr;
	fseek(pfSym, (long)-sizeof(MAPEND), 2);
	fread(&MAPEND, 1, sizeof(MAPEND), pfSym);
	if (MAPEND.ver != 3)
	{

lbNoSeg:
		pch = htoa(pch, segno);
		*pch = 0;
		if (offset != 0xFFFF)
		{
			*pch++ = '\t';
			pch = htoa(pch, offset);
			*pch = 0;
		}
		fclose(pfSym);
		return(-2);
	}
	i = segno+1;
	while (i--)
	{
		if (MAPEND.rel >= 10)
			fseek(pfSym, (long)(seg_ptr * 16), 0);
		else
			fseek(pfSym, (long)seg_ptr, 0);
		fread(&SEGDEF, 1, sizeof(SEGDEF), pfSym);
		seg_ptr = (WORD)SEGDEF.nxt_seg;
	}
	fread(pch, 1, (int)((BYTE)SEGDEF.nam_len), pfSym);

	pch += SEGDEF.nam_len;
	*pch = 0;
	if (offset == 0xFFFF)
	{
		fclose(pfSym);
		return(1);
	}
	*pch++ = '\t';

	i = (WORD)SEGDEF.sym_cnt;
	if (i == 0)
		goto lbNoSym;
	symPos1 = 0;
	while (i--)
	{
		symPos2 = symPos1;
		symPos1 = ftell(pfSym);
		fread(&SYMDEF, 1, sizeof(SYMDEF), pfSym);
		if (i == 0 || (WORD)SYMDEF.sym_val > offset)
		{
			if ((WORD)SYMDEF.sym_val > offset)
			{
				if (symPos2 == 0)
					goto lbNoSym;
				fseek(pfSym, (long)symPos2, 0);
				fread(&SYMDEF, 1, sizeof(SYMDEF), pfSym);
			}
			fread(pch, 1, (int)((BYTE)SYMDEF.nam_len), pfSym);
			pch += SYMDEF.nam_len;
			if ((WORD)SYMDEF.sym_val < offset)
			{
				*pch++ = '+';
				pch = htoa(pch, offset - SYMDEF.sym_val);
			}
			*pch = 0;
			fclose(pfSym);
			return(1);
		}
		fseek(pfSym, (long)((BYTE)SYMDEF.nam_len), 1);
	}
lbNoSym:
	pch = htoa(pch, offset);
	*pch = 0;
	fclose(pfSym);
	return(0);
}

BYTE *htoa( s, w )		/* Hexadecimal to ASCII */
register BYTE *s;
WORD w;
{
	register int i;
	char c;

	i = 4;
	s += i;
	while (i--)
	{
		c = (char)(w & (WORD)0xF);
		w >>= 4;
		if (c > 9)
			c += 'A' - 10;
		else
			c += '0';
		*--s = c;
	}

	return s+4;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\mciole\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\mciole\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\mciole\libinit.asm ===
page	,132
;-----------------------------Module-Header-----------------------------;
; Module Name:  LIBINIT.ASM
;
; library stub to do local init for a Dynamic linked library
;
; Created: 06-27-89
; Author:  Todd Laney [ToddLa]
;
; Exported Functions:   none
;
; Public Functions:     none
;
; Public Data:		none
;
; General Description:
;
; Restrictions:
;
;   This must be the first object file in the LINK line, this assures
;   that the reserved parameter block is at the *base* of DGROUP
;
;-----------------------------------------------------------------------;

?PLM=1      ; PASCAL Calling convention is DEFAULT
?WIN=1	    ; Windows calling convention

        .286p
	.xlist
	include cmacros.inc
;       include windows.inc
        .list

ifndef SEGNAME
    SEGNAME equ <_TEXT>
endif

createSeg %SEGNAME, CodeSeg, word, public, CODE

;-----------------------------------------------------------------------;
;   external functions
;
        externFP    LocalInit           ; in KERNEL
        externP     LibMain             ; C code to do DLL init

;-----------------------------------------------------------------------;
;
; Stuff needed to avoid the C runtime coming in, and init the windows
; reserved parameter block at the base of DGROUP
;
%out link me first!!
sBegin  Data
assumes DS,Data
            org 0               ; base of DATA segment!

            DD  0               ; So null pointers get 0
maxRsrvPtrs = 5
            DW  maxRsrvPtrs
usedRsrvPtrs = 0
labelDP     <PUBLIC,rsrvptrs>

DefRsrvPtr  MACRO   name
globalW     name,0
usedRsrvPtrs = usedRsrvPtrs + 1
ENDM

DefRsrvPtr  pLocalHeap          ; Local heap pointer
DefRsrvPtr  pAtomTable          ; Atom table pointer
DefRsrvPtr  pStackTop           ; top of stack
DefRsrvPtr  pStackMin           ; minimum value of SP
DefRsrvPtr  pStackBot           ; bottom of stack

if maxRsrvPtrs-usedRsrvPtrs
            DW maxRsrvPtrs-usedRsrvPtrs DUP (0)
endif

public  __acrtused
	__acrtused = 1

sEnd        Data

;-----------------------------------------------------------------------;

sBegin  CodeSeg
        assumes cs,CodeSeg

;--------------------------Private-Routine-----------------------------;
;
; LibEntry - called when DLL is loaded
;
; Entry:
;       CX    = size of heap
;       DI    = module handle
;       DS    = automatic data segment
;       ES:SI = address of command line (not used)
;
; Returns:
;       AX = TRUE if success
; Error Returns:
;       AX = FALSE if error (ie fail load process)
; Registers Preserved:
;	SI,DI,DS,BP
; Registers Destroyed:
;       AX,BX,CX,DX,ES,FLAGS
; Calls:
;	None
; History:
;
;       06-27-89 -by-  Todd Laney [ToddLa]
;	Created.
;-----------------------------------------------------------------------;

cProc   LibEntry,<FAR,PUBLIC,NODATA>,<>
cBegin
        ;
        ; Init the local heap (if one is declared in the .def file)
        ;
        jcxz no_heap

        cCall   LocalInit,<0,0,cx>

no_heap:
        cCall   LibMain, <di>
cEnd

if 0
;--------------------------Exported-Routine-----------------------------;
;
;   WEP()
;
;   called when the DLL is unloaded, it is passed 1 WORD parameter that
;   is TRUE if the system is going down, or zero if the app is
;
;   WARNING:
;
;       This function is basicly useless, you cant can any kernel function
;       that may cause the LoadModule() code to be reentered..
;
;-----------------------------------------------------------------------;

cProc   WEP,<FAR,PUBLIC,NODATA>,<>
;       ParmW   fSystemExit
cBegin  nogen
        mov     ax,1
        retf    2
cEnd    nogen
endif

sEnd    CodeSeg

        end     LibEntry
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\mmsystem\auxout.c ===
#include <windows.h>
#define MMNOMCI
#include "mmsystem.h"
#define NOMCIDEV
#include "mmddk.h"
#include "mmsysi.h"

/* -------------------------------------------------------------------------
** External globals
** -------------------------------------------------------------------------
*/
extern DWORD               mmwow32Lib;
extern LPSOUNDDEVMSGPROC   aux32Message;



/*****************************************************************************
 * @doc EXTERNAL AUX
 *
 * @api UINT | auxGetNumDevs | This function retrieves the number of auxiliary
 *   output devices present in the system.
 *
 * @rdesc Returns the number of auxiliary output devices present in the system.
 *
 * @xref auxGetDevCaps
 ****************************************************************************/
UINT WINAPI auxGetNumDevs(void)
{
    return (UINT)auxOutMessage( 0, AUXDM_GETNUMDEVS, 0L, 0L );
}

/*****************************************************************************
 * @doc EXTERNAL AUX
 *
 * @api UINT | auxGetDevCaps | This function queries a specified
 *   auxiliary output device to determine its capabilities.
 *
 * @parm UINT | wDeviceID | Identifies the auxiliary output device to be
 *   queried. Specify a valid device ID (see the following comments
 *   section), or use the following constant:
 *   @flag AUX_MAPPER | Auxiliary audio mapper. The function will
 *     return an error if no auxiliary audio mapper is installed.
 *
 * @parm LPAUXCAPS | lpCaps | Specifies a far pointer to an AUXCAPS
 *   structure.  This structure is filled with information about the
 *   capabilities of the device.
 *
 * @parm UINT | wSize | Specifies the size of the AUXCAPS structure.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_BADDEVICEID | Specified device ID is out of range.
 *   @flag MMSYSERR_NODRIVER | The driver failed to install.
 *
 * @comm The device ID specified by <p wDeviceID> varies from zero
 *   to one less than the number of devices present. AUX_MAPPER may
 *   also be used. Use <f auxGetNumDevs> to determine the number of
 *   auxiliary devices present in the system.
 *
 * @xref auxGetNumDevs
 ****************************************************************************/
UINT WINAPI auxGetDevCaps(UINT wDeviceID, LPAUXCAPS lpCaps, UINT wSize)
{
    if (!wSize)
        return MMSYSERR_NOERROR;

    V_WPOINTER(lpCaps, wSize, MMSYSERR_INVALPARAM);
    return (UINT)auxOutMessage(wDeviceID, AUXDM_GETDEVCAPS, (DWORD)lpCaps, (DWORD)wSize);
}

/*****************************************************************************
 * @doc EXTERNAL AUX
 *
 * @api UINT | auxGetVolume | This function returns the current volume
 *   setting of an auxiliary output device.
 *
 * @parm UINT | wDeviceID | Identifies the auxiliary output device to be
 *   queried.
 *
 * @parm LPDWORD | lpdwVolume | Specifies a far pointer to a location
 *   to be filled with the current volume setting.  The low-order word of
 *   this location contains the left channel volume setting, and the high-order
 *   word contains the right channel setting. A value of 0xFFFF represents
 *   full volume, and a value of 0x0000 is silence.
 *
 *   If a device does not support both left and right volume
 *   control, the low-order word of the specified location contains
 *   the volume level.
 *
 *   The full 16-bit setting(s)
 *   set with <f auxSetVolume> are returned, regardless of whether
 *   the device supports the full 16 bits of volume level control.
 *
 * @comm  Not all devices support volume control.
 *   To determine whether the device supports volume control, use the
 *   AUXCAPS_VOLUME flag to test the <e AUXCAPS.dwSupport> field of the
 *   <t AUXCAPS> structure (filled by <f auxGetDevCaps>).
 *
 *   To determine whether the device supports volume control on both the
 *   left and right channels, use the AUXCAPS_LRVOLUME flag to test the
 *   <e AUXCAPS.dwSupport> field of the <t AUXCAPS> structure (filled
 *   by <f auxGetDevCaps>).
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_BADDEVICEID | Specified device ID is out of range.
 *   @flag MMSYSERR_NODRIVER | The driver failed to install.
 *
 * @xref auxSetVolume
 ****************************************************************************/
UINT WINAPI auxGetVolume(UINT wDeviceID, LPDWORD lpdwVolume)
{
    V_WPOINTER(lpdwVolume, sizeof(DWORD), MMSYSERR_INVALPARAM);
    return (UINT)auxOutMessage(wDeviceID, AUXDM_GETVOLUME, (DWORD)lpdwVolume, 0);
}

/*****************************************************************************
 * @doc EXTERNAL AUX
 *
 * @api UINT | auxSetVolume | This function sets the volume in an
 *   auxiliary output device.
 *
 * @parm UINT | wDeviceID |  Identifies the auxiliary output device to be
 *   queried.  Device IDs are determined implicitly from the number of
 *   devices present in the system.  Device ID values range from zero
 *   to one less than the number of devices present.  Use <f auxGetNumDevs>
 *   to determine the number of auxiliary devices in the system.
 *
 * @parm DWORD | dwVolume | Specifies the new volume setting.  The
 *   low-order word specifies the left channel volume setting, and the
 *   high-order word specifies the right channel setting.
 *   A value of 0xFFFF represents full volume, and a value of 0x0000
 *   is silence.
 *
 *   If a device does not support both left and right volume
 *   control, the low-order word of <p dwVolume> specifies the volume
 *   level, and the high-order word is ignored.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_BADDEVICEID | Specified device ID is out of range.
 *   @flag MMSYSERR_NODRIVER | The driver failed to install.
 *
 * @comm Not all devices support volume control.
 *   To determine whether the device supports volume control, use the
 *   AUXCAPS_VOLUME flag to test the <e AUXCAPS.dwSupport> field of the
 *   <t AUXCAPS> structure (filled by <f auxGetDevCaps>).
 *
 *   To determine whether the device supports volume control on both the
 *   left and right channels, use the AUXCAPS_LRVOLUME flag to test the
 *   <e AUXCAPS.dwSupport> field of the <t AUXCAPS> structure (filled
 *   by <f auxGetDevCaps>).
 *
 *   Most devices do not support the full 16 bits of volume level control
 *   and will use only the high-order bits of the requested volume setting.
 *   For example, for a device that supports 4 bits of volume control,
 *   requested volume level values of 0x4000, 0x4fff, and 0x43be will
 *   all produce the same physical volume setting, 0x4000. The
 *   <f auxGetVolume> function will return the full 16-bit setting set
 *   with <f auxSetVolume>.
 *
 *   Volume settings are interpreted logarithmically. This means the
 *   perceived volume increase is the same when increasing the
 *   volume level from 0x5000 to 0x6000 as it is from 0x4000 to 0x5000.
 *
 * @xref auxGetVolume
 ****************************************************************************/
UINT WINAPI auxSetVolume(UINT wDeviceID, DWORD dwVolume)
{
    return (UINT)auxOutMessage(wDeviceID, AUXDM_SETVOLUME, dwVolume, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\mciole\mciole.c ===
//
//  MCIOLE  - OLE handler DLL for MCI objects
//
//
//  NOTES:
//      The whole reason for this handler DLL is to supply the function
//
//      OleQueryObjPos()
//
//      this function gives information to the server application on the
//      location (in the client document) of the activated OLE object.
//      the server can use this information to play the object in place
//      or position the server window correctly
//
//  IMPLEMENTION:
//
//      in theory all this DLL (handler) has to do is save the information
//      passed to OleActivate().  But in reality no app correctly calls
//      OleActivate().  They either pass no information or the wrong
//      information.
//
//      this DLL is a OLE handler, because of global data (vtblDef!) it
//      can only be a handler for one class at a time.
//
//      the handler intercepts the OleDraw, OleActivate, and all the
//      creation/destuction OLE APIs.  for each OLE object a info
//      structure is maintained (a OBJINFO structure) when ever the
//      client draws (using OleDraw...) the drawing position, and the
//      window drawn to is remembered.
//
//      when the client calls OleActivate, the saved draw location is
//      recalled, or if the app never called OleDraw() (plays
//      the meta-file itself) then the rectangle passed to OleActivate()
//      is used. (if one is supplied)
//
//      there are many classes of apps:
//
//          calls OleActivate() with correct info
//          calls OleActivate() with incorrect info
//          calls OleActivate() with no info
//
//          calls OleDraw()
//          does not call OleDraw()
//
//      here is a table of known OLE Clients....
//
//                      OleDraw     OleActivate()
//      App             Y or N      Y, N, X
//                                  (X = wrong info)
//      -------------   ----------  ------------
//      Write           Y           N
//      CardFile        Y           N
//      Packager        Y           N
//
//      Excel           N           N               (uses DDE)
//      Excel 4.0       N           N               (uses DDE)
//      PowerPnt 2.0    N           N               (uses DDE)
//
//      WinWord         N           N
//      WinWorks        Y           X
//      PowerPnt 3.0    N           Y
//      MsPublisher     N           X
//      ClTest          Y           N
//      Cirus           Y           X
//      WinProj         ?           ?
//
//      AmiPro          Y           ?
//
#include <windows.h>
#include "ole.h"
#include "shellapi.h"
#include "mciole.h"

HANDLE  ghInstance;

OLEOBJECTVTBL   vtblDll;        // these are our functions.
OLEOBJECTVTBL   vtblDef;        // these are the default functions.
HBITMAP         hbmStock;

#ifdef DEBUG
RECT rcNull = {0,0,0,0};
#define PUSHRC(prc) *((prc) ? (prc) : &rcNull)
#define CARETPOS()  // {POINT pt; GetCaretPos(&pt); DPRINTF(("CaretPos: [%d, %d]", pt.x, pt.y));}
#endif

/****************************************************************************
****************************************************************************/

void    ReplaceFunctions(LPOLEOBJECT);
BOOL    CanReplace(LPOLEOBJECT);

/****************************************************************************

    FUNCTION: LibMain(HANDLE hInstance)

****************************************************************************/

BOOL NEAR PASCAL LibMain (HANDLE hInstance)
{
    HDC hdc;
    HBITMAP hbm;

    ghInstance = hInstance;

    //
    // get the stock 1x1 mono bitmap.
    //
    hbm = CreateBitmap(1,1,1,1,NULL);
    hdc = CreateCompatibleDC(NULL);
    hbmStock = SelectObject(hdc, hbm);
    SelectObject(hdc, hbmStock);
    DeleteDC(hdc);
    DeleteObject(hbm);

//  // register clipboard formats.
//  cfObjectLink    = RegisterClipboardFormat("ObjectLink");
//  cfOwnerLink     = RegisterClipboardFormat("OwnerLink");
//  cfNative        = RegisterClipboardFormat("Native");

    return TRUE;
}

/****************************************************************************

    FUNCTION: WEP(int)

    PURPOSE: Standard exit routine for the DLL

****************************************************************************/

int FAR PASCAL _loadds WEP(nParameter)
int nParameter;
{
    return 1;
}

/****************************************************************************
****************************************************************************/

BOOL NEAR PASCAL IsApp(LPSTR szApp)
{
    char ach[80];
    int  i;
    WORD wStack;

    _asm mov wStack,ss

    GetModuleFileName((HINSTANCE)wStack, ach, sizeof(ach));

    for (i = lstrlen(ach);
        i > 0 && ach[i-1] != '\\' && ach[i-1] != '/' && ach[i] != ':';
        i--)
        ;

    return lstrcmpi(ach + i, szApp) == 0;
}

/****************************************************************************
****************************************************************************/

BOOL NEAR PASCAL IsDcMemory(HDC hdc)
{
    HBITMAP hbmT;

    if (hbmT = SelectObject(hdc, hbmStock))
        SelectObject(hdc, hbmT);

    return hbmT != NULL;
}

/****************************************************************************
****************************************************************************/

typedef struct _OBJINFO {

    struct _OBJINFO*poiNext;

    LPOLEOBJECT     lpobj;          // client side LPOLEOBJECT

    HWND            hwnd;           // client window (passed to OleActivate)
    RECT            rcActivate;     // activation rectangle (passed to OleActivate)

    HWND            hwndDraw;       // active window at time of OleDraw
    RECT            rcDraw;         // rectangle of draw
}   OBJINFO;

#ifdef DEBUG
int nObjects = 0;
#endif
OBJINFO *poiFirst = NULL;

LPOLEOBJECT lpobjActive;
BOOL RegSetGetData(OBJINFO *poi, BOOL Write);

OBJINFO *FindObj(LPOLEOBJECT lpobj)
{
    OBJINFO *poi;

    for (poi=poiFirst; poi; poi=poi->poiNext)
        if (poi->lpobj == lpobj)
            return poi;

    DPRINTF(("FindObj: Unable to find object %lx", lpobj));

    return NULL;
}

void DelObj(LPOLEOBJECT lpobj)
{
    OBJINFO *poi;
    OBJINFO *poiT;

    for (poiT=NULL,poi=poiFirst; poi; poiT=poi,poi=poi->poiNext)
    {
        if (poi->lpobj == lpobj)
        {
            if (poiT)
                poiT->poiNext = poi->poiNext;
            else
                poiFirst = poi->poiNext;

            poi->lpobj = NULL;
            LocalFree((HLOCAL)poi);

            DPRINTF(("DelObj(%lx): %d objects", lpobj, --nObjects));
            return;
        }
    }

    DPRINTF(("DelObj(%lx): Cant find object to delete.", lpobj));
}

BOOL RegSetGetData(OBJINFO *poi, BOOL Write)
{

    static char szKey[] = "PlayData";
    static char szFormat[] = "%ld %ld %d %d %d %d %d %d %d %d";


    if (Write) {
        LONG Rc;

        char Data[100];

        //
        // Store hwnd, hwnddraw, rcDraw, rcActivate
        //

#ifdef WIN32
        wsprintf(Data, szFormat,
                 (LONG)poi->hwnd,
                 (LONG)poi->hwndDraw,
                 poi->rcDraw.left,
                 poi->rcDraw.right,
                 poi->rcDraw.top,
                 poi->rcDraw.bottom,
                 poi->rcActivate.left,
                 poi->rcActivate.right,
                 poi->rcActivate.top,
                 poi->rcActivate.bottom);

#else
        wsprintf(Data, szFormat,
                 (LONG)(poi->hwnd == NULL ? (LONG)0 : MAKELONG(poi->hwnd, 0xFFFF)),
                 (LONG)(poi->hwndDraw == NULL ? (LONG)0 : MAKELONG(poi->hwndDraw, 0xFFFF)),
                 poi->rcDraw.left,
                 poi->rcDraw.right,
                 poi->rcDraw.top,
                 poi->rcDraw.bottom,
                 poi->rcActivate.left,
                 poi->rcActivate.right,
                 poi->rcActivate.top,
                 poi->rcActivate.bottom);
#endif

        Rc = RegSetValue(HKEY_CLASSES_ROOT,
                         szKey,
                         REG_SZ,
                         Data,
                         lstrlen(Data));

        return Rc == ERROR_SUCCESS;
    } else {

#ifdef WIN32
        LONG Rc;
        CHAR Data[100];
        DWORD hwnd, hwndDraw;
        LONG Length;

        Length = sizeof(Data);

        Rc = RegQueryValue(HKEY_CLASSES_ROOT, szKey,
                           Data, &Length);

        RegSetValue(HKEY_CLASSES_ROOT, szKey, REG_SZ, "", 0);

        //
        // Extract our data - sscanf doesn't work yet!!!
        //

        if (Rc == ERROR_SUCCESS) {
            LONG OurData[10];
            int i;
            LPTSTR lpData;

            for (i = 0, lpData = Data; i < 10; i++) {
                OurData[i] = atol(lpData);
                while (*lpData != ' ' && *lpData != '\0') {
                    lpData++;
                }

                if (*lpData == ' ') {
                    lpData++;
                }
            }

            poi->hwnd = (HWND)OurData[0];
            poi->hwndDraw = (HWND)OurData[1];
            poi->rcDraw.left = OurData[2];
            poi->rcDraw.right = OurData[3];
            poi->rcDraw.top = OurData[4];
            poi->rcDraw.bottom = OurData[5];
            poi->rcActivate.left = OurData[6];
            poi->rcActivate.right = OurData[7];
            poi->rcActivate.top = OurData[8];
            poi->rcActivate.bottom = OurData[9];
        }

        return Rc == ERROR_SUCCESS && Length != 0;
#else
        return FALSE;
#endif
    }
}

//
// for some reason we dont get all the OleDelete() calls that we should
// so lets try to "weed out the bad apples" so we dont choke.
//
void CleanObjects()
{
    OBJINFO *poi;

again:
    for (poi=poiFirst; poi; poi=poi->poiNext)
    {
        if (IsBadReadPtr(poi->lpobj, 0))
        {
            DPRINTF(("Freeing bad object %lx", poi->lpobj));
            DelObj(poi->lpobj);
            goto again;
        }
    }
}

OBJINFO *NewObj(LPOLEOBJECT lpobj)
{
    OBJINFO *poi;

    CleanObjects();

    if (poi = FindObj(lpobj))
    {
        DPRINTF(("NewObj(%lx): Trying to add object twice!", lpobj));
        return poi;
    }

    if (poi = (OBJINFO*)LocalAlloc(LPTR, sizeof(OBJINFO)))
    {
        poi->lpobj = lpobj;
        poi->hwnd  = NULL;
        poi->hwndDraw = NULL;
        SetRectEmpty(&poi->rcDraw);
        SetRectEmpty(&poi->rcActivate);

        poi->poiNext = poiFirst;
        poiFirst = poi;

        DPRINTF(("NewObj(%lx): %d objects", lpobj, ++nObjects));
    }
    else
    {
        DPRINTF(("NewObj(%lx): Out of room in the object table", lpobj));
    }

    return poi;
}

/****************************************************************************
****************************************************************************/

HWND LookForDC(HWND hwndP, HDC hdc)
{
    RECT    rc;
    DWORD   dw;
    HWND    hwnd;

    if (hwndP == NULL)
        return NULL;

    dw = GetDCOrg(hdc);

    for (hwnd = hwndP; hwnd; hwnd = GetWindow(hwnd, GW_HWNDNEXT))
    {
        GetClientRect(hwnd, &rc);
        ClientToScreen(hwnd, (LPPOINT)&rc);
        ClientToScreen(hwnd, (LPPOINT)&rc+1);

        if ((int)LOWORD(dw) == rc.left && (int)HIWORD(dw) == rc.top)
            return hwnd;

        if (PtInRect(&rc, MAKEPOINT(dw)) && (hwndP = GetWindow(hwnd, GW_CHILD)))
            if (hwndP = LookForDC(hwndP,hdc))
                return hwndP;
    }

    return NULL;
}

HWND WindowFromDC(HDC hdc)
{
    return LookForDC(GetDesktopWindow(), hdc);
}

/****************************************************************************
****************************************************************************/

BOOL RectSameSize(LPRECT lprc1, LPRECT lprc2)
{
    return lprc1->right  - lprc1->left == lprc2->right  - lprc2->left &&
           lprc1->bottom - lprc1->top  == lprc2->bottom - lprc2->top;
}

/****************************************************************************

    OleQueryObjPos - this function retuns the last drawn or activated
                     position of a object

****************************************************************************/

OLESTATUS FAR PASCAL _loadds OleQueryObjPos(
LPOLEOBJECT lpobj,      /* object to query */
HWND FAR *  lphwnd,     /* window of the document containing the object */
LPRECT      lprc,       /* rect (client cords) of object. */
LPRECT      lprcWBounds)/* rect (client cords) of bounding rect. */
{
    OBJINFO *poi;

    //
    // we dont do this any more
    //
    if (lprcWBounds)
        SetRectEmpty(lprcWBounds);

    //
    // because the server side calls this API the passed lpobj is
    // a server side LPOLEOBJECT, we can't search our table for this
    // object.
    //
    // this API is only callable by the server during the DoVerb
    // server callback
    //
    //!!! this only works for the last active object!!!!

    DPRINTF(("OleQueryObjPos(%lx)", lpobj));

    if (lpobjActive != NULL && (poi = FindObj(lpobjActive)))
    {
        //
        //  set lpobjActive to NULL so we will never retrive the
        //  wrong info again.
        //
        lpobjActive = NULL;

        *lphwnd = poi->hwnd;

//      if (IsRectEmpty(&poi->rcActivate))
        if (!IsRectEmpty(&poi->rcDraw))
        {
            DPRINTF(("Using the OleDraw() rectange...."));

            //
            // use the draw rectangle
            //
            *lprc = poi->rcDraw;

            if (poi->hwndDraw)
            {
                ClientToScreen(poi->hwndDraw, (LPPOINT)lprc);
                ClientToScreen(poi->hwndDraw, (LPPOINT)lprc+1);
            }

            ScreenToClient(poi->hwnd, (LPPOINT)lprc);
            ScreenToClient(poi->hwnd, (LPPOINT)lprc+1);
        }
        else
        {
            //
            // use the activate rectangle
            //
            *lprc = poi->rcActivate;
        }

        if (poi->hwnd && !IsRectEmpty(lprc))
            return OLE_OK;
        else
            return OLE_ERROR_BLANK;     // return a error, we dont know about this OBJ
    }
    else
    {
        *lphwnd = NULL;
        SetRectEmpty(lprc);

        return OLE_ERROR_BLANK;     // return a error, we dont know about this OBJ
    }
}

/****************************************************************************
****************************************************************************/

OLESTATUS FAR PASCAL _loadds DllLoadFromStream (lpstream, lpprotocol, lpclient, lhclientdoc, lpobjname, lplpobj, objType, aClass, cfFormat)
LPOLESTREAM         lpstream;
LPSTR               lpprotocol;
LPOLECLIENT         lpclient;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpobj;
LONG                objType;
ATOM                aClass;
OLECLIPFORMAT       cfFormat;
{
    OLESTATUS   retVal;

    DPRINTF(("OleLoadFromStream(%s,%s)", lpprotocol, lpobjname));

    retVal = DefLoadFromStream (lpstream, lpprotocol, lpclient,
                    lhclientdoc, lpobjname, lplpobj,
                    objType, aClass, cfFormat);

    if (retVal <= OLE_WAIT_FOR_RELEASE)
        ReplaceFunctions(*lplpobj);

    return retVal;
}

/****************************************************************************
****************************************************************************/

OLESTATUS FAR PASCAL _loadds DllCreateFromClip (lpprotocol, lpclient, lhclientdoc, lpobjname, lplpobj, optRender, cfFormat, objType)
LPSTR               lpprotocol;
LPOLECLIENT         lpclient;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpobj;
OLEOPT_RENDER       optRender;
OLECLIPFORMAT       cfFormat;
LONG                objType;
{
    OLESTATUS   retVal;

    DPRINTF(("OleCreateFromClip(%s,%s)", lpprotocol, lpobjname));

    retVal =  DefCreateFromClip (lpprotocol, lpclient,
                            lhclientdoc, lpobjname, lplpobj,
                            optRender, cfFormat, objType);

    if (retVal <= OLE_WAIT_FOR_RELEASE)
        ReplaceFunctions(*lplpobj);

    return retVal;
}

/****************************************************************************
****************************************************************************/

OLESTATUS FAR PASCAL _loadds DllCreateLinkFromClip (lpprotocol, lpclient, lhclientdoc, lpobjname, lplpobj, optRender, cfFormat)
LPSTR               lpprotocol;
LPOLECLIENT         lpclient;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpobj;
OLEOPT_RENDER       optRender;
OLECLIPFORMAT       cfFormat;
{
    OLESTATUS       retVal;
    BOOL            bReplace = FALSE;

    DPRINTF(("OleCreateLinkFromClip(%s,%s)", lpprotocol, lpobjname));

    retVal =  DefCreateLinkFromClip (lpprotocol, lpclient,
                        lhclientdoc, lpobjname, lplpobj,
                        optRender, cfFormat);

    if (retVal <= OLE_WAIT_FOR_RELEASE)
        ReplaceFunctions(*lplpobj);

    return retVal;
}

/****************************************************************************
****************************************************************************/

OLESTATUS FAR PASCAL _loadds DllCreateFromTemplate (lpprotocol, lpclient, lptemplate, lhclientdoc, lpobjname, lplpobj, optRender, cfFormat)
LPSTR               lpprotocol;
LPOLECLIENT         lpclient;
LPSTR               lptemplate;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpobj;
OLEOPT_RENDER       optRender;
OLECLIPFORMAT       cfFormat;
{
    OLESTATUS   retVal;

    DPRINTF(("OleCreateFromTemplate(%s,%s,%s)", lpprotocol, lptemplate, lpobjname));

    retVal = DefCreateFromTemplate (lpprotocol, lpclient, lptemplate,
                            lhclientdoc, lpobjname, lplpobj,
                            optRender, cfFormat);

    if (retVal <= OLE_WAIT_FOR_RELEASE)
        ReplaceFunctions(*lplpobj);

    return retVal;
}

/****************************************************************************
****************************************************************************/

OLESTATUS FAR PASCAL _loadds DllCreate (lpprotocol, lpclient, lpclass, lhclientdoc, lpobjname, lplpobj, optRender, cfFormat)
LPSTR               lpprotocol;
LPOLECLIENT         lpclient;
LPSTR               lpclass;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpobj;
OLEOPT_RENDER       optRender;
OLECLIPFORMAT       cfFormat;
{
    OLESTATUS   retVal;

    DPRINTF(("OleCreate(%s,%s,%s)", lpprotocol, lpclass, lpobjname));

    retVal = DefCreate (lpprotocol, lpclient, lpclass,
                    lhclientdoc, lpobjname, lplpobj,
                    optRender, cfFormat);

    if (retVal <= OLE_WAIT_FOR_RELEASE)
        ReplaceFunctions(*lplpobj);

    return retVal;
}

/****************************************************************************
****************************************************************************/

OLESTATUS FAR PASCAL _loadds DllCreateFromFile (lpprotocol, lpclient, lpclass, lpfile, lhclientdoc, lpobjname, lplpobj, optRender, cfFormat)
LPSTR               lpprotocol;
LPOLECLIENT         lpclient;
LPSTR               lpclass;
LPSTR               lpfile;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpobj;
OLEOPT_RENDER       optRender;
OLECLIPFORMAT       cfFormat;
{
    OLESTATUS   retVal;

    DPRINTF(("OleCreateFromFile(%s,%s,%s,%s)", lpprotocol, lpclass, lpfile, lpobjname));

    retVal = DefCreateFromFile (lpprotocol, lpclient, lpclass, lpfile,
                        lhclientdoc, lpobjname, lplpobj,
                        optRender, cfFormat);

    if (retVal <= OLE_WAIT_FOR_RELEASE)
        ReplaceFunctions(*lplpobj);

    return retVal;
}


/****************************************************************************
****************************************************************************/

OLESTATUS FAR PASCAL _loadds DllCreateLinkFromFile (lpprotocol, lpclient, lpclass, lpfile, lpitem, lhclientdoc, lpobjname, lplpobj, optRender, cfFormat)
LPSTR               lpprotocol;
LPOLECLIENT         lpclient;
LPSTR               lpclass;
LPSTR               lpfile;
LPSTR               lpitem;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpobj;
OLEOPT_RENDER       optRender;
OLECLIPFORMAT       cfFormat;
{
    OLESTATUS   retVal;

    DPRINTF(("OleCreateLinkFromFile(%s,%s,%s,%s,%s)", lpprotocol, lpclass, lpfile, lpitem, lpobjname));

    retVal = DefCreateLinkFromFile (lpprotocol, lpclient,
                        lpclass, lpfile, lpitem,
                        lhclientdoc, lpobjname, lplpobj,
                        optRender, cfFormat);

    if (retVal <= OLE_WAIT_FOR_RELEASE)
        ReplaceFunctions(*lplpobj);

    return retVal;
}


/****************************************************************************
****************************************************************************/

void ReplaceFunctions(LPOLEOBJECT lpobj)
{
//  OBJINFO *poi;

    if (!CanReplace(lpobj))
        return;

    NewObj(lpobj);

    //
    // get the default handlers
    //
    if (vtblDef.Draw == NULL)           // only get the handlers once!
        vtblDef = *lpobj->lpvtbl;       // save default handlers

    //
    //  make the OLE object use our handlers
    //
    lpobj->lpvtbl = (LPOLEOBJECTVTBL)&vtblDll;

    //
    //  init our VTBL, ie replace any handlers we want to override.
    //  any handlers we dont replace we set the the default ones.
    //
    vtblDll = vtblDef;

////(FARPROC)vtblDll.QueryProtocol           = (FARPROC)DllQueryProtocol;
////(FARPROC)vtblDll.Release                 = (FARPROC)DllRelease;
////(FARPROC)vtblDll.Show                    = (FARPROC)DllShow;
////(FARPROC)vtblDll.DoVerb                  = (FARPROC)DllDoVerb;
////(FARPROC)vtblDll.GetData                 = (FARPROC)DllGetData;
////(FARPROC)vtblDll.SetData                 = (FARPROC)DllSetData;
////(FARPROC)vtblDll.SetTargetDevice         = (FARPROC)DllSetTargetDevice;
////(FARPROC)vtblDll.SetBounds               = (FARPROC)DllSetBounds;
////(FARPROC)vtblDll.EnumFormats             = (FARPROC)DllEnumFormats;
////(FARPROC)vtblDll.SetColorScheme          = (FARPROC)DllSetColorScheme;

    (FARPROC)vtblDll.Delete                  = (FARPROC)DllDelete;
////(FARPROC)vtblDll.SetHostNames            = (FARPROC)DllSetHostNames;
////(FARPROC)vtblDll.SaveToStream            = (FARPROC)DllSaveToStream;
    (FARPROC)vtblDll.Clone                   = (FARPROC)DllClone;
    (FARPROC)vtblDll.CopyFromLink            = (FARPROC)DllCopyFromLink;
////(FARPROC)vtblDll.Equal                   = (FARPROC)DllEqual;
////(FARPROC)vtblDll.CopyToClipboard         = (FARPROC)DllCopyToClipboard;
    (FARPROC)vtblDll.Draw                    = (FARPROC)DllDraw;
    (FARPROC)vtblDll.Activate                = (FARPROC)DllActivate;
////(FARPROC)vtblDll.Execute                 = (FARPROC)DllExecute;
////(FARPROC)vtblDll.Close                   = (FARPROC)DllClose;
////(FARPROC)vtblDll.Update                  = (FARPROC)DllUpdate;
////(FARPROC)vtblDll.Reconnect               = (FARPROC)DllReconnect;
    (FARPROC)vtblDll.ObjectConvert           = (FARPROC)DllObjectConvert;
////(FARPROC)vtblDll.GetLinkUpdateOptions    = (FARPROC)DllGetLinkUpdateOptions;
////(FARPROC)vtblDll.SetLinkUpdateOptions    = (FARPROC)DllSetLinkUpdateOptions;
////(FARPROC)vtblDll.Rename                  = (FARPROC)DllRename;
////(FARPROC)vtblDll.QueryName               = (FARPROC)DllQueryName;
////(FARPROC)vtblDll.QueryType               = (FARPROC)DllQueryType;
////(FARPROC)vtblDll.QueryBounds             = (FARPROC)DllQueryBounds;
////(FARPROC)vtblDll.QuerySize               = (FARPROC)DllQuerySize;
////(FARPROC)vtblDll.QueryOpen               = (FARPROC)DllQueryOpen;
////(FARPROC)vtblDll.QueryOutOfDate          = (FARPROC)DllQueryOutOfDate;
////(FARPROC)vtblDll.QueryReleaseStatus      = (FARPROC)DllQueryReleaseStatus;
////(FARPROC)vtblDll.QueryReleaseError       = (FARPROC)DllQueryReleaseError;
////(FARPROC)vtblDll.QueryReleaseMethod      = (FARPROC)DllQueryReleaseMethod;
////(FARPROC)vtblDll.RequestData             = (FARPROC)DllRequestData;
////(FARPROC)vtblDll.ObjectLong              = (FARPROC)DllObjectLong;
////(FARPROC)vtblDll.ChangeData              = (FARPROC)DllChangeData;
}

/****************************************************************************
****************************************************************************/

BOOL CanReplace(LPOLEOBJECT lpobj)
{
#if 0   // did not work anyway.
    //
    // we dont work on the wierd OLE shipped with PenWindows so don't load
    //
#pragma message("Disabling handler because we are on PenWindows...")
    if (GetSystemMetrics(SM_PENWINDOWS))
        return FALSE;
#endif

    return TRUE;
}

/****************************************************************************
****************************************************************************/

LPVOID GetData(LPOLEOBJECT lpobj, WORD cf)
{
    HANDLE h;

    if ( (*vtblDef.GetData)(lpobj, cf, &h) != OLE_OK || h == NULL)
        return NULL;

    return GlobalLock(h);
}

/****************************************************************************

these are the actual handlers.....

****************************************************************************/

/****************************************************************************
****************************************************************************/

LPVOID          FAR PASCAL _loadds DllQueryProtocol (
LPOLEOBJECT     lpobj,
LPSTR           lpsz)
{
    DPRINTF(("OleQueryProtocol(%ls)", lpsz));

    return vtblDef.QueryProtocol(lpobj, lpsz);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _loadds DllRelease (
LPOLEOBJECT     lpobj)
{
    DPRINTF(("OleRelease()"));

    return vtblDef.Release(lpobj);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _loadds DllShow (
LPOLEOBJECT     lpobj,
BOOL            fShow)
{
    DPRINTF(("OleShow(%d)", fShow));

    return vtblDef.Show(lpobj, fShow);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _loadds DllDoVerb (
LPOLEOBJECT     lpobj,
WORD            verb,
BOOL            fShow,
BOOL            fActivate)
{
    DPRINTF(("OleDoVerb(%d, %d, %d)", verb, fShow, fActivate));

    return vtblDef.DoVerb(lpobj, verb, fShow, fActivate);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _loadds DllGetData (
LPOLEOBJECT     lpobj,
OLECLIPFORMAT   cf,
LPHANDLE        lph)
{
    DPRINTF(("OleGetData(%d)", cf));

    return vtblDef.GetData(lpobj, cf, lph);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _loadds DllSetData (
LPOLEOBJECT     lpobj,
OLECLIPFORMAT   cf,
HANDLE          h)
{
    DPRINTF(("OleSetData(%d, %d)", cf, h));

    return vtblDef.SetData(lpobj, cf, h);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _loadds DllSetTargetDevice (
LPOLEOBJECT     lpobj,
HANDLE          h)
{
    DPRINTF(("OleSetTargetDevice()"));

    return vtblDef.SetTargetDevice(lpobj, h);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _loadds DllSetBounds (
LPOLEOBJECT     lpobj,
LPRECT          lprc)
{
    DPRINTF(("OleSetBounds([%d,%d,%d,%d])", PUSHRC(lprc)));

    return vtblDef.SetBounds(lpobj, lprc);
}

/****************************************************************************
****************************************************************************/

OLECLIPFORMAT   FAR PASCAL _loadds DllEnumFormats (
LPOLEOBJECT     lpobj,
OLECLIPFORMAT   cf)
{
    DPRINTF(("OleEnumFormats(%d)", cf));

    return vtblDef.EnumFormats(lpobj, cf);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _loadds DllSetColorScheme (
LPOLEOBJECT     lpobj,
LPLOGPALETTE    lppal)
{
    DPRINTF(("OleSetColorScheme()"));

    return vtblDef.SetColorScheme(lpobj, lppal);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _loadds DllDelete (
LPOLEOBJECT     lpobj)
{
    DPRINTF(("OleDelete(%lx)", lpobj));

    DelObj(lpobj);
    CleanObjects();

    return vtblDef.Delete(lpobj);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _loadds DllSetHostNames (
LPOLEOBJECT     lpobj,
LPSTR           szClientName,
LPSTR           szDocName)
{
    DPRINTF(("OleSetHostNames(%ls,%ls)", szClientName, szDocName));

    return vtblDef.SetHostNames(lpobj, szClientName, szDocName);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _loadds DllSaveToStream (
LPOLEOBJECT     lpobj,
LPOLESTREAM     lpstream)
{
    DPRINTF(("OleSaveToStream()"));

    return vtblDef.SaveToStream(lpobj, lpstream);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _loadds DllClone (
LPOLEOBJECT     lpobj,
LPOLECLIENT     lpClient,
LHCLIENTDOC     lhClientDoc,
LPSTR           szObjName,
LPOLEOBJECT FAR*lplpobj)
{
    OLESTATUS err;

    DPRINTF(("OleClone(%ls)", szObjName));

    err = vtblDef.Clone(lpobj, lpClient, lhClientDoc, szObjName, lplpobj);

    //
    // if the object cloned correctly then clone our object information
    //
    if (err <= OLE_WAIT_FOR_RELEASE)
    {
        OBJINFO *poi, *poiT;

        if ((poiT = FindObj(lpobj)) && (poi = NewObj(NULL)))
        {
            poi->lpobj      = *lplpobj;
            poi->hwnd       = poiT->hwnd;
            poi->rcActivate = poiT->rcActivate;
            poi->hwndDraw   = poiT->hwndDraw;
            poi->rcDraw     = poiT->rcDraw;
        }
    }

    return err;
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _loadds DllCopyFromLink (
LPOLEOBJECT     lpobj,
LPOLECLIENT     lpClient,
LHCLIENTDOC     lhClientDoc,
LPSTR           szObjName,
LPOLEOBJECT FAR*lplpobj)
{
    OLESTATUS err;

    DPRINTF(("OleCopyFromLink(%ls)", szObjName));

    err = vtblDef.CopyFromLink(lpobj, lpClient, lhClientDoc, szObjName, lplpobj);

    if (err <= OLE_WAIT_FOR_RELEASE)
        NewObj(*lplpobj);

    return err;
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _loadds DllEqual (
LPOLEOBJECT     lpobj1,
LPOLEOBJECT     lpobj2)
{
    DPRINTF(("OleEqual()"));

    return vtblDef.Equal(lpobj1, lpobj2);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _loadds DllCopyToClipboard (
LPOLEOBJECT     lpobj)
{
    DPRINTF(("OleCopyToClipboard()"));

    return vtblDef.CopyToClipboard(lpobj);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _loadds DllDraw (
LPOLEOBJECT     lpobj,
HDC             hdc,
LPRECT          lprcBounds,
LPRECT          lprcWBounds,
HDC             hdcFormat)
{
    OBJINFO *poi;
    RECT rc;
    DWORD   dw;

    DPRINTF(("OleDraw(%lx,[%d,%d,%d,%d], [%d,%d,%d,%d])", lpobj, PUSHRC(lprcBounds), PUSHRC(lprcWBounds)));

#ifdef DEBUG
    if (OleIsDcMeta(hdc))
        DPRINTF(("OleDraw: drawing to a meta-file"));
    else if (IsDcMemory(hdc))
        DPRINTF(("OleDraw: drawing to a bitmap"));
#endif

    if ((poi = FindObj(lpobj)) && !OleIsDcMeta(hdc) && !IsDcMemory(hdc))
    {
        //!!!get the window from the HDC!!!

        poi->hwndDraw = WindowFromDC(hdc);
        DPRINTF(("OleDraw: hwndDraw = %04X", poi->hwndDraw));

        if (lprcBounds && !IsRectEmpty(lprcBounds))
        {
            poi->rcDraw = *lprcBounds;

            //
            // convert the bound rectange into coordinates.
            // relative to hwndDraw
            //
            LPtoDP(hdc, (LPPOINT)&poi->rcDraw, 2);

            if (poi->hwndDraw == NULL)
            {
                dw = GetDCOrg(hdc);
                OffsetRect(&poi->rcDraw, LOWORD(dw), HIWORD(dw));
            }
        }

        if (GetClipBox(hdc, &rc) == NULLREGION)
            return OLE_OK;
    }

    return vtblDef.Draw(lpobj, hdc, lprcBounds, lprcWBounds, hdcFormat);
}

/****************************************************************************

    scan WinWords stack and "extract" the info it should have passed to
    OleActivate() this has been tested with WinWord 2.0 and 2.0a.

    we expect future verisons of WinWord to pass the correct info to
    OleActivate() so we will never get here.

****************************************************************************/

BOOL NEAR PASCAL GetOpusRect(LPRECT lprcBound)
{
    LPRECT lprc;
    LPVOID lp;
//  int i,dx,dy;

    //
    //  see if the current app is WinWord
    //
    if (!IsApp("WINWORD.EXE"))
        return FALSE;

    //
    //  lets scan the stack looking for a RECT, this is a total
    //  hack to get MSWORD to work.
    //
    _asm
    {
        mov     bx,ss:[bp]      ; get saved BP              DllActivate()
        and     bx, not 1
        mov     bx,ss:[bx]      ; get saved saved BP        OleActivate()
        and     bx, not 1
        mov     bx,ss:[bx]      ; get saved saved saved BP  "winword"
        and     bx, not 1

        mov     word ptr lp[0], bx
        mov     word ptr lp[2], ss
    }

#ifdef DEBUG
    DPRINTF(("****** SCANING WINWORDs STACK ********"));
    lprc = lp;

    for (i=0; i<1000; i++)
    {
        dx = lprc->right  - lprc->left;
        dy = lprc->bottom - lprc->top;

        if (dx >= 158 && dx <= 162 &&
            dy >= 118 && dy <= 122)
        {
            DPRINTF(("found a RECT at offset %d, [%d, %d, %d, %d]",
                (LPBYTE)lprc - (LPBYTE)lp, PUSHRC(lprc)));
        }

        ((LPBYTE)lprc)++;
    }
    DPRINTF(("**************************************"));
#endif

    lprc = (LPRECT)((LPBYTE)lp + 6);

    if (lprc->right - lprc->left > 0 && lprc->bottom - lprc->top > 0)
    {
        DPRINTF(("*** HACK FOR WINWORD, [%d, %d, %d, %d]", PUSHRC(lprc)));
        *lprcBound = *lprc;
        return TRUE;
    }

    return FALSE;
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _loadds DllActivate (
LPOLEOBJECT     lpobj,
WORD            verb,
BOOL            fShow,
BOOL            fActivate,
HWND            hwnd,
LPRECT          lprcBound)
{
    OBJINFO *poi;
    RECT    rc;

    DPRINTF(("OleActivate(%lx, %d, %d, %d, %04X, [%d,%d,%d,%d])", lpobj, verb, fShow, fActivate, hwnd, PUSHRC(lprcBound)));

    //
    //  hack for Write
    //
    if (IsWindow(fActivate))
    {
        DPRINTF(("OleActivate: Write pre-realase work around"));
        hwnd = fActivate;
        fActivate = TRUE;
    }

    if (poi = FindObj(lpobj))
    {
        lpobjActive = lpobj;

        poi->hwnd = hwnd;

        if (poi->hwnd == NULL)
        {
            if (GetFocus())
            {
                DPRINTF(("OleActivate: no window specifed, using the focus window"));
                poi->hwnd = GetFocus();
            }
            else
            {
                DPRINTF(("OleActivate: no window specifed, using the active window"));
                poi->hwnd = GetActiveWindow();
            }
        }

        if (lprcBound && !IsRectEmpty(lprcBound))
        {
            poi->rcActivate = *lprcBound;
        }
        else
        {
            GetOpusRect(&poi->rcActivate);
        }

        //
        //  MS-Publisher gives use the *wrong* rectangle in the OleActivate call
        //  and never calls OleDraw() we are hosed!
        //
        //  so we check if the rect is off in space, and dont use it if so.
        //
        if (poi->hwnd)
        {
            GetClientRect(poi->hwnd, &rc);

            IntersectRect(&rc,&rc,&poi->rcActivate);

            if (IsRectEmpty(&rc))
            {
                DPRINTF(("OleActivate: rectangle specifed is not valid"));
                SetRectEmpty(&poi->rcActivate);
            }
        }

        if (IsRectEmpty(&poi->rcActivate))
        {
            DPRINTF(("OleActivate: stupid ole app!!!"));
        }

        //
        // Shove it in the registry
        //

        {
            RegSetGetData(poi, TRUE);
        }
    }

    return vtblDef.Activate(lpobj, verb, fShow, fActivate, hwnd, lprcBound);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _loadds DllExecute (
LPOLEOBJECT     lpobj,
HANDLE          hCmds,
WORD            reserved)
{
    DPRINTF(("OleExecute(%ls)", GlobalLock(hCmds)));

    return vtblDef.Execute(lpobj, hCmds, reserved);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _loadds DllClose (
LPOLEOBJECT     lpobj)
{
    DPRINTF(("OleClose(%lx)", lpobj));

////DelObj(lpobj);

    return vtblDef.Close(lpobj);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _loadds DllUpdate (
LPOLEOBJECT     lpobj)
{
    DPRINTF(("OleUpdate()"));

    return vtblDef.Update(lpobj);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _loadds DllReconnect (
LPOLEOBJECT     lpobj)
{
    DPRINTF(("OleReconnect()"));

    return vtblDef.Reconnect(lpobj);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _loadds DllObjectConvert (
LPOLEOBJECT     lpobj,
LPSTR           szProtocol,
LPOLECLIENT     lpClient,
LHCLIENTDOC     lhClientDoc,
LPSTR           szObjName,
LPOLEOBJECT FAR*lplpobj)
{
    OLESTATUS err;

    DPRINTF(("OleObjectConvert(%ls,%ls)", szProtocol, szObjName));

    err = vtblDef.ObjectConvert(lpobj, szProtocol, lpClient, lhClientDoc, szObjName, lplpobj);

    if (err <= OLE_WAIT_FOR_RELEASE)
        NewObj(*lplpobj);

    return err;
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _loadds DllGetLinkUpdateOptions (
LPOLEOBJECT     lpobj,
OLEOPT_UPDATE FAR *lpoleopt)
{
    DPRINTF(("OleGetLinkUpdateOptions()"));

    return vtblDef.GetLinkUpdateOptions(lpobj, lpoleopt);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _loadds DllSetLinkUpdateOptions (
LPOLEOBJECT     lpobj,
OLEOPT_UPDATE   oleopt)
{
    DPRINTF(("OleSetLinkUpdateOptions()"));

    return vtblDef.SetLinkUpdateOptions(lpobj, oleopt);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _loadds DllRename (
LPOLEOBJECT     lpobj,
LPSTR           szName)
{
    DPRINTF(("OleRename(%ls)", szName));

    return vtblDef.Rename(lpobj, szName);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _loadds DllQueryName (
LPOLEOBJECT     lpobj,
LPSTR           szObjName,
WORD FAR *      lpwSize)
{
    DPRINTF(("OleQueryName(%ls)", szObjName));

    return vtblDef.QueryName(lpobj, szObjName, lpwSize);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _loadds DllQueryType (
LPOLEOBJECT     lpobj,
LPLONG          lpType)
{
    DPRINTF(("OleQueryType()"));

    return vtblDef.QueryType(lpobj, lpType);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _loadds DllQueryBounds (
LPOLEOBJECT     lpobj,
LPRECT          lprc)
{
    DPRINTF(("OleQueryBounds()"));

    return vtblDef.QueryBounds(lpobj, lprc);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _loadds DllQuerySize (
LPOLEOBJECT     lpobj,
DWORD FAR *     lpdwSize)
{
    DPRINTF(("OleQuerySize()"));

    return vtblDef.QuerySize(lpobj, lpdwSize);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _loadds DllQueryOpen (
LPOLEOBJECT     lpobj)
{
    DPRINTF(("OleQueryOpen()"));

    return vtblDef.QueryOpen(lpobj);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _loadds DllQueryOutOfDate (
LPOLEOBJECT     lpobj)
{
    DPRINTF(("OleQueryOutOfDate()"));

    return vtblDef.QueryOutOfDate(lpobj);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _loadds DllQueryReleaseStatus (
LPOLEOBJECT     lpobj)
{
    DPRINTF(("OleQueryReleaseStatus()"));

    return vtblDef.QueryReleaseStatus(lpobj);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _loadds DllQueryReleaseError (
LPOLEOBJECT     lpobj)
{
    DPRINTF(("OleQueryReleaseError()"));

    return vtblDef.QueryReleaseError(lpobj);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _loadds DllRequestData (
LPOLEOBJECT     lpobj,
OLECLIPFORMAT   cf)
{
    DPRINTF(("OleRequestData(%d)", cf));

    return vtblDef.RequestData(lpobj, cf);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _loadds DllObjectLong (
LPOLEOBJECT     lpobj,
WORD            w,
LPLONG          lpl)
{
    DPRINTF(("OleObjectLong()"));

    return vtblDef.ObjectLong(lpobj, w, lpl);
}

/****************************************************************************
****************************************************************************/

OLE_RELEASE_METHOD  FAR PASCAL _loadds DllQueryReleaseMethod (
LPOLEOBJECT     lpobj)
{
    DPRINTF(("OleQueryReleaseMethod()"));

    return vtblDef.QueryReleaseMethod(lpobj);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _loadds DllChangeData (
LPOLEOBJECT     lpobj,
HANDLE          h,
LPOLECLIENT     lpClient,
BOOL            f)
{
    DPRINTF(("OleChangeData()"));

    return vtblDef.ChangeData(lpobj, h, lpClient, f);
}

///////////////////////////////////////////////////////////////////////////////
//
//  DEBUG STUFF
//
///////////////////////////////////////////////////////////////////////////////

#ifdef DEBUG

void FAR cdecl dprintf(LPSTR szFormat, ...)
{
    char ach[128];

    extern FAR PASCAL OutputDebugStr(LPSTR);

    lstrcpy(ach, "MCIOLE: ");
    wvsprintf(ach + 8,szFormat,(LPSTR)(&szFormat+1));
    lstrcat(ach,"\r\n");

    OutputDebugString(ach);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\mciole\shellapi.h ===
/*****************************************************************************\
*                                                                             *
* shellapi.h -  SHELL.DLL functions, types, and definitions                   *
*                                                                             *
*               Copyright (c) 1992, Microsoft Corp.  All rights reserved      *
*                                                                             *
\*****************************************************************************/

#ifndef _INC_SHELLAPI
#define _INC_SHELLAPI

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

/* If included with Windows 3.0 windows.h: define 3.1-compatible types */

#ifndef _INC_WINDOWS

#define HDROP   HANDLE
#define WINAPI  FAR PASCAL
#define LPCSTR  LPSTR
#define UINT    WORD

#else

DECLARE_HANDLE(HDROP);

#endif

/* return codes from Registration functions */
#define ERROR_SUCCESS           0L
#define ERROR_BADDB             1L
#define ERROR_BADKEY            2L
#define ERROR_CANTOPEN          3L
#define ERROR_CANTREAD          4L
#define ERROR_CANTWRITE         5L
#define ERROR_OUTOFMEMORY       6L
#define ERROR_INVALID_PARAMETER 7L
#define ERROR_ACCESS_DENIED     8L

#define REG_SZ			1	    /* string type */

#define HKEY_CLASSES_ROOT	1

typedef DWORD HKEY;
typedef HKEY FAR* PHKEY;

LONG WINAPI RegOpenKey(HKEY, LPCSTR, HKEY FAR*);
LONG WINAPI RegCreateKey(HKEY, LPCSTR, HKEY FAR*);
LONG WINAPI RegCloseKey(HKEY);
LONG WINAPI RegDeleteKey(HKEY, LPCSTR);
LONG WINAPI RegSetValue(HKEY, LPCSTR, DWORD, LPCSTR, DWORD);
LONG WINAPI RegQueryValue(HKEY, LPCSTR, LPSTR, LONG FAR*);
LONG WINAPI RegEnumKey(HKEY, DWORD, LPSTR, DWORD);

UINT WINAPI DragQueryFile(HDROP, UINT, LPSTR, UINT);
BOOL WINAPI DragQueryPoint(HDROP, POINT FAR*);
void WINAPI DragFinish(HDROP);
void WINAPI DragAcceptFiles(HWND, BOOL);

HICON WINAPI ExtractIcon(HINSTANCE hInst, LPCSTR lpszExeFileName, UINT nIconIndex);

/* error values for ShellExecute() beyond the regular WinExec() codes */
#define SE_ERR_SHARE            26
#define SE_ERR_ASSOCINCOMPLETE  27
#define SE_ERR_DDETIMEOUT       28
#define SE_ERR_DDEFAIL          29
#define SE_ERR_DDEBUSY          30
#define SE_ERR_NOASSOC          31

HINSTANCE WINAPI ShellExecute(HWND hwnd, LPCSTR lpOperation, LPCSTR lpFile, LPCSTR lpParameters, LPCSTR lpDirectory, int iShowCmd);
HINSTANCE WINAPI FindExecutable(LPCSTR lpFile, LPCSTR lpDirectory, LPSTR lpResult);
				 

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()
#endif  /* RC_INVOKED */

#endif  /* _INC_SHELLAPI */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\mciole\ole.h ===
/*****************************************************************************\
*                                                                             *
* ole.h -       Object Linking and Embedding functions, types, and definitions*
*                                                                             *
*               Version 1.0                                                   *
*                                                                             *
*               NOTE: windows.h must be #included first                       *
*                                                                             *
*               Copyright (c) 1990-1992, Microsoft Corp.  All rights reserved.*
*                                                                             *
\*****************************************************************************/

#ifndef _INC_OLE
#define _INC_OLE

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* !RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

#ifndef WINAPI          /* If not included with 3.1 headers... */
#define WINAPI      FAR PASCAL
#define CALLBACK    FAR PASCAL
#define LPCSTR      LPSTR
#define UINT        WORD
#define LPARAM      LONG
#define WPARAM      WORD
#define LRESULT     LONG
#define HMODULE     HANDLE
#define HINSTANCE   HANDLE
#define HLOCAL      HANDLE
#define HGLOBAL     HANDLE
#endif  /* _INC_WINDOWS */

#ifdef STRICT
#define OLE_LPCSTR  LPCSTR
#define OLE_CONST   const
#else   /* STRICT */
#define OLE_LPCSTR  LPSTR
#define OLE_CONST
#endif /* !STRICT */


/* Object types */
#define OT_LINK             1L
#define OT_EMBEDDED         2L
#define OT_STATIC           3L

/* activate verbs */
#define OLEVERB_PRIMARY     0

/* target device info structure */
typedef struct _OLETARGETDEVICE
{
    UINT otdDeviceNameOffset;
    UINT otdDriverNameOffset;
    UINT otdPortNameOffset;
    UINT otdExtDevmodeOffset;
    UINT otdExtDevmodeSize;
    UINT otdEnvironmentOffset;
    UINT otdEnvironmentSize;
    BYTE otdData[1];
} OLETARGETDEVICE;
typedef OLETARGETDEVICE FAR* LPOLETARGETDEVICE;

/* flags used in some methods */
#define OF_SET              0x0001
#define OF_GET              0x0002
#define OF_HANDLER          0x0004

/* return codes for OLE functions */
typedef enum
{
    OLE_OK,                     /* 0   Function operated correctly             */

    OLE_WAIT_FOR_RELEASE,       /* 1   Command has been initiated, client      */
                                /*     must wait for release. keep dispatching */
                                /*     messages till OLE_RELESE in callback    */

    OLE_BUSY,                   /* 2   Tried to execute a method while another */
                                /*     method is in progress.                  */

    OLE_ERROR_PROTECT_ONLY,     /* 3   Ole APIs are called in real mode        */
    OLE_ERROR_MEMORY,           /* 4   Could not alloc or lock memory          */
    OLE_ERROR_STREAM,           /* 5  (OLESTREAM) stream error                 */
    OLE_ERROR_STATIC,           /* 6   Non static object expected              */
    OLE_ERROR_BLANK,            /* 7   Critical data missing                   */
    OLE_ERROR_DRAW,             /* 8   Error while drawing                     */
    OLE_ERROR_METAFILE,         /* 9   Invalid metafile                        */
    OLE_ERROR_ABORT,            /* 10  Client chose to abort metafile drawing  */
    OLE_ERROR_CLIPBOARD,        /* 11  Failed to get/set clipboard data        */
    OLE_ERROR_FORMAT,           /* 12  Requested format is not available       */
    OLE_ERROR_OBJECT,           /* 13  Not a valid object                      */
    OLE_ERROR_OPTION,           /* 14  Invalid option(link update / render)    */
    OLE_ERROR_PROTOCOL,         /* 15  Invalid protocol                        */
    OLE_ERROR_ADDRESS,          /* 16  One of the pointers is invalid          */
    OLE_ERROR_NOT_EQUAL,        /* 17  Objects are not equal                   */
    OLE_ERROR_HANDLE,           /* 18  Invalid handle encountered              */
    OLE_ERROR_GENERIC,          /* 19  Some general error                      */
    OLE_ERROR_CLASS,            /* 20  Invalid class                           */
    OLE_ERROR_SYNTAX,           /* 21  Command syntax is invalid               */
    OLE_ERROR_DATATYPE,         /* 22  Data format is not supported            */
    OLE_ERROR_PALETTE,          /* 23  Invalid color palette                   */
    OLE_ERROR_NOT_LINK,         /* 24  Not a linked object                     */
    OLE_ERROR_NOT_EMPTY,        /* 25  Client doc contains objects.            */
    OLE_ERROR_SIZE,             /* 26  Incorrect buffer size passed to the api */
                                /*     that places some string in caller's     */
                                /*     buffer                                  */

    OLE_ERROR_DRIVE,            /* 27  Drive letter in doc name is invalid     */
    OLE_ERROR_NETWORK,          /* 28  Failed to establish connection to a     */
                                /*     network share on which the document     */
                                /*     is located                              */

    OLE_ERROR_NAME,             /* 29  Invalid name(doc name, object name),    */
                                /*     etc.. passed to the APIs                */

    OLE_ERROR_TEMPLATE,         /* 30  Server failed to load template          */
    OLE_ERROR_NEW,              /* 31  Server failed to create new doc         */
    OLE_ERROR_EDIT,             /* 32  Server failed to create embedded        */
                                /*     instance                                */
    OLE_ERROR_OPEN,             /* 33  Server failed to open document,         */
                                /*     possible invalid link                   */

    OLE_ERROR_NOT_OPEN,         /* 34  Object is not open for editing          */
    OLE_ERROR_LAUNCH,           /* 35  Failed to launch server                 */
    OLE_ERROR_COMM,             /* 36  Failed to communicate with server       */
    OLE_ERROR_TERMINATE,        /* 37  Error in termination                    */
    OLE_ERROR_COMMAND,          /* 38  Error in execute                        */
    OLE_ERROR_SHOW,             /* 39  Error in show                           */
    OLE_ERROR_DOVERB,           /* 40  Error in sending do verb, or invalid    */
                                /*     verb                                    */
    OLE_ERROR_ADVISE_NATIVE,    /* 41  Item could be missing                   */
    OLE_ERROR_ADVISE_PICT,      /* 42  Item could be missing or server doesn't */
                                /*     this format.                            */

    OLE_ERROR_ADVISE_RENAME,    /* 43  Server doesn't support rename           */
    OLE_ERROR_POKE_NATIVE,      /* 44  Failure of poking native data to server */
    OLE_ERROR_REQUEST_NATIVE,   /* 45  Server failed to render native data     */
    OLE_ERROR_REQUEST_PICT,     /* 46  Server failed to render presentation    */
                                /*     data                                    */
    OLE_ERROR_SERVER_BLOCKED,   /* 47  Trying to block a blocked server or     */
                                /*     trying to revoke a blocked server       */
                                /*     or document                             */

    OLE_ERROR_REGISTRATION,     /* 48  Server is not registered in regestation */
                                /*     data base                               */
    OLE_ERROR_ALREADY_REGISTERED,/*49  Trying to register same doc multiple    */
                                 /*    times                                   */
    OLE_ERROR_TASK,             /* 50  Server or client task is invalid        */
    OLE_ERROR_OUTOFDATE,        /* 51  Object is out of date                   */
    OLE_ERROR_CANT_UPDATE_CLIENT,/* 52 Embed doc's client doesn't accept       */
                                /*     updates                                 */
    OLE_ERROR_UPDATE,           /* 53  erorr while trying to update            */
    OLE_ERROR_SETDATA_FORMAT,   /* 54  Server app doesn't understand the       */
                                /*     format given to its SetData method      */
    OLE_ERROR_STATIC_FROM_OTHER_OS,/* 55 trying to load a static object created */
                                   /*    on another Operating System           */

    /*  Following are warnings */
    OLE_WARN_DELETE_DATA = 1000 /*     Caller must delete the data when he is  */
                                /*     done with it.                           */
} OLESTATUS;



/* Codes for CallBack events */
typedef enum
{
    OLE_CHANGED,            /* 0                                             */
    OLE_SAVED,              /* 1                                             */
    OLE_CLOSED,             /* 2                                             */
    OLE_RENAMED,            /* 3                                             */
    OLE_QUERY_PAINT,        /* 4  Interruptible paint support                */
    OLE_RELEASE,            /* 5  Object is released(asynchronous operation  */
                            /*    is completed)                              */
    OLE_QUERY_RETRY         /* 6  Query for retry when server sends busy ACK */
} OLE_NOTIFICATION;

typedef enum
{
    OLE_NONE,               /* 0  no method active                           */
    OLE_DELETE,             /* 1  object delete                              */
    OLE_LNKPASTE,           /* 2  PasteLink(auto reconnect)                  */
    OLE_EMBPASTE,           /* 3  paste(and update)                          */
    OLE_SHOW,               /* 4  Show                                       */
    OLE_RUN,                /* 5  Run                                        */
    OLE_ACTIVATE,           /* 6  Activate                                   */
    OLE_UPDATE,             /* 7  Update                                     */
    OLE_CLOSE,              /* 8  Close                                      */
    OLE_RECONNECT,          /* 9  Reconnect                                  */
    OLE_SETUPDATEOPTIONS,   /* 10 setting update options                     */
    OLE_SERVERUNLAUNCH,     /* 11 server is being unlaunched                 */
    OLE_LOADFROMSTREAM,     /* 12 LoadFromStream(auto reconnect)             */
    OLE_SETDATA,            /* 13 OleSetData                                 */
    OLE_REQUESTDATA,        /* 14 OleRequestData                             */
    OLE_OTHER,              /* 15 other misc async operations                */
    OLE_CREATE,             /* 16 create                                     */
    OLE_CREATEFROMTEMPLATE, /* 17 CreatefromTemplate                         */
    OLE_CREATELINKFROMFILE, /* 18 CreateLinkFromFile                         */
    OLE_COPYFROMLNK,        /* 19 CopyFromLink(auto reconnect)               */
    OLE_CREATEFROMFILE,     /* 20 CreateFromFile                             */
    OLE_CREATEINVISIBLE     /* 21 CreateInvisible                            */
} OLE_RELEASE_METHOD;

/* rendering options */
typedef enum
{
    olerender_none, 
    olerender_draw, 
    olerender_format 
} OLEOPT_RENDER;

/* standard clipboard format type */
typedef WORD OLECLIPFORMAT;

/* Link update options */
typedef enum
{
    oleupdate_always,
    oleupdate_onsave,
#ifndef OLE_INTERNAL
    oleupdate_oncall
#else
    oleupdate_oncall,
    oleupdate_onclose
#endif  /* OLE_INTERNAL */
} OLEOPT_UPDATE;

typedef HANDLE  HOBJECT;
typedef LONG    LHSERVER;
typedef LONG    LHCLIENTDOC;
typedef LONG    LHSERVERDOC;

typedef struct _OLEOBJECT FAR*  LPOLEOBJECT;
typedef struct _OLESTREAM FAR*  LPOLESTREAM;
typedef struct _OLECLIENT FAR*  LPOLECLIENT;


#ifndef OLE_INTERNAL
/* object method table definitions. */
typedef struct _OLEOBJECTVTBL
{
    void FAR*      (CALLBACK* QueryProtocol)        (LPOLEOBJECT, OLE_LPCSTR);
    OLESTATUS      (CALLBACK* Release)              (LPOLEOBJECT);
    OLESTATUS      (CALLBACK* Show)                 (LPOLEOBJECT, BOOL);
    OLESTATUS      (CALLBACK* DoVerb)               (LPOLEOBJECT, UINT, BOOL, BOOL);
    OLESTATUS      (CALLBACK* GetData)              (LPOLEOBJECT, OLECLIPFORMAT, HANDLE FAR*);
    OLESTATUS      (CALLBACK* SetData)              (LPOLEOBJECT, OLECLIPFORMAT, HANDLE);
    OLESTATUS      (CALLBACK* SetTargetDevice)      (LPOLEOBJECT, HGLOBAL);
    OLESTATUS      (CALLBACK* SetBounds)            (LPOLEOBJECT, OLE_CONST RECT FAR*);
    OLECLIPFORMAT  (CALLBACK* EnumFormats)          (LPOLEOBJECT, OLECLIPFORMAT);
    OLESTATUS      (CALLBACK* SetColorScheme)       (LPOLEOBJECT, OLE_CONST LOGPALETTE FAR*);
    /* Server has to implement only the above methods. */

#ifndef SERVERONLY
    /* Extra methods required for client. */
    OLESTATUS      (CALLBACK* Delete)               (LPOLEOBJECT);
    OLESTATUS      (CALLBACK* SetHostNames)         (LPOLEOBJECT, OLE_LPCSTR, OLE_LPCSTR);
    OLESTATUS      (CALLBACK* SaveToStream)         (LPOLEOBJECT, LPOLESTREAM);
    OLESTATUS      (CALLBACK* Clone)                (LPOLEOBJECT, LPOLECLIENT, LHCLIENTDOC, OLE_LPCSTR, LPOLEOBJECT FAR*);
    OLESTATUS      (CALLBACK* CopyFromLink)         (LPOLEOBJECT, LPOLECLIENT, LHCLIENTDOC, OLE_LPCSTR, LPOLEOBJECT FAR*);
    OLESTATUS      (CALLBACK* Equal)                (LPOLEOBJECT, LPOLEOBJECT);
    OLESTATUS      (CALLBACK* CopyToClipboard)      (LPOLEOBJECT);
    OLESTATUS      (CALLBACK* Draw)                 (LPOLEOBJECT, HDC, OLE_CONST RECT FAR*, OLE_CONST RECT FAR*, HDC);
    OLESTATUS      (CALLBACK* Activate)             (LPOLEOBJECT, UINT, BOOL, BOOL, HWND, OLE_CONST RECT FAR*);
    OLESTATUS      (CALLBACK* Execute)              (LPOLEOBJECT, HGLOBAL, UINT);
    OLESTATUS      (CALLBACK* Close)                (LPOLEOBJECT);
    OLESTATUS      (CALLBACK* Update)               (LPOLEOBJECT);
    OLESTATUS      (CALLBACK* Reconnect)            (LPOLEOBJECT);

    OLESTATUS      (CALLBACK* ObjectConvert)        (LPOLEOBJECT, OLE_LPCSTR, LPOLECLIENT, LHCLIENTDOC, OLE_LPCSTR, LPOLEOBJECT FAR*);
    OLESTATUS      (CALLBACK* GetLinkUpdateOptions) (LPOLEOBJECT, OLEOPT_UPDATE FAR*);
    OLESTATUS      (CALLBACK* SetLinkUpdateOptions) (LPOLEOBJECT, OLEOPT_UPDATE);
    
    OLESTATUS      (CALLBACK* Rename)               (LPOLEOBJECT, OLE_LPCSTR);
    OLESTATUS      (CALLBACK* QueryName)            (LPOLEOBJECT, LPSTR, UINT FAR*);

    OLESTATUS      (CALLBACK* QueryType)            (LPOLEOBJECT, LONG FAR*);
    OLESTATUS      (CALLBACK* QueryBounds)          (LPOLEOBJECT, RECT FAR*);
    OLESTATUS      (CALLBACK* QuerySize)            (LPOLEOBJECT, DWORD FAR*);
    OLESTATUS      (CALLBACK* QueryOpen)            (LPOLEOBJECT);
    OLESTATUS      (CALLBACK* QueryOutOfDate)       (LPOLEOBJECT);

    OLESTATUS      (CALLBACK* QueryReleaseStatus)   (LPOLEOBJECT);
    OLESTATUS      (CALLBACK* QueryReleaseError)    (LPOLEOBJECT);
    OLE_RELEASE_METHOD (CALLBACK* QueryReleaseMethod)(LPOLEOBJECT);

    OLESTATUS      (CALLBACK* RequestData)          (LPOLEOBJECT, OLECLIPFORMAT);
    OLESTATUS      (CALLBACK* ObjectLong)           (LPOLEOBJECT, UINT, LONG FAR*);
    
/* This method is internal only */
    OLESTATUS      (CALLBACK* ChangeData)           (LPOLEOBJECT, HANDLE, LPOLECLIENT, BOOL);
#endif  /* !SERVERONLY */
} OLEOBJECTVTBL;
typedef  OLEOBJECTVTBL FAR* LPOLEOBJECTVTBL;

typedef struct _OLEOBJECT
{
    LPOLEOBJECTVTBL    lpvtbl;
} OLEOBJECT;
#endif  /* !OLE_NTERNAL */

/* ole client definitions */
typedef struct _OLECLIENTVTBL
{
    int (CALLBACK* CallBack)(LPOLECLIENT, OLE_NOTIFICATION, LPOLEOBJECT);
} OLECLIENTVTBL;

typedef  OLECLIENTVTBL FAR*  LPOLECLIENTVTBL;

typedef struct _OLECLIENT
{
    LPOLECLIENTVTBL   lpvtbl;
} OLECLIENT;

/* Stream definitions */
typedef struct _OLESTREAMVTBL
{
    DWORD (CALLBACK* Get)(LPOLESTREAM, void FAR*, DWORD);
    DWORD (CALLBACK* Put)(LPOLESTREAM, OLE_CONST void FAR*, DWORD);
} OLESTREAMVTBL;
typedef  OLESTREAMVTBL FAR*  LPOLESTREAMVTBL;

typedef struct _OLESTREAM
{
    LPOLESTREAMVTBL      lpstbl;
} OLESTREAM;

/* Public Function Prototypes */
OLESTATUS   WINAPI  OleDelete(LPOLEOBJECT);
OLESTATUS   WINAPI  OleRelease(LPOLEOBJECT);
OLESTATUS   WINAPI  OleSaveToStream(LPOLEOBJECT, LPOLESTREAM);
OLESTATUS   WINAPI  OleEqual(LPOLEOBJECT, LPOLEOBJECT );
OLESTATUS   WINAPI  OleCopyToClipboard(LPOLEOBJECT);
OLESTATUS   WINAPI  OleSetHostNames(LPOLEOBJECT, LPCSTR, LPCSTR);
OLESTATUS   WINAPI  OleSetTargetDevice(LPOLEOBJECT, HGLOBAL);
OLESTATUS   WINAPI  OleSetBounds(LPOLEOBJECT, const RECT FAR*);
OLESTATUS   WINAPI  OleSetColorScheme(LPOLEOBJECT, const LOGPALETTE FAR*);
OLESTATUS   WINAPI  OleQueryBounds(LPOLEOBJECT, RECT FAR*);
OLESTATUS   WINAPI  OleQuerySize(LPOLEOBJECT, DWORD FAR*);
OLESTATUS   WINAPI  OleDraw(LPOLEOBJECT, HDC, const RECT FAR*, const RECT FAR*, HDC);
OLESTATUS   WINAPI  OleQueryOpen(LPOLEOBJECT);
OLESTATUS   WINAPI  OleActivate(LPOLEOBJECT, UINT, BOOL, BOOL, HWND, const RECT FAR*);
OLESTATUS   WINAPI  OleExecute(LPOLEOBJECT, HGLOBAL, UINT);
OLESTATUS   WINAPI  OleClose(LPOLEOBJECT);
OLESTATUS   WINAPI  OleUpdate(LPOLEOBJECT);
OLESTATUS   WINAPI  OleReconnect(LPOLEOBJECT);
OLESTATUS   WINAPI  OleGetLinkUpdateOptions(LPOLEOBJECT, OLEOPT_UPDATE FAR*);
OLESTATUS   WINAPI  OleSetLinkUpdateOptions(LPOLEOBJECT, OLEOPT_UPDATE);
void FAR*   WINAPI  OleQueryProtocol(LPOLEOBJECT, LPCSTR);

/* Routines related to asynchronous operations. */
OLESTATUS   WINAPI  OleQueryReleaseStatus(LPOLEOBJECT);
OLESTATUS   WINAPI  OleQueryReleaseError(LPOLEOBJECT);
OLE_RELEASE_METHOD WINAPI OleQueryReleaseMethod(LPOLEOBJECT);

OLESTATUS   WINAPI  OleQueryType(LPOLEOBJECT, LONG FAR*);

/* LOWORD is major version, HIWORD is minor version */
DWORD       WINAPI  OleQueryClientVersion(void);
DWORD       WINAPI  OleQueryServerVersion(void);

/* Converting to format (as in clipboard): */
OLECLIPFORMAT  WINAPI  OleEnumFormats(LPOLEOBJECT, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleGetData(LPOLEOBJECT, OLECLIPFORMAT, HANDLE FAR*);
OLESTATUS   WINAPI  OleSetData(LPOLEOBJECT, OLECLIPFORMAT, HANDLE);
OLESTATUS   WINAPI  OleQueryOutOfDate(LPOLEOBJECT);
OLESTATUS   WINAPI  OleRequestData(LPOLEOBJECT, OLECLIPFORMAT);

/* Query apis for creation from clipboard */
OLESTATUS   WINAPI  OleQueryLinkFromClip(LPCSTR, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleQueryCreateFromClip(LPCSTR, OLEOPT_RENDER, OLECLIPFORMAT);

/* Object creation functions */
OLESTATUS   WINAPI  OleCreateFromClip(LPCSTR, LPOLECLIENT, LHCLIENTDOC, LPCSTR,  LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleCreateLinkFromClip(LPCSTR, LPOLECLIENT, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleCreateFromFile(LPCSTR, LPOLECLIENT, LPCSTR, LPCSTR, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleCreateLinkFromFile(LPCSTR, LPOLECLIENT, LPCSTR, LPCSTR, LPCSTR, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleLoadFromStream(LPOLESTREAM, LPCSTR, LPOLECLIENT, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*);
OLESTATUS   WINAPI  OleCreate(LPCSTR, LPOLECLIENT, LPCSTR, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleCreateInvisible(LPCSTR, LPOLECLIENT, LPCSTR, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT, BOOL);
OLESTATUS   WINAPI  OleCreateFromTemplate(LPCSTR, LPOLECLIENT, LPCSTR, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleClone(LPOLEOBJECT, LPOLECLIENT, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*);
OLESTATUS   WINAPI  OleCopyFromLink(LPOLEOBJECT, LPCSTR, LPOLECLIENT, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*);
OLESTATUS   WINAPI  OleObjectConvert(LPOLEOBJECT, LPCSTR, LPOLECLIENT, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*);
OLESTATUS   WINAPI  OleRename(LPOLEOBJECT, LPCSTR);
OLESTATUS   WINAPI  OleQueryName(LPOLEOBJECT, LPSTR, UINT FAR*);
OLESTATUS   WINAPI  OleRevokeObject(LPOLECLIENT);
BOOL        WINAPI  OleIsDcMeta(HDC);

/* client document API */
OLESTATUS   WINAPI  OleRegisterClientDoc(LPCSTR, LPCSTR, LONG, LHCLIENTDOC FAR*);
OLESTATUS   WINAPI  OleRevokeClientDoc(LHCLIENTDOC);
OLESTATUS   WINAPI  OleRenameClientDoc(LHCLIENTDOC, LPCSTR);
OLESTATUS   WINAPI  OleRevertClientDoc(LHCLIENTDOC);
OLESTATUS   WINAPI  OleSavedClientDoc(LHCLIENTDOC);
OLESTATUS   WINAPI  OleEnumObjects(LHCLIENTDOC, LPOLEOBJECT FAR*);

/* server usage definitions */
typedef enum {
    OLE_SERVER_MULTI,           /* multiple instances */
    OLE_SERVER_SINGLE           /* single instance(multiple document) */
} OLE_SERVER_USE;

/* Server API */
typedef struct _OLESERVER FAR*  LPOLESERVER;

OLESTATUS   WINAPI  OleRegisterServer(LPCSTR, LPOLESERVER, LHSERVER FAR*, HINSTANCE, OLE_SERVER_USE);
OLESTATUS   WINAPI  OleRevokeServer(LHSERVER);
OLESTATUS   WINAPI  OleBlockServer(LHSERVER);
OLESTATUS   WINAPI  OleUnblockServer(LHSERVER, BOOL FAR*);

/* APIs to keep server open */
OLESTATUS   WINAPI  OleLockServer(LPOLEOBJECT, LHSERVER FAR*);
OLESTATUS   WINAPI  OleUnlockServer(LHSERVER);

/* Server document API */

typedef struct _OLESERVERDOC FAR*  LPOLESERVERDOC;

OLESTATUS   WINAPI  OleRegisterServerDoc(LHSERVER, LPCSTR, LPOLESERVERDOC, LHSERVERDOC FAR*);
OLESTATUS   WINAPI  OleRevokeServerDoc(LHSERVERDOC);
OLESTATUS   WINAPI  OleRenameServerDoc(LHSERVERDOC, LPCSTR);
OLESTATUS   WINAPI  OleRevertServerDoc(LHSERVERDOC);
OLESTATUS   WINAPI  OleSavedServerDoc(LHSERVERDOC);

typedef struct _OLESERVERVTBL
{
    OLESTATUS (CALLBACK* Open)  (LPOLESERVER, LHSERVERDOC, OLE_LPCSTR, LPOLESERVERDOC FAR*);
                                    /* long handle to doc(privtate to DLL)  */
                                    /* lp to OLESERVER                      */
                                    /* document name                        */
                                    /* place holder for returning oledoc.   */

    OLESTATUS (CALLBACK* Create)(LPOLESERVER, LHSERVERDOC, OLE_LPCSTR, OLE_LPCSTR, LPOLESERVERDOC FAR*);
                                    /* long handle to doc(privtate to DLL)  */
                                    /* lp to OLESERVER                      */
                                    /* lp class name                        */
                                    /* lp doc name                          */
                                    /* place holder for returning oledoc.   */

    OLESTATUS (CALLBACK* CreateFromTemplate)(LPOLESERVER, LHSERVERDOC, OLE_LPCSTR, OLE_LPCSTR, OLE_LPCSTR, LPOLESERVERDOC FAR*);
                                    /* long handle to doc(privtate to DLL)  */
                                    /* lp to OLESERVER                      */
                                    /* lp class name                        */
                                    /* lp doc name                          */
                                    /* lp template name                     */
                                    /* place holder for returning oledoc.   */

    OLESTATUS (CALLBACK* Edit)  (LPOLESERVER, LHSERVERDOC, OLE_LPCSTR, OLE_LPCSTR, LPOLESERVERDOC FAR*);
                                    /* long handle to doc(privtate to DLL)  */
                                    /* lp to OLESERVER                      */
                                    /* lp class name                        */
                                    /* lp doc name                          */
                                    /* place holder for returning oledoc.   */

    OLESTATUS (CALLBACK* Exit)  (LPOLESERVER);
                                    /* lp OLESERVER                         */

    OLESTATUS (CALLBACK* Release)  (LPOLESERVER);
                                    /* lp OLESERVER                         */

    OLESTATUS (CALLBACK* Execute)(LPOLESERVER, HGLOBAL);
                                    /* lp OLESERVER                         */
                                    /* handle to command strings            */
} OLESERVERVTBL;
typedef  OLESERVERVTBL FAR*  LPOLESERVERVTBL;

typedef struct _OLESERVER
{
    LPOLESERVERVTBL    lpvtbl;
} OLESERVER;

typedef struct _OLESERVERDOCVTBL
{
    OLESTATUS (CALLBACK* Save)      (LPOLESERVERDOC);
    OLESTATUS (CALLBACK* Close)     (LPOLESERVERDOC);
    OLESTATUS (CALLBACK* SetHostNames)(LPOLESERVERDOC, OLE_LPCSTR, OLE_LPCSTR);
    OLESTATUS (CALLBACK* SetDocDimensions)(LPOLESERVERDOC, OLE_CONST RECT FAR*);
    OLESTATUS (CALLBACK* GetObject) (LPOLESERVERDOC, OLE_LPCSTR, LPOLEOBJECT FAR*, LPOLECLIENT);
    OLESTATUS (CALLBACK* Release)   (LPOLESERVERDOC);
    OLESTATUS (CALLBACK* SetColorScheme)(LPOLESERVERDOC, OLE_CONST LOGPALETTE FAR*);
    OLESTATUS (CALLBACK* Execute)  (LPOLESERVERDOC, HGLOBAL);
} OLESERVERDOCVTBL;
typedef  OLESERVERDOCVTBL FAR*  LPOLESERVERDOCVTBL;

typedef struct _OLESERVERDOC
{
    LPOLESERVERDOCVTBL lpvtbl;
} OLESERVERDOC;

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()
#endif  /* !RC_INVOKED */

#endif  /* !_INC_OLE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\mciole\mciole.h ===
///////////////////////////////////////////////////////////////////////////////
//
//  these are the default OLE functions (exported from OLECLI.DLL)
//
///////////////////////////////////////////////////////////////////////////////
extern OLESTATUS FAR PASCAL DefLoadFromStream (LPOLESTREAM, LPSTR, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, LONG, ATOM, OLECLIPFORMAT);
extern OLESTATUS FAR PASCAL DefCreateFromClip (LPSTR, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT, LONG);
extern OLESTATUS FAR PASCAL DefCreateLinkFromClip (LPSTR, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);
extern OLESTATUS FAR PASCAL DefCreateFromTemplate (LPSTR, LPOLECLIENT, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);
extern OLESTATUS FAR PASCAL DefCreate (LPSTR, LPOLECLIENT, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);
extern OLESTATUS FAR PASCAL DefCreateFromFile (LPSTR, LPOLECLIENT, LPSTR, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);
extern OLESTATUS FAR PASCAL DefCreateLinkFromFile (LPSTR, LPOLECLIENT, LPSTR, LPSTR, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);

///////////////////////////////////////////////////////////////////////////////
//
//  these are our OLE handlers (defined in this file)
//
///////////////////////////////////////////////////////////////////////////////

// Server has to implement only the following methods.
LPVOID          FAR PASCAL _loadds DllQueryProtocol         (LPOLEOBJECT, LPSTR);
OLESTATUS       FAR PASCAL _loadds DllRelease               (LPOLEOBJECT);
OLESTATUS       FAR PASCAL _loadds DllShow                  (LPOLEOBJECT, BOOL);
OLESTATUS       FAR PASCAL _loadds DllDoVerb                (LPOLEOBJECT, WORD, BOOL, BOOL);
OLESTATUS       FAR PASCAL _loadds DllGetData               (LPOLEOBJECT, OLECLIPFORMAT, LPHANDLE);
OLESTATUS       FAR PASCAL _loadds DllSetData               (LPOLEOBJECT, OLECLIPFORMAT, HANDLE);
OLESTATUS       FAR PASCAL _loadds DllSetTargetDevice       (LPOLEOBJECT, HANDLE);
OLESTATUS       FAR PASCAL _loadds DllSetBounds             (LPOLEOBJECT, LPRECT);
OLECLIPFORMAT   FAR PASCAL _loadds DllEnumFormats           (LPOLEOBJECT, OLECLIPFORMAT);
OLESTATUS       FAR PASCAL _loadds DllSetColorScheme        (LPOLEOBJECT, LPLOGPALETTE);

// Extra methods required for client.
OLESTATUS       FAR PASCAL _loadds DllDelete                (LPOLEOBJECT);
OLESTATUS       FAR PASCAL _loadds DllSetHostNames          (LPOLEOBJECT, LPSTR, LPSTR);
OLESTATUS       FAR PASCAL _loadds DllSaveToStream          (LPOLEOBJECT, LPOLESTREAM);
OLESTATUS       FAR PASCAL _loadds DllClone                 (LPOLEOBJECT, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *);
OLESTATUS       FAR PASCAL _loadds DllCopyFromLink          (LPOLEOBJECT, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *);
OLESTATUS       FAR PASCAL _loadds DllEqual                 (LPOLEOBJECT, LPOLEOBJECT);
OLESTATUS       FAR PASCAL _loadds DllCopyToClipboard       (LPOLEOBJECT);
OLESTATUS       FAR PASCAL _loadds DllDraw                  (LPOLEOBJECT, HDC, LPRECT, LPRECT, HDC);
OLESTATUS       FAR PASCAL _loadds DllActivate              (LPOLEOBJECT, WORD, BOOL, BOOL, HWND, LPRECT);
OLESTATUS       FAR PASCAL _loadds DllExecute               (LPOLEOBJECT, HANDLE, WORD);
OLESTATUS       FAR PASCAL _loadds DllClose                 (LPOLEOBJECT);
OLESTATUS       FAR PASCAL _loadds DllUpdate                (LPOLEOBJECT);
OLESTATUS       FAR PASCAL _loadds DllReconnect             (LPOLEOBJECT);
OLESTATUS       FAR PASCAL _loadds DllObjectConvert         (LPOLEOBJECT, LPSTR, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *);
OLESTATUS       FAR PASCAL _loadds DllGetLinkUpdateOptions  (LPOLEOBJECT, OLEOPT_UPDATE FAR *);
OLESTATUS       FAR PASCAL _loadds DllSetLinkUpdateOptions  (LPOLEOBJECT, OLEOPT_UPDATE);
OLESTATUS       FAR PASCAL _loadds DllRename                (LPOLEOBJECT, LPSTR);
OLESTATUS       FAR PASCAL _loadds DllQueryName             (LPOLEOBJECT, LPSTR, WORD FAR *);
OLESTATUS       FAR PASCAL _loadds DllQueryType             (LPOLEOBJECT, LPLONG);
OLESTATUS       FAR PASCAL _loadds DllQueryBounds           (LPOLEOBJECT, LPRECT);
OLESTATUS       FAR PASCAL _loadds DllQuerySize             (LPOLEOBJECT, DWORD FAR *);
OLESTATUS       FAR PASCAL _loadds DllQueryOpen             (LPOLEOBJECT);
OLESTATUS       FAR PASCAL _loadds DllQueryOutOfDate        (LPOLEOBJECT);
OLESTATUS       FAR PASCAL _loadds DllQueryReleaseStatus    (LPOLEOBJECT);
OLESTATUS       FAR PASCAL _loadds DllQueryReleaseError     (LPOLEOBJECT);
OLESTATUS       FAR PASCAL _loadds DllRequestData           (LPOLEOBJECT, OLECLIPFORMAT);
OLESTATUS       FAR PASCAL _loadds DllObjectLong            (LPOLEOBJECT, WORD, LPLONG);
OLE_RELEASE_METHOD  FAR PASCAL _loadds DllQueryReleaseMethod(LPOLEOBJECT);

// This method is internal only 
OLESTATUS       FAR PASCAL _loadds DllChangeData            (LPOLEOBJECT, HANDLE, LPOLECLIENT, BOOL);

///////////////////////////////////////////////////////////////////////////////
//
//  DEBUG STUFF
//
///////////////////////////////////////////////////////////////////////////////

#ifdef DEBUG
    extern void FAR cdecl dprintf(LPSTR, ...);

    #define DPRINTF(x) dprintf x
#else
    #define DPRINTF(x)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\mmsystem\bwinexec.asm ===
PAGE 58,132
;******************************************************************************
TITLE bwinexec.asm - WinExec with binary command line
;******************************************************************************
;
;   Copyright (C) Microsoft Corporation 1985-1990. All rights reserved.
;
;   Title:      bwinexec.asm - Exec. an app. with a block of binary data.
;
;   Version:    1.00
;
;   Date:       14-Mar-1990 (from winexec)
;
;   Author:     ROBWI
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE     REV            DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;   14-Mar-1990 RJW Modified Toddla's WinExec code to take a binary command
;                   block instead of an ascii command line
;
;==============================================================================

?PLM=1
?WIN=0
PMODE=1

.xlist
include cmacros.inc
include windows.inc
.list

                externFP        LoadModule

EXECBLOCK struc
envseg          dw      ?    ; seg addr of environment
lpcmdline       dd      ?    ; pointer to command block (normally ascii str)
lpfcb1          dd      ?    ; default fcb at 5C
lpfcb2          dd      ?    ; default fcb at 6C
EXECBLOCK ends

; The following structure should be used to access high and low
; words of a DWORD.  This means that "word ptr foo[2]" -> "foo.hi".

LONG    struc
lo      dw      ?
hi      dw      ?
LONG    ends

ifndef SEGNAME
    SEGNAME equ <_TEXT>
endif

createSeg %SEGNAME, CodeSeg, word, public, CODE

sBegin CodeSeg
        assumes cs,CodeSeg
        assumes es,nothing
        assumes ds,nothing

;****************************************************************************
;
;   @doc    INTERNAL    MMSYSTEMS
;
;   @api    HANDLE | BWinExec | This function executes the Windows
;           or non-Windows application identified by the <p lpCmdLine>
;           parameter. The <p nCmdShow> parameter specifies the initial
;           state of the applications main window when it is created.
;   
;     @parm   LPSTR | lpModuleName |  Far pointer to a null-terminated 
;             character string that contains the filename of the 
;             application to run. See <f LoadModule> for more info.
;
;     @parm   WORD | nCmdShow |  Specifies how the application is shown.
;             See <f ShowWindow> for valid values.
;
;     @parm   LPVOID | lpParameters | Specifies a far pointer to a block
;             of data which will be passed to the application as a cmd 
;             tail. The first byte of the block must be the length of the
;             data and must be less than or equal to 120. 
;
;   @rdesc  The return value identifies the instance of the loaded module if
;           the function was successful. Otherwise, it is a value less than
;           32 that specifies the error. See <f LoadModule> for valid
;           error values.
;
;   @xref   LoadModule WinExec
;
;============================================================================

cProc BWinExec, <FAR,PUBLIC,NODATA>,<si,di>

    parmD lpszFile              ; Pathname ptr
    parmW wShow                 ; Mode flag
    parmD lpParameters          ; Cmd Line Data

    LocalV szCommand, 128       ; ASCIIZ Name of program to exec

    LocalV szParm, 128          ; DOS version of parameters
    LocalB szParmLen            ; DOS parm length
    LocalB bDotFound            ; Non-zero if a period is in the string

    LocalV loadparams, %(SIZE EXECBLOCK)
    LocalV rOF, %(SIZE OPENSTRUC)
    LocalD FCB1

cBegin
    mov     byte ptr szParm,0Dh
    mov     szParmLen,0         ; Init to zero length, Line feed

; Copy first part of line into szCommand.

    lds     si,lpszFile
    mov     ax,ss
    mov     es,ax
    lea     di,szCommand

    xor     al,al
    mov     bDotFound,al

; Loop until a blank or NULL is found.

WELoop1:
    lodsb
    cmp     al,' '              ; Exit loop if blank or NULL
    je      WECont1
    or      al,al
    je      WECont1
    cmp     al,'.'
    jne     WELoopCont
    mov     bDotFound,al
WELoopCont:
    stosb
    jmp     short WELoop1

WECont1:

; Does the command have an extension?

    cmp     bDotFound,0
    jne     WEHasExt

    mov     ax,0452Eh           ;'.E'
    stosw                       
    mov     ax,04558h           ;'XE'
    stosw

WEHasExt:
    xor     ax,ax               ; NULL terminate string
    stosb                   

    lds     si,lpParameters     
    mov     ax, ds
    or      ax, si              ; NULL Parameter block?
    jz      WEExec              ;  Y: exec 

; Copy Parameter Block into szParm.

    lea    di, szParmLen
    lodsb
    xor    cx,cx
    mov    cl, al   
    push   dx                           ; truncate to legal length!
    mov    ax, 78h 
    sub    ax, cx
    cwd    
    and    ax, dx
    add    cx, ax                       ; length + 1 in cx
    pop    dx
    mov    al, cl
    stosb
    dec    cx
    cld
    rep    movsb

; Terminate it with a linefeed.

    mov    al,0Dh
    stosb

; Set up the FCBs.

WEExec:
    mov    word ptr FCB1[0],2   ; FCB1[0] = 2;
    mov    ax,wShow             ; FCB1[1] = wShow;
    mov    word ptr FCB1[2],ax
    xor    ax,ax
    mov    loadparams.envseg,ax         ; loadparms.segEnv = 0;
    mov    loadparams.lpfcb2.lo,ax      ; loadparms.lpFCB2 = (LPSTR)NULL;
    mov    loadparams.lpfcb2.hi,ax
    lea    ax,szParmLen            ; loadparms.lpCmdLine = (LPSTR)ach;
    mov    loadparams.lpCmdLine.lo,ax
    mov    loadparams.lpCmdLine.hi,ss
    lea    ax,FCB1              ; loadparms.lpFCB1 = (LPSTR)fcb1buf;
    mov    loadparams.lpfcb1.lo,ax
    mov    loadparams.lpfcb1.hi,ss

; Exec the progam.

    lea     dx,szCommand        ; ds:ax == ptr to file to exec
    lea     bx,loadparams       ; es:bx == ptr to param block
if 1
    cCall   LoadModule, <ss,dx, ss,bx>      ; return ax=hInstance, dx=hTask
    cmp     ax,32
    jb      @f
    mov     ax,dx                           ; return hTask
@@:
else
    mov     ax,ss
    mov     ds,ax
    mov     ax,4B00h            ; dos exec
    int     21h
endif

cEnd

sEnd CodeSeg

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\mmsystem\comm.asm ===
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   COMM.ASM
;
;   Copyright (c) Microsoft Corporation 1990. All rights reserved.
;
;   This module contains code to write a string to the COM port
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

?PLM=1  ; pascal call convention
?WIN=0  ; Windows prolog/epilog code

        .286
        .xlist
        include cmacros.inc
;       include windows.inc
        .list

        WF_CPU286       equ 0002h

        ifdef DEBUG
            DEBUG_RETAIL equ 1
        endif

;       externA     __0040h                 ; in KERNEL
;       externA     __B000h                 ; in KERNEL

        externFP    OutputDebugString       ; in KERNEL

        externFP    wvsprintf               ; in USER

        SCREENWIDTH  equ 80
        SCREENHEIGHT equ 25
        SCREENBYTES  equ (SCREENWIDTH*2)
        DEFATTR      equ 07

        LASTLINE     equ ((SCREENHEIGHT-1)*SCREENBYTES)

BUFFER_SIZE = 256

;******************************************************************************
;
;   SEGMENTS
;
;******************************************************************************

createSeg _TEXT,    CodeRes, word, public, CODE
createSeg FIX,      CodeFix, word, public, CODE
createSeg INTDS,    DataFix, byte, public, DATA

;******************************************************************************
;
;   FIXED DATA
;
;******************************************************************************
ifdef DEBUG_RETAIL
sBegin  DataFix
        globalW fDebugOutput, 0
sEnd    DataFix
endif

;******************************************************************************
;
;   NON FIXED DATA
;
;******************************************************************************
ifdef DEBUG
sBegin  Data
        globalW _fDebug, 0
sEnd    Data
endif

ifdef DEBUG

sBegin  CodeRes
        assumes cs,CodeRes
        assumes ds,nothing
        assumes es,nothing

;******************************************************************************
;
;   dprintf    - output a MMSYSTEM debug string with formatting
;
;   if the mmsystem global fDebug==0, no ouput will be sent
;
;==============================================================================
        assumes ds,Data
        assumes es,nothing

?PLM=0
cProc   dprintf, <FAR, C, PUBLIC>, <>
        ParmD   szFormat
        ParmW   Args
        LocalV  szBuffer, BUFFER_SIZE
cBegin
        cmp     [_fDebug],0
        jz      dprintf_exit

        lea     ax,szBuffer
        lea     bx,Args
        cCall   wvsprintf, <ss,ax, szFormat, ss,bx>

        lea     ax,szBuffer
        push    ss
        push    ax
        call    far ptr OutputDebugStr

dprintf_exit:

cEnd
?PLM=1

sEnd

endif

;******************************************************************************
;
;******************************************************************************
sBegin  CodeFix
        assumes cs,CodeFix
        assumes ds,nothing
        assumes es,nothing

        externW CodeFixDS                       ; in STACK.ASM
        externW CodeFixWinFlags

ifdef DEBUG

;******************************************************************************
;
;   dout       - output a MMSYSTEM debug string
;
;   if the mmsystem global fDebug==0, no ouput will be sent
;
;==============================================================================
        assumes ds,Data
        assumes es,nothing

public  dout
dout   proc far

        cmp     [_fDebug],0
        jnz     OutputDebugStr
        retf 4

dout  endp

endif; DEBUG


;
;   in the retail version stub out the OutputDebugStr function
;
cProc   OutputDebugStr, <FAR, PASCAL, PUBLIC>, <>
        ParmD   szString
cBegin

        cCall   OutputDebugString, <szString>
cEnd

sEnd
end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\mmsystem\debug.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992, 1993  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//  debug.h
//
//  Description:
//
//
//
//==========================================================================;

#ifndef _INC_DEBUG
#define _INC_DEBUG
#ifdef __cplusplus
extern "C"
{
#endif


//
//
//
//
#define DEBUG_MODULE_NAME       "MSMIXMGR"  // key name and prefix for output

#ifdef DEBUG
    #define DEBUG_SECTION       "Debug"     // section name for
    #define DEBUG_MAX_LINE_LEN  255         // max line length (bytes!)
#endif


//
//  based code makes since only in win 16 (to try and keep stuff out of
//  [fixed] data segments, etc)...
//
#ifndef BCODE
#ifdef WIN32
    #define BCODE
#else
    #define BCODE           _based(_segname("_CODE"))
#endif
#endif




//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//  #pragma message(REMIND("this is a reminder"))
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifdef DEBUG

    #define D(x)        {x;}
    #define DPF(_x_)
    #define DPI(sz)     {static char BCODE ach[] = sz; OutputDebugStr(ach);}

#else

    #define D(x)
    #define DPF(_x_)
    #define DPI(sz)

#endif

#ifdef __cplusplus
}
#endif
#endif  // _INC_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\mmsystem\gmem.h ===
/*
 * GMEM.H - Macros for windows 3.0 memory management in protected mode
 *
 * because windows 3.0 runs in pmode GlobalLock and GlobalUnlock are
 * unnessary.  The "Selector" to a memory object will always be the
 * same for the life of the memory object.
 *
 * these macros take advantage of the following win3 memory "facts"
 *
 *      a SELECTOR (to a global object) is a HANDLE
 *      a HANDLE is *not* a SELECTOR!!!!!!!!
 *
 *      GlobalLock() and GlobalUnlock() do *not* keep lock counts
 *
 *      GlobalLock() is the only way to convert a HANDLE to a SELECTOR
 *
 * functions:
 *
 *      GHandle(sel)                convert a SELECTOR to a HANDLE
 *      GSelector(h)                convert a HANDLE to a SELECTOR
 *
 *      GAllocSel(ulBytes)          allocate a SELECTOR ulBytes in size
 *      GAllocPtr(ulBytes)          allocate a POINTER ulBytes in size
 *
 *      GReAllocSel(sel,ulBytes)    re-alloc a SELECTOR
 *      GReAllocPtr(lp,ulBytes)     re-alloc a POINTER
 *
 *      GSizeSel(sel)               return the size in bytes of a SELECTOR
 *
 *      GLockSel(sel)               convert a SELECTOR into a POINTER
 *      GUnlockSel(sel)             does nothing
 *
 *      GFreeSel(sel)               free a SELECTOR
 *      GFreePtr(lp)                free a POINTER
 *
 * 5/31/90 ToddLa
 *
 */

HGLOBAL __H;

#define MAKEP(sel,off)      ((LPVOID)MAKELONG(off,sel))

#define GHandle(sel)        ((HGLOBAL)(sel))  /* GlobalHandle? */
#define GSelector(h)        (HIWORD((DWORD)GlobalLock(h)))

#define GAllocSelF(f,ulBytes) ((__H=GlobalAlloc(f,(LONG)(ulBytes))) ? GSelector(__H) : NULL )
#define GAllocPtrF(f,ulBytes) MAKEP(GAllocSelF(f,ulBytes),0)
#define GAllocF(f,ulBytes)    GAllocSelF(f,ulBytes)

#define GAllocSel(ulBytes)    GAllocSelF(GMEM_MOVEABLE,ulBytes)
#define GAllocPtr(ulBytes)    GAllocPtrF(GMEM_MOVEABLE,ulBytes)
#define GAlloc(ulBytes)       GAllocSelF(GMEM_MOVEABLE,ulBytes)

#define GReAllocSel(sel,ulBytes)   ((__H=GlobalReAlloc((HGLOBAL)(sel),(LONG)(ulBytes), GMEM_MOVEABLE | GMEM_ZEROINIT)) ? GSelector(__H) : NULL )
#define GReAllocPtr(lp,ulBytes)    MAKEP(GReAllocSel(HIWORD((DWORD)(lp)),ulBytes),0)
#define GReAlloc(sel,ulBytes)      GReAllocSel(sel,ulBytes)

#define GSizeSel(sel)       GlobalSize((HGLOBAL)(sel))
#define GSize(sel)          GSizeSel(sel)

#define GLockSel(sel)       MAKEP(sel,0)
#define GUnlockSel(sel)     /* nothing */
#define GLock(sel)          GLockSel(sel)
#define GUnlock(sel)        GUnlockSel(sel)

#define GFreeSel(sel)       (GlobalUnlock(GHandle(sel)),GlobalFree(GHandle(sel)))
#define GFreePtr(lp)        GFreeSel(HIWORD((DWORD)(lp)))
#define GFree(sel)          GFreeSel(sel)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\mmsystem\debug.asm ===
;--------------------------------------------------------------------------

ifdef	DEBUG
	DEBUG_RETAIL equ 1
endif	; ifdef DEBUG

;--------------------------------------------------------------------------
	?PLM = 1
	?WIN = 0
	PMODE = 1

        .xlist
        include cmacros.inc
        include windows.inc
	include mmsystem.inc
;       include logerror.inc
	include mmddk.inc
        .list

;--------------------------------------------------------------------------

;/* Error modifier bits */

ERR_WARNING             equ 08000h
ERR_PARAM               equ 04000h

;/* Generic parameter values */
ERR_BAD_VALUE           equ 06001h
ERR_BAD_FLAGS           equ 06002h
ERR_BAD_INDEX           equ 06003h
ERR_BAD_DVALUE          equ 07004h
ERR_BAD_DFLAGS          equ 07005h
ERR_BAD_DINDEX          equ 07006h
ERR_BAD_PTR             equ 07007h
ERR_BAD_FUNC_PTR        equ 07008h
ERR_BAD_SELECTOR        equ 06009h
ERR_BAD_STRING_PTR      equ 0700ah
ERR_BAD_HANDLE          equ 0600bh

;/* KERNEL parameter errors */
ERR_BAD_HINSTANCE       equ 06020h
ERR_BAD_HMODULE         equ 06021h
ERR_BAD_GLOBAL_HANDLE   equ 06022h
ERR_BAD_LOCAL_HANDLE    equ 06023h
ERR_BAD_ATOM            equ 06024h
ERR_BAD_HFILE           equ 06025h

;/* USER parameter errors */
ERR_BAD_HWND            equ 06040h
ERR_BAD_HMENU           equ 06041h
ERR_BAD_HCURSOR         equ 06042h
ERR_BAD_HICON           equ 06043h
ERR_BAD_HDWP            equ 06044h
ERR_BAD_CID             equ 06045h
ERR_BAD_HDRVR           equ 06046h

DBF_TRACE           equ 00000h
DBF_WARNING         equ 04000h
DBF_ERROR           equ 08000h
DBF_FATAL           equ 0c000h

; [Windows] DebugFilter and flags values

DBF_INTERNAL        equ 02000h
DBF_KERNEL          equ 01000h
DBF_USER            equ 00800h
DBF_GDI             equ 00400h
DBF_COMPAT          equ 00200h
DBF_LOGERROR        equ 00100h
DBF_PARAMERROR      equ 00080h
DBF_MMSYSTEM        equ 00040h
DBF_PENWIN          equ 00020h

;--------------------------------------------------------------------------

AssertF macro reg
        local   assert_ok
ifdef DEBUG
        or      reg,reg
        jnz     assert_ok
        int     3
assert_ok:
endif
        endm

AssertT macro reg
        local   assert_ok
ifdef DEBUG
        or      reg,reg
        jz      assert_ok
        int     3
assert_ok:
endif
        endm

;--------------------------------------------------------------------------
;
; DebugErr() macro
;
ifdef DEBUG_RETAIL

externFP    _DebugOutput

DebugErr    macro   flags,msg
        local   a,b

        push    cs
        push    offset a
        push    flags or DBF_MMSYSTEM
        call    _DebugOutput
        add     sp,6
        jmp     short b
a:
        db      "MMSYSTEM: "
        db      msg
        db      13,10,0
b:
endm

else    ; DEBUG

DebugErr    macro   flags,msg
endm

endif   ; DEBUG

;--------------------------------------------------------------------------

; Define the return address as a type using the DefD macro in order to
; be able to pass it as a parameter to the LogParamError function.
ReturnAddr equ (dword ptr [bp+2])
DefD ReturnAddr

;--------------------------------------------------------------------------

NSTYPE			equ 00007h	; Segment type mask
NSCODE			equ 00000h	; Code segment
NSDATA			equ 00001h	; Data segment
NSITER			equ 00008h	; Iterated segment flag
NSMOVE			equ 00010h	; Movable segment flag
NSPURE			equ 00020h	; Pure segment flag
NSPRELOAD		equ 00040h	; Preload segment flag
NSRELOC			equ 00100h	; Segment has relocations
NSDEBUG			equ 00200h	; Segment has debug info
NSDPL			equ 00C00h	; 286 DPL bits
NSDISCARD		equ 01000h	; Discard bit for segment

CODEINFO	struc
	ns_sector	dw	?	; File sector of start of segment
	ns_cbseg	dw	?	; Number of bytes in file
	ns_flags	dw	?	; Attribute flags
	ns_minalloc	dw	?	; Minimum allocation in bytes
	ns_handle	dw	?	; handle to object
	ns_align	dw	?	; file alignment
CODEINFO	ends

DSC_CODE_BIT	equ	08h

;--------------------------------------------------------------------------

;**************************************************************************;
;   IF YOU CHANGE THESE TYPES YOU MUST ALSO CHANGE THE ONES IN MMSYSI.H
;**************************************************************************;
TYPE_WAVEOUT		equ	1
TYPE_WAVEIN		equ	2
TYPE_MIDIOUT		equ	3
TYPE_MIDIIN		equ	4
TYPE_MMIO               equ     5
TYPE_IOPROC             equ     6
TYPE_MCI                equ     7
TYPE_DRVR               equ     8
TYPE_MIXER              equ     9
;**************************************************************************;

;--------------------------------------------------------------------------

;**************************************************************************;
;   IF YOU CHANGE THIS STRUCTURE YOU MUST ALSO CHANGE THE ONE IN MMSYSI.H
;**************************************************************************;
HNDL	struc
	hndlNext	dw	?	; link to next handle
	hndlType	dw	?	; type of handle wave, midi, mmio, ...
	hndlTask	dw	?	; task that owns it
HNDL	ends
;**************************************************************************;

;--------------------------------------------------------------------------

externW		_pHandleList
externA		__AHINCR
externA		__WINFLAGS
externFP	LogParamError		;(WORD wError, FARPROC lpfn, DWORD dValue);
externFP	LocalAlloc		;(WORD fwFlags, WORD wSize);
externFP	LocalFree		;(LOCALHANDLE h);
externFP	IsWindow		;(HWND hwnd);
externFP	GetCodeInfo		;(FARPROC lpfnProc, LPVOID lpSegInfo);
externFP	GetCurrentTask		;(void);
externFP	IsTask			;(HANDLE hTask);

; Windows internal pointer validation tools.
externFP	IsBadReadPtr		;(LPVOID lp, WORD cb);
externFP	IsBadWritePtr		;(LPVOID lp, WORD cb);
externFP	IsBadHugeReadPtr	;(LPVOID lp, DWORD cb);
externFP	IsBadHugeWritePtr	;(LPVOID lp, DWORD cb);
externFP	IsBadCodePtr		;(FARPROC lp);
externFP	IsBadStringPtr		;(LPSTR lpsz, WORD wMaxLen);
externFP	IsSharedSelector	;(WORD wSelector);

;--------------------------------------------------------------------------
sBegin Data

sEnd Data

;--------------------------------------------------------------------------

createSeg _TEXT, CodeRes, word, public, CODE
createSeg FIX,   CodeFix, word, public, CODE

sBegin  CodeRes
        assumes cs, CodeRes
	assumes ds, Data

;--------------------------------------------------------------------------
; @doc INTERNAL
;
; @func HANDLE | NewHandle | allocate a fixed handle in MMSYSTEM's local heap
;
; @parm  WORD | wType | unique id describing handle type
; @parm  WORD | wSize | size in bytes to be allocated
;
; @rdesc Returns pointer/handle to memory object
;
; @comm a standard handle header (HNDL) will be added to the object,
;       and it will be linked into the list of MMSYSTEM handles.
;
cProc	NewHandle, <FAR, PUBLIC, PASCAL> <>
	parmW	wType
	parmW	wSize
cBegin
	mov	ax, wSize		; Attempt to allocate local memory
	add	ax, SIZE HNDL		; Add header to requested size first
        cCall   LocalAlloc, <LPTR, ax>
        AssertF ax
	or	ax, ax
	jz	NewHandle_Exit		; Return NULL
	mov	bx, ax
        mov     ax, [_pHandleList]      ; Put the head of the list as the
	mov	[bx].hndlNext, ax	; next pointer
	cCall	GetCurrentTask, <>
	mov	[bx].hndlTask, ax	; Set task for new handle
	mov	ax, wType		; Set type for new handle
	mov	[bx].hndlType, ax
        mov     [_pHandleList], bx      ; Make new handle head of list
	lea	ax, [bx + SIZE HNDL]	; Return data portion of handle
NewHandle_Exit:
cEnd

;--------------------------------------------------------------------------
; @doc INTERNAL
;
; @func HANDLE | FreeHandle | free handle allocated with NewHandle
;
; @parm HANDLE | hLocal | handle returned from NewHandle
;
; @comm handle will be unlinked from list, and memory will be freed with
;       LocalFree
;
cProc   FreeHandle, <FAR, PUBLIC, PASCAL> <>
	parmW	hLocal
cBegin
        mov     ax, hLocal
        AssertF ax
        or      ax, ax
        jz      FreeHandle_Exit         ; NULL handle returns NULL
        sub     ax, SIZE HNDL           ; Get real handle from data portion
        lea     bx, [_pHandleList]      ; Pointer to first pointer
        errnz   hndlNext		; Assume this is the first element

FreeHandle_Search:
        mov     dx, [bx].hndlNext       ; get pointer to next handle
        cmp     dx, ax                  ; If this is the handle
        je      FreeHandle_Free         ; Free it

	mov	bx, dx			; advance to next handle.
        or      bx, bx                  ; Check for end of list
        jnz     FreeHandle_Search
	AssertF bx			; bx == 0 force a fail
	jmp	FreeHandle_Exit 	; Handle not found, so return handle

FreeHandle_Free:
        xchg    ax, bx                  ; BX --> handle
	xor	dx, dx			; Zero out entries for better debugging
        mov     [bx].hndlType, dx
        mov     [bx].hndlTask, dx
        xchg    [bx].hndlNext, dx       ; Get next handle in list
        xchg    ax, bx                  ; BX --> prev handle
	mov	[bx].hndlNext, dx	; update link
        cCall   LocalFree, <ax>         ; Free handle found, returning error
	AssertT ax

FreeHandle_Exit:
cEnd

;--------------------------------------------------------------------------
; @doc INTERNAL WAVE MIDI
;
; @func BOOL | ValidateHeader | validates a wave or midi date header
;
; @parm LPVOID | lpHeader| pointer to wave/midi header
; @parm  WORD  | wSize  | size of header passed by app
; @parm  WORD  | wType  | unique id describing header/handle type
;
; @rdesc Returns TRUE  if <p> is non NULL and <wSize> is the correct size
;        Returns FALSE otherwise
;
; @comm  if the header is invalid an error will be generated.
;

cProc   ValidateHeader, <FAR, PUBLIC, PASCAL> <>
        parmD   lpHeader
	parmW	wSize
	parmW	wType
cBegin
        cCall   IsBadWritePtr, <lpHeader, wSize>
	or	ax, ax			; If fail,
        jnz     vValidateHeader_Fail_Header_Ptr

        mov     ax, wType
        mov     dx, SIZE WAVEHDR        ; assume WAVEHDR
        mov     cx, not WHDR_VALID

        cmp     ax, TYPE_WAVEIN         ; If wave out
        jbe     ValidateHeader_Size
        errnz   TYPE_WAVEOUT-1
        errnz   TYPE_WAVEIN-2

        mov     dx, SIZE MIDIHDR        ; Set MIDIHDR
        mov     cx, not MHDR_VALID

ValidateHeader_Size:
	cmp	dx, wSize		; Compare against given size
        jne     ValidateHeader_Fail_Size; Fail if wrong size, LogParamError

        les     bx, lpHeader            ; Load lpData pointer

        mov     ax,es:[bx].dwWaveFlags.lo
        test    ax,cx
        jnz     ValidateHeader_Fail_Flags

	push	es:[bx].lpWaveData.hi	; Validate data pointer
	push	es:[bx].lpWaveData.lo
	push	es:[bx].dwWaveBufferLength.hi
	push	es:[bx].dwWaveBufferLength.lo
        cCall   IsBadHugeWritePtr, <>
        or      ax,ax
        jnz     vValidateHeader_Fail_Buffer_Ptr
        errn$   ValidateHeader_Exit

ValidateHeader_Exit:
        not     ax
cEnd

ValidateHeader_Fail_Exit:
        mov     ax, -1                  ; Return FALSE
        jmp     short ValidateHeader_Exit

vValidateHeader_Fail_Header_Ptr:
        jmp     ValidateHeader_Fail_Header_Ptr

vValidateHeader_Fail_Buffer_Ptr:
        jmp     ValidateHeader_Fail_Buffer_Ptr

ValidateHeader_Fail_Size:
        DebugErr DBF_ERROR, "Invalid header size."
        cCall   LogParamError, <ERR_BAD_VALUE, ReturnAddr, 0, wSize>
        jmp     short ValidateHeader_Fail_Exit

ValidateHeader_Fail_Flags:
        cCall   LogParamError, <ERR_BAD_FLAGS, ReturnAddr, 0, ax>
        jmp     short ValidateHeader_Fail_Exit

ValidateHeader_Fail_Header_Ptr:
        DebugErr DBF_ERROR, "Invalid header pointer."
        cCall   LogParamError, <ERR_BAD_PTR, ReturnAddr, lpHeader>
        jmp     ValidateHeader_Fail_Exit

ValidateHeader_Fail_Buffer_Ptr:
        DebugErr DBF_ERROR, "Invalid buffer pointer."
        push    ERR_BAD_PTR
        push    ReturnAddr.hi
        push    ReturnAddr.lo
        les     bx,lpHeader
        push    es:[bx].lpWaveData.hi
        push    es:[bx].lpWaveData.lo
        cCall   LogParamError
        jmp     ValidateHeader_Fail_Exit

;--------------------------------------------------------------------------
; @doc INTERNAL
;
; @func BOOL | ValidateReadPointer | validates that a pointer is valid to
;	read from.
;
; @parm LPVOID | lpPoint| pointer to validate
; @parm DWORD  | dLen   | supposed length of said pointer
;
; @rdesc Returns TRUE  if <p> is a valid pointer
;        Returns FALSE if <p> is not a valid pointer
;
; @comm will generate error if the pointer is invalid
;
cProc	ValidateReadPointer, <FAR, PUBLIC, PASCAL> <>
	parmD	lpPoint
	parmD	dLen
cBegin
        cCall   IsBadHugeReadPtr, <lpPoint, dLen>
        or      ax,ax
        jz      ValidateReadPointer_Exit        ; Return TRUE

	cCall	LogParamError, <ERR_BAD_PTR, ReturnAddr, lpPoint>
        mov     ax,-1                           ; Return FALSE

ValidateReadPointer_Exit:
        not     ax
cEnd

;--------------------------------------------------------------------------
; @doc INTERNAL
;
; @func BOOL | ValidateWritePointer | validates that a pointer is valid to
;	write to.
;
; @parm LPVOID | lpPoint| pointer to validate
; @parm DWORD  | dLen   | supposed length of said pointer
;
; @rdesc Returns TRUE  if <p> is a valid pointer
;        Returns FALSE if <p> is not a valid pointer
;
; @comm will generate error if the pointer is invalid
;
cProc	ValidateWritePointer, <FAR, PUBLIC, PASCAL> <>
	parmD	lpPoint
	parmD	dLen
cBegin
	cCall	IsBadHugeWritePtr, <lpPoint, dLen>
        or      ax,ax                           ; If not fail,
        jz      ValidateWritePointer_Exit       ; Return TRUE
	cCall	LogParamError, <ERR_BAD_PTR, ReturnAddr, lpPoint>
        mov     ax,-1                           ; Return FALSE
ValidateWritePointer_Exit:
        not     ax
cEnd

;--------------------------------------------------------------------------
; @doc INTERNAL
;
; @func WORD | ValidDriverCallback |
;
;  validates that a driver callback is valid, to be valid a driver
;  callback must be a valid window, task, or a function in a FIXED DLL
;  code segment.
;
; @parm DWORD  | dwCallback | callback to validate
; @parm  WORD  | wFlags     | driver callback flags
;
; @rdesc Returns 0  if <dwCallback> is a valid callback
;        Returns error condition if <dwCallback> is not a valid callback
;
cProc	ValidDriverCallback, <NEAR, PASCAL> <>
	parmD	dCallback
	parmW	wFlags
	localV	ci, %(SIZE CODEINFO)
cBegin
	mov	ax, wFlags			; switch on callback type
	and	ax, DCB_TYPEMASK
	errnz	<DCB_NULL>
	jnz	ValidDriverCallback_Window	; case DCB_NULL
        jmp     ValidDriverCallback_Exit        ; return zero for success

ValidDriverCallback_Window:
	dec	ax
	errnz	<DCB_WINDOW - 1>
	jnz	ValidDriverCallback_Task	; case DCB_WINDOW
	cmp	dCallback.hi, 0			; HIWORD must be NULL
	jnz	ValidDriverCallback_BadWindow	; Set error
	push	dCallback.lo			; Check for valid HWND
	cCall	IsWindow, <>
	or	ax, ax				; If HWND,
        jnz     ValidDriverCallback_Success     ; Set successful return

ValidDriverCallback_BadWindow:                  ; Else set error return
	mov	ax, ERR_BAD_HWND
        jmp     ValidDriverCallback_Exit        ; Return error

ValidDriverCallback_Task:
	dec	ax
	errnz	<DCB_TASK - 2>
	jnz	ValidDriverCallback_Function	; case DCB_TASK
	cmp	dCallback.hi, 0			; HIWORD must be NULL
	jnz	ValidDriverCallback_BadTask	; Set error
	push	dCallback.lo			; Check for valid Task
	cCall	IsTask, <>
	or	ax, ax				; If Task,
        jnz     ValidDriverCallback_Success     ; Set successful return

ValidDriverCallback_BadTask:			; Else set error return
	mov	ax, ERR_BAD_HANDLE
        jmp     ValidDriverCallback_Exit        ; Return error

ValidDriverCallback_Function:
	dec	ax
        errnz   <DCB_FUNCTION - 3>              ; case DCB_FUNCTION
        jnz     ValidDriverCallback_Default
	lea	ax, ci
	cCall	GetCodeInfo, <dCallback, ss, ax>
	or	ax, ax
	jz	ValidDriverCallback_BadFunction	; Set error return
	mov	ax, ci.ns_flags			; Check for valid flags
	and	ax, NSDATA or NSMOVE or NSDISCARD
        jz      ValidDriverCallback_Exit        ; Return zero for success
        jnz     ValidDriverCallback_BadFunction

ValidDriverCallback_Default:
	mov	ax, ERR_BAD_FLAGS		; default to error condition
        jmp     ValidDriverCallback_Exit

ValidDriverCallback_Success:
        xor     ax, ax

ValidDriverCallback_Exit:
cEnd

ValidDriverCallback_BadFunction:                ; Else set error return
        DebugErr DBF_ERROR, "Driver callbacks MUST be in a FIXED segment of a DLL."
	mov	ax, ERR_BAD_FUNC_PTR
        jmp     ValidDriverCallback_Exit        ; Return error

;--------------------------------------------------------------------------
; @doc INTERNAL
;
; @func BOOL | ValidateDriverCallback |
;
;  validates that a driver callback is valid, to be valid a driver
;  callback must be a valid window, task, or a function in a FIXED DLL
;  code segment.
;
; @parm DWORD  | dwCallback | callback to validate
; @parm  WORD  | wFlags     | driver callback flags
;
; @rdesc Returns TRUE  if <dwCallback> is a valid callback
;        Returns FALSE if <dwCallback> is not a valid callback
;
; @comm will generate error if the callback is invalid
;
cProc	ValidateDriverCallback, <FAR, PUBLIC, PASCAL> <>
	parmD	dCallback
	parmW	wFlags
cBegin
	cCall	ValidDriverCallback, <dCallback, wFlags>
	or	ax, ax				; If no error return
	jz	ValidateDriverCallback_Exit	; Return TRUE
	cCall	LogParamError, <ax, ReturnAddr, dCallback>
	mov	ax, -1				; Return FALSE
ValidateDriverCallback_Exit:
	not	ax
cEnd

;--------------------------------------------------------------------------
; @doc INTERNAL
;
; @func BOOL | ValidateCallback |
;
;  validates that a callback is valid.
;
; @parm FARPROC  | dCallback | callback to validate
;
; @rdesc Returns TRUE  if <lpfnCallback> is a valid callback
;        Returns FALSE if <lpfnCallback> is not a valid callback
;
; @comm will generate error if the callback is invalid
;
cProc	ValidateCallback, <FAR, PUBLIC, PASCAL> <>
	parmD	dCallback
cBegin
	cCall	IsBadCodePtr, <dCallback>
        or      ax,ax                           ; If not fail,
        jz      ValidateCallback_Exit           ; Return TRUE
	cCall	LogParamError, <ERR_BAD_FUNC_PTR, ReturnAddr, dCallback>
        mov     ax, -1                          ; Return FALSE
ValidateCallback_Exit:
        not     ax
cEnd

;--------------------------------------------------------------------------
; @doc INTERNAL
;
; @func BOOL | ValidateString |
;
cProc	ValidateString, <FAR, PUBLIC, PASCAL> <>
        parmD   lsz
        parmW   max_len
cBegin
        cCall   IsBadStringPtr, <lsz, max_len>  ; Maximum length
        or      ax,ax                           ; If not fail,
        jz      ValidateString_Exit             ; Return TRUE
	cCall	LogParamError, <ERR_BAD_STRING_PTR, ReturnAddr, lsz>
        mov     ax, -1                          ; Return FALSE
ValidateString_Exit:
        not     ax
cEnd

sEnd

;--------------------------------------------------------------------------

sBegin  CodeFix
        assumes cs, CodeFix
        assumes ds, nothing

;--------------------------------------------------------------------------
; @doc INTERNAL
;
; @func BOOL | ValidateHandle | validates a handle created with NewHandle
;
; @parm HANDLE | hLocal | handle returned from NewHandle
; @parm WORD   | wType  | unique id describing handle type
;
; @rdesc Returns TRUE  if <h> is a valid handle of type <wType>
;        Returns FALSE if <h> is not a valid handle
;
; @comm  if the handle is invalid an error will be generated.
;
;--------------------------------------------------------------------------
        assumes ds, Data
        assumes es, nothing

cProc	ValidateHandle, <FAR, PUBLIC, PASCAL> <>
	parmW	hLocal
	parmW	wType
cBegin
        mov     bx, hLocal
        sub     bx, SIZE HNDL           ; Get actual handle
        jc      ValidateHandle_Bad

	mov	ax, ds
        lsl     ax, ax                  ; Get DS limit
        cmp     bx, ax                  ; Check for out of limit
        jae     ValidateHandle_Bad

        mov     ax,[bx].hndlType
        cmp     ax, wType               ; Compare handle type
        je      ValidateHandle_Exit     ; Types are the same, return TRUE

ValidateHandle_Bad:
        add     bx, SIZE HNDL
        cCall   LogParamError, <ERR_BAD_HANDLE, ReturnAddr, 0, bx>
        xor     ax, ax                  ; Return FALSE

ValidateHandle_Exit:
cEnd

;--------------------------------------------------------------------------
; @doc INTERNAL
;
; @func BOOL | ValidateTimerCallback |
;
;  validates that a timer callback is valid, to be valid a driver
;  callback must be a valid function in a FIXED DLL code segment.
;
; @parm LPTIMECALLBACK  | lpfn | callback to validate
;
; @rdesc Returns TRUE  if <lpfn> is a valid callback
;        Returns FALSE if <lpfn> is not a valid callback
;
; @comm will generate error if the callback is invalid
;
;--------------------------------------------------------------------------
        assumes ds, nothing
        assumes es, nothing

cProc	ValidateTimerCallback, <FAR, PUBLIC, PASCAL> <>
	parmD	lpfn
cBegin
	mov	ax, lpfn.hi
	lar	bx, ax
	jnz	ValidateTimerCallback_Fail	; Invalid segment
	test	bh, DSC_CODE_BIT
	jz	ValidateTimerCallback_Fail	; Not executable segment
	lsl	cx, ax				; Get segment limit
	mov	bx, lpfn.lo
	cmp	bx, cx
	jae	ValidateTimerCallback_Fail	; Invalid offset
	mov	es, ax
	mov	bx, es:[bx]+2
	cmp	bx, 0581eH			; push ds, pop ax
	je	ValidateTimerCallback_Fail	; Invalid entry point
	cmp	bx, 0d88cH			; mov ax, ds
	jne	ValidateTimerCallback_Exit	; Return TRUE
ValidateTimerCallback_Fail:
	cCall	LogParamError, <ERR_BAD_FUNC_PTR, ReturnAddr, lpfn>
	xor	ax, ax				; Return FALSE
ValidateTimerCallback_Exit:
cEnd

sEnd    CodeFix

;--------------------------------------------------------------------------

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\mmsystem\drvproc.c ===
/*
    drvproc.c

    contains MMSYSTEMs DriverProc

    Copyright (c) Microsoft Corporation 1990. All rights reserved

*/

#include <windows.h>
#include <mmsysver.h>
#include "mmsystem.h"
#include "mmsysi.h"
#include "drvr.h"
#include "mmioi.h"

extern IOProcMapEntry NEAR * gIOProcMapHead;   // in MMIO.C

/****************************************************************************

    internal prototypes

****************************************************************************/

static void FAR PASCAL SetPrivateProfileInt(LPSTR szSection, LPSTR szKey, int i, LPSTR szIniFile);

static BYTE    fFirstTime=TRUE;         // First enable

extern BOOL FAR PASCAL DrvLoad(void);   // in init.c
extern BOOL FAR PASCAL DrvFree(void);
extern char far szStartupSound[];       // in mmwnd.c

static  SZCODE  szExitSound[]   = "SystemExit";

#ifdef DEBUG_RETAIL
        extern  char far szMMSystem[];
        extern  char far szSystemIni[];
        extern  char far szDebugOutput[];
        extern  char far szMci[];

//      extern  WORD    fDebugOutput;
        extern  int     DebugmciSendCommand;        // in MCI.C
#ifdef DEBUG
        extern  char far szDebug[];
        extern  WORD    fDebug;
#endif
#endif

void NEAR PASCAL AppExit(HTASK hTask, BOOL fNormalExit);

/*****************************************************************************
 *
 * @doc   INTERNAL
 *
 * @api   LRESULT | DriverProc | This is the standard DLL entry point. It is
 *        called from user (3.1) or mmsound.drv (3.0) when MMSYSTEM.DLL is
 *        loaded, enabled, or disabled.
 *
 ****************************************************************************/
LRESULT CALLBACK
DriverProc(
    DWORD dwDriver,
    HDRVR hDriver,
    UINT wMessage,
    LPARAM lParam1,
    LPARAM lParam2
    )
{
    switch (wMessage)
        {
        case DRV_LOAD:
            //
            //  first load message, initialize mmsystem.
            //  sent from USER when loading drivers from drivers= line
            //
            if (fFirstTime)
                return (LRESULT)(LONG)DrvLoad();

            //
            //  a normal load message, a app is trying to open us
            //  with OpenDriver()
            //
            break; // return success all other times (1L)

        case DRV_FREE:
            //
            //  a free message, this is send just before the DLL is unloaded
            //  by the driver interface.
            //
            //  sent by user just before system exit, after sending
            //  the DRV_DISABLE message.
            //
            DrvFree();
            break;         // return success (1L)

        case DRV_OPEN:     // FALL-THROUGH
        case DRV_CLOSE:
            break;         // return success (1L)

        case DRV_ENABLE:
            DOUT("MMSYSTEM: Enable\r\n");
            fFirstTime = FALSE;
            break;         // return success (1L)

        case DRV_DISABLE:
            DOUT("MMSYSTEM: Disable\r\n");
            break;         // return success (1L)

        //
        //  sent when a application is terminating
        //
        //  lParam1:
        //      DRVEA_ABNORMALEXIT
        //      DRVEA_NORMALEXIT
        //
        case DRV_EXITAPPLICATION:
            AppExit(GetCurrentTask(), (BOOL)lParam1 == DRVEA_NORMALEXIT);
            break;

        case DRV_EXITSESSION:
            sndPlaySound(szExitSound, SND_SYNC | SND_NODEFAULT);
            break;

#ifdef  DEBUG_RETAIL
        case MM_GET_DEBUG:
            break;

        case MM_GET_DEBUGOUT:
            return (LRESULT)(LONG)fDebugOutput;

        case MM_SET_DEBUGOUT:
            fDebugOutput = (BYTE)(LONG)lParam1;
            SetPrivateProfileInt(szMMSystem,szDebugOutput,fDebugOutput,szSystemIni);
            break;

        case MM_GET_MCI_DEBUG:
            return (LRESULT)(LONG)DebugmciSendCommand;

        case MM_SET_MCI_DEBUG:
            DebugmciSendCommand = (WORD)(LONG)lParam1;
            SetPrivateProfileInt(szMMSystem,szMci,DebugmciSendCommand,szSystemIni);
            break;

#ifdef DEBUG
        case MM_GET_MM_DEBUG:
            return (LRESULT)(LONG)fDebug;

        case MM_SET_MM_DEBUG:
            fDebug = (BYTE)(LONG)lParam1;
            SetPrivateProfileInt(szMMSystem,szDebug,fDebug,szSystemIni);
            break;

#ifdef DEBUG
        case MM_DRV_RESTART:
            break;
#endif


        case MM_HINFO_MCI:
            if ((HLOCAL)(LONG)lParam2 == (HLOCAL)NULL)
                return (LRESULT)(LONG)MCI_wNextDeviceID;
            if (MCI_VALID_DEVICE_ID((UINT)(LONG)lParam1))
            {
                *(LPMCI_DEVICE_NODE)lParam2 = *MCI_lpDeviceList[(UINT)(LONG)lParam1];
                break;
            }
            return (LRESULT)FALSE;

        case MM_HINFO_NEXT:
            if ((HLOCAL)(LONG)lParam1 == (HLOCAL)NULL)
                return (LRESULT)(LONG)(UINT)GetHandleFirst();
            else
                return (LRESULT)(LONG)(UINT)GetHandleNext((HLOCAL)(LONG)lParam1);

        case MM_HINFO_TASK:
            return (LRESULT)(LONG)(UINT)GetHandleOwner((HLOCAL)(LONG)lParam1);

        case MM_HINFO_TYPE:
            return GetHandleType((HLOCAL)(LONG)lParam1);

#endif   // ifdef DEBUG
#endif   // ifdef DEBUG_RETAIL

        default:
            return DefDriverProc(dwDriver, hDriver, wMessage, lParam1, lParam2);
        }
    return (LRESULT)1L;
}

/*****************************************************************************
 * @doc INTERNAL
 *
 * @func void | AppExit |
 *      a application is exiting, free any MMSYS resources it may own
 *
 ****************************************************************************/

void NEAR PASCAL AppExit(HTASK hTask, BOOL fNormalExit)
{
    HLOCAL h;
    HLOCAL hNext;
    WORD   wDebugFlags;
    UINT   wDeviceID;
    UINT   cFree;
    UINT   cHeap;
    UINT   err;

    if (hdrvDestroy != (HLOCAL)-1)
    {
        DOUT("MMSYSTEM: Hey! AppExit has been re-entered!\r\n");
    }

#ifdef DEBUG
    if (!fNormalExit)
        ROUT("MMSYSTEM: Abnormal app termination");
#endif

    //
    // either log a error or a warning depending on wether it was
    // a normal exit or not.
    //
    if (fNormalExit)
        wDebugFlags = DBF_MMSYSTEM | DBF_ERROR;
    else
        wDebugFlags = DBF_MMSYSTEM | DBF_WARNING; // DBF_TRACE?

    //
    // now free MCI devices.
    //
    for (wDeviceID=1; wDeviceID<MCI_wNextDeviceID; wDeviceID++)
    {
        if (MCI_VALID_DEVICE_ID(wDeviceID) && MCI_lpDeviceList[wDeviceID]->hCreatorTask == hTask)
        {
            DebugErr2(wDebugFlags, "MCI device %ls (%d) not released.", MCI_lpDeviceList[wDeviceID]->lpstrInstallName, wDeviceID);

            //
            // clear these to force MCI to close the device
            //
            MCI_lpDeviceList[wDeviceID]->dwMCIFlags &= ~MCINODE_ISCLOSING;
            MCI_lpDeviceList[wDeviceID]->dwMCIFlags &= ~MCINODE_ISAUTOCLOSING;

            err = (UINT)mciSendCommand(wDeviceID, MCI_CLOSE, NULL, NULL);

#ifdef DEBUG
            if (err != 0)
                DebugErr1(DBF_WARNING, "Unable to close MCI device (err = %04X).", err);
#endif
        }
    }

    //
    // free all WAVE/MIDI/MMIO handles
    //
start_over:
    for (h=GetHandleFirst(); h; h=hNext)
    {
        hNext = GetHandleNext(h);

        if (GetHandleOwner(h) == hTask)
        {
            //
            //  hack for the wave/midi mapper, always free handle's backward.
            //
            if (hNext && GetHandleOwner(hNext) == hTask)
                continue;

            //
            // do this so even if the close fails we will not
            // find it again.
            //
            SetHandleOwner(h, NULL);

            //
            // set the hdrvDestroy global so DriverCallback will not
            // do anything for this device
            //
            hdrvDestroy = h;

            switch(GetHandleType(h))
            {
                case TYPE_WAVEOUT:
                    DebugErr1(wDebugFlags, "WaveOut handle (%04X) was not released.", h);
                    waveOutReset((HWAVEOUT)h);
                    err = waveOutClose((HWAVEOUT)h);
                    break;

                case TYPE_WAVEIN:
                    DebugErr1(wDebugFlags, "WaveIn handle (%04X) was not released.", h);
                    waveInStop((HWAVEIN)h);
                    waveInReset((HWAVEIN)h);
                    err = waveInClose((HWAVEIN)h);
                    break;

                case TYPE_MIDIOUT:
                    DebugErr1(wDebugFlags, "MidiOut handle (%04X) was not released.", h);
                    midiOutReset((HMIDIOUT)h);
                    err = midiOutClose((HMIDIOUT)h);
                    break;

                case TYPE_MIDIIN:
                    DebugErr1(wDebugFlags, "MidiIn handle (%04X) was not released.", h);
                    midiInStop((HMIDIIN)h);
                    midiInReset((HMIDIIN)h);
                    err = midiInClose((HMIDIIN)h);
                    break;

                case TYPE_MMIO:
                    DebugErr1(wDebugFlags, "MMIO handle (%04X) was not released.", h);
                    err = mmioClose((HMMIO)h, 0);
                    break;

                case TYPE_IOPROC:
                    DebugErr1(wDebugFlags, "MMIO handler '%4.4ls' not removed.", (LPSTR)&((IOProcMapEntry*)h)->fccIOProc);
                    err = !mmioInstallIOProc(((IOProcMapEntry*)h)->fccIOProc, NULL, MMIO_REMOVEPROC);
                    break;

            }

#ifdef DEBUG
            if (err != 0)
                DebugErr1(DBF_WARNING, "Unable to close handle (err = %04X).", err);
#endif

            //
            // unset hdrvDestroy so DriverCallback will work.
            // some hosebag drivers (like the TIMER driver)
            // may pass NULL as their driver handle.
            // so dont set it to NULL.
            //
            hdrvDestroy = (HLOCAL)-1;

            //
            // the reason we start over is because a single free may cause
            // multiple free's (ie MIDIMAPPER has another HMIDI open, ...)
            //
            goto start_over;
        }
    }

    //
    //  what about timeSetEvent()!!!???
    //
    //  any outstanding timer events till be killed by the timer driver
    //  it self.
    //
    mciAppExit( hTask );


    // shrink our heap, down to minimal size.

    if ((cFree = LocalCountFree()) > 1024)
    {
        cHeap = LocalHeapSize() - (cFree - 512);
        LocalShrink(NULL, cHeap);
        DPRINTF(("MMSYSTEM: Shrinking the heap (%d)\r\n", cHeap));
    }
}

#ifdef  DEBUG_RETAIL
/*****************************************************************************
 * @doc INTERNAL
 *
 * @func void | SetPrivateProfileInt | windows should have this function
 *
 * @comm  used by DriverProc to set debug state in SYSTEM.INI
 *
 ****************************************************************************/

static  void FAR PASCAL SetPrivateProfileInt(LPSTR szSection, LPSTR szKey, int i, LPSTR szIniFile)
{
    char    ach[32] ;

    if (i != (int)GetPrivateProfileInt(szSection, szKey, ~i, szIniFile))
    {
        wsprintf(ach, "%d", i);
        WritePrivateProfileString(szSection, szKey, ach, szIniFile);
    }
}
#endif   //ifdef DEBUG_RETAIL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\mmsystem\dpmipage.asm ===
page    ,132
;-----------------------------Module-Header-----------------------------;
; Module Name:  PAGELOCK
;
;   This module contains functions for page locking memory using DPMI
;
; Created:  03-20-90
; Author:   Todd Laney [ToddLa]
;
; Copyright (c) 1984-1990 Microsoft Corporation
;
; Exported Functions:	none
;
; Public Functions:     DpmiPageLock
;                       DpmiPageUnlock
;
; Public Data:          none
;
; General Description:
;
; Restrictions:
;
;-----------------------------------------------------------------------;

        ?PLM = 1
        ?WIN = 0
        ?NODATA = 1

        .286
        .xlist
        include cmacros.inc
        include int31.inc
        .list

        externA         __AHINCR                    ; KERNEL
        externFP        GlobalHandle                ; KERNEL
        externFP        GlobalHandleNoRip           ; KERNEL
        externFP        GlobalFix                   ; KERNEL
        externFP        GlobalUnFix                 ; KERNEL

ifndef SEGNAME
    SEGNAME equ <_TEXT>
endif

createSeg %SEGNAME, CodeSeg, word, public, CODE

Int31_SelMgt_Get_Base     EQU ((Int31_Sel_Mgt shl 8) + SelMgt_Get_Base )
Int31_Lock_Region         EQU ((Int31_Page_Lock shl 8) + Lock_Region )
Int31_Unlock_Region       EQU ((Int31_Page_Lock shl 8) + Unlock_Region )

; The following structure should be used to access high and low
; words of a DWORD.  This means that "word ptr foo[2]" -> "foo.hi".

LONG    struc
lo      dw      ?
hi      dw      ?
LONG    ends

FARPOINTER      struc
off     dw      ?
sel     dw      ?
FARPOINTER      ends

sBegin CodeSeg
        assumes cs,CodeSeg
        assumes ds,nothing
        assumes es,nothing

;---------------------------Public-Routine------------------------------;
; DpmiPageLock
;
;   page lock a region using DPMI
;
; Entry:
;       lpBase      Selector:offset of base of region to lock
;       dwSize      size in bytes of region to lock
;
; Returns:
;       NZ
;       AX = TRUE if successful
;
; Error Returns:
;       Z
;       AX = FALSE if error
;
; Registers Preserved:
;       BP,DS,SI,DI
; Registers Destroyed:
;       AX,BX,CX,DX,FLAGS
; Calls:
;       INT 31h
; History:
;
;       Wed 04-Jan-1990 13:45:58 -by-  Todd Laney [ToddLa]
;	Created.
;-----------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing

cProc   DpmiPageLock, <NEAR>, <>
;       parmD   lpBase
;       parmD   dwSize
cBegin  nogen
        mov     cx,Int31_Lock_Region
        jmp     short DpmiPageLockUnLock
cEnd    nogen

;---------------------------Public-Routine------------------------------;
; DpmiPageUnlock
;
;   un-page lock a region using DPMI
;
; Entry:
;       lpBase      Selector:offset of base of region to unlock
;       dwSize      size in bytes of region to unlock
;
; Returns:
;       NZ
;       AX = TRUE if successful
;
; Error Returns:
;       Z
;       AX = FALSE if error
;
; Registers Preserved:
;       BP,DS,SI,DI
; Registers Destroyed:
;       AX,BX,CX,DX,FLAGS
; Calls:
;       INT 31h
; History:
;
;       Wed 04-Jan-1990 13:45:58 -by-  Todd Laney [ToddLa]
;	Created.
;-----------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing

cProc   DpmiPageUnlock, <NEAR>, <>
;       parmD   lpBase
;       parmD   dwSize
cBegin  nogen
        mov     cx,Int31_Unlock_Region
        errn$   DpmiPageLockUnLock
cEnd    nogen

cProc   DpmiPageLockUnLock, <NEAR>, <si,di>
        parmD   lpBase
        parmD   dwSize
cBegin
        mov     si,cx                       ; save lock/unlock flag

        mov     ax,Int31_SelMgt_Get_Base
        mov     bx,lpBase.sel
        int     31h                         ; returns CX:DX selector base
        jc      dpl_exit

        mov     bx,cx                       ; BX:CX is base
        mov     cx,dx

        add     cx,lpBase.off               ; add offset into selector base
        adc     bx,0

        mov     ax,si                       ; get lock/unlock flag
        mov     si,dwSize.hi                ; SI:DI length
        mov     di,dwSize.lo

        int     31h                         ; lock or unlock it
dpl_exit:
        cmc                                 ; set carry iff success
        sbb     ax,ax                       ; return TRUE/FALSE
cEnd

;---------------------------Public-Routine------------------------------;
; HugePageLock
;
;   page lock a range of windows allocated memory
;
; Entry:
;       lpBase      Selector:offset of base of region to lock
;       dwSize      size in bytes of region to lock
;
; Returns:
;       AX = TRUE if successful
;
; Error Returns:
;       AX = FALSE if error
;
; Registers Preserved:
;       BP,DS,SI,DI
; Registers Destroyed:
;       AX,BX,CX,DX,FLAGS
; Calls:
;       INT 31h
; History:
;
;       Wed 04-Jan-1990 13:45:58 -by-  Todd Laney [ToddLa]
;	Created.
;-----------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing

cProc   HugePageLock, <FAR, PUBLIC>, <>
        parmD   lpBase
        parmD   dwSize
cBegin
        mov     ax,lpBase.sel               ; NULL pointer, invalid
        or      ax,ax
        jz      GPageLock_Exit

        call    HugeGlobalFix               ; fix the memory, then page lock
        cCall   DpmiPageLock,<lpBase, dwSize>
        jnz     GPageLock_Exit

        mov     ax,lpBase.sel               ; page lock failed, un-fix
        call    HugeGlobalUnFix             ; and return failure
        xor     ax,ax

GPageLock_Exit:
cEnd

;---------------------------Public-Routine------------------------------;
; HugePageUnlock
;
;   un-page lock a range of windows alocated memory, (locked with HugePageLock)
;
; Entry:
;       lpBase      Selector:offset of base of region to lock
;       dwSize      size in bytes of region to lock
;
; Returns:
;       none
;
; Registers Preserved:
;       BP,DS,SI,DI
; Registers Destroyed:
;       AX,BX,CX,DX,FLAGS
; Calls:
;       INT 31h
; History:
;
;       Wed 04-Jan-1990 13:45:58 -by-  Todd Laney [ToddLa]
;	Created.
;-----------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing

cProc   HugePageUnlock, <FAR, PUBLIC>, <>
        parmD   lpBase
        parmD   dwSize
cBegin
        cCall   DpmiPageUnlock,<lpBase, dwSize>

        mov     ax,lpBase.sel
        call    HugeGlobalUnFix
cEnd

;---------------------------Public-Routine------------------------------;
; HugeGlobalFix
;
;   fix the global object that represents the passed selector
;
; Entry:
;       AX = SELECTOR
;
; Returns:
;       none
;
; Registers Preserved:
;       BP,DS,SI,DI
; Registers Destroyed:
;       AX,BX,CX,DX,FLAGS
; Calls:
;       GlobalFix
;       HugeGlobalHandle
; History:
;
;       Wed 04-Jan-1990 13:45:58 -by-  Todd Laney [ToddLa]
;	Created.
;-----------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing

HugeGlobalFix proc near

        call    HugeGlobalHandle
        jz      HugeGlobalFixExit

        cCall   GlobalFix,<ax>

HugeGlobalFixExit:
        ret

HugeGlobalFix endp

;---------------------------Public-Routine------------------------------;
; HugeGlobalUnFix
;
;   un-fix the global object that represents the passed selector
;
; Entry:
;       AX = SELECTOR
;
; Returns:
;       none
;
; Registers Preserved:
;       BP,DS,SI,DI
; Registers Destroyed:
;       AX,BX,CX,DX,FLAGS
; Calls:
;       HugeGlobalHandle
;       GlobalUnFix
; History:
;
;       Wed 04-Jan-1990 13:45:58 -by-  Todd Laney [ToddLa]
;	Created.
;-----------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing

HugeGlobalUnFix proc near

        call    HugeGlobalHandle
        jz      HugeGlobalUnFixExit

        cCall   GlobalUnFix,<ax>

HugeGlobalUnFixExit:
        ret

HugeGlobalUnFix endp

;---------------------------Public-Routine------------------------------;
; HugeGlobalHandle
;
; Entry:
;       AX = SELECTOR to global object
;
; Returns:
;       NZ
;       AX = HANDLE of global object
;
; Error Returns:
;       Z
;       AX = 0 if error
;
; Registers Preserved:
;       BP,DS,SI,DI
; Registers Destroyed:
;       AX,BX,CX,DX,FLAGS
; Calls:
;       GlobalHandleNoRip
; History:
;
;       Wed 04-Jan-1990 13:45:58 -by-  Todd Laney [ToddLa]
;	Created.
;-----------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing

HugeGlobalHandle proc near

        push    si
        mov     si,ax

        or      ax,ax                   ; test for NULL pointer!
        jz      HugeGlobalHandleExit

HugeGlobalHandleAgain:
        cCall   GlobalHandleNoRip,<si>
        sub     si,__AHINCR
        or      ax,ax
        jz      HugeGlobalHandleAgain

HugeGlobalHandleExit:
        pop     si
        ret

HugeGlobalHandle endp

sEnd

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\mmsystem\drvr.h ===
/******************************************************************************

   Copyright (C) Microsoft Corporation 1985-1990. All rights reserved.

   Title:   drvr.h - Installable driver code internal header file.

   Version: 1.00

   Date:    10-Jun-1990

   Author:  DAVIDDS ROBWI

------------------------------------------------------------------------------

   Change log:

      DATE        REV            DESCRIPTION
   -----------   ----- -----------------------------------------------------------
   10-JUN-1990   ROBWI Based on windows 3.1 installable driver code by davidds

*****************************************************************************/

typedef LRESULT (CALLBACK *DRIVERPROC)
        (DWORD dwDriverID, HDRVR hDriver, UINT wMessage, LPARAM lParam1, LPARAM lParam2);

typedef struct tagDRIVERTABLE
{
  WORD    fFirstEntry:1;
  WORD    fBusy:1;
  DWORD   dwDriverIdentifier;
  WORD    hModule;
  DRIVERPROC lpDriverEntryPoint;
} DRIVERTABLE;
typedef DRIVERTABLE FAR *LPDRIVERTABLE;

LONG FAR PASCAL InternalBroadcastDriverMessage(WORD, WORD, LONG, LONG, WORD);
LONG FAR PASCAL InternalCloseDriver(WORD, LONG, LONG, BOOL);
LONG FAR PASCAL InternalOpenDriver(LPSTR, LPSTR, LONG, BOOL);
LONG FAR PASCAL InternalLoadDriver(LPSTR, LPSTR, LPSTR, WORD, BOOL);
WORD FAR PASCAL InternalFreeDriver(WORD, BOOL);
void FAR PASCAL InternalInstallDriverChain (void);
void FAR PASCAL InternalDriverDisable (void);
void FAR PASCAL InternalDriverEnable (void);
int  FAR PASCAL GetDrvrUsage(HANDLE);
HANDLE FAR PASCAL LoadAliasedLibrary (LPSTR, LPSTR, LPSTR, LPSTR, WORD);
void NEAR PASCAL DrvInit(void);

/* Defines for internalbroadcastdrivermessage flags */
#define IBDM_SENDMESSAGE       0x0001
#define IBDM_REVERSE           0x0002
#define IBDM_ONEINSTANCEONLY   0x0004
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\mmsystem\drvr31.asm ===
page    ,132
;-----------------------------Module-Header-----------------------------;
; Module Name:  DRVR31.ASM - Installable driver code.
;
; all this code does is pass any installable driver API on to
; win 3.1 USER.
;
; Created:  28-08-91
; Author:   Todd Laney [ToddLa]
;
; Copyright (c) 1984-1991 Microsoft Corporation
;
;-----------------------------------------------------------------------;

        ?PLM    = 1
        ?WIN    = 0
        PMODE	= 1

	.xlist
	include cmacros.inc
        include windows.inc
        .list

;
; these are the USER driver interface functions
;
        externFP    OpenDriver                  ; USER
        externFP    CloseDriver                 ; USER
        externFP    GetDriverModuleHandle       ; USER
        externFP    SendDriverMessage           ; USER
	externFP    DefDriverProc		; USER

ifdef DEBUG
        externFP    GetModuleFileName           ; KERNEL
        externFP    _dprintf                    ; COMM.ASM
endif

; The following structure should be used to access high and low
; words of a DWORD.  This means that "word ptr foo[2]" -> "foo.hi".

LONG    struc
lo      dw      ?
hi      dw      ?
LONG    ends

FARPOINTER      struc
off     dw      ?
sel     dw      ?
FARPOINTER      ends

ifndef SEGNAME
        SEGNAME equ <_TEXT>
endif

createSeg %SEGNAME, CodeSeg, word, public, CODE

sBegin  CodeSeg
        assumes cs,CodeSeg
        assumes ds,nothing
        assumes es,nothing

;-----------------------------------------------------------------------;
;-----------------------------------------------------------------------;
    assumes ds,nothing
    assumes es,nothing

ifdef DEBUG

szSuccess:
        db "MMSYSTEM: DrvOpen(%ls) (%ls)", 13,10,0

szFailed:
        db "MMSYSTEM: DrvOpen(%ls) *failed*", 13,10,0

cProc DrvOpen, <FAR, PUBLIC, PASCAL, LOADDS>, <>
        ParmD   szDriverName
        ParmD   szSectionName
        ParmD   dw2
        LocalV  ach,128
cBegin
	cCall   OpenDriver, <szDriverName, szSectionName, dw2>
        push    ax

        lea     bx,szFailed
        or      ax,ax
        jz      DrvOpenFailed

        cCall   GetDriverModuleHandle, <ax>

        lea     bx,ach
        cCall   GetModuleFileName,<ax, ss,bx, 128>

        lea     bx,szSuccess

DrvOpenFailed:
        lea     ax,ach
        push    ss                      ; ach
        push    ax

        push    szDriverName.sel        ; szDriverName
        push    szDriverName.off

        push    cs                      ; szFormat
        push    bx

        call    _dprintf                ; dprintf(szFormat, szDriverName, ach)
        add     sp,6*2

DrvOpenExit:
	pop	ax			; return hdrv to caller

DrvOpenExitNow:
cEnd

else ; DEBUG

cProc DrvOpen, <FAR, PUBLIC, PASCAL>, <>
;       ParmD   szDriverName
;       ParmD   szSectionName
;       ParmD   dw2
cBegin nogen

        jmp     OpenDriver

cEnd nogen




endif ; DEBUG

;-----------------------------------------------------------------------;
;-----------------------------------------------------------------------;
    assumes ds,nothing
    assumes es,nothing

cProc DrvClose, <FAR, PUBLIC, PASCAL>, <>
;       ParmW   hDriver
;       ParmD   dw1
;       ParmD   dw2
cBegin nogen

        jmp     CloseDriver

cEnd nogen

;-----------------------------------------------------------------------;
;-----------------------------------------------------------------------;
    assumes ds,nothing
    assumes es,nothing

cProc DrvGetModuleHandle, <FAR, PUBLIC, PASCAL>, <>
;       ParmW   hDriver
cBegin nogen

        jmp     GetDriverModuleHandle

cEnd nogen

;-----------------------------------------------------------------------;
;-----------------------------------------------------------------------;
    assumes ds,nothing
    assumes es,nothing

cProc DrvSendMessage, <FAR, PUBLIC, PASCAL>, <>
;       ParmW   hDriver
;       ParmW   message
;       ParmD   dw1
;       ParmD   dw2
cBegin nogen

        jmp     SendDriverMessage

cEnd nogen

;-----------------------------------------------------------------------;
;-----------------------------------------------------------------------;
    assumes ds,nothing
    assumes es,nothing

cProc DrvDefDriverProc, <FAR, PUBLIC, PASCAL>, <>
;       ParmD   dwDriver
;       ParmW   hDriver
;       ParmW   message
;       ParmD   dw1
;       ParmD   dw2
cBegin nogen

        jmp     DefDriverProc

cEnd nogen

sEnd

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\mmsystem\dosa.asm ===
title	dosa.asm
;
; ASM routines lifted from WINCOM
;
; ToddLa & RussellW
;
; DavidLe removed all but current drive/directory functions
;
?PLM=1	    ; PASCAL Calling convention is DEFAULT
?WIN=0      ; Windows calling convention
PMODE=1     ; Enable enter/leave

        .xlist
        include cmacros.inc
        .list

; -------------------------------------------------------
;               DATA SEGMENT DECLARATIONS
; -------------------------------------------------------

ifndef SEGNAME
    SEGNAME equ <_TEXT>
endif

createSeg %SEGNAME, CodeSeg, word, public, CODE

sBegin  CodeSeg
        assumes CS,CodeSeg
        assumes DS,Data
        assumes ES,nothing

; ----------------------------------------------------------------
;
; @doc	INTERNAL
; @api  int | DosChangeDir | This function changes the current drive
; and directory.
;
; @parm LPSTR | lpszPath | Points to the desired drive and directory path.
; The optional drive identifier must be the first character, followed by
; a colon.  The drive identifier is followed by an optional path
; specification, which may be relative or absolute.
;
; @rdesc Returns one of the following values:
;
; @flag	1	The drive and directory were successfully changed.
; @flag	0	The specified pathname is invalid.  The drive and
;		current directory is restored
;		to the default values when the function was called.
; @flag	-1	The specified drive is invalid.  The drive and directory
;		current directory is restored to the default values when the
;		function was called.
;
; @xref	DosGetCurrentDir, DosGetCurrentPath, DosGetCurrentDrive
;
szCurDir:
        db '.',0

cProc	DosChangeDir,<PUBLIC, FAR, PASCAL>, <ds>
	parmD	lpszPath

	LocalW	fDriveChange
	LocalW	wLastDrive
	LocalW	wReturn
	LocalV	szPoint, 2
cBegin
	mov	fDriveChange, 0

	lds	dx, lpszPath
	mov	bx, dx

	; Check if a drive was specified.  If not, then go direct to ChDir
	cmp	BYTE PTR ds:[bx+1],':'	; no drive allowed
	jnz	chdnodrive

	;  get the current drive to save it in case the drive change/
	;  dir change fails, so we can restore it.
	mov	ah, 19h
	int	21h
	mov	wLastDrive, ax

	mov	fDriveChange, 1		; flag the drive change

	;  Now, change the drive to that specified in the input
	;  string.
	mov	dl, ds:[bx]		; Get the drive letter
	or	dl, 20h			; lower case it
	sub	dl, 'a'			; and adjust so 0 = a:, 1 = b:, etc

	mov	ah, 0eh			; set current drive
	int	21h

	mov	ah, 19h			; get current drive
	int	21h

	cmp	al, dl			; check that chDrive succeeded
	jne	chdDriveError

	;  as a further test of whether the drive change took, attempt
	;  to change to the current directory on the new drive.
        mov     ax, cs
	mov	ds, ax
        mov     dx, CodeSegOFFSET szCurDir
	mov	ah, 3bh
	int	21h
	jc	chdDriveError

	lds	dx, lpszPath
	add	dx, 2			; skip over the drive identifier
	mov	bx, dx
	;; if they passed only drive: without dir path, then end now
	cmp	BYTE PTR ds:[bx], 0	; if path name is "", we are there
	jz	chdok

chdnodrive:
	mov	ah, 3bh
	int	21h
	jc	chdPathError
chdok:
	mov	ax, 1
chdexit:
cEnd

chdPathError:
	mov	wReturn, 0
	jmp	short chderror

chdDriveError:
	mov	wReturn, -1

chderror:
	;  if a drive change occurred, but the CD failed, change
	;  the drive back to that which was the original drive
	;  when entered.
	mov	ax, fDriveChange
	or	ax, ax
	jz	chdNoCD
	
	mov	dx, wLastDrive
	mov	ah, 0eh
	int	21h
	mov	ax, wReturn
	jmp	short chdexit
chdNoCD:
	xor	ax, ax			; return zero on error
	jmp	short chdexit




; ----------------------------------------------------------------
;
; @doc	INTERNAL
; @api  WORD | DosGetCurrentDrive | This function returns the drive identifier
;	of the current drive.
; @rdesc        Returns the drive code of the current drive: 0 is drive
;		A:, 1 is drive B:, etc.
;
; @comm This function assumes that drive A: is zero. Some
;	other DOS functions assume drive A: is one.
;
; @xref	DosSetCurrentDrive
;

cProc	DosGetCurrentDrive,<PUBLIC, FAR, PASCAL>
cBegin
	mov	ah, 19h		; Get Current Drive
	int	21h
	sub	ah, ah		; Zero out AH
cEnd


; ----------------------------------------------------------------
;
; @doc	INTERNAL WINCOM
; @api	WORD | DosSetCurrentDrive | This function sets the current DOS
;		drive to be the specified drive.
;
; @parm	WORD | wDrive | Specifies the drive to be set as the current drive.
;               0 indicates drive A:, 1 is B:, etc.
;
; @rdesc	Returns TRUE if the drive change was successful, or FALSE
;               if the current drive was not changed.
;
; @comm         This is the same range returned by <f DosGetCurrentDrive>.
;               Other functions assume drive A: is 1.
;
;
; @xref	DosGetCurrentDrive
;

cProc	DosSetCurrentDrive,<FAR, PUBLIC, PASCAL>
ParmW Drive
cBegin
	mov     dx, Drive
	mov     ah, 0Eh		; Set Current Drive
	int     21h

	; Check if successful
	mov	ah, 19h		; get current drive
	int	21h

	cmp	al, dl		; check that chDrive succeeded
	jne	SetDriveError
	mov	ax, 1h		; return true on success
SetDriveExit:
cEnd
SetDriveError:
	xor	ax, ax		; return false on error
	jmp	short SetDriveExit



; ----------------------------------------------------------------
;
; @doc	INTERNAL WINCOM
;
; @api	WORD | DosGetCurrentDir | This function copies the current
; directory of the specified drive into a caller-supplied buffer.  This
; function differs from the <f DosGetCurrentPath> function in that it
; copies only the current directory of the specified drive, whereas
; <f DosGetCurrentPath> copies the current drive and its current directory
; into the caller's buffer.
;
; @parm	WORD | wCurdrive | Specifies the drive.  0 is the default drive,
;		1 is drive A, 2 is drive B, etc.
;
; @parm	LPSTR | lpszBuf | Points to the buffer in which to place the
; current directory.  This buffer must be 66 bytes in length.
; The returned directory name will always have a leading '\' character.
;
; @rdesc Returns NULL if the function succeeded.  Otherwise, it returns
; the DOS error code.
;
; @comm The drive identifier value specified by <p wCurdrive>
;	assumes that drive A: is one, whereas the <f DosGetCurrentDrive>
;	function assumes that drive A: is zero.
;
; @xref	DosGetCurrentDrive, DosChangeDir, DosGetCurrentPath
;

cProc	DosGetCurrentDir,<PUBLIC,FAR,PASCAL>,<si,di,ds>
	parmW	wCurdrive
	parmD	lpDest
cBegin
	cld
	les	di, lpDest	; es:di = lpDest
	mov	al, '\'
	stosb
	push	es
	pop	ds		; ds = es
	mov	si, di		; ds:si = lpDest + 1
	; Add NULL char for case of error
	xor	al, al
	stosb			; null terminate in case of error
	
	mov	ah, 47h		; GetCurrentDirectory
	mov	dx, wCurdrive	; of this drive
	int	21h
	jc	CWDexit		; return error code for failure
	xor	ax, ax		; return NULL on success
CWDexit:
cEnd

sEnd	CodeSeg

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\mmsystem\libentry.asm ===
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   LIBENTRY.ASM
;
;   Copyright (c) Microsoft Corporation 1989, 1990. All rights reserved.
;
;   This module contains the entry point for MMsystem.dll
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        PMODE = 1

        include cmacros.inc                   

?PLM=1  ; pascal call convention
?WIN=0  ; Windows prolog/epilog code

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   extrns
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        externNP LibMain
        externFP LocalInit

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   Code segment
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ifndef SEGNAME
    SEGNAME equ <_TEXT>
endif

createSeg %SEGNAME, CodeSeg, word, public, CODE

;-----------------------------------------------------------------------;
;
; Stuff needed to avoid the C runtime coming in, and init the windows
; reserved parameter block at the base of DGROUP
;
sBegin  Data
assumes DS,Data

            DD  0               ; So null pointers get 0
maxRsrvPtrs = 5
            DW  maxRsrvPtrs
usedRsrvPtrs = 0
labelDP     <PUBLIC,rsrvptrs>

DefRsrvPtr  MACRO   name
globalW     name,0
usedRsrvPtrs = usedRsrvPtrs + 1
ENDM

DefRsrvPtr  pLocalHeap          ; Local heap pointer
DefRsrvPtr  pAtomTable          ; Atom table pointer
DefRsrvPtr  pStackTop           ; top of stack
DefRsrvPtr  pStackMin           ; minimum value of SP
DefRsrvPtr  pStackBot           ; bottom of stack

if maxRsrvPtrs-usedRsrvPtrs
            DW maxRsrvPtrs-usedRsrvPtrs DUP (0)
endif

public  __acrtused
	__acrtused = 1

sEnd        Data

sBegin  CodeSeg
	assumes cs,CodeSeg
        assumes ds,Data
        assumes es,nothing

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;       Library entry point
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;--------------------------Private-Routine-----------------------------;
;
; LibEntry - called when DLL is loaded
;
; Entry:
;       CX    = size of heap
;       DI    = module handle
;       DS    = automatic data segment
;       ES:SI = address of command line (not used)
;
; Returns:
;       AX = TRUE if success
; Error Returns:
;       AX = FALSE if error (ie fail load process)
; Registers Preserved:
;	SI,DI,DS,BP
; Registers Destroyed:
;       AX,BX,CX,DX,ES,FLAGS
; Calls:
;	None
; History:
;
;       06-27-89 -by-  Todd Laney [ToddLa]
;	Created.
;-----------------------------------------------------------------------;

cProc   LibEntry,<FAR,PUBLIC,NODATA>,<>
cBegin
	;
        ; Push frame for LibMain (hModule,cbHeap,lpszCmdLine)
	;
	push	di
	push	cx
	push	es
	push	si

        ;
        ; Init the local heap (if one is declared in the .def file)
        ;
        jcxz no_heap

        xor     ax,ax
        cCall   LocalInit,<ax,ax,cx>

no_heap:
        cCall   LibMain
cEnd

	assumes ds,nothing
	assumes es,nothing

cProc   WEP, <FAR, PUBLIC, PASCAL>, <>
;	ParmW  fSystemExit
cBegin nogen
	mov	ax, 1
	retf	2
cEnd   nogen

        sEnd CodeSeg

        end LibEntry
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\mmsystem\isr.asm ===
TITLE   ISR.ASM -- Windows DLL HARDWARE ISR
;****************************************************************************
;
;   PROGRAM: isr.asm
;
;   PURPOSE:
;       Installs an interrupt handler under Windows 3.x
;       This ISR (Interrupt service routine) will then service a requested
;       multi-media callback routine.
;
;   FUNCTIONS:
;       DoInterrupt:                    Performs interrupt processing
;       InstallInterruptHandler:        Installs the interrupt handler
;       DeInstallInterruptHandler:      Removes the interrupt handler
;
;****************************************************************************

        .286
memS    EQU 1                   ;Small memory model

.xlist
        include cmacros.inc
        include windows.inc
        include wowmmcb.inc
	include vint.inc
.list


;-------------------------------------------------------------------------;
;
;   debug support
;
;-------------------------------------------------------------------------;


externFP        OutputDebugString
externFP        DoInterrupt

;-------------------------------------------------------------------------;
;
;   callback support
;
;-------------------------------------------------------------------------;
externW         CodeFixWinFlags



;--------------------------Private-Macro----------------------------------;
; DOUT String - send a debug message to the debugger
;
; Entry:
;       String      String to send to the COM port, does not need a CR,LF
;
; Registers Destroyed:
;       none
;
; NOTE no code is generated unless the DEBUG symbol is defined
;
; History:
;       Sun 31-Jul-1989  -by-  ToddLa
;        Wrote it.
;-------------------------------------------------------------------------;

DOUT    macro   text
        local string_buffer
ifdef MYDEBUG
        push    cs
        push    offset string_buffer
        call    OutputDebugString
        jmp     @F
string_buffer label byte
        db      "MMSYSTEM: "
        db      "&text&",13,10,0
@@:
endif
        endm


;****************************************************************************
;
; Create a fixed code segment
;
;****************************************************************************

createSeg FIX,          CodeFix, word, public, CODE
createSeg INTDS,        DataFix, byte, public, DATA



DOS_SetVector           EQU 2500h
DOS_GetVector           EQU 3500h
Pic1                    EQU 20h
Pic2                    EQU 0a0h

sBegin  Data
staticD dOldVector,0
sEnd

sBegin  CodeFix
        assumes cs,CodeFix
        assumes ds,Data



;****************************************************************************
;   FUNCTION:  InstallInterruptHandler()
;
;   PURPOSE:
;       This routine saves the interrupt vector "MultiMediaVector" in
;       the global variable "dOldVector". Then, it installs a small
;       ISR at that vector which calls the routine "DoInt()" when
;       the interrupt occurs.
;
;
;****************************************************************************
cProc InstallInterruptHandler, <FAR,PUBLIC>, <si,di>
cBegin  InstallInterruptHandler

        push    bx                      ;Save previous vector
        push    es
        mov     ax,DOS_GetVector + MULTIMEDIA_INTERRUPT
        int     21h
        mov     WORD PTR dOldVector,bx
        mov     WORD PTR dOldVector+2,es
        pop     es
        pop     bx


        push    ds                      ;Install handler
        push    dx                      ;
        push    cs
        pop     ds
        mov     dx,OFFSET MULTI_MEDIA_ISR286
        test    cs:[CodeFixWinFlags],WF_WIN286
        jnz     @F
        mov     dx,OFFSET MULTI_MEDIA_ISR386
@@:
        mov     ax,DOS_SetVector + MULTIMEDIA_INTERRUPT
        int     21h
        pop     dx
        pop     ds

        jmp     set_exit

        ; ****  Entry point of ISR  ****
MULTI_MEDIA_ISR286:                     ;Our Multi-Media ISR (286)
        pusha
        push    ds
        push    es

        cCall   DoInterrupt             ;Do Interrupt Handling

        mov     al,20h
        out     Pic2,al                 ;EOI on Pic2
        out     Pic1,al                 ;EOI on Pic1
        pop     es
        pop     ds
        popa
	; FSTI
        ; iret                            ;exit MULTI_MEDIA_ISR
        FIRET

MULTI_MEDIA_ISR386:                     ;Our Multi-Media ISR (286)
.386
        pushad
        push    ds
        push    es
        push    fs
        push    gs

        cCall   DoInterrupt             ;Do Interrupt Handling

        mov     al,20h
        out     Pic2,al                 ;EOI on Pic2
        out     Pic1,al                 ;EOI on Pic1
        pop     gs
        pop     fs
        pop     es
        pop     ds
        popad
	; FSTI
        ; iret                            ;exit MULTI_MEDIA_ISR
        FIRET
.286

set_exit:                               ;exit InstallHandler

;       DOUT    <Interupt installed>
        mov     ax,1                    ;return TRUE

cEnd    InstallInteruptHandler


;****************************************************************************
;   FUNCTION:  DeInstallInterruptHandler()
;
;   PURPOSE:
;       Restores the interrupt vector "MultiMediaVector" with the address
;       at "dOldVector".
;
;****************************************************************************
cProc DeInstallInterruptHandler, <FAR,PUBLIC>, <si,di>
cBegin  DeInstallInterruptHandler

        push    ds                      ;
        push    dx                      ;
        mov     dx,WORD PTR dOldVector
        mov     ax,WORD PTR dOldVector+2
        cmp     dx,0                    ;were we installed?
        jnz     dih_go
        cmp     ax,0
        jz      dih_skip
dih_go:
        mov     ds,ax
        mov     ax,DOS_SetVector + MULTIMEDIA_INTERRUPT
        int     21h

dih_skip:
        pop     dx                      ;
        pop     ds                      ;

cEnd    DeInstallHandler

sEnd
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\mmsystem\idrv.h ===
//==========================================================================;
//
//  idrv.h
//
//  Description:
//      This header file defines common information needed for compiling
//      the installable driver.
//
//  History:
//      11/ 8/92    cjp     [curtisp]
//
//==========================================================================;

#ifndef _INC_IDRV
#define _INC_IDRV                   // #defined if file has been included

#ifndef RC_INVOKED
#pragma pack(1)                     // assume byte packing throughout
#endif

#ifndef EXTERN_C
#ifdef __cplusplus
    #define EXTERN_C extern "C"
#else
    #define EXTERN_C extern
#endif
#endif

#ifdef __cplusplus
extern "C"                          // assume C declarations for C++
{
#endif




//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  Win 32
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifdef WIN32
    #ifndef FNLOCAL
        #define FNLOCAL
        #define FNCLOCAL
        #define FNGLOBAL
        #define FNCGLOBAL
        #define FNWCALLBACK CALLBACK
        #define FNEXPORT    CALLBACK
    #endif

    //
    //
    //
    #define Edit_GetSelEx(hwndCtl, pnS, pnE)    \
        ((DWORD)SendMessage((hwndCtl), EM_GETSEL, (WPARAM)pnS, (LPARAM)pnE))

    //
    //  for compiling Unicode
    //
    #ifdef UNICODE
        #define SIZEOF(x)   (sizeof(x)/sizeof(WCHAR))
    #else
        #define SIZEOF(x)   sizeof(x)
    #endif

    //
    //  win32 apps [usually] don't have to worry about 'huge' data
    //
    #define hmemcpy     memcpy
#endif // #ifdef WIN32


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  Win 16
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifndef WIN32
    #ifndef FNLOCAL
        #ifdef CALLBACK
            #undef CALLBACK
        #endif
        #ifdef _WINDLL
            #define CALLBACK    _far _pascal _loadds
        #else
            #define CALLBACK    _far _pascal
        #endif

    #ifdef DEBUG
        #define FNLOCAL     NEAR PASCAL
        #define FNCLOCAL    NEAR _cdecl
    #else
        #define FNLOCAL     static NEAR PASCAL
        #define FNCLOCAL    static NEAR _cdecl
    #endif
        #define FNGLOBAL    FAR PASCAL
        #define FNCGLOBAL   FAR _cdecl
        #define FNWCALLBACK CALLBACK
        #define FNEXPORT    CALLBACK _export
    #endif

    //
    //  stuff for Unicode in Win 32--make it a noop in Win 16
    //
    #ifndef _TCHAR_DEFINED
        #define _TCHAR_DEFINED
        typedef char            TCHAR, *PTCHAR;
        typedef unsigned char   TBYTE, *PTUCHAR;

        typedef PSTR            PTSTR, PTCH;
        typedef LPSTR           LPTSTR, LPTCH;
        typedef LPCSTR          LPCTSTR;
    #endif

    #define TEXT(a)         a
    #define SIZEOF(x)       sizeof(x)

    //
    //
    //
    #define CharNext        AnsiNext
    #define CharPrev        AnsiPrev

    //
    //
    //
    #define Edit_GetSelEx(hwndCtl, pnS, pnE)                        \
    {                                                               \
        DWORD   dw;                                                 \
        dw = (DWORD)SendMessage((hwndCtl), EM_GETSEL, 0, 0L);       \
        *pnE = (int)HIWORD(dw);                                     \
        *pnS = (int)LOWORD(dw);                                     \
    }

    //
    //  common message cracker macros available in windowx.h on NT--these
    //  should be added to the Win 16 windowsx.h and probably will be
    //  in the future.
    //
    //  there is a windowsx.h16 that ships with the NT PDK that defines
    //  these macros. so if that version is being used, don't redefine
    //  message crackers.
    //

#ifndef WM_CTLCOLORMSGBOX
    #define WM_CTLCOLORMSGBOX           0x0132
    #define WM_CTLCOLOREDIT             0x0133
    #define WM_CTLCOLORLISTBOX          0x0134
    #define WM_CTLCOLORBTN              0x0135
    #define WM_CTLCOLORDLG              0x0136
    #define WM_CTLCOLORSCROLLBAR        0x0137
    #define WM_CTLCOLORSTATIC           0x0138
#endif

#ifndef GET_WM_ACTIVATE_STATE
    #define GET_WM_ACTIVATE_STATE(wp, lp)           (wp)
    #define GET_WM_ACTIVATE_FMINIMIZED(wp, lp)      (BOOL)HIWORD(lp)
    #define GET_WM_ACTIVATE_HWND(wp, lp)            (HWND)LOWORD(lp)
    #define GET_WM_ACTIVATE_MPS(s, fmin, hwnd)      (WPARAM)(s), MAKELONG(hwnd, fmin)

    #define GET_WM_CHARTOITEM_CHAR(wp, lp)          (CHAR)(wp)
    #define GET_WM_CHARTOITEM_POS(wp, lp)           HIWORD(lp)
    #define GET_WM_CHARTOITEM_HWND(wp, lp)          (HWND)LOWORD(lp)
    #define GET_WM_CHARTOITEM_MPS(ch, pos, hwnd)    (WPARAM)(ch), MAKELONG(hwnd, pos)

    #define GET_WM_COMMAND_ID(wp, lp)               (wp)
    #define GET_WM_COMMAND_HWND(wp, lp)             (HWND)LOWORD(lp)
    #define GET_WM_COMMAND_CMD(wp, lp)              HIWORD(lp)
    #define GET_WM_COMMAND_MPS(id, hwnd, cmd)       (WPARAM)(id), MAKELONG(hwnd, cmd)

    #define GET_WM_CTLCOLOR_HDC(wp, lp, msg)        (HDC)(wp)
    #define GET_WM_CTLCOLOR_HWND(wp, lp, msg)       (HWND)LOWORD(lp)
    #define GET_WM_CTLCOLOR_TYPE(wp, lp, msg)       HIWORD(lp)
    #define GET_WM_CTLCOLOR_MPS(hdc, hwnd, type)    (WPARAM)(hdc), MAKELONG(hwnd, type)

    #define GET_WM_MENUSELECT_CMD(wp, lp)           (wp)
    #define GET_WM_MENUSELECT_FLAGS(wp, lp)         LOWORD(lp)
    #define GET_WM_MENUSELECT_HMENU(wp, lp)         (HMENU)HIWORD(lp)
    #define GET_WM_MENUSELECT_MPS(cmd, f, hmenu)    (WPARAM)(cmd), MAKELONG(f, hmenu)

    // Note: the following are for interpreting MDIclient to MDI child messages.
    #define GET_WM_MDIACTIVATE_FACTIVATE(hwnd, wp, lp)  (BOOL)(wp)
    #define GET_WM_MDIACTIVATE_HWNDDEACT(wp, lp)        (HWND)HIWORD(lp)
    #define GET_WM_MDIACTIVATE_HWNDACTIVATE(wp, lp)     (HWND)LOWORD(lp)

    // Note: the following is for sending to the MDI client window.
    #define GET_WM_MDIACTIVATE_MPS(f, hwndD, hwndA) (WPARAM)(hwndA), 0

    #define GET_WM_MDISETMENU_MPS(hmenuF, hmenuW)   0, MAKELONG(hmenuF, hmenuW)

    #define GET_WM_MENUCHAR_CHAR(wp, lp)            (CHAR)(wp)
    #define GET_WM_MENUCHAR_HMENU(wp, lp)           (HMENU)LOWORD(lp)
    #define GET_WM_MENUCHAR_FMENU(wp, lp)           (BOOL)HIWORD(lp)
    #define GET_WM_MENUCHAR_MPS(ch, hmenu, f)       (WPARAM)(ch), MAKELONG(hmenu, f)

    #define GET_WM_PARENTNOTIFY_MSG(wp, lp)         (wp)
    #define GET_WM_PARENTNOTIFY_ID(wp, lp)          HIWORD(lp)
    #define GET_WM_PARENTNOTIFY_HWNDCHILD(wp, lp)   (HWND)LOWORD(lp)
    #define GET_WM_PARENTNOTIFY_X(wp, lp)           (INT)LOWORD(lp)
    #define GET_WM_PARENTNOTIFY_Y(wp, lp)           (INT)HIWORD(lp)
    #define GET_WM_PARENTNOTIFY_MPS(msg, id, hwnd)  (WPARAM)(msg), MAKELONG(hwnd, id)
    #define GET_WM_PARENTNOTIFY2_MPS(msg, x, y)     (WPARAM)(msg), MAKELONG(x, y)

    #define GET_WM_VKEYTOITEM_CODE(wp, lp)          (wp)
    #define GET_WM_VKEYTOITEM_ITEM(wp, lp)          (INT)HIWORD(lp)
    #define GET_WM_VKEYTOITEM_HWND(wp, lp)          (HWND)LOWORD(lp)
    #define GET_WM_VKEYTOITEM_MPS(code, item, hwnd) (WPARAM)(code), MAKELONG(hwnd, item)

    #define GET_EM_SETSEL_START(wp, lp)             LOWORD(lp)
    #define GET_EM_SETSEL_END(wp, lp)               HIWORD(lp)
    #define GET_EM_SETSEL_MPS(iStart, iEnd)         0, MAKELONG(iStart, iEnd)

    #define GET_EM_LINESCROLL_MPS(vert, horz)       0, MAKELONG(vert, horz)

    #define GET_WM_CHANGECBCHAIN_HWNDNEXT(wp, lp)   (HWND)LOWORD(lp)

    #define GET_WM_HSCROLL_CODE(wp, lp)             (wp)
    #define GET_WM_HSCROLL_POS(wp, lp)              LOWORD(lp)
    #define GET_WM_HSCROLL_HWND(wp, lp)             (HWND)HIWORD(lp)
    #define GET_WM_HSCROLL_MPS(code, pos, hwnd)     (WPARAM)(code), MAKELONG(pos, hwnd)

    #define GET_WM_VSCROLL_CODE(wp, lp)             (wp)
    #define GET_WM_VSCROLL_POS(wp, lp)              LOWORD(lp)
    #define GET_WM_VSCROLL_HWND(wp, lp)             (HWND)HIWORD(lp)
    #define GET_WM_VSCROLL_MPS(code, pos, hwnd)     (WPARAM)(code), MAKELONG(pos, hwnd)
#endif

#endif // #ifndef WIN32






//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  Installable Driver Version Information:
//
//
//
//  NOTE! all string resources that will be used in app.rcv for the
//  version resource information *MUST* have an explicit \0 terminator!
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#define IDRV_VERSION_MAJOR          3
#define IDRV_VERSION_MINOR          11
#define IDRV_VERSION_BUILD          43
#ifdef UNICODE
#define IDRV_VERSION_STRING_RC      "Version 3.11 (Unicode Enabled)\0"
#else
#define IDRV_VERSION_STRING_RC      "Version 3.11\0"
#endif

#define IDRV_VERSION_NAME_RC        "msmixmgr.dll\0"
#define IDRV_VERSION_COMPANYNAME_RC "Microsoft Corporation\0"
#define IDRV_VERSION_COPYRIGHT_RC   "Copyright \251 Microsoft Corp. 1993\0"

#define IDRV_VERSION_PRODUCTNAME_RC "Microsoft Audio Mixer Manager\0"

#ifdef DEBUG
#define IDRV_VERSION_DESCRIPTION_RC "Microsoft Audio Mixer Manager (debug)\0"
#else
#define IDRV_VERSION_DESCRIPTION_RC "Microsoft Audio Mixer Manager\0"
#endif


//
//  Unicode versions (if UNICODE is defined)... the resource compiler
//  cannot deal with the TEXT() macro.
//
#define IDRV_VERSION_STRING         TEXT(IDRV_VERSION_STRING_RC)
#define IDRV_VERSION_NAME           TEXT(IDRV_VERSION_NAME_RC)
#define IDRV_VERSION_COMPANYNAME    TEXT(IDRV_VERSION_COMPANYNAME_RC)
#define IDRV_VERSION_COPYRIGHT      TEXT(IDRV_VERSION_COPYRIGHT_RC)
#define IDRV_VERSION_PRODUCTNAME    TEXT(IDRV_VERSION_PRODUCTNAME_RC)
#define IDRV_VERSION_DESCRIPTION    TEXT(IDRV_VERSION_DESCRIPTION_RC)




//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  misc defines for misc sizes and things...
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

//
//  bilingual. this allows the same identifier to be used in resource files
//  and code without having to decorate the id in your code.
//
#ifdef RC_INVOKED
    #define RCID(id)                id
#else
    #define RCID(id)                MAKEINTRESOURCE(id)
#endif


//
//
//
#ifdef WIN32
    #define BSTACK
    #define BCODE
    #define BDATA
#else
    #define BSTACK  _based(_segname("_STACK"))
    #define BCODE   _based(_segname("_CODE"))
    #define BDATA   _based(_segname("_DATA"))
#endif


//
//
//
//
#define IDRV_MAX_STRING_RC_CHARS    512
#define IDRV_MAX_STRING_RC_BYTES    (IDRV_MAX_STRING_RC_CHARS * sizeof(TCHAR))
#define IDRV_MAX_STRING_ERROR_CHARS 512
#define IDRV_MAX_STRING_ERROR_BYTES (IDRV_MAX_STRING_ERROR_CHARS * sizeof(TCHAR))


//
//  resource defines...
//
#define ICON_IDRV                   RCID(10)


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

BOOL FNGLOBAL ProfileWriteUInt
(
    LPCTSTR         pszSection,
    LPCTSTR         pszKey,
    UINT            uValue
);

UINT FNGLOBAL ProfileReadUInt
(
    LPCTSTR         pszSection,
    LPCTSTR         pszKey,
    UINT            uDefault
);

BOOL FNGLOBAL ProfileWriteString
(
    LPCTSTR         pszSection,
    LPCTSTR         pszKey,
    LPCTSTR         pszValue
);

UINT FNGLOBAL ProfileReadString
(
    LPCTSTR         pszSection,
    LPCTSTR         pszKey,
    LPCTSTR         pszDefault,
    LPTSTR          pszBuffer,
    UINT            cbBuffer
);

BOOL FNGLOBAL ProfileWriteBytes
(
    LPCTSTR         pszSection,
    LPCTSTR         pszKey,
    LPBYTE          pbStruct,
    UINT            cbStruct
);

BOOL FNGLOBAL ProfileReadBytes
(
    LPCTSTR         pszSection,
    LPCTSTR         pszKey,
    LPBYTE          pbStruct,
    UINT            cbStruct
);


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

//
//
//
#define BOGUS_DRIVER_ID     1L


//
//
//
//
typedef struct tIDRVINST
{
    HDRVR           hdrvr;          // driver handle we were opened with

} IDRVINST, *PIDRVINST, FAR *LPIDRVINST;



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

LRESULT FNGLOBAL IDrvLoad
(
    HDRVR               hdrvr
);

LRESULT FNGLOBAL IDrvFree
(
    HDRVR               hdrvr
);

LRESULT FNGLOBAL IDrvEnable
(
    HDRVR               hdrvr
);

LRESULT FNGLOBAL IDrvDisable
(
    HDRVR               hdrvr
);

LRESULT FNGLOBAL IDrvExitSession
(
    PIDRVINST           pidi
);

LRESULT FNGLOBAL IDrvConfigure
(
    PIDRVINST           pidi,
    HWND                hwnd,
    LPDRVCONFIGINFO     pdci
);


LRESULT FNGLOBAL IDrvInstall
(
    PIDRVINST           pidi,
    LPDRVCONFIGINFO     pdci
);

LRESULT FNGLOBAL IDrvRemove
(
    PIDRVINST           pidi
);



//
//  defines for gfuIDrvFlags
//
//
#define IDRVF_FIRSTLOAD             0x0001
#define IDRVF_ENABLED               0x0002


//
//  defines for gfuIDrvOptions
//
//
#define IDRV_OPTF_ZYZSMAG           0x0001



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  global variables
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

extern HINSTANCE    ghinstIDrv;

extern UINT         gfuIDrvFlags;
extern UINT         gfuIDrvOptions;

extern TCHAR        gszIDrvSecConfig[];
extern TCHAR        gszNull[];


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifndef RC_INVOKED
#pragma pack()                      // revert to default packing
#endif

#ifdef __cplusplus
}                                   // end of extern "C" {
#endif

#endif // _INC_IDRV
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\mmsystem\joy.c ===
/******************************************************************************

   Copyright (C) Microsoft Corporation 1985-1990. All rights reserved.

   Title:   joy.c - MMSYSTEM Joystick interface code

   Version: 1.00

   Date:    10-Jun-1990

   Author:  GLENNS ROBWI

------------------------------------------------------------------------------

   Change log:

      DATE        REV            DESCRIPTION
  --------   ----- -----------------------------------------------------------
    2/7/90             Changes to avoid a bug in Windows which won't allow
                       FreeLibrary to be called during WEP.

    10/11/90      .61  Use windows timer + general cleanup

*****************************************************************************/

#include <windows.h>
#include "mmsystem.h"
#include "mmddk.h"
#include "mmsysi.h"
#include "thunks.h"

//  Put init and terminate code in correct segment.

static void NEAR PASCAL joyGetCalibration(void);

#pragma alloc_text( INIT, JoyInit )
#pragma alloc_text( INIT, joyGetCalibration)

/* -------------------------------------------------------------------------
** Thunking stuff
** -------------------------------------------------------------------------
*/
extern JOYMESSAGEPROC PASCAL joy32Message;



/****************************************************************************

    strings

****************************************************************************/

extern char far szNull[];                   // in INIT.C
extern char far szSystemIni[];
extern char far szJoystick[];
extern char far szJoystickDrv[];
extern char far szDrivers[];

char szJoyKey[] = "JoyCal ";

/****************************************************************************

    Joystick Capture Internal Structure

****************************************************************************/

typedef struct joycapture_tag {
    HWND    hWnd;
    UINT    wPeriod;
    BOOL    bChanged;
    UINT    wThreshold;
    UINT    wIDEvent;
} JOYCAPTURE;

#define iJoyMax 2
#define JOY_UNINITIALIZED 0xFFFF

// !!! Code assumes these constants equal 0 and 1

#if JOYSTICKID1	!= 0
ERROR IN ASSUMMED CONSTANT
#endif
#if JOYSTICKID2	!= 1
ERROR IN ASSUMMED CONSTANT
#endif


/****************************************************************************

    Local data

****************************************************************************/

static JOYCAPTURE  JoyCapture[iJoyMax];
static HDRVR       hDrvJoy[iJoyMax];
static UINT        wNumDevs = JOY_UNINITIALIZED;

void CALLBACK joyPollCallback(HWND hWnd, UINT wMsg, UINT wIDEvent, DWORD dwTime);

/****************************************************************************

    @doc INTERNAL

    @api void | joyGetCalibration | Retrieve and set calibration from
    [joystick.drv] section of system.ini file.

****************************************************************************/

// !!! need to do clean up of strings in all of mmsystem

static void NEAR PASCAL joyGetCalibration(void)
{
    char szKeyName[sizeof(szJoyKey)];

    #define hexval(h)   (int)(h>='a'?h-'a'+10:h-'0')

    UINT     val[6];
    UINT     wDev,wVal;
    int      hv;
    char     c,sz[80],far *psz;

    lstrcpy(szKeyName, szJoyKey);
    for (wDev=0; wDev < wNumDevs; wDev++)
    {
        szKeyName[sizeof(szKeyName)-2] = (char)(wDev + '0');

        if (GetPrivateProfileString(szJoystickDrv,
                szKeyName,szNull,sz,sizeof(sz),szSystemIni))
        {
            AnsiLower(sz);
            for (psz=sz,wVal=0; c = *psz, wVal < 6; psz++)
            {
                if (c != ' ')
                {
                    hv=0;

                    do {
                        hv = (hv << 4) + hexval(c);
                    } while ((c=*++psz) && (c!=' '));

                    val[wVal++] = hv;
                }
            }
            joySetCalibration (wDev,val+0,val+1,val+2,val+3,val+4,val+5);
        }
    }
}

/****************************************************************************

    @doc INTERNAL

    @api BOOL | JoyInit | This function initializes the joystick services.

    @rdesc The return value is TRUE if the services are initialised, FALSE
	   if an error occurs

****************************************************************************/

BOOL FAR PASCAL JoyInit(void)
{
    // Only attempt initialization once.
    if (wNumDevs != JOY_UNINITIALIZED) {
        return FALSE;
    }
    else {
        wNumDevs = 0;
    }

    wNumDevs = joyMessage( (HDRVR)1, JDD_GETNUMDEVS, 0L, 0L );

    // Make sure driver was installed.
    if (joy32Message == NULL) {
        return FALSE;
    }

    switch ( wNumDevs ) {

    case 2:
        hDrvJoy[1] = (HDRVR)2;
        /* fall thru */

    case 1:
        hDrvJoy[0] = (HDRVR)1;
        break;

    default:
        return FALSE;
    }

    // Initialize joycapture...

    // Code relies on hWnd being NULL or an invalid window handle
    // if joystick is not captured.

    JoyCapture[0].hWnd = NULL;
    JoyCapture[1].hWnd = NULL;

    // Code relies on joystick threshold being initialized to a rational
    // value. 0 essentially turns threshold off - any change in joystick
    // position will be reported.

    JoyCapture[0].wThreshold= 0;
    JoyCapture[1].wThreshold= 0;

    JoyCapture[0].wIDEvent= 0;
    JoyCapture[1].wIDEvent= 0;

    // bChanged, and wPeriod do not need initializing.

    joyGetCalibration ();

    return TRUE;

}


/****************************************************************************
*
*   MMSYSTEM JOYSTICK API'S
*
****************************************************************************/

/****************************************************************************

    @doc EXTERNAL

    @api UINT | joyGetDevCaps | This function queries a joystick device to
    determine its capabilities.

    @parm UINT | wId | Identifies the device to be queried. This value
    is either JOYSTICKID1 or JOYSTICKID2.

    @parm LPJOYCAPS | lpCaps | Specifies a far pointer to a <t JOYCAPS>
    data structure.  This structure is filled with information about the
    capabilities of the joystick device.

    @parm UINT | wSize | Specifies the size of the <t JOYCAPS> structure.

    @rdesc Returns JOYERR_NOERROR if successful.  Otherwise, returns one of the
    following error codes:

    @flag MMSYSERR_NODRIVER | The joystick driver is not present.

    @flag JOYERR_PARMS | The specified joystick device ID <p wId> is invalid.

    @comm Use <f joyGetNumDevs> to determine the number of
    joystick devices supported by the driver.

    @xref joyGetNumDevs
****************************************************************************/

UINT WINAPI joyGetDevCaps(UINT wId, LPJOYCAPS lpCaps, UINT wSize)
{
    V_WPOINTER(lpCaps, wSize, MMSYSERR_INVALPARAM);

    if ((!hDrvJoy[0] && !JoyInit()) || (wId >= iJoyMax))
        return MMSYSERR_NODRIVER;

    if (wId >= wNumDevs)
        return JOYERR_PARMS;

    return joyMessage( hDrvJoy[wId], JDD_GETDEVCAPS,
                       (DWORD)lpCaps, (DWORD)wSize );
}

/****************************************************************************

    @doc EXTERNAL

    @api UINT | joyGetNumDevs | This function returns the number of joystick
    devices supported by the system.

    @rdesc Returns the number of joystick devices supported by the joystick
    driver. If no driver is present, the function returns zero.

    @comm Use <f joyGetPos> to determine whether a given
    joystick is actually attached to the system. The <f joyGetPos> function returns
    a JOYERR_UNPLUGGED error code if the specified joystick is not connected.

    @xref joyGetDevCaps joyGetPos

****************************************************************************/

UINT WINAPI joyGetNumDevs(void)
{
    // Return 0 on error (Can't return JOYERR_NODRIVER
    // since no way to distinguish error code from valid count.)

    if (!hDrvJoy[0] && !JoyInit())
        return 0;

    return wNumDevs;
}

/****************************************************************************

    @doc EXTERNAL

    @api UINT | joyGetPos | This function queries for the position and button
    activity of a joystick device.

    @parm UINT | wId | Identifies the joystick device to be queried.
    This value is either JOYSTICKID1 or JOYSTICKID2.

    @parm LPJOYINFO | lpInfo | Specifies a far pointer to a <t JOYINFO>
    data structure.  This structure is filled with information about the
    position and button activity of the joystick device.

    @rdesc Returns JOYERR_NOERROR if successful.  Otherwise, returns one of the
    following error codes:

    @flag MMSYSERR_NODRIVER | The joystick driver is not present.

    @flag JOYERR_PARMS | The specified joystick device ID <p wId> is invalid.

    @flag JOYERR_UNPLUGGED | The specified joystick is not connected to the
    system.

****************************************************************************/

UINT WINAPI joyGetPos(UINT wId, LPJOYINFO lpInfo)
{
    V_WPOINTER(lpInfo, sizeof(JOYINFO), MMSYSERR_INVALPARAM);

    if ((!hDrvJoy[0] && !JoyInit()) || (wId >= iJoyMax))
        return MMSYSERR_NODRIVER;

    if (wId >= wNumDevs)
       return JOYERR_PARMS;

    return joyMessage( hDrvJoy[wId], JDD_GETPOS, (DWORD)lpInfo, 0L );
}

/****************************************************************************

    @doc EXTERNAL

    @api UINT | joyGetThreshold | This function queries the current
    movement threshold of a joystick device.

    @parm UINT | wId | Identifies the joystick device to be queried.
    This value is either JOYSTICKID1 or JOYSTICKID2.

    @parm UINT FAR* | lpwThreshold | Specifies a far pointer to a UINT variable
    that is filled with the movement threshold value.

    @rdesc Returns JOYERR_NOERROR if successful.  Otherwise, returns one of the
    following error codes:

    @flag MMSYSERR_NODRIVER | The joystick driver is not present.

    @flag JOYERR_PARMS | The specified joystick device ID <p wId> is invalid.

    @comm The movement threshold is the distance the joystick must be
	  moved before a WM_JOYMOVE message is sent to a window that has
	  captured the device. The threshold is initially zero.

    @xref joySetThreshold

****************************************************************************/

UINT WINAPI joyGetThreshold(UINT wId, UINT FAR* lpwThreshold)
{
    V_WPOINTER(lpwThreshold, sizeof(UINT), MMSYSERR_INVALPARAM);

    if (!hDrvJoy[0] && !JoyInit())
        return MMSYSERR_NODRIVER;

    if (wId >= iJoyMax)
        return MMSYSERR_INVALPARAM;

    if (wId >= wNumDevs)
       return JOYERR_PARMS;

    *lpwThreshold = (JoyCapture[wId].wThreshold);

    return JOYERR_NOERROR;
}

/****************************************************************************

    @doc EXTERNAL

    @api UINT | joyReleaseCapture | This function releases the capture
    set by <f joySetCapture> on the specified joystick device.

    @parm UINT | wId | Identifies the joystick device to be released.
    This value is either JOYSTICKID1 or JOYSTICK2.

    @rdesc Returns JOYERR_NOERROR if successful.  Otherwise, returns one of the
    following error codes:

    @flag MMSYSERR_NODRIVER | The joystick driver is not present.

    @flag JOYERR_PARMS | The specified joystick device ID <p wId> is invalid.

    @xref joySetCapture
****************************************************************************/

UINT WINAPI joyReleaseCapture(UINT wId)
{
    if (!hDrvJoy[0] && !JoyInit())
        return MMSYSERR_NODRIVER;

    if (wId >= iJoyMax)
        return MMSYSERR_INVALPARAM;

    if (wId >= wNumDevs)
       return JOYERR_PARMS;

    if (JoyCapture[wId].hWnd == NULL)
        return JOYERR_NOERROR;

    KillTimer (NULL, JoyCapture[wId].wIDEvent);
    JoyCapture[wId].wIDEvent = 0;
    JoyCapture[wId].hWnd = NULL;

    return JOYERR_NOERROR;
}

/****************************************************************************

    @doc EXTERNAL

    @api UINT | joySetCapture | This function causes joystick messages to
    be sent to the specified window.

    @parm HWND | hWnd | Specifies a handle to the window to which messages
    are to be sent.

    @parm UINT | wId | Identifies the joystick device to be captured.
    This value is either JOYSTICKID1 or JOYSTICKID2.

    @parm UINT | wPeriod | Specifies the polling rate, in milliseconds.

    @parm BOOL | bChanged | If this parameter is set to TRUE, then messages
    are sent only when the position changes by a value greater than the
    joystick movement threshold.

    @rdesc Returns JOYERR_NOERROR if successful.  Otherwise, returns one of the
    following error codes:

    @flag MMSYSERR_NODRIVER | The joystick driver is not present.

    @flag JOYERR_PARMS | The specified window handle <p hWnd>
    or joystick device ID <p wId> is invalid.

    @flag JOYERR_NOCANDO | Cannot capture joystick input because some
    required service (for example, a Windows timer) is unavailable.

    @flag JOYERR_UNPLUGGED | The specified joystick is not connected to the
    system.

    @comm     This function fails if the specified joystick device is
    currently captured.  You should call the <f joyReleaseCapture> function when
    the joystick capture is no longer needed.  If the window is destroyed,
    the joystick will be released automatically.

    @xref  joyReleaseCapture joySetThreshold joyGetThreshold

****************************************************************************/

UINT WINAPI joySetCapture(HWND hwnd, UINT wId, UINT wPeriod, BOOL bChanged )
{
    JOYINFO     joyinfo;
    LPJOYINFO   lpinfo = &joyinfo;
    UINT        w;
    JOYCAPS     JoyCaps;

    if (!hwnd || !IsWindow(hwnd))
        return JOYERR_PARMS;

    if (!hDrvJoy[0] && !JoyInit())
        return MMSYSERR_NODRIVER;

    if (wId >= iJoyMax)
        return MMSYSERR_INVALPARAM;

    if (wId >= wNumDevs)
       return JOYERR_PARMS;

    if (JoyCapture[wId].hWnd)
        if (IsWindow(JoyCapture[wId].hWnd))
            return JOYERR_NOCANDO;
        else
            joyReleaseCapture(wId);

    if (joyGetDevCaps (wId, &JoyCaps, sizeof(JOYCAPS)) == 0)
	wPeriod = min(JoyCaps.wPeriodMax,max(JoyCaps.wPeriodMin,wPeriod));
    else
        return JOYERR_NOCANDO;

    // ensure that position info. is ok.

    if (w = joyGetPos(wId, lpinfo))
        return (w);

    JoyCapture[wId].wPeriod = wPeriod;
    JoyCapture[wId].bChanged = bChanged;

    if (!(JoyCapture[wId].wIDEvent = SetTimer(NULL, 0, wPeriod, (TIMERPROC)joyPollCallback)))
    {
        DOUT("MMSYSTEM: Couldn't allocate timer in joy.c\r\n");
        return JOYERR_NOCANDO;
    }

    JoyCapture[wId].hWnd = hwnd;
    return JOYERR_NOERROR;
}

/****************************************************************************

    @doc EXTERNAL

    @api UINT | joySetThreshold | This function sets the movement threshold
	 of a joystick device.

    @parm UINT | wId | Identifies the joystick device.  This value is either
    JOYSTICKID1 or JOYSTICKID2.

    @parm UINT | wThreshold | Specifies the new movement threshold.

    @rdesc Returns JOYERR_NOERROR if successful.  Otherwise, returns one of the
    following error codes:

    @flag MMSYSERR_NODRIVER | The joystick driver is not present.

    @flag JOYERR_PARMS | The specified joystick device ID <p wId> is invalid.

    @comm The movement threshold is the distance the joystick must be
	  moved before a MM_JOYMOVE message is sent to a window that has
	  captured the device.

    @xref joyGetThreshold joySetCapture

****************************************************************************/

UINT WINAPI joySetThreshold(UINT wId, UINT wThreshold)
{
    if (!hDrvJoy[0] && !JoyInit())
        return MMSYSERR_NODRIVER;

    if (wId >= iJoyMax)
        return MMSYSERR_INVALPARAM;

    if (wId >= wNumDevs)
       return JOYERR_PARMS;

    JoyCapture[wId].wThreshold = wThreshold;
    return JOYERR_NOERROR;
}

/****************************************************************************

    @doc INTERNAL

    @api UINT | joySetCalibration | This function sets the values used to
	 convert the values returned by the joystick drivers GetPos function
	 to the range specified in GetDevCaps.

    @parm UINT | wId | Identifies the joystick device

    @parm UINT FAR* | pwXbase | Specifies the base value for the X pot.  The
	  previous value will be copied back to the variable pointed to here.

    @parm UINT FAR* | pwXdelta | Specifies the delta value for the X pot.	The
	  previous value will be copied back to the variable pointed to here.

    @parm UINT FAR* | pwYbase | Specifies the base value for the Y pot.  The
	  previous value will be copied back to the variable pointed to here.

    @parm UINT FAR* | pwYdelta | Specifies the delta value for the Y pot.	The
	  previous value will be copied back to the variable pointed to here.

    @parm UINT FAR* | pwZbase | Specifies the base value for the Z pot.  The
	  previous value will be copied back to the variable pointed to here.

    @parm UINT FAR* | pwZdelta | Specifies the delta value for the Z pot.	The
	  previous value will be copied back to the variable pointed to here.

    @rdesc The return value is zero if the function was successful, otherwise
	   it is an error number.

    @comm The base represents the lowest value the joystick driver returns,
	  whereas the delta represents the multiplier to use to convert
	  the actual value returned by the driver to the valid range
	  for the joystick API's.
	  i.e.	If the driver returns a range of 43-345 for the X pot, and
	  the valid mmsystem API range is 0-65535, the base value will be
	  43, and the delta will be 65535/(345-43)=217.  Thus the base,
	  and delta convert 43-345 to a range of 0-65535 with the formula:
	  ((wXvalue-43)*217) , where wXvalue was given by the joystick driver.

****************************************************************************/

UINT WINAPI joySetCalibration( UINT wId,
                               UINT FAR* pwXbase,
                               UINT FAR* pwXdelta,
                               UINT FAR* pwYbase,
                               UINT FAR* pwYdelta,
                               UINT FAR* pwZbase,
                               UINT FAR* pwZdelta )
{
    JOYCALIBRATE    oldCal,newCal;
    UINT w;

    if (!hDrvJoy[0] && !JoyInit())
        return MMSYSERR_NODRIVER;

    if (wId >= wNumDevs)
       return JOYERR_PARMS;

    newCal.wXbase  = *pwXbase;
    newCal.wXdelta = *pwXdelta;

    newCal.wYbase  = *pwYbase;
    newCal.wYdelta = *pwYdelta;

    newCal.wZbase  = *pwZbase;
    newCal.wZdelta = *pwZdelta;

    w = joyMessage( hDrvJoy[wId], JDD_SETCALIBRATION, (DWORD)(LPSTR)&newCal,
                    (DWORD)(LPSTR)&oldCal );

    *pwXbase  = oldCal.wXbase;
    *pwXdelta = oldCal.wXdelta;

    *pwYbase  = oldCal.wYbase;
    *pwYdelta = oldCal.wYdelta;

    *pwZbase  = oldCal.wZbase;
    *pwZdelta = oldCal.wZdelta;

    return w;
}

/****************************************************************************

    @doc INTERNAL

    @api void | joyPollCallback | Function called for joystick
	 timer polling scheme initiated from SetCapture call.
	
    @parm HWND | hWnd | Identifies the window associated with the timer
    event.

    @parm UINT | wMsg | Specifies the WM_TIMER message.

    @parm UINT | wIDEvent | Specifies the timer's ID.

    @parm DWORD | dwTime | Specifies the current system time.


****************************************************************************/

void CALLBACK joyPollCallback(HWND hWnd, UINT wMsg, UINT wIDEvent, DWORD dwTime)
{
    #define	diff(w1,w2) (UINT)(w1 > w2 ? w1-w2 : w2-w1)

    static  JOYINFO  oldInfo[2] = {{ 0, 0, 0, 0 },{ 0, 0, 0, 0 }};
    JOYINFO Info;

    UINT    w ,fBtnMask;

    if (wIDEvent == JoyCapture[0].wIDEvent)
        wIDEvent = 0;
    else if (wIDEvent == JoyCapture[1].wIDEvent)
        wIDEvent = 1;

#ifdef DEBUG
    else
    {
        DOUT("MMSYSTEM: Invalid timer handle in joy.c\r\n");
        KillTimer (NULL, wIDEvent);
    }
#endif


    if (!JoyCapture[wIDEvent].hWnd || !IsWindow(JoyCapture[wIDEvent].hWnd))
        joyReleaseCapture(wIDEvent);

    if (!joyMessage( hDrvJoy[wIDEvent], JDD_GETPOS,
                     (DWORD)(LPJOYINFO)&Info, 0L ))
    {

	for (w=0,fBtnMask=1; w < 4; w++,fBtnMask <<=1)
        {
	    if ((Info.wButtons ^ oldInfo[wIDEvent].wButtons) & fBtnMask)
            {
		PostMessage(
		      JoyCapture[wIDEvent].hWnd,
		      wIDEvent + ((Info.wButtons & fBtnMask) ?
		      MM_JOY1BUTTONDOWN : MM_JOY1BUTTONUP ),
		      (WPARAM)(Info.wButtons | fBtnMask << 8),
		      MAKELPARAM(Info.wXpos,Info.wYpos));
	    }
	}

	if (!JoyCapture[wIDEvent].bChanged ||
	    diff(Info.wXpos,oldInfo[wIDEvent].wXpos)>JoyCapture[wIDEvent].wThreshold ||
	    diff(Info.wYpos,oldInfo[wIDEvent].wYpos)>JoyCapture[wIDEvent].wThreshold)
        {
	    PostMessage(
	        JoyCapture[wIDEvent].hWnd,
	        MM_JOY1MOVE+wIDEvent,
	        (WPARAM)(Info.wButtons),
	        MAKELPARAM(Info.wXpos,Info.wYpos));

	}

        else if (!JoyCapture[wIDEvent].bChanged ||
	    diff(Info.wZpos,oldInfo[wIDEvent].wZpos)>JoyCapture[wIDEvent].wThreshold)
        {
	    PostMessage(
	        JoyCapture[wIDEvent].hWnd,
		MM_JOY1ZMOVE+wIDEvent,
		(WPARAM)Info.wButtons,
		MAKELPARAM(Info.wZpos,0));
        }
	
        oldInfo[wIDEvent] = Info;
    }
    #undef  diff
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\mmsystem\mci.c ===
/******************************************************************************
* Module Name: mci.c
*
* Media Control Architecture Driver Interface
*
* Contents:  MCI external message API's mciSendString and mciSendCommand
* Author:  DLL (DavidLe)
* Created: 2/13/90
*
* Copyright (c) 1990 Microsoft Corporation
*
\******************************************************************************/
#ifdef DEBUG
#ifndef DEBUG_RETAIL
#define DEBUG_RETAIL
#endif
#endif

#include <windows.h>
#include <string.h>

#define MMNOSEQ
#define MMNOJOY
#define MMNOWAVE
#define MMNOMIDI
#include "mmsystem.h"

#define NOMIDIDEV
#define NOWAVEDEV
#define NOTIMERDEV
#define NOJOYDEV
#define NOSEQDEV
#define NOTASKDEV
#include "mmddk.h"

#include "mmsysi.h"
#include "thunks.h"

#ifndef STATICFN
#define STATICFN
#endif


/* -------------------------------------------------------------------------
** Thunking stuff
** -------------------------------------------------------------------------
*/
LPMCIMESSAGE PASCAL mci32Message;
DWORD WINAPI mciSendCommand16(
    UINT wDeviceID,
    UINT wMessage,
    DWORD dwParam1,
    DWORD dwParam2
    );


//
//  Define the init code for this file.
//
#pragma alloc_text( INIT, MCITerminate )

#ifdef DEBUG_RETAIL
int DebugmciSendCommand;
#endif

#ifdef DEBUG
void PASCAL NEAR mciCheckLocks(void);
#endif

STATICFN UINT PASCAL NEAR
mciConvertReturnValue(
    UINT wType,
    UINT wErr,
    UINT wDeviceID,
    LPDWORD dwParams,
    LPSTR lpstrReturnString,
    UINT wReturnLength
    );

STATICFN DWORD NEAR PASCAL
mciSendStringInternal(
    LPCSTR lpstrCommand,
    LPSTR lpstrReturnString,
    UINT wReturnLength,
    HWND hwndCallback,
    LPMCI_SYSTEM_MESSAGE lpMessage
    );

STATICFN DWORD NEAR PASCAL
mciSendSystemString(
    LPCSTR lpstrCommand,
    LPSTR lpstrReturnString,
    UINT wReturnLength
    );

extern int FAR PASCAL
mciBreakKeyYieldProc(
    UINT wDeviceID,
    DWORD dwYieldData
    );


// From dosa.asm
extern int FAR PASCAL DosChangeDir(LPCSTR lpszPath);
extern WORD FAR PASCAL DosGetCurrentDrive(void);
extern BOOL FAR PASCAL DosSetCurrentDrive(WORD wDrive);
extern WORD FAR PASCAL DosGetCurrentDir(WORD wCurdrive, LPSTR lpszBuf);

#define MAX_PATHNAME 144

// This macro defines the list of messages for which mciSendString
// will not try to auto-open
#define MCI_CANNOT_AUTO_OPEN(wMessage) \
    (wMessage == MCI_OPEN || wMessage == MCI_SYSINFO \
        || wMessage == MCI_SOUND || wMessage == MCI_CLOSE \
        || wMessage == MCI_BREAK)

// This macro devices the list of message which do not require an open
// device.  It is a subset of MCI_CANNOT_AUTO_OPEN
#define MCI_DO_NOT_NEED_OPEN(wMessage) \
    (wMessage == MCI_OPEN || wMessage == MCI_SOUND || wMessage == MCI_SYSINFO)

// Strings used in mciAutoOpenDevice
          SZCODE szOpen[] = "open";
static    SZCODE szClose[] = "close";
static    SZCODE szNotify[] = "notify";
static    SZCODE szWait[] = "wait";
static    SZCODE szCmdFormat[] = "%ls %ls";
static    SZCODE szLongFormat[] = "%ld";
static    SZCODE szRectFormat[] = "%d %d %d %d";
extern char far szSystemDefault[];

// Special device name
static    SZCODE szNew[] = "new";

/******************************Public*Routine******************************\
* mciAppExit
*
* Notify the 32 bit code that a 16 bit app has died.
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
DWORD
mciAppExit(
    HTASK hTask
    )
{
    return mciMessage( THUNK_APP_EXIT, (DWORD)hTask,
                       0L, 0L, 0L );
}



/*****************************************************************************
 * @doc INTERNAL
 *
 * @api void | MciNotify  | called by mmWndProc when it recives a
 *                          MM_MCINOTIFY message
 * @rdesc None.
 *
 ****************************************************************************/

void FAR PASCAL
MciNotify(
    WPARAM wParam,
    LPARAM lParam
    )
{
    //
    //  wParam is the notify status
    //  lParam is the MCI device id
    //
    if (MCI_VALID_DEVICE_ID(LOWORD(lParam)) &&
        !(MCI_lpDeviceList[LOWORD(lParam)]->dwMCIFlags & MCINODE_ISCLOSING)) {
        MCI_lpDeviceList[LOWORD(lParam)]->dwMCIFlags |= MCINODE_ISAUTOCLOSING;
        mciCloseDevice (LOWORD(lParam), 0L, NULL, TRUE);
    }
}



STATICFN void NEAR PASCAL
HandleNotify(
    UINT wErr,
    UINT wDeviceID,
    DWORD dwFlags,
    DWORD dwParam2
    )
{
    LPMCI_GENERIC_PARMS lpGeneric = (LPMCI_GENERIC_PARMS)dwParam2;
    HWND hwndCallback;
    if (wErr == 0 && dwFlags & MCI_NOTIFY && lpGeneric != NULL &&
        (hwndCallback = (HWND)(UINT)lpGeneric->dwCallback) != NULL)

        mciDriverNotify (hwndCallback, wDeviceID, MCI_NOTIFY_SUCCESSFUL);
}

#ifdef DEBUG_RETAIL
//
// Dump the string form of an MCI command
//
UINT PASCAL NEAR
mciDebugOut(
    UINT wDeviceID,
    UINT wMessage,
    DWORD dwFlags,
    DWORD dwParam2,
    LPMCI_DEVICE_NODE nodeWorking
    )
{
    LPSTR lpCommand, lpFirstParameter, lpPrevious, lszDebugOut;
    char strTemp[256];
    UINT wID, wOffset, wOffsetFirstParameter, wReturnType;
    DWORD dwValue;
    DWORD dwMask;
    UINT wTable;

// Find the command table for the given command message ID
    lpCommand = FindCommandItem( wDeviceID, NULL,
                                 (LPSTR)MAKELONG (wMessage, 0),
                                 NULL, &wTable);

    if (lpCommand == NULL)
    {
        if (wMessage != MCI_OPEN_DRIVER && wMessage != MCI_CLOSE_DRIVER)
            ROUT ("MMSYSTEM: mciDebugOut:  Command table not found");
        return 0;
    }

    lszDebugOut = mciAlloc(512);
    if (!lszDebugOut) {
        ROUT("MMSYSTEM: Not enough memory to display command");
	return 0;
    }

//  Dump the command name
    wsprintf(lszDebugOut, "MMSYSTEM: MCI command: \"%ls", lpCommand);

// Dump the device name
    if (wDeviceID == MCI_ALL_DEVICE_ID)
    {
        lstrcat(lszDebugOut, " all");
    }
    else if (nodeWorking != NULL)
    {
        if (nodeWorking->dwMCIOpenFlags & MCI_OPEN_ELEMENT_ID)
        {
            wsprintf(lszDebugOut + lstrlen(lszDebugOut), " Element ID:0x%lx", nodeWorking->dwElementID);
        } else if (nodeWorking->lpstrName != NULL)
        {
            wsprintf(lszDebugOut + lstrlen(lszDebugOut), " %ls", nodeWorking->lpstrName);
        }
    }

// Skip past command entry
    lpCommand += mciEatCommandEntry (lpCommand, NULL, NULL);

// Get the next entry
    lpFirstParameter = lpCommand;

// Skip past the DWORD return value
    wOffsetFirstParameter = 4;

    lpCommand += mciEatCommandEntry (lpCommand, &dwValue, &wID);

// If it is a return value, skip it
    if (wID == MCI_RETURN)
    {
        wReturnType = (UINT)dwValue;
        lpFirstParameter = lpCommand;
        wOffsetFirstParameter += mciGetParamSize (dwValue, wID);
        lpCommand += mciEatCommandEntry (lpCommand, &dwValue, &wID);
    }
    else {
        wReturnType = (UINT)0;
    }

// Dump device name parameter to OPEN
    if (wMessage == MCI_OPEN)
    {
        LPCSTR lpstrDeviceType =
            ((LPMCI_OPEN_PARMS)dwParam2)->lpstrDeviceType;
        LPCSTR lpstrElementName =
            ((LPMCI_OPEN_PARMS)dwParam2)->lpstrElementName;

// Tack on device type
        if (dwFlags & MCI_OPEN_TYPE_ID)
        {
            LPMCI_OPEN_PARMS lpOpen = (LPMCI_OPEN_PARMS)dwParam2;
            DWORD dwOld = (DWORD)lpOpen->lpstrDeviceType;
            if (mciExtractTypeFromID ((LPMCI_OPEN_PARMS)dwParam2) != 0)
                strTemp[0] = '\0';
            lstrcpy (strTemp, lpOpen->lpstrDeviceType);
            mciFree ((LPSTR)lpOpen->lpstrDeviceType);
            lpOpen->lpstrDeviceType = (LPSTR)dwOld;
        } else if (lpstrDeviceType != NULL)
            lstrcpy (strTemp, lpstrDeviceType);
        else
            strTemp[0] = '\0';

        if (dwFlags & MCI_OPEN_ELEMENT_ID)
        {
// Tack on element ID
            lstrcat (strTemp, " Element ID:");
            wsprintf (strTemp + lstrlen (strTemp), szLongFormat,
                      LOWORD ((DWORD)lpstrDeviceType));
        } else
        {
// Add separator if both type name and element name are present
            if (lpstrDeviceType != 0 && lpstrElementName != 0)
                lstrcat (strTemp, "!");
            if (lpstrElementName != 0 && dwFlags & MCI_OPEN_ELEMENT)
                lstrcat (strTemp, lpstrElementName);
        }
        wsprintf(lszDebugOut + lstrlen(lszDebugOut), " %ls", (LPSTR)strTemp);
    }


// Walk through each flag
    for (dwMask = 1; dwMask;)
    {
// Is this bit set?
        if ((dwFlags & dwMask) != 0 && !
// The MCI_OPEN_TYPE and MCI_OPEN_ELEMENT flags are taken care of
// above
            (wMessage == MCI_OPEN && (dwMask == MCI_OPEN_TYPE
                                      || dwMask == MCI_OPEN_ELEMENT)))
        {
            lpPrevious = lpCommand = lpFirstParameter;
            wOffset = 0;
            lpCommand += mciEatCommandEntry (lpCommand, &dwValue, &wID);

// What parameter uses this bit?
            while (wID != MCI_END_COMMAND && dwValue != dwMask)
            {
                wOffset += mciGetParamSize (dwValue, wID);

                if (wID == MCI_CONSTANT)
                    while (wID != MCI_END_CONSTANT)
                        lpCommand += mciEatCommandEntry (lpCommand,
                                                         NULL, &wID);

                lpPrevious = lpCommand;
                lpCommand += mciEatCommandEntry (lpCommand, &dwValue, &wID);
            }

            if (wID != MCI_END_COMMAND)
            {
// Found the parameter which matches this flag bit
// Print the parameter name
                if (*lpPrevious)
                    wsprintf(lszDebugOut + lstrlen(lszDebugOut), " %ls", lpPrevious);

// Print any argument
                switch (wID)
                {
                    case MCI_STRING:
                        wsprintf(lszDebugOut + lstrlen(lszDebugOut), " %ls", *(LPSTR FAR *)((LPSTR)dwParam2 + wOffset + wOffsetFirstParameter));
                        break;
                    case MCI_CONSTANT:
                    {
                        DWORD dwConst = *(LPDWORD)((LPSTR)dwParam2 + wOffset +
                                             wOffsetFirstParameter);
                        UINT wLen;
                        BOOL bFound;

                        for (bFound = FALSE; wID != MCI_END_CONSTANT;)
                        {
                            wLen = mciEatCommandEntry (lpCommand,
                                                       &dwValue, &wID);

                            if (dwValue == dwConst)
                            {
                                bFound = TRUE;
                                wsprintf(lszDebugOut + lstrlen(lszDebugOut), " %ls", lpCommand);
                            }

                            lpCommand += wLen;
                        }
                        if (bFound)
                            break;
// FALL THROUGH
                    }
                    case MCI_INTEGER:
                        wsprintf ((LPSTR)strTemp, szLongFormat,
                                  *(LPDWORD)((LPSTR)dwParam2 + wOffset +
                                             wOffsetFirstParameter));
                        wsprintf(lszDebugOut + lstrlen(lszDebugOut), " %ls", (LPSTR)strTemp);
                        break;
                }
            }
        }
// Go the the next flag
        dwMask <<= 1;
    }
    mciUnlockCommandTable (wTable);
    lstrcat(lszDebugOut, "\"");
    ROUTS(lszDebugOut);
    mciFree(lszDebugOut);
    return wReturnType;
}
#endif

STATICFN DWORD PASCAL NEAR
mciBreak(
    UINT wDeviceID,
    DWORD dwFlags,
    LPMCI_BREAK_PARMS lpBreakon
    )
{
    HWND hwnd;

    if (dwFlags & MCI_BREAK_KEY)
    {
        if (dwFlags & MCI_BREAK_OFF)
            return MCIERR_FLAGS_NOT_COMPATIBLE;

        if (dwFlags & MCI_BREAK_HWND)
            hwnd = lpBreakon->hwndBreak;
        else
            hwnd = 0;

        return  mciSetBreakKey (wDeviceID, lpBreakon->nVirtKey,
                                hwnd)
                    ? 0 : MMSYSERR_INVALPARAM;

    } else if (dwFlags & MCI_BREAK_OFF) {

        mciSetYieldProc(wDeviceID, NULL, 0);
        return 0;

    } else
        return MCIERR_MISSING_PARAMETER;
}

// Close the indicated device by sending a message inter-task
STATICFN DWORD PASCAL NEAR
mciAutoCloseDevice(
    LPCSTR lpstrDevice
    )
{
    LPSTR lpstrCommand;
    DWORD dwRet;

    if ((lpstrCommand =
            mciAlloc (sizeof (szClose) + 1 +
                    lstrlen (lpstrDevice))) == NULL)
        return MCIERR_OUT_OF_MEMORY;

    wsprintf(lpstrCommand, szCmdFormat, (LPCSTR)szClose, lpstrDevice);

    dwRet = mciSendSystemString (lpstrCommand, NULL, 0);

    mciFree (lpstrCommand);

    return dwRet;
}

//
// Process a single MCI command
//
// Called by mciSendCommandInternal
//
STATICFN DWORD PASCAL NEAR
mciSendSingleCommand(
    UINT wDeviceID,
    UINT wMessage,
    DWORD dwParam1,
    DWORD dwParam2,
    LPMCI_DEVICE_NODE nodeWorking,
    BOOL bTaskSwitch,
    LPMCI_INTERNAL_OPEN_INFO lpOpenInfo
    )
{
    DWORD dwRet;
#ifdef	DEBUG_RETAIL
    UINT wReturnType;
    DWORD dwTime;
#endif

#ifdef  DEBUG_RETAIL
    if (DebugmciSendCommand)
        wReturnType =
            mciDebugOut (wDeviceID, wMessage, dwParam1, dwParam2,
                         nodeWorking);
#endif

    switch (wMessage)
    {
        case MCI_OPEN:
            dwRet = mciOpenDevice (dwParam1,
                                   (LPMCI_OPEN_PARMS)dwParam2, lpOpenInfo);
            break;

        case MCI_CLOSE:
// If this device was auto opened send the command via a task switch
            if (bTaskSwitch)
            {
                if (dwParam1 & MCI_NOTIFY)
                    return MCIERR_NOTIFY_ON_AUTO_OPEN;

                dwRet = mciAutoCloseDevice (nodeWorking->lpstrName);
            } else
                dwRet =
                    mciCloseDevice (wDeviceID,
                                    dwParam1,
                                    (LPMCI_GENERIC_PARMS)dwParam2, TRUE);
            break;

        case MCI_SYSINFO:
            dwRet = mciSysinfo (wDeviceID, dwParam1,
                               (LPMCI_SYSINFO_PARMS)dwParam2);
            HandleNotify ((UINT)dwRet, 0, dwParam1, dwParam2);
            break;

        case MCI_BREAK:
            dwRet = mciBreak (wDeviceID, dwParam1,
                              (LPMCI_BREAK_PARMS)dwParam2);
            HandleNotify ((UINT)dwRet, wDeviceID, dwParam1, dwParam2);
            break;

        case MCI_SOUND:
        {
            dwRet =
                sndPlaySound (MCI_SOUND_NAME & dwParam1 ?
                              ((LPMCI_SOUND_PARMS)dwParam2)->lpstrSoundName : szSystemDefault,
                              dwParam1 & MCI_WAIT ?
                                    SND_SYNC : SND_ASYNC)
                    ? 0 : MCIERR_HARDWARE;
            HandleNotify ((UINT)dwRet, wDeviceID, dwParam1, dwParam2);
            break;
        }
        default:
#ifdef DEBUG_RETAIL
            if (DebugmciSendCommand)
            {
                dwTime = timeGetTime();
            }
#endif
// Initialize GetAsyncKeyState for break key
            if (dwParam1 & MCI_WAIT &&
                nodeWorking->fpYieldProc == mciBreakKeyYieldProc)
                GetAsyncKeyState (LOWORD(nodeWorking->dwYieldData));

            dwRet = (DWORD)SendDriverMessage(nodeWorking->hDrvDriver, wMessage,
                                   (LPARAM)dwParam1, (LPARAM)dwParam2);
#ifdef DEBUG_RETAIL
            if (DebugmciSendCommand)
            {
		dwTime = timeGetTime() - dwTime;
            }
#endif
            break;
    } // switch

#ifdef DEBUG_RETAIL
    if (DebugmciSendCommand)
    {
        if (dwRet & MCI_INTEGER_RETURNED) {
            wReturnType = MCI_INTEGER;
        }


        switch (wReturnType)
        {
            case MCI_INTEGER:
            {
                char strTemp[50];

                if (wMessage == MCI_OPEN) {

                    mciConvertReturnValue( wReturnType, HIWORD(dwRet),
                                           wDeviceID, (LPDWORD)dwParam2,
                                           strTemp, sizeof(strTemp));
                }
                else {
                    mciConvertReturnValue( wReturnType, HIWORD(dwRet),
                                           wDeviceID, (LPDWORD)dwParam2,
                                           strTemp, sizeof(strTemp));
                }

                RPRINTF2( "MMSYSTEM: time: %lums returns: \"%ls\"",
                          dwTime, (LPSTR)strTemp);
                break;
            }
            case MCI_STRING:
                RPRINTF2( "MMSYSTEM: time: %lums returns: \"%ls\"",
                          dwTime, (LPSTR)*(((LPDWORD)dwParam2) + 1));
                break;
        }
    }
#endif

    return dwRet;
}

// Internal version of mciSendCommand.  Differs ONLY in that the return
// value is a DWORD where the high word has meaning only for mciSendString

STATICFN DWORD NEAR PASCAL
mciSendCommandInternal(
    UINT wDeviceID,
    UINT wMessage,
    DWORD dwParam1,
    DWORD dwParam2,
    LPMCI_INTERNAL_OPEN_INFO lpOpenInfo
    )
{
    DWORD dwRetVal;
    LPMCI_DEVICE_NODE nodeWorking = NULL;
    BOOL bWalkAll;
    BOOL bTaskSwitch;
    DWORD dwAllError = 0;
    HTASK hCurrentTask;

    hCurrentTask = GetCurrentTask();

// If the device is "all" and the message is *not*
// "sysinfo" then we must walk all devices
    if (wDeviceID == MCI_ALL_DEVICE_ID && wMessage != MCI_SYSINFO && wMessage != MCI_SOUND)
    {
        if (wMessage == MCI_OPEN)
        {
            dwRetVal = MCIERR_CANNOT_USE_ALL;
            goto exitfn;
        }

        bWalkAll = TRUE;

// Start at device #1
        wDeviceID = 1;
    } else
        bWalkAll = FALSE;

// Walk through all devices if bWalkAll or just one device if !bWalkAll
    do
    {
// Initialize
        dwRetVal = 0;
        bTaskSwitch = FALSE;

// Validate the device ID if single device
        if (!bWalkAll)
        {
            if (!MCI_DO_NOT_NEED_OPEN(wMessage))
            {
                if (!MCI_VALID_DEVICE_ID(wDeviceID))
                {
                    dwRetVal = MCIERR_INVALID_DEVICE_ID;
                    goto exitfn;
                }
                nodeWorking = MCI_lpDeviceList[wDeviceID];
            }
        } else if (wMessage != MCI_SYSINFO)
            nodeWorking = MCI_lpDeviceList[wDeviceID];

// Skip if walking the device list and the
// device is not part of the current task

        if (bWalkAll)
        {
            if (nodeWorking == NULL ||
                nodeWorking->hOpeningTask != hCurrentTask)
                    goto no_send;
        }
// If the device is in the process of closing and the message
// is not MCI_CLOSE_DRIVER then return an error
        if (nodeWorking != NULL &&
            (nodeWorking->dwMCIFlags & MCINODE_ISCLOSING) &&
            wMessage != MCI_CLOSE_DRIVER)
        {
            dwRetVal = MCIERR_DEVICE_LOCKED;
            goto exitfn;
        }

// If this message is being sent from the wrong task (the device was auto-
// opened) fail all but the MCI_CLOSE message which gets sent inter-task
        if (nodeWorking != NULL &&
            nodeWorking->hCreatorTask != hCurrentTask)
            if (wMessage != MCI_CLOSE)
                return MCIERR_ILLEGAL_FOR_AUTO_OPEN;
            else
            {
// Don't even allow close from mciSendCommand if auto-open device has a
// pending close
                if (nodeWorking->dwMCIFlags & MCINODE_ISAUTOCLOSING)
                {
// But at least give the close a chance to take place
//!!                    Yield();
                    return MCIERR_DEVICE_LOCKED;
                } else
                    bTaskSwitch = TRUE;
            }

        dwRetVal = mciSendSingleCommand (wDeviceID, wMessage, dwParam1,
                                         dwParam2, nodeWorking, bTaskSwitch,
                                         lpOpenInfo);
no_send:

// If we are processing multiple devices
        if (bWalkAll)
        {
// If there was an error for this device
            if (dwRetVal != 0)
// If this is not the first error
                if (dwAllError != 0)
                    dwAllError = MCIERR_MULTIPLE;
// Just one error so far
                else
                    dwAllError = dwRetVal;
        }
    } while (bWalkAll && ++wDeviceID < MCI_wNextDeviceID);

exitfn:
// Return the accumulated error if multiple devices or just the single error
    return bWalkAll ? dwAllError : dwRetVal;
}


/*
 * @doc EXTERNAL MCI
 *
 * @api DWORD | mciSendCommand | This function sends a command message to
 * the specified MCI device.
 *
 * @parm UINT | wDeviceID | Specifies the device ID of the MCI device to
 * receive the command. This parameter is
 *  not used with the <m MCI_OPEN> command.
 *
 * @parm UINT | wMessage | Specifies the command message.
 *
 * @parm DWORD | dwParam1 | Specifies flags for the command.
 *
 * @parm DWORD | dwParam2 | Specifies a pointer to a parameter block
 *  for the command.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *  error information. The low-order word
 *  of the returned DWORD is the error return value. If the error is
 *  device-specific, the high-order word contains the driver ID; otherwise
 *  the high-order word is zero.
 *
 *  To get a textual description of <f mciSendCommand> return values,
 *  pass the return value to <f mciGetErrorString>.
 *
 *  Error values that are returned when a device is being opened
 *  are listed with the MCI_OPEN message. In addition to the
 *  MCI_OPEN error returns, this function can
 *  return the following values:
 *
 *  @flag MCIERR_BAD_TIME_FORMAT | Illegal value for time format.
 *
 *  @flag MCIERR_CANNOT_USE_ALL | The device name "all" is not allowed
 *  for this command.
 *
 *  @flag MCIERR_CREATEWINDOW | Could not create or use window.
 *
 *  @flag MCIERR_DEVICE_LOCKED | The device is locked until it is
 *  closed automatically.
 *
 *  @flag MCIERR_DEVICE_NOT_READY | Device not ready.
 *
 *  @flag MCIERR_DEVICE_TYPE_REQUIRED | The device name must be a valid
 *  device type.
 *
 *  @flag MCIERR_DRIVER | Unspecified device error.
 *
 *  @flag MCIERR_DRIVER_INTERNAL | Internal driver error.
 *
 *  @flag MCIERR_FILE_NOT_FOUND | Requested file not found.
 *
 *  @flag MCIERR_FILE_NOT_SAVED | The file was not saved.
 *
 *  @flag MCIERR_FILE_READ | A read from the file failed.
 *
 *  @flag MCIERR_FILE_WRITE | A write to the file failed.
 *
 *  @flag MCIERR_FLAGS_NOT_COMPATIBLE | Incompatible parameters
 *  were specified.
 *
 *  @flag MCIERR_HARDWARE | Hardware error on media device.
 *
 *  @flag MCIERR_INTERNAL | mmsystem startup error.
 *
 *  @flag MCIERR_INVALID_DEVICE_ID | Invalid device ID.
 *
 *  @flag MCIERR_INVALID_DEVICE_NAME | The device is not open
 *  or is not known.
 *
 *  @flag MCIERR_INVALID_FILE | Invalid file format.
 *
 *  @flag MCIERR_MULTIPLE | Errors occurred in more than one device.
 *
 *  @flag MCIERR_NO_WINDOW | There is no display window.
 *
 *  @flag MCIERR_NULL_PARAMETER_BLOCK | Parameter block pointer was NULL.
 *
 *  @flag MCIERR_OUT_OF_MEMORY | Not enough memory for requested operation.
 *
 *  @flag MCIERR_OUTOFRANGE | Parameter value out of range.
 *
 *  @flag MCIERR_UNNAMED_RESOURCE | Attempt to save unnamed file.
 *
 *  @flag MCIERR_UNRECOGNIZED_COMMAND | Unknown command.
 *
 *  @flag MCIERR_UNSUPPORTED_FUNCTION | Action not available for this
 *  device.
 *
 *  The following additional return values are defined for MCI sequencers:
 *
 *  @flag MCIERR_SEQ_DIV_INCOMPATIBLE | Set Song Pointer incompatible
 *  with SMPTE files.
 *
 *  @flag MCIERR_SEQ_PORT_INUSE | Specified port is in use.
 *
 *  @flag MCIERR_SEQ_PORT_MAPNODEVICE | Current map uses non-existent
 *  device.
 *
 *  @flag MCIERR_SEQ_PORT_MISCERROR | Miscellaneous error with
 *  specified port.
 *
 *  @flag MCIERR_SEQ_PORT_NONEXISTENT | Specified port does not exist.
 *
 *  @flag MCIERR_SEQ_PORTUNSPECIFIED | No current MIDI port.
 *
 *  @flag MCIERR_SEQ_NOMIDIPRESENT | No MIDI ports present.
 *
 *  @flag MCIERR_SEQ_TIMER | Timer error.
 *
 *  The following additional return values are defined for MCI waveform
 *  audio devices:
 *
 *  @flag MCIERR_WAVE_INPUTSINUSE | No compatible waveform recording
 *   device is free.
 *
 *  @flag MCIERR_WAVE_INPUTSUNSUITABLE | No compatible waveform
 *  recording devices.
 *
 *  @flag MCIERR_WAVE_INPUTUNSPECIFIED | Any compatible waveform
 *  recording device may be used.
 *
 *  @flag MCIERR_WAVE_OUTPUTSINUSE | No compatible waveform playback
 *  device is free.
 *
 *  @flag MCIERR_WAVE_OUTPUTSUNSUITABLE | No compatible waveform
 *  playback devices.
 *
 *  @flag MCIERR_WAVE_OUTPUTUNSPECIFIED | Any compatible waveform
 *  playback device may be used.
 *
 *  @flag MCIERR_WAVE_SETINPUTINUSE | Set waveform recording device
 *  is in use.
 *
 *  @flag MCIERR_WAVE_SETINPUTUNSUITABLE | Set waveform recording
 *  device is incompatible with set format.
 *
 *  @flag MCIERR_WAVE_SETOUTPUTINUSE | Set waveform playback device
 *  is in use.
 *
 *  @flag MCIERR_WAVE_SETOUTPUTUNSUITABLE | Set waveform playback
 *  device is incompatible with set format.
 *
 * @comm Use the <m MCI_OPEN> command to obtain the device ID
 *  specified by <p wDeviceID>.
 *
 * @xref mciGetErrorString mciSendString
 */

 /*
 * @doc internal
 *
 * @api DWORD | mciDriverEntry | Actually a callback.  The entry point for MCI drivers.
 *
 * @parm UINT | wMessage | Identifies the requested action to be performed.
 *
 * @parm DWORD | dwParam1 | Specifies data for this message.  Defined separately
 * for each message.
 *
 * @parm DWORD | dwParam2 | Specifies data for this message.  Defined separately
 * for each message.
 *
 * @rdesc The return value is defined separately for each message.
 */
DWORD WINAPI
mciSendCommand(
    UINT wDeviceID,
    UINT wMessage,
    DWORD dwParam1,
    DWORD dwParam2
    )
{
    // Initialize the 16-bit device list if needed.
    if (!MCI_bDeviceListInitialized && !mciInitDeviceList())
        return MCIERR_OUT_OF_MEMORY;

    // MCI_OPEN_DRIVER & MCI_CLOSE_DRIVER only supported on 16-bit drivers
    if ( (wMessage == MCI_OPEN_DRIVER) || (wMessage == MCI_CLOSE_DRIVER) ) {
        return mciSendCommand16( wDeviceID, wMessage, dwParam1, dwParam2 );
    }

    /*
    ** If we are opening the device try the 32 bit side first.  If this
    ** worked (hopefully this is the usual case) we return the given
    ** device ID.  Otherwise, we try for a 16 bit device.
    */
    if ( wMessage == MCI_OPEN ) {

        DWORD dwErr;

        DPRINTF(("mciSendCommand: Got an MCI_OPEN command... "
                 "trying 32 bits\r\n" ));

        dwErr = mciMessage( THUNK_MCI_SENDCOMMAND, (DWORD)wDeviceID,
                            (DWORD)wMessage, dwParam1, dwParam2 );

        if ( dwErr == MMSYSERR_NOERROR ) {

            LPMCI_OPEN_PARMS lpOpenParms = (LPMCI_OPEN_PARMS)dwParam2;

            DPRINTF(("mciSendCommand: We have a 32 bit driver,"
                     " devID = 0x%X\r\n", lpOpenParms->wDeviceID ));

            return dwErr;

        }
        else {

            /*
            ** We could open the device on the 32 bit side so let
            ** the 16 bit code have a go (ie. just fall thru to the code below).
            */
            DPRINTF(("mciSendCommand: Could not find a 32 bit driver, "
                     "trying for a 16 bit driver\r\n" ));

            dwErr = mciSendCommand16( wDeviceID, wMessage, dwParam1, dwParam2 );

            if ( dwErr == MMSYSERR_NOERROR ) {

                LPMCI_OPEN_PARMS lpOpenParms = (LPMCI_OPEN_PARMS)dwParam2;

                DPRINTF(("mciSendCommand: We have a 16 bit driver,"
                         " devID = 0x%X\r\n", lpOpenParms->wDeviceID ));
            }

            return dwErr;
        }
    }
    else {

        DWORD dwErr16;
        DWORD dwErr32;

        /*
        ** If we have been given the MCI_ALL_DEVICE_ID then we have to
        ** send the command to both the 32 and 16 bit side.
        **
        ** Special care needs to be taken with the MCI_ALL_DEVICE_ID.
        ** The message must be passed on to both 32 and 16 bit devices.
        */

        if (CouldBe16bitDrv(wDeviceID)) {
            dwErr16 = mciSendCommand16( wDeviceID, wMessage,
                                        dwParam1, dwParam2 );

            if ( wDeviceID != MCI_ALL_DEVICE_ID ) {
                return dwErr16;
            }
        }

        dwErr32 = mciMessage( THUNK_MCI_SENDCOMMAND, (DWORD)wDeviceID,
                              (DWORD)wMessage, dwParam1, dwParam2 );

        /*
        ** If we have the MCI_ALL_DEVICE_ID device ID we only return
        ** an error if both the 16 and 32 bit calls failed.  In which
        ** case we return the 32 bit error code.
        */
        if ( wDeviceID == MCI_ALL_DEVICE_ID ) {

            if ( (dwErr16 != MMSYSERR_NOERROR)
              && (dwErr32 != MMSYSERR_NOERROR) ) {

                return dwErr32;
            }
            else {
                return MMSYSERR_NOERROR;
            }
        }

        return dwErr32;
    }
}


/*****************************Private*Routine******************************\
* mciSendCommand16
*
* Here is where we execute the real 16 bit mciSendCommand.  Hoefully this
* will not get called to often.
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
DWORD WINAPI
mciSendCommand16(
    UINT wDeviceID,
    UINT wMessage,
    DWORD dwParam1,
    DWORD dwParam2
    )
{
    DWORD dwErr;
    MCI_INTERNAL_OPEN_INFO OpenInfo;


    //
    // Send the command.  This shell is responsible for adding the device ID
    // to the error code if necessary
    //
    OpenInfo.hCallingTask = GetCurrentTask();
    OpenInfo.lpstrParams = NULL;
    OpenInfo.lpstrPointerList = NULL;
    OpenInfo.wParsingError = 0;
    dwErr = mciSendCommandInternal (wDeviceID, wMessage,
                                    dwParam1, dwParam2, &OpenInfo);
    //
    // If the return value contains a resource ID then clear
    // it from clear the high word
    //
    if (dwErr & MCI_RESOURCE_RETURNED)
        ((LPDWORD)dwParam2)[1] &= 0xFFFF;
    dwErr &= 0xFFFF;

    //
    // If the error message is in a driver, store the driver ID in the high
    // word of the error code
    //
    if ((UINT)dwErr >= MCIERR_CUSTOM_DRIVER_BASE)
        dwErr |= ((DWORD)wDeviceID << 16);

#ifdef DEBUG
    // Dump the error text if any to the debug terminal
    if (dwErr != 0)
    {
        char strTemp[MAXERRORLENGTH];

        if (!mciGetErrorString (dwErr, strTemp, sizeof(strTemp)))
            LoadString(ghInst, STR_MCISCERRTXT, strTemp, sizeof(strTemp));
        else
            DPRINTF(("mciSendCommand: %ls\r\n",(LPSTR)strTemp));
    }
#endif
    return dwErr;
}



// Grab colonized digit
// Return is number of bytes written to output (NOT including NULL)
// or 0 if out of room in output buffer (but is terminated anyway)
// If there is room then at least two digits are written, padded with '0'
// if necessary.  The function assumes that the buffer size is non-zero length,
// as this is checked in the calling function.
STATICFN UINT PASCAL NEAR
mciColonizeDigit(
    LPSTR lpstrOutput,
    unsigned char cDigit,
    UINT wSize
    )
{
    UINT wCount;

    wCount = 2;

// If there is room for at least two digits
    if (wSize >= 3)
    {
        if (cDigit >= 100)
        {
            wCount = 3;
            if (wSize < 4)
                goto terminate;
            *lpstrOutput++ = (char)((cDigit / 100) % 10 + '0');
            cDigit = (char)(cDigit % 100);
        }
        *lpstrOutput++ = (char)(cDigit / 10 + '0');
        *lpstrOutput++ = (char)(cDigit % 10 + '0');
    }

terminate:
    *lpstrOutput++ = '\0';

// If we ran out of room then return an error
    return (wCount >= wSize) ? 0 : wCount;
}

/*
 * @doc INTERNAL MCI
 * @func BOOL | mciColonize | Convert a colonized dword into a string
 * representation
 *
 * @parm LPSTR | lpstrOutput | Output buffer
 *
 * @parm UINT | wLength | Size of output buffer
 *
 * @parm DWORD | dwData | Value to convert
 *
 * @parm UINT | wType | Either MCI_COLONIZED3_RETURN or
 * MCI_COLONIZED4_RETURN is set (HIWORD portion only!)
 *
 * @comm Example:  For C4, 0x01020304 is converted to "04:03:02:01"
 *                 For C3, 0x01020304 is converted to "04:03:02"
 *
 * @rdesc FALSE if there is not enough room in the output buffer
 *
 */
STATICFN BOOL PASCAL NEAR mciColonize(
    LPSTR lpstrOutput,
    UINT wLength,
    DWORD dwData,
    UINT wType
    )
{
    LPSTR lpstrInput = (LPSTR)&dwData;
    UINT wSize;
    int i;

    for (i = 1; i <= (wType & HIWORD(MCI_COLONIZED3_RETURN) ? 3 : 4); ++i)
    {
        wSize = mciColonizeDigit (lpstrOutput,
                                  *lpstrInput++,
                                  wLength);
        if (wSize == 0)
            return FALSE;
        lpstrOutput += wSize;
        wLength -= wSize;
        if (i < 3 || i < 4 && wType & HIWORD(MCI_COLONIZED4_RETURN))
        {
            --wLength;
            if (wLength == 0)
                return FALSE;
            else
                *lpstrOutput++ = ':';
        }
    }
    return TRUE;
}

//
// Convert the return value to a return string
//
STATICFN UINT PASCAL NEAR
mciConvertReturnValue(
    UINT wType,
    UINT wErrCode,
    UINT wDeviceID,
    LPDWORD   dwParams,
    LPSTR lpstrReturnString,
    UINT wReturnLength
    )
{
    UINT    wExternalTable;

    if (lpstrReturnString == NULL || wReturnLength == 0)
        return 0;

    switch (wType)
    {
        case MCI_INTEGER:
// Convert integer or resource return value to string
            if (wErrCode & HIWORD(MCI_RESOURCE_RETURNED))
            {
                int nResId = HIWORD(dwParams[1]);
                LPMCI_DEVICE_NODE nodeWorking;
                HINSTANCE hInstance;

                if ((nodeWorking = MCI_lpDeviceList[wDeviceID])
                    == NULL)
                {
// Return blank string on memory error
                    DOUT ("mciConvertReturnValue Warning:NULL device node\r\n");
                    break;
                }

// Return value is a resource
                if (wErrCode & HIWORD(MCI_RESOURCE_DRIVER))
                {
// Return string ID belongs to driver
                    hInstance = nodeWorking->hDriver;

                    wExternalTable = nodeWorking->wCustomCommandTable;
                } else
                {
                    wExternalTable = nodeWorking->wCommandTable;
                    hInstance = ghInst;
                }

// Try to get string from custom or device specific external table
                if (wExternalTable == -1 ||
                    command_tables[wExternalTable].hModule == NULL ||
                    LoadString (command_tables[wExternalTable].hModule,
                                nResId, lpstrReturnString, wReturnLength)
                    == 0)
                {
// Try to get string from CORE.MCI if it's not from the driver
                    if (hInstance != ghInst ||
                        command_tables[0].hModule == NULL ||
                        LoadString (command_tables[0].hModule,
                                    nResId, lpstrReturnString, wReturnLength)
                        == 0)
// Get string from custom module or MMSYSTEM.DLL
                        LoadString (hInstance, nResId, lpstrReturnString,
                                    wReturnLength);
                }

            } else if (wErrCode & HIWORD(MCI_COLONIZED3_RETURN) ||
                        wErrCode & HIWORD(MCI_COLONIZED4_RETURN))
            {
                if (!mciColonize (lpstrReturnString,
                                wReturnLength, dwParams[1], wErrCode))
                    return MCIERR_PARAM_OVERFLOW;
            } else
// Convert integer return value to string
            {
                DWORD dwTemp;

// Need room for a sign, up to ten digits and a NULL
                if (wReturnLength < 12)
                    return MCIERR_PARAM_OVERFLOW;

                if (wType == MCI_STRING ||
                    wErrCode == HIWORD(MCI_INTEGER_RETURNED))
                    dwTemp = *(LPDWORD)dwParams[1];
                else
                    dwTemp = dwParams[1];
                wsprintf(lpstrReturnString, szLongFormat, dwTemp);
            }
            break;
        case MCI_RECT:
// Need from for 4 times (a sign plus 5 digits) plus three spaces and a NULL
            if (wReturnLength < 4 * 6 + 4)
                return MCIERR_PARAM_OVERFLOW;

            wsprintf (lpstrReturnString, szRectFormat,
                        ((LPWORD)dwParams)[2], ((LPWORD)dwParams)[3],
                        ((LPWORD)dwParams)[4], ((LPWORD)dwParams)[5]);
            break;
        default:
// Only support INTEGERs & MIXED
            DOUT ("mciConvertReturnValue Warning:  Unknown return type\r\n");
            return MCIERR_PARSER_INTERNAL;
    }
    return 0;
}


//
// Pull off the command name and device name from the command string,
// leaving *lplpstrCommand pointing past the device name
//
// Returns 0 or an error code on failure.  If successful, the caller must
// free the pstrCommandName and pstrDeviceName
//
// If bCompound then check for a '!' separator in the extracted device name
// and return only the element part.  This is done so that inter-task
// commands to auto-opened devices will include the correct device name
//
STATICFN DWORD PASCAL NEAR
mciSeparateCommandParts(
    LPSTR FAR *lplpstrCommand,
    BOOL bCompound,
    LPSTR FAR *lplpstrCommandName,
    LPSTR FAR *lplpstrDeviceName
    )
{
    LPSTR lpstrCommand;
    UINT wErr;

// Localize the input
    lpstrCommand = *lplpstrCommand;

// Remove leading spaces

    while (*lpstrCommand == ' ')
        ++lpstrCommand;

    if (*lpstrCommand == '\0')
        return MCIERR_MISSING_COMMAND_STRING;

// Pull the command name off of the command string
   if ((wErr = mciEatToken (&lpstrCommand, ' ', lplpstrCommandName, FALSE))
       != 0)
       return wErr;

// Skip past spaces
    while (*lpstrCommand == ' ')
        ++lpstrCommand;

// If we're looking for compound elements then yank off any leading
// device type if it is not the open command
    if (bCompound && lstrcmpi (szOpen, *lplpstrCommandName) != 0)
    {
        LPSTR lpstrTemp = lpstrCommand;
        while (*lpstrTemp != '\0')
        {
            if (*lpstrTemp == '!')
            {
// A ! was found so skip past it
                lpstrCommand = lpstrTemp + 1;
                break;
            } else
                ++lpstrTemp;
        }
    }

// Pull the device name off of the command string
    if ((wErr = mciEatToken (&lpstrCommand, ' ', lplpstrDeviceName, FALSE))
        != 0)
    {
        mciFree (*lplpstrCommandName);
        return wErr;

    }

// Fix up the results
    *lplpstrCommand = lpstrCommand;

    return 0;
}

STATICFN DWORD NEAR PASCAL
mciSendSystemString(
    LPCSTR lpstrCommand,
    LPSTR lpstrReturnString,
    UINT wReturnLength
    )
{
    DWORD    dwRet;
    LPMCI_SYSTEM_MESSAGE    lpMessage;

    if (!hwndNotify)
        return MCIERR_INTERNAL;
    if (lpMessage = mciAlloc (sizeof (MCI_SYSTEM_MESSAGE))) {
        LPSTR    lpstrPath;

        if (lpstrPath = mciAlloc(MAX_PATHNAME)) {
            if (!(DosGetCurrentDir(0, lpstrPath))) {
                lpMessage->lpstrCommand = (LPSTR)lpstrCommand;
                lpMessage->lpstrReturnString = lpstrReturnString;
                lpMessage->wReturnLength = wReturnLength;
                lpMessage->hCallingTask = GetCurrentTask();
                lpMessage->lpstrNewDirectory = lpstrPath;
                lpMessage->nNewDrive = DosGetCurrentDrive();
                dwRet = (DWORD)SendMessage(hwndNotify, MM_MCISYSTEM_STRING, (WPARAM)0, (LPARAM)lpMessage);
            } else {
                DOUT("mciSendSystemString: cannot get current directory\r\n");
                dwRet = MCIERR_GET_CD;
            }
            mciFree(lpstrPath);
        } else {
            DOUT("mciSendSystemString: cannot allocate new path\r\n");
            dwRet = MCIERR_OUT_OF_MEMORY;
        }
        mciFree(lpMessage);
    } else {
        DOUT("mciSendSystemString: cannot allocate message block\r\n");
        dwRet = MCIERR_OUT_OF_MEMORY;
    }
    return dwRet;
}

DWORD FAR PASCAL
mciRelaySystemString(
    LPMCI_SYSTEM_MESSAGE lpMessage
    )
{
    DWORD    dwRet;
    LPSTR    lpstrOldPath;

    if (lpstrOldPath = mciAlloc(MAX_PATHNAME)) {
        if (!(DosGetCurrentDir(0, lpstrOldPath))) {
            int    nOldDrive;

            nOldDrive = DosGetCurrentDrive();
            if (DosSetCurrentDrive(lpMessage->nNewDrive)) {
                if (DosChangeDir(lpMessage->lpstrNewDirectory) == 1) {
                    dwRet = mciSendStringInternal (NULL, NULL, 0, 0, lpMessage);
                    if (!DosSetCurrentDrive(nOldDrive))
                        DOUT("mciRelaySystemString: WARNING, cannot restore drive\r\n");
                    if (DosChangeDir(lpstrOldPath) != 1)
                        DOUT("mciRelaySystemString: WARNING, cannot restore directory\r\n");
                } else {
                    DosSetCurrentDrive(nOldDrive);
                    DOUT("mciRelaySystemString: cannot change to new directory\r\n");
                    dwRet = MCIERR_SET_CD;
                }
            } else {
                DOUT("mciRelaySystemString: cannot change to new drive\r\n");
                dwRet = MCIERR_SET_DRIVE;
            }
        } else {
            DOUT("mciRelaySystemString: cannot get old directory\r\n");
            dwRet = MCIERR_GET_CD;
        }
        mciFree(lpstrOldPath);
    } else {
        DOUT("mciRelaySystemString: cannot allocate old path\r\n");
        dwRet = MCIERR_OUT_OF_MEMORY;
    }
    return dwRet;
}

// Returns TRUE if "notify" is contained in string with leading blank
// and trailing blank or '\0'
STATICFN BOOL PASCAL NEAR
mciFindNotify(
    LPSTR lpString
    )
{
    while (*lpString != '\0')
    {
// "notify" must be preceded by a blank
        if (*lpString++ == ' ')
        {
            LPSTR lpTemp;

            lpTemp = szNotify;
            while (*lpTemp != '\0' && *lpString != '\0' &&
                   *lpTemp == MCI_TOLOWER(*lpString))
            {
                ++lpTemp;
                ++lpString;
            }
// "notify" must be followed by a blank or a null
            if (*lpTemp == '\0' &&
                (*lpString == '\0' || *lpString == ' '))
                return TRUE;
        }
    }
    return FALSE;
}

/*
 * @doc INTERNAL MCI
 *
 * @func UINT | mciAutoOpenDevice | Try to auto-open the given device and
 * then send the given command with notification sent to the system task
 * window proc which sends a close command to the device on receipt
 *
 * @parm LPSTR | lpstrDeviceName | The device name to open
 *
 * @parm LPSTR | lpstrCommand | The full command to send including the
 * device name which must be the same as lpstrDeviceName
 *
 * @parm LPSTR | lpstrReturnString | The caller's return string buffer
 *
 * @parm UINT | wReturnLength | Size of the caller's return string buffer
 *
 * @rdesc The errorcode to return to the user
 */
STATICFN UINT PASCAL NEAR
mciAutoOpenDevice(
    LPSTR lpstrDeviceName,
    LPSTR lpstrCommand,
    LPSTR lpstrReturnString,
    UINT wReturnLength
    )
{
    LPSTR lpstrTempCommand, lpstrTempReturn = NULL;
    UINT wErr;

// "notify" not allowed.  This will be found by the parser but the wrong
// error message will be returned.
    if (mciFindNotify (lpstrCommand))
        return MCIERR_NOTIFY_ON_AUTO_OPEN;

// Build the command string "open <device name>"

// Must be GMEM_SHARE for system task
// device name + blank + "open"
    if ((lpstrTempCommand = mciAlloc (lstrlen (lpstrDeviceName) + 1 +
                                        sizeof (szOpen)))
        == NULL)
        return MCIERR_OUT_OF_MEMORY;

    wsprintf(lpstrTempCommand, szCmdFormat, (LPSTR)szOpen, lpstrDeviceName);
// Get the open string into the system task via a SendMessage() to mmWndProc
    wErr = (UINT)mciSendSystemString (lpstrTempCommand, NULL, NULL);

    mciFree (lpstrTempCommand);

    if (wErr != 0)
        return wErr;

    lpstrTempCommand = NULL;
// Must make a GMEM_SHARE copy of the return string for system task
    if (lpstrReturnString == NULL ||
        (lpstrTempReturn = mciAlloc (wReturnLength + 1)) != NULL)
    {
// Build a GMEM_SHARE command string "<user command> <notify>
// command + blank + "notify"
        if ((lpstrTempCommand = mciAlloc (lstrlen (lpstrCommand) + 1 + sizeof(szNotify))) == NULL)
            mciFree (lpstrTempReturn);
    }

    if (lpstrTempCommand == NULL)
    {
// Close the device
        mciDriverNotify (hwndNotify, mciGetDeviceID (lpstrDeviceName), 0);
        return MCIERR_OUT_OF_MEMORY;
    }

    wsprintf(lpstrTempCommand, szCmdFormat, lpstrCommand, (LPSTR)szNotify);

// Get the user command string into the system task via a SendMessage()
// to mmWndProc
// The notification handle is also mmWndProc
    wErr = (UINT)mciSendSystemString (lpstrTempCommand, lpstrTempReturn,
                                    wReturnLength);

// Copy the return string into the user's buffer
    if (lpstrReturnString != NULL)
    {
        lstrcpy (lpstrReturnString, lpstrTempReturn);
        mciFree (lpstrTempReturn);
    }

    mciFree (lpstrTempCommand);

// If there was an error we must close the device
    if (wErr != 0)
        mciAutoCloseDevice (lpstrDeviceName);

    return wErr;
}

//
// Identical to mciSendString() but the lpMessage parameter is tacked on
//
// lpMessage comes from inter-task mciSendString and includes an
// hCallingTask item which is sent down the the OPEN command
//
STATICFN DWORD NEAR PASCAL
mciSendStringInternal(
    LPCSTR lpstrCommand,
    LPSTR lpstrReturnString,
    UINT wReturnLength,
    HWND hwndCallback,
    LPMCI_SYSTEM_MESSAGE lpMessage
    )
{
    UINT    wID, wConvertReturnValue, wErr, wMessage;
    UINT    wLen;
    UINT    wDeviceID;
    LPDWORD lpdwParams = NULL;
    DWORD   dwReturn, dwFlags = 0;
    LPSTR   lpCommandItem;
    DWORD   dwErr, dwRetType;
    UINT    wTable = (UINT)-1;
    LPSTR    lpstrDeviceName = NULL, lpstrCommandName = NULL;
    LPSTR   FAR *lpstrPointerList = NULL;
    LPSTR   lpstrCommandStart;
    HTASK hCallingTask;
    UINT    wParsingError;
    BOOL    bNewDevice;
    LPSTR   lpstrInputCopy;

    // Did this call come in from another task
    if (lpMessage != NULL)
    {
        // Yes so restore info
        lpstrCommand = lpMessage->lpstrCommand;
        lpstrReturnString = lpMessage->lpstrReturnString;
        wReturnLength = lpMessage->wReturnLength;
        hwndCallback = hwndNotify;
        hCallingTask = lpMessage->hCallingTask;
        lpstrInputCopy = NULL;

    } else
    {
        BOOL bInQuotes = FALSE;

        // No so set hCallingTask to current
        hCallingTask = GetCurrentTask();

        if (lpstrCommand == NULL)
            return MCIERR_MISSING_COMMAND_STRING;

        // Make a copy of the input string and convert tabs to
        // spaces except those inside quotes
        //
        if ((lpstrInputCopy = mciAlloc (lstrlen (lpstrCommand) + 1)) == NULL)
            return MCIERR_OUT_OF_MEMORY;
        lstrcpy (lpstrInputCopy, lpstrCommand);
        lpstrCommand = lpstrInputCopy;
        lpstrCommandStart = (LPSTR)lpstrCommand;
        while (*lpstrCommandStart != '\0')
        {
            if (*lpstrCommandStart == '"')
                bInQuotes = !bInQuotes;
            else if (!bInQuotes && *lpstrCommandStart == '\t')
                *lpstrCommandStart = ' ';
            ++lpstrCommandStart;
        }
    }
    lpstrCommandStart = (LPSTR)lpstrCommand;

    if (lpstrReturnString == NULL) {
        //
        // As an additional safeguard against the driver writing into the
        // output buffer when the return string pointer is NULL, set its
        // length to 0
        //
        wReturnLength = 0;
    }
    else {
        //
        // Set return to empty string so that it won't print out garbage if not
        // touched again
        //
        *lpstrReturnString = '\0';
    }

    // Pull the command name and device name off the command string
    if ((dwReturn = mciSeparateCommandParts (&lpstrCommand, lpMessage != NULL,
                                   &lpstrCommandName, &lpstrDeviceName)) != 0)
        goto exitfn;

    // Get the device id (if any) of the given device name
    wDeviceID = mciGetDeviceIDInternal(lpstrDeviceName, hCallingTask);

    // Allow "new" for an empty device name
    if (wDeviceID == 0 && lstrcmpi (lpstrDeviceName, szNew) == 0)
    {
        bNewDevice = TRUE;
        *lpstrDeviceName = '\0';
    } else {
        bNewDevice = FALSE;
    }


    // Look up the command name
    wMessage = mciParseCommand (wDeviceID, lpstrCommandName, lpstrDeviceName,
                                &lpCommandItem, &wTable);

    // If the device has a pending auto-close
    if (MCI_VALID_DEVICE_ID(wDeviceID))
    {
        LPMCI_DEVICE_NODE nodeWorking = MCI_lpDeviceList[wDeviceID];

        // Is there a pending auto-close message?
        if (nodeWorking->dwMCIFlags & MCINODE_ISAUTOCLOSING)
        {
            // Let the device close
            //!!            Yield();
            // Did the device close?
            //!!            wDeviceID = mciGetDeviceIDInternal (lpstrDeviceName, hCallingTask);
            // If not then fail this command
            //!!            if (wDeviceID == 0)
            //!!            {

            wErr = MCIERR_DEVICE_LOCKED;
            goto cleanup;

            //!!            }

            // If the call does not come from another task and is not owned by this task
            // and is not the SYSINFO command
            //

        } else if (lpMessage == NULL &&
            nodeWorking->hOpeningTask != nodeWorking->hCreatorTask &&
            wMessage != MCI_SYSINFO)
        // Send the string inter-task
        {
            if (mciFindNotify (lpstrCommandStart))
            {
                wErr = MCIERR_NOTIFY_ON_AUTO_OPEN;
                goto cleanup;
            } else
            {
                LPSTR    lpstrReturnStringCopy;

                mciFree(lpstrCommandName);
                mciFree(lpstrDeviceName);
                mciUnlockCommandTable (wTable);

                if ((lpstrReturnStringCopy = mciAlloc (wReturnLength + 1)) != NULL)
                {
                    dwReturn = mciSendSystemString (lpstrCommandStart,
                                                    lpstrReturnStringCopy,
                                                    wReturnLength);
                    lstrcpy (lpstrReturnString, lpstrReturnStringCopy);
                    mciFree (lpstrReturnStringCopy);
                } else
                    dwReturn = MCIERR_OUT_OF_MEMORY;
                goto exitfn;
            }
        }
    }

    // There must be a device name (except for the MCI_SOUND message)
    if (*lpstrDeviceName == '\0' && wMessage != MCI_SOUND && !bNewDevice)
    {
        wErr = MCIERR_MISSING_DEVICE_NAME;
        goto cleanup;
    }

    // The command must appear in the parser tables
    if (wMessage == 0)
    {
        wErr = MCIERR_UNRECOGNIZED_COMMAND;
        goto cleanup;
    }

    // The "new" device name is only legal for the open message
    if (bNewDevice)
    {
        if (wMessage != MCI_OPEN)
        {
            wErr = MCIERR_INVALID_DEVICE_NAME;
            goto cleanup;
        }
    }

    // If there was no device ID
    if (wDeviceID == 0)
        // If auto open is not legal (usually internal commands)
        if (MCI_CANNOT_AUTO_OPEN (wMessage))
        {
            // If the command needs an open device
            if (!MCI_DO_NOT_NEED_OPEN (wMessage))
            {
                wErr = MCIERR_INVALID_DEVICE_NAME;
                goto cleanup;
            }
        } else

        // If auto open is legal try to open the device automatically
        {
            wErr = mciAutoOpenDevice (lpstrDeviceName, lpstrCommandStart,
                                      lpstrReturnString, wReturnLength);
            goto cleanup;
        }

    //
    //   Parse the command parameters
    //
    // Allocate command parameter block
    if ((lpdwParams = (LPDWORD)mciAlloc (sizeof(DWORD) * MCI_MAX_PARAM_SLOTS))
        == NULL)
    {
        wErr = MCIERR_OUT_OF_MEMORY;
        goto cleanup;
    }

    wErr = mciParseParams (lpstrCommand, lpCommandItem,
                            &dwFlags,
                            (LPSTR)lpdwParams,
                            MCI_MAX_PARAM_SLOTS * sizeof(DWORD),
                            &lpstrPointerList, &wParsingError);
    if (wErr != 0)
        goto cleanup;

    // The 'new' device keyword requires an alias
    if (bNewDevice && !(dwFlags & MCI_OPEN_ALIAS))
    {
        wErr = MCIERR_NEW_REQUIRES_ALIAS;
        goto cleanup;
    }

    // Parsed OK so execute command

    // Special processing for the MCI_OPEN message's parameters
    if (wMessage == MCI_OPEN)
    {
        // Manually reference the device type and device element
        if (dwFlags & MCI_OPEN_TYPE)
        {
            // The type name was specified explicitly as a parameter
            // so the given device name is the element name
            ((LPMCI_OPEN_PARMS)lpdwParams)->lpstrElementName
                = (LPSTR)lpstrDeviceName;
            dwFlags |= MCI_OPEN_ELEMENT;
        } else
        {
            // A type must be explicitly specified when "new" is used
            if (bNewDevice)
            {
                wErr = MCIERR_INVALID_DEVICE_NAME;
                goto cleanup;
            }
            // The device type is the given device name.
            // There is no element name
            ((LPMCI_OPEN_PARMS)lpdwParams)->lpstrDeviceType
                = (LPSTR)lpstrDeviceName;
            ((LPMCI_OPEN_PARMS)lpdwParams)->lpstrElementName = NULL;
            dwFlags |= MCI_OPEN_TYPE;
        }
    }

    else if (wMessage == MCI_SOUND && *lpstrDeviceName != '\0')
    {
        // Kludge the sound name for SOUND
        //!!        mciToLower (lpstrDeviceName);
        if (lstrcmpi (lpstrDeviceName, szNotify) == 0)
            dwFlags |= MCI_NOTIFY;
        else if (lstrcmpi (lpstrDeviceName, szWait) == 0)
            dwFlags |= MCI_WAIT;
        else
        {
            ((LPMCI_SOUND_PARMS)lpdwParams)->lpstrSoundName = lpstrDeviceName;
            dwFlags |= MCI_SOUND_NAME;
        }
    }

    // Figure out what kind of return value to expect

    // Initialize flag
    wConvertReturnValue = 0;

    // Skip past header
    wLen = mciEatCommandEntry (lpCommandItem, NULL, NULL);

    // Get return value (if any)
    mciEatCommandEntry (lpCommandItem + wLen, &dwRetType, &wID);
    if (wID == MCI_RETURN)
    {
        // There is a return value
        if (wDeviceID == MCI_ALL_DEVICE_ID && wMessage != MCI_SYSINFO)
        {
            wErr = MCIERR_CANNOT_USE_ALL;
            goto cleanup;
        }
        switch ((UINT)dwRetType)
        {
            case MCI_STRING:
                // The return value is a string, point output
                // buffer to user's buffer
                lpdwParams[1] = (DWORD)lpstrReturnString;
                lpdwParams[2] = (DWORD)wReturnLength;
                break;

            case MCI_INTEGER:
                // The return value is an integer, flag to convert it
                // to a string later
                wConvertReturnValue = MCI_INTEGER;
                break;

            case MCI_RECT:
                // The return value is an rect, flag to
                // convert it to a string later
                wConvertReturnValue = MCI_RECT;
                break;
#ifdef DEBUG
            default:
                DOUT ("mciSendStringInternal:  Unknown return type\r\n");
                break;
#endif
        }
    }

    // We don't need this around anymore
    mciUnlockCommandTable (wTable);
    wTable = (UINT)-1;

    /* Fill the callback entry */
    lpdwParams[0] = (DWORD)(UINT)hwndCallback;

    // Kludge the type number for SYSINFO
    if (wMessage == MCI_SYSINFO)
        ((LPMCI_SYSINFO_PARMS)lpdwParams)->wDeviceType = mciLookUpType(lpstrDeviceName);

    // Now we actually send the command further into the bowels of MCI!

    // The INTERNAL version of mciSendCommand is used in order to get
    // special return description information encoded in the high word
    // of the return value and to get back the list of pointers allocated
    // by any parsing done in the open command
    {
        MCI_INTERNAL_OPEN_INFO OpenInfo;
        OpenInfo.lpstrParams = (LPSTR)lpstrCommand;
        OpenInfo.lpstrPointerList = lpstrPointerList;
        OpenInfo.hCallingTask = hCallingTask;
        OpenInfo.wParsingError = wParsingError;
        dwErr = mciSendCommandInternal (wDeviceID, wMessage, dwFlags,
                                        (DWORD)(LPDWORD)lpdwParams,
                                        &OpenInfo);
        // If the command was reparsed there may be a new pointer list
        // and the old one was free'd
        lpstrPointerList = OpenInfo.lpstrPointerList;
    }

    wErr = (UINT)dwErr;

    if (wErr != 0)
        // If command execution error
        goto cleanup;

    // Command executed OK
    // See if a string return came back with an integer instead
    if (dwErr & MCI_INTEGER_RETURNED)
        wConvertReturnValue = MCI_INTEGER;

    // If the return value must be converted
    if (wConvertReturnValue != 0 && wReturnLength != 0)
        wErr = mciConvertReturnValue (wConvertReturnValue, HIWORD(dwErr),
                                      wDeviceID, lpdwParams,
                                      lpstrReturnString, wReturnLength);

cleanup:
    if (wTable != -1)
        mciUnlockCommandTable (wTable);

    mciFree(lpstrCommandName);
    mciFree(lpstrDeviceName);
    if (lpdwParams != NULL)
        mciFree (lpdwParams);

    // Free any memory used by string parameters
    mciParserFree (lpstrPointerList);

    dwReturn =  (wErr >= MCIERR_CUSTOM_DRIVER_BASE ?
                (DWORD)wErr | (DWORD)wDeviceID << 16 :
                (DWORD)wErr);

#ifdef DEBUG
    if (dwReturn != 0)
    {
        char strTemp[MAXERRORLENGTH];

        if (!mciGetErrorString (dwReturn, strTemp, sizeof(strTemp)))
            LoadString(ghInst, STR_MCISSERRTXT, strTemp, sizeof(strTemp));
        else
            DPRINTF(("mciSendString: %ls\r\n",(LPSTR)strTemp));
    }
#endif

exitfn:
    if (lpstrInputCopy != NULL)
        mciFree (lpstrInputCopy);

#ifdef DEBUG
    mciCheckLocks();
#endif

    return dwReturn;
}

/*
 * @doc EXTERNAL MCI
 *
 * @api DWORD | mciSendString | This function sends a command string to an
 *  MCI device.  The device that the command is sent to is specified in the
 *  command string.
 *
 * @parm LPCSTR | lpstrCommand | Specifies an MCI command string.
 *
 * @parm LPSTR | lpstrReturnString | Specifies a buffer for return
 *  information. If no return information is needed, you can specify
 *  NUL for this parameter.
 *
 * @parm UINT | wReturnLength | Specifies the size of the return buffer
 *  specified by <p lpstrReturnString>.
 *
 * @parm HWND | hwndCallback | Specifies a handle to a window to call back
 *  if "notify" was specified in the command string.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *  error information. The low-order word
 *  of the returned DWORD contains the error return value.
 *
 *  To get a textual description of <f mciSendString> return values,
 *  pass the return value to <f mciGetErrorString>.
 *
 *  The error returns listed for <f mciSendCommand> also apply to
 *  <f mciSendString>. The following error returns are unique to
 *  <f mciSendString>:
 *
 *  @flag MCIERR_BAD_CONSTANT | Unknown value for parameter.
 *
 *  @flag MCIERR_BAD_INTEGER | Invalid or missing integer in command.
 *
 *  @flag MCIERR_DUPLICATE_FLAGS | A flag or value was specified twice.
 *
 *  @flag MCIERR_MISSING_COMMAND_STRING | No command was specified.
 *
 *  @flag MCIERR_MISSING_DEVICE_NAME | No device name was specified.
 *
 *  @flag MCIERR_MISSING_STRING_ARGUMENT | A string value was
 *  missing from the command.
 *
 *  @flag MCIERR_NEW_REQUIRES_ALIAS | An alias must be used
 *  with the "new" device name.
 *
 *  @flag MCIERR_NO_CLOSING_QUOTE | A closing quotation mark is missing.
 *
 *  @flag MCIERR_NOTIFY_ON_AUTO_OPEN | The "notify" flag is illegal
 *  with auto-open.
 *
 *  @flag MCIERR_PARAM_OVERFLOW | The output string was not long enough.
 *
 *  @flag MCIERR_PARSER_INTERNAL | Internal parser error.
 *
 *  @flag MCIERR_UNRECOGNIZED_KEYWORD | Unknown command parameter.
 *
 * @xref mciGetErrorString mciSendCommand
 */
DWORD WINAPI
mciSendString(
    LPCSTR lpstrCommand,
    LPSTR lpstrReturnString,
    UINT wReturnLength,
    HWND hwndCallback
    )
{
    DWORD   dwErr32;
    DWORD   dwErr16 = MMSYSERR_NOERROR;
    LPSTR   lpstr;
    BOOL    fHaveAll = FALSE;

    // Initialize the 16-bit device list
    if (!MCI_bDeviceListInitialized && !mciInitDeviceList()) {
        return MCIERR_OUT_OF_MEMORY;
    }

    dwErr32 = mciMessage( THUNK_MCI_SENDSTRING, (DWORD)lpstrCommand,
                          (DWORD)lpstrReturnString, (DWORD)wReturnLength,
                          (DWORD)hwndCallback );

    /*
    ** Even if the string was processed correctly by the 32 bit side
    ** we might still have to pass it through to the 16 bit side if it
    ** contains the string " all\0" or " all ".
    */
    lpstr = _fstrstr( lpstrCommand, " all" );
    if ( lpstr ) {

        lpstr += 4;

        if ( *lpstr == ' ' || *lpstr == '\0' ) {
            fHaveAll = TRUE;
        }
    }


    /*
    ** If we have the all device or an error from the 32 bit side
    ** we have to try the 16 bit side.
    */

    if ( !fHaveAll && dwErr32 == MMSYSERR_NOERROR ) {
        return dwErr32;
    }
    else {

        dwErr16 = mciSendStringInternal( lpstrCommand, lpstrReturnString,
                                         wReturnLength, hwndCallback, NULL );
    }


    /*
    ** Special processing of the return code is required if the
    ** MCI_ALL_DEVICE_ID was specified.
    */
    if ( fHaveAll ) {
        if ( (dwErr16 != MMSYSERR_NOERROR)
          && (dwErr32 != MMSYSERR_NOERROR) ) {

            return dwErr32;
        }
        else {
            return MMSYSERR_NOERROR;
        }
    }

    if ( dwErr32 != MCIERR_INVALID_DEVICE_NAME
      && dwErr16 != MMSYSERR_NOERROR ) {

         return dwErr32;
    }

    return dwErr16;
}


/*
 * @doc INTERNAL MCI
 *
 * @api BOOL | mciExecute | This function is a simplified version of the
 *  <f mciSendString> function. It does not take a buffer for
 *  return information, and it displays a message box when errors occur.
 *
 * @parm LPCSTR | lpstrCommand | Specifies an MCI command string.
 *
 * @rdesc TRUE if successful, FALSE if unsuccessful.
 *
 * @comm This function provides a simple interface to MCI from scripting
 *  languages.
 *
 * @xref mciSendString
 */
BOOL WINAPI
mciExecute(
    LPCSTR lpstrCommand
    )
{
    char aszError[MAXERRORLENGTH];
    DWORD dwErr;
    LPSTR lpstrName;

    if (LOWORD(dwErr = mciSendString (lpstrCommand, NULL, 0, NULL)) == 0)
        return TRUE;

    if (!mciGetErrorString (dwErr, aszError, sizeof(aszError)))
        LoadString(ghInst, STR_MCIUNKNOWN, aszError, sizeof(aszError));
    else

    if (lpstrCommand != NULL)
    {
// Skip initial blanks
        while (*lpstrCommand == ' ')
            ++lpstrCommand;
// Then skip the command
        while (*lpstrCommand != ' ' && *lpstrCommand != '\0')
            ++lpstrCommand;
// Then blanks before the device name
        while (*lpstrCommand == ' ')
            ++lpstrCommand;

// Now, get the device name
        if (lpstrCommand != '\0' &&
            mciEatToken (&lpstrCommand, ' ', &lpstrName, FALSE) != 0)
            DOUT ("Could not allocate device name text for error box\r\n");
    } else
        lpstrName = NULL;

    MessageBox (NULL, aszError, lpstrName, MB_ICONHAND | MB_OK);

    if (lpstrName != NULL)
        mciFree(lpstrName);

    return FALSE;
}

/*
 * @doc EXTERNAL MCI
 *
 * @api BOOL | mciGetErrorString | This function returns a
 * textual description of the specified MCI error.
 *
 * @parm DWORD | dwError | Specifies the error code returned by
 *  <f mciSendCommand> or <f mciSendString>.
 *
 * @parm LPSTR | lpstrBuffer | Specifies a pointer to a buffer that is
 *  filled with a textual description of the specified error.
 *
 * @parm UINT | wLength | Specifies the length of the buffer pointed to by
 *  <p lpstrBuffer>.
 *
 * @rdesc Returns TRUE if successful.  Otherwise, the given error code
 *  was not known.
 */
BOOL WINAPI
mciGetErrorString (
    DWORD dwError,
    LPSTR lpstrBuffer,
    UINT wLength
    )
{
    HINSTANCE hInst;


    if (lpstrBuffer == NULL)
        return FALSE;

    if ( mciMessage( THUNK_MCI_GETERRORSTRING, (DWORD)dwError,
                     (DWORD)lpstrBuffer, (DWORD)wLength, 0L ) ) {
        return TRUE;
    }

// If the high bit is set then get the error string from the driver
// else get it from mmsystem.dll
    if (HIWORD(dwError) != 0)
    {
        if (!MCI_VALID_DEVICE_ID (HIWORD (dwError)) || !(hInst = MCI_lpDeviceList[HIWORD (dwError)]->hDriver))
        {
            hInst = ghInst;
            dwError = MCIERR_DRIVER;
        }
    } else
        hInst = ghInst;

    if (LoadString (hInst, LOWORD(dwError), lpstrBuffer, wLength) == 0)
    {
// If the string load failed then at least terminate the string
        if (wLength > 0)
            *lpstrBuffer = '\0';
        return FALSE;
    }
    else
        return TRUE;
}

#if 0
/* Return non-zero if load successful */
BOOL NEAR PASCAL MCIInit(void)
{
    mci32Message = (LPMCIMESSAGE)GetProcAddress32W( mmwow32Lib,
                                                    "mci32Message" );
    return TRUE;
}
#endif


void NEAR PASCAL
MCITerminate(
    void
    )
{
/*
    We would like to close all open devices here but cannot because of
 	   unknown WEP order
*/
    if (hMciHeap != NULL)
        HeapDestroy(hMciHeap);

    hMciHeap = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\mmsystem\init.c ===
/*
    init.c

    Level 1 kitchen sink DLL initialisation

    Copyright (c) Microsoft Corporation 1990. All rights reserved

*/
#ifdef DEBUG
#ifndef DEBUG_RETAIL
#define DEBUG_RETAIL
#endif
#endif

#include <windows.h>
#include <mmsysver.h>
#include "mmsystem.h"
#include "mmddk.h"
#include "mmsysi.h"
#include "drvr.h"
#include "thunks.h"


/****************************************************************************

    global data

****************************************************************************/

HINSTANCE ghInst;                     // our module handle


/* -------------------------------------------------------------------------
** Thunking stuff
** -------------------------------------------------------------------------
*/
LPCB32             PASCAL cb32;
LPSOUNDDEVMSGPROC  PASCAL wod32Message;
LPSOUNDDEVMSGPROC  PASCAL wid32Message;
LPSOUNDDEVMSGPROC  PASCAL mod32Message;
LPSOUNDDEVMSGPROC  PASCAL mid32Message;
LPSOUNDDEVMSGPROC  PASCAL aux32Message;
JOYMESSAGEPROC     PASCAL joy32Message;


UINT FAR PASCAL _loadds ThunkInit(void);
static BOOL NEAR PASCAL ThunkTerm( void );

LPSOUNDDEVMSGPROC  PASCAL wodMapper;
LPSOUNDDEVMSGPROC  PASCAL widMapper;


#ifdef DEBUG_RETAIL
BYTE    fIdReverse;                   // reverse wave/midi id's
#endif

PHNDL pHandleList;

#ifdef   DEBUG_RETAIL
extern  int         DebugmciSendCommand;    // in MCI.C
#endif

#ifdef DEBUG
extern  WORD        fDebug;
#endif

/****************************************************************************

    strings

****************************************************************************/

static  SZCODE  szMMWow32[]             = "winmm.dll";
static  SZCODE  szNotifyCB[]             = "NotifyCallbackData";
static  SZCODE  szWodMessage[]          = "wod32Message";
static  SZCODE  szWidMessage[]          = "wid32Message";
static  SZCODE  szModMessage[]          = "mod32Message";
static  SZCODE  szMidMessage[]          = "mid32Message";
static  SZCODE  szAuxMessage[]          = "aux32Message";
static  SZCODE  szTidMessage[]          = "tid32Message";
static  SZCODE  szJoyMessage[]          = "joy32Message";
static  SZCODE  szWaveMapper[]          = "wavemapper";
static  SZCODE  szWodMapper[]           = "wodMessage";
static  SZCODE  szWidMapper[]           = "widMessage";

        SZCODE  szNull[]                = "";
        SZCODE  szSystemIni[]           = "system.ini";
        SZCODE  szDrivers[]             = "Drivers";
        SZCODE  szBoot[]                = "boot";
        SZCODE  szDriverProc[]          = "DriverProc";
        SZCODE  szJoystick[]            = "joystick";
        SZCODE  szJoystickDrv[]         = "joystick.drv";
        SZCODE  szTimerDrv[]            = "timer";

#ifdef DEBUG_RETAIL
        SZCODE  szLibMain[]     = "MMSYSTEM: Win%dp %ls Version"
                                  "%d.%02d MMSystem Version %d.%02d.%03d\r\n";
        SZCODE  szWinDebug[]    = "(Debug)";
        SZCODE  szWinRetail[]   = "(Retail)";
#endif

        SZCODE  szMMSystem[]            = "mmsystem";
        SZCODE  szStackFrames[]         = "StackFrames";
        SZCODE  szStackSize[]           = "StackSize";

#ifdef DEBUG_RETAIL
        SZCODE  szDebugOutput[]         = "DebugOutput";
        SZCODE  szMci[]                 = "mci";
#endif
#ifdef DEBUG
        SZCODE  szDebug[]               = "Debug";
#endif

#ifdef   DEBUG_RETAIL
/*****************************************************************************
 *
 * DebugInit()  - called from init.c!LibMain() to handle any DLL load time
 *                initialization in the DEBUG version
 *
 ****************************************************************************/

#pragma warning(4:4704)

static  void NEAR PASCAL
DebugInit(
    void
    )
{
        fDebugOutput = GetPrivateProfileInt(szMMSystem,szDebugOutput,0,szSystemIni);
        DebugmciSendCommand = GetPrivateProfileInt(szMMSystem,szMci,0,szSystemIni);

#ifdef DEBUG
        fDebug = GetPrivateProfileInt(szMMSystem,szDebug,fDebugOutput,szSystemIni);

        if (fDebug && !fDebugOutput)
                fDebug = FALSE;

        if (fDebug) {
            OutputDebugString( "Breaking for debugging\r\n" );
            _asm int 3
        }
#endif
}
#endif   // ifdef DEBUG_RETAIL



/****************************************************************************

    Library initialization code

    libentry took care of calling LibMain() and other things....

****************************************************************************/
int NEAR PASCAL
LibMain(
    HINSTANCE hInstance,
    UINT cbHeap,
    LPSTR lpCmdLine
    )
{

#ifdef DEBUG_RETAIL
    WORD    w;
#endif

    ghInst = hInstance;

    /*
    ** Here we do a global alloc of the Callback data array.  We then
    ** Lock and Page Lock the allocated storage and initialize the storage
    ** to all zeros.  We then call WOW32 passing to it the address of the
    ** Callback data array, which is saved by WOW32.
    */
    hGlobal = GlobalAlloc( GHND, sizeof(CALLBACK_DATA) );
    if ( hGlobal == (HGLOBAL)NULL ) {
        return FALSE;
    }

    vpCallbackData = (VPCALLBACK_DATA)GlobalLock( hGlobal );
    if ( vpCallbackData == NULL ) {
        return FALSE;
    }

    if ( !HugePageLock( vpCallbackData, (DWORD)sizeof(CALLBACK_DATA) ) ) {
        return FALSE;
    }

    /*
    ** Now we create our interrupt callback stacks.
    */
    if ( StackInit() == FALSE ) {
        return FALSE;
    }

    /*
    ** Now we install our interrupt service routine.  InstallInterruptHandler
    ** return FALSE if it couldn't set the interrupt vector.  If this is the
    ** case we have to terminate the load of the dll.
    */
    if ( InstallInterruptHandler() == FALSE ) {
        return FALSE;
    }


#ifdef DEBUG_RETAIL
    DebugInit();
    w = (WORD)GetVersion();
#endif

    DPRINTF(( szLibMain, WinFlags & WF_WIN386 ? 386 : 286,
        (LPSTR)(GetSystemMetrics(SM_DEBUG) ? szWinDebug : szWinRetail),
        LOBYTE(w), HIBYTE(w),
        HIBYTE(mmsystemGetVersion()), LOBYTE(mmsystemGetVersion()),
        MMSYSRELEASE ));

#ifdef DEBUG
    DPRINTF(("MMSYSTEM: NumTasks: %d\r\n", GetNumTasks()));
    //
    // 3.0 - MMSYSTEM must be loaded by MMSOUND (ie at boot time)
    // check for this and fail to load otherwise.
    //
    // the real reason we need loaded at boot time is so we can get
    // in the enable/disable chain.
    //
    if (GetNumTasks() > 1)
    {
        DOUT("MMSYSTEM: ***!!! Not correctly installed !!!***\r\n");
////////return FALSE;   -Dont fail loading, just don't Enable()
    }
#endif

#ifdef DEBUG_RETAIL
    //
    // fIdReverse being TRUE causes mmsystem to reverse all wave/midi
    // logical device id's.
    //
    // this prevents apps/drivers assuming a driver load order.
    //
    // see wave.c!MapWaveId() and midi.c!MapId()
    //

    fIdReverse = LOBYTE(LOWORD(GetCurrentTime())) & (BYTE)0x01;

    if (fIdReverse)
        ROUT("MMSYSTEM: wave/midi driver id's will be inverted");
#endif

    //
    // do a LoadLibrary() on ourself
    //
    LoadLibrary(szMMSystem);

    return TRUE;
}

/****************************************************************************

    DrvFree - Handler for a DRV_FREE driver message

****************************************************************************/
void FAR PASCAL
DrvFree(
    void
    )
{
    MCITerminate();     // mci.c    free heap
    WndTerminate();     // mmwnd.c  destroy window, unregister class
    if ( mmwow32Lib != 0L ) {
        ThunkTerm();
    }
}


/****************************************************************************

    DrvLoad - handler for a DRV_LOAD driver message

****************************************************************************/
BOOL FAR PASCAL DrvLoad(void)
{

/*
**  The VFW1.1 wave mapper was GP faulting in Daytona when running dangerous
**  creatures videos.  Since it was trying to load an invalid selector in
**  its callback routine it's doubtful we can ever enable them.
**
*/
#if 0 // The wave mappers were GP faulting in Daytona so NOOP for now

    HDRVR   h;


    /* The wave mapper.
     *
     * MMSYSTEM allows the user to install a special wave driver which is
     * not visible to the application as a physical device (it is not
     * included in the number returned from getnumdevs).
     *
     * An application opens the wave mapper when it does not care which
     * physical device is used to input or output waveform data. Thus
     * it is the wave mapper's task to select a physical device that can
     * render the application-specified waveform format or to convert the
     * data into a format that is renderable by an available physical
     * device.
     */

    if (h = mmDrvOpen(szWaveMapper))
    {
        mmDrvInstall(h, &wodMapper, MMDRVI_MAPPER|MMDRVI_WAVEOUT|MMDRVI_HDRV);
        /* open again to get usage count in DLL correct */
        h = mmDrvOpen(szWaveMapper);
        mmDrvInstall(h, &widMapper, MMDRVI_MAPPER|MMDRVI_WAVEIN |MMDRVI_HDRV);
    }
#endif // NOOP wave mapper


    if ( TimeInit() && WndInit() ) {
        return TRUE;
    }

    //
    // something failed, backout the changes
    //
    DrvFree();
    return FALSE;
}

/******************************Public*Routine******************************\
* StackInit
*
*
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
BOOL FAR PASCAL
StackInit(
    void
    )
{
#   define GMEM_STACK_FLAGS        (GMEM_FIXED | GMEM_SHARE)
#   define DEF_STACK_SIZE          0x600           // 1.5k
#   define DEF_STACK_FRAMES        3
#   define MIN_STACK_SIZE          64
#   define MIN_STACK_FRAMES        1

    DWORD   dwStackBytes;
    WORD    wStackFrames;

    //
    //  The original Window 3.1 code didn't create stack frames for the
    //  Windows Enchanced mode.  However, WOW only emulates standard mode so
    //  I won't bother with this distinction.
    //
    //  if (WinFlags & WF_ENHANCED)
    //      return TRUE;
    //

    /* read stackframes and stacksize from system.ini */
    gwStackSize = GetPrivateProfileInt( szMMSystem, szStackSize,
                                        DEF_STACK_SIZE, szSystemIni );

    /* make sure value isn't something bad */
    if ( gwStackSize < DEF_STACK_SIZE ) {
        gwStackSize = DEF_STACK_SIZE;
    }

    wStackFrames = GetPrivateProfileInt( szMMSystem, szStackFrames,
                                         DEF_STACK_FRAMES, szSystemIni );

    //
    // Always create at least DEF_STACK_FRAMES stack frames.
    //
    if ( wStackFrames < DEF_STACK_FRAMES ) {
        wStackFrames = DEF_STACK_FRAMES;
    }

    gwStackFrames = wStackFrames;

    /* round to nearest number of WORDs */
    gwStackSize = (gwStackSize + 1) & ~1;

    dwStackBytes = (DWORD)gwStackSize * (DWORD)gwStackFrames;

    /* try to alloc memory */
    if ( dwStackBytes >= 0x10000 ||
       !(gwStackSelector = GlobalAlloc(GMEM_STACK_FLAGS, dwStackBytes)) )
    {
        gwStackFrames = DEF_STACK_FRAMES;
        gwStackSize   = DEF_STACK_SIZE;

        /* do as little at runtime as possible.. */
        dwStackBytes = (DWORD)(DEF_STACK_FRAMES * DEF_STACK_SIZE);

        /* try allocating defaults--if this fails, we are HOSED! */
        gwStackSelector = GlobalAlloc( GMEM_STACK_FLAGS, dwStackBytes );
    }

    /*
    ** set to first available stack
    */
    gwStackUse = (WORD)dwStackBytes;


    /*
    ** did we get memory for stacks??
    */
    if ( !gwStackSelector ) {

        /*
        ** no stacks available... as if we have a chance of survival!
        */

        gwStackUse = 0;
        return FALSE;
    }

    /* looks good... */
    return TRUE;
}


/*****************************Private*Routine******************************\
* StackInit
*
*
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
BOOL NEAR PASCAL
StackTerminate(
    void
    )
{
    if ( gwStackSelector )
    {
        DOUT("MMSTACKS: Freeing stacks\r\n");

        gwStackSelector = GlobalFree( gwStackSelector );

        if ( gwStackSelector )
            DOUT("MMSTACKS: GlobalFree failed!\r\n");
    }

    /* return the outcome... non-zero is bad */
    return ( (BOOL)gwStackSelector );
} /* StackTerminate() */


/*****************************************************************************
 * @doc EXTERNAL MMSYSTEM
 *
 * @api WORD | mmsystemGetVersion | This function returns the current
 * version number of the Multimedia extensions system software.
 *
 * @rdesc The return value specifies the major and minor version numbers of
 * the Multimedia extensions.  The high-order byte specifies the major
 * version number.  The low-order byte specifies the minor version number.
 *
 ****************************************************************************/
WORD WINAPI mmsystemGetVersion(void)
{
    return(MMSYSTEM_VERSION);
}


/*****************************************************************************
 *
 * @doc   INTERNAL
 *
 * @api   BOOL | DrvTerminate | This function cleans up the installable
 *        driver interface.
 *
 ****************************************************************************/
static void NEAR PASCAL DrvTerminate(void)
{
// don't know about system exit dll order - so do nothing.
}


/*****************************************************************************
 * @doc INTERNAL
 *
 * @api BOOL | mmDrvInstall | This function installs a WAVE driver
 *
 * @parm HANDLE | hDriver | Module handle or driver handle containing driver
 *
 * @parm DRIVERMSGPROC | drvMessage | driver message procedure, if NULL
 *      the standard name will be used (looked for with GetProcAddress)
 *
 * @parm UINT | wFlags | flags
 *
 *      @flag MMDRVI_TYPE      | driver type mask
 *      @flag MMDRVI_WAVEIN    | install driver as a wave input  driver
 *      @flag MMDRVI_WAVEOUT   | install driver as a wave ouput  driver
 *
 *      @flag MMDRVI_MAPPER    | install this driver as the mapper
 *      @flag MMDRVI_HDRV      | hDriver is a installable driver
 *
 *  @rdesc  returns NULL if unable to install driver
 *
 ****************************************************************************/
BOOL WINAPI
mmDrvInstall(
    HANDLE hDriver,
    DRIVERMSGPROC *drvMessage,
    UINT wFlags
    )
{
    DWORD       dw;
    HINSTANCE   hModule;
    UINT        msg_num_devs;
    SZCODE      *szMessage;

    hModule = GetDriverModuleHandle((HDRVR)hDriver);

    switch (wFlags & MMDRVI_TYPE)
    {
        case MMDRVI_WAVEOUT:
            msg_num_devs = WODM_GETNUMDEVS;
            szMessage    = szWodMapper;
            break;

        case MMDRVI_WAVEIN:
            msg_num_devs = WIDM_GETNUMDEVS;
            szMessage    = szWidMapper;
            break;

        default:
            goto error_exit;
    }

    if (hModule != NULL)
        *drvMessage = (DRIVERMSGPROC)GetProcAddress(hModule, szMessage);

    if (*drvMessage == NULL)
        goto error_exit;

    //
    // send the init message, if the driver returns a error, should we
    // unload them???
    //
    dw = (*(*drvMessage))(0,DRVM_INIT,0L,0L,0L);

    //
    // call driver to get num-devices it supports
    //
    dw = (*(*drvMessage))(0,msg_num_devs,0L,0L,0L);

    //
    //  the device returned a error, or has no devices
    //
    if (HIWORD(dw) != 0)
        goto error_exit;

    return TRUE;

error_exit:
    if (hDriver)
        CloseDriver(hDriver, 0, 0);

    return FALSE;
}


/*****************************************************************************
 *
 * @doc   INTERNAL
 *
 * @api   HDRVR | mmDrvOpen | This function load's an installable driver, but
 *                 first checks weather it exists in the [Drivers] section.
 *
 * @parm LPSTR | szAlias | driver alias to load
 *
 * @rdesc The return value is return value from OpenDriver or NULL if the alias
 *        was not found in the [Drivers] section.
 *
 ****************************************************************************/
HDRVR NEAR PASCAL
mmDrvOpen(
    LPSTR szAlias
    )
{
    char buf[3];

    if (GetPrivateProfileString( szDrivers,szAlias,szNull,buf,
                                 sizeof(buf),szSystemIni )) {

        return OpenDriver(szAlias, NULL, 0L);
    }
    else {
        return NULL;
    }
}

/*****************************Private*Routine******************************\
* ThunkInit
*
* Tries to setup the thunking system.  If this can not be performed
* it returns an error code of MMSYSERR_NODRIVER.  Otherwise it returns
* MMSYSERR_NOERROR to indicate sucess.
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
UINT FAR PASCAL _loadds
ThunkInit(
    void
    )
{
    mmwow32Lib = LoadLibraryEx32W( szMMWow32, NULL, 0L );
    if ( mmwow32Lib == 0L ) {
        return MMSYSERR_NODRIVER;
    }
    cb32 = (LPCB32)GetProcAddress32W(mmwow32Lib, szNotifyCB );

    /*
    ** Now we notify WOW32 that all is OK by passing the 16:16 bit pointer
    ** to the CALLBACK_DATA to it.
    */
    Notify_Callback_Data( vpCallbackData );

    /*
    ** Now initialize the rest of the thunking system
    */
    wod32Message = (LPSOUNDDEVMSGPROC)GetProcAddress32W( mmwow32Lib, szWodMessage );
    wid32Message = (LPSOUNDDEVMSGPROC)GetProcAddress32W( mmwow32Lib, szWidMessage );
    mod32Message = (LPSOUNDDEVMSGPROC)GetProcAddress32W( mmwow32Lib, szModMessage );
    mid32Message = (LPSOUNDDEVMSGPROC)GetProcAddress32W( mmwow32Lib, szMidMessage );
    aux32Message = (LPSOUNDDEVMSGPROC)GetProcAddress32W( mmwow32Lib, szAuxMessage );
    mci32Message = (LPMCIMESSAGE)GetProcAddress32W( mmwow32Lib, "mci32Message" );
    tid32Message = (TIDMESSAGEPROC)GetProcAddress32W( mmwow32Lib, szTidMessage );
    joy32Message = (JOYMESSAGEPROC)GetProcAddress32W( mmwow32Lib, szJoyMessage );

    return MMSYSERR_NOERROR;
}

/*****************************Private*Routine******************************\
* ThunkTerm
*
*
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
static BOOL NEAR PASCAL
ThunkTerm(
    void
    )
{
    /*
    ** Free the interrupt stack frames and  uninstall the interrupt handler.
    */
    StackTerminate();
    DeInstallInterruptHandler();

    /*
    ** Next we notify WOW32 that we are going away by passing NULL to
    ** Notify_Callback_Data, then free the storage.
    */
    Notify_Callback_Data( NULL );
    HugePageUnlock( vpCallbackData, (DWORD)sizeof(CALLBACK_DATA) );
    GlobalUnlock( hGlobal );
    GlobalFree( hGlobal );

    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\mmsystem\hmemcpy.asm ===
; mem.asm:
;
; masm -Mx -Zi -DSEGNAME=????? asm.asm
;
	TITLE MEM.ASM

;****************************************************************
;* MEM.ASM - Assembly mem-copy routines				*
;*		for 80286 and 80386				*
;****************************************************************
;

?PLM=1	    ; PASCAL Calling convention is DEFAULT
?WIN=0      ; Windows calling convention

.xlist
include cmacros.inc
include windows.inc
.list

	externA	    __WinFlags	    ; in KERNEL
	externA	    __AHINCR	    ; in KERNEL
	externA	    __AHSHIFT	    ; in KERNEL

; The following structure should be used to access high and low
; words of a DWORD.  This means that "word ptr foo[2]" -> "foo.hi".

LONG	struc
lo	dw	?
hi	dw	?
LONG	ends

FARPOINTER	struc
off	dw	?
sel	dw	?
FARPOINTER	ends

; -------------------------------------------------------
;		DATA SEGMENT DECLARATIONS
; -------------------------------------------------------

ifndef SEGNAME
    SEGNAME equ <_TEXT>
endif

createSeg %SEGNAME, CodeSeg, word, public, CODE

sBegin Data
sEnd Data

sBegin CodeSeg
        assumes cs,CodeSeg
        assumes ds,DATA

cProc fstrrchr,<NEAR,PASCAL,PUBLIC,NODATA>,<di>
	ParmD	lsz
	ParmB	c
cBegin
	les	di, lsz
	xor	al, al			; Search for terminating NULL
	mov	cx, -1			; Search forever
	cld				; Moving forward
	repne	scasb			; Look for the NULL
	not	cx			; Negative value minus 1 gives length
	dec	cx			; CX is always incremented
	jcxz	fstrrchr_fail		; Zero length string fails
	dec	di			; DI is one past character found
	dec	di			; Back up to last character in string
	mov	al, c			; Get character to search for
	std				; Moving backwards
	repne	scasb			; Look for the character
	cld				; Reset direction
	jne	fstrrchr_fail		; Fail if not found
	inc	di			; Back up to actual character found
	mov	ax, di			; Return pointer to that character
	mov	dx, es
	jmp	fstrrchr_exit
fstrrchr_fail:
	xor	ax, ax			; Return NULL on failure
	cwd
fstrrchr_exit:
cEnd

;---------------------------Public-Routine------------------------------;
; MemCopy
;
;   copy memory, dons *not* handle overlaped copies.
;
; Entry:
;	lpSrc	HPSTR to copy from
;	lpDst	HPSTR to copy to
;	cbMem	DWORD count of bytes to move
;
; Returns:
;	destination pointer
; Error Returns:
;	None
; Registers Preserved:
;	BP,DS,SI,DI
; Registers Destroyed:
;	AX,BX,CX,DX,FLAGS
; Calls:
;	nothing
; History:
;
;	Wed 04-Jan-1990 13:45:58 -by-  Todd Laney [ToddLa]
;	Created.
;	Tue 16-Oct-1990 16:41:00 -by-  David Maymudes [DavidMay]
;	Modified 286 case to work correctly with cbMem >= 64K.
;	Changed name to hmemcpy.
;	Changed 386 case to copy by longwords
;-----------------------------------------------------------------------;

cProc MemCopy,<NEAR,PASCAL,PUBLIC,NODATA>,<>
;	 ParmD	 lpDst
;	 ParmD	 lpSrc
;	 ParmD	 cbMem
cBegin	<nogen>
	mov	ax,__WinFlags
	test	ax,WF_CPU286
        jz      MemCopy386
        jmp     NEAR PTR MemCopy286
cEnd <nogen>

cProc MemCopy386,<NEAR,PASCAL,PUBLIC,NODATA>,<ds>
	ParmD	lpDst
	ParmD	lpSrc
	ParmD	cbMem
cBegin
	.386
	push	edi
	push	esi
	cld

	mov	ecx,cbMem
	jecxz	mc386_exit

	movzx	edi,di
	movzx	esi,si
	lds	si,lpSrc
	les	di,lpDst

	push	ecx
	shr	ecx,2		; get count in DWORDs
	rep	movs dword ptr es:[edi], dword ptr ds:[esi]
	db	67H
	pop	ecx
	and	ecx,3
	rep	movs byte ptr es:[edi], byte ptr ds:[esi]
	db	67H
	nop
mc386_exit:
	cld
	pop	esi
	pop	edi
	mov	dx,lpDst.sel	; return destination address
	mov	ax,lpDst.off
	.286
cEnd

cProc MemCopy286,<NEAR,PASCAL,PUBLIC,NODATA>,<ds,si,di>
	ParmD	lpDst
	ParmD	lpSrc
	ParmD	cbMem
cBegin
	mov	cx,cbMem.lo	; CX holds count
	or	cx,cbMem.hi	; or with high word
	jnz	@f
	jmp	empty_copy
@@:
	lds	si,lpSrc	  ; DS:SI = src
	les	di,lpDst	  ; ES:DI = dst

next:
	mov	ax,cx
	dec	ax

	mov	ax,di
	not	ax		; AX = 65535-DI

	mov	dx,si
	not	dx		; DX = 65535-SI

	sub	ax,dx
	sbb	bx,bx
	and	ax,bx
	add	ax,dx		; AX = MIN(AX,DX) = MIN(65535-SI,65535-DI)

	; problem: ax might have wrapped to zero

	test	cbMem.hi,-1
	jnz	plentytogo	; at least 64k still to copy
	
	dec	cx		; this is ok, since high word is zero
	sub	ax,cx
	sbb	bx,bx
	and	ax,bx
	add	ax,cx		; AX = MIN(AX,CX)
	inc	cx

plentytogo:
	xor	bx,bx
	add	ax,1		; AX = Num = MIN(count,65536-SI,65536-DI)
				; we must check the carry here!
	adc	bx,0		; BX could be 1 here, if CX==0 indicating
				; exactly 64k to copy
	xchg	ax,cx
	sub	ax,cx		; Count -= Num
	sbb	cbMem.hi,bx

	shr	bx,1
	rcr	cx,1		; if bx==1, then cx ends up 0x8000
	rep	movsw
	jnc	@f
	movsb			; move last byte, if necessary
@@:
	mov	cx,ax		; put low word of count back in cx
	or	ax,cbMem.hi

	jz	done		; If Count == 0 Then BREAK

	or	si,si		; if SI wraps, update DS
	jnz	@f
;
	mov	ax,ds
	add	ax,__AHINCR
	mov	ds,ax		; update DS if appropriate
@@:
	or	di,di		; if DI wraps, update ES
	jnz	next
;
	mov	ax,es
	add	ax,__AHINCR
	mov	es,ax		; update ES if appropriate
	jmp	next
;
; Restore registers and return
;
done:
empty_copy:
	mov	dx,lpDst.sel	; return destination address
	mov	ax,lpDst.off
cEnd

sEnd

sEnd CodeSeg
end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\mmsystem\heap.asm ===
page    ,132
;-----------------------------Module-Header-----------------------------;
; Module Name:  HEAP.ASM
;
;   This module contains functions for dealing with external local heaps
;
; Created:  09-20-90
; Author:   Todd Laney [ToddLa]
;
; Copyright (c) 1984-1990 Microsoft Corporation
;
; Exported Functions:	none
;
; Public Functions:     HeapCreate
;                       HeapDestroy
;                       HeapAlloc
;                       HeapFree
;
; Public Data:          none
;
; General Description:
;
; Restrictions:
;
;-----------------------------------------------------------------------;

        ?PLM    = 1
        ?WIN    = 0
        ?NODATA = 1
        .286p

	.xlist
	include cmacros.inc
        include windows.inc
        .list

        MIN_HEAPSIZE    = 128
        GMEM_SHARE      = GMEM_DDESHARE

        externFP        LocalInit           ; in KERNEL
        externFP        LocalAlloc          ; in KERNEL
        externFP        LocalReAlloc        ; in KERNEL
        externFP        LocalFree           ; in KERNEL
        externFP        LocalCompact        ; in KERNEL
        externFP        GlobalAlloc         ; in KERNEL
        externFP        GlobalLock          ; in KERNEL
        externFP        GlobalUnlock        ; in KERNEL
        externFP        GlobalFree          ; in KERNEL


; The following structure should be used to access high and low
; words of a DWORD.  This means that "word ptr foo[2]" -> "foo.hi".

LONG    struc
lo      dw      ?
hi      dw      ?
LONG    ends

FARPOINTER      struc
off     dw      ?
sel     dw      ?
FARPOINTER      ends

createSeg INIT, InitSeg, word, public, CODE

sBegin InitSeg
        assumes cs,InitSeg
        assumes ds,nothing
        assumes es,nothing

;---------------------------Public-Routine------------------------------;
; HeapCreate
;
;   Create a external heap
;
; Entry:
;       cbSize is the initial size of the heap
;
; Returns:
;       AX = handle to heap
; Error Returns:
;       AX = 0
; Registers Preserved:
;       BP,DS,SI,DI
; Registers Destroyed:
;       AX,BX,CX,DX,FLAGS
; Calls:
;       GlobalAlloc, LocalInit
; History:
;       Fri 21-Sep-1990 13:45:58 -by-  Todd Laney [ToddLa]
;	Created.
;-----------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing

cProc   HeapCreate, <FAR,PUBLIC>, <>
        ParmW   cbSize
cBegin
        mov     ax,cbSize
        cmp     ax,MIN_HEAPSIZE
        jg      hc_alloc
        mov     ax,MIN_HEAPSIZE
        mov     cbSize,ax

hc_alloc:
        cCall   GlobalAlloc, <GHND+GMEM_SHARE,0,ax>
        or      ax,ax
        jz      hc_exit

        cCall   GlobalLock, <ax>
        push    dx
        mov     ax,cbSize
        dec     ax
        cCall   LocalInit,<dx,0,ax>
        pop     ax
hc_exit:
cEnd

;---------------------------Public-Routine------------------------------;
; HeapDestroy
;
;   Destroys a external heap
;
; Entry:
;       hHeap contains heap handle (ie the selector)
;
; Returns:
;       none
; Error Returns:
;       none
; Registers Preserved:
;       BP,DS,SI,DI
; Registers Destroyed:
;       AX,BX,CX,DX,FLAGS
; Calls:
;       GlobalUnlock, GlobalFree
; History:
;       Fri 21-Sep-1990 13:45:58 -by-  Todd Laney [ToddLa]
;	Created.
;-----------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing

cProc   HeapDestroy, <FAR,PUBLIC>, <>
        ParmW   hHeap
cBegin
        cCall   GlobalUnlock, <hHeap>       ; !!! only need in REAL mode
        cCall   GlobalFree, <hHeap>
cEnd

sEnd

ifndef SEGNAME
    SEGNAME equ <_TEXT>
endif

createSeg %SEGNAME, CodeSeg, word, public, CODE

sBegin  CodeSeg
        assumes cs,CodeSeg
        assumes ds,nothing
        assumes es,nothing

;---------------------------Public-Routine------------------------------;
; HeapAlloc
;
;       allocate memory from a external heap
;
; Entry:
;       hHeap contains heap handle (ie the selector)
;       cbSize contains the requested size of the allocation
;
; Returns:
;       DX:AX = pointer to allocated object
; Error Returns:
;       DX:AX = NULL
; Registers Preserved:
;       BP,DS,SI,DI
; Registers Destroyed:
;       AX,BX,CX,DX,FLAGS
; Calls:
;       LocalAlloc
; History:
;       Fri 21-Sep-1990 13:45:58 -by-  Todd Laney [ToddLa]
;	Created.
;-----------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing

cProc   HeapAlloc, <FAR,PUBLIC>, <ds>
        ParmW   hHeap
        ParmW   cbSize
cBegin
        mov     ds,hHeap
        cCall   LocalAlloc, <LPTR, cbSize>
        xor     dx,dx
        or      ax,ax
        jz      hal_exit
        mov     dx,ds
hal_exit:
cEnd

;---------------------------Public-Routine------------------------------;
; HeapReAlloc
;
;       reallocate memory from a external heap
;
; Entry:
;       lpObject contains the pointer to the object to be reallocated
;       cbSize contains the requested size of the reallocation
;
; Returns:
;       DX:AX = pointer to allocated object
; Error Returns:
;       DX:AX = NULL
; Registers Preserved:
;       BP,DS,SI,DI
; Registers Destroyed:
;       AX,BX,CX,DX,FLAGS
; Calls:
;       LocalAlloc
; History:
;       Wed  8-Jan-1991  1: 2: 3 -by-  David Levine [DavidLe]
;	Created based on HeapAlloc.
;-----------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing

cProc   HeapReAlloc, <FAR,PUBLIC>, <ds>
        ParmD   lpObject
        ParmW   cbSize
cBegin
        lds     ax,lpObject

AllocFlags EQU LMEM_MOVEABLE OR LMEM_ZEROINIT

        cCall   LocalReAlloc, <ax, cbSize, AllocFlags>
        xor     dx,dx
        or      ax,ax
        jz      hral_exit
        mov     dx,ds
hral_exit:
cEnd

;---------------------------Public-Routine------------------------------;
; HeapFree
;
;       free memory from a external heap
;
; Entry:
;       hObject contains the object to free
;
; Returns:
;       none
; Error Returns:
;       none
; Registers Preserved:
;       BP,DS,SI,DI
; Registers Destroyed:
;       AX,BX,CX,DX,FLAGS
; Calls:
;       LocalFree
; History:
;       Fri 21-Sep-1990 13:45:58 -by-  Todd Laney [ToddLa]
;	Created.
;-----------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing

cProc   HeapFree, <FAR,PUBLIC>, <ds>
        ParmD   lpObject
cBegin
        lds     ax,lpObject
        cCall   LocalFree, <ax>
cEnd

sEnd    CodeSeg
	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\mmsystem\mmiocf.c ===
/* cf.c
 *
 * MMIO RIFF compound file functions.
 */

#include <windows.h>
#include "mmsystem.h"
#include "mmiocf.h"
#include "mmioi.h"

/* @doc CFDOC

@api	HMMCF | mmioCFOpen | Open a RIFF compound file by name.

@parm	LPSTR | szFileName | The name of the RIFF compound file.

@parm	DWORD | dwFlags | Zero or more of the following flags:
	MMIO_READ, MMIO_WRITE, MMIO_READWRITE, MMIO_COMPAT, MMIO_EXCLUSIVE,
	MMIO_DENYWRITE, MMIO_DENYREAD, MMIO_DENYNONE, MMIO_CREATE.
	See <f mmioOpen> for a description of these flags.

@rdesc	Returns a handle to the open compound file.  Returns NULL if the
	compound file could not be opened.  If the compound file was already
	opened by this process, a handle to the compound file is returned,
	and the usage count of the compound file is incremented.

@comm	A RIFF compound file is any RIFF file that contains a 'CTOC'
	chunk (compound file table of contents) and a 'CGRP' chunk
	(compound file resource group).  The RIFF compound file format
	is documented separately.

	If the MMIO_CREATE flag is specified, then:

	-- If the compound file is already open, the handle to that compound
	file is returned.

	-- If <p dwFlags> includes MMIO_WRITE, then the compound file will
	actually be opened for both reading and writing, since a compound
	file cannot be opened for writing alone.

	Every call to <f mmioCFOpen> must be matched by a call to
	<f mmioCFClose>.
*/
HMMCF API
mmioCFOpen(LPSTR szFileName, DWORD dwFlags)
{
	/* TO DO */
	return NULL;
}


/* @doc CFDOC

@api	HMMCF | mmioCFAccess | Open a RIFF compound file by reading the
	'CTOC' chunk (compound file table of contents) from a file that
	was opened by <f mmioOpen>.

@parm	HMMIO | hmmio | The open file handle returned by <f mmioOpen>.

@parm	LPMMCFINFO | lpmmcfinfo | Optional information used if
	<p dwFlags> if the compound file is to be created.  <p lpmmcfinfo>
	may be NULL if default information is to be used.
	If <p lpmmcfinfo> is provided, then the following
	fields should be filled in.  Note that all these fields, including
	the arrays, can be coded in a fixed C structure for a specific
	file format, for the purposes of creating a new compound file.
	However, note that if an existing compound file is opened, the
	caller should expect that additional (possibly unknown) "extra
	fields" may be present.

	@flag	dwEntriesTotal | Should contain the initial number of
		(unused) entries in the table of contents (default 16).

	@flag	dwHeaderFlags | Should contain zero.

	@flag	wNameSize | The size of the <p achName> field of each
		CTOC entry (default 13).

	@flag	wExHdrFields | The number of extra header fields to
		allocate at the end of the CTOC header (default 0).

	@flag	wExEntFields | The number of extra entry fields
		at the end of each CTOC entry (default 0).

	@flag	awExHdrFldUsage | Usage codes for extra header fields
		(default no usage code).

	@flag	awExHdrEntUsage | Usage codes for extra entry fields
		(default no usage code).

	@flag	adwExHdrField | Extra header field values
		(default no extra header field values).

@parm	DWORD | dwFlags | Zero or more of the following flags:

	@flag	MMIO_CREATE | Create a compound file, i.e. create
		the 'CTOC' and 'CGRP' chunks.

	@flag	MMIO_CTOCFIRST | Create the empty 'CTOC' chunk
		immediately and place it before the 'CGRP' chunk.
		If the 'CTOC' chunk gets too big, it may later have to
		be rewritten after the 'CGRP' chunk.

		This flag is ignored unless MMIO_CREATE is specified.

@rdesc	Returns a handle to the open compound file.  Returns NULL if the
	compound file could not be opened.

@comm	This function will open a RIFF compound file, assuming that
	<p hmmio> has already been descended into the RIFF file
	(using <f mmioDescend>) and <p hmmio> points to the beginning
	of a chunk header.  <p mmioCFAccess> scans through the file,
	looking for a 'CTOC' and 'CGRP' chunk.  If these chunks are not
	found but MMIO_CREATE is specified, then a 'CTOC' chunk is created
	(if MMIO_CTOCFIRST is specified) then a 'CGRP' chunk is created.
	The CTOC is then maintained in memory until <f mmioCFClose>
	is called.

	Every call to <f mmioCFAccess> must be matched by a call to
	<f mmioCFClose>.
*/
HMMCF API
mmioCFAccess(HMMIO hmmio, LPMMCFINFO lpmmcfinfo, DWORD dwFlags)
{
	/* TO DO */
	return NULL;
}


/* @doc CFDOC

@api	WORD | mmioCFClose | Close a compound file that was opened by
	<f mmioCFOpen> or <f mmioCFAccess>.

@parm	HMMCF | hmmcf | A compound file handle returned by <f mmioCFOpen>
	or <f mmioCFAccess>.

@parm	WORD | wFlags | Is not used and should be set to zero.

@comm	This function decrements the usage count of the compound file
	<p hmmcf>.  If the usage count drops to zero, the compound file
	is closed.  If the compound file was opened by <f mmioCFAccess>,
	then the <p hmmcf> information is deallocated but the HMMIO
	file handle associated with the compound file is not closed.
*/
WORD API
mmioCFClose(HMMCF hmmcf, WORD wFlags)
{
	/* TO DO */
	return 0;
}


/* @doc CFDOC

@api	WORD | mmioCFCopy | Copy the 'CTOC' and 'CGRP' chunks from an open
	RIFF compound file to another file.  The newly written 'CGRP' chunk
	will be compacted, i.e. it will have no deleted elements.

@parm	HMMCF | hmmcf | A compound file handle returned by <f mmioCFOpen>
	or <f mmioCFAccess>.

@parm	HMMIO | hmmio | An open file handle returned by <f mmioOpen>.
	The compound file is copied to <p hmmio>.

@parm	DWORD | dwFlags | Is not used and should be set to zero.

@rdesc	If the function succeeds, zero is returned.  If the function fails,
	an error code is returned.

@comm	<f mmioCFCopy> assumes that the current file position of <p hmmio> 
	is the end of a file, descended into a 'RIFF' chunk.  <f mmioCFCopy>
	creates copies the 'CTOC' and 'CGRP' chunks from <p hmmcf> to
	<p hmmio>.  A side effect of the copy operation is that the
	copy of the compound file is compacted, i.e. there are no deleted
	elements.
*/
WORD API
mmioCFCopy(HMMCF hmmcf, HMMIO hmmio, DWORD dwFlags)
{
	/* TO DO */
	return 0;
}


/* @doc CFDOC

@api	DWORD | mmioCFGetInfo | Retrieve information from the CTOC header
	of an open RIFF compound file.

@parm	HMMCF | hmmcf | A compound file handle returned by <f mmioCFOpen>
	or <f mmioCFAccess>.

@parm	LPMMCFINFO | lpmmcfinfo | A caller-supplied buffer that will be
	filled in with the CTOC header.

@parm	DWORD | cb | The size of buffer <p lpmmcfinfo>.  At most <p cb> 
	bytes will be copied into <p lpmmcfinfo>.

@rdesc	Returns the number of bytes copied into <p lpmmcfinfo>.

@comm	The information that is copied to <p lpmmcfinfo> consists of
	an MMCFINFO structure followed by the variable-length arrays
	<p awExHdrFldUsage>, <p awExEntFldUsage>, and <p adwExHdrField>.
	See the definition of RIFF Compound Files for more information.

	To find out how big the RIFF CTOC header is (e.g. to allocate
	enough memory for the entire block), call <f mmioCFGetInfo>
	with <p cb> equal to the size of a DWORD, and the function will
	copy the first field of the MMCFINFO structure (i.e.
	<p dwHeaderSize>, the size of the CTOC header) into <p lpmmcfinfo>.
*/
DWORD API
mmioCFGetInfo(HMMCF hmmcf, LPMMCFINFO lpmmcfinfo, DWORD cb)
{
	DWORD		dwBytes;

	dwBytes = min(cb, PC(hmmcf)->pHeader->dwHeaderSize);
        MemCopy(lpmmcfinfo, PC(hmmcf)->pHeader, dwBytes);
	return dwBytes;
}


/* @doc CFDOC

@api	DWORD | mmioCFSetInfo | Modify information that is stored in the
	CTOC header of an open RIFF compound file.

@parm	HMMCF | hmmcf | A compound file handle returned by <f mmioCFOpen>
	or <f mmioCFAccess>.

@parm	LPMMCFINFO | lpmmcfinfo | A caller-supplied buffer that was filled
	in by <f mmioCFGetInfo> and then modified by the caller.  Only
	the <p awExHdrFldUsage> and <p adwExHdrField> fields should be
	modified.

@parm	DWORD | cb | The size of buffer <p lpmmcfinfo>.

@rdesc	Returns the number of bytes copied from <p lpmmcfinfo>.

@comm	See <f mmioCFGetInfo> for more information.
*/
DWORD API
mmioCFSetInfo(HMMCF hmmcf, LPMMCFINFO lpmmcfinfo, DWORD cb)
{
	/* TO DO:
	 * Re-allocate CTOC header if necessary and copy <p lpmmcfinfo> to it.
	 */

	return 0L;
}


/* @doc CFDOC

@api	LPMMCTOCENTRY | mmioCFFindEntry | Find an particular entry in an open
	RIFF compound file.

@parm	HMMCF | hmmcf | A compound file handle returned by <f mmioCFOpen>
	or <f mmioCFAccess>.

@parm	LPSTR | szName | Then name of the compound file element to look for.
	The search is case-insensitive.  Flags in <p wFlags> can be set to
	specify that an element is to be searched for by some attribute other
	than name.

@parm	WORD | wFlags | Zero or more of the following flags:

	@flag	MMIO_FINDFIRST | Find the first entry in the CTOC table.

	@flag	MMIO_FINDNEXT | Find the next entry in the CTOC table
		after the entry <p lParam> (which should be an
		LPMMCTOCENTRY pointer returned by this function).
		Returns NULL if <p lParam> refers to the last entry.

	@flag	MMIO_FINDUNUSED | Find the first entry in the CTOC table
		that is marked as "unused", i.e. the entry does not refer
		to any part of the compound file.

	@flag	MMIO_FINDDELETED | Find the first entry in the CTOC table
		that is marked as "deleted", i.e. the entry refers to a
		compound file element that occupies space in the CGRP
		chunk but is currently unused.

@parm	LPARAM | lParam | Additional information (see <p wFlags> above).

@rdesc	Returns a pointer to the CTOC table entry that was found.
	If no entry was found, NULL is returned.  Warning: assume that
	the returned pointer is invalid after the next call to any MMIO
	function.

@comm	MMIO_FINDFIRST and MMIO_FINDNEXT can be used to enumerate the entries
	in an open RIFF compound file.
*/
LPMMCTOCENTRY API
mmioCFFindEntry(HMMCF hmmcf, LPSTR szName, WORD wFlags, LPARAM lParam)
{
	LPSTR		pchEntry;
	DWORD		dwElemNum;

	if (wFlags & MMIO_FINDFIRST)
		return (LPMMCTOCENTRY) PC(hmmcf)->pEntries;

	if (wFlags & MMIO_FINDNEXT)
	{
		pchEntry = (LPSTR) lParam + PC(hmmcf)->wEntrySize;
		if (pchEntry > PC(hmmcf)->pEntries
			  + PC(hmmcf)->pHeader->dwEntriesTotal * PC(hmmcf)->wEntrySize)
			return NULL;
		else
			return (LPMMCTOCENTRY) pchEntry;
	}

	for (pchEntry = PC(hmmcf)->pEntries, dwElemNum = 0;
	     dwElemNum < PC(hmmcf)->pHeader->dwEntriesTotal;
	     pchEntry += PC(hmmcf)->wEntrySize, dwElemNum++)
	{
		BYTE		bFlags;

		bFlags = *(BYTE FAR *) (pchEntry + PC(hmmcf)->wEntFlagsOffset);

		if ((wFlags & MMIO_FINDUNUSED) && (bFlags & CTOC_EF_UNUSED))
			return (LPMMCTOCENTRY) pchEntry;

		if ((wFlags & MMIO_FINDDELETED) && (bFlags & CTOC_EF_DELETED))
			return (LPMMCTOCENTRY) pchEntry;

		if (bFlags & (CTOC_EF_DELETED | CTOC_EF_UNUSED))
			continue;

		if (lstrcmpi(szName, pchEntry + PC(hmmcf)->wEntNameOffset) == 0)
			return (LPMMCTOCENTRY) pchEntry;
	}

	return NULL;
}


/* @doc INTERNAL

@api	LRESULT | mmioBNDIOProc | The 'BND' I/O procedure, which handles I/O
	on RIFF compound file elements (including BND files).

@parm	LPSTR | lpmmioinfo | A pointer to an MMIOINFO block that
	contains information about the open file.

@parm	WORD | wMsg | The message that the I/O procedure is being
	asked to execute.

@parm	LPARAM | lParam1 | Specifies additional message information.

@parm	LPARAM | lParam2 | Specifies additional message information.

@rdesc	Return value depends on <p wMsg>.
*/
LRESULT CALLBACK
mmioBNDIOProc(LPSTR lpmmioStr, WORD wMsg, LPARAM lParam1, LPARAM lParam2)
{
	PMMIO		pmmio = (PMMIO) (WORD) (LONG) lpmmioStr; // only in DLL!
	MMIOBNDINFO *	pInfo = (MMIOBNDINFO *) pmmio->adwInfo;
	LPSTR		szFileName = (LPSTR) lParam1;
	PMMCF		pmmcf = PC(pInfo->hmmcf); // CF status block
	LPSTR		szElemName;	// name of CF element
	LONG		lBytesLeft;	// bytes left in file
	LONG		lExpand;	// how much element expanded by
	LONG		lEndElement;	// offset of end of element
	LONG		lResult;
	LPSTR		pch;

	switch (wMsg)
	{

	case MMIOM_OPEN:

		if (pmmcf == NULL)
		{

			/* expect <lParam1> is "...foo.bnd!element" */
			if ((pch = fstrrchr(szFileName, CFSEPCHAR)) == NULL)
				return (LRESULT) MMIOERR_CANNOTOPEN;

			*pch = 0;		// temporarily zero the "!"
			if (pch[1] == 0)	// is name of form "foo.bnd!"?
				return (LRESULT) MMIOERR_CANNOTOPEN;
			pInfo->hmmcf = mmioCFOpen(szFileName, (LONG) lParam2);
			pmmcf = (PMMCF) pInfo->hmmcf;
			*pch = CFSEPCHAR;
			if (pInfo->hmmcf == NULL)
				return (LRESULT) MMIOERR_CANNOTOPEN;
			szElemName = pch + 1;

			/* decrement the usage count, since the usage count
			 * was incremented by mmioCFOpen() and will
			 * be incremented below, but this MMIOM_OPEN
			 * represents only a single usage
			 */
			pmmcf->lUsage--;
		}
		else
		{
			/* expect <lParam1> is CF element name */
			szElemName = szFileName;
		}

		/* TO DO...
		 * If compound file is opened for writing or create(truncate),
		 * then make new entry at end (copying entry if required);
		 */

		/* <pmmcf> is a handle to the compound file containing
		 * the element, and <szElemName> is the name of the element
		 */
		if ((pInfo->pEntry = mmioCFFindEntry(pInfo->hmmcf,
				szElemName, 0, 0L)) == NULL)
		{
			mmioCFClose(pInfo->hmmcf, 0);
			return (LRESULT) MMIOERR_CANNOTOPEN;
		}

		if (pmmio->dwFlags & MMIO_DELETE)
		{
			/* TO DO: delete element: mark as deleted, update
			 * CTOC header, etc.
			 */
		}

		if (pmmio->dwFlags & (MMIO_PARSE | MMIO_EXIST))
		{
			/* TO DO: qualify name
			 */
		}

		return (LRESULT) 0;

	case MMIOM_CLOSE:

		mmioCFClose(pInfo->hmmcf, 0);
		return (LRESULT) 0;

	case MMIOM_READ:

		lBytesLeft = pInfo->pEntry->dwSize - pmmio->lDiskOffset;
		if ((LONG) lParam2 > lBytesLeft)
			(LONG) lParam2 = lBytesLeft;
		if (mmioSeek(pmmcf->hmmio, pmmio->lDiskOffset, SEEK_SET) == -1L)
			return (LRESULT) -1L;
		if ((lResult = mmioRead(pmmcf->hmmio,
				        (HPSTR) lParam1, (LONG) lParam2)) == -1L)
			return (LRESULT) -1L;
		pmmio->lDiskOffset += lResult;
		return (LRESULT) lResult;

	case MMIOM_WRITE:
	case MMIOM_WRITEFLUSH:		/* Note: flush not really handled! */

		lEndElement = pmmcf->lStartCGRPData + pInfo->pEntry->dwOffset
			+ pInfo->pEntry->dwSize;
		if ((lEndElement != pmmcf->lEndCGRP) ||
		    (pmmcf->lEndCGRP != pmmcf->lEndFile))
		{
			/* this CF element is not growable -- limit writing
			 * to the current end of the CF element
			 */
			lBytesLeft = pInfo->pEntry->dwSize - pmmio->lDiskOffset;
			if ((LONG) lParam2 > lBytesLeft)
				(LONG) lParam2 = lBytesLeft;
		}
		if ((lResult = mmioWrite(pmmcf->hmmio,
				         (HPSTR) lParam1, (LONG) lParam2)) == -1L)
			return (LRESULT) -1L;
		pmmio->lDiskOffset += lResult;

		if ((lExpand = pmmio->lDiskOffset - pInfo->pEntry->dwSize) > 0)
		{
			pInfo->pEntry->dwSize += lExpand;
			pmmcf->lEndCGRP += lExpand;
			pmmcf->lEndFile += lExpand;
			pmmcf->lTotalExpand += lExpand;
		}

		return (LRESULT) lResult;

	case MMIOM_SEEK:

		/* calculate the new <lDiskOffset> (the current disk offset
		 * relative to the beginning of the compound file); don't
		 * bother seeking, since we'll have to seek again anyway
		 * at the next read (since <pmmcf->hmmio> is shared between
		 * all elements of the compound file)
		 */
		switch ((int)(LONG) lParam2)
		{

		case SEEK_SET:

			pmmio->lDiskOffset = pmmcf->lStartCGRPData
				+ pInfo->pEntry->dwOffset + (DWORD)lParam1;
			break;

		case SEEK_CUR:

			pmmio->lDiskOffset += lParam1;
			break;

		case SEEK_END:

			pmmio->lDiskOffset = pmmcf->lStartCGRPData +
				+ pInfo->pEntry->dwOffset
				+ pInfo->pEntry->dwSize - (DWORD)lParam1;
			break;
		}

		return (LRESULT) pmmio->lDiskOffset;

	case MMIOM_GETCF:

		return (LRESULT)(LONG)(WORD) pInfo->hmmcf;

	case MMIOM_GETCFENTRY:

		return (LRESULT) pInfo->pEntry;
	}

	return (LRESULT) 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\mmsystem\midi.c ===
/*****************************************************************************
    midi.c

    Level 1 kitchen sink DLL midi support module

    Copyright (c) Microsoft Corporation 1990. All rights reserved

*****************************************************************************/
#include <windows.h>
#include "mmsystem.h"
#include "mmddk.h"
#include "mmsysi.h"
#include "thunks.h"

/* -------------------------------------------------------------------------
** Local functions
** -------------------------------------------------------------------------
*/
static UINT NEAR PASCAL
midiGetErrorText(
    UINT wError,
    LPSTR lpText,
    UINT wSize
    );

/* -------------------------------------------------------------------------
** Local structures
** -------------------------------------------------------------------------
*/
typedef struct mididev_tag {
    PMIDIDRV    mididrv;
    UINT        wDevice;
    DWORD       dwDrvUser;
    UINT        wDeviceID;
} MIDIDEV;
typedef MIDIDEV *PMIDIDEV;


/* -------------------------------------------------------------------------
** Segmentation
**
**  Define the fixed code for this file.
** -------------------------------------------------------------------------
*/
#pragma alloc_text( FIX, midiIMessage)
#pragma alloc_text( FIX, midiOMessage)
#pragma alloc_text( FIX, midiOutMessage)
#pragma alloc_text( FIX, midiOutShortMsg)
#pragma alloc_text( FIX, midiOutLongMsg)
#pragma alloc_text( FIX, midiOutReset)

/* -------------------------------------------------------------------------
** Global data
** -------------------------------------------------------------------------
*/
static  int     iMidiLockCount = 0;


/*****************************************************************************
 * @doc INTERNAL  MIDI
 *
 * @api void | midiLockData |
 *
 *      This function is called every time a new MIDI handle is created, it
 *      makes sure MMSYSTEM's data segment is page-locked.  MIDI handles
 *      are useable at interupt time so we must page-lock the data seg.
 *
 *      in the future we should re-do the MIDI system.
 *
 ****************************************************************************/
BOOL NEAR PASCAL
midiLockData(
    void
    )
{
    if (iMidiLockCount == 0) {

        DOUT("MMSYSTEM: Locking data segment\r\n");

        if ( !GlobalPageLock((HGLOBAL)HIWORD((DWORD)(LPVOID)&iMidiLockCount))
          && (WinFlags & WF_ENHANCED)) {

            return 0;
        }
    }

    return ++iMidiLockCount;
}

/*****************************************************************************
 * @doc INTERNAL  MIDI
 *
 * @api void | midiUnlockData |
 *
 *      This function is called every time a MIDI handle is closed, it
 *      makes sure MMSYSTEM's data segment is un-page-locked.  MIDI handles
 *      are useable at interupt time so we must page-lock the data seg.
 *
 *      in the future we should re-do the MIDI system.
 *
 ****************************************************************************/
void NEAR PASCAL
midiUnlockData(
    void
    )
{

#ifdef DEBUG
    if (iMidiLockCount == 0)
        DOUT("MMSYSTEM: midiUnlockData() underflow!!!!\r\n");
#endif

    if (--iMidiLockCount == 0) {

        DOUT("MMSYSTEM: Unlocking data segment\r\n");
        GlobalPageUnlock((HGLOBAL)HIWORD((DWORD)(LPVOID)&iMidiLockCount));
    }
}

/*****************************************************************************
 * @doc INTERNAL  MIDI
 *
 * @api UINT | midiPrepareHeader | This function prepares the header and data
 *   if the driver returns MMSYSERR_NOTSUPPORTED.
 *
 * @rdesc Currently always returns MMSYSERR_NOERROR.
 ****************************************************************************/
static UINT NEAR PASCAL
midiPrepareHeader(
    LPMIDIHDR lpMidiHdr,
    UINT wSize
    )
{
    if (!HugePageLock(lpMidiHdr, (DWORD)sizeof(MIDIHDR)))
        return MMSYSERR_NOMEM;

    if (!HugePageLock(lpMidiHdr->lpData, lpMidiHdr->dwBufferLength)) {
        HugePageUnlock(lpMidiHdr, (DWORD)sizeof(MIDIHDR));
        return MMSYSERR_NOMEM;
    }

//  lpMidiHdr->dwFlags |= MHDR_PREPARED;

    return MMSYSERR_NOERROR;
}

/*****************************************************************************
 * @doc INTERNAL  MIDI
 *
 * @api UINT | midiUnprepareHeader | This function unprepares the header and
 *   data if the driver returns MMSYSERR_NOTSUPPORTED.
 *
 * @rdesc Currently always returns MMSYSERR_NOERROR.
 ****************************************************************************/
static UINT NEAR PASCAL
midiUnprepareHeader(
    LPMIDIHDR lpMidiHdr,
    UINT wSize
    )
{
    HugePageUnlock(lpMidiHdr->lpData, lpMidiHdr->dwBufferLength);
    HugePageUnlock(lpMidiHdr, (DWORD)sizeof(MIDIHDR));

//  lpMidiHdr->dwFlags &= ~MHDR_PREPARED;

    return MMSYSERR_NOERROR;
}



/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api UINT | midiOutGetNumDevs | This function retrieves the number of MIDI
 *   output devices present in the system.
 *
 * @rdesc Returns the number of MIDI output devices present in the system.
 *
 * @xref midiOutGetDevCaps
 ****************************************************************************/
UINT WINAPI midiOutGetNumDevs(void)
{
    return midiOIDMessage( 0, MODM_GETNUMDEVS, 0L, 0L, 0L );
}

/****************************************************************************
 * @doc EXTERNAL MIDI
 *
 * @api DWORD | midiOutMessage | This function sends messages to the MIDI device
 *   drivers.
 *
 * @parm HMIDIOUT | hMidiOut | The handle to the MIDI device.
 *
 * @parm UINT  | msg | The message to send.
 *
 * @parm DWORD | dw1 | Parameter 1.
 *
 * @parm DWORD | dw2 | Parameter 2.
 *
 * @rdesc Returns the value of the message sent.
 ***************************************************************************/
DWORD WINAPI midiOutMessage(HMIDIOUT hMidiOut, UINT msg, DWORD dw1, DWORD dw2)
{
    V_HANDLE(hMidiOut, TYPE_MIDIOUT, 0L);

    return midiOMessage( (HMIDI)hMidiOut, msg, dw1, dw2);
}

/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api UINT | midiOutGetDevCaps | This function queries a specified
 *   MIDI output device to determine its capabilities.
 *
 * @parm UINT | wDeviceID | Identifies the MIDI output device.
 *
 * @parm LPMIDIOUTCAPS | lpCaps | Specifies a far pointer to a <t MIDIOUTCAPS>
 *   structure.  This structure is filled with information about the
 *   capabilities of the device.
 *
 * @parm UINT | wSize | Specifies the size of the <t MIDIOUTCAPS> structure.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_BADDEVICEID | Specified device ID is out of range.
 *   @flag MMSYSERR_NODRIVER | The driver was not installed.
 *   @flag MMSYSERR_NOMEM | Unable load mapper string description.
 *
 * @comm Use <f midiOutGetNumDevs> to determine the number of MIDI output
 *   devices present in the system.  The device ID specified by <p wDeviceID>
 *   varies from zero to one less than the number of devices present.
 *   The MIDI_MAPPER constant may also be used as a device id. Only
 *   <p wSize> bytes (or less) of information is copied to the location
 *   pointed to by <p lpCaps>.  If <p wSize> is zero, nothing is copied,
 *   and the function returns zero.
 *
 * @xref midiOutGetNumDevs
 ****************************************************************************/
UINT WINAPI
midiOutGetDevCaps(
    UINT wDeviceID,
    LPMIDIOUTCAPS lpCaps,
    UINT wSize
    )
{
    if (wSize == 0) {
        return MMSYSERR_NOERROR;
    }

    V_WPOINTER(lpCaps, wSize, MMSYSERR_INVALPARAM);

    if (ValidateHandle((HMIDIOUT)wDeviceID, TYPE_MIDIOUT)) {
       return((UINT)midiOMessage((HMIDI)wDeviceID,
                                 MODM_GETDEVCAPS,
                                 (DWORD)lpCaps,
                                 (DWORD)wSize));
    }

    return midiOIDMessage( wDeviceID,
                          MODM_GETDEVCAPS, 0L, (DWORD)lpCaps, (DWORD)wSize);
}

/*****************************************************************************
 * @doc EXTERNAL MIDI
 *
 * @api UINT | midiOutGetVolume | This function returns the current volume
 *   setting of a MIDI output device.
 *
 * @parm UINT | wDeviceID | Identifies the MIDI output device.
 *
 * @parm LPDWORD | lpdwVolume | Specifies a far pointer to a location
 *   to be filled with the current volume setting. The low-order word of
 *   this location contains the left channel volume setting, and the high-order
 *   WORD contains the right channel setting. A value of 0xFFFF represents
 *   full volume, and a value of 0x0000 is silence.
 *
 *   If a device does not support both left and right volume
 *   control, the low-order word of the specified location contains
 *   the mono volume level.
 *
 *   The full 16-bit setting(s)
 *   set with <f midiOutSetVolume> is returned, regardless of whether
 *   the device supports the full 16 bits of volume level control.
 *
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MMSYSERR_NOTSUPPORTED | Function isn't supported.
 *   @flag MMSYSERR_NODRIVER | The driver was not installed.
 *
 * @comm Not all devices support volume control. To determine whether the
 *   device supports volume control, use the MIDICAPS_VOLUME
 *   flag to test the <e MIDIOUTCAPS.dwSupport> field of the <t MIDIOUTCAPS>
 *   structure (filled by <f midiOutGetDevCaps>).
 *
 *   To determine whether the device supports volume control on both the
 *   left and right channels, use the MIDICAPS_LRVOLUME flag to test
 *   the <e MIDIOUTCAPS.dwSupport> field of the <t MIDIOUTCAPS>
 *   structure (filled by <f midiOutGetDevCaps>).
 *
 * @xref midiOutSetVolume
 ****************************************************************************/
UINT WINAPI
midiOutGetVolume(
    UINT wDeviceID,
    LPDWORD lpdwVolume
    )
{
    V_WPOINTER(lpdwVolume, sizeof(DWORD), MMSYSERR_INVALPARAM);

    if (ValidateHandle((HMIDIOUT)wDeviceID, TYPE_MIDIOUT)) {
       return((UINT)midiOMessage((HMIDI)wDeviceID,
                                 MODM_GETVOLUME,
                                 (DWORD)lpdwVolume,
                                 0));
    }

    return midiOIDMessage( wDeviceID, MODM_GETVOLUME, 0L, (DWORD)lpdwVolume, 0 );
}

/*****************************************************************************
 * @doc EXTERNAL MIDI
 *
 * @api UINT | midiOutSetVolume | This function sets the volume of a
 *      MIDI output device.
 *
 * @parm UINT | wDeviceID | Identifies the MIDI output device.
 *
 * @parm DWORD | dwVolume | Specifies the new volume setting.
 *   The low-order word contains the left channel volume setting, and the
 *   high-order word contains the right channel setting. A value of
 *   0xFFFF represents full volume, and a value of 0x0000 is silence.
 *
 *   If a device does not support both left and right volume
 *   control, the low-order word of <p dwVolume> specifies the volume
 *   level, and the high-order word is ignored.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MMSYSERR_NOTSUPPORTED | Function isn't supported.
 *   @flag MMSYSERR_NODRIVER | The driver was not installed.
 *
 * @comm Not all devices support volume changes. To determine whether the
 *   device supports volume control, use the MIDICAPS_VOLUME
 *   flag to test the <e MIDIOUTCAPS.dwSupport> field of the <t MIDIOUTCAPS>
 *   structure (filled by <f midiOutGetDevCaps>).
 *
 *   To determine whether the device supports volume control on both the
 *   left and right channels, use the MIDICAPS_LRVOLUME flag to test
 *   the <e MIDIOUTCAPS.dwSupport> field of the <t MIDIOUTCAPS>
 *   structure (filled by <f midiOutGetDevCaps>).
 *
 *   Most devices do not support the full 16 bits of volume level control
 *   and will use only the high-order bits of the requested volume setting.
 *   For example, for a device that supports 4 bits of volume control,
 *   requested volume level values of 0x4000, 0x4fff, and 0x43be will
 *   all produce the same physical volume setting, 0x4000. The
 *   <f midiOutGetVolume> function will return the full 16-bit setting set
 *   with <f midiOutSetVolume>.
 *
 *   Volume settings are interpreted logarithmically. This means the
 *   perceived increase in volume is the same when increasing the
 *   volume level from 0x5000 to 0x6000 as it is from 0x4000 to 0x5000.
 *
 * @xref midiOutGetVolume
 ****************************************************************************/
UINT WINAPI
midiOutSetVolume(
    UINT wDeviceID,
    DWORD dwVolume
    )
{
    if (ValidateHandle((HMIDIOUT)wDeviceID, TYPE_MIDIOUT)) {
       return((UINT)midiOMessage((HMIDI)wDeviceID,
                                 MODM_SETVOLUME,
                                 dwVolume,
                                 0));
    }

    return midiOIDMessage( wDeviceID, MODM_SETVOLUME, 0L, dwVolume, 0);
}

/*****************************************************************************
 * @doc INTERNAL MIDI
 *
 * @func UINT | midiGetErrorText | This function retrieves a textual
 *   description of the error identified by the specified error number.
 *
 * @parm UINT | wError | Specifies the error number.
 *
 * @parm LPSTR | lpText | Specifies a far pointer to a buffer which
 *   is filled with the textual error description.
 *
 * @parm UINT | wSize | Specifies the length of the buffer pointed to by
 *   <p lpText>.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_BADERRNUM | Specified error number is out of range.
 *
 * @comm If the textual error description is longer than the specified buffer,
 *   the description is truncated.  The returned error string is always
 *   null-terminated. If <p wSize> is zero, nothing is copied and MMSYSERR_NOERROR
 *   is returned.
 ****************************************************************************/
static UINT NEAR PASCAL
midiGetErrorText(
    UINT wError,
    LPSTR lpText,
    UINT wSize
    )
{
    lpText[0] = 0;

#if MMSYSERR_BASE
    if ( ((wError < MMSYSERR_BASE) || (wError > MMSYSERR_LASTERROR))
      && ((wError < MIDIERR_BASE) || (wError > MIDIERR_LASTERROR))) {

        return MMSYSERR_BADERRNUM;
    }
#else
    if ((wError > MMSYSERR_LASTERROR) && ((wError < MIDIERR_BASE)
     || (wError > MIDIERR_LASTERROR))) {

        return MMSYSERR_BADERRNUM;
    }
#endif

    if (wSize > 1) {

        if (!LoadString(ghInst, wError, lpText, wSize)) {
            return MMSYSERR_BADERRNUM;
        }
    }

    return MMSYSERR_NOERROR;
}

/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api UINT | midiOutGetErrorText | This function retrieves a textual
 *   description of the error identified by the specified error number.
 *
 * @parm UINT | wError | Specifies the error number.
 *
 * @parm LPSTR | lpText | Specifies a far pointer to a buffer to be
 *   filled with the textual error description.
 *
 * @parm UINT | wSize | Specifies the length of the buffer pointed to by
 *   <p lpText>.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_BADERRNUM | Specified error number is out of range.
 *
 * @comm If the textual error description is longer than the specified buffer,
 *   the description is truncated.  The returned error string is always
 *   null-terminated. If <p wSize> is zero, nothing is copied, and the
 *   function returns MMSYSERR_NOERROR.  All error descriptions are
 *   less than MAXERRORLENGTH characters long.
 ****************************************************************************/
UINT WINAPI
midiOutGetErrorText(
    UINT wError,
    LPSTR lpText,
    UINT wSize
    )
{
    if(wSize == 0) {
        return MMSYSERR_NOERROR;
    }

    V_WPOINTER(lpText, wSize, MMSYSERR_INVALPARAM);

    return midiGetErrorText(wError, lpText, wSize);
}

/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api UINT | midiOutOpen | This function opens a specified MIDI
 *   output device for playback.
 *
 * @parm LPHMIDIOUT | lphMidiOut | Specifies a far pointer to an HMIDIOUT
 *   handle.  This location is filled with a handle identifying the opened
 *   MIDI output device.  Use the handle to identify the device when calling
 *   other MIDI output functions.
 *
 * @parm UINT | wDeviceID | Identifies the MIDI output device that is
 *   to be opened.
 *
 * @parm DWORD | dwCallback | Specifies the address of a fixed callback
 *   function or
 *   a handle to a window called during MIDI playback to process
 *   messages related to the progress of the playback.  Specify NULL
 *   for this parameter if no callback is desired.
 *
 * @parm DWORD | dwCallbackInstance | Specifies user instance data
 *   passed to the callback.  This parameter is not used with
 *   window callbacks.
 *
 * @parm DWORD | dwFlags | Specifies a callback flag for opening the device.
 *   @flag CALLBACK_WINDOW | If this flag is specified, <p dwCallback> is
 *      assumed to be a window handle.
 *   @flag CALLBACK_FUNCTION | If this flag is specified, <p dwCallback> is
 *      assumed to be a callback procedure address.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are as follows:
 *   @flag MMSYSERR_BADDEVICEID | Specified device ID is out of range.
 *   @flag MMSYSERR_ALLOCATED | Specified resource is already allocated.
 *   @flag MMSYSERR_NOMEM | Unable to allocate or lock memory.
 *   @flag MIDIERR_NOMAP | There is no current MIDI map. This occurs only
 *   when opening the mapper.
 *   @flag MIDIERR_NODEVICE | A port in the current MIDI map doesn't exist.
 *   This occurs only when opening the mapper.
 *
 * @comm Use <f midiOutGetNumDevs> to determine the number of MIDI output
 *   devices present in the system.  The device ID specified by <p wDeviceID>
 *   varies from zero to one less than the number of devices present.
 *   You may also specify MIDI_MAPPER as the device ID to open the MIDI mapper.
 *
 *   If a window is chosen to receive callback information, the following
 *   messages are sent to the window procedure function to indicate the
 *   progress of MIDI output:  <m MM_MOM_OPEN>, <m MM_MOM_CLOSE>,
 *   <m MM_MOM_DONE>.
 *
 *   If a function is chosen to receive callback information, the following
 *   messages are sent to the function to indicate the progress of MIDI
 *   output: <m MOM_OPEN>, <m MOM_CLOSE>, <m MOM_DONE>.  The callback function
 *   must reside in a DLL.  You do not have to use <f MakeProcInstance> to
 *   get a procedure-instance address for the callback function.
 *
 * @cb void CALLBACK | MidiOutFunc | <f MidiOutFunc> is a placeholder for
 *   the application-supplied function name.  The actual name must be
 *   exported by including it in an EXPORTS statement in the DLL's
 *   module-definition file.
 *
 * @parm HMIDIOUT | hMidiOut | Specifies a handle to the MIDI device
 *   associated with the callback.
 *
 * @parm UINT | wMsg | Specifies a MIDI output message.
 *
 * @parm DWORD | dwInstance | Specifies the instance data
 *   supplied with <f midiOutOpen>.
 *
 * @parm DWORD | dwParam1 | Specifies a parameter for the message.
 *
 * @parm DWORD | dwParam2 | Specifies a parameter for the message.
 *
 * @comm Because the callback is accessed at interrupt time, it must reside
 *   in a DLL and its code segment must be specified as FIXED in the
 *   module-definition file for the DLL.  Any data that the callback accesses
 *   must be in a FIXED data segment as well. The callback may not make any
 *   system calls except for <f PostMessage>, <f timeGetSystemTime>,
 *   <f timeGetTime>, <f timeSetEvent>, <f timeKillEvent>,
 *   <f midiOutShortMsg>, <f midiOutLongMsg>, and <f OutputDebugStr>.
 *
 * @xref midiOutClose
 ****************************************************************************/
UINT WINAPI
midiOutOpen(
    LPHMIDIOUT lphMidiOut,
    UINT wDeviceID,
    DWORD dwCallback,
    DWORD dwInstance,
    DWORD dwFlags
    )
{
    MIDIOPENDESC mo;
    PMIDIDEV     pdev;
    UINT         wRet;

    V_WPOINTER(lphMidiOut, sizeof(HMIDIOUT), MMSYSERR_INVALPARAM);
    V_DCALLBACK(dwCallback, HIWORD(dwFlags), MMSYSERR_INVALPARAM);
    V_FLAGS(LOWORD(dwFlags), 0, midiOutOpen, MMSYSERR_INVALFLAG);

    /*
    ** Check for no devices
    */
//  if (wTotalMidiOutDevs == 0 ) {
//      return MMSYSERR_BADDEVICEID;
//  }
//
//  /*
//  ** check for device ID being to large
//  */
//  if ( wDeviceID != MIDI_MAPPER ) {
//      if ( wDeviceID >= wTotalMidiOutDevs ) {
//          return MMSYSERR_BADDEVICEID;
//      }
//  }

    *lphMidiOut = NULL;

    if (!midiLockData()) {
        return MMSYSERR_NOMEM;
    }

    pdev = (PMIDIDEV)NewHandle(TYPE_MIDIOUT, sizeof(MIDIDEV));
    if( pdev == NULL) {
        return MMSYSERR_NOMEM;
    }

    pdev->wDevice = wDeviceID;
    pdev->wDeviceID = wDeviceID;

    mo.hMidi      = (HMIDI)pdev;
    mo.dwCallback = dwCallback;
    mo.dwInstance = dwInstance;

    wRet = midiOIDMessage( wDeviceID, MODM_OPEN,
                          (DWORD)(LPDWORD)&pdev->dwDrvUser,
                          (DWORD)(LPMIDIOPENDESC)&mo, dwFlags );

    if (wRet) {
        FreeHandle((HMIDIOUT)pdev);
        midiUnlockData();
    } else {
        *lphMidiOut = (HMIDIOUT)pdev;
    }

    return wRet;
}

/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api UINT | midiOutClose | This function closes the specified MIDI
 *   output device.
 *
 * @parm HMIDIOUT | hMidiOut | Specifies a handle to the MIDI output device.
 *  If the function is successful, the handle is no longer
 *   valid after this call.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MIDIERR_STILLPLAYING | There are still buffers in the queue.
 *
 * @comm If there are output buffers that have been sent with
 *   <f midiOutLongMsg> and haven't been returned to the application,
 *   the close operation will fail.  Call <f midiOutReset> to mark all
 *   pending buffers as being done.
 *
 * @xref midiOutOpen midiOutReset
 ****************************************************************************/
UINT WINAPI
midiOutClose(
    HMIDIOUT hMidiOut
    )
{
    UINT         wRet;

    V_HANDLE(hMidiOut, TYPE_MIDIOUT, MMSYSERR_INVALHANDLE);

    wRet = (UINT)midiOMessage( (HMIDI)hMidiOut, MODM_CLOSE, 0L,0L);
    if (!wRet) {
        FreeHandle(hMidiOut);
        midiUnlockData();
    }
    return wRet;
}

/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api UINT | midiOutPrepareHeader | This function prepares a MIDI
 *   system-exclusive data block for output.
 *
 * @parm HMIDIOUT | hMidiOut | Specifies a handle to the MIDI output
 *   device.
 *
 * @parm LPMIDIHDR | lpMidiOutHdr | Specifies a far pointer to a <t MIDIHDR>
 *   structure that identifies the data block to be prepared.
 *
 * @parm UINT | wSize | Specifies the size of the <t MIDIHDR> structure.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MMSYSERR_NOMEM | Unable to allocate or lock memory.
 *
 * @comm The <t MIDIHDR> data structure and the data block pointed to by its
 *   <e MIDIHDR.lpData> field must be allocated with <f GlobalAlloc> using the
 *   GMEM_MOVEABLE and GMEM_SHARE flags and locked with <f GlobalLock>.
 *   Preparing a header that has already been prepared has no effect, and
 *   the function returns zero.
 *
 * @xref midiOutUnprepareHeader
 ****************************************************************************/
UINT WINAPI
midiOutPrepareHeader(
    HMIDIOUT hMidiOut,
    LPMIDIHDR lpMidiOutHdr,
    UINT wSize
    )
{
    UINT         wRet;

    V_HANDLE(hMidiOut, TYPE_MIDIOUT, MMSYSERR_INVALHANDLE);
    V_HEADER(lpMidiOutHdr, wSize, TYPE_MIDIOUT, MMSYSERR_INVALPARAM);

    if (lpMidiOutHdr->dwFlags & MHDR_PREPARED) {
        return MMSYSERR_NOERROR;
    }

    lpMidiOutHdr->dwFlags = 0;

    wRet = midiPrepareHeader(lpMidiOutHdr, wSize);

    if (wRet == MMSYSERR_NOERROR) {
        wRet = (UINT)midiOMessage( (HMIDI)hMidiOut, MODM_PREPARE,
                                  (DWORD)lpMidiOutHdr, (DWORD)wSize );
    }

    return wRet;
}

/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api UINT | midiOutUnprepareHeader | This function cleans up the
 * preparation performed by <f midiOutPrepareHeader>. The
 * <f midiOutUnprepareHeader> function must be called
 * after the device driver fills a data buffer and returns it to the
 * application. You must call this function before freeing the data
 * buffer.
 *
 * @parm HMIDIOUT | hMidiOut | Specifies a handle to the MIDI output
 *   device.
 *
 * @parm LPMIDIHDR | lpMidiOutHdr |  Specifies a pointer to a <t MIDIHDR>
 *   structure identifying the buffer to be cleaned up.
 *
 * @parm UINT | wSize | Specifies the size of the <t MIDIHDR> structure.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MIDIERR_STILLPLAYING | <p lpMidiOutHdr> is still in the queue.
 *
 * @comm This function is the complementary function to
 * <f midiOutPrepareHeader>.
 * You must call this function before freeing the data buffer with
 * <f GlobalFree>.
 * After passing a buffer to the device driver with <f midiOutLongMsg>, you
 * must wait until the driver is finished with the buffer before calling
 * <f midiOutUnprepareHeader>.
 *
 * Unpreparing a buffer that has not been
 * prepared has no effect, and the function returns zero.
 *
 * @xref midiOutPrepareHeader
 ****************************************************************************/
UINT WINAPI
midiOutUnprepareHeader(
    HMIDIOUT hMidiOut,
    LPMIDIHDR lpMidiOutHdr,
    UINT wSize
    )
{
    UINT         wRet;

    V_HANDLE(hMidiOut, TYPE_MIDIOUT, MMSYSERR_INVALHANDLE);
    V_HEADER(lpMidiOutHdr, wSize, TYPE_MIDIOUT, MMSYSERR_INVALPARAM);

    if (!(lpMidiOutHdr->dwFlags & MHDR_PREPARED)) {
        return MMSYSERR_NOERROR;
    }

    if(lpMidiOutHdr->dwFlags & MHDR_INQUEUE) {
        DebugErr( DBF_WARNING,
                  "midiOutUnprepareHeader: header still in queue\r\n");
        return MIDIERR_STILLPLAYING;
    }

    wRet = midiUnprepareHeader(lpMidiOutHdr, wSize);

    if (wRet == MMSYSERR_NOERROR) {
        wRet = (UINT)midiOMessage( (HMIDI)hMidiOut, MODM_UNPREPARE,
                                  (DWORD)lpMidiOutHdr, (DWORD)wSize );
    }

    return wRet;
}

/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api UINT | midiOutShortMsg | This function sends a short MIDI message to
 *   the specified MIDI output device.  Use this function to send any MIDI
 *   message except for system-exclusive messages.
 *
 * @parm HMIDIOUT | hMidiOut | Specifies a handle to the MIDI output
 *   device.
 *
 * @parm DWORD | dwMsg | Specifies the MIDI message.  The message is packed
 *   into a DWORD with the first byte of the message in the low-order byte.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MIDIERR_NOTREADY | The hardware is busy with other data.
 *
 * @comm This function may not return until the message has been sent to the
 *   output device.
 *
 * @xref midiOutLongMsg
 ****************************************************************************/
UINT WINAPI
midiOutShortMsg(
    HMIDIOUT hMidiOut,
    DWORD dwMsg
    )
{
    V_HANDLE(hMidiOut, TYPE_MIDIOUT, MMSYSERR_INVALHANDLE);
    return (UINT)midiOMessage( (HMIDI)hMidiOut, MODM_DATA, dwMsg, 0L );
}

/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api UINT | midiOutLongMsg | This function sends a system-exclusive
 *   MIDI message to the specified MIDI output device.
 *
 * @parm HMIDIOUT | hMidiOut | Specifies a handle to the MIDI output
 *   device.
 *
 * @parm LPMIDIHDR | lpMidiOutHdr | Specifies a far pointer to a <t MIDIHDR>
 *   structure that identifies the MIDI data buffer.
 *
 * @parm UINT | wSize | Specifies the size of the <t MIDIHDR> structure.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MIDIERR_UNPREPARED | <p lpMidiOutHdr> hasn't been prepared.
 *   @flag MIDIERR_NOTREADY | The hardware is busy with other data.
 *
 * @comm The data buffer must be prepared with <f midiOutPrepareHeader>
 *   before it is passed to <f midiOutLongMsg>.  The <t MIDIHDR> data
 *   structure and the data buffer pointed to by its <e MIDIHDR.lpData>
 *   field must be allocated with <f GlobalAlloc> using the GMEM_MOVEABLE
 *   and GMEM_SHARE flags, and locked with <f GlobalLock>. The MIDI output
 *   device driver determines whether the data is sent synchronously or
 *   asynchronously.
 *
 * @xref midiOutShortMsg midiOutPrepareHeader
 ****************************************************************************/
UINT WINAPI
midiOutLongMsg(
    HMIDIOUT hMidiOut,
    LPMIDIHDR lpMidiOutHdr,
    UINT wSize
    )
{
    V_HANDLE(hMidiOut, TYPE_MIDIOUT, MMSYSERR_INVALHANDLE);

//
// we can't call these at interupt time.
//
#pragma message("header not validated for midiOutLongMessage")
////V_HEADER(lpMidiOutHdr, wSize, TYPE_MIDIOUT, MMSYSERR_INVALPARAM);

    if ( HIWORD(lpMidiOutHdr) == 0 ) {
        return MMSYSERR_INVALPARAM;
    }

    if ( wSize != sizeof(MIDIHDR) ) {
        return MMSYSERR_INVALPARAM;
    }

    if (LOWORD(lpMidiOutHdr->dwFlags) & ~MHDR_VALID) {
        return MMSYSERR_INVALFLAG;
    }

    if (!(lpMidiOutHdr->dwFlags & MHDR_PREPARED)) {
        return MIDIERR_UNPREPARED;
    }

    if (lpMidiOutHdr->dwFlags & MHDR_INQUEUE) {
        return MIDIERR_STILLPLAYING;
    }

    return (UINT)midiOMessage( (HMIDI)hMidiOut, MODM_LONGDATA,
                              (DWORD)lpMidiOutHdr, (DWORD)wSize);
}

/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api UINT | midiOutReset | This function turns off all notes on all MIDI
 *   channels for the specified MIDI output device. Any pending
 *   system-exclusive output buffers are marked as done and
 *   returned to the application.
 *
 * @parm HMIDIOUT | hMidiOut | Specifies a handle to the MIDI output
 *   device.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *
 * @comm To turn off all notes, a note-off message for each note for each
 *   channel is sent. In addition, the sustain controller is turned off for
 *   each channel.
 *
 * @xref midiOutLongMsg midiOutClose
 ****************************************************************************/
UINT WINAPI
midiOutReset(
    HMIDIOUT hMidiOut
    )
{
    V_HANDLE(hMidiOut, TYPE_MIDIOUT, MMSYSERR_INVALHANDLE);
    return (UINT)midiOMessage( (HMIDI)hMidiOut, MODM_RESET, 0L, 0L );
}

/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api UINT | midiOutCachePatches | This function requests that an internal
 *   MIDI synthesizer device preload a specified set of patches. Some
 *   synthesizers are not capable of keeping all patches loaded simultaneously
 *   and must load data from disk when they receive MIDI program change
 *   messages. Caching patches ensures specified patches are immediately
 *   available.
 *
 * @parm HMIDIOUT | hMidiOut | Specifies a handle to the opened MIDI output
 *   device. This device must be an internal MIDI synthesizer.
 *
 * @parm UINT | wBank | Specifies which bank of patches should be used.
 *   This parameter should be set to zero to cache the default patch bank.
 *
 * @parm WORD FAR* | lpPatchArray | Specifies a pointer to a <t PATCHARRAY>
 *   array indicating the patches to be cached or uncached.
 *
 * @parm UINT | wFlags | Specifies options for the cache operation. Only one
 *   of the following flags can be specified:
 *      @flag MIDI_CACHE_ALL | Cache all of the specified patches. If they
 *         can't all be cached, cache none, clear the <t PATCHARRAY> array,
 *         and return MMSYSERR_NOMEM.
 *      @flag MIDI_CACHE_BESTFIT | Cache all of the specified patches.
 *         If all patches can't be cached, cache as many patches as
 *         possible, change the <t PATCHARRAY> array to reflect which
 *         patches were cached, and return MMSYSERR_NOMEM.
 *      @flag MIDI_CACHE_QUERY | Change the <t PATCHARRAY> array to indicate
 *         which patches are currently cached.
 *      @flag MIDI_UNCACHE | Uncache the specified patches and clear the
 *         <t PATCHARRAY> array.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   one of the following error codes:
 *      @flag MMSYSERR_INVALHANDLE | The specified device handle is invalid.
 *      @flag MMSYSERR_NOTSUPPORTED | The specified device does not support
 *          patch caching.
 *      @flag MMSYSERR_NOMEM | The device does not have enough memory to cache
 *          all of the requested patches.
 *
 * @comm The <t PATCHARRAY> data type is defined as:
 *
 *   typedef WORD PATCHARRAY[MIDIPATCHSIZE];
 *
 *   Each element of the array represents one of the 128 patches and
 *   has bits set for
 *   each of the 16 MIDI channels that use that particular patch. The
 *   least-significant bit represents physical channel 0; the
 *   most-significant bit represents physical channel 15 (0x0F). For
 *   example, if patch 0 is used by physical channels 0 and 8, element 0
 *   would be set to 0x0101.
 *
 *   This function only applies to internal MIDI synthesizer devices.
 *   Not all internal synthesizers support patch caching. Use the
 *   MIDICAPS_CACHE flag to test the <e MIDIOUTCAPS.dwSupport> field of the
 *   <t MIDIOUTCAPS> structure filled by <f midiOutGetDevCaps> to see if the
 *   device supports patch caching.
 *
 * @xref midiOutCacheDrumPatches
 ****************************************************************************/
UINT WINAPI
midiOutCachePatches(
    HMIDIOUT hMidiOut,
    UINT wBank,
    WORD FAR* lpPatchArray,
    UINT wFlags
    )
{
    V_HANDLE(hMidiOut, TYPE_MIDIOUT, MMSYSERR_INVALHANDLE);
    V_WPOINTER(lpPatchArray, sizeof(PATCHARRAY), MMSYSERR_INVALPARAM);
    V_FLAGS(wFlags, MIDI_CACHE_VALID, midiOutCachePatches, MMSYSERR_INVALFLAG);

    return (UINT)midiOMessage( (HMIDI)hMidiOut,
                              MODM_CACHEPATCHES, (DWORD)lpPatchArray,
                              MAKELONG(wFlags, wBank) );
}

/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api UINT | midiOutCacheDrumPatches | This function requests that an
 *   internal MIDI synthesizer device preload a specified set of key-based
 *   percussion patches. Some synthesizers are not capable of keeping all
 *   percussion patches loaded simultaneously. Caching patches ensures
 *   specified patches are available.
 *
 * @parm HMIDIOUT | hMidiOut | Specifies a handle to the opened MIDI output
 *   device. This device should be an internal MIDI synthesizer.
 *
 * @parm UINT | wPatch | Specifies which drum patch number should be used.
 *   This parameter should be set to zero to cache the default drum patch.
 *
 * @parm WORD FAR* | lpKeyArray | Specifies a pointer to a <t KEYARRAY>
 *   array indicating the key numbers of the specified percussion patches
 *  to be cached or uncached.
 *
 * @parm UINT | wFlags | Specifies options for the cache operation. Only one
 *   of the following flags can be specified:
 *      @flag MIDI_CACHE_ALL | Cache all of the specified patches. If they
 *         can't all be cached, cache none, clear the <t KEYARRAY> array,
 *       and return MMSYSERR_NOMEM.
 *      @flag MIDI_CACHE_BESTFIT | Cache all of the specified patches.
 *         If all patches can't be cached, cache as many patches as
 *         possible, change the <t KEYARRAY> array to reflect which
 *         patches were cached, and return MMSYSERR_NOMEM.
 *      @flag MIDI_CACHE_QUERY | Change the <t KEYARRAY> array to indicate
 *         which patches are currently cached.
 *      @flag MIDI_UNCACHE | Uncache the specified patches and clear the
 *       <t KEYARRAY> array.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   one of the following error codes:
 *      @flag MMSYSERR_INVALHANDLE | The specified device handle is invalid.
 *      @flag MMSYSERR_NOTSUPPORTED | The specified device does not support
 *          patch caching.
 *      @flag MMSYSERR_NOMEM | The device does not have enough memory to cache
 *          all of the requested patches.
 *
 * @comm The <t KEYARRAY> data type is defined as:
 *
 *   typedef WORD KEYARRAY[MIDIPATCHSIZE];
 *
 *   Each element of the array represents one of the 128 key-based percussion
 *   patches and has bits set for
 *   each of the 16 MIDI channels that use that particular patch. The
 *   least-significant bit represents physical channel 0; the
 *   most-significant bit represents physical channel 15. For
 *   example, if the patch on key number 60 is used by physical channels 9
 *       and 15, element 60 would be set to 0x8200.
 *
 *       This function applies only to internal MIDI synthesizer devices.
 *   Not all internal synthesizers support patch caching. Use the
 *   MIDICAPS_CACHE flag to test the <e MIDIOUTCAPS.dwSupport> field of the
 *   <t MIDIOUTCAPS> structure filled by <f midiOutGetDevCaps> to see if the
 *   device supports patch caching.
 *
 * @xref midiOutCachePatches
 ****************************************************************************/
UINT WINAPI
midiOutCacheDrumPatches(
    HMIDIOUT hMidiOut,
    UINT wPatch,
    WORD FAR* lpKeyArray,
    UINT wFlags
    )
{
    V_HANDLE(hMidiOut, TYPE_MIDIOUT, MMSYSERR_INVALHANDLE);
    V_WPOINTER(lpKeyArray, sizeof(KEYARRAY), MMSYSERR_INVALPARAM);
    V_FLAGS(wFlags, MIDI_CACHE_VALID, midiOutCacheDrumPatches, MMSYSERR_INVALFLAG);

    return (UINT)midiOMessage( (HMIDI)hMidiOut,
                               MODM_CACHEDRUMPATCHES, (DWORD)lpKeyArray,
                               MAKELONG(wFlags, wPatch) );
}

/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api UINT | midiInGetNumDevs | This function retrieves the number of MIDI
 *   input devices in the system.
 *
 * @rdesc Returns the number of MIDI input devices present in the system.
 *
 * @xref midiInGetDevCaps
 ****************************************************************************/
UINT WINAPI
midiInGetNumDevs(
    void
    )
{
    return midiIIDMessage( 0, MIDM_GETNUMDEVS, 0L, 0L, 0L );
}

/****************************************************************************
 * @doc EXTERNAL MIDI
 *
 * @api DWORD | midiInMessage | This function sends messages to the MIDI device
 *   drivers.
 *
 * @parm HMIDIIN | hMidiIn | The handle to the MIDI device.
 *
 * @parm UINT  | msg | The message to send.
 *
 * @parm DWORD | dw1 | Parameter 1.
 *
 * @parm DWORD | dw2 | Parameter 2.
 *
 * @rdesc Returns the value of the message sent.
 ***************************************************************************/
DWORD WINAPI
midiInMessage(
    HMIDIIN hMidiIn,
    UINT msg,
    DWORD dw1,
    DWORD dw2
    )
{
    V_HANDLE(hMidiIn, TYPE_MIDIIN, 0L);

    return midiIMessage( (HMIDI)hMidiIn, msg, dw1, dw2);
}

/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api UINT | midiInGetDevCaps | This function queries a specified MIDI input
 *    device to determine its capabilities.
 *
 * @parm UINT | wDeviceID | Identifies the MIDI input device.
 *
 * @parm LPMIDIINCAPS | lpCaps | Specifies a far pointer to a <t MIDIINCAPS>
 *   data structure.  This structure is filled with information about
 *   the capabilities of the device.
 *
 * @parm UINT | wSize | Specifies the size of the <t MIDIINCAPS> structure.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_BADDEVICEID | Specified device ID is out of range.
 *   @flag MMSYSERR_NODRIVER | The driver was not installed.
 *
 * @comm Use <f midiInGetNumDevs> to determine the number of MIDI input
 *   devices present in the system.  The device ID specified by <p wDeviceID>
 *   varies from zero to one less than the number of devices present.
 *   The MIDI_MAPPER constant may also be used as a device id. Only
 *   <p wSize> bytes (or less) of information is copied to the location
 *   pointed to by <p lpCaps>.  If <p wSize> is zero, nothing is copied,
 *   and the function returns zero.
 *
 * @xref midiInGetNumDevs
 ****************************************************************************/
UINT WINAPI
midiInGetDevCaps(
    UINT wDeviceID,
    LPMIDIINCAPS lpCaps,
    UINT wSize
    )
{
    if (wSize == 0) {
         return MMSYSERR_NOERROR;
    }

    V_WPOINTER(lpCaps, wSize, MMSYSERR_INVALPARAM);

    if (ValidateHandle((HMIDIIN)wDeviceID, TYPE_MIDIIN)) {
       return((UINT)midiIMessage((HMIDIIN)wDeviceID,
                                 MIDM_GETDEVCAPS,
                                 (DWORD)lpCaps,
                                 (DWORD)wSize));
    }

    return midiIIDMessage( wDeviceID,
                          MIDM_GETDEVCAPS, 0L, (DWORD)lpCaps, (DWORD)wSize);
}

/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api UINT | midiInGetErrorText | This function retrieves a textual
 *   description of the error identified by the specified error number.
 *
 * @parm UINT | wError | Specifies the error number.
 *
 * @parm LPSTR | lpText | Specifies a far pointer to the buffer to be
 *   filled with the textual error description.
 *
 * @parm UINT | wSize | Specifies the length of buffer pointed to by
 *   <p lpText>.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_BADERRNUM | Specified error number is out of range.
 *
 * @comm If the textual error description is longer than the specified buffer,
 * the description is truncated.  The returned error string is always
 * null-terminated. If <p wSize> is zero, nothing is copied, and
 * the function returns zero. All error descriptions are
 * less than MAXERRORLENGTH characters long.
 ****************************************************************************/
UINT WINAPI
midiInGetErrorText(
    UINT wError,
    LPSTR lpText,
    UINT wSize
    )
{
    if(wSize == 0) {
        return MMSYSERR_NOERROR;
    }

    V_WPOINTER(lpText, wSize, MMSYSERR_INVALPARAM);

    return midiGetErrorText(wError, lpText, wSize);
}

/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api UINT | midiInOpen | This function opens a specified MIDI input device.
 *
 * @parm LPHMIDIIN | lphMidiIn | Specifies a far pointer to an HMIDIIN handle.
 *   This location is filled with a handle identifying the opened MIDI
 *   input device.  Use the handle to identify the device when calling
 *   other MIDI input functions.
 *
 * @parm UINT | wDeviceID | Identifies the MIDI input device to be
 *   opened.
 *
 * @parm DWORD | dwCallback | Specifies the address of a fixed callback
 *   function or a handle to a window called with information
 *   about incoming MIDI messages.
 *
 * @parm DWORD | dwCallbackInstance | Specifies user instance data
 *   passed to the callback function.  This parameter is not
 *   used with window callbacks.
 *
 * @parm DWORD | dwFlags | Specifies a callback flag for opening the device.
 *   @flag CALLBACK_WINDOW | If this flag is specified, <p dwCallback> is
 *      assumed to be a window handle.
 *   @flag CALLBACK_FUNCTION | If this flag is specified, <p dwCallback> is
 *      assumed to be a callback procedure address.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_BADDEVICEID | Specified device ID is out of range.
 *   @flag MMSYSERR_ALLOCATED | Specified resource is already allocated.
 *   @flag MMSYSERR_NOMEM | Unable to allocate or lock memory.
 *
 * @comm Use <f midiInGetNumDevs> to determine the number of MIDI input
 *   devices present in the system.  The device ID specified by <p wDeviceID>
 *   varies from zero to one less than the number of devices present.
 *   The MIDI_MAPPER constant may also be used as a device id.
 *
 *   If a window is chosen to receive callback information, the following
 *   messages are sent to the window procedure function to indicate the
 *   progress of MIDI input:  <m MM_MIM_OPEN>, <m MM_MIM_CLOSE>,
 *   <m MM_MIM_DATA>, <m MM_MIM_LONGDATA>, <m MM_MIM_ERROR>,
 *   <m MM_MIM_LONGERROR>.
 *
 *   If a function is chosen to receive callback information, the following
 *   messages are sent to the function to indicate the progress of MIDI
 *   input:  <m MIM_OPEN>, <m MIM_CLOSE>, <m MIM_DATA>, <m MIM_LONGDATA>,
 *   <m MIM_ERROR>, <m MIM_LONGERROR>.  The callback function must reside in
 *