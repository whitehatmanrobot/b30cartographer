_DBG( ValidateQueue() );
    Assert( IsAnyoneListening() );
    TraceTag((tagTraceTreeSync, "TreeSync: InsertText - cp=%d; cch=%d;", cp, cch));

    // Allocate our record
    pchrec = (CChangeRecord_TextChange *)MemAlloc(Mt(CLogManager_ChangeRecord_pv), 
                                                  sizeof(CChangeRecord_TextChange) +  // A Text Change Record
                                                  ( ( cchRec ) * sizeof( TCHAR ) ) ); // And a buffer of text
    if( !pchrec)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    pchrec->_opcode  = CHANGE_RECORD_OPCODE( CHANGE_RECORD_INSERTTEXT | DirFlags() );
    pchrec->_cp      = cp;
    pchrec->_cch     = cch;

    if( TestForward() )
    {
        // copy in the text buffer
        memcpy( (BYTE *)pchrec + sizeof( CChangeRecord_TextChange ), pchText, ( cch ) * sizeof( TCHAR ) );
    }
    
    AppendRecord( pchrec );

    PostCallback();

Cleanup:
    RRETURN( hr );
}

//+----------------------------------------------------------------+
//
//  Method: InsertOrRemoveElement
//
//  Synopsis: Creates and appends a Change Record for an Insert 
//      Element or Remove Element operation.
//
//+----------------------------------------------------------------+

HRESULT
CLogManager::InsertOrRemoveElement( BOOL fInsert, long cpBegin, long cpEnd, CElement *pElement )
{
    HRESULT                         hr      = S_OK;
    CChangeRecord_ElemChange    *   pchrec  = NULL;
    BSTR                            bstr    = NULL;
    long                            cchElem = 0;
    CGenericElement             *   pGenericElement = NULL;
    long                            cchLiteralContent = 0;
    BOOL                            fRecordElem = fInsert ? TestForward() : TestBackward();
    BYTE *                          pBuff;

    WHEN_DBG( ValidateQueue() );
    Assert( IsAnyoneListening() );
    TraceTag((tagTraceTreeSync, "TreeSync: Ins/Rem Element - fIns=%d; cpBegin=%d; cpEnd=%d; pElement=%lx", fInsert, cpBegin, cpEnd, pElement));

    if( fRecordElem )
    {
        // First we have to save the element to know how much memory to allocate
        hr = THR( SaveElementToBstr( pElement, &bstr ) );
        if( hr )
            goto Cleanup;

        cchElem = SysStringLen( bstr );

        Assert( pElement->Tag() != ETAG_GENERIC_NESTED_LITERAL );
       if( pElement->Tag() == ETAG_GENERIC_LITERAL )
        {
            pGenericElement = DYNCAST(CGenericElement, pElement);

            cchLiteralContent = pGenericElement->_cstrContents.Length();
        }
    }

    // Allocate our record
    pchrec = (CChangeRecord_ElemChange *)MemAlloc( Mt(CLogManager_ChangeRecord_pv),
                                                      sizeof( CChangeRecord_ElemChange ) +
                                                      cchElem * sizeof( TCHAR ) +
                                                      ( cchLiteralContent ? ( cchLiteralContent * sizeof( TCHAR ) + sizeof( long ) ) : 0 ) );

    if( !pchrec )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // Set its fields
    pchrec->_opcode    = CHANGE_RECORD_OPCODE( ( fInsert ? CHANGE_RECORD_INSERTELEM : CHANGE_RECORD_REMOVEELEM ) | 
                                               DirFlags() | 
                                               ( cchLiteralContent ? CHANGE_RECORD_EXTENDED : 0 ) );
    pchrec->_cpBegin   = cpBegin;
    pchrec->_cpEnd     = cpEnd;
    pchrec->_cchElem   = cchElem;

    if( fRecordElem )
    {
        // Copy the string in
        memcpy( (BYTE *)pchrec + sizeof( CChangeRecord_ElemChange ), bstr, pchrec->_cchElem * sizeof( TCHAR ) );

        // If necessary, copy literal content
        if( cchLiteralContent )
        {
            Assert( pGenericElement );

            pBuff = (BYTE *)pchrec + sizeof( CChangeRecord_ElemChange ) + pchrec->_cchElem * sizeof( TCHAR );
            *(long *)pBuff = cchLiteralContent;
            pBuff += sizeof(long);

            memcpy( pBuff, pGenericElement->_cstrContents, cchLiteralContent * sizeof( TCHAR ) );
        }

        if( pElement->_fBreakOnEmpty )
        {
            pchrec->_opcode = CHANGE_RECORD_OPCODE( pchrec->_opcode | CHANGE_RECORD_BREAKONEMPTY );
        }
    }

    AppendRecord( pchrec );

    PostCallback();

Cleanup:
    SysFreeString( bstr );
    RRETURN( hr );
}


//+----------------------------------------------------------------+
//
//  Method: RemoveSplice
//
//  Synopsis: Creates and appends a Change Record for a Remove
//      Splice operation
//
//+----------------------------------------------------------------+

HRESULT
CLogManager::RemoveSplice( long                     cpBegin, 
                           long                     cpEnd, 
                           CSpliceRecordList    *   paryRegion, 
                           TCHAR                *   pchRemoved,
                           long                     cchRemoved )
{
    HRESULT                         hr = S_OK;
    long                            nRecSize;
    long                            crec = 0;
    CChangeRecord_Splice        *   pchrec;
    
    WHEN_DBG( ValidateQueue() );
    Assert( IsAnyoneListening() );
    Assert( !TestBackward() || ( paryRegion && pchRemoved ) );
    TraceTag((tagTraceTreeSync, "TreeSync: RemoveSplice - cpBegin=%d; cpEnd=%d", cpBegin, cpEnd));

    // Allocate our buffer
    nRecSize = sizeof( CChangeRecord_Splice );
    pchrec = (CChangeRecord_Splice *)MemAlloc( Mt(CLogManager_ChangeRecord_pv), nRecSize );

    if( !pchrec )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // Set up the record
    pchrec->_opcode    = CHANGE_RECORD_OPCODE( CHANGE_RECORD_REMOVESPLICE | DirFlags() );
    pchrec->_cpBegin   = cpBegin;
    pchrec->_cpEnd     = cpEnd;

    if( TestBackward() )
    {
        hr = THR( ConvertRecordsToChunks( NULL, paryRegion, pchRemoved, &pchrec, &nRecSize, &crec ) );
        if( hr )
            goto Cleanup;
    }

    // Note the size, so we don't have to walk this whole structure to count it.
    pchrec->_cb = nRecSize - sizeof(CChangeRecordBase *);
    pchrec->_crec = crec;

    AppendRecord( pchrec );

    PostCallback();

Cleanup:

    if( hr )
    {
        MemFree( pchrec );
    }

    RRETURN( hr );
}


//+----------------------------------------------------------------+
//
//  Method: InsertSplice
//
//  Synopsis: Creates and appends a Change Record for a Insert
//      Splice operation
//
//  TODO (JHarding):
//  If it turns out that calling MemRealloc is causing a
//  bottleneck, we can use a more efficient allocation pattern
//
//+----------------------------------------------------------------+

HRESULT
CLogManager::InsertSplice( long cp, long cch, TCHAR * pch, CSpliceRecordList * paryLeft, CSpliceRecordList * paryInside )
{
    HRESULT                         hr = S_OK;
    CChangeRecord_Splice        *   pchrec;
    long                            nRecSize;
    long                            crec = 0;

    WHEN_DBG( ValidateQueue() );
    Assert( IsAnyoneListening() );
    TraceTag((tagTraceTreeSync, "TreeSync: InsertSplice - cpBegin=%d; cch=%d", cp, cch));

    // We'll start our record out at the size of an InsertSplice record
    nRecSize = sizeof( CChangeRecord_Splice );
    pchrec = (CChangeRecord_Splice *)MemAlloc( Mt(CLogManager_ChangeRecord_pv), nRecSize );

    if( !pchrec )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // Set up the fixed Change Record
    pchrec->_opcode    = CHANGE_RECORD_OPCODE( CHANGE_RECORD_INSERTSPLICE | DirFlags() );
    pchrec->_cpBegin   = cp;
    pchrec->_cpEnd     = cp + cch;
    // We'll set up _cb later when we know the real size

    if( TestForward() )
    {
        hr = THR( ConvertRecordsToChunks( paryLeft, paryInside, pch, &pchrec, &nRecSize, &crec ) );
        if( hr )
            goto Cleanup;
    }

    // Note the size, so we don't have to walk this whole structure to count it.
    pchrec->_cb = nRecSize - sizeof(CChangeRecordBase *);
    pchrec->_crec = crec;

    AppendRecord( pchrec );

    PostCallback();

Cleanup:

    if( hr )
    {
        MemFree( pchrec );
    }
    RRETURN( hr );
}


//+----------------------------------------------------------------+
//
//  Method: AttrChangeProp
//
//  Synopsis: Creates a change record for a property change on an
//      element
//
//+----------------------------------------------------------------+

HRESULT
CLogManager::AttrChangeProp( CElement * pElement, CBase * pBase, ATTR_CHANGE_FLAGS lFlags, DISPID dispid, VARIANT * pVarOld, VARIANT * pVarNew )
{
    HRESULT                         hr;
    IDispatchEx                 *   pDisp   = NULL;
    BSTR                            bstr    = NULL;
    CChangeRecord_AttrChange    *   pchrec  = NULL;
    long                            cp;
    CTreePos                    *   ptpBegin;
    BYTE                        *   pb;
    VARIANT                         varTemp;
    BSTR                            bstrOld = NULL;
    BSTR                            bstrNew = NULL;

    WHEN_DBG( ValidateQueue() );
    Assert( IsAnyoneListening() );
    TraceTag((tagTraceTreeSync, "TreeSync: AttrChange - pElement=%lx; pBase=%lx; lFlags=%lx; dispid=%lx", pElement, pBase, lFlags, dispid));

    hr = THR( pBase->PunkOuter()->QueryInterface( IID_IDispatchEx, (void **)&pDisp ) );
    if( hr )
        goto Cleanup;

    hr = THR( pDisp->GetMemberName( dispid, &bstr ) );
    if( hr )
        goto Cleanup;

    if( !pVarOld || V_VT( pVarOld ) == VT_NULL || V_VT( pVarOld ) == VT_EMPTY )
    {
        // No value currently set
        lFlags = ATTR_CHANGE_FLAGS( (long)lFlags | ATTR_CHANGE_OLDNOTSET );
    }
    else
    {
        if( pVarOld->vt == VT_LPWSTR || pVarOld->vt == VT_BSTR )
        {
            hr = THR( FormsAllocString( (TCHAR *)pVarOld->byref, &bstrOld ) );
        }
        else
        {
            VariantInit( &varTemp );
            hr = THR( VariantChangeType( &varTemp, pVarOld, 0, VT_BSTR ) );
            if( hr )
                goto Cleanup;

            bstrOld = V_BSTR( &varTemp );
        }
    }

    if( !pVarNew || V_VT( pVarNew ) == VT_NULL || V_VT( pVarNew ) == VT_EMPTY )
    {
        // Clearing the value
        lFlags = ATTR_CHANGE_FLAGS( (long)lFlags | ATTR_CHANGE_NEWNOTSET );
    }
    else
    {
        if( pVarNew->vt == VT_LPWSTR || pVarNew->vt == VT_BSTR )
        {
            hr = THR( FormsAllocString( (TCHAR *)pVarNew->byref, &bstrNew ) );
        }
        else
        {
            VariantInit( &varTemp );
            hr = THR( VariantChangeType( &varTemp, pVarNew, 0, VT_BSTR ) );
            if( hr )
                goto Cleanup;

            bstrNew = V_BSTR( &varTemp );
        }
    }


    pElement->GetTreeExtent( &ptpBegin, NULL );
    Assert(ptpBegin);
    cp = ptpBegin->GetCp();

    pchrec = (CChangeRecord_AttrChange *)MemAlloc( Mt(CLogManager_ChangeRecord_pv),
                                                   sizeof( CChangeRecord_AttrChange ) +         // The record
                                                   SysStringLen( bstr ) * sizeof( TCHAR ) +     // Plus the prop name
                                                   SysStringLen( bstrOld ) * sizeof( TCHAR ) +  // Plus the old value
                                                   SysStringLen( bstrNew ) * sizeof( TCHAR ) ); // Plus the new value
    
    if( !pchrec )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    pchrec->_opcode      = CHANGE_RECORD_OPCODE( CHANGE_RECORD_ATTRCHANGE | DirFlags() );
    pchrec->_lFlags      = lFlags;
    pchrec->_cpElement   = cp;
    pchrec->_cchName     = SysStringLen( bstr );
    pchrec->_cchOldValue = SysStringLen( bstrOld );
    pchrec->_cchNewValue = SysStringLen( bstrNew );

    pb = (BYTE *)pchrec + sizeof( CChangeRecord_AttrChange );
    memcpy( pb, bstr, SysStringLen( bstr ) * sizeof( TCHAR ) );

    pb += SysStringLen( bstr ) * sizeof( TCHAR );
    memcpy( pb, bstrOld, SysStringLen( bstrOld ) * sizeof( TCHAR ) );

    pb += SysStringLen( bstrOld ) * sizeof( TCHAR );
    memcpy( pb, bstrNew, SysStringLen( bstrNew ) * sizeof( TCHAR ) );

    AppendRecord( pchrec );

    PostCallback();

Cleanup:
    ReleaseInterface( pDisp );
    SysFreeString( bstr );
    SysFreeString( bstrOld );
    SysFreeString( bstrNew );

    RRETURN( hr );
}

//+----------------------------------------------------------------+
//
//  Method: PostCallback
//
//  Synopsis: Posts a method call for us to notify any Sinks
//      of pending changes
//
//+----------------------------------------------------------------+

HRESULT
CLogManager::PostCallback()
{
    WHEN_DBG( ValidateQueue() );
    TraceTag((tagTraceTreeSync, "TreeSync: Posting callback"));

    // We better have someone listening
    Assert( _aryLogs.Size() > 0 );

    if( !TestCallbackPosted() )
    {
        GWPostMethodCall(this, ONCALL_METHOD(CLogManager, NotifySinksCallback, notifysinkscallback), 0, TRUE, "CLogManager::NotifySinksCallback");
        SetCallbackPosted();
    }

    RRETURN( S_OK );
}

//+----------------------------------------------------------------+
//
//  Method: NotifySinksCallback
//
//  Synopsis: Notifies listeners that there are new changes pending
//      for them to grab.
//
//+----------------------------------------------------------------+

void
CLogManager::NotifySinksCallback( DWORD_PTR dwParam )
{
    long            c;
    CChangeLog **   ppLog;
    BOOL            fWasNotified;
    CDeletionLock   Lock(this);     // May delete this in destructor

    WHEN_DBG( ValidateQueue() );
    Assert( TestCallbackPosted() );
    TraceTag((tagTraceTreeSync, "TreeSync: Notifying sinks"));

    ClearCallbackPosted();

    // Clear flags
    ClearReentrant();
    for( c = _aryLogs.Size(), ppLog = _aryLogs; c; c--, ++ppLog )
    {
        Assert( (*ppLog) && (*ppLog)->_pPlaceholder );

        (*ppLog)->_fNotified = FALSE;
    }

NotifyLoop:
    for( c = _aryLogs.Size(), ppLog = _aryLogs; c; c--, ++ppLog )
    {
        Assert( (*ppLog) && (*ppLog)->_pPlaceholder );

        // The notified flag is to prevent us from notifying someone repeatedly.
        // Thus, if we skip someone becasue they have no changes pending, we
        // can set the flag, because we don't want to come back and notify them
        // if we have to re-iterate through the clients.
        fWasNotified = (*ppLog)->_fNotified;
        (*ppLog)->_fNotified = TRUE;

        // Someone may have registered or read changes after we posted
        // our callback, so make sure there really is a change pending
        if( !fWasNotified && (*ppLog)->_pPlaceholder->GetNextRecord() )
        {
            (*ppLog)->NotifySink();
        }

        if( TestReentrant() )
        {
            TraceTag((tagTraceTreeSync, "TreeSync: Reentrancy detected in notification loop - resetting"));
            ClearReentrant();
            goto NotifyLoop;
        }
    }

    Assert( !TestReentrant() );
#if DBG==1
    for( c = _aryLogs.Size(), ppLog = _aryLogs; c; c--, ++ppLog )
    {
        Assert( (*ppLog)->_fNotified );
    }
#endif // DBG

    WHEN_DBG( ValidateQueue() );
}


//+----------------------------------------------------------------+
//
//  Method: RegisterSink
//
//  Synopsis: Registers an IHTMLChangeSink.  Creates a CChangeLog
//      object to communicate with the Sink and adds it to our
//      data structures
//
//+----------------------------------------------------------------+

HRESULT
CLogManager::RegisterSink( IHTMLChangeSink * pChangeSink, IHTMLChangeLog ** ppChangeLog, BOOL fForward, BOOL fBackward )
{
    HRESULT                     hr;
    CChangeLog                * pChangeLog = NULL;
    CChangeRecord_Placeholder * pPlaceholder;
    CDeletionLock               Lock(this); // May delete this in destructor


    WHEN_DBG( ValidateQueue() );
    TraceTag((tagTraceTreeSync, "TreeSync: Registering new sink:%lx; fForward=%d; fBackward=%d", pChangeSink, fForward, fBackward));

    Assert( pChangeSink && ppChangeLog );

    // Create a placeholder first
    pPlaceholder = (CChangeRecord_Placeholder *)MemAlloc( Mt(CLogManager_ChangeRecord_pv),
                                                          sizeof(CChangeRecord_Placeholder) );
    if( !pPlaceholder )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // Now create the log object
    pChangeLog = new CChangeLog( this, pChangeSink, pPlaceholder );
    if( !pChangeLog )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    pPlaceholder->_opcode = CHANGE_RECORD_PLACEHOLDER;

    // Add the log
    hr = THR( _aryLogs.Append( pChangeLog ) );
    if( hr )
        goto Cleanup;

    // Add the placeholder
    pPlaceholder->_pPrev = _pchrecTail;
    AppendRecord( pPlaceholder );

    *ppChangeLog = pChangeLog;
    
    SetReentrant();

    // This will propagate back into us to do the right thing.
    pChangeLog->SetDirection( fForward, fBackward );

Cleanup:
    WHEN_DBG( ValidateQueue() );

    if( hr )
    {
        delete pChangeLog;
        delete pPlaceholder;
    }

    RRETURN( hr );
}


//+----------------------------------------------------------------+
//
//  Method: Unregister
//
//  Synopsis: Unregisters a Change Log and removes it from our
//      data structures
//
//+----------------------------------------------------------------+

HRESULT
CLogManager::Unregister( CChangeLog *pChangeLog )
{
    HRESULT                     hr = S_OK;
    CDeletionLock               Lock(this); // May delete this in destructor

    WHEN_DBG( ValidateQueue() );
    TraceTag((tagTraceTreeSync, "TreeSync: Unregistering Log:%lx", pChangeLog));

    Assert( pChangeLog && pChangeLog->_pPlaceholder );

    // Remove the log from our list
    if( !_aryLogs.DeleteByValue( pChangeLog ) )
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    RemovePlaceholder( pChangeLog->_pPlaceholder );

    MemFree( pChangeLog->_pPlaceholder );

    TrimQueue();

    // Make us re-evaluate what information we're storing.
    SetDirection( FALSE, FALSE );

    SetReentrant();

    WHEN_DBG( ValidateQueue() );

Cleanup:
    RRETURN( hr );
}

//+----------------------------------------------------------------+
//
//  Method: DisconnectFromMarkup
//
//  Synopsis: Disconnects the log manager from its markup
//
//+----------------------------------------------------------------+
void
CLogManager::DisconnectFromMarkup()
{
    if( _pMarkup )
    {
        Assert( _pMarkup->HasLogManager() && _pMarkup->GetLogManager() == this );
        _pMarkup->GetChangeNotificationContext()->_pLogManager = NULL;
        _pMarkup = NULL;
    }
}

//+----------------------------------------------------------------+
//
//  Method: SetDirection
//
//  Synopsis: Sets which directions of information we're interested
//      in recording.  If someone turns on a direction, we just
//      set a flag.  If someone turns off, we scan to see if any
//      other clients are interested.
//
//      NOTE (JHarding): We could maintain counts for these instead,
//      but since we don't expect many clients, running the list
//      isn't a big deal.
//
//+----------------------------------------------------------------+

HRESULT
CLogManager::SetDirection( BOOL fForward, BOOL fBackward )
{
    long            c;
    CChangeLog  **  ppLog;

    if( fForward )
    {
        SetForward();
    }
    else
    {
        // Re-scan now to see if anyone wants forward info
        ClearForward();
        for( c = _aryLogs.Size(), ppLog = _aryLogs; c; c--, ppLog++ )
        {
            if( (*ppLog)->_pPlaceholder->_opcode & LOGMGR_FORWARDINFO )
            {
                SetForward();
                break;
            }
        }
    }

    if( fBackward )
    {
        SetBackward();
    }
    else
    {
        // Re-scan now to see if anyone wants forward info
        ClearBackward();
        for( c = _aryLogs.Size(), ppLog = _aryLogs; c; c--, ppLog++ )
        {
            if( (*ppLog)->_pPlaceholder->_opcode & LOGMGR_BACKWARDINFO )
            {
                SetBackward();
                break;
            }
        }
    }

    RRETURN( S_OK );
}


//+----------------------------------------------------------------+
//
//  Method: AppendRecord
//
//  Synopsis: Just appends the ChangeRecord to our stream of
//      changes
//+----------------------------------------------------------------+
#if DBG==1      // Don't inline in debug
void
#else
inline void
#endif // DBG==1
CLogManager::AppendRecord( CChangeRecordBase * pchrec )
{
    AssertSz( _aryLogs.Size() > 0, "AppendRecord should only be called when someone is listening." );
    TraceTag((tagTraceTreeSync, "TreeSync: Appending record - %lx", pchrec->_opcode));

    pchrec->_pNext = NULL;

    // If for some reason the QS failed, we'll keep using 0
    if( _pISequencer )
    {
        _pISequencer->GetSequenceNumber( _nSequenceNumber, &_nSequenceNumber );
    }
    pchrec->_nSequenceNumber = _nSequenceNumber;

    if( !_pchrecHead )
    {
        Assert( !_pchrecTail );

        _pchrecHead = _pchrecTail = pchrec;
    }
    else
    {
        // Add him after the tail
        _pchrecTail->_pNext = pchrec;
        _pchrecTail = pchrec;
    }
}


//+----------------------------------------------------------------+
//
//  Method: RemovePlaceholder
//
//  Synopsis: Removes a placeholder from the stream and cleans up the
//      queue
//
//+----------------------------------------------------------------+

void
CLogManager::RemovePlaceholder( CChangeRecord_Placeholder * pPlaceholder )
{
    // If there was something before the placeholder
    if( pPlaceholder->_pPrev )
    {
        // Set its next pointer past the placeholder
        pPlaceholder->_pPrev->_pNext = pPlaceholder->_pNext;
    }
    else
    {
        // Otherwise, the placeholder should have been the head
        Assert( _pchrecHead == pPlaceholder );

        // Set the head pointer
        _pchrecHead = pPlaceholder->_pNext;
    }

    // If the placeholder was the tail, we need to update the tail ptr
    if( _pchrecTail == pPlaceholder )
    {
        Assert( pPlaceholder->_pNext == NULL );

        _pchrecTail = pPlaceholder->_pPrev;
    }

    // Now, if there was another placeholder after this placeholder, fix its prev ptr
    if( pPlaceholder->_pNext && 
        ( pPlaceholder->_pNext->_opcode & CHANGE_RECORD_TYPEMASK ) == CHANGE_RECORD_PLACEHOLDER )
    {
        ((CChangeRecord_Placeholder *)pPlaceholder->_pNext)->_pPrev = pPlaceholder->_pPrev;
    }
}


//+----------------------------------------------------------------+
//
//  Method: InsertPlaceholderAfterRecord
//
//  Synopsis: Moves the given placeholder to a position in the stream
//      just after the given record.  Placeholder are the only records
//      allowed to move around in the stream, and so they are
//      handled explicitly.
//
//+----------------------------------------------------------------+

void
CLogManager::InsertPlaceholderAfterRecord( CChangeRecord_Placeholder * pPlaceholder,
                                           CChangeRecordBase         * pchrec )
{
    Assert( pPlaceholder && pchrec );

    // Set the placeholder's prev ptr
    pPlaceholder->_pPrev = pchrec;

    if( pchrec == _pchrecTail )
    {
        AppendRecord( pPlaceholder );
    }
    else
    {
        // And insert it into its new home
        pPlaceholder->_pNext = pchrec->_pNext;
        pchrec->_pNext  = pPlaceholder;

        // If the guy after the placeholder now has a prev pointer, we have to fix it
        if( ( pPlaceholder->_pNext->_opcode & CHANGE_RECORD_TYPEMASK ) == CHANGE_RECORD_PLACEHOLDER )
        {
            ((CChangeRecord_Placeholder *)pPlaceholder->_pNext)->_pPrev = pPlaceholder;
        }
    }

    TrimQueue();
}


//+----------------------------------------------------------------+
//
//  Method: TrimQueue
//
//  Synopsis: Trims useless records off the head of the queue. 
//      The first record in the stream should always be a placeholder,
//      because any records before a placeholder do not have anyone
//      waiting to receive them.
//
//+----------------------------------------------------------------+

void
CLogManager::TrimQueue()
{
    CChangeRecordBase * pchrec;

    while( _pchrecHead && ( _pchrecHead->_opcode & CHANGE_RECORD_TYPEMASK ) != CHANGE_RECORD_PLACEHOLDER )
    {
        pchrec = _pchrecHead->_pNext;
        MemFree( _pchrecHead );
        _pchrecHead = pchrec;
    }

    if( _pchrecHead )
    {
        Assert( ( _pchrecHead->_opcode & CHANGE_RECORD_TYPEMASK ) == CHANGE_RECORD_PLACEHOLDER && _aryLogs.Size() > 0 );
        ((CChangeRecord_Placeholder *)_pchrecHead)->_pPrev = NULL;
    }
    else
    {
        // We drained the whole queue
        Assert( _aryLogs.Size() == 0 );
        _pchrecTail = NULL;
    }

    WHEN_DBG( ValidateQueue() );
}

//+----------------------------------------------------------------+
//
//  Method: ClearQueue
//
//  Synopsis: Clears and frees all records from the queue
//
//+----------------------------------------------------------------+

void
CLogManager::ClearQueue()
{
    CChangeRecordBase * pchrec;

    while( _pchrecHead )
    {
        pchrec = _pchrecHead->_pNext;
        MemFree( _pchrecHead );
        _pchrecHead = pchrec;
    }

    _pchrecTail = NULL;
}


//+----------------------------------------------------------------+
//
//  Method: SaveElementToBstr
//
//  Synopsis: Saves the given element into a newly created BSTR
//  TODO (JHarding): This is not particularly efficient, as it
//  has to allocate a Global, a stream, and a BSTR.
//
//+----------------------------------------------------------------+
HRESULT
CLogManager::SaveElementToBstr( CElement * pElement, BSTR * pbstr )
{
    HRESULT   hr;
    IStream * pstm = NULL;

    Assert( pbstr );

    *pbstr = NULL;

    hr = THR( CreateStreamOnHGlobal( NULL, TRUE, &pstm ) );
    if( hr )
        goto Cleanup;

    {
        CStreamWriteBuff swb( pstm, CP_UCS_2 );

        hr = THR( swb.Init() );
        if( hr )
            goto Cleanup;

        swb.SetFlags( WBF_NO_WRAP | WBF_NO_PRETTY_CRLF | WBF_FOR_TREESYNC );
        swb.SetElementContext( pElement );
        WHEN_DBG( swb._fValidateDbg = FALSE );

        hr = THR( pElement->Save( &swb, FALSE ) );
        if( hr )
            goto Cleanup;

        hr = swb.Terminate();
        if( hr )
            goto Cleanup;
    }

    hr = THR( GetBStrFromStream( pstm, pbstr, TRUE ) );
    if( hr )
        goto Cleanup;

Cleanup:
    ReleaseInterface( pstm );
    RRETURN( hr );
}

//+----------------------------------------------------------------+
//
//  Method: ConvertChunksToRecords
//
//  Synopsis: Helper function to convert a buffer of SpliceChunks
//      into a SpliceRecordList + Text Stream combo.  Does some
//      work to Do The Right Thing with Text chunks, splitting 
//      them up into text TreePos' by SID.
//
//      Output buffer and SpliceRecordList are allocated by us.
//      If we succeed, they're set, otherwise they're not.
//      If we succeed, caller is responsible for freeing them.
//
//      Note on verification of SpliceChunks.  In order to preserve
//  the symmetry of insert/remove operations, we validate the
//  splice chunks as we convert them.  It is illegal to insert
//  content completely enclosing an existing element.  For example,
//  if the tree contained: foo<B></B>bar, the following would be
//  LEGAL to insert between "o" and <B>:
//  *) moo<Skip Begin>cow
//  *) moo<I>cow<Skip Begin>blah<End 1>
//  However, the following would be ILLEGAL:
//  *) moo<Skip Begin>cow<End 0>more
//  Because it completely encloses the existing <B> tag.
//
//  Also, we walk the tree as we go to make sure that things
//  like skipped begin/end nodes are already there.
//
//+----------------------------------------------------------------+

HRESULT
CLogManager::ConvertChunksToRecords( CMarkup            *   pMarkup, 
                                     long                   cpInsert, 
                                     BYTE               *   pbFirstChunk, 
                                     long                   nBufferLength,
                                     long                   crec, 
                                     TCHAR             **   ppch, 
                                     long               *   pcch, 
                                     CSpliceRecordList **   pparyRecords )
{
    HRESULT                     hr              = S_OK;
    CSpliceChunkBase        *   pscBase         = (CSpliceChunkBase *)pbFirstChunk;
    CSpliceRecord           *   prec;
    CTreePos                *   ptpIns;
    CStackDataAry<BOOL, 10>     aryfElemInTree(Mt(CLogManager_aryfElemInTree)); // Stack of BOOLs noting if elem was in tree
    TCHAR                   *   pchText         = NULL;
    TCHAR                   *   pchTextStart    = NULL;
    long                        cch             = 0;
    CSpliceRecordList       *   paryRecords     = NULL;
    IHTMLElement            *   pIHTMLElement   = NULL;


    Assert( pbFirstChunk && pparyRecords && pcch && ppch );

    // Zero out our output params
    *ppch = NULL;
    *pcch = 0;
    *pparyRecords = NULL;

    // Estimate (generously) the space needed to store the text stream
    pchTextStart = pchText = (TCHAR *)MemAlloc( Mt(CLogManager_ChangeRecord_pv), nBufferLength - crec * sizeof(long) );
    if( !pchText )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    // And create our record list
    paryRecords = new CSpliceRecordList();
    if( !paryRecords )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    ptpIns = pMarkup->TreePosAtCp( cpInsert, NULL, TRUE );
    Assert( !ptpIns->IsPointer() );

    while( crec-- )
    {
        switch( pscBase->_opcodeAndFlags & CSpliceChunkBase::TypeMask )
        {
        case CTreePos::NodeBeg:
            {
                CSpliceChunk_NodeBegin * pscNodeBeg = (CSpliceChunk_NodeBegin *)pscBase;
                CElement               * pElement = NULL;
                long                     cchLiteralContent = 0;

                if( ( pscNodeBeg->_opcodeAndFlags & CSpliceChunkBase::SkipChunk ) )
                {
                    // Should not be an element string for something we're skipping
                    // Nor should they have set both these flags
                    if( pscNodeBeg->_cchElem || ( pscNodeBeg->_opcodeAndFlags & CSpliceChunkBase::ElemPtr )  )
                    {
                        hr = E_INVALIDARG;
                        goto Cleanup;
                    }

                    // Skip the existing begin
                    if( !ptpIns->IsBeginElementScope() )
                    {
                        AssertSz( FALSE, "Bogus Insert Splice Change Record given - Attempting to skip into non-existing element" );
                        hr = E_INVALIDARG;
                        goto Cleanup;
                    }
                    pElement = ptpIns->Branch()->Element();
                    pElement->AddRef(); // Splice Records hold AddRef'd pointers

                    // Adjust to the next Edge NodePos or Text
                    do
                    {
                        ptpIns = ptpIns->NextTreePos();
                    } while( ptpIns->IsPointer() ||
                             ( ptpIns->IsNode() && !ptpIns->IsEdgeScope() ) );
                }
                else if( ( pscNodeBeg->_opcodeAndFlags & CSpliceChunkBase::ElemPtr ) )
                {
                    // They've given us an element ptr - QI for IHTMLElement to make sure it really is one
                    hr = THR( pscNodeBeg->_pElement->QueryInterface( IID_IHTMLElement, (void **)&pIHTMLElement ) );
                    if( hr )
                        goto Cleanup;

                    // Make sure it's not already in the tree
                    hr = THR( pIHTMLElement->QueryInterface( CLSID_CElement, (void **)&pElement ) );
                    if( hr )
                    {
                        goto Cleanup;
                    }
                    if( pElement->GetFirstBranch() || pElement->Tag() == ETAG_ROOT )
                    {
                        hr = E_INVALIDARG;
                        goto Cleanup;
                    }

                    pElement->AddRef();     // Hold an AddRef'd pointer for the Splice Record
                    ClearInterface( &pIHTMLElement );
                }
                else
                {
                    // Create the element from the string
                    hr = THR( pMarkup->CreateElement( ETAG_NULL, 
                                                       &pElement, 
                                                       (TCHAR *)((BYTE *)pscNodeBeg + sizeof(CSpliceChunk_NodeBegin)), 
                                                       pscNodeBeg->_cchElem ) );
                    if( hr )
                        goto Cleanup;

                    if( pscNodeBeg->_opcodeAndFlags & CSpliceChunkBase::Extended )
                    {
                        cchLiteralContent = *(long *)( (BYTE *)pscNodeBeg + sizeof(CSpliceChunk_NodeBegin) + pscNodeBeg->_cchElem * sizeof( TCHAR ) );

                        Assert( pElement->Tag() != ETAG_GENERIC_NESTED_LITERAL );
                        if( pElement->Tag() == ETAG_GENERIC_LITERAL )
                        {
                            CGenericElement * pGenericElement = DYNCAST( CGenericElement, pElement );

                            pGenericElement->_cstrContents.Set( (TCHAR *)( (BYTE *)pscNodeBeg + sizeof(CSpliceChunk_NodeBegin) + pscNodeBeg->_cchElem * sizeof( TCHAR ) + sizeof( long ) ),
                                                                 cchLiteralContent );
                        }
                    }

                    if( pscNodeBeg->_opcodeAndFlags & CSpliceChunkBase::BreakOnEmpty )
                    {
                        pElement->_fBreakOnEmpty = TRUE;
                    }
                }

                // Append a splice record
                hr = THR( paryRecords->AppendIndirect( NULL, &prec ) );
                if( hr )
                    goto Cleanup;

                // And set the fields
                prec->_type  = CTreePos::NodeBeg;
                prec->_pel   = pElement;    // Transferring the ref to the SpliceRecord
                prec->_fSkip = !!( pscNodeBeg->_opcodeAndFlags & CSpliceChunkBase::SkipChunk );

                aryfElemInTree.AppendIndirect( &(prec->_fSkip), NULL );

                // Add a WCH_NODE char to the stream
                *pchText++ = WCH_NODE;
                cch += 1;

                // Skip to the next record
                pscBase = (CSpliceChunkBase *)((BYTE *)pscBase + sizeof(CSpliceChunk_NodeBegin) + 
                          ( ( pscNodeBeg->_opcodeAndFlags & CSpliceChunkBase::ElemPtr ) ? 0 : pscNodeBeg->_cchElem * sizeof( TCHAR ) ) +
                          ( cchLiteralContent ? cchLiteralContent * sizeof( TCHAR ) + sizeof( long ) : 0 ) );
            }
            break;

        case CTreePos::NodeEnd:
            {
                CSpliceChunk_NodeEnd * pscNodeEnd = (CSpliceChunk_NodeEnd *)pscBase;

                //
                // Verify this Node End:
                //
                // 1) If it's not in our stack, then it should be in the tree
                if( pscNodeEnd->_cIncl >= aryfElemInTree.Size() )
                {
                    if( !ptpIns->IsEndElementScope() )
                    {
                        AssertSz( FALSE, "Bogus Insert Splice Change Record given - Trying to end an existing element in the wrong place" );
                        hr = E_INVALIDARG;
                        goto Cleanup;
                    }

                    // Adjust to the next Edge NodePos or Text
                    do
                    {
                        ptpIns = ptpIns->NextTreePos();
                    } while( ptpIns->IsPointer() ||
                             ( ptpIns->IsNode() && !ptpIns->IsEdgeScope() ) );
                }
                else
                {
                    // 2) If this was skipped in the tree, we can't end it
                    if( aryfElemInTree[ aryfElemInTree.Size() - pscNodeEnd->_cIncl - 1 ] )
                    {
                        AssertSz( FALSE, "Bogus Insert Splice Change Record given - Trying to end an element whose begin we skipped" );
                        hr = E_INVALIDARG;
                        goto Cleanup;
                    }
                    // 3) Otherwise we created it, so we can end it
                    aryfElemInTree.Delete( aryfElemInTree.Size() - pscNodeEnd->_cIncl - 1 );
                }

                // Append a splice record
                hr = THR( paryRecords->AppendIndirect( NULL, &prec ) );
                if( hr )
                    goto Cleanup;

                // set the fields
                prec->_type  = CTreePos::NodeEnd;
                prec->_cIncl = pscNodeEnd->_cIncl;
                prec->_pel   = NULL;

                // Add a WCH_NODE char to the stream
                *pchText++ = WCH_NODE;
                cch += 1;

                // and skip to the next record
                pscBase = (CSpliceChunkBase *)((BYTE *)pscBase + sizeof(CSpliceChunk_NodeEnd));
            }
            break;

        case CTreePos::Text:
            // For text, we have to split the text up into text pos's by Script ID
            // (which we have to calculate)
            {
                CSpliceChunk_Text * pscText = (CSpliceChunk_Text *)pscBase;
                SCRIPT_ID           sidCurr, sidChunk;
                long                cchLeft;
                TCHAR               chCurr;
                TCHAR *             pchIn;
                TCHAR *             pchStart;


                pchIn       = (TCHAR *)((BYTE *)pscText + sizeof(CSpliceChunk_Text));
                cchLeft     = pscText->_cch;

                while( cchLeft )    // Iterate over all the characters here
                {
                    // Append a splice record for this text-pos-to-be
                    hr = THR( paryRecords->AppendIndirect( NULL, &prec ) );
                    if( hr )
                        goto Cleanup;


                    // The first char determines the starting sid
                    sidChunk = ScriptIDFromCh( *pchIn );

                    // Remember the start of this chunk
                    pchStart = pchIn;

                    while( cchLeft )    // pull up chars that merge with the first
                    {
                        chCurr = *pchIn;

                        // If we got a bogus character, try to do something intelligent with it.
                        if( chCurr == 0 || !IsValidWideChar( chCurr ) )
                        {
                            AssertSz( FALSE, "Bogus character came in through an Insert Splice record in ExecChange" );

                            chCurr = _T('?');
                        }

                        // Find the sid for the new char
                        sidCurr = ScriptIDFromCh( chCurr );

                        if( AreDifferentScriptIDs( &sidChunk, sidCurr ) )
                            break;  // Done with this chunk

                        pchIn++;
                        cchLeft--;
                    }   // Done pulling up chars that merge with the first

                    Assert( pchIn > pchStart );

                    if( sidChunk == sidMerge )
                        sidChunk = sidDefault;

                    // set the fields
                    prec->_type     = CTreePos::Text;
                    prec->_cch      = pchIn - pchStart;
                    prec->_sid      = sidChunk;
                    prec->_lTextID  = 0;

                    cch += prec->_cch;

                    // Copy this chunk into the text stream
                    memcpy( pchText, pchStart, prec->_cch * sizeof( TCHAR ) );
                    pchText += prec->_cch;
                }

                // and skip to the next record
                pscBase = (CSpliceChunkBase *)((BYTE *)pscBase + sizeof(CSpliceChunk_Text) + pscText->_cch * sizeof( TCHAR ));
            }
            break;

        default:
            AssertSz( FALSE, "Unknown Splice Chunk in Insert Splice operation" );
            hr = E_INVALIDARG;
            goto Cleanup;
        }
    }

Cleanup:
    if( hr )
    {
        MemFree( pchTextStart );
        delete paryRecords;
    }
    else
    {
        *pcch = cch;
        *pparyRecords = paryRecords;
        *ppch = pchTextStart;
    }

    ReleaseInterface( pIHTMLElement );
    RRETURN( hr );
}

//+----------------------------------------------------------------+
//
//  Method: ConvertRecordsToChunks
//
//  Synopsis: Helper function to convert one or two 
//      SpliceRecordLists to a buffer of Splice Chunks.  The
//      pointer given must point to a valid pointer, because we're
//      going to MemRealloc it.
//
//+----------------------------------------------------------------+

HRESULT
CLogManager::ConvertRecordsToChunks( CSpliceRecordList           * paryLeft, 
                                     CSpliceRecordList           * paryInside, 
                                     TCHAR                       * pch, 
                                     CChangeRecord_Splice       ** ppchrecIns,
                                     long                        * pnBufferSize,
                                     long                        * pcRec )
{
    HRESULT                 hr          = S_OK;
    long                    crec;
    TCHAR               *   pchText;
    CSpliceRecord       *   prec;
    long                    nRecSize;
    long                    nChunkSize;
    BSTR                    bstr        = NULL;
    long                    nOffsetOfLastText = 0;

    Assert( ppchrecIns && paryInside && pnBufferSize && pcRec );

    // Count the number of records
    crec = paryLeft ? paryLeft->Size() : 0;
    crec += paryInside->Size();

    nRecSize = *pnBufferSize;

    prec = paryLeft ? *paryLeft : *paryInside;
    pchText = pch;
    *pcRec = crec;

    for( ; crec; crec--, prec++ )
    {
        // If we finished paryLeft, jump to paryInside
        if( paryLeft && crec == paryInside->Size() )
            prec = *paryInside;

        switch( prec->_type )
        {
        // For a NodeBegin SpliceRecord, we need to save:
        // 1) Note the opcode for a NodeBegin (we never skip begin nodes)
        // 2) Record the length of the persisted element string
        // 3) Append the element string after the record
        case CTreePos::NodeBeg:
        {

            CSpliceChunk_NodeBegin * pscNodeBegin;
            CGenericElement        * pGenericElement = NULL;
            long                     cchElem = 0;
            long                     cchLiteralContent = 0;

            if( !prec->_fSkip )
            {
                // Save the element to a BSTR
                hr = THR( SaveElementToBstr( prec->_pel, &bstr ) );
                if( hr )
                    goto Cleanup;

                cchElem = SysStringLen( bstr );

                Assert( prec->_pel->Tag() != ETAG_GENERIC_NESTED_LITERAL );
                if( prec->_pel->Tag() == ETAG_GENERIC_LITERAL )
                {
                    pGenericElement = DYNCAST( CGenericElement, prec->_pel );

                    cchLiteralContent = pGenericElement->_cstrContents.Length();
                }
            }

            // Calcuate the size of this new chunk
            nChunkSize = sizeof( CSpliceChunk_NodeBegin ) +         // NodeBegin chunk
                         cchElem * sizeof( TCHAR ) +                // element string
                         ( cchLiteralContent ? cchLiteralContent * sizeof( TCHAR ) + sizeof( long ) : 0 ); // Possibly literal content
                        
            // Grow our allocation by the new chunk size
            hr = THR( MemRealloc( Mt(CLogManager_ChangeRecord_pv), (void **)ppchrecIns, nRecSize + nChunkSize ) );
            if( hr )
                goto Cleanup;

            // Set up a pointer to the newly allocated memory for this chunk
            pscNodeBegin = (CSpliceChunk_NodeBegin *)((BYTE *)*ppchrecIns + nRecSize);
            nRecSize += nChunkSize;

            //
            // Copy the data into the buffer
            //
            pscNodeBegin->_opcodeAndFlags = CTreePos::NodeBeg;                  // Opcode
            pscNodeBegin->_cchElem = cchElem;                                   // String len
            if( prec->_fSkip )
            {
                // No string and no string length
                Assert( !bstr && cchElem == 0 );

                // If this is a skip, set the flag, and don't copy the elem string
                pscNodeBegin->_opcodeAndFlags |= CSpliceChunkBase::SkipChunk;
            }
            else
            {
                // Otherwise, set length and copy string
                memcpy( (BYTE *)pscNodeBegin + sizeof( CSpliceChunk_NodeBegin ), 
                        bstr, 
                        pscNodeBegin->_cchElem * sizeof( TCHAR ) );             // Element string

                SysFreeString( bstr );
                bstr = NULL;

                if( cchLiteralContent )
                {
                    Assert( pGenericElement );

                    *(long *)( (BYTE *)pscNodeBegin + sizeof( CSpliceChunk_NodeBegin ) + pscNodeBegin->_cchElem * sizeof( TCHAR ) ) = cchLiteralContent;

                    memcpy( (BYTE *)pscNodeBegin + sizeof( CSpliceChunk_NodeBegin ) + pscNodeBegin->_cchElem * sizeof( TCHAR ) + sizeof( long ),
                            pGenericElement->_cstrContents,
                            cchLiteralContent * sizeof( TCHAR ) );

                    pscNodeBegin->_opcodeAndFlags |= CSpliceChunkBase::Extended;
                }
            }
            if( prec->_pel->_fBreakOnEmpty )
            {
                pscNodeBegin->_opcodeAndFlags |= CSpliceChunkBase::BreakOnEmpty;
            }

            nOffsetOfLastText = 0;

            Assert( *pchText == WCH_NODE );
            ++pchText;

            break;
        }

        // For a NodeEnd SpliceRecord, we need to save:
        // 1) Note the opcode for a NodeEnd, as well as the fSkip flag
        // 2) Record the length of the inclusion around this node's ending
        case CTreePos::NodeEnd:

            CSpliceChunk_NodeEnd * pscNodeEnd;

            // Calcuate the size of this new chunk
            nChunkSize = sizeof( CSpliceChunk_NodeEnd );

            // Grow our allocation by the new chunk size
            hr = THR( MemRealloc( Mt(CLogManager_ChangeRecord_pv), (void **)ppchrecIns, nRecSize + nChunkSize ) );
            if( hr )
                goto Cleanup;

            // Set up a pointer to the newly allocated memory for this chunk
            pscNodeEnd = (CSpliceChunk_NodeEnd *)((BYTE *)*ppchrecIns + nRecSize);
            nRecSize += nChunkSize;

            // Copy the data into the buffer
            pscNodeEnd->_opcodeAndFlags = CTreePos::NodeEnd;
            pscNodeEnd->_cIncl = prec->_cIncl; 

            nOffsetOfLastText = 0;

            Assert( *pchText == WCH_NODE );
            ++pchText;

            break;

        // For a Text SpliceRecord, we need to save:
        // 1) Note the opcode for a Text pos
        // 2) Record the cch
        case CTreePos::Text:
            CSpliceChunk_Text * pscText;

            // If the last record was text, just work with it.
            if( nOffsetOfLastText )
            {
                // Reallocate for more text
                hr = THR( MemRealloc( Mt(CLogManager_ChangeRecord_pv), (void **)ppchrecIns, nRecSize + prec->_cch * sizeof( TCHAR ) ) );
                if( hr )
                    goto Cleanup;

                // Set up a pointer to the last text splice chunk
                pscText = (CSpliceChunk_Text *)((BYTE *)*ppchrecIns + nOffsetOfLastText);
                Assert( ( pscText->_opcodeAndFlags & CSpliceChunkBase::TypeMask ) == CTreePos::Text );

                // Update the character count for that splice chunk
                pscText->_cch += prec->_cch;

                // And copy it in.
                memcpy( (BYTE *)*ppchrecIns + nRecSize, pchText, prec->_cch * sizeof( TCHAR ) );
                pchText += prec->_cch;

                nRecSize += prec->_cch * sizeof( TCHAR );

                // One less record, too.
                (*pcRec) -= 1;
            }
            else
            {
                // Calcuate the size of this new chunk
                nChunkSize = sizeof( CSpliceChunk_Text ) + prec->_cch * sizeof( TCHAR );

                // Grow our allocation by the new chunk size
                hr = THR( MemRealloc( Mt(CLogManager_ChangeRecord_pv), (void **)ppchrecIns, nRecSize + nChunkSize ) );
                if( hr )
                    goto Cleanup;

                // Set up a pointer to the newly allocated memory for this chunk
                pscText = (CSpliceChunk_Text *)((BYTE *)*ppchrecIns + nRecSize);

                // Copy the data into the buffer
                pscText->_opcodeAndFlags = CTreePos::Text;
                pscText->_cch = prec->_cch;

                memcpy( (TCHAR *)((BYTE *)pscText + sizeof( CSpliceChunk_Text )), pchText, prec->_cch * sizeof( TCHAR ) );
                pchText += prec->_cch;

                nRecSize += nChunkSize;

                nOffsetOfLastText = (BYTE *)pscText - (BYTE *)*ppchrecIns;
            }

            break;

        case CTreePos::Pointer:
            *pcRec -= 1;
            break;


#if DBG==1
        default:
            AssertSz( FALSE, "Unintialized splice record" );
            break;
#endif // DBG
        }
    }

Cleanup:

    SysFreeString( bstr );
    if( hr )
    {
        MemFree( *ppchrecIns );
        nRecSize = 0;
    }

    *pnBufferSize = nRecSize;

    RRETURN( hr );
}


///////////////////////////////
// CChangeRecordBase Methods

//+----------------------------------------------------------------+
//
//  Method: RecordLength
//
//  Synopsis: Returns the length of the record, in bytes - 
//      The flags passed in specify what information you're
//      interested in.  It is not valid to ask for more information
//      than was recorded.
//
//+----------------------------------------------------------------+

long
CChangeRecordBase::RecordLength( DWORD dwFlags )
{
    long nLen = 0;
    BOOL fForward = !!( dwFlags & CHANGE_RECORD_FORWARD );
    BOOL fBackward = !!( dwFlags & CHANGE_RECORD_BACKWARD );

    // Assert the type of info they want is stored.
    Assert( ( !fForward || _opcode & CHANGE_RECORD_FORWARD ) &&
            ( !fBackward || _opcode & CHANGE_RECORD_BACKWARD ) );

    switch( _opcode & CHANGE_RECORD_TYPEMASK )
    {
    case CHANGE_RECORD_INSERTTEXT:
        {
            CChangeRecord_TextChange * pchrec = (CChangeRecord_TextChange *)this;
            
            nLen = sizeof( CChangeRecord_TextChange );

            if( fForward )
            {
                nLen += pchrec->_cch * sizeof( TCHAR );
            }
        }
        break;

    case CHANGE_RECORD_INSERTELEM:
    case CHANGE_RECORD_REMOVEELEM:
        {
            CChangeRecord_ElemChange * pchrec = (CChangeRecord_ElemChange *)this;

            if( ( fForward  && ( _opcode & CHANGE_RECORD_TYPEMASK ) == CHANGE_RECORD_INSERTELEM ) ||
                ( fBackward && ( _opcode & CHANGE_RECORD_TYPEMASK ) == CHANGE_RECORD_REMOVEELEM ) )
            {
                nLen = sizeof( CChangeRecord_ElemChange ) +
                       pchrec->_cchElem * sizeof( TCHAR );
                if( _opcode & CHANGE_RECORD_EXTENDED )
                {
                    // Add literal content data
                    nLen += *(long *)( (BYTE *)pchrec + nLen ) * sizeof( TCHAR ) + sizeof( long );
                }
            }
            else
            {
                nLen = offsetof( CChangeRecord_ElemChange, _cchElem );
            }
        }
        break;

    case CHANGE_RECORD_REMOVESPLICE:
    case CHANGE_RECORD_INSERTSPLICE:
        {
            CChangeRecord_Splice * pchrec = (CChangeRecord_Splice *)this;
            if( ( fForward  && ( _opcode & CHANGE_RECORD_TYPEMASK ) == CHANGE_RECORD_INSERTSPLICE ) ||
                ( fBackward && ( _opcode & CHANGE_RECORD_TYPEMASK ) == CHANGE_RECORD_REMOVESPLICE ) )
            {
                nLen = pchrec->_cb + sizeof(CChangeRecordBase *);
            }
            else
            {
                nLen = offsetof( CChangeRecord_Splice, _crec );
            }
        }
        break;
    case CHANGE_RECORD_ATTRCHANGE:
        {
            CChangeRecord_AttrChange * pchrec = (CChangeRecord_AttrChange *)this;

            nLen = sizeof( CChangeRecord_AttrChange ) + 
                   ( pchrec->_cchName + pchrec->_cchOldValue + pchrec->_cchNewValue ) * sizeof( TCHAR );
        }
        break;

    case CHANGE_RECORD_PLACEHOLDER:
        nLen = sizeof( CChangeRecord_Placeholder );
        break;
#if DBG==1
    default:
        nLen = sizeof( CChangeRecordBase );
        AssertSz( FALSE, "Unknown record - Log Manager is probably corrupted." );
        break;
#endif // DBG==1
    }

    // The length should not include _pNext ptr.
    return nLen - sizeof(CChangeRecordBase *);
}

//+----------------------------------------------------------------+
//
//  Method: CChangeRecordBase::PlayIntoMarkup
//
//  Synopsis: Determines the type of the record, casts, and 
//      calls the appropriate version
//
//+----------------------------------------------------------------+

HRESULT
CChangeRecordBase::PlayIntoMarkup( CMarkup * pMarkup, BOOL fForward )
{
    HRESULT             hr = S_OK;

    // We have to have info for the direction they want to play
    if(  fForward && !( _opcode & CHANGE_RECORD_FORWARD ) ||
        !fForward && !( _opcode & CHANGE_RECORD_BACKWARD ) )
    {
        AssertSz( FALSE, "TreeSync record being played backwards!" );
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    switch( _opcode & CHANGE_RECORD_TYPEMASK )
    {
    case CHANGE_RECORD_INSERTTEXT:
        {
            CChangeRecord_TextChange * pchrecText = (CChangeRecord_TextChange *)this;

            hr = THR( pchrecText->PlayIntoMarkup( pMarkup, fForward ) );
            if( hr )
                goto Cleanup;
        }

        break;

    case CHANGE_RECORD_REMOVEELEM:
    case CHANGE_RECORD_INSERTELEM:
        {
            CChangeRecord_ElemChange * pchrecElem = (CChangeRecord_ElemChange *)this;

            hr = THR( pchrecElem->PlayIntoMarkup( pMarkup, fForward ) );
            if( hr )
                goto Cleanup;
        }

        break;

    case CHANGE_RECORD_REMOVESPLICE:
    case CHANGE_RECORD_INSERTSPLICE:
        {
            CChangeRecord_Splice       * pchrecSplice = (CChangeRecord_Splice *)this;

            hr = THR( pchrecSplice->PlayIntoMarkup( pMarkup, fForward ) );
            if( hr )
                goto Cleanup;
        }

        break;

    case CHANGE_RECORD_ATTRCHANGE:
        {
            CChangeRecord_AttrChange * pchrecAttr = (CChangeRecord_AttrChange *)this;

            hr = THR( pchrecAttr->PlayIntoMarkup( pMarkup, fForward ) );
            if( hr )
                goto Cleanup;
        }

        break;

    default:
        AssertSz( FALSE, "Invalid TreeSync Change Record!" );
        hr = E_INVALIDARG;
        break;
    }

Cleanup:
    RRETURN( hr );
}

//+----------------------------------------------------------------+
//
//  Method: CChangeRecord_TextChange::PlayIntoMarkup
//
//  Synopsis: Replays the TextChange record into the given
//      markup
//
//+----------------------------------------------------------------+

HRESULT
CChangeRecord_TextChange::PlayIntoMarkup( CMarkup * pMarkup, BOOL fForward )
{
    HRESULT         hr;
    CMarkupPointer  mp( pMarkup->Doc() );

    TraceTag((tagTraceTreeSync, "TreeSync: Replaying TextChange fForward=%d", fForward));

    hr = THR( mp.MoveToCp( _cp, pMarkup ) );
    if( hr )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    
    if( fForward )
    {
        // Forward means Insert the Text
        hr = THR( pMarkup->Doc()->InsertText( &mp, (TCHAR *)((BYTE *)this + sizeof(CChangeRecord_TextChange)), _cch ) );
        if( hr )
            goto Cleanup;
    }
    else
    {
        CMarkupPointer mpEnd( pMarkup->Doc() );

        hr = THR( mpEnd.MoveToCp( _cp + _cch, pMarkup ) );
        if( hr )
            goto Cleanup;

        // Backwards means cut it out
        hr = THR( pMarkup->Doc()->CutCopyMove( &mp, &mpEnd, NULL, TRUE ) );
        if( hr )
            goto Cleanup;
    }

Cleanup:
    RRETURN( hr );
}

//+----------------------------------------------------------------+
//
//  Method: CChangeRecord_ElemChange::PlayIntoMarkup
//
//  Synopsis: Replays the Element Change record into the given
//      markup
//
//+----------------------------------------------------------------+

HRESULT
CChangeRecord_ElemChange::PlayIntoMarkup( CMarkup * pMarkup, BOOL fForward )
{
    HRESULT             hr = S_OK;
    CElement          * pElement = NULL;
    CMarkupPointer      mp( pMarkup->Doc() );
    CTreePos          * ptp;

    TraceTag((tagTraceTreeSync, "TreeSync: Replaying ElemChange fForward=%d", fForward));

    if( ( ( _opcode & CHANGE_RECORD_TYPEMASK ) == CHANGE_RECORD_INSERTELEM &&  fForward ) ||
        ( ( _opcode & CHANGE_RECORD_TYPEMASK ) == CHANGE_RECORD_REMOVEELEM && !fForward ) )
    {
        CMarkupPointer             mpEnd( pMarkup->Doc() );

        hr = THR( mp.MoveToCp( _cpBegin, pMarkup ) );
        if( hr )
        {
            hr = E_INVALIDARG;
            goto InsCleanup;
        }
        // Replaying a remove backwards, the end cp is off by one, because it's where
        // we removed.
        hr = THR( mpEnd.MoveToCp( fForward ? _cpEnd : _cpEnd - 1, pMarkup ) );
        if( hr )
        {
            hr = E_INVALIDARG;
            goto InsCleanup;
        }

        hr = THR( pMarkup->CreateElement( ETAG_NULL, &pElement, (TCHAR *)((BYTE *)this + sizeof(CChangeRecord_ElemChange)), _cchElem ) );
        if( hr )
            goto InsCleanup;

        Assert( pElement->Tag() != ETAG_GENERIC_NESTED_LITERAL );
        if( _opcode & CHANGE_RECORD_EXTENDED && pElement->Tag() == ETAG_GENERIC_LITERAL )
        {
            CGenericElement * pGenericElement = DYNCAST( CGenericElement, pElement );

            pGenericElement->_cstrContents.Set( (TCHAR *)((BYTE *)this + sizeof( CChangeRecord_ElemChange ) + _cchElem * sizeof( TCHAR ) ) + sizeof( long ),
                                                *(long *)((BYTE *)this + sizeof( CChangeRecord_ElemChange ) + _cchElem * sizeof( TCHAR ) ) );
        }
        if( _opcode & CHANGE_RECORD_BREAKONEMPTY )
        {
            pElement->_fBreakOnEmpty = TRUE;
        }

        hr = THR( pMarkup->Doc()->InsertElement( pElement, &mp, &mpEnd ) );

InsCleanup:
        if( pElement )
            pElement->Release();

        if( hr )
            goto Cleanup;
    }
    else
    {
        ptp = pMarkup->TreePosAtCp( _cpBegin, NULL, TRUE );
        if( !ptp || !ptp->IsBeginElementScope() )
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }

        pElement = ptp->Branch()->Element();

        hr = THR( pMarkup->RemoveElementInternal( pElement ) );
        if( hr )
            goto Cleanup;
    }

Cleanup:
    RRETURN( hr );
}

//+----------------------------------------------------------------+
//
//  Method: CChangeRecord_Splice::PlayIntoMarkup
//
//  Synopsis: Converts the splice chunks into a splice record
//      list and plays into the given markup
//
//+----------------------------------------------------------------+

HRESULT
CChangeRecord_Splice::PlayIntoMarkup( CMarkup * pMarkup, BOOL fForward )
{
    HRESULT             hr = S_OK;
    CMarkupPointer      mp( pMarkup->Doc() );

    TraceTag((tagTraceTreeSync, "TreeSync: Replaying Splice fForward=%d", fForward));
    
    // Both directions are going to need this pointer
    hr = THR( mp.MoveToCp( _cpBegin, pMarkup ) );
    if( hr )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if( ( ( _opcode & CHANGE_RECORD_TYPEMASK ) == CHANGE_RECORD_INSERTSPLICE &&  fForward ) ||
        ( ( _opcode & CHANGE_RECORD_TYPEMASK ) == CHANGE_RECORD_REMOVESPLICE && !fForward ) )
    {
        CSpliceRecordList          * paryRecords = NULL;
        TCHAR                      * pch = NULL;
        long                         cch;

        hr = THR( CLogManager::ConvertChunksToRecords( pMarkup,
                                                       _cpBegin,
                                                       (BYTE *)this + sizeof(CChangeRecord_Splice),
                                                       _cb - sizeof( CChangeRecord_Splice ) + sizeof( CChangeRecordBase *),
                                                       _crec, 
                                                       &pch, 
                                                       &cch, 
                                                       &paryRecords ) );
        if( hr )
            goto InsCleanup;

        hr = THR( pMarkup->UndoRemoveSplice( &mp, 
                                             paryRecords, 
                                             cch, 
                                             pch,
                                             0 ) );

InsCleanup:
        if( pch )
            MemFree( pch );
        if( paryRecords )
            delete paryRecords;

        if( hr )
            goto Cleanup;
    }
    else
    {
        CMarkupPointer               mpEnd( pMarkup->Doc() );

        hr = THR( mpEnd.MoveToCp( _cpEnd, pMarkup ) );
        if( hr )
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }

        hr = THR( pMarkup->Doc()->CutCopyMove( &mp, &mpEnd, NULL, TRUE ) );
        if( hr )
            goto Cleanup;
    }

Cleanup:
    RRETURN( hr );
}


//+----------------------------------------------------------------+
//
//  Method: CChangeRecord_AttrChange::PlayIntoMarkup
//
//  Synopsis: Replays the attribute change into the given markup
//
//+----------------------------------------------------------------+

HRESULT
CChangeRecord_AttrChange::PlayIntoMarkup( CMarkup * pMarkup, BOOL fForward )
{
    HRESULT         hr              = S_OK;
    VARIANT         varNewValue;
    BSTR            bstrValue       = NULL;
    BSTR            bstrName        = NULL;
    CTreePos    *   ptp;
    CElement    *   pElement;
    IDispatchEx *   pDisp           = NULL;
    DISPID          dispid;
    TCHAR       *   pch             = NULL;
    CBase       *   pBase           = NULL;

    TraceTag((tagTraceTreeSync, "TreeSync: Replaying AttrChange fForward=%d", fForward));

    VariantInit(&varNewValue);              // keep compiler happy
    
    // Find the element
    ptp = pMarkup->TreePosAtCp( _cpElement, NULL, TRUE );
    if( !ptp || !ptp->IsBeginElementScope() )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    pElement = ptp->Branch()->Element();

    if( fForward )
    {
        if( _lFlags & ATTR_CHANGE_NEWNOTSET )
        {
            V_VT( &varNewValue ) = VT_NULL;
        }
        else
        {
            pch = (TCHAR *)MemAlloc( Mt(Mem), ( _cchNewValue + 1 ) * sizeof( TCHAR ) );
            if( !pch )
                goto Cleanup;

            memcpy( pch, (BYTE *)this + sizeof( CChangeRecord_AttrChange ) + ( _cchName + _cchOldValue ) * sizeof( TCHAR ), _cchNewValue * sizeof( TCHAR ) );
            pch[ _cchNewValue ] = _T('\0');

        }
    }
    else
    {
        if( _lFlags & ATTR_CHANGE_OLDNOTSET )
        {
            V_VT( &varNewValue ) = VT_NULL;
        }
        else
        {
            pch = (TCHAR *)MemAlloc( Mt(Mem), ( _cchOldValue + 1 ) * sizeof( TCHAR ) );
            if( !pch )
                goto Cleanup;

            memcpy( pch, (BYTE *)this + sizeof( CChangeRecord_AttrChange ) + _cchName * sizeof( TCHAR ), _cchOldValue * sizeof( TCHAR ) );
            pch[ _cchOldValue ] = _T('\0');
        }
    }

    if( pch )
    {
        hr = THR( FormsAllocString( pch, &bstrValue ) );
        if( hr )
            goto Cleanup;

        V_VT( &varNewValue )    = VT_BSTR;
        V_BSTR( &varNewValue )  = bstrValue;
        MemFree( pch );
        pch = NULL;
    }

    if( _lFlags & ATTR_CHANGE_INLINESTYLE )
    {
        // Get style object
        CStyle * pStyle;

        hr = THR( pElement->GetStyleObject( &pStyle ) );
        if( hr )
            goto Cleanup;

        Assert( pStyle );
        hr = THR( pStyle->QueryInterface( IID_IDispatchEx, (void **)&pDisp ) );
        if( hr )
            goto Cleanup;

        pBase = pStyle;
    }
    else if( _lFlags & ATTR_CHANGE_RUNTIMESTYLE )
    {
        CStyle * pStyle;

        hr = THR( pElement->EnsureRuntimeStyle( &pStyle ) );
        if( hr )
            goto Cleanup;

        Assert( pStyle );
        hr = THR( pStyle->QueryInterface( IID_IDispatchEx, (void **)&pDisp ) );
        if( hr )
            goto Cleanup;
        pBase = pStyle;
    }
    else
    {
        hr = THR( pElement->QueryInterface( IID_IDispatchEx, (void **)&pDisp ) );
        if( hr )
            goto Cleanup;

        pBase = pElement;
    }

    Assert( pDisp );

    pch = (TCHAR *)MemAlloc( Mt(Mem), ( _cchName + 1 ) * sizeof( TCHAR ) );
    if( !pch )
        goto Cleanup;

    memcpy( pch, (BYTE *)this + sizeof( CChangeRecord_AttrChange ), _cchName * sizeof( TCHAR ) );
    pch[ _cchName ] = _T('\0');

    hr = THR( FormsAllocString( pch, &bstrName ) );
    if( hr )
        goto Cleanup;

    hr = THR( pDisp->GetDispID( bstrName, fdexNameCaseSensitive | fdexNameEnsure, &dispid ) );
    if( hr )
        goto Cleanup;

    if( V_VT(&varNewValue) == VT_NULL )
    {
        if(! pBase->removeAttributeDispid( dispid ) )
        {
            hr = E_FAIL;
            goto Cleanup;
        }
    }
    else
    {
        hr = THR( SetDispProp( pDisp,
                               dispid, 
                               g_lcidUserDefault,
                               &varNewValue,
                               NULL ) );
    }
        

Cleanup:
    SysFreeString( bstrValue );
    SysFreeString( bstrName );
    ReleaseInterface( pDisp );
    MemFree( pch );
    RRETURN( hr );
}

///////////////////////////////
// CChangeRecord_Placeholder Methods

//+----------------------------------------------------------------+
//
//  Method: GetNextRecord
//
//  Synopsis: Returns the next REAL Change Record in the queue,
//      skipping past all placeholders
//
//+----------------------------------------------------------------+

CChangeRecordBase *
CChangeRecord_Placeholder::GetNextRecord()
{
    CChangeRecordBase * pchrec = _pNext;

    while( pchrec && ( pchrec->_opcode & CHANGE_RECORD_TYPEMASK ) == CHANGE_RECORD_PLACEHOLDER )
    {
        pchrec = pchrec->_pNext;
    }

    return pchrec;
}



#if DBG==1
////////////////////////////////
// Debug methods


//+----------------------------------------------------------------+
//
//  Method: ValidateQueue (DEBUG)
//
//  Synopsis: Performs some basic validation on the queue
//
//+----------------------------------------------------------------+
void
CLogManager::ValidateQueue()
{
    CChangeRecordBase * pchrec;
    long                nLogs = 0;

    // If we're empty, we shouldn't have any logs.  If we're not empty,
    // then the first thing had better be a placeholder and we'd better
    // have some logs
    Assert( ( !_pchrecHead && !_pchrecTail && _aryLogs.Size() == 0 ) || 
            ( ( _pchrecHead->_opcode & CHANGE_RECORD_TYPEMASK ) == CHANGE_RECORD_PLACEHOLDER && 
                _aryLogs.Size() > 0 ) );

    pchrec = _pchrecHead;
    while( pchrec )
    {
        if( ( pchrec->_opcode & CHANGE_RECORD_TYPEMASK ) == CHANGE_RECORD_PLACEHOLDER )
            ++nLogs;
        pchrec = pchrec->_pNext;
    }
    Assert( nLogs == _aryLogs.Size() );
}

#define TEXTDUMPLENGTH 40

//+----------------------------------------------------------------+
//
//  Method: DumpRecord (DEBUG)
//
//  Synopsis: Dumps the record in the given buffer to the dump file
//
//+----------------------------------------------------------------+
void 
CLogManager::DumpRecord( BYTE * pbRecord )
{
    // TODO (JHarding): This is cheating.  We're never going to reference
    // the first 4 bytes of the structure, which would ordinarily be the _pNext
    // ptr, but to line up the pointer, we need to point there.
    CChangeRecordBase * pchrec = (CChangeRecordBase *)(pbRecord - sizeof(CChangeRecordBase *));

    WriteHelp( g_f, _T("<0d>) "), pchrec->_nSequenceNumber );

    switch( pchrec->_opcode & CHANGE_RECORD_TYPEMASK )
    {
    case CHANGE_RECORD_INSERTTEXT:
        {
        CChangeRecord_TextChange * pchrecText = (CChangeRecord_TextChange *)pchrec;
        WriteHelp( g_f, _T("[Insert Text]\tcp=<0d>\tcch=<1d>"), 
            pchrecText->_cp, 
            pchrecText->_cch );
        
        if( pchrec->_opcode & CHANGE_RECORD_FORWARD )
        {
            TCHAR achText[TEXTDUMPLENGTH + 1 ];
            long  nTextLen = pchrecText->_cch > TEXTDUMPLENGTH ? TEXTDUMPLENGTH : pchrecText->_cch;

            // Copy some text in
            memcpy( achText, (BYTE *)pchrecText + sizeof( CChangeRecord_TextChange ), nTextLen * sizeof( TCHAR ) );
            achText[ nTextLen ] = _T('\0');

            if( nTextLen == TEXTDUMPLENGTH )
            {
                _tcscpy( &achText[ nTextLen - 3 ], _T("...") );
            }

            WriteHelp( g_f, _T("\t<0s>"), achText);
        }

        WriteHelp( g_f, _T("\r\n") );

        break;
        }
    case CHANGE_RECORD_INSERTELEM:
    case CHANGE_RECORD_REMOVEELEM:
        {
        CChangeRecord_ElemChange * pchrecElem = (CChangeRecord_ElemChange *)pchrec;

        WriteHelp( g_f, _T("[<0s>]\tcpBegin=<1d>\tcpEnd=<2d>\t"), 
            pchrec->_opcode & CHANGE_RECORD_INSERTELEM ? _T("Insert Elem") : _T("Remove Elem"), 
            pchrecElem->_cpBegin, 
            pchrecElem->_cpEnd );

        if( ( ( pchrec->_opcode & CHANGE_RECORD_TYPEMASK ) == CHANGE_RECORD_INSERTELEM &&   // Insert and
                pchrec->_opcode & CHANGE_RECORD_FORWARD ) ||                                // Forward, OR
            ( ( pchrec->_opcode & CHANGE_RECORD_TYPEMASK ) == CHANGE_RECORD_REMOVEELEM &&   // Remove and
                pchrec->_opcode & CHANGE_RECORD_BACKWARD ) )                                // Backward
        {
            // Terminate the string for printing.  
            TCHAR ch = *((TCHAR *)((BYTE *)pchrecElem + sizeof(CChangeRecord_ElemChange) + pchrecElem->_cchElem * sizeof( TCHAR )));
            *((TCHAR *)((BYTE *)pchrecElem + sizeof(CChangeRecord_ElemChange) + pchrecElem->_cchElem * sizeof( TCHAR ))) = 0;

            WriteHelp( g_f, _T("<0s>\n"), (TCHAR *)((BYTE *)pchrecElem + sizeof( CChangeRecord_ElemChange )) );
            *((TCHAR *)((BYTE *)pchrecElem + sizeof(CChangeRecord_ElemChange) + pchrecElem->_cchElem * sizeof( TCHAR ))) = ch;
        }
        if( pchrec->_opcode & CHANGE_RECORD_EXTENDED )
        {
            long cchLiteral = *(long *)((BYTE *)pchrecElem + sizeof(CChangeRecord_ElemChange) + pchrecElem->_cchElem * sizeof( TCHAR ));

            *((TCHAR *)((BYTE *)pchrecElem + sizeof(CChangeRecord_ElemChange) + ( pchrecElem->_cchElem + cchLiteral ) * sizeof( TCHAR ) + sizeof( long ))) = 0;

            WriteHelp( g_f, _T("Literal Content: <0s>"), (TCHAR *)((BYTE *)pchrecElem + sizeof( CChangeRecord_ElemChange ) + pchrecElem->_cchElem * sizeof( TCHAR ) + sizeof( long )) );
        }

        WriteHelp( g_f, _T("\r\n") );
        break;
        }
    case CHANGE_RECORD_REMOVESPLICE:
    case CHANGE_RECORD_INSERTSPLICE:
        {
        CChangeRecord_Splice * pchrecSplice = (CChangeRecord_Splice *)pchrec;
        BYTE * pCurr;
        BOOL   fDumpChunks;
        long   crec;

        if( pchrec->_opcode & CHANGE_RECORD_REMOVESPLICE )
        {
            WriteHelp( g_f, _T("[Remove") );
            fDumpChunks = pchrec->_opcode & CHANGE_RECORD_BACKWARD;
        }
        else
        {
            WriteHelp( g_f, _T("[Insert") );
            fDumpChunks = pchrec->_opcode & CHANGE_RECORD_FORWARD;
        }
        WriteHelp( g_f, _T(" Splice]\tcpBegin=<0d>\tcpEnd=<1d>"), pchrecSplice->_cpBegin, pchrecSplice->_cpEnd );

        if( fDumpChunks )
        {
            WriteHelp( g_f, _T("\tcrec=<0d>:\r\n"), pchrecSplice->_crec );
            for( crec = pchrecSplice->_crec, pCurr = (BYTE *)pchrecSplice + sizeof( CChangeRecord_Splice ); crec; crec-- )
            {
                CSpliceChunkBase * pscBase = (CSpliceChunkBase *)pCurr;
            
                switch( pscBase->_opcodeAndFlags & CSpliceChunkBase::TypeMask )
                {
                case CTreePos::NodeBeg:
                    {
                        CSpliceChunk_NodeBegin * pscNodeBegin = (CSpliceChunk_NodeBegin *)pscBase;
                        TCHAR                  * pch          = (TCHAR *)MemAlloc(Mt(Mem), ( pscNodeBegin->_cchElem + 1 ) * sizeof( TCHAR ) );

                        WriteHelp( g_f, _T("\t(Node Begin<0s>)"), pscNodeBegin->_opcodeAndFlags & CSpliceChunkBase::SkipChunk ? _T(" Skip") : _T("") );
                        memcpy( pch, pCurr + sizeof( CSpliceChunk_NodeBegin ), pscNodeBegin->_cchElem * sizeof( TCHAR ));
                        pch[pscNodeBegin->_cchElem] = _T('\0');

                        WriteHelp( g_f, _T("\t<0s>\r\n"), pch );
                        MemFree( pch );
                        pCurr += sizeof( CSpliceChunk_NodeBegin ) + pscNodeBegin->_cchElem * sizeof( TCHAR );

                        if( pscNodeBegin->_opcodeAndFlags & CSpliceChunkBase::Extended )
                        {
                            pch = (TCHAR *)MemAlloc(Mt(Mem), ( *(long *)pCurr + 1 ) * sizeof( TCHAR ) );
                            memcpy( pch, pCurr + sizeof( long ), *(long *)pCurr * sizeof( TCHAR ) );
                            pch[*(long *)pCurr] = _T('\0');
                            WriteHelp( g_f, _T("Literal Content: <0s>\r\n"), pch );
                            MemFree( pch );
                            pCurr += *(long *)pCurr * sizeof( TCHAR )+ sizeof( long );
                        }
                    }
                    break;

                case CTreePos::NodeEnd:
                    {
                        CSpliceChunk_NodeEnd * pscNodeEnd = (CSpliceChunk_NodeEnd *)pscBase;

                        WriteHelp( g_f, _T("\t(Node End)") );
                        WriteHelp( g_f, _T("\tcIncl = <0d>\r\n"), pscNodeEnd->_cIncl );
                        pCurr += sizeof( CSpliceChunk_NodeEnd );
                    }
                    break;

                case CTreePos::Text:
                    {
                        CSpliceChunk_Text * pscText = (CSpliceChunk_Text *)pscBase;
                        TCHAR             * pch     = (TCHAR *)MemAlloc(Mt(Mem), ( pscText->_cch + 1 ) * sizeof( TCHAR ) );

                        memcpy( pch, pCurr + sizeof( CSpliceChunk_Text ), pscText->_cch * sizeof( TCHAR ) );
                        pch[ pscText->_cch ] = _T('\0');

                        WriteHelp( g_f, _T("\t(Text)\t<0s>\r\n"), pch );
                        MemFree( pch );
                        pCurr += sizeof( CSpliceChunk_Text ) + pscText->_cch * sizeof( TCHAR );
                    }
                    break;
                }
            }
        }
        else
        {
            WriteHelp( g_f, _T("\r\n") );
        }
    
        break;
        }

    case CHANGE_RECORD_PLACEHOLDER:
        {
        WriteHelp( g_f, _T("[Log Placeholder]\r\n") );
        break;
        }
    case CHANGE_RECORD_ATTRCHANGE:
        {
            CChangeRecord_AttrChange * pchrecAttr = (CChangeRecord_AttrChange *)pchrec;
            long                       cchAlloc   = max( max( pchrecAttr->_cchName, pchrecAttr->_cchOldValue ), pchrecAttr->_cchNewValue ) + 1;
            TCHAR                    * pch        = (TCHAR *)MemAlloc(Mt(Mem), cchAlloc * sizeof( TCHAR ) );
            TCHAR                    * pchSrc;

            WriteHelp( g_f, _T("[Attr Change]\tcpElement=<0d>"), pchrecAttr->_cpElement );
            if( pchrecAttr->_lFlags & ATTR_CHANGE_INLINESTYLE )
            {
                WriteHelp( g_f, _T("\tStyle:") );
            }
            else if( pchrecAttr->_lFlags & ATTR_CHANGE_RUNTIMESTYLE )
            {
                WriteHelp( g_f, _T("\tRuntimeStyle:") );
            }

            pchSrc = (TCHAR *)((BYTE *)pchrecAttr + sizeof( CChangeRecord_AttrChange ));
            memcpy( pch, pchSrc, pchrecAttr->_cchName * sizeof( TCHAR ) );
            pch[ pchrecAttr->_cchName ] = _T('\0');
            WriteHelp( g_f, _T("\tName=\"<0s>\""), pch );

            pchSrc += pchrecAttr->_cchName;
            memcpy( pch, pchSrc, pchrecAttr->_cchOldValue * sizeof( TCHAR ) );
            pch[ pchrecAttr->_cchOldValue ] = _T('\0');
            WriteHelp( g_f, _T("\tOld Value=\"<0s>\""), ( pchrecAttr->_lFlags & ATTR_CHANGE_OLDNOTSET ) ? _T("[Not Set]") : pch );

            pchSrc += pchrecAttr->_cchOldValue;
            memcpy( pch, pchSrc, pchrecAttr->_cchNewValue * sizeof( TCHAR ) );
            pch[ pchrecAttr->_cchNewValue ] = _T('\0');
            WriteHelp( g_f, _T("\tNew Value=\"<0s>\"\r\n"), ( pchrecAttr->_lFlags & ATTR_CHANGE_NEWNOTSET ) ? _T("[Not Set]") : pch );

            MemFree( pch );
        }
        break;

    default:
        WriteHelp( g_f, _T("[Unknown Entry]\r\n") );
        break;
    }
}

//+----------------------------------------------------------------+
//
//  Method: DumpQueue (DEBUG)
//
//  Synopsis: Dumps the entire queue to the dump file
//
//+----------------------------------------------------------------+
void
CLogManager::DumpQueue()
{
    CChangeRecordBase * pchrec = _pchrecHead;

    if( !InitDumpFile() )
        return;

    WriteString( g_f, _T("\r\n------------------ Log Manager Queue ----------------\r\n" ) );

    while( pchrec )
    {
        DumpRecord( (BYTE *)pchrec + sizeof(CChangeRecordBase *) );
        pchrec = pchrec->_pNext;
    }

    CloseDumpFile();
}
#endif // DBG



CLogManager::CDeletionLock::CDeletionLock( CLogManager * pLogMgr )
{ 
    Assert( _pLogMgr );
    _pLogMgr = pLogMgr; 

    // If we're the first lock, we're responsible for clearing 
    // the flag and ensuring deletion of the log manager
    _fFirstLock = !pLogMgr->TestFlag( LOGMGR_NOTIFYINGLOCK ); 
    pLogMgr->SetFlag( LOGMGR_NOTIFYINGLOCK );
}

CLogManager::CDeletionLock::~CDeletionLock()
{
    if( _fFirstLock )
    {
        _pLogMgr->ClearFlag( LOGMGR_NOTIFYINGLOCK );
        if( 0 == _pLogMgr->_aryLogs.Size() )
        {
            delete _pLogMgr;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\markup.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_HEDELEMS_HXX_
#define X_HEDELEMS_HXX_
#include "hedelems.hxx"
#endif

#ifndef X_ROOTCTX_HXX
#define X_ROOTCTX_HXX
#include "rootctx.hxx"
#endif

#ifndef X_ROOTELEM_HXX
#define X_ROOTELEM_HXX
#include "rootelem.hxx"
#endif

#ifndef X_ESCRIPT_HXX
#define X_ESCRIPT_HXX
#include "escript.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_IRANGE_HXX_
#define X_IRANGE_HXX_
#include "irange.hxx"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_POSTDATA_HXX_
#define X_POSTDATA_HXX_
#include "postdata.hxx"
#endif

#ifndef X_PROGSINK_HXX_
#define X_PROGSINK_HXX_
#include "progsink.hxx"
#endif

#ifndef X_CONNECT_HXX_
#define X_CONNECT_HXX_
#include "connect.hxx"
#endif

#ifndef X_HTC_HXX_
#define X_HTC_HXX_
#include "htc.hxx"
#endif

#ifndef X_FRAME_HXX_
#define X_FRAME_HXX_
#include "frame.hxx"
#endif

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx"
#endif

#ifndef X_DLL_HXX_
#define X_DLL_HXX_
#include "dll.hxx"
#endif

#ifndef X_TPOINTER_HXX_
#define X_TPOINTER_HXX_
#include "tpointer.hxx"
#endif

#ifndef X_ESTYLE_HXX_
#define X_ESTYLE_HXX_
#include "estyle.hxx"
#endif

#ifndef X_ELINK_HXX_
#define X_ELINK_HXX_
#include "elink.hxx"
#endif

#ifndef X_DEBUGGER_HXX_
#define X_DEBUGGER_HXX_
#include "debugger.hxx"
#endif

#ifndef X_XMLNS_HXX_
#define X_XMLNS_HXX_
#include "xmlns.hxx"
#endif

#ifndef X_FRAMESET_HXX_
#define X_FRAMESET_HXX_
#include "frameset.hxx"

#ifndef X_OPTARY_H_
#define X_OPTARY_H_
#include <optary.h>
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif

#ifndef X_OTHRGUID_H_
#define X_OTHRGUID_H_
#include "othrguid.h"
#endif
#endif

#ifndef X_NTVERP_H_
#define X_NTVERP_H_
#include "ntverp.h"
#endif

#ifndef X_PERHIST_HXX_
#define X_PERHIST_HXX_
#include "perhist.hxx"
#endif

#ifndef X_WEBOC_HXX_
#define X_WEBOC_HXX_
#include "weboc.hxx"
#endif

#ifndef X_WEBOCUTIL_H_
#define X_WEBOCUTIL_H_
#include "webocutil.h"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X_EOBJECT_HXX_
#define X_EOBJECT_HXX_
#include "eobject.hxx"
#endif

#ifndef X_PEERURLMAP_HXX_
#define X_PEERURLMAP_HXX_
#include "peerurlmap.hxx"
#endif

#ifndef X_URLHIST_H_
#define X_URLHIST_H_
#include "urlhist.h"
#endif

#ifndef X_LOGMGR_HXX_
#define X_LOGMGR_HXX_
#include "logmgr.hxx"
#endif

#ifndef X_LRREG_HXX_
#define X_LRREG_HXX_
#include "lrreg.hxx"
#endif

#ifndef X_PEERXTAG_HXX_
#define X_PEERXTAG_HXX_
#include "peerxtag.hxx"
#endif

#ifndef X_MIMEOLE_H_
#define X_MIMEOLE_H_
#define _MIMEOLE_  // To avoid having DECLSPEC_IMPORT
#include "mimeole.h"
#endif

#ifndef X_CGLYPH_HXX_
#define X_CGLYPH_HXX_
#include "cglyph.hxx"
#endif


#ifndef X_FRAMEWEBOC_HXX_
#define X_FRAMEWEBOC_HXX_
#include "frameweboc.hxx"
#endif

#ifndef X_PRIVACY_HXX_
#define X_PRIVACY_HXX_
#include "privacy.hxx"
#endif

BOOL IsSpecialUrl(LPCTSTR pchUrl);   // TRUE for javascript, vbscript, about protocols

// TODO: move to global place in trident [ashrafm]
#define IFC(expr) {hr = THR(expr); if (FAILED(hr)) goto Cleanup;}

#define EXPANDOS_DEFAULT TRUE

MtDefine(CMarkup, Tree, "CMarkup")
MtDefine(CMarkupChangeNotificationContext, CMarkup, "CMarkupChangeNotificationContext")
MtDefine(CMarkupChangeNotificationContext_aryMarkupDirtyRange_pv, CMarkupChangeNotificationContext, "CMarkupChangeNotificationContext::aryMarkupDirtyRange::pv")
MtDefine(CMarkupTextFragContext, CMarkup, "CMarkupTextFragContext")
MtDefine(CMarkupTextFragContext_aryMarkupTextFrag_pv, CMarkupTextFragContext,  "CMarkupTextFragContext::aryMarkupTextFrag::pv")
MtDefine(MarkupTextFrag_pchTextFrag, CMarkupTextFragContext,  "MarkupTextFrag::_pchTextFrag")
MtDefine(CDocFrag, CMarkup, "CDocFrag")
MtDefine(CMarkupScriptContext, Tree, "CMarkupScriptContext")
MtDefine(CMarkup_aryScriptEnqueued_pv, CMarkupScriptContext, "CMarkupScriptContext::_aryScriptEnqueued::_pv")
MtDefine(CMarkup_aryScriptUnblock_pv, CMarkupScriptContext, "CMarkupScriptContext::_aryScriptUnblock::_pv")
MtDefine(CMarkupPeerTaskContext, CMarkup, "CMarkupPeerTaskContext")
MtDefine(LoadInfo, Dwn, "LoadInfo")
MtDefine(CMarkupTransNavContext, CMarkup, "CMarkupTransNavContext");
MtDefine(CMarkupLocationContext, CMarkup, "CMarkupLocationContext");
MtDefine(CMarkupTextContext, CMarkup, "CMarkupTextContext")
MtDefine(CMarkupEditContext, CMarkup, "CMarkupEditContext")
MtDefine(CMarkup_pchDomain, CMarkup, "CMarkup::_pchDomain")
MtDefine(CMarkup_aryFocusItems_pv, CMarkup, "CMarkup::aryFocusItems")
MtDefine(CDoc_aryMarkups_pv, CDoc, "CDoc::_aryMarkups::_pv")
MtDefine(CDocDelegateNavigation_pBuffer, CDoc, "CDoc::DelegateNavigation pBuffer")
MtDefine(CPrivacyInfo, CMarkup, "CPrivacyInfo")

DeclareTag(tagMarkupCSS1Compat, "Markup", "Enforce Strict CSS1 Compatibility")
DeclareTag(tagMarkupOnLoadStatus, "Markup", "trace CMarkup::OnLoadStatus")
DeclareTag(tagNoMetaToTrident, "Markup", "Don't set generator to trident")
DeclareTag(tagCMarkup, "CMarkup", "CMarkup Methods")
DeclareTag(tagCSSWhitespacePre, "CSS", "Enable white-space:pre");

ExternTag(tagSecurityContext);
DeclareTag(tagOrphanedMarkup, "Markup", "Trace orphaned CMarkups")

PerfDbgExtern(tagPerfWatch)
PerfDbgTag(tagDocBytesRead, "Doc", "Show bytes read on done")

DeclareTag(tagPendingAssert, "Markup", "Markup pending in OnLoadStatusDone, was an assert")

extern BOOL IsScriptUrl(LPCTSTR pszURL);

#define _cxx_
#include "markup.hdl"

BEGIN_TEAROFF_TABLE(CMarkup, IMarkupContainer2)
    TEAROFF_METHOD(CMarkup, OwningDoc, owningdoc, ( IHTMLDocument2 ** ppDoc ))
    // End of IMarkupContainer methods, Begin of IMarkupContainer2 methods
    TEAROFF_METHOD(CMarkup, CreateChangeLog, createchangelog, ( IHTMLChangeSink * pChangeSink, IHTMLChangeLog ** pChangeLog, BOOL fForward, BOOL fBackward ) )
#if 0
    TEAROFF_METHOD(CMarkup, GetRootElement, getrootelement, ( IHTMLElement ** ppElement ) )
#endif // 0
    TEAROFF_METHOD(CMarkup, RegisterForDirtyRange, registerfordirtyrange, ( IHTMLChangeSink * pChangeSink, DWORD * pdwCookie ) )
    TEAROFF_METHOD(CMarkup, UnRegisterForDirtyRange, unregisterfordirtyrange, ( DWORD dwCookie ) )
    TEAROFF_METHOD(CMarkup, GetAndClearDirtyRange, getandcleardirtyrange, ( DWORD dwCookie, IMarkupPointer * pIPointerBegin, IMarkupPointer * pIPointerEnd ) )
   TEAROFF_METHOD_(CMarkup, GetVersionNumber, getversionnumber, long, () )
    TEAROFF_METHOD(CMarkup, GetMasterElement, getmasterelement, ( IHTMLElement ** ppElementMaster ) )
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CMarkup, IMarkupTextFrags)
    TEAROFF_METHOD(CMarkup, GetTextFragCount, gettextfragcount, (long *pcFrags) )
    TEAROFF_METHOD(CMarkup, GetTextFrag, gettextfrag, (long iFrag, BSTR* pbstrFrag, IMarkupPointer* pPointerFrag ) )
    TEAROFF_METHOD(CMarkup, RemoveTextFrag, removetextfrag, (long iFrag) )
    TEAROFF_METHOD(CMarkup, InsertTextFrag, inserttextfrag, (long iFrag, BSTR bstrInsert, IMarkupPointer* pPointerInsert ) )
    TEAROFF_METHOD(CMarkup, FindTextFragFromMarkupPointer, findtextfragfrommarkuppointer, (IMarkupPointer* pPointerFind, long* piFrag, BOOL* pfFragFound ) )
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CMarkup, IHTMLChangePlayback)
    TEAROFF_METHOD(CMarkup, ExecChange, execchange, ( BYTE * pbRecord, BOOL fForward ) )
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CMarkup, IPersistStream)
    // IPersist methods
    TEAROFF_METHOD( CMarkup, GetClassID, getclassid, ( CLSID * pclsid ) )
    // IPersistFile methods
    TEAROFF_METHOD( CMarkup, IsDirty, isdirty, () )
    TEAROFF_METHOD( CMarkup, Load, load, ( LPSTREAM pStream ) )
    TEAROFF_METHOD( CMarkup, Save, save, ( LPSTREAM pStream, BOOL fClearDirty ) )
    TEAROFF_METHOD( CMarkup, GetSizeMax, getsizemax, ( ULARGE_INTEGER FAR * pcbSize ) )
END_TEAROFF_TABLE()





const CBase::CLASSDESC CMarkup::s_classdesc =
{
    &CLSID_HTMLDocument,            // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                           // _pcpi
    0,                              // _dwFlags
    NULL,                           // _piidDispinterface
    &CDoc::s_apHdlDescs,            // _apHdlDesc
};

extern "C" const GUID   SID_SXmlNamespaceMapping;
extern "C" const CLSID  CLSID_HTMLDialog;

#if DBG==1
    CMarkup *    g_pDebugMarkup = NULL;        // Used in tree dump overwrite cases to see real-time tree changes
#endif

    extern BOOL  g_fThemedPlatform;

DWORD CMarkup::s_dwDirtyRangeServiceCookiePool = 0x0;

//+---------------------------------------------------------------------------
//
//  Member:     CMarkupScriptContext constructor
//
//----------------------------------------------------------------------------

CMarkupScriptContext::CMarkupScriptContext()
{
    _dwScriptCookie             = NO_SOURCE_CONTEXT;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMarkupScriptContext destructor
//
//----------------------------------------------------------------------------

CMarkupScriptContext::~CMarkupScriptContext()
{
    if (_pScriptDebugDocument)
    {
        _pScriptDebugDocument->Release();
    }

    CMarkup **  ppMarkup;
    int         i;

    for (i = _aryScriptUnblock.Size(), ppMarkup = _aryScriptUnblock;
         i > 0;
         i--, ppMarkup++)
    {
        (*ppMarkup)->SubRelease();
    }

    for (i = _aryScriptEnqueued.Size(); i > 0; i--)
    {
        _aryScriptEnqueued[i-1]->Release();
    }
}

//+-------------------------------------------------------------------
//
//  Member:     CMarkupScriptContext::RegisterMarkupForScriptUnblock
//
//--------------------------------------------------------------------

HRESULT
CMarkupScriptContext::RegisterMarkupForScriptUnblock(CMarkup * pMarkup)
{
    HRESULT     hr;

    // assert that the markup is not registered already
    Assert (-1 == _aryScriptUnblock.Find(pMarkup));

    hr = _aryScriptUnblock.Append(pMarkup);

    pMarkup->SubAddRef();

    RRETURN (hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CMarkupScriptContext::UnregisterMarkupForScriptUnblock
//
//--------------------------------------------------------------------

HRESULT
CMarkupScriptContext::UnregisterMarkupForScriptUnblock(CMarkup * pMarkup)
{
    HRESULT     hr = S_OK;

    Verify( _aryScriptUnblock.DeleteByValue(pMarkup) );

    pMarkup->SubRelease();

    RRETURN (hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CMarkupScriptContext::NotifyMarkupsScriptUnblock
//
//--------------------------------------------------------------------

HRESULT
CMarkupScriptContext::NotifyMarkupsScriptUnblock()
{
    HRESULT     hr = S_OK;
    int         c;
    CMarkup *   pMarkup;

    while (0 != (c = _aryScriptUnblock.Size()) && !_fScriptExecutionBlocked)
    {
        pMarkup = _aryScriptUnblock[c - 1];

        _aryScriptUnblock.Delete(c - 1);

        // Let that guy know that we are now unblocked
        if(!pMarkup->IsShuttingDown())
        {
            hr = THR(pMarkup->UnblockScriptExecutionHelper());
            if (hr)
                break;
        }

        // We are deleted out of the array so release the markup
        pMarkup->SubRelease();
    }

    Assert (0 == _aryScriptUnblock.Size() || _fScriptExecutionBlocked);

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CMarkupTopElemCache constructor
//
//----------------------------------------------------------------------------

CMarkupTopElemCache::CMarkupTopElemCache()
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CMarkupTopElemCache destructor
//
//----------------------------------------------------------------------------

CMarkupTopElemCache::~CMarkupTopElemCache()
{
}

CMarkupPeerTaskContext::CMarkupPeerTaskContext()
{
}

CMarkupPeerTaskContext::~CMarkupPeerTaskContext()
{
    Assert( _aryPeerQueue.Size() == 0 );
    Assert( !_dwPeerQueueProgressCookie );
    Assert( !_pElementIdentityPeerTask );
}

//+---------------------------------------------------------------------------
//
//  Member:     CMarkup constructor
//
//----------------------------------------------------------------------------

CMarkup::CMarkup ( CDoc *pDoc, BOOL fIncrementalAlloc )
#if DBG == 1 || defined(DUMPTREE)
    : _nSerialNumber( CTreeNode::s_NextSerialNumber++ )
#endif
{
    __lMarkupTreeVersion = 1;
    __lMarkupContentsVersion = 1 | MARKUP_DIRTY_FLAG;

    pDoc->SubAddRef();

    _pDoc = pDoc;

    Assert( _pDoc && _pDoc->AreLookasidesClear( this, LOOKASIDE_MARKUP_NUMBER ) );

    _LoadStatus = LOADSTATUS_UNINITIALIZED;
    _fIncrementalAlloc = fIncrementalAlloc;
    // TODO (KTam): Figure out the right check here; recall that this may be called
    // for the primary markup, so we might not have a _pWindowPrimary!

    // if (pDoc->PrimaryMarkup() && pDoc->PrimaryMarkup()->IsPrintMedia())

    _fInheritDesignMode = TRUE;  
    _fExpando           = EXPANDOS_DEFAULT;
    // _fShowWaitCursor    = FALSE;

    WHEN_DBG( ZeroMemory(_apLookAside, sizeof(_apLookAside)); )      
}

//+---------------------------------------------------------------------------
//
//  Member:     CMarkup destructor
//
//----------------------------------------------------------------------------

CMarkup::~CMarkup()
{   
    ClearLookasidePtrs();

    //
    // Destroy stylesheets collection subobject (if anyone held refs on it, we
    // should never have gotten here since the doc should then have subrefs
    // keeping it alive).  This is the only place where we directly access the
    // CBase impl. of IUnk. for the CStyleSheetArray -- we do this instead of
    // just calling delete in order to assure that the CBase part of the CSSA
    // is properly destroyed (CBase::Passivate gets called etc.)
    //

    if (HasStyleSheetArray())
    {
        CStyleSheetArray * pStyleSheets = GetStyleSheetArray();

        pStyleSheets->CBase::PrivateRelease();
        DelLookasidePtr(LOOKASIDE_STYLESHEETS);
    }

    _pDoc->SubRelease();

}

//+---------------------------------------------------------------------------
//
//  Members:    Debug only version number incrementors
//
//----------------------------------------------------------------------------

#if DBG == 1

void
CMarkup::UpdateMarkupTreeVersion ( )
{
    AssertSz(!__fDbgLockTree, "Tree was modified when it should not have been (e.g., inside ENTERTREE notification)");
    __lMarkupTreeVersion++;
    UpdateMarkupContentsVersion();
    _fFocusCacheDirty = TRUE;
}

void
CMarkup::UpdateMarkupContentsVersion ( )
{
     AssertSz(!__fDbgLockTree, "Tree was modified when it should not have been (e.g., inside ENTERTREE notification)");
    __lMarkupContentsVersion++;
    SetDirtyFlag();
}

#endif

//+---------------------------------------------------------------------------
//
//  Member:     ClearLookasidePtrs
//
//----------------------------------------------------------------------------

void
CMarkup::ClearLookasidePtrs ( )
{
    delete DelCollectionCache();
   
    Assert(_pDoc->GetLookasidePtr((DWORD *) this + LOOKASIDE_COLLECTIONCACHE) == NULL);

    Assert( !HasChangeNotificationContext() );

    Assert( !HasTransNavContext() );
    Assert(!HasWindow());

    Assert (!HasBehaviorContext());
    Assert (!HasScriptContext());
    Assert (!HasTextRangeListPtr());
    Assert (!HasCFState());
}


//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::Init
//
//----------------------------------------------------------------------------

HRESULT 
CMarkup::Init( CRootElement * pElementRoot )
{
    HRESULT     hr;

    Assert( pElementRoot );

    _tpRoot.MarkLast();
    _tpRoot.MarkRight();

    WHEN_DBG( _cchTotalDbg = 0 );
    WHEN_DBG( _cElementsTotalDbg = 0 );            

    hr = CreateInitialMarkup( pElementRoot );
    if (hr)
        goto Cleanup;    
   
    hr = THR(super::Init());
    if (hr)
        goto Cleanup;

    /* The following code is commented out because it produces some problems
     * with Outlook Express. See bug #23961. 
     */

    //if registry key says always use Strict - then do it.
    // {
    //     Doc()->UpdateFromRegistry();
    //     OPTIONSETTINGS *pos = Doc()->_pOptionSettings;
    //     if(pos && pos->nStrictCSSInterpretation == STRICT_CSS_ALWAYS)
    //         SetStrictCSS1Document(TRUE);
    // }

        
#if DBG == 1
    if(IsTagEnabled(tagMarkupCSS1Compat))   //enforce strict CSS1 compat regardless
        SetStrictCSS1Document(TRUE);        //of DOCTYPE tag for debugging
#endif



Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::UpdateReleaseHtmCtx
//
//----------------------------------------------------------------------------

HRESULT
CMarkup::UpdateReleaseHtmCtx(BOOL fShutdown)
{
    HRESULT     hr = S_OK;

    if (_pHtmCtx)
    {   
        if (!fShutdown)
        {
            if (NeedsHtmCtx())
                goto Cleanup; // still need HtmCtx, don't do anything
        }
        else
        {
            _pHtmCtx->SetLoad(FALSE, NULL, FALSE);
        }

        _pHtmCtx->Release();
        _pHtmCtx = NULL;
    }

Cleanup:
    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::UnloadContents
//
//----------------------------------------------------------------------------

HRESULT
CMarkup::UnloadContents( BOOL fForPassivate /*= FALSE*/)
{
    HRESULT          hr = S_OK;
    CElement::CLock  lockElem( Root() );
    const TCHAR *    pchDwnHeader = GetDwnHeader();
    CTreeNode::CLock lockNode;
    CDoc * pDoc = Doc();
    CMarkup::CLock markupLock(this);

    hr = THR( lockNode.Init( RootNode() ) );
    if( hr )
        goto Cleanup;

    //
    // Remove any pending FirePostedOnPropertyChange
    //
    GWKillMethodCall( Document(), ONCALL_METHOD(CDocument, FirePostedOnPropertyChange, firepostedonpropertychange), 0);
    
    if (pchDwnHeader)
    {
        CoTaskMemFree((TCHAR *) pchDwnHeader);

        IGNORE_HR(SetDwnHeader(NULL));
    }

    //
    // With native frames, it is possible that we get a mouse down on one markup
    // which can navigate and result in the mouse up triggering on the next
    // markup.  So, we can fire the dblclick event without firing the single 
    // click event.  This scenario will break home publisher (bug 89715).
    //
    // So, don't fire dbl click if we didn't see the single click on this
    // markup.
    //

    if (pDoc->_pNodeLastMouseOver == NULL
        || pDoc->_pNodeLastMouseOver->GetNodeInMarkup(this) != NULL)
    {
        pDoc->_fCanFireDblClick = FALSE;
    }

    ExecStop(FALSE, FALSE, FALSE);

    if (Root() && 
        (pDoc->_fHasViewSlave ||
         pDoc->_fBroadcastStop || 
         (GetProgSinkC() && 
            GetProgSinkC()->GetClassCounter((DWORD)-1))))
    {
        CNotification   nf;

        nf.MarkupUnload1(Root());
        Notify(&nf);
    }


    //
    // [Removed some conflicting comments by sramani & ferhane regarding IE5 Bug #103673]
    // ReleaseNotify will talk to external code which may push a message loop.  As such,
    // it should be done AFTER ExecStop/UpdateReleaseHtmCtx (so as to shut down the parser),
    // and AFTER we clear the ProgSink (so he can kill his posted method call).
    // If we see other bugs where someone's getting a posted method call where it's not
    // expected, we may want to move the ReleaseNotify further down. 
    // The UpdateReleaseHtmCtx should be done BEFORE the ProgSink gets nuked, because
    // if we're still loading, we need the progsink stuff to happen so that we stop 
    // the globe from spinning, etc.
    // (JHarding, FerhanE, SRamani)
    //

    UpdateReleaseHtmCtx(/* fShutdown = */TRUE);

    if (_pProgSink)
    {
        CProgSink * pProgSink = _pProgSink;

        _pProgSink = NULL;
        pProgSink->Detach();
        pProgSink->Release();
    }

    IGNORE_HR(ReleaseNotify());

    if (Doc()->_pElemUIActive && Doc()->_pElemUIActive->GetMarkup() == this)
        Doc()->_pElemUIActive = NULL;

    hr = SetAAreadystate(READYSTATE_UNINITIALIZED);
    if (hr)
        goto Cleanup;

    ClearDefaultCharFormat();
    ClearDwnPost();

    {
        CDwnDoc * pDwnDoc = GetDwnDoc();

        if (pDwnDoc)
        {
            pDwnDoc->Disconnect();
            pDwnDoc->Release();

            hr = SetDwnDoc(NULL);
            if (hr)
                goto Cleanup;
        }
    }

    ReleaseDataBinding();

    if (_fPicsProcessPending && _pDoc->_pClientSite)
    {
        Assert( HasWindowPending() && !HasWindow() );
        IUnknown * pUnk = DYNCAST(IHTMLWindow2, GetWindowPending());

        CVariant cvarUnk(VT_UNKNOWN);
        V_UNKNOWN(&cvarUnk) = pUnk;
        pUnk->AddRef();

        IGNORE_HR(CTExec(_pDoc->_pClientSite, &CGID_ShellDocView, SHDVID_CANCELPICSFORWINDOW, 
                         0, &cvarUnk, NULL));

        Assert( !GetPicsTarget() );

        _fPicsProcessPending = FALSE;
    }

    if (HasTransNavContext())
    {
        TerminateLookForBookmarkTask();

        CMarkupTransNavContext * ptnc = GetTransNavContext();

        if (ptnc)
        {
            ptnc->_historyCurElem.lIndex = -1L;
            ptnc->_historyCurElem.dwCode = 0;
            ptnc->_historyCurElem.lSubDivision = 0;

            ptnc->_dwHistoryIndex = 0;
 
            ptnc->_dwFlags = 0;

            ptnc->_HistoryLoadCtx.Clear();

            ClearInterface( &(ptnc->_pctPics) );

            EnsureDeleteTransNavContext(ptnc);
        }
    }

    ReleaseLayoutRectRegistry();

    //
    // text and tree
    // 
    _fHaveDifferingLayoutFlows = FALSE;

    delete _pHighlightRenSvcProvider;
    _pHighlightRenSvcProvider = NULL;

    _TxtArray.RemoveAll();


//
//  Clear defunked AccEvents -- mwatt 
//
    _pDoc->_aryAccEvents.Flush();


    hr = DestroySplayTree(!fForPassivate);
    if (hr)
        goto Cleanup;

    //
    // behaviors UnloadContents
    //

    ProcessPeerTasks(0);
    
    Assert( !HasMarkupPeerTaskContext() ||
            ( GetMarkupPeerTaskContext()->_aryPeerQueue.Size() == 0 &&
              !GetMarkupPeerTaskContext()->_pElementIdentityPeerTask ) ||
            IsProcessingPeerTasksNow() );

    GWKillMethodCall(this, ONCALL_METHOD(CMarkup, ProcessPeerTasks, processpeertasks), 0);

    delete DelMarkupPeerTaskContext();

    if (HasBehaviorContext())
    {
        CMarkupBehaviorContext *pContext = BehaviorContext();

        delete pContext->_pPeerFactoryUrlMap;
        pContext->_pPeerFactoryUrlMap = NULL;

        delete pContext->_pExtendedTagTableBooster;
        pContext->_pExtendedTagTableBooster = NULL;

    }

    // 
    // Clear off the editing context stuff
    //

    // Free cached radio groups

    if ( HasRadioGroupName())
    {   
        DelRadioGroupName();
    }

    if( HasEditRouter() )
    {
        CEditRouter *pRouter = GetEditRouter();
        pRouter->Passivate();
    }

    if( HasGlyphTable() )
    {
        delete DelGlyphTable();
    }
       
    //
    // misc
    //

    if (    pDoc->_pWindowPrimary
        &&  !pDoc->_pWindowPrimary->IsPassivating()
        &&  IsPrimaryMarkup())
    {
        pDoc->_cStylesheetDownloading         = 0;
        pDoc->_dwStylesheetDownloadingCookie += 1;
    }

    
    //
    // Restore initial state
    //

    _fIncrementalAlloc = FALSE;
    _fEnsuredFormats = FALSE;

    _fNoUndoInfo = FALSE;
    _fLoaded = FALSE;
    //_fEnableDownload = TRUE;

    _fSslSuppressedLoad = FALSE;
    _fUserInteracted = FALSE;

    _fExpando = EXPANDOS_DEFAULT;
    _fHasScriptForEvent = FALSE;

    if (HasWindow())
    {
        pDoc->_fEngineSuspended = FALSE;
        Window()->Window()->_fEngineSuspended = FALSE;
    }
    // 
    // CompatibleLayoutContext
    // 

    if (HasCompatibleLayoutContext())
    {
        DelCompatibleLayoutContext();
    }

    //
    // behaviors
    //

    delete DelBehaviorContext();

    //
    // script
    //

    if (HasScriptContext())
    {
        CMarkupScriptContext *  pScriptContext = ScriptContext();

        if (pScriptContext->_fScriptExecutionBlocked)
        {
            _pDoc->UnregisterMarkupForInPlace(this);
        }

        if (_pDoc->_pScriptCookieTable && NO_SOURCE_CONTEXT != pScriptContext->_dwScriptCookie)
        {
            IGNORE_HR(_pDoc->_pScriptCookieTable->RevokeSourceObject(pScriptContext->_dwScriptCookie, this));
        }
    }

    SetUrl(this, NULL);
    SetUrlOriginal(this, NULL);
    SetDomain(NULL);
    SetUrlSearch(this, NULL);
    
    IGNORE_HR( ReplaceMonikerPtr( NULL ) );

    delete DelLocationContext();

    delete DelPrivacyInfo();

    delete DelScriptContext();
   
    _codepage = NULL;
    _codepageFamily = NULL;
    if(!GetAAcodepageurl())
        SetURLCodePage(NULL);
    _fVisualOrder = 0;

    //
    // Dirty range service
    //

    if( HasChangeNotificationContext() )
    {
        CMarkupChangeNotificationContext * pcnc;
        MarkupDirtyRange            *   pdr;
        long                            cdr;

        pcnc = GetChangeNotificationContext();
        Assert( pcnc );

        // Clear all our flags
        pcnc->_fReentrantModification = FALSE;
        for( cdr = pcnc->_aryMarkupDirtyRange.Size(), pdr = pcnc->_aryMarkupDirtyRange; cdr; cdr--, pdr++ )
        {
            pdr->_fNotified = FALSE;
        }

        // Release all the dirty range clients
        for( cdr = pcnc->_aryMarkupDirtyRange.Size(), pdr = pcnc->_aryMarkupDirtyRange; cdr; cdr--, pdr++ )
        {
            if( !pdr->_fNotified )
            {
                pdr->_fNotified = TRUE;
                pdr->_pChangeSink->Release();
            }

            // If someone messed with anything, we have to reset our state
            if( pcnc->_fReentrantModification )
            {
                pcnc->_fReentrantModification = FALSE;
                cdr = pcnc->_aryMarkupDirtyRange.Size();
                pdr = pcnc->_aryMarkupDirtyRange;
            }
        }

        // Verify
        Assert( !pcnc->_fReentrantModification );
#if DBG==1
        for( cdr = pcnc->_aryMarkupDirtyRange.Size(), pdr = pcnc->_aryMarkupDirtyRange; cdr; cdr--, pdr++ )
        {
            Assert( pdr->_fNotified );
        }
#endif // DBG

        if (pcnc->_fOnDirtyRangeChangePosted)
        {
            GWKillMethodCall(this, ONCALL_METHOD(CMarkup, OnDirtyRangeChange, ondirtyrangechange), 0);
            pcnc->_fOnDirtyRangeChangePosted = FALSE;
        }

        if( pcnc->_pLogManager )
        {
            // Disonnect the log manager.
            Assert( pcnc->_pLogManager->_pMarkup == this );
            pcnc->_pLogManager->DisconnectFromMarkup();
        }

        delete DelChangeNotificationContext();
    }

    //
    // loading
    //

    if (_fInteractiveRequested)
    {
        Doc()->UnregisterMarkupForModelessEnable(this);
        _fInteractiveRequested = FALSE;
    }

    _LoadStatus = LOADSTATUS_UNINITIALIZED;

    if (HasStyleSheetArray())
    {
        CStyleSheetArray * pStyleSheets = GetStyleSheetArray();
        pStyleSheets->Free( );  // Force our stylesheets collection to release its
                                    // refs on stylesheets/rules.  We will rel in passivate,
                                    // delete in destructor.
    }

    {
        IStream * pStmDirty = GetStmDirty();

        if (pStmDirty)
        {
            ReleaseInterface(pStmDirty);
            hr = SetStmDirty(NULL);
            if (hr)
                goto Cleanup;
        }
    }   

     // free the focus items array
    CAryFocusItem * paryFocusItem;    
   
    if ((paryFocusItem = GetFocusItems(FALSE)) != NULL)
    {
        AssertSz (!paryFocusItem->Size(), "Focus item array not empty in CMarkup destructor");
        paryFocusItem->DeleteAll();
        delete paryFocusItem;

        FindAAIndexAndDelete ( DISPID_INTERNAL_FOCUSITEMS, CAttrValue::AA_Internal );    
    }

    DelScriptCollection();    

    if( IsPrimaryMarkup() )
    {
        Assert( !Doc()->_fClearingOrphanedMarkups );
        Doc()->_fClearingOrphanedMarkups = TRUE;

        while( Doc()->_aryMarkups.Size() )
        {
            int c;
            CMarkup ** ppMarkup;
            CDoc::CAryMarkups aryMarkupsCopy;

            aryMarkupsCopy.Copy( Doc()->_aryMarkups, FALSE );
            Doc()->_aryMarkups.DeleteAll();

            for( c = aryMarkupsCopy.Size(), ppMarkup = aryMarkupsCopy; c; ppMarkup++, c-- )
            {
                TraceTag(( tagOrphanedMarkup, "Orphaned markup in array: %d(%x)", (*ppMarkup)->_nSerialNumber, (*ppMarkup) ));
                Assert( (*ppMarkup)->IsOrphanedMarkup() );
                (*ppMarkup)->SubAddRef();
            }

            for( c = aryMarkupsCopy.Size(), ppMarkup = aryMarkupsCopy; c; ppMarkup++, c-- )
            {
                if( !(*ppMarkup)->IsPassivated() && !(*ppMarkup)->IsPassivating() )
                {
                    TraceTag(( tagOrphanedMarkup, "Orphaned markup tearing down: %d(%x)", (*ppMarkup)->_nSerialNumber, (*ppMarkup) ));
                    Assert( (*ppMarkup)->HasTextContext() );

                    (*ppMarkup)->GetTextContext()->_fOrphanedMarkup = FALSE;
                    (*ppMarkup)->TearDownMarkup( /* fStop= */ TRUE, /* fSwitch= */ FALSE);
                }
                (*ppMarkup)->SubRelease();
            }
        }

        Doc()->_fClearingOrphanedMarkups = FALSE;
    }


    //if registry key says always use Strict - then do it.
    {
        OPTIONSETTINGS *pos = Doc()->_pOptionSettings;
        if (pos)
        {
            if(pos->nStrictCSSInterpretation == STRICT_CSS_ALWAYS)
                SetStrictCSS1Document(TRUE);
            else // Reset Strict CSS1 mode to default (not Strict CSS1) in case markup is reused
                SetStrictCSS1Document(FALSE);
        }
    }

Cleanup:

    // TODO: we should be able to assert this but we keep seeing it
    // in a really strange stress case.  Revisit later.
    // Assert(!_aryANotification.Size());
    
    RRETURN( hr );
}

//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::Passivate
//
//----------------------------------------------------------------------------

void
CMarkup::Passivate()
{
    //
    // Release everything
    //

    Assert(!_fWindowPending);

    if( IsOrphanedMarkup() )
    {
        Verify( !SetOrphanedMarkup( FALSE ) );
    }

    if(Document() && Document()->HasPageTransitionInfo() && 
        Document()->GetPageTransitionInfo()->GetTransitionToMarkup() == this)
    {
        // Current markup is participating in a page transition, abort the transition
        Document()->CleanupPageTransitions(0);
    }

    IGNORE_HR( UnloadContents( TRUE ) );

    if( HasEditRouter() )
    {
        CEditRouter *pRouter = GetEditRouter();
        pRouter->Passivate();

        delete DelEditRouter();
    }

    if( HasEditContext() )
    {
        delete DelEditContext();
    }

    if( HasTextContext() )
    {
        delete DelTextContext();
    }

    // Release stylesheets subobj, which will subrel us
    if ( HasStyleSheetArray() )
    {
        CStyleSheetArray * pStyleSheets = GetStyleSheetArray();
        pStyleSheets->Release();
        // we will delete in destructor
    }

    ClearWindow();
    ReleaseAryElementReleaseNotify();

    if (HasDocumentPtr())
    {
        DelDocumentPtr()->PrivateRelease();
    }

    if( HasWindowedMarkupContextPtr() )
    {
        DelWindowedMarkupContextPtr()->SubRelease();
    }

    //
    // super
    //

    super::Passivate();
}

void
CMarkup::ClearWindow(BOOL fFromRestart /*= FALSE*/)
{
    COmWindowProxy *pWindow = DelWindow();

    TraceTag((tagCMarkup, "CMarkup::ClearWindow() - this:[0x%x] Proxy Window:[0x%x] CWindow:[0x%x]",
              this, pWindow, pWindow ? pWindow->_pCWindow : NULL));

    _fWindow = FALSE;
    Assert( !_fWindowPending );

    if (pWindow)
    {
        COmWindowProxy * pProxySecure = pWindow->GetSecureWindowProxy(TRUE);

        Assert(pProxySecure);

        delete *pProxySecure->GetAttrArray();
        pProxySecure->SetAttrArray(NULL);

        pProxySecure->Release();

        pWindow->OnClearWindow(this, fFromRestart);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::DoEmbedPointers
//
//  Synopsis:   Puts unembedded pointers into the splay tree.
//
//----------------------------------------------------------------------------

#if DBG!=1
#pragma optimize(SPEED_OPTIMIZE_FLAGS, on)
#endif

HRESULT
CMarkup::DoEmbedPointers ( )
{
    HRESULT hr = S_OK;
    
    //
    // This should only be called from EmbedPointers when there are any
    // outstanding
    //
    
#if DBG == 1
    
    //
    // Make sure all unembedded pointers are correct
    //
    
    {
        for ( CMarkupPointer * pmp = _pmpFirst ; pmp ; pmp = pmp->_pmpNext )
        {
            Assert( pmp->Markup() == this );
            Assert( ! pmp->_fEmbedded );
            Assert( pmp->_ptpRef );
            Assert( pmp->_ptpRef->GetMarkup() == this );
            Assert( ! pmp->_ptpRef->IsPointer() );

            if (pmp->_ptpRef->IsText())
                Assert( pmp->_ichRef <= pmp->_ptpRef->Cch() );
            else
                Assert( pmp->_ichRef == 0 );
        }
    }
#endif

    while ( _pmpFirst )
    {
        CMarkupPointer * pmp;
        CTreePos *       ptpNew;

        //
        // Remove the first pointer from the list
        //
        
        pmp = _pmpFirst;
        
        _pmpFirst = pmp->_pmpNext;
        
        if (_pmpFirst)
            _pmpFirst->_pmpPrev = NULL;
        
        pmp->_pmpNext = pmp->_pmpPrev = NULL;

        Assert( pmp->_ichRef == 0 || pmp->_ptpRef->IsText() );

        //
        // Consider the case where two markup pointers point in to the the
        // middle of the same text pos, where the one with the larger ich
        // occurs later in the list of unembedded pointers.  When the first
        // is encountered, it will split the text pos, leaving the second
        // with an invalid ich.
        //
        // Here we check to see if the ich is within the text pos.  If it is
        // not, then the embedding of a previous pointer must have split the
        // text pos.  In this case, we scan forward to locate the right hand
        // side of that split, and re-adjust this pointer!
        //

        if (pmp->_ptpRef->IsText() && pmp->_ichRef > pmp->_ptpRef->Cch())
        {
            //
            // If we are out of range, then there better very well be a pointer
            // next which did it.
            //
            
            Assert( pmp->_ptpRef->NextTreePos()->IsPointer() );

            while ( pmp->_ichRef > pmp->_ptpRef->Cch() )
            {
                Assert( pmp->_ptpRef->IsText() && pmp->_ptpRef->Cch() > 0 );
            
                pmp->_ichRef -= pmp->_ptpRef->Cch();

                do
                    { pmp->_ptpRef = pmp->_ptpRef->NextTreePos(); }
                while ( ! pmp->_ptpRef->IsText() );
            }
        }
        
        //
        // See if we have to split a text pos
        //

        if (pmp->_ptpRef->IsText() && pmp->_ichRef < pmp->_ptpRef->Cch())
        {
            Assert( pmp->_ichRef != 0 );
            
            hr = THR( Split( pmp->_ptpRef, pmp->_ichRef ) );

            if (hr)
                goto Cleanup;
        }
        
        ptpNew = NewPointerPos( pmp, pmp->Gravity(), pmp->Cling() );

        if (!ptpNew)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        //
        // We should always be at the end of a text pos.
        //

        Assert( ! pmp->_ptpRef->IsText() || pmp->_ichRef == pmp->_ptpRef->Cch() );

        hr = THR( Insert( ptpNew, pmp->_ptpRef, FALSE ) );

        if (hr)
            goto Cleanup;

        pmp->_fEmbedded = TRUE;
        pmp->_ptpEmbeddedPointer = ptpNew;
        pmp->_ichRef = 0;
    }

Cleanup:

    RRETURN( hr );
}

//+---------------------------------------------------------------
//
//  Member:         CMarkup::IsSkeletonMode
//
//  [ htc dependency ]
//
//---------------------------------------------------------------

BOOL
CMarkup::IsSkeletonMode()
{
    CMarkupBehaviorContext * pBehaviorContext = BehaviorContext();
    if (!pBehaviorContext || !pBehaviorContext->_pHtmlComponent)
    {
        return FALSE;
    }
    else
    {
        return pBehaviorContext->_pHtmlComponent->IsSkeletonMode();
    }
}

//+---------------------------------------------------------------
//
//  Member:         CMarkup::CanCommitScripts
//
//  [ htc dependency ]
//
//---------------------------------------------------------------

BOOL
CMarkup::CanCommitScripts(CMarkup * pMarkup, CScriptElement *pelScript)
{
    HRESULT                     hr;
    BOOL                        fCanCommitScripts = FALSE;
    PUA_Flags                   pua = PUA_None;
    CMarkupBehaviorContext *    pBehaviorContext;

    if (pMarkup)
    {
        pBehaviorContext = pMarkup->BehaviorContext();

        // if a behavior-owned markup
        if (pBehaviorContext && pBehaviorContext->_pHtmlComponent)
        {
            // Does the behavior support edit mode?
            if( !pBehaviorContext->_pHtmlComponent->CanCommitScripts(pelScript) )
                return FALSE;

            // Since element behaviors are basically first-class elements, 
            // they don't have to respect the no script loadf.
            if( pBehaviorContext->_pHtmlComponent->IsElementBehavior() )
            {
                pua = PUA_NoLoadfCheckForScripts;
            }
        }

        fCanCommitScripts = TRUE;

        if (IsSpecialUrl(CMarkup::GetUrl(pMarkup)))
        {
            hr = THR(pMarkup->ProcessURLAction(URLACTION_SCRIPT_RUN, 
                                                &fCanCommitScripts,
                                                0, 
                                                NULL, 
                                                pMarkup->GetAAcreatorUrl(),
                                                NULL,
                                                0, 
                                                pua));
        }
        else
        {
            hr = THR(pMarkup->ProcessURLAction(URLACTION_SCRIPT_RUN, 
                                                &fCanCommitScripts,
                                                0,
                                                NULL,
                                                NULL,
                                                NULL,
                                                0,
                                                pua));
        }

        if (hr)
            fCanCommitScripts = FALSE;

        return fCanCommitScripts;
    }
    else
    {
        // TODO (JHarding): Somehow, I don't trust the caller.  This is the lightweight htc case.
        // the question "can commit scripts?" is asked outside of a markup;
        // the caller is reponsible for making the security decision
        return TRUE;
    }
}

#if DBG!=1
#pragma optimize("", on)
#endif


//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::GetDD
//
//  Synopsis:   returns Default Dispatch object for this markup
//
//  [ htc dependency ]
//
//----------------------------------------------------------------------------

CBase *
CMarkup::GetDefaultDocument()
{
    CMarkupBehaviorContext *pBehaviorContext = BehaviorContext();

    if (pBehaviorContext && pBehaviorContext->_pHtmlComponent)
        return (CBase*) &pBehaviorContext->_pHtmlComponent->_DD;
    else
    {        
        CDocument *pDocument = NULL;
        EnsureDocument(&pDocument);
        return pDocument;
    }
}

CScriptCollection *
CMarkup::GetScriptCollection(BOOL fCreate /* TRUE */)
{
    CScriptCollection * pScriptCollection = NULL;
    CMarkup * pScriptCollectionMarkup;       
   
    // NOTE do not check for _fInDestroySplayTree here: script collection should be available
    // during destroy splay tree to allow HTCs run onDetach code (or else bug 95913)
    if (IsPassivating() ||  Doc()->IsPassivating() ||  Doc()->IsPassivated())
        goto Cleanup;

    pScriptCollectionMarkup = GetNearestMarkupForScriptCollection();
    
    Assert(pScriptCollectionMarkup);

    if (!pScriptCollectionMarkup->HasScriptCollection() && fCreate)
    {         
        if (pScriptCollectionMarkup->SetScriptCollection())
           goto Cleanup;                             
    }
    pScriptCollection = (CScriptCollection *) pScriptCollectionMarkup->GetLookasidePtr(LOOKASIDE_SCRIPTCOLLECTION);            

 
    Assert (pScriptCollection || !fCreate);                             

Cleanup:       
    return pScriptCollection;
}


HRESULT
CMarkup::SetScriptCollection()
{
    HRESULT             hr = E_FAIL;
    CScriptCollection * pScriptCollection = NULL;          
 
    Assert(this == GetNearestMarkupForScriptCollection());

    if (!HasWindowPending())
        goto Cleanup;
   
    pScriptCollection = new CScriptCollection();
    if (!pScriptCollection)                  
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;        
    }

    hr = THR(pScriptCollection->Init(Doc(), GetWindowPending()));
    if (hr)
        goto Cleanup;

    hr = SetLookasidePtr(LOOKASIDE_SCRIPTCOLLECTION, pScriptCollection);    
    pScriptCollection = NULL;

Cleanup:
    if (pScriptCollection)
        pScriptCollection->Release();
    return hr;
}

void
CMarkup::TearDownMarkup(BOOL fStop /* = TRUE */, BOOL fSwitch /* = FALSE */)
{
    CDoc *  pDoc = Doc();    
    CWindow * pWindow = HasWindow() ? Window()->Window() : NULL;

    CMarkup::CLock MarkupLock(this);  // UnloadContents can make us passivate, which would be bad
    CDoc::CLock Lock(pDoc, SERVERLOCK_BLOCKPAINT | FORMLOCK_UNLOADING); // TODO (lmollico): move the lock to CMarkup

    if (fStop)
    {
        if (!fSwitch && pWindow)
            pWindow->DetachOnloadEvent();

        IGNORE_HR(UnloadContents());
        
        if (!fSwitch && pWindow && pWindow->_pMarkupPending)
            pWindow->ReleaseMarkupPending(pWindow->_pMarkupPending);
    }
    else if (HasScriptContext())
    {
        delete DelScriptContext();
    }

    DelScriptCollection();
}

void
CMarkup::DelScriptCollection()
{
    if (HasScriptCollection())
    {
        ((CScriptCollection *) DelLookasidePtr(LOOKASIDE_SCRIPTCOLLECTION))->Release();          
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::EnsureDocument
//
//----------------------------------------------------------------------------

HRESULT
CMarkup::EnsureDocument(CDocument ** ppDocument)
{
    HRESULT     hr = S_OK;
    CDocument * pDocument = Document();

    // We shouldn't have a document if we are pending 
    // -- we should switch first
    Assert( !_fWindowPending );

    if (!pDocument)
    {
        // The ref from creation will be owned by the
        // CMarkup
        pDocument = new CDocument( this );
        if (!pDocument)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        Assert (pDocument->_pWindow == NULL);

        hr = THR(SetDocumentPtr(pDocument));
        if (hr)
        {
            // oops, we couldn't set the document pointer --
            // we are pretty much stuck here -- at least
            // let go of the document we just created.
            pDocument->PrivateRelease();

            goto Cleanup;
        }
    }

    if (ppDocument)
    {
        *ppDocument = pDocument;
    }

Cleanup:
    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::Document
//
//----------------------------------------------------------------------------

CDocument *
CMarkup::Document()
{
    // We shouldn't have a document if we are pending 
    // -- we should switch first
    Assert( !(_fWindowPending && HasDocument())); 

    if (HasWindow())
    {
        Assert (Window()->Window()->HasDocument());
        return Window()->Window()->Document();
    }
    else
    {
        return GetDocumentPtr();
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::EnsureScriptContext
//
//----------------------------------------------------------------------------

HRESULT
CMarkup::EnsureScriptContext (CMarkupScriptContext ** ppScriptContext)
{
    HRESULT                 hr = S_OK;
    CMarkupScriptContext *  pScriptContext = ScriptContext();
    CScriptCollection *     pScriptCollection;
    
    // Don't create script context for paste markup
    if (!pScriptContext)
    {
        //
        // create the context
        //

        pScriptContext = new CMarkupScriptContext();
        if (!pScriptContext)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = THR(SetScriptContext(pScriptContext));
        if (hr)
            goto Cleanup;
       
        //
        // init namespace
        //

        // TODO (sramani): The scriptcontext shud really not be created at all for paste markups,
        // but to do this the parser code has to be modified. Something todo for v4
        if (!_fMarkupServicesParsing)
        {
            if (HasWindowPending()) 
            {
                Assert(!IsHtcMarkup());
                hr = THR(pScriptContext->_cstrNamespace.Set(DEFAULT_OM_SCOPE));

                // don't do AddNamedItem for PrimaryMarkup: this is done once when we create script engines.
                // we don't want to be re-registering DEFAULT_OM_SCOPE namespace each time in refresh
            }
            else
            {
                CHtmlComponent *pFactory = NULL;
                CHtmlComponent *pComponent = HasBehaviorContext() ? BehaviorContext()->_pHtmlComponent : NULL;
                if (pComponent)
                {
                    pFactory = pComponent->_pConstructor->_pFactoryComponent;
                    Assert(pFactory);
                }

                if (pComponent && pComponent->_fFactoryComponent)
                {
                    hr = THR(_pDoc->GetUniqueIdentifier(&pScriptContext->_cstrNamespace));
                    if (hr)
                        goto Cleanup;
                }
                else if (!pFactory || !pFactory->_fClonedScript)
                {
                    pScriptCollection = GetScriptCollection();
                    if (pScriptCollection)
                    {                     
                        CBase *pBase = GetDefaultDocument();
                        if (!pBase)
                        {
                            hr = E_FAIL;
                            goto Cleanup;
                        }

                        IGNORE_HR(pScriptCollection->AddNamedItem(
                              /* pchNamespace = */NULL, pScriptContext,
                              (IUnknown*)(IPrivateUnknown*)pBase));
                    }
                }
                else
                {
                    Assert(!pFactory->_fLightWeight);
                    Assert(!pFactory->_pScriptContext);
                    Assert(pFactory->GetMarkup()->HasScriptContext());
                    Assert(pFactory->GetMarkup()->ScriptContext()->GetNamespace());
                    pScriptContext->_cstrNamespace.SetPch(pFactory->GetMarkup()->ScriptContext()->GetNamespace());
                    pScriptContext->_fClonedScript = TRUE;
                }
            }

            //
            // script debugger initialization wiring
            //

            {
                CScriptDebugDocument::CCreateInfo   createInfo(this, HtmCtx());
            
                hr = THR(CScriptDebugDocument::Create(&createInfo, &pScriptContext->_pScriptDebugDocument));
                if (hr)
                    goto Cleanup;
            }
        }
    }


    if (ppScriptContext)
    {
        *ppScriptContext = pScriptContext;
    }

Cleanup:
    RRETURN (hr);
}

//+----------------------------------------------------------------------------
//  
//  Method:     CMarkup::EnsureMarkupPeerTaskContext
//  
//  Synopsis:   Ensures a CMarkupPeerTaskContext for this markup
//  
//  Returns:    HRESULT
//  
//  Arguments:
//          CMarkupPeerTaskContext ** ppPTC - for returning the PTC
//  
//+----------------------------------------------------------------------------

HRESULT
CMarkup::EnsureMarkupPeerTaskContext( CMarkupPeerTaskContext ** ppPTC /*=NULL*/ )
{
    HRESULT hr = S_OK;
    CMarkupPeerTaskContext * pPTC = HasMarkupPeerTaskContext() ? GetMarkupPeerTaskContext() : NULL;

    // Only a frame should have one of these.
    Assert( GetFrameOrPrimaryMarkup() == this );

    // Try to make and set one if needed
    if( !pPTC )
    {
        pPTC = new CMarkupPeerTaskContext();
        if( !pPTC )
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = THR( SetMarkupPeerTaskContext( pPTC ) );
        if( hr )
        {
            delete pPTC;
            pPTC = NULL;
            goto Cleanup;
        }
    }

Cleanup:
    if( ppPTC )
    {
        *ppPTC = pPTC;
    }

    RRETURN( hr );
}

//+---------------------------------------------------------------
//
//  Member:         CMarkup::NeedsHtmCtx
//
//  [ htc dependency ]
//
//---------------------------------------------------------------

BOOL
CMarkup::NeedsHtmCtx()
{
    // frame or primary markups always need HtmCtx (for view source)
    if (this == GetFrameOrPrimaryMarkup())
        return TRUE;

    // script debug documents always need it (for view source analogue)
    if (HasScriptContext() && ScriptContext()->_pScriptDebugDocument)
        return TRUE;

    // factory behavior component always need it
    if (HasBehaviorContext())
    {
        CMarkupBehaviorContext * pBehaviorContext = BehaviorContext();
        if (pBehaviorContext &&
            pBehaviorContext->_pHtmlComponent &&
            pBehaviorContext->_pHtmlComponent->_fFactoryComponent)
            return TRUE;
    }

    return  FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::PrivateQueryInterface
//
//  TODO (anandra): This should go away completely.
//  
//----------------------------------------------------------------------------

HRESULT
CMarkup::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    HRESULT      hr = S_OK;
    const void * apfn = NULL;
    void *       pv = NULL;
    void *       appropdescsInVtblOrder = NULL;
    const IID * const * apIID = NULL;

    *ppv = NULL;

    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_TEAROFF(this, IMarkupContainer2, NULL)
        QI_TEAROFF2(this, IMarkupContainer, IMarkupContainer2, NULL)
        QI_TEAROFF(this, IMarkupTextFrags, NULL)
        QI_TEAROFF(this, IHTMLChangePlayback, NULL)
        QI_TEAROFF(this, IPersistStream, NULL)
        
    default:
        if (IsEqualIID(iid, CLSID_CMarkup))
        {
            *ppv = this;
            return S_OK;
        }
        else if (iid == IID_IDispatchEx || iid == IID_IDispatch)
        {
            hr = THR(EnsureDocument());
            if (hr)
                RRETURN (hr);
         
            pv = (void *) Document();
            apIID = g_apIID_IDispatchEx;
            apfn = (const void *) CDocument::s_apfnIDispatchEx;
        }
        else if (iid == IID_IHTMLDocument || iid == IID_IHTMLDocument2)
        {
            hr = THR(EnsureDocument());
            if (hr)
                RRETURN (hr);
         
            pv = (void *) Document();
            apfn = (const void *) CDocument::s_apfnpdIHTMLDocument2;
            appropdescsInVtblOrder = (void *) CDocument::s_ppropdescsInVtblOrderIHTMLDocument2; 
        }
        else if (iid == IID_IHTMLDocument3)
        {
            hr = THR(EnsureDocument());
            if (hr)
                RRETURN (hr);
         
            pv = (void *) Document();
            apfn = (const void *) CDocument::s_apfnpdIHTMLDocument3;
            appropdescsInVtblOrder = (void *) CDocument::s_ppropdescsInVtblOrderIHTMLDocument3; 
        }
        else if (iid == IID_IHTMLDocument4)
        {
            hr = THR(EnsureDocument());
            if (hr)
                RRETURN (hr);
         
            pv = (void *) Document();
            apfn = (const void *) CDocument::s_apfnpdIHTMLDocument4;
            appropdescsInVtblOrder = (void *) CDocument::s_ppropdescsInVtblOrderIHTMLDocument4; 
        }
        else if (iid == IID_IHTMLDocument5)
        {
            hr = THR(EnsureDocument());
            if (hr)
                RRETURN (hr);
         
            pv = (void *) Document();
            apfn = (const void *) CDocument::s_apfnpdIHTMLDocument5;
            appropdescsInVtblOrder = (void *) CDocument::s_ppropdescsInVtblOrderIHTMLDocument5;
        }
        else if (iid == IID_IConnectionPointContainer)
        {
            *((IConnectionPointContainer **)ppv) = new CConnectionPointContainer(
                (CBase *) this, (IUnknown *)(IPrivateUnknown *) this);
            if (!*ppv)
                RRETURN(E_OUTOFMEMORY);
        }
        else if (iid == IID_IServiceProvider )
        {
            pv = Doc();
            apfn = CDoc::s_apfnIServiceProvider;
        }
        else if (iid == IID_IOleWindow)
        {
            pv = Doc();
            apfn = CDoc::s_apfnIOleInPlaceObjectWindowless;
        }
        else if (iid == IID_IOleCommandTarget)
        {
            pv = Doc();
            apfn = CDoc::s_apfnIOleCommandTarget;
        }
        else if (iid == IID_IMarkupServices || iid == IID_IMarkupServices2)
        {
            pv = Doc();
            apfn = CDoc::s_apfnIMarkupServices2;
        }
        else if (iid == IID_IHighlightRenderingServices )
        {
            pv = Doc();
            apfn = CDoc::s_apfnIHighlightRenderingServices;
        }       
        else if (iid == IID_IDisplayServices)
        {
            pv = Doc();
            apfn = CDoc::s_apfnIDisplayServices;
        }
#if DBG ==1
        else if (iid == IID_IEditDebugServices)
        {
            pv = Doc();
            apfn = CDoc::s_apfnIEditDebugServices;
        }    
#endif
        else if( iid == IID_IIMEServices )
        {
            pv = Doc();
            apfn = CDoc::s_apfnIIMEServices;
        }
        else
        {
            RRETURN(THR_NOTRACE(super::PrivateQueryInterface(iid, ppv)));
        }

        if (pv)
        {
            Assert(apfn);
            hr = THR(CreateTearOffThunk(
                    pv, 
                    apfn, 
                    NULL, 
                    ppv, 
                    (IUnknown *)(IPrivateUnknown *)this, 
                    *(void **)(IUnknown *)(IPrivateUnknown *)this,
                    QI_MASK | ADDREF_MASK | RELEASE_MASK,
                    apIID,
                    appropdescsInVtblOrder));
            if (hr)
                RRETURN(hr);
        }
    }

    // any unknown interface will be handled by the default above
    Assert(*ppv);

    (*(IUnknown **)ppv)->AddRef();

    DbgTrackItf(iid, "CMarkup", FALSE, ppv);

    return S_OK;

}

//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::PrivateQueryInterface
//
//----------------------------------------------------------------------------

HRESULT
CMarkup::QueryService(REFGUID rguidService, REFIID riid, void ** ppvObject)
{
    HRESULT     hr;

    Assert (Doc()->_dwTID == GetCurrentThreadId());

    if (IsEqualGUID(rguidService, SID_SXmlNamespaceMapping))
    {
        CMarkupBehaviorContext *    pContext = BehaviorContext();
        CExtendedTagTable *         pExtendedTagTable = NULL;
        
        if (pContext && pContext->_pExtendedTagTable)
        {
            pExtendedTagTable = pContext->_pExtendedTagTable;
        }
        else if (HtmCtx())
        {
            pExtendedTagTable = HtmCtx()->GetExtendedTagTable();
        }

        if (pExtendedTagTable)
        {
            hr = THR(pExtendedTagTable->QueryInterface(riid, ppvObject));
            goto Cleanup; // done
        }
    }

    if (Document())
    {
        hr = THR_NOTRACE(Document()->QueryService(rguidService, riid, ppvObject));
    }
    else
    {
        hr = THR_NOTRACE(_pDoc->QueryService(rguidService, riid, ppvObject));
    }
    
Cleanup:
    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::Load
//
//----------------------------------------------------------------------------

HRESULT
CMarkup::Load(IStream * pStream, CMarkup * pContextMarkup, BOOL fAdvanceLoadStatus, HTMPASTEINFO * phtmpasteinfo)
{
    HRESULT         hr;
    HTMLOADINFO     htmloadinfo;

    htmloadinfo.pDoc                = _pDoc;
    htmloadinfo.pMarkup             = this;
    htmloadinfo.pContextMarkup      = pContextMarkup;
    htmloadinfo.pDwnDoc             = GetWindowedMarkupContext()->GetDwnDoc();
    if( !htmloadinfo.pDwnDoc )
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }


    htmloadinfo.pDwnDoc->SetLoadf( htmloadinfo.pDwnDoc->GetLoadf() | DLCTL_NO_METACHARSET );
    htmloadinfo.pVersions           = _pDoc->_pVersions;
    htmloadinfo.pchUrl              = _pDoc->GetPrimaryUrl();
#if 0
    htmloadinfo.pchUrl              = CMarkup::GetUrl(GetWindowedMarkupContext());
#endif 
    htmloadinfo.fParseSync          = TRUE;
    htmloadinfo.fAdvanceLoadStatus  = fAdvanceLoadStatus;

    htmloadinfo.phpi                = phtmpasteinfo;
    htmloadinfo.pstm                = pStream;

    htmloadinfo.fPendingRoot        = IsPendingRoot();

    hr = THR(Load(&htmloadinfo));

Cleanup:
    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::Load
//
//----------------------------------------------------------------------------

HRESULT
CMarkup::Load(
    IMoniker *                          pMoniker,
    IBindCtx *                          pBindCtx,
    BOOL                                fNoProgressUI,
    BOOL                                fOffline,
    FUNC_TOKENIZER_FILTEROUTPUTTOKEN *  pfnTokenizerFilterOutputToken,
    BOOL                                fDownloadHtc /*=FALSE*/ )
{
    HRESULT         hr;
    HTMLOADINFO     htmloadinfo;
    LPTSTR          pchUrl = NULL;

    hr = THR(pMoniker->GetDisplayName(pBindCtx, NULL, &pchUrl));
    if (hr)
        goto Cleanup;

    htmloadinfo.pDoc                            = _pDoc;
    htmloadinfo.pMarkup                         = this;
    htmloadinfo.pDwnDoc                         = GetWindowedMarkupContext()->GetDwnDoc();
    if( !htmloadinfo.pDwnDoc )
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    htmloadinfo.pDwnDoc->SetLoadf( htmloadinfo.pDwnDoc->GetLoadf() | DLCTL_NO_METACHARSET );
    htmloadinfo.pInetSess                       = TlsGetInternetSession();
    htmloadinfo.pmk                             = pMoniker;
    htmloadinfo.pbc                             = pBindCtx;
    htmloadinfo.pchUrl                          = pchUrl;
    htmloadinfo.fNoProgressUI                   = fNoProgressUI;
    htmloadinfo.fOffline                        = fOffline;
    htmloadinfo.pfnTokenizerFilterOutputToken   = pfnTokenizerFilterOutputToken;
    htmloadinfo.fDownloadHtc                    = fDownloadHtc;

    htmloadinfo.fPendingRoot                    = IsPendingRoot();
    
    hr = THR(Load(&htmloadinfo));

Cleanup:
    CoTaskMemFree(pchUrl);

    RRETURN (hr);
}

BOOL PathIsFilePath(LPCWSTR lpszPath)
{
    if ((lpszPath[0] == TEXT('\\')) || (lpszPath[0] != TEXT('\0') && lpszPath[1] == TEXT(':')))
        return TRUE;

    return UrlIsFileUrl(lpszPath);
}


//+---------------------------------------------------------------------------
//
//
//
//----------------------------------------------------------------------------
HRESULT
CMarkup::EnsureMoniker(struct CDoc::LOADINFO * pLoadInfo)
{
    IMoniker *  pmkNew = NULL;
    HRESULT     hr = S_OK;

    // If there is a file name, regardless of the fact that we have a moniker
    // or not, use the file name.
    if (pLoadInfo->pchFile)
    {
        // Now load the new contents from the appropriate source

        // Make a moniker if all we have is a filename
        // (Also do conversion of an RTF file to a temp HTML file if needed)

        TCHAR achTemp[MAX_PATH];
        TCHAR achPath[MAX_PATH];
        TCHAR * pchExt;
        TCHAR achUrl[pdlUrlLen];
        ULONG cchUrl;
        ULONG cchPath;

        _tcsncpy(achTemp, pLoadInfo->pchFile, MAX_PATH);
        achTemp[MAX_PATH-1] = 0;

        // We now have a file to load from.
        // Make a URL moniker out of it.

        if (!PathIsFilePath(achTemp))
        {
            hr = E_UNEXPECTED;
            goto Cleanup;
        }
        cchPath = GetFullPathName(achTemp, ARRAY_SIZE(achPath), achPath, &pchExt);
        if (!cchPath || cchPath > ARRAY_SIZE(achPath))
        {
            hr = E_UNEXPECTED;
            goto Cleanup;
        }

        cchUrl = ARRAY_SIZE(achUrl);
        hr = THR(UrlCreateFromPath(achPath, achUrl, &cchUrl, 0));
        if (hr)
            goto Cleanup;

        hr = THR(CreateURLMoniker(NULL, achUrl, &pmkNew));
        if (hr)
            goto Cleanup;

        ReplaceInterface(&pLoadInfo->pmk, pmkNew);
    }
    else if (!pLoadInfo->pmk && pLoadInfo->pchDisplayName)
    {
        // Make a moniker if all we have is a URL
        hr = THR(CreateURLMoniker(NULL, pLoadInfo->pchDisplayName, &pmkNew));
        if (hr)
            goto Cleanup;

        ReplaceInterface(&pLoadInfo->pmk, pmkNew);
    }

Cleanup:

    ClearInterface(&pmkNew);

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//  Function    :   DetermineUrlOfMarkup
//  Parameters  :   
//                  pLoadInfo:  Pointer to the loadinfo structure the LoadFromInfo
//                              is called with.
//                  ppchUrl  :  Address of the TCHAR * to receive the URL to be
//                              loaded into this markup
//                  ppchTask :  Address of the TCHAR * to receive the URL that 
//                              was carried within the moniker. The return value
//                              of this parameter may be NULL if the loadinfo does
//                              not contain a moniker pointer.
//
//      *ppchUrl and *ppchTask may or may not be the same.
//
//---------------------------------------------------------------------------+
HRESULT
CMarkup::DetermineUrlOfMarkup( struct CDoc::LOADINFO * pLoadInfo, 
                              TCHAR **  ppchUrl,                    
                              TCHAR **  ppchTask)
{
    HRESULT hr = S_OK;
    TCHAR * pchTask = NULL;


    // we should have a moniker except for the new/empty page case.
    if (pLoadInfo->pmk)
    {
        // get the url to be used.
        hr = THR(pLoadInfo->pmk->GetDisplayName(pLoadInfo->pbctx, NULL, &pchTask));
        if (hr)
            goto Cleanup;

        hr = THR(ReplaceMonikerPtr( pLoadInfo->pmk ));
        if( hr )
            goto Cleanup;

        *ppchUrl = pchTask;
    }
    else
    {
        *ppchUrl = (TCHAR *)CMarkup::GetUrl(this);
    }
    
    *ppchTask = pchTask;

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//
//---------------------------------------------------------------------------+
HRESULT
CMarkup::ProcessHTMLLoadOptions(struct CDoc::LOADINFO * pLoadInfo)
{
    HRESULT             hr = S_OK;
    IUnknown *          pUnk = NULL;
    IHtmlLoadOptions *  pHtmlLoadOptions  = NULL;
    CDoc *              pDoc = Doc();

    pLoadInfo->pbctx->GetObjectParam(SZ_HTMLLOADOPTIONS_OBJECTPARAM, &pUnk);

    if (pUnk)
    {
        pUnk->QueryInterface(IID_IHtmlLoadOptions, (void **) &pHtmlLoadOptions);

        if (pHtmlLoadOptions)
        {
            CODEPAGE cp = 0;
            BOOL     fHyperlink = FALSE;
            ULONG    cb = sizeof(CODEPAGE);

            // HtmlLoadOption from the shell can override the codepage
            hr = THR(pHtmlLoadOptions->QueryOption(HTMLLOADOPTION_CODEPAGE, &cp, &cb));
            if (hr == S_OK && cb == sizeof(CODEPAGE))
            {
                HRESULT hrT = THR(mlang().ValidateCodePage(g_cpDefault, cp, pDoc->_pInPlace ? pDoc->_pInPlace->_hwnd : 0, 
                                                           FALSE, pDoc->_dwLoadf & DLCTL_SILENT));
                if (OK(hrT))
                {
                    pLoadInfo->fNoMetaCharset = TRUE;
                    pLoadInfo->codepage = cp;
                }
            }

            // Grab the shortcut only if this load came from one of the CDoc::Load* codepaths.  In all
            // other cases, this will get handled via SuperNavigate
            if (pLoadInfo->fCDocLoad)
            {
                TCHAR    achCacheFile[MAX_PATH];
                ULONG    cchCacheFile = ARRAY_SIZE(achCacheFile);

                // now determine if this is a shortcut-initiated load
                hr = THR(pHtmlLoadOptions->QueryOption(HTMLLOADOPTION_INETSHORTCUTPATH,
                                                       &achCacheFile,
                                                       &cchCacheFile));
                if (hr == S_OK && cchCacheFile)
                {
                    // we are a shortcut!
                    IPersistFile *pISFile = NULL;

                    // create the shortcut object for the provided cachefile
                    hr = THR(CoCreateInstance(CLSID_InternetShortcut,
                                              NULL,
                                              CLSCTX_INPROC_SERVER,
                                                  IID_IPersistFile,
                                              (void **)&pISFile));
                    if (SUCCEEDED(hr))
                    {
                        hr = THR(pISFile->Load(achCacheFile, 0));
                        if (SUCCEEDED(hr))
                        {
                            ClearInterface(&pDoc->_pShortcutUserData);

                            hr = THR(pISFile->QueryInterface(IID_INamedPropertyBag,
                                                             (void **)&pDoc->_pShortcutUserData));
                            if (!hr)
                            {
                                IGNORE_HR(pDoc->_cstrShortcutProfile.Set(achCacheFile));
                            }
                        }

                        pISFile->Release();
                    }
                }
            }

            // determine if we're loading as a result of a hyperlink
            cb = sizeof(fHyperlink);
            hr = THR(pHtmlLoadOptions->QueryOption(HTMLLOADOPTION_HYPERLINK,
                                                   &fHyperlink,
                                                   &cb));
            if (hr == S_OK && cb == sizeof(fHyperlink))
                pLoadInfo->fHyperlink = fHyperlink;

            // override the possible error code.
            hr = S_OK;
        }
    }

    ReleaseInterface(pHtmlLoadOptions);
    ReleaseInterface(pUnk);

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//
//---------------------------------------------------------------------------+
HRESULT
CMarkup::ProcessDwnBindInfo( struct CDoc::LOADINFO * pLoadInfo, 
                                struct CMarkup::LOADFLAGS * pFlags, 
                                TCHAR * pchTask,
                                CWindow * pWindowParent)
{
    HRESULT         hr = S_OK;
    IUnknown *      pUnk = NULL;
    CDwnBindInfo *  pDwnBindInfo      = NULL;
    DWORD           dwBindf = pFlags->dwBindf;

    pLoadInfo->pbctx->GetObjectParam(SZ_DWNBINDINFO_OBJECTPARAM, &pUnk);

    if (pUnk)
    {
        pUnk->QueryInterface(IID_IDwnBindInfo, (void **)&pDwnBindInfo);

        if (pDwnBindInfo)
        {
            CDwnDoc * pDwnDoc = pDwnBindInfo->GetDwnDoc();
            dwBindf &= ~(BINDF_PRAGMA_NO_CACHE|BINDF_GETNEWESTVERSION|BINDF_RESYNCHRONIZE);
            dwBindf |= pDwnDoc->GetBindf() & (BINDF_PRAGMA_NO_CACHE|BINDF_GETNEWESTVERSION|BINDF_RESYNCHRONIZE|BINDF_HYPERLINK);

            // (dinartem)
            // Need to distinguish the frame bind case from the normal
            // hyperlinking case.  Only frame wants to inherit dwRefresh
            // from parent, not the normal hyperlinking of a frame from
            // the <A TARGET="foo"> tag.
            // (dbau) this is now done via HTMLLOADOPTION_FRAMELOAD

            if (pWindowParent && !pLoadInfo->fHyperlink)
            {
                CDwnDoc * pParentDwnDoc = pWindowParent->_pMarkup->GetDwnDoc();

                // inherit dwRefresh from parent
                if (pParentDwnDoc && pLoadInfo->dwRefresh == 0 && !pLoadInfo->fMetaRefresh)
                {
                    pLoadInfo->dwRefresh = pParentDwnDoc->GetRefresh();
                }
            }

            // Cache the header
            {
                TCHAR   achNull[1];
                TCHAR * pchDwnHeader = NULL;

                achNull[0] = 0;

                hr = THR(pDwnBindInfo->BeginningTransaction(pchTask, achNull, 0, &pchDwnHeader));
                if (hr)
                    goto Cleanup;
                hr = SetDwnHeader(pchDwnHeader);
                if (hr)
                    goto Cleanup;
            }

            if (pDwnBindInfo->GetDwnPost())
            {
                if (pLoadInfo->pDwnPost)
                    pLoadInfo->pDwnPost->Release();
                pLoadInfo->pDwnPost = pDwnBindInfo->GetDwnPost();
                pLoadInfo->pDwnPost->AddRef();
            }
            else
            {
                pLoadInfo->pbctx->RevokeObjectParam(SZ_DWNBINDINFO_OBJECTPARAM);
            }

            if (pDwnDoc->GetDocReferer())
            {
                hr = THR(MemReplaceString(Mt(LoadInfo), pDwnDoc->GetDocReferer(),
                            &pLoadInfo->pchDocReferer));
                if (hr)
                    goto Cleanup;
            }

            if (pDwnDoc->GetSubReferer())
            {
                hr = THR(MemReplaceString(Mt(LoadInfo), pDwnDoc->GetSubReferer(),
                            &pLoadInfo->pchSubReferer));
                if (hr)
                    goto Cleanup;
            }

            // If we have a codepage in the hlink info, use it if one wasn't already specified
            if (!pLoadInfo->codepage)
                pLoadInfo->codepage = pDwnDoc->GetDocCodePage();

            if (!pLoadInfo->codepageURL)
                pLoadInfo->codepageURL = pDwnDoc->GetURLCodePage();
        }
    }

Cleanup:
    pFlags->dwBindf = dwBindf;

    ReleaseInterface(pUnk);
    ReleaseInterface((IBindStatusCallback *)pDwnBindInfo);

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//
//----------------------------------------------------------------------------
HRESULT
CMarkup::ProcessLoadFlags(struct CDoc::LOADINFO * pLoadInfo,
                          TCHAR * pchUrl, 
                          struct CMarkup::LOADFLAGS * pFlags)
{
    HRESULT hr = S_OK;
    
    DWORD   dwBindf = pFlags->dwBindf;
    DWORD   dwDownf = pFlags->dwDownf;
    DWORD   dwDocBindf = pFlags->dwDocBindf;
    DWORD   dwLoadf = pFlags->dwLoadf;

    DWORD   dwOfflineFlag;
    CDoc *  pDoc = Doc();
    BOOL    fDocOffline = FALSE;

    // Require load from local cache if offline,

    pDoc->IsFrameOffline(&dwOfflineFlag);
    dwBindf |= dwOfflineFlag;

    // Require load from local cache if doing a history load (and non-refresh) of the result of a POST
    
    if (pLoadInfo->pstmRefresh && pLoadInfo->pDwnPost
             && !(dwBindf & (BINDF_GETNEWESTVERSION|BINDF_RESYNCHRONIZE)))
    {
        pLoadInfo->pchFailureUrl = _T("about:PostNotCached");
        fDocOffline = TRUE;
    }

    if (pDoc->_dwLoadf & DLCTL_SILENT)
    {
        dwBindf |= BINDF_SILENTOPERATION | BINDF_NO_UI;
    }

    if (pDoc->_dwLoadf & DLCTL_RESYNCHRONIZE)
    {
        dwBindf |= BINDF_RESYNCHRONIZE;
    }

    if (pDoc->_dwLoadf & DLCTL_PRAGMA_NO_CACHE)
    {
        dwBindf |= BINDF_PRAGMA_NO_CACHE;
    }

    if (pLoadInfo->dwRefresh == 0)
    {
        pLoadInfo->dwRefresh = IncrementLcl();
    }

    dwDownf = GetDefaultColorMode();

    if (pDoc->IsPrintDialogNoUI() && dwDownf <= 16)
    {
        dwDownf = 24;
    }

    if (pDoc->_pOptionSettings && !pDoc->_pOptionSettings->fSmartDithering)
    {
        dwDownf |= DWNF_FORCEDITHER;
    }

    if (pDoc->_dwLoadf & DLCTL_DOWNLOADONLY)
    {
        dwDownf |= DWNF_DOWNLOADONLY;
    }

    dwLoadf = pDoc->_dwLoadf;

    if (pLoadInfo->fSync || pLoadInfo->fNoMetaCharset) // IE5 #53582 (avoid RestartLoad if loading from a stream)
    {
        dwLoadf |= DLCTL_NO_METACHARSET;
    }

    if (HasWindowPending())
    {
        CMarkup *pMarkupOld = GetWindowPending()->Markup();
        Assert(pMarkupOld);
        if (pMarkupOld->_fDesignMode || pMarkupOld->DontRunScripts())
            dwLoadf |= DLCTL_NO_SCRIPTS;
    }
    
    // initialize.
    dwDocBindf = dwBindf;

    // note (dbau) to fix bug 18360, we set BINDF_OFFLINEOPERATION only for the doc bind
    if (fDocOffline)
        dwDocBindf |= BINDF_OFFLINEOPERATION;

    pFlags->dwBindf = dwBindf & ~BINDF_FORMS_SUBMIT;    // Never use FORMS_SUBMIT for secondary downloads
    pFlags->dwDownf = dwDownf;
    pFlags->dwDocBindf = dwDocBindf;
    pFlags->dwLoadf = dwLoadf;

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//---------------------------------------------------------------------------+
HRESULT
CMarkup::HandleHistoryAndNavContext( struct CDoc::LOADINFO * pLoadInfo)
{
    HRESULT hr = S_OK;

    if (pLoadInfo->pstmHistory)
    {
        CMarkupTransNavContext * ptnc = EnsureTransNavContext();
        if (ptnc)
        {
            Assert( !ptnc->_HistoryLoadCtx.HasData() );

            if (!OK(ptnc->_HistoryLoadCtx.Init(pLoadInfo->pstmHistory)))
            {
                ptnc->_HistoryLoadCtx.Clear();
                EnsureDeleteTransNavContext( ptnc );
            }

            // Remeber that we have to send the DELAY_HISTORY_LOAD notification
            ptnc->_fDoDelayLoadHistory = TRUE;
        }
    }

    //copy the string if there is one of these.
    // Note that we might not have a history, so a NULL return is okay.
    if (pLoadInfo->pchHistoryUserData)
    {
        CMarkupBehaviorContext * pContext = NULL;

        if (S_OK == EnsureBehaviorContext(&pContext))
        {
            hr = pContext->_cstrHistoryUserData.Set(pLoadInfo->pchHistoryUserData);
        }
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//---------------------------------------------------------------------------+
HRESULT
CMarkup::HandleSSLSecurity(struct CDoc::LOADINFO *pLoadInfo, 
                           const TCHAR * pchUrl, 
                           struct CMarkup::LOADFLAGS * pFlags, 
                           IMoniker ** ppMonikerSubstitute)
{
    HRESULT hr              = S_OK;
    CDoc *  pDoc            = Doc();
    BOOL    fPendingPrimary = IsPendingPrimaryMarkup();

    //If we are in an object tag we don't want to update the ui (IE6 Bug 28338)
    if (_pDoc->_fInObjectTag)
    {
        goto Cleanup;
    }

    if (IsPrimaryMarkup() || fPendingPrimary)
    {
        if (GetUrlScheme(pchUrl) == URL_SCHEME_HTTPS && !pLoadInfo->fUnsecureSource && !(pDoc->_dwLoadf & DLCTL_SILENT))
        {
            pDoc->SetRootSslState(fPendingPrimary, SSL_SECURITY_SECURE, SSL_PROMPT_QUERY, TRUE);
        }
        else
        {
            pDoc->SetRootSslState(fPendingPrimary, SSL_SECURITY_UNSECURE, SSL_PROMPT_ALLOW, TRUE);
        }

        pLoadInfo->fPendingRoot = fPendingPrimary;
    }
    else
    {
        BOOL fPendingRoot;

        if (pLoadInfo->pElementMaster && pLoadInfo->pElementMaster->IsInMarkup())
            fPendingRoot = pLoadInfo->pElementMaster->GetMarkup()->IsPendingRoot();
        else
            fPendingRoot = IsPendingRoot();

        pLoadInfo->fPendingRoot = fPendingRoot;

        // If we're not the root doc, we want to ignore security problems if
        // the root doc is unsecure
        if (pDoc->AllowFrameUnsecureRedirect(fPendingRoot))
            pFlags->dwBindf |= BINDF_IGNORESECURITYPROBLEM;
            
        // warn about mixed security (must come after call to SetClientSite)
        if (!ValidateSecureUrl(fPendingRoot, pchUrl, pLoadInfo->fFrameTarget, FALSE, pLoadInfo->fUnsecureSource))
        {
            hr = THR(CreateURLMoniker(NULL, _T("about:NavigationCancelled"), ppMonikerSubstitute));
            if (hr)
                goto Cleanup;

            if (!fPendingRoot)
                pDoc->OnIgnoreFrameSslSecurity();

            _fSslSuppressedLoad = TRUE;
        }
    }

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//---------------------------------------------------------------------------+
HRESULT
CMarkup::ProcessCodepage( struct CDoc::LOADINFO * pLoadInfo, CWindow * pWindowParent)
{
    HRESULT hr;
    CDoc * pDoc = Doc();

    if (!pLoadInfo->codepage)
    {
        // use CP_AUTO when so requested
        if (pDoc->IsCpAutoDetect())
        {
            pLoadInfo->codepage = CP_AUTO;
        }
        else if (pWindowParent)
        {
            CMarkup * pMarkupParent = pWindowParent->_pMarkup;

            // Inherit the codepage from our parent frame
            pLoadInfo->codepage =   pMarkupParent->_fCodePageWasAutoDetect
                                    ? CP_AUTO_JP
                                    : pMarkupParent->GetCodePage();
        }
        else
        {
            // Get it from the option settings default
            pLoadInfo->codepage =
                NavigatableCodePage(pDoc->_pOptionSettings->codepageDefault);
        }
    }

    if (!pLoadInfo->codepageURL)
        pLoadInfo->codepageURL = GetURLCodePage();

    SwitchCodePage(pLoadInfo->codepage);
    hr = SetURLCodePage(pLoadInfo->codepageURL);
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//---------------------------------------------------------------------------+
HRESULT
CMarkup::CheckZoneCrossing(TCHAR * pchTask)
{
    HRESULT hr = S_OK;
    CDoc * pDoc  = Doc();
    
    Assert(HasWindowPending());

    COmWindowProxy * pProxyPending = GetWindowPending();
    
    // If we are having a transition from secure to unsecure, make sure
    // that you get user approval.
    if (!(pDoc->_dwLoadf & DLCTL_SILENT) && pchTask && pProxyPending->Window()->IsPrimaryWindow())
    {
        HWND    hwnd = _pDoc->GetHWND();
        CDoEnableModeless dem(pDoc, pProxyPending->Window());

        LPCTSTR pchUrl = CMarkup::GetUrl(pProxyPending->Markup());

        //
        // Bail for about:blank comparison with first markup.
        //
        if (IsSpecialUrl(pchUrl) && pProxyPending->Markup()->Doc()->_fStartup )
            return S_OK;           

        // pass the URL of the markup that we are replacing, and the URL of this
        if (!hwnd && _pDoc->_pClientSite)
        {
            IOleWindow *pIOleWindow = NULL;

            //
            // if the doc is not in place, get the host hwnd
            //

            hr = THR(_pDoc->_pClientSite->QueryInterface(IID_IOleWindow, (void **)&pIOleWindow));

            //
            //  if QI fails, we still try the wininet call for VS
            //

            if (SUCCEEDED(hr))
            {
                hr = THR(pIOleWindow->GetWindow(&hwnd));
                ReleaseInterface(pIOleWindow);

                if (FAILED(hr))
                {
                    hwnd = NULL;
                }
            }

            hr = S_OK;
        }

        // markup. If they are in different security domains, a dialog will be shown.
        DWORD err = InternetConfirmZoneCrossing(hwnd,
                                                (LPWSTR)pchUrl, 
                                                (LPWSTR) pchTask, 
                                                FALSE);
        if (ERROR_SUCCESS != err) 
        {
            //
            //  Either the user cancelled it or there is not enough
            // memory. Abort the navigation.
            //
            hr = HRESULT_FROM_WIN32(err);

            pProxyPending->Window()->ReleaseMarkupPending(this);
        }
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//---------------------------------------------------------------------------+
HRESULT
CMarkup::PrepareDwnDoc( CDwnDoc * pDwnDoc, 
                        struct CDoc::LOADINFO * pLoadInfo, 
                        TCHAR * pchUrl, 
                        struct CMarkup::LOADFLAGS * pFlags,
                        LPCTSTR pchCallerUrl                    /* = NULL */)
{
    HRESULT hr;
    CDoc * pDoc = Doc();

    pDwnDoc->SetDocAndMarkup(pDoc, this);
    pDwnDoc->SetBindf(pFlags->dwBindf);
    pDwnDoc->SetDocBindf(pFlags->dwDocBindf);
    pDwnDoc->SetDownf(pFlags->dwDownf);
    pDwnDoc->SetRefresh(pLoadInfo->dwRefresh);
    pDwnDoc->SetDocCodePage(NavigatableCodePage(pLoadInfo->codepage));
    pDwnDoc->SetURLCodePage(NavigatableCodePage(pLoadInfo->codepageURL));
    pDwnDoc->TakeRequestHeaders(&(pLoadInfo->pbRequestHeaders), &(pLoadInfo->cbRequestHeaders));
    pDwnDoc->SetExtraHeaders(pLoadInfo->pchExtraHeaders);
    pDwnDoc->SetDownloadNotify(pDoc->_pDownloadNotify);
    pDwnDoc->SetDwnTransform(pDoc->IsAggregatedByXMLMime());

    //fix for IE bug 110387. If codepage is UTF-8, and machine id KO, JP or TW (at least), and
    //"Always use UTF-8" in Advanced Options is disabled, we 
    //get garbled bytes sent over the wire instead of URL. The bug is actually in
    //shlwapi but we don't have time to fix it and we feel that sending escaped UTF-8 is 
    //better anyway because it's safer.

/*
    NOTE: (dmitryt) See 110775. shlwapi or no shlwapi, poll among ieintwar showed 
    support for escaped UTF-8 if navigation is initiated by UTF-8 page, even if IE has 
    "use UTF-8 always" *unchecked*. Those 3 codepages below were arbitrary picked 
    according to IE5.5 war team to reduce risk of the fix because it was somewhat late in
    a shipping cycle for IE5.5
    However, it seems to be a right thing to do so I'm opening it for all platforms in Whistler.

    if((g_cpDefault == CP_KOR_5601 ||  g_cpDefault == CP_JPN_SJ ||  g_cpDefault == CP_TWN)
        && (pDwnDoc->GetURLCodePage() == CP_UTF_8)
      )
*/
    if(pDwnDoc->GetURLCodePage() == CP_UTF_8)
        pDwnDoc->SetLoadf((pFlags->dwLoadf & ~DLCTL_URL_ENCODING_DISABLE_UTF8) | DLCTL_URL_ENCODING_ENABLE_UTF8);
    else
        pDwnDoc->SetLoadf(pFlags->dwLoadf);


    if (pDoc->_pOptionSettings->fHaveAcceptLanguage)
    {
        hr = THR(pDwnDoc->SetAcceptLanguage(pDoc->_pOptionSettings->cstrLang));
        if (hr)
            goto Cleanup;
    }

    if (pDoc->_bstrUserAgent)
    {
        hr = THR(pDwnDoc->SetUserAgent(pDoc->_bstrUserAgent));
        if (hr)
            goto Cleanup;
    }

    SetReadyState(READYSTATE_LOADING);

    hr = THR(pDwnDoc->SetDocReferer(pLoadInfo->pchDocReferer));
    if (hr)
        goto Cleanup;

    hr = THR(pDwnDoc->SetSubReferer(pLoadInfo->pchSubReferer ?
                pLoadInfo->pchSubReferer : pchUrl));
    if (hr)
        goto Cleanup;

    if (pLoadInfo->pElementMaster && pLoadInfo->pElementMaster->IsInMarkup())
    {
        if (Doc()->_fActiveDesktop && IsActiveDesktopComponent())
            hr = pDwnDoc->SetSecurityID(this, TRUE);
        else 
            hr = pDwnDoc->SetSecurityID(pLoadInfo->pElementMaster->GetMarkup());
    }
    else
    {
        hr = pDwnDoc->SetSecurityID(this);
    }
    
//    hr = pDwnDoc->SetSecurityID(pLoadInfo->pElementMaster && pLoadInfo->pElementMaster->IsInMarkup() ?
//                                pLoadInfo->pElementMaster->GetMarkup() : this);
    if (hr)
        goto Cleanup;

    //
    // This data is used to process UrlActions that occur on redirects
    //

    pDwnDoc->SetCallerUrl(pchCallerUrl);

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//---------------------------------------------------------------------------+
HRESULT
CMarkup::PrepareHtmlLoadInfo( HTMLOADINFO * pHtmlLoadInfo, 
                             struct CDoc::LOADINFO * pLoadInfo, 
                             TCHAR * pchUrl,
                             IMoniker * pmkSubstitute, 
                             CDwnDoc * pDwnDoc)
{
    HRESULT hr = S_OK;
    CDoc * pDoc = Doc();

    if (pLoadInfo->fBindOnApt)
        pHtmlLoadInfo->pInetSess = NULL;
    else
        pHtmlLoadInfo->pInetSess = TlsGetInternetSession();

    pHtmlLoadInfo->pDwnDoc         = pDwnDoc;
    pHtmlLoadInfo->pDwnPost        = GetDwnPost();
    pHtmlLoadInfo->pDoc            = pDoc;
    pHtmlLoadInfo->pMarkup         = this;
    pHtmlLoadInfo->pchBase         = pchUrl;
    pHtmlLoadInfo->pmi             = pLoadInfo->pmi;
    pHtmlLoadInfo->fClientData     = pLoadInfo->fKeepOpen;
    pHtmlLoadInfo->fParseSync      = pLoadInfo->fSync;
    pHtmlLoadInfo->ftHistory       = pLoadInfo->ftHistory;
    pHtmlLoadInfo->pchFailureUrl   = pLoadInfo->pchFailureUrl;
    pHtmlLoadInfo->pchUrlOriginal  = pLoadInfo->pchUrlOriginal;
    pHtmlLoadInfo->pchUrlLocation  = pLoadInfo->pchLocation;
    pHtmlLoadInfo->pstmRefresh     = pLoadInfo->pstmRefresh;
    pHtmlLoadInfo->fKeepRefresh    = pLoadInfo->fKeepRefresh;
    pHtmlLoadInfo->pVersions       = pDoc->_pVersions;
    pHtmlLoadInfo->fUnsecureSource = pLoadInfo->fUnsecureSource;
    pHtmlLoadInfo->fPendingRoot    = pLoadInfo->fPendingRoot;

    if (pmkSubstitute)
    {
        pHtmlLoadInfo->pmk = pmkSubstitute;
    }
    else if (pLoadInfo->pDwnBindData)
    {
        pHtmlLoadInfo->pDwnBindData = pLoadInfo->pDwnBindData;
        pHtmlLoadInfo->pstmLeader = pLoadInfo->pstmLeader;
        pHtmlLoadInfo->pchUrl = pchUrl;      // used for security assumptions
    }
    else if (pLoadInfo->pstmDirty)
    {
        IStream * pStmDirty = GetStmDirty();
        
        pHtmlLoadInfo->pstm = pLoadInfo->pstmDirty;
        ReplaceInterface(&pStmDirty, pLoadInfo->pstmDirty);
        hr = SetStmDirty(pStmDirty);
        if (hr)
            goto Cleanup;
        pHtmlLoadInfo->pchUrl = pchUrl;      // used for security assumptions
    }
    else if (pLoadInfo->pstm)
    {
        pHtmlLoadInfo->pstm = pLoadInfo->pstm;
        pHtmlLoadInfo->pchUrl = pchUrl;      // used for security assumptions
    }
    else if (pLoadInfo->pmk)
    {
        pHtmlLoadInfo->pmk = pLoadInfo->pmk;
        pHtmlLoadInfo->pchUrl = pchUrl;
        pHtmlLoadInfo->pbc = pLoadInfo->pbctx;
    }

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//---------------------------------------------------------------------------+
void
CMarkup::HandlePicsSupport(struct CDoc::LOADINFO * pLoadInfo)
{
    // NB: (jbeda) We shouldn't be pics processing.
    // However, in the case of a reload for a cp change
    // we might already have a pics target
    Assert( !_fPicsProcessPending );

    // Set up the PICS monitoring here
    if (    pLoadInfo->fStartPicsCheck    
        &&  _pDoc->_pClientSite
        &&  HasWindowPending() 
        &&  !HasWindow()
        &&  !(_pDoc->_dwFlagsHostInfo & DOCHOSTUIFLAG_NOPICS))
    {
        CVariant cvarPrivWindow(VT_UNKNOWN);
        CVariant cvarPicsPending;

        V_UNKNOWN(&cvarPrivWindow) = DYNCAST(IHTMLWindow2, GetWindowPending());
        V_UNKNOWN(&cvarPrivWindow)->AddRef();

        IGNORE_HR(CTExec(_pDoc->_pClientSite, &CGID_ShellDocView, SHDVID_STARTPICSFORWINDOW, 
                         0, &cvarPrivWindow, &cvarPicsPending));

        // If we now have a pctPics on this markup, we want to start prescanning
        if (V_BOOL(&cvarPicsPending) == VARIANT_TRUE)
        {
            _fPicsProcessPending = TRUE;
            Assert( GetPicsTarget() );
        }
#if DBG==1
        else
            Assert( !GetPicsTarget() );
#endif
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::LoadFromInfo
//
//----------------------------------------------------------------------------
HRESULT
CMarkup::LoadFromInfo(struct CDoc::LOADINFO * pLoadInfo, 
                      DWORD dwFlags,                           /* = 0 */
                      LPCTSTR pchCallerUrl                     /* = NULL */)
{
    HRESULT                 hr;
    HTMLOADINFO             htmloadinfo;
    IMoniker *              pmkSubstitute     = NULL;
    TCHAR *                 pchUrl;
    TCHAR *                 pchTask           = NULL;
    struct CDoc::LOADINFO   LoadInfo          = *pLoadInfo;
    CDwnDoc *               pDwnDoc;
    CDoc *                  pDoc              = Doc();
    CWindow *               pWindowParent     = NULL;
    IHTMLWindow2 *          pWindowShdocvw    = NULL;
    IHTMLWindow2 *          pWindow2          = NULL;
    IHTMLDocument2 *        pDocument2        = NULL;
    BSTR                    bstrName          = NULL;
    BSTR                    bstrUrl           = NULL;
    IBindCtx *              pbcNew            = NULL;
    IMoniker *              pmkNew            = NULL;
    CMarkup *               pMarkupForWaitCursor = NULL;
    CStr                    cstrCreatorUrl;
    BOOL                    fSpecialUrl       = FALSE;

    IMoniker* pmkTmp = NULL;              // Used with MIME mime type
    DWORD dwBindfTmp;

    
    struct CMarkup::LOADFLAGS  flags = {0};

    if (HasWindowPending())
    {
        CWindow *pWindow = GetWindowPending()->Window();
        if (pWindow)
        {
            pMarkupForWaitCursor = pWindow->_pMarkup;
            if (pMarkupForWaitCursor)
            {
                pMarkupForWaitCursor->ShowWaitCursor(TRUE);
            }
        }
    }

    pLoadInfo->pDwnPost      = NULL;
    pLoadInfo->pchDocReferer = NULL;
    pLoadInfo->pchSubReferer = NULL;

    if (LoadInfo.pstm)
        LoadInfo.pstm->AddRef();

    if (LoadInfo.pmk)
        LoadInfo.pmk->AddRef();

    BOOL fPendingPrimary = HasWindowPending() && GetWindowPending()->Markup()->IsPrimaryMarkup();
    
    if (fPendingPrimary)
    {
        _pDoc->_fShdocvwNavigate = LoadInfo.fShdocvwNavigate;
    }

    // If we are hosted in an object tag
    // or an HTML dialog, the _fDontFireWebOCEvents 
    // is set in CDoc::SetClientSite() or 
    // CHTMLDlg::SetFlagsOnDoc(), respectively.
    // and reset in CMarkup::OnLoadStatusDone().
    // Therefore, leave it alone.
    //
    if (!_pDoc->_fInObjectTag && !_pDoc->_fInHTMLDlg && !LoadInfo.fCreateDocumentFromUrl) 
    {
        _pDoc->_fDontFireWebOCEvents = LoadInfo.fDontFireWebOCEvents;
    }

    if (fPendingPrimary || LoadInfo.fDontUpdateTravelLog)
    {
        _pDoc->_fDontUpdateTravelLog = LoadInfo.fDontUpdateTravelLog;                
    }
    
    _pDoc->ResetProgressData();

    // We need a moniker.
    hr = THR(EnsureMoniker(&LoadInfo));
    if (hr)
        goto Cleanup;

    /*
    This is a description of how we handle opening MHTML documents in IE4.
    The developers involved in this work are:
    - DavidEbb for the Trident part (Office developer on loan).
    - SBailey for the MimeOle code (in INETCOMM.DLL).
    - JohannP for the URLMON.DLL changes.

    Here are the different scenarios we are covering:
    1. Opening the initial MHTML file:
    - When we initially open the MHTML file in the browser, URLMON will instantiate the MHTML handler (which is Trident), and call its IPersistMoniker::Load(pmkMain).
        - Trident calls GetMimeOleAndMk(pmkMain, &punkMimeOle, &pmkNew) (a new MimeOle API).
        - MimeOle looks at the moniker (which may look like http://server/foo.mhtml ), and checks in a global table whether there already exists a Mime Message object for the moniker. Suppose this is not the case now.
        - MimeOle creates a new Mime Message object, and loads its state from the moniker. It then adds this new Mime Message object to the global table.
        - Now, MimeOle creates a new moniker, which will look like "mhtml: http://server/foo.mhtml !", and it returns it to Trident. The meaning of this moniker is "the root object of the mhtml file". It also returns an AddRef'd IUnknown pointer to
        - Trident holds on to the IUnknown ptr until it (Trident) is destroyed. This guarantees that the Mime Message object stays around as long as Trident is alive.
        - Now Trident goes on to do what it normally does in its IPersistMoniker::Load, except that it uses pmkNew instead of pmkMain.
        - At some point in the Load code, Trident will call pmkNew->BindToStorage().
        - Now, we're in URLMON, which needs to deal with this funky mhtml: moniker. The trick here is that MimeOle will have registered an APP (Asynchronous Pluggable Protocol) for mhtml:. So URLMON instantiates the APP, and uses it to get the bits.
        - The APP looks at the moniker, breaks it into its two parts, " http://server/foo.mhtml " and "" (empty string, meaning root). It finds http://server/foo.mhtml  in its global table, and uses the associated MimeMessage object for the download.


    2. Retrieving images referenced by the root HTML doc of the MHTML file:
    So at this point, Trident is loaded with the root HTML document of the MHTML file. Now let's look at what happens when trident tries to resolve an embedded JPG image (say, bar.jpg):
    - Trident calls CoInternetCombineUrl, passing it "mhtml: http://server/foo.mhtml!" as the base, and "bar.jpg".
        - Now again, URLMON will need some help from the MHTML APP to combine those two guys. So it will end up calling MimeOle to perform the combine operation.
        - MimeOle will combine the two parts into the moniker "mhtml: http://server/foo.mhtml!bar.jpg " (note: if there had been a non empty string after the bang, it would have been removed).
    - Trident then calls BindToStorage on this new moniker. From there on, things are essentially the same as above. It goes into the APP, which finds http://server/foo.mhtml  in its global table, and knows how to get the bits for the part named "ba


    3. Navigating to another HTML document inside the MHTML file:
    Now let's look at what happens when we navigate to another HTML document (say part2.html) which is stored in the MHTML file:
    - As above, the APP will be used to combine the two parts into the moniker "mhtml: http://server/foo.mhtml!part2.html ".
    - Now SHDCOVW calls BindToObject on this moniker.
        - URLMON uses the APP to get the part2.html data (similar to case above, skipping details).
    - The APP reports that the data is of type text/html, so URLMON instantiates Trident, and calls its IPersistMoniker::Load with the moniker mhtml: http://server/foo.mhtml!part2.html .
        - Trident looks at the moniker and sees that it has the mhtml: protocol.
    - Again, it calls GetMimeOleAndMk, but this time it gets back the very same moniker. So the only purpose of this call is to get the Mime Message IUnknown ptr to hold on to. Suggestion: we should use a different API in this case, which simply ret
        - Trident then keeps on going with the moniker, and things happen as in case 1.

    4. Retrieving images referenced by the other (non root) HTML doc of the MHTML file:
    This is almost identical to case 2., except the now the base moniker is "mhtml: http://server/foo.mhtml!part2.html " instead of "mhtml: http://server/foo.mhtml !".

    5. Refreshing the current page:
    This should now work quite nicely because the current moniker that IE uses has enough information to re-get the data "from scratch". The reason it was broken before is that in our old scheme, IE only new the name of the part, and failed when tryi

    6. Resolving a shortcut:
    The very nice thing about this solution is that it will allow the creation of shortcuts to parts of an MHTML file. This works for the same reason that case 5 works.
    */

    // If we've been instantiated as an mhtml handler, or if we are dealing
    // with a 'mhtml:' url, we need to get a special moniker from MimeOle.
    // Also, we get an IUnknown ptr to the Mime Message object, which allows
    // us to keep it alive until we go away.

    if (    LoadInfo.pmk
        &&  HasWindowPending()
        &&  GetWindowPending() == pDoc->_pWindowPrimary
        &&  (pDoc->_fMhtmlDoc || 
                 (pDoc->_fMhtmlDocOriginal && (_fInRefresh || (dwFlags & CDoc::FHL_RESTARTLOAD))) ||
                 (!LoadInfo.pstmHistory && LoadInfo.pchDisplayName && _tcsnicmp(LoadInfo.pchDisplayName, 6, _T("mhtml:"), -1) == 0)
            )
       )
    {
        TCHAR* pchOriginalUrl = NULL;
        
        if ( pDoc->_fMhtmlDocOriginal && ! _fInRefresh )
        {
            // Get the URL from the display name of the moniker:
            hr = pDoc->_pOriginalMoniferForMHTML->GetDisplayName(NULL, NULL, & pchOriginalUrl );
            if (FAILED(hr))
            {
                CoTaskMemFree( pchOriginalUrl );
                goto Cleanup;
            }
        }

        //
        // Either we don't have an original url, or this is a different url. 
        //
        if ((!pDoc->_fMhtmlDocOriginal && !_fInRefresh) ||
            (pchOriginalUrl && _tcsicmp(LoadInfo.pchDisplayName, pchOriginalUrl) != 0 ))

        {
            ClearInterface(&pDoc->_pOriginalMoniferForMHTML);            

            pDoc->_pOriginalMoniferForMHTML = LoadInfo.pmk;
            pDoc->_pOriginalMoniferForMHTML->AddRef();

            pDoc->_fMhtmlDocOriginal = TRUE;
        }

        CoTaskMemFree( pchOriginalUrl );

        if (dwFlags & CDoc::FHL_RESTARTLOAD)
        {
            pmkTmp = LoadInfo.pmk;           
        }
        else
        {
            pmkTmp = pDoc->_pOriginalMoniferForMHTML;  
        }

        if (_fInRefresh)
        {
            dwBindfTmp = LoadInfo.dwBindf; 
        }
        else
        {
            dwBindfTmp = flags.dwBindf;
        }

        pmkTmp->AddRef();  // Make sure the moniker stays alive during this funniness.

        ClearInterface(&pDoc->_punkMimeOle);

        hr = MimeOleObjectFromMoniker((BINDF) dwBindfTmp, 
                                       pmkTmp,
                                       LoadInfo.pbctx, 
                                       IID_IUnknown, 
                                       (void**) 
                                       &pDoc->_punkMimeOle, &pmkNew);

        pmkTmp->Release();

        if (FAILED(hr))
            goto Cleanup;

        // From here on, work with the new moniker instead of the one passed in
        ReplaceInterface(&LoadInfo.pmk, pmkNew);
        hr = THR( ReplaceMonikerPtr( pmkNew ) );

        if( hr )
            goto Cleanup;

        // Create a new bind context if we are an mhtml handler, because this
        // will be a new binding operation.
        if (pDoc->_fMhtmlDoc)
        {
            hr = CreateBindCtx(0, &pbcNew);
            if (FAILED(hr))
                goto Cleanup;

            // We don't hold a reference to LoadInfo.pbctx, so don't use
            // ReplaceInterface here.
            LoadInfo.pbctx = pbcNew;
        }
    }

    // We need to get and set the local URL 
    hr = THR(DetermineUrlOfMarkup(&LoadInfo, &pchUrl, &pchTask));
    if (hr)
        goto Cleanup;

    fSpecialUrl = IsSpecialUrl( pchUrl );
    
    pDwnDoc = new CDwnDoc;
    if (pDwnDoc == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = SetDwnDoc(pDwnDoc);
    if (hr)
        goto Cleanup;

    if (HasWindowPending())
    {
        pWindowParent = GetWindowPending()->Window()->_pWindowParent;
    }

    //
    // The _pDoc->_pShellBrowser will only be set when we are hosted in IE. In
    // all other hosts, the host does the check in OnBeforeNavigate2, so we don't
    // want to do it and possibly show UI here.
    //
    if (_fWindowPending && !_pDoc->_fShdocvwNavigate && _pDoc->_fInIEBrowser)
    {
        BOOL fIsError;

        if (pchTask && pDoc->_pTridentSvc)
        {
            hr = THR(pDoc->_pTridentSvc->IsErrorUrl(pchTask, &fIsError));
            if (hr)
                goto Cleanup;
        }
        else
            fIsError = FALSE;

        if (!fIsError)
        {
            hr = THR(CheckZoneCrossing(pchTask));
            if (hr)
                goto Cleanup;
        }
    }

    // TODO (jbeda) this bit remembers if the host set the load
    // bits directly but not if we actually read prefs already.
    // We will make this call twice while loading -- once early
    // in CDoc::LoadFromInfo and once here. However, if we need the
    // call here for the case where we are called from LoadHistory. 
    // Maybe the real answer is to have only one LoadFromInfo?
    if (!pDoc->_fGotAmbientDlcontrol)
    {
        pDoc->SetLoadfFromPrefs();
    }

    // Create CVersions object if we haven't already
    if (!pDoc->_pVersions)
    {
        hr = THR(pDoc->QueryVersionHost());
        if (hr)
            goto Cleanup;
    }

    // Before creating any elements, create the history load context
    hr = THR(HandleHistoryAndNavContext(&LoadInfo));
    if (hr)
        goto Cleanup;

    flags.dwBindf = LoadInfo.dwBindf;

    // Extract information from the pbctx
    if (LoadInfo.pbctx)
    {
        TCHAR * pchCreatorUrl = NULL;
        CVariant varOpener(VT_EMPTY);

        Assert(LoadInfo.pmk); // we should only have a pbctx when we have a pmk

        // TODO (lmollico): temporary hack
        
        {
            hr = pDoc->QueryService(SID_SHTMLWindow2, IID_IHTMLWindow2, (void **) &pWindowShdocvw);
            if (!hr)
            {
                // Make sure we don't already have an opener
                //
                pDoc->_pWindowPrimary->get_opener(&varOpener);

                if (VT_EMPTY == V_VT(&varOpener))
                {
                    varOpener.Clear();

                    hr = pWindowShdocvw->get_opener(&varOpener);
                    if (hr)
                        goto opener_error;

                    hr = pDoc->_pWindowPrimary->put_opener(varOpener);
                    if (hr)
                        goto Cleanup;

                    if (V_VT(&varOpener) == VT_DISPATCH)
                    {
                        hr = V_DISPATCH(&varOpener)->QueryInterface(IID_IHTMLWindow2, (void **) &pWindow2);
                        if (hr)
                            goto opener_error;

                        hr = pWindow2->get_document(&pDocument2);
                        if (hr)
                            goto opener_error;

                        hr = pDocument2->get_URL(&bstrUrl);
                        if (hr)
                            goto opener_error;
                    }
                }

                hr = pWindowShdocvw->get_name(&bstrName);
                if (hr)
                    goto opener_error;

                if (pDoc->_fViewLinkedInWebOC && IsPrimaryMarkup() && (!bstrName || !*bstrName))
                {
                    COmWindowProxy * pOmWindowProxy = pDoc->GetOuterWindow();

                    if (pOmWindowProxy)
                        IGNORE_HR(pOmWindowProxy->Window()->get_name(&bstrName));
                }

                if ((IsPrimaryMarkup() || (HasWindowPending() && GetWindowPending()->Markup()->IsPrimaryMarkup())) 
                    && bstrName 
                    && *bstrName)
                {
                    hr = pDoc->_pWindowPrimary->put_name(bstrName);
                    if (hr)
                        goto Cleanup;
                }
            }
            else
                hr = S_OK;

opener_error:
            // We don't want to fail the load just
            // because we couldn't get to the opener.
            hr = S_OK;
        }
                          
        // Always get the creator Url out of the bind context to avoid leaking memory
        //
        THR(GetBindContextParam(LoadInfo.pbctx, &cstrCreatorUrl));        

        TraceTag((tagSecurityContext, "CMarkup::LoadFromInfo- Markup: 0x%x URL: %ws BindCtx_Creator URL: %ws", this, pchUrl, (LPTSTR)cstrCreatorUrl));

        //
        // If we are being opened by a window.open call, then we have the URL for the 
        // document calling us in the bind context. Take that and save it in the cstrCreatorUrl.
        // This variable will be used when communicating with the URLMON and responding security
        // context queries.
        // If primary and don't have an opener, we don't have a creator.
        //        
        if (    (   IsPrimaryMarkup() 
                ||  (   IsPendingPrimaryMarkup() &&  LoadInfo.fErrorPage) 
                || _fNewWindowLoading) 
            &&  V_VT(&varOpener) != VT_EMPTY)
        {               
            if (cstrCreatorUrl.Length())
            {
                pchCreatorUrl = cstrCreatorUrl;
            }
            else if (bstrUrl)
            {
                cstrCreatorUrl.Set(bstrUrl);         
                pchCreatorUrl = cstrCreatorUrl;
            }

#if DBG==1  
            if (IsPendingPrimaryMarkup() && LoadInfo.fErrorPage)
            {
                TraceTag((tagSecurityContext, "                     - Error page load. Creator URL: %ws", pchCreatorUrl ));
            }
            else
            {
                TraceTag((tagSecurityContext, "                     - Window.open load. Creator URL: %ws", pchCreatorUrl ));
            }
#endif
        }        
        else if ((!IsPendingPrimaryMarkup() || (LoadInfo.dwBindf & BINDF_HYPERLINK)) && fSpecialUrl ) 
        {
            // If we are doing a navigation, the creator url should be stored in the bind context. We only
            // need to set this if we are navigating to a special url.
            // The special URL check is only applied if we are a frame nav. or we are navigating the top
            // level with a hyperlink action.
            pchCreatorUrl = cstrCreatorUrl;            

            TraceTag((tagSecurityContext, "                     - Frame nav. or top level nav. with hyperlink action. Creator URL: %ws", pchCreatorUrl ));
        }

        if ( fSpecialUrl )
        {
            TraceTag((tagSecurityContext, "                     - Special URL processing, add creator back into the bindctx"));

            // since the CxxxProtocol::ParseAndBind is going to try to get to the same bindctx params,
            // we should put the information back in.
            hr = THR(AddBindContextParam(LoadInfo.pbctx, &cstrCreatorUrl));
            if (hr)
                goto Cleanup;
        }
                            
        // Set the creatorUrl 
        if (pchCreatorUrl && *pchCreatorUrl)
        {
            TraceTag((tagSecurityContext, "                     - Markup 0x%x SetAACreatorUrl(%ws)", this, pchCreatorUrl));

            hr = THR(SetAAcreatorUrl(pchCreatorUrl));
            if (hr)
                goto Cleanup;

            // HACKHACK (jbeda): if we are in the PICS case
            // we have a blank document that is a place holder
            // Set the creator url on that guy too
            if (    _fNewWindowLoading 
                &&  HasWindowPending() )
            {
                CWindow * pWindow = GetWindowPending()->Window();
                if (    pWindow->_pMarkup
                    &&  pWindow->_pMarkup->_fPICSWindowOpenBlank)
                {
                    pWindow->_pMarkup->SetAAcreatorUrl(pchCreatorUrl);
                }
            }
        }

        hr = THR(ProcessHTMLLoadOptions(&LoadInfo));
        if (hr)
            goto Cleanup;

        hr = THR(ProcessDwnBindInfo(&LoadInfo, &flags, pchTask, pWindowParent));
        if (hr)
            goto Cleanup;
    }

    // set the markup URL 
    if (pchTask)
    {
        // we must have a moniker here,
        Assert(LoadInfo.pmk);

        // now chop of #location part, if any
        TCHAR *pchLoc = const_cast<TCHAR *>(UrlGetLocation(pchTask));
        if (pchLoc)
            *pchLoc = _T('\0');

        hr = THR(SetUrl(this, pchTask));
        if (hr)
            goto Cleanup;

        if (LoadInfo.pchSearch)
        {
             hr = THR(SetUrlSearch(this, LoadInfo.pchSearch));
             if (hr)
                 goto Cleanup;
        }

        hr = THR(SetUrlOriginal(this, LoadInfo.pchUrlOriginal));
        if (hr)
            goto Cleanup;

        UpdateSecurityID();

        pDoc->DeferUpdateTitle(this);
    }

    //
    // If it's a javascript: or vbscript: url - we want to use the creator url.
    //
    hr = THR(HandleSSLSecurity(&LoadInfo, 
                               fSpecialUrl && IsScriptUrl( pchUrl ) ? ( (LPTSTR) cstrCreatorUrl) : pchUrl , 
                               &flags, 
                               &pmkSubstitute));
    if (hr)
        goto Cleanup;

    hr = THR(ProcessLoadFlags(&LoadInfo, pchUrl, &flags));
    if (hr)
        goto Cleanup;

    hr = THR(ProcessCodepage(&LoadInfo, pWindowParent));
    if (hr)
        goto Cleanup;

    hr = THR(PrepareDwnDoc(pDwnDoc, &LoadInfo, pchUrl, &flags, pchCallerUrl));
    if (hr)
        goto Cleanup;

    if (LoadInfo.pDwnPost)
    {
        Assert(!GetDwnPost()); // This is a new Markup

        hr = SetDwnPost(LoadInfo.pDwnPost);
        if (hr)
            goto Cleanup;
        LoadInfo.pDwnPost->AddRef();
    }

    hr = THR(PrepareHtmlLoadInfo(&htmloadinfo, &LoadInfo, pchUrl, pmkSubstitute, pDwnDoc));
    if (hr)
        goto Cleanup;

    // Loading a dirty subframe should dirty the whole world.  However, 
    // loading a clean page only sets us clean if it's the primary
    if( GetStmDirty() )
    {
        Doc()->_lDirtyVersion = MAXLONG;
    } 
    else if( HasPrimaryWindow() )
    {
        Doc()->_lDirtyVersion = 0;
    }

    HandlePicsSupport(&LoadInfo);

    hr = THR(Load(&htmloadinfo));

Cleanup:
    // Clear this flag, we have no further use for it for this markup.
    // If we are loading another mhtml document, we will create another
    // CDoc for it. If we do not clear this flag now, it will confuse
    // the next CMarkup being loaded into thinking it is an MHTML
    // document too.

    pDoc->_fMhtmlDoc = FALSE;

    ReleaseInterface(pmkSubstitute);
    ReleaseInterface(pbcNew);
    ReleaseInterface(pmkNew);
    ReleaseInterface(LoadInfo.pstm);
    ReleaseInterface(LoadInfo.pmk);
    MemFree(LoadInfo.pchDocReferer);
    MemFree(LoadInfo.pchSubReferer);
    CoTaskMemFree(pchTask);
    ReleaseInterface((IUnknown *) LoadInfo.pDwnPost);
    ReleaseInterface(pWindowShdocvw);
    ReleaseInterface(pWindow2);
    ReleaseInterface(pDocument2);
    FormsFreeString(bstrName);
    FormsFreeString(bstrUrl);
    if (S_OK != hr && pMarkupForWaitCursor)
       pMarkupForWaitCursor->ShowWaitCursor(FALSE);
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::Load
//
//----------------------------------------------------------------------------

HRESULT
CMarkup::Load(HTMLOADINFO * phtmloadinfo)
{
    HRESULT hr;
    CHtmCtx *       pHtmCtxLocal = NULL;

    //
    // create _pHtmCtx
    //

    hr = THR(NewDwnCtx(DWNCTX_HTM, FALSE, phtmloadinfo, (CDwnCtx **)&_pHtmCtx));
    if (hr)
        goto Cleanup;

    // Addref for the stack
    pHtmCtxLocal = _pHtmCtx;
    pHtmCtxLocal->AddRef();

    //
    // create _pProgSink if necessary:
    //
    // 1. Primary markup always needs it
    // 2. It is always necessary during async download
    // 3. It is necessary if _LoadStatus is requested to be advanced as download progresses
    //

    if (    HasWindowPending()
        ||  !phtmloadinfo->fParseSync
        ||  phtmloadinfo->fAdvanceLoadStatus)
    {
        _pProgSink = new CProgSink(_pDoc, this);
        if (!_pProgSink)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = THR(_pProgSink->Init());
        if (hr)
            goto Cleanup;

        hr = THR(_pHtmCtx->SetProgSink(_pProgSink));
        if (hr)
            goto Cleanup;


    }

    //
    // set up Url
    //

    if (phtmloadinfo->pchUrl)
    {
        hr = SetUrl(this, (TCHAR*)phtmloadinfo->pchUrl);
        if (hr)
            goto Cleanup;

        hr = THR(SetUrlOriginal(this, phtmloadinfo->pchUrlOriginal));
        if (hr)
            goto Cleanup;

        hr = THR(SetUrlLocation(this, phtmloadinfo->pchUrlLocation));
        if (hr)
            goto Cleanup;

        // If the load operation is not being made into a possibly temporary markup
        // then ensure the script context to be able to show this markup in the 
        // script debugger's running document's window even if it does not contain
        // any script.
        hr = THR(EnsureScriptContext(NULL));
        if (hr)
            goto Cleanup;
    }


    //
    // copy design mode from context
    //   
    if (phtmloadinfo->pContextMarkup)
    {
        _fInheritDesignMode = phtmloadinfo->pContextMarkup->_fInheritDesignMode;
        _fDesignMode = phtmloadinfo->pContextMarkup->_fDesignMode;
    }

    //
    // launch download
    //

    _pHtmCtx->SetLoad(TRUE, phtmloadinfo, FALSE);
    hr = (pHtmCtxLocal->GetState() & DWNLOAD_ERROR) ? E_FAIL : S_OK;
    if (hr)
        goto Cleanup;

    //
    // finalize
    //

    if (phtmloadinfo->fAdvanceLoadStatus)
    {
        // cause ProgSink to update it's status synchronously - this will advance LoadStatus if possible
        _pProgSink->OnMethodCall((DWORD_PTR)_pProgSink);
    }

Cleanup:
    if (pHtmCtxLocal)
        pHtmCtxLocal->Release();

    RRETURN (hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::SuspendDownload
//
//----------------------------------------------------------------------------

HRESULT
CMarkup::SuspendDownload()
{
    HRESULT hr = S_OK;
    if (HtmCtx())
    {
        HtmCtx()->Sleep(TRUE);
    }
    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::ResumeDownload
//
//----------------------------------------------------------------------------

HRESULT
CMarkup::ResumeDownload()
{
    HRESULT hr = S_OK;
    if (HtmCtx())
    {
        HtmCtx()->Sleep(FALSE);
    }
    RRETURN (hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::LoadStatus
//
//----------------------------------------------------------------------------

LOADSTATUS
CMarkup::LoadStatus()
{
    return _LoadStatus;
}

//+---------------------------------------------------------------
//
//  Member:     SetMetaToTrident()
//
//  Synopsis:   When we create or edit (enter design mode on) a
//      document the meta generator tag in the header is to be
//      set to Trident and the appropriate build. If a meta generator
//      already exists then it should be replaced.
//             this is called after the creation of head,title... or
//      on switching to design mode. in both cases we can assume that
//      the headelement array is already created.
//
//---------------------------------------------------------------

static BOOL 
LocateGeneratorMeta(CMetaElement * pMeta)
{
    LPCTSTR szMetaName;
    BOOL    fRet;

    szMetaName = pMeta->GetAAname();

    if(szMetaName == NULL)
    {
        fRet = FALSE;
    }
    else
    {
        fRet = ! StrCmpIC( pMeta->GetAAname(), _T( "GENERATOR" ) );
    }

    return fRet;
}


//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::SetMetaToTrident
//
//  Synopsis:   Set the meta marker to trident
//
//----------------------------------------------------------------------------
HRESULT
CMarkup::SetMetaToTrident()
{
    HRESULT         hr = S_OK;
    TCHAR           achVersion [256];
    CMetaElement *  pMeta=NULL;
    
    if( Doc()->_fDontWhackGeneratorOrCharset
        WHEN_DBG( || IsTagEnabled(tagNoMetaToTrident) ) )
        goto Cleanup;

    hr = THR(LocateOrCreateHeadMeta(LocateGeneratorMeta, &pMeta));
    if (hr || !pMeta)
        goto Cleanup;

    hr = THR(
        pMeta->AddString(
            DISPID_CMetaElement_name, _T("GENERATOR"),
            CAttrValue::AA_Attribute));
    if (hr)
        goto Cleanup;

    hr =
        Format(
            0, achVersion, ARRAY_SIZE(achVersion),
            _T("MSHTML <0d>.<1d2>.<2d4>.<3d>"), VER_PRODUCTVERSION);
    if (hr)
        goto Cleanup;

    hr = THR(pMeta->SetAAcontent(achVersion));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN( hr );
}

// defined in mshtml\src\other\misc\weboc.cxx
LPCTSTR VariantToStrCast(const VARIANT *pvar);

HRESULT
CMarkup::ViewLinkWebOC(VARIANT * pvarUrl,
                       VARIANT * pvarFlags,
                       VARIANT * pvarFrameName,
                       VARIANT * pvarPostData,
                       VARIANT * pvarHeaders)

{
    HRESULT           hr;
    CObjectElement  * pObjectElement = NULL;
    IWebBrowser2    * pWebBrowser    = NULL;
    IBrowserService * pBrowserSvc    = NULL;

    BSTR              bstrClassId    = SysAllocString(_T("clsid:8856F961-340A-11D0-A96B-00C04FD705A2")); // WebOC

    CVariant          varSize(VT_BSTR);
    CVariant          cvarWindowID(VT_I4);
    COmWindowProxy  * pProxy = GetWindowPending();
    CWindow         * pWindow;
    
    if (bstrClassId == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    if (pProxy == NULL)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    pWindow = pProxy->Window();

    if (pWindow == NULL)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = CreateElement(ETAG_OBJECT, (CElement**) &pObjectElement);
    if (hr)
        goto Cleanup;

    pObjectElement->_fViewLinkedWebOC = TRUE;

    hr = Root()->InsertAdjacent(CElement::AfterBegin, pObjectElement);
    if (hr)
        goto Cleanup;

    V_BSTR(&varSize) = SysAllocString(_T("100%"));

    hr = pObjectElement->put_VariantHelper(varSize, (PROPERTYDESC*)&s_propdescCObjectElementwidth);
    if (hr)
        goto Cleanup;

    hr = pObjectElement->put_VariantHelper(varSize, (PROPERTYDESC*)&s_propdescCObjectElementheight);
    if (hr)
        goto Cleanup;

    hr = pObjectElement->put_classid(bstrClassId);
    if (hr)
        goto Cleanup;

    hr = pObjectElement->QueryInterface(IID_IWebBrowser2, (void**)&pWebBrowser);
    if (hr)
        goto Cleanup;

    Assert(!pWindow->_dwWebBrowserEventCookie);
    Assert(!pWindow->_punkViewLinkedWebOC);

    pWindow->_punkViewLinkedWebOC = pObjectElement->PunkCtrl();
    pWindow->_punkViewLinkedWebOC->AddRef();

    hr = ConnectSink(pWindow->_punkViewLinkedWebOC,
                     DIID_DWebBrowserEvents2,
                     (IUnknown*)(IPrivateUnknown*)pWindow,
                     &pWindow->_dwWebBrowserEventCookie);
    if (hr)
        goto Cleanup;

    hr = IUnknown_QueryService(pWindow->_punkViewLinkedWebOC,
                               SID_SShellBrowser,
                               IID_IBrowserService,
                               (void**)&pBrowserSvc);
    if (hr)
        goto Cleanup;

    if (!pWindow->_dwViewLinkedWebOCID)
    {
        pWindow->_dwViewLinkedWebOCID = pBrowserSvc->GetBrowserIndex();
    }
    else
    {
        V_I4(&cvarWindowID) = pWindow->_dwViewLinkedWebOCID;

        IGNORE_HR(CTExec(pBrowserSvc,
                         &CGID_DocHostCmdPriv,
                         DOCHOST_SETBROWSERINDEX,
                         NULL,
                         &cvarWindowID,
                         NULL));
    }

    if (VariantToStrCast(pvarUrl))
    {
        // This is a bug fix for # 26636.  There is a scenerio where we shdocvw
        // brings up a Modal dialog in CDocObjectHost before navigating to a media
        // page.  If navigation happens via a TIMER message through script before
        // the user responds to the dialog, then the instance of CDocObjectHost
        // gets deleted causing a crash.  There doesn't seem to be a way to block
        // navigation in that particular scenerio from shdocvw.  So we're blocking
        // navigation in Trident before delegating navigation to shdocvw for
        // Media pages.

        HRESULT             hrtmp = E_FAIL;
        IUnknown            *pUnk = NULL;

        if (pWindow->_pBindCtx)
        {
            hrtmp = pWindow->_pBindCtx->GetObjectParam(_T("MediaBarMime"), &pUnk);
            if (hrtmp == S_OK)
                _pDoc->EnableModeless(FALSE);
        }

        hr = NavigateWebOCWithBindCtx(pWebBrowser, pvarUrl, pvarFlags, pvarFrameName,
                                      pvarPostData, pvarHeaders, pWindow->_pBindCtx,
                                      CMarkup::GetUrlLocation(this));

        if (hrtmp == S_OK)
        {
            _pDoc->EnableModeless(TRUE);
            if (pUnk)
                pUnk->Release();
        }
    }
    else
    {
        hr = pWebBrowser->Navigate2(pvarUrl, pvarFlags, pvarFrameName, pvarPostData, pvarHeaders);
    }
    if (hr)
        goto Cleanup;
        
Cleanup:
    if (pObjectElement)
        pObjectElement->Release();

    if (pWebBrowser != NULL)
        ReleaseInterface(pWebBrowser);

    if (bstrClassId != NULL)
        SysFreeString(bstrClassId);

    ReleaseInterface(pBrowserSvc);

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::OnLoadStatus
//
//  Synopsis:   Handle change in download status
//
//  [ htc dependency ]
//
//----------------------------------------------------------------------------

void
CMarkup::OnLoadStatus(LOADSTATUS LoadStatus)
{
    // NOTE (lmollico): we need to addref CMarkup because CDoc::OnLoadStatus can cause 
    // this (CMarkup) to be destroyed if the doc is unloaded
    AddRef();

    while (_LoadStatus < LoadStatus)
    {                
        AssertSz(CPeerHolder::IsMarkupStable(this), "CMarkup::OnLoadStatus appears to be called at an unsafe moment of time");
        
        // if we are not yet LOADSTATUS_INTERACTIVE, we will call ProcessPeerTasks when 
        // the posted SetInteractive is processed
        if (_LoadStatus >= LOADSTATUS_INTERACTIVE)
        {
            ProcessPeerTasks(0); // NOTE an important assumption here is that this is ONLY called
                                 // at a safe moment of time to run external code
        }

        _LoadStatus = (LOADSTATUS) (_LoadStatus + 1);

        PerfDbgLog1(tagPerfWatch, this, "+CMarkup::OnLoadStatus %s",
            LoadStatus == LOADSTATUS_INTERACTIVE ? "INTERACTIVE" :
            LoadStatus == LOADSTATUS_PARSE_DONE ? "PARSE_DONE" :
            LoadStatus == LOADSTATUS_QUICK_DONE ? "QUICK_DONE" :
            LoadStatus == LOADSTATUS_DONE ? "DONE" : "?");


        switch (_LoadStatus)
        {
            case LOADSTATUS_INTERACTIVE:
                OnLoadStatusInteractive();
                break;

            case LOADSTATUS_PARSE_DONE:
                {
                    BOOL fComplete = OnLoadStatusParseDone();
                    if (fComplete)
                        goto Cleanup;
                }
                break;

            case LOADSTATUS_QUICK_DONE:
                OnLoadStatusQuickDone();
                break;

            case LOADSTATUS_DONE:
                {
                    BOOL fComplete = OnLoadStatusDone();

                    if (g_fInMoney98 && _pDoc && IsPrimaryMarkup())
                    {
                        // during certain navigations, Money turns off painting
                        // on their host window and never sends a repaint message
                        // to the Trident child window.  Here's a hack to work
                        // around this.  [See bug 106189 - sambent.]
                        _pDoc->Invalidate();
                    }

                    if (fComplete)
                        goto Cleanup;
                }
                break;

            default:
                Assert(0 && "Bad enum value");
                goto Cleanup;
        }

        //
        // send to html component, if any

        if (HasBehaviorContext() && BehaviorContext()->_pHtmlComponent)
        {
            BehaviorContext()->_pHtmlComponent->OnLoadStatus(_LoadStatus);
        }
    }

Cleanup:
    Release();
}

//+---------------------------------------------------------------------------
//
//  Member  :   CMarkup::OnLoadStatusInteractive
//
//  Synopsis:   Handles the LOADSTATUS_INTERACTIVE case for OnLoadStatus
//
//----------------------------------------------------------------------------

void
CMarkup::OnLoadStatusInteractive()
{
    if ((GetReadyState() < READYSTATE_INTERACTIVE) && !_fIsInSetInteractive)
    {
        RequestReadystateInteractive();
    }                                              

    // If we have a task to look for a certain scroll position,
    // make sure we have recalc'd at least to that point before
    // display.

    // Supress scrollbits if we're about to inval the entire window anyway
    // $$anandra Consider if this inval stuff should be on doc or markup.  
    //           has relevance if CView is per CDoc or CMarkup.  
    //
    NavigateNow(!_pDoc->_fInvalNoninteractive);

    // If we have prviously supressed invalidations before LOADSTATUS_INTERACTIVE,
    // we must invalidate now.
    //
    if (_pDoc->_fInvalNoninteractive)
    {
        _pDoc->_fInvalNoninteractive = FALSE;
        _pDoc->Invalidate(NULL, NULL, NULL, INVAL_CHILDWINDOWS);
    }


    // for frame markup's, the only way to get them added to history is to call
    // AddUrl, BUT, at DocNavigate time we didn't know the friendly URL name,
    // so do it now.
    //
    // only do this for windowed (frame) markups and only if this is due ot a navigation
    // and not to inital loading.
    if(   HtmCtx()
       && (   _fNavFollowHyperLink
           && !IsPrimaryMarkup()
           && !IsPendingPrimaryMarkup()
           )
       && Doc()->_pUrlHistoryStg // should have been Ensured in DoNavigate()
       && !_fServerErrorPage) 
    {
        BSTR bstrTitle = NULL;
        BSTR bstrUrl = SysAllocString (GetUrl(this));

        if (bstrUrl)
        {
            if (GetTitleElement() && GetTitleElement()->_cstrTitle)
            {
                GetTitleElement()->_cstrTitle.AllocBSTR(&bstrTitle);
            }
            else
            {
                // This is wrong. Steal the code from CDoc::UpdateTitle() to
                // create the correct title for file:// url's
                bstrTitle = SysAllocString(_T(""));
            }

            Doc()->_pUrlHistoryStg->AddUrl(bstrUrl, 
                                           bstrTitle, 
                                           ADDURL_ADDTOHISTORYANDCACHE);

            SysFreeString(bstrTitle);

            SysFreeString(bstrUrl);
        }
    }
}


//-------------------------------------------------------------------------------------
//
//  used to see if the image toolbar is explicitly disabled by a meta tag or not...
//  see CMetaElement::IsGalleryMeta() in hedelems.cxx
//
//-------------------------------------------------------------------------------------

BOOL CMarkup::IsGalleryMode()
{

    BOOL bFlag=TRUE;

    if (GetHeadElement())
    {
        CTreeNode *pNode;
        CChildIterator ci ( GetHeadElement() );
 
        //
        // ToDO: Query host and detect if theme is on
        //
 
        while ( (pNode = ci.NextChild()) != NULL )
        {
            if (pNode->Tag() == ETAG_META )
            {
                if (!DYNCAST(CMetaElement,pNode->Element())->IsGalleryMeta())
                {
                    bFlag=FALSE;
                }
            }
        }
    }
    return bFlag;
}

//+---------------------------------------------------------------------------
//
//  Member  : CMarkup::OnLoadStatusParseDone
//
//  Synopsis: Handles the LOADSTATUS_PARSE_DONE case for OnLoadStatus
//
//  Return  : TRUE indicates that OnLoadStatus if complete and should not
//            continue processing.
//
//----------------------------------------------------------------------------

BOOL
CMarkup::OnLoadStatusParseDone()
{
    HRESULT hr;
    BOOL    fComplete = FALSE;
    BOOL    fIsPrimaryMarkup = IsPrimaryMarkup();

    // Reset this flag. We may not do navigation delegation so we need the extra initialization
    // This get reset to false when navigating a frame, but that's okay because you must have
    // delegatated -- you're in html.
    _pDoc->_fDelegatedDownload = FALSE;

    // In design mode, set META generator tag to Trident, and
    // clear the dirty bit.
    if (_fDesignMode)
    {
        // Setting this meta tag is still part of the 
        // parse phase.  Because of this, we can safely
        // not save undo info if we end up sticking in a
        // meta tag here.
        Assert(!_fNoUndoInfo );
        _fNoUndoInfo = TRUE;

        IGNORE_HR(SetMetaToTrident());
        _fNoUndoInfo = FALSE;              
    }
/*
    // if a gallery meta tag exists, tell shdocvw to turn off image hoverbar thingie
    ITridentService2 *pTriSvc2;

    if (_pDoc->_pTridentSvc 
        && SUCCEEDED(_pDoc->_pTridentSvc->QueryInterface(IID_ITridentService2, (void **)&pTriSvc2))) 
    {
        pTriSvc2->IsGalleryMeta(IsGalleryMode());
        pTriSvc2->Release();
    }
*/
    ProcessMetaPicsDone();

    CHtmCtx * pHtmCtx = HtmCtx();

    // When htm loading is complete, first check for failure
    // and alternate URL. If they exist, do a reload
    //
    if (    pHtmCtx
        &&  (pHtmCtx->GetState() & DWNLOAD_ERROR)
        &&  !IsSpecialUrl(GetUrl(this)))
    {
        HRESULT hrBindResult = pHtmCtx->GetBindResult();

        if ( IsPrimaryMarkup() )
        {
            _pDoc->_fNeedUpdateTitle = FALSE;
        }
        
        if (pHtmCtx->GetFailureUrl())
        {
            IStream * pStreamRefresh;

            pStreamRefresh = pHtmCtx->GetRefreshStream();
            if (pStreamRefresh)
            {
                pStreamRefresh->AddRef();

                // TODO (CARLED) there is currently an assert and memory leak here, 
                // (bug 106014)
                // We are replacing this markup without releaseing it. We're 
                // not navigating to the failureUrl, or switching markups, but just loading 
                // ontop of the current one. See LoadFailureUrl for more comments

                IGNORE_HR(LoadFailureUrl(pHtmCtx->GetFailureUrl(), pStreamRefresh));
                ClearInterface(&pStreamRefresh);

                fComplete = TRUE;
                goto Cleanup;
            }
        }
        else if (hrBindResult)
        {
            if (  hrBindResult == E_ABORT  || hrBindResult == E_ACCESSDENIED)
            {
                if (pHtmCtx->GetMimeInfo() == g_pmiTextHtml && !(_pDoc->_dwLoadf & DLCTL_SILENT))
                {
                    IGNORE_HR(_pDoc->ShowLoadError(pHtmCtx));
                }
            }
            else if (  hrBindResult != HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)
                    && hrBindResult != HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND))
            {
                Assert(_pDoc->_pClientSite);

                CTExec(_pDoc->_pClientSite, &CGID_ShellDocView,
                       SHDVID_NAVIGATEFROMDOC, 0, NULL, NULL);

                if (this == GetFrameOrPrimaryMarkup())
                {
                    // If DelegateNavigation returns TRUE, we must
                    // continue processing the rest of this method
                    // but tell the caller that we have completed
                    // our function.
                    //
                    hr = _pDoc->DelegateNavigation(hrBindResult, NULL, NULL, this, NULL, &fComplete);
                    if (hr)
                    {
                        fComplete = TRUE;
                        goto Cleanup;
                    }
                }
            }
        }
    }
    else
    {
        _fLoadingHistory  = FALSE;
    }

    if (fIsPrimaryMarkup)
    {
        _pDoc->_fShdocvwNavigate  = FALSE;
    }
    
    if (HasWindowPending())
    {
        GetWindowPending()->Window()->_fHttpErrorPage = FALSE;
    }

    // If the currency has not been set, set it to the client element.
    _pDoc->DeferSetCurrency(0);

    // Now is the time to ask the sites to load any history
    // that they could not earlier (e.g. scroll/caret positions
    // because they require the doc to be recalced, the site
    // arrays built, etc.)
    {
        CMarkupTransNavContext * ptnc;
        if (    _pDoc->State() >= OS_INPLACE 
            &&  HasTransNavContext()
            &&  (ptnc = GetTransNavContext())->_fDoDelayLoadHistory)
        {
            CNotification   nf;

            ptnc->_fDoDelayLoadHistory = FALSE;
            EnsureDeleteTransNavContext(ptnc);

            nf.DelayLoadHistory(Root());
        
            Assert(!_fNoUndoInfo );
            _fNoUndoInfo = TRUE;

            Notify(&nf);
            _fNoUndoInfo = FALSE;
        }
    }

    // Let the host know that parsing is done and they are free
    // to modify the document.

    if (_pDoc->_pClientSite && fIsPrimaryMarkup)
    {
        CTExec(_pDoc->_pClientSite, (GUID *)&CGID_MSHTML,
               IDM_PARSECOMPLETE, 0, NULL, NULL);
    }

    hr = THR(LoadSlaveMarkupHistory());
    if (hr)
        fComplete = TRUE;

    _fLoadHistoryReady = TRUE;

    if (HasWindow())
       Window()->Window()->_fRestartLoad = FALSE;

Cleanup:
    return fComplete;
}

//+-----------------------------------------------------------------------------
//
//  Member  : CDoc::DelegateNavigation
//
//  Synopsis: Delegates the navigation to shdocvw. This is done primarily
//            for non-html mime types.
//
//  Output  : pfDelegated - TRUE indicates that shdocvw handled the navigation.
//
//------------------------------------------------------------------------------

HRESULT 
CDoc::DelegateNavigation(HRESULT        hrBindResult,
                         const TCHAR  * pchUrl,
                         const TCHAR  * pchLocation,
                         CMarkup      * pMarkup,
                         CDwnBindInfo * pDwnBindInfo,
                         BOOL         * pfDelegated,
                         VARIANT      * pvarFrameName)
{
    HRESULT          hr = S_OK;
    CVariant         varFlags(VT_EMPTY);
    CDwnDoc        * pDwnDoc             = NULL;
    CVariant         cvarUrl(VT_BSTR);
    CDwnPost       * pDwnPost            = NULL;
    TCHAR          * pchHeader           = NULL;
    CVariant       * pvarPostData        = NULL;
    CVariant       * pvarHeader          = NULL;
    CVariant         varHeader(VT_BSTR);
    CVariant         varArray(VT_ARRAY);
    SAFEARRAY      * psaPostData         = NULL;
    BOOL             fDelegated          = FALSE;
    COmWindowProxy * pWindowPrxy         = pMarkup ? pMarkup->GetWindowPending() : NULL;
    CDwnPostStm    * pDwnPostStm         = NULL;
    char           * pBuffer             = NULL;
    
    Assert(!(pMarkup && (pchUrl || pDwnBindInfo)));

    if (pMarkup)
    {
        pMarkup->TerminateLookForBookmarkTask();

        pDwnDoc = pMarkup->GetDwnDoc();
        pDwnPost = pMarkup->GetDwnPost();
    }
    else if (pDwnBindInfo)
    {
        pDwnDoc = pDwnBindInfo->GetDwnDoc();
        pDwnPost = pDwnBindInfo->GetDwnPost();
    }

    if (pDwnDoc && (pDwnDoc->GetBindf() & BINDF_HYPERLINK))
    {
        V_VT(&varFlags) = VT_I4;
        V_I4(&varFlags) = navHyperlink;
    }

    if (pWindowPrxy && pWindowPrxy->Window()->_fRestricted)
    {
        V_VT(&varFlags) = VT_I4;
        V_I4(&varFlags) |= navEnforceRestricted;        
        if (pMarkup->GetDwnDoc()->GetDocIsXML())
        {
            hr = E_ACCESSDENIED;
            goto Cleanup;
        }
        
            
    }
    
    // This variable is initialized by a call to _pDoc->_fDelegatedDownload = FALSE;

    // Extract postdata and headers
    if (pDwnPost)
    {        
        // TODO (MohanB) Should pass header to Navigate2() even when there is no post data?
        //
        if (!pMarkup)
        {
            TCHAR   achNull[1];
            
            achNull[0] = 0;
            hr = THR(pDwnBindInfo->BeginningTransaction(pchUrl, achNull, 0, &pchHeader));
            if (hr)
                goto Cleanup;
        }
        
        V_BSTR(&varHeader) = SysAllocString(pMarkup ? pMarkup->GetDwnHeader() : pchHeader);
        if (NULL == V_BSTR(&varHeader))
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        
        pvarHeader = &varHeader;

        pDwnPostStm = new CDwnPostStm(pDwnPost);
        if (!pDwnPostStm)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        
        DWORD dwBufferSize;
        hr = pDwnPostStm->ComputeSize(&dwBufferSize);
        if (hr)
        {
            goto Cleanup;
        }
     
        if (dwBufferSize != 0)
        {
            pBuffer = new(Mt(CDocDelegateNavigation_pBuffer)) char[dwBufferSize];        
            if (!pBuffer)
            {       
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }        
        
            DWORD dwBufferFilled = 0;
            hr = pDwnPostStm->Read(pBuffer, dwBufferSize, &dwBufferFilled);
            if (hr)
            {
                goto Cleanup;
            }

            Assert(dwBufferSize == dwBufferFilled);

            psaPostData = SafeArrayCreateVector(VT_UI1, 0, dwBufferSize);
            if (!psaPostData)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }

            Assert(psaPostData->pvData);
            memcpy(psaPostData->pvData, pBuffer, dwBufferSize);

            V_ARRAY(&varArray) = psaPostData;
            pvarPostData = &varArray;        
        }
    }

    V_BSTR(&cvarUrl) = SysAllocString(pMarkup ? CMarkup::GetUrl(pMarkup) : pchUrl);
    if (NULL == V_BSTR(&cvarUrl))
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    if (   pMarkup
        && pWindowPrxy
        && pWindowPrxy != _pWindowPrimary)
    {
        if (    pWindowPrxy->Window()->_pWindowParent
            ||  (pMarkup->Root()->HasMasterPtr() && hrBindResult == INET_E_TERMINATED_BIND))
        {
            // Note: If there is currently no ViewLinked WebOC releasing is still okay.

            pWindowPrxy->Window()->ReleaseViewLinkedWebOC();

            hr = pMarkup->ViewLinkWebOC(&cvarUrl, &varFlags, NULL, pvarPostData, pvarHeader);
            if (hr == S_OK)
            {
                fDelegated = TRUE;
            }
        }
    }
    else if (_pTopWebOC)
    {
        SetHostNavigation(TRUE);

        IBindCtx * pBindCtx = NULL;

        if (pWindowPrxy)
        {
            pBindCtx = pWindowPrxy->Window()->_pBindCtx;
        }

        hr = NavigateWebOCWithBindCtx(_pTopWebOC, &cvarUrl, &varFlags, pvarFrameName,
                                      pvarPostData, pvarHeader, pBindCtx,
                                      pchLocation ? pchLocation : CMarkup::GetUrlLocation(pMarkup));

        fDelegated = TRUE;
        _fDelegatedDownload = TRUE;
    }

Cleanup:
    if (pchHeader)
    {
        CoTaskMemFree(pchHeader);
    }

    if (pfDelegated)
    {
        *pfDelegated  = fDelegated;
    }

    if (pWindowPrxy)
    {
        ClearInterface(&pWindowPrxy->Window()->_pBindCtx);
    }

    if (psaPostData)
    {
        SafeArrayDestroy(psaPostData);  // CVariant won't destroy the safearray.
    }

    if (pDwnPostStm)
    {
        pDwnPostStm->Release();
    }
    
    if (pBuffer)
    {
        delete [] pBuffer;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member  :   CMarkup::OnLoadStatusQuickDone
//
//  Synopsis:   Handles the LOADSTATUS_QUICK_DONE case for OnLoadStatus
//
//----------------------------------------------------------------------------

void 
CMarkup::OnLoadStatusQuickDone()
{
    CHtmlComponent *pComponent = NULL;
    CScriptCollection * pScriptCollection;

        // TODO (alexz) understand why is this necessary; might be a leftover to remove
    if (HasScriptContext())
    {
        ScriptContext()->_fScriptExecutionBlocked = FALSE;
    }

    IGNORE_HR(_pDoc->CommitDeferredScripts(FALSE, this));
    if (HasBehaviorContext())
    {
        pComponent = BehaviorContext()->_pHtmlComponent;
    }

    if (!pComponent || !pComponent->_fFactoryComponent)
        IGNORE_HR(_pDoc->CommitScripts(this));

    // JHarding: We should only do the SetState once we've finished parsing the frame
    if (!_fDesignMode && HasScriptCollection() )
    {
        pScriptCollection = GetScriptCollection();
        if (pScriptCollection)
            IGNORE_HR(pScriptCollection->SetState(SCRIPTSTATE_CONNECTED));
    }

    Assert(IsSplayValid());

#ifndef NO_DATABINDING
    SetDataBindingEnabled(TRUE);    // do any deferred databinding
#endif // ndef NO_DATABINDING

#if 0
    // CONSIDER (alexz) (1) _fSendDocEndParse can be on per tree basis
    //                  (2) this could be on per element basis, so to avoid full tree walk
    if (_pDoc->_fSendDocEndParse)
    {
        CNotification   nf;

        nf.DocEndParse(Root());
        _pDoc->BroadcastNotify(&nf);
    }
#endif
    IGNORE_HR( SendDocEndParse() );

    if (HasTransNavContext())
    {
        CMarkupTransNavContext * ptnc = GetTransNavContext();
        if (ptnc->_fGotHttpExpires)
        {
            ptnc->_fGotHttpExpires = FALSE;
            EnsureDeleteTransNavContext(ptnc);
        }
    }

    if (Document())
    {
        // Try to play the page transitions
        Document()->PlayPageTransitions();
    }

    if (   IsPrimaryMarkup()
        && _pDoc->_fPrintJobPending
        && Window())
    {
        _pDoc->_fPrintJobPending = FALSE;
        Window()->Window()->print();
    }
}

//+---------------------------------------------------------------------------
//
//  Member  :   CMarkup::OnLoadStatusDone
//
//  Synopsis:   Handles the LOADSTATUS_DONE case for OnLoadStatus
//
//  Return  : TRUE indicates that OnLoadStatus if complete and should not
//            continue processing.
//
//----------------------------------------------------------------------------

BOOL
CMarkup::OnLoadStatusDone() 
{
    BOOL fComplete = FALSE;
    CHtmCtx * pHtmCtx = HtmCtx();
    
    if (Doc()->IsShut() || !pHtmCtx)
    {
        return TRUE;
    }

    if (   _pDoc->_pTridentSvc
        && _pDoc->_fIsActiveDesktopComponent
        && IsPrimaryMarkup() )
    {
        IGNORE_HR(_pDoc->_pTridentSvc->UpdateDesktopComponent(Window()));
    }

    // Transfer extended tag table ownership to markup
    //
    IGNORE_HR(pHtmCtx->TransferExtendedTagTable(this));

    CScriptCollection * pScriptCollection = GetScriptCollection();
    COmWindowProxy * pWindowPrxy = Window();            

    if (pScriptCollection)
        pScriptCollection->AddRef();

    CDwnDoc * pDwnDoc = GetDwnDoc();

    ShowWaitCursor(FALSE);    
    GWKillMethodCall(this, ONCALL_METHOD(CMarkup, SetInteractiveInternal, setinteractiveinternal), 0);
    if (_fInteractiveRequested)
    {
        Doc()->UnregisterMarkupForModelessEnable(this);
        _fInteractiveRequested = FALSE;
    }
    
    if (_pDoc->_pClientSite)
    {
        CTExec(_pDoc->_pClientSite, NULL, OLECMDID_HTTPEQUIV_DONE,
               0, NULL, NULL);
    }

    if (pWindowPrxy)
    {
        pWindowPrxy->Window()->StartMetaRefreshTimer();
    }

    // Unfreeze events now that document is fully loaded.
    {
        CNotification nf;
        
        nf.FreezeEvents(Root(), (void *)FALSE);
        Notify(&nf);
    }

    // MULTI_LAYOUT
    // If this root elem has a master ptr, our master might be a layout rect,
    // in which case this document is its content.  We need to notify the
    // containing layout rect so it can measure its view chain.
    // (Moved from CRootElement::Notify handling DOC_END_PARSE, which it wasn't
    // guaranteed to get.
    if ( Root()->HasMasterPtr() )
    {
        CElement *pMaster = Root()->GetMasterPtr();
        if ( pMaster->IsLinkedContentElement() )
        {
            pMaster->UpdateLinkedContentChain();
        }
    }

    SetReadyState(READYSTATE_COMPLETE);

    // Fire the DocumentComplete event. 
    //
    if (   !_fInRefresh
        && pWindowPrxy
        && !(_pDoc->_fHostNavigates && IsPrimaryMarkup()))
    {
#if DBG==1
        // This used to be an assert, changing to a trace tag for Whistler RC1. 
        if(pWindowPrxy->_pCWindow->_pMarkupPending)
        {
            TraceTag((tagPendingAssert, "OnLoadStatusDone: pending markup when none expected - this:[0x%x] pending markup:[0x%x]",
              this, pWindowPrxy->_pCWindow->_pMarkupPending));

        }
#endif

        // Don't fire the event if we are a ViewLinkedWebOC

        if (!pWindowPrxy->Window()->_punkViewLinkedWebOC)
        {
            _pDoc->_webOCEvents.DocumentComplete(pWindowPrxy, GetUrl(this), GetUrlLocation(this));
        }

        if (!HtmCtx() || pWindowPrxy->_pCWindow->_pMarkupPending)
        {
            // The window has been navigated away to a different markup. Leave
            // without firing any other events and without cleaning up the window
            // data (because that data now belongs to the new markup).
            //
            UpdateReleaseHtmCtx();
            fComplete = TRUE;

            goto Cleanup;
        }
    }

    _fInRefresh = FALSE;

    // [kusumav] We really should be checking the following before setting _fDontFireWebOCEvents since
    // we check before setting the flag in DoNavigate and CMarkup::LoadFromInfo. But since we also explicitly
    // check for these flags in the event firing functions where we use the _fDontFireWebOCEvents we are okay
    // See Windows bug 535312 for more info
    //
    // if (pWindowPrxy && !pWindowPrxy->Window()->_fCreateDocumentFromUrl  
    //     && !_pDoc->_fInObjectTag && !_pDoc->_fInHTMLDlg )
        _pDoc->_fDontFireWebOCEvents = FALSE;

    if (IsPrimaryMarkup())
    {
        _pDoc->_fDontUpdateTravelLog = FALSE;
    }
    
    if (IsPrimaryMarkup())
    {
        _pDoc->_fStartup       = FALSE;
        _pDoc->_fNewWindowInit = FALSE;
    }

    _fNewWindowLoading = FALSE;

    // Fire window onfocus() to start with, if we have the focus, after frameset
    // or body has become current as this will not be fired in BecomeCurrent()
    if ((_pDoc->_pElemCurrent == GetElementClient()) && 
        (::GetFocus() == _pDoc->_pInPlace->_hwnd))
    {
        if (pWindowPrxy && _pDoc->_state >= OS_UIACTIVE)
        {
            pWindowPrxy->Post_onfocus();
        }
    }

    if (pWindowPrxy)
    {
        pWindowPrxy->Window()->DetachOnloadEvent();
        pWindowPrxy->Window()->ClearWindowData();
    }

    // We have to get the HtmCtx again because another
    // navigation can occur in a handler for DocumentComplete.
    //
    pHtmCtx = HtmCtx();

    // Do not fire onload if we are not inplace & either scripting is
    // disabled or we are a dialog.
    //
    if ( _pDoc->State() >= OS_INPLACE                                          || 
        (   !(_pDoc->_dwFlagsHostInfo & DOCHOSTUIFLAG_DISABLE_SCRIPT_INACTIVE)
         && !_pDoc->_fInHTMLDlg)                                                )
    {
        if (pWindowPrxy)
        {
            Assert(!pWindowPrxy->_pCWindow->_pMarkupPending);

            // Note that Netscape fires onunload later even if it hadn't fired onload
            Assert(!pWindowPrxy->_fFiredOnLoad);
            pWindowPrxy->_fFiredOnLoad = TRUE;
        }

        // 18849: fire onload only if load was not interrupted

        if (  pHtmCtx &&
            !(pHtmCtx->GetState() & (DWNLOAD_ERROR | DWNLOAD_STOPPED)))
        {
            // TODO (carled) this is temporary until we can fix the parser to allow
            // these events at enterTree time.
            // $$anandra This history and shortcut stuff needs to be reworked.  
            // trident should not know anything special about these behaviors.  
            CMarkupBehaviorContext * pContext = NULL;

            THR(EnsureBehaviorContext(&pContext));

            if ((pContext && pContext->_cstrHistoryUserData) || Doc()->_pShortcutUserData)
                FirePersistOnloads();

            if (pWindowPrxy)
            {
                // Report pending script errors 
                pWindowPrxy->Window()->HandlePendingScriptErrors(TRUE);

                Assert(pHtmCtx && GetProgSink());
                pWindowPrxy->Fire_onload();

                if (!pHtmCtx || !GetProgSink())
                {
                    // This markup has been unloaded and passivated during onload event
                    // processing. Cleanup and leave.         
                    //
                    fComplete = TRUE;
                    goto Cleanup;
                }
            }
        }

        // Let the client site know we are loaded
        // Only HTMLDialog pays attention to this
        if (pWindowPrxy && _pDoc->_pClientSite && _pDoc->_fInHTMLDlg)
        {
            CTExec(_pDoc->_pClientSite, &CLSID_HTMLDialog,
                   0, 0, NULL, NULL);
        }
    }

    if (Document() && Document()->HasPageTransitionInfo())
    {
        // make sure we will execute the page-exit for the next navigation
        Document()->GetPageTransitionInfo()->ShiftTransitionStrings();
    }

    if (!_fDesignMode)
    {
        // $$anandra Fix me
        CElement * pElemDefault = _pDoc->_pElemCurrent ?
                                  _pDoc->_pElemCurrent->FindDefaultElem(TRUE) : 0;
        if (pElemDefault)
        {
            CNotification nf;

            nf.AmbientPropChange(pElemDefault, (void *)DISPID_AMBIENT_DISPLAYASDEFAULT);
            pElemDefault->_fDefault = TRUE;
            pElemDefault->Notify(&nf);
        } 
    }
    else
    {
        //
        // We may have been flipped from edit to browse back to edit.
        // In which case the _fShowZeroBorder Bit is correctly set,
        // but we need to fire a notification through the document to 
        // let everyone know.
        //
        if (IsShowZeroBorderAtDesignTime())
        {
            CNotification nf;
            nf.ZeroGrayChange(GetElementTop());
            Notify(&nf);
        } 
    }
    
    // From now on, new downloads don't follow the refresh binding
    // flags used to load the document.
    // $$anandra fixme.  
    if (pDwnDoc)
        pDwnDoc->SetBindf(pDwnDoc->GetBindf() &
        ~(BINDF_RESYNCHRONIZE|BINDF_GETNEWESTVERSION|
            BINDF_PRAGMA_NO_CACHE));

    // If the document was loaded due to an http 449 status code, we need to kick off a refresh
    // now that we're done loading

    if (pHtmCtx && pHtmCtx->IsHttp449())
    {
        IGNORE_HR(GWPostMethodCall(Window(),
                                   ONCALL_METHOD(COmWindowProxy, ExecRefreshCallback, execrefreshcallback),
                                   OLECMDIDF_REFRESH_NORMAL | OLECMDIDF_REFRESH_CLEARUSERINPUT,
                                   FALSE, "COmWindowProxy::ExecRefreshCallback"));
    }

#if DBG==1 || defined(PERFTAGS)
    if (IsPerfDbgEnabled(tagDocBytesRead))
    {
        VARIANT vt;
        _pDoc->ExecHelper(pWindowPrxy ? pWindowPrxy->Document() : NULL, (GUID *)&CGID_MSHTML, IDM_GETBYTESDOWNLOADED,
            MSOCMDEXECOPT_DONTPROMPTUSER, NULL, &vt);
        Assert(pDwnDoc->GetBytesRead() == (DWORD)vt.lVal);
        PerfDbgLog1(tagDocBytesRead, this, "CDoc::OnLoadStatus (%ld bytes downloaded)", vt.lVal);
    }
#endif

    if (g_pHtmPerfCtl && 
        (g_pHtmPerfCtl->dwFlags &
         (HTMPF_CALLBACK_ONLOAD|HTMPF_CALLBACK_ONLOAD2
#ifndef NO_ETW_TRACING
          |HTMPF_CALLBACK_ONEVENT
#endif
          )) && 
        IsPrimaryMarkup())
    {
#ifndef NO_ETW_TRACING
        // Send event to ETW if it is enabled by the shell.
        // We do NOT want to do a WaitForRecalc.
        if (g_pHtmPerfCtl->dwFlags & HTMPF_CALLBACK_ONEVENT) {
            g_pHtmPerfCtl->pfnCall(EVENT_TRACE_TYPE_BROWSE_LOADEDPARSED,
                                   (TCHAR *)GetUrl(this));
        }
        else {
#endif
            // We shouldn't calc a print doc at this point because our view isn't initialized yet (42603).
            if (!_pDoc->IsPrintDialogNoUI())
                _pDoc->WaitForRecalc(this);
            
            if (g_pHtmPerfCtl->dwFlags & HTMPF_CALLBACK_ONLOAD)
                g_pHtmPerfCtl->pfnCall(HTMPF_CALLBACK_ONLOAD, (TCHAR *)GetUrl(this));
            
            if (g_pHtmPerfCtl->dwFlags & HTMPF_CALLBACK_ONLOAD2)
                g_pHtmPerfCtl->pfnCall(HTMPF_CALLBACK_ONLOAD, (IUnknown*)(IPrivateUnknown*)_pDoc);
#ifndef NO_ETW_TRACING
        }
#endif
    }


    // Display the error page if this was a frame
    // and the src URL was not found.
    //
    if (pWindowPrxy && pHtmCtx && !(HasBehaviorContext() && BehaviorContext()->_pHtmlComponent))
    {
        HRESULT hrBindResult = pHtmCtx->GetBindResult();

        if (E_ABORT == hrBindResult || ! IsPrimaryMarkup())
        {
            if (    HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hrBindResult
                ||  HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND) == hrBindResult
                ||  (E_ABORT == hrBindResult && !_fStopDone))
            {
                _pDoc->_fDontUpdateTravelLog = TRUE;
                DoAutoSearch(hrBindResult, pWindowPrxy->_pWindow);
            }
        }
    }

    // release HtmCtx if it is no longer used
    UpdateReleaseHtmCtx();

Cleanup:
    if (pScriptCollection)
        pScriptCollection->Release();

    return fComplete;
}

//+---------------------------------------------------------------------------
//
//  Member   : CMarkup::DoAutoSearch()
//
//  Synopsis : In the case of a binding error, this method will perform an
//             autosearch for the top-level window. In the case of an HTTP
//             error (e.g., 404) an error page will be displayed. The error
//             page will be displayed for the top-level and frame windows.
//
//----------------------------------------------------------------------------


void
CMarkup::DoAutoSearch(HRESULT        hrReason,
                      IHTMLWindow2 * pHTMLWindow,
                      IBinding     * pBinding /* = NULL */)
{
    long        lIdx = 0;
    HRESULT     hr;
    CVariant    cvarTemp(VT_I4);
    CVariant    cvarargIn(VT_ARRAY);
    CVariant    cvargOut(VT_BOOL);
    SAFEARRAY * psaNavData = NULL;
    SAFEARRAYBOUND sabound;

    Assert(hrReason);
    Assert(pHTMLWindow);

    sabound.cElements = 6;
    sabound.lLbound   = 0;

    psaNavData = SafeArrayCreate(VT_VARIANT, 1, &sabound);
    if (!psaNavData)
        goto Cleanup;

    // 0) hrReason
    //
    V_I4(&cvarTemp) = hrReason;

    hr = SafeArrayPutElement(psaNavData, &lIdx, &cvarTemp);
    if (hr)
        goto Cleanup;

    cvarTemp.Clear();

    // 1) URL
    //
    V_VT(&cvarTemp)   = VT_BSTR;
    V_BSTR(&cvarTemp) = SysAllocString(CMarkup::GetUrl(this));

    lIdx++;
    hr = SafeArrayPutElement(psaNavData, &lIdx, &cvarTemp);
    if (hr)
        goto Cleanup;

    cvarTemp.Clear();

    // Binding
    if (pBinding)
    {
        V_VT(&cvarTemp) = VT_UNKNOWN;
    
        hr = THR(pBinding->QueryInterface(IID_IUnknown,
                                          (void**)&V_UNKNOWN(&cvarTemp)));
        if (hr)
            goto Cleanup;
    }

    // 2) Add the binding to the safearray even if it is NULL.
    //
    lIdx++;
    hr = SafeArrayPutElement(psaNavData, &lIdx, &cvarTemp);
    if (hr)
        goto Cleanup;

    cvarTemp.Clear();

    // 3) IHTMLWindow2 of the current window.
    //
    V_VT(&cvarTemp)      = VT_UNKNOWN;
    V_UNKNOWN(&cvarTemp) = pHTMLWindow;
    V_UNKNOWN(&cvarTemp)->AddRef();

    lIdx++;
    hr = SafeArrayPutElement(psaNavData, &lIdx, &cvarTemp);
    if (hr)
        goto Cleanup;

    cvarTemp.Clear();

    // 4) Do autosearch or show error page only.
    // If _fShdocvwNavigate is TRUE, we will attempt to 
    // do an autosearch. Otherwise, we will just display
    // the HTTP error page.
    //
    V_VT(&cvarTemp)   = VT_BOOL;
    V_BOOL(&cvarTemp) = _pDoc->_fShdocvwNavigate ? VARIANT_TRUE : VARIANT_FALSE;

    lIdx++;
    hr = SafeArrayPutElement(psaNavData, &lIdx, &cvarTemp);
    if (hr)
        goto Cleanup;

    //
    // 5) Propagate _fInRefresh Flag
    //
    cvarTemp.Clear();
    V_VT(&cvarTemp)   = VT_BOOL;
    V_BOOL(&cvarTemp) = _fInRefresh ? VARIANT_TRUE : VARIANT_FALSE;

    lIdx++;
    hr = SafeArrayPutElement(psaNavData, &lIdx, &cvarTemp);
    if (hr)
        goto Cleanup;

    V_ARRAY(&cvarargIn) = psaNavData;

    if (hrReason >= HTTP_STATUS_BAD_REQUEST && hrReason <= HTTP_STATUS_LAST)
    {
        Assert(GetWindowPending());
        CWindow * pCWindow = GetWindowPending()->Window();

        Assert(pCWindow);

        pCWindow->_fHttpErrorPage = TRUE;

        IGNORE_HR(CTExec(_pDoc->_pClientSite, &CGID_DocHostCmdPriv,
                         DOCHOST_NAVIGATION_ERROR, NULL, &cvarargIn, & cvargOut ));

        if ( (V_VT(&cvargOut) == VT_BOOL) && (V_BOOL(&cvargOut) == VARIANT_FALSE ) )
        {
            //
            // shdocvw did not delegate back to us
            // dont' update the travel log.
            //
            _pDoc->_fDontUpdateTravelLog = TRUE;
        }
    } 
    else
    {
        IGNORE_HR(CTExec(_pDoc->_pClientSite, &CGID_DocHostCmdPriv,
                         DOCHOST_NAVIGATION_ERROR, NULL, &cvarargIn, NULL));
    }

Cleanup:
    if (psaNavData)
    {
        SafeArrayDestroy(psaNavData);  // CVariant won't destroy the safearray.
    }
}

//+---------------------------------------------------------------------------
//
//  Member   : CMarkup::ResetSearchInfo()
//
//  Synopsis : Called upon a successful navigation, this code notifies the browser
//             that the search information should be reset.
//
//----------------------------------------------------------------------------

void
CMarkup::ResetSearchInfo( )
{
    if (_pDoc && _pDoc->_pClientSite)
    {
        IGNORE_HR(CTExec(_pDoc->_pClientSite, &CGID_DocHostCmdPriv,
                         DOCHOST_RESETSEARCHINFO, NULL, NULL, NULL));
    }
}

//+---------------------------------------------------------------------------
//
//  Member   : CMarkup::NoteErrorWebPage()
//
//  Synopsis : If a navigation is about to fail and display either the server's
//             or the friendly error page, tell shdocvw to avoid adding the entry
//             to history
//
//----------------------------------------------------------------------------

void
CMarkup::NoteErrorWebPage( )
{
    if (_pDoc && _pDoc->_pClientSite)
    {
        IGNORE_HR(CTExec(_pDoc->_pClientSite, &CGID_DocHostCmdPriv,
                         DOCHOST_NOTE_ERROR_PAGE, NULL, NULL, NULL));
    }
}

//+-------------------------------------------------------------------
//
//  Member:     EnsureTitle
//
//--------------------------------------------------------------------

HRESULT
CMarkup::EnsureTitle ( )
{
    HRESULT hr = S_OK;
    CElement *  pElementTitle = NULL;

    if (!GetTitleElement())
    {
        if (!GetHeadElement())
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        hr = THR( CreateElement( ETAG_TITLE_ELEMENT, & pElementTitle ) );

        if (hr)
            goto Cleanup;
        
        // TODO: watch how this might interfere with the parser!
        hr = THR( AddHeadElement( pElementTitle ) );

        if (hr)
            goto Cleanup;
    }
    
Cleanup:

    CElement::ClearPtr( & pElementTitle );
    
    RRETURN( hr );
}

//+-------------------------------------------------------------------
//
//  Member:     CRootSite::AddHeadElement
//
//  Synopsis:   Stores and addrefs element in HEAD.
//              Also picks out first TITLE element...
//
//--------------------------------------------------------------------

HRESULT
CMarkup::AddHeadElement ( CElement * pElement, long lIndex )
{
    HRESULT hr = S_OK;

    Assert( GetHeadElement() );

    if (lIndex >= 0)
    {
        CTreeNode * pNodeIter;
        CChildIterator ci ( GetHeadElement(), NULL, CHILDITERATOR_DEEP );

        while ( (pNodeIter = ci.NextChild()) != NULL )
        {
            if (lIndex-- == 0)
            {
                hr = THR(
                    pNodeIter->Element()->InsertAdjacent(
                        CElement::BeforeBegin, pElement ) );

                if (hr)
                    goto Cleanup;

                goto Cleanup;
            }
        }
    }

    // If the parser is still in the head while we are trying
    // to insert an element in the head, make sure we don't insert it in
    // front of the parser's frontier.
    
    if (_pRootParseCtx)
    {
        CTreePosGap tpgFrontier;

        if (_pRootParseCtx->SetGapToFrontier( & tpgFrontier ) 
            && tpgFrontier.Branch()->SearchBranchToRootForScope( GetHeadElement() ))
        {
            CMarkupPointer mp ( Doc() );

            hr = THR( mp.MoveToGap( & tpgFrontier, this ) );

            if (hr)
                goto Cleanup;

            hr = THR( Doc()->InsertElement( pElement, & mp, NULL ) );

            if (hr)
                goto Cleanup;

            goto Cleanup;
        }
    }

    hr = THR(
        GetHeadElement()->InsertAdjacent(
            CElement::BeforeEnd, pElement ) );

    if (hr)
        goto Cleanup;
    
Cleanup:

    RRETURN( hr );
}

//+---------------------------------------------------------------
//
//  Member:     CMarkup::SetXML
//
//  Synopsis:   Treats unqualified tags as xtags.
//
//---------------------------------------------------------------
void
CMarkup::SetXML(BOOL flag)
{
    // pass down to the parser if it is live    
    _fXML = flag ? 1 : 0;
    if (_pHtmCtx)
        _pHtmCtx->SetGenericParse(_fXML);
}

BOOL
CMarkup::IsActiveDesktopComponent()
{
    CDoc * pDoc = Doc();

    if (    pDoc
        &&  pDoc->_fActiveDesktop
        &&  pDoc->_pClientSite )
    {
        IServiceProvider * pSP = NULL;
        HRESULT hr;

        hr = pDoc->_pClientSite->QueryInterface(IID_IServiceProvider, (void **) &pSP);

        if (!hr && pSP)
        {        
            void * pv;
            
            hr = pSP->QueryService(CLSID_HTMLFrameBase, CLSID_HTMLFrameBase, &pv);
            pSP->Release();

            if (hr)     // it should fails in shell32
            {
                COmWindowProxy * pOmWindowProxy = _fWindowPending ? GetWindowPending()
                                                                  : Window();

                if (    pOmWindowProxy
                    &&  pOmWindowProxy->Window()->_pWindowParent
                    &&  pOmWindowProxy->Window()->_pWindowParent->IsPrimaryWindow())
                {
                    return TRUE;
                }
            }
        }
    }

    return FALSE;
}

//+---------------------------------------------------------------
//
//  Member:     CMarkup::PasteClipboard
//
//  Synopsis:   Manage paste from clipboard
//
//---------------------------------------------------------------

HRESULT
CMarkup::PasteClipboard()
{
    HRESULT          hr;
    IDataObject    * pDataObj   = NULL;
    CCurs            curs(IDC_WAIT);
    CLock            Lock(this);
    
    hr = THR(OleGetClipboard(&pDataObj));
    if (hr)
        goto Cleanup;

    hr = THR(AllowPaste(pDataObj));
    if (hr)
        goto Cleanup;


Cleanup:
    ReleaseInterface( pDataObj );

    if (hr)
    {
        ClearErrorInfo();
        PutErrorInfoText(EPART_ACTION, IDS_EA_PASTE_CONTROL);
        CloseErrorInfo(hr);
    }

    RRETURN(hr);
}

#ifdef UNIX_NOTYET
/*
 *  CMarkup::PasteUnixQuickTextToRange
 *
 *  @mfunc  Freeze display and paste object
 *
 *  @rdesc  HRESULT from IDataTransferEngine::PasteMotifTextToRange
 *
 */

HRESULT 
CMarkup::PasteUnixQuickTextToRange(
    CTxtRange *prg,
    VARIANTARG *pvarTextHandle
    )
{
    HRESULT      hr;

    {
        CLightDTEngine ldte( this );

        hr = THR(ldte.PasteUnixQuickTextToRange(prg, pvarTextHandle));
        if (hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN(hr);
}
#endif // UNIX

void 
CMarkup::SetModified ( void )
{
    // Tell the form
    Doc()->OnDataChange();
}

//+-------------------------------------------------------------------------
//
//  Method:     createTextRange
//
//  Synopsis:   Get an automation range for the entire document
//
//--------------------------------------------------------------------------

HRESULT
CMarkup::createTextRange( IHTMLTxtRange * * ppDisp, CElement * pElemContainer )
{
    HRESULT hr = S_OK;

    hr = THR(createTextRange(ppDisp, pElemContainer, NULL, NULL, TRUE));

    RRETURN(hr);
}

//+-------------------------------------------------------------------------
//
//  Method:     createTextRange
//
//  Synopsis:   Get an automation range for the entire document
//
//--------------------------------------------------------------------------

HRESULT
CMarkup::createTextRange( 
    IHTMLTxtRange * * ppDisp, 
    CElement * pElemContainer, 
    IMarkupPointer *pLeft, 
    IMarkupPointer *pRight,
    BOOL fAdjustPointers)
{
    HRESULT hr = S_OK;
    CAutoRange * pAutoRange = NULL;

    if (!ppDisp)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    pAutoRange = new CAutoRange( this, pElemContainer );

    if (!pAutoRange)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // Set the lookaside entry for this range
    pAutoRange->SetNext( DelTextRangeListPtr() );
    hr = THR( SetTextRangeListPtr( pAutoRange ) );
    if (hr)
        goto Cleanup;

    hr = THR( pAutoRange->Init() );
    if (hr)
        goto Cleanup;

    if (pLeft && pRight)
    {
        hr = THR_NOTRACE( pAutoRange->SetLeftAndRight(pLeft, pRight, fAdjustPointers) );
    }
    else
    {
        hr = THR_NOTRACE( pAutoRange->SetTextRangeToElement( pElemContainer ) );
    }

    Assert( hr != S_FALSE );

    if (hr)
        goto Cleanup;

    *ppDisp = pAutoRange;
    pAutoRange->AddRef();
  
Cleanup:
    if (pAutoRange)
    {
        pAutoRange->Release();
    }
    RRETURN( SetErrorInfo( hr ) );
}




//+-------------------------------------------------------------------------
//
//  Method:     CMarkup::AcceptingUndo
//
//  Synopsis:   Tell the PedUndo if we're taking any changes.
//
//--------------------------------------------------------------------------

BOOL
CMarkup::AcceptingUndo()
{
    return      !_fNoUndoInfo;
//            &&  IsEditable()
}

//+-------------------------------------------------------------------------
//
// IMarkupContainer Method Implementations
//
//--------------------------------------------------------------------------

HRESULT
CMarkup::OwningDoc( IHTMLDocument2 * * ppDoc )
{
    return _pDoc->PrimaryMarkup()->QueryInterface( IID_IHTMLDocument2, (void **) ppDoc );
}

HRESULT 
CMarkup::AddSegment( 
    IDisplayPointer* pIStart, 
    IDisplayPointer* pIEnd,
    IHTMLRenderStyle* pIRenderStyle,
    IHighlightSegment **ppISegment )  
{
    HRESULT hr  = EnsureSelRenSvc();

    if ( !hr )
        hr = _pHighlightRenSvcProvider->AddSegment( pIStart, pIEnd, pIRenderStyle, ppISegment);

    RRETURN ( hr );            
}

HRESULT 
CMarkup::MoveSegmentToPointers( 
    IHighlightSegment *pISegment,
    IDisplayPointer* pDispStart, 
    IDisplayPointer* pDispEnd )  
{
    HRESULT hr = EnsureSelRenSvc();

    if ( !hr )
         hr = _pHighlightRenSvcProvider->MoveSegmentToPointers(pISegment, pDispStart, pDispEnd ) ;

    RRETURN ( hr );        
}    
    
HRESULT 
CMarkup::RemoveSegment( IHighlightSegment *pISegment )
{
    if ( _pHighlightRenSvcProvider)
        RRETURN ( _pHighlightRenSvcProvider->RemoveSegment( pISegment ) );
    else
        return S_OK;
}

HRESULT
CMarkup::EnsureSelRenSvc()
{
    if ( ! _pHighlightRenSvcProvider )
        _pHighlightRenSvcProvider = new CSelectionRenderingServiceProvider( Doc() , this   );
    if ( ! _pHighlightRenSvcProvider )
        return E_OUTOFMEMORY;
    return S_OK;        
}

//+==============================================================================
// 
// Method: GetSelectionChunksForLayout
//
// Synopsis: Get the 'chunks" for a given Flow Layout, as well as the Max and Min Cp's of the chunks
//              
//            A 'chunk' is a part of a SelectionSegment, broken by FlowLayout
//
//-------------------------------------------------------------------------------

VOID
CMarkup::GetSelectionChunksForLayout( 
    CFlowLayout* pFlowLayout, 
    CRenderInfo *pRI,
    CDataAry<HighlightSegment> *paryHighlight, 
    int* piCpMin, 
    int * piCpMax )
{
    if ( _pHighlightRenSvcProvider )
    {
        _pHighlightRenSvcProvider->GetSelectionChunksForLayout( pFlowLayout, pRI, paryHighlight, piCpMin, piCpMax );
    }
    else
    {
        Assert( piCpMax );
        *piCpMax = -1;
    }    
}

VOID
CMarkup::HideSelection()
{
    if ( _pHighlightRenSvcProvider )
    {
        _pHighlightRenSvcProvider->HideSelection();
    }
}

VOID
CMarkup::ShowSelection()
{
    if ( _pHighlightRenSvcProvider )
    {
        _pHighlightRenSvcProvider->ShowSelection();
    }
}


VOID
CMarkup::InvalidateSelection()
{
    if ( _pHighlightRenSvcProvider )
    {
        _pHighlightRenSvcProvider->InvalidateSelection( TRUE );
    }
}


CElement *
CMarkup::GetElementTop()
{
    CElement * pElement = GetElementClient();

    return pElement ? pElement : Root();
}

CElement *
CMarkup::GetCanvasElementHelper(CMarkup * pMarkup)
{
    return pMarkup ? pMarkup->GetCanvasElement() : NULL;
}


CElement *
CMarkup::GetHtmlElementHelper(CMarkup * pMarkup)
{
    return pMarkup ? pMarkup->GetHtmlElement() : NULL;
}

CElement *
CMarkup::GetElementClientHelper(CMarkup * pMarkup)
{
    return pMarkup ? pMarkup->GetElementClient() : NULL;
}

CElement *
CMarkup::GetElementTopHelper(CMarkup * pMarkup)
{
    return pMarkup ? pMarkup->GetElementTop() : NULL;
}

IProgSink *
CMarkup::GetProgSinkHelper(CMarkup * pMarkup)
{
    return(pMarkup ? pMarkup->GetProgSink() : NULL);
}

CProgSink *
CMarkup::GetProgSinkCHelper(CMarkup * pMarkup)
{
    return(pMarkup ? pMarkup->GetProgSinkC() : NULL);
}

CHtmCtx *
CMarkup::HtmCtxHelper(CMarkup * pMarkup)
{
    return(pMarkup ? pMarkup->HtmCtx() : NULL);
}

void
CMarkup::EnsureTopElems ( )
{
    CElement  *     pHtmlElementCached;
    CHeadElement  * pHeadElementCached;
    CTitleElement * pTitleElementCached;
    CElement *      pElementClientCached;
    
    if (GetMarkupTreeVersion() == _lTopElemsVersion
        || !Root())
        return;

    _lTopElemsVersion = GetMarkupTreeVersion();

    static ELEMENT_TAG  atagStop[2] = { ETAG_BODY, ETAG_FRAMESET };
    
    CChildIterator ci(
        Root(), 
        NULL,
        CHILDITERATOR_USETAGS,
        atagStop, ARRAY_SIZE(atagStop));
    int nFound = 0;
    
    CTreeNode * pNode;

    pHtmlElementCached = NULL;
    pHeadElementCached = NULL;
    pTitleElementCached = NULL;
    pElementClientCached = NULL;
    
    while ( nFound < 4 && (pNode = ci.NextChild()) != NULL )
    {
        CElement * pElement = pNode->Element();
        
        switch ( pElement->Tag() )
        {
            case ETAG_HEAD  :
            {
                if (!pHeadElementCached)
                {
                    pHeadElementCached = DYNCAST( CHeadElement, pElement );
                    nFound++;
                }
                
                break;
            }
            case ETAG_TITLE_ELEMENT :
            {
                if (!pTitleElementCached)
                {
                    pTitleElementCached = DYNCAST( CTitleElement, pElement );
                    nFound++;
                }
                
                break;
            }

            case ETAG_HTML  :
            {
                if (!pHtmlElementCached)
                {
                    pHtmlElementCached = pElement;
                    nFound++;
                }
                
                break;
            }
            case ETAG_BODY :
            case ETAG_FRAMESET :
            {
                if (!pElementClientCached)
                {
                    pElementClientCached = pElement;
                    nFound++;
                }
                
                break;
            }
        }
    }

    if (nFound)
    {
        CMarkupTopElemCache * ptec = EnsureTopElemCache();

        if (ptec)
        {
            ptec->__pHtmlElementCached = pHtmlElementCached;
            ptec->__pHeadElementCached = pHeadElementCached;
            ptec->__pTitleElementCached = pTitleElementCached;
            ptec->__pElementClientCached = pElementClientCached;
        }
    }
    else
    {
        delete DelTopElemCache();
    }
}

//+-------------------------------------------------------------------
//
//  Member:     CMarkup::DoesPersistMetaAllow
//
//  Synopsis:   the perist Metatags can enable/disable sets of controls
//      and objects.  This helper function will look for the given
//      element ID and try to determin if the meta tags allow or restrict
//      its default operation (wrt persistence)
//
//--------------------------------------------------------------------

BOOL
CMarkup::MetaPersistEnabled(long eState)
{
    CTreeNode * pNode;

    // search through the list of meta tags for one that would activate
    // the persistData objects

    if (!eState || !GetHeadElement())
        return FALSE;

    CChildIterator ci ( GetHeadElement() );

    while ( (pNode = ci.NextChild()) != NULL )
    {
        if (pNode->Tag() == ETAG_META )
        {
            if (DYNCAST( CMetaElement, pNode->Element() )->IsPersistMeta( eState ))
                return TRUE;
        }
    }

    return FALSE;
}

//+-------------------------------------------------------------------
//
//  Member:     CMarkup::IsThemeEnabled
//
//  returns:
//
//      1 : Theme
//      0 :
//     -1 :
//
// always use this table and check with PM
//
// +--------------------------------------------------------------------------+
// |                App not themed |     App Themed                           |
// +-------------------------------+--------------+---------------+-----------+
// |          Never Themed         | DOCUIFLAG on | DOCUIFLAG off | default   |
// +----------+--------------------+--------------+---------------+-----------+
// | Meta on  |                    |   Themed     |   not Themed  | Themed    |
// +----------+--------------------+--------------+---------------+-----------+
// | Meta off |                    |   not Themed |   not Themed  | not Themed|
// +----------+--------------------+--------------+---------------+-----------+
// | no Meta  |                    |   Themed     |   not Themed  | default   |
// +----------+--------------------+--------------+---------------+-----------+
//
//  Synopsis:   
//              look for a Theme meta
//--------------------------------------------------------------------

THEME_USAGE
CMarkup::GetThemeUsage()
{
    CTreeNode * pNode;

    if (!g_fThemedPlatform)
        return THEME_USAGE_OFF;
    
    CMarkupEditContext *pEditCtx = GetEditContext();

    if (!pEditCtx)
    {
        pEditCtx = EnsureEditContext();
        if (!pEditCtx)
            return THEME_USAGE_OFF;
    }

    if (pEditCtx->_fThemeDetermined)
        goto Cleanup;

    pEditCtx->_fThemeDetermined = TRUE;

    // Turn themes off for non-themed apps

    if (!IsAppThemed())
    {
        pEditCtx->_eThemed = THEME_USAGE_OFF;
        goto Cleanup;
    }

    //Look at DOCHOSTUI flags first

    // DOCHOSTUIFLAG_NOTHEME has highest precedence - always turns themes OFF

    if (_pDoc->_dwFlagsHostInfo & DOCHOSTUIFLAG_NOTHEME)
    {
        pEditCtx->_eThemed = THEME_USAGE_OFF;
        goto Cleanup;
    }
    
    // Turn themes ON for DOCHOSTUIFLAG_THEME - will be turned off by META if exists

    if (_pDoc->_dwFlagsHostInfo & DOCHOSTUIFLAG_THEME)
    {
        pEditCtx->_eThemed = THEME_USAGE_ON;
    }

    // look at inetcpl if no DOCHOSTUIFLAG settings

    if ( !(_pDoc->_dwFlagsHostInfo & (DOCHOSTUIFLAG_NOTHEME | DOCHOSTUIFLAG_THEME)) )
    {
        if ( _pDoc->_pOptionSettings && _pDoc->_pOptionSettings->fUseThemes)
        {
            // turn themes ON
            pEditCtx->_eThemed = THEME_USAGE_ON;
        }
        else
        {
            // no settings by host and inetcpl is non-themed -> set themes to DEFAULT
            // will be overridden by META if exists
            pEditCtx->_eThemed = THEME_USAGE_DEFAULT;
        }
    }

    // Look at the META tag - we can only get here if DOCHOSTUIFLAG_THEME or default
    // META OFF -> turns off themes completelly
    // META ON  -> turns themes on
    // No META  -> for DOCHOSTUIFLAG_THEME they are already THEME_USAGE_ON, for "default" they are THEME_USAGE_DEFAULT

    if (GetHeadElement())
    {
        CChildIterator ci ( GetHeadElement(), NULL, CHILDITERATOR_DEEP);

        while ( (pNode = ci.NextChild()) != NULL )
        {
            if (pNode->Tag() == ETAG_META )
            {
                switch (DYNCAST(CMetaElement,pNode->Element())->TestThemeMeta())
                {
                case 1 :
                    pEditCtx->_eThemed = THEME_USAGE_ON;
                    goto Cleanup;
                case 0 :
                    pEditCtx->_eThemed = THEME_USAGE_OFF;
                    goto Cleanup;
                }
            }
        }
    }

Cleanup:

    return pEditCtx->_eThemed;
}

//+-------------------------------------------------------------------
//
//  Member:     CRootSite::LocateHeadMeta
//
//  Synopsis:   Look for a particular type of meta tag in the head
//
//--------------------------------------------------------------------

HRESULT
CMarkup::LocateHeadMeta (
    BOOL ( * pfnCompare ) ( CMetaElement * ), CMetaElement * * ppMeta )
{
    HRESULT hr = S_OK;
    CTreeNode * pNode;

    Assert( ppMeta );

    *ppMeta = NULL;

    if (GetHeadElement())
    {
        //
        // Attempt to locate an existing meta tag associated with the
        // head (we will not look for meta tags in the rest of the doc).
        //

        CChildIterator ci ( GetHeadElement(), NULL, CHILDITERATOR_DEEP );

        while ( (pNode = ci.NextChild()) != NULL )
        {
            if (pNode->Tag() == ETAG_META)
            {
                *ppMeta = DYNCAST( CMetaElement, pNode->Element() );

                if (pfnCompare( *ppMeta ))
                    break;

                *ppMeta = NULL;
            }
        }
    }
    
    RRETURN( hr );
}

//+-------------------------------------------------------------------
//
//  Member:     CRootSite::LocateOrCreateHeadMeta
//
//  Synopsis:   Locate a
//
//--------------------------------------------------------------------

HRESULT
CMarkup::LocateOrCreateHeadMeta (
    BOOL ( * pfnCompare ) ( CMetaElement * ),
    CMetaElement * * ppMeta,
    BOOL fInsertAtEnd )
{
    HRESULT hr;
    CElement *pTempElement = NULL;

    Assert( ppMeta );

    //
    // First try to find one
    //

    *ppMeta = NULL;

    hr = THR(LocateHeadMeta(pfnCompare, ppMeta));
    if (hr)
        goto Cleanup;

    //
    // If we could not locate an existing element, make a new one
    //
    // _pElementHEAD can be null if we are doing a doc.open on a
    // partially created document.(pending navigation scenario)
    //

    if (!*ppMeta && GetHeadElement())
    {
        long lIndex = -1;

        if (_LoadStatus < LOADSTATUS_PARSE_DONE)
        {
            // Do not add create a meta element if we have not finished
            // parsing.
            hr = E_FAIL;
            goto Cleanup;
        }

        hr = THR( CreateElement( ETAG_META, & pTempElement ) );

        if (hr)
            goto Cleanup;

        * ppMeta = DYNCAST( CMetaElement, pTempElement );
        
        Assert( * ppMeta );

        if (!fInsertAtEnd)
        {
            lIndex = 0;

            //
            // Should not insert stuff before the title
            //

            if (GetTitleElement() &&
                GetTitleElement()->GetFirstBranch()->Parent() &&
                GetTitleElement()->GetFirstBranch()->Parent()->Element() == GetHeadElement())
            {
                lIndex = 1;
            }
        }
            
        hr = THR( AddHeadElement( pTempElement, lIndex ) );
        
        if (hr)
            goto Cleanup;
    }

Cleanup:
    
    CElement::ClearPtr( & pTempElement );

    RRETURN( hr );
}

//+-------------------------------------------------------------------
//
//  Member:     CMarkup::GetProgSinkC
//
//--------------------------------------------------------------------

CProgSink *
CMarkup::GetProgSinkC()
{
    return _pProgSink;
}

//+-------------------------------------------------------------------
//
//  Member:     CMarkup::GetProgSink
//
//--------------------------------------------------------------------

IProgSink *
CMarkup::GetProgSink()
{
    return (IProgSink*) _pProgSink;
}

//+-------------------------------------------------------------------
//
//  Member:     CMarkup::IsEditable
//
//--------------------------------------------------------------------

BOOL        
CMarkup::IsEditable() const
{
    return _fDesignMode;
}

//+---------------------------------------------------------------------------
//
//  Lookaside storage
//
//----------------------------------------------------------------------------

void *
CMarkup::GetLookasidePtr(int iPtr)
{
#if DBG == 1
    if(HasLookasidePtr(iPtr))
    {
        void * pLookasidePtr =  Doc()->GetLookasidePtr((DWORD *)this + iPtr);

        Assert(pLookasidePtr == _apLookAside[iPtr]);

        return pLookasidePtr;
    }
    else
        return NULL;
#else
    return(HasLookasidePtr(iPtr) ? Doc()->GetLookasidePtr((DWORD *)this + iPtr) : NULL);
#endif
}

HRESULT
CMarkup::SetLookasidePtr(int iPtr, void * pvVal)
{
    Assert (!HasLookasidePtr(iPtr) && "Can't set lookaside ptr when the previous ptr is not cleared");

    HRESULT hr = THR(Doc()->SetLookasidePtr((DWORD *)this + iPtr, pvVal));

    if (hr == S_OK)
    {
        _fHasLookasidePtr |= 1 << iPtr;

#if DBG == 1
        _apLookAside[iPtr] = pvVal;
#endif
    }

    RRETURN(hr);
}

void *
CMarkup::DelLookasidePtr(int iPtr)
{
    if (HasLookasidePtr(iPtr))
    {
        void * pvVal = Doc()->DelLookasidePtr((DWORD *)this + iPtr);
        _fHasLookasidePtr &= ~(1 << iPtr);
#if DBG == 1
        _apLookAside[iPtr] = NULL;
#endif
        return(pvVal);
    }

    return(NULL);
}

//
// CMarkup ref counting helpers
//

void
CMarkup::ReplacePtr ( CMarkup * * pplhs, CMarkup * prhs )
{
    if (pplhs)
    {
        CMarkup * plhsLocal = *pplhs;
        if (prhs)
        {
            prhs->AddRef();
        }
        *pplhs = prhs;
        if (plhsLocal)
        {
            plhsLocal->Release();
        }
    }
}

void
CMarkup::SetPtr ( CMarkup ** pplhs, CMarkup * prhs )
{
    if (pplhs)
    {
        if (prhs)
        {
            prhs->AddRef();
        }
        *pplhs = prhs;
    }
}

void
CMarkup::StealPtrSet ( CMarkup ** pplhs, CMarkup * prhs )
{
    SetPtr( pplhs, prhs );

    if (pplhs && *pplhs)
        (*pplhs)->Release();
}

void
CMarkup::StealPtrReplace ( CMarkup ** pplhs, CMarkup * prhs )
{
    ReplacePtr( pplhs, prhs );

    if (pplhs && *pplhs)
        (*pplhs)->Release();
}

void
CMarkup::ClearPtr ( CMarkup * * pplhs )
{
    if (pplhs && * pplhs)
    {
        CMarkup * pElement = *pplhs;
        *pplhs = NULL;
        pElement->Release();
    }
}

void
CMarkup::ReleasePtr ( CMarkup * pMarkup )
{
    if (pMarkup)
    {
        pMarkup->Release();
    }
}

//+---------------------------------------------------------------------------
//
//  Log Manager for TreeSync and Undo
//
//+---------------------------------------------------------------------------
CLogManager *
CMarkup::EnsureLogManager()
{
    CMarkupChangeNotificationContext * pcnc;

    pcnc = EnsureChangeNotificationContext();

    if (!pcnc)
        return NULL;

    if (!pcnc->_pLogManager)
        pcnc->_pLogManager = new CLogManager( this );

    return pcnc->_pLogManager;
}

BOOL                        
CMarkup::HasLogManagerImpl()
{
    Assert( HasChangeNotificationContext() );

    CMarkupChangeNotificationContext * pcnc;

    pcnc = GetChangeNotificationContext();

    return !!pcnc->_pLogManager;
}

CLogManager *   
CMarkup::GetLogManager()
{
    if( HasChangeNotificationContext() )
    {
        CMarkupChangeNotificationContext * pcnc;

        pcnc = GetChangeNotificationContext();

        return pcnc->_pLogManager;
    }
    else
        return NULL;
}

//+---------------------------------------------------------------------------
//
//  Top Elem Cache
//
//----------------------------------------------------------------------------

CMarkupTopElemCache * 
CMarkup::EnsureTopElemCache()
{
    CMarkupTopElemCache * ptec;

    if (HasTopElemCache())
        return GetTopElemCache();

    ptec = new CMarkupTopElemCache;
    if (!ptec)
        return NULL;

    if (SetTopElemCache( ptec ))
    {
        delete ptec;
        return NULL;
    }

    return ptec;
}

//+---------------------------------------------------------------------------
//
//  Transient Navigation Context
//
//----------------------------------------------------------------------------

CMarkupTransNavContext *    
CMarkup::EnsureTransNavContext()
{
    CMarkupTransNavContext * ptnc;

    if (HasTransNavContext())
        return GetTransNavContext();

    ptnc = new CMarkupTransNavContext;
    if (!ptnc)
        return NULL;

    if (SetTransNavContext( ptnc ))
    {
        delete ptnc;
        return NULL;
    }

    return ptnc;
}

void
CMarkup::EnsureDeleteTransNavContext( CMarkupTransNavContext * ptnc )
{
    Assert(HasTransNavContext() && ptnc == GetTransNavContext());

    if(     !ptnc->_pTaskLookForBookmark 
       &&   ptnc->_historyCurElem.lIndex == -1L
       &&   !ptnc->_HistoryLoadCtx.HasData()
       &&   !ptnc->_dwHistoryIndex
       &&   !ptnc->_dwFlags
       &&   !ptnc->_pctPics)
    {
        delete DelTransNavContext();
    }
}

//+---------------------------------------------------------------------------
//
//  Stuff for CComputeFormatState (for psuedo first letter/line elements)
//
//----------------------------------------------------------------------------

CComputeFormatState *    
CMarkup::EnsureCFState()
{
    CComputeFormatState * pcfState;

    if (HasCFState())
        return GetCFState();

    pcfState = new CComputeFormatState;
    if (!pcfState)
        return NULL;

    if (S_OK != AddPointer( DISPID_INTERNAL_COMPUTEFORMATSTATECACHE, 
                            (void *) pcfState, 
                            CAttrValue::AA_Internal ))
    {
        delete pcfState;
        return NULL;
    }

    _fHasCFState = TRUE;

    return pcfState;
}

void                     
CMarkup::EnsureDeleteCFState( CComputeFormatState * pcfState )
{
    Assert(HasCFState() && pcfState == GetCFState());

    if(pcfState->IsReset())
    {
        AAINDEX aaIdx = FindAAIndex( DISPID_INTERNAL_COMPUTEFORMATSTATECACHE, 
                                     CAttrValue::AA_Internal );
        DeleteAt( aaIdx );
        delete pcfState;

        _fHasCFState = FALSE;
    }
}

CComputeFormatState *    
CMarkup::GetCFState()
{
    CComputeFormatState * pcfState = NULL;
    GetPointerAt( FindAAIndex( DISPID_INTERNAL_COMPUTEFORMATSTATECACHE, 
                               CAttrValue::AA_Internal ),
                  (void **) &pcfState );
    return pcfState;
}

//+---------------------------------------------------------------------------
//
//  Text Frag Service
//
//----------------------------------------------------------------------------

CMarkupTextFragContext * 
CMarkup::EnsureTextFragContext()
{
    CMarkupTextFragContext *    ptfc;

    if (HasTextFragContext())
        return GetTextFragContext();

    ptfc = new CMarkupTextFragContext;
    if (!ptfc)
        return NULL;

    if (SetTextFragContext( ptfc ))
    {
        delete ptfc;
        return NULL;
    }

    return ptfc;
}

CMarkupTextFragContext::~CMarkupTextFragContext()
{
    int cFrag;
    MarkupTextFrag * ptf;

    for( cFrag = _aryMarkupTextFrag.Size(), ptf = _aryMarkupTextFrag; cFrag > 0; cFrag--, ptf++ )
    {
        MemFreeString( ptf->_pchTextFrag );
    }
}

HRESULT     
CMarkupTextFragContext::AddTextFrag( CTreePos * ptpTextFrag, TCHAR* pchTextFrag, ULONG cchTextFrag, long iTextFrag )
{
    HRESULT             hr = S_OK;
    TCHAR *             pchCopy = NULL;
    MarkupTextFrag *    ptf = NULL;

    Assert( iTextFrag >= 0 && iTextFrag <= _aryMarkupTextFrag.Size() );

    // Allocate and copy the string
    hr = THR( MemAllocStringBuffer( Mt(MarkupTextFrag_pchTextFrag), cchTextFrag, pchTextFrag, &pchCopy ) );
    if (hr)
        goto Cleanup;

    // Allocate the TextFrag object in the array
    hr = THR( _aryMarkupTextFrag.InsertIndirect( iTextFrag, NULL ) );
    if (hr)
    {
        MemFreeString( pchCopy );
        goto Cleanup;
    }

    // Fill in the text frag

    ptf = &_aryMarkupTextFrag[iTextFrag];
    Assert( ptf );

    ptf->_ptpTextFrag = ptpTextFrag;
    ptf->_pchTextFrag = pchCopy;

Cleanup:
    RRETURN( hr );
}

HRESULT     
CMarkupTextFragContext::RemoveTextFrag( long iTextFrag, CMarkup * pMarkup )
{
    HRESULT             hr = S_OK;
    MarkupTextFrag *    ptf;

    Assert( iTextFrag >= 0 && iTextFrag <= _aryMarkupTextFrag.Size() );

    // Get the text frag
    ptf = &_aryMarkupTextFrag[iTextFrag];

    // Free the string
    MemFreeString( ptf->_pchTextFrag );

    hr = THR( pMarkup->RemovePointerPos( ptf->_ptpTextFrag, NULL, NULL ) );
    if (hr)
        goto Cleanup;

Cleanup:

    // Remove the entry from the array
    _aryMarkupTextFrag.Delete( iTextFrag );

    RRETURN( hr );
}

long
CMarkupTextFragContext::FindTextFragAtCp( long cpFind, BOOL * pfFragFound )
{
    // Do a binary search through the array to find the spot in the array
    // where cpFind lies

    int             iFragLow, iFragHigh, iFragMid;
    MarkupTextFrag* pmtfAry = _aryMarkupTextFrag;
    MarkupTextFrag* pmtfMid;
    BOOL            fResult;
    long            cpMid;

    iFragLow  = 0;
    fResult   = FALSE;
    iFragHigh = _aryMarkupTextFrag.Size() - 1;

    while (iFragLow <= iFragHigh)
    {
        iFragMid = (iFragLow + iFragHigh) >> 1;

        pmtfMid  = pmtfAry + iFragMid;
        cpMid    = pmtfMid->_ptpTextFrag->GetCp();

        if (cpMid == cpFind)
        {
            iFragLow = iFragMid;
            fResult = TRUE;
            break;
        }
        else if (cpMid < cpFind)
            iFragLow = iFragMid + 1;
        else
            iFragHigh = iFragMid - 1;
    }

    if (fResult && iFragLow > 0)
    {
        // Search backward through all of the entries
        // at the same cp so we return the first one
        
        for ( iFragLow-- ; iFragLow ; iFragLow-- )
        {
            if (pmtfAry[iFragLow]._ptpTextFrag->GetCp() != cpFind)
            {
                iFragLow++;
                break;
            }
        }
    }

    if (pfFragFound)
        *pfFragFound = fResult;

    Assert( iFragLow == 0 || pmtfAry[iFragLow-1]._ptpTextFrag->GetCp() < cpFind );
    Assert(     iFragLow == _aryMarkupTextFrag.Size() - 1 
            ||  _aryMarkupTextFrag.Size() == 0
            ||  cpFind <= pmtfAry[iFragLow]._ptpTextFrag->GetCp() );
    Assert( !fResult || pmtfAry[iFragLow]._ptpTextFrag->GetCp() == cpFind );

    return iFragLow;
}

#if DBG==1
void
CMarkupTextFragContext::TextFragAssertOrder()
{
    // Walk the array and assert order for each pair
    // to make sure that the array is ordered correctly
    int cFrag;
    MarkupTextFrag * ptf, *ptfLast = NULL;

    for( cFrag = _aryMarkupTextFrag.Size(), ptf = _aryMarkupTextFrag; cFrag > 0; cFrag--, ptf++ )
    {
        if (ptfLast)
        {
            Assert( ptfLast->_ptpTextFrag->InternalCompare( ptf->_ptpTextFrag ) == -1 );
        }

        ptfLast = ptf;
    }
}
#endif


//+-------------------------------------------------------------------------
//
// IMarkupTextFrags Method Implementations
//
//--------------------------------------------------------------------------
HRESULT 
CMarkup::GetTextFragCount(long* pcFrags)
{
    HRESULT hr = S_OK;

    if (!pcFrags)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if( !HasTextFragContext() )
        *pcFrags = 0;
    else
        *pcFrags = GetTextFragContext()->_aryMarkupTextFrag.Size();

Cleanup:
    RRETURN( hr );
}

HRESULT 
CMarkup::GetTextFrag(long iFrag, BSTR* pbstrFrag, IMarkupPointer* pIPointerFrag)
{
    HRESULT hr = S_OK;
    CDoc *  pDoc = Doc();
    CMarkupTextFragContext *    ptfc = GetTextFragContext();
    MarkupTextFrag *            ptf;
    CMarkupPointer *            pPointerFrag;

    // Check args
    if (    !pbstrFrag
        ||  !pIPointerFrag
        ||  !pDoc->IsOwnerOf( pIPointerFrag )
        ||  !ptfc
        ||  iFrag < 0
        ||  iFrag >= ptfc->_aryMarkupTextFrag.Size())
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *pbstrFrag = NULL;

    // Crack the pointer
    hr = pIPointerFrag->QueryInterface(CLSID_CMarkupPointer, (void**)&pPointerFrag);
    if (hr)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // copy the string
    ptf = &(ptfc->_aryMarkupTextFrag[iFrag]);
    Assert( ptf );

    hr = THR( FormsAllocString( ptf->_pchTextFrag, pbstrFrag ) );
    if (hr)
        goto Cleanup;

    // position the pointer
    {
        CTreePosGap tpgPointer( ptf->_ptpTextFrag, TPG_RIGHT );
        hr = THR( pPointerFrag->MoveToGap( &tpgPointer, this ) );
        if (hr)
        {
            FormsFreeString( *pbstrFrag );
            *pbstrFrag = NULL;
            goto Cleanup;
        }
    }

Cleanup:
    RRETURN( hr );
}

HRESULT 
CMarkup::RemoveTextFrag(long iFrag)
{
    HRESULT hr = S_OK;
    CMarkupTextFragContext *    ptfc = GetTextFragContext();
    
    // Check args
    if (    !ptfc
        ||  iFrag < 0
        ||  iFrag >= ptfc->_aryMarkupTextFrag.Size())
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // Remove the text frag
    hr = THR( ptfc->RemoveTextFrag( iFrag, this ) );
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN( hr );
}

HRESULT 
CMarkup::InsertTextFrag(long iFragInsert, BSTR bstrInsert, IMarkupPointer* pIPointerInsert)
{
    HRESULT                     hr = S_OK;
    CDoc *                      pDoc = Doc();
    CMarkupTextFragContext *    ptfc = EnsureTextFragContext();
    CMarkupPointer *            pPointerInsert;
    CTreePosGap                 tpgInsert;

    // Check for really bad args
    if (    !pIPointerInsert
        ||  !pDoc->IsOwnerOf( pIPointerInsert )
        ||  !bstrInsert)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // Make sure we had or created a text frag context
    if (!ptfc)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // Crack the pointer
    hr = pIPointerInsert->QueryInterface(CLSID_CMarkupPointer, (void**)&pPointerInsert);
    if (hr || !pPointerInsert->IsPositioned() || pPointerInsert->Markup() != this)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }


    // Find the position for insert
    {
        BOOL fFragFound = TRUE;
        BOOL fPosSpecified = TRUE;
        long cFrags = ptfc->_aryMarkupTextFrag.Size();
        long cpInsert = pPointerInsert->GetCp();
        long cpBefore = -1;
        long cpAfter = MAXLONG;

        if (iFragInsert < 0)
        {
            iFragInsert = ptfc->FindTextFragAtCp( cpInsert, &fFragFound );
            fPosSpecified = FALSE;
        }

        // Make sure that the pointer and iFragInsert are in sync
        if (fPosSpecified)
        {
            if (iFragInsert > 0)
            {
                cpBefore = ptfc->_aryMarkupTextFrag[iFragInsert-1]._ptpTextFrag->GetCp();
            }

            if (iFragInsert <= cFrags - 1)
            {
                cpAfter = ptfc->_aryMarkupTextFrag[iFragInsert]._ptpTextFrag->GetCp();
            }

            if (cpBefore > cpInsert || cpAfter < cpInsert || iFragInsert > cFrags)
            {
                hr = E_INVALIDARG;
                goto Cleanup;
            }
        }

        // Position it carefully if a neighbor is at the same cp
        if (fPosSpecified && cpBefore == cpInsert)
        {
            hr = THR( tpgInsert.MoveTo( ptfc->_aryMarkupTextFrag[iFragInsert-1]._ptpTextFrag, TPG_RIGHT ) );
            if (hr)
                goto Cleanup;
        }
        else if (fPosSpecified && cpAfter == cpInsert || !fPosSpecified && fFragFound)
        {
            hr = THR( tpgInsert.MoveTo( ptfc->_aryMarkupTextFrag[iFragInsert]._ptpTextFrag, TPG_LEFT ) );
            if (hr)
                goto Cleanup;
        }
        else
        {
            // Note: Eric, you will have to split any text poses here if pPointerInsert
            // is ghosted.
            // Note2 (Eric): just force all pointers to embed.  Could make this faster
            //

            hr = THR( EmbedPointers() );

            if (hr)
                goto Cleanup;
            
            hr = THR( tpgInsert.MoveTo( pPointerInsert->GetEmbeddedTreePos(), TPG_LEFT ) );
            if (hr)
                goto Cleanup;
        }
    }

    // Now that we have where we want to insert this text frag, we have to actually insert
    // it an add it to the list
    {
        CTreePos * ptpInsert;

        ptpInsert = NewPointerPos( NULL, FALSE, FALSE );
        if( ! ptpInsert )
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = THR( Insert( ptpInsert, &tpgInsert ) );
        if (hr)
        {
            FreeTreePos( ptpInsert );
            goto Cleanup;
        }

        hr = THR( ptfc->AddTextFrag( ptpInsert, bstrInsert, FormsStringLen( bstrInsert), iFragInsert ) );
        if (hr)
        {
            IGNORE_HR( Remove( ptpInsert ) );
            goto Cleanup;
        }
    }

    WHEN_DBG( ptfc->TextFragAssertOrder() );

Cleanup:
    RRETURN( hr );
}

HRESULT 
CMarkup::FindTextFragFromMarkupPointer(IMarkupPointer* pIPointerFind,long* piFrag,BOOL* pfFragFound)
{
    HRESULT hr = S_OK;
    CDoc *  pDoc = Doc();
    CMarkupTextFragContext *    ptfc = GetTextFragContext();
    CMarkupPointer *            pPointerFind;

    // Check args
    if (    !pIPointerFind
        ||  !pDoc->IsOwnerOf( pIPointerFind ))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // Crack the pointer
    hr = pIPointerFind->QueryInterface(CLSID_CMarkupPointer, (void**)&pPointerFind);
    if (hr || !pPointerFind->IsPositioned())
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }


    {
        long iFrag;
        BOOL fFragFound = FALSE;

        if (ptfc)
        {
            iFrag = ptfc->FindTextFragAtCp( pPointerFind->GetCp(), &fFragFound );
        }
        else
        {
            // If we don't have a context, return 0/False
            iFrag = 0;
        }

        if (piFrag)
            *piFrag = iFrag;

        if (pfFragFound)
            *pfFragFound = fFragFound;
    }


Cleanup:
    RRETURN( hr );
}


//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::EnsureStyleSheets
//
//  Synopsis:   Ensure the stylesheets collection exists, creates it if not..
//
//----------------------------------------------------------------------------

HRESULT
CMarkup::EnsureStyleSheets()
{
    CStyleSheetArray * pStyleSheets;
    if (HasStyleSheetArray())
        return S_OK;

    pStyleSheets = new CStyleSheetArray( this, NULL, 0 );
    if (!pStyleSheets || pStyleSheets->_fInvalid )
        return E_OUTOFMEMORY;

    SetStyleSheetArray(pStyleSheets);
    return S_OK;
}


HRESULT 
CMarkup::ApplyStyleSheets(
        CStyleInfo *    pStyleInfo,
        ApplyPassType   passType,
        EMediaType      eMediaType,
        BOOL *          pfContainsImportant)
{
    HRESULT hr = S_OK;
    CStyleSheetArray * pStyleSheets;
    
    if (Doc()->_pHostStyleSheets)
    {
        hr = THR(Doc()->_pHostStyleSheets->Apply(pStyleInfo, passType, eMediaType, NULL));
        if (hr)
            goto Cleanup;
    }

    if (!HasStyleSheetArray())
        return S_OK;

    pStyleSheets = GetStyleSheetArray();
        
    if (!pStyleSheets->Size())
        return S_OK;

    hr = THR(pStyleSheets->Apply(pStyleInfo, passType, eMediaType, pfContainsImportant));

Cleanup:
    RRETURN(hr);
}


CMarkup *   
CMarkup::GetParentMarkup()
{       
    // First check our root   
    CElement * pRoot;      
    pRoot = Root();

    if (!pRoot)
        return NULL;

    if (pRoot->HasMasterPtr())
    {
        return pRoot->GetMasterPtr()->GetMarkup();
    }

    // HTC link?         
    CMarkupBehaviorContext *    pBehaviorContext;    
    CHtmlComponent *            pHtmlComponent;
    CElement *                  pHtmlComponentElement;   

    pBehaviorContext = BehaviorContext();
    if (pBehaviorContext)
    {                
        pHtmlComponent = pBehaviorContext->_pHtmlComponent;
        if (pHtmlComponent)
        {
            pHtmlComponentElement = pHtmlComponent->_pElement;
            if (pHtmlComponentElement &&
                pHtmlComponentElement->IsInMarkup())
            {
                return pHtmlComponentElement->GetMarkup();          
            }
        }
    }

    else if (_fWindowPending)
    {
        pRoot = GetWindowPending()->Markup()->Root();

        if (!pRoot)
            return NULL;

        if (pRoot->HasMasterPtr())
        {
            return pRoot->GetMasterPtr()->GetMarkup();
        }
    }

    return NULL;
}


//-----------------------------------------------------------------------------
// CMarkup::GetRootMarkup
//    
// fUseNested is used for determining the security ID of the root markup
// in the active desktop case. We don't want to use the ID of the htt
// file that hosts active desktop pages, so we pass in fUseNested to
// avoid doing so. 
//-----------------------------------------------------------------------------

CMarkup *   
CMarkup::GetRootMarkup(BOOL fUseNested /* = FALSE */)
{
    CMarkup * pMarkupPrev;
    CMarkup * pMarkup = NULL; 
    CMarkup * pMarkupParent = this;

    do
    {
        pMarkupPrev = pMarkup;
        pMarkup = pMarkupParent;
        pMarkupParent = pMarkup->GetParentMarkup();
    }
    while(pMarkupParent);    

    if (fUseNested && pMarkupPrev && pMarkupPrev->IsActiveDesktopComponent())
    {
        return pMarkupPrev;
    }
    return pMarkup;
}

#if DBG==1
BOOL
CMarkup::IsConnectedToPrimaryWorld()
{
    CMarkup * pPendingPrimary = Doc()->PendingPrimaryMarkup();
    CMarkup * pPrimary = Doc()->PrimaryMarkup();
    CMarkup * pMarkup = this;

    while( pMarkup != pPendingPrimary && pMarkup != pPrimary )
    {
        // Grab the root element of the appropriate markup 
        CElement * pelRoot = pMarkup->_fWindowPending ? 
                                pMarkup->GetWindowPending()->Markup()->Root() : 
                                pMarkup->Root();

        // No view-link = not connected
        if( !pelRoot->HasMasterPtr() )
            return FALSE;

        // View-linked to element in ether = not connected
        pMarkup = pelRoot->GetMasterPtr()->GetMarkup();
        if( !pMarkup )
            return FALSE;
    }

    // Must have hit primary
    Assert( pMarkup == pPrimary || pMarkup == pPendingPrimary );
    return TRUE;
}
#endif // DBG


BOOL
CMarkup::IsConnectedToPrimaryMarkup()
{
    CMarkup *pPrimary = Doc()->PrimaryMarkup();
    CMarkup *pMarkup = this;

    Assert(pPrimary);

    while (pMarkup != pPrimary)
    {
        CElement *pelRoot;
        pelRoot = pMarkup->Root();

        // stand-alone (ether) markup!
        if (!pelRoot->HasMasterPtr())
            return FALSE;

        // Get the markup in which the master element is in.
        pMarkup = pelRoot->GetMasterPtr()->GetMarkup();

        // stand-alone (ether) master element!
        if (!pMarkup)
            return FALSE;
    }

    Assert(pMarkup == pPrimary || !pMarkup);
    return !!pMarkup;
}

BOOL
CMarkup::IsPendingRoot()
{
    CMarkup * pMarkupRoot = GetRootMarkup();

    if (    pMarkupRoot->_fWindowPending 
        &&  pMarkupRoot->GetWindowPending()->Window()->IsPrimaryWindow())
    {
        return TRUE;
    }

    // If we aren't connected to the root markup in any way, assume that we are
    // created from script/code and we must be in the non pending world.
    return FALSE;

}

HRESULT
CMarkup::ForceRelayout()
{
    CNotification nf;

    Assert(IsConnectedToPrimaryMarkup());

    Root()->EnsureFormatCacheChange(ELEMCHNG_CLEARCACHES);
    nf.DisplayChange(Root());
    Root()->SendNotification(&nf);     

    CElement *pClient = GetElementClient();
    if(pClient) 
        pClient->ResizeElement(NFLAGS_FORCE);

    return S_OK;
}

BOOL        
CMarkup::CanNavigate()
{ 
    CWindow * pWindow = GetWindowedMarkupContextWindow(); 
    return pWindow ? pWindow->CanNavigate() : (!Doc()->_fDisableModeless && (Doc()->_ulDisableModeless == 0)); 
}


//+---------------------------------------------------------------
//
//  Member:         CMarkup::OnCssChange
//
//---------------------------------------------------------------

HRESULT
CMarkup::OnCssChange(BOOL fStable, BOOL fRecomputePeers)
{
    HRESULT     hr = S_OK;

    if (fRecomputePeers)
    {
        if (fStable)
            hr = THR(RecomputePeers());
        else
            hr = THR(ProcessPeerTask(PEERTASK_MARKUP_RECOMPUTEPEERS_UNSTABLE));

        if (hr)
            goto Cleanup;
    }

    if (IsConnectedToPrimaryMarkup())
    {
        //
        // When we finish downloading embedded fonts, we need to clear 
        // font face cache, which is used during ApplyFontFace.
        // This is because before downloading embedded font we can compute
        // formats and update font face cache, and after downloading
        // we recompute formats, but we use font face cache for perf.
        //
        fc().ClearFaceCache();

        hr = ForceRelayout();
    }

Cleanup:
    RRETURN (hr);
}

//+---------------------------------------------------------------
//
//  Member:         CMarkup::EnsureFormats
//
//---------------------------------------------------------------

void
CMarkup::EnsureFormats( FORMAT_CONTEXT FCPARAM )
{
    // Walk the tree and make sure all formats are computed

    if (_fEnsuredFormats)
        return;
    _fEnsuredFormats = TRUE; // cleared only at unload time

    CTreePos * ptpCurr = FirstTreePos();
    while (ptpCurr)
    {
        if (ptpCurr->IsBeginNode())
        {
            ptpCurr->Branch()->EnsureFormats( FCPARAM );
        }
        ptpCurr = ptpCurr->NextTreePos();
    }
}

//+------------------------------------------------------------------------
//
//  Member:     CMarkup::CreateWindowHelper
//
//  Synopsis:   We create a window for: 
//                  1) the primary markup 
//                  2) whenever we open a new browser window
//                  3) createDocumentFromUrl
//
//-------------------------------------------------------------------------

HRESULT
CMarkup::CreateWindowHelper()
{
    HRESULT         hr = S_OK;
    CWindow *       pWindow = NULL;
    COmWindowProxy *pProxy = NULL;
    BYTE            abSID[MAX_SIZE_SECURITY_ID];
    DWORD           cbSID = ARRAY_SIZE(abSID);
    CDocument *     pDocument;
    
    AssertSz (!IsHtcMarkup(), "Attempt to CreateWindowHelper for HTC markup. This is a major perf hit and a likely bug. Contact alexz, lmollico or mohanb for details.");
    AssertSz (!HasWindowPending(), "Don't call this function unless you need a window. (peterlee)");

    //
    // Make sure we have a document
    //

    hr = THR(EnsureDocument(&pDocument));
    if (hr)
        goto Cleanup;

    //
    // Create a window
    //

    pWindow = new CWindow(this);
    if (!pWindow)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    //
    // Create the Window proxy
    //
    
    pProxy = new COmWindowProxy;
    if (!pProxy)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(GetSecurityID(abSID, &cbSID));
    if (hr)
        goto Cleanup;

    pProxy->_fTrusted = TRUE;

    hr = THR(pProxy->Init((IHTMLWindow2 *)pWindow, abSID, cbSID));
    if (hr)
        goto Cleanup;

    // Play ref counting games wrt the proxy/window
    pWindow->SetProxy( pProxy );

    //
    // Add this entry to the thread local cache.
    //

    hr = THR(EnsureWindowInfo());
    if (hr)
        goto Cleanup;

    hr = THR(TLS(windowInfo.paryWindowTbl)->AddTuple(
            (IHTMLWindow2 *)pWindow,
            abSID,
            cbSID,
            IsMarkupTrusted(),
            (IHTMLWindow2 *)pProxy));
    if (hr)
        goto Cleanup;

    hr = THR(SetWindow(pProxy));
    if (hr) 
        goto Cleanup;

    _fWindow = TRUE;

    pProxy->_fTrustedDoc = !!IsMarkupTrusted();

    pProxy->OnSetWindow();        

    //
    // now transfer ownership of document to the window
    //

    pDocument->SwitchOwnerToWindow( pWindow );

Cleanup:
    if (hr && pWindow)
    {
        // On error sub release markup on behalf of CWindow.
        Assert(this == pWindow->_pMarkup);
        pWindow->_pMarkup = NULL;
        SubRelease();
    }
    if (pWindow)
    {
        pWindow->Release();
    }
    if (pProxy)
    {
        pProxy->Release();
    }
    RRETURN(hr);
}

   
//+-------------------------------------------------------------------------
//
//  Method:     CMarkup::InitWindow
//
//  Synopsis:   Copies over any temporary dispids from the markup onto 
//              the new window.
//
//--------------------------------------------------------------------------
HRESULT
CMarkup::InitWindow()
{
    HRESULT         hr = S_OK;
    CAttrArray *    pAAMarkupNew;
    CAttrArray **   ppAAWindow;
    CAttrValue *    pAV;
   
    //
    // Move over to the window any temporary attributes stored on the new markup 
    //                   
    pAAMarkupNew = *GetAttrArray();    
    if (pAAMarkupNew)
    {        
        // window's attr array should be null since we just cleared it
        ppAAWindow = Window()->GetAttrArray();

        if (!*ppAAWindow)
        {
            // create a new attr array on the window
            *ppAAWindow = new CAttrArray;
            if (!*ppAAWindow)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }
        }

        // run through the attr array on the new markup
        int i, cIndex;
        for (i = pAAMarkupNew->Size(), cIndex = 0, pAV = *pAAMarkupNew;
                i > 0;
                i--)
        {                           
            Assert (pAV);                          
            if ( CMarkup::IsTemporaryDISPID (pAV->GetDISPID()) )
            {
                Assert (!(*ppAAWindow)->Find(pAV->GetDISPID(), pAV->AAType()));

                // move temporary attr value onto the window                
                (*ppAAWindow)->AppendIndirect(pAV, NULL);
                pAAMarkupNew->Delete(cIndex);

                // after deleting, array elements have been shifted down one
                // so continue at same array index
                continue;
            }
            cIndex++;
            pAV++;
        }
    }   

Cleanup:
    return hr;
}


//+----------------------------------------------------------------------
//
//  Member:     CMarkup::GetFramesCount
//
//  Synopsis:   returns number of frames in frameset;
//              fails if the doc does not contain frameset
//
//-----------------------------------------------------------------------

HRESULT
CMarkup::GetFramesCount (LONG * pcFrames)
{
    HRESULT             hr;
    CElement      *     pElement;

    if (!pcFrames)
        RRETURN (E_POINTER);

    pElement = GetElementClient();
    if (!pElement || pElement->Tag() != ETAG_FRAMESET)
    {
        *pcFrames = 0;
        hr = S_OK;  // TODO: Why return S_OK if GetClientSite failed?
    }
    else
        hr = THR(DYNCAST(CFrameSetSite, pElement)->GetFramesCount(pcFrames));

    RRETURN( hr );
}

////////////////////////////////
// IMarkupContainer2 methods

//+---------------------------------------------------------------
//
//  Member: CreateChangeLog
//
//  Synopsis: Creates a new ChangeLog object and associates it with
//      the given ChangeSink.
//
//+---------------------------------------------------------------

HRESULT
CMarkup::CreateChangeLog(
    IHTMLChangeSink * pChangeSink,
    IHTMLChangeLog ** ppChangeLog,
    BOOL              fForward,
    BOOL              fBackward )
{
    HRESULT hr = S_OK;
    CLogManager * pLogMgr;
    IHTMLChangeSink * pChangeSinkCopy = NULL;

    if( !pChangeSink || !ppChangeLog || ( !fForward && !fBackward ) )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR( pChangeSink->QueryInterface( IID_IHTMLChangeSink, (void **)&pChangeSinkCopy ) );
    if( hr )
        goto Cleanup;

    pLogMgr = EnsureLogManager();
    if( !pLogMgr )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR( pLogMgr->RegisterSink( pChangeSinkCopy, ppChangeLog, fForward, fBackward ) );

Cleanup:
    ReleaseInterface( pChangeSinkCopy );
    RRETURN( hr );
}


//+---------------------------------------------------------------
//
//  Member: ExecChange
//
//  Synopsis: Executes the given Change Record on the markup
//
//+---------------------------------------------------------------

HRESULT
CMarkup::ExecChange(
    BYTE * pbRecord,
    BOOL   fForward )
{
    HRESULT             hr;
    CChangeRecordBase * pchrec;
    CMarkupPointer      mp( Doc() );

    Assert( pbRecord );
    if( !pbRecord )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // We're cheating here to line up the pointer with the actual data in memory
    pchrec = (CChangeRecordBase *)(pbRecord - sizeof(CChangeRecordBase *));

    hr = THR( pchrec->PlayIntoMarkup( this, fForward ) );
    if( hr )
        goto Cleanup;

Cleanup:
    RRETURN( hr );
}

#if 0
//+---------------------------------------------------------------
//
//  Member: GetRootElement
//
//  Synopsis: Gets the Root Element for the container
//
//+---------------------------------------------------------------

HRESULT
CMarkup::GetRootElement( IHTMLElement ** ppElement )
{
    HRESULT hr = S_OK;

    if( !ppElement )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *ppElement = NULL;

    Assert( Root() );
    hr = THR( Root()->QueryInterface( IID_IHTMLElement, (void **)ppElement ) );

Cleanup:
    RRETURN( hr );
}
#endif // 0

//+---------------------------------------------------------------------------
//
//  Dirty Range Service
//
//----------------------------------------------------------------------------
HRESULT 
CMarkup::RegisterForDirtyRange( IHTMLChangeSink * pChangeSink, DWORD * pdwCookie )
{
    HRESULT                     hr = S_OK;
    MarkupDirtyRange *          pdr;
    CMarkupChangeNotificationContext *  pcnc;
    IHTMLChangeSink *           pChangeSinkCopy = NULL;

    Assert( pChangeSink && pdwCookie );

    if( !pChangeSink || !pdwCookie )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // Did they actually give us a ChangeSink?
    hr = THR( pChangeSink->QueryInterface( IID_IHTMLChangeSink, (void **)&(pChangeSinkCopy) ) );
    if( hr )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    pcnc = EnsureChangeNotificationContext();
    if (!pcnc)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR( pcnc->_aryMarkupDirtyRange.AppendIndirect( NULL, &pdr ) );
    if (hr)
        goto Cleanup;

    Assert( pdr );

    pdr->_dwCookie      = 
    *pdwCookie          = InterlockedIncrement( (long *) &s_dwDirtyRangeServiceCookiePool );
    pdr->_pChangeSink   = pChangeSinkCopy;

    pdr->_pChangeSink->AddRef();
    pdr->_dtr.Reset();

    // In case anyone cares...
    pcnc->_fReentrantModification = TRUE;

Cleanup:
    ReleaseInterface( pChangeSinkCopy );
    RRETURN( hr );
}

HRESULT 
CMarkup::UnRegisterForDirtyRange( DWORD dwCookie )
{
    HRESULT                     hr = S_OK;
    CMarkupChangeNotificationContext *  pcnc;
    MarkupDirtyRange *          pdr;
    int                         cdr, idr;

    if (!HasChangeNotificationContext())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    pcnc = GetChangeNotificationContext();
    Assert( pcnc );

    for( idr = 0, cdr = pcnc->_aryMarkupDirtyRange.Size(), pdr = pcnc->_aryMarkupDirtyRange;
         idr < cdr;
         idr++, pdr++ )
    {
        if( pdr->_dwCookie == dwCookie )
        {
            pdr->_pChangeSink->Release();
            pcnc->_aryMarkupDirtyRange.Delete( idr );
            goto Cleanup;
        }
    }

    // In case anyone cares...
    pcnc->_fReentrantModification = TRUE;

    hr = E_FAIL;

Cleanup:
    RRETURN( hr );
}

HRESULT 
CMarkup::GetAndClearDirtyRange( DWORD dwCookie, CMarkupPointer * pmpBegin, CMarkupPointer * pmpEnd )
{
    HRESULT                     hr = S_OK;
    CMarkupChangeNotificationContext *  pcnc;
    MarkupDirtyRange *          pdr;
    int                         cdr, idr;

    if (!HasChangeNotificationContext())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    pcnc = GetChangeNotificationContext();
    Assert( pcnc );

    for( idr = 0, cdr = pcnc->_aryMarkupDirtyRange.Size(), pdr = pcnc->_aryMarkupDirtyRange;
         idr < cdr;
         idr++, pdr++ )
    {
        if (pdr->_dwCookie == dwCookie)
        {
            if (pmpBegin)
            {
                if( pdr->_dtr._cp == -1 )
                    hr = THR( pmpBegin->Unposition() );
                else
                    hr = THR( pmpBegin->MoveToCp( pdr->_dtr._cp, this ) );
                if (hr)
                    goto Cleanup;
            }
            
            if (pmpEnd)
            {
                if( pdr->_dtr._cp == -1 )
                    hr = THR( pmpEnd->Unposition() );
                else
                    hr = THR( pmpEnd->MoveToCp( pdr->_dtr._cp + pdr->_dtr._cchNew, this ) );
                if (hr)
                    goto Cleanup;
            }

            pdr->_dtr.Reset();

            goto Cleanup;
        }
    }

    hr = E_FAIL;

Cleanup:
    RRETURN( hr );
}

HRESULT
CMarkup::GetAndClearDirtyRange( DWORD dwCookie, IMarkupPointer * pIPointerBegin, IMarkupPointer * pIPointerEnd )
{
    HRESULT hr;
    CDoc *  pDoc = Doc();
    CMarkupPointer * pmpBegin, * pmpEnd;

    if (    (pIPointerBegin && !pDoc->IsOwnerOf( pIPointerBegin ))
        ||  (pIPointerEnd && !pDoc->IsOwnerOf( pIPointerEnd )))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR( pIPointerBegin->QueryInterface( CLSID_CMarkupPointer, (void **) & pmpBegin ) );

    if (hr)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    
    hr = THR( pIPointerEnd->QueryInterface( CLSID_CMarkupPointer, (void **) & pmpEnd ) );

    if (hr)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = GetAndClearDirtyRange( dwCookie, pmpBegin, pmpEnd );

Cleanup:
    RRETURN( hr );
}

void    
CMarkup::OnDirtyRangeChange(DWORD_PTR dwContext)
{
    CMarkupChangeNotificationContext * pcnc;
    MarkupDirtyRange            *   pdr;
    long                            cdr;
    BOOL                            fWasNotified;

    Assert( HasChangeNotificationContext() );

    pcnc = GetChangeNotificationContext();
    Assert( pcnc );

    Assert( pcnc->_fOnDirtyRangeChangePosted );
    pcnc->_fOnDirtyRangeChangePosted = FALSE;

    // Clear our flags
    pcnc->_fReentrantModification = FALSE;
    for( cdr = pcnc->_aryMarkupDirtyRange.Size(), pdr = pcnc->_aryMarkupDirtyRange; cdr > 0; cdr--, pdr++ )
    {
        pdr->_fNotified = FALSE;
    }

NotifyLoop:
    // Notify everyone of the change
    for( cdr = pcnc->_aryMarkupDirtyRange.Size(), pdr = pcnc->_aryMarkupDirtyRange; cdr > 0; cdr--, pdr++ )
    {
        Assert( pdr->_pChangeSink );

        fWasNotified = pdr->_fNotified;
        pdr->_fNotified = TRUE;

        // Check to make sure this sink hasn't already been notified, and that it has a dirty range
        if( !fWasNotified && pdr->_dtr.IsDirty() )
        {
            pdr->_pChangeSink->Notify();
        }

        // If they messed with us, we have to restart.
        if( pcnc->_fReentrantModification )
        {
            pcnc->_fReentrantModification = FALSE;
            goto NotifyLoop;
        }
    }

    // Make sure everything is cool, ie, everyone was notified
    Assert( !pcnc->_fReentrantModification );
#if DBG==1
    for( cdr = pcnc->_aryMarkupDirtyRange.Size(), pdr = pcnc->_aryMarkupDirtyRange; cdr; cdr--, pdr++ )
    {
        Assert( pdr->_fNotified );
    }
#endif // DBG


}

CMarkupChangeNotificationContext *    
CMarkup::EnsureChangeNotificationContext()
{
    CMarkupChangeNotificationContext *    pcnc;

    if (HasChangeNotificationContext())
        return GetChangeNotificationContext();

    pcnc = new CMarkupChangeNotificationContext;
    if (!pcnc)
        return NULL;

    if (SetChangeNotificationContext( pcnc ))
    {
        delete pcnc;
        return NULL;
    }

    return pcnc;
}


//+----------------------------------------------------------------------------
//  
//  Method:     CMarkup::GetVersionNumber
//  
//  Synopsis:   Returns the content version number
//  
//  Returns:    long
//  
//  Arguments:  None
//  
//+----------------------------------------------------------------------------

STDMETHODIMP_(long)
CMarkup::GetVersionNumber()
{
    return GetMarkupContentsVersion();
}

//+----------------------------------------------------------------------------
//
//  Method:     CMarkup::GetMasterElement
//  
//  Synopsis:   Returns the master element for the markup container, or NULL
//                  if the container is not slaved.
//  
//  Returns:    HRESULT
//  
//  Arguments:  
//          IHTMLElement ** ppElementMaster - Pointer to be filled
//  
//+----------------------------------------------------------------------------

STDMETHODIMP
CMarkup::GetMasterElement( IHTMLElement ** ppElementMaster )
{
    HRESULT hr = S_OK;
    CElement * pRootElement = Root();

    if( !ppElementMaster )
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    *ppElementMaster = NULL;

    Assert( pRootElement );

    if( pRootElement->HasMasterPtr() )
    {
        Assert( pRootElement->GetMasterPtr() );

        hr = THR( pRootElement->GetMasterPtr()->QueryInterface( IID_IHTMLElement, (void **)ppElementMaster ) );
    }
    else
    {
        pRootElement = GetElementClient();

        if( pRootElement && pRootElement->HasMasterPtr() )
        {
            Assert( pRootElement->GetMasterPtr() );

            hr = THR( pRootElement->GetMasterPtr()->QueryInterface( IID_IHTMLElement, (void **)ppElementMaster ) );
        }
    }

Cleanup:
    RRETURN( hr );
}

//+---------------------------------------------------------------------------
//
//  Layout Rect Registry - Keeps track of incoming layout rect elements
//   and their unsatisfied nextRect connections.
//
//----------------------------------------------------------------------------

CLayoutRectRegistry *
CMarkup::GetLayoutRectRegistry()
{
    CLayoutRectRegistry * pLRR = GetLRRegistry();

    if (!pLRR)
    {
        pLRR = new CLayoutRectRegistry();
    }

    IGNORE_HR(SetLRRegistry(pLRR));

    return pLRR;
}

void
CMarkup::ReleaseLayoutRectRegistry()
{
    CLayoutRectRegistry * pLRR = GetLRRegistry();

    if ( pLRR )
    {
        delete pLRR;
        IGNORE_HR( SetLRRegistry( NULL ) );
    }
}

//+------------------------------------------------------------------------
//
//  Member   : CMarkup::GetUpdatedCompatibleLayoutContext
//
//-------------------------------------------------------------------------

CCompatibleLayoutContext *
CMarkup::GetUpdatedCompatibleLayoutContext(CLayoutContext *pLayoutContextSrc)
{
    // This assert is important to guarantee validity of the compatible context.
    AssertSz( pLayoutContextSrc && pLayoutContextSrc->IsValid(), "When you ask for a compatible context, you must provide a valid context for it to be compatible with!" );

    CCompatibleLayoutContext *pLayoutContext = (CCompatibleLayoutContext *)GetCompatibleLayoutContext();
    if (pLayoutContext == NULL)
    {
        HRESULT hr; 

        pLayoutContext = new CCompatibleLayoutContext();
        Assert(pLayoutContext != NULL && "Failure to allocate CCompatibleLayoutContext");

        hr = SetCompatibleLayoutContext(pLayoutContext);
        if (hr != S_OK)
        {
            delete pLayoutContext;
            pLayoutContext = NULL;
        }
    }

    if (pLayoutContext != NULL)
    {
        pLayoutContext->Init(pLayoutContextSrc);
    }

    return (pLayoutContext);
}

//+------------------------------------------------------------------------
//
//  Member   : CMarkup::DelCompatibleLayoutContext
//
//-------------------------------------------------------------------------
void
CMarkup::DelCompatibleLayoutContext()
{
    Assert(HasCompatibleLayoutContext());

    // Make us stop pointing to the context
    CCompatibleLayoutContext * pLayoutContext = (CCompatibleLayoutContext *)DelLookasidePtr(LOOKASIDE_COMPATIBLELAYOUTCONTEXT);

    AssertSz(pLayoutContext, "Better have a context if we said we had one");
    AssertSz(pLayoutContext->RefCount() > 0, "Context better still be alive");
    AssertSz(pLayoutContext->IsValid(), "Context better still be valid");
    
    // Make the context stop pointing to an owner
    pLayoutContext->ClearLayoutOwner();

    // This release corresponds to the addref in SetCompatibleLayoutContext()
    pLayoutContext->Release();
}

//+------------------------------------------------------------------------
//
//  Member   : CMarkup::SetCompatibleLayoutContext
//
//-------------------------------------------------------------------------
HRESULT
CMarkup::SetCompatibleLayoutContext( CCompatibleLayoutContext *pLayoutContext )
{
    Assert( !HasCompatibleLayoutContext() && "Compatible contexts shouldn't be replaced; we should just re-use" );
    Assert( pLayoutContext && " bad bad thing, E_INVALIDARG" );
    
    pLayoutContext->AddRef();
    return SetLookasidePtr(LOOKASIDE_COMPATIBLELAYOUTCONTEXT, pLayoutContext);
}

//+------------------------------------------------------------------------
//
//      Member:     CElement::GetFrameOrPrimaryMarkup
//
//-------------------------------------------------------------------------

CMarkup *
CElement::GetFrameOrPrimaryMarkup(BOOL fStrict/*=FALSE*/)
{
    return GetWindowedMarkupContext();
}

//+------------------------------------------------------------------------
//
//      Member:     CElement::GetNearestMarkupForScriptCollection
//
//      Synopsis:   Returns the nearest markup in the hierarchy that has a 
//                  script collection. If there is no script collection,
//                  then the nearest frame or primary markup is returned.
//  
//-------------------------------------------------------------------------

CMarkup *
CElement::GetNearestMarkupForScriptCollection()
{
    return GetWindowedMarkupContext();
}

//+------------------------------------------------------------------------
//
//      Member:     CMarkup::GetFrameOrPrimaryMarkup
//
//-------------------------------------------------------------------------

CMarkup *
CMarkup::GetFrameOrPrimaryMarkup(BOOL fStrict/*=FALSE*/)
{
    return GetWindowedMarkupContext();
}

//+------------------------------------------------------------------------
//
//      Member:     CMarkup::GetNearestMarkupForScriptCollection
//
//      Synopsis:   Returns the nearest markup in the hierarchy that has a 
//                  script collection. If there is no script collection,
//                  then the nearest frame or primary markup is returned.
//  
//-------------------------------------------------------------------------
CMarkup *
CMarkup::GetNearestMarkupForScriptCollection()
{
    return GetWindowedMarkupContext();
}


//+------------------------------------------------------------------------
//
//  Member   : CMarkup::GetPositionCookie
//
//-------------------------------------------------------------------------

HRESULT
CMarkup::GetPositionCookie(DWORD * pdwCookie)
{
    CElement * pElement = GetCanvasElement();

    if (   pElement
        && IsScrollingElementClient(pElement)
       )
    {
        *pdwCookie = pElement->GetUpdatedLayout()->GetYScroll();
    }
    else
    {
        *pdwCookie = 0;
    }
    
    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Member   : CMarkup::SetPositionCookie
//
//-------------------------------------------------------------------------

HRESULT
CMarkup::SetPositionCookie(DWORD dwCookie)
{ 
    return NavigateHere(0, NULL, dwCookie, TRUE);
}

// TODO: (jbeda) I'm not sure that this code works right -- most HTCs have windows!
#if 0
//+------------------------------------------------------------------------
//
//  Member   : CMarkup::NearestWindowHelper()
//
//-------------------------------------------------------------------------

// Helper fn for NearestWindow(); starts with "this" markup and looks up
// through the master chain for the nearest markup that has an OM window
// and returns that window.
COmWindowProxy *
CMarkup::NearestWindowHelper()
{
    CElement *pRootElem;
    CElement *pMasterElem;
    CMarkup *pMarkup = this;
    COmWindowProxy *pWindow = NULL;

    while ( pWindow == NULL )
    {
        pRootElem = pMarkup->Root();
        AssertSz( pRootElem, "Markup must have a root element" );
        if ( pRootElem->HasMasterPtr() )
        {
            pMasterElem = pRootElem->GetMasterPtr();
            pMarkup = pMasterElem->GetMarkup();
            if ( pMarkup )
            {
                pWindow = pMarkup->Window();
                // If our master markup has a window, pWindow will be non-NULL
                // and we'll fall out of the loop.  If it doesn't, we'll
                // try and find our master's master etc.
            }
        }
        else
        {
            // found a root w/o a master; nowhere left to go!
            break;
        }
    }

    return pWindow;
}
#endif

//+------------------------------------------------------------------------
//
//      Member:     CMarkup::GetFocusItems
//
//      Synopsis:   Returns the focus items array, creating one 
//                  if one does not exist.
//  
//      Arguments:  
//                  fShouldCreate - Whether we should create it, if one does
//                      already not exist
//-------------------------------------------------------------------------

CAryFocusItem * 
CMarkup::GetFocusItems(BOOL fShouldCreate) 
{
    HRESULT hr;
    CAryFocusItem * paryFocusItem = NULL;

    hr = GetPointerAt (FindAAIndex(DISPID_INTERNAL_FOCUSITEMS, CAttrValue::AA_Internal), 
        (void **) &paryFocusItem);    
    
    // create focus items array
    if (hr==DISP_E_MEMBERNOTFOUND && fShouldCreate)
    {    
        paryFocusItem = new CAryFocusItem;            
        if (paryFocusItem)
        {
            hr = AddPointer ( DISPID_INTERNAL_FOCUSITEMS,
                    (void *) paryFocusItem,
                    CAttrValue::AA_Internal );
            if (hr)
            {
                delete paryFocusItem;
            }
            else
            {
                hr = S_OK;
            }
        }
    }

    return hr ? NULL : (CAryFocusItem*)paryFocusItem;
}

//+------------------------------------------------------------------------
//
//      Member:     CMarkup::GetPicsTarget
//
//      Synopsis:   Get the IOleCommandTarget to report pics results to
//  
//-------------------------------------------------------------------------

IOleCommandTarget *
CMarkup::GetPicsTarget() 
{
    if (HasTransNavContext())
        return GetTransNavContext()->_pctPics;
    return NULL;
}

//+------------------------------------------------------------------------
//
//      Member:     CMarkup::SetPicsTarget
//
//      Synopsis:   Set the IOleCommandTarget to report pics results to
//  
//-------------------------------------------------------------------------

HRESULT
CMarkup::SetPicsTarget(IOleCommandTarget * pctPics) 
{
    HRESULT hr = S_OK;

    CMarkupTransNavContext * ptnc;
    if (pctPics)
    {
        ptnc = EnsureTransNavContext();
        if(!ptnc)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        ReplaceInterface( &(ptnc->_pctPics), pctPics );
    }
    else if(HasTransNavContext())
    {
        ptnc = GetTransNavContext();

        ClearInterface( &(ptnc->_pctPics) );

        EnsureDeleteTransNavContext( ptnc );
    }

Cleanup:
    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//  
//  Method:     CMarkup::EnsureLocationContext
//  
//  Synopsis:   Ensures the location context
//  
//  Returns:    CMarkupLocationContext * - the location context
//  
//  Arguments:  None
//  
//+----------------------------------------------------------------------------

CMarkupLocationContext *
CMarkup::EnsureLocationContext()
{
    CMarkupLocationContext * pmlc;

    if( HasLocationContext() )
        return GetLocationContext();

    pmlc = new CMarkupLocationContext;
    if( !pmlc )
        return NULL;

    if( SetLocationContext( pmlc ) )
    {
        delete pmlc;
        return NULL;
    }

    return pmlc;
}


//+----------------------------------------------------------------------------
//  
//  Method:     CMarkup::SetUrl
//  
//  Synopsis:   Sets the url in the MarkupLocationContext.  We must not
//                  currently have an URL set.
//  
//  Returns:    HRESULT
//  
//  Arguments:
//          TCHAR * pchUrl - New Url
//  
//+----------------------------------------------------------------------------

HRESULT
CMarkup::SetUrl(TCHAR * pchUrl)
{
    HRESULT hr = S_OK;
    CMarkupLocationContext * pmlc = EnsureLocationContext();

    if (!pmlc)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    Assert(!pmlc->_pchUrl && pchUrl);
    pmlc->_pchUrl = pchUrl;

Cleanup:
    RRETURN(hr);
}



//+----------------------------------------------------------------------------
//  
//  Method:     CMarkup::DelUrl
//  
//  Synopsis:   Removes and returns the current url from the 
//                  MarkupLocationContext, if we have one
//  
//  Returns:    TCHAR * - the current url
//  
//  Arguments:
//  
//+----------------------------------------------------------------------------

TCHAR *
CMarkup::DelUrl()
{
    TCHAR * pch = NULL;
    
    if( HasLocationContext() )
    {
        CMarkupLocationContext * pmlc = GetLocationContext();
        
        pch = pmlc->_pchUrl;
        pmlc->_pchUrl = NULL;
    }

    return pch;
}

//+----------------------------------------------------------------------------
//  
//  Method  : CMarkup::SetUrlOriginal
//  
//  Synopsis: Sets the original url in the MarkupLocationContext.
//  
//  Input   : pszUrlOriginal - New original Url
//  
//+----------------------------------------------------------------------------

HRESULT
CMarkup::SetUrlOriginal(LPTSTR pszUrlOriginal)
{
    CMarkupLocationContext * pmlc = EnsureLocationContext();

    if (!pmlc)
    {
        return E_OUTOFMEMORY;
    }

    MemFreeString(pmlc->_pchUrlOriginal);
    pmlc->_pchUrlOriginal = pszUrlOriginal;

    return S_OK;
}

//+----------------------------------------------------------------------------
//  
//  Method  : CMarkup::SetDomain
//  
//  Synopsis: Sets the domain in the MarkupLocationContext.
//  
//  Input   : pszDomain - New domain
//  
//+----------------------------------------------------------------------------

HRESULT
CMarkup::SetDomain(LPTSTR pszDomain)
{
    HRESULT hr = E_FAIL;
    TCHAR * pchAlloc = NULL;
    CMarkupLocationContext * pmlc = NULL;

    if( HasLocationContext() )
    {
        pmlc = GetLocationContext();
        
        MemFreeString(pmlc->_pchDomain);
        pmlc->_pchDomain = NULL;
    }

    if (!pszDomain)
    {
        goto Cleanup;
    }

    if (!pmlc)
    {
        pmlc = EnsureLocationContext();
        if (!pmlc)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }

    hr = THR(MemAllocString(Mt(CMarkup_pchDomain), pszDomain, &pchAlloc));
    if (hr)
        goto Cleanup;

    pmlc->_pchDomain = pchAlloc;

Cleanup:
    return hr;
}

//+----------------------------------------------------------------------------
//  
//  Method:     CMarkup::ReplaceMonikerPtr
//  
//  Synopsis:   Replaces the existing moniker ptr (if any) w/ a new one
//  
//  Returns:    HRESULT
//  
//  Arguments:
//          IMoniker * pmkNew - new moniker for markup
//  
//+----------------------------------------------------------------------------

HRESULT
CMarkup::ReplaceMonikerPtr( IMoniker * pmkNew )
{
    CMarkupLocationContext * pmlc;

    if( !pmkNew && !HasLocationContext() )
        return S_OK;

    pmlc = EnsureLocationContext();

    if( !pmlc )
        return E_OUTOFMEMORY;

    ReplaceInterface( &(pmlc->_pmkName), pmkNew );
    
    return S_OK;
}

//+----------------------------------------------------------------------------
//  
//  Method:     CMarkup::EnsureTextContext
//  
//  Synopsis:   Ensures the text context
//  
//  Returns:    CMarkupTextContext * - the text context
//  
//  Arguments:  None
//  
//+----------------------------------------------------------------------------

CMarkupTextContext *
CMarkup::EnsureTextContext()
{
    CMarkupTextContext *pContext;

    if( HasTextContext() )
        return GetTextContext();

    pContext = new CMarkupTextContext;
    if( !pContext )
        return NULL;

    if( SetTextContext( pContext ) )
    {
        delete pContext;
        return NULL;
    }

    return pContext;
}


//+----------------------------------------------------------------------------
//  
//  Method:     CMarkup::SetTextRangeListPtr
//  
//  Synopsis:   Sets the CAutoRange in the CMarkupTextContext.  We must not
//              have a CAutoRange set.
//  
//  Returns:    HRESULT
//  
//  Arguments:
//          CAutoRange *pAutoRange - AutoRange
//  
//+----------------------------------------------------------------------------

HRESULT
CMarkup::SetTextRangeListPtr( CAutoRange *pAutoRange )
{
    CMarkupTextContext * pContext = EnsureTextContext();

    if( !pContext )
    {
        return E_OUTOFMEMORY;
    }

    Assert( !pContext->_pAutoRange && pAutoRange );
    pContext->_pAutoRange = pAutoRange;

    return S_OK;
}


//+----------------------------------------------------------------------------
//  
//  Method:     CMarkup::DelTextRangeListPtr
//  
//  Synopsis:   Removes and returns the CAutoRange from the 
//                  MarkupTextContext, if we have one
//  
//  Returns:    CAutoRange * - The auto range
//  
//  Arguments:
//  
//+----------------------------------------------------------------------------

CAutoRange *
CMarkup::DelTextRangeListPtr()
{
    CAutoRange *pRange = NULL;
    
    if( HasTextContext() )
    {
        CMarkupTextContext * pContext = GetTextContext();
        
        pRange = pContext->_pAutoRange;
        pContext->_pAutoRange = NULL;
    }

    return pRange;
}

//+----------------------------------------------------------------------------
//  
//  Method:     CMarkup::SetTextFragContext
//  
//  Synopsis:   Sets the CMarkupTextFragContext. 
//  
//  Returns:    HRESULT
//  
//  Arguments:
//          CMarkupTextFragContext *ptfc - Text frag context
//  
//+----------------------------------------------------------------------------

HRESULT
CMarkup::SetTextFragContext(CMarkupTextFragContext * ptfc)
{
    CMarkupTextContext * pContext = EnsureTextContext();

    if( !pContext )
    {
        return E_OUTOFMEMORY;
    }

    Assert( !pContext->_pTextFrag && ptfc );
    pContext->_pTextFrag = ptfc;

    return S_OK;
}


//+----------------------------------------------------------------------------
//  
//  Method:     CMarkup::DelTextFragContext
//  
//  Synopsis:   Removes and returns the CMarkupTextFragContext 
//  
//  Returns:    CAutoRange * - The auto range
//  
//  Arguments:
//  
//+----------------------------------------------------------------------------

CMarkupTextFragContext *
CMarkup::DelTextFragContext()
{
    CMarkupTextFragContext *ptfc = NULL;
    
    if( HasTextFragContext() )
    {
        CMarkupTextContext * pContext = GetTextContext();
        
        ptfc = pContext->_pTextFrag;
        pContext->_pTextFrag = NULL;
    }

    return ptfc;
}

//+----------------------------------------------------------------------------
//  
//  Method:     CMarkup::SetOrphanedMarkup
//
//  Synopsis:   Sets a markup's orphaned state.  If fOrphaned is TRUE, then
//              we'll add ourselves to the  list of orphaned markups
//              and set a bit on ourselves.
//              If fOrphaned is FALSE, then we pull ourselves out of the
//              list and clear the bit.
//
//  Arguments:  fOrphaned - New orphaned state
//
//+----------------------------------------------------------------------------
HRESULT CMarkup::SetOrphanedMarkup( BOOL fOrphaned )
{
    HRESULT hr                      = S_OK;
    CMarkupTextContext * pContext   = NULL;

    if( fOrphaned )
    {
        TraceTag(( tagOrphanedMarkup, "Orphaning markup %d(%x)", _nSerialNumber, this ));

        // Get the appropriate contexts
        pContext = EnsureTextContext();
        if( !pContext )
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        // We'd better not already be in there
        Assert( Doc()->_aryMarkups.Find( this ) == -1 && !IsOrphanedMarkup() );

        hr = THR( Doc()->_aryMarkups.Append( this ) );
        if( hr )
            goto Cleanup;

        // Remember that we're orphaned
        pContext->_fOrphanedMarkup = TRUE;
    }
    else
    {
        TraceTag(( tagOrphanedMarkup, "Un-Orphaning markup %d(%x)", _nSerialNumber, this ));

        pContext = GetTextContext();
        Assert( pContext && pContext->_fOrphanedMarkup );

        // Either we should be in the live array, or in the process of clearing orphans
        Assert( Doc()->_aryMarkups.Find( this ) != -1 || Doc()->_fClearingOrphanedMarkups );

        Doc()->_aryMarkups.DeleteByValue( this );
        pContext->_fOrphanedMarkup = FALSE;
    }

Cleanup:
    RRETURN( hr );
}


//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::EnsureEditRouter
//
//----------------------------------------------------------------------------

HRESULT
CMarkup::EnsureEditRouter(CEditRouter **ppEditRouter)
{
    HRESULT     hr = S_OK;
    CEditRouter *pRouter = GetEditRouter();

    if( !pRouter )
    {
        pRouter = new CEditRouter();
        if( !pRouter )
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = THR(SetEditRouter(pRouter));
        if (hr)
            goto Cleanup;
    }

    if( ppEditRouter )
    {
        *ppEditRouter = pRouter;
    }

Cleanup:
    RRETURN (hr);
}
//+----------------------------------------------------------------------------
//  
//  Method:     CMarkup::SetEditRouter
//  
//  Synopsis:   Sets the CEditRouter 
//  
//  Returns:    HRESULT
//  
//  Arguments:
//          CEditRouter *pRouter = Router
//  
//+----------------------------------------------------------------------------
HRESULT
CMarkup::SetEditRouter(CEditRouter *pRouter)
{
    CMarkupEditContext * pContext = EnsureEditContext();

    if( !pContext )
    {
        return E_OUTOFMEMORY;
    }

    Assert( !pContext->_pEditRouter && pRouter );
    pContext->_pEditRouter = pRouter;

    return S_OK;
}


//+----------------------------------------------------------------------------
//  
//  Method:     CMarkup::DelEditRouter
//  
//  Synopsis:   Removes and returns the CEditRouter 
//  
//  Returns:    CEditRouter - The Edit router
//
//+----------------------------------------------------------------------------
CEditRouter *
CMarkup::DelEditRouter()
{
    CEditRouter *pRouter = NULL;
    
    if( HasEditRouter() )
    {
        CMarkupEditContext * pContext = GetEditContext();
        
        pRouter = pContext->_pEditRouter;
        pContext->_pEditRouter = NULL;
    }

    return pRouter;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::EnsureGlyphTable
//
//----------------------------------------------------------------------------
HRESULT
CMarkup::EnsureGlyphTable(CGlyph **ppGlyphTable)
{
    HRESULT     hr = S_OK;
    CGlyph      *pTable = GetGlyphTable();

    if( !pTable )
    {
        pTable = new CGlyph(Doc());
        if( !pTable )
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = THR(SetGlyphTable(pTable));
        if (hr)
            goto Cleanup;
    }

    if( ppGlyphTable )
    {
        *ppGlyphTable = pTable;
    }

Cleanup:
    RRETURN (hr);
}

//+----------------------------------------------------------------------------
//  
//  Method:     CMarkup::SetGlyphTable
//  
//  Synopsis:   Sets the glyph table 
//  
//  Returns:    HRESULT
//  
//  Arguments:
//          CGlyphTable *pTable = glyph table
//  
//+----------------------------------------------------------------------------
HRESULT
CMarkup::SetGlyphTable(CGlyph *pTable)
{
    CMarkupEditContext * pContext = EnsureEditContext();

    if( !pContext )
    {
        return E_OUTOFMEMORY;
    }

    Assert( !pContext->_pGlyphTable && pTable );
    pContext->_pGlyphTable = pTable;

    return S_OK;
}


//+----------------------------------------------------------------------------
//  
//  Method:     CMarkup::DelGlyphTable
//  
//  Synopsis:   Removes and returns the glyph table 
//  
//  Returns:    CGlyph - The glyph table
//
//+----------------------------------------------------------------------------
CGlyph *
CMarkup::DelGlyphTable()
{
    CGlyph *pTable = NULL;
    
    if( HasGlyphTable() )
    {
        CMarkupEditContext * pContext = GetEditContext();
        
        pTable = pContext->_pGlyphTable;
        pContext->_pGlyphTable = NULL;
    }

    return pTable;
}

//+----------------------------------------------------------------------------
//  
//  Method:     CMarkup::EnsureEditContext
//  
//  Synopsis:   Ensures the edit context
//  
//  Returns:    CMarkupEditContext * - the edit context
//  
//  Arguments:  None
//  
//+----------------------------------------------------------------------------
CMarkupEditContext *
CMarkup::EnsureEditContext()
{
    CMarkupEditContext *pContext;

    if( HasEditContext() )
        return GetEditContext();

    pContext = new CMarkupEditContext;
    if( !pContext )
        return NULL;

    if( SetEditContext( pContext ) )
    {
        delete pContext;
        return NULL;
    }

    return pContext;
}


HRESULT
CMarkup::GetTagInfo(CTreePos                *ptp, 
                    int                     gAlign, 
                    int                     gPositioning, 
                    int                     gOrientation, 
                    void                    *invalidateInfo, 
                    CGlyphRenderInfoType    *ptagInfo )
{
    HRESULT hr = S_OK;

    if( HasGlyphTable() )
    {
        hr = GetGlyphTable()->GetTagInfo( ptp, 
                                         (GLYPH_ALIGNMENT_TYPE)gAlign, 
                                         (GLYPH_POSITION_TYPE)gPositioning, 
                                         (GLYPH_ORIENTATION_TYPE)gOrientation, 
                                         invalidateInfo, 
                                         ptagInfo );
    }
    
    return (hr);
}

HRESULT
CMarkup::EnsureGlyphTableExistsAndExecute(  GUID        *pguidCmdGroup,
                                            UINT        idm,
                                            DWORD       nCmdexecopt,
                                            VARIANTARG  *pvarargIn,
                                            VARIANTARG  *pvarargOut)
{
    HRESULT hr = S_OK;

    if( idm == IDM_EMPTYGLYPHTABLE )
    {
        delete DelGlyphTable();
        hr = THR(ForceRelayout());
        RRETURN(hr);
    }

    if( !HasGlyphTable() )
    {
        hr = THR( EnsureGlyphTable(NULL) );
        if( hr )
            goto Cleanup;
            
        hr = GetGlyphTable()->Init();
        if (hr)
            goto Cleanup;
    }
    
    hr = GetGlyphTable()->Exec(pguidCmdGroup, idm, nCmdexecopt,pvarargIn, pvarargOut);

Cleanup:
    RRETURN (hr);
}

//+----------------------------------------------------------------------------
//  
//  Method:     CMarkup::SetMedia
//  
//  Synopsis:   Sets the media type
//  
//  Returns:    HRESULT
//  
//+----------------------------------------------------------------------------
HRESULT
CMarkup::SetMedia(mediaType type)
{
    CMarkupEditContext * pContext = EnsureEditContext();

    if( !pContext )
    {
        return E_OUTOFMEMORY;
    }

    pContext->_eMedia = type;

    // Set the bit on the markup accordingly.
    _fForPrint = !!(GetMedia() & mediaTypePrint);

    return S_OK;
}



HRESULT
CMarkup::SetPrintTemplate(BOOL f)
{
    if (f || HasEditContext())
    {
        CMarkupEditContext * pContext = EnsureEditContext();

        if (!pContext)
            return E_OUTOFMEMORY;

        pContext->_fIsPrintTemplate = f;    

        {
            // Walk the tree, setting templateness on any markup children we have
            CTreePos * ptp;
            CElement * pElement;
            CMarkup  * pMarkup;
            for (ptp = FirstTreePos(); ptp; ptp = ptp->NextTreePos() )
            {
                if (ptp->IsBeginElementScope())
                {
                    pElement = ptp->Branch()->Element();
                    if (pElement->HasSlavePtr())
                    {
                        pMarkup = pElement->GetSlavePtr()->GetMarkup();
                        if (    !pMarkup->IsPrintMedia()                // in LayoutRect
                            &&  !pMarkup->IsPrintTemplateExplicit() )   // has been set explicitly
                        {
                            pMarkup->SetPrintTemplate(f);
                        }
                    }
                }
            }    
        }
    }

    return S_OK;
}
HRESULT
CMarkup::SetPrintTemplateExplicit(BOOL f)
{
    if (f || HasEditContext())
    {
        CMarkupEditContext * pContext = EnsureEditContext();

        if (!pContext)
            return E_OUTOFMEMORY;
    
        pContext->_fIsPrintTemplateExplicit = f;
    }
    return S_OK;
}

//+----------------------------------------------------------------------------
//  
//  Method:     CMarkup::GetFrameOptions
//  
//  Synopsis:   Gets the frame options
//  
//  Returns:    DWORD that is the frame options
//  
//+----------------------------------------------------------------------------
DWORD
CMarkup::GetFrameOptions()
{
    DWORD dwFrameOptions;
    
    dwFrameOptions = ( HasEditContext() ? GetEditContext()->_dwFrameOptions : 0 );
    
    if ( Doc()->_fViewLinkedInWebOC && IsPrimaryMarkup() )
    {
        HRESULT hr;
        COleSite *pOleSite;
        
        hr = IUnknown_QueryService(Doc()->_pClientSite, CLSID_HTMLFrameBase, CLSID_HTMLFrameBase, (void**)&pOleSite);
        if (!hr)
        {
            CMarkup *pMarkup;
            pMarkup = pOleSite->GetWindowedMarkupContext();
            if (pMarkup)
            {
                dwFrameOptions = pMarkup->GetFrameOptions();
            }
        }
    }

    return dwFrameOptions;
}

//+----------------------------------------------------------------------------
//  
//  Method:     CMarkup::SetFrameOptions
//  
//  Synopsis:   Sets the frame options
//  
//  Returns:    HRESULT
//  
//+----------------------------------------------------------------------------
HRESULT
CMarkup::SetFrameOptions(DWORD dwFrameOptions)
{
    CMarkupEditContext * pContext = EnsureEditContext();

    if( !pContext )
    {
        return E_OUTOFMEMORY;
    }

    pContext->_dwFrameOptions = dwFrameOptions;
    return S_OK;
}

//+----------------------------------------------------------------------------
//  
//  Method:     CMarkup::SetMapHead
//  
//  Synopsis:   Sets the CMapElement 
//  
//  Returns:    HRESULT
//  
//  Arguments:
//          CMapElement *pMap = Map
//  
//+----------------------------------------------------------------------------
HRESULT
CMarkup::SetMapHead(CMapElement *pMap)
{
    CMarkupEditContext * pContext = EnsureEditContext();

    if( !pContext )
    {
        return E_OUTOFMEMORY;
    }

    Assert( pMap );
    pContext->_pMapHead = pMap;

    return S_OK;
}

//+----------------------------------------------------------------------------
//  
//  Method:     CMarkup::SetRadioGroupName
//  
//  Synopsis:   Sets the RADIOGRPNAME 
//  
//  Returns:    HRESULT
//  
//  Arguments:
//          RADIOGRPNAME * pRadioGrpName
//  
//+----------------------------------------------------------------------------
HRESULT
CMarkup::SetRadioGroupName(RADIOGRPNAME * pRadioGrpName)
{
    CMarkupEditContext * pContext = EnsureEditContext();

    if( !pContext )
    {
        return E_OUTOFMEMORY;
    }

    pContext->_pRadioGrpName = pRadioGrpName;

    return S_OK;
}


//+----------------------------------------------------------------------------
//  
//  Method:     CMarkup::DelRadioGroupName
//  
//  Synopsis:   Removes and deletes the list of radio group names
//
//+----------------------------------------------------------------------------
void
CMarkup::DelRadioGroupName()
{    
    Assert( HasRadioGroupName() );

    CMarkupEditContext * pContext      = GetEditContext();
    RADIOGRPNAME       * pRadioGrpName = pContext->_pRadioGrpName;

    do
    {
        RADIOGRPNAME  *pNextRadioGrpName = pRadioGrpName->_pNext;

        SysFreeString((BSTR)pRadioGrpName->lpstrName);
        delete pRadioGrpName;
        pRadioGrpName = pNextRadioGrpName;
    } 
    while (pRadioGrpName);

    pContext->_pRadioGrpName = NULL;
}


//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::ShowWaitCursor
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
void
CMarkup::ShowWaitCursor(BOOL fShowWaitCursor)
{
    if (!!_fShowWaitCursor != !!fShowWaitCursor)
    {
        _fShowWaitCursor = fShowWaitCursor;
        if (_pDoc->_fHasViewSlave )
        {
            CNotification nf;
            
            nf.ShowWaitCursor(Root());
            nf.SetData((DWORD)(!!_fShowWaitCursor));
            Notify(&nf);
        }
        _pDoc->SendSetCursor(0);
    }
}

HRESULT
CMarkup::GetClassID( CLSID * pclsid )
{
    return E_NOTIMPL;
}

HRESULT
CMarkup::IsDirty()
{
    RRETURN1( ( __lMarkupContentsVersion & MARKUP_DIRTY_FLAG ) ? S_OK : S_FALSE, S_FALSE );
}

HRESULT
CMarkup::Load( LPSTREAM pStream )
{
    return E_NOTIMPL;
}

HRESULT
CMarkup::Save( LPSTREAM pStream, BOOL fClearDirty )
{
    HRESULT hr;

    hr = THR( SaveToStream( pStream ) );
    if( hr )
        goto Cleanup;

    if( fClearDirty )
    {
        ClearDirtyFlag();
    }

Cleanup:
    RRETURN( hr );
}

HRESULT
CMarkup::GetSizeMax(ULARGE_INTEGER FAR * pcbSize)
{
    return E_NOTIMPL;
}


//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::GetThemeHelper
//
//  Returns:    HTHEME
//
//----------------------------------------------------------------------------

HTHEME
CMarkup::GetThemeHelper(THEMECLASSID themeId)
{
    if (!HasWindow() && !HasWindowPending() && HasWindowedMarkupContextPtr())
    {
        return GetWindowedMarkupContextPtr()->GetThemeHelper(themeId);
    }
    else if ( GetThemeUsage() == THEME_USAGE_ON || 
            ((GetThemeUsage() == THEME_USAGE_DEFAULT) && (themeId == THEME_SCROLLBAR)) )
    {
        return GetThemeHandle(_pDoc->_pInPlace ? _pDoc->_pInPlace->_hwnd : GetDesktopWindow(), themeId);
    }
    return NULL;
}

BOOL
IsHtmlLayoutHelper(CMarkup * pMarkup)
{
    return pMarkup && pMarkup->IsHtmlLayout();
}

HRESULT                  
CMarkup::SetImageFile(BOOL fImageFile)
{
    HRESULT hr                          = S_OK;
    CMarkupLocationContext * pContext   = NULL;

    if( fImageFile )
    {
        pContext = EnsureLocationContext();
        if( !pContext )
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        pContext->_fImageFile = TRUE;
    }
    else
    {
        //if we already have context, clear the bit.
        //if no context or no bit set, nothing should be done
        if(IsImageFile())
            GetLocationContext()->_fImageFile = FALSE;
    }

Cleanup:
    RRETURN( hr );
}


//+----------------------------------------------------------------------------
//  
//  Method:     CMarkup::SetCookie
//  
//  Synopsis:   
//
//+----------------------------------------------------------------------------

void
CMarkup::SetCookieOnUIThread(DWORD_PTR pVoid)
{
    MarkupCookieStruct * pmcs = (MarkupCookieStruct*)pVoid;
    SetPrivacyInfo(&pmcs->lpszP3PHeader);
    SetCookie(pmcs->lpszUrl, pmcs->lpszCookieName, pmcs->lpszCookieData);
    Assert(pmcs->lpszCookieName == NULL); //this should only be called from CHtmPre::HandleMETA
    MemFreeString(pmcs->lpszUrl);
    MemFreeString(pmcs->lpszCookieData);
    delete pmcs;
}

BOOL
CMarkup::SetCookie(LPCTSTR lpszUrl, 
                   LPCTSTR lpszCookieName, 
                   LPCTSTR lpszCookieData)
{
    DWORD             bSet           = 0;
    DWORD             dwPrivacyFlags = 0;
    DWORD             dwFlags        = 0;
    TCHAR           * pchP3PHeader   = NULL; 
    CPrivacyInfo    * pPrivacyInfo   = NULL;    
    
    pPrivacyInfo = GetPrivacyInfo();
    if (pPrivacyInfo)
    {            
        pchP3PHeader = pPrivacyInfo->_pchP3PHeader;
        if (!pchP3PHeader)
           pchP3PHeader = _T("");
    }                
    else
    {
        pchP3PHeader = _T("");
    }

    if ((HasWindow() && Window()->Window()->_fRestricted) || 
        (HasWindowedMarkupContextPtr() && 
         GetWindowedMarkupContext()->Window()->Window()->_fRestricted))
         dwFlags |= INTERNET_FLAG_RESTRICTED_ZONE;
       
    dwFlags |= IsMarkupThirdParty() ? INTERNET_COOKIE_THIRD_PARTY     : 0;
    dwFlags |= INTERNET_COOKIE_EVALUATE_P3P;

    bSet = InternetSetCookieEx(lpszUrl, lpszCookieName, lpszCookieData, dwFlags, (DWORD_PTR)pchP3PHeader);

    switch((InternetCookieState)bSet)
    {
    case COOKIE_STATE_ACCEPT:
        dwPrivacyFlags |= COOKIEACTION_ACCEPT;        
        break;
    case COOKIE_STATE_PROMPT:
        AssertSz(0, "InternetSetCookieEx should not pass back prompt for cookie state");
        break;
    case COOKIE_STATE_UNKNOWN:
        // we'll get this for cookie rejected for reasons other than privacy
        break;
    case COOKIE_STATE_REJECT:        
        dwPrivacyFlags |= COOKIEACTION_REJECT;
        break;
    case COOKIE_STATE_LEASH:
        dwPrivacyFlags |= COOKIEACTION_LEASH;
        break;
    case COOKIE_STATE_DOWNGRADE:
        dwPrivacyFlags |= COOKIEACTION_DOWNGRADE;
        break;
    default:
        ;
    }                    
    
    THR(Doc()->AddToPrivacyList(lpszUrl, NULL, dwPrivacyFlags));

    return bSet;
}


BOOL
CMarkup::GetCookie(LPCTSTR lpszUrlName, LPCTSTR lpszCookieName, LPTSTR lpszCookieData, DWORD *lpdwSize)
{
    BOOL            bRet           = FALSE;
    long            dwPrivacyFlags = COOKIEACTION_READ; 
    DWORD           dwFlags        = 0;        
    
    dwFlags = IsMarkupThirdParty() ? INTERNET_COOKIE_THIRD_PARTY : 0;

    bRet = InternetGetCookieEx( lpszUrlName, 
                                lpszCookieName, 
                                lpszCookieData, 
                                lpdwSize, 
                                dwFlags,
                                NULL);

    // We want to set the suppress bit only if we didn't fail due to other errors like
    // insufficient buffer error or cookie did not exist. We are depending on the fact 
    // that Wininet does not set the LastError info if cookie is suppressed due to 
    // privacy settings. If they ever change the behavior to set a specific error, we
    // need to check for that instead.
    if (!bRet && !GetLastError()) 
    {
        // We are not using |= to mimic wininet's behavior which does not set the READ flag when suppressing
        dwPrivacyFlags = COOKIEACTION_SUPPRESS;
    }

    THR(Doc()->AddToPrivacyList(lpszUrlName, NULL, dwPrivacyFlags));

    return bRet;
}


BOOL
CMarkup::IsMarkupThirdParty()
{
    CMarkup   * pMarkupContext = GetWindowedMarkupContext();

    if (pMarkupContext)
    {
        CDwnDoc * pDwnDoc = pMarkupContext->GetDwnDoc();

        if (pDwnDoc)
        {
            BYTE  abRootSID[MAX_SIZE_SECURITY_ID];
            DWORD cbRootSID = ARRAY_SIZE(abRootSID);
            BYTE  abCookieSID[MAX_SIZE_SECURITY_ID];
            DWORD cbCookieSID = ARRAY_SIZE(abCookieSID);

            if (    S_OK == pDwnDoc->GetSecurityID(abRootSID, &cbRootSID)
                &&  S_OK == GetSecurityID(abCookieSID, &cbCookieSID, CMarkup::GetUrl(this)))
            {
                if (S_FALSE == CompareSecurityIds(abRootSID, cbRootSID, abCookieSID, cbCookieSID, 0))
                    return TRUE;
            }
        }
    }

    return FALSE;
}

//+----------------------------------------------------------------------------
//  
//  Method:     CMarkup::SetPrivacyInfo
//  
//  Synopsis:   Stores the privacy information bubbled up by wininet/urlmon  
//              to be used when setting cookies through script
//  
//  Returns:    HRESULT indicating success or failure when setting the 
//              lookaside pointer
//  
//  Arguments:  p3pheader
//              We now own the memory passed in p3pheader and need to free it
//              appropriately
//  
//+----------------------------------------------------------------------------

HRESULT
CMarkup::SetPrivacyInfo(LPTSTR * ppchP3PHeader)
{ 
    HRESULT           hr             = S_OK;
    CPrivacyInfo    * pPrivacyInfo   = NULL;
    BOOL              fHasPrivacyPtr = FALSE;
    BOOL              fHasP3PHeader = (ppchP3PHeader && *ppchP3PHeader && **ppchP3PHeader);
    

    // Do we need to create the lookaside on the markup for the privacy info?
    if (!fHasP3PHeader)
    {
        goto cleanup;
    }

    fHasPrivacyPtr = HasPrivacyInfo();

    if (fHasPrivacyPtr)
    {
        pPrivacyInfo = GetPrivacyInfo();
    }
    else 
    {
        pPrivacyInfo = new CPrivacyInfo();
        
        if (!pPrivacyInfo)
        {
            hr = E_OUTOFMEMORY;
            goto cleanup;
        }
    }

    if (fHasP3PHeader)
    {
        delete [] pPrivacyInfo->_pchP3PHeader;
        pPrivacyInfo->_pchP3PHeader = *ppchP3PHeader;
    }

    if (!fHasPrivacyPtr)
    {
        hr = SetLookasidePtr(LOOKASIDE_PRIVACY, pPrivacyInfo);
        if (FAILED(hr))
        {
            // Need to set the p3p hdr to null since we delete
            // the parameter in cleanup. Else the destructor for
            // the class also ends up deleting the same piece of memory
            pPrivacyInfo->_pchP3PHeader = NULL;
            delete pPrivacyInfo;
        }
    }

cleanup:
    if (FAILED(hr) && fHasP3PHeader)
        delete [] *ppchP3PHeader;

    if (fHasP3PHeader) 
        *ppchP3PHeader = NULL;

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\metarefresh.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1999
//
//  File    :   metarefresh.cxx
//
//  Contents:   Meta Refresh tag processing
//
//  Classes :   CWindow
//
//  Author  :   Scott Roberts (12/23/1999)
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx"
#endif

MtDefine(MetaRefresh, Locals, "Meta refresh")
DeclareTag(tagMetaRefresh, "Meta Refresh", "Trace Meta Refresh Methods");

//+-------------------------------------------------------------------------
//
//  Method  :   CWindow::ProcessMetaRefresh
//
//  Synopsis:   Processes the meta refresh URL and delay.
//
//--------------------------------------------------------------------------

void
CWindow::ProcessMetaRefresh(LPCTSTR pszUrl, UINT uiDelay)
{
    TraceTag((tagMetaRefresh, "+CWindow::ProcessMetaRefresh() - this:[0x%x] pszUrl:[%ws]",
              this, pszUrl));

    // Only accept the first Meta Refresh URL.
    //
    if ((!_pszMetaRefreshUrl || !*_pszMetaRefreshUrl) && pszUrl)
    {
        TraceTag((tagMetaRefresh, " CWindow::ProcessMetaRefresh() - Processing Refresh Data"));

        KillMetaRefreshTimer();

        if (_pszMetaRefreshUrl)
        {
            MemFreeString(_pszMetaRefreshUrl);
            _pszMetaRefreshUrl = NULL;
        }

        HRESULT hr = THR(MemAllocString(Mt(MetaRefresh), pszUrl, &_pszMetaRefreshUrl));
        if (hr)
            return;

        _uiMetaRefreshTimeout   = uiDelay*1000;
        _fMetaRefreshTimeoutSet = TRUE;
    }

    TraceTag((tagMetaRefresh, "-CWindow::ProcessMetaRefresh() - this:[0x%x]", this));
}

//+-------------------------------------------------------------------------
//
//  Method  :   CWindow::StartMetaRefreshTimer
//
//  Synopsis:   Starts the meta refresh timer.
//
//--------------------------------------------------------------------------

void
CWindow::StartMetaRefreshTimer()
{
    TraceTag((tagMetaRefresh, "+CWindow::StartMetaRefreshTimer() - this:[0x%x]", this));

    if (_fMetaRefreshTimeoutSet) 
    {
        KillMetaRefreshTimer();

        TraceTag((tagMetaRefresh, " CWindow::StartMetaRefreshTimer() - Starting Meta Refresh Timer"));

        HRESULT hr = FormsSetTimer(this, ONTICK_METHOD(CWindow, MetaRefreshTimerCallback, metarefreshtimercallback),
                                   TIMER_METAREFRESH, _uiMetaRefreshTimeout);
        if (S_OK == hr)
            _fMetaRefreshTimerSet = TRUE;
    }

    TraceTag((tagMetaRefresh, "-CWindow::StartMetaRefreshTimer() - this:[0x%x] _fMetaRefreshTimerSet:[%d]",
              this, _fMetaRefreshTimerSet));
}

//+-------------------------------------------------------------------------
//
//  Method  :   CWindow::KillMetaRefreshTimer
//
//  Synopsis:   Kills the meta refresh timer.
//
//--------------------------------------------------------------------------

void
CWindow::KillMetaRefreshTimer()
{
    TraceTag((tagMetaRefresh, "+CWindow::KillMetaRefreshTimer() - this:[0x%x]", this));

    if (_fMetaRefreshTimerSet)
    {
        _fMetaRefreshTimeoutSet = FALSE;
        _fMetaRefreshTimerSet   = FALSE;

        TraceTag((tagMetaRefresh, " CWindow::KillMetaRefreshTimer() - killing Meta Refresh Timer"));
        IGNORE_HR(FormsKillTimer(this, TIMER_METAREFRESH));
    }

    TraceTag((tagMetaRefresh, "-CWindow::KillMetaRefreshTimer() - this:[0x%x]", this));
}

//+-------------------------------------------------------------------------
//
//  Method  :   CWindow::ClearMetaRefresh
//
//  Synopsis:   Kills the meta refresh timer and clears the refresh url.
//
//--------------------------------------------------------------------------

void 
CWindow::ClearMetaRefresh()
{
    TraceTag((tagMetaRefresh, "+CWindow::ClearMetaRefresh() - this:[0x%x]", this));

    KillMetaRefreshTimer();

    // If we're called here after ProcessMetaRefresh but BEFORE StartMetaRefreshTimer, then
    // _fMetaRefreshTimerSet will be FALSE and _fMetaRefreshTimeoutSet will not be cleared in 
    // KillMetaRefreshTimer.  Do it here.
    //
    _fMetaRefreshTimeoutSet = FALSE;

    MemFreeString(_pszMetaRefreshUrl);
    _pszMetaRefreshUrl = NULL;

    TraceTag((tagMetaRefresh, "-CWindow::ClearMetaRefresh() - this:[0x%x]", this));
}

//+-------------------------------------------------------------------------
//
//  Method  :   CWindow::MetaRefreshTimerCallback
//
//  Synopsis:   Meta refresh callback method.
//
//--------------------------------------------------------------------------

HRESULT BUGCALL
CWindow::MetaRefreshTimerCallback(UINT uTimerID)
{
    Assert(uTimerID == TIMER_METAREFRESH);
    Assert(_pMarkup);

    HRESULT  hr     = S_OK;
    CDoc   * pDoc   = Doc();
    LPTSTR   pszUrl = NULL;

    TraceTag((tagMetaRefresh, "+CWindow::MetaRefreshTimerCallback() - this:[0x%x] _pMarkup:[0x%x] ID:[%d]",
              this, _pMarkup, uTimerID));


    // do nothing if this is the print template or a doc in design mode.
    // Also, don't continue if the CDoc is in a bad state. The window can be alive independently due to
    // external references.
    if (pDoc->DesignMode() || pDoc->IsPassivating() ||
        pDoc->IsPassivated() || Markup()->IsPrintMedia() )
    {
        goto Cleanup;
    }

    // Check if the security zone settings allow refreshing through meta tags...
    //
    BOOL    fAllow = FALSE;
    DWORD   dwPuaf = _fRestricted ? PUAF_ENFORCERESTRICTED : 0;
    DWORD   dwPolicy;

    hr = THR(Markup()->ProcessURLAction( URLACTION_HTML_META_REFRESH, 
                                            &fAllow, 
                                            dwPuaf,
                                            &dwPolicy));

    if (hr || !fAllow || (GetUrlPolicyPermissions(dwPolicy) == URLPOLICY_DISALLOW))
    {
        goto Cleanup;
    }

    // A copy of the refresh URL must be made because, 
    // _pszMetaRefreshUrl has to be released. If it is not
    // released, the timer will not be restarted.
    //
    if (_pszMetaRefreshUrl && *_pszMetaRefreshUrl)
    {
        hr = THR(MemAllocString(Mt(MetaRefresh), _pszMetaRefreshUrl, &pszUrl));
        if (hr)
            goto Cleanup;
    }
    else
    {
        // TODO (scotrobe): If the URL is null, we're really supposed 
        // just refresh the document. However, there is a bug in BecomeCurrent()
        // which is called by ExecRefresh which prevents the window from being
        // passivated. This causes this timer proc to be called after navigating
        // away from the page. When the bug in BecomeCurrent is changed, this 
        // method should be changed to refresh the document. Use this code to cause
        // the refresh to occur. Also, remove the code below because ExecHelper will
        // take care of notifying the DocHostUIHandler.  Here is the code to use:
        //
        //       V_I4(&cvarLevel) = OLECMDIDF_REFRESH_NO_CACHE|OLECMDIDF_REFRESH_CLEARUSERINPUT;
        //       hr = _pDocument->Exec(NULL, OLECMDID_REFRESH, OLECMDEXECOPT_PROMPTUSER, &cvarLevel, NULL);*/
        //
        hr = THR(MemAllocString(Mt(MetaRefresh), CMarkup::GetUrl(_pMarkup), &pszUrl));
        if (hr)
            goto Cleanup;

        if (pDoc->_pHostUICommandHandler)
        {
            // Give the DocHostUIHandler a chance to handle the refresh. Only proceed if 
            // the DocHostUIHandler doesn't handle the command id (i.e., Exec returns a 
            // failure code.)
            //
            CVariant cvarLevel(VT_I4);
            V_I4(&cvarLevel) = OLECMDIDF_REFRESH_NO_CACHE|OLECMDIDF_REFRESH_CLEARUSERINPUT;

            hr = THR_NOTRACE(pDoc->_pHostUICommandHandler->Exec(&CGID_DocHostCommandHandler,
                                                                OLECMDID_REFRESH, OLECMDEXECOPT_PROMPTUSER,
                                                                &cvarLevel, NULL));
            if (SUCCEEDED(hr))  // Handled by host
            {
                TraceTag((tagMetaRefresh, " CWindow::MetaRefreshTimerCallback() - Refresh handled by host"));
                goto Cleanup;
            }
        }
    }

    TraceTag((tagMetaRefresh, " CWindow::MetaRefreshTimerCallback() - Navigating to [%ws]",
              pszUrl));

    // Need to kill the timer *before* the call to FollowHyperlinkHelper, since this is synchronous and can end
    // up pumping messages (e.g., wininet's "connect or stay offline" dialog).
    ClearMetaRefresh();

    hr = THR(FollowHyperlinkHelper(pszUrl, 
                                   BINDF_RESYNCHRONIZE|BINDF_PRAGMA_NO_CACHE, 
                                   CDoc::FHL_METAREFRESH | 
                                   ( ( 0 == _uiMetaRefreshTimeout) ? CDoc::FHL_DONTUPDATETLOG : 0 ) ));

Cleanup:
    TraceTag((tagMetaRefresh, "-CWindow::MetaRefreshTimerCallback() - this:[0x%x] hr:[0x%x]",
              this, hr));

    MemFreeString(pszUrl);
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\meta.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1994
//
//  File:       meta.cxx
//
//  Contents:   META tag processing
//
//  Classes:    CDoc (partial)
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_HEDELEMS_HXX_
#define X_HEDELEMS_HXX_
#include "hedelems.hxx"
#endif

#ifndef X_SHELL_H_
#define X_SHELL_H_
#include "shell.h"
#endif

#ifndef X_UWININET_H_
#define X_UWININET_H_
#include "uwininet.h"
#endif

#ifdef WIN16
DeclareTag(tagShDocMetaRefresh, "ShDocVwSkel", "HTTP (and meta) Refresh");
#endif

DeclareTag(tagMeta, "Meta", "Trace meta tags");

MtDefine(CDoc_pvPics, CDoc, "CDoc::_pvPics buffer")

#ifdef WIN16
#define BSTRPAD _T("    ")
#else
#  ifdef UNIX
     // On Unix sizeof(WCHAR) == 4
#    define BSTRPAD _T(" ")
#  else
     // or can be 4 ansi spaces.
#    define BSTRPAD _T("  ")
#  endif // UNIX
#endif

BOOL ParseRefreshContent(LPCTSTR pchContent,
    UINT * puiDelay, LPTSTR pchUrlBuf, UINT cchUrlBuf)
{
    // We are parsing the following string:
    //
    //  [ws]* [0-9]+ { ws | ; }* url [ws]* = [ws]* { ' | " } [any]* { ' | " }
    //
    // Netscape insists that the string begins with a delay.  If not, it
    // ignores the entire directive.  There can be more than one URL mentioned,
    // and the last one wins.  An empty URL is treated the same as not having
    // a URL at all.  An empty URL which follows a non-empty URL resets
    // the previous URL.

    enum { PRC_START, PRC_DIG, PRC_DIG_WS_SEMI, PRC_DIG_DOT, PRC_SEMI_URL,
        PRC_SEMI_URL_EQL, PRC_SEMI_URL_EQL_ANY };
    #define ISSPACE(ch) (((ch) == 32) || ((unsigned)((ch) - 9)) <= 13 - 9)

    UINT uiState = PRC_START;
    UINT uiDelay = 0;
    LPCTSTR pch = pchContent;
    LPTSTR  pchUrl = NULL;
    UINT    cchUrl = 0;
    TCHAR   ch, chDel = 0;

    *pchUrlBuf = 0;

    do
    {
        ch = *pch;

        switch (uiState)
        {
            case PRC_START:
                if (ch >= '0' && ch <= '9')
                {
                    uiState = PRC_DIG;
                    uiDelay = ch - '0';
                }
                else if (ch == '.')
                    uiState = PRC_DIG_DOT;
                else if (!ISSPACE(ch))
                    goto done;
                break;

            case PRC_DIG:
                if (ch >= '0' && ch <= '9')
                    uiDelay = uiDelay * 10 + ch - '0';
                else if (ch == '.')
                    uiState = PRC_DIG_DOT;
                else if (ISSPACE(ch) || ch == ';')
                    uiState = PRC_DIG_WS_SEMI;
                else
                    goto done;
                break;

            case PRC_DIG_DOT:
                if (ISSPACE(ch) || ch == ';')
                    uiState = PRC_DIG_WS_SEMI;
                else if ((ch < '0' || ch > '9') && (ch != '.'))
                    goto done;
                break;

            case PRC_DIG_WS_SEMI:
                if (    (ch == 'u' || ch == 'U')
                    &&  (pch[1] == 'r' || pch[1] == 'R')
                    &&  (pch[2] == 'l' || pch[2] == 'L'))
                {
                    uiState = PRC_SEMI_URL;
                    pch += 2;
                }
                else if (!ISSPACE(ch) && ch != ';')
                    goto done;
                break;

            case PRC_SEMI_URL:
                if (ch == '=')
                {
                    uiState = PRC_SEMI_URL_EQL;
                    *pchUrlBuf = 0;
                }
                else if (ch == ';')
                    uiState = PRC_DIG_WS_SEMI;
                else if (!ISSPACE(ch))
                    goto done;
                break;

            case PRC_SEMI_URL_EQL:
                if (ch == ';')
                    uiState = PRC_DIG_WS_SEMI;
                else if (!ISSPACE(ch))
                {
                    uiState = PRC_SEMI_URL_EQL_ANY;

                    pchUrl = pchUrlBuf;
                    cchUrl = cchUrlBuf;

                    if (ch == '\''|| ch == '\"')
                        chDel = ch;
                    else
                    {
                        chDel = 0;
                        *pchUrl++ = ch;
                        cchUrl--;
                    }
                }
                break;
                        
            case PRC_SEMI_URL_EQL_ANY:
                if (    !ch
                    ||  ( chDel && ch == chDel)
                    ||  (!chDel && ch == ';'))
                {
                    *pchUrl = 0;
                    uiState = PRC_DIG_WS_SEMI;
                }
                else if (cchUrl > 1)
                {
                    *pchUrl++ = ch;
                    cchUrl--;
                }
                break;
        }

        ++pch;

    } while (ch);

done:

    *puiDelay = uiDelay;

    return(uiState >= PRC_DIG);
}

void
CMarkup::ProcessMetaPics( LPCTSTR pchContent, BOOL fInHeader )
{
    CDoc * pDoc = Doc();
    IOleCommandTarget * pct = GetPicsTarget();
    HRESULT hr;

    if (pct)
    {
        VARIANT var;
        TCHAR *pch;
        DWORD *plen;

        VariantInit(&var);
        var.vt = VT_BSTR;

        // We've got a command target, just send up the string.
        if (Format(FMT_OUT_ALLOC, &pch, 0, BSTRPAD _T("<0s>"), pchContent) == S_OK)
        {
            plen = (DWORD *)pch;
            var.bstrVal = (BSTR) ((LPBYTE) pch + sizeof(DWORD));
            *plen = _tcslen(var.bstrVal) * sizeof(TCHAR);
            pct->Exec(&CGID_ShellDocView, fInHeader ? SHDVID_PICSLABELFOUNDINHTTPHEADER : SHDVID_PICSLABELFOUND, 0, &var, NULL);
            delete (pch);
        }

    }
    else if (pDoc->_fStartup && pDoc->_pvPics != (void *)(LONG_PTR)(-1) && IsPrimaryMarkup())
    {
        // No command target yet.  Save the string until it becomes
        // available later.

        UINT cbOld = pDoc->_pvPics ? *(DWORD *)pDoc->_pvPics : sizeof(DWORD);
        UINT cbNew = (_tcslen(pchContent) + 1) * sizeof(TCHAR);

        hr = MemRealloc(Mt(CDoc_pvPics), &pDoc->_pvPics, cbOld + cbNew);

        if (hr == S_OK)
        {
            *(DWORD *)pDoc->_pvPics = cbOld + cbNew;
            memcpy((BYTE *)pDoc->_pvPics + cbOld, pchContent, cbNew);
        }
    }
}

void    
CMarkup::ProcessMetaPicsDone()
{
    IOleCommandTarget * pct = GetPicsTarget();

    if (pct)
    {
        pct->Exec(&CGID_ShellDocView, SHDVID_NOMOREPICSLABELS, 0, NULL, NULL);
        SetPicsTarget(NULL);
    }
}

void
CMarkup::ProcessHttpEquiv(LPCTSTR pchHttpEquiv, LPCTSTR pchContent)
{
    VARIANT var;
    TCHAR *pch;
    DWORD *plen;
    BOOL fRefresh;
    BOOL fExpireImmediate;
    const TCHAR * pchUrl;
    HRESULT hr;
    CDoc * pDoc = Doc();
    CDocument *pDocument = Document();

    TraceTag((tagMeta, "META http-equiv=\"%S\" content=\"%S\"", pchHttpEquiv, pchContent));

    // All http-equiv must be given to us before parsing is complete.  If
    // not, then we are probably parsing for paste and came across a <META>
    // tag.  Just ignore it.

    if (LoadStatus() >= LOADSTATUS_PARSE_DONE)
    {
        TraceTag((tagMeta, "META _LoadStatus >= LOADSTATUS_PARSE_DONE, we're outta here"));
        return;
    }

    VariantInit(&var);
    var.vt = VT_BSTR;

    // Special case for "PICS-Label" until it gets merged with normal
    // command target mechanism in the shell.

    if (IsPrimaryMarkup() && pDoc->_fStartup && StrCmpIC(pchHttpEquiv, _T("PICS-Label")) == 0)
    {
        ProcessMetaPics( pchContent );
    }

    fRefresh = StrCmpIC(pchHttpEquiv, _T("Refresh")) == 0;

    if (    pDoc->_pClientSite
        &&  (   !(pDoc->_dwLoadf & DLCTL_NO_CLIENTPULL)
            ||  !fRefresh))
    {
        TCHAR   ach[pdlUrlLen];
        UINT    uiDelay;
        TCHAR   cBuf[pdlUrlLen] = {0};
        TCHAR * pchUrl = cBuf;

        // If this is a Refresh header, we have to get the URL and expand
        // it because it could be relative.

        if (fRefresh)
        {
            if (ParseRefreshContent(pchContent, &uiDelay, ach, ARRAY_SIZE(ach)))
            {
                if (ach[0])
                {
                    // Netscape ignores any BASE tags which come before the <META>
                    // when expanding the relative URL.  So do we.

                    hr = THR(CMarkup::ExpandUrl(this, ach, ARRAY_SIZE(cBuf),
                                                pchUrl, EXPANDIGNOREBASETAGS));
                }

                if (HasWindowPending())
                {
                    GetWindowPending()->Window()->ProcessMetaRefresh(pchUrl, uiDelay);
                }
            }
        }
        else if (Format(FMT_OUT_ALLOC, &pch, 0, BSTRPAD _T("<0s>:<1s>"), pchHttpEquiv, pchContent) == S_OK)
        {
            // Send to the command target of the client site.  Note that
            // the string needs to be in the format http-equiv:content.

            plen = (DWORD *)pch;
            var.bstrVal = (BSTR) ((LPBYTE) pch + sizeof(DWORD));
            *plen = _tcslen(var.bstrVal) * sizeof(TCHAR);

            Assert(pDoc->_pClientSite);
        
            CTExec(pDoc->_pClientSite, NULL, OLECMDID_HTTPEQUIV, 0, &var, NULL);
            TraceTag((tagMeta, "META Invoking OLECMDID_HTTPEQUIV"));

            MemFree(pch);

            // Save the page transition info on the document to be used later
            // If this is not a page transition at all the call will do nothing
            if (HasWindowPending())
            {
                CDocument * pDocument = GetWindowPending()->Document();
                if(pDocument)
                    IGNORE_HR(pDocument->SetUpPageTransitionInfo(pchHttpEquiv, pchContent));
            }
        }
    }

    fExpireImmediate = FALSE;

    // Special case for "Pragma: no-cache" http-equiv.
    
    pchUrl = GetUrl(this);

    if (    pchUrl
        &&  !StrCmpIC(pchHttpEquiv, _T("Pragma"))
        &&  !StrCmpIC(pchContent, _T("no-cache")))
    {
        if (GetUrlScheme(pchUrl) == URL_SCHEME_HTTPS)
            DeleteUrlCacheEntry(pchUrl);
        else
            fExpireImmediate = TRUE;
    }
    
    // Special case for "ImageToolbar" http-equiv
    if (!StrCmpIC(pchHttpEquiv, _T("ImageToolbar")) &&
        (!StrCmpIC(pchContent, _T("no")) ||
         !StrCmpIC(pchContent, _T("false"))
         ) )
    {
        if (pDocument)
        {
            pDocument->SetGalleryMeta(FALSE);
        }
        else
        {
            // Get a document pointer from the pending window
            CDocument * pDocument = GetWindowPending()->Document();
            if(pDocument)
            {
                pDocument->SetGalleryMeta(FALSE);
            }
        }
    }

    // Special case for "Expires" http-equiv.
    {
        CMarkupTransNavContext * ptnc = NULL;

        if (    fExpireImmediate
            || (  !(    HasTransNavContext() 
                    &&  (ptnc = GetTransNavContext())->_fGotHttpExpires)
                &&  pchUrl
                &&  !StrCmpIC(pchHttpEquiv, _T("Expires")) ) )
        {
            SYSTEMTIME stime;
            INTERNET_CACHE_ENTRY_INFO icei;

            if (fExpireImmediate || !InternetTimeToSystemTime(pchContent, &stime, 0))
            {
                // If the conversion failed, assume the document expires now.
                GetSystemTime(&stime);
            }

            SystemTimeToFileTime(&stime, &icei.ExpireTime);
            SetUrlCacheEntryInfo(pchUrl, &icei, CACHE_ENTRY_EXPTIME_FC);

            // We only care about the first one if there are many.

            if(!ptnc)
                ptnc = EnsureTransNavContext();
            
            ptnc->_fGotHttpExpires = TRUE;
        }
    }
}

void
CDoc::ProcessMetaName(LPCTSTR pchName, LPCTSTR pchContent)
{
    if (!StrCmpIC(pchName, _T("GENERATOR")))
    {
        // NOTE: This check should stop at the first zero of the major version number
        //       since HP98 generates documents with a number of different major/minor
        //       version numbers. (brendand)
        if (!StrCmpNIC(pchContent, _T("MMEditor Version 00.00.0"), 24) ||
            !StrCmpIC(pchContent, _T("IE4 Size and Overflow")) )    // For public consumption.
        {
            _fInHomePublisherDoc = TRUE;
        }
    }
}

HRESULT
CDoc::SetPicsCommandTarget(IOleCommandTarget *pctPics)
{
    HRESULT hr = S_OK;
    CMarkup * pMarkupPrimary = PrimaryMarkup();

    if (!pMarkupPrimary)
        goto Cleanup;

    hr = THR(pMarkupPrimary->SetPicsTarget(pctPics));
    if (hr)
        goto Cleanup;

    if (pctPics == NULL)
    {
        // Setting _pvPics to this value tells ProcessHttpEquiv to ignore
        // any further PICS-Label directives and not attempt to queue them
        // up in _pvPics for later.

        if (_pvPics == NULL)
        {
            _pvPics = (void *)(LONG_PTR)(-1);
        }

        return(S_OK);
    }

    if (_pvPics && _pvPics != (void *)(LONG_PTR)(-1))
    {
        VARIANT var;
        BYTE *  pb    = (BYTE *)_pvPics + sizeof(DWORD);
        BYTE *  pbEnd = pb + *(DWORD *)_pvPics;
        UINT    cb;

        VariantInit(&var);
        var.vt = VT_BSTR;

        while (pb < pbEnd)
        {
            cb = (_tcslen((TCHAR *)pb) + 1) * sizeof(TCHAR);
            *(DWORD *)(pb - sizeof(DWORD)) = cb;
            var.bstrVal = (BSTR)pb;
            pctPics->Exec(&CGID_ShellDocView, SHDVID_PICSLABELFOUND,
                0, &var, NULL);
            pb += cb;
        }

        MemFree(_pvPics);
        _pvPics = NULL;
    }

    if (LoadStatus() >= LOADSTATUS_PARSE_DONE)
    {
        pMarkupPrimary->ProcessMetaPicsDone();
    }

Cleanup:
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\notify.cxx ===
//+----------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994, 1995, 1996, 1997, 1998
//
//  File:       notify.cxx
//
//  Contents:   Notification base classes
//
//  Classes:    CNotification, et. al.
//
//-----------------------------------------------------------------------------


#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif


MtDefine(CNotification, Tree, "CNotification")

#if DBG==1
      DWORD CNotification::s_snNext = 0;
#endif

const DWORD CNotification::s_aryFlags[NTYPE_MAX] =
{
#define  _NOTIFYTYPE_TABLE_
#include "notifytype.h"
};

//-----------------------------------------------------------------------------
//
//  Member:     SetElement
//
//  Synopsis:   Change the CElement associated with a notification and
//              optionally update the associated range
//
//  Arguments:  pElement   - Pointer to new affected CElement
//              fKeepRange - Flag to keep/update range
//
//-----------------------------------------------------------------------------
void
CNotification::SetElement(
    CElement *  pElement,
    BOOL        fKeepRange)
{
    Assert(fKeepRange || pElement || IsFlagSet(NFLAGS_TREECHANGE));

    _pElement = pElement;

    if (_pElement)
    {
        //
        //  Set the associated range
        //

        if (!fKeepRange)
        {
            if (!IsFlagSet(NFLAGS_LAZYRANGE))
            {
                EnsureRange();
            }
            else
            {
                SetTextRange(-1, -1);
            }
        }
        
        //
        //  Determine the starting node in the tree
        //  (If not already set)
        //

        CTreeNode * pNode = _pElement->GetFirstBranch();

        if (_pNode && _pNode->Element() != _pElement)
        {
            if (!pNode || pNode->IsLastBranch())
            {
                _pNode = pNode;
            }
            else // overlapping involved
            {
                // Update _pNode to the appropriate ancestor
                _pNode = _pNode->SearchBranchToRootForScope(_pElement);
                Assert(_pNode);
            }
        }
        if (!_pNode)
        {
            _pNode = pNode;
        }

        Assert(!_pNode || SameScope(_pNode, _pElement));

        //
        //  Ensure the handler is cleared
        //  (Changing the pElement changes the notification and implies that
        //   it is no longer "handled")
        //

        _pHandler = NULL;
    }
}

//-----------------------------------------------------------------------------
//
//  Member:     EnsureRange
//
//  Synopsis:   Update the associated range with the given pElement
//
//-----------------------------------------------------------------------------

void
CNotification::EnsureRange()
{
    BOOL    fInTree = !!(_pElement->GetFirstBranch());
    
    if (fInTree)
    {
        _pElement->GetRange(&_cp, &_cch);
    }

    if (    !fInTree
        ||  _cp < 0)
    {
        _cp  = -1;
        _cch = -1;
    }

    ClearFlag(NFLAGS_LAZYRANGE);
}


//+----------------------------------------------------------------------------
//
//  Member:     LayoutFlags
//
//  Synopsis:   Convert internal NFLAGS_xxxx to external LAYOUT_xxxx flags
//
//-----------------------------------------------------------------------------
DWORD
CNotification::LayoutFlags() const
{
    DWORD   grfLayout = 0;

    if (_grfFlags & NFLAGS_FORCE)
        grfLayout |= LAYOUT_FORCE;

    return grfLayout;
}


#if DBG==1
//+----------------------------------------------------------------------------
//
//  Member:     Name
//
//  Synopsis:   Returns a static string describing the notification
//
//-----------------------------------------------------------------------------

LPCTSTR
CNotification::Name() const
{
    LPCTSTR pch;

    switch (_ntype)
    {
    #define  _NOTIFYTYPE_NAMES_
    #include "notifytype.h"

        default:
            AssertSz(FALSE, "Unknown CNotification type");
            pch = _T("???");
            break;
    }

    return pch;
}
#endif


//+----------------------------------------------------------------------------
//
//  Member:     Accumulate
//
//  Synopsis:   Accumulate the dirty tree region described by a CNotification
//
//  Arguments:  pnf - Notification documenting the change
//
//-----------------------------------------------------------------------------
void
CDirtyTreeRegion::Accumulate(
    CNotification * pnf)
{
    Assert(pnf);
    Assert(pnf->IsTreeChange());

    AssertSz(FALSE, "CDirtyTreeRegion::Accumulate is not written");
}


//+----------------------------------------------------------------------------
//
//  Member:     Adjust
//
//  Synopsis:   Adjust the recorded dirty region to take into account
//              nested changes
//
//  Arguments:  pnf - Notification documenting the change
//
//-----------------------------------------------------------------------------
void
CDirtyTreeRegion::Adjust(
    CNotification * pnf)
{
    Assert(pnf);
    Assert(pnf->IsTreeChange());

    AssertSz(FALSE, "CDirtyTreeRegion::Adjust is not written");

    if (IsDirty())
    {
    }
}


//+----------------------------------------------------------------------------
//
//  Member:     Accumulate
//
//  Synopsis:   Accumulate the dirty text region described by a CNotification
//
//  Arguments:  pnf - Notification documenting the change
//
//-----------------------------------------------------------------------------
void
CDirtyTextRegion::Accumulate(
    CNotification * pnf,
    long            cpFirst,
    long            cpLast,
    BOOL            fInnerRange)
{
    Assert(pnf);
    Assert(     pnf->IsTextChange()
            ||  pnf->IsLayoutChange());
    Assert(cpFirst >= 0);

    long    cp  = pnf->Cp(cpFirst) - cpFirst;
    long    cch = pnf->Cch();

    //
    //  Adjust the range to exclude the WCH_NODE chars
    //  (The cp is correctly bounded using the passed cpFirst,
    //   only the cch needs correction at this point)
    //

    if(fInnerRange)
    {
        cch -= 2;
    }

    switch (pnf->Type())
    {
    case NTYPE_CHARS_ADDED:
        TextAdded(cp, cch);
        break;

    case NTYPE_CHARS_DELETED:
        TextDeleted(cp, cch);
        break;

    default:
        TextChanged(cp, cch);
        break;
    }

    _cchNew = min(_cchNew, (cpLast - (_cp + cpFirst)));

#if DBG==1
    if (_cp != -1)
    {
        Assert(_cp >= 0);
        Assert(_cchNew >= 0);
        Assert(_cchOld >= 0);
    }
#endif
}


//+----------------------------------------------------------------------------
//
//  Member:     Adjust
//
//  Synopsis:   Adjust the recorded dirty region to take into account
//              nested changes
//
//  Arguments:  pnf - Notification documenting the change
//
//-----------------------------------------------------------------------------
void
CDirtyTextRegion::Adjust(
    CNotification * pnf,
    long            cpFirst,
    long            cpLast)
{
    if (IsDirty())
    {
        long cp         = pnf->Cp(cpFirst) - cpFirst;
        long cchChanged = pnf->CchChanged(cpLast);

        Assert(pnf->IsTextChange());

        if (cp < _cp)
        {
            _cp += cchChanged;
        }
        else if (cp < _cp + _cchNew)
        {
            _cchNew += cchChanged;
        }
    }
}


//-----------------------------------------------------------------------------
//
//  Member:     TextAdded
//
//  Synopsis:   Accumulate information about a text addition
//
//  Arguments:  pnf - Pointer to CNotification describing the change
//
//-----------------------------------------------------------------------------
void
CDirtyTextRegion::TextAdded(
    long cp,
    long cch)
{
    if (_cp == -1)
    {
        _cp     = cp;
        _cchNew = cch;
    }
    else
    {
        if (cp < _cp)
        {
            long dch = _cp - cp;
            _cp      = cp;
            _cchNew += dch + cch;
            _cchOld += dch;
        }
        else if (cp > _cp + _cchNew)
        {
            long dch = cp - (_cp + _cchNew);
            _cchNew += dch + cch;
            _cchOld += dch;
        }
        else
        {
            _cchNew += cch;
        }
    }
}


//-----------------------------------------------------------------------------
//
//  Member:     TextDeleted
//
//  Synopsis:   Accumulate information about a text deletion
//
//  Arguments:  pnf - Pointer to CNotification describing the change
//
//-----------------------------------------------------------------------------
void
CDirtyTextRegion::TextDeleted(
    long cp,
    long cch)
{
    if (_cp == -1)
    {
        _cp     = cp;
        _cchOld = cch;
    }
    else
    {
        long dch = _cchOld - _cchNew;

        if (cp < _cp)
        {
            _cchNew = max((_cp + _cchNew) - (cp + cch), 0L);
            _cp     = cp;
        }
        else if (cp < _cp + _cchNew)
        {
            _cchNew = cp - _cp + max((_cp + _cchNew) - (cp + cch), 0L);
        }
        else
        {
            _cchNew = cp - _cp;
        }

        _cchOld = _cchNew + dch + cch;
    }
}


//-----------------------------------------------------------------------------
//
//  Member:     TextChanged
//
//  Synopsis:   Accumulate information about a text change
//
//  Arguments:  pnf - Pointer to CNotification describing the change
//
//-----------------------------------------------------------------------------
void
CDirtyTextRegion::TextChanged(
    long cp,
    long cch)
{
    if (_cp == -1)
    {
        _cp     = cp;
        _cchOld = cch;
        _cchNew = cch;
    }
    else
    {
        long dch = _cchOld - _cchNew;

        if (cp < _cp)
        {
            _cchNew = max(_cp - cp + _cchNew, cch);
            _cp     = cp;
        }
        else
        {
            _cchNew = max(cp - _cp + cch, _cchNew);
        }

        _cchOld = _cchNew + dch;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\markupundo.cxx ===
//+---------------------------------------------------------------------
//
//   File:      markupundo.cxx
//
//  Contents:   Undo of markup changes
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_MARKUPUNDO_HXX_
#define X_MARKUPUNDO_HXX_
#include "markupundo.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X__TEXT_H_
#define X__TEXT_H_
#include "_text.h"
#endif

#ifndef X_TPOINTER_HXX_
#define X_TPOINTER_HXX_
#include "tpointer.hxx"
#endif

#ifndef _X_SEGLIST_HXX_
#define _X_SEGLIST_HXX_
#include "seglist.hxx"
#endif

MtDefine(CInsertElementUndoUnit, Undo, "CInsertElementUndoUnit")
MtDefine(CRemoveElementUndoUnit, Undo, "CRemoveElementUndoUnit")
MtDefine(CInsertTextUndoUnit, Undo, "CInsertTextUndoUnit")
MtDefine(CRemoveTextUndoUnit, Undo, "CRemoveTextUndoUnit")
MtDefine(CRemoveTextUndoUnit_pchText, CRemoveTextUndoUnit, "CRemoveTextUndoUnit::pchText")
MtDefine(CInsertSpliceUndoUnit, Undo, "CInsertSpliceUndoUnit")
MtDefine(CRemoveSpliceUndoUnit, Undo, "CRemoveSpliceUndoUnit")
MtDefine(CSelectionUndoUnit, Undo, "CSelectionUndoUnit")
MtDefine(CDeferredSelectionUndoUnit, Undo, "CDeferredSelectionUndoUnit")

DeclareTag(tagUndoSel, "Undo", "Selection Undo ");

//---------------------------------------------------------------------------
//
// CUndoHelper
//
//---------------------------------------------------------------------------

BOOL 
CUndoHelper::UndoDisabled()
{
    return FALSE;
}

HRESULT 
CUndoHelper::CreateAndSubmit( BOOL fDirtyChange /*=TRUE*/)
{
    HRESULT         hr = S_OK;
    IOleUndoUnit *  pUU = NULL;

    if( !UndoDisabled() && _pDoc->QueryCreateUndo( TRUE, fDirtyChange ) )
    {
        pUU = CreateUnit();
        if( !pUU )
        {
            if( fDirtyChange )
                _pDoc->FlushUndoData();

            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = THR( _pDoc->UndoManager()->Add( pUU ) ) ;
        if (hr)
            goto Cleanup;
    }

Cleanup:
    if( pUU )
        pUU->Release();

    RRETURN( hr );
}

BOOL
CUndoHelper::AcceptingUndo()
{
    // Query if we create undo but don't flush the stack
    return !UndoDisabled() && _pDoc->QueryCreateUndo( TRUE, FALSE );
}

//---------------------------------------------------------------------------
//
// CInsertElementUndo
//
//---------------------------------------------------------------------------

void    
CInsertElementUndo::SetData( CElement* pElement )
{ 
    Assert( !_pElement );
    CElement::SetPtr( &_pElement, pElement ); 
}

IOleUndoUnit * 
CInsertElementUndo::CreateUnit()
{
    CInsertElementUndoUnit * pUU;

    Assert( _pElement );

    TraceTag((tagUndo, "CInsertElementUndo::CreateUnit"));

    pUU = new CInsertElementUndoUnit( _pMarkup->Doc() );

    if (pUU)
    {
        pUU->SetData( _pElement, _dwFlags );
    }

    return pUU;
}

//---------------------------------------------------------------------------
//
// CInsertElementUndoUnit
//
//---------------------------------------------------------------------------

CInsertElementUndoUnit::CInsertElementUndoUnit(CDoc * pDoc)
    : CUndoUnitBase( pDoc, IDS_UNDOGENERICTEXT )
{
}

CInsertElementUndoUnit::~CInsertElementUndoUnit()
{ 
    CElement::ReleasePtr( _pElement ); 
}

void    
CInsertElementUndoUnit::SetData( CElement * pElement, DWORD dwFlags )
{ 
    Assert( !_pElement );
    CElement::SetPtr( &_pElement, pElement );
    _dwFlags = dwFlags;
}

HRESULT
CInsertElementUndoUnit::PrivateDo(IOleUndoManager *pUndoManager)
{
    HRESULT hr = S_OK;

    Assert( _pElement );
    Assert( _pElement->IsInMarkup() );

    hr = THR( _pElement->Doc()->RemoveElement( _pElement, _dwFlags ) );

    RRETURN( hr );
}

//---------------------------------------------------------------------------
//
// CRemoveElementUndo
//
//---------------------------------------------------------------------------

CRemoveElementUndo::CRemoveElementUndo( CMarkup * pMarkup, CElement * pElementRemove, DWORD dwFlags ) 
    : CMarkupUndoBase( pMarkup->Doc(), pMarkup, dwFlags ), _pElement( NULL )
{
    _fAcceptingUndo = CMarkupUndoBase::AcceptingUndo();

    if( _fAcceptingUndo )
    {
        CElement::SetPtr( &_pElement, pElementRemove );
    }
}

void
CRemoveElementUndo::SetData(
    long cpBegin, 
    long cpEnd )
{
    _cpBegin = cpBegin;
    _cpEnd = cpEnd;
}

IOleUndoUnit * 
CRemoveElementUndo::CreateUnit()
{
    CRemoveElementUndoUnit * pUU;

    Assert( _fAcceptingUndo );
    Assert( _pElement );

    TraceTag((tagUndo, "CRemoveElementUndo::CreateUnit"));

    pUU = new CRemoveElementUndoUnit( _pMarkup->Doc() );

    if (pUU)
    {
        pUU->SetData( _pMarkup, _pElement, _cpBegin, _cpEnd, _dwFlags );
    }

    return pUU;
}

//---------------------------------------------------------------------------
//
// CRemoveElementUndoUnit
//
//---------------------------------------------------------------------------
CRemoveElementUndoUnit::CRemoveElementUndoUnit(CDoc * pDoc)
    : CUndoUnitBase( pDoc, IDS_UNDOGENERICTEXT ) 
{
}


CRemoveElementUndoUnit::~CRemoveElementUndoUnit()               
{ 
    CMarkup::ReleasePtr( _pMarkup ); 
    CElement::ReleasePtr( _pElement ); 
}

void    
CRemoveElementUndoUnit::SetData( 
    CMarkup * pMarkup, 
    CElement* pElement, 
    long cpBegin, 
    long cpEnd,
    DWORD dwFlags )
{
    Assert( !_pMarkup && !_pElement );

    CMarkup::SetPtr( &_pMarkup, pMarkup );
    CElement::SetPtr( &_pElement, pElement );
    _cpBegin = cpBegin;
    _cpEnd = cpEnd;
    _dwFlags = dwFlags;
}

HRESULT
CRemoveElementUndoUnit::PrivateDo(IOleUndoManager *pUndoManager)
{
    HRESULT     hr = S_OK;
    CDoc *      pDoc = _pMarkup->Doc();
    CMarkupPointer mpBegin(pDoc), mpEnd(pDoc);

    Assert( _pElement );

    hr = THR( mpBegin.MoveToCp( _cpBegin, _pMarkup ) );
    if (hr)
        goto Cleanup;

    hr = THR( mpEnd.MoveToCp( _cpEnd, _pMarkup ) );
    if (hr)
        goto Cleanup;

    // The element may have gotten ensured into a markup while it was in the
    // undo stack.  There is no undo unit to pull it out of there, so we have
    // to do it now.
    if( _pElement->IsInMarkup() )
    {
        Assert( _pElement->GetMarkupPtr()->_fEnsuredMarkupDbg );

        hr = THR( _pElement->GetMarkupPtr()->RemoveElementInternal( _pElement ) );
        if( hr )
            goto Cleanup;
    }

    Assert( ! _pElement->IsInMarkup() );

    hr = THR( pDoc->InsertElement( _pElement, & mpBegin, & mpEnd, _dwFlags ) );

Cleanup:
    RRETURN( hr );
}

//---------------------------------------------------------------------------
//
// CInsertSpliceUndo
//
//---------------------------------------------------------------------------
IOleUndoUnit * 
CInsertSpliceUndo::CreateUnit()
{
    CInsertSpliceUndoUnit * pUU = NULL;

    Assert( _cpBegin >= 0 );

    TraceTag((tagUndo, "CInsertSpliceUndo::CreateUnit"));

    pUU = new CInsertSpliceUndoUnit( _pMarkup->Doc() );

    if (pUU)
    {
        pUU->SetData( _pMarkup, _cpBegin, _cpEnd, _dwFlags );
    }

    return pUU;
}

//---------------------------------------------------------------------------
//
// CInsertSpliceUndoUnit
//
//---------------------------------------------------------------------------
CInsertSpliceUndoUnit::CInsertSpliceUndoUnit(CDoc * pDoc)
    : CUndoUnitBase( pDoc, IDS_UNDOGENERICTEXT ) 
{
    _cpBegin = -1;
}

CInsertSpliceUndoUnit::~CInsertSpliceUndoUnit()
{
    CMarkup::ReleasePtr( _pMarkup );
}

void
CInsertSpliceUndoUnit::SetData(
    CMarkup * pMarkup, 
    long cpBegin, 
    long cpEnd,
    DWORD dwFlags )
{
    Assert( !_pMarkup );

    CMarkup::SetPtr( &_pMarkup, pMarkup );
    _cpBegin = cpBegin;
    _cpEnd = cpEnd;
    _dwFlags = dwFlags;
}

HRESULT
CInsertSpliceUndoUnit::PrivateDo(IOleUndoManager *pUndoManager)
{
    HRESULT         hr = S_OK;
    CDoc *          pDoc = _pMarkup->Doc();
    CMarkupPointer  mpBegin(pDoc), mpEnd(pDoc);

    Assert( _cpBegin >= 0 );

    hr = THR( mpBegin.MoveToCp( _cpBegin, _pMarkup ) );
    
    if (hr)
        goto Cleanup;

    hr = THR( mpEnd.MoveToCp( _cpEnd, _pMarkup ) );
    
    if (hr)
        goto Cleanup;

    hr = THR( pDoc->Remove( & mpBegin, & mpEnd, _dwFlags ) );

Cleanup:
    
    RRETURN( hr );
}

//---------------------------------------------------------------------------
//
// CRemoveSpliceUndo
//
//---------------------------------------------------------------------------
CRemoveSpliceUndo::CRemoveSpliceUndo( CDoc * pDoc ) 
    : CMarkupUndoBase( pDoc, NULL, NULL )
{
    _paryRegion = NULL;
    _pchRemoved = NULL;
    _cpBegin = -1;
}

void 
CRemoveSpliceUndo::Init( CMarkup * pMarkup, DWORD dwFlags )
{
    CMarkupUndoBase::Init( pMarkup, dwFlags );

    _fAcceptingUndo = CMarkupUndoBase::AcceptingUndo();
}

void
CRemoveSpliceUndo::SetText( long cpBegin, long cchRemoved, TCHAR * pchRemoved )
{
    Assert( AcceptingUndo() );

    _cpBegin    = cpBegin;
    _cchRemoved = cchRemoved;
    _pchRemoved = pchRemoved;
}


IOleUndoUnit * 
CRemoveSpliceUndo::CreateUnit()
{
    CRemoveSpliceUndoUnit * pUU = NULL;

    if( _paryRegion && _pchRemoved )
    {
        Assert( _cpBegin >= 0 );

        TraceTag((tagUndo, "CRemoveSpliceUndo::CreateUnit"));

        pUU = new CRemoveSpliceUndoUnit( _pMarkup->Doc() );

        if (pUU)
        {
            // The undo unit owns the string 
            // and list after this

            pUU->SetData( _pMarkup, 
                          _paryRegion,
                          _cchRemoved, 
                          _pchRemoved, 
                          _cpBegin,
                          _dwFlags );
            
            _paryRegion = NULL;
            _pchRemoved = NULL;
        }
    }

    return pUU;
}

BOOL    
CRemoveSpliceUndo::AcceptingUndo()
{
    return _fAcceptingUndo;
}


//---------------------------------------------------------------------------
//
// CRemoveSpliceUndoUnit
//
//---------------------------------------------------------------------------

CRemoveSpliceUndoUnit::CRemoveSpliceUndoUnit(CDoc * pDoc)
            : CUndoUnitBase( pDoc, IDS_UNDOGENERICTEXT ) 
{
}

CRemoveSpliceUndoUnit::~CRemoveSpliceUndoUnit()
{
    CMarkup::ReleasePtr( _pMarkup );
    delete _paryRegion;
    MemFree(_pchRemoved);
}

void    
CRemoveSpliceUndoUnit::SetData( CMarkup * pMarkup, CSpliceRecordList * paryRegion, 
                                long cchRemoved, TCHAR * pchRemoved, 
                                long cpBegin, DWORD dwFlags )
{
    CMarkup::SetPtr( &_pMarkup, pMarkup );
    _paryRegion = paryRegion;
    _cchRemoved = cchRemoved;
    _pchRemoved = pchRemoved;
    _cpBegin = cpBegin;
    _dwFlags = dwFlags;
}

HRESULT
CRemoveSpliceUndoUnit::PrivateDo(IOleUndoManager *pUndoManager)
{
    HRESULT hr = S_OK;
    CDoc *  pDoc = _pMarkup->Doc();

    Assert( _cpBegin >= 0 );

    CMarkupPointer mpBegin(pDoc);

    hr = THR( mpBegin.MoveToCp( _cpBegin, _pMarkup ) );
    if (hr)
        goto Cleanup;

    hr = THR( _pMarkup->UndoRemoveSplice( 
                &mpBegin, _paryRegion, _cchRemoved, _pchRemoved, _dwFlags ) );
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\optnobj.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:       optnobj.cxx
//
//  Contents:   Contains the implementation of the User Option settings for
//              CDoc, including OM access.
//
//----------------------------------------------------------------------------

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_DOCGLBS_HXX_
#define X_DOCGLBS_HXX_
#include "docglbs.hxx"
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif

#ifndef X_FONTLINK_HXX_
#define X_FONTLINK_HXX_
#include "fontlink.hxx"
#endif

#ifndef X_MSHTMHST_H_
#define X_MSHTMHST_H_
#include <mshtmhst.h>
#endif

#ifdef WIN16
#define MIN_JAVA_MEMORY 8192L+1L        // must be over 8Meg to run Java
extern DWORD WINAPI DetectPhysicalMem();

#ifndef X_INETREG_H_
#define X_INETREG_H_
#include <inetreg.h>
#endif

#endif

#ifdef UNIX
// Unix uses this global variable to memorize users selected Font size View->Font
// and passes this to each new CDoc, if it's been changed.
int g_SelectedFontSize = -1;
#endif

MtDefine(CodePageSettings, CDoc, "CDoc::_pCodePageSettings")
MtDefine(CDocReadContextMenuExtFromRegistry_pCME, Locals, "CDoc::ReadContextMenuExtFromRegistry pCME")

BOOL IsInIEBrowser(CDoc * pDoc);

//+---------------------------------------------------------------------------
//
//  Member:     OPTIONSETTINGS::Init, public
//
//  Synopsis:   Initializes data that should only be initialized once.
//
//  Arguments:  [psz] -- String to initialize achKeyPath to. Cannot be NULL.
//
//----------------------------------------------------------------------------

void
OPTIONSETTINGS::Init(
    TCHAR *psz,
    BOOL fUseCodePageBasedFontLinkingArg )
{
    _tcscpy(achKeyPath, psz);
    fSettingsRead = FALSE;
    fUseCodePageBasedFontLinking = !!fUseCodePageBasedFontLinkingArg;
    sBaselineFontDefault = BASELINEFONTDEFAULT;

    InvalidateScriptBasedFontInfo();
}

//+---------------------------------------------------------------------------
//
//  Member:     OPTIONSETTINGS::InvalidateScriptBasedFontInfo, public
//
//  Synopsis:   Invalidates script based font info.
//
//----------------------------------------------------------------------------

void
OPTIONSETTINGS::InvalidateScriptBasedFontInfo()
{
    memset(alatmProporitionalFonts,   -1, sizeof(alatmProporitionalFonts));
    memset(alatmFixedPitchFonts,      -1, sizeof(alatmFixedPitchFonts));
    memset(alatmProporitionalAtFonts, -1, sizeof(alatmProporitionalAtFonts));
    memset(alatmFixedPitchAtFonts,    -1, sizeof(alatmFixedPitchAtFonts));
}

//+---------------------------------------------------------------------------
//
//  Member:     CODEPAGESETTINGS::SetDefaults, public
//
//  Synopsis:   Sets the default values for the CODEPAGESETTINGS struct.
//
//----------------------------------------------------------------------------

void
CODEPAGESETTINGS::SetDefaults(
    UINT  uiFamilyCodePageDefault,
    SHORT sOptionSettingsBaselineFontDefault)
{
    fSettingsRead = FALSE;
    bCharSet = DEFAULT_CHARSET;
    sBaselineFontDefault = sOptionSettingsBaselineFontDefault;
    uiFamilyCodePage = uiFamilyCodePageDefault;
    latmFixedFontFace = -1;
    latmPropFontFace  = -1;
}


//+---------------------------------------------------------------------------
//
//  Member:     OPTIONSETTINGS::SetDefaults, public
//
//  Synopsis:   Sets the default values of the struct
//
//----------------------------------------------------------------------------

void
OPTIONSETTINGS::SetDefaults( )
{
    colorBack            = OLECOLOR_FROM_SYSCOLOR(COLOR_WINDOW);
    colorText            = OLECOLOR_FROM_SYSCOLOR(COLOR_WINDOWTEXT);
    colorAnchor          = RGB(0, 0, 0xFF);
    colorAnchorVisited   = RGB(0x80, 0, 0x80);
    colorAnchorHovered   = RGB(0, 0, 0x80);

    fPageTransitions     = TRUE;
    fUseDlgColors        = TRUE;
    fExpandAltText       = FALSE;
    fShowImages          = TRUE;
#ifndef NO_AVI
    fShowVideos          = TRUE;
#endif // ndef NO_AVI
    fPlaySounds          = TRUE;
    fPlayAnimations      = TRUE;
    fPrintBackground     = FALSE;
    fUseStylesheets      = TRUE;
    fSmoothScrolling     = TRUE;
    fShowImagePlaceholder = FALSE;
    fShowFriendlyUrl     = FALSE;
    fSmartDithering      = TRUE;
    fAlwaysUseMyColors   = FALSE;
    fAlwaysUseMyFontSize = FALSE;
    fAlwaysUseMyFontFace = FALSE;
    fUseMyStylesheet     = FALSE;
    fUseHoverColor       = FALSE;
    fDisableScriptDebugger = TRUE;
    fMoveSystemCaret     = FALSE;
    fHaveAcceptLanguage  = FALSE;
    fCpAutoDetect        = FALSE;
    fAllowCutCopyPaste   = FALSE;
    fDisableCachingOfSSLPages  = FALSE;
    fHKSCSSupport        = FALSE;
    fForceOffscreen      = FALSE;
    fEnableImageResize   = TRUE;
    fUsePlugin           = FALSE;
    fUseThemes           = TRUE;
    fUseHiRes            = FALSE;
    fRouteEditorOnce     = FALSE;
    fLocalMachineCheck   = TRUE;
    fCleanupHTCs         = FALSE;

    nAnchorUnderline     = ANCHORUNDERLINE_YES;

    nStrictCSSInterpretation = STRICT_CSS_DOCTYPE;

    // HACKHACK (johnv) For japanese, default to Autodetect.  This hack
    // can be removed once setup does its job properly.
    codepageDefault      = (g_cpDefault == 932) ? CP_AUTO_JP : g_cpDefault;

    dwMaxStatements      = CWindow::RUNAWAY_SCRIPT_STATEMENTCOUNT;

    dwRtfConverterf      = RTFCONVF_ENABLED;    // enabled, but not for dbcs

    dwMiscFlags          = 0;

    dwNoChangingWallpaper = 0;

    // Free the context menu extension array
    {
        CONTEXTMENUEXT **   ppCME;
        int                 n;

        for (ppCME = aryContextMenuExts,
             n = aryContextMenuExts.Size();
             n;
             n--, ppCME++)
        {
            delete *ppCME;
        }

        aryContextMenuExts.DeleteAll();
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::EnsureOptionSettings, public
//
//  Synopsis:   Ensures that this CDoc is pointing to a valid OPTIONSETTINGS
//              object. Should only be called by ReadOptionSettingsFromRegistry.
//
//  Arguments:  (none)
//
//----------------------------------------------------------------------------

HRESULT
CDoc::EnsureOptionSettings()
{
    HRESULT             hr = S_OK;
    int                 c;
    OPTIONSETTINGS   *  pOS;
    OPTIONSETTINGS   ** ppOS;
    TCHAR             * pstr=NULL;
    BOOL                fUseCodePageBasedFontLinking;

    static TCHAR pszDefaultKey[] = _T("Software\\Microsoft\\Internet Explorer");
    static TCHAR pszOE4Key[] = _T("Software\\Microsoft\\Outlook Express\\Trident");

    if (_pOptionSettings)
        return S_OK;

    if (_pHostUIHandler)
    {
        _pHostUIHandler->GetOptionKeyPath(&pstr, 0);
    }

    if (!pstr)
    {
        pstr = pszDefaultKey;
    }

    _fOE4 = (0 == StrCmpC(pstr, pszOE4Key));

#ifndef UNIX
    // On Unix, we create new option setting for each new CDoc, because all IEwindows
    // run on the same thread.

    for (c = TLS(optionSettingsInfo.pcache).Size(),
         ppOS = TLS(optionSettingsInfo.pcache);
         c > 0;
         c--, ppOS++)
    {
        if (!StrCmpC((*ppOS)->achKeyPath, pstr))
        {
            _pOptionSettings = *ppOS;
            goto Cleanup;
        }
    }
#endif
    // We only make it here if we didn't find an existing entry.

    // OPTIONSETTINGS has one character already in it, which accounts for a
    // NULL terminator.

    pOS = new ( _tcslen(pstr) * sizeof(TCHAR) ) OPTIONSETTINGS;
    if (!pOS)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // New clients, such as OE5, will set the UIHost flag.  For compatibility with OE4, however,
    // we need to employ some trickery to get the old font regkey values.

    fUseCodePageBasedFontLinking = 0 != (_dwFlagsHostInfo & DOCHOSTUIFLAG_CODEPAGELINKEDFONTS);
    if (!fUseCodePageBasedFontLinking)
    {
        fUseCodePageBasedFontLinking = _fOE4;
    }

    MemSetName((pOS, "OPTIONSETTINGS object, index %d",
                    TLS(optionSettingsInfo.pcache).Size()));

    pOS->Init(pstr, fUseCodePageBasedFontLinking);
    pOS->SetDefaults( );

    hr = TLS(optionSettingsInfo.pcache).Append(pOS);
    if (hr)
        goto Cleanup;

    _pOptionSettings = pOS;

    PrimaryMarkup()->ClearDefaultCharFormat();

Cleanup:
    if (pstr != pszDefaultKey)
        CoTaskMemFree(pstr);

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::EnsureCodepageSettings, public
//
//  Synopsis:   Ensures that this CDoc is pointing to a valid CODEPAGESETTINGS
//              object. Should only be called by ReadCodepageSettingsFromRegistry.
//
//  Arguments:  uiFamilyCodePage - the family to check for
//
//----------------------------------------------------------------------------

HRESULT
CMarkup::EnsureCodepageSettings(UINT uiFamilyCodePage)
{
    HRESULT            hr = S_OK;
    int                n;
    CODEPAGESETTINGS** ppCS, *pCS;
    OPTIONSETTINGS *   pOptionSettings = Doc()->_pOptionSettings;

    // Make sure we have a valid pOptionSettings object
    Assert(pOptionSettings);

    // The first step is to look up the entry in the codepage cache

    for (n = pOptionSettings->aryCodepageSettingsCache.Size(),
                ppCS = pOptionSettings->aryCodepageSettingsCache;
                n > 0;
                n--, ppCS++)
    {
        if ( (*ppCS)->uiFamilyCodePage == uiFamilyCodePage )
        {
            hr = SetCodepageSettings(*ppCS);
            goto Cleanup;
        }
    }

    // We're out of luck, need to read in the codepage setting from the registry

    pCS = (CODEPAGESETTINGS *) MemAlloc(Mt(CodePageSettings), sizeof(CODEPAGESETTINGS) );
    if (!pCS)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    MemSetName((pCS, "CODEPAGESETTINGS"));

    pCS->Init( );
    pCS->SetDefaults( uiFamilyCodePage, pOptionSettings->sBaselineFontDefault );

    hr = pOptionSettings->aryCodepageSettingsCache.Append(pCS);
    if (hr)
        goto Cleanup;

    hr = SetCodepageSettings(pCS);
    if (hr)
        goto Cleanup;

    ClearDefaultCharFormat();

Cleanup:
    RRETURN(hr);
}

#ifndef NO_RTF
//+-------------------------------------------------------------------------
//
//  Method:     CDoc::RtfConverterEnabled
//
//  Synopsis:   TRUE if this rtf conversions are enabled, FALSE otherwise.
//
//--------------------------------------------------------------------------

BOOL
CDoc::RtfConverterEnabled()
{
    DWORD  dwConvf = _pOptionSettings->dwRtfConverterf; // for shorthand
    CPINFO cpinfo;

    //
    // Rtf conversions can be disabled on an sbcs-dbcs basis, or even
    // completely.  See the RTFCONVF flags in formkrnl.hxx.
    //
    return (dwConvf & RTFCONVF_ENABLED) &&
        ((dwConvf & RTFCONVF_DBCSENABLED) ||
        (GetCPInfo(g_cpDefault, &cpinfo) && cpinfo.MaxCharSize == 1));
}

BOOL
CMarkup::RtfConverterEnabled()
{
    return( Doc()->RtfConverterEnabled() &&
            ( GetAAcodepage() == 1255 || GetAAcodepage() == 1256 ) );
}

#endif // ndef NO_RTF

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::UpdateFromRegistry, public
//
//  Synopsis:   Load configuration information from the registry. Needs to be
//              called after we have our client site so we can do a
//              QueryService.
//
//  Arguments:  flags - REGUPDATE_REFRESH - read even if we find a cache entry
//                    - REGUPDATE_KEEPLOCALSTATE - true if we do not want to
//                                                 override local state
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

struct SAVEDSETTINGS
{
    OLE_COLOR colorBack;
    OLE_COLOR colorText;
    OLE_COLOR colorAnchor;
    OLE_COLOR colorAnchorVisited;
    OLE_COLOR colorAnchorHovered;
    LONG      latmFixedFontFace;
    LONG      latmPropFontFace;
    LONG      nAnchorUnderline;
    SHORT     sBaselineFontDefault;
    BYTE      fAlwaysUseMyColors;
    BYTE      fAlwaysUseMyFontSize;
    BYTE      fAlwaysUseMyFontFace;
    BYTE      fUseMyStylesheet;
    BYTE      bCharSet;
};

static void
SaveSettings(OPTIONSETTINGS *pOptionSettings,
             CODEPAGESETTINGS *pCodepageSettings,
             SAVEDSETTINGS *pSavedSettings)
{
    memset(pSavedSettings, 0, sizeof(SAVEDSETTINGS));
    pSavedSettings->colorBack             = pOptionSettings->colorBack;
    pSavedSettings->colorText             = pOptionSettings->colorText;
    pSavedSettings->colorAnchor           = pOptionSettings->colorAnchor;
    pSavedSettings->colorAnchorVisited    = pOptionSettings->colorAnchorVisited;
    pSavedSettings->colorAnchorHovered    = pOptionSettings->colorAnchorHovered;
    pSavedSettings->nAnchorUnderline      = pOptionSettings->nAnchorUnderline;
    pSavedSettings->fAlwaysUseMyColors    = pOptionSettings->fAlwaysUseMyColors;
    pSavedSettings->fAlwaysUseMyFontSize  = pOptionSettings->fAlwaysUseMyFontSize;
    pSavedSettings->fAlwaysUseMyFontFace  = pOptionSettings->fAlwaysUseMyFontFace;
    pSavedSettings->fUseMyStylesheet      = pOptionSettings->fUseMyStylesheet;
    pSavedSettings->bCharSet              = pCodepageSettings->bCharSet;
    pSavedSettings->latmFixedFontFace     = pCodepageSettings->latmFixedFontFace;
    pSavedSettings->latmPropFontFace      = pCodepageSettings->latmPropFontFace;
    pSavedSettings->sBaselineFontDefault  = pCodepageSettings->sBaselineFontDefault;
}

HRESULT
CDoc::UpdateFromRegistry(DWORD dwFlags, BOOL *pfNeedLayout)
{
    HRESULT         hr = S_OK;
    CODEPAGE        codepage;
    BOOL            fFirstTime = !_pOptionSettings;
    SAVEDSETTINGS   savedSettings1;
    SAVEDSETTINGS   savedSettings2;
    CODEPAGESETTINGS *pCodepageSettings = _pWindowPrimary ? PrimaryMarkup()->GetCodepageSettings() : NULL;

    // Use the cached values unless we are forced to re-read
    if (!fFirstTime && !(dwFlags & REGUPDATE_REFRESH))
        return hr;

    if (pfNeedLayout)
    {
        if (!_pOptionSettings || !pCodepageSettings)
        {
            // We assume that in this context, the caller is interested
            // only in whether or not we want to relayout, and not to
            // force us to read in registry settings.
            *pfNeedLayout = FALSE;
            return hr;
        }
        SaveSettings(_pOptionSettings, pCodepageSettings, &savedSettings1);
    }

    // First read in the standard option settings
    hr = THR(ReadOptionSettingsFromRegistry(dwFlags));
    if (hr)
        goto Cleanup;

    if (g_fTerminalServer)
        _pOptionSettings->fSmoothScrolling = FALSE;

    // For HTML applications, override registry settings for multimedia components.
    // We don't want (for example) images in an HTA to fail to appear due to
    // custom internet options settings...

    if (IsHostedInHTA())
    {
        _pOptionSettings->fShowImages      = TRUE;
#ifndef NO_AVI
        _pOptionSettings->fShowVideos      = TRUE;
#endif // ndef NO_AVI
        _pOptionSettings->fPlaySounds      = TRUE;
        _pOptionSettings->fPlayAnimations  = TRUE;
        _pOptionSettings->fSmartDithering  = TRUE;
    }

    _dwMiscFlags() = _pOptionSettings->dwMiscFlags;

    SetEditBitsForMarkup( PrimaryMarkup() );
    
    // If we are getting settings for the first time, use the default
    //  codepage.  Otherwise, read based on our current setting.
    codepage = pCodepageSettings ? PrimaryMarkup()->GetCodePage() :
                                    _pOptionSettings->codepageDefault;
    IGNORE_HR( PrimaryMarkup()->ReadCodepageSettingsFromRegistry( codepage, WindowsCodePageFromCodePage( codepage ), dwFlags ) );

    // ReadCodepageSettingsFromRegistry could change _pCodepageSettings and hence we need to
    // reinitialize it.
    pCodepageSettings = _pWindowPrimary ? PrimaryMarkup()->GetCodepageSettings() : NULL;

    if (pCodepageSettings)
    {
        // Set the baseline font only the first time we read from the registry
#ifdef UNIX
        if (g_SelectedFontSize != -1) // Copy the previous selected font size.
            _sBaselineFont = pCodepageSettings->sBaselineFontDefault = g_SelectedFontSize;
    else
#endif
        _sBaselineFont = pCodepageSettings->sBaselineFontDefault;
    }

    // Request the accept language header info from shlwapi.
    {
        TCHAR achLang[256];
        DWORD cchLang = ARRAY_SIZE(achLang);
        _pOptionSettings->fHaveAcceptLanguage = (GetAcceptLanguages(achLang, &cchLang) == S_OK)
                                                && (_pOptionSettings->cstrLang.Set(achLang, cchLang) == S_OK);
    }

    if (pfNeedLayout)
    {
        SaveSettings(_pOptionSettings, pCodepageSettings, &savedSettings2);
        *pfNeedLayout = !!memcmp(&savedSettings1, &savedSettings2, sizeof(SAVEDSETTINGS));
    }

Cleanup:
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::ReadSettingsFromRegistry, public
//
//  Synopsis:   A generic function to read from the registry.
//
//  Arguments:  pAryKeys - a pointer to an array of keys
//              iKeyCount - the number of keys in this array
//              pBase - a pointer to which offsets in pAryKeys are relative.
//              dwFlags - see UpdateWithRegistry
//              fSettingsRead - True if the settings were already read
//              pUserData - may hold some user data.  for now if we are looking
//                          for a RPI_CPKEY, this is assumed to point to a codepage enum.
//
//----------------------------------------------------------------------------

#define MAX_REG_VALUE_LENGTH   50

enum RKI_TYPE
{
    RKI_KEY,
    RKI_CPKEY,
    RKI_BOOL,
    RKI_COLOR,
    RKI_FONT,
    RKI_SIZE,
    RKI_CP,
    RKI_BYTEBOOL,
    RKI_STRING,
    RKI_ANCHORUNDERLINE,
    RKI_STRICT_CSS,
    RKI_DWORD,
    RKI_TYPE_Last_Enum
};

struct REGKEYINFORMATION
{
    TCHAR *   pszName;            // Name of the value or key
    BYTE      rkiType;            // Type of entry
    size_t    cbOffset;           // Offset of member to store data in
    size_t    cbOffsetCondition;  // Offset of member that must be false (true only
                                  //  for type RKI_STRING) to use this value. If
                                  //  it's true (false for type RKI_STRING)
                                  //  this value is left as its default value. Assumed
                                  //  to be data that's sizeof(BYTE). If 0 then
                                  //  no condition is used.
    BOOL      fLocalState;        // True if this is local state which may not always get
                                  //  updated when read again from the registry.
};

HRESULT
ReadSettingsFromRegistry(
    TCHAR * pchKeyPath,
    const REGKEYINFORMATION* pAryKeys, int iKeyCount,
    void* pBase, DWORD dwFlags, BOOL fSettingsRead,
    void* pUserData )
{
    LONG                lRet;
    HKEY                hKeyRoot = NULL;
    HKEY                hKeySub  = NULL;
    int                 i;
    DWORD               dwType;
    DWORD               dwSize;

    //
    // IEUNIX
    // Note we access dwDataBuf as a byte array through bDataBuf
    // but DWORD align it by declaring it a DWORD array (dwDataBuf).
    //
    DWORD               dwDataBuf[pdlUrlLen / sizeof(DWORD) +1 ];
    BYTE              * bDataBuf = (BYTE*) dwDataBuf;

    TCHAR               achCustomKey[64], * pch;
    BYTE              * pbData;
    BYTE                bCondition;
    BOOL                fUpdateLocalState;
    const REGKEYINFORMATION * prki;
    LONG              * pl;

    Assert( pBase );

    // Do not re-read unless explictly asked to do so.
    if( fSettingsRead && !(dwFlags & REGUPDATE_REFRESH) )
        return S_OK;

    // Always read local settings at least once
    fUpdateLocalState = !fSettingsRead || (dwFlags & REGUPDATE_OVERWRITELOCALSTATE );

    // Get a registry key handle

    lRet = RegOpenKeyEx(HKEY_CURRENT_USER, pchKeyPath, 0, KEY_READ, &hKeyRoot);
    if( lRet != ERROR_SUCCESS )
        return S_FALSE;

    for (i = 0; i < iKeyCount; i++)
    {
        prki = &pAryKeys[i];
        // Do not update local state unless asked to do so.
        if( !fUpdateLocalState && prki->fLocalState )
            continue;
        switch (prki->rkiType)
        {
        case RKI_KEY:
        case RKI_CPKEY:
            if (!prki->pszName)
            {
                hKeySub = hKeyRoot;
            }
            else
            {
                if (hKeySub && (hKeySub != hKeyRoot))
                {
                    RegCloseKey(hKeySub);
                    hKeySub = NULL;
                }

                if (prki->rkiType == RKI_CPKEY)
                {
                    // N.B. (johnv) It is assumed here that pUserData points
                    // to a codepage if we are looking for codepage settings.
                    // RKI_CPKEY entries are per family codepage.

                    Assert(pUserData);

                    Format( 0, achCustomKey, ARRAY_SIZE( achCustomKey ),
                            prki->pszName,
                            *(DWORD*)pUserData );

                    pch = achCustomKey;
                }
                else
                {
                    pch = prki->pszName;
                }

                lRet = RegOpenKeyEx(hKeyRoot,
                                    pch,
                                    0,
                                    KEY_READ,
                                    &hKeySub);

                if (lRet != ERROR_SUCCESS)
                {
                    // We couldn't get this key, skip it.
                    i++;
                    while (i < iKeyCount &&
                           pAryKeys[i].rkiType != RKI_KEY &&
                           pAryKeys[i].rkiType != RKI_CPKEY )
                    {
                        i++;
                    }

                    i--; // Account for the fact that continue will increment i again.
                    hKeySub = NULL;
                    continue;
                }
            }
            break;

        case RKI_SIZE:
            Assert(hKeySub);

            dwSize = MAX_REG_VALUE_LENGTH;

            lRet = RegQueryValueEx(hKeySub,
                                   prki->pszName,
                                   0,
                                   &dwType,
                                   bDataBuf,
                                   &dwSize);

            if (lRet == ERROR_SUCCESS)
            {
                short s;

                if (dwType == REG_BINARY)
                {
                    s = (short)*(BYTE *)bDataBuf;
                }
                else if (dwType == REG_DWORD)
                {
                    s = (short)*(DWORD *)bDataBuf;
                }
                else
                {
                    break;
                }

                *(short*)((BYTE *)pBase + prki->cbOffset) =
                    min( short(BASELINEFONTMAX), max( short(BASELINEFONTMIN), s ) );
            }
            break;

        case RKI_BOOL:
            Assert(hKeySub);

            dwSize = MAX_REG_VALUE_LENGTH;
            lRet = RegQueryValueEx(hKeySub,
                                   prki->pszName,
                                   0,
                                   &dwType,
                                   bDataBuf,
                                   &dwSize);

            if (lRet == ERROR_SUCCESS)
            {
                pbData = (BYTE*)((BYTE *)pBase + prki->cbOffset);

                if (dwType == REG_DWORD)
                {
                    *pbData = (*(DWORD*)bDataBuf != 0);
                }
                else if (dwType == REG_SZ)
                {
                    TCHAR ch = *(TCHAR *)bDataBuf;

                    if (ch == _T('1') ||
                        ch == _T('y') ||
                        ch == _T('Y'))
                    {
                        *pbData = TRUE;
                    }
                    else
                    {
                        *pbData = FALSE;
                    }
                } else if (dwType == REG_BINARY)
                {
                    *pbData = (*(BYTE*)bDataBuf != 0);
                }

                // Can't convert other types. Just leave it the default.
            }
            break;

        case RKI_FONT:
            Assert(hKeySub);
            dwSize = LF_FACESIZE * sizeof(TCHAR);

            lRet = RegQueryValueEx(hKeySub,
                                   prki->pszName,
                                   0,
                                   &dwType,
                                   bDataBuf,
                                   &dwSize);

            pl = (LONG *)((BYTE *)pBase + prki->cbOffset);

            if (lRet == ERROR_SUCCESS && dwType == REG_SZ)
            {
                TCHAR * pchFontFace = (TCHAR *)bDataBuf;
                if (*pchFontFace)
                {
                    // Make sure we don't overflow static buffer
                    AssertSz(_tcsclen(pchFontFace) < LF_FACESIZE, "String length > LF_FACESIZE");
                    pchFontFace[LF_FACESIZE - 1] = 0;

                    *pl = fc().GetAtomFromFaceName(pchFontFace);
                }
            }
            break;

        case RKI_COLOR:
            Assert(hKeySub);

            dwSize = MAX_REG_VALUE_LENGTH;

            bCondition = *(BYTE*)((BYTE *)pBase + prki->cbOffsetCondition);
            if (prki->cbOffsetCondition && bCondition)
            {
                //
                // The appropriate flag is set that says we should not pay
                // attention to this value, so just skip it and keep the
                // default.
                //
                break;
            }

            lRet = RegQueryValueEx(hKeySub,
                                   prki->pszName,
                                   0,
                                   &dwType,
                                   bDataBuf,
                                   &dwSize);

            if (lRet == ERROR_SUCCESS)
            {
                if (dwType == REG_SZ)
                {
                    //
                    // Crack the registry format for colors which is a string
                    // of the form "R,G,B" where R, G, and B are decimal
                    // values for Red, Green, and Blue, respectively.
                    //

                    DWORD   colors[3];
                    TCHAR * pchStart  = (TCHAR*)bDataBuf;
                    TCHAR * pchEnd;
                    int     i;

                    pbData = (BYTE*)((BYTE *)pBase + prki->cbOffset);

                    for (i = 0; i < 3; i++)
                    {
                        colors[i] = wcstol(pchStart, &pchEnd, 10);

                        if (*pchEnd == _T('\0') && i != 2)
                            break;

                        pchStart  = pchEnd + 1;
                    }

                    if (i != 3) // We didn't get all the colors. Abort.
                        break;

                    *(COLORREF*)pbData = RGB(colors[0], colors[1], colors[2]);
                }
                // Can't convert other types. Just leave it the default.
            }
            break;

        case RKI_CP:
            Assert(hKeySub);

            dwSize = sizeof(DWORD);

            lRet = RegQueryValueEx(hKeySub,
                                   prki->pszName,
                                   0,
                                   &dwType,
                                   bDataBuf,
                                   &dwSize);

            if (lRet == ERROR_SUCCESS && dwType == REG_BINARY)
            {
                *(CODEPAGE*)((BYTE *)pBase + prki->cbOffset) = *(CODEPAGE *)bDataBuf;
            }
            break;

        case RKI_BYTEBOOL:
            Assert(hKeySub);

            dwSize = sizeof(DWORD);

            lRet = RegQueryValueEx(hKeySub,
                                   prki->pszName,
                                   0,
                                   &dwType,
                                   bDataBuf,
                                   &dwSize);

            if (lRet == ERROR_SUCCESS && dwType == REG_BINARY)
            {
                *(BYTE*)((BYTE *)pBase + prki->cbOffset) = (BYTE) !! (*((DWORD*)bDataBuf));
            }
            break;

        case RKI_DWORD:
            Assert(hKeySub);

            dwSize = sizeof(DWORD);

            lRet = RegQueryValueEx(hKeySub,
                                   prki->pszName,
                                   0,
                                   &dwType,
                                   bDataBuf,
                                   &dwSize);

            if (lRet == ERROR_SUCCESS && (dwType == REG_BINARY || dwType == REG_DWORD))
            {
                *(DWORD*)((BYTE *)pBase + prki->cbOffset) = *(DWORD*)bDataBuf;
            }
            break;

        case RKI_ANCHORUNDERLINE:
            Assert(hKeySub);

            dwSize = MAX_REG_VALUE_LENGTH;

            lRet = RegQueryValueEx(hKeySub,
                                   prki->pszName,
                                   0,
                                   &dwType,
                                   bDataBuf,
                                   &dwSize);

            if (lRet == ERROR_SUCCESS && dwType == REG_SZ)
            {
                int nAnchorunderline = ANCHORUNDERLINE_YES;

                LPTSTR pchBuffer = (TCHAR *)bDataBuf;
                Assert (pchBuffer != NULL);

                if (pchBuffer)
                {
                    if (_tcsicmp(pchBuffer, _T("yes")) == 0)
                        nAnchorunderline = ANCHORUNDERLINE_YES;
                    else if (_tcsicmp(pchBuffer, _T("no")) == 0)
                        nAnchorunderline = ANCHORUNDERLINE_NO;
                    else if (_tcsicmp(pchBuffer, _T("hover")) == 0)
                        nAnchorunderline = ANCHORUNDERLINE_HOVER;
                }

                *(int*)((BYTE *)pBase + prki->cbOffset) = nAnchorunderline;

            }
            break;

        case RKI_STRICT_CSS:
            Assert(hKeySub);

            dwSize = MAX_REG_VALUE_LENGTH;

            lRet = RegQueryValueEx(hKeySub,
                                   prki->pszName,
                                   0,
                                   &dwType,
                                   bDataBuf,
                                   &dwSize);

            if (lRet == ERROR_SUCCESS && dwType == REG_SZ)
            {
                int nStrictCSS = STRICT_CSS_DOCTYPE;

                LPTSTR pchBuffer = (TCHAR *)bDataBuf;
                Assert (pchBuffer != NULL);

                if (pchBuffer)
                {
                    if (_tcsicmp(pchBuffer, _T("never")) == 0)
                        nStrictCSS = STRICT_CSS_NEVER;
                    else if (_tcsicmp(pchBuffer, _T("always")) == 0)
                        nStrictCSS = STRICT_CSS_ALWAYS;
                }

                *(int*)((BYTE *)pBase + prki->cbOffset) = nStrictCSS;

            }
            break;

        case RKI_STRING:
            Assert(hKeySub);

            dwSize = 0;
            bCondition = *(BYTE*)((BYTE *)pBase + prki->cbOffsetCondition);

            if ((prki->cbOffsetCondition && bCondition) || !prki->cbOffsetCondition)
            {
                //
                // The appropriate flag is set that says we should pay
                // attention to this value or the flag is 0, then do it
                // else skip and keep the default.
                //

                // get the size of string
                lRet = RegQueryValueEx(hKeySub,
                                       prki->pszName,
                                       0,
                                       &dwType,
                                       NULL,
                                       &dwSize);

                if (   lRet == ERROR_SUCCESS 
                    && (dwSize <= pdlUrlLen)) // to prevent buffer overrun
                {
                    lRet = RegQueryValueEx(hKeySub,
                                           prki->pszName,
                                           0,
                                           &dwType,
                                           bDataBuf,
                                           &dwSize);

                    if (lRet == ERROR_SUCCESS && dwType == REG_SZ)
                    {
                        ((CStr *)((BYTE *)pBase + prki->cbOffset))->Set((LPCTSTR)bDataBuf);
                    }
                }
            }

            break;

        default:
            AssertSz(FALSE, "Unrecognized RKI Type");
            break;
        }
    }

    if (hKeySub && (hKeySub != hKeyRoot))
        RegCloseKey(hKeySub);

    RegCloseKey( hKeyRoot );

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::ReadCodepageSettingsFromRegistry, public
//
//  Synopsis:   Read settings for a particular codepage from the registry.
//
//  Arguments:  cp - the codepage to read
//              dwFlags - See UpdateFromRegistry
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CMarkup::ReadCodepageSettingsFromRegistry(
    CODEPAGE cp,
    UINT uiFamilyCodePage,
    DWORD dwFlags )
{
    HRESULT    hr = S_OK;
    SCRIPT_ID  sid = RegistryAppropriateSidFromSid(DefaultSidForCodePage(uiFamilyCodePage));

    Assert(uiFamilyCodePage != CP_UNDEFINED && uiFamilyCodePage != CP_ACP);

    hr = THR(EnsureCodepageSettings(uiFamilyCodePage));
    if( hr )
        goto Cleanup;

    Doc()->_pOptionSettings->ReadCodepageSettingsFromRegistry(GetCodepageSettings(), dwFlags, sid);

    // Remember if we were autodetected
    _fCodePageWasAutoDetect = GetCodePage() == CP_AUTO_JP;

    // Set the codepage on the doc to the actual codepage requested
    hr = SetCodePage(cp);
    if (hr)
        goto Cleanup;
    hr = SetFamilyCodePage(uiFamilyCodePage);

Cleanup:
    RRETURN( hr );
}

//+---------------------------------------------------------------------------
//
//  Member:     OPTIONSETTINGS::ReadCodePageSettingsFromRegistry
//
//  Synopsis:   Read the fixed and proportional
//  
//----------------------------------------------------------------------------

void
   OPTIONSETTINGS::ReadCodepageSettingsFromRegistry(
    CODEPAGESETTINGS * pCS,
    DWORD dwFlags,
    SCRIPT_ID sid )
{
    static const REGKEYINFORMATION aScriptBasedFontKeys[] =
    {
        { _T("International\\Scripts\\<0d>"),      RKI_CPKEY, (long)0 },
        { _T("IEFontSize"),                        RKI_SIZE, offsetof(CODEPAGESETTINGS, sBaselineFontDefault),    0, FALSE },
        { _T("IEPropFontName"),                    RKI_FONT, offsetof(CODEPAGESETTINGS, latmPropFontFace),  1, FALSE },
        { _T("IEFixedFontName"),                   RKI_FONT, offsetof(CODEPAGESETTINGS, latmFixedFontFace), 0, FALSE },
    };

    static const REGKEYINFORMATION aCodePageBasedFontKeys[] =
    {
        { _T("International\\<0d>"),               RKI_CPKEY, (long)0 },
        { _T("IEFontSize"),                        RKI_SIZE, offsetof(CODEPAGESETTINGS, sBaselineFontDefault),    0, FALSE },
        { _T("IEPropFontName"),                    RKI_FONT, offsetof(CODEPAGESETTINGS, latmPropFontFace),  1, FALSE },
        { _T("IEFixedFontName"),                   RKI_FONT, offsetof(CODEPAGESETTINGS, latmFixedFontFace), 0, FALSE },
    };

    // NB (cthrash) (CP_UCS_2,sidLatin) is for Unicode documents.  So for OE, pick the Unicode font.
    // (CP_UCS_2,!sidAsciiLatin), on the other hand, is for codepageless fontlinking.  In OE, we obviously
    // can't use codepage-based fontlinking; use instead IE5 fontlinking.
    
    fUseCodePageBasedFontLinking &=    sid == sidAsciiLatin
                                    || sid == sidLatin
                                    || DefaultCharSetFromScriptAndCharset(sid, DEFAULT_CHARSET) != DEFAULT_CHARSET;
    
    DWORD dwArg = fUseCodePageBasedFontLinking ? DWORD(pCS->uiFamilyCodePage) : DWORD(sid);

    IGNORE_HR( ReadSettingsFromRegistry( achKeyPath,
                                         fUseCodePageBasedFontLinking ? aCodePageBasedFontKeys : aScriptBasedFontKeys,
                                         ARRAY_SIZE(aCodePageBasedFontKeys),
                                         pCS,
                                         dwFlags,
                                         pCS->fSettingsRead,
                                         (void *)&dwArg ) );

    // Determine the appropriate GDI charset

    pCS->bCharSet = DefaultCharSetFromScriptAndCodePage( sid, pCS->uiFamilyCodePage );

    // Do a little fixup on the fonts if not present.  Note that we avoid
    // doing this in CODEPAGESETTINGS::SetDefault as this could be expensive
    // and often unnecessary.
    if (    pCS->latmPropFontFace  == -1 
        ||  pCS->latmFixedFontFace == -1)
    {
        fl().ScriptAppropriateFaceNameAtom(sid, pCS->latmPropFontFace, pCS->latmFixedFontFace);
    }

    pCS->fSettingsRead = TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::ReadContextMenuExtFromRegistry, public
//
//  Synopsis:   Load information about context menu extensions
//              from the registry
//
//  Arguments:  dwFlags - See UpdateFromRegistry.
//
//  Returns:    HRESULT, S_FALSE says nothing was there to read
//
//----------------------------------------------------------------------------
HRESULT
CDoc::ReadContextMenuExtFromRegistry( DWORD dwFlags /* = 0 */)
{
    HRESULT             hr = S_OK;
    CONTEXTMENUEXT *    pCME = NULL;
    int                 nExtMax, nExtCur;
    HKEY                hKeyRoot = NULL;
    HKEY                hKeyMenuExt = NULL;
    HKEY                hKeySub = NULL;
    TCHAR               achSubName[MAX_PATH + 1];
    long                lRegRet;
    DWORD               dwType;
    DWORD               dwSize;
    BYTE                bDataBuf[pdlUrlLen];

    // Do not re-read unless explictly asked to do so.
    if( _pOptionSettings->fSettingsRead && !(dwFlags & REGUPDATE_REFRESH) )
        return S_OK;

    //
    //  Open up our root key
    //
    lRegRet = RegOpenKeyEx(HKEY_CURRENT_USER, _pOptionSettings->achKeyPath,
                        0, KEY_READ, &hKeyRoot);
    if( lRegRet != ERROR_SUCCESS )
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    //
    // Get the menu extensions sub key
    //
    lRegRet = RegOpenKeyEx(hKeyRoot, _T("MenuExt"),
                           0, KEY_READ, &hKeyMenuExt);
    if( lRegRet != ERROR_SUCCESS )
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    //
    // Make sure our array is big enough
    //
    nExtMax = IDM_MENUEXT_LAST__ - IDM_MENUEXT_FIRST__;
    hr = _pOptionSettings->aryContextMenuExts.EnsureSize(nExtMax);
    if(hr)
        goto Cleanup;

    //
    // add an entry for each sub key
    //

    for(nExtCur = 0; nExtCur < nExtMax; nExtCur++)
    {
        lRegRet = RegEnumKey(hKeyMenuExt, nExtCur, achSubName, MAX_PATH+1);
        if(lRegRet != ERROR_SUCCESS)
        {
            break;
        }

        // Open the sub key
        lRegRet = RegOpenKeyEx(hKeyMenuExt, achSubName, 0, KEY_READ, &hKeySub);
        if(lRegRet != ERROR_SUCCESS)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        // we have a key so create an extension object
        pCME = new(Mt(CDocReadContextMenuExtFromRegistry_pCME)) CONTEXTMENUEXT;
        if(!pCME)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        // set the menu name
        pCME->cstrMenuValue.Set(achSubName);

        // read the default value
        dwSize = pdlUrlLen;
        bDataBuf[0] = 0;
        lRegRet = RegQueryValueEx(hKeySub, NULL,
                                  0, &dwType, bDataBuf, &dwSize);
        if(lRegRet == ERROR_SUCCESS && dwType == REG_SZ)
        {
            pCME->cstrActionUrl.Set((LPCTSTR)bDataBuf);
        }

        // look for flags
        dwSize = sizeof(DWORD);
        lRegRet = RegQueryValueEx(hKeySub, _T("Flags"),
                                  0, &dwType, bDataBuf, &dwSize);
        if(lRegRet == ERROR_SUCCESS &&
           (dwType == REG_DWORD || dwType == REG_BINARY) )
        {
            pCME->dwFlags = *((DWORD*)bDataBuf);
        }

        // look for contexts
        dwSize = sizeof(DWORD);
        lRegRet = RegQueryValueEx(hKeySub, _T("Contexts"),
                                  NULL, &dwType, bDataBuf, &dwSize);
        if(lRegRet == ERROR_SUCCESS &&
           (dwType == REG_DWORD || dwType == REG_BINARY) )
        {
            pCME->dwContexts = *((DWORD*)bDataBuf);
        }

        // check to make sure we have a good extension
        if(pCME->cstrMenuValue.Length() != 0 &&
           pCME->cstrActionUrl.Length() != 0)
        {
            _pOptionSettings->aryContextMenuExts.Append(pCME);
        }
        else
        {
            delete pCME;
        }

        pCME = NULL;
        RegCloseKey(hKeySub);
        hKeySub = NULL;
    }

Cleanup:
    delete pCME;

    if(hKeySub)
        RegCloseKey(hKeySub);

    if(hKeyMenuExt)
        RegCloseKey(hKeyMenuExt);

    if(hKeyRoot)
        RegCloseKey(hKeyRoot);

    RRETURN1(hr, S_FALSE);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::ReadOptionSettingsFromRegistry, public
//
//  Synopsis:   Read the general option settings from the registry.
//
//  Arguments:  dwFlags - See UpdateFromRegistry.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

BOOL g_fUseHR = FALSE;

HRESULT
CDoc::ReadOptionSettingsFromRegistry( DWORD dwFlags )
{
    HRESULT hr = S_OK;

    //
    // keys in main registry location
    //

    static const REGKEYINFORMATION aOptionKeys[] =
    {
        { NULL,                         RKI_KEY, 0 },
        { _T("Show_FullURL"),           RKI_BOOL,  offsetof(OPTIONSETTINGS, fShowFriendlyUrl), 0, FALSE },
        { _T("SmartDithering"),         RKI_BOOL,  offsetof(OPTIONSETTINGS, fSmartDithering),  0, FALSE },
        { _T("RtfConverterFlags"),      RKI_DWORD, offsetof(OPTIONSETTINGS, dwRtfConverterf),  0, FALSE },

        { _T("Main"),                   RKI_KEY, 0 },
        { _T("Page_Transitions"),       RKI_BOOL, offsetof(OPTIONSETTINGS, fPageTransitions), 0, FALSE },
        { _T("Use_DlgBox_Colors"),      RKI_BOOL, offsetof(OPTIONSETTINGS, fUseDlgColors),    0, FALSE },
        { _T("Anchor Underline"),       RKI_ANCHORUNDERLINE, offsetof(OPTIONSETTINGS, nAnchorUnderline), 0, FALSE },
        { _T("CSS_Compat"),             RKI_STRICT_CSS, offsetof(OPTIONSETTINGS, nStrictCSSInterpretation), 0, FALSE },
        { _T("Expand Alt Text"),        RKI_BOOL, offsetof(OPTIONSETTINGS, fExpandAltText),   0, FALSE },
        { _T("Display Inline Images"),  RKI_BOOL, offsetof(OPTIONSETTINGS, fShowImages),      0, FALSE },
#ifndef NO_AVI
        { _T("Display Inline Videos"),  RKI_BOOL, offsetof(OPTIONSETTINGS, fShowVideos),      0, FALSE },
#endif // ndef NO_AVI
        { _T("Play_Background_Sounds"), RKI_BOOL, offsetof(OPTIONSETTINGS, fPlaySounds),      0, FALSE },
        { _T("Play_Animations"),        RKI_BOOL, offsetof(OPTIONSETTINGS, fPlayAnimations),  0, FALSE },
        { _T("Print_Background"),       RKI_BOOL, offsetof(OPTIONSETTINGS, fPrintBackground),   0, FALSE },
        { _T("Use Stylesheets"),        RKI_BOOL, offsetof(OPTIONSETTINGS, fUseStylesheets),  0, FALSE },
        { _T("SmoothScroll"),           RKI_BOOL, offsetof(OPTIONSETTINGS, fSmoothScrolling), 0, FALSE },
        { _T("Show image placeholders"),   RKI_BOOL, offsetof(OPTIONSETTINGS, fShowImagePlaceholder), 0, FALSE },
        { _T("Disable Script Debugger"),    RKI_BOOL, offsetof(OPTIONSETTINGS, fDisableScriptDebugger), 0, TRUE },
        { _T("Move System Caret"),      RKI_BOOL, offsetof(OPTIONSETTINGS, fMoveSystemCaret), 0, FALSE },
        { _T("Force Offscreen Composition"), RKI_BOOL, offsetof(OPTIONSETTINGS, fForceOffscreen), 0, FALSE },
        { _T("Enable AutoImageResize"), RKI_BOOL, offsetof(OPTIONSETTINGS, fEnableImageResize), 0, FALSE },
        { _T("Q051873"),                RKI_BOOL,   offsetof(OPTIONSETTINGS, fUsePlugin),   0, FALSE },
        { _T("UseThemes"),              RKI_BOOL,   offsetof(OPTIONSETTINGS, fUseThemes),   0, FALSE },
        { _T("UseHR"),                  RKI_BOOL,   offsetof(OPTIONSETTINGS, fUseHiRes),   0, FALSE },
        { _T("Q300829"),                RKI_BOOL,   offsetof(OPTIONSETTINGS, fRouteEditorOnce), 0, FALSE },
        { _T("Disable_Local_Machine_Navigate"), RKI_BOOL,   offsetof(OPTIONSETTINGS, fLocalMachineCheck),   0, FALSE },
        { _T("Cleanup HTCs"),           RKI_BOOL,   offsetof(OPTIONSETTINGS, fCleanupHTCs), 0, FALSE },

        { _T("International"),          RKI_KEY,   0 },
        { _T("Default_CodePage"),       RKI_CP,   offsetof(OPTIONSETTINGS, codepageDefault),  0, TRUE },
#ifndef UNIX // Unix doesn't support AutoDetect
        { _T("AutoDetect"),    RKI_BOOL, offsetof(OPTIONSETTINGS, fCpAutoDetect),    0, FALSE },
#endif

        { _T("International\\Scripts"), RKI_KEY,   0 },
        { _T("Default_IEFontSize"),     RKI_SIZE,   offsetof(OPTIONSETTINGS, sBaselineFontDefault),  0, FALSE },

        { _T("Settings"),               RKI_KEY, 0 },
        { _T("Background Color"),       RKI_COLOR, offsetof(OPTIONSETTINGS, colorBack),          offsetof(OPTIONSETTINGS, fUseDlgColors), FALSE },
        { _T("Text Color"),             RKI_COLOR, offsetof(OPTIONSETTINGS, colorText),          offsetof(OPTIONSETTINGS, fUseDlgColors), FALSE },
        { _T("Anchor Color"),           RKI_COLOR, offsetof(OPTIONSETTINGS, colorAnchor),        0, FALSE },
        { _T("Anchor Color Visited"),   RKI_COLOR, offsetof(OPTIONSETTINGS, colorAnchorVisited), 0, FALSE },
        { _T("Anchor Color Hover"),     RKI_COLOR, offsetof(OPTIONSETTINGS, colorAnchorHovered), 0, FALSE },
        { _T("Always Use My Colors"),   RKI_BOOL, offsetof(OPTIONSETTINGS, fAlwaysUseMyColors),  0, FALSE },
        { _T("Always Use My Font Size"),   RKI_BOOL, offsetof(OPTIONSETTINGS, fAlwaysUseMyFontSize),  0, FALSE },
        { _T("Always Use My Font Face"),   RKI_BOOL, offsetof(OPTIONSETTINGS, fAlwaysUseMyFontFace),  0, FALSE },
        { _T("Use Anchor Hover Color"),    RKI_BOOL, offsetof(OPTIONSETTINGS, fUseHoverColor),        0, FALSE },
        { _T("MiscFlags"),              RKI_DWORD,   offsetof(OPTIONSETTINGS, dwMiscFlags),   0, TRUE },

        { _T("Styles"),                 RKI_KEY, 0 },
        { _T("Use My Stylesheet"),      RKI_BOOL, offsetof(OPTIONSETTINGS, fUseMyStylesheet),  0, FALSE },
        { _T("User Stylesheet"),        RKI_STRING, offsetof(OPTIONSETTINGS, cstrUserStylesheet),  offsetof(OPTIONSETTINGS, fUseMyStylesheet), FALSE },
        { _T("MaxScriptStatements"),    RKI_DWORD,   offsetof(OPTIONSETTINGS, dwMaxStatements),   0, FALSE },
    };

    //
    // keys in windows location
    //

    static TCHAR achWindowsSettingsPath [] = _T("Software\\Microsoft\\Windows\\CurrentVersion");

    static const REGKEYINFORMATION aOptionKeys2[] =
    {
        { _T("Policies\\ActiveDesktop"),RKI_KEY, 0 },
        { _T("NoChangingWallpaper"),    RKI_DWORD,  offsetof(OPTIONSETTINGS, dwNoChangingWallpaper), 0, FALSE },
        { _T("Policies"), RKI_KEY, 0 },
        { _T("Allow Programmatic Cut_Copy_Paste"), RKI_BOOL, offsetof(OPTIONSETTINGS, fAllowCutCopyPaste), 0, FALSE },
        { _T("Internet Settings"), RKI_KEY, 0 },
        { _T("DisableCachingOfSSLPages"),    RKI_BOOL,   offsetof(OPTIONSETTINGS, fDisableCachingOfSSLPages),   0, FALSE },
    };

    hr = THR(EnsureOptionSettings());
    if (hr)
        goto Cleanup;

    // Make sure we get back the default windows colors, etc.
    if(dwFlags & REGUPDATE_REFRESH)
        _pOptionSettings->SetDefaults();
    IGNORE_HR( ReadSettingsFromRegistry(
        _pOptionSettings->achKeyPath,
        aOptionKeys,
        ARRAY_SIZE(aOptionKeys),
        _pOptionSettings,
        dwFlags,
        _pOptionSettings->fSettingsRead,
        (void *)&_pOptionSettings->codepageDefault ) );

    IGNORE_HR( ReadSettingsFromRegistry(
        achWindowsSettingsPath,
        aOptionKeys2,
        ARRAY_SIZE(aOptionKeys2),
        _pOptionSettings, dwFlags,
        _pOptionSettings->fSettingsRead, NULL ) );

    // fUseThemes should be read from InetCpl settings only if we are hosted inside IE or Explorer

    if ( !(GetModuleHandle(TEXT("EXPLORER.EXE")) || GetModuleHandle(TEXT("IEXPLORE.EXE"))) )
    {
        _pOptionSettings->fUseThemes = FALSE;
    }

    // check if there is an overriding set of properties over the defaults provided
    if (_pHostUIHandler)
    {
        IDocHostUIHandler2 * pDHUIHandler2 = NULL;

        if (SUCCEEDED(_pHostUIHandler->QueryInterface(IID_IDocHostUIHandler2, 
                                                        (void **)&pDHUIHandler2)))
        {
            TCHAR   * pstr = NULL;

            Assert(pDHUIHandler2);

            if (SUCCEEDED(pDHUIHandler2->GetOverrideKeyPath(&pstr, 0)) && pstr)
            {
                IGNORE_HR( ReadSettingsFromRegistry(
                    pstr,
                    aOptionKeys,
                    ARRAY_SIZE(aOptionKeys),
                    _pOptionSettings,
                    dwFlags,
                    _pOptionSettings->fSettingsRead,
                    (void *)&_pOptionSettings->codepageDefault ) );

                // clear the buffer.
                CoTaskMemFree(pstr);
            }

            // release the interface pointer
            ReleaseInterface(pDHUIHandler2);
        }
    }

    // Look at the registry for context menu extensions
    IGNORE_HR( ReadContextMenuExtFromRegistry( dwFlags ) );

    // Look at the registry for HKSCS Support
    // If HKSCS support is enabled, need to perform special fontlinking
    {
        static TCHAR pszNlsCodePageKey[] = _T("System\\CurrentControlSet\\Control\\Nls\\CodePage");
        static TCHAR pszNlsCP950[] = _T("950");
        static TCHAR pszNlsCP950HK[] = _T("c_951.nls");
        static TCHAR pszNlsCP950HK_ForWin9x_Ugh[] = _T("cp_951.nls");

        HKEY hKeyNlsCP;
        LONG lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, pszNlsCodePageKey, 0, KEY_READ, &hKeyNlsCP);
        if (lRet == ERROR_SUCCESS)
        {
            DWORD dwType;
            TCHAR pszNlsData[16];
            pszNlsData[0] = 0;
            DWORD dwSize = sizeof(pszNlsData);
            lRet = RegQueryValueEx(hKeyNlsCP, pszNlsCP950, 0, &dwType, (BYTE *)pszNlsData, &dwSize);
            if (lRet == ERROR_SUCCESS && dwType == REG_SZ)
            {
                _pOptionSettings->fHKSCSSupport = (0 == _tcsicmp(pszNlsCP950HK, pszNlsData));
                if (!_pOptionSettings->fHKSCSSupport)
                {
                    _pOptionSettings->fHKSCSSupport = (0 == _tcsicmp(pszNlsCP950HK_ForWin9x_Ugh, pszNlsData));
                }
            }

            RegCloseKey(hKeyNlsCP);
        }
    }

    _pOptionSettings->fSettingsRead = TRUE;

#ifdef WIN16_NEVER
    // BUGWIN16: the Flag in OPTIONSETTINGS just went away ??!! in beta2 Trident code !!
    // Make sure that we have enough memory to run Java
    if (_pOptionSettings->fRunJava && (DetectPhysicalMem() < MIN_JAVA_MEMORY))
    {
        _pOptionSettings->fRunJava = FALSE;

        // Update the registry to disable java
        HKEY    hkey;
        DWORD dw;

        if (RegCreateKeyEx(HKEY_CURRENT_USER, REGSTR_PATH_INTERNETSETTINGS,
                0, NULL, 0, KEY_ALL_ACCESS, NULL, &hkey, &dw) == ERROR_SUCCESS)
        {
            dw = FALSE;
            RegSetValueEx(hkey, REGSTR_VAL_SECURITYJAVA, 0,
                REGSTR_VAL_SECURITYJAVA_TYPE, (LPBYTE)&dw, sizeof(dw));
        }
    }
#endif

    g_fUseHR = _pOptionSettings->fUseHiRes;

    g_uiDisplay.SetResolution(GetDeviceCaps(GetThreadState()->hdcDesktop, LOGPIXELSX),
                              GetDeviceCaps(GetThreadState()->hdcDesktop, LOGPIXELSY));
    
Cleanup:
    RRETURN( hr );
}

//+---------------------------------------------------------------------------
//
//  Function:   DeinitOptionSettings
//
//  Synopsis:   Frees up memory stored in the TLS(optionSettingsInfo) struct.
//
//  Notes:      Called by the DllThreadDetach code.
//
//----------------------------------------------------------------------------

void
DeinitOptionSettings( THREADSTATE* pts )
{
    int c, n;
    OPTIONSETTINGS ** ppOS;
    CODEPAGESETTINGS ** ppCS;
    CONTEXTMENUEXT **   ppCME;

    // Free all entries in the options cache
    for (c = pts->optionSettingsInfo.pcache.Size(),
         ppOS = pts->optionSettingsInfo.pcache;
         c;
         c--, ppOS++)
    {
        (*ppOS)->cstrUserStylesheet.Free();

        // Free all entries in the codepage settings cache
        for (ppCS = (*ppOS)->aryCodepageSettingsCache,
            n = (*ppOS)->aryCodepageSettingsCache.Size();
            n;
            n--, ppCS++ )
        {
            MemFree(*ppCS);
        }

        // Free the context menu extension array
        for (ppCME = (*ppOS)->aryContextMenuExts,
             n = (*ppOS)->aryContextMenuExts.Size();
             n;
             n--, ppCME++)
        {
            delete *ppCME;
        }

        delete (*ppOS);
    }

    pts->optionSettingsInfo.pcache.DeleteAll();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\mshtmsvr.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       mshtmsvr.cxx
//
//  Contents:   Implementation for server-side trident
//
//  History:    04-23-98    AnandRa     Created
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_MSHTMSVR_H_
#define X_MSHTMSVR_H_
#include "mshtmsvr.h"
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_MSHTMSVR_HXX_
#define X_MSHTMSVR_HXX_
#include "mshtmsvr.hxx"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#ifndef X_UNICWRAP_HXX_
#define X_UNICWRAP_HXX_
#include "unicwrap.hxx"
#endif

#ifndef X_OTHRGUID_H_
#define X_OTHRGUID_H_
#include "othrguid.h"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_PROGSINK_HXX_
#define X_PROGSINK_HXX_
#include "progsink.hxx"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_TPOINTER_HXX_
#define X_TPOINTER_HXX_
#include "tpointer.hxx"
#endif

extern HRESULT CreateStreamOnFile(
        LPCTSTR lpstrFile,
        DWORD dwSTGM,
        LPSTREAM * ppstrm);
EXTERN_C const GUID CLSID_HTMLServerDoc;


#define SVRTRI_BUFSIZE      4096
#define STRLEN_MSIE     5

MtDefine(CDocSvr, CDoc, "CDocSvr")
PerfDbgTag(tagCDocSvrNoClone, "CDocSvr", "Disable cloning")


//+------------------------------------------------------------------------
//
//  Member:     AddServerDoc
//
//  Synopsis:   Add this document to the TLS cache.
//
//  Notes:      This will null out the passed in document.  Use
//              GetServerDoc to retrieve the doc.  This is for
//              refcount bookkeeping.  
//
//-------------------------------------------------------------------------

HRESULT
AddServerDoc(CDocSvr **ppDoc)
{
    HRESULT hr = S_OK;

    if (!*ppDoc)
        goto Cleanup;
        
    if (!TLS(paryDocSvr))
    {
        TLS(paryDocSvr) = new CTlsDocSvrAry;
        if (!TLS(paryDocSvr))
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }

    hr = THR(TLS(paryDocSvr)->Append(*ppDoc));
    if (hr)
        goto Cleanup;

    (*ppDoc)->AddRef();
    *ppDoc = NULL;
    
Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     GetServerDoc
//
//  Synopsis:   Get a document of the passed in filename frm the TLS cache.
//
//-------------------------------------------------------------------------

void
GetServerDoc(TCHAR *pchFileName, CDocSvr **ppDoc)
{
    long        i;
    TCHAR       achPath[MAX_PATH];
    TCHAR *     pchExt;
    LPOLESTR    pchFile = NULL;
    
    if (TLS(paryDocSvr))
    {
        for (i = 0; i < TLS(paryDocSvr)->Size(); i++)
        {
            GetFullPathName(pchFileName, ARRAY_SIZE(achPath), achPath, &pchExt);
            if (OK((*TLS(paryDocSvr))[i]->GetCurFile(&pchFile)))
            {
                if (_tcsiequal(achPath, pchFile))
                {
                    *ppDoc = (*TLS(paryDocSvr))[i];
                    CoTaskMemFree(pchFile);
                    return;
                }
            }
            CoTaskMemFree(pchFile);
            pchFile = NULL;
        }
    }
}


BOOL WINAPI 
SvrTri_NormalizeUA(
    CHAR  *pchUA,                      // [in] User agent string
    DWORD *pdwUA                       // [out] User agend id
    )
{
    char *  pchMSIE = "MSIE ";
    char *  pchUAPtr = pchUA;
    long    lVer;
    long    cch;
    
    if (!pchUA || !pdwUA)
        return FALSE;

    *pdwUA = USERAGENT_DEFAULT;

    for (;;)
    {
        pchUAPtr = strchr(pchUAPtr, 'M');
        if (!pchUAPtr)
            goto Cleanup;

        cch = strlen(pchUAPtr);
        if (STRLEN_MSIE < cch &&
            CompareStringA(g_lcidUserDefault, 0, pchMSIE, STRLEN_MSIE,
                pchUAPtr, STRLEN_MSIE) == 2)
            break;
            
        // Increment pchMSIE to get to the next char beyond the 'M'
        pchUAPtr++;
    }

    pchUAPtr += 5;
    
    lVer = atol(pchUAPtr);
    if (lVer >= 5)
    {
        *pdwUA = USERAGENT_IE5;
    }
    else if (lVer == 4)
    {
        *pdwUA = USERAGENT_IE4;
    }
    else if (lVer == 3)
    {
        *pdwUA = USERAGENT_IE3;
    }
    
Cleanup:
    return TRUE;
}


HRESULT
GetServerInfo(
    VOID *                      pvSrvContext,   // [in] Server Context
    PFN_SVR_GETINFO_CALLBACK    pfnInfo,        // [in] GetInfo callback
    CStrInW *                   pcstrInUA,
    CStrInW *                   pcstrInQS,
    CStrInW *                   pcstrInURL)
{
    CHAR        pchBuffer[SVRTRI_BUFSIZE];
    HRESULT     hr = S_OK;
    ULONG       cch;
    CHAR *      pchTemp;
    
    //
    // Get the user agent
    //
    
    if (!(*pfnInfo)(pvSrvContext, SVRINFO_USERAGENT, pchBuffer, SVRTRI_BUFSIZE))
    {
        hr = E_FAIL;
        goto Cleanup;
    }
    pcstrInUA->Init(pchBuffer, -1);

    //
    // Get the Query string
    //
    
    if (!(*pfnInfo)(pvSrvContext, SVRINFO_QUERY_STRING, pchBuffer, SVRTRI_BUFSIZE))
    {
        hr = E_FAIL;
        goto Cleanup;
    }
    pcstrInQS->Init(pchBuffer, -1);

    //
    // Get the url.  This is retrieved by combining the protocol with 
    // the virtual path.
    //
    
    if (!(*pfnInfo)(pvSrvContext, SVRINFO_PROTOCOL, pchBuffer, 20))
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    //
    // Strp out /1.1 if it exists.  E.g. HTTP/1.1
    //
    
    pchTemp = strchr(pchBuffer, '/');
    cch = pchTemp ? pchTemp - pchBuffer : strlen(pchBuffer);
    strcpy(pchBuffer + cch, "://");
    cch += 3;

    //
    // Now get host name
    //
    
    if (!(*pfnInfo)(
            pvSrvContext, 
            SVRINFO_HOST, 
            pchBuffer + cch, 
            SVRTRI_BUFSIZE - cch))
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    cch = strlen(pchBuffer);
    pchBuffer[cch] = '/';
    cch++;

    //
    // Finally get virtual path
    //
    
    if (!(*pfnInfo)(
            pvSrvContext, 
            SVRINFO_PATH, 
            pchBuffer + cch, 
            SVRTRI_BUFSIZE - cch))
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    pcstrInURL->Init(pchBuffer, -1);

Cleanup:
    RRETURN(hr);
}


HRESULT
RetrieveDocument(TCHAR *pchFileName, IDispatch *pDisp, CDocSvr **ppDoc)
{
    HRESULT     hr = S_OK;
    MSG         msg;
    IUnknown *  pUnk = NULL;
    CDocSvr *   pDoc;
    CDocSvr *   pDocSvrToClone = NULL;
    IUnknown *  pUnk2 = NULL;
    BOOL        fAdd = FALSE;
    
    hr = THR(CoCreateInstance(
            CLSID_HTMLServerDoc,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IUnknown,
            (void **)&pUnk));
    if (hr)
        goto Cleanup;
    
    hr = THR(pUnk->QueryInterface(CLSID_HTMLServerDoc, (void **)&pDoc));
    if (hr)
        goto Cleanup;

    *ppDoc = pDoc;
    pUnk = NULL;        // Transfer ref over to *ppDoc
    
    //
    // Set up the doc with the initial settings.
    //
    
    pDoc->SetLoadfFromPrefs();
    pDoc->_fGotAmbientDlcontrol = TRUE;
    pDoc->_dwLoadf = 
                DLCTL_NO_SCRIPTS | 
                DLCTL_NO_JAVA |
                DLCTL_NO_RUNACTIVEXCTLS |
                DLCTL_NO_DLACTIVEXCTLS |
                DLCTL_NO_FRAMEDOWNLOAD |
                DLCTL_NO_CLIENTPULL |
                DLCTL_SILENT;
    pDoc->_fNoFixupURLsOnPaste = TRUE;
    
    if (pDisp)
    {
        pDoc->_pDispSvr = pDisp;
        pDisp->AddRef();
    }

#if DBG==1 || defined(PERFTAGS)
    if (!IsPerfDbgEnabled(tagCDocSvrNoClone))
#endif
    {
        GetServerDoc(pchFileName, &pDocSvrToClone);
    }

    if (!pDocSvrToClone)
    {
        //
        // Didn't find the requested document in the cache.  Create it 
        // and put it into the cache.
        //
        
        hr = THR(CoCreateInstance(
                CLSID_HTMLServerDoc,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IUnknown,
                (void **)&pUnk2));
        if (hr)
            goto Cleanup;
        
        hr = THR(pUnk2->QueryInterface(
                CLSID_HTMLServerDoc, (void **)&pDocSvrToClone));
        if (hr)
            goto Cleanup;

        //
        // Set up the doc with the initial settings.
        //
        
        pDocSvrToClone->SetLoadfFromPrefs();
        pDocSvrToClone->_fGotAmbientDlcontrol = TRUE;
        pDocSvrToClone->_dwLoadf = pDoc->_dwLoadf | DLCTL_NO_BEHAVIORS;
        pDocSvrToClone->_fNoFixupURLsOnPaste = TRUE;
    
        //
        // Now load the document with this file.
        //

        hr = THR(pDocSvrToClone->Load(pchFileName, 0));
        if (hr)
            goto Cleanup;
            
        //
        // Push a loop till we're done.  This api is synchronous.
        //
        
        while (pDocSvrToClone->_pPrimaryMarkup->LoadStatus() < LOADSTATUS_DONE)
        {
            ::GetMessage(&msg, NULL, 0, 0);
            ::TranslateMessage(&msg);
            ::DispatchMessage(&msg);
        }

#if DBG==1 || defined(PERFTAGS)
        if (!IsPerfDbgEnabled(tagCDocSvrNoClone))
#endif
        {
            fAdd = TRUE;
        }
    }
    
    Assert(pDocSvrToClone);
    hr = THR(pDocSvrToClone->Clone(pDoc));
    if (hr)
        goto Cleanup;

    if (fAdd)
    {
        hr = THR(AddServerDoc(&pDocSvrToClone));
        if (hr)
            goto Cleanup;
    }

Cleanup:
    ReleaseInterface(pUnk);
    ReleaseInterface(pUnk2);
    RRETURN(hr);
}

void WINAPI
SvrTri_ClearCache()
{
    extern DWORD g_dwTls;
    CPtrAry<CDocSvr *> *pary;
    
    if (!TlsGetValue(g_dwTls))
        return;

    pary = TLS(paryDocSvr);
    if (pary)
    {
        TLS(paryDocSvr) = NULL;
        pary->ReleaseAll();
        delete pary;
    }
}


BOOL WINAPI
SvrTri_GetDLText(
    VOID *pvSrvContext,                // [in] Server Context
    DWORD dwUA,                        // [in] User Agent
    CHAR *pchFileName,                 // [in] Physical file name of htm file
    IDispatch *pDisp,                  // [in] OA 'Server' object for scripting
    PFN_SVR_GETINFO_CALLBACK pfnInfo,  // [in] GetInfo callback
    PFN_SVR_MAPPER_CALLBACK pfnMapper, // [in] Mapper callback
    PFN_SVR_WRITER_CALLBACK pfnWriter, // [in] Writer callback
    DWORD *rgdwUAEquiv,                // [in, out] Array of ua equivalences
    DWORD cUAEquivMax,                 // [in] Size of array of ua equiv
    DWORD *pcUAEquiv                   // [out] # of UA Equivalencies filled in
    )
{
    if (pcUAEquiv)
    {
        *pcUAEquiv = 0;
    }
    
    if (dwUA >= USERAGENT_IE5)
        return TRUE;

    CEnsureThreadState ets;
    if (FAILED(ets._hr))
        return FALSE;
        
    HRESULT     hr = S_OK;
    CDocSvr *   pDoc = NULL;
    CStrInW     cstrInFile(pchFileName);

    CoInitialize(NULL);

    //
    // Retrieve the document first.
    //

    hr = THR(RetrieveDocument(cstrInFile, pDisp, &pDoc));
    if (hr)
        goto Cleanup;
        
    //
    // Now write it out the contents of pDoc.
    //

    if (pfnWriter)
    {
        hr = THR(pDoc->DoSave(pvSrvContext, pfnWriter));
        if (hr)
            goto Cleanup;
    }
    
Cleanup:
    if (pDoc)
    {
        pDoc->Release();
    }
    CoUninitialize();
        
    return hr ? FALSE : TRUE;
}


BEGIN_TEAROFF_TABLE_(CDocSvr, IServiceProvider)
        TEAROFF_METHOD(CDocSvr, QueryService, queryservice, (REFGUID guidService, REFIID riid, void **ppvObject))
END_TEAROFF_TABLE()

//+------------------------------------------------------------------------
//
//  Member:     CreateServerDoc
//
//  Synopsis:   Creates a new server-side doc instance.
//
//  Arguments:  pUnkOuter   Outer unknown
//
//-------------------------------------------------------------------------

CBase *
CreateServerDoc(IUnknown * pUnkOuter)
{
    CBase * pBase;

    Assert(!pUnkOuter);
    pBase = new CDocSvr;
    return(pBase);
}


//+---------------------------------------------------------------
//
//  Member:     CDocSvr::PrivateQueryInterface
//
//  Synopsis:   QueryInterface on our private unknown
//
//---------------------------------------------------------------

HRESULT
CDocSvr::PrivateQueryInterface(REFIID riid, void **ppv)
{
    if (riid == CLSID_HTMLServerDoc)
    {
        *ppv = this;
        return S_OK;
    }

    return super::PrivateQueryInterface(riid, ppv);
}


//+---------------------------------------------------------------
//
//  Member:     CDocSvr::Passivate
//
//  Synopsis:   First stage destruction. 
//
//---------------------------------------------------------------

void
CDocSvr::Passivate()
{
    ClearInterface(&_pDispSvr);
    super::Passivate();
}


//+---------------------------------------------------------------
//
//  Member:     CDocSvr::DoSave
//
//  Synopsis:   Save the doc out. 
//
//---------------------------------------------------------------

HRESULT
CDocSvr::DoSave(void *pvSrvContext, PFN_SVR_WRITER_CALLBACK pfnWriter)
{
    HRESULT         hr = S_OK;
    IStream *       pStm = NULL;
    ULARGE_INTEGER  luZero = {0, 0};
    LARGE_INTEGER   lZero =  {0, 0};
    TCHAR           achFileName[MAX_PATH];
    DWORD           dwRet;
    BYTE            pBuf[SVRTRI_BUFSIZE];
    ULONG           cbReal = 0;

#if 0    
    Assert(_pPrimaryMarkup->_LoadStatus == LOADSTATUS_DONE);
#endif

    //
    // TODO: Need to fire some event here maybe?
    //
        
    if (!GetTempFileName(_T("tri"), 0, achFileName))
        goto Cleanup;

    hr = THR(CreateStreamOnFile(
             achFileName,
             STGM_READWRITE | STGM_SHARE_DENY_WRITE |
                     STGM_CREATE | STGM_DELETEONRELEASE,
             &pStm));
    if (hr)
        goto Cleanup;

    hr = THR(pStm->SetSize(luZero));
    if (hr)
        goto Cleanup;

    hr = THR(SaveToStream(pStm, WBF_FORMATTED, GetCodePage()));
    if (hr)
        goto Cleanup;

    hr = THR(pStm->Seek(lZero, STREAM_SEEK_SET, NULL));
    if (hr)
        goto Cleanup;

    for (;;)
    {
        hr = THR_NOTRACE(pStm->Read(pBuf, SVRTRI_BUFSIZE, &cbReal));
        if (!cbReal || hr)
            break;
            
        (*pfnWriter)(pvSrvContext, pBuf, cbReal);
    }

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------
//
//  Member:     CDocSvr::QueryService
//
//  Synopsis:   Override of super's QueryService.  
//
//---------------------------------------------------------------

HRESULT
CDocSvr::QueryService(REFGUID guidService, REFIID riid, void **ppv)
{
    HRESULT hr;
    
    hr = THR_NOTRACE(super::QueryService(guidService, riid, ppv));
    if (hr == E_NOINTERFACE)
    {
        if (_pDispSvr && guidService == SID_SServerOM)
        {
            hr = THR_NOTRACE(_pDispSvr->QueryInterface(riid, ppv));
        }
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------
//
//  Member:     CDocSvr::Clone
//
//  Synopsis:   Clones this document and outputs a new one.  
//              Assumption is that the new document is empty.
//
//---------------------------------------------------------------

HRESULT
CDocSvr::Clone(CDocSvr *pDoc)
{
    HRESULT             hr;
    CProgSink *         pProgSink = NULL;
    CDwnDoc *           pDwnDoc = NULL;
    
    pDwnDoc = new CDwnDoc;
    if (pDwnDoc == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    pDoc->_pDwnDoc = pDwnDoc;
    pDwnDoc->SetDoc(pDoc);
    pDwnDoc->SetBindf(_pDwnDoc->GetBindf());
    pDwnDoc->SetDocBindf(_pDwnDoc->GetDocBindf());
    pDwnDoc->SetDownf(_pDwnDoc->GetDownf());
    pDwnDoc->SetLoadf(_pDwnDoc->GetLoadf());
    pDwnDoc->SetRefresh(_pDwnDoc->GetRefresh());
    pDwnDoc->SetDocCodePage(_pDwnDoc->GetDocCodePage());
    pDwnDoc->SetURLCodePage(_pDwnDoc->GetURLCodePage());
    hr = THR(pDwnDoc->SetAcceptLanguage(_pDwnDoc->GetAcceptLanguage()));
    if (hr)
        goto Cleanup;
    hr = THR(pDwnDoc->SetUserAgent(_pDwnDoc->GetUserAgent()));
    if (hr)
        goto Cleanup;
    hr = THR(pDwnDoc->SetDocReferer(_pDwnDoc->GetDocReferer()));
    if (hr)
        goto Cleanup;
    hr = THR(pDwnDoc->SetSubReferer(_pDwnDoc->GetSubReferer()));
    if (hr)
        goto Cleanup;
    
    pProgSink = new CProgSink(pDoc, pDoc->_pPrimaryMarkup);
    if (pProgSink == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(pProgSink->Init());
    if (hr)
        goto Cleanup;

    Assert(!pDoc->_pPrimaryMarkup->_pProgSink);
    pDoc->_pPrimaryMarkup->_pProgSink = pProgSink;
    pProgSink = NULL;   // Transfer ref over.

    {
        CDoc * pDocSource = _pPrimaryMarkup->Doc();
        CMarkupPointer mpSourceBegin( pDocSource ), mpSourceEnd( pDocSource ), mpTarget( pDoc );

        hr = THR( mpSourceBegin.MoveToContainer( _pPrimaryMarkup, TRUE ) );
        if (hr)
            goto Cleanup;
        hr = THR( mpSourceEnd.MoveToContainer( _pPrimaryMarkup, FALSE ) );
        if (hr)
            goto Cleanup;
        hr = THR( mpTarget.MoveToContainer( pDoc->_pPrimaryMarkup, TRUE ) );
        if (hr)
            goto Cleanup;

        hr = THR( _pPrimaryMarkup->Doc()->Copy( & mpSourceBegin, & mpSourceEnd, & mpTarget ) );
        if (hr)
            goto Cleanup;
    }

    pDoc->PeerDequeueTasks(0);
    
Cleanup:
    if (pProgSink)
    {
        pProgSink->Release();
    }
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\omdoc.cxx ===
//+------------------------------------------------------------------------
//
//  File:       OMDOC.CXX
//
//  Contents:   OmDocument
//
//  Classes:    COmDocument
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx"
#endif

#ifndef X_CONNECT_HXX_
#define X_CONNECT_HXX_
#include "connect.hxx"
#endif

IMPLEMENT_SUBOBJECT_IUNKNOWN(COmDocument, CDoc, Doc, _OmDocument)


//+-------------------------------------------------------------------------
//
//  Method:     COmDocument::QueryInterface
//
//--------------------------------------------------------------------------

HRESULT
COmDocument::QueryInterface(REFIID iid, void **ppv)
{
    HRESULT      hr = S_OK;
    const void * apfn = NULL;
    void *       pv = NULL;
    const IID * const * apIID = NULL;
    extern const IID * const g_apIID_IDispatchEx[];

    *ppv = NULL;

    if (!IsMyParentAlive())
    {
        RRETURN(E_UNEXPECTED);
    }
    else if (iid == IID_IProvideMultipleClassInfo ||
        iid == IID_IProvideClassInfo ||
        iid == IID_IProvideClassInfo2)
    {
        pv = Doc();
        apfn = CDoc::s_apfnIProvideMultipleClassInfo;
    }
    else if (iid == IID_IDispatchEx || iid == IID_IDispatch)
    {
        apIID = g_apIID_IDispatchEx;
        pv = (IDispatchEx *)Doc();
        apfn = *(void **)pv;
    }
    else if (iid == IID_IHTMLDocument ||
        iid == IID_IHTMLDocument2)
    {
        pv = (IHTMLDocument2 *)Doc();
        apfn = *(void **)pv;
    }
    else if (iid == IID_IConnectionPointContainer)
    {
        *((IConnectionPointContainer **)ppv) = new CConnectionPointContainer(Doc(), this);
        if (!*ppv)
            RRETURN(E_OUTOFMEMORY);
    }
    else if (iid == IID_IUnknown)
    {
        *ppv = (IUnknown *)this;
    }
    else if (iid == IID_IMarkupServices)
    {
        pv = Doc();
        apfn = CDoc::s_apfnIMarkupServices;
    }
    else if (iid == IID_IHTMLViewServices)
    {
        pv = Doc();
        apfn = CDoc::s_apfnIHTMLViewServices;
    }
#if DBG == 1
    else if ( iid == IID_IEditDebugServices )
    {
        pv = Doc();
        apfn = CDoc::s_apfnIEditDebugServices;        
    }
#endif
    else if (iid == IID_IServiceProvider )
    {
        pv = Doc();
        apfn = CDoc::s_apfnIServiceProvider;
    }
    else if (iid == IID_IOleWindow)
    {
        pv = Doc();
        apfn = CDoc::s_apfnIOleInPlaceObjectWindowless;
    }
    else if (iid == IID_IOleCommandTarget)
    {
        pv = Doc();
        apfn = CDoc::s_apfnIOleCommandTarget;
    }
    else
    {
        RRETURN(E_NOINTERFACE);
    }

    if (pv)
    {
        Assert(apfn);
        hr = THR(CreateTearOffThunk(
                pv, 
                apfn, 
                NULL, 
                ppv, 
                (IUnknown *)this, 
                *(void **)(IUnknown *)this,
                QI_MASK | ADDREF_MASK | RELEASE_MASK,
                apIID));
        if (hr)
            RRETURN(hr);
    }

    Assert(*ppv);
    ((IUnknown *)*ppv)->AddRef();

    DbgTrackItf(iid, "COmDocument", FALSE, ppv);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\optshold.cxx ===
//=================================================================
//
//   File:      optshold.cxx
//
//  Contents:   COptionsHolder class
//
//  Classes:    COptionsHolder
//              CFontNameOptions
//              CFontSizeOptions
//
//=================================================================

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx"
#endif

#ifndef X_OPTSHOLD_HXX_
#define X_OPTSHOLD_HXX_
#include "optshold.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_UWININET_H_
#define X_UWININET_H_
#include <uwininet.h>
#endif

#define _cxx_
#include "optshold.hdl"

MtDefine(COptionsHolder, ObjectModel, "COptionsHolder")
MtDefine(COptionsHolder_aryFontSizeObjects_pv, COptionsHolder, "COptionsHolder::_aryFontSizeObjects::_pv")
MtDefine(CFontNameOptions, ObjectModel, "CFontNameOptions")
MtDefine(CFontNameOptions_aryFontNames_pv, CFontNameOptions, "CFontNameOptions::_aryFontNames::_pv")
MtDefine(CFontSizeOptions, ObjectModel, "CFontSizeOptions")
MtDefine(CFontSizeOptions_aryFontSizes_pv, CFontSizeOptions, "CFontSizeOptions::_aryFontSize::_pv")

#define  START_OF_SAMPLE_STRINGS    0x0700

extern CGlobalCriticalSection   g_csFile;
extern TCHAR                    g_achSavePath[];
extern BSTR                     g_bstrFindText;

HRESULT
SetFindText(LPCTSTR bstr)
{
    LOCK_GLOBALS;

    FormsFreeString(g_bstrFindText);
    g_bstrFindText = NULL;
    RRETURN(FormsAllocString(bstr, &g_bstrFindText));
}


//+-------------------------------------------------------------------
//
//  Callbacks:   GetFont*Proc
//
//  These procedures are called by the EnumFontFamilies and EnumFont calls.
//  It fills the combobox with the font facename and the size
//
//--------------------------------------------------------------------

int CALLBACK
GetFontNameProc(LOGFONT FAR    * lplf,
                TEXTMETRIC FAR * lptm,
                int              iFontType,
                LPARAM           lParam)
{
    // Do not show vertical fonts
    if (lParam && lplf->lfFaceName[0] != _T('@'))
        ((CFontNameOptions *)lParam)->AddName(lplf->lfFaceName);

    return TRUE;
}

int CALLBACK
GetFontSizeProc(LOGFONT FAR *    lplf,
                TEXTMETRIC FAR * lptm,
                int              iFontType,
                LPARAM           lParam)
{
    if (lParam)
       ((CFontSizeOptions *)lParam)->AddSize(lplf->lfHeight);

    return TRUE;
}

//+----------------------------------------------------------------
//
//  member : classdesc
//
//  Synopsis : CBase Class Descriptor Structure
//
//+----------------------------------------------------------------

const CBase::CLASSDESC COptionsHolder::s_classdesc =
{
    &CLSID_HTMLDocument,            // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                           // _pcpi
    0,                              // _dwFlags
    &IID_IHTMLOptionsHolder,        // _piidDispinterface
    &s_apHdlDescs,                  // _apHdlDesc
};


//+----------------------------------------------------------------
//
//  member : CTOR
//
//+----------------------------------------------------------------

COptionsHolder::COptionsHolder(CWindow * pWindow) : super(), _pWindow(pWindow)
{
    Assert(pWindow);

    _pWindow->AddRef();
    _pFontNameObj=NULL;

    VariantInit(&_execArg);
    _hParentWnd = NULL;
}

//+----------------------------------------------------------------
//
//  member : DTOR
//
//+----------------------------------------------------------------

COptionsHolder::~COptionsHolder()
{
    _aryFontSizeObjects.ReleaseAll();

    _pWindow->Release();
    ReleaseInterface(_pFontNameObj);

    VariantClear(&_execArg);
}

void
COptionsHolder::Passivate()
{
    IGNORE_HR(SetFindText(GetAAfindText()));

    super::Passivate();
}


//+---------------------------------------------------------------
//
//  Member  : COptionsHolder::PrivateQueryInterface
//
//  Sysnopsis : Vanilla implementation for this class
//
//----------------------------------------------------------------

HRESULT
COptionsHolder::PrivateQueryInterface(REFIID iid, void **ppv)
{
    *ppv = NULL;
    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_INHERITS(this, IDispatch)
        QI_TEAROFF(this, IObjectIdentity, NULL)
    default:
        if (iid == IID_IHTMLOptionsHolder)
        {
           *ppv = (IHTMLOptionsHolder *) this;
        }
    }

    if (*ppv)
    {
        ((IUnknown*)*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}


//+----------------------------------------------------------------
//
//  member : get_document
//
//  Synopsis : IHTMLOptionsHolder property. returns the document
//      member
//
//+----------------------------------------------------------------

HRESULT
COptionsHolder::get_document(IHTMLDocument2 ** ppDocDisp)
{
    HRESULT hr = S_OK;

    if (!ppDocDisp)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppDocDisp = NULL;

    hr = THR_NOTRACE(_pWindow->Document()->QueryInterface(IID_IHTMLDocument2,
                                            (void**) ppDocDisp));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_unsecuredWindowOfDocument
//
//  Synopsis : IHTMLOptionsHolder property. returns the unsecured
//              window of the document
//
//+----------------------------------------------------------------

HRESULT
COptionsHolder::get_unsecuredWindowOfDocument(IHTMLWindow2 ** ppDocDisp)
{
    HRESULT         hr = S_OK;
    CWindow *       pWindow = NULL;

    if (!ppDocDisp)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    pWindow = _pWindow;
    Assert(pWindow);

    hr = THR_NOTRACE(pWindow->QueryInterface(IID_IHTMLWindow2,
                                            (void**)ppDocDisp));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : fonts
//
//  Synopsis : IHTMLOptionsHolder Property. returns an Ole collection of
//      BSTR of the available fonts
//
//+----------------------------------------------------------------

HRESULT
COptionsHolder::get_fonts(IHTMLFontNamesCollection ** ppFontCollection)
{
    HRESULT hr = S_OK;
    HWND    hWndInPlace;
    HDC     hdc;
    LOGFONT lf;

    if (!ppFontCollection)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppFontCollection = NULL;
    memset(&lf, 0, sizeof(LOGFONT));
    lf.lfCharSet = DEFAULT_CHARSET;

    // make sure we've got a font options collection
    if (!_pFontNameObj)
    {
        _pFontNameObj = new CFontNameOptions();
        if (!_pFontNameObj)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        _pFontNameObj->SetSize(0);

        // load it with the current system fonts
        _pWindow->Doc()->GetWindow(&hWndInPlace);

        hdc = GetDC(hWndInPlace);
        if (hdc)
        {
            EnumFontFamiliesEx(hdc,
                               &lf,
                               (FONTENUMPROC) GetFontNameProc,
                               (LPARAM)_pFontNameObj,
                               NULL);
            ReleaseDC(hWndInPlace, hdc);
        }
        else
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }

    // QI for an interface to return
    hr = THR_NOTRACE(_pFontNameObj->QueryInterface(
                                    IID_IHTMLFontNamesCollection,
                                    (void**)ppFontCollection));

    // We keep an additional ref because we cache the name collection obj

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : secureProtocolInfo
//
//  Synopsis : IHTMLOptionsHolder Property. returns a BSTR which 
//      describes the secure connection info. 
//      Empty string if current connection is insecure
//+----------------------------------------------------------------

HRESULT
COptionsHolder::get_secureConnectionInfo(BSTR * p)
{
    HRESULT hr = S_OK;
    BOOL bSuccess = FALSE;

    if ( p == NULL)
    {
        return E_POINTER;
    }
                
    if (CMarkup::HtmCtxHelper(_pWindow->_pMarkup) != NULL)
    {
        INTERNET_SECURITY_CONNECTION_INFO * pSCI = NULL;
        CMarkup::HtmCtxHelper(_pWindow->_pMarkup)->GetSecConInfo(&pSCI);

        if (!pSCI)
        {
            // Without benefit of INTERNET_SECURITY_CONNECTION_INFO, report "Encrypted."
            // if we believe the original source of the page to be secure
            
            TCHAR achMessage[FORMS_BUFLEN + 1];
            SSL_SECURITY_STATE sss;
            SSL_PROMPT_STATE sps;

            _pWindow->Doc()->GetRootSslState(FALSE, &sss, &sps);

            if (sss > SSL_SECURITY_MIXED)
            {
                if (!LoadString(GetResourceHInst(), IDS_SECURESOURCE, achMessage, ARRAY_SIZE(achMessage)))
                    return E_FAIL;

                *p = SysAllocString(achMessage);
                if (*p == NULL)
                {
                    hr = E_OUTOFMEMORY;
                }
                else
                {
                    bSuccess = TRUE;
                }
            }
        }
        
        if (pSCI != NULL && pSCI->fSecure)
        {
            // These are way beyond the sizes required for protocol & algorithm names (SSL 2.0, RC4, ...)
            // Assert's added in case the strings ever exceed the limit. 
            TCHAR achProtocol[32]; 
            TCHAR achAlgCipher[64];
            TCHAR achAlgExch[64];
            DWORD dwProtocol = ARRAY_SIZE(achProtocol);;
            DWORD dwAlgCipher = ARRAY_SIZE(achAlgCipher);
            DWORD dwAlgExch = ARRAY_SIZE(achAlgExch);
             
            if ( InternetSecurityProtocolToString(pSCI->dwProtocol, achProtocol, &dwProtocol, 0) && 
                 InternetAlgIdToString(pSCI->aiCipher, achAlgCipher, &dwAlgCipher, 0) &&
                 InternetAlgIdToString(pSCI->aiExch, achAlgExch, &dwAlgExch, 0)
               )
            {
                int idCipherQuality;
                
                if ( pSCI->dwCipherStrength < 56 )
                    idCipherQuality = IDS_SECURE_LOW;
                else if ( pSCI->dwCipherStrength < 128 )
                    idCipherQuality = IDS_SECURE_MEDIUM;
                else
                    idCipherQuality = IDS_SECURE_HIGH;
                
                TCHAR achSecurityInfo[256]; // This is way beyond what we can handle. 
                                
                hr = THR(Format(0,
                                achSecurityInfo,
                                ARRAY_SIZE(achSecurityInfo),
                                MAKEINTRESOURCE(IDS_SECURECONNECTIONINFO),
                                achProtocol,
                                achAlgCipher,
                                pSCI->dwCipherStrength,
                                GetResourceHInst(), idCipherQuality,
                                achAlgExch,
                                pSCI->dwExchStrength
                            ));

                if (SUCCEEDED(hr))
                {
                    *p = SysAllocString(achSecurityInfo);
                    if (*p == NULL)
                    {
                        hr = E_OUTOFMEMORY;
                    }
                    else
                    {
                        bSuccess = TRUE;
                    }
                }
            }
            else
            {
                DWORD dwError = GetLastError();
                // This implies the stack buffers we have allocated are not big enough!!
                Assert(dwError != ERROR_INSUFFICIENT_BUFFER);
                hr = HRESULT_FROM_WIN32(dwError);
            }
        }  /* if the connection was secure */
    } /* if we found a _pHtmCtx */

    // If we failed somewhere along the way. just allocate an empty string and return quietly. 
    if (!bSuccess)
    {
        *p = SysAllocString(_T(""));
        if (*p == NULL)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }                                                                                                                
                                         
    return hr;    
}



//+----------------------------------------------------------------
//
//  member : sizes
//
//  Synopsis : IHTMLOptionsHolder Property. returns an Ole Collecion of
//      longs of the available sizes available for the given font
//
//+----------------------------------------------------------------

HRESULT
COptionsHolder::sizes( BSTR bstrFontName,
                       IHTMLFontSizesCollection ** ppOptsCollection)
{
    HRESULT hr = S_OK;
    HWND    hWndInPlace;
    HDC     hdc;
    CStr    strName;
    long    lIndex;

    if (!ppOptsCollection)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    if (!bstrFontName || !SysStringLen(bstrFontName))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    lIndex = GetObjectLocation(bstrFontName);
    if (lIndex<0)
    {
        // some error happened
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // If we don't have the sizes cached for this font....
    if (lIndex == _aryFontSizeObjects.Size())
    {
        CFontSizeOptions * pfsObject=NULL;

        // add a new one to the list
        hr = THR(_aryFontSizeObjects.EnsureSize(lIndex+1));
        if (hr)
            goto Cleanup;

        pfsObject = new CFontSizeOptions();
        if (!pfsObject)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        pfsObject->_cstrFont.SetBSTR(bstrFontName);
        pfsObject->SetSize(0);

        _pWindow->Doc()->GetWindow(&hWndInPlace);

        hdc = GetDC(hWndInPlace);
        EnumFonts( hdc, pfsObject->_cstrFont,
                   (FONTENUMPROC) GetFontSizeProc,
                   (LPARAM)pfsObject);
        ReleaseDC(hWndInPlace, hdc);

        _aryFontSizeObjects[lIndex] = pfsObject;
    }

        // QI for an interface to return
    hr = THR_NOTRACE(_aryFontSizeObjects[lIndex]->QueryInterface(
                                    IID_IHTMLFontSizesCollection,
                                    (void**)ppOptsCollection));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

//+----------------------------------------------------------------
//
//  member : openfiledlg
//
//  Synopsis : IHTMLOptionsHolder method. bring up open file dialog and 
//              returns the selected filename
//
//+----------------------------------------------------------------

HRESULT
COptionsHolder::openfiledlg( VARIANTARG initFile, VARIANTARG initDir, VARIANTARG filter, VARIANTARG title, BSTR *pathName)
{
    RRETURN(SetErrorInfo(OpenSaveFileDlg(initFile, initDir, filter, title, pathName, FALSE)));
}

//+----------------------------------------------------------------
//
//  member : savefiledlg
//
//  Synopsis : IHTMLOptionsHolder method. bring up save file dialog and 
//              returns the selected filename
//
//+----------------------------------------------------------------

HRESULT
COptionsHolder::savefiledlg( VARIANTARG initFile, VARIANTARG initDir, VARIANTARG filter, VARIANTARG title, BSTR *pathName)
{
    RRETURN(SetErrorInfo(OpenSaveFileDlg(initFile, initDir, filter, title, pathName, TRUE)));
}

//+----------------------------------------------------------------
//
//  member : OpenSaveFileDlg
//
//  Synopsis : IHTMLOptionsHolder method. bring up open or save file dialog and 
//              returns the selected filename
//
//+----------------------------------------------------------------

#define VERIFY_VARARG_4BSTR(arg, var)           \
    switch(V_VT(&arg))                          \
    {                                           \
    case    VT_BSTR:                            \
        var = &arg;                             \
        break;                                  \
    case    VT_BYREF|VT_BSTR:                   \
        var = V_VARIANTREF(&arg);               \
        break;                                  \
    default:                                    \
        var = NULL;                             \
    }

HRESULT
COptionsHolder::OpenSaveFileDlg( VARIANTARG initFile, VARIANTARG initDir, VARIANTARG filter, VARIANTARG title, BSTR *pathName, BOOL fSaveFile)
{
    BOOL            fOK;
    DWORD           dwCommDlgErr;
    VARIANT *       pvarInitFile;
    VARIANT *       pvarInitDir;
    VARIANT *       pvarFilter;
    VARIANT *       pvarTitle;
    OPENFILENAME    ofn;
    HRESULT         hr = E_INVALIDARG;
    HWND            hWndInPlace;
    BSTR            bstrFile = 0;
    TCHAR           *pstrExt;
    TCHAR           achPath[MAX_PATH];

    VERIFY_VARARG_4BSTR(initFile, pvarInitFile);
    VERIFY_VARARG_4BSTR(initDir, pvarInitDir);
    VERIFY_VARARG_4BSTR(filter, pvarFilter);
    VERIFY_VARARG_4BSTR(title, pvarTitle);

    hr = THR(FormsAllocStringLen(NULL, MAX_PATH, &bstrFile));
    if (hr)
    {
        goto Cleanup;
    }

    if (pvarInitFile)
    {
        _tcscpy(bstrFile, V_BSTR(pvarInitFile));
    }
    else
    {
        *bstrFile = _T('\0');
    }

    _pWindow->Doc()->GetWindow(&hWndInPlace);

    Assert(_hParentWnd);
    // Initialize ofn struct
    memset(&ofn, 0, sizeof(ofn));
    ofn.lStructSize     = sizeof(ofn);
    // ofn.hwndOwner       = hWndInPlace;
    ofn.hwndOwner       = _hParentWnd;
    ofn.Flags           =   OFN_FILEMUSTEXIST   |
                            OFN_PATHMUSTEXIST   |
                            OFN_OVERWRITEPROMPT |
                            OFN_HIDEREADONLY    |
                            OFN_NOCHANGEDIR     |
                            OFN_EXPLORER;
                            // no readonly checkbox, per request

    ofn.lpfnHook        = NULL;
    ofn.lpstrFile       = bstrFile;     // file name buffer
    ofn.nMaxFile        = MAX_PATH;     // file name buffer size
    
    if (pvarInitDir)
    {
        ofn.lpstrInitialDir = V_BSTR(pvarInitDir);
    }

    if (pvarFilter)
    {
        BSTR    bstrFilter = V_BSTR(pvarFilter);
        TCHAR   *cp;

        for ( cp = bstrFilter; *cp; cp++ )
        {
            if ( *cp == _T('|') )
            {
                *cp = _T('\0');
            }
        }
        ofn.lpstrFilter = bstrFilter;
    }

    if (pvarTitle)
    {
        ofn.lpstrTitle = V_BSTR(pvarTitle);
    }

    //
    // Find the extension and set the filter index based on what the
    // extension is.  After these loops pstrExt will either be NULL if
    // we didn't find an extension, or will point to the extension starting
    // at the '.'

    pstrExt = bstrFile;
    while (*pstrExt)
        pstrExt++;
    while ( pstrExt > bstrFile )
    {
        if( *pstrExt == _T('.') )
            break;
        pstrExt--;
    }

    if( pstrExt > bstrFile )
    {
        int    iIndex = 0;
        const TCHAR* pSearch = ofn.lpstrFilter;

        while( pSearch )
        {
            if( wcsstr ( pSearch, pstrExt ) )
            {
                ofn.nFilterIndex = (iIndex / 2) + 1;
                ofn.lpstrDefExt = pstrExt + 1;

                // Remove the extension from the file name we pass in
                *pstrExt = _T('\0');

                break;
            }
            pSearch += _tcslen(pSearch);
            if( pSearch[1] == 0 )
                break;

            pSearch++;
            iIndex++;
        }
    }

    {
        LOCK_SECTION(g_csFile);

        _tcscpy(achPath, g_achSavePath);
        ofn.lpstrInitialDir = *achPath ? achPath : NULL;
    }

    DbgMemoryTrackDisable(TRUE);

    // Call function
    fOK = (fSaveFile ? GetSaveFileName : GetOpenFileName)(&ofn);

    DbgMemoryTrackDisable(FALSE);

    if (!fOK)
    {
        FormsFreeString(bstrFile);
        bstrFile = NULL;
#ifndef WINCE
        dwCommDlgErr = CommDlgExtendedError();
        if (dwCommDlgErr)
        {
            hr = HRESULT_FROM_WIN32(dwCommDlgErr);
            goto Cleanup;
        }
        else
        {
            hr = S_OK;
        }
#else //WINCE
        hr = E_FAIL;
#endif //WINCE
    }
    else
    {
        LOCK_SECTION(g_csFile);

        _tcscpy(g_achSavePath, ofn.lpstrFile);
        
        TCHAR * pchShortName =_tcsrchr(g_achSavePath, _T('\\'));

        if (pchShortName)
        {
            *(pchShortName + 1) = 0;
        }
        else
        {
            *g_achSavePath = 0;
        }
        hr = S_OK;
    }

Cleanup:

    *pathName = bstrFile;

    return hr;
}

HRESULT
COptionsHolder::choosecolordlg( VARIANTARG initColor, long *rgbColor)
{
#ifdef WINCE
    return S_OK;
#else
    int             i;
    BOOL            fOK;
    DWORD           dwCommDlgErr;
    CHOOSECOLOR     structCC;
    HRESULT         hr = E_INVALIDARG;
    HWND            hWndInPlace;
    COLORREF        aCColors[16];
    VARIANT *       pvarRGBColor;
    DWORD           dwResult;
    VARIANTARG      varArgTmp;

    hr = THR (VariantChangeTypeSpecial(&varArgTmp, &initColor, VT_I4));
    if (hr)
    {
        pvarRGBColor = NULL;
    }
    else
    {
        if (V_VT(&initColor) & VT_BYREF)
        {
            pvarRGBColor = V_VARIANTREF(&varArgTmp);
        }
        else
        {
            pvarRGBColor = &varArgTmp;
        }
    }

    _pWindow->Doc()->GetWindow(&hWndInPlace);

    for (i = ARRAY_SIZE(aCColors) - 1; i >= 0; i--)
    {
        aCColors[i] = RGB(255, 255, 255);
    }

    // Initialize ofn struct
    memset(&structCC, 0, sizeof(structCC));
    structCC.lStructSize     = sizeof(structCC);
    structCC.hwndOwner       = _hParentWnd;
    structCC.lpCustColors    = aCColors;
    
    if (pvarRGBColor)
    {
        structCC.Flags          = CC_RGBINIT;
        structCC.rgbResult      = V_I4(pvarRGBColor);
        dwResult                = structCC.rgbResult;
    }
    else
    {
        dwResult = RGB(0,0,0);
    }

    // Call function
    fOK = ChooseColor(&structCC);

    if (fOK)
    {
        hr = S_OK;
        dwResult = structCC.rgbResult;
    }
    else
    {
        dwCommDlgErr = CommDlgExtendedError();
        if (dwCommDlgErr)
        {
            hr = HRESULT_FROM_WIN32(dwCommDlgErr);
            goto Cleanup;
        }
        else
        {
            hr = S_OK;
        }
    }

Cleanup:

    *rgbColor = dwResult;

    RRETURN(SetErrorInfo( hr ));
#endif // WINCE
}

HRESULT
COptionsHolder::showSecurityInfo()
{
    HWND    hwnd = _hParentWnd;
    CDoc *  pDoc = _pWindow->Doc();

    if (!_hParentWnd)
        pDoc->GetWindow(&hwnd);
        
    InternetShowSecurityInfoByURL((TCHAR*)CMarkup::GetUrl(_pWindow->Markup()), hwnd);

    RRETURN(SetErrorInfo(S_OK));
}

HRESULT
COptionsHolder::isApartmentModel( IHTMLObjectElement* object, 
                                 VARIANT_BOOL * fApartment)
{
    HRESULT             hr = S_OK;
    IClientSecurity    *pCL = NULL;
    VARIANT_BOOL        vbRetVal = VB_FALSE;
    VARIANT             var;
    IOleCommandTarget  *pCT = NULL;

    VariantInit(&var);

    hr = THR(object->QueryInterface(IID_IOleCommandTarget, (void **) &pCT));
    if (hr)
        goto Cleanup;

    hr = THR(pCT->Exec((GUID *)&CGID_MSHTML, 
                        IDM_GETPUNKCONTROL, 
                        0, 
                        NULL, 
                        &var));
    if (hr)
        goto Cleanup;

    //
    //  QI IClientSecurity returns S_OK if the control is NOT 
    //  apartment model!
    //
    hr = var.punkVal->QueryInterface(IID_IClientSecurity, (void **) &pCL);
    if (!hr)
    {
        hr = S_OK;      // It really is OK.
        goto Cleanup;
    }

    vbRetVal = VB_TRUE;

Cleanup:
    ReleaseInterface(pCL);
    ReleaseInterface(pCT);

    *fApartment = vbRetVal;

    RRETURN( SetErrorInfo( S_OK ) );
}


HRESULT
COptionsHolder::getCharset(BSTR fontName, long * charset)
{
    HRESULT         hr = S_OK;
    LOGFONT         lf;
    UINT            uintResult = 0;
    HDC             hdc = NULL;
    HFONT           hfont = NULL, hfontOld = NULL;

    if (!charset)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *charset = 0;

    hdc = GetDC(NULL);
    if (!hdc)
        goto Cleanup;

    memset(&lf, 0, sizeof(lf));

    lf.lfCharSet = DEFAULT_CHARSET;
    lf.lfOutPrecision = OUT_DEFAULT_PRECIS;
    lf.lfClipPrecision = CLIP_DEFAULT_PRECIS;
    lf.lfQuality  = DEFAULT_QUALITY;
    lf.lfPitchAndFamily = DEFAULT_PITCH | FF_DONTCARE;
    
    // If fontName is too long, we have to shorten it.
    _tcsncpy(lf.lfFaceName, fontName, LF_FACESIZE - 1);
    lf.lfFaceName[LF_FACESIZE - 1] = 0;
    
    hfont = CreateFontIndirect(&lf);
    if (!hfont)
        goto Cleanup;

    hfontOld = (HFONT) SelectObject(hdc, hfont);
    if (!hfontOld)
        goto Cleanup;

    uintResult = GetTextCharset(hdc);

    *charset = uintResult;

Cleanup:

    if (hfontOld)
    {
        SelectObject(hdc, hfontOld);
    }

    if (hfont)
    {
        DeleteObject(hfont);
    }
    
    if (hdc)
    {
        ReleaseDC(NULL, hdc);
    }

    RRETURN( SetErrorInfo( hr ) );
}



//+----------------------------------------------------------------
//
//  Member GetObjetLocation
//
//  Synopsis : helper function for sizes. this will search the
//      pointer array of size collections to see if this one
//      already exists. if not, size() is returned.
//
//-----------------------------------------------------------------

long
COptionsHolder::GetObjectLocation(BSTR strTargetFontName)
{
    long    lSize = _aryFontSizeObjects.Size();
    long    l;

    // Look for a free slot in the non-reserved part of the cache.
    for (l=0; l < lSize; ++l)
    {
        if (!FormsStringICmp(_aryFontSizeObjects[l]->_cstrFont,
                             strTargetFontName))
            break;
    }

    return l;
}


HRESULT
STDMETHODCALLTYPE COptionsHolder::put_execArg(VARIANT varExecArg)
{
    VariantClear(&_execArg);
    RRETURN(SetErrorInfo(VariantCopy(&_execArg, &varExecArg)));
}

HRESULT 
STDMETHODCALLTYPE COptionsHolder::get_execArg(VARIANT *pexecArg)
{
    HRESULT     hr;

    if (pexecArg == NULL)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = VariantCopy(pexecArg, &_execArg);

Cleanup:
    RRETURN(SetErrorInfo(hr));
}




//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//      CFontNameOptions
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+----------------------------------------------------------------
//
//  member : classdesc
//
//+----------------------------------------------------------------

const CBase::CLASSDESC CFontNameOptions::s_classdesc =
{
    &CLSID_HTMLDocument,             // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                           // _pcpi
    0,                              // _dwFlags
    &IID_IHTMLFontNamesCollection,  // _piidDispinterface
    &s_apHdlDescs,                  // _apHdlDesc
};


//+----------------------------------------------------------------
//
//  member : DTOR
//
//+----------------------------------------------------------------

CFontNameOptions::~CFontNameOptions()
{
    CStr *  pcstr;
    long    i;

    for (i = _aryFontNames.Size(), pcstr = _aryFontNames;
         i > 0;
         i--, pcstr++)
    {
        pcstr->Free();
    }

    _aryFontNames.DeleteAll();
}


//+---------------------------------------------------------------
//
//  Member  : CFontNameOptions::PrivateQueryInterface
//
//  Sysnopsis : Vanilla implementation for this class
//
//----------------------------------------------------------------

HRESULT
CFontNameOptions::PrivateQueryInterface(REFIID iid, void **ppv)
{
    *ppv = NULL;
    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_INHERITS(this, IDispatch)
        QI_TEAROFF(this, IObjectIdentity, NULL)
    default:
        if (iid == IID_IHTMLFontNamesCollection)
        {
           *ppv = (IHTMLFontNamesCollection *) this;
        }
    }

    if (*ppv)
    {
        ((IUnknown*)*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

//+---------------------------------------------------------------
//
//  Member  : AddName
//
//  Sysnopsis : Helper function that takes a font name from the font
//      callback and adds it to the cdataary.
//
//----------------------------------------------------------------

HRESULT
CFontNameOptions::AddName(TCHAR * strFontName)
{
    HRESULT hr = S_OK;
    long    lIndex;
    long    lSizeAry = _aryFontNames.Size();

    // does this name already exist in the list
    for (lIndex = 0; lIndex < lSizeAry ; lIndex++)
    {
        if (_tcsiequal(strFontName, _aryFontNames[lIndex]))
            break;
    }

    // Not found, so add element to array.
    if (lIndex == lSizeAry)
    {
        CStr *pcstr;

        hr = THR(_aryFontNames.AppendIndirect(NULL, &pcstr));
        if (hr)
            goto Cleanup;

        hr = pcstr->Set(strFontName);
        if (hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------
//
//  Member  : CFontNameOptions::length
//
//  Sysnopsis : IHTMLFontNameCollection interface method
//
//----------------------------------------------------------------

HRESULT
CFontNameOptions::get_length(long * pLength)
{
    HRESULT hr = S_OK;

    if (!pLength)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pLength = _aryFontNames.Size();

Cleanup:
    RRETURN( SetErrorInfo( hr ));

}

//+---------------------------------------------------------------
//
//  Member  : CFontNameOptions::item
//
//  Sysnopsis : IHTMLFontNameCollection interface method
//
//----------------------------------------------------------------

HRESULT
CFontNameOptions::item(long lIndex, BSTR * pstrName)
{
    HRESULT   hr   = S_OK;

    if (!pstrName)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    if (lIndex < 0 || lIndex >= _aryFontNames.Size())
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = _aryFontNames[lIndex].AllocBSTR(pstrName);

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

//+---------------------------------------------------------------
//
//  Member  : CFontNameOptions::_newEnum
//
//  Sysnopsis :
//
//----------------------------------------------------------------

HRESULT
CFontNameOptions::get__newEnum(IUnknown ** ppEnum)
{
    HRESULT hr = S_OK;

    if (!ppEnum)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppEnum = NULL;

    hr = THR(_aryFontNames.EnumVARIANT(VT_BSTR,
                                (IEnumVARIANT**)ppEnum,
                                FALSE,
                                FALSE));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//      CFontSizeOptions
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+----------------------------------------------------------------
//
//  member : classdesc
//
//+----------------------------------------------------------------

const CBase::CLASSDESC CFontSizeOptions::s_classdesc =
{
    &CLSID_HTMLDocument,             // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                           // _pcpi
    0,                              // _dwFlags
    &IID_IHTMLFontSizesCollection,  // _piidDispinterface
    &s_apHdlDescs,                      // _apHdlDesc
};

//+---------------------------------------------------------------
//
//  Member  : CFontNameOptions::PrivateQueryInterface
//
//  Sysnopsis : Vanilla implementation for this class
//
//----------------------------------------------------------------

HRESULT
CFontSizeOptions::PrivateQueryInterface(REFIID iid, void **ppv)
{
    *ppv = NULL;
    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_INHERITS(this, IDispatch)
        QI_TEAROFF(this, IObjectIdentity, NULL)
    default:
        if (iid == IID_IHTMLFontSizesCollection)
        {
           *ppv = (IHTMLFontSizesCollection *) this;
        }
    }

    if (*ppv)
    {
        ((IUnknown*)*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}


//+---------------------------------------------------------------
//
//  Member  : CFontNameOptions::AddSize
//
//  Sysnopsis : adds the given size to the aryFontSizes
//          in ascending order.
//
//----------------------------------------------------------------
HRESULT
CFontSizeOptions::AddSize(long lFSize)
{
    HRESULT hr = S_OK;
    int     i, value, iSizeAry = _aryFontSizes.Size();

    for (i=0; i<iSizeAry; i++)
    {
        value = _aryFontSizes[i];

        // is it already in the list
        if (lFSize == value)
            goto Cleanup;

        // is it smaller than the thing we're looking at
        if (lFSize < value)
            break;
    }

    // it is not in the list and smaller than the value at index i
    // or i = iSizeAry and we want to tack this at the end.
    hr = THR(_aryFontSizes.Insert(i, lFSize));

Cleanup:
    RRETURN( hr );
}

//+---------------------------------------------------------------
//
//  Member  : CFontSizeOptions::length
//
//  Sysnopsis : IHTMLFONTSizesCollection interface method
//
//----------------------------------------------------------------

HRESULT
CFontSizeOptions::get_length(long * pLength)
{
    HRESULT hr = S_OK;

    if (!pLength)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pLength = _aryFontSizes.Size();

Cleanup:
    RRETURN( SetErrorInfo( hr ));

}

//+---------------------------------------------------------------
//
//  Member  : CFontSizeOptions::item
//
//  Sysnopsis : IHTMLFONTSizesCollection interface method
//
//----------------------------------------------------------------

HRESULT
CFontSizeOptions::item(long lIndex, long *plSize)
{
    HRESULT hr = S_OK;

    if (!plSize)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    if (lIndex < 0 || lIndex >= _aryFontSizes.Size())
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *plSize = _aryFontSizes[lIndex];

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+---------------------------------------------------------------
//
//  Member  : CFontSizeOptions::_newEnum
//
//  Sysnopsis : IHTMLFONTSizesCollection interface method
//
//----------------------------------------------------------------

HRESULT
CFontSizeOptions::get__newEnum(IUnknown ** ppEnum)
{
    HRESULT hr = S_OK;

    if (!ppEnum)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppEnum = NULL;

    hr = THR(_aryFontSizes.EnumVARIANT(VT_I4,
                                (IEnumVARIANT**)ppEnum,
                                FALSE,
                                FALSE));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\peerelem.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_PEER_HXX_
#define X_PEER_HXX_
#include "peer.hxx"
#endif

#ifndef X_PEERMGR_HXX_
#define X_PEERMGR_HXX_
#include "peermgr.hxx"
#endif

#ifndef X_PEERFACT_HXX_
#define X_PEERFACT_HXX_
#include "peerfact.hxx"
#endif

#ifndef X_OLESITE_HXX_
#define X_OLESITE_HXX_
#include "olesite.hxx"
#endif

#ifndef X_ROOTELEM_HXX
#define X_ROOTELEM_HXX
#include "rootelem.hxx"
#endif

#ifndef X_EOBJECT_HXX_
#define X_EOBJECT_HXX_
#include "eobject.hxx"
#endif

#ifndef X_XMLNS_HXX_
#define X_XMLNS_HXX_
#include "xmlns.hxx"
#endif

#ifndef X_PEERXTAG_HXX_
#define X_PEERXTAG_HXX_
#include "peerxtag.hxx"
#endif

#ifndef X_ELEMENTP_HXX_
#define X_ELEMENTP_HXX_
#include "elementp.hxx"
#endif

//////////////////////////////////////////////////////////////////////////////
//
// misc
//
//////////////////////////////////////////////////////////////////////////////

DeclareTag(tagPeerCMarkupProcessPeerTask,      "Peer", "trace CElement::ProcessPeerTask queueing");
DeclareTag(tagPeerIncDecPeerDownloads,      "Peer", "trace CElement::[Inc|Dec]PeerDownloads");

//////////////////////////////////////////////////////////////////////////////
//
// CElement - peer hosting code
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
//  Helper:     TraceProcessPeerTask, DEBUG ONLY helper
//
//----------------------------------------------------------------------------

#if DBG == 1
void
TraceProcessPeerTask(CElement * pElement, BOOL fIdentity, CBehaviorInfo * pCss, LPTSTR pchMsg)
{
    int i, c;

    //if (fIdentity ||
    //    (pCss && pCss->_acstrBehaviorUrls.Size()))
    {
        TraceTag((
            tagPeerCMarkupProcessPeerTask,
            "CElement::ProcessPeerTask, <%ls id = %ls SN = %ld>; %ls:",
            pElement->TagName(), STRVAL(pElement->GetAAid()), pElement->_nSerialNumber, pchMsg));
    }

    if (fIdentity)
        TraceTag((tagPeerCMarkupProcessPeerTask, "         '%ls' identity", STRVAL(pElement->TagName())));

    if (pCss)
    {
        for (i = 0, c = pCss->_acstrBehaviorUrls.TableSize(); i < c; i++)
        {
            TraceTag((tagPeerCMarkupProcessPeerTask, "            '%ls'", STRVAL(pCss->_acstrBehaviorUrls.TableItem(i))));
        }
    }
}
#endif

//+---------------------------------------------------------------------------
//
//  Member: CElement::ProcessPeerTask
//
//----------------------------------------------------------------------------

HRESULT
CElement::ProcessPeerTask(PEERTASK task)

{
    HRESULT         hr = S_OK;
    CDoc *          pDoc = Doc();
    CPeerMgr *      pPeerMgr;

    switch (task)
    {

    case PEERTASK_ENTERTREE_UNSTABLE:
        {
            //+---------------------------------------------------------------------------
            //
            // PEERTASK_ENTERTREE_UNSTABLE
            //
            //----------------------------------------------------------------------------

            Assert (IsInMarkup());

            //
            // identity peer handling
            //

            if (!HasIdentityPeerHolder() && NeedsIdentityPeer(NULL))
            {
                hr = THR(GetFrameOrPrimaryMarkup()->EnqueueIdentityPeerTask(this));
                if (hr)
                    goto Cleanup;
            }

            // Have our new markup tell us when he's done loading.
            if( HasPeerHolder() )
            {
                IGNORE_HR( GetMarkup()->RequestDocEndParse( this ) );
            }


            //
            // optimizations
            //

            BOOL fNeedStableNotifications = ( HasPeerHolder() && GetPeerHolder()->TestFlagMulti(CPeerHolder::NEEDDOCUMENTCONTEXTCHANGE) ) ||
                                            ( HasIdentityPeerHolder() && GetPeerHolder()->_fNotifyOnEnterTree );

            if (!pDoc->AreCssPeersPossible() && !fNeedStableNotifications)
                goto Cleanup;   // done: no need to post the task

            if (GetMarkup()->_fMarkupServicesParsing)
                goto Cleanup;   // done: don't post the task when parsing auxilary markup - the element will be 
                                // spliced into target markup later and that is when we post the task
        
            pPeerMgr = GetPeerMgr();

            if (pPeerMgr && pPeerMgr->IsEnterExitTreeStablePending())
            {
                goto Cleanup;   // done: the task is already pending
            }

            //
            // post the task
            //

            {
                CBehaviorInfo   info(GetFirstBranch());

                // (note that we compute behavior css here only to figure out if we need to
                // queue up the element. That's why we don't compute it when fNeedsIdentityPeer set:
                // in that case we queue it up anyway.)
                hr = THR(ApplyBehaviorCss(&info));
                if (hr)
                    goto Cleanup;

                // needs to do something at a safe moment of time?
                if (info._acstrBehaviorUrls.TableSize() || fNeedStableNotifications)
                {
                    //
                    // post a task to do that
                    //

                    hr = THR(CPeerMgr::EnsurePeerMgr(this, &pPeerMgr));
                    if (hr)
                        goto Cleanup;

                    pPeerMgr->SetEnterExitTreeStablePending(TRUE);

                    AddRef();

                    IGNORE_HR(GetFrameOrPrimaryMarkup()->EnqueuePeerTask(this, PEERTASK_ENTEREXITTREE_STABLE));
#if DBG == 1
                    TraceProcessPeerTask (this, FALSE, &info, _T("ENTERTREE_UNSTABLE"));
#endif
                }

                break;
            }
        }
        break;


    case PEERTASK_EXITTREE_UNSTABLE:
        {
            //+---------------------------------------------------------------------------
            //
            // PEERTASK_EXITTREE_UNSTABLE
            //
            //----------------------------------------------------------------------------

            if (HasPeerHolder())
            {
                pPeerMgr = GetPeerMgr();

                if (pPeerMgr && pPeerMgr->IsEnterExitTreeStablePending())
                    goto Cleanup; // done

                hr = THR(CPeerMgr::EnsurePeerMgr(this, &pPeerMgr));
                if (hr)
                    goto Cleanup;

                pPeerMgr->SetEnterExitTreeStablePending(TRUE);

                AddRef();

                IGNORE_HR(GetFrameOrPrimaryMarkup()->EnqueuePeerTask(this, PEERTASK_ENTEREXITTREE_STABLE));
#if DBG == 1
                TraceProcessPeerTask (this, FALSE, NULL, _T("EXITTREE_UNSTABLE"));
#endif
            }
        }
        break;


    case PEERTASK_ENTEREXITTREE_STABLE:
        {
            //+---------------------------------------------------------------------------
            //
            // PEERTASK_ENTEREXITTREE_STABLE
            //
            //----------------------------------------------------------------------------

#if DBG == 1
            TraceProcessPeerTask (this, FALSE, NULL, _T("ENTEREXITTREE_STABLE"));
#endif

            CBehaviorInfo   info(GetFirstBranch());

            // update peer mgr state and ensure identity peer

            pPeerMgr = GetPeerMgr();

            Assert (pPeerMgr && pPeerMgr->IsEnterExitTreeStablePending());

            pPeerMgr->SetEnterExitTreeStablePending(FALSE);
            CPeerMgr::EnsureDeletePeerMgr(this);

            //
            // process css peers
            //

            if (IsInMarkup())
            {
                //
                // in the tree now
                //

                if (!pDoc->IsShut())
                {
                    hr = THR(ApplyBehaviorCss(&info));
                    if (hr)
                        goto Cleanup;

                    IGNORE_HR(pDoc->AttachPeersCss(this, &info._acstrBehaviorUrls));

                    if (HasPeerHolder())
                    {
                        GetPeerHolder()->HandleEnterTree();
                    }
                }

                Release(); // NOTE that this element may passivate after this release
            }
            else
            {
                //
                // out of the tree now
                //

                ULONG ulElementRefs;

                Assert (!IsInMarkup());

                if (HasPeerHolder() && !GetPeerHolder()->_fNotifyOnEnterTree)
                {
                    GetPeerHolder()->NotifyMulti(BEHAVIOREVENT_DOCUMENTCONTEXTCHANGE);
                }

                if (!pDoc->IsShut())
                {
                    hr = THR(ApplyBehaviorCss(&info));
                    if (hr)
                        goto Cleanup;

                    // because 0 == info._acstrBehaviorUrls, this will cause all css-attached behaviors to be removed
                    IGNORE_HR(pDoc->AttachPeersCss(this, &info._acstrBehaviorUrls));
                }
        
                ulElementRefs = GetObjectRefs() - 1;        // (can't use return value of Release())
                                                            // this should happen after AttachPeersCss
                Release();                                  // NOTE that this element may passivate after this release

                if (ulElementRefs && HasPeerHolder())       // if still has not passivated and has peers
                {                                           // then there is risk of refcount loops
                    CMarkup * oldMarkup = GetWindowedMarkupContext();

                    if (pDoc->IsShut() || oldMarkup->IsPassivated() || oldMarkup->IsPassivating())
                    {
                        DelPeerHolder()->PrivateRelease();  // delete the ptr and release peer holders,
                    }                                       // thus breaking possible loops right here
                    else
                    {
                        oldMarkup->RequestReleaseNotify(this);   // defer breaking refcount loops (until CDoc::UnloadContents)
                    }
                }
            }
        }
        break;


    case PEERTASK_RECOMPUTEBEHAVIORS:
        {
            //+---------------------------------------------------------------------------
            //
            // PEERTASK_RECOMPUTEBEHAVIORS
            //
            //----------------------------------------------------------------------------

            CBehaviorInfo   info(GetFirstBranch());

            hr = THR(ApplyBehaviorCss(&info));
            if (hr)
                goto Cleanup;

            IGNORE_HR(pDoc->AttachPeersCss(this, &info._acstrBehaviorUrls));
        }
        break;

    case PEERTASK_APPLYSTYLE_UNSTABLE:

            //+---------------------------------------------------------------------------
            //
            // PEERTASK_APPLYSTYLE_UNSTABLE
            //
            //----------------------------------------------------------------------------

            if (HasPeerHolder())
            {
                // don't post the task if already did that; update peer mgr state

                pPeerMgr = GetPeerMgr();

                if (pPeerMgr && pPeerMgr->IsApplyStyleStablePending())
                    goto Cleanup; // done

                hr = THR(CPeerMgr::EnsurePeerMgr(this, &pPeerMgr));
                if (hr)
                    goto Cleanup;

                pPeerMgr->SetApplyStyleStablePending(TRUE);

                // post the task

                AddRef();

                IGNORE_HR(GetFrameOrPrimaryMarkup()->EnqueuePeerTask(this, PEERTASK_APPLYSTYLE_STABLE));
            }
            break;

            
    case PEERTASK_APPLYSTYLE_STABLE:

            //+---------------------------------------------------------------------------
            //
            // PEERTASK_APPLYSTYLE_STABLE
            //
            //----------------------------------------------------------------------------

            // update peer mgr state

            pPeerMgr = GetPeerMgr();
            Assert (pPeerMgr && pPeerMgr->IsApplyStyleStablePending());

            pPeerMgr->SetApplyStyleStablePending(FALSE);
            // don't do "CPeerMgr::EnsureDeletePeerMgr(this)" to avoid frequent memallocs

            // do the notification

            if (HasPeerHolder())
            {
                //::StartCAP();
                IGNORE_HR(GetPeerHolder()->ApplyStyleMulti());
                //::StopCAP();
            }

            Release(); // NOTE that this element may passivate after this release

            break;


    } // eo switch (task)

Cleanup:
    RRETURN (hr);
}


//+-------------------------------------------------------------------
//
//  Member:     CElement::ApplyBehaviorCss
//
//--------------------------------------------------------------------

HRESULT
CElement::ApplyBehaviorCss(CBehaviorInfo * pInfo)
{
    HRESULT      hr = S_OK;
    CAttrArray * pInLineStyleAA;
    CMarkup *    pMarkup = GetMarkup();

    // NOTE per rules of css application, inline styles take precedence so they should be applied last

    if (pMarkup)
    {
        if (pMarkup->IsSkeletonMode())
            goto Cleanup;

        // apply user style sheets
        // TODO (alexz): investigate why Apply crashes if the element is in not in any markup
        IGNORE_HR(Doc()->EnsureUserStyleSheets());

        if (TLS(pUserStyleSheets))
        {
            hr = THR(TLS(pUserStyleSheets)->Apply(pInfo, APPLY_Behavior));
            if (hr)
                goto Cleanup;
        }

        // apply markup rules
        hr = THR(pMarkup->ApplyStyleSheets(pInfo, APPLY_Behavior));
        if (hr)
            goto Cleanup;
    }
    
    // apply inline style rules
    pInLineStyleAA = GetInLineStyleAttrArray();
    if (pInLineStyleAA)
    {
        CMarkup * pMC = GetWindowedMarkupContext();

        if (!pMC->IsPassivated() && !pMC->IsPassivating())
        {
            hr = THR(ApplyAttrArrayValues(pInfo, &pInLineStyleAA, NULL, APPLY_Behavior));
            if (hr)
                goto Cleanup;
        }
    }

Cleanup:
    RRETURN (hr);
}


//+---------------------------------------------------------------------------
//
//  Member: CElement::addBehavior
//
//----------------------------------------------------------------------------

HRESULT
CElement::addBehavior(BSTR bstrUrl, VARIANT * pvarFactory, LONG * pCookie)
{
    HRESULT                     hr;
    CPeerFactoryBinaryOnstack   factory;
    CPeerFactory *              pFactory = NULL;
    LONG                        lCookieTemp;

    //
    // startup
    //

    if (!pCookie)
    {
        pCookie = &lCookieTemp;
    }

    *pCookie = 0;

    //
    // extract factory if any
    //

    if (pvarFactory)
    {
        // dereference
        if (V_VT(pvarFactory) & VT_BYREF)
        {
            pvarFactory = (VARIANT*) V_BYREF(pvarFactory);
            if (!pvarFactory)
            {
                hr = E_INVALIDARG;
                goto Cleanup;
            }
        }

        switch (V_VT(pvarFactory))
        {
        case VT_UNKNOWN:
        case VT_DISPATCH:

            // behavior factory?
            hr = THR_NOTRACE(V_UNKNOWN(pvarFactory)->QueryInterface(
                IID_IElementBehaviorFactory, (void**)&factory._pFactory));
            if (hr)
            {
                // behavior instance?
                hr = THR_NOTRACE(V_UNKNOWN(pvarFactory)->QueryInterface(
                    IID_IElementBehavior, (void**)&factory._pPeer));
                if (hr)
                    goto Cleanup;
            }

            factory.Init(bstrUrl);

            pFactory = &factory;

            break;

        case VT_NULL:
        case VT_EMPTY:
        case VT_ERROR:
            // just null
            break;

        default:
            hr = E_INVALIDARG;
            goto Cleanup;
        }
    }

    //
    // attach
    //

    hr = THR(Doc()->AttachPeer(this, bstrUrl, /* fIdentity = */ FALSE, pFactory, pCookie));

Cleanup:
    RRETURN (SetErrorInfo(hr));
}

//+---------------------------------------------------------------------------
//
//  Member: CElement::removeBehavior
//
//----------------------------------------------------------------------------

HRESULT
CElement::removeBehavior(LONG cookie, VARIANT_BOOL * pfResult)
{
    HRESULT     hr;

    hr = THR(Doc()->RemovePeer(this, cookie, pfResult));

    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CElement::NeedsIdentityPeer
//
//----------------------------------------------------------------------------

BOOL
CElement::NeedsIdentityPeer(CExtendedTagDesc *  pDesc)
{
    //
    // builtin or literal?
    //

    //
    // TODO (alexz)   currently if the tag is generic literal tag it implies that it has
    //                identity behavior (XML behavior in particular). This will not be true
    //                when we fully support literally parsed sprinkles: there will be literal
    //                tags that do not have identity behaviors.
    //

    Assert( Tag() != ETAG_GENERIC_NESTED_LITERAL );
    switch (Tag())
    {
    case ETAG_GENERIC_BUILTIN:
#ifndef V4FRAMEWORK
    case ETAG_GENERIC_LITERAL:
#endif
        return TRUE;
    }

    //
    // extended tag?
    //

    if (!pDesc)
    {
        pDesc = GetExtendedTagDesc();
    }
    if (    pDesc 
        &&  pDesc->HasIdentityPeerFactory() 
        &&    (    !HasPeerMgr()                            // If at first you don't succeed,
             ||    !GetPeerMgr()->_fIdentityPeerFailed ) )  // Give up.
        return TRUE;

    return FALSE;
}

//+------------------------------------------------------------------------
//
//  Member:     CElement::EnsureIdentityPeer()
//
//-------------------------------------------------------------------------

HRESULT
CElement::EnsureIdentityPeer()
{
    HRESULT                 hr;
    CExtendedTagDesc *      pDesc;

    if (HasIdentityPeerHolder())
        return S_OK;

    Assert (NeedsIdentityPeer(NULL));

    pDesc = GetExtendedTagDesc();

    Assert (pDesc && pDesc->HasIdentityPeerFactory());

    hr = THR(Doc()->AttachPeer(this, /* pchUrl = */ NULL, /* fIdentity = */ TRUE, pDesc->GetIdentityPeerFactory()));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Members:     CElement::HasIdentityPeerHolder
//
//----------------------------------------------------------------------------

BOOL
CElement::HasIdentityPeerHolder()
{
    return HasPeerHolder() ? GetPeerHolder()->HasIdentityPeerHolder() : FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CElement::GetIdentityPeerHolder
//
//----------------------------------------------------------------------------

CPeerHolder *
CElement::GetIdentityPeerHolder()
{
    return HasPeerHolder() ? GetPeerHolder()->GetIdentityPeerHolder() : NULL;
}

//+---------------------------------------------------------------------------
//
//  Members:     CElement::HasDefault
//
//----------------------------------------------------------------------------

BOOL
CElement::HasDefaults()
{
    return HasPeerMgr() && GetPeerMgr()->GetDefaults();
}

//+---------------------------------------------------------------------------
//
//  Members:     CElement::GetDefault
//
//----------------------------------------------------------------------------

CDefaults *
CElement::GetDefaults()
{
    return HasPeerMgr() ? GetPeerMgr()->GetDefaults() : NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CElement::GetPeerHolderInQI
//
//----------------------------------------------------------------------------

CPeerHolder *
CElement::GetPeerHolderInQI()
{
    return HasPeerHolder() ? GetPeerHolder()->GetPeerHolderInQI() : NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CElement::HasRenderPeerHolder
//
//----------------------------------------------------------------------------

BOOL
CElement::HasRenderPeerHolder()
{
    return HasPeerHolder() ? GetPeerHolder()->HasRenderPeerHolder() : FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CElement::GetRenderPeerHolder
//
//----------------------------------------------------------------------------

CPeerHolder *
CElement::GetRenderPeerHolder()
{
    return HasPeerHolder() ? GetPeerHolder()->GetRenderPeerHolder() : NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CElement::GetFilterPeerHolder
//
//----------------------------------------------------------------------------

CPeerHolder *
CElement::GetFilterPeerHolder(BOOL fCanRedirect/* = TRUE*/, BOOL * pfRedirected /* = NULL */)
{
    // We attach filter for page transitions to the root element and delegate
    // everything to the canvas element (it is not parsed soon enough for our purposes)
    // Here we do the reverse, return the root peerholder when asked for the body or
    // frameset and we are doing a transition
    if(fCanRedirect && (Tag() == ETAG_BODY || Tag() == ETAG_FRAMESET || Tag() == ETAG_HTML))
    {
        CMarkup *pMarkup = GetMarkup();
        if(pMarkup && pMarkup->Root()->HasPeerHolder()
            && Document() && Document()->HasPageTransitions() )
        {
            if(pfRedirected)
                *pfRedirected = TRUE;
            return GetMarkup()->Root()->GetPeerHolder()->GetFilterPeerHolder();
        }
    }
    if(pfRedirected)
        *pfRedirected = FALSE;
    return HasPeerHolder() ? GetPeerHolder()->GetFilterPeerHolder() : NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CElement::GetLayoutPeerHolder
//
//----------------------------------------------------------------------------
CPeerHolder *   
CElement::GetLayoutPeerHolder()
{   
    return HasPeerHolder() ? GetPeerHolder()->GetLayoutPeerHolder() : NULL; 
}

//+---------------------------------------------------------------------------
//
//  Member:     CElement::HasPeerWithUrn
//
//----------------------------------------------------------------------------

BOOL
CElement::HasPeerWithUrn(LPCTSTR Urn)
{
    CPeerHolder::CListMgr   List;

    List.Init(GetPeerHolder());

    return List.HasPeerWithUrn(Urn);
}

//+------------------------------------------------------------------------------
//
//  Member:     get_behaviorUrns
//
//  Synopsis:   returns the urn collection for the behaviors attached to this element
//      
//+------------------------------------------------------------------------------

HRESULT
CElement::get_behaviorUrns(IDispatch ** ppDispUrns)
{
    HRESULT                 hr = S_OK;
    CPeerUrnCollection *    pCollection = NULL;

    if (!ppDispUrns)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    pCollection = new CPeerUrnCollection(this);
    if (!pCollection)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(pCollection->QueryInterface (IID_IDispatch, (void **) ppDispUrns));
    if ( hr )
        goto Cleanup;

Cleanup:
    if (pCollection)
        pCollection->Release();

    RRETURN(SetErrorInfoPGet(hr, DISPID_CElement_behaviorUrns));
}

//+---------------------------------------------------------------------------
//
//  Member:     CElement::PutUrnAtom, helper
//
//----------------------------------------------------------------------------

HRESULT
CElement::PutUrnAtom (LONG urnAtom)
{
    HRESULT     hr;

    Assert (-1 != urnAtom);

    hr = THR(AddSimple(DISPID_A_URNATOM, urnAtom, CAttrValue::AA_Internal));

    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CElement::GetUrnAtom, helper
//
//----------------------------------------------------------------------------

HRESULT
CElement::GetUrnAtom(LONG * pAtom)
{
    HRESULT         hr = S_OK;
    AAINDEX         aaIdx;

    Assert (pAtom);

    aaIdx = FindAAIndex(DISPID_A_URNATOM, CAttrValue::AA_Internal);
    if (AA_IDX_UNKNOWN != aaIdx)
    {
        hr = THR(GetSimpleAt(aaIdx, (DWORD*)pAtom));
    }
    else
    {
        *pAtom = -1;
    }

    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CElement::GetUrn, per IHTMLElement2
//
//----------------------------------------------------------------------------

HRESULT
CElement::GetUrn(LPTSTR * ppchUrn)
{
#if 1

    HRESULT             hr = S_OK;
    CExtendedTagDesc *  pDesc;

    pDesc = GetExtendedTagDesc();
    if (pDesc)
    {
        *ppchUrn = pDesc->Urn();
    }
    else
    {
        *ppchUrn = NULL;
    }

    RRETURN (hr);

#else

    HRESULT             hr;
    LONG                urnAtom;

    Assert (ppchUrn);

    hr = THR(GetUrnAtom(&urnAtom));
    if (hr)
        goto Cleanup;

    if (-1 != urnAtom)
    {
        Assert (Doc()->_pXmlUrnAtomTable);      // should have been ensured when we stored urnAtom

        hr = THR(Doc()->_pXmlUrnAtomTable->GetUrn(urnAtom, ppchUrn));
    }
    else
    {
    }

Cleanup:
    RRETURN (hr);

#endif
}

//+---------------------------------------------------------------------------
//
//  Member:     CElement::put_tagUrn, per IHTMLElement2
//
//----------------------------------------------------------------------------

HRESULT
CElement::put_tagUrn (BSTR bstrUrn)
{
#if 1
    RRETURN (SetErrorInfo(E_UNEXPECTED));
#else
    HRESULT             hr;
    LPCTSTR             pchNamespace = Namespace();
    CXmlUrnAtomTable *  pUrnAtomTable;
    LONG                urnAtom;

    if (!pchNamespace)
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    hr = THR(Doc()->EnsureXmlUrnAtomTable(&pUrnAtomTable));
    if (hr)
        goto Cleanup;

    hr = THR(pUrnAtomTable->EnsureUrnAtom(bstrUrn, &urnAtom));
    if (hr)
        goto Cleanup;

    hr = THR(PutUrnAtom(urnAtom));

Cleanup:
    RRETURN (SetErrorInfo(hr));
#endif
}

//+---------------------------------------------------------------------------
//
//  Member:     CElement::get_tagUrn, per IHTMLElement2
//
//----------------------------------------------------------------------------

HRESULT
CElement::get_tagUrn(BSTR * pbstrUrn)
{
    HRESULT             hr = S_OK;
    LPCTSTR             pchNamespace = Namespace();
    LPTSTR              pchUrn = NULL;

    if (!pbstrUrn)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (pchNamespace)
    {
        hr = THR(GetUrn(&pchUrn));
        if (hr)
            goto Cleanup;
    }

    if (pchUrn)
    {
        hr = THR(FormsAllocString(pchUrn, pbstrUrn));
    }
    else
    {
        // CONSIDER: (anandra, alexz) return urn of html
        *pbstrUrn = NULL;
    }

Cleanup:
    RRETURN (SetErrorInfo(hr));
}

//+---------------------------------------------------------------------------
//
//  Member:     CElement::SetExtendedTagDesc
//
//----------------------------------------------------------------------------

HRESULT
CElement::SetExtendedTagDesc(CExtendedTagDesc * pDesc)
{
    HRESULT     hr;

    Assert (pDesc && pDesc->IsValid());

    hr = THR(AddUnknownObject(DISPID_A_EXTENDEDTAGDESC, pDesc, CAttrValue::AA_Internal));

    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CElement::GetExtendedTagDesc
//
//----------------------------------------------------------------------------

CExtendedTagDesc *
CElement::GetExtendedTagDesc()
{
    HRESULT             hr;
    CExtendedTagDesc *  pDesc = NULL;
    AAINDEX             aaIdx;

    aaIdx = FindAAIndex(DISPID_A_EXTENDEDTAGDESC, CAttrValue::AA_Internal);
    if (AA_IDX_UNKNOWN != aaIdx)
    {
        hr = THR(GetUnknownObjectAt(aaIdx, (IUnknown**)&pDesc));
        if (hr)
            goto Cleanup;

        Assert (pDesc && pDesc->IsValid());

        pDesc->Release(); // users of GetExtendedTagDesc use the pDesc as a weak ref and don't cache it
                          // this release compensates AddRef in GetUnknownObjectAt
    }

Cleanup:
    return pDesc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CElement::GetReadyState
//
//----------------------------------------------------------------------------

long
CElement::GetReadyState()
{
    return HasPeerMgr() ? GetPeerMgr()->_readyState : READYSTATE_COMPLETE;
}

//+----------------------------------------------------------------------------
//
//  Member:     CElement:get_readyState
//
//+------------------------------------------------------------------------------

HRESULT
CElement::get_readyState(VARIANT * pVarRes)
{
    HRESULT hr = S_OK;

    if (!pVarRes)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    GetFrameOrPrimaryMarkup()->ProcessPeerTasks(0);

    hr = THR(s_enumdeschtmlReadyState.StringFromEnum(GetReadyState(), &V_BSTR(pVarRes)));
    if (!hr)
        V_VT(pVarRes) = VT_BSTR;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//+----------------------------------------------------------------------------
//
//  Member:     CElement:get_readyStateValue
//
//+------------------------------------------------------------------------------

HRESULT
CElement::get_readyStateValue(long * plRetValue)
{
    HRESULT     hr = S_OK;

    if (!plRetValue)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    GetFrameOrPrimaryMarkup()->ProcessPeerTasks(0);

    *plRetValue = GetReadyState();

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//+---------------------------------------------------------------------------
//
//  Member:     CElement::OnReadyStateChange
//
//----------------------------------------------------------------------------

void
CElement::OnReadyStateChange()
{
    if (ElementDesc()->TestFlag(ELEMENTDESC_OLESITE))
    {
        COleSite::OLESITE_TAG olesiteTag = DYNCAST(COleSite, this)->OlesiteTag();

        if (olesiteTag == COleSite::OSTAG_ACTIVEX || olesiteTag == COleSite::OSTAG_APPLET)
        {
            DYNCAST(CObjectElement, this)->Fire_onreadystatechange();

            return; // done
        }
    }

    Fire_onreadystatechange();
}

//+---------------------------------------------------------------------------
//
//  Member:     CElement::IncPeerDownloads
//
//----------------------------------------------------------------------------

void
CElement::IncPeerDownloads()
{
    HRESULT     hr;
    CPeerMgr *  pPeerMgr;

#if DBG==1
    if (IsTagEnabled(tagPeerIncDecPeerDownloads))
    {
        TraceTag((0, "CElement::IncPeerDownloads on <%ls> element (SSN = %ld, %lx)", TagName(), SN(), this));
        TraceCallers(0, 0, 12);
    }
#endif

    hr = THR(CPeerMgr::EnsurePeerMgr(this, &pPeerMgr));
    if (hr)
        goto Cleanup;

    pPeerMgr->IncPeerDownloads();
    pPeerMgr->UpdateReadyState();

Cleanup:
    return;
}

//+---------------------------------------------------------------------------
//
//  Member:     CElement::DecPeerDownloads
//
//----------------------------------------------------------------------------

void
CElement::DecPeerDownloads()
{
    CPeerMgr *  pPeerMgr = GetPeerMgr();

#if DBG==1
    if (IsTagEnabled(tagPeerIncDecPeerDownloads))
    {
        TraceTag((0, "CElement::DecPeerDownloads on <%ls> element (SSN = %ld, %lx)", TagName(), SN(), this));
        TraceCallers(0, 0, 12);
    }
#endif

    Assert (pPeerMgr);
    if (!pPeerMgr)
        return;

    pPeerMgr->DecPeerDownloads();
    pPeerMgr->UpdateReadyState();

    CPeerMgr::EnsureDeletePeerMgr(this);
}

//+---------------------------------------------------------------------------
//
//  Member:     CElement::OnPeerListChange
//
//----------------------------------------------------------------------------

HRESULT
CElement::OnPeerListChange()
{
    HRESULT         hr = S_OK;

    CPeerMgr::UpdateReadyState(this, READYSTATE_UNINITIALIZED);

#ifdef PEER_NOTIFICATIONS_AFTER_INIT
    if (HasPeerHolder())
    {
        IGNORE_HR(GetPeerHolder()->EnsureNotificationsSentMulti());
    }
#endif

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CElement::InitExtendedTag
//
//  called from Init2
//
//-------------------------------------------------------------------------

HRESULT
CElement::InitExtendedTag(CInit2Context * pContext)
{
    HRESULT             hr = S_OK;
    CExtendedTagDesc *  pDesc = NULL;

    if (pContext &&                 // TODO (alexz) make this an assert? investigate implications of pContext->_pTargetMarkup check
        pContext->_pht &&
        pContext->_pTargetMarkup)
    {
        if (pContext->_pht->IsExtendedTag())
        {
            Assert (pContext->_pht->GetPch());

            CTagNameCracker tagNameCracker(pContext->_pht->GetPch());

            pDesc = pContext->_pTargetMarkup->GetExtendedTagDesc(
                tagNameCracker._pchNamespace, tagNameCracker._pchTagName, /* fEnsure =*/FALSE);

            Assert (pDesc);
        }

        if (pDesc)
        {
            hr = THR(SetExtendedTagDesc(pDesc));
            if (hr)
                goto Cleanup;
        }

        if (pContext->_pht->IsDynamic() && NeedsIdentityPeer(pDesc))
        {
            hr = THR(EnsureIdentityPeer());
            if (hr)
                goto Cleanup;
        }
    }

Cleanup:
    RRETURN (hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\peerdoc.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_OLESITE_HXX_
#define X_OLESITE_HXX_
#include "olesite.hxx"
#endif

#ifndef X_PEER_HXX_
#define X_PEER_HXX_
#include "peer.hxx"
#endif

#ifndef X_PEERMGR_HXX_
#define X_PEERMGR_HXX_
#include "peermgr.hxx"
#endif

#ifndef X_PEERFACT_HXX_
#define X_PEERFACT_HXX_
#include "peerfact.hxx"
#endif

#ifndef X_PEERURLMAP_HXX_
#define X_PEERURLMAP_HXX_
#include "peerurlmap.hxx"
#endif

#ifndef X_PEERXTAG_HXX_
#define X_PEERXTAG_HXX_
#include "peerxtag.hxx"
#endif

///////////////////////////////////////////////////////////////////////////
//
// misc
//
///////////////////////////////////////////////////////////////////////////

DeclareTag(tagPeerCMarkupAttachPeerUrl,                    "Peer", "trace CMarkup::AttachPeerUrl")
DeclareTag(tagPeerCMarkupAttachPeers,                      "Peer", "trace CMarkup::AttachPeers[Css]")
DeclareTag(tagPeerCMarkupAttachPeersEmptyPH,               "Peer", "CMarkup::AttachPeers: add empty peer holders to the list")
DeclareTag(tagPeerCMarkupPeerDequeueTasks,                 "Peer", "trace CMarkup::PeerDequeueTasks")
DeclareTag(tagPeerCMarkupProcessPeerTasks,                 "Peer", "trace CMarkup::ProcessPeerTasks")

MtDefine(CDoc_aryElementChangeVisibility_pv, CDoc, "CDoc::_aryElementChangeVisibility_pv::_pv")
MtDefine(CMarkupPeerTaskContext_aryPeerQueue_pv, CMarkup, "CMarkup::AttachPeers::aryUrls")
MtDefine(CMarkupBehaviorContext_aryPeerElems_pv, CMarkup, "CMarkup::_aryPeerElems_pv::_pv")

HRESULT CLSIDFromHtmlString(TCHAR *pchClsid, CLSID *pclsid);

#if DBG == 1
void TraceProcessPeerTask(CElement * pElement, BOOL fIdentity, CBehaviorInfo * pCss, LPTSTR pchMsg);
#endif

//////////////////////////////////////////////////////////////////////
//
// CDoc - parsing generic elements
//
//////////////////////////////////////////////////////////////////////

//+-------------------------------------------------------------------
//
//  Member:     CDoc::IsGenericElement
//
//--------------------------------------------------------------------

ELEMENT_TAG
CDoc::IsGenericElement (LPTSTR pchFullName, LPTSTR pchColon)
{
    ELEMENT_TAG     etag = ETAG_UNKNOWN;

    if (pchColon)
    {
        //
        // sprinkle in a host defined namespace?
        //

        etag = IsGenericElementHost(pchFullName, pchColon);
        if (ETAG_UNKNOWN != etag)
            goto Cleanup;           // done
    }
    else
    {
        //
        // builtin tag?
        //

        if (GetBuiltinGenericTagDesc(pchFullName))
            etag = ETAG_GENERIC_BUILTIN;
    }

Cleanup:

    return etag;
}

//+-------------------------------------------------------------------
//
//  Member:     CDoc::IsGenericElementHost
//
//--------------------------------------------------------------------

ELEMENT_TAG
CDoc::IsGenericElementHost (LPTSTR pchFullName, LPTSTR pchColon)
{
    ELEMENT_TAG     etag = ETAG_UNKNOWN;
    LPTSTR          pchHost;
    int             l;

    Assert (pchColon);

    pchHost = _cstrHostNS;
    
    // for debugging
    // pchHost = _T("FOO;A;AA;AAA;B");
    
    if (pchHost)
    {
        l = pchColon - pchFullName;

        // CONSIDER (alexz): use an optimal linear algorithm here instead of this one with quadratic behavior

        for (;;)
        {
            if (0 == StrCmpNIC(pchHost, pchFullName, l) &&
                (0 == pchHost[l]) || _T(';') == pchHost[l])
            {
                etag = ETAG_GENERIC;
                goto Cleanup;
            }

            pchHost = StrChr(pchHost, _T(';'));
            if (!pchHost)
                break;

            pchHost++;  // advance past ';'
        }
    }

Cleanup:

    return etag;
}

//////////////////////////////////////////////////////////////////////
//
// CDoc - behavior hosting code
//
//////////////////////////////////////////////////////////////////////

//+-------------------------------------------------------------------
//
//  Member:     CDoc::FindHostBehavior
//
//--------------------------------------------------------------------

HRESULT
CDoc::FindHostBehavior(
    const TCHAR *           pchPeerName,
    const TCHAR *           pchPeerUrl,
    IElementBehaviorSite *  pSite,
    IElementBehavior **     ppPeer)
{
    HRESULT hr = E_FAIL;

    if (_pHostPeerFactory)
    {
        hr = THR_NOTRACE(FindPeer(_pHostPeerFactory, pchPeerName, pchPeerUrl, pSite, ppPeer));
    }

    RRETURN (hr);
}

//+-------------------------------------------------------------------
//
//  Helper:     GetUrlFromDefaultBehaviorName
//
//--------------------------------------------------------------------

HRESULT
GetUrlFromDefaultBehaviorName(LPCTSTR pchName, LPTSTR pchUrl, UINT cchUrl)
{
    HRESULT     hr = S_OK;
    LONG        lRet;
    HKEY        hKey = NULL;
    DWORD       dwBufSize;
    DWORD       dwKeyType;

    //
    // read registry
    //

    lRet = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        _T("Software\\Microsoft\\Internet Explorer\\Default Behaviors"),
        0,
        KEY_QUERY_VALUE,
        &hKey);
    if (ERROR_SUCCESS != lRet || !hKey)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    dwBufSize = cchUrl;
    lRet = RegQueryValueEx(hKey, pchName, NULL, &dwKeyType, (LPBYTE)pchUrl, &dwBufSize);
    if (ERROR_SUCCESS != lRet || REG_SZ != dwKeyType)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

Cleanup:
    if (hKey)
        RegCloseKey (hKey);

    RRETURN (hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CDoc::FindDefaultBehaviorFactory
//
//--------------------------------------------------------------------

HRESULT
CDoc::FindDefaultBehaviorFactory(
    LPTSTR                      pchName,
    LPTSTR                      pchUrl,
    IElementBehaviorFactory **  ppFactory,
    LPTSTR                      pchUrlDownload,
    UINT                        cchUrlDownload)
{
    HRESULT                     hr = E_FAIL;
    HRESULT                     hr2;
    BOOL                        fRegistry = TRUE;
    TCHAR                       achUrl[pdlUrlLen];
    uCLSSPEC                    classpec;
    IElementBehaviorFactory *   pPeerFactory = NULL;
    CPeerFactoryDefault *       pPeerFactoryDefault = NULL;

    CLock                       lock(this); // this is to make sure the doc does not passivate while inside FaultInIEFeature

    Assert (ppFactory);
    *ppFactory = NULL;

    if (pchName)
    {
        //
        // look it up in registry and negotiate with host
        //

        hr2 = THR_NOTRACE(GetUrlFromDefaultBehaviorName(pchName, achUrl, ARRAY_SIZE(achUrl)));
        if (S_OK == hr2)
        {
            //
            // found the name in registry. Now make sure host does not implement this behavior;
            // if it does, let the one from host get thru
            // TODO (alexz) reconsider this; remove the call if possible
            //

            hr2 = THR_NOTRACE(FindHostBehavior(pchName, pchUrl, NULL, NULL));
            if (S_OK == hr2)
            {
                fRegistry = FALSE;
            }
        }
        else
        {
            fRegistry = FALSE;
        }

        //
        // prepare the factory info from url
        //

        if (fRegistry)
        {
            hr2 = THR_NOTRACE(CLSIDFromHtmlString(achUrl, &classpec.tagged_union.clsid));
            if (S_OK == hr2)
            {
                //
                // if this is a "CLSID:", ensure it is JIT downloaded and cocreate it's factory;
                //

                // TODO (alexz, kgallo) if FaultInIEFeatureHelper returns S_FALSE,
                // this means that the feature is not IE JIT-able.
                // temporarily, we allow the following situation:
                //      HTML+TIME is no longer marked in registry as IE JIT-able feature, but we 
                //      still call FaultInIEFeatureHelper for it.
                // This is now more fragile for anyone who introduces a new feature but forgets
                // to mark it as JIT-able feature in registry. In that case we we will no longer
                // assert as we used to do before.
                // opened IE 5.5 B3 bug 93581 for this

                classpec.tyspec = TYSPEC_CLSID;

                hr = THR(FaultInIEFeatureHelper(GetHWND(), &classpec, NULL, 0));
#if 0
                Assert (S_FALSE != hr);
                if (hr)
                    goto Cleanup;
#else
                if (FAILED(hr))
                    goto Cleanup;
#endif

                hr = THR(CoCreateInstance(
                    classpec.tagged_union.clsid,
                    NULL,
                    CLSCTX_INPROC_SERVER | CLSCTX_INPROC_HANDLER,
                    IID_IElementBehaviorFactory,
                    (void **)&pPeerFactory));
                if (hr)
                    goto Cleanup;

                Assert (pPeerFactory);
            }
            else
            {
                //
                // if this is a usual URL, expand it and return it
                //

                hr = THR(CMarkup::ExpandUrl(PrimaryMarkup(), achUrl, cchUrlDownload, pchUrlDownload, NULL));
                goto Cleanup; // done
            }
        }
    }

    //
    // set up CPeerFactoryDefault
    //

    pPeerFactoryDefault = new CPeerFactoryDefault(this);
    if (!pPeerFactoryDefault)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    if (pPeerFactory)
    {
        pPeerFactoryDefault->_pPeerFactory = pPeerFactory;
        pPeerFactoryDefault->_pPeerFactory->AddRef();
    }

    hr = THR(pPeerFactoryDefault->QueryInterface(IID_IElementBehaviorFactory, (void**) ppFactory));
    if (hr)
        goto Cleanup;

Cleanup:
    if (pPeerFactoryDefault)
        pPeerFactoryDefault->Release();

    ReleaseInterface (pPeerFactory);

    RRETURN (hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CDoc::EnsureIepeersFactory
//
//--------------------------------------------------------------------

HRESULT
CDoc::EnsureIepeersFactory()
{
    static const CLSID CLSID_DEFAULTPEERFACTORY = {0x3050f4cf, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b};

    HRESULT hr = S_OK;

    if (!_fIepeersFactoryEnsured)
    {
        _fIepeersFactoryEnsured = TRUE;

        hr = THR(CoCreateInstance(
            CLSID_DEFAULTPEERFACTORY,
            NULL,
            CLSCTX_INPROC_SERVER | CLSCTX_INPROC_HANDLER,
            IID_IElementBehaviorFactory,
            (void **)&_pIepeersFactory));
        if (hr)
            _pIepeersFactory = NULL;
    }

    if (!_pIepeersFactory)
        hr = E_FAIL;

    RRETURN (hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CDoc::SetCssPeersPossible
//
//--------------------------------------------------------------------

void
CDoc::SetCssPeersPossible()
{
    if (_fCssPeersPossible)
        return;

    if (_dwLoadf & DLCTL_NO_BEHAVIORS)
        return;

    _fCssPeersPossible = TRUE;
}

//+-------------------------------------------------------------------
//
//  Member:     CDoc::StopPeerFactoriesDownloads
//
//--------------------------------------------------------------------

void
CMarkup::StopPeerFactoriesDownloads()
{
    CPeerFactoryUrlMap * pPeerFactoryUrlMap = GetPeerFactoryUrlMap();
    
    if (pPeerFactoryUrlMap)
    {
        IGNORE_HR(pPeerFactoryUrlMap->StopDownloads());
    }
}

//+-------------------------------------------------------------------
//
//  Helper:     ReportAccessDeniedError
//
//--------------------------------------------------------------------

HRESULT
ReportAccessDeniedError(CElement * pElement, CMarkup * pMarkup, LPTSTR pchUrlBehavior)
{
    HRESULT             hr = S_OK;
    CDoc *              pDoc;
    TCHAR               achMessage[pdlUrlLen + 32];
    CPendingScriptErr * pErrRec;
    COmWindowProxy *    pWindowProxy;
    CMarkup *           pWMC;

    Assert (pElement || pMarkup);

    pDoc = pElement ? pElement->Doc() : pMarkup->Doc();

    Assert (pDoc->_dwTID == GetCurrentThreadId());

    Format(0, achMessage, ARRAY_SIZE(achMessage), _T("Access is denied to: <0s>"), pchUrlBehavior);

    if (!pMarkup)
    {
        Assert (pElement);

        pMarkup = pElement->IsInMarkup() ? pElement->GetMarkup() : pDoc->PrimaryMarkup();
    }

    Assert (pMarkup);

    // queue the event firing on the closest window
    pWMC = pMarkup->GetWindowedMarkupContext();
    
    if( pWMC->HasWindow() )
    {
        ErrorRecord errorRecord;
        LPTSTR      pchUrlBehaviorHost = (LPTSTR) CMarkup::GetUrl(pMarkup);

        errorRecord.Init(E_ACCESSDENIED, achMessage, pchUrlBehaviorHost);

        hr = THR(pWMC->ReportScriptError(errorRecord));
    }
    else
    {
        pWindowProxy = pWMC->GetWindowPending();
        if (pWindowProxy)
        {
            pErrRec = pWindowProxy->Window()->_aryPendingScriptErr.Append();

            if (pErrRec)
            {
                pErrRec->_pMarkup = pMarkup; 
                pMarkup->SubAddRef();
                pErrRec->_cstrMessage.Set(achMessage);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }

    RRETURN (hr);
}

//+-------------------------------------------------------------------
//
//  Helper:     ExpandPeerUrl
//
//--------------------------------------------------------------------

HRESULT
ExpandPeerUrl(LPTSTR * ppchUrl, CElement * pElement, LPTSTR pchUrlBuf, LONG cUrlBuf)
{
    HRESULT     hr = S_OK;
    CMarkup *   pMarkup;

    if (!(*ppchUrl) ||
        _T('#') == (*ppchUrl)[0])
        goto Cleanup; // done

    pMarkup = pElement->GetWindowedMarkupContext();

    hr = THR(CMarkup::ExpandUrl(pMarkup, *ppchUrl, cUrlBuf, pchUrlBuf, pElement));
    if (hr)
        goto Cleanup;

    *ppchUrl = pchUrlBuf;

Cleanup:
    RRETURN (hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CDoc::AttachPeersCss
//
//--------------------------------------------------------------------

HRESULT
CDoc::AttachPeersCss(
    CElement *      pElement,
    CAtomTable *    pacstrBehaviorUrls)
{
    HRESULT                 hr = S_OK;

    //
    // control reentrance: if we are in process of attaching peer, do not
    // allow to attach any other peer
    //

    if (!pElement->TestLock(CElement::ELEMENTLOCK_ATTACHPEER))
    {
        CElement::CLock lock(pElement, CElement::ELEMENTLOCK_ATTACHPEER);
        CView::CEnsureDisplayTree edt(GetView());

        HRESULT                 hr2;
        int                     i, cUrls;
        CPeerHolder *           pPeerHolder;
        LPTSTR                  pchUrl;
        TCHAR                   achUrl[pdlUrlLen];
        CPeerHolder::CListMgr   ListPrev;
        CPeerHolder::CListMgr   ListNew;

        TraceTag((tagPeerCMarkupAttachPeers,
                  "CMarkup::AttachPeersCss, <%ls id = %ls SN = %ld>, peers to be attached:",
                  pElement->TagName(), STRVAL(pElement->GetAAid()), pElement->SN()));

        cUrls = pacstrBehaviorUrls->TableSize();

        ListPrev.Init (pElement->DelPeerHolder()); // DelPeerHolder will disconnect the old list from element
        ListNew.BuildStart (pElement);

        //
        // move identity peers to the new list (there can only be 1 identity peer for now)
        //

        while (!ListPrev.IsEnd() && ListPrev.Current()->IsIdentityPeer())
        {
            ListPrev.MoveCurrentToHeadOf(&ListNew);
            ListNew.BuildStep();
        }

        //
        // Pass 1: build new list of peer holders:
        //          -   moving existing peers that we don't change into the new list intact, and
        //          -   creating new peers
        //

        for (i = 0; i < cUrls; i++)
        {
            //
            // handle url
            //

            pchUrl = pacstrBehaviorUrls->TableItem(i);
            if (!pchUrl || 0 == pchUrl[0])  // if empty
                continue;

            hr = THR(ExpandPeerUrl(&pchUrl, pElement, achUrl, ARRAY_SIZE(achUrl)));
            if (hr)
                goto Cleanup;

            TraceTag((tagPeerCMarkupAttachPeers, "           '%ls'", pchUrl));

            //
            // attempt to find existing peer holder for the url.
            // if found, move it to the new list; otherwise, create a new empty peer holder
            //

            if (ListPrev.Find(pchUrl))
            {
                ListPrev.MoveCurrentToTailOf(&ListNew);
                ListNew.BuildStep();
            }
            else
            {
                pPeerHolder = new CPeerHolder(pElement);
                if (!pPeerHolder)
                {
                    hr = E_OUTOFMEMORY;
                    goto Cleanup;
                }

                ListNew.AddToTail(pPeerHolder);
                ListNew.BuildStep();

                //
                // AttachPeerUrl
                //

                pPeerHolder->SetFlag(CPeerHolder::CSSPEER);

                hr2 = THR_NOTRACE(AttachPeerUrl(pPeerHolder, pchUrl));

                if (hr2) // if error creating the peer
                {
                    if (E_ACCESSDENIED == hr2)
                    {
                        IGNORE_HR(ReportAccessDeniedError(pElement, /* pMarkup = */ NULL, pchUrl));
                    }

                    {
                        // ( the lock prevents DetachCurrent from passivating pPeerHolder. We want pPeerHolder passivate
                        // after BuildStep so that element does not have pPeerHolder attached when passivation happens )
                        CPeerHolder::CLock lock (pPeerHolder);
                        ListNew.DetachCurrent();
                        ListNew.BuildStep();
                    }
                }
            }
        }

        //
        // Pass 2: release all css created peers left in the old list
        // (and leave host and "attachBehavior" peers intact)
        //

        ListPrev.Reset();
        while (!ListPrev.IsEnd())
        {
            Assert (!ListPrev.Current()->IsIdentityPeer()); // identity peers have been moved already

            if (ListPrev.Current()->IsCssPeer())            // if css peer to save and remove
            {
                ListPrev.DetachCurrent(/*fSave = */TRUE);
            }
            else                                            // behavior added by addBehavior
            {
                ListPrev.MoveCurrentToTailOf(&ListNew);
            }
        }

        //
        // debug stuff
        //

#if DBG == 1
        if (IsTagEnabled(tagPeerCMarkupAttachPeersEmptyPH))
        {
            if (!ListNew.Head() || !ListNew.Head()->IsIdentityPeer())
            {
                ListNew.AddToHead(new CPeerHolder(pElement));
                ListNew.BuildStep();
            }
            ListNew.AddToTail(new CPeerHolder(pElement));
            ListNew.BuildStep();
        }
#endif
        //
        // finalize
        //

        hr = THR(ListNew.BuildDone());
        if (hr)
            goto Cleanup;
    }

Cleanup:

    RRETURN (hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CDoc::AttachPeer
//
//--------------------------------------------------------------------

HRESULT
CDoc::AttachPeer(
    CElement *              pElement,
    LPTSTR                  pchUrl,
    BOOL                    fIdentity,
    CPeerFactory *          pFactory,
    LONG *                  pCookie)
{
    HRESULT     hr = S_OK;

    if ((!pchUrl || !pchUrl[0]) && !pFactory)  // if empty
        goto Cleanup;

    if (!pElement->TestLock(CElement::ELEMENTLOCK_ATTACHPEER))
    {
        CElement::CLock lock(pElement, CElement::ELEMENTLOCK_ATTACHPEER);
        CView::CEnsureDisplayTree edt(GetView());

        CPeerHolder *           pPeerHolder;
        TCHAR                   achUrl[pdlUrlLen];
        CPeerHolder::CListMgr   List;

        List.BuildStart (pElement);

        //
        // expand url and check if the peer already exists
        //

        hr = THR(ExpandPeerUrl(&pchUrl, pElement, achUrl, ARRAY_SIZE(achUrl)));
        if (hr)
            goto Cleanup;

        TraceTag((tagPeerCMarkupAttachPeers,
                  "CMarkup::AttachPeer, <%ls id = %ls SN = %ld>, peer to be attached:",
                  pElement->TagName(), STRVAL(pElement->GetAAid()), pElement->SN()));

        TraceTag((tagPeerCMarkupAttachPeers, "           '%ls'", STRVAL(pchUrl)));

        if (!pchUrl || !List.Find(pchUrl))
        {
            //
            // create peer holder and initiate attaching peer
            //

            pPeerHolder = new CPeerHolder(pElement);
            if (!pPeerHolder)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }

            if (fIdentity)
            {
                AssertSz( List.IsEmpty(), "Attempting to attach element behavior with a behavior already attached!" );

                List.AddToHead(pPeerHolder);
                pPeerHolder->SetFlag(CPeerHolder::IDENTITYPEER);
            }
            else
            {
                List.AddToTail(pPeerHolder);
            }

            List.BuildStep ();

            if (!pFactory)
            {
                Assert (pchUrl && pchUrl[0]);

                hr = THR_NOTRACE(AttachPeerUrl(pPeerHolder, pchUrl));
            }
            else
            {
                hr = THR_NOTRACE(pFactory->AttachPeer(pPeerHolder));
            }

            if (S_OK == hr)
            {
                if (pCookie)
                {
                    (*pCookie) = pPeerHolder->CookieID();
                }
            }
            else // if error
            {
                // ( the lock prevents DetachCurrent from passivating pPeerHolder. We want pPeerHolder passivate
                // after BuildStep so that element does not have pPeerHolder attached when passivation happens )
                CPeerHolder::CLock lock (pPeerHolder);

                List.DetachCurrent();
                List.BuildStep ();

                if( fIdentity )
                {
                    CPeerMgr * pPeerMgr;

                    hr = THR( CPeerMgr::EnsurePeerMgr( pElement, &pPeerMgr ) );
                    if( hr )
                        goto Cleanup;

                    pPeerMgr->_fIdentityPeerFailed = TRUE;
                }

                goto Cleanup;
            }
        } // eo if not found

        //
        // finalize
        //

        hr = THR(List.BuildDone());
        if (hr)
            goto Cleanup;

    } // eo if lock

Cleanup:

    RRETURN (hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CDoc::RemovePeer
//
//--------------------------------------------------------------------

HRESULT
CDoc::RemovePeer(
    CElement *      pElement,
    LONG            cookie,
    VARIANT_BOOL *  pfResult)
{
    HRESULT     hr = E_UNEXPECTED;

    if (!pfResult)
        RRETURN (E_POINTER);

    *pfResult = VB_FALSE;

    if (!pElement->TestLock(CElement::ELEMENTLOCK_ATTACHPEER))
    {
        CElement::CLock         lock(pElement, CElement::ELEMENTLOCK_ATTACHPEER);
        CView::CEnsureDisplayTree edt(GetView());

        CPeerHolder::CListMgr   List;

        List.BuildStart (pElement);

        // search for the cookie

        while (!List.IsEnd())
        {
            if (cookie == List.Current()->CookieID())
            {   //..todo lock
                *pfResult = VB_TRUE;
                List.DetachCurrent(/*fSave = */TRUE);
                List.BuildStep();
                break;
            }

            List.Step();
        }

        // finalize

        hr = THR(List.BuildDone());
    }


    RRETURN (hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CDoc::EnsurePeerFactoryUrl
//
//--------------------------------------------------------------------

HRESULT
CDoc::EnsurePeerFactoryUrl(LPTSTR pchUrl, CElement * pElement, CMarkup * pMarkup, CPeerFactoryUrl ** ppFactory)
{
    HRESULT                 hr = S_OK;
    CMarkup *               pHostMarkup;
    CPeerFactoryUrlMap *    pPeerFactoryUrlMap;

    Assert (pElement || pMarkup);
    Assert (ppFactory);
    Assert (pchUrl && pchUrl[0]);

    *ppFactory = NULL;

    // consider the following interesting cases here:
    // - most typical, both pElement and pMarkup is not NULL
    // - pElement is not NULL, but the element lives in ether (it is not in any markup). Then pMarkup is NULL
    // - pElement is NULL, but we want to ensure PeerFactoryUrl object in a given markup (ETT usage), so pMarkup is not NULL

    if (pElement)
    {
        pHostMarkup = pElement->GetFrameOrPrimaryMarkup();
    }
    else
    {
        pHostMarkup = pMarkup->GetFrameOrPrimaryMarkup();
    }

    Assert (pHostMarkup && pHostMarkup->GetProgSink());

    //
    // First check to see if we already have a factory
    // If we do, we can skip an expensive security check.
    pPeerFactoryUrlMap = pHostMarkup->GetPeerFactoryUrlMap();

    if (pPeerFactoryUrlMap)
    {
        if (pPeerFactoryUrlMap->HasPeerFactoryUrl(pchUrl, ppFactory))
            goto Cleanup;
    }

    //
    // security check
    //

    if (_T('#') != pchUrl[0] && !_tcsnipre(_T("cdl:"), 4, pchUrl, -1))
    {
        // TODO (alexz) (1) test coverage for this; (2) security review
        if (!pHostMarkup->AccessAllowed(pchUrl))
        {
            hr = E_ACCESSDENIED;
            goto Cleanup;
        }
    }

    //
    // ensure PeerFactoryUrlMap in the correct markup and PeerFactoryUrl in the map
    //

    hr = THR(pHostMarkup->EnsurePeerFactoryUrlMap(&pPeerFactoryUrlMap));
    if (hr)
        goto Cleanup;

    hr = THR(pPeerFactoryUrlMap->EnsurePeerFactoryUrl(pchUrl, pMarkup, ppFactory));

Cleanup:
    RRETURN (hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CDoc::AttachPeerUrl
//
//--------------------------------------------------------------------

HRESULT
CDoc::AttachPeerUrl(CPeerHolder * pPeerHolder, LPTSTR pchUrl)
{
    HRESULT             hr;
    CPeerFactoryUrl *   pFactory = NULL;

    TraceTag((tagPeerCMarkupAttachPeerUrl,
              "CMarkup::AttachPeerUrl, attaching peer to <%ls id = %ls SN = %ld>, url: '%ls'",
              pPeerHolder->_pElement->TagName(),
              STRVAL(pPeerHolder->_pElement->GetAAid()),
              pPeerHolder->_pElement->SN(),
              pchUrl));

    hr = THR(EnsurePeerFactoryUrl(pchUrl, pPeerHolder->_pElement, pPeerHolder->_pElement->GetMarkup(), &pFactory));
    if (hr)
        goto Cleanup;

    Assert (pFactory);

    hr = THR_NOTRACE(pFactory->AttachPeer(pPeerHolder, /* fAfterDownload = */FALSE));

Cleanup:

    RRETURN (hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CMarkup::EnqueuePeerTask
//
//--------------------------------------------------------------------

HRESULT
CMarkup::EnqueuePeerTask(CBase * pTarget, PEERTASK task)
{
    HRESULT             hr = S_OK;
    CPeerQueueItem *    pQueueItem;
    CMarkupPeerTaskContext * pPTC;

    hr = THR( EnsureMarkupPeerTaskContext( &pPTC ) );
    if( hr )
        goto Cleanup;

    //
    // post message to commit, if not posted yet (and not unloading)
    //

    if (0 == pPTC->_aryPeerQueue.Size() && !Doc()->TestLock(FORMLOCK_UNLOADING))
    {
        IProgSink * pProgSink;

        hr = THR(GWPostMethodCall(
            this, ONCALL_METHOD(CMarkup, ProcessPeerTasks, processpeertasks),
            0, FALSE, "CMarkup::ProcessPeerTasks"));
        if (hr)
            goto Cleanup;

        pProgSink = GetProgSink();

        Assert (0 == pPTC->_dwPeerQueueProgressCookie);

        if (pProgSink)
        {
            pProgSink->AddProgress (PROGSINK_CLASS_CONTROL, &pPTC->_dwPeerQueueProgressCookie);
        }
    }

    //
    // add to the queue
    //

    pQueueItem = pPTC->_aryPeerQueue.Append();
    if (!pQueueItem)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    pQueueItem->Init(pTarget, task);

Cleanup:
    RRETURN (hr);
}


//+-------------------------------------------------------------------
//
//  Member:     CDoc::ProcessPeerTasks
//
//  NOTE:   it is important that the queue gets processed in the order
//          it was queued - this is how we guarantee that all behaviors are attached
//          to parents before all behaviors are attached to children
//
//--------------------------------------------------------------------

void
CMarkup::ProcessPeerTasks(DWORD_PTR dwFlags)
{
    int                         i;
    ULONG                       cDie;
    CBase *                     pTarget;
    CElement *                  pElement;
    CPeerQueueItem *            pQueueItem;
    CMarkupPeerTaskContext *    pPTC = HasMarkupPeerTaskContext() ? GetMarkupPeerTaskContext() : NULL;

    // We can't process peer tasks until we're switched in.
    if (!pPTC || !pPTC->HasPeerTasks() || (_fWindowPending && dwFlags != PROCESS_PEER_TASK_UNLOAD))
    {
        goto Cleanup;
    }
    else if (_fWindowPending && dwFlags == PROCESS_PEER_TASK_UNLOAD)
    {
        goto DeleteQueue;
    }

    // startup
    //


    TraceTag((tagPeerCMarkupPeerDequeueTasks, "CMarkup::PeerDequeueTasks, queue size: %ld", pPTC->_aryPeerQueue.Size()));

    if (NULL == pPTC->_aryPeerQueue[0]._pTarget)  // if reentered the method
    {
#if DBG == 1
        if (IsTagEnabled(tagPeerCMarkupPeerDequeueTasks))
        {
            TraceTag((tagPeerCMarkupPeerDequeueTasks, "CMarkup::PeerDequeueTasks, REENTRANCE detected, call stack:"));
            TraceCallers(0, 0, 20);
        }
#endif

        goto Cleanup;                                               // bail out
    }

    //
    // go up to interactive state if necessary
    //

    // if need to be inplace active in order execute scripts and we need
    // to have our markup switched in...
    if (!AllowScriptExecution())
    {
        // request in-place activation by going interactive
        RequestReadystateInteractive(TRUE);

        // and wait until activated or switched - the activation codepath will 
        // call PeerDequeueTasks again
        goto Cleanup;
    }

    //
    // dequeue all the elements in queue
    //

    // note that the queue might get blown away while we are in this loop.
    // this can happen in CDoc::UnloadContents, resulted from document.write, executed
    // during creation of a behavior (e.g. in inline script of a scriptlet). We use cDie
    // to be robust for this reentrance.

    cDie = Doc()->_cDie;

    for (i = 0; cDie == Doc()->_cDie && i < pPTC->_aryPeerQueue.Size(); i++)
    {
        pQueueItem = &( pPTC->_aryPeerQueue[i] );

        pTarget = pQueueItem->_pTarget;

        Assert (pTarget); // (we should detect reentrance sitiation in the beginning of this function)
        if (!pTarget)
            goto Cleanup;

        pQueueItem->_pTarget = NULL;

        if (PEERTASK_ELEMENT_FIRST <= pQueueItem->_task && pQueueItem->_task <= PEERTASK_ELEMENT_LAST)
        {
            pElement = DYNCAST(CElement, pTarget);

            TraceTag((tagPeerCMarkupPeerDequeueTasks, "                [%lx] <%ls id = %ls SN = %ld>", pElement, STRVAL(pElement->TagName()), STRVAL(pElement->GetAAid()), pElement->SN()));

            IGNORE_HR(pElement->ProcessPeerTask(pQueueItem->_task));
        }
        else
        {
            Assert (PEERTASK_MARKUP_FIRST <= pQueueItem->_task && pQueueItem->_task <= PEERTASK_MARKUP_LAST);

            TraceTag((tagPeerCMarkupPeerDequeueTasks, "                [%lx] <<MARKUP>>", pTarget));

            IGNORE_HR(DYNCAST(CMarkup, pTarget)->ProcessPeerTask(pQueueItem->_task));
        }
    }

DeleteQueue:
    pPTC->_aryPeerQueue.DeleteAll();

    //
    // remove progress
    //

    if (0 != pPTC->_dwPeerQueueProgressCookie)
    {
        IProgSink * pProgSink = GetProgSink();

        //
        // progsink must have been available in order to AddProgress return _dwPeerQueueProgressCookie.
        // Now it can be released only when the doc is unloading (progsink living on tree is destroyed
        // before we dequeue the queue)
        //
        TraceTag((tagPeerCMarkupProcessPeerTasks,
                  "CMarkup::ProcessPeerTasks pProgSink = %x, Doc()->TestLock(FORMLOCK_UNLOADING) = %ld", 
                        pProgSink, 
                        Doc()->TestLock(FORMLOCK_UNLOADING)));

        if (pProgSink)
        {
            pProgSink->DelProgress (pPTC->_dwPeerQueueProgressCookie);
        }

        pPTC->_dwPeerQueueProgressCookie = 0;
    }

Cleanup:
    return;
}

//+-------------------------------------------------------------------
//
//  Member:     CMarkup::EnqueueIdentityPeerTask
//
//--------------------------------------------------------------------

HRESULT
CMarkup::EnqueueIdentityPeerTask(CElement * pElement)
{
    HRESULT hr = S_OK;
    CMarkupPeerTaskContext * pPTC;

    Assert (!HasMarkupPeerTaskContext() || !GetMarkupPeerTaskContext()->_pElementIdentityPeerTask);
    Assert (pElement->NeedsIdentityPeer(NULL));

    hr = THR( EnsureMarkupPeerTaskContext( &pPTC ) );
    if( hr )
        goto Cleanup;

    pElement->PrivateAddRef();

    pPTC->_pElementIdentityPeerTask = pElement;

#if DBG == 1
    TraceProcessPeerTask (pPTC->_pElementIdentityPeerTask, TRUE, NULL, _T("ENQUEUE"));
#endif

Cleanup:
    RRETURN (hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CMarkup::ProcessIdentityPeerTask
//
//--------------------------------------------------------------------

HRESULT
CMarkup::ProcessIdentityPeerTask()
{
    HRESULT         hr = S_OK;
    CElement *      pElement = NULL;
    CMarkup *       pMarkup = NULL;
    CPeerHolder *   pPeerHolder;
    CPeerMgr *      pPeerMgr;
    CMarkupPeerTaskContext * pPTC;

    Assert( HasMarkupPeerTaskContext() );
    pPTC = GetMarkupPeerTaskContext();
    pElement = pPTC->_pElementIdentityPeerTask;
    pMarkup = pElement->GetMarkupPtr();

    Assert (pPTC->_pElementIdentityPeerTask);
    Assert (pElement->NeedsIdentityPeer(NULL));

#if DBG == 1
    TraceProcessPeerTask (pPTC->_pElementIdentityPeerTask, TRUE, NULL, _T("DEQUEUE"));
#endif

    pPTC->_pElementIdentityPeerTask = NULL;

    if (!Doc()->TestLock(FORMLOCK_UNLOADING))
    {
        Assert(!_fWindowPending);

        pElement->EnsureIdentityPeer();

        pPeerHolder = pElement->GetIdentityPeerHolder();

        if (pPeerHolder &&
            pPeerHolder->TestFlag(CPeerHolder::BLOCKPARSERWHILEINCOMPLETE))
        {
            READYSTATE  readyState = pPeerHolder->GetReadyState();

            if (READYSTATE_UNINITIALIZED < readyState && readyState < READYSTATE_COMPLETE)
            {
                // suspend download in the current markup if the identity peer requests it
                // it will get resumed when the identity peer reports readyState 'complete'

                hr = THR(CPeerMgr::EnsurePeerMgr(pElement, &pPeerMgr));
                if (hr)
                    goto Cleanup;

                pPeerMgr->SuspendDownload();
            }
        }
    }

Cleanup:
    pElement->PrivateRelease();

    RRETURN (hr);
}

HRESULT
CMarkup::RequestDocEndParse( CElement * pElement )
{
    HRESULT hr = S_OK;
    CMarkupBehaviorContext * pBC;

    // We may already have passed Quickdone.
    if( LoadStatus() >= LOADSTATUS_QUICK_DONE )
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    hr = THR( EnsureBehaviorContext( &pBC ) );
    if( hr )
        goto Cleanup;

    // We'll filter out dupes when we send the notification.
    hr = THR( pBC->_aryPeerElems.Append( pElement ) );
    if( hr )
        goto Cleanup;

    // Subref for the array - we don't want to keep behaviors attached
    pElement->SubAddRef();

Cleanup:
    RRETURN1( hr, S_FALSE );
}

HRESULT
CMarkup::SendDocEndParse()
{
    HRESULT                     hr  = S_OK;
    CAryPeerElems               aryPeerElems;
    CMarkupBehaviorContext  *   pBC;
    long                        c;
    CElement                **  ppElem;

    // No context, no notifications
    if( !HasBehaviorContext() )
        goto Cleanup;

    pBC = BehaviorContext();

    for( c = pBC->_aryPeerElems.Size(), ppElem = pBC->_aryPeerElems; c > 0; c--, ppElem++ )
    {
        // Make sure the element is still in this markup
        if( (*ppElem)->GetMarkup() == this )
        {
            // Can't be passivated and in the markup
            Assert( !(*ppElem)->IsPassivated() );

            hr = THR( aryPeerElems.Append( *ppElem ) );
            if( hr )
                goto Cleanup;

            // Convert our sub ref into a full ref while we notify
            (*ppElem)->AddRef();
        }
        (*ppElem)->SubRelease();
    }

    pBC->_aryPeerElems.DeleteAll();

    for( c = aryPeerElems.Size(), ppElem = aryPeerElems; c > 0; c--, ppElem++ )
    {
        CNotification nf;

        nf.DocEndParse(*ppElem);
        (*ppElem)->Notify(&nf);
        (*ppElem)->Release();
    }

Cleanup:
    RRETURN( hr );
}

//+-------------------------------------------------------------------
//
//  Member:     CDocument::get_namespaces
//              CDoc::get_namespaces
//
//--------------------------------------------------------------------

HRESULT
CDocument::get_namespaces(IDispatch ** ppdispNamespaces)
{
    HRESULT     hr;

    hr = THR(CHTMLNamespaceCollection::Create(Markup(), ppdispNamespaces));

    RRETURN (SetErrorInfo(hr));
}

//+-------------------------------------------------------------------
//
//  Member:     CDoc::EnsureExtendedTagTableHost
//
//--------------------------------------------------------------------

HRESULT
CDoc::EnsureExtendedTagTableHost()
{
    HRESULT     hr = S_OK;

    if (!_pExtendedTagTableHost)
    {
        _pExtendedTagTableHost = new CExtendedTagTable(this, /* pMarkup = NULL */ NULL, /* fShareBooster = */FALSE);
        if (!_pExtendedTagTableHost)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    RRETURN (hr);
}


//+-------------------------------------------------------------------
//
//  Member:     CDoc::RequestElementChangeVisibility
//
//  Synopsis:   The filter behavior needs to override an element's visibility
//              while playing a transition from visible to invisible or
//              vice-versa.  We need to handle these changes asynchronously
//              to avoid firing events while rendering.  We keep a list of
//              elements whose visibility is changing, and post ourselves
//              a message to react to the changes.
//
//--------------------------------------------------------------------

HRESULT
CDoc::RequestElementChangeVisibility(CElement *pElement)
{
    HRESULT             hr = S_OK;

    //
    // post message to commit, if not posted yet (and not unloading)
    //

    if (0 == _aryElementChangeVisibility.Size() && !TestLock(FORMLOCK_UNLOADING))
    {
        hr = THR(GWPostMethodCall(
            this, ONCALL_METHOD(CDoc, ProcessElementChangeVisibility, processelementchangevisibility),
            0, FALSE, "CDoc::ProcessElementChangeVisibility"));
        if (hr)
            goto Cleanup;
    }

    //
    // add to the queue (with a weak reference)
    //

    hr = _aryElementChangeVisibility.Append(pElement);
    if (!hr)
    {
        pElement->SubAddRef();
    }

Cleanup:
    RRETURN (hr);
}


//+-------------------------------------------------------------------
//
//  Member:     CDoc::ProcessElementChangeVisibility
//
//--------------------------------------------------------------------

void
CDoc::ProcessElementChangeVisibility(DWORD_PTR)
{
    int i;
    int cEntries = _aryElementChangeVisibility.Size();

    // process only the entries that are present when we start.  (More
    // could be added as we do this.)
    for (i = 0;  i < cEntries;  ++i)
    {
        // In the call to OnPropertyChange, we do not use the propdesc, bcoz, DISPID_A_VISIBILITY is not
        // actually supported by Element, and so, if we provide a propdesc, the call to Findpropdescfromdispid
        // which should actually fail is avoided, and events get fired wrongly
        _aryElementChangeVisibility[i]->OnPropertyChange(DISPID_A_VISIBILITY, ELEMCHNG_CLEARCACHES | ELEMCHNG_INLINESTYLE_PROPERTY);
    }

    // we release in a separate pass - the release code is also called
    // at shutdown
    ReleaseElementChangeVisibility(0, cEntries);
}


//+-------------------------------------------------------------------
//
//  Member:     CDoc::ReleaseElementChangeVisibility
//
//--------------------------------------------------------------------

void
CDoc::ReleaseElementChangeVisibility(int iStart, int iFinish)
{
    Assert(0<=iStart && iStart<=iFinish && iFinish<=_aryElementChangeVisibility.Size());
    int i;

    for (i = iStart;  i < iFinish;  ++i)
    {
        _aryElementChangeVisibility[i]->SubRelease();
    }

    if (iFinish > iStart)
    {
        _aryElementChangeVisibility.DeleteMultiple(iStart, iFinish-1);
    }

    // if there are still unprocessed requests (and we're not shutting down),
    // post another message to get them processed.
    if (_aryElementChangeVisibility.Size() > 0 && !TestLock(FORMLOCK_UNLOADING))
    {
        GWPostMethodCall(
            this, ONCALL_METHOD(CDoc, ProcessElementChangeVisibility, processelementchangevisibility),
            0, FALSE, "CDoc::ProcessElementChangeVisibility");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\paint.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1995
//
//  File:       paint.cxx
//
//  Contents:   Painting and invalidation
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_COLOR3D_HXX_
#define X_COLOR3D_HXX_
#include "color3d.hxx"
#endif

#ifndef X_COLLECT_HXX_
#define X_COLLECT_HXX_
#include "collect.hxx"
#endif

#ifndef X__FONT_H_
#define X__FONT_H_
#include "_font.h"
#endif

#ifndef X_OCMM_H_
#define X_OCMM_H_
#include "ocmm.h"
#endif

#ifndef X_SHELL_H_
#define X_SHELL_H_
#include "shell.h"
#endif

#ifndef X_ELABEL_HXX_
#define X_ELABEL_HXX_
#include "elabel.hxx"
#endif

#ifndef X_INPUTTXT_HXX_
#define X_INPUTTXT_HXX_
#include "inputtxt.hxx"
#endif

#ifndef X_TIMER_HXX_
#define X_TIMER_HXX_
#include "timer.hxx"
#endif

#ifndef X_OLESITE_HXX_
#define X_OLESITE_HXX_
#include "olesite.hxx"
#endif

#ifndef X_PEER_HXX_
#define X_PEER_HXX_
#include "peer.hxx"
#endif

#ifndef X_HYPLNK_HXX_
#define X_HYPLNK_HXX_
#include "hyplnk.hxx"
#endif

#ifndef X_EAREA_HXX_
#define X_EAREA_HXX_
#include "earea.hxx"
#endif

#ifndef X_DEBUGPAINT_HXX_
#define X_DEBUGPAINT_HXX_
#include "debugpaint.hxx"
#endif

#ifndef X_SHAPE_HXX_
#define X_SHAPE_HXX_
#include "shape.hxx"
#endif

#ifndef X_LTABLE_HXX_
#define X_LTABLE_HXX_
#include "ltable.hxx"
#endif

#ifndef X_LAYOUT_HXX_
#define X_LAYOUT_HXX_
#include "layout.hxx"
#endif

#ifndef X_UPDSINK_HXX_
#define X_UPDSINK_HXX_
#include "updsink.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X_ROOTELEM_HXX
#define X_ROOTELEM_HXX
#include "rootelem.hxx"
#endif

#ifndef X_CDUTIL_HXX_
#define X_CDUTIL_HXX_
#include "cdutil.hxx"
#endif

#ifdef WIN16
#ifndef X_PRINT_H_
#define X_PRINT_H_
#include <print.h>
#endif
#ifndef UNICODE
#define iswspace isspace
#endif
#endif // WIN16

#ifndef X_SWITCHES_HXX_
#define X_SWITCHES_HXX_
#include "switches.hxx"
#endif

#ifndef X_DISPSURFACE_HXX_
#define X_DISPSURFACE_HXX_
#include "dispsurface.hxx"
#endif

DeclareTagOther(tagPaintShow,    "DocPaintShow",    "erase bkgnd before paint")
DeclareTagOther(tagPaintPause,   "DocPaintPause",   "pause briefly before paint")
DeclareTagOther(tagPaintWait,    "DocPaintWait",    "wait for shift key before paint")
PerfDbgTagOther(tagInvalShow,    "DocInvalShow",    "paint hatched brush over invalidated areas")
PerfDbgTagOther(tagInvalWait,    "DocInvalWait",    "wait after invalidating")
PerfDbgTagOther(tagInvalPaint,	 "DocInvalPaint",   "paint during invalidation")
PerfDbgTag(tagDocPaint,          "DocPaint",        "painting")
DeclareTag(tagFormInval,         "DocInval",        "invalidation")
DeclareTag(tagFormInvalT,        "DocInvalStack",   "invalidation stack trace")
DeclareTag(tagPrintClearBkgrnd,  "Print",           "No parent site background clearing")
PerfDbgTag(tagNoGdiBatch,        "DocBatch",        "disable GDI batching")
PerfDbgTag(tagNoOffScr,          "DocOffScreen",    "disable off-screen rendering")
PerfDbgTag(tagNoTile,            "DocTile",         "disable tiling")
DeclareTagOther(tagForceClip,    "DocForceClip",    "force physical clipping always");
DeclareTagOther(tagUpdateInt,    "DocUpdateInt",    "trace UpdateInterval stuff");
DeclareTag(tagTile,              "DocTile",         "tiling information");
DeclareTag(tagDisEraseBkgnd,     "Erase Background: disable", "Disable erase background")
MtDefine(CSiteDrawList, Locals, "CSiteDrawList")
MtDefine(CSiteDrawList_pv, CSiteDrawList, "CSiteDrawList::_pv")
MtDefine(CSiteDrawSiteList_aryElements_pv, Locals, "CSite::DrawSiteList aryElements::_pv")
MtDefine(CSiteGetSiteDrawList_aryElements_pv, Locals, "CSite::GetSiteDrawList aryElements::_pv")

ExternTag(tagPalette);
ExternTag(tagTimePaint);
ExternTag(tagView);

#ifdef PRODUCT_PROF_FERG
// for PROFILING perposes only
extern "C" void _stdcall ResumeCAP(void);
extern "C" void _stdcall SuspendCAP(void);
#endif

//+------------------------------------------------------------------------
//
//  Function:   DumpRgn
//
//  Synopsis:   Write region to debug output
//
//-------------------------------------------------------------------------

#if DBG==1
void
DumpRgn(HRGN hrgn)
{
    struct
    {
        RGNDATAHEADER rdh;
        RECT arc[128];
    } data;

    if (GetRegionData(hrgn, ARRAY_SIZE(data.arc), (RGNDATA *)&data) != 1)
    {
        TraceTag((0, "HRGN=%08x: buffer too small", hrgn));
    }
    else
    {
        TraceTag((0, "HRGN=%08x, iType=%d, nCount=%d, nRgnSize=%d, t=%d b=%d l=%d r=%d",
                hrgn,
                data.rdh.iType,
                data.rdh.nCount,
                data.rdh.nRgnSize,
                data.rdh.rcBound.top,
                data.rdh.rcBound.bottom,
                data.rdh.rcBound.left,
                data.rdh.rcBound.right));
        for (DWORD i = 0; i < data.rdh.nCount; i++)
        {
            TraceTag((0, "    t=%d, b=%d, l=%d, r=%d",
                data.arc[i].top,
                data.arc[i].left,
                data.arc[i].bottom,
                data.arc[i].right));
        }
    }
}
#endif

//+------------------------------------------------------------------------
//
//  Member:     CDoc::UpdateForm
//
//  Synopsis:   Update the form's window
//
//-------------------------------------------------------------------------

void
CDoc::UpdateForm()
{
    if (_pInPlace)
    {
        UpdateChildTree(_pInPlace->_hwnd);
    }
}

//+------------------------------------------------------------------------
//
//  Member:     CDoc::Invalidate
//
//  Synopsis:   Invalidate an area in the form.
//
//              We keep track of whether the background should be
//              erased on paint privately.  If we let Windows keep
//              track of this, then we can get flashing because
//              the WM_ERASEBKGND message can be delivered far in
//              advance of the WM_PAINT message.
//
//              Invalidation flags:
//
//              INVAL_CHILDWINDOWS
//                  Invaildate child windows. Causes the RDW_ALLCHILDREN
//                  flag to be passed to RedrawWindow.
//
//  Arguments:  prc         The physical rectangle to invalidate.
//              prcClip     Clip invalidation against this rectangle.
//              hrgn        ...or, the region to invalidate.
//              dwFlags     See description above.
//
//-------------------------------------------------------------------------

void
CDoc::Invalidate(const RECT *prc, const RECT *prcClip, HRGN hrgn, DWORD dwFlags)
{
    UINT uFlags;
    RECT rc;
    
    if (_state >= OS_INPLACE)
    {
        if (prcClip)
        {
            Assert(prc);
            if (!IntersectRect(&rc, prc, prcClip))
                return;

            prc = &rc;
        }

        // Do not invalidate when not yet INTERACTIVE.
        
        // INTERACTIVE is when we want to start doing our own drawing. It means we've had
        // to process an externally triggered WM_PAINT, or we've loaded enough of the
        // document to draw the initial scroll position correctly, or five seconds
        // have passed since we've tried to do the initial scroll position.

        if (LoadStatus() < LOADSTATUS_INTERACTIVE)
        {
            _fInvalNoninteractive = TRUE; // When we become interactive, we must inval
            return;
        }


#if (DBG==1 || defined(PERFTAGS)) && !defined(WINCE)
#if DBG==1
        if (prc)
        {
            TraceTag((tagFormInval,
                    "%08lX Inval%s l=%ld, t=%ld, r=%ld, b=%ld",
                    this,
                    dwFlags & INVAL_CHILDWINDOWS ? " CHILD" : "",
                    prc->left, prc->top, prc->right, prc->bottom));
        }
        else
        {
            TraceTag((tagFormInval, "%08lX Inval%s",
                    this,
                    dwFlags & INVAL_CHILDWINDOWS ? " CHILD" : ""));
        }
        TraceCallers(tagFormInvalT, 2, 4);
#endif

        if (IsPerfDbgEnabled(tagInvalShow))
        {
            static int s_iclr;
            static COLORREF s_aclr[] =
            {
                    RGB(255, 0, 0), RGB(0, 255, 0),
                    RGB(255, 255, 0), RGB(0, 255, 255),
            };

            s_iclr = (s_iclr + 1) % ARRAY_SIZE(s_aclr);
            HDC hdc = ::GetDC(_pInPlace->_hwnd);
            HBRUSH hbrush = CreateHatchBrush(HS_DIAGCROSS, s_aclr[s_iclr]);
            int bkMode = SetBkMode(hdc, TRANSPARENT);
            if (prc)
            {
                FillRect(hdc, prc, hbrush);
            }
            else if (hrgn)
            {
                FillRgn(hdc, hrgn, hbrush);
            }
            DeleteObject((HGDIOBJ)hbrush);
            SetBkMode(hdc, bkMode);
            ::ReleaseDC(_pInPlace->_hwnd, hdc);
        }
        if (IsPerfDbgEnabled(tagInvalWait))
            Sleep(120);
#endif // (DBG==1 || defined(PERFTAGS)) && !defined(WINCE)

        uFlags = RDW_INVALIDATE | RDW_NOERASE;


#if defined(PERFTAGS)
        if (IsPerfDbgEnabled(tagInvalPaint))
            uFlags |= RDW_UPDATENOW;
#endif

        if (dwFlags & INVAL_CHILDWINDOWS)
        {
            uFlags |= RDW_ALLCHILDREN;
        }

        Assert(_pInPlace && " about to crash");

        _cInval++;

        if ( !_pUpdateIntSink )
        {
            RedrawWindow(_pInPlace->_hwnd, prc, hrgn, uFlags);
        }
        else if ( _pUpdateIntSink->_state < UPDATEINTERVAL_ALL )
        {
            // accumulate invalid rgns until the updateInterval timer fires
            HRGN    hrgnSrc;
            TraceTag((tagUpdateInt, "Accumulating invalid Rect/Rgn"));
            if ( prc )
            {
                hrgnSrc = CreateRectRgnIndirect( prc );
                if ( !hrgnSrc )
                {
                    RedrawWindow(_pInPlace->_hwnd, prc, hrgn, uFlags);
                }
                else if ( UPDATEINTERVAL_EMPTY == _pUpdateIntSink->_state )
                {
                    _pUpdateIntSink->_hrgn = hrgnSrc;
                    _pUpdateIntSink->_state = UPDATEINTERVAL_REGION;
                    _pUpdateIntSink->_dwFlags |= uFlags;
                }
                else
                {
                    Assert( UPDATEINTERVAL_REGION == _pUpdateIntSink->_state );
                    if ( ERROR == CombineRgn(_pUpdateIntSink->_hrgn,
                                             _pUpdateIntSink->_hrgn,
                                             hrgnSrc, RGN_OR) )
                    {
                        TraceTag((tagUpdateInt, "Error in accumulating invalid Rect"));
                        RedrawWindow(_pInPlace->_hwnd, prc, hrgn, uFlags);
                    }
                    else
                    {
                        _pUpdateIntSink->_dwFlags |= uFlags;
                    }
                    DeleteObject( hrgnSrc );
                }
            }
            else if ( hrgn )
            {
                if ( UPDATEINTERVAL_EMPTY == _pUpdateIntSink->_state )
                {
                    _pUpdateIntSink->_hrgn = hrgn;
                    _pUpdateIntSink->_state = UPDATEINTERVAL_REGION;
                    _pUpdateIntSink->_dwFlags |= uFlags;
                }
                else
                {
                    Assert( UPDATEINTERVAL_REGION == _pUpdateIntSink->_state );
                    if ( ERROR == CombineRgn(_pUpdateIntSink->_hrgn,
                                             _pUpdateIntSink->_hrgn,
                                             hrgn, RGN_OR) )
                    {
                        TraceTag((tagUpdateInt, "Error in accumulating invalid Rgn"));
                        RedrawWindow(_pInPlace->_hwnd, prc, hrgn, uFlags);
                    }
                    else
                    {
                        _pUpdateIntSink->_dwFlags |= uFlags;
                    }
                }
            }
            else
            {
                // update entire client area, no need to accumulate anymore
                _pUpdateIntSink->_state = UPDATEINTERVAL_ALL;
                DeleteObject( _pUpdateIntSink->_hrgn );
                _pUpdateIntSink->_hrgn = NULL;
                _pUpdateIntSink->_dwFlags |= uFlags;
            }
        }

        OnViewChange(DVASPECT_CONTENT);
    }
}


//+------------------------------------------------------------------------
//
//  Member:     CDoc::Invalidate
//
//  Synopsis:   Invalidate the form's entire area.
//
//-------------------------------------------------------------------------

void
CDoc::Invalidate()
{
    Invalidate(NULL, NULL, NULL, 0);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::DisabledTilePaint()
//
//  Synopsis:   return true if tiled painting disabled
//
//----------------------------------------------------------------------------

inline BOOL
CDoc::TiledPaintDisabled()
{
#if DBG==1 || defined(PERFTAGS)
    if (IsPerfDbgEnabled(tagNoTile))
        return TRUE;
#endif

    return _fDisableTiledPaint;
}

#ifdef DISPLAY_FRAMERATE  //turn this on to get a framerate printed in the upper left corner of the primary display   
void
CDoc::UpdateFrameRate()
{
    static int iPaintCount = 0;
    static LARGE_INTEGER liLastOutput;
    LARGE_INTEGER liCurTime;
    static LARGE_INTEGER liFrequency;
    static bool bFirstTime = true;

    if (bFirstTime == true) //need to determine the counter frequency
    {
        bFirstTime = false;
        QueryPerformanceFrequency(&liFrequency);
        QueryPerformanceCounter(&liLastOutput);
    }
    
    iPaintCount++;

    QueryPerformanceCounter(&liCurTime);

    //output performance numbers
    if ((liCurTime.QuadPart - liLastOutput.QuadPart) >= liFrequency.QuadPart) //at least a second has past
    {
        WCHAR cFrameRate[25] = {0};
        HDC dc = 0;
        COLORREF color = CLR_INVALID;
        // create the string
        wsprintfW(cFrameRate, L"framerate: %d   \n", iPaintCount);
        //get the HDC to the desktop
        dc = ::GetDC(0); 

        //output the string
        ::MoveToEx(dc, 10, 10, NULL);
        color = ::SetBkColor(dc, RGB(50, 255, 50));
        ::ExtTextOut(dc, 10, 10, ETO_OPAQUE, NULL, cFrameRate, 13, NULL);
        if (color != CLR_INVALID)
        {
            //restore the background color
            ::SetBkColor(dc, color);
        }
        //release the DC
        ::ReleaseDC(0, dc);

        //update the framerate values
        iPaintCount = 0;
        liLastOutput = liCurTime;
    }
}
#endif //DISPLAY_FRAMERATE

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::OnPaint
//
//  Synopsis:   Handle WM_PAINT
//
//----------------------------------------------------------------------------

#ifndef NO_RANDOMRGN
typedef int WINAPI GETRANDOMRGN(HDC, HRGN, int);
static GETRANDOMRGN * s_pfnGetRandomRgn;
static BOOL s_fGetRandomRgnFetched = FALSE;
#endif

void
CDoc::OnPaint()
{
    IF_WIN16(RECT rc;)
    PAINTSTRUCT         ps;
    CFormDrawInfo       DI;
    BOOL                fViewIsReady;
    BOOL                fHtPalette;
#ifndef NO_RANDOMRGN
    HRGN                hrgn = NULL;
    POINT               ptBefore;
    POINT               ptAfter;
#endif
    HWND                hwndInplace;
#ifndef NO_ETW_TRACING
    BOOL                fNoPaint = FALSE;
#endif

    TraceTagEx((tagView, TAG_NONAME,
           "View : CDoc::OnPaint"));

#ifdef DISPLAY_FRAMERATE  //turn this on to get a framerate printed in the upper left corner of the primary display
        UpdateFrameRate();
#endif //DISPLAY_FRAMERATE

    _fInvalInScript = FALSE;

    DI._hdc = NULL;

    // Don't allow OnPaint to recurse.  This can occur as a result of the
    // call to RedrawWindow in a random control.

    // TODO: StylesheetDownload should be linked to the LOADSTATUS interactive?
    if (TestLock(SERVERLOCK_BLOCKPAINT) || IsStylesheetDownload() || _fPageTransitionLockPaint)
    {
        // We get endless paint messages when we try to popup a messagebox...
        // and prevented the messagebox from getting paint !
        BeginPaint(_pInPlace->_hwnd, &ps);
        EndPaint(_pInPlace->_hwnd, &ps);

        // Post a delayed paint to make up for what was missed
        _view.Invalidate(&ps.rcPaint, FALSE, FALSE, FALSE);

        TraceTagEx((tagView, TAG_NONAME,
               "View : CDoc::OnPaint - Exit"));

        return;
    }

    // If we're not interactive by the time we get the first paint, we should be
    if (PrimaryMarkup()->LoadStatus() < LOADSTATUS_INTERACTIVE)
    {
        PrimaryMarkup()->OnLoadStatus(LOADSTATUS_INTERACTIVE);
    }

    PerfDbgLog(tagDocPaint, this, "+CDoc::OnPaint");
    CDebugPaint debugPaint;
    debugPaint.StartTimer();

    fViewIsReady = _view.EnsureView(LAYOUT_SYNCHRONOUS | LAYOUT_INPAINT | LAYOUT_DEFERPAINT);
    Assert( !fViewIsReady
        ||  !_view.IsDisplayTreeOpen());

    CLock Lock(this, SERVERLOCK_BLOCKPAINT);

    SwitchesBegTimer(SWITCHES_TIMER_PAINT);

    // since we're painting, paint any accumulated regions if any
    if ( _pUpdateIntSink && _pUpdateIntSink->_state != UPDATEINTERVAL_EMPTY )
    {
        ::InvalidateRgn( _pInPlace->_hwnd, _pUpdateIntSink->_hrgn, FALSE );
        if ( _pUpdateIntSink->_hrgn )
        {
            DeleteObject( _pUpdateIntSink->_hrgn );
            _pUpdateIntSink->_hrgn = NULL;
            _pUpdateIntSink->_state = UPDATEINTERVAL_EMPTY;
            _pUpdateIntSink->_dwFlags = 0;
        }
    }

#ifndef NO_RANDOMRGN
    ptBefore.x = ptBefore.y = 0;
    MapWindowPoints(_pInPlace->_hwnd, NULL, &ptBefore, 1);
#endif

    // Setup DC for painting.

    // This is bad, in some cases (bug 106098) our _pInplace goes away because
    // one of the controls runs a message loop that gets a message posted by the
    // test program. So on return from paint our _pInPlace is NULL and we crash
    // when doing an EndPaint. THis is why I cache the hwnd in a local variable.
    hwndInplace = _pInPlace->_hwnd;
    BeginPaint(hwndInplace, &ps);

    if (IsRectEmpty(&ps.rcPaint))
    {
        // It appears there are cases when our window is obscured yet
        // internal invalidations still trigger WM_PAINT with a valid
        // update region but the PAINTSTRUCT RECT is empty.
#ifndef NO_ETW_TRACING
        fNoPaint = TRUE;
#endif
        goto Cleanup;
    }

    // If the view could not be properly prepared, accumulate the invalid rectangle and return
    // (The view will issue the invalidation/paint once it is safe to do so)
    if (!fViewIsReady)
    {
        _view.Invalidate(&ps.rcPaint);
        _view.SetFlag(CView::VF_FORCEPAINT);

        TraceTagEx((tagView, TAG_NONAME,
               "View : CDoc::OnPaint - !fViewIsReady, Setting VF_FORCEPAINT for rc(%d, %d, %d, %d)",
               ps.rcPaint.left,
               ps.rcPaint.top,
               ps.rcPaint.right,
               ps.rcPaint.bottom));

#ifndef NO_ETW_TRACING
        fNoPaint = TRUE;
#endif
        goto Cleanup;
    }

#ifndef NO_RANDOMRGN
#ifdef WIN32
    if (!s_fGetRandomRgnFetched)
    {
        s_pfnGetRandomRgn = (GETRANDOMRGN *)GetProcAddress(GetModuleHandleA("GDI32.DLL"), "GetRandomRgn");
        s_fGetRandomRgnFetched = TRUE;
    }

    if (s_pfnGetRandomRgn)
    {
        Verify((hrgn = CreateRectRgnIndirect(&g_Zero.rc)) != NULL);
        Verify(s_pfnGetRandomRgn(ps.hdc, hrgn, 4) != ERROR);
        if (g_dwPlatformID == VER_PLATFORM_WIN32_NT)
        {
            Verify(OffsetRgn(hrgn, -ptBefore.x, -ptBefore.y) != ERROR);
        }

        // Don't trust the region if the window moved in the meantime

        ptAfter.x = ptAfter.y = 0;
        MapWindowPoints(hwndInplace, NULL, &ptAfter, 1);

        if (ptBefore.x != ptAfter.x || ptBefore.y != ptAfter.y)
        {
            Verify(DeleteObject(hrgn));
            hrgn = NULL;
#ifndef NO_ETW_TRACING
            fNoPaint = TRUE;
#endif
            goto Cleanup;
        }
    }
#endif
#endif

    GetPalette(ps.hdc, &fHtPalette);

#ifndef NO_PERFDBG
#if DBG==1
    // If it looks like we are the foreground application, check to see
    // if we have an identify palette.  Turn on "warn if not identity palette"
    // trace tag to see the output.

    if (_pElemUIActive == PrimaryRoot() &&
        _pInPlace->_fFrameActive)
    {
        extern BOOL IsSameAsPhysicalPalette(HPALETTE);
        if (!IsSameAsPhysicalPalette(GetPalette()))
            TraceTag((tagError, "Logical palette does not match physical palette"));
    }
#endif
#endif

#if DBG==1
    if (!CDebugPaint::UseDisplayTree() &&
        (IsTagEnabled(tagPaintShow) || IsTagEnabled(tagPaintPause)))
    {
        // Flash the background.

        HBRUSH hbr;
        static int s_iclr;
        static COLORREF s_aclr[] =
        {
                RGB(  0,   0, 255),
                RGB(  0, 255,   0),
                RGB(  0, 255, 255),
                RGB(255,   0,   0),
                RGB(255,   0, 255),
                RGB(255, 255,   0)
        };

        GetAsyncKeyState(VK_SHIFT);

        do
        {
            // Fill the rect and pause.

            if (IsTagEnabled(tagPaintShow))
            {
                s_iclr = (s_iclr + 1) % ARRAY_SIZE(s_aclr);
                hbr = GetCachedBrush(s_aclr[s_iclr]);
                FillRect(ps.hdc, &ps.rcPaint, hbr);
                ReleaseCachedBrush(hbr);
                GdiFlush();
            }

            if (IsTagEnabled(tagPaintPause))
            {
                DWORD dwTick = GetTickCount();
                while (GetTickCount() - dwTick < 100) ;
            }
        }
        while (GetAsyncKeyState(VK_SHIFT) & 0x8000);
    }
#endif // DBG==1

#if DBG==1 || defined(PERFTAGS)
    if (IsPerfDbgEnabled(tagNoGdiBatch))
        GdiSetBatchLimit(1);
#endif // DBG==1 || defined(PERFTAGS)

    if (_pTimerDraw)
        _pTimerDraw->Freeze(TRUE);      // time stops so controls can synchronize
#if !defined(WIN16) && !defined(NO_RANDOMRGN)
    if (!TiledPaintDisabled())
    {
#endif
        // Invalidation was not on behalf of an ActiveX control.  Paint the
        // document in one pass here and tile if required in CSite::DrawOffscreen.

        DI.Init(CMarkup::GetElementTopHelper(PrimaryMarkup()), XHDC(ps.hdc, NULL));
        DI.CDocScaleInfo::Copy(_dciRender);
        DI._rcClip = ps.rcPaint;
        DI._rcClipSet = ps.rcPaint;
#ifndef NO_RANDOMRGN
        DI._hrgnPaint = hrgn;
#else
        DI._hrgnPaint = NULL;
#endif
        DI._fHtPalette = fHtPalette;

        Assert(!_view.IsDisplayTreeOpen());

#ifndef NO_RANDOMRGN
        _view.RenderView(&DI, DI._hrgnPaint);
#else
#if DBG==1
        int i = GetObjectType(DI._pSurface._hdc);
#endif
        _view.RenderView(&DI, &ps.rcPaint);
#endif
        WHEN_DBG(debugPaint.StopTimer(tagTimePaint, "Display Tree Paint", TRUE));

#if !defined(WIN16) && !defined(NO_RANDOMRGN)
    }
    else
    {
        RECT *   prc;
        int      c;
        struct REGION_DATA
        {
            RGNDATAHEADER rdh;
            RECT          arc[MAX_INVAL_RECTS];
        } rd;

        // Invalidation was on behalf of an ActiveX Control.  We chunk things
        // up here based on the inval region with the hope that the ActiveX
        // Control will be painted in a single pass.  We do this because
        // some ActiveX Controls (controls using Direct Animation are an example)
        // have very bad performance when painted in tiles.

        // if we have more than one invalid rectangle, see if we can combine
        // them so drawing will be more efficient. Windows chops up invalid
        // regions in a funny, but predicable, way to maintain their ordered
        // listing of rectangles. Also, some times it is more efficient to
        // paint a little extra area than to traverse the hierarchy multiple times.

        if (hrgn &&
            GetRegionData(hrgn, sizeof(rd), (RGNDATA *)&rd) &&
            rd.rdh.iType == RDH_RECTANGLES &&
            rd.rdh.nCount <= MAX_INVAL_RECTS)
        {
            c = rd.rdh.nCount;
            prc = rd.arc;

            CombineRectsAggressive(&c, prc);
        }
        else
        {
            c = 1;
            prc = &ps.rcPaint;
        }

        // Paint each rectangle.

        for (; --c >= 0; prc++)
        {
            DI.Init(CMarkup::GetElementTopHelper(PrimaryMarkup()));
            DI._hdc = XHDC(ps.hdc, NULL);
            DI._hic = XHDC(ps.hdc, NULL);
            DI._rcClip = *prc;
            DI._rcClipSet = *prc;
            DI._fHtPalette = fHtPalette;

            if (prc != &ps.rcPaint)
            {
                // If painting the update region in more than one
                // pass and painting directly to the screen, then
                // we explicitly set the clip rectangle to insure correct
                // painting.  If we don't do this, the FillRect for the
                // background of a later pass will clobber the foreground
                // for an earlier pass.

                Assert(DI._hdc == ps.hdc);
                IntersectClipRect(DI._hdc,
                        DI._rcClip.left, DI._rcClip.top,
                        DI._rcClip.right, DI._rcClip.bottom);

            }

            PerfDbgLog6(tagDocPaint, this,
                    "CDoc::OnPaint Draw(i=%d %s l=%ld, t=%ld, r=%ld, b=%ld)",
                    c,
                    DI._hdc != ps.hdc ? "OFF" : "ON",
                    DI._rcClip.left, DI._rcClip.top,
                    DI._rcClip.right, DI._rcClip.bottom);

            _view.RenderView(&DI, &DI._rcClip);

            PerfDbgLog(tagDocPaint, this, "-CDoc::OnPaint Draw");

            if (c != 0)
            {
                // Restore the clip region set above.
                SelectClipRgn(DI._hdc, NULL);
            }
        }
    }
#endif

    if (_pTimerDraw)
        _pTimerDraw->Freeze(FALSE);

Cleanup:
    if (!DI._hdc.IsEmpty())
        SelectPalette(DI._hdc, (HPALETTE)GetStockObject(DEFAULT_PALETTE), TRUE);
    AssertSz(IsWindow(hwndInplace), "oops, the window was destroyed while we were painting");
    EndPaint(hwndInplace, &ps);
    _fDisableTiledPaint = FALSE;

#ifndef NO_ETW_TRACING
    // Send event to ETW if it is enabled by the shell.
    if (!fNoPaint && g_pHtmPerfCtl &&
        (g_pHtmPerfCtl->dwFlags & HTMPF_CALLBACK_ONEVENT)) {
        g_pHtmPerfCtl->pfnCall(EVENT_TRACE_TYPE_BROWSE_PAINT,
                               (TCHAR *)GetPrimaryUrl());
    }
#endif

#ifndef NO_RANDOMRGN
    // Find out if the window moved during paint

    ptAfter.x = ptAfter.y = 0;
    MapWindowPoints(hwndInplace, NULL, &ptAfter, 1);

    if (ptBefore.x != ptAfter.x || ptBefore.y != ptAfter.y)
    {
        TraceTag((tagDocPaint, "CDoc::OnPaint (Window moved during paint!)"));
        Invalidate(hrgn ? NULL : &ps.rcPaint, NULL, hrgn, 0);
    }

    if (hrgn)
    {
        Verify(DeleteObject(hrgn));
    }
#endif

    SwitchesEndTimer(SWITCHES_TIMER_PAINT);

    PerfDbgLog(tagDocPaint, this, "-CDoc::OnPaint");

    TraceTagEx((tagView, TAG_NONAME,
           "View : CDoc::OnPaint - Exit"));
}


//+---------------------------------------------------------------------------
//
//  Member:     CDoc::OnEraseBkgnd
//
//  Synopsis:   Handle WM_ERASEBKGND
//
//----------------------------------------------------------------------------

BOOL
CDoc::OnEraseBkgnd(HDC hdc)
{
    CFormDrawInfo         DI;
    BOOL                  fHtPalette;

    if (   TestLock(SERVERLOCK_BLOCKPAINT) 
        || _fPageTransitionLockPaint)
        return FALSE;

#if DBG==1
    if(IsTagEnabled(tagDisEraseBkgnd))
        return TRUE;
#endif

    // this is evil: some nasty OLE controls (in particular, the IE Label
    // control) pass us their DC and expect us to draw our background into it.
    // This was a hack to try to simulate transparency, but it doesn't
    // even work very well. In this case, we have to avoid normal clipping
    // regions we set on the DC.  Blech.
    BOOL fDrawBackgroundForChildWindow =
        (WindowFromDC(hdc) != InPlace()->_hwnd);

    if (TestLock(SERVERLOCK_IGNOREERASEBKGND) && !fDrawBackgroundForChildWindow)
        return TRUE;

    // Framesets leave the background to the embedded frames.

    if (!fDrawBackgroundForChildWindow && PrimaryMarkup()->_fFrameSet)
        return TRUE;

    SwitchesBegTimer(SWITCHES_TIMER_PAINT);

    PerfDbgLog(tagDocPaint, this, "+CDoc::OnEraseBkgnd");

    CLock Lock(this, SERVERLOCK_BLOCKPAINT);

    GetPalette(hdc, &fHtPalette);
    DI.Init(CMarkup::GetElementTopHelper(PrimaryMarkup()));
    GetClipBox(hdc, &DI._rcClip);
    DI._rcClipSet = DI._rcClip;
    DI._hdc = XHDC(hdc, NULL);
    DI._hic = XHDC(hdc, NULL);
    DI._fInplacePaint = TRUE;
    DI._fHtPalette = fHtPalette;

    PerfDbgLog1(tagDocPaint, this, "CDoc::OnEraseBkgnd l=%ld, t=%ld, r=%ld, b=%ld", *DI.ClipRect());

#if DBG==1

    if (IsTagEnabled(tagPaintShow) || IsTagEnabled(tagPaintPause))
    {
        HBRUSH hbr;

        // Fill the rect with blue and pause.
        hbr = GetCachedBrush(RGB(0,0,255));
        FillRect(hdc, DI.ClipRect(), hbr);
        ReleaseCachedBrush(hbr);
        GdiFlush();
        Sleep(IsTagEnabled(tagPaintPause) ? 160 : 20);
    }
#endif

#ifdef WIN16
        // when OE 16 uses us the option settings are not read immediately,
        // so we check here.
        if ( _pOptionSettings == NULL )
        {
                if ( UpdateFromRegistry(0) )
                        return TRUE;
        }
#endif

    _view.EraseBackground(&DI, &DI._rcClip, fDrawBackgroundForChildWindow);
    
    SwitchesEndTimer(SWITCHES_TIMER_PAINT);

    PerfDbgLog(tagDocPaint, this, "-CDoc::OnEraseBkgnd");

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::Draw, CServer
//
//  Synopsis:   Draw the form.
//              Called from CServer implementation if IViewObject::Draw
//
//----------------------------------------------------------------------------

HRESULT
CDoc::Draw(CDrawInfo * pDI, RECT *prc)
{
    CServer::CLock Lock(this, SERVERLOCK_IGNOREERASEBKGND);

    CFormDrawInfo   DI;
    int             r;
    CSize           sizeOld;
    CSize           sizeNew;
    CPoint          ptOrgOld;
    CPoint          ptOrg;
    HRESULT         hr = S_OK;
    BOOL            fHadView = !!_view.IsActive();

    RECT            rc = *prc;
    float           clientScale[2];
    float*          pClientScale = 0;

    // CLayout *       pLayoutRoot = PrimaryRoot()->GetLayout();

    if (DVASPECT_CONTENT  != pDI->_dwDrawAspect &&
        DVASPECT_DOCPRINT != pDI->_dwDrawAspect)
    {
        RRETURN(DV_E_DVASPECT);
    }

    //
    // Do not display if we haven't received all the stylesheets
    //

    if (IsStylesheetDownload())
        return hr;

    //{
        //(mikhaill 4/6/00) Since in IE 5.5 CDocScaleInfo have lost
        //the ability to scale (not at all yet, however this ability
        //is not used and/or blocked in many places), we need to
        //promote scaling other way. So clientScale[] was added.

        SIZE sizeOutput, sizeDisplay, sizeInch;

        sizeOutput.cx = prc->right - prc->left;
        sizeOutput.cy = prc->bottom - prc->top;

        sizeInch.cx = GetDeviceCaps(pDI->_hic, LOGPIXELSX);
        sizeInch.cy = GetDeviceCaps(pDI->_hic, LOGPIXELSY);

        g_uiDisplay.DeviceFromHimetric(sizeDisplay, _sizel);

        clientScale[0] = float(sizeOutput.cx) / float(sizeDisplay.cx);
        clientScale[1] = float(sizeOutput.cy) / float(sizeDisplay.cy);

        if (clientScale[0] != 1 || clientScale[1] != 1)
            pClientScale = clientScale;

        if (_pInPlace)
        {   //hack size
            SIZE sizeDev;
            sizeDev.cx = MulDiv(_sizel.cx, sizeInch.cx, 2540);
            sizeDev.cy = MulDiv(_sizel.cy, sizeInch.cy, 2540);
            rc = _pInPlace->_rcPos;
            rc.right  = rc.left + sizeDev.cx;
            rc.bottom = rc.top  + sizeDev.cy;

            prc = &rc;
        }
    //}

    //
    // Setup drawing info.
    //

    DI.Init(CMarkup::GetElementTopHelper(PrimaryMarkup()));

    //
    // Copy the CDrawInfo information into CFormDrawInfo
    //

    *(CDrawInfo*)&DI = *pDI;

    ::SetViewportOrgEx(DI._hdc, 0, 0, &ptOrg);

    ((CRect *)prc)->OffsetRect(ptOrg.AsSize());

    DI._pDoc     = this;
    DI._pMarkup  = PrimaryMarkup();
    DI._hrgnClip = CreateRectRgnIndirect(prc);

    r = GetClipRgn(DI._hdc, DI._hrgnClip);
    if (r == -1)
    {
        DeleteObject(DI._hrgnClip);
        DI._hrgnClip = NULL;
    }

#ifdef _MAC
    DI._rcClipSet = (*prc);
#else
    r = GetClipBox(DI._hdc, &DI._rcClip);
    if (r == 0)
    {
        // No clip box, assume very large clip box to start.
        DI._rcClip.left   =
        DI._rcClip.top    = SHRT_MIN;
        DI._rcClip.right  =
        DI._rcClip.bottom = SHRT_MAX;
    }
    DI._rcClipSet = DI._rcClip;
#endif

    DI.SetUnitInfo(&g_uiDisplay);

    Assert(!DI._hic.IsEmpty());

    _dciRender = *((CDocInfo *)&DI);
    
    //
    //  *********************************** HACK FOR HOME PUBLISHER ***********************************
    //
    //  Home Publisher subclasses our HWND, taking control of WM_PAINT processing. Instead of allowing us to
    //  see the WM_PAINT, they catch the message and use IVO::Draw instead. Our asynch collect/send techniques
    //  causes them both performance problems and never-ending loops, as well as scrolling difficulties.
    //  So, the following special cases Home Publisher to make them work better (even though what they're doing
    //  is very, very bad!).
    //
    //  Essentially, the hack assumes that the IVO::Draw call is a replacement for WM_PAINT and behaves just
    //  as if WM_PAINT had been received instead. This only works when the IVO::Draw call is used by our
    //  host to supercede our WM_PAINT handling.
    //
    //  This hack can be removed once we no longer share the layout/display information maintained for our
    //  primary HWND with that used to service an IVO::Draw request.
    //
    //  (brendand)
    //
    //  *********************************** HACK FOR HOME PUBLISHER ***********************************
    //

    if (g_fInHomePublisher98)
    {
        BOOL    fViewIsReady;

        Assert(fHadView);

        fViewIsReady = _view.EnsureView(LAYOUT_SYNCHRONOUS | LAYOUT_INPAINT | LAYOUT_DEFERPAINT);
        Assert( !fViewIsReady
            ||  !_view.IsDisplayTreeOpen());

        if (fViewIsReady)
        {
            _view.RenderView(&DI, DI._hrgnClip, &DI._rcClip);
        }
        else
        {
            _view.Invalidate(&DI._rcClip);
        }
    }

    //
    //  Otherwise, proceed as normal
    //

    else
    {
        CRegion rgnInvalid;

        //
        // Update layout if needed
        // NOTE: Normally, this code should allow the paint to take place (in fact, it should force one), but doing so
        //       can cause problems for clients that use IVO::Draw at odd times.
        //       So, instead of pushing the paint through, the simple collects the invalid region and holds on to it
        //       until it's safe (see below). (brendand)
        //

        if (!fHadView)
        {
            _view.Activate();
        }
        else
        {
            _view.EnsureView(   LAYOUT_NOBACKGROUND
                            |   LAYOUT_SYNCHRONOUS
                            |   LAYOUT_DEFEREVENTS
                            |   LAYOUT_DEFERINVAL
                            |   LAYOUT_DEFERPAINT);

            rgnInvalid = _view._rgnInvalid;
            _view.ClearInvalid();
        }

        _view.GetViewSize(&sizeOld);
        sizeNew = ((CRect *)prc)->Size();

        _view.SetViewSize(sizeNew);

        _view.GetViewPosition(&ptOrgOld);
        _view.SetViewPosition(ptOrg);

        //
        //  In all cases, ensure the view is up-to-date with the passed dimensions
        //  (Do not invalidate the in-place HWND (if any) or do anything else significant as result (e.g., fire events)
        //   since the information backing it all is transient and only relevant to this request.)
        //

        _view.EnsureView(   LAYOUT_FORCE
                        |   LAYOUT_NOBACKGROUND
                        |   LAYOUT_SYNCHRONOUS
                        |   LAYOUT_DEFEREVENTS
                        |   LAYOUT_DEFERENDDEFER
                        |   LAYOUT_DEFERINVAL
                        |   LAYOUT_DEFERPAINT);
        _view.ClearInvalid();

        //
        //  Render the sites.
        //

        _view.RenderView(&DI, DI._hrgnClip, &DI._rcClip, pClientScale);

        //
        // Restore layout if inplace.
        // (Now, bring the view et. al. back in-sync with the document. Again, do not force a paint or any other
        //  significant work during this layout pass. Once it completes, however, re-establish any held invalid
        //  region and post a call such that layout/paint does eventually occur.)
        //

        if (fHadView)
        {
            _view.SetViewSize(sizeOld);
            _view.SetViewPosition(ptOrgOld);
            _view.EnsureView(   LAYOUT_FORCE
                            |   LAYOUT_NOBACKGROUND
                            |   LAYOUT_SYNCHRONOUS
                            |   LAYOUT_DEFEREVENTS
                            |   LAYOUT_DEFERENDDEFER
                            |   LAYOUT_DEFERINVAL
                            |   LAYOUT_DEFERPAINT);
            _view.ClearInvalid();

            if (!rgnInvalid.IsEmpty())
            {
                _view.OpenView();
                _view._rgnInvalid = rgnInvalid;
            }
        }
        else
        {
            _view.Deactivate();
        }
    }

//Cleanup:
    if (DI._hrgnClip)
        DeleteObject(DI._hrgnClip);

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CFormDrawInfo::DrawImageFlags
//
//  Synopsis:   Return DRAWIMAGE flags to be used when drawing with the DI
//
//----------------------------------------------------------------------------
DWORD
CFormDrawInfo::DrawImageFlags()
{
    return _fHtPalette ? 0 : DRAWIMAGE_NHPALETTE;
}

//-----------------------------------------------------
//
//  Member:     GetPalette
//
//  Synopsis:   Returns the current document palette and optionally
//              selects it into the destation DC.
//
//              The palette returned depends on several factors.
//              If there is an ambient palette, we always use that.
//              If the buffer depth or the screen depth is 8 (actually
//              if the screen is palettized) then we use whatever we
//              use _pColors
//      The final choice of palette is affected by several things:
//      _hpalAmbient (modified by OnAmbientPropertyChange)
//      _pColors (modified by InvalidateColors)
//
//

HPALETTE
CDoc::GetPalette(HDC hdc, BOOL *pfHtPal, BOOL * pfPaletteSwitched)
{
    HPALETTE    hpal;
    BOOL        fHtPal;
    BOOL        fPaletteSwitched = FALSE;
    
    // IE5 bug 65066 (dbau)
    // A buggy host can delete our ambient palette without warning us; 
    // let's detect and partially protect against that situation;
    // With a bit of paranoia, we also give _hpalDocument the same treatment.
    
    if (_hpalAmbient && GetObjectType((HGDIOBJ)_hpalAmbient) != OBJ_PAL)
    {
        TraceTag((tagError, "Error! Ambient palette was deleted from underneath mshtml.dll. Clearing value."));
        _hpalAmbient = NULL;
        _fHtAmbientPalette = FALSE;
    }
    
    if (_hpalDocument && GetObjectType((HGDIOBJ)_hpalDocument) != OBJ_PAL)
    {
        TraceTag((tagError, "Error! Document palette was deleted from underneath mshtml.dll. Clearing value."));
        _hpalDocument = NULL;
        _fHtDocumentPalette = FALSE;
    }
    
    hpal = _hpalAmbient;
    fHtPal = _fHtAmbientPalette;
    
    if (!hpal && (_bufferDepth == 8 || (GetDeviceCaps(TLS(hdcDesktop), RASTERCAPS) & RC_PALETTE)))
    {
        if (_hpalDocument)
        {
            hpal = _hpalDocument;
            fHtPal = _fHtDocumentPalette;
        }
        else
        {
            if (!_pColors)
            {
                CColorInfo CI;
                UpdateColors(&CI);
            }

            if (_pColors)
            {
                hpal = _hpalDocument = CreatePalette(_pColors);
                _fHtDocumentPalette = fHtPal = IsHalftonePalette(hpal);
            }
            else
            {
                hpal = GetDefaultPalette();
                fHtPal = TRUE;
            }
        }
    }

    if (pfHtPal)
    {
        *pfHtPal = fHtPal;
    }

    if (hpal && hdc)
    {
        SelectPalette(hdc, hpal, TRUE);
        RealizePalette(hdc);

        fPaletteSwitched = TRUE;
    }
    
    if (pfPaletteSwitched)
    {
        *pfPaletteSwitched = fPaletteSwitched;
    }

    return hpal;
}

//---------------------------------------
//
//  Member:     GetColors
//
//  Synopsis:   Computes the document color set (always for DVASPECT_CONTENT)
//              Unlike IE 3, we don't care about the UIActive control, instead
//              we allow the author to define colors.
//
//
HRESULT
CDoc::GetColors(CColorInfo *pCI)
{
    HRESULT hr = S_OK;

    if (_fGotAuthorPalette)
    {
        // REVIEW - michaelw (Can I count on having a _pDwnDoc)
        Assert(PrimaryMarkup()->GetDwnDoc());
        hr = PrimaryMarkup()->GetDwnDoc()->GetColors(pCI);
    }

    if (SUCCEEDED(hr) && !pCI->IsFull())
    {
        CElement *pElementClient = CMarkup::GetElementClientHelper(PrimaryMarkup());
        
        hr = pElementClient ? pElementClient->GetColors(pCI) : S_FALSE;
    }

    //
    // Add the halftone colors in, only if we are not
    // hosted as a frame.  This isn't the place to
    // add system colors, that will get done by GetColorSet
    //
    if (SUCCEEDED(hr) && !pCI->IsFull())
        hr = pCI->AddColors(236, &g_lpHalftone.ape[10]);

    RRETURN1(hr, S_FALSE);
}

HRESULT
CDoc::UpdateColors(CColorInfo *pCI)
{
    HRESULT hr = GetColors(pCI);

    if (SUCCEEDED(hr))
    {
        hr = pCI->GetColorSet(&_pColors);
    }

    RRETURN1(hr, S_FALSE);
}

STDMETHODIMP
CDoc::GetColorSet(DWORD dwDrawAspect, LONG lindex, void * pvAspect, DVTARGETDEVICE * ptd, HDC hicTargetDev, LPLOGPALETTE * ppColorSet)
{
    if (ppColorSet == NULL)
        RRETURN(E_POINTER);

    HRESULT hr = S_OK;

    // We only cache the colors for DVASPECT_CONTENT

    if (dwDrawAspect != DVASPECT_CONTENT)
    {
        CColorInfo CI(dwDrawAspect, lindex, pvAspect, ptd, hicTargetDev);

        hr = GetColors(&CI);

        if (SUCCEEDED(hr))
            hr = CI.GetColorSet(ppColorSet);
    }
    else
    {
        if (!_pColors)
        {
            CColorInfo CI(dwDrawAspect, lindex, pvAspect, ptd, hicTargetDev);

            hr = UpdateColors(&CI);
        }

        if (hr == S_OK && _pColors)
        {
            unsigned cbColors = GetPaletteSize(_pColors);
            *ppColorSet = (LPLOGPALETTE) CoTaskMemAlloc(cbColors);
            if (*ppColorSet)
            {
                memcpy(*ppColorSet, _pColors, cbColors);
                hr = S_OK;
            }
            else
                hr = E_OUTOFMEMORY;
        }
        else
        {
            *ppColorSet = NULL;
            hr = S_FALSE;
        }
    }

    RRETURN1(hr, S_FALSE);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::InvalidateColors()
//
//  Synopsis:   Invalidates the color set of the document.
//
//----------------------------------------------------------------------------
void
CDoc::InvalidateColors()
{
    TraceTag((tagPalette, "InvalidateColors"));
    if (!_fColorsInvalid)
    {
        _fColorsInvalid = TRUE;

        GWPostMethodCallEx(GetThreadState(), (void *)this,
                           ONCALL_METHOD(CDoc, OnRecalcColors, onrecalccolors),
                           0, FALSE, "CDoc::OnRecalcColors");
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::RecalcColors()
//
//  Synopsis:   Recalcs the colors of the document and if necessary, notify's
//              our container.
//
//----------------------------------------------------------------------------

void
CDoc::OnRecalcColors(DWORD_PTR dwContext)
{
    TraceTag((tagPalette, "OnRecalcColors"));
    LOGPALETTE *pColors = NULL;

    CColorInfo CI;

    if (SUCCEEDED(GetColors(&CI)))
    {
        CI.GetColorSet(&pColors);
    }


    //
    // If the palettes are different, we need to broadcast the change
    //

    if ((pColors == 0) && (_pColors == 0))
        goto Cleanup;

    if (!pColors || !_pColors || ComparePalettes(pColors, _pColors))
    {
        TraceTag((tagPalette, "Document palette has changed!"));
        CoTaskMemFree(_pColors);
        _pColors = pColors;

#if 0
        _fNonhalftonePalette = ComparePalettes((LOGPALETTE *)&g_lpHalftone, pColors);
#endif

        //
        // Force the document palette (if any) to be recreated
        //
        if (_hpalDocument)
        {
            DeleteObject(_hpalDocument);
            _hpalDocument = 0;
            _fHtDocumentPalette = FALSE;
        }

        // If our container doesn't implement the ambient palette then we must
        // be faking it.  Now is the time to broadcast the change.
        if (GetAmbientPalette() == NULL)
        {
            CNotification   nf;

            nf.AmbientPropChange(PrimaryRoot(), (void *)DISPID_AMBIENT_PALETTE);
            BroadcastNotify(&nf);
        }

        //
        // This is the new, efficient way to say that our colors have changed.
        // The shell can avoid setting and advise sink (since it really doesn't
        // need it for any other reason) and just watch for this.  This prevents
        // palette recalcs everytime we do OnViewChange.
        //
        if (_pClientSite)
        {
            IOleCommandTarget *pCT;
            HRESULT hr = THR_NOTRACE(_pClientSite->QueryInterface(IID_IOleCommandTarget, (void **) &pCT));
            if (!hr)
            {
                VARIANT v;

                VariantInit(&v);

                V_VT(&v) = VT_BYREF;
                V_BYREF(&v) = pColors;

                THR_NOTRACE(pCT->Exec(
                        &CGID_ShellDocView,
                        SHDVID_ONCOLORSCHANGE,
                        OLECMDEXECOPT_DONTPROMPTUSER,
                        &v,
                        NULL));
                pCT->Release();
            }
        }
        OnViewChange(DVASPECT_CONTENT);
    }
    else
        CoTaskMemFree(pColors);

Cleanup:
    // Clear the way for the next InvalidateColors to force a RecalcColors.  If
    // for some bizarre reason RecalcColors (and by implication GetColors) causes
    // someone to call InvalidateColors after we've checked them, tough luck.
    _fColorsInvalid = FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::updateInterval
//
//  Synopsis:   Set the paint update interval. Throttles multiple controls
//              that are randomly invalidating into a periodic painting
//              interval.
//
//----------------------------------------------------------------------------
void
CDoc::UpdateInterval(long interval)
{
    ITimerService  *pTM = NULL;
    VARIANT         vtimeMin, vtimeMax, vtimeInt;

    interval = interval < 0 ? 0 : interval; // no negative values
    VariantInit( &vtimeMin );    V_VT(&vtimeMin) = VT_UI4;
    VariantInit( &vtimeMax );    V_VT(&vtimeMax) = VT_UI4;
    VariantInit( &vtimeInt );    V_VT(&vtimeInt) = VT_UI4;

    if ( !_pUpdateIntSink )
    {
        if ( 0 == interval )
            return;

        // allocate timer and sink
        TraceTag((tagUpdateInt, "creating updateInterval sink"));
        Assert( !_pUpdateIntSink );
        _pUpdateIntSink = new CDocUpdateIntSink( this );
        if ( !_pUpdateIntSink )
            goto error;

        if ( FAILED(QueryService( SID_STimerService, IID_ITimerService, (void **)&pTM )) )
            goto error;

        if ( FAILED(pTM->GetNamedTimer( NAMEDTIMER_DRAW,
                                        &_pUpdateIntSink->_pTimer )) )
            goto error;

        pTM->Release();
        pTM = NULL;
    }

    if ( 0 == interval )
    {
        // disabling updateInterval, invalidate what we have
        HRGN    hrgn = _pUpdateIntSink->_hrgn;
        DWORD hrgnFlags = _pUpdateIntSink->_dwFlags;

        TraceTag((tagUpdateInt, "deleting updateInterval sink. Cookie = %d", _pUpdateIntSink->_cookie));
        _pUpdateIntSink->_pDoc = NULL;      // let sink know not to respond.
        _pUpdateIntSink->_pTimer->Unadvise( _pUpdateIntSink->_cookie );
        _pUpdateIntSink->_pTimer->Release();
        _pUpdateIntSink->Release();
        _pUpdateIntSink = NULL;
        Invalidate( NULL, NULL, hrgn, hrgnFlags );
        DeleteObject( hrgn );

    }
    else if ( interval != _pUpdateIntSink->_interval )
    {
        // reset timer interval
        _pUpdateIntSink->_pTimer->GetTime(&vtimeMin);
        V_UI4(&vtimeMax) = 0;
        V_UI4(&vtimeInt) = interval;
        _pUpdateIntSink->_pTimer->Unadvise( _pUpdateIntSink->_cookie );     // ok if 0
        if ( FAILED(_pUpdateIntSink->_pTimer->Advise(vtimeMin, vtimeMax,
                                                     vtimeInt, 0,
                                                     (ITimerSink *)_pUpdateIntSink,
                                                     &_pUpdateIntSink->_cookie )) )
            goto error;

        _pUpdateIntSink->_interval = interval;
        TraceTag((tagUpdateInt, "setting updateInterval = %d", _pUpdateIntSink->_interval));
    }

cleanup:
    return;

error:
    if ( _pUpdateIntSink )
    {
        ReleaseInterface( _pUpdateIntSink->_pTimer );
        _pUpdateIntSink->Release();
        _pUpdateIntSink = NULL;
    }
    ReleaseInterface( pTM );
    goto cleanup;
}

LONG CDoc::GetUpdateInterval()
{
    return _pUpdateIntSink ? _pUpdateIntSink->_interval : 0;
}

BOOL IntersectRgnRect(HRGN hrgn, RECT *prc, RECT *prcIntersect)
{
    BOOL fIntersects;
    HRGN hrgnScratch;

    if (!hrgn)
    {
        Assert(prc && prcIntersect);

        *prcIntersect = *prc;
        fIntersects = TRUE;

        return fIntersects;
    }

    hrgnScratch = CreateRectRgnIndirect(prc);
    if (hrgnScratch)
    {
        switch (CombineRgn(hrgnScratch, hrgnScratch, hrgn, RGN_AND))
        {
        case NULLREGION:
            memset(prcIntersect, 0, sizeof(*prcIntersect));
            fIntersects = FALSE;
            break;

        default:
            if (GetRgnBox(hrgnScratch, prcIntersect) != ERROR)
            {
                fIntersects = TRUE;
                break;
            }
            // fall through

        case ERROR:
            *prcIntersect = *prc;
            fIntersects = TRUE;
            break;
        }

        DeleteObject(hrgnScratch);
    }
    else
        fIntersects = FALSE;

    return fIntersects;
}


/******************************************************************************
                CDocUpdateIntSink
******************************************************************************/
CDocUpdateIntSink::CDocUpdateIntSink( CDoc *pDoc )
{
    _pDoc = pDoc;
    _hrgn = 0;
    _dwFlags = 0;
    _state = UPDATEINTERVAL_EMPTY;
    _interval = 0;
    _pTimer = NULL;
    _cookie = 0;
    _ulRefs = 1;
}

CDocUpdateIntSink::~CDocUpdateIntSink( )
{
    Assert( !_pDoc );     // Makes sure CDoc knows we are on our way out.
}

ULONG
CDocUpdateIntSink::AddRef()
{
    return ++_ulRefs;
}

ULONG
CDocUpdateIntSink::Release()
{
    if ( 0 == --_ulRefs )
    {
        delete this;
        return 0;
    }
    return _ulRefs;
}

//+-------------------------------------------------------------------------
//
//  Member:     QueryInterface
//
//  Synopsis:   IUnknown implementation.
//
//  Arguments:  the usual
//
//  Returns:    HRESULT
//
//--------------------------------------------------------------------------
HRESULT
CDocUpdateIntSink::QueryInterface(REFIID iid, void **ppv)
{
    if ( !ppv )
        RRETURN(E_POINTER);

    *ppv = NULL;
    switch (iid.Data1)
    {
        QI_INHERITS((ITimerSink *)this, IUnknown)
        QI_INHERITS(this, ITimerSink)
        default:
            break;
    }

    if (*ppv)
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }

    RRETURN(E_NOINTERFACE);
}

//+----------------------------------------------------------------------------
//
//  Method:     OnTimer             [ITimerSink]
//
//  Synopsis:   Takes the accumulated region and invalidates the window
//
//  Arguments:  timeAdvie - the time that the advise was set.
//
//  Returns:    S_OK
//
//-----------------------------------------------------------------------------
HRESULT
CDocUpdateIntSink::OnTimer( VARIANT vtimeAdvise )
{
    TraceTag((tagUpdateInt, "CDocUpdateIntSink::OnTimer "));
    if ( _state != UPDATEINTERVAL_EMPTY &&
         _pDoc && _pDoc->_state >= OS_INPLACE &&
         _pDoc->LoadStatus() >= LOADSTATUS_INTERACTIVE )
    {
        TraceTag((tagUpdateInt, "CDocUpdateIntSink::OnTimer redrawing window at %d", V_UI4(&vtimeAdvise) ));
        Assert(_pDoc->_pInPlace);

        Assert(_pDoc->_pInPlace->_hwnd);
        RedrawWindow( _pDoc->_pInPlace->_hwnd, (GDIRECT *)NULL, _hrgn, _dwFlags );

        if ( _hrgn )
        {
            DeleteObject( _hrgn );
            _hrgn = NULL;
        }
        _state = UPDATEINTERVAL_EMPTY;
        _dwFlags = 0;

        UpdateWindow( _pDoc->_pInPlace->_hwnd );
    }
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CFormDrawInfo::Init
//
//  Synopsis:   Initialize paint info for painting to form's hwnd
//
//----------------------------------------------------------------------------

void
CFormDrawInfo::Init(
    XHDC    hdc,
    RECT *  prcClip)
{
    _hdc = (hdc != NULL) ?
                hdc :
                XHDC(TLS(hdcDesktop), NULL);
    _hic = _hdc;

    _fInplacePaint = TRUE;
    _dwDrawAspect  = DVASPECT_CONTENT;
    _lindex        = -1;

    _dvai.cb       = sizeof(_dvai);
    _dvai.dwFlags  = DVASPECTINFOFLAG_CANOPTIMIZE;
    _pvAspect      = (void *)&_dvai;

    _rcClip.top    =
    _rcClip.left   = LONG_MIN;
    _rcClip.bottom =
    _rcClip.right  = LONG_MAX;

    // TODO (KTam, GregLett): Do we need equivalent functionality
    // to FixupForPrint under NATIVE_FRAME?
    if(_pDoc->State()     >= OS_INPLACE            &&
             _pDoc->LoadStatus() >= LOADSTATUS_INTERACTIVE )
    {
        IntersectRect(&_rcClipSet,
                      &_pDoc->_pInPlace->_rcClip,
                      &_pDoc->_pInPlace->_rcPos);
    }
    else
    {
        _rcClipSet = g_Zero.rc;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CFormDrawInfo::Init
//
//  Synopsis:   Initialize paint info for painting to form's hwnd
//
//----------------------------------------------------------------------------

void
CFormDrawInfo::Init(
    CElement * pElement,
    XHDC    hdc,
    RECT *  prcClip)
{
    memset(this, 0, sizeof(*this));

    Assert(pElement);

    CDocInfo::Init(pElement);

    Init(hdc, prcClip);

    InitToSite(pElement->GetUpdatedLayout(), prcClip);
}

//+---------------------------------------------------------------------------
//
//  Member:     CFormDrawInfo::Init
//
//  Synopsis:   Initialize paint info for painting to form's hwnd
//
//----------------------------------------------------------------------------

void
CFormDrawInfo::Init(
    CLayout * pLayout,
    XHDC    hdc,
    RECT *  prcClip)
{
    Assert(pLayout);

    Init(pLayout->ElementOwner(), hdc, prcClip);
}

//+---------------------------------------------------------------------------
//
//  Member:     CFormDrawInfo::InitToSite
//
//  Synopsis:   Reduce/set the clipping RECT to the visible portion of
//              the passed CSite
//
//----------------------------------------------------------------------------

void
CFormDrawInfo::InitToSite(CLayout * pLayout, RECT * prcClip)
{
    RECT    rcClip;
    RECT    rcUserClip;

    //
    // For CRootElement (no layout) on normal documents,
    // initialize the clip RECT to that of the entire document
    //
    if (!pLayout && !_pMarkup->IsPrintMedia())
    {
        if (_pDoc->State()     >= OS_INPLACE            &&
            _pDoc->LoadStatus() >= LOADSTATUS_INTERACTIVE )
        {
            IntersectRect(&rcClip,
                          &_pDoc->_pInPlace->_rcClip,
                          &_pDoc->_pInPlace->_rcPos);
        }
        else
        {
            rcClip = g_Zero.rc;
        }

        rcUserClip = rcClip;
    }

    //
    // For all sites other than CRootSite or CRootSite on print documents,
    // set _rcClip to the visible client RECT
    // NOTE: Do not pass _rcClip to prevent its modification during initialization
    //

    else
    {
// TODO: This needs to be fixed! (brendand)
        rcClip     =
        rcUserClip = g_Zero.rc;
    }

    //
    // Reduce the current clipping RECT
    //

    IntersectRect(&_rcClip, &_rcClip, &rcClip);

    //
    // If the clip RECT is empty, canonicalize it to all zeros
    //

    if (IsRectEmpty(&_rcClip))
    {
        _rcClip = g_Zero.rc;
    }

    //
    // If passed a clipping RECT, use it to reduce the clip RECT
    //

    if (prcClip)
    {
        IntersectRect (&_rcClip, &_rcClip, prcClip);
    }
}



//+---------------------------------------------------------------------------
//
//  Member:     GetDC, GetGlobalDC, GetDirectDrawSurface, GetSurface
//
//  Synopsis:   Each of these is a simple layer over the true CDispSurface call
//
//----------------------------------------------------------------------------

XHDC
CFormDrawInfo::GetDC(const RECT& rcWillDraw, BOOL fGlobalCoords)
{
    if (_pSurface)
    {
        HDC hdcT;
        _pSurface->SetClip(rcWillDraw, fGlobalCoords);
        _pSurface->GetDC(&hdcT);
        _hdc = XHDC(hdcT, _pSurface);
    }
    else
    {
        _hdc = NULL;
    }

    return _hdc;
}


HRESULT
CFormDrawInfo::GetDirectDrawSurface(
    IDirectDrawSurface **   ppSurface,
    SIZE *                  pOffset)
{
    return _pSurface
                ? _pSurface->GetDirectDrawSurface(ppSurface, pOffset)
                : E_FAIL;
}


HRESULT
CFormDrawInfo::GetSurface(
    BOOL        fPhysicallyClip,
    const IID & iid,
    void **     ppv,
    SIZE *      pOffset)
{
    HRESULT hr =  _pSurface
                ? _pSurface->GetSurface(iid, ppv, pOffset)
                : E_FAIL;

    if (!hr)
    {
        Assert(_pSurface);
        _pSurface->SetClip( fPhysicallyClip ? _rc : _rcClip );
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CSetDrawInfo::CSetDrawInfo
//
//  Synopsis:   Initialize a CSetDrawInfo
//
//----------------------------------------------------------------------------

CSetDrawSurface::CSetDrawSurface(
    CFormDrawInfo * pDI,
    const RECT *    prcBounds,
    const RECT *    prcRedraw,
    CDispSurface *  pSurface)
{
    Assert(pDI);
    Assert(pSurface);

    _pDI      = pDI;
    _hdc      = pDI->_hdc;
    _pSurface = pDI->_pSurface;

    _pDI->_pSurface = pSurface;
    _pDI->_rc       = *prcBounds;
    _pDI->_rcClip   = *prcRedraw;
    _pDI->_fIsMemoryDC = _pDI->_pSurface->IsMemory();
    _pDI->_fIsMetafile = _pDI->_pSurface->IsMetafile();
}


//+---------------------------------------------------------------------------
//
//  Member:     CDocInfo::Init
//
//  Synopsis:   Initialize a CDocInfo.
//
//----------------------------------------------------------------------------

void
CDocInfo::Init(CElement * pElement)
{
    Assert(pElement);

    //  TODO  The _pDoc set here will be overwritten in the memcpy Init below.
    _pDoc = pElement->Doc();
    Assert(_pDoc);

    Init(_pDoc->GetView()->GetMeasuringDevice(mediaTypeNotSet));

    _pMarkup = pElement->GetMarkup();
    Assert(_pMarkup);
}

//+---------------------------------------------------------------------------
//
//  Member:     CParentInfo::Init
//
//  Synopsis:   Initialize a CParentInfo.
//
//----------------------------------------------------------------------------

void
CParentInfo::Init()
{
    _sizeParent = g_Zero.size;
}

void
CParentInfo::Init(const CDocInfo * pdci)
{
    Assert(pdci);

    ::memcpy(this, pdci, sizeof(CDocInfo));

    Init();
}

void
CParentInfo::Init(const CCalcInfo * pci)
{
    ::memcpy(this, pci, sizeof(CParentInfo));
}

void
CParentInfo::Init(SIZE * psizeParent)
{
    SizeToParent(psizeParent
                    ? psizeParent
                    : &g_Zero.size);
}

void
CParentInfo::Init(CLayout * pLayout)
{
    Assert(pLayout);
    
    CDocInfo::Init(pLayout->ElementOwner());

    // Pick up measurement resolution from context if available.

    SetLayoutContext( pLayout->DefinedLayoutContext() );
    if ( !GetLayoutContext() )
        SetLayoutContext( pLayout->LayoutContext() );

    CLayoutContext *pLayoutContext = GetLayoutContext();

    if ( pLayoutContext
        && pLayoutContext->IsValid())
    {
        CDocScaleInfo::Copy(*pLayoutContext->GetMeasureInfo());
    }
    
    SizeToParent(pLayout);

    Assert(pLayoutContext || (!pLayout->DefinedLayoutContext() && !pLayout->LayoutContext()));
    Assert(    pLayout->DefinedLayoutContext() == pLayoutContext
           || !pLayout->DefinedLayoutContext() && pLayout->LayoutContext() == pLayoutContext);
}

//+---------------------------------------------------------------------------
//
//  Member:     CParentInfo::SizeToParent
//
//  Synopsis:   Set the parent size to the client RECT of the passed CLayout
//
//----------------------------------------------------------------------------

void
CParentInfo::SizeToParent(CLayout * pLayout)
{
    RECT    rc;

    Assert(pLayout);

    pLayout->GetClientRect(&rc);
    SizeToParent(&rc);
}

//+---------------------------------------------------------------------------
//
//  Member:     CCalcInfo::Init
//
//  Synopsis:   Initialize a CCalcInfo.
//
//----------------------------------------------------------------------------

void
CCalcInfo::Init()
{
    _smMode     = SIZEMODE_NATURAL;
    _grfLayout  = 0L;
    _hdc        = XHDC(( _pDoc ? _pDoc->GetHDC() : TLS(hdcDesktop) ), NULL);
    _cyAvail    = 0;
    _cxAvailForVert = 0;
    _yConsumed  = 0;
    _yBaseLine  = 0;
    _grfFlags   = 0;
    _sizeParentForVert = _sizeParent;
}

void
CCalcInfo::Init(const CDocInfo * pdci, CLayout * pLayout)
{
    CView *     pView;
    DWORD       grfState;

    Assert(pdci);
    Assert(pLayout);

    ::memcpy(this, pdci, sizeof(CDocInfo));

    CParentInfo::Init(pLayout);

    Init();

    pView = pLayout->GetView();
    Assert(pView);

    grfState = pView->GetState();

    if (!(grfState & (CView::VS_OPEN | CView::VS_INLAYOUT | CView::VS_INRENDER)))
    {
        Verify(pView->OpenView());
    }
    
    Assert(GetLayoutContext() || (!pLayout->DefinedLayoutContext() && !pLayout->LayoutContext()));
}

void
CCalcInfo::Init(CLayout * pLayout, SIZE * psizeParent, XHDC hdc)
{
    CView *     pView;
    DWORD       grfState;

    CParentInfo::Init(pLayout);

    _smMode    = SIZEMODE_NATURAL;
    _grfLayout = 0L;

    // If a DC was passed in, use that one - else ask the doc which DC to use.
    // Only if there is no doc yet, use the desktop DC.
    if (hdc != NULL)
        _hdc = hdc;
    else if (_pDoc)
        _hdc = XHDC(_pDoc->GetHDC(), NULL);
    else
        _hdc = XHDC(TLS(hdcDesktop), NULL);

    _cyAvail   = 0;
    _cxAvailForVert = 0;
    _yConsumed = 0;
    _yBaseLine = 0;
    _grfFlags  = 0;
    _sizeParentForVert = _sizeParent;
    
    pView = pLayout->GetView();
    Assert(pView);

    grfState = pView->GetState();

    if (!(grfState & (CView::VS_OPEN | CView::VS_INLAYOUT | CView::VS_INRENDER)))
    {
        Verify(pView->OpenView());
    }
    
    Assert(GetLayoutContext() || (!pLayout->DefinedLayoutContext() && !pLayout->LayoutContext()));
}

#if DBG == 1
const TCHAR * achSizeModeNames[SIZEMODE_MAX] =
{
    _T("NATURAL"),      // SIZEMODE_NATURAL
    _T("SET"),          // SIZEMODE_SET
    _T("FULLSIZE"),     // SIZEMODE_FULLSIZE
    _T("MMWIDTH"),      // SIZEMODE_MMWIDTH
    _T("MINWIDTH"),     // SIZEMODE_MINWIDTH
    _T("PAGE"),         // SIZEMODE_PAGE
    _T("NATURALMIN"),   // SIZEMODE_NATURALMIN
};

const TCHAR *
CCalcInfo::SizeModeName() const
{
    return (_smMode >= 0 && _smMode < SIZEMODE_MAX) ? achSizeModeNames[_smMode] : _T("#ERR");
}
#endif

//+---------------------------------------------------------------------------
//
//  Member:     CElement::GetLabel
//
//  Synopsis:   Return any label element associated with this element. If the
//              element has no label, return NULL. If the element has more than
//              one label, return the first one encountered in the collection.
//
//----------------------------------------------------------------------------

CLabelElement *
CElement::GetLabel() const
{
    HRESULT         hr = S_OK;
    CElement *      pElem;
    CLabelElement * pLabel = NULL;
    int             iCount, iIndex;
    LPCTSTR         pszIdFor, pszId;
    CCollectionCache *pCollectionCache;
    CMarkup *       pMarkup;

    // check if there is label associated with this site

    pszId = GetAAid();
    if (!pszId || lstrlen(pszId) == 0)
        goto Cleanup;

    pMarkup = GetMarkupPtr();
    hr = THR(pMarkup->EnsureCollectionCache(CMarkup::LABEL_COLLECTION));
    if (hr)
        goto Cleanup;

    pCollectionCache = pMarkup->CollectionCache();
    iCount = pCollectionCache->SizeAry(CMarkup::LABEL_COLLECTION);
    if (iCount <= 0)
        goto Cleanup;

    for (iIndex = iCount - 1; iIndex >= 0; iIndex--)
    {
        hr = THR(pCollectionCache->GetIntoAry(
                CMarkup::LABEL_COLLECTION,
                iIndex,
                &pElem));
        if (hr)
            goto Cleanup;

        pLabel = DYNCAST(CLabelElement, pElem);
        pszIdFor = pLabel->GetAAhtmlFor();
        if (!pszIdFor || lstrlen(pszIdFor) == 0)
            continue;

        if (!FormsStringICmp(pszIdFor, pszId))
            break; // found the associated label
    }

    if (iIndex < 0)
        pLabel = NULL;

Cleanup:
    // ignore hr
    return pLabel;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\peer.cxx ===
//+---------------------------------------------------------------------
//
//  File:       peer.cxx
//
//  Contents:   peer holder
//
//  Classes:    CPeerHolder
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_PEER_HXX_
#define X_PEER_HXX_
#include "peer.hxx"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_PEERFACT_HXX_
#define X_PEERFACT_HXX_
#include "peerfact.hxx"
#endif

#ifndef X_PROPBAG_HXX_
#define X_PROPBAG_HXX_
#include "propbag.hxx"
#endif

#ifndef X_LAYOUT_HXX_
#define X_LAYOUT_HXX_
#include "layout.hxx"
#endif

#ifndef X_DISPNODE_HXX_
#define X_DISPNODE_HXX_
#include "dispnode.hxx"
#endif

#ifndef X_STYLE_HXX_
#define X_STYLE_HXX_
#include "style.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_SAVER_HXX_
#define X_SAVER_HXX_
#include "saver.hxx"
#endif

#ifndef X_DISPCONTEXT_HXX_
#define X_DISPCONTEXT_HXX_
#include "dispcontext.hxx"
#endif

#ifndef X_DDRAW_H_
#define X_DDRAW_H_
#include "ddraw.h"
#endif

#ifndef X_DDRAWEX_H_
#define X_DDRAWEX_H_
#include <ddrawex.h>
#endif

extern IDirectDraw * g_pDirectDraw;

///////////////////////////////////////////////////////////////////////////
//
// misc
//
///////////////////////////////////////////////////////////////////////////

MtDefine(CPeerHolder,                       Elements, "CPeerHolder")
MtDefine(CPeerHolder_CEventsBag,            Elements, "CPeerHolder::CEventsBag")
MtDefine(CPeerHolder_CEventsBag_aryEvents,  Elements, "CPeerHolder::CEventsBag::_aryEvents")
MtDefine(CPeerHolder_CPaintAdapter,         Elements, "CPeerHolder::CPaintAdapter")
MtDefine(CPeerHolder_CRenderBag,            Elements, "CPeerHolder::CRenderBag")
MtDefine(CPeerHolder_CLayoutBag,            Elements, "CPeerHolder::CLayoutBag")
MtDefine(CPeerHolder_CMiscBag,              Elements, "CPeerHolder::CMiscBag")
MtDefine(CPeerHolder_CMiscBag_aryDispidMap, Elements, "CPeerHolder::CMiscBag::aryDispidMap")
MtDefine(CPeerHolder_CPeerHolderIterator_aryPeerHolders, Elements, "CPeerHolder::CPeerHolderIterator::aryPeerHolders")

DeclareTag(tagPeerAttach,       "Peer", "trace CPeerHolder::AttachPeer")
DeclareTag(tagPeerPassivate,    "Peer", "trace CPeerHolder::Passivate")
DeclareTag(tagPeerNoOM,         "Peer", "Don't expose OM of peers (fail CPeerHolder::EnsureDispatch)")
DeclareTag(tagPeerNoRendering,  "Peer", "Don't allow peers to do drawing (disable CPeerHolder::Draw)")
DeclareTag(tagPeerNoHitTesting, "Peer", "Don't allow peers to do hit testing (clear hit testing bit in CPeerHolder::InitRender)")
DeclareTag(tagPeerApplyStyle,   "Peer", "trace CPeerHolder::ApplyStyleMulti")
DeclareTag(tagPeerNotifyMulti,  "Peer", "trace CPeerHolder::NotifyMulti");
DeclareTag(tagPainterDraw,      "Peer", "trace IHTMLPainter::Draw");
DeclareTag(tagPainterHit,       "Peer", "trace IHTMLPainter::HitTest");
DeclareTag(tagVerifyPeerDraw,   "Peer", "verify Draw");
DeclareTag(tagPeerDrawObject,   "Peer", "trace CPeerHolder::_pRenderBag::_fWantsDrawObject")
DeclareTag(tagFilterVisible,    "Filter", "trace filter visibility");
DeclareTag(tagPrintFilterRect,  "Filter", "Paint red rect under filtered element area when printing.")
ExternTag(tagDisableLockAR);

PerfDbgTag(tagPeer, "Peer", "Trace Peer Calls")

// implemented in olesite.cxx
extern HRESULT
InvokeDispatchWithNoThis (
    IDispatch *         pDisp,
    DISPID              dispidMember,
    LCID                lcid,
    WORD                wFlags,
    DISPPARAMS *        pdispparams,
    VARIANT *           pvarResult,
    EXCEPINFO *         pexcepinfo);

extern const CLSID CLSID_CHtmlComponent;

//+---------------------------------------------------------------------------
//
//  Helper function:    GetNextUniquePeerNumber
//
//----------------------------------------------------------------------------

DWORD
GetNextUniquePeerNumber(CElement * pElement)
{
    HRESULT         hr;
    DWORD           n = 0;
    AAINDEX         aaIdx;

    // get previous number

    //  ( TODO perf(alexz) these 2 searches can actually show up on perf numbers (up to 1%) )

    aaIdx = pElement->FindAAIndex(DISPID_A_UNIQUEPEERNUMBER, CAttrValue::AA_Internal);
    if (AA_IDX_UNKNOWN != aaIdx)
    {
        hr = THR_NOTRACE(pElement->GetSimpleAt(aaIdx, &n));
    }

    // increment it

    n++;
    // (the very first access here will return '1')

    // store it

    IGNORE_HR(pElement->AddSimple(DISPID_A_UNIQUEPEERNUMBER, n, CAttrValue::AA_Internal));

    return n;
}

//////////////////////////////////////////////////////////////////////////////
//
// CPeerHolder::CListMgr methods
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
//  CPeerHolder::CListMgr constructor
//
//----------------------------------------------------------------------------

CPeerHolder::CListMgr::CListMgr()
{
    _pHead     = NULL;
    _pCurrent  = NULL;
    _pPrevious = NULL;
}

//+---------------------------------------------------------------------------
//
//  CPeerHolder::CListMgr::Init
//
//----------------------------------------------------------------------------

HRESULT
CPeerHolder::CListMgr::Init(CPeerHolder * pPeerHolder)
{
    HRESULT     hr = S_OK;

    _pHead    = pPeerHolder;
    _pCurrent = _pHead;
    Assert (NULL == _pPrevious);

    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  CPeerHolder::CListMgr::BuildStart
//
//----------------------------------------------------------------------------

HRESULT
CPeerHolder::CListMgr::BuildStart(CElement * pElement)
{
    HRESULT     hr;

    _pElement = pElement;

    hr = THR(Init(_pElement->DelPeerHolder()));

    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  CPeerHolder::CListMgr::BuildStep
//
//----------------------------------------------------------------------------

HRESULT
CPeerHolder::CListMgr::BuildStep()
{
    HRESULT     hr = S_OK;

    Assert (_pElement);

    if (!_pElement->HasPeerHolder())
    {
        if (!IsEmpty())
        {
            hr = THR(_pElement->SetPeerHolder(Head()));
        }
    }
    else
    {
        if (IsEmpty())
        {
            _pElement->DelPeerHolder();
        }
        else
        {
            // assert that we are exclusively building peer holder list for the element
            Assert (_pElement->GetPeerHolder() == Head());
        }
    }

    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  CPeerHolder::CListMgr::BuildDone
//
//----------------------------------------------------------------------------

HRESULT
CPeerHolder::CListMgr::BuildDone()
{
    HRESULT     hr;

    Assert (_pElement);

    hr = THR(BuildStep());
    if (hr)
        goto Cleanup;

    hr = THR(_pElement->OnPeerListChange());

Cleanup:
    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  CPeerHolder::CListMgr::AddTo
//
//----------------------------------------------------------------------------

void
CPeerHolder::CListMgr::AddTo(CPeerHolder * pItem, BOOL fAddToHead)
{
    if (!_pHead)
    {
        _pHead = _pCurrent = pItem;
        Assert (!_pPrevious);
    }
    else
    {
        if (fAddToHead)
        {
            // add to head

            pItem->_pPeerHolderNext = _pHead;

            _pPrevious = NULL;
            _pHead = _pCurrent = pItem;
        }
        else
        {
            // add to tail

            // if not at the end of the list, move there
            if (!_pCurrent || _pCurrent->_pPeerHolderNext)
            {
                Assert(_pHead);

                for (_pCurrent = _pHead;
                     _pCurrent->_pPeerHolderNext;
                     _pCurrent = _pCurrent->_pPeerHolderNext)
                     ;
            }

            // add
            _pPrevious = _pCurrent;
            _pCurrent  = pItem;
            _pPrevious->_pPeerHolderNext = _pCurrent;
        }
    }
}

//+---------------------------------------------------------------------------
//
//  CPeerHolder::CListMgr::Reset
//
//----------------------------------------------------------------------------

void
CPeerHolder::CListMgr::Reset()
{
    _pPrevious = NULL;
    _pCurrent = _pHead;
}

//+---------------------------------------------------------------------------
//
//  CPeerHolder::CListMgr::Step
//
//----------------------------------------------------------------------------

void
CPeerHolder::CListMgr::Step()
{
    Assert (!IsEnd());

    _pPrevious = _pCurrent;
    _pCurrent = _pCurrent->_pPeerHolderNext;
}

//+---------------------------------------------------------------------------
//
//  CPeerHolder::CListMgr::Find
//
//----------------------------------------------------------------------------

BOOL
CPeerHolder::CListMgr::Find(LPTSTR pchUrl)
{
    Assert (pchUrl);
    Reset();
    while  (!IsEnd())
    {
        if (_pCurrent->_pPeerFactoryUrl && _pCurrent->_pPeerFactoryUrl->_cstrUrl &&
            0 == StrCmpIC(_pCurrent->_pPeerFactoryUrl->_cstrUrl, pchUrl))
        {
            return TRUE;
        }
        Step();
    }
    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  CPeerHolder::CListMgr::MoveCurrentTo
//
//----------------------------------------------------------------------------

void
CPeerHolder::CListMgr::MoveCurrentTo(CListMgr * pTargetList, BOOL fHead, BOOL fSave /* = FALSE */)
{
    CPeerHolder * pNext;

    Assert (!IsEmpty() && !IsEnd());

    pNext = _pCurrent->_pPeerHolderNext;

    _pCurrent->_pPeerHolderNext = NULL;             // disconnect current from this list

    if (pTargetList)
    {
        pTargetList->AddTo(_pCurrent, fHead);       // add current to the new list
    }
    else
    {
        if (fSave)
        {
            _pCurrent->Save();
        }

        _pCurrent->PrivateRelease();                // or release
    }

    if (_pHead == _pCurrent)                        // update _pHead member in this list
    {
        _pHead = pNext;
    }

    _pCurrent = pNext;                              // update _pCurrent

    if (_pPrevious)                                 // update _pPrevious->_pPeerHolderNext
    {
        _pPrevious->_pPeerHolderNext = _pCurrent;
    }
}

//+---------------------------------------------------------------------------
//
//  CPeerHolder::CListMgr::InsertInHeadOf
//
//  Note:   ! assumes that the list was iterated to the end before calling here
//
//----------------------------------------------------------------------------

void
CPeerHolder::CListMgr::InsertInHeadOf (CListMgr * pTargetList)
{
    if (IsEmpty())  // if empty
        return;     // nothing to insert

    Assert (IsEnd() && _pPrevious); // assert that we've been iterated to the end

    // connect tail of this list to target list
    _pPrevious->_pPeerHolderNext = pTargetList->_pHead;

    // set target list head to this list
    pTargetList->_pHead = _pHead;
    pTargetList->Reset();
}

//+---------------------------------------------------------------------------
//
//  CPeerHolder::CListMgr::GetPeerHolderCount
//
//----------------------------------------------------------------------------

long
CPeerHolder::CListMgr::GetPeerHolderCount(BOOL fNonEmptyOnly)
{
    long        lCount = 0;

    Reset();
    while  (!IsEnd())
    {
        if (Current()->_pPeer || !fNonEmptyOnly)
        {
            lCount++;
        }
        Step();
    }

    return lCount;
}


//+---------------------------------------------------------------------------
//
//  CPeerHolder::CListMgr::GetPeerHolderByIndex
//
//----------------------------------------------------------------------------

CPeerHolder *
CPeerHolder::CListMgr::GetPeerHolderByIndex(long lIndex, BOOL fNonEmptyOnly)
{
    long            lCurrent = 0;
    CPeerHolder *   pPeerHolder;

    Reset();
    while  (!IsEnd())
    {
        if (Current()->_pPeer || !fNonEmptyOnly) // if we either have peer, or we were not asked to always have peer
        {
            if (lCurrent == lIndex)
                break;

            lCurrent++;
        }
        Step();
    }

    if (!IsEnd())
    {
        Assert(lCurrent == lIndex && (Current()->_pPeer || !fNonEmptyOnly));
        pPeerHolder = Current();
    }
    else
    {
        pPeerHolder = NULL;
    }

    return pPeerHolder;
}

//+---------------------------------------------------------------------------
//
//  CPeerHolder::CListMgr::HasPeerWithUrn
//
//  Returns TRUE if we find a peer with the given Urn
//----------------------------------------------------------------------------

BOOL
CPeerHolder::CListMgr::HasPeerWithUrn(LPCTSTR Urn)
{
    Reset();
    while  (!IsEnd())
    {
        if (!Current()->_cstrUrn.IsNull() && 0 == StrCmpIC(Current()->_cstrUrn, Urn))
            return TRUE;

        Step();
    }

    return FALSE;
}


///////////////////////////////////////////////////////////////////////////
//
// CPeerHolder methods
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPeerHolder
//
//  Synopsis:   constructor
//
//-------------------------------------------------------------------------

CPeerHolder::CPeerHolder(CElement * pElement)
{
    _pElement = pElement;
    _pElement->SubAddRef();     // lock the element in memory while peer holder exists;
                                // the balancing SubRelease is in CPeerHolder::Passivate

    PrivateAddRef();            // set main refcount to 1. This is balanced in CElement::Passivate or
                                // when the element releases the CPeerHolder.
    SubAddRef();                // set subrefcount to 1
                                // this is balanced in PrivateRelease when refcount drops to 0

    // this should be done as early as possible, so that during creation peer could use the _dispidBase.
    // Another reason to do it here is that it is also used as a unique identier of the peer holder
    // on the element (e.g. in addBehavior)
    _dispidBase = UniquePeerNumberToBaseDispid(GetNextUniquePeerNumber(pElement));

#if DBG == 1
    _PeerSite._pPeerHolderDbg = this;

    // check integrity of notifications enums with flags
    Assert (NEEDCONTENTREADY          == FlagFromNotification(BEHAVIOREVENT_CONTENTREADY         ));
    Assert (NEEDDOCUMENTREADY         == FlagFromNotification(BEHAVIOREVENT_DOCUMENTREADY        ));
    Assert (NEEDAPPLYSTYLE            == FlagFromNotification(BEHAVIOREVENT_APPLYSTYLE           ));
    Assert (NEEDDOCUMENTCONTEXTCHANGE == FlagFromNotification(BEHAVIOREVENT_DOCUMENTCONTEXTCHANGE));
    Assert (NEEDCONTENTSAVE           == FlagFromNotification(BEHAVIOREVENT_CONTENTSAVE          ));

    Assert (BEHAVIOREVENT_CONTENTREADY          == NotificationFromFlag(NEEDCONTENTREADY         ));
    Assert (BEHAVIOREVENT_DOCUMENTREADY         == NotificationFromFlag(NEEDDOCUMENTREADY        ));
    Assert (BEHAVIOREVENT_APPLYSTYLE            == NotificationFromFlag(NEEDAPPLYSTYLE           ));
    Assert (BEHAVIOREVENT_DOCUMENTCONTEXTCHANGE == NotificationFromFlag(NEEDDOCUMENTCONTEXTCHANGE));
    Assert (BEHAVIOREVENT_CONTENTSAVE           == NotificationFromFlag(NEEDCONTENTSAVE          ));
#endif
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::~CPeerHolder
//
//  Synopsis:   destructor
//
//-------------------------------------------------------------------------

CPeerHolder::~CPeerHolder()
{
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::Passivate
//
//-------------------------------------------------------------------------

void
CPeerHolder::Passivate()
{
    TraceTag((tagPeerPassivate, "CPeerHolder::Passivate, peer holder: %ld", CookieID()));

    AssertSz( !_fPassivated, "CPeerHolder::Passivate called more than once!" );

    IGNORE_HR(DetachPeer());

    delete _pEventsBag;
    _pEventsBag = NULL;
    delete _pMiscBag;
    _pMiscBag = NULL;

    if (_pPeerHolderNext)
    {
        _pPeerHolderNext->PrivateRelease();
        _pPeerHolderNext = NULL;
    }

    if (_pElement)
    {
#if DBG == 1
        {
            CPeerHolderIterator itr;
            for (itr.Start(_pElement->GetPeerHolder()); !itr.IsEnd(); itr.Step())
            {
                Assert (itr.PH() != this);
            }
        }
#endif

        _pElement->SubRelease();
        _pElement = NULL;
    }

    WHEN_DBG( _fPassivated = TRUE );

    GWKillMethodCall( this, ONCALL_METHOD(CPeerHolder, SendNotificationAsync, sendnotificationasync), 0 );
    GWKillMethodCall( this, ONCALL_METHOD(CPeerHolder, NotifyDisplayTreeAsync, notifydisplaytreeasync), 0 );
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::DetachPeer
//
//-------------------------------------------------------------------------

HRESULT
CPeerHolder::DetachPeer()
{
    HRESULT     hr = S_OK;

    if (IsRenderPeer())
    {
        NotifyDisplayTree();
    }

    if (_pPeer)
    {

        PerfDbgLog(tagPeer, this, "+CPeerHolder::DetachPeer");
	    _pPeer->Detach();
        PerfDbgLog1(tagPeer, this, "-CPeerHolder::DetachPeer(%S)", (_pPeerFactoryUrl && (LPCTSTR)_pPeerFactoryUrl->_cstrUrl) ? (LPCTSTR)_pPeerFactoryUrl->_cstrUrl : L"");

        ClearInterface (&_pDisp);
        ClearInterface (&_pPeerUI);
        ClearInterface (&_pPeerCmdTarget);

        delete _pRenderBag; // releases _pBehaviorRender
        _pRenderBag = NULL;

        delete _pLayoutBag;
        _pLayoutBag = NULL;

        // final reference on the peer
        ClearInterface (&_pPeer);
    }

    RRETURN (hr);
}

//+---------------------------------------------------------------
//
//  Member:     CPeerHolder::CLock methods
//
//---------------------------------------------------------------

CPeerHolder::CLock::CLock(CPeerHolder * pPeerHolder, FLAGS enumFlags)
{
    _pPeerHolder = pPeerHolder;

    if (!_pPeerHolder)
        return;

    // assert that only lock flags are passed in here
    Assert (0 == ((WORD)enumFlags & ~LOCKFLAGS));

    _wPrevFlags = _pPeerHolder->_wFlags;
    _pPeerHolder->_wFlags |= (WORD) enumFlags;

    _fNoRefs = pPeerHolder->_ulRefs == 0;

    if( !_fNoRefs
#if DBG==1
       && !IsTagEnabled(tagDisableLockAR)
#endif
      )
    {
       _pPeerHolder->PrivateAddRef();
       if (_pPeerHolder->_pElement)
       {
            // AddRef the element so it does not passivate while are keeping peer and peer holder alive
            _pPeerHolder->_pElement->AddRef();
       }
    }
}


CPeerHolder::CLock::~CLock()
{
    if (!_pPeerHolder)
        return;

    // restore only lock flags; don't touch others
    _pPeerHolder->_wFlags = (_wPrevFlags & LOCKFLAGS) | (_pPeerHolder->_wFlags & ~LOCKFLAGS);

    if( !_fNoRefs
#if DBG==1
       && !IsTagEnabled(tagDisableLockAR)
#endif
      )
    {
        if (_pPeerHolder->_pElement)
        {
            _pPeerHolder->_pElement->Release();
        }
        _pPeerHolder->PrivateRelease();
    }
}

//+---------------------------------------------------------------
//
//  Member:     CPeerHolder::QueryInterface
//
//
//  CPeerHolder objects do not have COM object identity!
//
//  The only reason why QI, AddRef and Release exist on peer holder
//  is to serve as IUnknown part of interface thunks created when
//  peer QI-s element for an interface. CElement, when performing
//  PrivateQueryInterface, always checks if there is a CPeerHolder
//  attached in QueryInterface (indicated by LOCK_INQI)) and then returns
//  thunk with IUnknown part wired to the CPeerHolder. As a result, QI on
//  CElement, if originated from peer, does not increase CElement
//  main refcount (_ulRefs), but affects subrefcount (_ulAllRefs).
//  This logic breaks refcount loops when peer caches element pointer
//  received from IElementBehaviorSite::GetElement - peer has no way
//  to touch main refcount of it's element and therefore delay moment
//  of passivation of the element (with a few exceptions - see below).
//  Because QI of the thunks is also wired to this method, all
//  subsequent QIs on the returned interfaces will also go through
//  this method and the bit LOCK_INQI will be set correctly.
//
//  The only way a peer can touch main refcount of CElement it is attached
//  to is by QI-ing for IUnknown - but we do not wrap that case so to
//  preserve object identity of CElement. However, that case is naturally
//  not dangerous in terms of creating refloops because there is no really
//  reason to cache IUnknown in peer when caching of IHTMLElement is so much
//  more natural (a peer has to have malicious intent to create refcount loop
//  to do it).
//
//  Note that as a result of this logic, no object but tearoff thunks or
//  CPeerSite should be able to get to this method directly. The thunks
//  and peer site use the method only as a helper which sets proper bits
//  and then QIs CElement - they expect interface returned to be identity
//  of CElement this peer is attached to.
//
//---------------------------------------------------------------

HRESULT
CPeerHolder::QueryInterface(REFIID riid, void ** ppv)
{
    HRESULT hr;

    if (!_pElement)
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    Assert (!TestFlag(LOCKINQI));

    if (!TestFlag(LOCKINQI))
    {
        CLock   lock(this, LOCKINQI);

        hr = THR_NOTRACE(_pElement->PrivateQueryInterface(riid, ppv));
    }
    else
    {
        hr = E_NOINTERFACE;
    }

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::GetPeerHolderInQI
//
//-------------------------------------------------------------------------

CPeerHolder *
CPeerHolder::GetPeerHolderInQI()
{
    CPeerHolderIterator itr;

    for (itr.Start(this); !itr.IsEnd(); itr.Step())
    {
        if (itr.PH()->TestFlag(LOCKINQI))
            return itr.PH();
    }

    return NULL;
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::PrivateAddRef
//
//-------------------------------------------------------------------------

ULONG
CPeerHolder::PrivateAddRef()
{
    AssertSz( !_fPassivated, "CPeerHolder::PrivateAddRef called after passivated!" );
    _ulRefs++;
    return _ulRefs;
};

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::PrivateRelease
//
//-------------------------------------------------------------------------

ULONG
CPeerHolder::PrivateRelease()
{
    _ulRefs--;
    if (0 == _ulRefs)
    {
        _ulRefs = ULREF_IN_DESTRUCTOR;
        Passivate();
        _ulRefs = 0;
        SubRelease();
        return 0;
    }
    return _ulRefs;
};

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::SubAddRef
//
//-------------------------------------------------------------------------

ULONG
CPeerHolder::SubAddRef()
{
    _ulAllRefs++;
    return _ulAllRefs;
};

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::SubRelease
//
//-------------------------------------------------------------------------

ULONG
CPeerHolder::SubRelease()
{
    _ulAllRefs--;
    if (0 == _ulAllRefs)
    {
        _ulAllRefs = ULREF_IN_DESTRUCTOR;
        _ulRefs = ULREF_IN_DESTRUCTOR;
        delete this;
        return 0;
    }
    return _ulRefs;
};

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::QueryPeerInterface
//
//  Synposis:   for explicit QI's into the peer
//
//-------------------------------------------------------------------------

HRESULT
CPeerHolder::QueryPeerInterface(REFIID riid, void ** ppv)
{
    RRETURN(_pPeer ? _pPeer->QueryInterface(riid, ppv) : E_NOINTERFACE);
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::QueryPeerInterfaceMulti
//
//-------------------------------------------------------------------------

HRESULT
CPeerHolder::QueryPeerInterfaceMulti(REFIID riid, void ** ppv, BOOL fIdentityOnly)
{
    HRESULT             hr2;
    CPeerHolderIterator itr;

    for (itr.Start(this); !itr.IsEnd(); itr.Step())
    {
        if (fIdentityOnly && !itr.PH()->IsIdentityPeer())
            continue;

        hr2 = THR_NOTRACE(itr.PH()->QueryPeerInterface(riid, ppv));
        if (S_OK == hr2)
            RRETURN (S_OK);
    }

    RRETURN (E_NOTIMPL);
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::Create
//
//-------------------------------------------------------------------------

HRESULT
CPeerHolder::Create(CPeerFactory *  pPeerFactory)
{
    HRESULT                 hr;
    WHEN_DBG(CDoc *                  pDoc = _pElement->Doc();)
    IElementBehavior *      pPeer = NULL;

    Assert (pPeerFactory);

    AssertSz(IsMarkupStable(_pElement->GetMarkup()), "CPeerHolder::Create appears to be called at an unsafe moment of time");

    //
    // setup peer holder
    //

    // _pElement should be set before FindPeer so at the moment of creation
    // the peer has valid site and element available
    Assert (_pElement);

    if( _pElement->IsPassivated() )
    {
        hr = E_ABORT;
        goto Cleanup;
    }
    
    {
        CElement::CLock lock(_pElement);    // if the element is blown away by peer while we create the peer,
                                            // this should keep us from crashing
        //
        // get the peer
        //

        hr = THR_NOTRACE(pPeerFactory->FindBehavior(this, &_PeerSite, &pPeer));
        if (hr)
            goto Cleanup;
    }

    //
    // attach peer to the peer holder and peer holder to the element
    //

    Assert (!_pPeer);

    hr = THR(AttachPeer(pPeer));
    if (hr)
        goto Cleanup;

    //
    // finalize
    //

    Assert (!IsCssPeer() || pDoc->AreCssPeersPossible());
    if( _pElement->GetMarkup() )
    {
        IGNORE_HR( _pElement->GetMarkup()->RequestDocEndParse( _pElement ) );
    }

Cleanup:

    ReleaseInterface (pPeer);

    Assert (S_OK == hr &&  _pPeer ||
            S_OK != hr && !_pPeer);

    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::AttachPeer
//
//  Synopsis:   attaches the peer to this peer holder
//
//-------------------------------------------------------------------------

HRESULT
CPeerHolder::AttachPeer(IElementBehavior * pPeer)
{
    HRESULT     hr = S_OK;
    CHtmlComponent *pComponent = NULL;
    CDoc::CLock lock (_pElement->Doc(), FORMLOCK_FILTER);  // do not want filter tasks to be executed

    if (!pPeer)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    Assert (pPeer);
    _pPeer = pPeer;
    _pPeer->AddRef();

    //
    // initialize and QI
    //

    hr = THR(_pPeer->QueryInterface(CLSID_CHtmlComponent, (void**)&pComponent));
    if (!hr && pComponent)
        _fHtcPeer = TRUE;

    PerfDbgLog(tagPeer, this, "+CPeerHolder::InitPeer");
    hr = THR(_pPeer->Init(&_PeerSite));
    PerfDbgLog1(tagPeer, this, "-CPeerHolder::InitPeer(%S)", (_pPeerFactoryUrl && (LPCTSTR)_pPeerFactoryUrl->_cstrUrl) ? (LPCTSTR)_pPeerFactoryUrl->_cstrUrl : L"");
    if (hr)
        goto Cleanup;

    if (_pPeerFactoryUrl)
    {
        hr = THR(_pPeerFactoryUrl->PersistMonikerLoad(_pPeer, FALSE));
        if (hr)
            goto Cleanup;
    }

    hr = THR(InitAttributes()); // dependencies: this should happen before InitRender, InitUI, or InitCategory
    if (hr)
        goto Cleanup;

    hr = THR(InitReadyState());
    if (hr)
        goto Cleanup;

    hr = THR(InitRender());
    if (hr)
        goto Cleanup;

    hr = THR(InitUI());
    if (hr)
        goto Cleanup;

    hr = THR(InitCategory());
    if (hr)
        goto Cleanup;

    hr = THR(InitCmdTarget());
    if (hr)
        goto Cleanup;

    hr = THR(InitLayout());
    if (hr)
        goto Cleanup;

    SetFlag(NEEDDOCUMENTREADY);
    SetFlag(NEEDCONTENTREADY);
    SetFlag(AFTERINIT);

    //
    // Here's the deal:
    // Since element behaviors get hooked up immediately, it's easy for them to be running in a 
    // state which they're not really going to understand (ie, temporary parsing for innerHTML, etc.)
    // So what we actually do for them is delay sending content/document ready until they actually
    // enter a tree somewhere.  Otherwise, the act of asking for their document will give them one, and
    // it will not be the one they want (ie, someone does createElement and then appendChild).
    // Unfortunately, it's too late to do this for attach behaviors.
    //
    if( IsIdentityPeer() &&
        ( !_pElement->IsInMarkup() ||
          ( _pElement->Doc()->_fInHTMLInjection &&
            _pElement->GetMarkupPtr()->_fMarkupServicesParsing ) ) )
    {
        _fNotifyOnEnterTree = TRUE;
    }
    else
    {
        IGNORE_HR(EnsureNotificationsSent());
    }

    if (IsRenderPeer())
    {
        NotifyDisplayTree();
    }

    //
    // finalize
    //

Cleanup:

    TraceTag((
        tagPeerAttach,
        "CPeerHolder::AttachPeer, peer holder: %ld, tag: %ls, tag id: %ls, SN: %ld, peer: %ls, hr: %x",
        CookieID(),
        _pElement->TagName(), STRVAL(_pElement->GetAAid()), _pElement->SN(),
        STRVAL(_pPeerFactoryUrl ? (LPTSTR)_pPeerFactoryUrl->_cstrUrl : NULL),
        hr));

    if (hr)
    {
        // DetachPeer is important to handle Init case gracefully
        IGNORE_HR(DetachPeer());
    }

    RRETURN (hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::InitUI
//
//-------------------------------------------------------------------------

HRESULT
CPeerHolder::InitUI()
{
    _pPeerUI = NULL;
    return S_OK;
}


//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::InitCmdTarget
//
//-------------------------------------------------------------------------

HRESULT
CPeerHolder::InitCmdTarget()
{
    HRESULT     hr;

    hr = THR_NOTRACE(QueryPeerInterface(IID_IOleCommandTarget, (void **)&_pPeerCmdTarget));
    if (hr)
    {
        _pPeerCmdTarget = NULL; // don't trust peers to set it to NULL when they fail QI - it could be uninitialized
    }

    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::InitAttributes
//
//-------------------------------------------------------------------------

HRESULT
CPeerHolder::InitAttributes()
{
    HRESULT                 hr;
    IPersistPropertyBag2 *  pPersistPropertyBag2 = NULL;
    IPersistPropertyBag *   pPersistPropertyBag = NULL;
    CPropertyBag *          pPropertyBag;

    hr = THR_NOTRACE(QueryPeerInterface(IID_IPersistPropertyBag2, (void **)&pPersistPropertyBag2));
    if (hr || !pPersistPropertyBag2)
    {
        hr = THR_NOTRACE(QueryPeerInterface(IID_IPersistPropertyBag, (void **)&pPersistPropertyBag));
        if (hr || !pPersistPropertyBag)
           return S_OK;
    }

    // ( TODO perf(alexz) the property bag implementation is terribly inefficient. SaveAttributes actually
    // shows up on perf profiles - up to 6%. It should not do explicit copy of attributes, but should
    // rather just link to element )

    pPropertyBag = new CPropertyBag();
    if (!pPropertyBag)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    pPropertyBag->_pElementExpandos = _pElement; // this transitions it to expandos loading mode

    hr = THR(_pElement->SaveAttributes(pPropertyBag));
    if (hr)
    {
        hr = S_OK;
        goto Cleanup;
    }

    // ignore hr here so that if it does not implement Load method we still use the behavior
    if (pPersistPropertyBag2)
    {
        IGNORE_HR(pPersistPropertyBag2->Load(pPropertyBag, NULL));
    }
    else
    {
        Assert (pPersistPropertyBag);
        IGNORE_HR(pPersistPropertyBag->Load(pPropertyBag, NULL));
    }

Cleanup:
    ReleaseInterface(pPersistPropertyBag2);
    ReleaseInterface(pPersistPropertyBag);
    if (pPropertyBag)
    {
        pPropertyBag->Release();
    }

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::InitRender
//
//-------------------------------------------------------------------------

HRESULT
CPeerHolder::InitRender()
{
    // NOTE: startup should be minimal if rendering interfaces are not supported
    HRESULT                     hr;
    IHTMLPainter *              pPainter;
    IElementBehaviorRender *    pPeerRender;
    BOOL                        fUpdateLayout;

    hr = THR_NOTRACE(QueryPeerInterface(IID_IHTMLPainter, (void**)&pPainter));
    if (hr || !pPainter)
    {
        hr = THR_NOTRACE(QueryPeerInterface(IID_IElementBehaviorRender, (void**)&pPeerRender));
        if (hr || !pPeerRender)
            return S_OK;

        pPainter = NULL;
    }
    else
    {
        pPeerRender = NULL;
    }

    _pRenderBag = new CRenderBag();
    if (!_pRenderBag)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    if (pPainter)
    {
        _pRenderBag->_pPainter = pPainter;
    }
    else
    {
        // for compatability with behaviors that support IEBR, create an adapter
        CPaintAdapter *pAdapter = new CPaintAdapter(this);
        if (!pAdapter)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        _pRenderBag->_pAdapter = pAdapter;
        _pRenderBag->_pPainter = (IHTMLPainter*)pAdapter;

        Assert(pPeerRender);
        pAdapter->_pPeerRender = pPeerRender;
    }

    // get the painter's info, flags, preferences, etc.
    UpdateRenderBag();

    // by this time, the element's initial visibilty is known
    if (IsFilterPeer())
    {
        SetFilteredElementVisibility(!_pElement->GetFirstBranch()->GetCharFormat()->_fVisibilityHidden);
    }

    fUpdateLayout = (_pRenderBag->_sPainterInfo.lZOrder != HTMLPAINT_ZORDER_NONE);

    // NOTE (KTam): This is wrong -- it needs to be multi-layout aware.  Unfortunately,
    // OnLayoutAvailable() assumes it's only going to get 1 layout and calls GetSize on it
    // (which conceptually doesn't make sense for CLayoutInfo).   Invalidate should probably
    // be moved onto CLayoutInfo.
    if (fUpdateLayout)
    {
        CLayout    * pLayout;
        if(_pElement->HasLayoutAry())
        {
            CLayoutAry * pLayoutAry = _pElement->GetLayoutAry();
            int nLayoutCookie = 0;

            for(;;)
            {
                pLayout = pLayoutAry->GetNextLayout(&nLayoutCookie);
                if(nLayoutCookie == -1 || !pLayout)
                    break;

                // we must have missed the moment when layout was created and attached to the element
                // so simulate OnLayoutAvailable now
                IGNORE_HR(OnLayoutAvailable( pLayout ));

                // and invalidate the layout to cause initial redraw
                pLayout->Invalidate();
            }
        }
        else
        {
            // don't call GetUpdatedLayout unless you want the layout to actually be
            // created at this time.
            pLayout = _pElement->GetLayoutPtr();

            if (pLayout)
            {
                // we must have missed the moment when layout was created and attached to the element
                // so simulate OnLayoutAvailable now
                IGNORE_HR(OnLayoutAvailable( pLayout ));

                // and invalidate the layout to cause initial redraw
                pLayout->Invalidate();
            }
        }
    }

Cleanup:
    // do not do ReleaseInterface(pPainter);
    // do not do ReleaseInterface(pPeerRender);

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::InitLayout
//
//-------------------------------------------------------------------------
HRESULT
CPeerHolder::InitLayout()
{
    HRESULT                  hr;
    IElementBehaviorLayout * pPeerLayout;
    IElementBehaviorLayout2 * pPeerLayout2 = NULL;

    hr = THR_NOTRACE(QueryPeerInterface(IID_IElementBehaviorLayout, (void**)&pPeerLayout));
    if (hr || !pPeerLayout)
        return S_OK;

    THR_NOTRACE(pPeerLayout->QueryInterface(IID_IElementBehaviorLayout2, (void**)&pPeerLayout2));
    
    _pLayoutBag = new CLayoutBag();
    if (!_pLayoutBag)
    {
        ReleaseInterface(pPeerLayout);
        ReleaseInterface(pPeerLayout2);
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    _pLayoutBag->_pPeerLayout = pPeerLayout;
    _pLayoutBag->_pPeerLayout2 = pPeerLayout2;

    // now get the Layout info
    hr = THR(_pLayoutBag->_pPeerLayout->GetLayoutInfo(&_pLayoutBag->_lLayoutInfo));
    if (hr)
        goto Cleanup;

    //
    // peers that participate in layout need a relayout to happen
    //
    _pElement->ResizeElement(NFLAGS_FORCE);

Cleanup:
    // do not do ReleaseInterface(pPeerLayout);

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::InitReadyState
//
//-------------------------------------------------------------------------

HRESULT
CPeerHolder::InitReadyState()
{
    HRESULT                         hr;
    HRESULT                         hr2;
    DWORD                           dwCookie;
    IConnectionPointContainer *     pCPC = NULL;
    IConnectionPoint *              pCP = NULL;

    hr = THR_NOTRACE(QueryPeerInterface(IID_IConnectionPointContainer, (void**)&pCPC));
    if (hr || !pCPC)
        return S_OK;

    hr = THR_NOTRACE(pCPC->FindConnectionPoint(IID_IPropertyNotifySink, &pCP));
    if (hr)
    {
        hr = S_OK;
        goto Cleanup;
    }

    hr = THR_NOTRACE(pCP->Advise((IPropertyNotifySink*)&_PeerSite, &dwCookie));
    if (hr)
        goto Cleanup;

    hr2 = THR_NOTRACE(UpdateReadyState());
    if (hr2)
    {
        _readyState = READYSTATE_UNINITIALIZED;
    }

Cleanup:
    ReleaseInterface(pCPC);
    ReleaseInterface(pCP);

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::UpdateReadyState
//
//-------------------------------------------------------------------------

HRESULT
CPeerHolder::UpdateReadyState()
{
    HRESULT     hr = S_OK;
    CInvoke     invoke;
    CVariant    varReadyState;

    EnsureDispatch();
    if (!_pDisp)
    {
        hr = E_NOINTERFACE;
        goto Cleanup;
    }

    if (TestFlag(DISPEX))
        hr = THR(invoke.Init((IDispatchEx*)_pDisp));
    else
        hr = THR(invoke.Init(_pDisp));
    if (hr)
        goto Cleanup;

    hr = THR(invoke.Invoke(DISPID_READYSTATE, DISPATCH_PROPERTYGET));
    if (hr)
        goto Cleanup;

    hr = THR(VariantChangeType(&varReadyState, invoke.Res(), 0, VT_I4));
    if (hr)
        goto Cleanup;

    _readyState = (READYSTATE) V_I4(&varReadyState);

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::GetReadyStateMulti
//
//-------------------------------------------------------------------------

READYSTATE
CPeerHolder::GetReadyStateMulti()
{
    READYSTATE          readyState;
    CPeerHolderIterator itr;

    // get min readyState of all peers that support readyState

    readyState = READYSTATE_COMPLETE;

    for (itr.Start(this); !itr.IsEnd(); itr.Step())
    {
        if (READYSTATE_UNINITIALIZED == itr.PH()->_readyState)
            continue;

        readyState = min(itr.PH()->GetReadyState(), readyState);
    }

    return readyState;
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::GetIdentityReadyState
//
//-------------------------------------------------------------------------

READYSTATE
CPeerHolder::GetIdentityReadyState()
{
    CPeerHolder * pPeerHolder = GetIdentityPeerHolder();
    READYSTATE    readyState;

    if (pPeerHolder)
    {
        readyState = pPeerHolder->GetReadyState();
        if (READYSTATE_UNINITIALIZED == readyState)
            readyState = READYSTATE_COMPLETE;
    }
    else
        readyState = READYSTATE_COMPLETE;

    return readyState;
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::ContentSavePass, static helper
//
//-------------------------------------------------------------------------

HRESULT
CPeerHolder::ContentSavePass(CTreeSaver * pTreeSaver, BOOL fText)
{
    Assert (pTreeSaver);

    HRESULT         hr = S_OK;
    INT             i,c;
    CChildIterator  ci (pTreeSaver->GetFragment(), NULL, CHILDITERATOR_DEEP);
    CTreeNode *     pNode;
    CElement *      pElement;

    CStackPtrAry <CElement*, 16> aryElements(Mt(Mem));

    //
    // pass 1 - lock and store elements with behaviors participating in contentSave
    //

    pElement = pTreeSaver->GetFragment();
    do {
        Assert (pElement);

        if (pElement->HasPeerHolder())
        {
            CPeerHolderIterator     itr;

            for (itr.Start(pElement->GetPeerHolder()); !itr.IsEnd(); itr.Step())
            {
                if (itr.PH()->TestFlag(NEEDCONTENTSAVE) && !itr.PH()->TestFlag(LOCKINCONTENTSAVE))
                {
                    pElement->PrivateAddRef(); // balanced in pass 2

                    hr = THR(aryElements.Append(pElement));
                    if (hr)
                        goto Cleanup;

                    break;
                }
            }
        }

        pNode = ci.NextChild();
        pElement = pNode ? pNode->Element() : NULL;
    } while( pElement );

    //
    // pass 2 - fire the content save
    //

    for (i = 0, c = aryElements.Size(); i < c; i++)
    {
        pElement = aryElements[i];

        if (pElement->HasPeerHolder())
        {
            CPeerHolderIterator     itr;

            for (itr.Start(pElement->GetPeerHolder()); !itr.IsEnd(); itr.Step())
            {
                if (itr.PH()->TestFlag(NEEDCONTENTSAVE))
                {
                    VARIANT vt;
                    BSTR bstrSaveType;

                    if( SUCCEEDED( FormsAllocString( fText ? _T("TEXT") : _T("HTML"), &bstrSaveType ) ) )
                    {
                        V_VT(&vt) = VT_BSTR;
                        V_BSTR(&vt) = bstrSaveType;

                        Assert( !itr.PH()->TestFlag(LOCKINCONTENTSAVE));

                        {
                            CPeerHolder::CLock Lock(itr.PH(), LOCKINCONTENTSAVE);

                            IGNORE_HR(itr.PH()->Notify(BEHAVIOREVENT_CONTENTSAVE, &vt));
                        }

                        FormsFreeString( bstrSaveType );
                    }

                    break;
                }
            }
        }

        pElement->PrivateRelease(); // balanced in pass 1
    }

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Helper:     NormalizeDoubleNullStr
//
//-------------------------------------------------------------------------

LPTSTR
NormalizeDoubleNullStr(LPTSTR pchSrc)
{
    LPTSTR      pch;
    LPTSTR      pch2;
    int         l;

    if (!pchSrc)
        return NULL;

    // count total length

    pch = pchSrc;
    while (pch[1]) // while second char is not null, indicating that there is at least one more string to go
    {
        pch = _tcschr(pch + 1, 0);
    }

    l = pch - pchSrc + 2;

    // allocate and copy string

    pch = new TCHAR [l];
    if (!pch)
        return NULL;

    memcpy (pch, pchSrc, sizeof(TCHAR) * l);

    // flip 0-s to 1-s so the string becomes usual null-terminated string

    pch2 = pch;
    while (pch2[1])
    {
        pch2 = _tcschr(pch + 1, 0);
        *pch2 = 1;
    }

    return pch;
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::InitCategory
//
//-------------------------------------------------------------------------

HRESULT
CPeerHolder::InitCategory()
{
    HRESULT     hr;
    LPTSTR      pchCategory;
    LPTSTR      pchCategoryNorm;

    IElementBehaviorCategory * pPeerCategory;

    hr = THR_NOTRACE(QueryPeerInterface(IID_IElementBehaviorCategory, (void**)&pPeerCategory));
    if (hr || !pPeerCategory)
        return S_OK;

    hr = THR(pPeerCategory->GetCategory(&pchCategory));
    if (hr)
        goto Cleanup;

    // TODO (alexz) this all should be optimized to use hash tables

    pchCategoryNorm = NormalizeDoubleNullStr(pchCategory);

    if (pchCategoryNorm)
    {
        hr = THR(_cstrCategory.Set(pchCategoryNorm));

        delete pchCategoryNorm;
    }

Cleanup:
    ReleaseInterface(pPeerCategory);

    if (pchCategory)
        CoTaskMemFree (pchCategory);


    RRETURN (hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::ApplyStyleMulti
//
//  Synopsis:   Send down an applystyle to all behaviors.  Need to do this
//              in reverse order so that the behavior in the beginning
//              takes precedence.
//
//-------------------------------------------------------------------------

HRESULT
CPeerHolder::ApplyStyleMulti()
{
    HRESULT                 hr = S_OK;
    long                    c;
    CPeerHolderIterator     itr;
    BYTE                    fi[sizeof(CFormatInfo)];
    CFormatInfo *           pfi = (CFormatInfo*)&fi;
    CStyle *                pStyle = NULL;
    CTreeNode *             pNode;
    CVariant                varStyle;
    IHTMLCurrentStyle *     pCurrentStyle = NULL;
    CAttrArray **           ppAA;

    CStackPtrAry <CPeerHolder *, 16> aryPeers(Mt(Mem));

    //
    // If not in markup, or any of the formats are not valid, bail out now.
    // We will compute the formats later so we will come back in here afterwards.
    //

    Assert(_pElement);
    if (!_pElement->IsInMarkup())
        goto Cleanup;

    AssertSz(IsMarkupStable(_pElement->GetMarkup()), "CPeerHolder::ApplyStyleMulti appears to be called at an unsafe moment of time");

    //
    // If any of the formats are not valid, bail out now.
    // We will compute the formats later
    // so we will come back in here afterwards.
    //

    if (!_pElement->IsFormatCacheValid())
        goto Cleanup;

    for (itr.Start(this); !itr.IsEnd(); itr.Step())
    {
        if (itr.PH()->TestFlag(NEEDAPPLYSTYLE))
        {
            hr = THR(aryPeers.Append(itr.PH()));
            if (hr)
                break;
        }
    }

    if (!aryPeers.Size())
        goto Cleanup;

    //
    // Create and initialize write-able style object.
    //

    pStyle = new CStyle(
        _pElement, DISPID_UNKNOWN,
        CStyle::STYLE_NOCLEARCACHES | CStyle::STYLE_SEPARATEFROMELEM | CStyle::STYLE_REFCOUNTED);
    if (!pStyle)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(_pElement->get_currentStyle(&pCurrentStyle, NULL));
    if (hr)
        goto Cleanup;

    pStyle->_pStyleSource = pCurrentStyle;
    pStyle->_pStyleSource->AddRef();

    //
    // Iterate thru array backwards applying the style.
    //

    TraceTag((
        tagPeerApplyStyle,
        "CPeerHolder::ApplyStyleMulti, tag: %ls, id: %ls, sn: %ld; calling _pPeer->Notify",
        _pElement->TagName(), STRVAL(_pElement->GetAAid()), _pElement->SN()));

    V_VT(&varStyle) = VT_DISPATCH;
    hr = THR(pStyle->QueryInterface(IID_IDispatch, (void **)&V_DISPATCH(&varStyle)));
    if (hr)
        goto Cleanup;

    for (c = aryPeers.Size() - 1; c >= 0; c--)
    {
        IGNORE_HR(aryPeers[c]->Notify(BEHAVIOREVENT_APPLYSTYLE, &varStyle));
    }

    // NOTE (sambent) The comment below ("Do a force compute...") suggests an
    // intent to do no more work if the peer didn't change anything in the style.
    // But there is no code to implement that intent.  The filter behavior needs
    // to listen for the ApplyStyle notification, and without the check for no
    // changes, there was an infinite loop when an element had a filter whose
    // value was given by an expression (recalc.htm in the DRT).  The following
    // test was suggested by AlexZ as a way to detect no change in the style.

    ppAA = pStyle->GetAttrArray();
    if (!ppAA || !*ppAA || (*ppAA)->Size() == 0)
    {
        goto Cleanup;
    }

    //
    // Do a force compute on the element now with this style object,
    // but only if the caches are cleared.  This implies that
    // the peer did not change any props in the style.
    //

    pNode = _pElement->GetFirstBranch();
    if (!pNode)
        goto Cleanup;

    _pElement->EnsureFormatCacheChange(ELEMCHNG_CLEARCACHES);

    pfi->_eExtraValues = ComputeFormatsType_ForceDefaultValue;
    pfi->_pStyleForce = pStyle;

    while (pNode)
    {
        TraceTag((
            tagPeerApplyStyle,
            "CPeerHolder::ApplyStyleMulti, tag: %ls, id: %ls, sn: %ld; calling _pElement->ComputeFormats",
            _pElement->TagName(), STRVAL(_pElement->GetAAid()), _pElement->SN()));

        pfi->_lRecursionDepth = 0;
        _pElement->ComputeFormats(pfi, pNode);
        pNode = pNode->NextBranch();
    }

Cleanup:

    if (pStyle)
    {
        pStyle->PrivateRelease();
    }
    ReleaseInterface(pCurrentStyle);

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::EnsureNotificationsSentMulti
//
//-------------------------------------------------------------------------

HRESULT
CPeerHolder::EnsureNotificationsSentMulti()
{
    HRESULT             hr = S_OK;
    CPeerHolderIterator itr;

    for (itr.Start(this); !itr.IsEnd(); itr.Step())
    {
        IGNORE_HR(itr.PH()->EnsureNotificationsSent());
    }

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::EnsureNotificationsSent
//
//-------------------------------------------------------------------------

HRESULT
CPeerHolder::EnsureNotificationsSent()
{
    HRESULT     hr = S_OK;

    AssertSz(IsMarkupStable(_pElement->GetMarkup()), "CPeerHolder::EnsureNotificationsSent appears to be called at an unsafe moment of time");

    if (_pPeer)
    {
        // if need contentReady, but missed moment of parsing closing tag, or know that we won't get it
        if (TestFlag(NEEDCONTENTREADY) &&
            (_pElement->_fExplicitEndTag ||                         // (if we got the notification already)
             HpcFromEtag(_pElement->Tag())->_scope == SCOPE_EMPTY)) // (if we know that we are not going to get it)
        {
            ClearFlag(NEEDCONTENTREADY);
            IGNORE_HR(Notify(BEHAVIOREVENT_CONTENTREADY));
        }

        // if missed moment of quick done, then post a callback to notify.
        // We have to do this async so that they can come back and do attach peer outside of the lock
        if (    TestFlag(NEEDDOCUMENTREADY) 
             && (   _pElement->GetMarkup() 
                 && (   LOADSTATUS_QUICK_DONE <= _pElement->GetMarkup()->LoadStatus() 
                     || !_pElement->GetMarkup()->HtmCtx() ) ) )
        {
            GWPostMethodCall( this, ONCALL_METHOD(CPeerHolder, SendNotificationAsync, sendnotificationasync), BEHAVIOREVENT_DOCUMENTREADY, FALSE, "CPeerHolder::SendNotificationAsync" );
        }
    }

    RRETURN (hr);
}

void
CPeerHolder::SendNotificationAsync(DWORD_PTR dwContext)
{
    Assert( dwContext <= BEHAVIOREVENT_LAST );

    ClearFlag( FlagFromNotification(dwContext) );
    IGNORE_HR( Notify( dwContext ) );
}


//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::OnElementNotification
//
//-------------------------------------------------------------------------

void
CPeerHolder::OnElementNotification(CNotification * pNF)
{
    LONG                lEvent;

    // We may get these while parsing for innerHTML, and should postpone them
    if( !_fNotifyOnEnterTree )
    {
        switch (pNF->Type())
        {
        case NTYPE_END_PARSE:
            lEvent = BEHAVIOREVENT_CONTENTREADY;
            break;

        case NTYPE_DOC_END_PARSE:
            if( TestFlag(AFTERDOCREADY) )
                return;

            SetFlag(AFTERDOCREADY);
            lEvent = BEHAVIOREVENT_DOCUMENTREADY;
            break;

        default:
            return;
        }

        NotifyMulti(lEvent);
    }
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::Notify
//
//-------------------------------------------------------------------------

HRESULT
CPeerHolder::Notify(LONG lEvent, VARIANT * pvarParam)
{
    HRESULT     hr;
    CLock       lock(this); // reason to lock: case if the peer blows itself and the element away using outerHTML

    // Make sure we never send these notifications out of markup or in temp markup
    Assert( !IsIdentityPeer() ||
            ( ( lEvent != BEHAVIOREVENT_CONTENTREADY || ( !_fNotifyOnEnterTree && _pElement->IsInMarkup() ) ) &&
              ( lEvent != BEHAVIOREVENT_DOCUMENTREADY || ( !_fNotifyOnEnterTree && _pElement->IsInMarkup() ) ) ) );

    PerfDbgLog(tagPeer, this, "+CPeerHolder::NotifyPeer");
	hr = THR(_pPeer->Notify(lEvent, pvarParam));
    PerfDbgLog2(tagPeer, this, "-CPeerHolder::NotifyPeer(%S, %d)",  (_pPeerFactoryUrl && (LPCTSTR)_pPeerFactoryUrl->_cstrUrl) ? (LPCTSTR)_pPeerFactoryUrl->_cstrUrl : L"", lEvent);

    RRETURN1 (hr, S_FALSE);
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::NotifyMulti
//
//-------------------------------------------------------------------------

void
CPeerHolder::NotifyMulti(LONG lEvent)
{
    CPeerHolderIterator itr;
    IElementBehavior *  pPeer;
    FLAGS               flag;

    AssertSz(IsMarkupStable(_pElement->GetMarkup()), "CPeerHolder::NotifyMulti appears to be called at an unsafe moment of time");

    TraceTag((
        tagPeerNotifyMulti,
        "CPeerHolder::NotifyMulti, event: %ld, ph: %ld, tag: %ls, id: %ls, SN: %ld, peer: %ls",
        lEvent, CookieID(), _pElement->TagName(), STRVAL(_pElement->GetAAid()), _pElement->SN(),
        STRVAL(_pPeerFactoryUrl ? (LPTSTR)_pPeerFactoryUrl->_cstrUrl : NULL)));

    flag = FlagFromNotification(lEvent);

    for (itr.Start(this); !itr.IsEnd(); itr.Step())
    {
        pPeer = itr.PH()->_pPeer;

        if (!pPeer || !itr.PH()->TestFlag(flag))
            continue;

        IGNORE_HR(itr.PH()->Notify(lEvent));
    }
}


//+----------------------------------------------------------------------------
//
//  Method:     HandleEnterTree
//
//  Synopsis:   Called when an element behavior enters the tree.  This
//              takes care of the two cases where we're either sending
//              delayed content/document-Ready notification for entering
//              its destination tree, or sending a context change
//
//  Returns:    HRESULT
//
//  Arguments:
//
//+----------------------------------------------------------------------------

HRESULT
CPeerHolder::HandleEnterTree()
{
    if( _fNotifyOnEnterTree )
    {
        // If attach behaviors can attach in ether, we should make this a multi
        _fNotifyOnEnterTree = FALSE;
        IGNORE_HR( EnsureNotificationsSent() );
    }
    else
    {
        NotifyMulti(BEHAVIOREVENT_DOCUMENTCONTEXTCHANGE);
    }

    RRETURN( S_OK );
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::ExecMulti
//
//-------------------------------------------------------------------------

HRESULT
CPeerHolder::ExecMulti(
    const GUID *    pguidCmdGroup,
    DWORD           nCmdID,
    DWORD           nCmdExecOpt,
    VARIANTARG *    pvaIn,
    VARIANTARG *    pvaOut)
{
    HRESULT             hr = MSOCMDERR_E_NOTSUPPORTED;
    CPeerHolderIterator itr;

    AssertSz(IsMarkupStable(_pElement->GetMarkup()), "CPeerHolder::ExecMulti appears to be called at an unsafe moment of time");

    for (itr.Start(this); !itr.IsEnd(); itr.Step())
    {
        if (itr.PH()->_pPeerCmdTarget)
        {
            hr = THR_NOTRACE(itr.PH()->_pPeerCmdTarget->Exec(pguidCmdGroup, nCmdID, nCmdExecOpt, pvaIn, pvaOut));
            if (MSOCMDERR_E_NOTSUPPORTED != hr) // if (S_OK == hr || MSOCMDERR_E_NOTSUPPORTED != hr)
                break;
        }
    }

    RRETURN (hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::TestFlagMulti
//
//-------------------------------------------------------------------------

BOOL
CPeerHolder::TestFlagMulti(FLAGS flag)
{
    CPeerHolderIterator itr;

    for (itr.Start(this); !itr.IsEnd(); itr.Step())
    {
        if (itr.PH()->TestFlag(flag))
            return TRUE;
    }

    return FALSE;
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::Save
//
//-------------------------------------------------------------------------

HRESULT
CPeerHolder::Save(CStreamWriteBuff * pStreamWriteBuff, BOOL * pfAny)
{
    HRESULT                 hr = S_OK;
    HRESULT                 hr2;
    IPersistPropertyBag2 *  pPersistPropertyBag = NULL;
    CPropertyBag *          pPropertyBag = NULL;
    int                     i, c;
    PROPNAMEVALUE *         pPropPair;
    BSTR                    bstrPropName = NULL;
    BOOL                    fAny = FALSE;

    //
    // startup
    //

    if (!_pPeer)
        goto Cleanup;

    hr = _pPeer->QueryInterface(IID_IPersistPropertyBag2, (void**)&pPersistPropertyBag);
    if (hr)
        goto Cleanup;

    pPropertyBag = new CPropertyBag();
    if (!pPropertyBag)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    //
    // save
    //

    hr = THR(pPersistPropertyBag->Save(pPropertyBag, FALSE, FALSE));
    if (hr)
        goto Cleanup;

    //
    // process results
    //

    c = pPropertyBag->_aryProps.Size();

    if (pfAny)
        *pfAny = (0 < c);   // note that if c is 0, pfAny should not be touched (it can be TRUE already)
                            // (this is how it is used in the codepath)
    for (i = 0; i < c; i++)
    {
        fAny = TRUE;

        pPropPair = &pPropertyBag->_aryProps[i];

        if (pStreamWriteBuff)
        {
            CVariant    varStr;

            //
            // saving to stream
            //

            hr2 = THR(VariantChangeTypeSpecial(&varStr, &pPropPair->_varValue, VT_BSTR));
            if (hr2)
                continue;

            hr = THR(_pElement->SaveAttribute(
                    pStreamWriteBuff, pPropPair->_cstrName, V_BSTR(&varStr),
                    NULL, NULL, /* fEqualSpaces = */ TRUE, /* fAlwaysQuote = */ TRUE));
            if (hr)
                goto Cleanup;
        }
        else
        {
            //
            // saving to expandos
            //

            hr = THR(FormsAllocString(pPropPair->_cstrName, &bstrPropName));
            if (hr)
                goto Cleanup;

            {
                // lock GetDispID method so that the attribute gets set as expando
                CLock lock (this, LOCKGETDISPID);

                hr = THR(_pElement->setAttribute(bstrPropName, pPropPair->_varValue, 0));
                if (hr)
                    goto Cleanup;
            }

            FormsFreeString(bstrPropName);
            bstrPropName = NULL;
        }
    }

Cleanup:
    delete pPropertyBag;

    ReleaseInterface(pPersistPropertyBag);

    if (bstrPropName)
    {
        FormsFreeString(bstrPropName);
        bstrPropName = NULL;
    }

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::SaveMulti
//
//-------------------------------------------------------------------------

HRESULT
CPeerHolder::SaveMulti(CStreamWriteBuff * pStreamWriteBuff, BOOL * pfAny)
{
    HRESULT                 hr = S_OK;
    CPeerHolderIterator     itr;

    for (itr.Start(this); !itr.IsEnd(); itr.Step())
    {
        IGNORE_HR(itr.PH()->Save(pStreamWriteBuff, pfAny));
    }

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::IllegalSiteCall
//
//  Synopsis:   returns TRUE if call is illegal
//
//-------------------------------------------------------------------------

BOOL
CPeerHolder::IllegalSiteCall()
{
    if (!_pElement)
        return TRUE;

    if (_pElement->Doc()->_dwTID != GetCurrentThreadId())
    {
        Assert(0 && "peer object called MSHTML across apartment thread boundary (not from thread it was created on) (not an MSHTML bug)");
        return TRUE;
    }

    return FALSE;
}

//+----------------------------------------------------------------------------------
//
//  Member:     CPeerHolder::EnsureDispatch
//
//  Synposis:   ensures either IDispatch or IDispatchEx pointer cached
//
//-----------------------------------------------------------------------------------

void
CPeerHolder::EnsureDispatch()
{
#if DBG == 1
    if (IsTagEnabled(tagPeerNoOM))
        return;
#endif

    if (TestFlag(DISPCACHED) || !_pPeer)
        return;

    SetFlag (DISPCACHED);

    Assert (!_pDisp);

    IGNORE_HR(_pPeer->QueryInterface(IID_IDispatchEx, (void**)&_pDisp));
    if (_pDisp)
    {
        SetFlag (DISPEX);
    }
    else
    {
        IGNORE_HR(_pPeer->QueryInterface(IID_IDispatch, (void**)&_pDisp));
        Assert (!TestFlag(DISPEX));
    }
}

//+----------------------------------------------------------------------------------
//
//  Member:     CPeerHolder::GetDispIDMulti
//
//-----------------------------------------------------------------------------------

HRESULT
CPeerHolder::GetDispIDMulti(BSTR bstrName, DWORD grfdex, DISPID *pid)
{
    HRESULT             hr = DISP_E_UNKNOWNNAME;
    DISPID              dispid;
    CPeerHolderIterator itr;

    if (!TestFlag(LOCKGETDISPID))
    {
        CLock lock (this, LOCKGETDISPID);

        STRINGCOMPAREFN pfnStrCmp = (grfdex & fdexNameCaseSensitive) ? StrCmpC : StrCmpIC;

        //
        // check if the requested name is name of a peer in the list
        //

        dispid = DISPID_PEER_NAME_BASE;

        for (itr.Start(this); !itr.IsEnd(); itr.Step())
        {
            if (itr.PH()->_cstrName.Length() && bstrName &&
                0 == pfnStrCmp(itr.PH()->_cstrName, bstrName))
                break;

            dispid++;
        }
        if (!itr.IsEnd())
        {
            if (!pid)
            {
                RRETURN (E_POINTER);
            }

            (*pid) = dispid;
            RRETURN (S_OK);
        }

        //
        // check if the name is exposed by a peer
        //

        grfdex &= (~fdexNameEnsure);  // disallow peer to ensure the name

        for (itr.Start(this); !itr.IsEnd(); itr.Step())
        {
            if (!itr.PH()->TestFlag(AFTERINIT)) // if the peer has not initialized yet
                continue;                       // don't invoke it in name resolution yet

            hr = THR_NOTRACE(itr.PH()->GetDispIDSingle(bstrName, grfdex, pid));
            if (S_OK == hr)
                break;
        }
    }

    RRETURN(hr);
}

//+----------------------------------------------------------------------------------
//
//  Member:     CPeerHolder::InvokeExMulti
//
//-----------------------------------------------------------------------------------

HRESULT
CPeerHolder::InvokeExMulti(
    DISPID              dispid,
    LCID                lcid,
    WORD                wFlags,
    DISPPARAMS *        pdispparams,
    VARIANT *           pvarResult,
    EXCEPINFO *         pexcepinfo,
    IServiceProvider *  pSrvProvider)
{
    HRESULT             hr;
    CPeerHolderIterator itr;

    if (DISPID_PEER_NAME_BASE <= dispid && dispid <= DISPID_PEER_NAME_MAX)
    {
        if (0 == (wFlags & DISPATCH_PROPERTYGET))
        {
            hr = DISP_E_MEMBERNOTFOUND;
            goto Cleanup;
        }

        //
        // return IDispatch of a peer holder
        //

        // find corresponding peer holder
        dispid -= DISPID_PEER_NAME_BASE;
        for (itr.Start(this); !itr.IsEnd(); itr.Step())
        {
            if (0 == dispid)
                break;

            dispid--;
        }
        if (itr.IsEnd())
        {
            hr = DISP_E_MEMBERNOTFOUND;
            goto Cleanup;
        }

        if (!pvarResult)
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }

        hr = THR_NOTRACE(itr.PH()->QueryPeerInterface(IID_IDispatch, (void**)&V_DISPATCH(pvarResult)));
        if (hr)
            goto Cleanup;

        V_VT(pvarResult) = VT_DISPATCH;
    }
    else if (DISPID_PEER_HOLDER_FIRST_RANGE_BASE <= dispid)
    {
        //
        // delegate to the corresponding peer holder
        //

        for (itr.Start(this); !itr.IsEnd(); itr.Step())
        {
            if (itr.PH()->_dispidBase <= dispid && dispid < itr.PH()->_dispidBase + DISPID_PEER_HOLDER_RANGE_SIZE)
                break;
        }

        if (itr.IsEnd())
        {
            hr = DISP_E_MEMBERNOTFOUND;
            goto Cleanup;
        }

        hr = THR_NOTRACE(itr.PH()->InvokeExSingle(dispid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, pSrvProvider));
        if (hr)
            goto Cleanup;
    }
    else
    {
        hr = THR_NOTRACE(InvokeExSingle(dispid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, pSrvProvider));
        if (hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerHolder::GetEventDispidMulti, helper
//
//  called from CScriptElement::CommitFunctionPointersCode
//
//----------------------------------------------------------------------------

HRESULT
CPeerHolder::GetEventDispidMulti(LPOLESTR pchEvent, DISPID * pdispid)
{
    HRESULT             hr;
    CPeerHolderIterator itr;

    hr = DISP_E_UNKNOWNNAME;
    for (itr.Start(this); !itr.IsEnd(); itr.Step())
    {
        hr = THR_NOTRACE(itr.PH()->_PeerSite.GetEventDispid(pchEvent, pdispid));
        if (S_OK == hr)
            break;
    }

    RRETURN (hr);
}

//+----------------------------------------------------------------------------------
//
//  Member:     CPeerHolder::GetDispIDSingle
//
//-----------------------------------------------------------------------------------

HRESULT
CPeerHolder::GetDispIDSingle(BSTR bstrName, DWORD grfdex, DISPID *pdispid)
{
    HRESULT         hr;

    if (IllegalSiteCall())
        RRETURN (E_UNEXPECTED);

    if (!pdispid)
        RRETURN (E_POINTER);

    //
    // check to see if the name is a registered event
    //

    if (0 < CustomEventsCount())
    {
        hr = THR_NOTRACE(_PeerSite.GetEventDispid(bstrName, pdispid));
        if (S_OK == hr)     // if found
            goto Cleanup;   // nothing more todo
    }

    //
    // delegate to the peer object
    //

    EnsureDispatch();

    if (_pDisp)
    {
        if (TestFlag(DISPEX))
        {
            hr = THR_NOTRACE(((IDispatchEx*)_pDisp)->GetDispID(
                bstrName,
                grfdex,
                pdispid));
        }
        else
        {
            hr = THR_NOTRACE(_pDisp->GetIDsOfNames(IID_NULL, &bstrName, 1, 0, pdispid));
        }

        if (S_OK == hr)
        {
            if (DISPID_PEER_BASE <= (*pdispid) && (*pdispid) <= DISPID_PEER_MAX)
            {
                (*pdispid) = MapToExternalRange(*pdispid);
            }
            else if (DISPID_PEER_MAX < (*pdispid))
            {
                hr = THR(MapToCompactedRange(pdispid));
                if (hr)
                    goto Cleanup;

                (*pdispid) = MapToExternalRange(*pdispid);
            }
        }
    }
    else
    {
        hr = DISP_E_UNKNOWNNAME;
    }

Cleanup:
    RRETURN(hr);
}

//+----------------------------------------------------------------------------------
//
//  Member:     CPeerHolder::InvokeExSingle
//
//-----------------------------------------------------------------------------------

HRESULT
CPeerHolder::InvokeExSingle(
    DISPID              dispid,
    LCID                lcid,
    WORD                wFlags,
    DISPPARAMS *        pdispparams,
    VARIANT *           pvarResult,
    EXCEPINFO *         pexcepinfo,
    IServiceProvider *  pSrvProvider)
{
    HRESULT         hr;

    if (IllegalSiteCall())
        RRETURN(E_UNEXPECTED);

    //
    // OM surfacing of custom peer events
    //

    if (IsCustomEventDispid(dispid))
    {
        hr = THR(_pElement->InvokeAA(dispid, CAttrValue::AA_Internal, lcid,
                    wFlags, pdispparams, pvarResult, pexcepinfo, pSrvProvider));
        goto Cleanup;   // nothing more todo
    }

    //
    // delegate to the peer object
    //

    if (DISPID_PEER_HOLDER_FIRST_RANGE_BASE <= dispid)
    {
        dispid = MapFromExternalRange(dispid);
    }

    EnsureDispatch();

    if (_pDisp)
    {
        CLock Lock( this, LOCKNODRAW );

        if (DISPID_PEER_COMPACTED_BASE <= dispid && dispid <= DISPID_PEER_COMPACTED_MAX)
        {
            hr = THR_NOTRACE(MapFromCompactedRange(&dispid));
            if (hr)
                goto Cleanup;
        }

        if (TestFlag(DISPEX))
        {
            hr = THR_NOTRACE(((IDispatchEx*)_pDisp)->InvokeEx(
                dispid,
                lcid,
                wFlags,
                pdispparams,
                pvarResult,
                pexcepinfo,
                pSrvProvider));
        }
        else
        {
            hr = THR_NOTRACE(InvokeDispatchWithNoThis (
                _pDisp,
                dispid,
                lcid,
                wFlags,
                pdispparams,
                pvarResult,
                pexcepinfo));
        }
    }
    else
    {
        hr = DISP_E_MEMBERNOTFOUND;
    }

Cleanup:
    RRETURN1(hr, DISP_E_MEMBERNOTFOUND);
}

//+----------------------------------------------------------------------------------
//
//  Member:     CPeerHolder::MapToCompactedRange
//
//-----------------------------------------------------------------------------------

HRESULT
CPeerHolder::MapToCompactedRange(DISPID * pdispid)
{
    HRESULT     hr = S_OK;
    int         idx;
    DISPID *    pItem;

    Assert (pdispid);

    //
    // start up
    //

    if (!_pMiscBag)
    {
        _pMiscBag = new CMiscBag();
        if (!_pMiscBag)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }

    //
    // check if we've mapped the dispid already
    // (a trivial euristic: search backwards so to find properties added later faster)
    //

    for (idx = _pMiscBag->_aryDispidMap.Size() - 1; 0 <= idx; idx--)
    {
        if (_pMiscBag->_aryDispidMap[idx] == *pdispid)
        {
            *pdispid = DISPID_PEER_COMPACTED_BASE + idx;
            goto Cleanup; // done
        }
    }

    if (DISPID_PEER_COMPACTED_MAX - DISPID_PEER_COMPACTED_BASE <= _pMiscBag->_aryDispidMap.Size())
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    //
    // map
    //

    pItem = _pMiscBag->_aryDispidMap.Append();
    if (!pItem)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    *pItem   = *pdispid;
    *pdispid = DISPID_PEER_COMPACTED_BASE + (_pMiscBag->_aryDispidMap.Size() - 1);

Cleanup:
    RRETURN (hr);
}

//+----------------------------------------------------------------------------------
//
//  Member:     CPeerHolder::MapFromCompactedRange
//
//-----------------------------------------------------------------------------------

HRESULT
CPeerHolder::MapFromCompactedRange(DISPID * pdispid)
{
    HRESULT     hr;
    DISPID      dispid = *pdispid - DISPID_PEER_COMPACTED_BASE;

    if (!_pMiscBag ||
        dispid < 0 || _pMiscBag->_aryDispidMap.Size() <= dispid)
    {
        hr = DISP_E_MEMBERNOTFOUND;
        goto Cleanup;
    }

    *pdispid = _pMiscBag->_aryDispidMap[dispid];
    hr = S_OK;

Cleanup:
    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerHolder::GetNextDispIDMulti, helper
//
//----------------------------------------------------------------------------

HRESULT
CPeerHolder::GetNextDispIDMulti(
    DWORD       grfdex,
    DISPID      dispid,
    DISPID *    pdispid)
{
    HRESULT             hr;
    CPeerHolderIterator itr;

    itr.Start(this);

    //
    // make a step within peer holder the current dispid belongs to
    //

    if (IsPeerDispid(dispid))
    {
        // find peer holder this dispid belongs to

        for (;;)
        {
            if (itr.PH()->TestFlag(DISPCACHED))
            {
                // if dispid belongs to the itr.PH() range
                if (itr.PH()->_dispidBase <= dispid && dispid < itr.PH()->_dispidBase + DISPID_PEER_HOLDER_RANGE_SIZE)
                    break;
            }

            itr.Step();
            if (itr.IsEnd())
            {
                hr = S_FALSE;
                goto Cleanup;
            }
        }

        Assert (itr.PH()->TestFlag(DISPEX));

        hr = THR_NOTRACE(((IDispatchEx*)itr.PH()->_pDisp)->GetNextDispID(
            grfdex, itr.PH()->MapFromExternalRange(dispid), pdispid));
        switch (hr)
        {
        case S_OK:
            *pdispid = itr.PH()->MapToExternalRange(*pdispid);
            goto Cleanup;   // done;
        case S_FALSE:
            break;          // keep searching
        default:
            goto Cleanup;   // fatal error
        }

        Assert (S_FALSE == hr);

        itr.Step();
        if (itr.IsEnd())
        {
            hr = S_FALSE;
            goto Cleanup;
        }
    }

    //
    // find first peer holder that:
    // - supports IDispatchEx, and
    // - returns next dispid
    //

    for (;;)
    {
        // find first peer holder that supports IDispatchEx
        for (;;)
        {
            itr.PH()->EnsureDispatch();

            if (itr.PH()->TestFlag(DISPEX))
                break;

            itr.Step();
            if (itr.IsEnd())
            {
                hr = S_FALSE;
                goto Cleanup;
            }
        }

        // check that it returns next dispid
        hr = THR_NOTRACE(((IDispatchEx*)itr.PH()->_pDisp)->GetNextDispID(grfdex, -1, pdispid));
        switch (hr)
        {
        case S_OK:
            *pdispid = itr.PH()->MapToExternalRange(*pdispid);
            goto Cleanup;   // done;
        case S_FALSE:
            break;          // keep searching
        default:
            goto Cleanup;   // fatal error
        }

        itr.Step();
        if (itr.IsEnd())
        {
            hr = S_FALSE;
            goto Cleanup;
        }
    }

Cleanup:
    RRETURN1 (hr, S_FALSE);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerHolder::GetMemberNameMulti, helper
//
//----------------------------------------------------------------------------

HRESULT
CPeerHolder::GetMemberNameMulti(DISPID dispid, BSTR * pbstrName)
{
    HRESULT             hr = DISP_E_UNKNOWNNAME;
    CPeerHolderIterator itr;

    for (itr.Start(this); !itr.IsEnd(); itr.Step())
    {
        if (itr.PH()->_dispidBase <= dispid && dispid < itr.PH()->_dispidBase + DISPID_PEER_HOLDER_RANGE_SIZE)
        {
            if (itr.PH()->TestFlag(DISPEX))
            {
                hr = THR_NOTRACE(((IDispatchEx*)itr.PH()->_pDisp)->GetMemberName(
                    itr.PH()->MapFromExternalRange(dispid), pbstrName));
            }
            break;
        }
    }

    RRETURN1 (hr, DISP_E_UNKNOWNNAME);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CustomEventName, helper
//
//----------------------------------------------------------------------------

LPTSTR CPeerHolder::CustomEventName(int cookie)
{
    DISPID  dispid = CustomEventDispid(cookie);
    LPTSTR  pchName = NULL;

    if (IsStandardDispid(dispid))
    {
        PROPERTYDESC * pPropDesc;

        // CONSIDER (alexz): Because of the search below, we have a slight perf hit
        // when building typeinfo: we make a search in prop descs for every registered event.
        // To solve that, we could store prop desc ptr in the array instead of dispid;
        // but then all the rest of code will be slightly penalized for that by having to do
        // more complex access to dispid, especially in normal case of non-standard events.
        _pElement->FindPropDescFromDispID (dispid, &pPropDesc, NULL, NULL);

        Assert(pPropDesc);

        pchName = (LPTSTR)pPropDesc->pstrName;
    }
    else
    {
        CAtomTable * pAtomTable = NULL;

        Assert (IsCustomEventDispid(dispid));

        pAtomTable = _pElement->GetAtomTable();

        Assert(pAtomTable && "missing atom table ");

        pAtomTable->GetNameFromAtom(AtomFromEventDispid(dispid), (LPCTSTR*)&pchName);
    }

    Assert(pchName && "(bad atom table entries?)");

    return pchName;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CanElementFireStandardEventMulti, helper
//
//----------------------------------------------------------------------------

BOOL
CPeerHolder::CanElementFireStandardEventMulti(DISPID dispid)
{
    CPeerHolderIterator         itr;
    int                         i, c;
    CEventsBag *                pEventsBag;
    CEventsBag::CEventsArray *  pEventsArray;
    CEventsItem *               pEventItem;

    for (itr.Start(this); !itr.IsEnd(); itr.Step())
    {
        pEventsBag = itr.PH()->_pEventsBag;
        if (!pEventsBag)
            continue;

        pEventsArray = &pEventsBag->_aryEvents;
        if (!pEventsArray)
            continue;

        for (i = 0, c = itr.PH()->CustomEventsCount(); i < c; i++)
        {
            pEventItem = &((*pEventsArray)[i]);

            if (dispid == pEventItem->dispid && !(pEventItem->lFlags & BEHAVIOREVENTFLAGS_STANDARDADDITIVE))
            {
                return TRUE;
            }
        }
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerHolder::GetCustomEventsTypeInfoCount, helper
//
//----------------------------------------------------------------------------

HRESULT
CPeerHolder::GetCustomEventsTypeInfoCount(ULONG * pCount)
{
    CPeerHolderIterator itr;

    for (itr.Start(this); !itr.IsEnd(); itr.Step())
    {
        if (0 < itr.PH()->CustomEventsCount())
        {
            itr.PH()->_pEventsBag->_ulTypeInfoIdx = (*pCount);
            (*pCount)++;
        }
    }
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CreateCustomEventsTypeInfo, helper
//
//
//----------------------------------------------------------------------------

HRESULT
CPeerHolder::CreateCustomEventsTypeInfo(ULONG iTI, ITypeInfo ** ppTICoClass)
{
    HRESULT             hr = S_FALSE;
    CPeerHolderIterator itr;

    for (itr.Start(this); !itr.IsEnd(); itr.Step())
    {
        if (0 < itr.PH()->CustomEventsCount() && iTI == itr.PH()->_pEventsBag->_ulTypeInfoIdx)
        {
            hr = THR(itr.PH()->CreateCustomEventsTypeInfo(ppTICoClass));
            break;
        }
    }

    RRETURN1 (hr, S_FALSE);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CreateCustomEventsTypeInfo, helper
//
//----------------------------------------------------------------------------

HRESULT
CPeerHolder::CreateCustomEventsTypeInfo(ITypeInfo ** ppTICoClass)
{
    HRESULT     hr;
    int         i, c;
    FUNCDESC    funcdesc;
    LPTSTR      pchName;

    CCreateTypeInfoHelper Helper;

    if (!ppTICoClass)
        RRETURN (E_POINTER);

    //
    // start creating the typeinfo
    //

    hr = THR(Helper.Start(DIID_HTMLElementEvents));
    if (hr)
        goto Cleanup;

    //
    // set up the funcdesc we'll be using
    //

    memset (&funcdesc, 0, sizeof (funcdesc));
    funcdesc.funckind = FUNC_DISPATCH;
    funcdesc.invkind = INVOKE_FUNC;
    funcdesc.callconv = CC_STDCALL;
    funcdesc.cScodes = -1;

    //
    // add all registered events to the typeinfo
    //

    for (i = 0, c = CustomEventsCount(); i < c; i++)
    {
        funcdesc.memid = CustomEventDispid(i);

        hr = THR(Helper.pTypInfoCreate->AddFuncDesc(i, &funcdesc));
        if (hr)
            goto Cleanup;

        pchName = CustomEventName(i);
        hr = THR(Helper.pTypInfoCreate->SetFuncAndParamNames(i, &pchName, 1));
        if (hr)
            goto Cleanup;
    }

    //
    // finalize creating the typeinfo
    //

    hr = THR(Helper.Finalize(IMPLTYPEFLAG_FDEFAULT | IMPLTYPEFLAG_FSOURCE));
    if (hr)
        goto Cleanup;

    ReplaceInterface (ppTICoClass, Helper.pTICoClassOut);

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::OnLayoutAvailable
//
//-------------------------------------------------------------------------

HRESULT
CPeerHolder::OnLayoutAvailable(CLayout * pLayout)
{
    HRESULT     hr = S_OK;

    if (_pRenderBag)
    {
        hr = THR(UpdateRenderBag());

        // Simulate OnResize
        SIZE size;

        pLayout->GetSize(&size);
        OnResize(size);
    }

    RRETURN (hr);
}


void
CPeerHolder::NotifyDisplayTreeAsync(DWORD_PTR dwContext)
{
    NotifyDisplayTree();
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::NotifyDisplayTree
//
//-------------------------------------------------------------------------

void
CPeerHolder::NotifyDisplayTree()
{
    Assert(_pRenderBag && _pElement);
    CElement * pElemToUse = NULL;

    // if we're in the middle of drawing (or hit-testing), post the notification
    // to be handled asynchronously.  This should be a rare event - behaviors normally
    // don't change themselves during draw.
    if (_pRenderBag->_pCallbackInfo)
    {
        GWPostMethodCall( this,
                            ONCALL_METHOD(CPeerHolder, NotifyDisplayTreeAsync, notifydisplaytreeasync),
                            0, TRUE, "CPeerHolder::NotifyDisplayTreeAsync" );
        return;
    }

    pElemToUse = GetElementToUseForPageTransitions();

    if(!pElemToUse)
        pElemToUse = _pElement;


    // TODO (KTam): This is bad; no one should be touching the display
    // tree outside of rendering code (text/layout/display).  It's not
    // multi-layout aware.  We need a CLayoutInfo method that exposes this
    // functionality.

    // don't call GetUpdatedLayout unless you want the layout to actually be
    // created at this time.

    if(pElemToUse->HasLayoutAry())
    {
        CLayoutAry * pLayoutAry = pElemToUse->GetLayoutAry();
        CLayout    * pCurLayout;
        int nLayoutCookie = 0;

        for(;;)
        {
            pCurLayout = pLayoutAry->GetNextLayout(&nLayoutCookie);
            if(nLayoutCookie == -1 || !pCurLayout)
                break;

            CDispNode *pDispNode = pCurLayout->GetElementDispNode();
            if (pDispNode)
            {
                CView::CEnsureDisplayTree edt(_pElement->Doc()->GetView());
                InvalidateRect(pDispNode, NULL);
                pDispNode->RequestRecalc();
            }
        }
    }
    else
    {
        CLayout *  pLayout = pElemToUse->GetLayoutPtr();

        if (pLayout)
        {
            CDispNode *pDispNode = pLayout->GetElementDispNode();
            if (pDispNode)
            {
                CView::CEnsureDisplayTree edt(pElemToUse->Doc()->GetView());
                InvalidateRect(pDispNode, NULL);
                pDispNode->RequestRecalc();
            }
        }
    }
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::InvalidateRect
//
//-------------------------------------------------------------------------

void
CPeerHolder::InvalidateRect(CDispNode *pDispNode, RECT* prcInvalid)
{
    Assert(pDispNode && _pRenderBag);
    CRect rc;
    BOOL fHasExpand = _pRenderBag->_fHasExpand;
    COORDINATE_SYSTEM cs = (fHasExpand || PaintZOrder() == HTMLPAINT_ZORDER_REPLACE_ALL)
                    ? COORDSYS_BOX
                    : COORDSYS_CONTENT;

    if (!prcInvalid)
    {
        if (cs == COORDSYS_CONTENT)
        {
            pDispNode->GetClientRect(&rc, CLIENTRECT_CONTENT);
        }
        else
        {
            rc = pDispNode->GetSize();
            if (fHasExpand)
            {
                rc.Expand(_pRenderBag->_sPainterInfo.rcExpand);
            }
        }
    }
    else
    {
        rc = *prcInvalid;
        if (fHasExpand)
        {
            rc.OffsetRect(_pRenderBag->_sPainterInfo.rcExpand.left,
                          _pRenderBag->_sPainterInfo.rcExpand.top);
        }
    }

    if (PaintZOrder() != HTMLPAINT_ZORDER_WINDOW_TOP)
    {
        pDispNode->Invalidate(rc, cs);
    }
    else
    {
        pDispNode->InvalidateAtWindowTop(rc, cs);
    }
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::UpdateRenderBag
//
//-------------------------------------------------------------------------

HRESULT
CPeerHolder::UpdateRenderBag()
{
    HRESULT     hr = S_OK;
    IHTMLFilterPainter *pFilterPainter;
    IHTMLPainterOverlay *pPainterOverlay;
    IHTMLPainterEventInfo *pEventInfo;
    CElement * pElemToUse;

    Assert (_pRenderBag && _pRenderBag->_pPainter);

    hr = THR(_pRenderBag->_pPainter->GetPainterInfo(&_pRenderBag->_sPainterInfo));
    if (hr)
        goto Cleanup;

    pElemToUse = GetElementToUseForPageTransitions();

    if(!pElemToUse)
        pElemToUse = _pElement;

    // if SURFACE or SURFACE3D bits are set
    if (_pRenderBag->_sPainterInfo.lFlags & (HTMLPAINTER_SURFACE | HTMLPAINTER_3DSURFACE))
    {
        pElemToUse->SetSurfaceFlags(0 != (_pRenderBag->_sPainterInfo.lFlags  & HTMLPAINTER_SURFACE),
                                 0 != (_pRenderBag->_sPainterInfo.lFlags  & HTMLPAINTER_3DSURFACE));
    }


    TraceTag((tagPeerDrawObject, 
              "+ CPeerHolder::UpdateRenderBag, _fWantsDrawObject: %s",
              _pRenderBag->_fWantsDrawObject ? "true" : "false"));

    _pRenderBag->_fWantsDrawObject = !IsEqualIID(_pRenderBag->_sPainterInfo.iidDrawObject, g_Zero.iid);

    TraceTag((tagPeerDrawObject, 
              "- CPeerHolder::UpdateRenderBag, _fWantsDrawObject: %s",
              _pRenderBag->_fWantsDrawObject ? "true" : "false"));

    _pRenderBag->_fHasExpand = !(_pRenderBag->_sPainterInfo.rcExpand.top == 0 &&
                                _pRenderBag->_sPainterInfo.rcExpand.bottom == 0 &&
                                _pRenderBag->_sPainterInfo.rcExpand.left == 0 &&
                                _pRenderBag->_sPainterInfo.rcExpand.right == 0);

    _pRenderBag->_fIsFilter = FALSE;
    if (OK(QueryPeerInterface(IID_IHTMLFilterPainter, (void**)&pFilterPainter)))
    {
        _pRenderBag->_fIsFilter = TRUE;
        ReleaseInterface(pFilterPainter);
    }

    _pRenderBag->_fIsOverlay = FALSE;
    if (OK(QueryPeerInterface(IID_IHTMLPainterOverlay, (void**)&pPainterOverlay)))
    {
        _pRenderBag->_fIsOverlay = TRUE;
        ReleaseInterface(pPainterOverlay);
    }

    if ((_pRenderBag->_pAdapter == NULL) && SUCCEEDED(_pRenderBag->_pPainter->QueryInterface(IID_IHTMLPainterEventInfo, (LPVOID *)&pEventInfo)))
    {
        Assert(pEventInfo);

        long flags = 0;

        pEventInfo->GetEventInfoFlags(&flags);

        if (flags & HTMLPAINT_EVENT_TARGET)
            _pRenderBag->_fEventTarget = 1;

        if (flags & HTMLPAINT_EVENT_SETCURSOR)
            _pRenderBag->_fSetCursor = 1;

        pEventInfo->Release();

    }

#if DBG == 1
    if (IsTagEnabled(tagPeerNoHitTesting))
    {
        _pRenderBag->_sPainterInfo.lFlags &= ~HTMLPAINTER_HITTEST;
    }
#endif

    NotifyDisplayTree();

Cleanup:
    RRETURN (hr);
}


//+------------------------------------------------------------------------
//
//  Member: CPeerHolder::OnResize, delegate to the behavior
//
//-------------------------------------------------------------------------
void
CPeerHolder::OnResize(SIZE size)
{
    Assert(_pRenderBag);

    size.cx += _pRenderBag->_sPainterInfo.rcExpand.left + _pRenderBag->_sPainterInfo.rcExpand.right;
    size.cy += _pRenderBag->_sPainterInfo.rcExpand.top + _pRenderBag->_sPainterInfo.rcExpand.bottom;

    _pRenderBag->_pPainter->OnResize(size);
}
//  Member: CPeerHolder::OnResize, delegate to the behavior


extern BOOL g_fInVizAct2000;

//+------------------------------------------------------------------------
//
//  Member: CPeerHolder::Draw, IHTMLPainter
//
//-------------------------------------------------------------------------
HRESULT
CPeerHolder::Draw(CDispDrawContext * pContext, LONG lRenderInfo)
{
    HRESULT         hr              = S_OK;
    HDC             hdc             = NULL;
    CFormDrawInfo * pDI             = (CFormDrawInfo *)pContext->GetClientData();
    LONG            lDrawFlags      = 0;    // TODO display tree should supply
    IUnknown *      punkDrawObject  = NULL; // TODO display tree should supply
    CRect           rcBounds        = pDI->_rc;
    CRect           rcClip          = pDI->_rcClip;
    CRect           rcClipPrinter;
    int             nSavedDC        = 0;
    HDC             hdcDD           = NULL;
    IDirectDrawSurface *    
                    pDDSurface      = NULL;
    HTML_PAINTER_INFO & 
                    sPainterInfo    = _pRenderBag->_sPainterInfo;
    RENDER_CALLBACK_INFO sCallbackInfo;



    Assert(_pRenderBag && _pRenderBag->_pPainter);

    // fCreateSurface           If we're rendering to an actual printer and the
    //                          filter has requested a DirectDraw surface to
    //                          draw onto, we'll need to create one since
    //                          there's no screen buffer surface during printing.

    bool    fCreateSurface  = false;

    // fWantsDirectDrawObject   True if this rendering behavior would like to
    //                          render to a DirectDraw surface.

    bool    fWantsDirectDrawObject  = 
                   _pRenderBag->_fWantsDrawObject 
                && (IID_IDirectDrawSurface == _pRenderBag->_sPainterInfo.iidDrawObject);

    // fHighResolution          True if the display device is a high resolution
    //                          display.

    bool    fHighResolution = g_uiDisplay.IsDeviceScaling() ? true : false;




    rcClipPrinter.SetRectEmpty();

#if DBG == 1
    // Variables to track hdc origin to ensure the peer doesn't change it on us.

    CPoint ptOrgBefore = g_Zero.pt; // keep compiler happy
    CPoint ptOrgAfter;

    if (IsTagEnabled(tagPeerNoRendering))
        goto Cleanup;
#endif

    // Don't re-enter behaviors from an invoke.

    if (g_fInVizAct2000 && TestFlag(LOCKNODRAW))
    {
        goto Cleanup;
    }

    // Store the information needed if painter calls us back during Draw
    {
        const CDispClipTransform& transform = pContext->GetClipTransform();

        transform.Transform(rcClip, &sCallbackInfo._rcgClip);
        sCallbackInfo._pContext = pContext;

        if (!pContext->GetRedrawRegion()->Contains(sCallbackInfo._rcgClip))
            lDrawFlags |= HTMLPAINT_DRAW_UPDATEREGION;
    }

    // The following code block covers three scenarios, although it looks more 
    // like two.
    //
    // 1.  The painter wants a draw object.  Fill in our punkDrawObject local
    //     variable.
    // 2.  The painter wants an HDC, fill in our hdc local variable.
    // 3.  The painter doesn't want either (implied) in which case both will
    //     be left empty and passed to the painter as NULL.  (Who knows what the
    //     painter will do then.)

    if (_pRenderBag->_fWantsDrawObject)
    {
        // If the renderer wants to draw onto a special draw object, we'll get 
        // the object it wants with the GetSurface call.  Currently only 
        // DirectDraw surfaces are supported as draw objects.  If any other 
        // draw objects are requested, we'll fail and leave the method.

        CSize sizeOffset;

        hr = pDI->GetSurface(!(sPainterInfo.lFlags & HTMLPAINTER_NOPHYSICALCLIP),
                                _pRenderBag->_sPainterInfo.iidDrawObject,
                                (void**)&punkDrawObject, &sizeOffset);

        if (   (E_FAIL == hr)
            && (pContext->GetLayoutContext() != GUL_USEFIRSTLAYOUT)
            && (pContext->GetLayoutContext()->GetMedia() & mediaTypePrint)
            && fWantsDirectDrawObject)
        {
            // If pDI->GetSurface wasn't able to return a surface, and we're
            // print media (print preview or actual printing), and the draw 
            // object requested is a DirectDraw surface it means we're printing
            // to an actual printer and will have to create a surface for the 
            // peer.

            fCreateSurface  = true;
            hr              = S_OK;
        }
        else if (hr)
        {
            goto Cleanup;
        }

        // If we give the painter the DirectDraw surface, they may not be using
        // GDI to paint.  We need to make sure GDI does all of it's cached
        // drawing now so that it won't do it later on top of what the painter
        // is about to draw.

        ::GdiFlush();

        // If the only transformation for this object is a translation to 
        // position it correctly, we'll just add the translation offset into
        // the rectangles we pass the painter.  If not, we'll tell the painter
        // that they need to call us back to get the full tranformation matrix
        // to use.  If the painter doesn't support painting with a 
        // transformation matrix, we just won't draw anything.

        if (   pDI->IsOffsetOnly()
            && !(fHighResolution && fWantsDirectDrawObject))
        {
            rcBounds.OffsetRect(sizeOffset);
            rcClip.OffsetRect(sizeOffset);
        }
        else if (sPainterInfo.lFlags & HTMLPAINTER_SUPPORTS_XFORM)
        {
            lDrawFlags |= HTMLPAINT_DRAW_USE_XFORM;
        }
        else
        {
            goto Cleanup;
        }

        // If we're working with an object that renders to a DirectDraw surface
        // we will have to scale the coordinates down if we're printing or in 
        // high resolution drawing mode.

        if (fWantsDirectDrawObject)
        {
            if (   (pContext->GetLayoutContext() != GUL_USEFIRSTLAYOUT)
                && (pContext->GetLayoutContext()->GetMedia() & mediaTypePrint))
            {
                // If we're printing an object that's rendering to a DirectDraw
                // surface we need to convert the coordinates from print
                // measurement coordinates to screen coordinates.  These
                // painters should not know the difference between screen
                // rendering and print rendering.

                // Save clip bounds in printer device coordinates in case we're 
                // rendering to a printer.

                CopyRect(&rcClipPrinter, &rcClip);

                // Transform bounds into screen coordinates.

                // 2001/03/28 mcalkins:
                // Should really use DocPixelsFromDevice, why didn't I notice
                // that before?

                g_uiVirtual.TargetFromDevice(rcBounds,  g_uiDisplay);
                g_uiVirtual.TargetFromDevice(rcClip,    g_uiDisplay);

    #if DBG == 1
                if (IsTagEnabled(tagPrintFilterRect))
                {
                    XHDC    xhdc    = pDI->GetDC(
                                      !(sPainterInfo.lFlags & HTMLPAINTER_NOPHYSICALCLIP));
                    HBRUSH  hbr     = CreateSolidBrush(RGB(255, 0, 0));

                    xhdc.FillRect(&rcClipPrinter, hbr);

                    DeleteObject(hbr);
                }
    #endif
            }
            else if (fHighResolution)
            {
                // If we're in high resolution mode, we need to convert from the
                // screen device DPI down to the document DPI (generally 96dpi.)

                g_uiDisplay.DocPixelsFromDevice(&rcBounds);
                g_uiDisplay.DocPixelsFromDevice(&rcClip);
            }
        }

    }
    else if (!(sPainterInfo.lFlags & HTMLPAINTER_NODC))
    {
        XHDC    xhdc            = pDI->GetDC(!(sPainterInfo.lFlags 
                                               & HTMLPAINTER_NOPHYSICALCLIP));
        CSize   sizeTranslate   = g_Zero.size;

        // Similar to the logic for when the painter wants a draw object above.
        // If the transformation for the element is merely a translation, 
        // XHDC::GetTranslatedDC will return true and fill in the sizeTranslate
        // structure.  Otherwise if the painter supports drawing with a 
        // complex transformation matrix, we'll tell them to call Trident back
        // to ask for the matrix.  Otherwise, if we're printing, we'll use the
        // NoTransformDrawHelper.

        if (xhdc.GetTranslatedDC(&hdc, &sizeTranslate))
        {
            rcBounds.OffsetRect(sizeTranslate);
            rcClip.OffsetRect(sizeTranslate);
        }
        else if (sPainterInfo.lFlags & HTMLPAINTER_SUPPORTS_XFORM)
        {
            // The painter says it can deal with transforms.  Give it the raw
            // DC, and wish it luck.  If it screws up, don't blame Trident.

            lDrawFlags |= HTMLPAINT_DRAW_USE_XFORM;
            hdc         = xhdc.GetPainterDC();
        }
        else
        {
            // If the painter can't deal with transforms, then we need to help
            // them out (back compat) when printing.  IsPrintPreviewDoc()
            // returns true if we're print previewing or if we're actually
            // printing to a printer device.
            if (_pElement->IsPrintMedia())
            {
                // set up the callback info
                sCallbackInfo._lFlags = lDrawFlags;
                _pRenderBag->_pCallbackInfo = &sCallbackInfo;

                hr = NoTransformDrawHelper(pContext);
            }

            goto Cleanup;
        }
    }

#if DBG == 1
    if (hdc && IsTagEnabled(tagVerifyPeerDraw))
    {
        ::GetViewportOrgEx(hdc, &ptOrgBefore);
    }
#endif

    // If we're sending an HDC and the painter has asked us to save the state
    // of the device context, then save it.  This takes the pressure of the 
    // painter for leaving the device context as it was given.
    
    if (hdc && !(sPainterInfo.lFlags & HTMLPAINTER_NOSAVEDC))
    {
        nSavedDC = ::SaveDC(hdc);
    }

    // set up the callback info
    sCallbackInfo._lFlags = lDrawFlags;
    _pRenderBag->_pCallbackInfo = &sCallbackInfo;

    TraceTag((tagPainterDraw, "Draw %x (%ld,%ld,%ld,%ld) (%ld,%ld,%ld,%ld) %x",
                this,
                rcBounds.left, rcBounds.top, rcBounds.right, rcBounds.bottom,
                rcClip.left, rcClip.top, rcClip.right, rcClip.bottom,
                lDrawFlags
            ));

    // If we don't have to create a DirectDraw surface for the painter we're
    // prepared to ask the painter to draw at this point.

    if (!fCreateSurface)
    {
        // Some painters, like the 64 bit VML change the DC setting (like ViewportOrg)
        // And that problem in this branch because here we ususally reuse the surface.
        // We used to save and restore the hdc, but not the one from the surface
        int nSaveDCSurf = 0;
        HDC hdcSurface = NULL;
        // Painters can promise they will not change the DC, and in that case we can save
        // 2 system calls.
        if((!(sPainterInfo.lFlags & HTMLPAINTER_NOSAVEDC)) && pDI->_pSurface)
        {
            pDI->_pSurface->GetDC(&hdcSurface);
            nSaveDCSurf = SaveDC(hdcSurface);
        }

        hr = THR(_pRenderBag->_pPainter->Draw(rcBounds, rcClip, lDrawFlags,
                                              hdc, (void *)punkDrawObject));

        if (hr == E_NOTIMPL)
        {
            hr = S_OK;
        }

        if(!(sPainterInfo.lFlags & HTMLPAINTER_NOSAVEDC))
        {
            if (nSaveDCSurf)
            {
                ::RestoreDC(hdcSurface, nSaveDCSurf);
            }
        }

    }
    else 
    {
        // At this point we're printing to an actual printer device for a
        // painter that's requested a DirectDraw surface.  We need to create the
        // surface.

        CElement *      pElemParent     = NULL;
        DWORD           dwBackground    = 0xFFFFFFFF; // Default to white.
        XHDC            xhdc            = pDI->GetDC(!(sPainterInfo.lFlags & HTMLPAINTER_NOPHYSICALCLIP));
        DDSURFACEDESC   ddsd;
        DDBLTFX         ddbfx;

        Assert(NULL == hdc);

        // Translate the rects so that their origin is {0, 0}.

        OffsetRect(&rcClip,   -rcClip.left,   -rcClip.top);
        OffsetRect(&rcBounds, -rcBounds.left, -rcBounds.top);

        // Clear the surface description and blit effects structures.

        ZeroMemory(&ddsd, sizeof(ddsd));
        ZeroMemory(&ddbfx, sizeof(ddbfx));

        // Prepare a surface description of the surface that will be passed
        // to the painter.

        ddsd.dwSize     = sizeof(DDSURFACEDESC);
        ddsd.dwFlags    = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH | DDSD_PIXELFORMAT;
        ddsd.dwHeight   = rcClip.bottom - rcClip.top;
        ddsd.dwWidth    = rcClip.right  - rcClip.left;

        ddsd.ddsCaps.dwCaps = DDSCAPS_DATAEXCHANGE | DDSCAPS_OWNDC 
                              | DDSCAPS_3DDEVICE;

        ddsd.ddpfPixelFormat.dwSize             = sizeof(DDPIXELFORMAT);
        ddsd.ddpfPixelFormat.dwFlags            = DDPF_RGB;
        ddsd.ddpfPixelFormat.dwFourCC           = 0;
        ddsd.ddpfPixelFormat.dwRGBBitCount      = 32;
        ddsd.ddpfPixelFormat.dwRBitMask         = 0x00FF0000;
        ddsd.ddpfPixelFormat.dwGBitMask         = 0x0000FF00;
        ddsd.ddpfPixelFormat.dwBBitMask         = 0x000000FF;
        ddsd.ddpfPixelFormat.dwRGBAlphaBitMask  = 0x00000000;

        // Create the surface.

        hr = g_pDirectDraw->CreateSurface(&ddsd, &pDDSurface, NULL);

        if (hr)
        {
            goto Cleanup;
        }

        // Get parent element.

        pElemParent = _pElement->GetFirstBranch()->Parent()->Element();

        if (pElemParent)
        {
            COLORREF colorBackground = pElemParent->GetInheritedBackgroundColor();

            // COLORREFs come in a different format than traditional AARRGGBB
            // so we need to assemble a traditional DWORD representation of the
            // color to be used by ddraw.

            dwBackground =    0xFF000000 
                            | GetRValue(colorBackground) << 16
                            | GetGValue(colorBackground) << 8
                            | GetBValue(colorBackground);
        }

        // Draw parent's background color onto the surface.  We would like to
        // be able to draw everything behind the element onto the surface but
        // that is too complex for IE6.0.  In the future, we should use GDIPlus
        // or some other technology that is capable of blitting to printers
        // using alpha blending.

        ddbfx.dwSize        = sizeof(ddbfx);
        ddbfx.dwFillColor   = dwBackground;

        hr = pDDSurface->Blt(NULL, NULL, NULL, DDBLT_COLORFILL, &ddbfx);

        if (hr)
        {
            goto Cleanup;
        }

        // Get the DC from the DirectDraw surface to create the XHDC that
        // will be used for the StretchBlt calls.
        
        hr = pDDSurface->GetDC(&hdcDD);

        if (hr)
        {
            goto Cleanup;
        }
        else
        {
            // Create the XHDC for the DirectDraw surface.

            BOOL        fResult                 = FALSE;
            XHDC        xhdcDD(hdcDD, NULL);

            // TODO:    (mcalkins) Some function should be called here to draw
            //          the page behind the element onto the surface being
            //          passed to the painter.

            // We don't want the painter to use the transform because we'll use
            // StretchBlt later to do both the appropriate scaling and offset.

            lDrawFlags &= (~HTMLPAINT_DRAW_USE_XFORM);

            // Ask the painter to draw.

            hr = THR(_pRenderBag->_pPainter->Draw(rcBounds, rcClip,
                                                  lDrawFlags, hdc, 
                                                  (void *)pDDSurface));

            if (hr)
            {
                if (hr == E_NOTIMPL)
                {
                    hr = S_OK;
                }

                goto Cleanup;
            }

            fResult = xhdc.StretchBlt(rcClipPrinter.left, rcClipPrinter.top, 
                                      rcClipPrinter.right - rcClipPrinter.left,
                                      rcClipPrinter.bottom - rcClipPrinter.top,
                                      xhdcDD,
                                      rcClip.left, rcClip.top, 
                                      rcClip.right - rcClip.left,
                                      rcClip.bottom - rcClip.top,
                                      SRCCOPY);

            if (!fResult)
            {
#if DBG == 1
                DWORD dw = GetLastError();

                TraceTag((tagVerifyPeerDraw, 
                          "In CPeerHolder::Draw, "
                          "XHDC::StretchBlt failed.  GetLastError: %x",
                          dw));
#endif

                hr = E_FAIL;

                goto Cleanup;
            }
        }
    }

Cleanup:

    _pRenderBag->_pCallbackInfo = NULL;


#if DBG == 1
    if (hdc && IsTagEnabled(tagVerifyPeerDraw))
    {
        ::GetViewportOrgEx(hdc, &ptOrgAfter);
        if (ptOrgBefore != ptOrgAfter)
        {
            TraceTag((tagVerifyPeerDraw, "peer %x changed DC %x origin from %d,%d to %d,%d",
                      this, hdc,
                      ptOrgBefore.x, ptOrgBefore.y,
                      ptOrgAfter.x, ptOrgAfter.y));
        }
    }
#endif

    if (nSavedDC)
    {
        ::RestoreDC(hdc, nSavedDC);
    }

    if (hdcDD)
    {
        ReleaseDC(NULL, hdcDD);
    }

    ReleaseInterface(pDDSurface);

    RRETURN(hr);
}
//  Member: CPeerHolder::Draw, IHTMLPainter


//+----------------------------------------------------------------------
//
//  Member :    CPeerHolder:NoTransformDrawHelper
//
//  Synopsis :  This is called for printing renderingBehaviors that do NOT
//      themselves support transformations.  To make this work (back compat)
//      what we do is:
//          1. create a base-white bitmap and have the behavior draw into that
//          2. create a base-black bintmap and have the behavior draw into that
//          3. xor the bitmaps to get a mask
//          4. use the mask to whiten the bits to draw in the destination DC
//          5. now transfer (using bit-wise-and) the white-base drawing to the
//                  destination
//
//-----------------------------------------------------------------------
HRESULT
CPeerHolder::NoTransformDrawHelper(CDispDrawContext * pContext)
{
    HRESULT         hr     = S_OK;

    HDC             hdcBmpWhite   = NULL;
    HBITMAP         hbmpWhite     = NULL;
    HBRUSH          hbrWhite      = NULL;
    XHDC            xhdcSrcWhite  = NULL;

    HDC             hdcBmpBlack   = NULL;
    HBITMAP         hbmpBlack     = NULL;
    HBRUSH          hbrBlack      = NULL;
    XHDC            xhdcSrcBlack  = NULL;

    CFormDrawInfo * pDI    = (CFormDrawInfo *) pContext->GetClientData();
    CRect           rcBounds = pDI->_rc;
    CRect           rcClip   = pDI->_rcClip;
    HANDLE          hbmpOrg  = NULL;
    XHDC            xhdcDest = pDI->GetDC();

    {
        //TODO (mikhaill) -- this seem works correct, but I'm not sure
        //that these weird coordinate conversions should be made here
        if (xhdcDest.GetObjectType() == OBJ_DC)
        {
            const CWorldTransform &xf = xhdcDest.transform();
            xf.Transform(&rcBounds);
            xf.Transform(&rcClip);
        }
        else
        {
            rcBounds.left   = pDI->DocPixelsFromDeviceX(rcBounds.left  );
            rcBounds.top    = pDI->DocPixelsFromDeviceY(rcBounds.top   );
            rcBounds.right  = pDI->DocPixelsFromDeviceX(rcBounds.right );
            rcBounds.bottom = pDI->DocPixelsFromDeviceY(rcBounds.bottom);
            rcClip.left   = pDI->DocPixelsFromDeviceX(rcClip.left  );
            rcClip.top    = pDI->DocPixelsFromDeviceY(rcClip.top   );
            rcClip.right  = pDI->DocPixelsFromDeviceX(rcClip.right );
            rcClip.bottom = pDI->DocPixelsFromDeviceY(rcClip.bottom);
        }
    }

    rcClip.OffsetRect(-rcBounds.TopLeft().AsSize());
    rcBounds.MoveToOrigin();

    //
    // 1. get a white-based bitmap in compatible DC
    //------------------------------------------------
    {
        hdcBmpWhite = CreateCompatibleDC(xhdcDest);
        if (!hdcBmpWhite)
        {
            hr = GetLastError();
            goto Cleanup;
        }

        hbmpWhite = CreateCompatibleBitmap(xhdcDest,
                                           rcBounds.Width(),
                                           rcBounds.Height());
        if (!hbmpWhite )
        {
            WHEN_DBG(GetLastError());
            hr = S_OK;
            goto Cleanup;
        }

        hbmpOrg = SelectObject(hdcBmpWhite, hbmpWhite);
        hbrWhite = CreateSolidBrush(0xffffff);      // white
        xhdcSrcWhite = XHDC(hdcBmpWhite, NULL);

        // fill with white
        xhdcSrcWhite.FillRect(&rcBounds, hbrWhite);

        // do the actual draw into that bitmap
        //--------------------------------------------------

        hr = THR(_pRenderBag->_pPainter->Draw(rcBounds,
                                              rcBounds,
                                              0,
                                              hdcBmpWhite,
                                              NULL));

    }

    if (hr)
        goto Cleanup;

    //
    // 3. get a black-based bitmap in compatible DC
    //------------------------------------------------
    {
        hdcBmpBlack = CreateCompatibleDC(xhdcDest);
        if (!hdcBmpBlack)
        {
            hr = GetLastError();
            goto Cleanup;
        }

        hbmpBlack = CreateCompatibleBitmap(xhdcDest,
                                           rcBounds.Width(),
                                           rcBounds.Height());
        if (!hbmpBlack)
        {
            WHEN_DBG(GetLastError());
            hr = S_OK;
            goto Cleanup;
        }

        hbmpOrg = SelectObject(hdcBmpBlack, hbmpBlack);
        hbrBlack = CreateSolidBrush(0x0);            // Black
        xhdcSrcBlack = XHDC(hdcBmpBlack, NULL);

        // fill with Black
        xhdcSrcBlack.FillRect(&rcBounds, hbrBlack);

        // do the actual draw into that bitmap
        //--------------------------------------------------

        hr = THR(_pRenderBag->_pPainter->Draw(rcBounds,
                                              rcBounds,
                                              0,
                                              hdcBmpBlack,
                                              NULL));

    }


    if (hr)
        goto Cleanup;
    //
    // 4. create a mask from the two bitmaps
    //------------------------------------------------
    {
        if (!xhdcSrcBlack.StretchBlt(
                     rcBounds.left,
                     rcBounds.top,
                     rcBounds.Width(),
                     rcBounds.Height(),
                     xhdcSrcWhite,
                     rcBounds.left,
                     rcBounds.top,
                     rcBounds.Width(),
                     rcBounds.Height(),
                     SRCINVERT))
        {
            hr = GetLastError();
            goto Cleanup;
        }
    }

    //
    // 5.  Use the mask to maskBlt to whiten the destinate bits
    //      that we know we want to print to
    //------------------------------------------------
    if (!xhdcDest.StretchBlt(
                        pDI->_rcClip.left,   // Destination values
                        pDI->_rcClip.top,
                        pDI->_rcClip.Width(),
                        pDI->_rcClip.Height(),
                        xhdcSrcBlack,      // Black is currently the Mask
                        rcClip.left,       // Source values
                        rcClip.top,
                        rcClip.Width(),
                        rcClip.Height(),
                        MERGEPAINT))       // invert the mask, Bitwise OR into the dest
    {
        hr = GetLastError();
    }

    // we have now whitened the destination bits that we want to print to.

    //
    // 6. transfer the white-based drawn image into the whitened destination
    //-----------------------------------------------------------------------
    if (SUCCEEDED(hr))
    {
        // now StretchBlt into the place where we render
        //-----------------------------------------------
        if (!xhdcDest.StretchBlt(
                            pDI->_rcClip.left,   // Destination values
                            pDI->_rcClip.top,
                            pDI->_rcClip.Width(),
                            pDI->_rcClip.Height(),
                            xhdcSrcWhite,
                            rcClip.left,       // Source values
                            rcClip.top,
                            rcClip.Width(),
                            rcClip.Height(),
                            SRCAND))          // DWORD dwRop
        {
            hr = GetLastError();
        }
    }

Cleanup:
    if (hr == E_NOTIMPL)
        hr = S_OK;

    if (hdcBmpWhite)
        DeleteDC(hdcBmpWhite);

    if (hbmpWhite)
        DeleteObject(hbmpWhite);

    if (hbrWhite)
        DeleteObject(hbrWhite);

    if (hdcBmpBlack)
        DeleteDC(hdcBmpBlack);

    if (hbmpBlack)
        DeleteObject(hbmpBlack);

    if (hbrBlack)
        DeleteObject(hbrBlack);

    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::HitTestPoint, helper for IHTMLPainter
//
//-------------------------------------------------------------------------

HRESULT
CPeerHolder::HitTestPoint(CDispHitContext *pContext, BOOL fHitContent, POINT * pPoint, BOOL * pfHit)
{
    HRESULT     hr;
    Assert(_pRenderBag && _pRenderBag->_pPainter);
    Assert(_pRenderBag->_pCallbackInfo == NULL);
    CHitTestInfo *phti = (CHitTestInfo *)(pContext->_pClientData);
    RENDER_CALLBACK_INFO sCallbackInfo;

    *pfHit = FALSE;
    sCallbackInfo._pContext = pContext;
    _pRenderBag->_pCallbackInfo = &sCallbackInfo;
    _pRenderBag->_fHitContent = fHitContent;

    // this is a bad assert.  the reason is that a "psuedo hit" fills in this
    // structure, but RETURNS FALSE so that hit testing can continue looking for a
    // "hard" hit.
    // Assert(phti->_htc == HTC_NO);

    LONG lPartID;

    TraceTag((tagPainterHit, "%x +HitTest at %ld,%ld",
                    this, pPoint->x, pPoint->y));

    // TODO (michaelw) sambent should fix this
    //
    // Behaviors expect coordinates to be local to their 0, 0 based rect
    //
    // The display tree incorrectly assumes a rect of -something, -something, ...
    //

    POINT pt = *pPoint;

    pt.x += _pRenderBag->_sPainterInfo.rcExpand.left;
    pt.y += _pRenderBag->_sPainterInfo.rcExpand.top;
    hr = THR(_pRenderBag->_pPainter->HitTestPoint(pt, pfHit, &lPartID));

    TraceTag((tagPainterHit, "%x -HitTest at %ld,%ld  returns %s  part %ld",
                    this, pPoint->x, pPoint->y, (*pfHit? "true" : "false"), lPartID));

    _pRenderBag->_pCallbackInfo = NULL;

    if (!hr && *pfHit)
    {
        // If the behavior is actually a filter and is nesting hit-tests and it succeeded then
        // _htc has already been set.  Otherwise, the hit is really on this element/behavior
        if (phti->_htc == HTC_NO)
        {
            // We can't set the htc code here because the layout
            // code needs to see if it has been set or not
            if (phti->_plBehaviorCookie)
                *phti->_plBehaviorCookie = CookieID();

            if (phti->_plBehaviorPartID)
                *phti->_plBehaviorPartID = lPartID;

            if (phti->_ppElementEventTarget)
                IGNORE_HR(GetEventTarget(phti->_ppElementEventTarget));
        }

    }

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::GetEventTarget
//
//-------------------------------------------------------------------------
HRESULT
CPeerHolder::GetEventTarget(CElement **ppElement)
{
    Assert(ppElement);
    HRESULT hr = S_FALSE;

    *ppElement = NULL;
    if (_pRenderBag->_fEventTarget)
    {
        IHTMLPainterEventInfo *pEventInfo = NULL;

        hr = THR(_pRenderBag->_pPainter->QueryInterface(IID_IHTMLPainterEventInfo, (LPVOID *)&pEventInfo));
        if (!hr && pEventInfo)
        {
            IHTMLElement *pElement = 0;

            hr = THR(pEventInfo->GetEventTarget(&pElement));
            if (!hr && pElement)
            {
                hr = THR(pElement->QueryInterface(CLSID_CElement, (LPVOID *)ppElement));
                if (!hr)
                    *ppElement = NULL;

                ReleaseInterface(pElement);
            }
            ReleaseInterface(pEventInfo);
        }
    }

    RRETURN1(hr, S_FALSE);
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::SetCursor
//
//-------------------------------------------------------------------------
HRESULT
CPeerHolder::SetCursor(LONG lPartID)
{
    HRESULT hr = S_FALSE;
    if (_pRenderBag && _pRenderBag->_fSetCursor)
    {
        IHTMLPainterEventInfo *pEventInfo = NULL;

        hr = THR(_pRenderBag->_pPainter->QueryInterface(IID_IHTMLPainterEventInfo, (LPVOID *)&pEventInfo));
        if (!hr && pEventInfo)
        {
            hr = pEventInfo->SetCursor(lPartID);

            ReleaseInterface(pEventInfo);
        }
    }

    RRETURN1(hr, S_FALSE);
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::StringFromPartID
//
//-------------------------------------------------------------------------
HRESULT
CPeerHolder::StringFromPartID(LONG lPartID, BSTR *pbstrPartID)
{
    HRESULT hr = S_FALSE;
    if (_pRenderBag && _pRenderBag->_pPainter && _pRenderBag->_pAdapter == NULL)
    {
        IHTMLPainterEventInfo *pEventInfo = NULL;

        hr = THR(_pRenderBag->_pPainter->QueryInterface(IID_IHTMLPainterEventInfo, (LPVOID *)&pEventInfo));
        if (!hr && pEventInfo)
        {
            hr = pEventInfo->StringFromPartID(lPartID, pbstrPartID);

            ReleaseInterface(pEventInfo);
        }
        
        if (hr == E_NOINTERFACE)
            hr = S_FALSE;
    }

    RRETURN1(hr, S_FALSE);
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::OnMove, helper for IHTMLPainter
//
//-------------------------------------------------------------------------
HRESULT
CPeerHolder::OnMove(CRect *prcScreen)
{
    HRESULT hr = S_OK;
    if (_pRenderBag && _pRenderBag->_fIsOverlay)
    {
        IHTMLPainterOverlay *pPainterOverlay = NULL;

        hr = THR(QueryPeerInterface(IID_IHTMLPainterOverlay, (LPVOID *)&pPainterOverlay));
        if (!hr && pPainterOverlay)
        {
            hr = pPainterOverlay->OnMove(*prcScreen);

            ReleaseInterface(pPainterOverlay);
        }
    }

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::InvalidateFilter, helper for filter behavior
//
//-------------------------------------------------------------------------

void
CPeerHolder::InvalidateFilter(
                const RECT* prc,
                HRGN hrgn,
                BOOL fSynchronousRedraw)
{
    Assert(IsFilterPeer());
    IHTMLFilterPainter *pFilterPainter = NULL;

    if (OK(QueryPeerInterface(IID_IHTMLFilterPainter, (void**)&pFilterPainter)))
    {
        BOOL fSyncRedrawSave = _pRenderBag->_fSyncRedraw;
        _pRenderBag->_fSyncRedraw = fSynchronousRedraw;

        if (hrgn)
        {
            pFilterPainter->InvalidateRgnUnfiltered(hrgn);
        }
        else
        {
            if(prc)
            {
                CRect rcInvalid = *prc;
                pFilterPainter->InvalidateRectUnfiltered(&rcInvalid);
            }
            else
            {
                pFilterPainter->InvalidateRectUnfiltered(NULL);
            }
        }

        _pRenderBag->_fSyncRedraw = fSyncRedrawSave;
    }

    ReleaseInterface(pFilterPainter);
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::SetFilteredElementVisibility, helper for filter behavior
//
//  Synopsis:   Sets the element's desired visibility to the given value,
//              and returns the value to use for the actual visibility.
//              A transition may override the element's visibility in order
//              to keep rendering  until the transition finishes.
//
//-------------------------------------------------------------------------

BOOL
CPeerHolder::SetFilteredElementVisibility(BOOL fElementVisible)
{
    Assert(IsFilterPeer());

    if (!!_pRenderBag->_fElementInvisible != !fElementVisible)
    {
        _pRenderBag->_fElementInvisible = !fElementVisible;

        TraceTag((tagFilterVisible, "%ls %d (%x) set eltVis=%d  Now eltVis=%d filVis=%d",
                    _pElement->TagName(), _pElement->SN(), _pElement,
                    fElementVisible,
                    !_pRenderBag->_fElementInvisible,
                    !_pRenderBag->_fFilterInvisible));
                    
        // tell filter - give it a chance to update _fElementInvisible
        IHTMLFilterPainter *pFilterPainter = NULL;
        if (OK(QueryPeerInterface(IID_IHTMLFilterPainter, (void**)&pFilterPainter)))
        {
            // we're changing on behalf of the element, so don't fire OnPropertyChange
            _pRenderBag->_fBlockPropertyNotify = TRUE;

            IGNORE_HR(pFilterPainter->ChangeElementVisibility(fElementVisible));

            _pRenderBag->_fBlockPropertyNotify = FALSE;
        }

        ReleaseInterface(pFilterPainter);
    }

    BOOL fElementVisibleNow = !_pRenderBag->_fFilterInvisible;

    // save a trace that filter have changed visibility
    _pRenderBag->_fVisibilityForced = fElementVisible != fElementVisibleNow;

    return fElementVisibleNow;
}


//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::IsRelated, helper
//
//-------------------------------------------------------------------------

BOOL
CPeerHolder::IsRelated(LPTSTR pchCategory)
{
    return _cstrCategory.IsNull() ?
        FALSE :
        NULL != StrStrI(_cstrCategory, pchCategory);
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::IsRelatedMulti, helper
//
//-------------------------------------------------------------------------

BOOL
CPeerHolder::IsRelatedMulti(LPTSTR pchCategory, CPeerHolder ** ppPeerHolder)
{
    CPeerHolder::CPeerHolderIterator    itr;

    for (itr.Start(this); !itr.IsEnd(); itr.Step())
    {
        if (itr.PH()->IsRelated(pchCategory))
        {
            if (ppPeerHolder)
            {
                *ppPeerHolder = itr.PH();
            }
            return TRUE;
        }
    }

    if (ppPeerHolder)
    {
        *ppPeerHolder = NULL;
    }

    return FALSE;
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::IsCorrectIdentityPeerHolder, DEBUG ONLY helper
//
//-------------------------------------------------------------------------

#if DBG == 1
BOOL
CPeerHolder::IsCorrectIdentityPeerHolder()
{
    int                                 c;
    CPeerHolder::CPeerHolderIterator    itr;

    c = 0;
    for (itr.Start(this); !itr.IsEnd(); itr.Step())
    {
        if (itr.PH()->IsIdentityPeer())
        {
            Assert (itr.PH() == this);

            c++;
        }
    }

    return c <= 1;
}
#endif

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::GetRenderPeerHolder
//
//-------------------------------------------------------------------------

CPeerHolder *
CPeerHolder::GetRenderPeerHolder()
{
    CPeerHolder::CPeerHolderIterator    itr;

    for (itr.Start(this); !itr.IsEnd(); itr.Step())
    {
        if (itr.PH()->IsRenderPeer())
            return itr.PH();
    }
    return NULL;
}

//+------------------------------------------------------------------------------------
//
//  Member:     CPeerHolder::GetElementToUseForPageTransitions
//                    This will return the element that the peer is attached.
//                    If in the middle of a page transition and the element is
//                  the root element it will return the canvas (body, frameset, html)
//                  element of the old or new markup, depending on the transition state
//-------------------------------------------------------------------------------------

CElement *
CPeerHolder::GetElementToUseForPageTransitions()
{
    CElement * pElemToUse;

    pElemToUse = _pElement;

    if(pElemToUse && pElemToUse->IsRoot())
    {
        CDocument * pDocument = pElemToUse->DocumentOrPendingDocument();

        // We need to delagate the rendering to the old or new markup, depending
         // on the page transition state
        if(pDocument && pDocument->HasPageTransitions())
        {
            CMarkup * pMarkupOld = pDocument->GetPageTransitionInfo()->GetTransitionFromMarkup();
            if(pMarkupOld)
                // pMarkupOld is only set during the Apply() call and forces
                // the rendering to happen with the old markup and html (body, frameset) element
                pElemToUse = pMarkupOld->GetCanvasElement();
            else
                // Use the new html (body, frameset) element (current markup should be the new one)
                pElemToUse = pElemToUse->GetMarkup()->GetCanvasElement();
            }
    }

   return pElemToUse;
}


//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::GetFilterPeerHolder
//
//-------------------------------------------------------------------------

CPeerHolder *
CPeerHolder::GetFilterPeerHolder()
{
    CPeerHolder::CPeerHolderIterator    itr;

    for (itr.Start(this); !itr.IsEnd(); itr.Step())
    {
        if (itr.PH()->IsFilterPeer())
            return itr.PH();
    }
    return NULL;
}


///////////////////////////////////////////////////////////////////////////
//
//  CPaintAdapter is a helper class to provide backwards compatibility for
//  existing behaviors that use IElementBehaviorRender.  When we see one of
//  these behaviors, we create an adapter and use it as the IHTMLPainter.
//  In turn, it forwards the work to IEBR.  There's a corresponding
//  translation between IHTMLPaintSite and IElementBehaviorSiteRender that's
//  handled by the peer site directly.
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPaintAdapter::Draw  per IHTMLPainter
//
//-------------------------------------------------------------------------

HRESULT
CPeerHolder::CPaintAdapter::Draw(RECT rcBounds,
                                RECT rcUpdate,
                                LONG lDrawFlags,
                                HDC hdc,
                                LPVOID pvDrawObject)
{
    HRESULT hr;

    LONG lRenderInfo = _lRenderInfo & BEHAVIORRENDERINFO_ALLLAYERS;

    // A few VML shapes need to draw at AFTERBACKGROUND (to set up scale) as
    // well as BEFORECONTENT.  We're only prepared to make one call to Draw, which
    // we'll do at below-flow time, but retaining the original lRenderInfo.  This
    // gets VML to draw both layers, although the AFTERBACKGROUND layer will come
    // after any child content with negative z-index.  The VML/PPT folks tell me
    // that Office doesn't generate any -z content, and OK'd this workaround.
    // (Otherwise, we'd have to figure out a mechanism to call the same peer twice,
    // and fill in some context to get the first call to specify AFTERBACKGROUND and
    // the second one BEFORECONTENT.  Possible, but not particularly pleasant.)

    //if (lRenderInfo == 6)               // VML bug
        //lRenderInfo = BEHAVIORRENDERINFO_BEFORECONTENT;

    // old-style behaviors can't handle non-zero based rcBounds
    POINT ptOrg;
    ::GetViewportOrgEx(hdc, &ptOrg);
    ptOrg.x += rcBounds.left;
    ptOrg.y += rcBounds.top;

    // don't bother to draw on Win9x if our coordinate values exceed
    // what SetViewportOrgEx can handle
    if ((g_dwPlatformID == VER_PLATFORM_WIN32_WINDOWS) &&
        (ptOrg.x < SHRT_MIN || ptOrg.x > SHRT_MAX ||
         ptOrg.y < SHRT_MIN || ptOrg.y > SHRT_MAX))
    {
        AssertSz(FALSE, "Behavior can't be drawn at large coordinate values");
        RRETURN(S_OK);
    }

    // pass zero-based bounds with offset contained in DC
    rcBounds.right -= rcBounds.left;
    rcBounds.bottom -= rcBounds.top;
    rcBounds.left = rcBounds.top = 0;
    ::SetViewportOrgEx(hdc, ptOrg.x, ptOrg.y, &ptOrg);

    hr = THR(_pPeerRender->Draw(hdc, lRenderInfo, &rcBounds, (IPropertyBag *)NULL));

    ::SetViewportOrgEx(hdc, ptOrg.x, ptOrg.y, NULL);

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPaintAdapter::GetPainterInfo  per IHTMLPainter
//
//-------------------------------------------------------------------------

HRESULT
CPeerHolder::CPaintAdapter::GetPainterInfo(HTML_PAINTER_INFO* pInfo)
{
    Assert(pInfo && _pPeerHolder && _pPeerHolder->_pRenderBag);

    HRESULT     hr;
    LONG lFlags = 0;

    hr = THR(_pPeerRender->GetRenderInfo(&_lRenderInfo));
    if (hr)
        goto Cleanup;

    lFlags |= HTMLPAINTER_TRANSPARENT;      // have to assume it's transparent

    if (_lRenderInfo & BEHAVIORRENDERINFO_HITTESTING)
        lFlags |= HTMLPAINTER_HITTEST;

    if (_lRenderInfo & BEHAVIORRENDERINFO_SURFACE)
        lFlags |= HTMLPAINTER_SURFACE;
    if (_lRenderInfo & BEHAVIORRENDERINFO_3DSURFACE)
        lFlags |= HTMLPAINTER_3DSURFACE;

    pInfo->lFlags = lFlags;

    pInfo->lZOrder = HTMLPAINT_ZORDER_NONE;     // assume the worst

    switch (_lRenderInfo & (BEHAVIORRENDERINFO_ALLLAYERS))
    {
    case 6:                                     // VML - they used an ancient IDL by mistake
    case BEHAVIORRENDERINFO_BEFORECONTENT:      // this is what VML meant to say
        pInfo->lZOrder = HTMLPAINT_ZORDER_BELOW_FLOW;
        break;

    case BEHAVIORRENDERINFO_AFTERCONTENT:       // HTML + TIME media behavior
        pInfo->lZOrder = HTMLPAINT_ZORDER_ABOVE_FLOW;
        break;

    case BEHAVIORRENDERINFO_AFTERBACKGROUND:    // Access grid dots
        pInfo->lZOrder = HTMLPAINT_ZORDER_BELOW_CONTENT;
        // fall through...

    case BEHAVIORRENDERINFO_BEFOREBACKGROUND:
        if ((_lRenderInfo & BEHAVIORRENDERINFO_DISABLEALLLAYERS) == BEHAVIORRENDERINFO_DISABLEBACKGROUND)
            pInfo->lZOrder = HTMLPAINT_ZORDER_REPLACE_BACKGROUND;
        break;

    case BEHAVIORRENDERINFO_AFTERFOREGROUND:
    case BEHAVIORRENDERINFO_ABOVECONTENT:
        pInfo->lZOrder = HTMLPAINT_ZORDER_ABOVE_CONTENT;

    case 0:
        if ((_lRenderInfo & BEHAVIORRENDERINFO_DISABLEALLLAYERS) == BEHAVIORRENDERINFO_DISABLEALLLAYERS)
            pInfo->lZOrder = HTMLPAINT_ZORDER_REPLACE_ALL;
        break;

    default:
        break;
    }

    if ((_lRenderInfo & BEHAVIORRENDERINFO_DISABLEALLLAYERS) ==
                            (BEHAVIORRENDERINFO_DISABLENEGATIVEZ |
                             BEHAVIORRENDERINFO_DISABLECONTENT   |
                             BEHAVIORRENDERINFO_DISABLEPOSITIVEZ)   &&
        pInfo->lZOrder != HTMLPAINT_ZORDER_NONE)   // i.e. the enabled layers are something we recognized already
    {
        pInfo->lZOrder = HTMLPAINT_ZORDER_REPLACE_CONTENT;
    }

    AssertSz((pInfo->lZOrder != HTMLPAINT_ZORDER_NONE) || (0 == (_lRenderInfo & BEHAVIORRENDERINFO_ALLLAYERS)),
            "5.0-style rendering behavior has layer flags that don't map to 5.5-style");

    pInfo->iidDrawObject = g_Zero.iid;

    pInfo->rcExpand = g_Zero.rc;

Cleanup:
    RRETURN(S_OK);
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPaintAdapter::HitTestPoint  per IHTMLPainter
//
//-------------------------------------------------------------------------

HRESULT
CPeerHolder::CPaintAdapter::HitTestPoint(POINT pt, BOOL* pfHit, LONG *plPartID)
{
    Assert(_pPeerHolder && _pPeerHolder->_pRenderBag);
    HRESULT     hr;

    Assert (0 != (BEHAVIORRENDERINFO_HITTESTING & _lRenderInfo));

    *pfHit = FALSE;
    *plPartID = 0;

    hr = THR(_pPeerRender->HitTestPoint(&pt, NULL, pfHit));

    RRETURN (hr);
}


void
CPeerHolder::CPeerHolderIterator::Start(CPeerHolder * pPH)
{
    CPeerHolder * pPHWalk = pPH;
    HRESULT hr = S_OK;

    Reset();

    while( pPHWalk )
    {
        hr = THR( _aryPeerHolders.Append(pPHWalk) );
        if( hr )
            goto Cleanup;

        pPHWalk->SubAddRef();
        pPHWalk = pPHWalk->_pPeerHolderNext;
    }

Cleanup:
    // Need to set up _nCurr before possibly resetting.
    _nCurr = _aryPeerHolders.Size() ? 0 : -1;
    if( hr )
    {
        Reset();
    }
}


void
CPeerHolder::CPeerHolderIterator::Step()
{
    Assert (!IsEnd());
    
    // SubRelease the current guy, now that we're done with him.
    _aryPeerHolders[_nCurr++]->SubRelease();

    // Make sure that we don't hand out someone who's been detached
    while( _nCurr < _aryPeerHolders.Size() && !_aryPeerHolders[_nCurr]->_pElement )
    {
        _aryPeerHolders[_nCurr++]->SubRelease();
    }

    // If there was nothing left, we're done.
    if( _nCurr >= _aryPeerHolders.Size() )
        _nCurr = -1;
}


void
CPeerHolder::CPeerHolderIterator::Reset()
{
    if( _nCurr != -1 )
    {
        Assert( _aryPeerHolders.Size() > 0 );
        // Release everyone we haven't hit yet.
        while( _nCurr < _aryPeerHolders.Size() )
        {
            _aryPeerHolders[_nCurr++]->SubRelease();
        }
        _nCurr = -1;
    }

    _aryPeerHolders.DeleteAll();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\peerfact.cxx ===
//------------------------------------------------------------------------
//
//  File:       peerfact.cxx
//
//  Contents:   peer factories
//
//  Classes:    CPeerFactoryUrl, etc.
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_SCRPTLET_H_
#define X_SCRPTLET_H_
#include "scrptlet.h"
#endif

#ifndef X_PEER_HXX_
#define X_PEER_HXX_
#include "peer.hxx"
#endif

#ifndef X_PEERFACT_HXX_
#define X_PEERFACT_HXX_
#include "peerfact.hxx"
#endif

#ifndef X_GENERIC_HXX_
#define X_GENERIC_HXX_
#include "generic.hxx"
#endif

#ifndef X_OLESITE_HXX_
#define X_OLESITE_HXX_
#include "olesite.hxx"
#endif

#ifndef X_HTC_HXX_
#define X_HTC_HXX_
#include "htc.hxx"
#endif

#ifndef X_PRGSNK_H_
#define X_PRGSNK_H_
#include <prgsnk.h>
#endif

#ifndef X_PEERXTAG_HXX_
#define X_PEERXTAG_HXX_
#include "peerxtag.hxx"
#endif

///////////////////////////////////////////////////////////////////////////
//
// (doc) implementation details that are not obvious
//
///////////////////////////////////////////////////////////////////////////

/*

Typical cases how CPeerFactoryUrls may be created.

  1.    <span style = "behavior:url(http://url)" >

        When css is applied to the span, CDoc::AttachPeerCss does not find matching 
        CPeerFactoryUrl in the list, and creates CPeerFactoryUrl for the url

  2.    <span style = "behavior:url(#default#foo)" >

        When css is applied to the span, CDoc::AttachPeerCss does not find matching 
        "#default" or "#default#foo" in the list, and creates CPeerFactoryUrl "#default"; then
        it immediately clones it into "#default#foo" and inserts it before "#default".

  3.    <object id = bar ... >...</object>

        <span id = span1 style = "behavior:url(#bar#foo)" >
        <span id = span2 style = "behavior:url(#bar#zoo)" >

        When css is applied to the span1, CDoc::AttachPeerCss does not find matching 
        "#bar#foo" or "#bar" in the list, and creates CPeerFactoryUrl "#bar"; then 
        it immediately clones it into "#bar#foo" and inserts it before "#bar".

        When css is applied to the span2, CDoc::AttachPeerCss finds matching "#bar" and
        clones it into "#bar#zoo".

  4.    (olesite #bar is missing)
        <span id = span1 style = "behavior:url(#bar#foo)" >
        <span id = span2 style = "behavior:url(#bar#foo)" >

        When css is applied to span1, we can't find matching "#bar" or "#bar#foo". We then
        search the whole page trying to find olesite "#bar", and we fail. We then create CPeerFactoryUrl "#bar"
        with DOWNLOANLOADSTATE_DONE and TYPE_NULL. The factory will be failing creating any behaviors:
        it's whole purpose is to avoid any additional searches of the page for olesite "#bar". CPeerFactoryUrl
        "#bar" is then immediately cloned into CPeerFactoryUrl "#bar#foo", that is also going to be failing
        creating behaviors.

        When css is applied to span2, we find CPeerFactoryUrl "#bar#foo", and reuse it.


*/

///////////////////////////////////////////////////////////////////////////
//
// misc
//
///////////////////////////////////////////////////////////////////////////

MtDefine(CPeerFactoryUrl,           CDoc,   "CPeerFactoryUrl")
MtDefine(CPeerFactoryBinaryOnstack,   CDoc,   "CPeerFactoryBinaryOnstack")
MtDefine(CPeerFactoryDefault,       CDoc,   "CPeerFactoryDefault")

MtDefine(CPeerFactoryUrl_aryDeferred,   CPeerFactoryUrl, "CPeerFactoryUrl::_aryDeferred")
MtDefine(CPeerFactoryUrl_aryETN,        CPeerFactoryUrl, "CPeerFactoryUrl::_aryETN")

// SubobjectThunk
HRESULT (STDMETHODCALLTYPE  CVoid::*const CPeerFactoryUrl::s_apfnSubobjectThunk[])(void) =
{
#ifdef UNIX //IEUNIX: This first item is null on Unix Thunk format
    TEAROFF_METHOD_NULL
#endif
    TEAROFF_METHOD(CPeerFactoryUrl,  SubobjectThunkQueryInterface, subobjectthunkqueryinterface, (REFIID, void **))
    TEAROFF_METHOD_(CPeerFactoryUrl, SubobjectThunkAddRef,         subobjectthunkaddref,         ULONG, ())
    TEAROFF_METHOD_(CPeerFactoryUrl, SubobjectThunkSubRelease,     subobjectthunkrelease,        ULONG, ())
};
HRESULT CreateNamespaceHelper( IUnknown * pBehFactory, IElementNamespace * pNamespace, TCHAR * pchImplementation, BOOL fNeedSysAlloc );

///////////////////////////////////////////////////////////////////////////
//
// misc helpers
//
///////////////////////////////////////////////////////////////////////////

LPTSTR
GetPeerNameFromUrl (LPTSTR pch)
{
    if (!pch || !pch[0])
        return NULL;

    if (_T('#') == pch[0])
        pch++;

    pch= StrChr(pch, _T('#'));
    if (pch)
    {
        pch++;
    }

    return pch;
}

//+-------------------------------------------------------------------
//
//  Helper:     FindOleSite
//
//--------------------------------------------------------------------

HRESULT
FindOleSite(LPTSTR pchName, CMarkup * pMarkup, COleSite ** ppOleSite)
{
    HRESULT                 hr;
    CElementAryCacheItem    cacheItem;
    CBase *                 pBase;
    int                     i, c;

    Assert (ppOleSite);

    *ppOleSite = NULL;

    // There is a chance that the markup pointer is NULL. In that case just
    // return an error.
    if (!pMarkup)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = THR(pMarkup->EnsureCollectionCache(CMarkup::ELEMENT_COLLECTION));
    if (hr)
        goto Cleanup;

    hr = THR_NOTRACE(pMarkup->CollectionCache()->BuildNamedArray(
        CMarkup::ELEMENT_COLLECTION,
        pchName,
        FALSE,              // fTagName
        &cacheItem,
        0,                  // iStartFrom
        FALSE));            // fCaseSensitive
    if (hr)
        goto Cleanup;

    hr = E_FAIL;
    for (i = 0, c = cacheItem.Length(); i < c; i++)
    {
        pBase = (CBase*)(cacheItem.GetAt(i));
        if (pBase->BaseDesc()->_dwFlags & CElement::ELEMENTDESC_OLESITE)
        {
            hr = S_OK;
            *ppOleSite = DYNCAST(COleSite, pBase);
            break;
        }
    }

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Helper:     QuerySafePeerFactory
//
//-------------------------------------------------------------------------

HRESULT
QuerySafePeerFactory(COleSite * pOleSite, IElementBehaviorFactory ** ppPeerFactory)
{
    HRESULT                     hr;

    Assert (ppPeerFactory);

    hr = THR_NOTRACE (pOleSite->QueryControlInterface(IID_IElementBehaviorFactory, (void**)ppPeerFactory));
    if (S_OK == hr && (*ppPeerFactory))
    {
        if (!pOleSite->IsSafeToScript() ||                             // do not allow unsafe activex controls
            !pOleSite->IsSafeToInitialize(IID_IPersistPropertyBag2))   // to workaround safety settings by
        {                                                              // exposing scriptable or loadable peers
            ClearInterface(ppPeerFactory);
            hr = E_ACCESSDENIED;
        }
    }

    RRETURN (hr);
}

//+-------------------------------------------------------------------
//
//  Helper:     IsDefaultUrl
//
//--------------------------------------------------------------------

BOOL
IsDefaultUrl(LPTSTR pchUrl, LPTSTR * ppchName = NULL)
{
    BOOL    fDefault = (0 == StrCmpNIC(_T("#default"), pchUrl, 8) &&
                        (0 == pchUrl[8] || _T('#') == pchUrl[8]));

    if (fDefault && ppchName)
    {
        *ppchName = pchUrl + 8;         // advance past "#default"

        if (_T('#') == (*ppchName)[0])
        {
            (*ppchName)++;              // advance past second "#"
        }
        else
        {
            Assert (0 == (*ppchName)[0]);
            (*ppchName) = NULL;
        }
    }

    return fDefault;
}

//+-------------------------------------------------------------------
//
//  Helper:     FindPeer
//
//--------------------------------------------------------------------

HRESULT
FindPeer(
    IElementBehaviorFactory *   pFactory,
    const TCHAR *               pchName,
    const TCHAR *               pchUrl,
    IElementBehaviorSite *      pSite,
    IElementBehavior**          ppPeer)
{
    HRESULT     hr;
    BSTR        bstrName = NULL;
    BSTR        bstrUrl  = NULL;

    hr = THR(FormsAllocString(pchName, &bstrName));
    if (hr)
        goto Cleanup;

    hr = THR(FormsAllocString(pchUrl, &bstrUrl));
    if (hr)
        goto Cleanup;

    hr = THR(pFactory->FindBehavior(bstrName, bstrUrl, pSite, ppPeer));

Cleanup:
    FormsFreeString(bstrName);
    FormsFreeString(bstrUrl);

    RRETURN (hr);
}

///////////////////////////////////////////////////////////////////////////
//
// CPeerFactory
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Member:     CPeerFactory::AttachPeer
//
//-------------------------------------------------------------------------

HRESULT
CPeerFactory::AttachPeer (CPeerHolder * pPeerHolder)
{
    HRESULT     hr;

    hr = THR_NOTRACE(pPeerHolder->Create(this));

    RRETURN (hr);
};

//+------------------------------------------------------------------------
//
//  Member:     CPeerFactory::GetElementNamespaceFactory
//
//-------------------------------------------------------------------------

HRESULT 
CPeerFactory::GetElementNamespaceFactoryCallback( IElementNamespaceFactoryCallback ** ppNSFactory )
{
    if (!ppNSFactory)
        return E_POINTER;

    *ppNSFactory = NULL;

    return E_NOINTERFACE;
};

///////////////////////////////////////////////////////////////////////////
//
// CPeerFactoryUrl
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Member:     CPeerFactoryUrl::CPeerFactoryUrl
//
//  Synopsis:   constructor
//
//-------------------------------------------------------------------------

CPeerFactoryUrl::CPeerFactoryUrl(CMarkup * pHostMarkup)
{
    _pHostMarkup = pHostMarkup;
    _pHostMarkup->SubAddRef();
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerFactoryUrl::~CPeerFactoryUrl
//
//  Synopsis:   destructor
//
//-------------------------------------------------------------------------

CPeerFactoryUrl::~CPeerFactoryUrl()
{
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerFactoryUrl::Passivate
//
//-------------------------------------------------------------------------

void
CPeerFactoryUrl::Passivate()
{
    StopBinding();

    ClearInterface (&_pFactory);
    ClearInterface (&_pMoniker);

    if (_pOleSite)
    {
        _pOleSite->PrivateRelease();
        _pOleSite = NULL;
    }

    _aryDeferred.ReleaseAll();

    _pHostMarkup->SubRelease();
    _pHostMarkup = NULL;

    super::Passivate();
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerFactoryUrl::QueryInterface
//
//-------------------------------------------------------------------------

STDMETHODIMP
CPeerFactoryUrl::QueryInterface(REFIID iid, LPVOID * ppv)
{
    *ppv = NULL;

    switch (iid.Data1)
    {
    QI_INHERITS2(this, IUnknown, IWindowForBindingUI)
    QI_INHERITS(this, IWindowForBindingUI)
    }

    if (*ppv)
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }
    else
    {
        RRETURN (super::QueryInterface(iid, ppv));
    }
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerFactoryUrl::QueryService, per IServiceProvider
//
//-------------------------------------------------------------------------

STDMETHODIMP
CPeerFactoryUrl::QueryService(REFGUID rguidService, REFIID riid, void ** ppvService)
{
    HRESULT     hr = E_NOINTERFACE;

    if (IsEqualGUID(rguidService, IID_IMoniker) && _pMoniker)
    {
        hr = THR(_pMoniker->QueryInterface(riid, ppvService));
    }
    else if (IsEqualGUID(rguidService, CLSID_HTMLDocument))
    {
        (*ppvService) = Doc();
        hr = S_OK;
    }
    else
    {
        hr = THR_NOTRACE(super::QueryService(rguidService, riid, ppvService));
    }

    RRETURN(hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CPeerFactoryUrl::Create
//
//--------------------------------------------------------------------

HRESULT
CPeerFactoryUrl::Create(LPTSTR pchUrl, CMarkup * pHostMarkup, CMarkup * pMarkup, CPeerFactoryUrl ** ppFactory)
{
    HRESULT             hr;

    Assert (pchUrl && ppFactory);

    (*ppFactory) = new CPeerFactoryUrl(pHostMarkup);
    if (!(*ppFactory))
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    if (_T('#') != pchUrl[0] || IsDefaultUrl(pchUrl))       
    {
        //
        // if "http://", "file://", etc., or "#default" or "#default#foo"
        //

        hr = THR((*ppFactory)->Init(pchUrl));           // this will launch download if necessary
        if (hr)
            goto Cleanup;
    }
    else
    {
        //
        // if local page reference
        //

        // assert that it is "#foo" but not "#foo#bar"
        Assert (_T('#') == pchUrl[0] && NULL == StrChr(pchUrl + 1, _T('#')));

        COleSite *          pOleSite;

        hr = THR(FindOleSite(pchUrl + 1, pMarkup, &pOleSite));
        if (hr)
            goto Cleanup;

        hr = THR((*ppFactory)->Init(pchUrl, pOleSite));
        if (hr)
            goto Cleanup;
    }

Cleanup:
    if (hr)
    {   // we get here when #foo is not found on the page
        (*ppFactory)->Release();
        (*ppFactory) = NULL;
    }

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerFactoryUrl::Init
//
//-------------------------------------------------------------------------

HRESULT
CPeerFactoryUrl::Init(LPTSTR pchUrl)
{
    HRESULT     hr;
    LPTSTR      pchName;

    Assert (pchUrl);

    hr = THR(_cstrUrl.Set(pchUrl));
    if (hr)
        goto Cleanup;

    if (IsHostOverrideBehaviorFactory())
    {
        _type = TYPE_NULL;
        _downloadStatus = DOWNLOADSTATUS_DONE;
        goto Cleanup; // done
    }

    if (_T('#') != pchUrl[0])
    {
        _type = TYPE_CLASSFACTORY;
        _downloadStatus = DOWNLOADSTATUS_INPROGRESS;

        hr = THR(LaunchUrlDownload(_cstrUrl));
    }
    else
    {
        if (IsDefaultUrl(pchUrl, &pchName))
        {
            TCHAR   achUrlDownload[pdlUrlLen];

            hr = THR(Doc()->FindDefaultBehaviorFactory(
                pchName,
                pchUrl,
                (IElementBehaviorFactory**)&_pFactory,
                achUrlDownload, ARRAY_SIZE(achUrlDownload)));
            if (hr)
                goto Cleanup;

            if (_pFactory)
            {
                _type = TYPE_PEERFACTORY;
                _downloadStatus = DOWNLOADSTATUS_DONE;
            }
            else
            {
                _type = TYPE_CLASSFACTORY;
                _downloadStatus = DOWNLOADSTATUS_INPROGRESS;

                hr = THR(LaunchUrlDownload(achUrlDownload));
            }
        }
        else
        {
            _type = TYPE_NULL;
            _downloadStatus = DOWNLOADSTATUS_DONE;
        }
    }

Cleanup:

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerFactoryUrl::Init
//
//-------------------------------------------------------------------------

HRESULT
CPeerFactoryUrl::Init(LPTSTR pchUrl, COleSite * pOleSite)
{
    HRESULT     hr;

    Assert (pchUrl && _T('#') == pchUrl[0]);

    hr = THR(_cstrUrl.Set(pchUrl));
    if (hr)
        goto Cleanup;

    _type = TYPE_PEERFACTORY;
    _downloadStatus = DOWNLOADSTATUS_DONE;

    // NOTE that it is valid for pOleSite to be null. In this case this CPeerFactoryUrl only serves as a bit
    // of cached information to avoid search for the olesite again

    _pOleSite = pOleSite;

    if (!_pOleSite)
        goto Cleanup;

    _pOleSite->AddRef();                         // balanced in passivate
    _pOleSite->_fElementBehaviorFactory = TRUE;  // without this we can't print EB's

    if (READYSTATE_LOADED <= _pOleSite->_lReadyState)
    {
        hr = THR(OnOleObjectAvailable());
    }
    else
    {
        hr = THR(_oleReadyStateSink.SinkReadyState()); // causes OnStartBinding, OnOleObjectAvailable, OnStopBinding
    }

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerFactoryUrl::Clone
//
//-------------------------------------------------------------------------

HRESULT
CPeerFactoryUrl::Clone(LPTSTR pchUrl, CPeerFactoryUrl ** ppFactory)
{
    HRESULT     hr;

    Assert (
        pchUrl && _T('#') == pchUrl[0] &&
        TYPE_PEERFACTORY == _type &&
        0 == StrCmpNIC(_cstrUrl, pchUrl, _cstrUrl.Length()));

    *ppFactory = new CPeerFactoryUrl(_pHostMarkup);
    if (!(*ppFactory))
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    if (_pOleSite)
    {
        hr = THR((*ppFactory)->Init(pchUrl, _pOleSite));
        if (hr)
            goto Cleanup;
    }
    else
    {
        hr = THR((*ppFactory)->Init(pchUrl));
        if (hr)
            goto Cleanup;
    }

Cleanup:
    if( hr && *ppFactory )
    {
        (*ppFactory)->Release();
        *ppFactory = NULL;
    }
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerFactoryUrl::LaunchUrlDownload
//
//-------------------------------------------------------------------------

HRESULT
CPeerFactoryUrl::LaunchUrlDownload(LPTSTR pchUrl)
{
    HRESULT                 hr;
    IMoniker *              pMk = NULL;
    IUnknown *              pUnk = NULL;
    IBindCtx *              pBindCtx = NULL;
    IBindStatusCallback *   pBSC = NULL;

    hr = THR(SubobjectThunkQueryInterface(IID_IBindStatusCallback, (void**)&pBSC));
    if (hr)
        goto Cleanup;

    hr = THR(CreateAsyncBindCtx(0, pBSC, NULL, &pBindCtx));
    if (hr)
        goto Cleanup;

    hr = THR(CreateURLMoniker(NULL, pchUrl, &pMk));
    if (hr)
        goto Cleanup;

    _pMoniker = pMk;        // this has to be done before BindToObject, so that if OnObjectAvailable
    _pMoniker->AddRef();    // happens synchronously _pMoniker is available

    hr = THR(pMk->BindToObject(pBindCtx, NULL, IID_IUnknown, (void**)&pUnk));
    if (S_ASYNCHRONOUS == hr)
    {
        hr = S_OK;
    }
    else if (S_OK == hr && pUnk)
    {
        pUnk->Release();
    }

Cleanup:

    ReleaseInterface (pMk);
    ReleaseInterface (pBindCtx);
    ReleaseInterface (pBSC);

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerFactoryUrl::AttachPeer, virtual
//
//-------------------------------------------------------------------------

HRESULT
CPeerFactoryUrl::AttachPeer (CPeerHolder * pPeerHolder)
{
    HRESULT     hr;

    hr = THR(AttachPeer(pPeerHolder, /* fAfterDownload = */FALSE));

    RRETURN (hr);
};

//+------------------------------------------------------------------------
//
//  Member:     CPeerFactoryUrl::AttachPeer
//
//  Synopsis:   either creates and attaches peer, or defers  it until download
//              complete
//
//-------------------------------------------------------------------------

HRESULT
CPeerFactoryUrl::AttachPeer (CPeerHolder * pPeerHolder, BOOL fAfterDownload)
{
    HRESULT     hr = S_OK;

    // this should be set up before creation of peer, and before even download is completed, so that we
    // don't attach same behavior twice
    pPeerHolder->_pPeerFactoryUrl = this;    

    switch (_downloadStatus)
    {
    case DOWNLOADSTATUS_NOTSTARTED:
        Assert (0 && "AttachPeer called on CPeerFactoryUrl before Init");
        break;

    case DOWNLOADSTATUS_INPROGRESS:

        //
        // download in progress - defer attaching peer until download completed
        //

        pPeerHolder->_pElement->IncPeerDownloads();
        pPeerHolder->PrivateAddRef();   // so it won't go away before we attach peer to it
                                        // balanced in DOWNLOADSTATUS_DONE when fAfterDownload set

        hr = THR(_aryDeferred.Append (pPeerHolder));
        if (hr)
            goto Cleanup;

        break;

    case DOWNLOADSTATUS_DONE:

        //
        // download ready - attach right now
        //

        if (TYPE_NULL != _type)
        {
            Assert (!pPeerHolder->_pPeer);

            IGNORE_HR(pPeerHolder->Create(this));
        }

        if (fAfterDownload)
        {
            if( !pPeerHolder->_pElement->IsPassivated() )
            {
                pPeerHolder->_pElement->DecPeerDownloads();
            }
            pPeerHolder->PrivateRelease();
        }

        break;
    }

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerFactoryUrl::AttachAllDeferred
//
//  Synopsis:   attaches the peer to all elements put on hold before
//
//-------------------------------------------------------------------------

HRESULT
CPeerFactoryUrl::AttachAllDeferred()
{
    int             c;
    CPeerHolder **  ppPeerHolder;

    Assert (DOWNLOADSTATUS_DONE == _downloadStatus);

    for (c = _aryDeferred.Size(), ppPeerHolder = _aryDeferred; 
         c; 
         c--, ppPeerHolder++)
    {
        IGNORE_HR (AttachPeer(*ppPeerHolder, /* fAfterDownload = */ TRUE));
    }

    _aryDeferred.DeleteAll();

    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerFactoryUrl::FindBehavior, per IElementBehaviorFactory
//
//-------------------------------------------------------------------------

HRESULT
CPeerFactoryUrl::FindBehavior(
    CPeerHolder *           pPeerHolder,
    IElementBehaviorSite *  pSite,
    IElementBehavior **     ppPeer)
{
    HRESULT         hr = E_FAIL;
    const TCHAR *   pchPeerName = GetPeerNameFromUrl(_cstrUrl);

    if( !pchPeerName && pPeerHolder->IsIdentityPeer() )
    {
        pchPeerName = pPeerHolder->_pElement->TagName();
    }

    if (IsHostOverrideBehaviorFactory())
    {
        hr = THR_NOTRACE(Doc()->FindHostBehavior(pchPeerName, _cstrUrl, pSite, ppPeer));
        goto Cleanup;   // done
    }
    
    switch (_type)
    {
    case TYPE_CLASSFACTORYEX:
        if (_pFactory)
        {
            hr = THR(((IClassFactoryEx*)_pFactory)->CreateInstanceWithContext(
                pSite, NULL, IID_IElementBehavior, (void **)ppPeer));
        }
        break;

    case TYPE_CLASSFACTORY:
        if (_pFactory)
        {
            hr = THR(((IClassFactory*)_pFactory)->CreateInstance(NULL, IID_IElementBehavior, (void **)ppPeer));
        }
        break;

    case TYPE_PEERFACTORY:
        if (_pFactory)
        {
            hr = THR(FindPeer((IElementBehaviorFactory *)_pFactory, pchPeerName, _cstrUrl, pSite, ppPeer));
        }
        break;

    default:
        Assert (0 && "wrong _type");
        break;
    }

Cleanup:
    RRETURN (hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CPeerFactoryUrl::SubobjectThunkQueryInterface
//
//-------------------------------------------------------------------------

STDMETHODIMP
CPeerFactoryUrl::SubobjectThunkQueryInterface(REFIID riid, LPVOID * ppv)
{
    HRESULT     hr;
    IUnknown *  punk;

    hr = THR_NOTRACE(QueryInterface(riid, (void**)&punk));
    if (S_OK == hr)
    {
        hr = THR(CreateTearOffThunk(
                punk,
                *(void **)punk,
                NULL,
                ppv,
                this,
                (void **)s_apfnSubobjectThunk,
                QI_MASK | ADDREF_MASK | RELEASE_MASK,
                NULL));

        punk->Release();

        if (S_OK == hr)
        {
            ((IUnknown*)*ppv)->AddRef();
        }
    }

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerFactoryUrl::GetBindInfo, per IBindStatusCallback
//
//-------------------------------------------------------------------------

HRESULT
CPeerFactoryUrl::GetBindInfo(DWORD * pdwBindf, BINDINFO * pbindinfo)
{
    HRESULT hr;

    hr = THR(super::GetBindInfo(pdwBindf, pbindinfo));

    if (S_OK == hr)
    {
        *pdwBindf |= BINDF_GETCLASSOBJECT;
    }

    // If we're doing a synchronous load, we can't bind asynchronously.  Duh.
    if( _pHostMarkup->Doc()->_fSyncParsing )
    {
        *pdwBindf &= ~BINDF_ASYNCHRONOUS;
    }

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerFactoryUrl::OnStartBinding, helper
//
//-------------------------------------------------------------------------

HRESULT
CPeerFactoryUrl::OnStartBinding()
{
    IProgSink * pProgSink = CMarkup::GetProgSinkHelper(_pHostMarkup);

    _downloadStatus = DOWNLOADSTATUS_INPROGRESS;

    if (pProgSink)
    {
        IGNORE_HR(pProgSink->AddProgress (PROGSINK_CLASS_CONTROL, &_dwBindingProgCookie));
        Assert (_dwBindingProgCookie);
    }

    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerFactoryUrl::OnStopBinding, helper
//
//-------------------------------------------------------------------------

HRESULT
CPeerFactoryUrl::OnStopBinding()
{
    _downloadStatus = DOWNLOADSTATUS_DONE;

    // note that even if _pFactory is NULL, we still want to do AttachAllDeferred so to balance Inc/DecPeersPending
    IGNORE_HR(AttachAllDeferred());

    IGNORE_HR(SyncETN());

    if (_dwBindingProgCookie)
    {
        CMarkup::GetProgSinkHelper(_pHostMarkup)->DelProgress (_dwBindingProgCookie);
    }

    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerFactoryUrl::OnStartBinding, per IBindStatusCallback
//
//-------------------------------------------------------------------------

HRESULT
CPeerFactoryUrl::OnStartBinding(DWORD grfBSCOption, IBinding * pBinding)
{
    IGNORE_HR(super::OnStartBinding(grfBSCOption, pBinding));

    IGNORE_HR(OnStartBinding());
    
    _pBinding = pBinding;
    _pBinding->AddRef();

    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerFactoryUrl::OnStopBinding, per IBindStatusCallback
//
//-------------------------------------------------------------------------

HRESULT
CPeerFactoryUrl::OnStopBinding(HRESULT hrErr, LPCWSTR szErr)
{
    IGNORE_HR(super::OnStopBinding(hrErr, szErr));

    ClearInterface(&_pBinding);

    IGNORE_HR(OnStopBinding());

    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerFactoryUrl::OnProgress, per IBindStatusCallback
//
//-------------------------------------------------------------------------

HRESULT
CPeerFactoryUrl::OnProgress(ULONG ulPos, ULONG ulMax, ULONG ulCode, LPCWSTR pszText)
{
    IGNORE_HR(super::OnProgress(ulPos, ulMax, ulCode, pszText));

    if (    (ulCode == BINDSTATUS_REDIRECTING)
        &&  !_pHostMarkup->AccessAllowed(pszText))
    {
        if (_pBinding)
            _pBinding->Abort();
    }

    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerFactoryUrl::PersistMonikerLoad, helper
//
//-------------------------------------------------------------------------

HRESULT
CPeerFactoryUrl::PersistMonikerLoad(IUnknown * pUnk, BOOL fLoadOnce)
{
    HRESULT             hr = S_OK;
    HRESULT             hr2;
    IPersistMoniker *   pPersistMoniker;

    if (!_pMoniker || !pUnk)
        goto Cleanup;

    hr2 = THR(pUnk->QueryInterface(IID_IPersistMoniker, (void**)&pPersistMoniker));
    if (S_OK == hr2)
    {
        IGNORE_HR(pPersistMoniker->Load(FALSE, _pMoniker, NULL, NULL));

        if (fLoadOnce)
        {
            ClearInterface(&_pMoniker);
        }

        ReleaseInterface (pPersistMoniker);
    }

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerFactoryUrl::OnObjectAvailable, per IBindStatusCallback
//
//-------------------------------------------------------------------------

HRESULT
CPeerFactoryUrl::OnObjectAvailable(REFIID riid, IUnknown * pUnk)
{
    HRESULT     hr = S_OK;
    HRESULT     hr2;
    IUnknown*   pUnk2;

    //
    // super
    //

    IGNORE_HR(super::OnObjectAvailable(riid, pUnk));

    if (!pUnk)
        goto Cleanup; // done

    pUnk->AddRef();

    //
    // do something weirdly special for HTCs: one level of indirection.
    // this is only necessary to have mshtmpad pick local mshtml.dll for HTCs -
    // as dictated by mechanics of wiring between mshtmpad.exe doing CoRegisterClassObject
    // and mshtml.dll DllEnumClassObjects and DllGetClassObject
    //

    {
        void *          pv;
        CClassFactory * pCF;

        hr2 = THR_NOTRACE(pUnk->QueryInterface(CLSID_CHtmlComponentConstructorFactory, &pv));
        if (S_OK == hr2)    // if recognized HTC constructor factory
        {
            hr = THR(pUnk->QueryInterface(IID_IClassFactory, (void**)&pCF));
            if (hr)
                goto Cleanup;

            pUnk->Release();
                
            // the indirection: get HTC constructor from the factory
            hr = THR(pCF->CreateInstance(NULL, IID_IUnknown, (void**) &pUnk));

            ReleaseInterface(pCF);

            if (hr)
                goto Cleanup;

            Assert (pUnk);
        }
    }

    //
    // extract factory from the IUnknown
    //

    hr2 = THR_NOTRACE(pUnk->QueryInterface(IID_IElementBehaviorFactory, (void**)&pUnk2));
    if (S_OK == hr2 && pUnk2)
    {
        _type = TYPE_PEERFACTORY;
        _pFactory = pUnk2;
    }
    else
    {
        hr2 = THR_NOTRACE(pUnk->QueryInterface(IID_IClassFactoryEx, (void**)&pUnk2));
        if (S_OK == hr2 && pUnk2)
        {
            _type = TYPE_CLASSFACTORYEX;
            _pFactory = pUnk2;
        }
        else
        {
            hr2 = THR_NOTRACE(pUnk->QueryInterface(IID_IClassFactory, (void**)&pUnk2));
            if (S_OK == hr2 && pUnk2)
            {
                Assert (TYPE_CLASSFACTORY == _type);
                _pFactory = pUnk2;
            }
        }
    }

    //
    // finalize
    //

    IGNORE_HR(PersistMonikerLoad(_pFactory, /* fLoadOnce = */TRUE));

Cleanup:
    ReleaseInterface(pUnk);

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerFactoryUrl::OnOleObjectAvailable, helper
//
//-------------------------------------------------------------------------

HRESULT
CPeerFactoryUrl::OnOleObjectAvailable()
{
    HRESULT     hr;

    hr = THR(QuerySafePeerFactory(_pOleSite, (IElementBehaviorFactory**)&_pFactory));
    if (hr)
    {
        hr = S_OK;
        _type = TYPE_NULL;
    }

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerFactoryUrl::StopBinding, helper
//
//-------------------------------------------------------------------------

void
CPeerFactoryUrl::StopBinding()
{
    if (_pBinding)
        _pBinding->Abort();
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerFactoryUrl::GetWindow, per IWindowForBindingUI
//
//----------------------------------------------------------------------------

STDMETHODIMP
CPeerFactoryUrl::GetWindow(REFGUID rguidReason, HWND *phwnd)
{
    HRESULT hr;

    hr = THR(Doc()->GetWindow(phwnd));

    RRETURN1(hr, S_FALSE);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerFactoryUrl::SyncETNHelper
//
//----------------------------------------------------------------------------

HRESULT
CPeerFactoryUrl::SyncETNHelper(CExtendedTagNamespace * pNamespace)
{
    HRESULT                         hr = S_OK;
    HRESULT                         hr2;
    IConnectionPointContainer *     pCPC = NULL;
    IConnectionPoint *              pCP = NULL;
    DWORD                           dwCookie;

    if( !_pFactory )
        goto Cleanup;

    {
        CExtendedTagNamespace::CExternalUpdateLock  updateLock(pNamespace, this);

        hr = THR_NOTRACE( CreateNamespaceHelper( _pFactory, pNamespace, pNamespace->_cstrFactoryUrl, /* fNeedSysAlloc = */ TRUE ) );
    }

    switch (hr)
    {
    case S_OK:
        break;

    case E_PENDING:

        //
        // the factory is not ready yet; sink it's readyState
        //

        hr2 = THR_NOTRACE(_pFactory->QueryInterface(IID_IConnectionPointContainer, (void**)&pCPC));
        if (hr2)
            goto Cleanup;

        hr2 = THR_NOTRACE(pCPC->FindConnectionPoint(IID_IPropertyNotifySink, &pCP));
        if (hr2)
            goto Cleanup;

        IGNORE_HR(pCP->Advise(&_ETNReadyStateSink, &dwCookie));

        Assert (E_PENDING == hr);
        goto Cleanup; // done; we will get called by the sink again when readyState COMPLETE is reached

    default:
        goto Cleanup;
    }

Cleanup:
    ReleaseInterface(pCPC);
    ReleaseInterface(pCP);

    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerFactoryUrl::SyncETN
//
//----------------------------------------------------------------------------

HRESULT
CPeerFactoryUrl::SyncETN(CExtendedTagNamespace * pNamespace)
{
    HRESULT         hr = S_OK;
    int             i, c;

    //
    // add the table (if passed) to the array, and bail out if nothing to do
    //

    if (pNamespace)
    {
        hr = THR(_aryETN.Append(pNamespace));
        if (hr)
            goto Cleanup;
    }

    if (0 == _aryETN.Size())
        goto Cleanup;

    //
    // still downloading the factory object?
    //

    if (DOWNLOADSTATUS_INPROGRESS == _downloadStatus)
    {
        hr = E_PENDING;
        goto Cleanup;
    }

    Assert (DOWNLOADSTATUS_DONE == _downloadStatus);

    //
    // query the information from the factory object and broadcast it to the listening tables
    //

    for (i = 0, c = _aryETN.Size(); i < c; i++)
    {
        pNamespace = _aryETN[i];
        if (pNamespace)
        {
            // will return S_OK or E_PENDING (E_PENDING is typical for HTCs when called the first time)
            hr = THR_NOTRACE(SyncETNHelper(pNamespace));
            if (E_PENDING == hr)  // (if error other then E_PENDING we still want to complete and do Sync2)
                goto Cleanup;

            _aryETN[i] = NULL; // (possible recursive entry) // TODO (alexz) is the architecture setup right for this?

            hr = THR(pNamespace->Sync2());
            if (hr)
                goto Cleanup;
        }
    }

    _aryETN.DeleteAll();

Cleanup:

    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerFactoryUrl::SyncETNAbort
//
//----------------------------------------------------------------------------

HRESULT
CPeerFactoryUrl::SyncETNAbort(CExtendedTagNamespace * pNamespace)
{
    _aryETN.DeleteByValue(pNamespace);

    RRETURN (S_OK);
}

///////////////////////////////////////////////////////////////////////////
//
// CTagDescReadyStateSink
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Member:     CPeerFactoryUrl::CETNReadyStateSink::QueryInterface, per IUnknown
//
//-------------------------------------------------------------------------

STDMETHODIMP
CPeerFactoryUrl::CETNReadyStateSink::QueryInterface(REFIID iid, LPVOID * ppv)
{
    *ppv = NULL;

    switch (iid.Data1)
    {
    QI_INHERITS(this, IUnknown)
    QI_INHERITS(this, IPropertyNotifySink)
    }

    if (*ppv)
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }
    else
        RRETURN(E_NOINTERFACE);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerFactoryUrl::CETNReadyStateSink::OnChanged, per IPropertyNotifySink
//
//----------------------------------------------------------------------------

HRESULT
CPeerFactoryUrl::CETNReadyStateSink::OnChanged(DISPID dispid)
{
    HRESULT         hr = S_OK;
    IDispatchEx *   pdispex = NULL;
    CInvoke         invoke;
    CVariant        varReadyState;

    switch (dispid)
    {
    case DISPID_READYSTATE:

        Assert(PFU()->_pFactory);

        hr = THR(PFU()->_pFactory->QueryInterface(IID_IDispatchEx, (void**)&pdispex));
        if (hr)
            goto Cleanup;

        hr = THR(invoke.Init(pdispex));
        if (hr)
            goto Cleanup;

        hr = THR(invoke.Invoke(DISPID_READYSTATE, DISPATCH_PROPERTYGET));
        if (hr)
            goto Cleanup;

        hr = THR(VariantChangeType(&varReadyState, invoke.Res(), 0, VT_I4));
        if (hr)
            goto Cleanup;

        if (READYSTATE_COMPLETE == (READYSTATE) V_I4(&varReadyState))
        {
            IGNORE_HR(PFU()->SyncETN());
        }

        break;
    }

Cleanup:
    ReleaseInterface(pdispex);

    RRETURN (hr);
}

///////////////////////////////////////////////////////////////////////////
//
// CPeerFactoryUrl::COleReadyStateSink class
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Member:     CPeerFactoryUrl::COleReadyStateSink::QueryInterface, per IUnknown
//
//-------------------------------------------------------------------------

STDMETHODIMP
CPeerFactoryUrl::COleReadyStateSink::QueryInterface(REFIID iid, LPVOID * ppv)
{
    *ppv = NULL;

    switch (iid.Data1)
    {
    QI_INHERITS(this, IUnknown)
    QI_INHERITS(this, IDispatch)
    }

    if (*ppv)
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }
    else
        RRETURN(E_NOINTERFACE);
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerFactoryUrl::COleReadyStateSink::Invoke, per IDispatch
//
//-------------------------------------------------------------------------

HRESULT
CPeerFactoryUrl::COleReadyStateSink::SinkReadyState()
{
    HRESULT         hr = S_OK;
    BSTR            bstrEvent = NULL;

    hr = THR(FormsAllocString(_T("onreadystatechange"), &bstrEvent));
    if (hr)
        goto Cleanup;
    
    hr = THR(PFU()->_pOleSite->attachEvent(bstrEvent, (IDispatch*)this, NULL));
    if (hr)
        goto Cleanup;

    hr = THR(PFU()->OnStartBinding());

Cleanup:
    FormsFreeString(bstrEvent);

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerFactoryUrl::COleReadyStateSink::Invoke, per IDispatch
//
//-------------------------------------------------------------------------

HRESULT
CPeerFactoryUrl::COleReadyStateSink::Invoke(
    DISPID          dispid,
    REFIID          riid,
    LCID            lcid,
    WORD            wFlags,
    DISPPARAMS *    pDispParams,
    VARIANT *       pvarResult,
    EXCEPINFO *     pExcepInfo,
    UINT *          puArgErr)
{
    HRESULT         hr = S_OK;
    BSTR            bstrEvent = NULL;

    Assert (PFU()->_pOleSite && DISPID_VALUE == dispid);

    if (READYSTATE_LOADED <= PFU()->_pOleSite->_lReadyState &&
        PFU()->_downloadStatus < DOWNLOADSTATUS_DONE)
    {
        hr = THR(PFU()->OnOleObjectAvailable());
        if (hr)
            goto Cleanup;
        
        hr = THR(PFU()->OnStopBinding());
        if (hr)
            goto Cleanup;

        hr = THR(FormsAllocString(_T("onreadystatechange"), &bstrEvent));
        if (hr)
            goto Cleanup;
        
        // TODO (alexz) can't do the following: this will prevent it from firing into the next sink point
        // hr = THR(PFU()->_pOleSite->detachEvent(bstrEvent, (IDispatch*)this));
    }

Cleanup:
    FormsFreeString(bstrEvent);

    RRETURN (hr);
}

///////////////////////////////////////////////////////////////////////////
//
// CPeerFactoryBuiltin class
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Member:     CPeerFactoryBuiltin::Init, virtual per CPeerFactory
//
//-------------------------------------------------------------------------

HRESULT
CPeerFactoryBuiltin::Init(const CTagDescBuiltin * pTagDescBuiltin)
{
    HRESULT     hr = S_OK;

    _pTagDescBuiltin = pTagDescBuiltin;

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerFactoryBuiltin::FindBehavior, virtual per CPeerFactory
//
//-------------------------------------------------------------------------

HRESULT
CPeerFactoryBuiltin::FindBehavior(
    CPeerHolder *           pPeerHolder,
    IElementBehaviorSite *  pSite,
    IElementBehavior **     ppPeer)
{
    HRESULT     hr = E_FAIL;

    Assert (_pTagDescBuiltin);

    switch (_pTagDescBuiltin->type)
    {
    case CTagDescBuiltin::TYPE_HTC:

        hr = THR(CHtmlComponent::FindBehavior(
            (HTC_BEHAVIOR_TYPE)_pTagDescBuiltin->extraInfo.dwHtcBehaviorType, pSite, ppPeer));

        break;

    case CTagDescBuiltin::TYPE_OLE:

        hr = THR(CoCreateInstance(
            _pTagDescBuiltin->extraInfo.clsid, NULL, CLSCTX_INPROC_SERVER | CLSCTX_INPROC_HANDLER,
            IID_IElementBehavior, (void **)ppPeer));

        break;

    default:
        Assert ("invalid BuiltinGenericTagDesc");
        hr = E_FAIL;
        break;
    }

    RRETURN (hr);
}

///////////////////////////////////////////////////////////////////////////
//
// CPeerFactoryBinary class
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Member:     CPeerFactoryBinary constructor
//
//-------------------------------------------------------------------------

CPeerFactoryBinary::CPeerFactoryBinary()
{
    _pFactory = NULL;
    _ulRefs = 1;
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerFactoryBinary destructor
//
//-------------------------------------------------------------------------

CPeerFactoryBinary::~CPeerFactoryBinary()
{
    ReleaseInterface(_pFactory);
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerFactoryBinary::QueryInterface
//
//-------------------------------------------------------------------------

HRESULT
CPeerFactoryBinary::QueryInterface (REFIID riid, LPVOID * ppv)
{
    Assert (FALSE && "Unexpected");
    RRETURN (E_UNEXPECTED);
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerFactoryBinary::Init
//
//-------------------------------------------------------------------------

HRESULT
CPeerFactoryBinary::Init(IElementBehaviorFactory * pFactory)
{
    HRESULT hr = S_OK;

    Assert (pFactory);

    _pFactory = pFactory;
    _pFactory->AddRef();

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerFactoryBinary::FindBehavior, virtual per CPeerFactory
//
//-------------------------------------------------------------------------

HRESULT
CPeerFactoryBinary::FindBehavior(
    CPeerHolder *           pPeerHolder,
    IElementBehaviorSite *  pSite,
    IElementBehavior **     ppPeer)
{
    HRESULT             hr;
    CElement *          pElement = pPeerHolder->_pElement;
    CExtendedTagDesc *  pDesc = pElement->GetExtendedTagDesc();
    const TCHAR *       pchName;

    Assert (_pFactory);
    Assert (pDesc); // (that means the factory for now can only be used for identity behaviors)

    pchName = pDesc->TagName();

    hr = THR(FindPeer(_pFactory, pchName, /* pchUrl = */ NULL, pSite, ppPeer));

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerFactoryBinary::GetElementNamespaceFactory, virtual per CPeerFactory
//
//-------------------------------------------------------------------------

HRESULT 
CPeerFactoryBinary::GetElementNamespaceFactoryCallback( IElementNamespaceFactoryCallback ** ppNSFactory )
{
    HRESULT hr;

    hr = THR_NOTRACE(_pFactory->QueryInterface( IID_IElementNamespaceFactoryCallback, (void**)ppNSFactory));

    RRETURN_NOTRACE( hr );
};


///////////////////////////////////////////////////////////////////////////
//
// CPeerFactoryBinaryOnstack class
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Member:     CPeerFactoryBinaryOnstack constructor
//
//-------------------------------------------------------------------------

CPeerFactoryBinaryOnstack::CPeerFactoryBinaryOnstack()
{
    _pFactory = NULL;
    _pPeer    = NULL;
    _pchUrl   = NULL;
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerFactoryBinaryOnstack destructor
//
//-------------------------------------------------------------------------

CPeerFactoryBinaryOnstack::~CPeerFactoryBinaryOnstack()
{
    ReleaseInterface(_pPeer);
    ReleaseInterface(_pFactory);
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerFactoryBinaryOnstack::Init
//
//-------------------------------------------------------------------------

HRESULT
CPeerFactoryBinaryOnstack::Init(LPTSTR pchUrl)
{
    HRESULT hr = S_OK;
    _pchUrl  = pchUrl;
    _pchName = _pchUrl ? GetPeerNameFromUrl(_pchUrl) : NULL;
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerFactoryBinaryOnstack::FindBehavior, virtual per CPeerFactory
//
//-------------------------------------------------------------------------

HRESULT
CPeerFactoryBinaryOnstack::FindBehavior(
    CPeerHolder *           pPeerHolder,
    IElementBehaviorSite *  pSite,
    IElementBehavior **     ppPeer)
{
    HRESULT     hr;

    if (_pFactory)
    {
        hr = THR(FindPeer(_pFactory, _pchName, _pchUrl, pSite, ppPeer));
    }
    else if (_pPeer)
    {
        *ppPeer = _pPeer;
        (*ppPeer)->AddRef();
        hr = S_OK;
    }
    else
    {
        hr = E_FAIL;
    }

    RRETURN (hr);
}

///////////////////////////////////////////////////////////////////////////
//
// Class:       CPeerFactoryDefault
//
///////////////////////////////////////////////////////////////////////////

//+-------------------------------------------------------------------
//
//  Member:     CPeerFactoryDefault constructor
//
//--------------------------------------------------------------------

CPeerFactoryDefault::CPeerFactoryDefault(CDoc * pDoc)
{
    AddRef();

    _pDoc = pDoc;
    _pDoc->SubAddRef();
}

//+-------------------------------------------------------------------
//
//  Member:     CPeerFactoryDefault destructor
//
//--------------------------------------------------------------------

CPeerFactoryDefault::~CPeerFactoryDefault()
{
    _pDoc->SubRelease();
    if (_pPeerFactory)
    {
        _pPeerFactory->Release();
    }
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerFactoryDefault::QueryInterface, per IUnknown
//
//-------------------------------------------------------------------------

HRESULT
CPeerFactoryDefault::QueryInterface(REFIID iid, LPVOID * ppv)
{
    *ppv = NULL;

    switch (iid.Data1)
    {
    QI_INHERITS((IElementBehaviorFactory*)this, IUnknown)
    QI_INHERITS(this, IElementBehaviorFactory)
    QI_INHERITS(this, IElementNamespaceFactory)
    QI_INHERITS(this, IElementNamespaceFactory2)
    }

    if (*ppv)
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }
    else
    {
        RRETURN (E_NOTIMPL);
    }
}

//+-------------------------------------------------------------------
//
//  Member:     CPeerFactoryDefault::FindBehavior
//
//  Synopsis:   lookup in host and iepeers.dll.
//
//--------------------------------------------------------------------

HRESULT
CPeerFactoryDefault::FindBehavior(
    BSTR                    bstrName,
    BSTR                    bstrUrl,
    IElementBehaviorSite *  pSite,
    IElementBehavior **     ppBehavior)
{
    HRESULT hr = E_FAIL;
    CDoc *pDoc = _pDoc;

    *ppBehavior= NULL;

    //
    // use the specific default factory if present
    //

    if (_pPeerFactory)
    {
        hr = THR_NOTRACE(_pPeerFactory->FindBehavior(bstrName, bstrUrl, pSite, ppBehavior));
        goto Cleanup;       // done, don't try others
    }

    //
    // try the host
    //

    while(pDoc->_fPopupDoc)
    {
        pDoc = pDoc->_pPopupParentWindow->Doc();
    }

    if (pDoc->_pHostPeerFactory)
    {
        hr = THR_NOTRACE(pDoc->_pHostPeerFactory->FindBehavior(bstrName, bstrUrl, pSite, ppBehavior));
        if (S_OK == hr)
            goto Cleanup;       // done;
    }

    //
    // lookup in iepeers.dll
    //

    hr = THR(_pDoc->EnsureIepeersFactory());
    if (hr)
        goto Cleanup;

    hr = THR_NOTRACE(_pDoc->_pIepeersFactory->FindBehavior(bstrName, bstrUrl, pSite, ppBehavior));

Cleanup:

    RRETURN (hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CPeerFactoryDefault::Create
//
//--------------------------------------------------------------------

HRESULT
CPeerFactoryDefault::Create(IElementNamespace * pNamespace)
{
    AssertSz( FALSE, "No one outside of Trident should have been able to get here, and Trident doesn't want to" );
    RRETURN( CreateWithImplementation( pNamespace, NULL ) );
}

HRESULT
CPeerFactoryDefault::CreateWithImplementation(IElementNamespace * pNamespace, BSTR bstrImplementation)
{
    HRESULT                         hr = S_OK;
    HRESULT                         hr2;
    IElementNamespaceFactory *      pFactory = NULL;
    CDoc *                          pDoc = _pDoc;

    Assert (pNamespace);

    //
    // use the specific default factory if present
    //

    if (_pPeerFactory)
    {
        hr2 = THR_NOTRACE( CreateNamespaceHelper( _pPeerFactory, pNamespace, bstrImplementation, /* fNeedSysAlloc = */ FALSE ) );
        goto Cleanup;       // done, don't try others
    }

    //
    // host
    //

    while(pDoc->_fPopupDoc)
    {
        pDoc = pDoc->_pPopupParentWindow->Doc();
    }

    if (pDoc->_pHostPeerFactory)
    {
        hr2 = THR_NOTRACE( CreateNamespaceHelper( pDoc->_pHostPeerFactory, pNamespace, bstrImplementation, /* fNeedSysAlloc = */ FALSE ) );
    }

    //
    // iepeers.dll
    //

    hr = THR(_pDoc->EnsureIepeersFactory());
    if (hr)
        goto Cleanup;

    hr2 = THR_NOTRACE( CreateNamespaceHelper( _pDoc->_pIepeersFactory, pNamespace, bstrImplementation, /* fNeedSysAlloc = */ FALSE ) );

#ifdef V4FRAMEWORK
    //
    // external COM+ MSUI framework
    //
    {
        IExternalDocument *pExtFactory;

        pExtFactory = _pDoc->EnsureExternalFrameWork();
        if (!pExtFactory) 
            goto Cleanup;

        hr = pExtFactory->GetTags((long)pNamespace);
        if (hr)
            goto Cleanup;
    }
#endif

Cleanup:
    ReleaseInterface(pFactory);

    RRETURN (hr);
}


//+-------------------------------------------------------------------
//
//  Member:     CreateNamespaceHelper
//
//  Synopsis:   Helper function for getting a NamespaceFactory and
//              having it populate a namespace.
//
//  Arguments:  IUnknown * pBehFactory - Behavior Factory ptr
//              IElementNamespaceFactory * pNamespace - Namespace to populate
//              TCHAR * pchImpl - Implementation string (#default#foo)
//              BOOL fNeedSysAlloc - FALSE if pchImpl is already a BSTR
//  
//--------------------------------------------------------------------

HRESULT CreateNamespaceHelper( IUnknown * pBehFactory, IElementNamespace * pNamespace, TCHAR * pchImplementation, BOOL fNeedSysAlloc )
{
    HRESULT                     hr          = S_OK;
    HRESULT                     hr2         = E_NOINTERFACE;
    IElementNamespaceFactory  * pFactory    = NULL;
    IElementNamespaceFactory2 * pFactory2   = NULL;
    BSTR                        bstrImpl    = fNeedSysAlloc ? NULL : pchImplementation;

    Assert( pBehFactory && pNamespace );

    // First go for a Factory2, then try for a Factory
    hr2 = THR_NOTRACE( pBehFactory->QueryInterface( IID_IElementNamespaceFactory2, (void **)&pFactory2 ) );
    if( !hr2 && fNeedSysAlloc && pchImplementation )
    {
        bstrImpl = SysAllocString( pchImplementation );
        if( !bstrImpl )
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }

    if( hr2 )
    {
        // If we can't get either  factory, we're hosed.
        hr = THR_NOTRACE( pBehFactory->QueryInterface( IID_IElementNamespaceFactory, (void **)&pFactory ) );
        if( hr )
            goto Cleanup;
    }

    if( pFactory2 )
    {
        hr = THR( pFactory2->CreateWithImplementation( pNamespace, bstrImpl ) );
        goto Cleanup;
    }
    else
    {
        hr = THR( pFactory->Create( pNamespace ) );
        goto Cleanup;
    }

Cleanup:
    if( fNeedSysAlloc )
    {
        SysFreeString( bstrImpl );
    }
    ReleaseInterface( pFactory );
    ReleaseInterface( pFactory2 );
    RRETURN( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\peermgr.cxx ===
//+---------------------------------------------------------------------
//
//  File:       peer.cxx
//
//  Contents:   peer holder
//
//  Classes:    CPeerHolder
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_PRGSNK_H_
#define X_PRGSNK_H_
#include <prgsnk.h>
#endif

#ifndef X_PEER_HXX_
#define X_PEER_HXX_
#include "peer.hxx"
#endif

#ifndef X_PEERMGR_HXX_
#define X_PEERMGR_HXX_
#include "peermgr.hxx"
#endif

#ifndef X_PEERXTAG_HXX_
#define X_PEERXTAG_HXX_
#include "peerxtag.hxx"
#endif

#ifndef X_ELEMENTP_HXX_
#define X_ELEMENTP_HXX_
#include "elementp.hxx"
#endif

//////////////////////////////////////////////////////////////////////////////
//
// misc
//
//////////////////////////////////////////////////////////////////////////////

MtDefine(CPeerMgr, Elements, "CPeerMgr")

DeclareTag(tagPeerMgrSuspendResumeDownload, "Peer", "trace CPeerMgr::[Suspend|Resume]Download")

//////////////////////////////////////////////////////////////////////////////
//
// CPeerMgr methods
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
//  Member:     CPeerMgr constructor
//
//----------------------------------------------------------------------------

CPeerMgr::CPeerMgr(CElement * pElement)
{
    Assert (!_cPeerDownloads);
    _readyState = READYSTATE_COMPLETE;
    _pElement = pElement;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerMgr destructor
//
//----------------------------------------------------------------------------

CPeerMgr::~CPeerMgr()
{
    DelDownloadProgress();
    ResumeDownload();

    if (_pDefaults)
        _pDefaults->PrivateRelease();
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerMgr::OnExitTree, helper
//
//----------------------------------------------------------------------------

void
CPeerMgr::OnExitTree()
{
    DelDownloadProgress();
    ResumeDownload();
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerMgr::EnsurePeerMgr, static helper
//
//----------------------------------------------------------------------------

HRESULT
CPeerMgr::EnsurePeerMgr(CElement * pElement, CPeerMgr ** ppPeerMgr)
{
    HRESULT            hr = S_OK;

    (*ppPeerMgr) = pElement->GetPeerMgr();

    if (*ppPeerMgr)     // if we already have peer mgr
        goto Cleanup;   // done

    // create it

    (*ppPeerMgr) = new CPeerMgr(pElement);
    if (!(*ppPeerMgr))
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    pElement->SetPeerMgr(*ppPeerMgr);

Cleanup:
    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerMgr::EnsureDeletePeerMgr, static helper
//
//  Synopsis:   if no one needs the PeerMgr, this method deletes it and removes ptr
//              to it from the element
//
//----------------------------------------------------------------------------

void
CPeerMgr::EnsureDeletePeerMgr(CElement * pElement, BOOL fForce)
{
    CPeerMgr *  pPeerMgr = pElement->GetPeerMgr();

    if (!pPeerMgr)
        return;

    if (!fForce && !pPeerMgr->CanDelete())
        return;

    delete pElement->DelPeerMgr();
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerMgr::UpdateReadyState, static helper
//
//----------------------------------------------------------------------------

void
CPeerMgr::UpdateReadyState(CElement * pElement, READYSTATE readyStateNew)
{
    HRESULT         hr;
    CPeerMgr *      pPeerMgr;
    CPeerHolder *   pPeerHolder = pElement->GetPeerHolder();
    READYSTATE      readyState = pPeerHolder ? pPeerHolder->GetReadyStateMulti() : READYSTATE_COMPLETE;

    if (READYSTATE_UNINITIALIZED != readyStateNew)
    {
        readyState = min (readyState, readyStateNew);
    }

    if (readyState < READYSTATE_COMPLETE)
    {
        hr = THR(CPeerMgr::EnsurePeerMgr(pElement, &pPeerMgr));
        if (hr)
            goto Cleanup;

        pPeerMgr->UpdateReadyState(readyState);
    }
    else
    {
        Assert (readyState == READYSTATE_COMPLETE);

        pPeerMgr = pElement->GetPeerMgr();

        if (pPeerMgr)
        {
            pPeerMgr->UpdateReadyState(READYSTATE_UNINITIALIZED);

            CPeerMgr::EnsureDeletePeerMgr(pElement);
        }
    }

Cleanup:
    return;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerMgr::UpdateReadyState
//
//----------------------------------------------------------------------------

void
CPeerMgr::UpdateReadyState(READYSTATE readyStateNew)
{
    CPeerHolder *   pPeerHolder = _pElement->GetPeerHolder();
    READYSTATE      readyStatePrev;
    CPeerMgr::CLock Lock(this);

    readyStatePrev = _readyState;

    if (READYSTATE_UNINITIALIZED == readyStateNew)
        readyStateNew = pPeerHolder ? pPeerHolder->GetReadyStateMulti() : READYSTATE_COMPLETE;

    _readyState = min (_cPeerDownloads ? READYSTATE_LOADING : READYSTATE_COMPLETE, readyStateNew);

    if (readyStatePrev == READYSTATE_COMPLETE && _readyState <  READYSTATE_COMPLETE)
    {
        AddDownloadProgress();
    }

    if ( readyStatePrev != _readyState )
    {
        _pElement->OnReadyStateChange();
    }

    if (readyStatePrev <  READYSTATE_COMPLETE && _readyState == READYSTATE_COMPLETE)
    {
        DelDownloadProgress();
    }

    if (!pPeerHolder ||
         pPeerHolder->GetIdentityReadyState() == READYSTATE_COMPLETE)
    {
        // ensure that script execution is unblocked if we blocked it before while waiting for the identity peer
        ResumeDownload();
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerMgr::AddDownloadProgress, helper
//
//----------------------------------------------------------------------------

void
CPeerMgr::AddDownloadProgress()
{
    CMarkup *   pMarkup = _pElement->GetMarkup();

    if (pMarkup)
    {
        IProgSink * pProgSink = pMarkup->GetProgSink();

        Assert (0 == _dwDownloadProgressCookie);

        if (pProgSink)
        {
            pProgSink->AddProgress (PROGSINK_CLASS_CONTROL, &_dwDownloadProgressCookie);
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerMgr::DelDownloadProgress, helper
//
//----------------------------------------------------------------------------

void
CPeerMgr::DelDownloadProgress()
{
    DWORD dwDownloadProgressCookie;

    if (0 != _dwDownloadProgressCookie)
    {
        // element should be in markup if _dwDownloadProgressCookie is set;
        // if element leaves markup before progress is released, OnExitTree should release the progress
        Assert (_pElement->GetMarkup());

        // progsink on markup should be available because we did AddProgress on it
        Assert (_pElement->GetMarkup()->GetProgSink());

        dwDownloadProgressCookie = _dwDownloadProgressCookie;
        _dwDownloadProgressCookie = 0;

        _pElement->GetMarkup()->GetProgSink()->DelProgress (dwDownloadProgressCookie);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerMgr::SuspendDownload
//
//----------------------------------------------------------------------------

void
CPeerMgr::SuspendDownload()
{

    Assert (!_fDownloadSuspended);

    TraceTag((tagPeerMgrSuspendResumeDownload,
        "CPeerMgr::SuspendDownload for element <%ls id = %ls SN = %ld>",
        _pElement->TagName(), STRVAL(_pElement->GetAAid()), _pElement->SN()));

    _fDownloadSuspended = TRUE;

    Assert (_pElement->IsInMarkup());

    _pElement->GetMarkup()->SuspendDownload();
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerMgr::ResumeDownload
//
//----------------------------------------------------------------------------

void
CPeerMgr::ResumeDownload()
{
    if (_fDownloadSuspended)
    {
        TraceTag((tagPeerMgrSuspendResumeDownload,
            "CPeerMgr::ResumeDownload for element <%ls id = %ls SN = %ld>",
            _pElement->TagName(), STRVAL(_pElement->GetAAid()), _pElement->SN()));

        _fDownloadSuspended = FALSE;

        Assert (_pElement->IsInMarkup());

        _pElement->GetMarkup()->ResumeDownload();

    }
#if DBG == 1
    else
    {
        TraceTag((tagPeerMgrSuspendResumeDownload,
            "CPeerMgr::ResumeDownload for element <%ls id = %ls SN = %ld> - not blocked",
            _pElement->TagName(), STRVAL(_pElement->GetAAid()), _pElement->SN()));
    }
#endif
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerMgr::EnsureDefaults
//
//----------------------------------------------------------------------------

HRESULT
CPeerMgr::EnsureDefaults(CDefaults **ppDefaults)
{
    HRESULT     hr = S_OK;

    Assert (ppDefaults);

    if (_pDefaults)
        goto Cleanup;

    _pDefaults = new CDefaults(_pElement);
    if (!_pDefaults)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

Cleanup:
    *ppDefaults = _pDefaults;

    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerMgr::OnDefaultsPassivate, static
//
//----------------------------------------------------------------------------

HRESULT
CPeerMgr::OnDefaultsPassivate(CElement * pElement)
{
    HRESULT     hr = S_OK;
    CPeerMgr *  pPeerMgr = pElement->GetPeerMgr();

    if (pPeerMgr)
    {
        pPeerMgr->_pElement = NULL;
        EnsureDeletePeerMgr(pElement);
    }

    RRETURN (hr);
}

//
// CPeerMgr::CLock
//

CPeerMgr::CLock::CLock( CPeerMgr * pPeerMgr )
{
    Assert( pPeerMgr );

    _pPeerMgr = pPeerMgr;
    if( !pPeerMgr->_fPeerMgrLock )
    {
        _fPrimaryLock = TRUE;
        pPeerMgr->_fPeerMgrLock = TRUE;
    }
}

CPeerMgr::CLock::~CLock()
{
    if( _fPrimaryLock )
    {
        _pPeerMgr->_fPeerMgrLock = FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\peermisc.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_PEER_HXX_
#define X_PEER_HXX_
#include "peer.hxx"
#endif

///////////////////////////////////////////////////////////////////////////
//
// misc
//
///////////////////////////////////////////////////////////////////////////

MtDefine(CPeerUrnCollection, Elements, "CPeerUrnCollection")

const CBase::CLASSDESC CPeerUrnCollection::s_classdesc =
{
    &CLSID_HTMLUrnCollection,               // _pclsid
    0,                                      // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                                   // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                                   // _pcpi
    0,                                      // _dwFlags
    &IID_IHTMLUrnCollection,                // _piidDispinterface
    &s_apHdlDescs                           // _apHdlDesc
};

#define _cxx_
#include "urncoll.hdl"

//////////////////////////////////////////////////////////////////////////////
//
// Class:  CPeerUrnCollection
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
//  Member:     CPeerUrnCollection constructor
//
//----------------------------------------------------------------------------

CPeerUrnCollection::CPeerUrnCollection( CElement *pElement ) : _pElement(pElement)
{
    pElement->AddRef();
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerUrnCollection::Passivate
//
//----------------------------------------------------------------------------

void
CPeerUrnCollection::Passivate()
{
    super::Passivate();
    _pElement->Release();
}


//+---------------------------------------------------------------------------
//
//  Member:     CPeerUrnCollection::PrivateQueryInterface
//
//----------------------------------------------------------------------------

HRESULT
CPeerUrnCollection::PrivateQueryInterface(REFIID iid, void **ppv)
{
    *ppv = NULL;
    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_TEAROFF_DISPEX(this, NULL)
        QI_TEAROFF(this, IObjectIdentity, NULL)
        default:
        {
            const CLASSDESC *pclassdesc = BaseDesc();

            // TODO (alexz) replace this with QI_TEAROFF
            if (pclassdesc &&
                pclassdesc->_piidDispinterface &&
                (iid == *pclassdesc->_piidDispinterface))
            {
                HRESULT hr = THR(CreateTearOffThunk(this, s_apfnIHTMLUrnCollection, NULL, ppv));
                if (hr)
                    RRETURN(hr);
            }
        }
    }

    if (*ppv)
    {
        (*(IUnknown**)ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

//+---------------------------------------------------------------------------
//
//  Member  : CPeerUrnCollection::length
//
//----------------------------------------------------------------------------

HRESULT
CPeerUrnCollection::get_length(long * pLength)
{
    HRESULT                 hr = S_OK;
    CPeerHolder::CListMgr   List;

    if (!pLength)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pLength = 0;
    Assert(_pElement);

    if (_pElement->HasPeerHolder())
    {
        List.Init(_pElement->GetPeerHolder());

        *pLength = List.GetPeerHolderCount(/* fNonEmptyOnly = */TRUE);
    }

Cleanup:
    RRETURN( SetErrorInfo( hr ));
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerUrnCollection::item
//
//----------------------------------------------------------------------------

HRESULT
CPeerUrnCollection::item(long lIndex, BSTR *ppUrn)
{
    HRESULT                 hr;
    VARIANT                 varBstr;

    if (!ppUrn)
    {
        RRETURN(E_POINTER);
    }

    hr = THR(GetItem(lIndex, &varBstr));
    if (hr)
        goto Cleanup;

    Assert(V_VT(&varBstr) == VT_BSTR);
    *ppUrn = V_BSTR(&varBstr);

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerUrnCollection::GetItem
//
//----------------------------------------------------------------------------

HRESULT 
CPeerUrnCollection::GetItem (long lIndex, VARIANT *pvar)
{
    HRESULT                 hr = E_INVALIDARG;
    CPeerHolder::CListMgr   List;
    CPeerHolder *           pPeerHolder;

    if (!_pElement)
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    if (!_pElement->HasPeerHolder())
    {
        Assert (E_INVALIDARG == hr);
        goto Cleanup;
    }

    // this is NULL if we're validating lIndex 
    if (pvar)    
        V_BSTR(pvar) = NULL;

    List.Init(_pElement->GetPeerHolder());
    pPeerHolder = List.GetPeerHolderByIndex(lIndex, /* fNonEmptyOnly = */TRUE);

    if (!pPeerHolder)
        goto Cleanup;

    // pvar can be NULL when checking for valid index
    if (pvar)
    {
        hr = THR(pPeerHolder->_cstrUrn.AllocBSTR(&V_BSTR(pvar)));
        if (hr)
            goto Cleanup;

        V_VT(pvar) = VT_BSTR;
    }
    else
        hr = S_OK;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\peermarkup.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ROOTELEM_HXX
#define X_ROOTELEM_HXX
#include "rootelem.hxx"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_XMLNS_HXX_
#define X_XMLNS_HXX_
#include "xmlns.hxx"
#endif

#ifndef X_PEER_HXX_
#define X_PEER_HXX_
#include "peer.hxx"
#endif

#ifndef X_PEERURLMAP_HXX_
#define X_PEERURLMAP_HXX_
#include "peerurlmap.hxx"
#endif

#ifndef X_PEERXTAG_HXX_
#define X_PEERXTAG_HXX_
#include "peerxtag.hxx"
#endif

//////////////////////////////////////////////////////////////////////////////
//
//  misc
//
//////////////////////////////////////////////////////////////////////////////

MtDefine(CMarkupBehaviorContext, CMarkup, "CMarkupBehaviorContext")

DeclareTag(tagPeerCMarkupIsGenericElement, "Peer", "trace CMarkup::IsGenericElement")

//////////////////////////////////////////////////////////////////////////////
//
//  Class:      CMarkupBehaviorContext
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
//  Member:     CMarkupBehaviorContext constructor
//
//----------------------------------------------------------------------------

CMarkupBehaviorContext::CMarkupBehaviorContext()
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CMarkupBehaviorContext destructor
//
//----------------------------------------------------------------------------

CMarkupBehaviorContext::~CMarkupBehaviorContext()
{
    int c;
    CElement ** ppElem;

    for( c = _aryPeerElems.Size(), ppElem = _aryPeerElems; c > 0; c--, ppElem++ )
    {
        (*ppElem)->SubRelease();
    }

    if (_pExtendedTagTable)
        _pExtendedTagTable->Release();

    delete _pExtendedTagTableBooster;

    if (_pXmlNamespaceTable)
        _pXmlNamespaceTable->Release();

    _cstrHistoryUserData.Free();

    ClearInterface(&_pXMLHistoryUserData);
}

//////////////////////////////////////////////////////////////////////////////
//
//  Class:      CMarkup
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::ProcessPeerTask
//
//----------------------------------------------------------------------------

HRESULT
CMarkup::ProcessPeerTask(PEERTASK task)
{
    HRESULT     hr = S_OK;

    switch (task)
    {
    case PEERTASK_MARKUP_RECOMPUTEPEERS_UNSTABLE:

        PrivateAddRef();

        IGNORE_HR(GetFrameOrPrimaryMarkup()->EnqueuePeerTask(this, PEERTASK_MARKUP_RECOMPUTEPEERS_STABLE));

        break;

    case PEERTASK_MARKUP_RECOMPUTEPEERS_STABLE:

        if (!_pDoc->TestLock(FORMLOCK_UNLOADING))
        {
            IGNORE_HR(RecomputePeers());
        }

        PrivateRelease(); // the markup may passivate after this call

        break;
    }

    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::RecomputePeers
//
//----------------------------------------------------------------------------

HRESULT
CMarkup::RecomputePeers()
{
    HRESULT     hr = S_OK;

    if (_pDoc->_fCssPeersPossible)
    {
        AssertSz(CPeerHolder::IsMarkupStable(this), "CMarkup::RecomputePeers appears to be called at an unsafe moment of time");

        CNotification   nf;
        nf.RecomputeBehavior(Root());
        Notify(&nf);
    }

    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::EnsureBehaviorContext
//
//----------------------------------------------------------------------------

HRESULT
CMarkup::EnsureBehaviorContext(CMarkupBehaviorContext ** ppBehaviorContext)
{
    HRESULT                     hr = S_OK;
    CMarkupBehaviorContext *    pBehaviorContext;

    Assert (Doc()->_dwTID == GetCurrentThreadId());

    if (!HasBehaviorContext())
    {
        pBehaviorContext = new CMarkupBehaviorContext();
        if (!pBehaviorContext)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = THR(SetBehaviorContext(pBehaviorContext));
        if (hr)
            goto Cleanup;

        if (ppBehaviorContext)
        {
            *ppBehaviorContext = pBehaviorContext;
        }
    }
    else
    {
        if (ppBehaviorContext)
        {
            *ppBehaviorContext = BehaviorContext();
        }
    }

Cleanup:

    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::IsGenericElement
//
//----------------------------------------------------------------------------

ELEMENT_TAG
CMarkup::IsGenericElement(LPTSTR pchFullName, BOOL fAllSprinklesGeneric)
{
    ELEMENT_TAG     etag = ETAG_UNKNOWN;
    LPTSTR          pchColon;

    pchColon = StrChr (pchFullName, _T(':'));

    if (pchColon)
    {
        CStringNullTerminator   nullTerminator(pchColon);

        //
        // is it a valid sprinkle ?
        //

        etag = IsXmlSprinkle(/* pchNamespace = */pchFullName);
        if (ETAG_UNKNOWN != etag)
            goto Cleanup;
    }

    //
    // delegate to doc (host provided behaviors?, builtin behaviors?, etc)
    //

    etag = _pDoc->IsGenericElement(pchFullName, pchColon);
    if (ETAG_UNKNOWN != etag)
        goto Cleanup;

    if (pchColon)
    {
        // (NOTE: these checks should be after _pDoc->IsGenericElement)

        //
        // all sprinkles are generic elements within context of the current operation?
        //

        if (fAllSprinklesGeneric)
        {
            etag = ETAG_GENERIC;
            goto Cleanup;           // done
        }

        //
        // markup services parsing? any sprinkle goes as generic element
        //

        if (_fMarkupServicesParsing)
        {
            etag = ETAG_GENERIC;
            goto Cleanup;           // done
        }
    }

Cleanup:

    TraceTag((tagPeerCMarkupIsGenericElement,
              "CMarkup::IsGenericElement, name <%ls> recognized as %ls",
              pchFullName,
              ETAG_UNKNOWN == etag ? _T("UNKNOWN") :
                ETAG_GENERIC_BUILTIN == etag ? _T("GENERIC_BUILTIN") : _T("GENERIC")));

    return etag;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::EnsureXmlNamespaceTable
//
//----------------------------------------------------------------------------

HRESULT
CMarkup::EnsureXmlNamespaceTable(CXmlNamespaceTable ** ppXmlNamespaceTable)
{
    HRESULT                     hr;
    CMarkupBehaviorContext *    pContext;

    hr = THR(EnsureBehaviorContext(&pContext));
    if (hr)
        goto Cleanup;

    if (!pContext->_pXmlNamespaceTable)
    {
        pContext->_pXmlNamespaceTable = new CXmlNamespaceTable(_pDoc);
        if (!pContext->_pXmlNamespaceTable)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = THR(pContext->_pXmlNamespaceTable->Init());
        if (hr)
            goto Cleanup;
    }

    if (ppXmlNamespaceTable)
    {
        *ppXmlNamespaceTable = pContext->_pXmlNamespaceTable;
    }

Cleanup:
    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::RegisterXmlNamespace
//
//----------------------------------------------------------------------------

HRESULT
CMarkup::RegisterXmlNamespace(LPTSTR pchNamespace, LPTSTR pchUrn, XMLNAMESPACETYPE namespaceType)
{
    HRESULT                 hr;
    CXmlNamespaceTable *    pNamespaceTable;

    hr = THR(EnsureXmlNamespaceTable(&pNamespaceTable));
    if (hr)
        goto Cleanup;

    hr = THR(pNamespaceTable->RegisterNamespace(pchNamespace, pchUrn, namespaceType));

Cleanup:
    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::IsXmlSprinkle
//
//----------------------------------------------------------------------------

ELEMENT_TAG
CMarkup::IsXmlSprinkle (LPTSTR pchNamespace)
{
    HRESULT                 hr;
    CXmlNamespaceTable *    pNamespaceTable;

    hr = THR(EnsureXmlNamespaceTable(&pNamespaceTable));
    if (hr)
        return ETAG_UNKNOWN;

    return pNamespaceTable->IsXmlSprinkle(pchNamespace);
}

//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::SaveXmlNamespaceAttrs
//
//----------------------------------------------------------------------------

HRESULT
CMarkup::SaveXmlNamespaceAttrs (CStreamWriteBuff * pStreamWriteBuff)
{
    HRESULT                     hr = S_OK;
    CMarkupBehaviorContext *    pContext = BehaviorContext();

    if (pContext && pContext->_pExtendedTagTable)
    {
        hr = THR(pContext->_pExtendedTagTable->SaveXmlNamespaceStdPIs(pStreamWriteBuff));
    }
    else if (HtmCtx())
    {
        hr = THR(HtmCtx()->SaveXmlNamespaceStdPIs(pStreamWriteBuff));
    }
    
    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::EnsurePeerFactoryUrlMap
//
//----------------------------------------------------------------------------

HRESULT
CMarkup::EnsurePeerFactoryUrlMap(CPeerFactoryUrlMap ** ppPeerFactoryUrlMap)
{
    HRESULT                     hr;
    CMarkupBehaviorContext *    pContext;

    Assert (ppPeerFactoryUrlMap);

    hr = THR(EnsureBehaviorContext(&pContext));
    if (hr)
        goto Cleanup;

    if (!pContext->_pPeerFactoryUrlMap)
    {
        pContext->_pPeerFactoryUrlMap = new CPeerFactoryUrlMap(this);
        if (!pContext->_pPeerFactoryUrlMap)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }

    *ppPeerFactoryUrlMap = pContext->_pPeerFactoryUrlMap;

Cleanup:
    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::GetPeerFactoryUrlMap
//
//----------------------------------------------------------------------------

CPeerFactoryUrlMap *
CMarkup::GetPeerFactoryUrlMap()
{
    if (!HasBehaviorContext())
        return NULL;

    return BehaviorContext()->_pPeerFactoryUrlMap;
}

#ifdef GETDHELPER
//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::GetExtendedTagDesc
//
//----------------------------------------------------------------------------

CExtendedTagDesc *
CMarkup::GetExtendedTagDesc(LPTSTR pchNamespace, LPTSTR pchTagName, BOOL fEnsure, BOOL * pfQueryHost)
{
    return CExtendedTagTable::GetExtendedTagDesc( NULL, 
                                                  this, 
                                                  Doc()->_pExtendedTagTableHost,
                                                  pchNamespace,
                                                  pchTagName,
                                                  fEnsure,
                                                  FALSE,
                                                  pfQueryHost );
}
#else
//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::GetExtendedTagDesc
//
//----------------------------------------------------------------------------

CExtendedTagDesc *
CMarkup::GetExtendedTagDesc(LPTSTR pchNamespace, LPTSTR pchTagName, BOOL fEnsure, BOOL * pfQueryHost)
{
    CExtendedTagDesc *          pDesc = NULL;

    if( pfQueryHost )
        *pfQueryHost = FALSE;

    // There was an assumption that if behaviors are going to be involved, then we 
    // would have transferred the extended tag table from the htmload to the behavior
    // context when the markup was done loading.  However, if you just want to do
    // a createElement for XML, then none of this would have happened, and we
    // will have no load on which to put a tag table.
    if( !HtmCtx() || ( !HtmCtx()->HasLoad() && !HtmCtx()->GetExtendedTagTable() ) )
    {
        CMarkupBehaviorContext * pBehaviorContext = NULL;
        CExtendedTagTable * pExtendedTagTable = NULL;

        // Ensure a Behavior Context
        if SUCCEEDED( EnsureBehaviorContext( &pBehaviorContext ) )
        {
            Assert( pBehaviorContext );

            // Ensure a tag table
            if( !pBehaviorContext->_pExtendedTagTable )
            {
                pExtendedTagTable = new CExtendedTagTable( Doc(), this, FALSE );
                if( !pExtendedTagTable )
                {
                    // If we couldn't make one, then we'll fail through to the normal path.
                    delete DelBehaviorContext();
                }
                else
                {
                    pBehaviorContext->_pExtendedTagTable = pExtendedTagTable;
                }
            }
        }
    }

    if( BehaviorContext() && BehaviorContext()->_pExtendedTagTable )
    {
        pDesc = BehaviorContext()->_pExtendedTagTable->FindTagDesc( pchNamespace, pchTagName );
    }
    else if( HtmCtx() )
    {
        pDesc = HtmCtx()->GetExtendedTagDesc( pchNamespace, pchTagName, FALSE );
    }

    if( pDesc )
        goto Cleanup;

    if( Doc()->_pExtendedTagTableHost )
    {
        pDesc = Doc()->_pExtendedTagTableHost->FindTagDesc( pchNamespace, pchTagName, pfQueryHost );
        if( pDesc )
            goto Cleanup;
    }

    if( fEnsure && ( !pfQueryHost || FALSE == *pfQueryHost ) )
    {
        if(    BehaviorContext()
            && BehaviorContext()->_pExtendedTagTable )
        {
            pDesc = BehaviorContext()->_pExtendedTagTable->EnsureTagDesc( pchNamespace, pchTagName );
        }
        else
        {
            pDesc = HtmCtx()->GetExtendedTagDesc( pchNamespace, pchTagName, TRUE );
        }
    }

Cleanup:
    return pDesc;
}
#endif // GETDHELPER

//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::EnsureExtendedTagTableBooster
//
//----------------------------------------------------------------------------

HRESULT
CMarkup::EnsureExtendedTagTableBooster(CExtendedTagTableBooster ** ppExtendedTagTableBooster)
{
    HRESULT                     hr;
    CMarkupBehaviorContext *    pContext;

    Assert (ppExtendedTagTableBooster);
    Assert (Doc()->_dwTID == GetCurrentThreadId());

    AssertSz (!IsHtcMarkup(), "Attempt to ensure ExtendedTagTableBooster for HTC markup - a serious perf speed and memory hit for HTCs.");

    hr = THR(EnsureBehaviorContext(&pContext));
    if (hr)
        goto Cleanup;

    if (!pContext->_pExtendedTagTableBooster)
    {
        pContext->_pExtendedTagTableBooster = new CExtendedTagTableBooster();
        if (!pContext->_pExtendedTagTableBooster)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }

    *ppExtendedTagTableBooster = pContext->_pExtendedTagTableBooster;

Cleanup:
    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::GetExtendedTagTableBooster
//
//----------------------------------------------------------------------------

CExtendedTagTableBooster *
CMarkup::GetExtendedTagTableBooster()
{
    if (!HasBehaviorContext())
        return NULL;

    return BehaviorContext()->_pExtendedTagTableBooster;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\peerurlmap.cxx ===
//+----------------------------------------------------------------------------
//
//  File:       peer.cxx
//
//  Contents:   peer holder
//
//  Classes:    CPeerHolder
//
//-----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_PEERFACT_HXX_
#define X_PEERFACT_HXX_
#include "peerfact.hxx"
#endif

#ifndef X_PEERURLMAP_HXX_
#define X_PEERURLMAP_HXX_
#include "peerurlmap.hxx"
#endif

///////////////////////////////////////////////////////////////////////////////
//
//  Misc
//
///////////////////////////////////////////////////////////////////////////////

MtDefine(CPeerFactoryUrlMap,                CDoc,               "CPeerFactoryUrlMap")
MtDefine(CPeerFactoryUrlMap_aryFactories,   CPeerFactoryUrlMap, "CDoc::_aryFactories")


///////////////////////////////////////////////////////////////////////////////
//
//  Class:      CPeerFactoryUrlMap
//
///////////////////////////////////////////////////////////////////////////////

//+----------------------------------------------------------------------------
//
//  Member:       CPeerFactoryUrlMap constructor
//
//-----------------------------------------------------------------------------

CPeerFactoryUrlMap::CPeerFactoryUrlMap(CMarkup * pHostMarkup) :
    _UrlMap(CStringTable::CASEINSENSITIVE)
{
    Assert(pHostMarkup);
    _pHostMarkup = pHostMarkup;
    _pHostMarkup->SubAddRef();
}

//+----------------------------------------------------------------------------
//
//  Member:       CPeerFactoryUrlMap destructor
//
//-----------------------------------------------------------------------------

CPeerFactoryUrlMap::~CPeerFactoryUrlMap()
{
    int                 c;
    CPeerFactoryUrl **  ppFactory;

    for (c = _aryFactories.Size(), ppFactory = _aryFactories;
         c;
         c--, ppFactory++)
    {
        (*ppFactory)->Release();
    }

    _aryFactories.DeleteAll();

    _pHostMarkup->SubRelease();
}

//+----------------------------------------------------------------------------
//
//  Member:     CPeerFactoryUrlMap::StopDownloads
//
//-----------------------------------------------------------------------------

HRESULT
CPeerFactoryUrlMap::StopDownloads()
{
    HRESULT             hr = S_OK;
    int                 c;
    CPeerFactoryUrl **  ppFactory;

    for (c = _aryFactories.Size(), ppFactory = _aryFactories;
         c;
         c--, ppFactory++)
    {
        (*ppFactory)->StopBinding();
    }

    RRETURN (hr);
}

//+----------------------------------------------------------------------------
//
//  Member:       CPeerFactoryUrlMap::HasPeerFactoryUrl
//
//  This function looks for a factory for the given URL.  If it is there, it
//  returns the factory, and TRUE.  Otherwise, it returns FALSE.
//
//-----------------------------------------------------------------------------
BOOL
CPeerFactoryUrlMap::HasPeerFactoryUrl(LPTSTR pchUrl, CPeerFactoryUrl ** ppFactory)
{
    HRESULT hr;

    Assert (ppFactory);

    hr = THR_NOTRACE(_UrlMap.Find(pchUrl, (void**)ppFactory));
    if (S_OK == hr)
        return TRUE;

    *ppFactory = NULL;
    return FALSE;

}

//+----------------------------------------------------------------------------
//
//  Member:       CPeerFactoryUrlMap::EnsurePeerFactoryUrl
//
// (for more details see also comments in the beginning of peerfact.cxx file)
// this function modifies _aryFactories in the following way:
//  - if there already is a factory for the url,
//          then no change happens;
//  - if the url is in form "http://...foo.bla" or "#foo" (but not "#foo#bla"),
//          then it creates a new factory for the url
//  - if the url is in form "#foo#bla",
//          then it creates 2 new factories: one for "#foo" and one for "#foo#bla"
//
//-----------------------------------------------------------------------------

HRESULT
CPeerFactoryUrlMap::EnsurePeerFactoryUrl(LPTSTR pchUrl, CMarkup * pMarkup, CPeerFactoryUrl ** ppFactory)
{
    HRESULT             hr = S_OK;
    CPeerFactoryUrl *   pFactory;
    LPTSTR              pchUrlSecondPound;
    LPTSTR              pchTemp = NULL;

    Assert (ppFactory);

    if (HasPeerFactoryUrl(pchUrl, &pFactory))
        goto Cleanup; // done

    // factory for the url not found

    pchUrlSecondPound = (_T('#') == pchUrl[0]) ? StrChr(pchUrl + 1, _T('#')) : NULL;

    if (!pchUrlSecondPound)
    {
        // url in form "http://...foo.bla"  or "#foo", but not in form "#foo#bar"

        hr = THR(CPeerFactoryUrl::Create(pchUrl, _pHostMarkup, pMarkup, &pFactory));
        if (hr)
            goto Cleanup;
    }
    else
    {
        // url in form "#foo#bar"

        // ensure factory for "#foo"
        {
            // We have to copy the memory here, because the string we were given
            // may be read-only and our string table requires null-terminated strings
            pchTemp = (TCHAR *)MemAlloc( Mt(CPeerFactoryUrl), (pchUrlSecondPound - pchUrl + 1) * sizeof( TCHAR ) );
            if( !pchTemp )
                goto Cleanup;

            _tcsncpy( pchTemp, pchUrl, pchUrlSecondPound - pchUrl );
            pchTemp[pchUrlSecondPound - pchUrl] = _T('\0');

            hr = THR(EnsurePeerFactoryUrl(pchTemp, pMarkup, &pFactory));
            if (hr)
                goto Cleanup;
        }

        // clone factory for "#foo#bar" from factory for "#foo"

        hr = THR(pFactory->Clone(pchUrl, &pFactory));
        if (hr)
            goto Cleanup;
    }

    hr = THR(_aryFactories.Append(pFactory));
    if (hr)
        goto Cleanup;

    hr = THR(_UrlMap.Add(pchUrl, pFactory));

Cleanup:

    if (S_OK == hr)
        *ppFactory = pFactory;
    else
        *ppFactory = NULL;

    MemFree( pchTemp );

    RRETURN (hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\perhist.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994
//
//  File:       perhist.cxx
//
//  Contents:   IPersistHistory implementation
//
//  Classes:    CDoc (partial), CHistoryLoadCtx, CHistorySaveCtx
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_BOOKMARK_HXX_
#define X_BOOKMARK_HXX_
#include "bookmark.hxx"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_PERHIST_HXX_
#define X_PERHIST_HXX_
#include "perhist.hxx"
#endif

#ifndef X_TXTSITE_HXX_
#define X_TXTSITE_HXX_
#include "txtsite.hxx"
#endif

#ifndef X_OTHRGUID_H_
#define X_OTHRGUID_H_
#include "othrguid.h"
#endif

#ifndef X_EVENTOBJ_HXX_
#define X_EVENTOBJ_HXX_
#include "eventobj.hxx"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X_FRAME_HXX_
#define X_FRAME_HXX_
#include "frame.hxx"
#endif

#ifndef X_ROOTELEM_HXX_
#define X_ROOTELEM_HXX_
#include "rootelem.hxx"
#endif

MtDefine(CHistoryLoadCtx, Dwn, "CHistoryLoadCtx");
MtDefine(CHistoryLoadCtx_arySubstreams_pv, CHistoryLoadCtx, "CHistoryLoadCtx::_arySubstreams::_pv");
MtDefine(COptionArray, Dwn, "COptionArray");
MtDefine(COptionArray_aryOption_pv, COptionArray, "COptionArray::_aryOption::_pv");
MtDefine(COptionArrayItem, COptionArray, "COptionArray item");
MtDefine(LOADINFO_pbRequestHeaders, Dwn, "LOADINFO::pbRequestHeaders");
MtDefine(LoadFailureUrl,CMarkup, "CMarkup::LoadFailureUrl");

BOOL IsInIEBrowser(CDoc * pDoc);

//+------------------------------------------------------------------------
//
//  Class:      CDoc (IPersistHistory implementation)
//
//-------------------------------------------------------------------------

//+------------------------------------------------------------------------
//
//  Member:     CDoc::GetPositionCookie
//
//  Synopsis:   implementation of IPersistHistory::GetPositionCookie
//
//-------------------------------------------------------------------------
HRESULT
CDoc::GetPositionCookie(DWORD *pdwCookie)
{
    return _pWindowPrimary->Window()->GetPositionCookie(pdwCookie);
}

//+------------------------------------------------------------------------
//
//  Member:     CDoc::SetPositionCookie
//
//  Synopsis:   implementation of IPersistHistory::SetPositionCookie
//
//-------------------------------------------------------------------------
HRESULT
CDoc::SetPositionCookie(DWORD dwCookie)
{
    return _pWindowPrimary->Window()->SetPositionCookie(dwCookie);
}

//+------------------------------------------------------------------------
//
//  Member:     CDoc::SaveHistory
//
//  Synopsis:   implementation of IPersistHistory::SaveHistory
//
//-------------------------------------------------------------------------
HRESULT
CDoc::SaveHistory(IStream *pStream)
{
    RRETURN(_pWindowPrimary->Window()->SaveHistory(pStream));
}

//
// In LoadHistoryInternal sometimes we have the wrong value for fNonHTMLMimeType
// In code is designed for this to true for XML, but it is false. 
// In the XML case this is good because we end up remembering the filters HTML data,
// and it would be inefficient to FollowHyperLink.
//
// This method is designed to check the problematic case where we have a nonHTMLType 
// being recalled from history by the travellog. In this case certain nonHTML file types are 
// will break navigation. We know that VBD do. Unfortunately, at this point it the code we only have
// the URL on which to guess the mime type. In future version, we should store the source 
// files mime type. 
//
// For now we will use this function to test if we have mime type
// that is known to cause problems. 
//

BOOL IsKnownNonHTMLMime(const TCHAR * pszURL)
{
    const TCHAR * pszDot = NULL;
    const TCHAR * pszCurrent = pszURL;

    int nLen = 0;

    if (pszURL)
    {
        nLen = _tcslen(pszURL);

        for (int i=0; i < nLen; i++)
        {
            if ((*pszCurrent) == _TEXT('.'))
            {
                pszDot = pszCurrent;              // remember the last dot
            }                                     // before the ? or #
            else if ((*pszCurrent) == _TEXT('?') ||
                     (*pszCurrent) == _TEXT('#')) 
            {
                i = nLen;
            }

            pszCurrent++;
        }
    }

    if (pszDot == NULL) 
    {
        return FALSE;
    }

    // Use >=4 instead of ==4 to account for the query string or bookmark after the extension
    if (nLen - (pszDot - pszURL) >= 4)
    {
        if (_tcsnicmp(pszDot, 4, _T(".vbd"), -1) == 0)
        {
            return TRUE;
        }
    }

    return FALSE;
}

//+------------------------------------------------------------------------
//
//  Member:     CDoc::SaveHistory
//
//  Synopsis:   does SaveHistory but also takes an additional bool
//
//-------------------------------------------------------------------------
HRESULT
CMarkup::SaveHistoryInternal(IStream *pStream, DWORD dwOptions)
{
    HRESULT          hr          = S_OK;
    HRESULT          hr2         = S_OK;
    IStream *        pSubstream  = NULL;
    IStream *        pStmSource  = NULL;
    IMoniker *       pmkName = NULL;
    CHistorySaveCtx  hsc;
    DWORD            dwScrollPos = 0;
    DWORD            dwPosition;
    CLSID            clsidMk = {0};
    BOOL             fDoDefault = TRUE;
    CHtmCtx *        pHtmCtx = HtmCtx();
    THREADSTATE    * pts = GetThreadState();
    CMarkup::CLock   markupLock(this);
    COmWindowProxy * pWindowPrxy;
    CTaskLookForBookmark * pBookmarkTask = NULL;    

    if (!pStream)
        return E_POINTER;

    {
        CDataStream ds(pStream);
        IStream * pStmDirty = GetStmDirty();

        // save dirty stream
        if (pStmDirty)
        {
            ULARGE_INTEGER uliSize;

            hr = THR(ds.SaveDword(HISTORY_STMDIRTY));
            if (hr)
                goto Cleanup;

            hr = THR(ds.BeginSaveSubstream(&pSubstream));
            if (hr)
                goto Cleanup;

            hr = THR(pStmDirty->Seek(LI_ZERO.li, STREAM_SEEK_END, &uliSize));
            if (hr)
                goto Cleanup;

            hr = THR(pStmDirty->Seek(LI_ZERO.li, STREAM_SEEK_SET, NULL));
            if (hr)
                goto Cleanup;

            hr = THR(pStmDirty->CopyTo(pSubstream, uliSize, NULL, NULL));
            if (hr)
                goto Cleanup;

            pSubstream->Release();
            pSubstream = NULL;

            hr = THR(ds.EndSaveSubstream());
            if (hr)
                goto Cleanup;
        }
        // In the case of a document.open'ed doc, save the source
        else if (pHtmCtx && pHtmCtx->WasOpened())
        {
            hr = THR(ds.SaveDword(HISTORY_STMDIRTY));
            if (hr)
                goto Cleanup;

            hr = THR(ds.BeginSaveSubstream(&pSubstream));
            if (hr)
                goto Cleanup;

            if (!pHtmCtx->IsSourceAvailable())
                hr = THR(SaveToStream(pSubstream, 0, GetCodePage()));
            else
                hr = THR(pHtmCtx->CopyOriginalSource(pSubstream, 0));

            if (hr)
                goto Cleanup;

            pSubstream->Release();
            pSubstream = NULL;

            hr = THR(ds.EndSaveSubstream());
            if (hr)
                goto Cleanup;
        }

        // If the document was really just a repository for a refresh stream
        // then save the refresh stream
        if (pHtmCtx && pHtmCtx->IsKeepRefresh() && pHtmCtx->GetRefreshStream())
        {
            hr = THR(pHtmCtx->GetRefreshStream()->Clone(&pStmSource));
            if (hr)
                goto Cleanup;

            ULARGE_INTEGER uliSize;
            uliSize.HighPart = uliSize.LowPart = 0xFFFFFFFF;

            hr = THR(ds.SaveDword(HISTORY_STMREFRESH));
            if (hr)
                goto Cleanup;

            hr = THR(ds.BeginSaveSubstream(&pSubstream));
            if (hr)
                goto Cleanup;

            hr = THR(pStmSource->CopyTo(pSubstream, uliSize, NULL, NULL));
            if (hr)
                goto Cleanup;

            pSubstream->Release();
            pSubstream = NULL;

            pStmSource->Release();
            pStmSource = NULL;

            hr = THR(ds.EndSaveSubstream());
            if (hr)
                goto Cleanup;
        }

        if ((  pHtmCtx
            && pHtmCtx->FromMimeFilter())
            || (IsPrimaryMarkup() && Doc()->IsAggregated()))
        {
            // If original page came from a mime filter,
            // be sure to bind on apt when refreshing so that
            // urlmon can hook up the mime filter again

            hr = THR(ds.SaveDword(HISTORY_BINDONAPT));
            if (hr)
                goto Cleanup;
        }

        pmkName = GetNonRefdMonikerPtr();

        // TODO (JHarding): Should we even try creating this now?
        if( !pmkName )
            hr = CreateURLMoniker(NULL, CMarkup::GetUrl(this), &pmkName);
        else
            pmkName->AddRef();

        if (pmkName && S_OK != IsAsyncMoniker(pmkName))
        {
            hr = THR(ds.SaveDword(HISTORY_PMKNAME));
            if (hr)
                goto Cleanup;

            hr = THR(ds.SaveDataLater(&dwPosition, sizeof(hr2)));
            if (hr)
                goto Cleanup;

            hr2 = THR(pmkName->GetClassID(&clsidMk));

            hr = THR(ds.SaveData(&clsidMk, sizeof(CLSID)));
            if (hr)
                goto Cleanup;

            hr = THR(ds.BeginSaveSubstream(&pSubstream));
            if (hr)
                goto Cleanup;

            if (!hr2)
                hr2 = THR(pmkName->Save(pSubstream, FALSE));

            pSubstream->Release();
            pSubstream=NULL;

            hr = THR(ds.EndSaveSubstream());
            if (hr)
                goto Cleanup;

            hr = THR(ds.SaveDataNow(dwPosition, &hr2, sizeof(hr2)));
            if (hr)
                goto Cleanup;
        }
            // TODO (jbeda) hacking because
            // of PICS with window.open
        else if (!_fPICSWindowOpenBlank)
        {
            const TCHAR * pchUrl = GetUrl(this);

            if (pchUrl && *pchUrl)
            {
                hr = THR(ds.SaveDword(HISTORY_PCHURL));
                if (hr)
                    goto Cleanup;

                hr = THR(ds.SaveString((TCHAR*)pchUrl));
                if (hr)
                    goto Cleanup;
            }

            const TCHAR * pchUrlOriginal = GetUrlOriginal(this);

            if (pchUrlOriginal && *pchUrlOriginal)
            {
                hr = THR(ds.SaveDword(HISTORY_PCHURLORIGINAL));
                if (hr)
                    goto Cleanup;

                hr = THR(ds.SaveString((TCHAR*)pchUrlOriginal));
                if (hr)
                    goto Cleanup;
            }

            const TCHAR * pchUrlLocation = GetUrlLocation(this);

            if (pchUrlLocation && *pchUrlLocation)
            {
                hr = THR(ds.SaveDword(HISTORY_PCHURLLOCATION));
                if (hr)
                    goto Cleanup;

                hr = THR(ds.SaveString((TCHAR*)pchUrlLocation));
                if (hr)
                    goto Cleanup;
            }
        }

        // save postdata
        if (GetDwnPost() && GetDwnPost()->ShouldSave())
        {
            hr = THR(ds.SaveDword(HISTORY_POSTDATA));
            if (hr)
                goto Cleanup;

            hr = THR(ds.BeginSaveSubstream(&pSubstream));
            if (hr)
                goto Cleanup;

            hr = THR(CDwnPost::Save(GetDwnPost(), pSubstream));
            if (hr)
                goto Cleanup;

            hr = THR(ds.EndSaveSubstream());
            if (hr)
                goto Cleanup;

            pSubstream->Release();
            pSubstream = NULL;
        }

        CDwnDoc * pDwnDoc = GetDwnDoc();

        // save referers
        if (pDwnDoc)
        {
            if (pDwnDoc->GetDocReferer())
            {
                hr = THR(ds.SaveDword(HISTORY_PCHDOCREFERER));
                if (hr)
                    goto Cleanup;

                hr = THR(ds.SaveString((TCHAR *)pDwnDoc->GetDocReferer()));
                if (hr)
                    goto Cleanup;
            }

            if (pDwnDoc->GetSubReferer())
            {
                hr = THR(ds.SaveDword(HISTORY_PCHSUBREFERER));
                if (hr)
                    goto Cleanup;

                hr = THR(ds.SaveString((TCHAR *)pDwnDoc->GetSubReferer()));
                if (hr)
                    goto Cleanup;
            }
        }

        // Save Last-mod date of doc into history
        {
            FILETIME ftLastMod = GetLastModDate();
            hr = THR(ds.SaveDword(HISTORY_FTLASTMOD));
            if (hr)
                goto Cleanup;

            hr = THR(ds.SaveData(&ftLastMod, sizeof(FILETIME)));
            if (hr)
                goto Cleanup;
        }

        // Save echo headers as raw headers
        if (dwOptions & SAVEHIST_ECHOHEADERS)
        {
            BYTE *pb;
            ULONG cb;

            // TODO (johnbed) 03/26/98
            // Outlook 98 ends up somehow creating a new CDoc after
            // exec'ing a IDM_SAVEAS with a null _pHtmCtx. This code
            // is called while setting mshtml into edit mode.
            // There don't appear to be any problems with just falling
            // out here and continuing on.

            if (pHtmCtx)
            {
                pHtmCtx->GetRawEcho(&pb, &cb);

                if (pb && cb)
                {
                        hr = THR(ds.SaveDword(HISTORY_REQUESTHEADERS));

                        if (hr)
                                goto Cleanup;

                        hr = THR(ds.SaveDword(cb));

                        if (hr)
                                goto Cleanup;

                        hr = THR(ds.SaveData(pb, cb));

                        if (hr)
                                goto Cleanup;
                }
            }
        }

        // Save codepage of URL.
        hr = THR(ds.SaveDword(HISTORY_HREFCODEPAGE));
        if (hr)
            goto Cleanup;

        hr = THR(ds.SaveDword(GetURLCodePage()));
        if (hr)
            goto Cleanup;

        // Save default codepage of the document. Can be overridden by the shell, hlink etc.
        hr = THR(ds.SaveDword(HISTORY_CODEPAGE));
        if (hr)
            goto Cleanup;

        hr = THR(ds.SaveDword(GetCodePage()));
        if (hr)
            goto Cleanup;

        // if this markup is in a frame, save the Navigated bit of that frame so
        // that favorites can do the correct thing.
        if (HasWindowPending())
        {
            CWindow * pWindow = GetWindowPending()->Window();

            if (pWindow && pWindow->_fNavigated)
            {
                hr = THR(ds.SaveDword(HISTORY_NAVIGATED));
                if (hr)
                    goto Cleanup;
                hr = THR(ds.SaveDword(1));
                if (hr)
                    goto Cleanup;
            }
        }

        // provide oppurtunity to save user data, and cancel defualt
        // behavior
        if (dwOptions & SAVEHIST_INPUT)
        {
            NOTIFYTYPE      snType; 
            CNotification   nf;
            CMarkupBehaviorContext * pContext = NULL;

            // it he meta persist tag is not specified then do the default handling
            // see the coimment for the else clause for how history is handled when 
            //  the persistence XTag is enabled.
            CElement * pElemCurrent;
            long lSubCurrent;

            fDoDefault = !MetaPersistEnabled(htmlPersistStateHistory);
            pElemCurrent = Doc()->_pElemCurrent;
            lSubCurrent = Doc()->_lSubCurrent;

            THR(EnsureBehaviorContext(&pContext));
            
            // now worry about default/user input saving
            if (fDoDefault)
            {
                if (pElemCurrent->GetMarkup() == this)
                {
                    // Save the current site's index and tag

                    hr = THR(ds.SaveDword(HISTORY_CURRENTSITE));
                    if (hr)
                        goto Cleanup;

                    hr = THR(ds.SaveDword(pElemCurrent->GetSourceIndex()));
                    if (hr)
                        goto Cleanup;

                    hr = THR(ds.SaveDword(pElemCurrent->HistoryCode()));
                    if (hr)
                        goto Cleanup;

                    hr = THR(ds.SaveDword(lSubCurrent));
                    if (hr)
                        goto Cleanup;
                }    

                // now set up for the saving the control's values
                snType = NTYPE_SAVE_HISTORY_1;
            } // fDoDefault
            else
            {
                // now set up for the saving the control's values
                // using the persistence XTAG
                // The way that the persistence XTag works for history is that 
                // a SN_XTAGPERSISTHISTORY is broadcast. Elements with the History
                // XTag peer will repsond, by fireing their events, and by doing a 
                // BroadcastNotify(NTYPE_SAVE_HISTORY) on their scoped elements.  All this goes
                // into the stream under their ID.
                snType = NTYPE_XTAG_HISTORY_SAVE;
                // make sure this is cleared out..

                if (pContext)
                {
                    ClearInterface(&(pContext->_pXMLHistoryUserData));
                }
            }

            // save substreams by doing a BroadcastNotify
            hr = THR(ds.SaveDword(HISTORY_STMHISTORY));
            if (hr)
                goto Cleanup;

            hr = THR(ds.BeginSaveSubstream(&pSubstream));
            if (hr)
                goto Cleanup;

            hr = THR(hsc.Init(pSubstream));
            if (hr)
                goto Cleanup;

            ClearInterface(&pSubstream);

            hsc._dwOptions = dwOptions;
            nf.Initialize(
                snType, 
                Root(), 
                Root()->GetFirstBranch(),
                &hsc,
                0);
            Notify(&nf);

            hr = THR(hsc.Finish());
            if (hr)
                goto Cleanup;

            hr = THR(ds.EndSaveSubstream());
            if (hr)
                goto Cleanup;

            // now that the elements have all had their turn at saveing thier contents
            //  if the XTags saved a bucket of data, we need to save that too.
            if (snType==NTYPE_XTAG_HISTORY_SAVE && pContext && pContext->_pXMLHistoryUserData)
            {
                BSTR                bstrTemp = NULL;
                UINT                uSize    = 0;

                // get the text of the XML document
                hr = THR(pContext->_pXMLHistoryUserData->get_xml(&bstrTemp));
                if (hr)
                    goto LocalCleanup;

                // how big is the data?
                uSize = (1+SysStringLen(bstrTemp))*sizeof(OLECHAR);
                if (uSize < PERSIST_XML_DATA_SIZE_LIMIT)
                {
                    hr = THR(ds.SaveDword(HISTORY_USERDATA));
                    if (hr)
                        goto LocalCleanup;

                    hr = THR(ds.SaveString(bstrTemp));
                    if (hr) 
                        goto LocalCleanup;                
                }
LocalCleanup:
                SysFreeString(bstrTemp);
                // we don't need this around anymore
                ClearInterface(&(pContext->_pXMLHistoryUserData));
            }
        }

        //  Check for an active bookmark task. If we have one,
        //  use that instead of the current scroll position.

        pBookmarkTask = ( HasTransNavContext() ? 
                            GetTransNavContext()->_pTaskLookForBookmark : 
                            NULL );

        if(pBookmarkTask)
        {
            Assert(!(pBookmarkTask->_dwScrollPos && pBookmarkTask->_cstrJumpLocation));
            if(pBookmarkTask->_cstrJumpLocation)
            {
                // Save the document scroll position
                hr = THR(ds.SaveDword(HISTORY_BOOKMARKNAME));
                if (hr)
                    goto Cleanup;

                hr = THR(ds.SaveString((TCHAR *)pBookmarkTask->_cstrJumpLocation));
                if (hr)
                    goto Cleanup;
            }
            else if(pBookmarkTask->_dwScrollPos)
            {
                // Save the document scroll position
                hr = THR(ds.SaveDword(HISTORY_SCROLLPOS));
                if (hr)
                    goto Cleanup;

                hr = THR(ds.SaveDword(pBookmarkTask->_dwScrollPos));
                if (hr)
                    goto Cleanup;
            }
        }
        else if(dwOptions & SAVEHIST_INPUT)
        {
            // Save the document scroll position
            hr = THR(ds.SaveDword(HISTORY_SCROLLPOS));
            if (hr)
                goto Cleanup;

            IGNORE_HR(GetPositionCookie(&dwScrollPos));
            hr = THR(ds.SaveDword(dwScrollPos));
            if (hr)
                goto Cleanup;
        }

        // Save default codepage of the document. Can be overridden by the shell, hlink etc.
        hr = THR(ds.SaveDword(HISTORY_FONTVERSION));
        if (hr)
            goto Cleanup;

        hr = THR(ds.SaveDword(pts->_iFontHistoryVersion));  // save current font history version
        if (hr)
            goto Cleanup;

        // Save the document's direction. Can be overridden if a direction is explicitly given
        // in the HTML
        hr = THR(ds.SaveDword(HISTORY_DOCDIRECTION));
        if (hr)
            goto Cleanup;

        // TODO (jharding, scotrobe): The below line of code used to crash in stress 
        // because it was using HasWindow() to check for a window. HasWindow()
        // is returning TRUE (in stress) when there is no window. This code
        // now checks for the window by calling Window(). This will be changed
        // back to HasWindow() when the real culprit is found.
        //
        Assert(!HasWindow() || Window());
        pWindowPrxy = Window();

        WORD eHTMLDocDir = pWindowPrxy ? pWindowPrxy->Document()->_eHTMLDocDirection : htmlDirNotSet;

        hr = THR(ds.SaveData(&eHTMLDocDir, sizeof(WORD)));
        if (hr)
            goto Cleanup;

        // Save the window ID
        //
        if (pWindowPrxy)
        {
            hr = THR(ds.SaveDword(HISTORY_WINDOWID));
            if (hr)
                goto Cleanup;

            hr = THR(ds.SaveDword(pWindowPrxy->Window()->GetWindowIndex()));
            if (hr)
                goto Cleanup;

            const TCHAR * pchUrlOriginal = GetUrlOriginal(this);

            if (pWindowPrxy->Window()->_punkViewLinkedWebOC || 
                IsXML() || 
                _pDoc->_fDelegatedDownload ||
                IsKnownNonHTMLMime(pchUrlOriginal))
            {
                hr = THR(ds.SaveDword(HISTORY_NONHTMLMIMETYPE));
                if (hr)
                    goto Cleanup;
            }

            if (_pDoc->IsAggregated())
            {
                CStr & cstrName = pWindowPrxy->Window()->_cstrName;

                if (!cstrName.IsNull())
                {
                    hr = THR(ds.SaveDword(HISTORY_PCHFRAMENAME));
                    if (hr)
                        goto Cleanup;

                    hr = THR(ds.SaveString((TCHAR*)cstrName));
                    if (hr)
                        goto Cleanup;
                }
            }

            if (pWindowPrxy->Window()->_fNavFrameCreation)
            {             
                hr = THR(ds.SaveDword(HISTORY_FRAMECREATION));
                if (hr)
                    goto Cleanup;
            }

            if (pWindowPrxy->Window()->_fHttpErrorPage
                || _fServerErrorPage)
            {
                hr = THR(ds.SaveDword(HISTORY_ERRORPAGE));
                if (hr)
                    goto Cleanup;                
            }
        }
        else if (_fServerErrorPage)
        {
            hr = THR(ds.SaveDword(HISTORY_ERRORPAGE));
            if (hr)
                goto Cleanup;        
        }


        // Save creator url
        {
            const TCHAR * pchCreatorUrl = GetAAcreatorUrl();

            if (pchCreatorUrl && *pchCreatorUrl)
            {
                hr = THR(ds.SaveDword(HISTORY_CREATORURL));
                if (hr)
                    goto Cleanup;

                hr = THR(ds.SaveString((TCHAR*)pchCreatorUrl));
                if (hr)
                    goto Cleanup;
            }
        }       
            
        // Save history end marker
        hr = THR(ds.SaveDword(HISTORY_END));
        if (hr)
            goto Cleanup;
    }


Cleanup:
    ReleaseInterface(pSubstream);
    ReleaseInterface(pStmSource);
    ReleaseInterface(pmkName);

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CDoc::LoadHistory
//
//  Synopsis:   implementation of IPersistHistory::LoadHistory
//
//-------------------------------------------------------------------------
HRESULT
CDoc::LoadHistory(IStream *pStream, IBindCtx *pbc)
{
    HRESULT hr;

    hr = THR(_pWindowPrimary->Window()->LoadHistory(pStream, pbc));

    if (_state < OS_LOADED)
        _state = OS_LOADED;

    if (OK(hr))
    {
        if (State() < OS_RUNNING)
        {
            IGNORE_HR(TransitionTo(OS_RUNNING));
        }
        else if (State() >= OS_UIACTIVE)
        {
            SetActiveObject();
        }
    }

    RRETURN(hr);

}

//----------------------------------------------------------------
//****************************************************************
// Making changes to history ? Also update CWindow::GetURLFromIStreamHelper
//****************************************************************
//----------------------------------------------------------------

HRESULT
CMarkup::LoadHistoryHelper(IStream        * pStream,
                           IBindCtx       * pbc,
                           DWORD            dwBindf,
                           IMoniker       * pmkHint,
                           IStream        * pstmLeader,
                           CDwnBindData   * pDwnBindData,
                           CODEPAGE         codepage,
                           ULONG          * pulHistoryScrollPos,
                           TCHAR         ** ppchBookMarkName,
                           CDoc::LOADINFO * pLoadInfo,
                           BOOL           * pfNonHTMLMimeType)
{
    HRESULT         hr = S_OK;
    HRESULT         hr2;
    HISTORY_CODE    historyCode;
    DWORD           dwCodePage;
    CLSID           clsidMk;
    IStream        *pSubstream = NULL;    

    CDataStream ds(pStream);

    for (;;)
    {
        hr = THR(ds.LoadDword((DWORD*)&historyCode));
        if (hr)
            goto Cleanup;

        switch (historyCode)
        {
        case HISTORY_STMREFRESH:
            hr = THR(ds.LoadSubstream(&pSubstream));
            if (hr)
                goto Cleanup;

            // Yes, recursive call
            hr = THR(LoadHistoryHelper(pSubstream,
                                       pbc,
                                       dwBindf,
                                       pmkHint,
                                       pstmLeader,
                                       pDwnBindData,
                                       codepage,
                                       pulHistoryScrollPos,
                                       ppchBookMarkName,
                                       pLoadInfo,
                                       pfNonHTMLMimeType));

            ClearInterface(&pSubstream);

            goto Cleanup;
            break;

        case HISTORY_STMDIRTY:
            ClearInterface(&pLoadInfo->pstmDirty);
            hr = THR(ds.LoadSubstream(&pLoadInfo->pstmDirty));
            if (hr)
                goto Cleanup;
            break;

        case HISTORY_PCHFILENAME:
            hr = THR(ds.LoadString(&pLoadInfo->pchFile));
            if (hr)
                goto Cleanup;
            break;

        case HISTORY_PCHURL:
            hr = THR(ds.LoadString(&pLoadInfo->pchDisplayName));
            if (hr)
                goto Cleanup;
            break;

        case HISTORY_PCHURLORIGINAL:
            hr = THR(ds.LoadString(&pLoadInfo->pchUrlOriginal));
            if (hr)
                goto Cleanup;
            break;

        case HISTORY_PCHURLLOCATION:
            hr = THR(ds.LoadString(&pLoadInfo->pchLocation));
            if( hr )
                goto Cleanup;
            break;

        case HISTORY_NAVIGATED:
            { 
                DWORD dwNavigated = 0;

                hr = THR(ds.LoadDword(&dwNavigated));
                if (hr)
                    goto Cleanup;

                if (HasWindowPending())
                    GetWindowPending()->Window()->NoteNavEvent();
            }
            break;

        case HISTORY_PMKNAME:
            hr = THR(ds.LoadDword((DWORD*)&hr2));
            if (hr)
                goto Cleanup;

            hr = THR(ds.LoadData(&clsidMk, sizeof(CLSID)));
            if (hr)
                goto Cleanup;

            hr = THR(ds.LoadSubstream(&pSubstream));
            if (hr)
                goto Cleanup;

            ClearInterface(&pLoadInfo->pmk);

            if (hr2)
            {
                // failed to get clsid or save to stream before...
                // but on refresh, we have a live moniker we can use instead
                if (pmkHint)
                {
                    pmkHint->AddRef();
                    pLoadInfo->pmk = pmkHint;
                }
            }
            else
            {
                hr = THR(CoCreateInstance(clsidMk, NULL, CLSCTX_INPROC_SERVER, IID_IMoniker, (void**)&pLoadInfo->pmk));
                if (hr)
                    goto Cleanup;
                hr = THR(pLoadInfo->pmk->Load(pSubstream));
                if (hr)
                    goto Cleanup;
            }

            pSubstream->Release();
            pSubstream = NULL;
            break;
        
        case HISTORY_BINDONAPT:
            pLoadInfo->fBindOnApt = TRUE;
            break;

        case HISTORY_POSTDATA:

            hr = THR(ds.LoadSubstream(&pSubstream));
            if (hr)
                goto Cleanup;

            if (pLoadInfo->pDwnPost)
            {
                pLoadInfo->pDwnPost->Release();
                pLoadInfo->pDwnPost = NULL;
            }

            hr = THR(CDwnPost::Load(pSubstream, &pLoadInfo->pDwnPost));
            if (hr)
                goto Cleanup;

            pSubstream->Release();
            pSubstream = NULL;

            break;

        case HISTORY_PCHDOCREFERER:
            hr = THR(ds.LoadString(&pLoadInfo->pchDocReferer));
            if (hr)
                goto Cleanup;
            break;

        case HISTORY_PCHSUBREFERER:
            hr = THR(ds.LoadString(&pLoadInfo->pchSubReferer));
            if (hr)
                goto Cleanup;
            break;

        case HISTORY_FTLASTMOD:
            hr = THR(ds.LoadData(&pLoadInfo->ftHistory, sizeof(FILETIME)));
            if (hr)
                goto Cleanup;
            break;

        case HISTORY_CURRENTSITE:
            {
                CMarkupTransNavContext * ptnc = EnsureTransNavContext();
                if (!ptnc)
                {
                    hr = E_OUTOFMEMORY;
                    goto Cleanup;
                }

                hr = THR(ds.LoadDword((DWORD *)&ptnc->_historyCurElem.lIndex));
                if (hr)
                    goto Cleanup;
                hr = THR(ds.LoadDword(&ptnc->_historyCurElem.dwCode));
                if (hr)
                    goto Cleanup;
                hr = THR(ds.LoadDword((DWORD *)&ptnc->_historyCurElem.lSubDivision));
                if (hr)
                    goto Cleanup;

                ptnc->_fDoDelayLoadHistory = TRUE;
            }
            break;

        case HISTORY_SCROLLPOS:
            hr = THR(ds.LoadDword(pulHistoryScrollPos));
            if (hr)
                goto Cleanup;
            break;

        case HISTORY_BOOKMARKNAME:
            hr = THR(ds.LoadString(ppchBookMarkName));
            if ( hr )
                goto Cleanup;
            break;

        case HISTORY_STMHISTORY:
            ClearInterface(&pLoadInfo->pstmHistory);
            hr = THR(ds.LoadSubstream(&pLoadInfo->pstmHistory));
            if (hr)
                goto Cleanup;
            break;

        case HISTORY_HREFCODEPAGE:
            hr = THR(ds.LoadDword(&dwCodePage));
            if (hr)
                goto Cleanup;
            pLoadInfo->codepageURL = (CODEPAGE)dwCodePage;
            break;

        case HISTORY_CODEPAGE:
            hr = THR(ds.LoadDword(&dwCodePage));
            if (hr)
                goto Cleanup;
            pLoadInfo->codepage = (CODEPAGE)dwCodePage;
            break;

        case HISTORY_USERDATA :
            Assert(!pLoadInfo->pchHistoryUserData);
            hr = THR(ds.LoadString(&pLoadInfo->pchHistoryUserData));
            if (hr)
                goto Cleanup;
            break;

        case HISTORY_REQUESTHEADERS:
            MemFree(pLoadInfo->pbRequestHeaders);
            pLoadInfo->pbRequestHeaders = NULL;
            hr = THR(ds.LoadDword(&pLoadInfo->cbRequestHeaders));
            if (hr)
                goto Cleanup;
            pLoadInfo->pbRequestHeaders = (BYTE*)MemAlloc(Mt(LOADINFO_pbRequestHeaders), pLoadInfo->cbRequestHeaders);
            if (!pLoadInfo->pbRequestHeaders)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }
            hr = THR(ds.LoadData(pLoadInfo->pbRequestHeaders, pLoadInfo->cbRequestHeaders));
            if (hr)
                goto Cleanup;
            break;

        case HISTORY_FONTVERSION:
            {
                LONG iFontHistoryVersion = -1;
                hr = THR(ds.LoadDword((DWORD *) &iFontHistoryVersion));
                if (hr)
                    goto Cleanup;
                IGNORE_HR(SetFontHistoryIndex(iFontHistoryVersion));
                break;
            }

        case HISTORY_DOCDIRECTION:
            hr = THR(ds.LoadData(&pLoadInfo->eHTMLDocDirection, sizeof(WORD)));
            if (hr)
                goto Cleanup;
            break;

        case HISTORY_WINDOWID:
            { 
                DWORD dwWindowID = 0;

                hr = THR(ds.LoadDword(&dwWindowID));
                if (hr)
                    goto Cleanup;

                if (HasWindowPending())
                    GetWindowPending()->Window()->SetWindowIndex(dwWindowID);
            }
            break;

        case HISTORY_NONHTMLMIMETYPE:
            if (pfNonHTMLMimeType)
                *pfNonHTMLMimeType = TRUE;
            break;
            
        case HISTORY_FRAMECREATION:
            
            if (HasWindowPending())
               GetWindowPending()->Window()->_fNavFrameCreation = TRUE;
            break;

        case HISTORY_CREATORURL:
            {
                TCHAR * pchCreatorUrl = NULL;
                  
                hr = THR(ds.LoadString(&pchCreatorUrl));
                if (hr)
                    goto Cleanup;
                
                if (pchCreatorUrl && *pchCreatorUrl)
                    SetAAcreatorUrl (pchCreatorUrl);

                delete pchCreatorUrl;
            }
            break;

        case HISTORY_ERRORPAGE:
            _fServerErrorPage = TRUE;
            break;

        case HISTORY_PCHFRAMENAME:
            {
                LPTSTR pchFrameName = NULL;

                hr = THR(ds.LoadString(&pchFrameName));
                if (hr)
                    goto Cleanup;

                if (HasWindowPending())
                {
                    IGNORE_HR(GetWindowPending()->Window()->_cstrName.Set(pchFrameName));
                }

                MemFreeString(pchFrameName);

                break;
            }        
        
        case HISTORY_END:
            goto Cleanup;
#if DBG==1
        default:
            AssertSz( FALSE, "Unknown code found in history!" );
            break;
#endif // DBG
        }
    }

Cleanup:
    ClearInterface(&pSubstream);
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CDoc::LoadHistoryInternal
//
//  Synopsis:   Does a LoadHistory; but also takes BINDF flags
//
//-------------------------------------------------------------------------
HRESULT
CMarkup::LoadHistoryInternal(IStream      * pStream,
                             IBindCtx     * pbc,
                             DWORD          dwBindf,
                             IMoniker     * pmkHint,
                             IStream      * pstmLeader,
                             CDwnBindData * pDwnBindData,
                             CODEPAGE       codepage,
                             CElement     * pElementMaster, /*=NULL*/
                             DWORD          dwFlags, /* = 0 */
                             const TCHAR *  pchName /*=NULL*/)

{
    HRESULT          hr                 = S_OK;
    CDoc::LOADINFO   LoadInfo           = { 0 };
    IStream        * pSubstream         = NULL;
    ULONG            ulHistoryScrollPos = 0;
    TCHAR          * pchBookMarkName    = NULL;
    BOOL             fNonHTMLMimeType   = FALSE;
    BOOL             fCancel            = FALSE;
    COmWindowProxy * pOmWindowPending   = GetWindowPending();

    const TCHAR * pchFrameName = NULL;

    if(pOmWindowPending && pOmWindowPending->Window()->_cstrName)
    {
        pchFrameName = pOmWindowPending->Window()->_cstrName;
    }
    else
    {
        pchFrameName = pchName;
    }

    Assert(!HasTransNavContext() || GetTransNavContext()->_historyCurElem.lIndex == -1L);

    _fSafeToUseCalcSizeHistory = TRUE;

    if (!pStream)
        RRETURN(E_POINTER);

    // Handle refresh
    LoadInfo.dwBindf = dwBindf;

    LoadInfo.pElementMaster = pElementMaster;

    // In the simplest form of refresh, we don't want a codepage switch to occur.
    LoadInfo.fNoMetaCharset = 0 == (dwBindf & (BINDF_RESYNCHRONIZE|BINDF_GETNEWESTVERSION));

    // Remember original history stream in case we need to replay it after failure
    hr = THR(pStream->Clone(&LoadInfo.pstmRefresh));
    if (hr)
        goto Cleanup;

    hr = LoadHistoryHelper(pStream,
                           pbc, 
                           dwBindf, 
                           pmkHint, 
                           pstmLeader, 
                           pDwnBindData, 
                           codepage,
                           &ulHistoryScrollPos,
                           &pchBookMarkName,
                           &LoadInfo,
                           &fNonHTMLMimeType);

    if (pOmWindowPending && (dwFlags & CDoc::FHL_RESTARTLOAD))
    {
       pOmWindowPending->Window()->_fNavFrameCreation = TRUE;
    }

    if (hr)
        goto Cleanup;

    if (   !_fInRefresh
        && !fNonHTMLMimeType
        && pOmWindowPending
        && !(Doc()->_fStartup && pOmWindowPending->Markup()->IsPrimaryMarkup())
        && !(dwFlags & CDoc::FHL_RESTARTLOAD))
    {
        TCHAR * pchUrl = NULL;

        if (!LoadInfo.pchDisplayName && LoadInfo.pmk)
        {
            IGNORE_HR(LoadInfo.pmk->GetDisplayName(LoadInfo.pbctx, NULL, &pchUrl));
        }

        _pDoc->_webOCEvents.BeforeNavigate2(pOmWindowPending,
                                            &fCancel,
                                            LoadInfo.pchDisplayName ? LoadInfo.pchDisplayName : pchUrl,
                                            LoadInfo.pchLocation,
                                            pchFrameName,
                                            NULL,
                                            0,
                                            NULL,
                                            !(dwFlags & CDoc::FHL_FRAMECREATION));
        CoTaskMemFree(pchUrl);

        if (fCancel)
            goto Cleanup;
    }

    if (_fServerErrorPage)
    {
        //
        // Tell shdocvw about the error page so it doesn't add it to history
        //
        
        NoteErrorWebPage();
    }
    
    if (fNonHTMLMimeType)
    {
        if (LoadInfo.pchDisplayName)
        {
            IGNORE_HR(Doc()->FollowHyperlink(LoadInfo.pchDisplayName,
                                             NULL,
                                             NULL,
                                             LoadInfo.pDwnPost,
                                             LoadInfo.pDwnPost ? TRUE : FALSE,
                                             NULL,
                                             FALSE,
                                             pOmWindowPending,
                                             NULL,
                                             0,
                                             ERROR_SUCCESS,
                                             FALSE,
                                             NULL,
                                             FALSE,
                                             (dwFlags | CDoc::FHL_LOADHISTORY),
                                             pchFrameName));
            goto Cleanup;
        }
        else if (LoadInfo.pmk)
        {
            TCHAR * pchTask = NULL;

            if (S_OK == LoadInfo.pmk->GetDisplayName(LoadInfo.pbctx, NULL, &pchTask))
            {
                IGNORE_HR(Doc()->FollowHyperlink(pchTask,
                                             NULL,
                                             NULL,
                                             LoadInfo.pDwnPost,
                                             LoadInfo.pDwnPost ? TRUE : FALSE,
                                             NULL,
                                             FALSE,
                                             pOmWindowPending,
                                             NULL,
                                             0,
                                             ERROR_SUCCESS,
                                             FALSE,
                                             NULL,
                                             FALSE,
                                             (dwFlags | CDoc::FHL_LOADHISTORY),
                                             pchFrameName));
                CoTaskMemFree(pchTask);
            }
            goto Cleanup;
        }
    }

    if (LoadInfo.pDwnPost && (LoadInfo.dwBindf & (BINDF_RESYNCHRONIZE | BINDF_GETNEWESTVERSION)))
    {
        int iAnswer = 0;

        IGNORE_HR(Doc()->ShowMessage(&iAnswer, MB_RETRYCANCEL | MB_ICONEXCLAMATION, 0, IDS_REPOSTFORMDATA));
        if (iAnswer == IDCANCEL)
        {
            LoadInfo.dwBindf &= ~(BINDF_RESYNCHRONIZE | BINDF_GETNEWESTVERSION | BINDF_PRAGMA_NO_CACHE);
            // NOTE: BINDF_OFFLINEOPERATION is set for the doc only in LoadFromInfo
        }
    }

    // override codepage
    if (codepage)
        LoadInfo.codepage = codepage;

    // Fill in/replace moniker
    if (LoadInfo.pchDisplayName && !LoadInfo.pmk)
    {
        hr = THR(CreateURLMoniker(NULL, LoadInfo.pchDisplayName, &LoadInfo.pmk));
        if (hr)
            goto Cleanup;
    }

    LoadInfo.pstmLeader = pstmLeader;
    LoadInfo.pDwnBindData = pDwnBindData;
    LoadInfo.pbctx = pbc;

    Doc()->_fInIEBrowser = IsInIEBrowser(Doc());

    // Fill in history substream
    hr = THR(LoadFromInfo(&LoadInfo,dwFlags));
    if (hr)
        goto Cleanup;

    if (Doc()->IsPrintDialogNoUI()) 
    {
        // don't scroll to anyplace if printing
        goto Cleanup;
    }

    // Scroll to the right place

    if ( pchBookMarkName )
    {
        hr = THR(NavigateHere(0, pchBookMarkName, 0, TRUE));
    }
    else
    {
        hr = THR(SetPositionCookie(ulHistoryScrollPos));
    }

    if (hr)
        goto Cleanup;

Cleanup:
    ReleaseInterface(LoadInfo.pstmRefresh);
    ReleaseInterface(LoadInfo.pstmDirty);
    MemFree(LoadInfo.pchFile);
    MemFree(LoadInfo.pchDisplayName);
    MemFree(LoadInfo.pchUrlOriginal);
    MemFree(LoadInfo.pchLocation);
    MemFree(LoadInfo.pchDocReferer);
    MemFree(LoadInfo.pchSubReferer);
    MemFree(LoadInfo.pbRequestHeaders);
    delete pchBookMarkName;
    ReleaseInterface(LoadInfo.pmk);
    if (LoadInfo.pDwnPost)
        LoadInfo.pDwnPost->Release();
    ReleaseInterface(LoadInfo.pstmHistory);
    MemFreeString(LoadInfo.pchHistoryUserData);
    ReleaseInterface(pSubstream);

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CMarkup::GetLoadHistoryStream
//
//  Synopsis:   Retrieves the history substream to load from, if any, that
//              corresponds to the given history index.
//
//              No stream will be returned if the dwCheck passed in
//              does not match the dwCheck passed into the saver.
//
//              *ppStream can be return NULL even for S_OK if there
//              is no substream for the specified index.
//
//-------------------------------------------------------------------------
HRESULT
CMarkup::GetLoadHistoryStream(ULONG index, DWORD dwCheck, IStream **ppStream)
{
    HRESULT hr = S_OK;

    *ppStream = NULL;

    if (HasTransNavContext())
    {
        CMarkupTransNavContext * ptnc = GetTransNavContext();

        hr = THR(ptnc->_HistoryLoadCtx.GetLoadStream(index, dwCheck, ppStream));

        EnsureDeleteTransNavContext(ptnc);
    }

    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CMarkup::ClearLoadHistoryStreams
//
//  Synopsis:   Clears the history streams; called before parsing the
//              document if we know we should not restore the user
//              state.
//
//-------------------------------------------------------------------------
void
CMarkup::ClearLoadHistoryStreams()
{
    if (HasTransNavContext())
    {
        CMarkupTransNavContext * ptnc = GetTransNavContext();

        ptnc->_HistoryLoadCtx.Clear();
        EnsureDeleteTransNavContext(ptnc);
    }
}

//+------------------------------------------------------------------------
//
//  Member:     CMarkup::LoadSlaveMarkupHistory()
//
//  Synopsis:   Load Slave Markup history
//
//-------------------------------------------------------------------------

HRESULT
CMarkup::LoadSlaveMarkupHistory()
{
    HRESULT hr = S_OK;

    CNotification           nf;
    CMarkupTransNavContext *ptnc;
    CDoc::LOADINFO          LoadInfo = { 0 };
    ULONG                   ulHistoryScrollPos = 0;
    TCHAR                  *pchBookMarkName = NULL;
    IStream                *pStreamMaster = NULL;
    CElement               *pElementMaster;
    CMarkup                *pMarkupMaster;

    if (!Root()->HasMasterPtr())
        goto Cleanup;

    AssertSz(!IsPrimaryMarkup(), "should not be called in primary Markup");

    pElementMaster = Root()->GetMasterPtr();
    pMarkupMaster  = pElementMaster->GetMarkup();

    if (   !_fLoadHistoryReady
        || !pMarkupMaster || !pMarkupMaster->HasTransNavContext())
        goto Cleanup;

    ptnc = EnsureTransNavContext();
    if (!ptnc)
        goto Cleanup;

    hr = THR(pMarkupMaster->GetLoadHistoryStream((0xF000000 | pElementMaster->GetSourceIndex()),
                                                 pElementMaster->HistoryCode(),
                                                 &pStreamMaster));
    if (FAILED(hr) || !pStreamMaster)
        goto Cleanup;

    hr = THR(pStreamMaster->Seek(LI_ZERO.li, STREAM_SEEK_SET, NULL));
    if (hr)
        goto Cleanup;

    hr = THR(LoadHistoryHelper(pStreamMaster,
                               0, 
                               0, 
                               0, 
                               0, 
                               0, 
                               0,
                               &ulHistoryScrollPos,
                               &pchBookMarkName,
                               &LoadInfo,
                               NULL));

    if (hr)
        goto Cleanup;

    if (!HasWindowPending() && LoadInfo.pchHistoryUserData)
    {
        CMarkupBehaviorContext * pContext = NULL;

        if (S_OK == EnsureBehaviorContext(&pContext))
        {
            hr = pContext->_cstrHistoryUserData.Set(LoadInfo.pchHistoryUserData);
        }
    }

    if (    !LoadInfo.pstmHistory
        ||  !OK(ptnc->_HistoryLoadCtx.Init(LoadInfo.pstmHistory)))
    {
        ptnc->_HistoryLoadCtx.Clear();
    }
    else
    {
        ptnc->_fDoDelayLoadHistory = TRUE;
        nf.DelayLoadHistory(Root());
        Notify(&nf);
    }
    // Scroll to the right place
    if ( pchBookMarkName )
    {
        hr = THR(NavigateHere(0, pchBookMarkName, 0, TRUE));
    }
    else if (HasWindowPending())
    {
        hr = THR(SetPositionCookie(ulHistoryScrollPos));
    }

    EnsureDeleteTransNavContext( ptnc );

Cleanup:
    MemFree(LoadInfo.pchFile);
    MemFree(LoadInfo.pchDisplayName);
    MemFree(LoadInfo.pchUrlOriginal);
    MemFree(LoadInfo.pchLocation);
    MemFree(LoadInfo.pchDocReferer);
    MemFree(LoadInfo.pchSubReferer);
    MemFree(LoadInfo.pbRequestHeaders);
    ReleaseInterface(LoadInfo.pmk);
    delete pchBookMarkName;
    if (LoadInfo.pDwnPost)
        LoadInfo.pDwnPost->Release();
    ReleaseInterface(LoadInfo.pstmHistory);
    if (LoadInfo.pchHistoryUserData)
        MemFreeString(LoadInfo.pchHistoryUserData);
    ReleaseInterface(pStreamMaster);

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Class:      CHistoryLoadCtx
//
//-------------------------------------------------------------------------

//+------------------------------------------------------------------------
//
//  Member:     CHistoryLoadCtx::dtor
//
//  Synopsis:   destructor - release any unused streams
//
//-------------------------------------------------------------------------
CHistoryLoadCtx::~CHistoryLoadCtx()
{
    Clear();
}

//+------------------------------------------------------------------------
//
//  Member:     CHistoryLoadCtx::Clear
//
//  Synopsis:   Clears and releases the substreams and bind ctx
//
//-------------------------------------------------------------------------
void CHistoryLoadCtx::Clear()
{
    int c;

    for (c = _arySubstreams.Size(); c;)
    {
        c--;
        ReleaseInterface(_arySubstreams[c].pStream);
    }

    _arySubstreams.DeleteAll();
    _cCountZeroed = 0;
    _iLastFound = 0;
}

//+------------------------------------------------------------------------
//
//  Member:     CHistoryLoadCtx::Init
//
//  Synopsis:   Loads the part of the history stream which contains
//              substreams.
//
//              Breaks the stream into substreams and sorts and stores
//              them by index.
//
//-------------------------------------------------------------------------
HRESULT CHistoryLoadCtx::Init(IStream *pStream)
{
    CDataStream ds(pStream);
    HRESULT hr;
    ULONG cSubstreams, c;
    DWORD dwCheck;


    hr = THR(ds.LoadDword(&cSubstreams));
    if (hr)
        goto Cleanup;

#if DBG==1
    {
        int cDbg = _arySubstreams.Size();
        SubstreamEntry * pEnt = _arySubstreams;
        for ( ; cDbg > 0; cDbg--, pEnt++)
        {
            Assert( pEnt->pStream == NULL );
        }
    }
#endif

    hr = THR(_arySubstreams.Grow(cSubstreams));
    if (hr)
        goto Cleanup;

    memset(_arySubstreams, 0, sizeof(SubstreamEntry) * cSubstreams);

    for (c=0; c < cSubstreams; c++)
    {
        DWORD    index;
        IStream *pSubstream;

        hr = THR(ds.LoadDword(&index));
        if (hr)
            goto Cleanup;

        hr = THR(ds.LoadDword(&dwCheck));
        if (hr)
            goto Cleanup;

        hr = THR(ds.LoadSubstream(&pSubstream));
        if (hr)
            goto Cleanup;

        if (_arySubstreams[c].pStream)
        {
            Assert(0);
            pSubstream->Release();
        }
        else
        {
            _arySubstreams[c].pStream = pSubstream;
            _arySubstreams[c].dwCheck = dwCheck;
            _arySubstreams[c].uCookieIndex = index;
        }

        pSubstream = NULL;
    }

    _cCountZeroed = 0;
    _iLastFound = 0;

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHistoryLoadCtx::GetLoadStream
//
//  Synopsis:   Retrieves the substream, if any, that corresponds to the
//              given index.
//
//              *ppStream can be return NULL even for S_OK if there
//              is no substream for the specified index
//
//-------------------------------------------------------------------------
HRESULT CHistoryLoadCtx::GetLoadStream(ULONG index, DWORD dwCheck, IStream **ppStream)
{
    ULONG i;
    ULONG uStart = _iLastFound;
    ULONG uEnd = (unsigned)_arySubstreams.Size();
    BOOL  fBottomSearch = FALSE;

    if (!ppStream)
        goto Cleanup;

    *ppStream = NULL;

    // although we are doing a linear search, 2 things make the expected
    // performance to be a constant time algorithm. First the elements save and load
    // their data in source order, thus the keys are naturally ordered (by the save).
    // for loading, we're accessed in source order so by remembering the iLastFound 
    // position we expect to find the next element with only a single probe.
    //  The second thing that helps our performance in not deleting the data element
    // until the whole thing has been zeroed.  we *should* never have to search
    // the front part of the list

SearchForIt:
    // first time around we search the top (expect success)
    for (i=uStart; i < uEnd; i++)
    { 
        if ( i >= (unsigned)_arySubstreams.Size())
            goto Cleanup;

        if ((_arySubstreams[i].uCookieIndex == index) &&
            (_arySubstreams[i].dwCheck == dwCheck))
        {
            // we found the substream
            *ppStream = _arySubstreams[i].pStream;
            if (*ppStream)
            {
                // remember the found position so that the next
                // search will be faster.
                _iLastFound = i+1;

                // Transfer ref from _ary to *ppStream
                // adn remove this entry from the list
                _arySubstreams[i].pStream = NULL;
                _arySubstreams[i].dwCheck == -1;
                _arySubstreams[i].uCookieIndex=0;  // cooresponds to HTML element and is 
                                                   // unlikely to be legal
                _cCountZeroed++;
                if (_cCountZeroed == (unsigned)_arySubstreams.Size())
                {
#if DBG==1
                    {
                        int cDbg = _arySubstreams.Size();
                        SubstreamEntry * pEnt = _arySubstreams;
                        for ( ; cDbg > 0; cDbg--, pEnt++)
                        {
                            Assert( pEnt->pStream == NULL );
                        }
                    }
#endif
                    _arySubstreams.DeleteAll();
                    _cCountZeroed=0;
                    _iLastFound = 0;
                }
            }
            // found == true
            goto Cleanup;
        }
    }
    if (fBottomSearch)
        goto Cleanup;  // not found

    // not in the expected part.. be paranoid and search the bottom
    uStart = 0;
    uEnd = _iLastFound;
    fBottomSearch = TRUE;
    goto SearchForIt;

Cleanup:
    return(S_OK);
}

//+------------------------------------------------------------------------
//
//  Class:      CHistorySaveCtx
//
//-------------------------------------------------------------------------

//+------------------------------------------------------------------------
//
//  Member:     CHistorySaveCtx::Init
//
//  Synopsis:   Begins saving to the part of the history stream which
//              contains substreams.
//
//              Must be matched by a call to Finish() to complete the save
//
//-------------------------------------------------------------------------
HRESULT CHistorySaveCtx::Init(IStream *pStream)
{
    HRESULT hr;

    _ds.Init(pStream);

    hr = THR(_ds.SaveDataLater(&_dwPoscSubstreams, sizeof(DWORD)));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHistorySaveCtx::BeginSaveStream
//
//  Synopsis:   Begins saving to a substream with the specified index
//              The index is most likely the sourceIndex of the element 
//              that wants to save into the substream,
//
//              The returned pStream has a ref (it must be released by
//              the caller).
//
//              Must be matched by a call to EndSaveSubstream()
//
//-------------------------------------------------------------------------
HRESULT CHistorySaveCtx::BeginSaveStream(DWORD dwCookieIndex, DWORD dwCheck, IStream **ppStream)
{
    HRESULT hr;

    _cSubstreams++;

    hr = THR(_ds.SaveDword(dwCookieIndex));
    if (hr)
        goto Cleanup;

    hr = THR(_ds.SaveDword(dwCheck));
    if (hr)
        goto Cleanup;

    hr = THR(_ds.BeginSaveSubstream(ppStream));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHistorySaveCtx::EndSaveStream
//
//  Synopsis:   Finishes the saving operation for a single substream
//
//-------------------------------------------------------------------------
HRESULT CHistorySaveCtx::EndSaveStream()
{
    HRESULT hr;

    hr = THR(_ds.EndSaveSubstream());
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHistorySaveCtx::Finish
//
//  Synopsis:   Finishes the entire saving operation
//
//-------------------------------------------------------------------------
HRESULT CHistorySaveCtx::Finish()
{
    HRESULT hr;

//    hr = THR(_ds.SaveDataNow(_dwPosiMax, &_iMax, sizeof(DWORD)));
//    if (hr)
//        goto Cleanup;

    hr = THR(_ds.SaveDataNow(_dwPoscSubstreams, &_cSubstreams, sizeof(DWORD)));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CDoc::LoadFailureUrl
//
//  Synopsis:   Does a very simple load into the doc
//
//-------------------------------------------------------------------------
HRESULT 
CMarkup::LoadFailureUrl(TCHAR *pchUrl, IStream *pstmRefresh)
{
    CDoc::LOADINFO LoadInfo = { 0 };
    HRESULT hr;
    CMarkup* pMarkupNew = NULL;
    TCHAR * pchOriginalUrl = NULL;
    
    hr = CreateURLMoniker(NULL, pchUrl, &LoadInfo.pmk);
    if (hr || !LoadInfo.pmk)
        goto Cleanup;

    LoadInfo.pchDisplayName = pchUrl;

    LoadInfo.pstmRefresh = pstmRefresh;
    LoadInfo.fKeepRefresh = TRUE;

    //
    // Store the original url
    //
    hr = THR(MemAllocString(Mt(LoadFailureUrl), (TCHAR*)CMarkup::GetUrl(this), &pchOriginalUrl));
    if (hr)
        goto Cleanup;

    LoadInfo.fDontUpdateTravelLog = TRUE;

    //TODO (carled, scotrobe) - this hack for IsPrimary should be removed.
    // To do this, and fix the memory-leak/Assert in bug 106014, this function needs
    // to create a NEW markup for the failure URL, and then NEW markup needs to 
    // replace the current one (SwitchMarkup?).  This will allow the current one 
    // to be released and not to leak.  This is what CDoc::LoadFromINfo does, 
    // and that is why the hack stops the memory leak. 

    if (IsPrimaryMarkup())
        hr = Doc()->LoadFromInfo(&LoadInfo, & pMarkupNew);
    else
    {
        hr = LoadFromInfo(&LoadInfo);
        pMarkupNew = this;
    }    
    if (hr)
        goto Cleanup;

    Assert( pMarkupNew );
    hr = THR( pMarkupNew->SetUrlOriginal( pchOriginalUrl ));
    
Cleanup:
    RRETURN(hr);
}



//+------------------------------------------------------------------------
//
//  Member:     COptionArray::QueryInterface
//
//  Synopsis:   Simple QI Impl
//
//-------------------------------------------------------------------------
STDMETHODIMP
COptionArray::QueryInterface(REFIID iid, void **ppv)
{
    if (iid == IID_IUnknown || iid == _iid)
        *ppv = (IOptionArray *)this;
    else
    {
        *ppv = NULL;
        return(E_NOINTERFACE);
    }

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Member:     COptionArray::AddRef
//
//  Synopsis:   Simple AddRef
//
//-------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
COptionArray::AddRef()
{
    return(super::AddRef());
}

//+------------------------------------------------------------------------
//
//  Member:     COptionArray::Release
//
//  Synopsis:   Simple Release
//
//-------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
COptionArray::Release()
{
    return(super::Release());
}


//+------------------------------------------------------------------------
//
//  Member:     COptionArray::~COptionArray
//
//  Synopsis:   Deletes all allocated memory
//
//-------------------------------------------------------------------------

COptionArray::~COptionArray()
{
    Option *pop;
    int c;

    for (pop = _aryOption, c = _aryOption.Size(); c; pop++, c--)
    {
        if (pop->cb > sizeof(DWORD))
        {
            MemFree(pop->pv);
        }
    }

    _aryOption.DeleteAll();
}

//+------------------------------------------------------------------------
//
//  Member:     COptionArray::QueryOption
//
//  Synopsis:   Copies the stored data to the buffer.
//
//              pBuffer is the buffer
//              *pcbBuf indicates the size of the incoming buffer
//
//              If pBuffer is NULL, *pcbBuf is set to the size of the
//              stored data (zero if no data has been stored) and S_OK
//              is returned.
//
//              If *pcbBuf is too small to copy all the data, it is set
//              to the required size and an error is returned.
//
//              If the buffer is big enough (or if no data was stored),
//              *pcbBuf is set to the size of the data and S_OK
//              is returned.
//
//-------------------------------------------------------------------------
STDMETHODIMP
COptionArray::QueryOption(DWORD dwOption, LPVOID pBuffer, ULONG *pcbBuf)
{
    ULONG index;
    ULONG cb;
    ULONG cbBuf = *pcbBuf;
    HRESULT hr = S_OK;

    if (!IndexFromOption(&index, dwOption))
    {
        *pcbBuf = 0;
        goto Cleanup;
    }

    cb = _aryOption[index].cb;
    *pcbBuf = cb;

    if (!pBuffer)
        goto Cleanup;

    if (cbBuf < cb)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    if (cb <= sizeof(DWORD))
    {
        memcpy(pBuffer, &(_aryOption[index].pv), cb);
    }
    else
    {
        memcpy(pBuffer, _aryOption[index].pv, cb);
    }

Cleanup:

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     COptionArray::SetOption
//
//  Synopsis:   Stores the specified data
//
//              Overwrites any data that is stored at the same index.
//
//-------------------------------------------------------------------------
STDMETHODIMP
COptionArray::SetOption(DWORD dwOption, LPVOID pBuffer, DWORD cbBuf)
{
    ULONG index;
    void *pvNew = NULL;
    Option op;
    HRESULT hr = S_OK;

    if (cbBuf > sizeof(DWORD))
    {
        pvNew = MemAlloc(Mt(COptionArrayItem), cbBuf);
        if (!pvNew)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        memcpy(pvNew, pBuffer, cbBuf);
    }

    op.dwOption = dwOption;
    op.cb = cbBuf;
    if (!pvNew)
        memcpy(&op.pv, pBuffer, cbBuf);
    else
        op.pv = pvNew;

    if (!IndexFromOption(&index, dwOption))
    {
        hr = THR(_aryOption.InsertIndirect(index, &op));
        if (hr)
            goto Cleanup;
    }
    else
    {
        if (_aryOption[index].cb > sizeof(DWORD))
        {
            MemFree(_aryOption[index].pv);
        }
        memcpy(&_aryOption[index], &op, sizeof(Option));
    }

    pvNew = NULL;

Cleanup:

    MemFree(pvNew);
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     COptionArray::IndexFromDword
//
//  Synopsis:   Efficient binary search
//
//-------------------------------------------------------------------------
BOOL
COptionArray::IndexFromOption(ULONG *pindex, DWORD dwOption)
{
    ULONG min;
    ULONG max;
    ULONG mid;
    ULONG imin;
    ULONG imax;
    ULONG imid;

    if (!_aryOption.Size() || dwOption > (_aryOption[_aryOption.Size()-1].dwOption))
    {
        *pindex = _aryOption.Size();
        return FALSE;
    }

    imin = 0;
    min = _aryOption[0].dwOption;

    imax = _aryOption.Size() - 1;
    max = _aryOption[imax].dwOption;

    while (max - min > imax - imin)
    {
        imid = (imax + imin) / 2;
        mid = _aryOption[imid].dwOption;

        if (dwOption <= mid)
        {
            imax = imid;
            max = mid;
        }
        else
        {
            imin = imid + 1;
            min = _aryOption[imin].dwOption;
        }
    }

    Assert(max - min == imax - imin);

    if (dwOption < min)
    {
        *pindex = imin;
        return FALSE;
    }

    *pindex = imin + (dwOption - min);
    return TRUE;
}

//+------------------------------------------------------------------------
//
//  Member:     CreateOptionArray
//
//  Synopsis:   Creates an OptionArray object which supports IOptionArray
//              under the specified IID.
//
//-------------------------------------------------------------------------

HRESULT
CreateOptionArray(IOptionArray **ppOptionArray, REFIID iid)
{
    COptionArray *pHbi = new COptionArray(iid);
    if (!pHbi)
    {
        return(E_OUTOFMEMORY);
    }

    *ppOptionArray = (IOptionArray*)pHbi;

    return(S_OK);
}

//+------------------------------------------------------------------------
//
//  Member:     CreateHtmLoadOptions
//
//  Synopsis:   Creates an OptionArray which implements IID_IHtmLoadOptions
//
//-------------------------------------------------------------------------

HRESULT
CreateHtmlLoadOptions(IUnknown * pUnkOuter, IUnknown **ppUnk)
{
    if (pUnkOuter != NULL)
    {
        *ppUnk = NULL;
        return(CLASS_E_NOAGGREGATION);
    }

    RRETURN(THR(CreateOptionArray((IOptionArray **)ppUnk, IID_IHtmlLoadOptions)));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\peersite.cxx ===
//+-----------------------------------------------------------------------
//
//  File:       peersite.cxx
//
//  Contents:   peer site
//
//  Classes:    CPeerHolder::CPeerSite
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_PEER_HXX_
#define X_PEER_HXX_
#include "peer.hxx"
#endif

#ifndef X_PEERMGR_HXX_
#define X_PEERMGR_HXX_
#include "peermgr.hxx"
#endif

#ifndef X_PEERFACT_HXX_
#define X_PEERFACT_HXX_
#include "peerfact.hxx"
#endif

#ifndef X_LAYOUT_HXX_
#define X_LAYOUT_HXX_
#include "layout.hxx"
#endif

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx"
#endif

#ifndef X_EVNTPRM_HXX_
#define X_EVNTPRM_HXX_
#include "evntprm.hxx"
#endif

#ifndef X_EVENTOBJ_HXX_
#define X_EVENTOBJ_HXX_
#include "eventobj.hxx"
#endif

#ifndef X_HTC_HXX_
#define X_HTC_HXX_
#include "htc.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_PRGSNK_H_
#define X_PRGSNK_H_
#include <prgsnk.h>
#endif

#ifndef X_GENERIC_HXX_
#define X_GENERIC_HXX_
#include "generic.hxx"
#endif

#ifndef X_ELEMENTP_HXX_
#define X_ELEMENTP_HXX_
#include "elementp.hxx"
#endif

#ifndef X_PEERXTAG_HXX_
#define X_PEERXTAG_HXX_
#include "peerxtag.hxx"
#endif // X_PEERXTAG_HXX_

#ifndef X_DISPCONTEXT_HXX_
#define X_DISPCONTEXT_HXX_
#include "dispcontext.hxx"
#endif

#ifndef X_DISPNODE_HXX_
#define X_DISPNODE_HXX_
#include "dispnode.hxx"
#endif

#ifndef X_DDRAW_H_
#define X_DDRAW_H_
#include "ddraw.h"
#endif

extern IDirectDraw * g_pDirectDraw;

ExternTag(tagPainterHit);
ExternTag(tagFilterVisible);

extern CGlobalCriticalSection g_csOscCache;

#define PH MyCPeerHolder

///////////////////////////////////////////////////////////////////////////
//
// tearoff tables
//
///////////////////////////////////////////////////////////////////////////

BEGIN_TEAROFF_TABLE_SUB_(CPeerHolder, CPeerSite, IElementBehaviorSiteOM2)
    TEAROFF_METHOD_SUB(CPeerHolder, CPeerSite, RegisterEvent,       registerevent,       (LPOLESTR pchEvent, LONG lFlags, LONG * plCookie))
    TEAROFF_METHOD_SUB(CPeerHolder, CPeerSite, GetEventCookie,      geteventcookie,      (LPOLESTR pchEvent, LONG* plCookie))
    TEAROFF_METHOD_SUB(CPeerHolder, CPeerSite, FireEvent,           fireevent,           (LONG lCookie, IHTMLEventObj * pEventObject))
    TEAROFF_METHOD_SUB(CPeerHolder, CPeerSite, CreateEventObject,   createeventobject,   (IHTMLEventObj ** ppEventObject))
    TEAROFF_METHOD_SUB(CPeerHolder, CPeerSite, RegisterName,        registername,        (LPOLESTR pchName))
    TEAROFF_METHOD_SUB(CPeerHolder, CPeerSite, RegisterUrn,         registerurn,         (LPOLESTR pchUrn))
    TEAROFF_METHOD_SUB(CPeerHolder, CPeerSite, GetDefaults,         getdefaults,         (IHTMLElementDefaults ** ppDefaults))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE_SUB_(CPeerHolder, CPeerSite, IElementBehaviorSiteRender)
    TEAROFF_METHOD_SUB(CPeerHolder, CPeerSite, Invalidate,              invalidate,             (LPRECT pRect))
    TEAROFF_METHOD_SUB(CPeerHolder, CPeerSite, InvalidateRenderInfo,    invalidaterenderinfo,   ())
    TEAROFF_METHOD_SUB(CPeerHolder, CPeerSite, InvalidateStyle,         invalidatestyle,        ())
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE_SUB_(CPeerHolder, CPeerSite, IElementBehaviorSiteLayout)
    TEAROFF_METHOD_SUB(CPeerHolder, CPeerSite, InvalidateLayoutInfo, invalidatelayoutinfo, ())
    TEAROFF_METHOD_SUB(CPeerHolder, CPeerSite, InvalidateSize,       invalidatesize,       ())
    TEAROFF_METHOD_SUB(CPeerHolder, CPeerSite, GetMediaResolution,   getmediaresolution,   (SIZE *psizeResolution))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE_SUB_(CPeerHolder, CPeerSite, IElementBehaviorSiteLayout2)
    TEAROFF_METHOD_SUB(CPeerHolder, CPeerSite, GetFontInfo,          getfontinfo,          (LOGFONTW* plf))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE_SUB_(CPeerHolder, CPeerSite, IHTMLPaintSite)
    TEAROFF_METHOD_SUB(CPeerHolder, CPeerSite, InvalidatePainterInfo,   invalidatepainterinfo,  ())
    TEAROFF_METHOD_SUB(CPeerHolder, CPeerSite, InvalidateRect,          invalidaterect,         (RECT* prcInvalid))
    TEAROFF_METHOD_SUB(CPeerHolder, CPeerSite, InvalidateRegion,        invalidateregion,       (HRGN rgnInvalid))
    TEAROFF_METHOD_SUB(CPeerHolder, CPeerSite, GetDrawInfo,             getdrawinfo,            (LONG lFlags, HTML_PAINT_DRAW_INFO* pDrawInfo))
    TEAROFF_METHOD_SUB(CPeerHolder, CPeerSite, TransformGlobalToLocal,  transformglobaltolocal, (POINT ptGlobal, POINT *pptLocal))
    TEAROFF_METHOD_SUB(CPeerHolder, CPeerSite, TransformLocalToGlobal,  transformlocaltoglobal, (POINT ptLocal, POINT *pptGlobal))
    TEAROFF_METHOD_SUB(CPeerHolder, CPeerSite, GetHitTestCookie,        gethittestcookie,       (LONG *plCookie))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE_SUB_(CPeerHolder, CPeerSite, IHTMLFilterPaintSite)
    TEAROFF_METHOD_SUB(CPeerHolder, CPeerSite, DrawUnfiltered,          drawunfiltered,         (HDC hdc, IUnknown *punkDrawObject, RECT rcBounds, RECT rcUpdate, LONG lDrawLayers))
    TEAROFF_METHOD_SUB(CPeerHolder, CPeerSite, HitTestPointUnfiltered,  hittestpointunfiltered, (POINT pt, LONG lDrawLayers, BOOL *pbHit))
    TEAROFF_METHOD_SUB(CPeerHolder, CPeerSite, InvalidateRectFiltered,  invalidaterectfiltered, (RECT *prcInvalid))
    TEAROFF_METHOD_SUB(CPeerHolder, CPeerSite, InvalidateRgnFiltered,   invalidatergnfiltered,  (HRGN hrgnInvalid))
    TEAROFF_METHOD_SUB(CPeerHolder, CPeerSite, ChangeFilterVisibility,  changefiltervisibility, (BOOL fVisible))
    TEAROFF_METHOD_SUB(CPeerHolder, CPeerSite, EnsureViewForFilterSite, ensureviewforfiltersite,())
    TEAROFF_METHOD_SUB(CPeerHolder, CPeerSite, GetDirectDraw,           getdirectdraw,          (void ** ppDirectDraw))
    TEAROFF_METHOD_SUB(CPeerHolder, CPeerSite, GetFilterFlags,          getfilterflags,         (DWORD * pdwFlags))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE_SUB_(CPeerHolder, CPeerSite, IElementBehaviorSiteCategory)
    TEAROFF_METHOD_SUB(CPeerHolder, CPeerSite, GetRelatedBehaviors, getrelatedbehaviors, (LONG lDirection, LPOLESTR pchCategory, IEnumUnknown ** ppEnumerator))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE_SUB_(CPeerHolder, CPeerSite, IServiceProvider)
     TEAROFF_METHOD_SUB(CPeerHolder, CPeerSite, QueryService, queryservice, (REFGUID rguidService, REFIID riid, void ** ppvObject))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE_SUB_(CPeerHolder, CPeerSite, IBindHost)
     TEAROFF_METHOD_SUB(CPeerHolder, CPeerSite, CreateMoniker,        createmoniker,       (LPOLESTR pchName, IBindCtx * pbc, IMoniker ** ppmk, DWORD dwReserved))
     TEAROFF_METHOD_SUB(CPeerHolder, CPeerSite, MonikerBindToStorage, monikerbindtostorage,(IMoniker * pmk, IBindCtx * pbc, IBindStatusCallback * pbsc, REFIID riid, void ** ppvObj))
     TEAROFF_METHOD_SUB(CPeerHolder, CPeerSite, MonikerBindToObject,  monikerbindtoobject, (IMoniker * pmk, IBindCtx * pbc, IBindStatusCallback * pbsc, REFIID riid, void ** ppvObj))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE_SUB_(CPeerHolder, CPeerSite, IPropertyNotifySink)
    TEAROFF_METHOD_SUB(CPeerHolder, CPeerSite, OnChanged,     onchanged,     (DISPID dispid))
    TEAROFF_METHOD_SUB(CPeerHolder, CPeerSite, OnRequestEdit, onrequestedit, (DISPID dispid))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE_SUB_(CPeerHolder, CPeerSite, IOleCommandTarget)
    TEAROFF_METHOD_SUB(CPeerHolder, CPeerSite, QueryStatus,   querystatus,   (const GUID * pguidCmdGroup, ULONG cCmds, OLECMD prgCmds[], OLECMDTEXT * pCmdText))
    TEAROFF_METHOD_SUB(CPeerHolder, CPeerSite, Exec,          exec,          (const GUID * pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt, VARIANT * pvarArgIn, VARIANT * pvarArgOut))
END_TEAROFF_TABLE()

///////////////////////////////////////////////////////////////////////////
//
// misc
//
///////////////////////////////////////////////////////////////////////////

IMPLEMENT_FORMS_SUBOBJECT_IUNKNOWN(CPeerHolder::CPeerSite, CPeerHolder, _PeerSite)

// defined in site\ole\OleBindh.cxx:
extern HRESULT
MonikerBind(
    CMarkup *               pMarkup,
    IMoniker *              pmk,
    IBindCtx *              pbc,
    IBindStatusCallback *   pbsc,
    REFIID                  riid,
    void **                 ppv,
    BOOL                    fObject,
    DWORD                   dwCompatFlags);

DeclareTag(tagPeerFireEvent, "Peer", "trace CPeerHolder::CPeerSite::FireEvent")

const CLSID CLSID_CPeerHolderSite = {0x3050f67f, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b};



//+------------------------------------------------------------------------
//
//  Member:     GetLayoutContext
//
//              Returns the layout context from the renderbag.
//              Never cache the layout context, it is valid only during this call
//-------------------------------------------------------------------------

CLayoutContext *
GetLayoutContext(CPeerHolder *pPH)
{
    CLayoutContext * pLayoutContext = GUL_USEFIRSTLAYOUT;

    if(pPH->_pRenderBag && pPH->_pRenderBag->_pCallbackInfo && pPH->_pRenderBag->_pCallbackInfo->_pContext)
        pLayoutContext = pPH->_pRenderBag->_pCallbackInfo->_pContext->GetLayoutContext();

    return pLayoutContext;
}


//+------------------------------------------------------------------------
//
//  Member:     InvalidateAllLayouts
//
//              Invalidate all the Peerholders if (pPH != 0), or
//                layouts (pPH == 0), for given element.
//              We assume that element has a LayoutAry
//-------------------------------------------------------------------------

void
InvalidateAllLayouts(CElement *pElemToUse, CPeerHolder *pPH)
{
    // Invalidate all the layouts
    Assert(pElemToUse->HasLayoutAry());

    CLayoutAry * pLayoutAry = pElemToUse->GetLayoutAry();
    CLayout    * pCurLayout;
    int nLayoutCookie = 0;

    for(;;)
    {
        pCurLayout = pLayoutAry->GetNextLayout(&nLayoutCookie);
        if(nLayoutCookie == -1)
            break;

        if (!pCurLayout)
            return;

        if(pPH)
        {
            CDispNode *pDispNode = pCurLayout->GetElementDispNode();
            if (pDispNode)
            {
                    pPH->InvalidateRect(pDispNode, NULL);
            }
        }
        else
        {
            pCurLayout->Invalidate();
        }
    }
}



///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPeerSite::QueryInterface
//
//-------------------------------------------------------------------------

HRESULT
CPeerHolder::CPeerSite::QueryInterface(REFIID iid, LPVOID * ppv)
{
    if (!ppv)
        RRETURN(E_POINTER);

    *ppv = NULL;

    switch (iid.Data1)
    {
    QI_INHERITS((IElementBehaviorSite*)this, IUnknown)
    QI_INHERITS(this, IElementBehaviorSite)
    QI_INHERITS(this, ISecureUrlHost)
    QI_TEAROFF2(this, IElementBehaviorSiteOM, IElementBehaviorSiteOM2, NULL)
    QI_TEAROFF (this, IElementBehaviorSiteOM2, NULL)
    QI_TEAROFF (this, IElementBehaviorSiteRender, NULL)
    QI_TEAROFF (this, IHTMLPaintSite, NULL)
    QI_TEAROFF (this, IHTMLFilterPaintSite, NULL)
    QI_TEAROFF (this, IElementBehaviorSiteCategory, NULL)
    QI_TEAROFF (this, IServiceProvider, NULL)
    QI_TEAROFF (this, IBindHost, NULL)
    QI_TEAROFF (this, IPropertyNotifySink, NULL)
    QI_TEAROFF (this, IOleCommandTarget, NULL)
    QI_TEAROFF (this, IElementBehaviorSiteLayout, NULL)
    QI_TEAROFF (this, IElementBehaviorSiteLayout2, NULL)
    default:

        if (IsEqualGUID(iid, CLSID_CPeerHolderSite))
        {
            *ppv = this;
            RRETURN (S_OK);
        }

        break;
    }

    if (*ppv)
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }
    else
        RRETURN(E_NOINTERFACE);
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPeerSite::GetElement
//
//-------------------------------------------------------------------------

HRESULT
CPeerHolder::CPeerSite::GetElement(IHTMLElement ** ppElement)
{
    if (PH()->IllegalSiteCall())
        RRETURN(E_UNEXPECTED);

    RRETURN (THR(PH()->QueryInterface(IID_IHTMLElement, (void**)ppElement)));
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPeerSite::GetDefaults
//
//-------------------------------------------------------------------------

HRESULT
CPeerHolder::CPeerSite::GetDefaults(IHTMLElementDefaults ** ppDefaults)
{
    if (PH()->IllegalSiteCall())
        RRETURN(E_UNEXPECTED);

    if (!PH()->IsIdentityPeer())
        RRETURN(E_ACCESSDENIED);

    HRESULT             hr = S_OK;
    CPeerMgr *          pPeerMgr;
    CDefaults *         pDefaults = NULL;

    hr = THR(CPeerMgr::EnsurePeerMgr(PH()->_pElement, &pPeerMgr));
    if (hr)
        goto Cleanup;

    hr = THR(pPeerMgr->EnsureDefaults(&pDefaults));
    if (hr)
        goto Cleanup;

    hr = THR(pDefaults->PrivateQueryInterface(IID_IHTMLElementDefaults, (void**)ppDefaults));

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPeerSite::RegisterNotification
//
//-------------------------------------------------------------------------

HRESULT
CPeerHolder::CPeerSite::RegisterNotification(LONG lEvent)
{
    if (PH()->IllegalSiteCall())
        RRETURN(E_UNEXPECTED);

    PH()->SetFlag(PH()->FlagFromNotification(lEvent));

    switch (lEvent)
    {
    case BEHAVIOREVENT_APPLYSTYLE:

#if 1
        // 90810 applyStyle disabled

        AssertSz(0,"Apply Style behavior notification is disabled.");
        PH()->ClearFlag(CPeerHolder::NEEDAPPLYSTYLE);

        break;
#else
        if (PH()->_pElement->IsFormatCacheValid())
        {
            if (PH()->TestFlag(AFTERINIT))
            {
                IGNORE_HR(PH()->_pElement->ProcessPeerTask(PEERTASK_APPLYSTYLE_UNSTABLE));
            }
            else
            {
                IGNORE_HR(PH()->_pElement->OnCssChange(/*fStable = */ TRUE, /* fRecomputePeers = */ FALSE));
            }
        }
#endif

        break;

    case BEHAVIOREVENT_CONTENTSAVE:

        PH()->_pElement->Doc()->_fContentSavePeersPossible = TRUE;

        break;
    }

    return S_OK;
}

HRESULT
CPeerHolder::CPeerSite::ValidateSecureUrl(BOOL* pfAllow, OLECHAR* pchUrl, DWORD dwFlags)
{
    HRESULT hr = S_OK;
    CMarkup * pMarkup = GetWindowedMarkupContext();


    Assert(pMarkup);
    if(pMarkup == NULL)
    {
        hr = E_FAIL;
        goto done;
    }

    *pfAllow = (pMarkup->ValidateSecureUrl(FALSE, pchUrl,
        !!(SUHV_PROMPTBEFORENO & dwFlags),
        !!(SUHV_SILENTYES & dwFlags),
        !!(SUHV_UNSECURESOURCE & dwFlags)));
done:
    return hr;
}


//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPeerSite::QueryService
//
//-------------------------------------------------------------------------

HRESULT
CPeerHolder::CPeerSite::QueryService(REFGUID rguidService, REFIID riid, void ** ppvObject)
{
    HRESULT             hr;
    CMarkup *           pMarkup;

    if (PH()->IllegalSiteCall())
        RRETURN(E_UNEXPECTED);

    if (IsEqualGUID(rguidService, SID_SBindHost))
    {
        hr = THR_NOTRACE(QueryInterface(riid, ppvObject));
        goto Cleanup;
    }
    else if (IsEqualGUID(rguidService, SID_SElementBehaviorMisc))
    {
        hr = THR_NOTRACE(QueryInterface(riid, ppvObject));
        goto Cleanup;
    }
    else if (PH()->_pPeerFactoryUrl && IsEqualGUID(rguidService, IID_IMoniker))
    {
        hr = THR_NOTRACE(PH()->_pPeerFactoryUrl->QueryService(rguidService, riid, ppvObject));
        goto Cleanup;
    }
    else if( IsEqualGUID( rguidService, CLSID_CMarkup ) )
    {
        *ppvObject = PH()->_pElement->GetWindowedMarkupContext();
        hr = S_OK;
        goto Cleanup;
    }

    pMarkup = PH()->_pElement->GetMarkup();
    if (pMarkup)
    {
        CMarkupBehaviorContext * pBehaviorContext = pMarkup->BehaviorContext();

        if (pBehaviorContext && pBehaviorContext->_pHtmlComponent)
        {
            hr = THR(pBehaviorContext->_pHtmlComponent->QueryService(rguidService, riid, ppvObject));
            goto Cleanup;   // done
        }

        hr = THR_NOTRACE(pMarkup->QueryService(rguidService, riid, ppvObject));

        goto Cleanup; // done (markup will delegate to the doc)
    }

    hr = THR_NOTRACE(Doc()->QueryService(rguidService, riid, ppvObject));

Cleanup:

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPeerSite::CreateMoniker, per IBindHost
//
//----------------------------------------------------------------------------

HRESULT
CPeerHolder::CPeerSite::CreateMoniker(
    LPOLESTR    pchUrl,
    IBindCtx *  pbc,
    IMoniker ** ppmk,
    DWORD dwReserved)
{
    HRESULT     hr;
    TCHAR       achExpandedUrl[pdlUrlLen];

    if (PH()->IllegalSiteCall())
        RRETURN(E_UNEXPECTED);

    hr = THR(CMarkup::ExpandUrl(GetWindowedMarkupContext(), pchUrl, ARRAY_SIZE(achExpandedUrl), achExpandedUrl, PH()->_pElement));
    if (hr)
        goto Cleanup;

    hr = THR(CreateURLMoniker(NULL, achExpandedUrl, ppmk));

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPeerSite::MonikerBindToStorage, per IBindHost
//
//----------------------------------------------------------------------------

HRESULT
CPeerHolder::CPeerSite::MonikerBindToStorage(
    IMoniker *              pmk,
    IBindCtx *              pbc,
    IBindStatusCallback *   pbsc,
    REFIID                  riid,
    void **                 ppvObj)
{
    if (PH()->IllegalSiteCall())
        RRETURN(E_UNEXPECTED);

    RRETURN1(MonikerBind(
        GetWindowedMarkupContext(),
        pmk,
        pbc,
        pbsc,
        riid,
        ppvObj,
        FALSE, // fObject = FALSE
        COMPAT_SECURITYCHECKONREDIRECT), S_ASYNCHRONOUS);
}


//+---------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPeerSite::MonikerBindToObject, per IBindHost
//
//----------------------------------------------------------------------------

HRESULT
CPeerHolder::CPeerSite::MonikerBindToObject(
    IMoniker *              pmk,
    IBindCtx *              pbc,
    IBindStatusCallback *   pbsc,
    REFIID                  riid,
    void **                 ppvObj)
{
    if (PH()->IllegalSiteCall())
        RRETURN(E_UNEXPECTED);

    RRETURN1(MonikerBind(
        GetWindowedMarkupContext(),
        pmk,
        pbc,
        pbsc,
        riid,
        ppvObj,
        TRUE, // fObject = TRUE
        COMPAT_SECURITYCHECKONREDIRECT), S_ASYNCHRONOUS);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPeerSite::RegisterEvent, per IElementBehaviorSiteOM
//
//----------------------------------------------------------------------------

HRESULT
CPeerHolder::CPeerSite::RegisterEvent(BSTR bstrEvent, LONG lFlags, LONG * plCookie)
{
    HRESULT     hr;
    LONG        lCookie;

    if (PH()->IllegalSiteCall())
        RRETURN(E_UNEXPECTED);

    if (!bstrEvent)
        RRETURN (E_POINTER);

    if (!plCookie)
        plCookie = &lCookie;

    hr = THR(GetEventCookieHelper(bstrEvent, lFlags, plCookie, /* fEnsureCookie = */ TRUE));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN (hr);
}

HRESULT
CPeerHolder::CPeerSite::RegisterEventHelper(BSTR bstrEvent, LONG lFlags, LONG * plCookie, CHtmlComponent *pContextComponent)
{
    HRESULT     hr;
    LONG        lCookie;

    if (PH()->IllegalSiteCall())
        RRETURN(E_UNEXPECTED);

    Assert(bstrEvent);
    Assert(!plCookie);
    Assert(pContextComponent);

    hr = THR(GetEventCookieHelper(bstrEvent, lFlags, &lCookie, /* fEnsureCookie = */ TRUE, pContextComponent));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN (hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPeerSite::GetEventCookie, per IElementBehaviorSiteOM
//
//----------------------------------------------------------------------------

HRESULT
CPeerHolder::CPeerSite::GetEventCookie(BSTR bstrEvent, LONG * plCookie)
{
    HRESULT     hr;

    if (PH()->IllegalSiteCall())
        RRETURN(E_UNEXPECTED);

    if (!plCookie || !bstrEvent)
        RRETURN (E_POINTER);

    hr = THR_NOTRACE(GetEventCookieHelper(bstrEvent, 0, plCookie, /* fEnsureCookie = */ FALSE));

    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPeerSite::GetEventDispid, helper
//
//----------------------------------------------------------------------------

HRESULT
CPeerHolder::CPeerSite::GetEventDispid(LPOLESTR pchEvent, DISPID * pdispid)
{
    HRESULT hr;
    LONG    lCookie;

    hr = THR_NOTRACE(GetEventCookieHelper(pchEvent, 0, &lCookie, /* fEnsureCookie = */ FALSE));
    if (hr)
        goto Cleanup;

    *pdispid = PH()->CustomEventDispid(lCookie);

Cleanup:
    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPeerSite::GetEventCookieHelper, helper
//
//----------------------------------------------------------------------------

HRESULT
CPeerHolder::CPeerSite::GetEventCookieHelper(
    LPOLESTR pchEvent,
    LONG     lFlags,
    LONG *   plCookie,
    BOOL     fEnsureCookie,
    CHtmlComponent *pContextComponent)
{
    HRESULT     hr = DISP_E_UNKNOWNNAME;
    LONG        idx = -1, cnt;
    CHtmlComponent *pComponent = NULL;
    CHtmlComponent *pFactory = NULL;

    Assert (pchEvent && plCookie);

    //
    // ensure events bag
    //

    if (!PH()->_pEventsBag)
    {
        PH()->_pEventsBag = new CEventsBag();
        if (!PH()->_pEventsBag)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }

    //
    // do the lookup or registration
    //
    cnt = PH()->CustomEventsCount();
    if (PH()->_fHtcPeer && (cnt > 0 || fEnsureCookie))
    {
        Assert(PH()->_pPeer);

        pComponent = DYNCAST(CHtmlComponent, PH()->_pPeer);
        if (pComponent && !pComponent->Dirty() && pComponent->_pConstructor)
        {
            pFactory = pComponent->_pConstructor->_pFactoryComponent;
            Assert(pFactory != pComponent && !pComponent->_fFactoryComponent);
            if (pFactory && cnt > 0)
            {
                Assert(pFactory->_fFactoryComponent);
                idx = pFactory->FindEventCookie(pchEvent);

                // if name found is a property or method, allow custom event of
                // same name, but perf has to be turned off :-(
                if (fEnsureCookie && idx >= HTC_PROPMETHODNAMEINDEX_BASE)
                    pFactory->_fDirty = TRUE;
            }
        }
    }

    // make search in array of dispids
    if (!pFactory)
    {
        for (idx = 0; idx < cnt; idx++)
        {
            if (0 == StrCmpIC(pchEvent, PH()->CustomEventName(idx)))
                break;
        }
    }

    if (idx >= 0 && idx < cnt) // if found the event
    {
        Assert(!pFactory || (0 == StrCmpIC(pchEvent, PH()->CustomEventName(idx))));
        *plCookie = idx;
        hr = S_OK;
    }
    else // if not found the event
    {
        // depending on action
        if (!fEnsureCookie)
        {
            Assert (DISP_E_UNKNOWNNAME == hr);
        }
        else
        {
            //
            // register the new event
            //

            BOOL        fConnectNow = FALSE;
            DISPID      dispidSrc;
            DISPID      dispidHandler;
            long        c;

            CEventsBag::CEventsArray *  pEventsArray = &PH()->_pEventsBag->_aryEvents;

            hr = PH()->_pElement->CBase::GetDispID(pchEvent, 0, &dispidSrc);
            switch (hr)
            {
            case S_OK:

                if (IsStandardDispid(dispidSrc))
                {
                    if (PH()->_pElement->GetBaseObjectFor(dispidSrc) != PH()->_pElement)
                    {
                        // we don't allow yet to override events fired by window
                        hr = E_NOTIMPL;
                    }

                    dispidHandler = dispidSrc;
                }
                else
                {
                    Assert (IsExpandoDispid(dispidSrc));

                    dispidHandler = PH()->AtomToEventDispid(dispidSrc - DISPID_EXPANDO_BASE);
                    fConnectNow = TRUE;

                    lFlags &= ~BEHAVIOREVENTFLAGS_BUBBLE; // disable bubbling for anything but standard events
                }

                break;

            case DISP_E_UNKNOWNNAME:
                {

                    CAtomTable * pAtomTable = PH()->_pElement->GetAtomTable();

                    Assert(pAtomTable && "missing atom table");

                    hr = THR(pAtomTable->AddNameToAtomTable (pchEvent, &dispidHandler));
                    if (hr)
                        goto Cleanup;

                    dispidHandler = PH()->AtomToEventDispid(dispidHandler);

                    lFlags &= ~BEHAVIOREVENTFLAGS_BUBBLE; // disable bubbling for anything but standard events
                }
                break;

            default:
                // fatal error
                goto Cleanup;
            }

            c = pEventsArray->Size();

            hr = THR(pEventsArray->EnsureSize(c + 1));
            if (hr)
                goto Cleanup;

            pEventsArray->SetSize(c + 1);

            // c is now index of the last (yet uninitialized) item of the array

            (*pEventsArray)[c].dispid  = dispidHandler;
            (*pEventsArray)[c].lFlags = lFlags;

            *plCookie = c;

            if (pFactory && !pComponent->Dirty() && pComponent->_fFirstInstance)
            {
                AssertSz(c < HTC_PROPMETHODNAMEINDEX_BASE, "More than 4095 custom events in htc");
                Assert(pFactory->_fFactoryComponent && !pComponent->_fFactoryComponent);
                pFactory->AddAtom(pchEvent, LongToPtr(c));
            }

            if (fConnectNow && PH()->_pElement->IsInMarkup())
            {
                // case when the event handler is inlined: <A:B onFooEvent = "..." >

                BOOL fRunScript;
                hr = THR(PH()->_pElement->GetMarkup()->ProcessURLAction(URLACTION_SCRIPT_RUN, &fRunScript));
                if (hr || !fRunScript)
                    goto Cleanup;

                Assert(!pContextComponent || (TagNameToHtcBehaviorType(PH()->_pElement->TagName()) & HTC_BEHAVIOR_ATTACH));

                // construct and connect code
                hr = THR(PH()->_pElement->ConnectInlineEventHandler(
                    dispidSrc,          // dispid of expando with text of code
                    dispidHandler,      // dispid of function pointer in attr array
                    0, 0,               // line/offset info - not known here - will be retrieved from attr array
                    FALSE,              // fStandard
                    NULL,
                    pContextComponent));// this instance of lightwight htc for <ATTACH> builtins
                if (hr)
                    goto Cleanup;
            }
        }
    }

Cleanup:
    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPeerSite::CreateEventObject, per IElementBehaviorSiteOM
//
//----------------------------------------------------------------------------

HRESULT
CPeerHolder::CPeerSite::CreateEventObject(IHTMLEventObj ** ppEventObject)
{
    HRESULT     hr;

    if (PH()->IllegalSiteCall())
        RRETURN(E_UNEXPECTED);

    hr = THR(CEventObj::Create(ppEventObject, Doc(), PH()->_pElement, NULL, /* fCreateAttached = */FALSE, PH()->_cstrUrn));

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPeerSite::FireEvent, helper
//
//----------------------------------------------------------------------------

HRESULT
CPeerHolder::CPeerSite::FireEvent(
    LONG            lCookie,
    BOOL            fSameEventObject,
    IDispatch *     pdispContextThis)
{
    HRESULT         hr = S_OK;
    LONG            lFlags;
    DISPID          dispid;
    CDoc *          pDoc = Doc();
    CTreeNode *     pNode = PH()->_pElement->GetFirstBranch();

    if (PH()->CustomEventsCount() <= lCookie)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (!fSameEventObject)
    {
        pDoc->_pparam->SetNodeAndCalcCoordinates(pNode);

        if (!pDoc->_pparam->GetSrcUrn())
             pDoc->_pparam->SetSrcUrn(PH()->_cstrUrn);
        // (do not check here pDoc->_pparam->GetSrcUrn()[0] - allow the string to be 0-length)

        if( !pDoc->_pparam->GetType() )
        {
            LPTSTR pStrEvent = PH()->CustomEventName( lCookie );

            // If the event name begins with "on",
            // and there's something after the "on",
            // strip it off for the type
            if(     !StrCmpNIC( pStrEvent, _T("on"), 2 )
                &&  pStrEvent[2] != _T('\0') )
            {
                pDoc->_pparam->SetType( pStrEvent + 2 );
            }
            else
            {
                pDoc->_pparam->SetType( pStrEvent );
            }
        }
    }

    dispid  = PH()->CustomEventDispid(lCookie);
    lFlags  = PH()->CustomEventFlags (lCookie);

    TraceTag((tagPeerFireEvent,
        "CPeerHolder::CPeerSite::FireEvent %08lX  Cookie: %d   DispID: %08lX  Flags: %08lX  Custom Name: %ls",
        PH(), lCookie, dispid, lFlags, STRVAL(PH()->CustomEventName(lCookie))));

    //
    // now fire
    //

    if (BEHAVIOREVENTFLAGS_BUBBLE & lFlags)
    {
        Assert (!pdispContextThis);

        IGNORE_HR(PH()->_pElement->BubbleEventHelper(
            pNode, 0, dispid, dispid, /* fRaisedByPeer = */ TRUE, NULL));
    }
    else
    {
        if (!PH()->_pElement->GetAAdisabled())
        {
            IGNORE_HR(PH()->_pElement->CBase::FireEvent(
                pDoc, PH()->_pElement, NULL, dispid, dispid, NULL, NULL, FALSE, pdispContextThis));
        }
    }

Cleanup:

    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPeerSite::FireEvent, per IElementBehaviorSiteOM
//
//----------------------------------------------------------------------------

HRESULT
CPeerHolder::CPeerSite::FireEvent(LONG lCookie, IHTMLEventObj * pEventObject)
{
    HRESULT     hr = S_OK;

    if (PH()->IllegalSiteCall() || !PH()->_pEventsBag)
        RRETURN(E_UNEXPECTED);

    hr = THR(FireEvent(lCookie, pEventObject, /* fReuseCurrentEventObject = */ FALSE, NULL));

    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPeerSite::FireEvent, helper (used by HTC)
//
//----------------------------------------------------------------------------

HRESULT
CPeerHolder::CPeerSite::FireEvent(
    LONG                lCookie,
    IHTMLEventObj *     pEventObject,
    BOOL                fReuseCurrentEventObject,
    IDispatch *         pdispContextThis)
{
    HRESULT     hr = S_OK;

    // NOTE any change here might have to be mirrored in CHtmlComponentAttach::FireHandler

    if (fReuseCurrentEventObject)
    {
        IGNORE_HR(FireEvent(lCookie, fReuseCurrentEventObject, pdispContextThis));
    }
    else if (pEventObject)
    {
        CEventObj::COnStackLock onStackLock(pEventObject);

        IGNORE_HR(FireEvent(lCookie, fReuseCurrentEventObject, pdispContextThis));
    }
    else
    {
        EVENTPARAM param(Doc(), PH()->_pElement, NULL, TRUE); // so to replace pEventObject

        IGNORE_HR(FireEvent(lCookie, fReuseCurrentEventObject, pdispContextThis));
    }

    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPeerSite::RegisterName, per IElementBehaviorSiteOM
//
//----------------------------------------------------------------------------

HRESULT
CPeerHolder::CPeerSite::RegisterName(BSTR bstrName)
{
    HRESULT hr;

    if (PH()->IllegalSiteCall())
        RRETURN(E_UNEXPECTED);

    hr = THR(PH()->_cstrName.Set(bstrName));

    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPeerSite::RegisterUrn, per IElementBehaviorSiteOM
//
//----------------------------------------------------------------------------

HRESULT
CPeerHolder::CPeerSite::RegisterUrn(BSTR bstrName)
{
    HRESULT hr;

    if (PH()->IllegalSiteCall())
        RRETURN(E_UNEXPECTED);

    hr = THR(PH()->_cstrUrn.Set(bstrName));

    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPeerSite::Invalidate, per IElementBehaviorSiteRender
//
//----------------------------------------------------------------------------

HRESULT
CPeerHolder::CPeerSite::Invalidate(LPRECT pRect)
{
    CElement     * pElemToUse = GetElementToUseForPageTransitions();
    if(!pElemToUse)
        RRETURN(E_UNEXPECTED);

    CLayoutContext * pLayoutContext = GetLayoutContext(PH());

    // Invalidate all the layouts
    if(pElemToUse->HasLayoutAry() && pLayoutContext == GUL_USEFIRSTLAYOUT)
    {
        // We don't know which one to invalidate, invalidate all of the layouts
        // Passig null will invalidate Layouts versus Dispnodes
        InvalidateAllLayouts(pElemToUse, NULL);
        return S_OK;
    }


    CLayout * pLayout = pElemToUse->GetUpdatedLayout(pLayoutContext);

    if (PH()->IllegalSiteCall() || !pLayout)
        RRETURN(E_UNEXPECTED);


    // TODO (sambent) VML calls Invalidate before we've recognized it as a rendering peer
    // Assert(PH()->_pRenderBag->_pAdapter);

    pLayout->Invalidate(pRect);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPeerSite::InvalidateRenderInfo, per IElementBehaviorSiteRender
//
//----------------------------------------------------------------------------

HRESULT
CPeerHolder::CPeerSite::InvalidateRenderInfo()
{
    HRESULT     hr;

    if (PH()->IllegalSiteCall() || !PH()->_pRenderBag || !PH()->_pRenderBag->_pAdapter)
        RRETURN(E_UNEXPECTED);

    hr = THR(PH()->UpdateRenderBag());

    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPeerSite::InvalidateStyle, per IElementBehaviorSiteRender
//
//----------------------------------------------------------------------------

HRESULT
CPeerHolder::CPeerSite::InvalidateStyle()
{
    if (PH()->IllegalSiteCall())
        RRETURN(E_UNEXPECTED);

    PH()->_pElement->EnsureFormatCacheChange(ELEMCHNG_CLEARCACHES);

    return S_OK;
}



//+---------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPeerSite::InvalidateLayoutInfo, per IElementBehaviorSiteLayout
//
//----------------------------------------------------------------------------

HRESULT
CPeerHolder::CPeerSite::InvalidateLayoutInfo()
{
    HRESULT     hr;

     if (   PH()->IllegalSiteCall()
         || !PH()->_pLayoutBag
         || !PH()->_pLayoutBag->_pPeerLayout)
     {
         hr = E_UNEXPECTED;
         goto Cleanup;
     }

    hr = THR(PH()->_pLayoutBag->_pPeerLayout->GetLayoutInfo(&PH()->_pLayoutBag->_lLayoutInfo));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPeerSite::GetElementToUseForPageTransitions
//                    This will return the element that the peer is attached.
//                    If in the middle of a page transition and the element is
//                  the root element it will return the canvas element of the
//                  old or new markup, depending on the transition state
//----------------------------------------------------------------------------

CElement *
CPeerHolder::CPeerSite::GetElementToUseForPageTransitions()
{
   return PH()->GetElementToUseForPageTransitions();
}


//+---------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPeerSite::InvalidateSize, per IElementBehaviorSiteLayout
//
//----------------------------------------------------------------------------

HRESULT
CPeerHolder::CPeerSite::InvalidateSize()
{
    if (   PH()->IllegalSiteCall()
        || !PH()->_pLayoutBag
        || !PH()->_pLayoutBag->_pPeerLayout
        || !PH()->_pElement->IsInMarkup())
    {
        return E_UNEXPECTED;
    }

    CElement * pElemToUse = GetElementToUseForPageTransitions();
    if(!pElemToUse)
        RRETURN(E_UNEXPECTED);

    //
    // if we are locked for sizing, this means that the LB
    // has called InvalidateSize DURING its GetSize callback.
    // We can't handle this, short of posting a new message to
    // ourselves to do the remeasure notification.  That is probably
    // proper, but more work than we can do now ie5.5 RTM. so
    // for now, just return an error
    //
    if (pElemToUse->TestLock(CElement::ELEMENTLOCK_SIZING))
        return E_PENDING;

    pElemToUse->RemeasureInParentContext(NFLAGS_FORCE);

    return S_OK;
}


HRESULT
CPeerHolder::CPeerSite::GetMediaResolution (SIZE* psizeResolution)
{
    HRESULT hr = S_OK;

    if (!psizeResolution)
    {
        hr = E_POINTER;
    }
    else
    {
        CElement           *pElem          = PH()->_pElement;
        CFancyFormat const *pFF = pElem->GetFirstBranch()->GetFancyFormat();
        mediaType           mediaReference = pFF->GetMediaReference();
        CSize               sizeInch       = g_Zero.size;
        CLayoutContext    * pLayoutContext = GetLayoutContext(PH());

        if (   mediaReference == mediaTypeNotSet
            && pElem->HasLayoutAry())
        {
            if(!pLayoutContext || pLayoutContext == GUL_USEFIRSTLAYOUT)
            {
                CLayout *pFirstLayout = pElem->GetUpdatedLayout(GUL_USEFIRSTLAYOUT);

                Assert(pFirstLayout); //should be true since we already tested for HasLayoutAry()
                pLayoutContext = pFirstLayout->LayoutContext();
            }

            mediaReference = pLayoutContext->GetMedia();
        }

        // if this element has a media set on it, then use that value and override the
        // context information.  This is probably a bug in multiple views (but above todo).
        sizeInch = pElem->Doc()->GetView()->GetMeasuringDevice(mediaReference)->GetResolution();

        *psizeResolution = sizeInch;
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPeerSite::InvalidatePainterInfo, per IHTMLPaintSite
//
//----------------------------------------------------------------------------

HRESULT
CPeerHolder::CPeerSite::InvalidatePainterInfo()
{
    HRESULT     hr;

    if (PH()->IllegalSiteCall() || !PH()->_pRenderBag)
        RRETURN(E_UNEXPECTED);

    hr = THR(PH()->UpdateRenderBag());

    RRETURN (hr);
}



//+---------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPeerSite::InvalidateRect, per IHTMLPaintSite
//
//----------------------------------------------------------------------------

HRESULT
CPeerHolder::CPeerSite::InvalidateRect(RECT* prcInvalid)
{
    if(PH()->IllegalSiteCall()  || !PH()->_pRenderBag || !PH()->_pElement->IsInMarkup())
        RRETURN(E_UNEXPECTED);

    CElement     * pElemToUse = GetElementToUseForPageTransitions();
    if(!pElemToUse)
        RRETURN(E_UNEXPECTED);

    CLayoutContext    * pLayoutContext = GetLayoutContext(PH());
    CDispNode         * pDispNode;
    CLayout           * pLayout;

    // Invalidate all the layouts
    if(pElemToUse->HasLayoutAry() && pLayoutContext == GUL_USEFIRSTLAYOUT)
    {
        // We don't know which one to invalidate, invalidate all of the layouts
        InvalidateAllLayouts(pElemToUse, PH());
        return S_OK;
    }

    pLayout = pElemToUse->GetUpdatedNearestLayout(pLayoutContext); // EnsureLayoutInDefaultContext

    if (!pLayout)
        RRETURN(E_UNEXPECTED);

    pDispNode = pLayout->GetElementDispNode();

    if (pDispNode)
    {
        PH()->InvalidateRect(pDispNode, prcInvalid);
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPeerSite::InvalidateRegion, per IHTMLPaintSite
//
//----------------------------------------------------------------------------

HRESULT
CPeerHolder::CPeerSite::InvalidateRegion(HRGN rgnInvalid)
{
    CLayoutContext * pLayoutContext = GetLayoutContext(PH());
    CLayout * pLayout = PH()->_pElement->GetUpdatedLayout(pLayoutContext);
    CElement     * pElemToUse = GetElementToUseForPageTransitions();

    if(!pElemToUse)
        RRETURN(E_UNEXPECTED);

    // Invalidate all the layouts
    if(pElemToUse->HasLayoutAry() && pLayoutContext == GUL_USEFIRSTLAYOUT)
    {
        // We don't know which one to invalidate, invalidate all of the layouts
        // Passig null will invalidate Layouts versus Dispnodes
        InvalidateAllLayouts(pElemToUse, NULL);
        return S_OK;
    }

    if (PH()->IllegalSiteCall() || !pLayout || !PH()->_pRenderBag)
        RRETURN(E_UNEXPECTED);

    pLayout->Invalidate(rgnInvalid);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPeerSite::GetDrawInfo, per IHTMLPaintSite
//
//----------------------------------------------------------------------------

HRESULT
CPeerHolder::CPeerSite::GetDrawInfo(LONG lFlags, HTML_PAINT_DRAW_INFO* pDrawInfo)
{
    HRESULT          hr              = S_OK;
    CElement       * pElemToUse      = NULL;
    CDispNode      * pDispNode       = NULL;
    DWORD            dwPrivateFlags  = 0;
    CLayoutContext * pLayoutContext = GetLayoutContext(PH());
    RENDER_CALLBACK_INFO *pCallbackInfo;

    if (PH()->IllegalSiteCall() || !PH()->_pRenderBag || !PH()->_pElement->IsInMarkup())
    {
        hr = E_UNEXPECTED;

        goto done;
    }

    pElemToUse = GetElementToUseForPageTransitions();

    if(NULL == pElemToUse)
    {
        hr = E_UNEXPECTED;

        goto done;
    }

    pCallbackInfo = PH()->_pRenderBag->_pCallbackInfo;

    // Are we measuring in high resolution coordinates?
    // (Usually when printing or print previewing.)

    if (   pLayoutContext
        && (pLayoutContext != GUL_USEFIRSTLAYOUT)
        && (pLayoutContext->GetMedia() & mediaTypePrint))
    {
        dwPrivateFlags |= HTMLPAINT_DRAWINFO_PRIVATE_PRINTMEDIA;
    }

    // Are we a filter peer?

    if (PH()->IsFilterPeer())
    {
        dwPrivateFlags |= HTMLPAINT_DRAWINFO_PRIVATE_FILTER;
    }

    pDispNode = pElemToUse->GetUpdatedLayout(pLayoutContext)->GetElementDispNode();

    Assert(pDispNode);

    hr = pDispNode->GetDrawInfo(
                        pCallbackInfo,
                        lFlags,
                        dwPrivateFlags,
                        pDrawInfo);

done:

    RRETURN1(hr, S_FALSE);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPeerSite::TransformLocalToGlobal, per IHTMLPaintSite
//
//----------------------------------------------------------------------------
HRESULT
CPeerHolder::CPeerSite::TransformLocalToGlobal(POINT ptLocal, POINT *pptGlobal)
{
    if (PH()->IllegalSiteCall() || !PH()->_pRenderBag)
        RRETURN(E_UNEXPECTED);

    CLayoutContext * pLayoutContext = GetLayoutContext(PH());

    CLayout *pLayout = PH()->_pElement->GetUpdatedLayout(pLayoutContext);
    AssertSz(pLayout, "Call to CPeerSite::TransformLocalToGlobal on element with no layout");
    if (!pLayout)
        RRETURN(E_UNEXPECTED);

    CDispNode * pDispNode = pLayout->GetElementDispNode();
    Assert(pDispNode);

    // TODO (michaelw) sambent needs to change this to look at some flag tbd so that the behavior chooses
    //                 to which rect it renders.
    //
    //                 For now we just check for window top (which catches edit grab handles)
    COORDINATE_SYSTEM cs = (PH()->_pRenderBag->_sPainterInfo.lZOrder == HTMLPAINT_ZORDER_WINDOW_TOP) ? COORDSYS_BOX : COORDSYS_CONTENT;

    ptLocal.x -= PH()->_pRenderBag->_sPainterInfo.rcExpand.left;
    ptLocal.y -= PH()->_pRenderBag->_sPainterInfo.rcExpand.top;
    pDispNode->TransformPoint((CPoint)ptLocal, cs, (CPoint *)pptGlobal, COORDSYS_GLOBAL);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPeerSite::TransformGlobalToLocal, per IHTMLPaintSite
//
//----------------------------------------------------------------------------
HRESULT
CPeerHolder::CPeerSite::TransformGlobalToLocal(POINT ptGlobal, POINT *pptLocal)
{
    if (PH()->IllegalSiteCall() || !PH()->_pRenderBag)
        RRETURN(E_UNEXPECTED);

    CLayoutContext * pLayoutContext = GetLayoutContext(PH());

    CLayout *pLayout = PH()->_pElement->GetUpdatedLayout(pLayoutContext);
    AssertSz(pLayout, "Call to CPeerSite::TransformGlobalToLocal on element with no layout");
    if (!pLayout)
        RRETURN(E_UNEXPECTED);

    CDispNode * pDispNode = pLayout->GetElementDispNode();
    Assert(pDispNode);

    // TODO (michaelw) sambent needs to change this to look at some flag tbd so that the behavior chooses
    //                 to which rect it renders.
    //
    //                 For now we just check for window top (which catches edit grab handles)
    COORDINATE_SYSTEM cs = (PH()->_pRenderBag->_sPainterInfo.lZOrder == HTMLPAINT_ZORDER_WINDOW_TOP) ? COORDSYS_BOX : COORDSYS_CONTENT;

    pDispNode->TransformPoint((CPoint)ptGlobal, COORDSYS_GLOBAL, (CPoint *)pptLocal, cs);

    pptLocal->x += PH()->_pRenderBag->_sPainterInfo.rcExpand.left;
    pptLocal->y += PH()->_pRenderBag->_sPainterInfo.rcExpand.top;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPeerSite::GetHitTestCookie
//
//----------------------------------------------------------------------------
HRESULT
CPeerHolder::CPeerSite::GetHitTestCookie(LONG *plCookie)
{
    if (PH()->IllegalSiteCall() || !PH()->_pRenderBag)
        RRETURN(E_UNEXPECTED);

    if (!plCookie)
        RRETURN(E_POINTER);

    *plCookie = PH()->CookieID();

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPeerSite::DrawUnfiltered, per IHTMLFilterPaintSite
//
//----------------------------------------------------------------------------

HRESULT
CPeerHolder::CPeerSite::DrawUnfiltered(HDC hdc, IUnknown *punkDrawObject,
                                       RECT rcBounds, RECT rcUpdate,
                                       LONG lDrawLayers)
{
    HRESULT     hr = S_OK;
    RENDER_CALLBACK_INFO *pCallbackInfo;

    if (PH()->IllegalSiteCall() || !PH()->_pRenderBag || !PH()->_pElement->IsInMarkup())
        RRETURN(E_UNEXPECTED);

    Assert(!PH()->_pRenderBag->_fInFilterCallback);

    PH()->_pRenderBag->_fInFilterCallback = TRUE;

    pCallbackInfo = PH()->_pRenderBag->_pCallbackInfo;
    CDispDrawContext *pContext = pCallbackInfo ? (CDispDrawContext*)pCallbackInfo->_pContext
                                                : NULL;

    CElement * pElemToUse = GetElementToUseForPageTransitions();
    if(!pElemToUse)
        RRETURN(E_UNEXPECTED);

    hr = Doc()->GetView()->RenderElement(
                                pElemToUse,
                                pContext,
                                hdc,
                                punkDrawObject,
                                &rcBounds,
                                &rcUpdate,
                                lDrawLayers);

    PH()->_pRenderBag->_fInFilterCallback = FALSE;

    // Since we're drawing to a surface that may need to be used immediately,
    // flush the GDI batch to make sure it's complete before leaving this
    // method.  GdiFlush can return an error that drawing failed, but it's
    // probably not the concern of this function to return that error.

    ::GdiFlush();

    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPeerSite::HitTestPointUnfiltered, per IHTMLFilterPaintSite
//
//----------------------------------------------------------------------------

HRESULT
CPeerHolder::CPeerSite::HitTestPointUnfiltered(POINT pt, LONG lDrawLayers, BOOL *pbHit)
{
    if (PH()->IllegalSiteCall() || !PH()->_pRenderBag || !PH()->_pElement->IsInMarkup())
        RRETURN(E_UNEXPECTED);
    // For page transitions we attach filters to the root element (only element available)
    // at that time and delagate everything to the body or frameset element.
    CElement   * pElemToUse = GetElementToUseForPageTransitions();

    if (!pElemToUse)
        RRETURN(E_UNEXPECTED);

    CLayoutContext * pLayoutContext = GetLayoutContext(PH());

    Assert(!PH()->_pRenderBag->_fInFilterCallback);
    Assert(pElemToUse->GetUpdatedLayout(pLayoutContext));
    Assert(PH()->_pRenderBag->_pCallbackInfo);

    CDispNode * pDispNode = pElemToUse->GetUpdatedLayout(pLayoutContext)->GetElementDispNode();
    Assert(pDispNode);

    PH()->_pRenderBag->_fInFilterCallback = TRUE;
    RENDER_CALLBACK_INFO *pCallbackInfo = PH()->_pRenderBag->_pCallbackInfo;

    TraceTag((tagPainterHit, "%x +HitTestUnfiltered at %ld,%ld", this, pt.x, pt.y));

    HRESULT hr = pDispNode->HitTestUnfiltered(
                            (CDispHitContext*)pCallbackInfo->_pContext,
                            PH()->_pRenderBag->_fHitContent,
                            &pt,
                            lDrawLayers,
                            pbHit);

    TraceTag((tagPainterHit, "%x -HitTestUnfiltered at %ld,%ld returns %s",
                        this, pt.x, pt.y, (*pbHit? "true" : "false") ));

    PH()->_pRenderBag->_fInFilterCallback = FALSE;

    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPeerSite::InvalidateRectFiltered, per IHTMLFilterPaintSite
//
//----------------------------------------------------------------------------

HRESULT
CPeerHolder::CPeerSite::InvalidateRectFiltered(RECT *prcInvalid)
{
    if(PH()->IllegalSiteCall() || !PH()->_pRenderBag || !PH()->_pElement->IsInMarkup())
        RRETURN(E_UNEXPECTED);
    // For page transitions we attach filters to the root element (only element available)
    // at that time and delagate everything to the body or frameset element.
    CElement     * pElemToUse = GetElementToUseForPageTransitions();
    if(!pElemToUse)
        RRETURN(E_UNEXPECTED);

    CLayoutContext * pLayoutContext = GetLayoutContext(PH());

    CLayout * pLayout = pElemToUse->GetUpdatedNearestLayout(pLayoutContext); // EnsureLayoutInDefaultContext

    if (!pLayout)
        RRETURN(E_UNEXPECTED);

    CDispNode *pDispNode = pLayout->GetElementDispNode();

    if (pDispNode)
    {
        CRect rc;

        if (!prcInvalid)
        {
            rc.SetRect(pDispNode->GetSize());
            pDispNode->GetMappedBounds(&rc);
        }
        else
        {
            rc = *prcInvalid;
        }

        pDispNode->Invalidate(rc, COORDSYS_BOX, PH()->_pRenderBag->_fSyncRedraw, TRUE);
    }

    RRETURN (S_OK);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPeerSite::InvalidateRgnFiltered, per IHTMLFilterPaintSite
//
//----------------------------------------------------------------------------

HRESULT
CPeerHolder::CPeerSite::InvalidateRgnFiltered(HRGN hrgnInvalid)
{
    if(PH()->IllegalSiteCall()  || !PH()->_pRenderBag || !PH()->_pElement->IsInMarkup())
        RRETURN(E_UNEXPECTED);

    CElement     * pElemToUse = GetElementToUseForPageTransitions();
    if(!pElemToUse)
        RRETURN(E_UNEXPECTED);

    CLayoutContext * pLayoutContext = GetLayoutContext(PH());

    CLayout * pLayout = pElemToUse->GetUpdatedNearestLayout(pLayoutContext); // EnsureLayoutInDefaultContext

    if (!pLayout)
        RRETURN(E_UNEXPECTED);

    CDispNode *pDispNode = pLayout->GetElementDispNode();

    if (pDispNode)
    {
        pDispNode->Invalidate(hrgnInvalid, COORDSYS_BOX, PH()->_pRenderBag->_fSyncRedraw, TRUE);
    }

    RRETURN (S_OK);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPeerSite::ChangeFilterVisibility, per IHTMLFilterPaintSite
//
//----------------------------------------------------------------------------

HRESULT
CPeerHolder::CPeerSite::ChangeFilterVisibility(BOOL fVisible)
{
    if (PH()->IllegalSiteCall() || !PH()->_pRenderBag)
        RRETURN(E_UNEXPECTED);

    CRenderBag *pRenderBag = PH()->_pRenderBag;
    fVisible = !!fVisible;

    if (!!pRenderBag->_fFilterInvisible != !fVisible)
    {
        pRenderBag->_fFilterInvisible = !fVisible;

        TraceTag((tagFilterVisible, "%ls %d (%x) set filVis=%d  Now eltVis=%d filVis=%d",
                    PH()->_pElement->TagName(), PH()->_pElement->SN(), PH()->_pElement,
                    fVisible,
                    !pRenderBag->_fElementInvisible,
                    !pRenderBag->_fFilterInvisible));

        if (!pRenderBag->_fBlockPropertyNotify)
        {
            PH()->_pElement->Doc()->RequestElementChangeVisibility(PH()->_pElement);
        }
    }

    RRETURN (S_OK);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPeerSite::EnsureViewForFilterSite, per IHTMLFilterPaintSite
//
//----------------------------------------------------------------------------

HRESULT
CPeerHolder::CPeerSite::EnsureViewForFilterSite()
{
    if (PH()->IllegalSiteCall() || !PH()->_pRenderBag)
        RRETURN(E_UNEXPECTED);

    PH()->_pElement->Doc()->GetView()->EnsureView(LAYOUT_SYNCHRONOUS);

    RRETURN (S_OK);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPeerSite::GetDirectDraw, per IHTMLFilterPaintSite
//
//----------------------------------------------------------------------------

HRESULT
CPeerHolder::CPeerSite::GetDirectDraw(void ** ppDirectDraw)
{
    HRESULT hr = S_OK;

    LOCK_SECTION(g_csOscCache);

    if (NULL == g_pDirectDraw)
    {
        hr = InitSurface();

        if (FAILED(hr))
        {
            goto done;
        }
    }

    if (g_pDirectDraw)
    {
        hr = g_pDirectDraw->QueryInterface(IID_IDirectDraw, ppDirectDraw);
    }
    else
    {
        hr = E_NOINTERFACE;
    }

done:

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPeerSite::GetFilterFlags, per IHTMLFilterPaintSite
//
//----------------------------------------------------------------------------

HRESULT
CPeerHolder::CPeerSite::GetFilterFlags(DWORD *pdwFlags)
{
    HRESULT hr = S_OK;

    LOCK_SECTION(g_csOscCache);
    CElement * pElemToUse;

    if(!pdwFlags)
    {
        hr = E_POINTER;
        goto Done;
    }

    *pdwFlags = 0l;

    pElemToUse = PH()->_pElement;

    if(pElemToUse && pElemToUse->IsRoot())
    {
        CDocument * pDocument = pElemToUse->DocumentOrPendingDocument();
        if(pDocument && pDocument->HasPageTransitions())
        {
            *pdwFlags |= (DWORD)FILTER_FLAGS_PAGETRANSITION;
        }
    }

Done:
    RRETURN(hr);
}



///////////////////////////////////////////////////////////////////////////
//
// helper class: peers enumerator
//
///////////////////////////////////////////////////////////////////////////

class CPeerEnumerator : IEnumUnknown
{
public:

    // construction and destruction

    CPeerEnumerator (DWORD dwDir, LPTSTR pchCategory, CElement * pElementStart);
    ~CPeerEnumerator();

    static HRESULT Create(DWORD dwDir, LPTSTR pchCategory, CElement * pElementStart, IEnumUnknown ** ppEnumerator);

    // IUnknown

    DECLARE_FORMS_STANDARD_IUNKNOWN(CPeerEnumerator);

    // IEnumUnknown

    STDMETHOD(Next)(ULONG c, IUnknown ** ppUnkBehavior, ULONG * pcFetched);
    STDMETHOD(Skip)(ULONG c);
    STDMETHOD(Reset)(void);
    STDMETHOD(Clone)(IEnumUnknown ** ppEnumerator);

    // helpers

    BOOL Next();

    // data

    DWORD               _dwDir;
    CStr                _cstrCategory;
    CElement *          _pElementStart;
    CTreeNode *         _pNode;
    CElement *          _pElementCurrent;
    CPeerHolder *       _pPeerHolderCurrent;
};

//+---------------------------------------------------------------------------
//
//  Member:     CPeerEnumerator constructor
//
//----------------------------------------------------------------------------

CPeerEnumerator::CPeerEnumerator (DWORD dwDir, LPTSTR pchCategory, CElement * pElementStart)
{
    _ulRefs = 1;

    _dwDir = dwDir;
    _cstrCategory.Set(pchCategory);
    _pElementStart = pElementStart;

    _pNode = NULL;

    _pElementStart->AddRef(); // so that if someone blows this away from tree we won't not crash

    Reset();
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerEnumerator destructor
//
//----------------------------------------------------------------------------

CPeerEnumerator::~CPeerEnumerator()
{
    _pElementStart->Release();

    if (_pNode)
        _pNode->NodeRelease();
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerEnumerator::QueryInterface, per IUnknown
//
//----------------------------------------------------------------------------

STDMETHODIMP
CPeerEnumerator::QueryInterface(REFIID riid, LPVOID * ppv)
{
    if (IsEqualGUID(IID_IUnknown, riid) || IsEqualGUID(IID_IEnumUnknown, riid))
    {
        *ppv = this;
        RRETURN(S_OK);
    }
    else
    {
        *ppv = NULL;
        RRETURN (E_NOINTERFACE);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerEnumerator::Reset, per IEnumUnknown
//
//----------------------------------------------------------------------------

STDMETHODIMP
CPeerEnumerator::Reset(void)
{
    HRESULT hr = S_OK;

    // cleanup previously set values

    if (_pNode)
    {
        _pNode->NodeRelease();
        _pNode = NULL;
    }

    // init

    _pNode = _pElementStart->GetFirstBranch();
    if (!_pNode)
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    hr = THR( _pNode->NodeAddRef() );
    if( hr )
    {
        _pNode = NULL;
        goto Cleanup;
    }

Cleanup:
    RRETURN( hr );
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerEnumerator::Next, helper
//
//----------------------------------------------------------------------------

BOOL
CPeerEnumerator::Next()
{
    if (!_pNode)
        return FALSE;

    for (;;)
    {
        // TODO: what if _pNode goes away after this release?!?!
        _pNode->NodeRelease();

        switch (_dwDir)
        {
        case BEHAVIOR_PARENT:

            _pNode = _pNode->Parent();

            break;
        }

        if (!_pNode)
            return FALSE;

        if( _pNode->NodeAddRef() )
        {
            _pNode = NULL;
            return FALSE;
        }

        _pElementCurrent = _pNode->Element();

        _pPeerHolderCurrent = NULL;

        if (_pElementCurrent->HasPeerHolder())
        {
            if (_pElementCurrent->GetPeerHolder()->IsRelatedMulti(_cstrCategory, &_pPeerHolderCurrent))
                return TRUE;
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerEnumerator::Next, per IEnumUnknown
//
//----------------------------------------------------------------------------

STDMETHODIMP
CPeerEnumerator::Next(ULONG c, IUnknown ** ppUnkBehaviors, ULONG * pcFetched)
{
    ULONG       i;
    HRESULT     hr = S_OK;
    IUnknown ** ppUnk;

    if (0 == c || !ppUnkBehaviors)
        RRETURN (E_INVALIDARG);

    for (i = 0, ppUnk = ppUnkBehaviors; i < c; i++, ppUnk++)
    {
        if (!Next())
        {
            hr = E_FAIL;
            break;
        }

        hr = THR(_pPeerHolderCurrent->QueryPeerInterface(IID_IUnknown, (void**)ppUnk));
        if (hr)
            break;
    }

    if (pcFetched)
        *pcFetched = i;

    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerEnumerator::Skip, per IEnumUnknown
//
//----------------------------------------------------------------------------

STDMETHODIMP
CPeerEnumerator::Skip(ULONG c)
{
    ULONG i;

    for (i = 0; i < c; i++)
    {
        if (!Next())
            break;
    }
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerEnumerator::Clone, per IEnumUnknown
//
//----------------------------------------------------------------------------

STDMETHODIMP
CPeerEnumerator::Clone(IEnumUnknown ** ppEnumerator)
{
    RRETURN (Create(_dwDir, _cstrCategory, _pElementStart, ppEnumerator));
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerEnumerator::Create, per IEnumUnknown
//
//----------------------------------------------------------------------------

HRESULT
CPeerEnumerator::Create(DWORD dwDir, LPTSTR pchCategory, CElement * pElementStart, IEnumUnknown ** ppEnumerator)
{
    HRESULT             hr = S_OK;
    CPeerEnumerator *   pEnumerator = NULL;

    pEnumerator = new CPeerEnumerator (dwDir, pchCategory, pElementStart);
    if (!pEnumerator)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    *ppEnumerator = pEnumerator;

Cleanup:
    // do not do pEnumerator->Release();

    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPeerSite::GetRelatedBehavior, per IElementBehaviorSiteCategory
//
//----------------------------------------------------------------------------

HRESULT
CPeerHolder::CPeerSite::GetRelatedBehaviors (LONG lDir, LPTSTR pchCategory, IEnumUnknown ** ppEnumerator)
{
    if (PH()->IllegalSiteCall())
        RRETURN(E_UNEXPECTED);

    if (BEHAVIOR_PARENT != lDir)
        RRETURN (E_NOTIMPL);

    if (!pchCategory || !ppEnumerator ||
        lDir < BEHAVIOR_FIRSTRELATION || BEHAVIOR_LASTRELATION < lDir)
        RRETURN (E_INVALIDARG);

    RRETURN (CPeerEnumerator::Create(lDir, pchCategory, PH()->_pElement, ppEnumerator));
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPeerSite::OnChanged, per IPropertyNotifySink
//
//----------------------------------------------------------------------------

HRESULT
CPeerHolder::CPeerSite::OnChanged(DISPID dispid)
{
    HRESULT     hr = S_OK;
    CLock       lock(PH()); // reason to lock: whe might run onpropertychange and onreadystatechange scripts here

    if (PH()->IllegalSiteCall())
        RRETURN(E_UNEXPECTED);

    //
    // custom processing
    //

    switch (dispid)
    {
    case DISPID_READYSTATE:
        {
            HRESULT     hr;

            if (PH()->_readyState == READYSTATE_UNINITIALIZED)  // if the peer did not provide connection point
                goto Cleanup;                                   // don't support it's readyState changes

            hr = THR(PH()->UpdateReadyState());
            if (hr)
                goto Cleanup;

            CPeerMgr::UpdateReadyState(PH()->_pElement, PH()->_readyState);

            goto Cleanup; // done
        }
        break;
    }

    //
    // default processing
    //

    if (PH()->_pElement)
    {
        PH()->_pElement->OnPropertyChange(PH()->MapToExternalRange(dispid), 0);
    }

Cleanup:
    RRETURN (hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPeerSite::OnChanged, per IPropertyNotifySink
//
//----------------------------------------------------------------------------

HRESULT
CPeerHolder::CPeerSite::Exec(
    const GUID *    pguidCmdGroup,
    DWORD           nCmdID,
    DWORD           nCmdExecOpt,
    VARIANT *       pvarArgIn,
    VARIANT *       pvarArgOut)
{
    HRESULT     hr = OLECMDERR_E_UNKNOWNGROUP;

    if (!pguidCmdGroup)
        goto Cleanup;

    if (IsEqualGUID(CGID_ElementBehaviorMisc, *pguidCmdGroup))
    {
        hr = OLECMDERR_E_NOTSUPPORTED;

        switch (nCmdID)
        {
        case CMDID_ELEMENTBEHAVIORMISC_GETCONTENTS:

            if (!pvarArgOut)
            {
                hr = E_INVALIDARG;
                goto Cleanup;
            }

            V_VT(pvarArgOut) = VT_BSTR;
            Assert( ETAG_GENERIC_NESTED_LITERAL != PH()->_pElement->Tag() );
            if ( ETAG_GENERIC_LITERAL == PH()->_pElement->Tag() )
            {
                hr = THR(FormsAllocString(
                    DYNCAST(CGenericElement, PH()->_pElement)->_cstrContents,
                    &V_BSTR(pvarArgOut)));
            }
            else
            {
                hr = THR(PH()->_pElement->get_innerHTML(&V_BSTR(pvarArgOut)));
            }

            break;

        case CMDID_ELEMENTBEHAVIORMISC_PUTCONTENTS:

            if (!pvarArgIn ||
                VT_BSTR != V_VT(pvarArgIn))
            {
                hr = E_INVALIDARG;
                goto Cleanup;
            }

            Assert( ETAG_GENERIC_NESTED_LITERAL != PH()->_pElement->Tag() );
            if ( ETAG_GENERIC_LITERAL == PH()->_pElement->Tag() )
            {
                CExtendedTagDesc *  pDesc = PH()->_pElement->GetExtendedTagDesc();

                // for Literal Identity behaviors, we have to dirty the doc
                if (pDesc && pDesc->_fLiteral)
                {
                    // TODO (JHarding): How is undo working with this?  Right now, we're going to
                    // dirty the doc and blow away the undo stack.
                    // TODO (alexz[v]) delete this
                    PH()->_pElement->QueryCreateUndo(TRUE, TRUE);
                }

                hr = THR(DYNCAST(CGenericElement, PH()->_pElement)->_cstrContents.Set(V_BSTR(pvarArgIn)));
            }
            else
            {
                hr = THR(PH()->_pElement->put_innerHTML(V_BSTR(pvarArgIn)));
            }

            break;

        case CMDID_ELEMENTBEHAVIORMISC_GETCURRENTDOCUMENT:

            if (!pvarArgOut)
            {
                hr = E_INVALIDARG;
                goto Cleanup;
            }

            if (PH()->_pElement->IsInMarkup())
            {
                V_VT(pvarArgOut) = VT_UNKNOWN;
                hr = THR(PH()->_pElement->get_document((IDispatch**)&V_UNKNOWN(pvarArgOut)));
            }
            else
            {
                VariantClear(pvarArgOut);
                V_VT(pvarArgOut) = VT_NULL;
                hr = S_OK;
            }

            break;

        case CMDID_ELEMENTBEHAVIORMISC_ISSYNCHRONOUSBEHAVIOR:

            if (!pvarArgOut)
            {
                hr = E_INVALIDARG;
                goto Cleanup;
            }

            hr = S_OK;

            // TODO (alexz) reconsider a better way to do this

            V_VT(pvarArgOut) = VT_I4;
            // V_I4(pvarArgOut) is now fRequestSynchronous

            if (PH()->IsIdentityPeer())
            {
                // identity peer can be asynchronous only when it is to be created for an element
                // in a markup being asynchronously parsed at this moment

                CMarkup * pMarkup = PH()->_pElement->GetMarkup();

                if (pMarkup)
                {
                    if (pMarkup->_LoadStatus < LOADSTATUS_QUICK_DONE)
                    {
                        // markup parsing is in progress

                        Assert (pMarkup->HtmCtx());

                        if (pMarkup->HtmCtx()->IsSyncParsing())
                        {
                            // the markup is being parsed synchronously, so request the identity peer
                            // to be created synchronously too
                            V_I4(pvarArgOut) = TRUE;
                        }
                        else
                        {
                            // the markup is being parsed asynchronously, so we can suspend parser
                            // if necessary and therefore we don't need to request synchronous creation

                            V_I4(pvarArgOut) = FALSE;
                        }
                    }
                    else
                    {
                        // element is created after markup has been parsed (using OM)
                        // so the identity peer is required to be synchronous
                        V_I4(pvarArgOut) = TRUE;
                    }
                }
                else
                {
                    // element is created outside markup (using OM), so the identity peer is
                    // required to be synchronous
                    V_I4(pvarArgOut) = TRUE;
                }
            }
            else
            {
                // attached peers never required to be synchronous
                V_I4(pvarArgOut) = FALSE;
            }


            break;

        case CMDID_ELEMENTBEHAVIORMISC_REQUESTBLOCKPARSERWHILEINCOMPLETE:

            // honor this only for identity behaviors
            if (PH()->IsIdentityPeer())
            {
                PH()->SetFlag(BLOCKPARSERWHILEINCOMPLETE);
            }
            hr = S_OK;

            break;

        }
    }

Cleanup:
    RRETURN (hr);
}

HRESULT
CPeerHolder::CPeerSite::GetFontInfo(LOGFONTW* plf)
{
    HRESULT hr = E_FAIL;

    if (!plf)
    {
        hr = E_POINTER;
    }
    else
    {
        CElement * pElem = PH()->_pElement;
        if (pElem && pElem->IsInMarkup())
        {
            CDocInfo dci(pElem);
            XHDC hdc(pElem->Doc()->GetHDC(), NULL);
            CCharFormat const * pcf = pElem->GetFirstBranch()->GetCharFormat();

            CCcs ccs;
            if (fc().GetCcs(&ccs, hdc, &dci, pcf))
            {
                const CBaseCcs * pBaseCcs = ccs.GetBaseCcs();
                if (pBaseCcs->GetLogFont(plf))
                    hr = S_OK;
            }
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\peerxtag.cxx ===
//+---------------------------------------------------------------------
//
//  File:       peerxtag.cxx
//
//  Classes:    CExtendedTagTable, etc.
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_PEERXTAG_HXX_
#define X_PEERXTAG_HXX_
#include "peerxtag.hxx"
#endif

#ifndef X_PEERFACT_HXX_
#define X_PEERFACT_HXX_
#include "peerfact.hxx"
#endif

#ifndef X_HTC_HXX_
#define X_HTC_HXX_
#include "htc.hxx"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#define _cxx_
#include "peerxtag.hdl"

///////////////////////////////////////////////////////////////////////////
//
//  misc
//
///////////////////////////////////////////////////////////////////////////

#define HASHBOOST

// HASHBOOST notes. ..todo

MtDefine(CExtendedTagDesc,                      Behaviors,              "CExtendedTagDesc");
MtDefine(CExtendedTagDescBuiltin,               Behaviors,              "CExtendedTagDescBuiltin");
MtDefine(CExtendedTagNamespace,                 Behaviors,              "CExtendedTagNamespace");
MtDefine(CExtendedTagNamespaceBuiltin,          Behaviors,              "CExtendedTagNamespaceBuiltin");
MtDefine(CExtendedTagTable,                     Behaviors,              "CExtendedTagTable");
MtDefine(CExtendedTagTableBooster,              Behaviors,              "CExtendedTagTableBooster");

MtDefine(CExtendedTagNamespace_CItemsArray,     CExtendedTagNamespace,  "CExtendedTagNamespace::CItemsArray");
MtDefine(CExtendedTagTable_CItemsArray,         CExtendedTagTable,      "CExtendedTagTable::CItemsArray");

MtDefine(CHTMLNamespace,                        Behaviors,              "CHTMLNamespace")
MtDefine(CHTMLNamespaceCollection,              Behaviors,              "CHTMLNamespaceCollection")

DeclareTag(tagPeerExtendedTagNamespace,             "Peer",                   "trace CExtendedTagTable namespaces")
DeclareTag(tagPeerExtendedTagDesc,                  "Peer",                   "trace CExtendedTagTable tag descs")
DeclareTag(tagPeerExtendedTagTableBooster,          "Peer",                   "trace CExtendedTagTableBooster hits and misses")
DeclareTag(tagPeerExtendedTagTableBoosterResults,   "Peer",                   "trace CExtendedTagTableBooster results")

DeclareTag(tagPeerExtendedTagHostResolve,           "Peer",             "Trace host tag resolution")

const CBase::CLASSDESC CHTMLNamespaceCollection::s_classdesc =
{
    &CLSID_HTMLNamespaceCollection,         // _pclsid
    0,                                      // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                                   // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                                   // _pcpi
    0,                                      // _dwFlags
    &IID_IHTMLNamespaceCollection,          // _piidDispinterface
    &s_apHdlDescs                           // _apHdlDesc
};

const CBase::CLASSDESC CHTMLNamespace::s_classdesc =
{
    &CLSID_HTMLNamespace,                   // _pclsid
    0,                                      // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                                   // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                                   // _pcpi
    0,                                      // _dwFlags
    &IID_IHTMLNamespace,                    // _piidDispinterface
    &s_apHdlDescs                           // _apHdlDesc
};

EXTERN_C const GUID SID_SXmlNamespaceMapping = {0x3050f628,0x98b5,0x11cf, {0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b}};
EXTERN_C const GUID CGID_XmlNamespaceMapping = {0x3050f629,0x98b5,0x11cf, {0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b}};
#define XMLNAMESPACEMAPPING_GETURN 1

///////////////////////////////////////////////////////////////////////////
//
//  misc helpers
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Helper:     TraceNamespace
//
//-------------------------------------------------------------------------

#if DBG == 1
void
TraceNamespace(LPTSTR pchEvent, CExtendedTagNamespace * pSyncItem)
{
    TraceTag((
        tagPeerExtendedTagNamespace,
        "%ls, [%lx] namespace = '%ls', factory = '%ls'",
        pchEvent,
        pSyncItem,
        STRVAL(pSyncItem->_cstrNamespace),
        STRVAL(pSyncItem->_cstrFactoryUrl)));
}
#endif

//+------------------------------------------------------------------------
//
//  Helper:     IsDefaultNamespace
//
//-------------------------------------------------------------------------

inline BOOL IsDefaultNamespace(LPTSTR pchNamespace, LONG cchNamespace = -1)
{
    if (!pchNamespace)
        return TRUE;

    if (-1 == cchNamespace)
    {
        return 0 == StrCmpIC(DEFAULT_NAMESPACE, pchNamespace);
    }
    else
    {
        return cchNamespace == DEFAULT_NAMESPACE_LEN && 0 == StrCmpIC(DEFAULT_NAMESPACE, pchNamespace);
    }
}

//+------------------------------------------------------------------------
//
//  Helper:     IsDefaultUrn
//
//-------------------------------------------------------------------------

inline BOOL IsDefaultUrn(LPTSTR pchUrn, LONG cchUrn = -1)
{
    if (!pchUrn)
        return FALSE;

    if (-1 == cchUrn)
    {
        return 0 == StrCmpIC(DEFAULT_NAMESPACE_URN, pchUrn);
    }
    else
    {
        return cchUrn == DEFAULT_NAMESPACE_URN_LEN && 0 == StrCmpIC(DEFAULT_NAMESPACE_URN, pchUrn);
    }
}

///////////////////////////////////////////////////////////////////////////
//
//  Class:      CBuiltinTagDesc
//
///////////////////////////////////////////////////////////////////////////

//
// NOTE when changing this table, also change CExtendedTagNamespaceBuiltin::_aryItemsBuiltin size.
// (this is asserted in the code anyway)

const CTagDescBuiltin g_aryTagDescsBuiltin[] =
{
    {_T("XML"),        ETAG_GENERIC_LITERAL,    CTagDescBuiltin::TYPE_OLE,      {0x379E501F, 0xB231, 0x11d1, 0xad, 0xc1, 0x00, 0x80, 0x5F, 0xc7, 0x52, 0xd8}},
    {_T("HTC"),        ETAG_GENERIC_BUILTIN,    CTagDescBuiltin::TYPE_HTC,      HTC_BEHAVIOR_DESC},
    {_T("COMPONENT"),  ETAG_GENERIC_BUILTIN,    CTagDescBuiltin::TYPE_HTC,      HTC_BEHAVIOR_DESC},
    {_T("PROPERTY"),   ETAG_GENERIC_BUILTIN,    CTagDescBuiltin::TYPE_HTC,      HTC_BEHAVIOR_PROPERTY},
    {_T("METHOD"),     ETAG_GENERIC_BUILTIN,    CTagDescBuiltin::TYPE_HTC,      HTC_BEHAVIOR_METHOD},
    {_T("EVENT"),      ETAG_GENERIC_BUILTIN,    CTagDescBuiltin::TYPE_HTC,      HTC_BEHAVIOR_EVENT},
    {_T("ATTACH"),     ETAG_GENERIC_BUILTIN,    CTagDescBuiltin::TYPE_HTC,      HTC_BEHAVIOR_ATTACH},
    {_T("PUT"),        ETAG_GENERIC_BUILTIN,    CTagDescBuiltin::TYPE_HTC,      HTC_BEHAVIOR_NONE},
    {_T("GET"),        ETAG_GENERIC_BUILTIN,    CTagDescBuiltin::TYPE_HTC,      HTC_BEHAVIOR_NONE},
    {_T("DEFAULTS"),   ETAG_GENERIC_BUILTIN,    CTagDescBuiltin::TYPE_HTC,      HTC_BEHAVIOR_DEFAULTS},
#ifdef NEW_SELECT // TODO (alexz) the clsid should be switched to "#default#select" for perf reasons
    {_T("SELECT"),     ETAG_SELECT,             CTagDescBuiltin::TYPE_OLE,      {0x3050f688, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b}},
#endif
    {NULL}
};

//+------------------------------------------------------------------------
//
//  Helper:     GetTagDescBuiltinIdx
//
//-------------------------------------------------------------------------

LONG
GetTagDescBuiltinIdx(const CTagDescBuiltin * pTagDescBuiltin)
{
    return pTagDescBuiltin - g_aryTagDescsBuiltin;
}

//+------------------------------------------------------------------------
//
//  Helper:     GetTagDescBuiltin
//
//-------------------------------------------------------------------------

const CTagDescBuiltin *
GetTagDescBuiltin(LPTSTR pchName, CExtendedTagTable * pTable)
{
    const CTagDescBuiltin * pTagDescBuiltin;

    Assert (NULL == StrChr(pchName, _T(':')));

#ifdef HASHBOOST
    LONG        idx;

    idx = pTable->GetHint(g_aryTagDescsBuiltin, pchName);
    if (0 <= idx && idx < ARRAY_SIZE(g_aryTagDescsBuiltin) - 1)
    {
        pTagDescBuiltin = &g_aryTagDescsBuiltin[idx];
        if (0 == StrCmpIC(pchName, pTagDescBuiltin->pchTagName))
        {
            TraceTag ((tagPeerExtendedTagTableBoosterResults, "::GetTagDescBuiltin:                HIT for %ls", pchName));

            return pTagDescBuiltin;
        }
    }
#endif

    TraceTag ((tagPeerExtendedTagTableBoosterResults, "::GetTagDescBuiltin:                LOOKUP %ld for %ls", ARRAY_SIZE(g_aryTagDescsBuiltin) - 1, pchName));

    for (pTagDescBuiltin = g_aryTagDescsBuiltin; pTagDescBuiltin->pchTagName; pTagDescBuiltin++)
    {
        if (0 == StrCmpIC(pchName, pTagDescBuiltin->pchTagName))
        {
#ifdef HASHBOOST
            pTable->SetHint(g_aryTagDescsBuiltin, pchName, pTagDescBuiltin - g_aryTagDescsBuiltin);
#endif
            return pTagDescBuiltin;
        }
    }

    return NULL;
}

///////////////////////////////////////////////////////////////////////////
//
//  Class:      CExtendedTagDesc
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagDesc::CExtendedTagDesc
//
//-------------------------------------------------------------------------

CExtendedTagDesc::CExtendedTagDesc()
{
    AddRef();
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagDesc::~CExtendedTagDesc
//
//-------------------------------------------------------------------------

CExtendedTagDesc::~CExtendedTagDesc()
{
    if (_pPeerFactory)
    {
        _pPeerFactory->Release();
    }

    _cstrTagName.Free();

    if (_pNamespace)
        _pNamespace->SubRelease();
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagDesc::QueryInterface, per IUnknown
//
//-------------------------------------------------------------------------

HRESULT
CExtendedTagDesc::QueryInterface(REFIID iid, LPVOID * ppv)
{
    *ppv = NULL;

    switch (iid.Data1)
    {
    QI_INHERITS(this, IUnknown)
    }

    if (*ppv)
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }
    else
    {
        RRETURN (E_NOTIMPL);
    }
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagDesc::Init
//
//-------------------------------------------------------------------------

HRESULT
CExtendedTagDesc::Init(CExtendedTagNamespace * pNamespace, LPTSTR pchTagName, CPeerFactory * pPeerFactory, ELEMENT_TAG etagBase, BOOL fLiteral)
{
    HRESULT     hr = S_OK;

    Assert (pNamespace && pchTagName && ETAG_NULL != etagBase);
    Assert (!_pNamespace && _cstrTagName.IsNull() && ETAG_NULL == _etagBase);

    _pPeerFactory = pPeerFactory;
    if (_pPeerFactory)
    {
        _pPeerFactory->AddRef();
    }

    _pNamespace = pNamespace;
    _pNamespace->SubAddRef();

    _etagBase = etagBase;
    _fLiteral = fLiteral;

    hr = THR(_cstrTagName.Set(pchTagName));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagDesc::Namespace
//
//-------------------------------------------------------------------------

LPTSTR
CExtendedTagDesc::Namespace()
{
    Assert (_pNamespace && _pNamespace->_cstrNamespace.Length());
    return _pNamespace->_cstrNamespace;
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagDesc::TagName
//
//-------------------------------------------------------------------------

LPTSTR
CExtendedTagDesc::TagName()
{
    return _cstrTagName;
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagDesc::Urn
//
//-------------------------------------------------------------------------

LPTSTR
CExtendedTagDesc::Urn()
{
    Assert (_pNamespace);
    return _pNamespace->_cstrUrn;
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagDesc::Implementation
//
//-------------------------------------------------------------------------

LPTSTR
CExtendedTagDesc::Implementation()
{
    if (_pPeerFactory)
    {
        return _pPeerFactory->GetUrl();
    }
    else
    {
        return NULL;
    }
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagDesc::IsPIRequired
//
//-------------------------------------------------------------------------

BOOL
CExtendedTagDesc::IsPIRequired()
{
    Assert (_pNamespace);
    return !_pNamespace->_fNonPersistable;
}

///////////////////////////////////////////////////////////////////////////
//
//  Class:      CExtendedTagDescBuiltin
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagDescBuiltin::CExtendedTagDescBuiltin
//
//-------------------------------------------------------------------------

CExtendedTagDescBuiltin::CExtendedTagDescBuiltin()
{
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagDescBuiltin::~CExtendedTagDescBuiltin
//
//-------------------------------------------------------------------------

CExtendedTagDescBuiltin::~CExtendedTagDescBuiltin()
{
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagDescBuiltin::Init
//
//-------------------------------------------------------------------------

HRESULT
CExtendedTagDescBuiltin::Init(CExtendedTagNamespace * pNamespace, const CTagDescBuiltin * pTagDescBuiltin)
{
    HRESULT     hr = S_OK;

    Assert (pNamespace && pTagDescBuiltin);
    Assert (!_pNamespace && _cstrTagName.IsNull());

    _pNamespace = pNamespace;
    _pNamespace->SubAddRef();

    hr = THR(_cstrTagName.Set(pTagDescBuiltin->pchTagName));
    if (hr)
        goto Cleanup;

    _etagBase = pTagDescBuiltin->etagBase;

    hr = THR(_factory.Init(pTagDescBuiltin));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN (hr);
}

///////////////////////////////////////////////////////////////////////////
//
//  Class:      CExtendedTagNamespace
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagNamespace constructor
//
//-------------------------------------------------------------------------

CExtendedTagNamespace::CExtendedTagNamespace(CExtendedTagTable * pTable)
{
    _pTable = pTable;

    AddRef();
    SubAddRef();
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagNamespace destructor
//
//-------------------------------------------------------------------------

CExtendedTagNamespace::~CExtendedTagNamespace()
{
    _cstrNamespace.Free();
    _cstrUrn.Free();
    _cstrFactoryUrl.Free();
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagNamespace::Passivate
//
//-------------------------------------------------------------------------

void
CExtendedTagNamespace::Passivate()
{
    int         c;
    CItem **    ppItem;

    for (ppItem = _aryItems, c = _aryItems.Size(); 0 < c; ppItem++, c--)
    {
        (*ppItem)->Release();
    }
    _aryItems.DeleteAll();

    ClearFactory();
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagNamespace::PrivateQueryInterface, per IUnknown
//
//-------------------------------------------------------------------------

HRESULT
CExtendedTagNamespace::QueryInterface(REFIID iid, LPVOID * ppv)
{
    *ppv = NULL;

    switch (iid.Data1)
    {
    QI_INHERITS((IElementNamespace*)this, IUnknown)
    QI_INHERITS(this, IElementNamespace)
    QI_INHERITS(this, IServiceProvider)
    QI_INHERITS(this, IElementNamespacePrivate)
    }

    if (*ppv)
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }
    else
    {
        RRETURN (E_NOTIMPL);
    }
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagTable::QueryService, per IServiceProvider
//
//-------------------------------------------------------------------------

STDMETHODIMP
CExtendedTagNamespace::QueryService(REFGUID rguidService, REFIID riid, void ** ppvService)
{
    HRESULT     hr = E_NOINTERFACE;

    if (IsEqualGUID(rguidService, CLSID_HTMLDocument) && _pTable)
    {
        (*ppvService) = _pTable->_pDoc;
        hr = S_OK;
    }
    else if( IsEqualGUID(rguidService, CLSID_CMarkup) && _pTable)
    {
        (*ppvService) = _pTable->_pMarkup;
        hr = S_OK;
    }
    else
    {
        hr = E_NOINTERFACE;
    }

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagNamespace::Init
//
//-------------------------------------------------------------------------

HRESULT
CExtendedTagNamespace::Init(LPTSTR pchNamespace, LPTSTR pchUrn)
{
    HRESULT     hr = S_OK;

    Assert (_cstrNamespace.IsNull() && _cstrUrn.IsNull());

    if (pchNamespace)
    {
        hr = THR(_cstrNamespace.Set(pchNamespace));
    }

    if (pchUrn)
    {
        hr = THR(_cstrUrn.Set(pchUrn));
    }

#if DBG == 1
    TraceNamespace(_T("CExtendedTagNamespace::Init"), this);
#endif

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagNamespace::ClearFactory
//
//-------------------------------------------------------------------------

HRESULT
CExtendedTagNamespace::ClearFactory()
{
    HRESULT     hr = S_OK;

    if (_pPeerFactory)
    {
        _pPeerFactory->Release();
        _pPeerFactory = NULL;
    }

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagNamespace::SetFactory
//
//-------------------------------------------------------------------------

HRESULT
CExtendedTagNamespace::SetFactory(CPeerFactory * pFactory, BOOL fPeerFactoryUrl)
{
    HRESULT     hr;

    hr = THR(ClearFactory());
    if (hr)
        goto Cleanup;

    _pPeerFactory = pFactory;
    if (_pPeerFactory)
        _pPeerFactory->AddRef();

    _fPeerFactoryUrl = fPeerFactoryUrl;

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagNamespace::SetFactory
//
//-------------------------------------------------------------------------

HRESULT
CExtendedTagNamespace::SetFactory(CMarkup * pMarkup, LPTSTR pchFactoryUrl)
{
    HRESULT             hr = S_OK;
    CPeerFactoryUrl *   pFactory;
    TCHAR               achFactoryUrl[pdlUrlLen];
    CDoc *              pDoc;

    Assert (pMarkup);

    pDoc = pMarkup->Doc();

    if (pchFactoryUrl)
    {
        if (_T('#') != pchFactoryUrl[0])
        {
            hr = THR(CMarkup::ExpandUrl(pMarkup, pchFactoryUrl, ARRAY_SIZE(achFactoryUrl), achFactoryUrl, NULL));
            if (hr)
                goto Cleanup;

            pchFactoryUrl = achFactoryUrl;
        }

        hr = THR_NOTRACE(pDoc->EnsurePeerFactoryUrl(pchFactoryUrl, NULL, pMarkup, &pFactory));
        if (hr)
        {
            // failed to ensure peer factory - for example, because of E_ACCESSDENIED or unavailable file.
            // in this case the entry in the table will only define a namespace valid for sprinkles
            if (E_ACCESSDENIED == hr)
            {
                ReportAccessDeniedError (/* pElement = */NULL, pMarkup, pchFactoryUrl);
            }

            hr = THR(ClearFactory());
            goto Cleanup;
        }

        hr = THR(_cstrFactoryUrl.Set(pchFactoryUrl));
        if (hr)
            goto Cleanup;

        hr = THR(SetFactory(pFactory, /* fPeerFactoryUrl */TRUE));
        if (hr)
            goto Cleanup;
    }

Cleanup:
#if DBG == 1
    TraceNamespace(_T("CExtendedTagNamespace::SetFactory"), this);
#endif

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagNamespace::Sync1
//
//-------------------------------------------------------------------------

HRESULT
CExtendedTagNamespace::Sync1(SYNCMODE syncMode)
{
    HRESULT     hr = S_OK;

    Assert (_fPeerFactoryUrl && _pPeerFactory);

    switch (syncMode)
    {
    case SYNCMODE_TABLE:
        _fSyncTable = TRUE;
        break;

    case SYNCMODE_COLLECTIONITEM:
        _fSyncTable = FALSE;
        Assert (_pCollectionItem);
        _pCollectionItem->AddRef();
        break;
    }

    hr = THR(DYNCAST(CPeerFactoryUrl, _pPeerFactory)->SyncETN(this));

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagNamespace::Sync2
//
//-------------------------------------------------------------------------

HRESULT
CExtendedTagNamespace::Sync2()
{
    HRESULT     hr = S_OK;

    if (_fSyncTable)
    {
        Assert (_pTable);
        hr = THR(_pTable->Sync2());
        if (hr)
            goto Cleanup;
    }
    else
    {
        Assert (_pCollectionItem);

        hr = THR(_pCollectionItem->OnImportComplete());
        if (hr)
            goto Cleanup;

        _pCollectionItem->Release();
    }

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagNamespace::SyncAbort
//
//-------------------------------------------------------------------------

HRESULT
CExtendedTagNamespace::SyncAbort()
{
    HRESULT     hr;

    Assert (_fPeerFactoryUrl);

    hr = THR(DYNCAST(CPeerFactoryUrl, _pPeerFactory)->SyncETNAbort(this));

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagNamespace::FindTagDesc
//
//-------------------------------------------------------------------------

CExtendedTagDesc *
CExtendedTagNamespace::FindTagDesc(LPTSTR pchTagName)
{
    LONG        c;
    CItem **    ppItem;

#ifdef HASHBOOST
    LONG        idx;

    if (_pTable)
    {
        idx = _pTable->GetHint(this, pchTagName);
        if (0 <= idx && idx < _aryItems.Size())
        {
            _ppLastItem = &_aryItems[idx];
        }
    }
#endif

    // check last item value
    if (_ppLastItem)
    {
        if (0 == StrCmpIC((*_ppLastItem)->_cstrTagName, pchTagName))
        {
            TraceTag ((tagPeerExtendedTagTableBoosterResults, "CExtendedTagNamespace::FindTagDesc: HIT for %ls", pchTagName));
            goto Cleanup;
        }
    }

    TraceTag ((tagPeerExtendedTagTableBoosterResults, "CExtendedTagNamespace::FindTagDesc: LOOKUP {%ld} for %ls", _aryItems.Size(), pchTagName));

    // search the array
    for (ppItem = _aryItems, c = _aryItems.Size(); 0 < c; ppItem++, c--)
    {
        if (ppItem != _ppLastItem &&
            0 == StrCmpIC((*ppItem)->_cstrTagName, pchTagName))
        {
            // found
            _ppLastItem = ppItem;
            Assert (*_ppLastItem);

#ifdef HASHBOOST
            if (_pTable)
            {
                _pTable->SetHint(this, pchTagName, _ppLastItem - &(_aryItems[0]));
            }
#endif

            goto Cleanup; // done
        }
    }

    // failed to find
    _ppLastItem = NULL;

Cleanup:

    return _ppLastItem ? (*_ppLastItem) : NULL;
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagNamespace::AddTagDesc, helper
//
//-------------------------------------------------------------------------

HRESULT
CExtendedTagNamespace::AddTagDesc(LPTSTR pchTagName, BOOL fOverride, LPTSTR pchBaseTagName, DWORD dwFlags, CExtendedTagDesc ** ppDesc)
{
    HRESULT             hr = S_OK;
    ELEMENT_TAG         etagBase;
    CItem *             pItem;
    CExtendedTagDesc *  pTagDesc;
    BOOL                fLiteral;

    //
    // startup
    //

    Assert (pchTagName && pchTagName[0]);

    if (!ppDesc)
        ppDesc = &pItem;

    *ppDesc = NULL;

    pItem = FindTagDesc(pchTagName);

    if (pItem && !fOverride)
    {
        *ppDesc = pItem;
        goto Cleanup;   // done
    }

    switch( dwFlags )
    {
    case ELEMENTDESCRIPTORFLAGS_NESTED_LITERAL:
        etagBase = ETAG_GENERIC_NESTED_LITERAL;
        fLiteral = TRUE;
        break;
    case ELEMENTDESCRIPTORFLAGS_LITERAL:
        etagBase = ETAG_GENERIC_LITERAL;
        fLiteral = TRUE;
        break;
    default:
        etagBase = ETAG_GENERIC;
        fLiteral = FALSE;
    }

    // TODO (jharding, alexz): We need to revisit literal parsing for derived tags, when we support it
    etagBase = pchBaseTagName ? EtagFromName(pchBaseTagName, _tcslen(pchBaseTagName)) : etagBase;

    //
    // create the new desc
    //

    pTagDesc = new CExtendedTagDesc();
    if (!pTagDesc)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

#if DBG == 1
    TraceNamespace(_T("CExtendedTagNamespace::AddTagDesc"), this);
    TraceTag((tagPeerExtendedTagDesc, "             tagDesc: [%lx], tagName = '%ls'", pTagDesc, STRVAL(pchTagName)));
#endif

    hr = THR(pTagDesc->Init(this, pchTagName, _pPeerFactory, etagBase, fLiteral));
    if (hr)
        goto Cleanup;

    //
    // put it in the array
    //

    if (!pItem)
    {
        // normal case, tag desc for the tagName not found

        hr = THR(_aryItems.AppendIndirect(&pTagDesc));
        if (hr)
            goto Cleanup;

        _ppLastItem = &_aryItems[_aryItems.Size() - 1];
    }
    else
    {
        // unusual case, the call overrides tagName previously registered

        Assert (_ppLastItem);

        (*_ppLastItem)->Release();  // release the previous tagDesc for tagName

        (*_ppLastItem) = pTagDesc;  // store the new one in the table
    }

    Assert (*_ppLastItem);

    //
    // finalize
    //

#ifdef HASHBOOST
    if (_pTable)
    {
        _pTable->SetHint(this, pchTagName, _ppLastItem - &_aryItems[0]);
    }
#endif

    *ppDesc = pTagDesc;

Cleanup:

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagNamespace::AddTag, per IElementIdentityTableNamespace
//  AND         CExtendedTagNamespace::AddTagPrivate, per IElementNamespacePrivate
//
//-------------------------------------------------------------------------

HRESULT
CExtendedTagNamespace::AddTag(BSTR bstrTagName, LONG lFlags)
{
    if(     lFlags & ELEMENTDESCRIPTORFLAGS_LITERAL
        &&  lFlags & ELEMENTDESCRIPTORFLAGS_NESTED_LITERAL )
    {
        RRETURN( E_INVALIDARG );
    }
    else
    {
        RRETURN( AddTagPrivate( bstrTagName, NULL, lFlags ) );
    }
}

HRESULT
CExtendedTagNamespace::AddTagPrivate(BSTR bstrTagName, BSTR bstrBaseTagName, LONG lFlags)
{
    HRESULT     hr;
    LPTSTR      pchBaseTagName  = NULL;

    Assert( !(     lFlags & ELEMENTDESCRIPTORFLAGS_LITERAL
               &&  lFlags & ELEMENTDESCRIPTORFLAGS_NESTED_LITERAL ) );

    if (!_fExternalUpdateAllowed)
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    if (!bstrTagName || !bstrTagName[0] ||
        (bstrBaseTagName && !bstrBaseTagName[0]))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // (for trident v3 baseTagName is publicly disabled, but it is still privately exercised in DRT to maintain the codepath alive)
#if 1
    if (bstrBaseTagName)
    {
        Assert (6 == _tcslen(_T("__MS__")));

        if (6 <= FormsStringLen(bstrBaseTagName) &&
            0 == StrCmpNIC(_T("__MS__"), bstrBaseTagName, 6))
        {
            pchBaseTagName = bstrBaseTagName + 6;
        }
        else
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }
    }
#endif

    hr = THR(AddTagDesc(bstrTagName, /* fOverride = */TRUE, pchBaseTagName, lFlags));

Cleanup:
    RRETURN (hr);
}


///////////////////////////////////////////////////////////////////////////
//
//  Class:      CExtendedTagNamespace::CExternalUpdateLock
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagNamespace::CExternalUpdateLock constructor
//
//-------------------------------------------------------------------------

CExtendedTagNamespace::CExternalUpdateLock::CExternalUpdateLock(CExtendedTagNamespace * pNamespace, CPeerFactory * pPeerFactory)
{
    Assert (pNamespace && pPeerFactory);

    _pNamespace = pNamespace;

    _pPeerFactoryPrevious = _pNamespace->_pPeerFactory;
    _pNamespace->_pPeerFactory = pPeerFactory;

    Assert (!_pNamespace->_fExternalUpdateAllowed);
    _pNamespace->_fExternalUpdateAllowed = TRUE;
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagNamespace::CExternalUpdateLock destructor
//
//-------------------------------------------------------------------------

CExtendedTagNamespace::CExternalUpdateLock::~CExternalUpdateLock()
{
    _pNamespace->_pPeerFactory = _pPeerFactoryPrevious;

    Assert (_pNamespace->_fExternalUpdateAllowed);
    _pNamespace->_fExternalUpdateAllowed = FALSE;
};

///////////////////////////////////////////////////////////////////////////
//
//  Class:      CExtendedTagNamespaceBuiltin
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagNamespaceBuiltin constructor
//
//-------------------------------------------------------------------------

CExtendedTagNamespaceBuiltin::CExtendedTagNamespaceBuiltin(CExtendedTagTable * pExtendedTagTable) :
    CExtendedTagNamespace(pExtendedTagTable)
{
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagNamespaceBuiltin destructor
//
//-------------------------------------------------------------------------

CExtendedTagNamespaceBuiltin::~CExtendedTagNamespaceBuiltin()
{
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagNamespaceBuiltin::Passivate
//
//-------------------------------------------------------------------------

void
CExtendedTagNamespaceBuiltin::Passivate()
{
    int                         i;
    CExtendedTagDescBuiltin **  ppTagDescBuiltin;

    for (i = 0, ppTagDescBuiltin = _aryItemsBuiltin; i < BUILTIN_COUNT; i++, ppTagDescBuiltin++)
    {
        if (*ppTagDescBuiltin)
        {
            (*ppTagDescBuiltin)->Release();
        }
    }

    super::Passivate();
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagNamespaceBuiltin::FindTagDesc
//
//-------------------------------------------------------------------------

CExtendedTagDesc *
CExtendedTagNamespaceBuiltin::FindTagDesc(LPTSTR pchTagName)
{
    HRESULT                     hr;
    CExtendedTagDesc *          pTagDesc = NULL;
    const CTagDescBuiltin *     pTagDescBuiltin;
    CExtendedTagDescBuiltin **  ppTagDesc;

    pTagDesc = super::FindTagDesc(pchTagName);

    if (!pTagDesc)
    {
        pTagDescBuiltin = GetTagDescBuiltin(pchTagName, _pTable);

        if (pTagDescBuiltin)
        {
            Assert (ARRAY_SIZE(_aryItemsBuiltin) == ARRAY_SIZE(g_aryTagDescsBuiltin) - 1);

            ppTagDesc = &_aryItemsBuiltin[GetTagDescBuiltinIdx(pTagDescBuiltin)];

            if (!(*ppTagDesc))
            {
                *ppTagDesc = new CExtendedTagDescBuiltin();
                if (!(*ppTagDesc))
                    goto Cleanup;

                hr = THR((*ppTagDesc)->Init(this, pTagDescBuiltin));
                if (hr)
                    goto Cleanup;

            }

            pTagDesc = *ppTagDesc;
        }
    }

Cleanup:
    return pTagDesc;
}

///////////////////////////////////////////////////////////////////////////
//
//  Class:      CExtendedTagTable
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagTable constructor
//
//-------------------------------------------------------------------------

CExtendedTagTable::CExtendedTagTable (CDoc * pDoc, CMarkup * pMarkup, BOOL fShareBooster)
{
    _pDoc = pDoc;
    _pMarkup = pMarkup;

    _fShareBooster = fShareBooster;

    // NOTE normally, CExtendedTabTable can't outlive CHtmInfo,
    // and CHtmInfo can't outlive markup and doc. However, this assumption
    // changes when the table pointer is handed out to anyone. Then _pDoc
    // and _pMarkup pointers have to be AddRef-ed. The problem in doing this
    // right here in constructor is that it is often called on tokenizer thread.
    // AddRef-ing doc and markup here would be a cross thread access in those cases,
    // which is not safe and therefore not allowed. Instead, _pDoc and _pMarkup are
    // AddRef-ed whenever the table is handed out to anyone (controlled by
    // EnsureContextLifetime).
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagTable destructor
//
//-------------------------------------------------------------------------

CExtendedTagTable::~CExtendedTagTable ()
{
    int         c;
    CItem **    ppItem;

    for (ppItem = _aryItems, c = _aryItems.Size(); 0 < c; ppItem++, c--)
    {
        (*ppItem)->_pTable = NULL;
        if ((*ppItem)->_pCollectionItem && (*ppItem)->_pCollectionItem->_cDownloads > 0)
        {
            (*ppItem)->SyncAbort();
            (*ppItem)->Sync2();
        }
        (*ppItem)->Release();
    }
    _aryItems.DeleteAll();

    if (_pNamespaceBuiltin)
        _pNamespaceBuiltin->Release();

    if (_fContextLifetimeEnsured)
    {
        _pDoc->SubRelease();
        if (_pMarkup)
            _pMarkup->SubRelease();
    }

    delete _pBooster;
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagTable::QueryInterface, per IUnknown
//
//-------------------------------------------------------------------------

HRESULT
CExtendedTagTable::QueryInterface(REFIID iid, LPVOID * ppv)
{
    *ppv = NULL;

    EnsureContextLifetime();

    switch (iid.Data1)
    {
    QI_INHERITS((IElementNamespaceTable*)this, IUnknown)
    QI_INHERITS(this, IElementNamespaceTable)
    QI_INHERITS(this, IOleCommandTarget)
    }

    if (*ppv)
    {
        EnsureContextLifetime();

        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }
    else
    {
        RRETURN (E_NOTIMPL);
    }
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagTable::EnsureContextLifetime, helper
//
//-------------------------------------------------------------------------

HRESULT
CExtendedTagTable::EnsureContextLifetime()
{
    HRESULT     hr = S_OK;

    if (!_fContextLifetimeEnsured)
    {
        _fContextLifetimeEnsured = TRUE;
        _pDoc->SubAddRef();
        if (_pMarkup)
            _pMarkup->SubAddRef();
    }

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagTable::EnsureBooster
//
//-------------------------------------------------------------------------

HRESULT
CExtendedTagTable::EnsureBooster(CExtendedTagTableBooster ** ppBooster)
{
    HRESULT     hr = S_OK;
    CMarkup *   pMarkup;

    Assert (ppBooster);

    *ppBooster = NULL;

    if (_fShareBooster)
    {
        Assert (_pDoc->_dwTID == GetCurrentThreadId());

        Assert (_pMarkup);
        Assert (!_pBooster);

        if (!_pFrameOrPrimaryMarkup)
        {
            _pFrameOrPrimaryMarkup = _pMarkup->GetFrameOrPrimaryMarkup();
        }
        pMarkup = _pFrameOrPrimaryMarkup;

        Assert (pMarkup);

        hr = THR(pMarkup->EnsureExtendedTagTableBooster(ppBooster));
    }
    else
    {
        if (!_pBooster)
        {
            _pBooster = new CExtendedTagTableBooster();
            if (!_pBooster)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }
        }

        *ppBooster = _pBooster;
    }

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagTable::ClearBooster
//
//-------------------------------------------------------------------------

void
CExtendedTagTable::ClearBooster()
{
    delete _pBooster;
    _pBooster = NULL;
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagTable::GetHint
//
//-------------------------------------------------------------------------

LONG
CExtendedTagTable::GetHint(LPCVOID pv, LPTSTR pch)
{
    CExtendedTagTableBooster * pBooster;

    IGNORE_HR(EnsureBooster(&pBooster));

    if (pBooster)
    {
        return pBooster->GetHint(pv, pch);
    }
    else
    {
        return -1;
    }
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagTable::SetHint
//
//-------------------------------------------------------------------------

void
CExtendedTagTable::SetHint(LPCVOID pv, LPTSTR pch, LONG idx)
{
    CExtendedTagTableBooster * pBooster;

    IGNORE_HR(EnsureBooster(&pBooster));

    if (pBooster)
    {
        pBooster->SetHint(pv, pch, idx);
    }
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagTable::CreateNamespaceBuiltin, helper
//
//-------------------------------------------------------------------------

HRESULT
CExtendedTagTable::CreateNamespaceBuiltin(LPTSTR pchNamespace, CExtendedTagNamespace ** ppNamespace)
{
    HRESULT     hr = S_OK;

    Assert (ppNamespace);

    if (_pNamespaceBuiltin && pchNamespace &&
        0 != StrCmpIC (_pNamespaceBuiltin->_cstrNamespace, pchNamespace))
    {
        _pNamespaceBuiltin->Release();
        _pNamespaceBuiltin = NULL;
    }

    if (!_pNamespaceBuiltin)
    {
        _pNamespaceBuiltin = new CExtendedTagNamespaceBuiltin(this);
        if (!_pNamespaceBuiltin)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = THR(_pNamespaceBuiltin->Init(pchNamespace, DEFAULT_NAMESPACE_URN));
    }

Cleanup:
    *ppNamespace = _pNamespaceBuiltin;

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagTable::CreateNamespace, helper
//
//-------------------------------------------------------------------------

HRESULT
CExtendedTagTable::CreateNamespace(LPTSTR pchNamespace, LPTSTR pchUrn, CExtendedTagNamespace ** ppNamespace)
{
    HRESULT                     hr = S_OK;
    BOOL                        fDefaultUrn;
    CExtendedTagNamespace *     pNamespace = NULL;

    Assert (ppNamespace);
    *ppNamespace = NULL;

    fDefaultUrn = IsDefaultUrn(pchUrn);

    if (!fDefaultUrn)
    {
        pNamespace = new CExtendedTagNamespace(this);
        if (!pNamespace)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = THR(pNamespace->Init(pchNamespace, pchUrn));
        if (hr)
            goto Cleanup;

        hr = THR(_aryItems.AppendIndirect(&pNamespace));
        if (hr)
            goto Cleanup;

        _ppLastItem = &_aryItems[_aryItems.Size() - 1];
        Assert (*_ppLastItem);

#ifdef HASHBOOST
        SetHint(this, pchNamespace, _ppLastItem - &(_aryItems[0]));
#endif
    }
    else
    {
        // someone is giving default namespace different name
        hr = THR(CreateNamespaceBuiltin(pchNamespace, &pNamespace));
        if (hr)
            goto Cleanup;
    }

Cleanup:
    *ppNamespace = pNamespace;

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagTable::EnsureHostNamespaces
//
//-------------------------------------------------------------------------

HRESULT
CExtendedTagTable::EnsureHostNamespaces()
{
    HRESULT                 hr = S_OK;
    LPTSTR                  pch0, pch1;
    CExtendedTagNamespace * pNamespace = NULL;

    if (!_fHostNamespacesEnsured && _pDoc->_cstrHostNS.Length())
    {
        _fHostNamespacesEnsured = TRUE;

        pch0 = _pDoc->_cstrHostNS;
        for (;;)
        {
            pch1 = StrChr(pch0, _T(';'));
            {
                CStringNullTerminator   term(pch1);

                hr = THR(CreateNamespace(pch0, /* pchUrn = */NULL, &pNamespace));
                if (hr)
                    goto Cleanup;

                pNamespace->_fAllowAnyTag = TRUE;
            }

            if (!pch1)
                break;

            Assert (_T(';') == (*pch1));

            pch0 = pch1 + 1;
        }
    }

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagTable::FindNamespace
//
//-------------------------------------------------------------------------

CExtendedTagNamespace *
CExtendedTagTable::FindNamespace (LPTSTR pchNamespace, LPTSTR pchUrn, LONG * pidx)
{
    HRESULT                 hr;
    int                     c;
    int                     cchNamespace = pchNamespace ? _tcslen(pchNamespace) : 0;
    int                     cchUrn = pchUrn ? _tcslen(pchUrn) : 0;
    CItem **                ppItem;
    CExtendedTagNamespace * pNamespace = NULL;
    BOOL                    fDefaultUrn = IsDefaultUrn(pchUrn, cchUrn);
    LONG                    idx;

    if (!pidx)
        pidx = &idx;

    if (pchNamespace && pchNamespace[0] && !fDefaultUrn)
    {
#ifdef HASHBOOST
        idx = GetHint(this, pchNamespace);
        if (0 <= idx && idx < _aryItems.Size())
        {
            _ppLastItem = &_aryItems[idx];
        }
#endif

        // check cached value
        if (_ppLastItem)
        {
            if ((*_ppLastItem)->Match(pchNamespace, cchNamespace, pchUrn, cchUrn))
            {
                TraceTag ((tagPeerExtendedTagTableBoosterResults, "CExtendedTagTable::FindNamespace:   HIT for %ls", pchNamespace));

                pNamespace = *_ppLastItem;
                *pidx = _ppLastItem - _aryItems;
                goto Cleanup; // done
            }
        }

        TraceTag ((tagPeerExtendedTagTableBoosterResults, "CExtendedTagTable::FindNamespace:   LOOKUP {%ld} for %ls", _aryItems.Size(), pchNamespace));

        // do the search BACKWARDS - to find recently added namespaces first
        // (this is (1) minor optimization, (2) functionality that a namespace
        // added later overrides previously added namespace)
        c = _aryItems.Size();
        for (ppItem = _aryItems + c - 1; 0 < c; ppItem--, c--)
        {
            if (ppItem != _ppLastItem &&
                (*ppItem)->Match(pchNamespace, cchNamespace, pchUrn, cchUrn))
            {
                // found
                _ppLastItem = ppItem;
                *pidx = _ppLastItem - _aryItems;
                pNamespace = *_ppLastItem;

#ifdef HASHBOOST
                SetHint(this, pchNamespace, _ppLastItem - &(_aryItems[0]));
#endif
                goto Cleanup; // done
            }
        }

        _ppLastItem = NULL;
    }

    // still not found

    // default namespace?
    if ((IsDefaultNamespace(pchNamespace) ||
         (_pNamespaceBuiltin && _pNamespaceBuiltin->Match(pchNamespace, cchNamespace, pchUrn, cchUrn))) &&
        (!pchUrn || fDefaultUrn) &&
        _pMarkup)
    {
        if (!_pNamespaceBuiltin)
        {
            // (the reason why this is ensured here instead of EnsureNamespace is to optimize logic when
            // the namespace is considered declared by default, when the table created. With such logic we
            // never get EnsureNamespace call, but we optimize and don't create namespace when the table is
            // created but rather do that lazily only when it is requested)
            hr = THR(CreateNamespaceBuiltin(DEFAULT_NAMESPACE, &pNamespace));
            if (hr)
                goto Cleanup;
        }

        pNamespace = _pNamespaceBuiltin;
        *pidx = -1;

        goto Cleanup; // done
    }

    // failed to find

Cleanup:

    return pNamespace;
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagTable::EnsureNamespace
//
//-------------------------------------------------------------------------

HRESULT
CExtendedTagTable::EnsureNamespace (
    LPTSTR                      pchNamespace,
    LPTSTR                      pchUrn,
    CExtendedTagNamespace **    ppNamespace,
    BOOL *                      pfChange)
{
    HRESULT                     hr = S_OK;
    CExtendedTagNamespace *     pNamespace;
    BOOL                        fChange;

    if (!ppNamespace)
         ppNamespace = &pNamespace;

    if (!pfChange)
        pfChange = &fChange;

    *pfChange = FALSE;

    (*ppNamespace) = FindNamespace(pchNamespace, pchUrn);

    if (!(*ppNamespace))
    {
        *pfChange = TRUE;

        hr = THR(CreateNamespace(pchNamespace, pchUrn, ppNamespace));
    }

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagTable::FindTagDesc
//
//-------------------------------------------------------------------------

CExtendedTagDesc *
CExtendedTagTable::FindTagDesc(LPTSTR pchNamespace,
                               LPTSTR pchTagName,
                               BOOL * pfQueryHost /* = NULL */)
{
    CExtendedTagDesc *      pDesc = NULL;
    CExtendedTagNamespace * pNamespace = FindNamespace(pchNamespace, /* pchUrn = */NULL);

    Assert (pchTagName && pchTagName[0]);

    if( pfQueryHost )
    {
        Assert( this == _pDoc->_pExtendedTagTableHost || _pDoc->IsShut());
        *pfQueryHost = FALSE;
    }

    if (pNamespace)
    {
        if (pNamespace->_fAllowAnyTag)
        {
            IGNORE_HR(pNamespace->AddTagDesc(
                pchTagName, /* fOverride = */FALSE, /* pchBaseTagName = */ NULL, 0, &pDesc));
        }
        else
        {
            pDesc = pNamespace->FindTagDesc(pchTagName);
        }

        if( pfQueryHost && !pDesc && pNamespace->_fQueryForUnknownTags && !_pDoc->IsShut())
        {
            *pfQueryHost = TRUE;
        }
    }

    return pDesc;
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagTable::EnsureTagDesc
//
//-------------------------------------------------------------------------

CExtendedTagDesc *
CExtendedTagTable::EnsureTagDesc(LPTSTR pchNamespace, LPTSTR pchTagName, BOOL fEnsureNamespace)
{
    HRESULT                 hr;
    CExtendedTagDesc *      pDesc = NULL;
    CExtendedTagNamespace * pNamespace;

    if (fEnsureNamespace)
    {
        hr = EnsureNamespace(pchNamespace, /* pchUrn = */NULL, &pNamespace);
        if (hr)
            goto Cleanup;
    }
    else
    {
        pNamespace = FindNamespace(pchNamespace, /* pchUrn = */NULL);
    }

    Assert (pchTagName && pchTagName[0]);

    if (pNamespace)
    {
        IGNORE_HR(pNamespace->AddTagDesc(pchTagName, /* fOverride = */FALSE, /* pchBaseTagName = */ NULL, 0, &pDesc));
    }

Cleanup:
    return pDesc;
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagTable::SaveXmlNamespaceStdPIs
//
//-------------------------------------------------------------------------

HRESULT
CExtendedTagTable::SaveXmlNamespaceStdPIs(CStreamWriteBuff * pStreamWriteBuff)
{
    HRESULT                     hr = S_OK;
    int                         c;
    CExtendedTagNamespace **    ppNamespace;

    for (ppNamespace = _aryItems, c = _aryItems.Size(); c; ppNamespace++, c--)
    {
        hr = THR(pStreamWriteBuff->EnsurePIsSaved(
            _pDoc, _pMarkup,
            (*ppNamespace)->_cstrNamespace, (*ppNamespace)->_cstrUrn,
            /* pchImplementation = */ NULL,
            XMLNAMESPACEDECL_STD));
        if (hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagTable::Exec
//
//-------------------------------------------------------------------------

HRESULT
CExtendedTagTable::Exec(
    const GUID *    pguidCmdGroup,
    DWORD           nCmdID,
    DWORD           nCmdExecOpt,
    VARIANT *       pvarArgIn,
    VARIANT *       pvarArgOut)
{
    HRESULT     hr;

    if (!pguidCmdGroup)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (IsEqualGUID(CGID_XmlNamespaceMapping, *pguidCmdGroup))
    {
        hr = OLECMDERR_E_NOTSUPPORTED;

        switch (nCmdID)
        {
        case XMLNAMESPACEMAPPING_GETURN:

            if (!pvarArgOut ||                                              // if no out arg or
                !pvarArgIn ||                                               // no in arg or
                VT_BSTR != V_VT(pvarArgIn) ||                               // in arg is not a string or
                !V_BSTR(pvarArgIn) || 0 == ((LPTSTR)V_BSTR(pvarArgIn))[0])  // the string is empty
            {
                hr = E_INVALIDARG;
                goto Cleanup;
            }

            {
                LPTSTR                  pchNamespace;
                CExtendedTagNamespace * pNamespace;

                pchNamespace = V_BSTR(pvarArgIn);

                pNamespace = FindNamespace(pchNamespace, /* pchUrn = */NULL);
                if (pNamespace && pNamespace->_cstrUrn.Length())
                {
                    hr = THR(FormsAllocString(pNamespace->_cstrUrn, &V_BSTR(pvarArgOut)));
                }
                else
                {
                    V_BSTR(pvarArgOut) = NULL;
                    hr = S_OK;
                }
            }

            break;
        }
    }
    else
    {
        hr = OLECMDERR_E_UNKNOWNGROUP;
    }

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagTable::Exec
//
//-------------------------------------------------------------------------

HRESULT
CExtendedTagTable::AddNamespace(BSTR bstrNamespace, BSTR bstrUrn, LONG lFlags, VARIANT * pvarFactory)
{
    HRESULT                         hr;
    HRESULT                         hr2;
    IElementBehaviorFactory *       pPeerFactory = NULL;
    IElementNamespaceFactory *      pNamespaceFactory = NULL;
    IElementNamespaceFactory2 *     pNSFactory2 = NULL;
    CPeerFactoryBinary *            pPeerFactoryBinary = NULL;
    CExtendedTagNamespace *         pNamespace = NULL;

    //
    // validate and process params
    //

    if (!bstrNamespace ||
        (pvarFactory && VT_UNKNOWN  != V_VT(pvarFactory) &&
                        VT_DISPATCH != V_VT(pvarFactory)) ||
        ( ( lFlags & ELEMENTNAMESPACEFLAGS_ALLOWANYTAG ) &&
          ( lFlags & ELEMENTNAMESPACEFLAGS_QUERYFORUNKNOWNTAGS ) ) )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr2 = THR(V_UNKNOWN(pvarFactory)->QueryInterface(IID_IElementNamespaceFactory2, (void**)&pNSFactory2));
    if (hr2)
    {
        hr = THR(V_UNKNOWN(pvarFactory)->QueryInterface(IID_IElementNamespaceFactory, (void**)&pNamespaceFactory));
        if (hr)
            goto Cleanup;
    }

    hr = THR(V_UNKNOWN(pvarFactory)->QueryInterface(IID_IElementBehaviorFactory, (void**)&pPeerFactory));
    if (hr)
        goto Cleanup;

    //
    // create peer factory holder
    //

    pPeerFactoryBinary = new CPeerFactoryBinary();
    if (!pPeerFactoryBinary)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(pPeerFactoryBinary->Init(pPeerFactory));
    if (hr)
        goto Cleanup;

    //
    // create namespace and use factory to populate it
    //

    hr = THR(CreateNamespace(bstrNamespace, bstrUrn, &pNamespace));
    if (hr)
        goto Cleanup;

    hr = THR(pNamespace->SetFactory(pPeerFactoryBinary, /* fPeerFactoryUrl = */ FALSE));
    if (hr)
        goto Cleanup;

    if (lFlags & ELEMENTNAMESPACEFLAGS_ALLOWANYTAG)
    {
        pNamespace->_fAllowAnyTag = TRUE;
    }
    else if (lFlags & ELEMENTNAMESPACEFLAGS_QUERYFORUNKNOWNTAGS)
    {
        pNamespace->_fQueryForUnknownTags = TRUE;
    }
    pNamespace->_fNonPersistable = TRUE;

    {
        CExtendedTagNamespace::CExternalUpdateLock  updateLock(pNamespace, pPeerFactoryBinary);

        if( pNSFactory2 )
        {
            hr = THR(pNSFactory2->CreateWithImplementation(pNamespace, bstrUrn));
        }
        else
        {
            hr = THR(pNamespaceFactory->Create(pNamespace));
        }
    }

Cleanup:

    ReleaseInterface (pPeerFactory);
    ReleaseInterface (pNamespaceFactory);
    ReleaseInterface (pNSFactory2);

    if (pPeerFactoryBinary)
        pPeerFactoryBinary->Release();

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagTable::Sync1
//
//              The synchronization sequence:
//              - on HtmPre thread, the PI token is tokenized, recognized and emitted
//              - on HtmPre thread, HtmPre is suspended
//              - on HtmPost/UI thread, the PI token is received
//              - on HtmPost/UI thread, RegisterExtendedTagNamespace is called
//                                      (that initializes _ppLastItem)
//              - on HtmPost/UI thread, Sync1 is called to mark item to synchronize and
//                                      launch synchronization with CPeerFactoryUrl object
//              - on HtmPost/UI thread, when CPeerFactoryUrl is ready, Sync2 is called.
//                                      Sync2 is also called to finish synchronization prematurely
//              - on HtmPost/UI thread, Sync2 resumes preparser and completes the synchronization
//
//-------------------------------------------------------------------------

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagTable::Sync1
//
//-------------------------------------------------------------------------

HRESULT
CExtendedTagTable::Sync1(BOOL fSynchronous)
{
    HRESULT     hr = S_OK;
    BOOL        fForceComplete = FALSE;

    Assert (_ppLastItem);

    _pSyncItem = *_ppLastItem;

#if DBG == 1
    TraceNamespace(_T("CExtendedTagTable::Sync1"), _pSyncItem);
#endif

    if (_pSyncItem->_pPeerFactory)
    {
        Assert (_pSyncItem->_fPeerFactoryUrl);

        // after this call we expect to get called back to Sync2() to complete the sequence
        hr = THR_NOTRACE(_pSyncItem->Sync1(CExtendedTagNamespace::SYNCMODE_TABLE));
        switch (hr)
        {
        case S_OK:
            // assert that Sync2 has been called, as indicated by _pSyncItem cleared
            Assert (!_pSyncItem);
            break;

        case E_PENDING:
            if (!fSynchronous)
            {
                // the operation is not synchronous; we can wait until we will get called
                // to Sync2 later, asynchronously
                hr = S_OK;
            }
            else
            {   // the operation is synchronous, so we can't wait and have to abort
                // (this is not a normal codepath)
                hr = THR(_pSyncItem->SyncAbort());
                if (hr)
                    goto Cleanup;

                fForceComplete = TRUE;
            }
            break;

        default:
            goto Cleanup;
        }
    }
    else // if (!_pSyncItem->_pPeerFactoryUrl)
    {
        fForceComplete = TRUE;
    }

    if (fForceComplete)
    {
        hr = THR(Sync2());
        if (hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagTable::Sync2
//
//-------------------------------------------------------------------------

HRESULT
CExtendedTagTable::Sync2()
{
    HRESULT     hr = S_OK;

    Assert (_pSyncItem);

    _pSyncItem->ClearFactory();

    // wake up parser now
    _pMarkup->HtmCtx()->ResumeAfterImportPI();

#if DBG == 1
    TraceNamespace(_T("CExtendedTagTable::Sync2"), _pSyncItem);
#endif

    _pSyncItem = NULL;

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagTable::GetNamespace
//
//-------------------------------------------------------------------------

CExtendedTagNamespace *
CExtendedTagTable::GetNamespace(LONG idx)
{
    if (idx < 0 || _aryItems.Size() <= idx)
        return NULL;

    return _aryItems[idx];
}



#ifdef GETDHELPER
//+----------------------------------------------------------------------------
//
//  Method:     CExtendedTagTable::GetExtendedTagDesc   (static)
//
//  Synopsis:   Helper function to deal with searching through various
//              ExtendedTagTables for a TagDesc.  There are basically 3 levels
//              to search:
//              1) A specific table.  This is the case in parsing, where the
//              CHtmInfo has a tag table related to that parse.
//              2) A context markup.  The context markup may have a table in
//              its behavior context, or in its HtmInfo if it has not yet
//              been transferred
//              3) The host table.  This is where hosts can add their own
//              namespaces.
//
//              If a host wants a query on a namespace, we won't ensure the
//              tag no matter what fEnsure says.
//
//  Returns:    CExtendedTagDesc * - ExtendedTagDesc, if found
//
//  Arguments:
//          CExtendedTagTable * pExtendedTagTable - First table to search
//          CMarkup * pMarkupContext - Context markup
//          CExtendedTagTable * pExtendedTagTableHost - Host tag table
//          LPTSTR * pchNamespace - Namespace
//          LPTSTR * pchTagName - Tag
//          BOOL     fEnsureTag - Ensure tag if not found
//          BOOL     fEnsureNamespace - Ensure namespace if necessary to ensure tag
//          BOOL   * pfQueryHost - Set if host wants a query for this namespace
//
//+----------------------------------------------------------------------------

CExtendedTagDesc *
CExtendedTagTable::GetExtendedTagDesc( CExtendedTagTable * pExtendedTagTable,       // First check this table
                                       CMarkup * pMarkupContext,                    // Then this context markup
                                       CExtendedTagTable * pExtendedTagTableHost,   // Then the host table
                                       LPTSTR   pchNamespace,                       // Namespace we're looking in
                                       LPTSTR   pchTagName,                         // Tag we're looking for
                                       BOOL     fEnsureTag,                         // Ensure tag if not found
                                       BOOL     fEnsureNamespace,                   // Ensure namespace if needed
                                       BOOL   * pfQueryHost )                       // Does host want a query for this?
{
    CExtendedTagDesc        *   pDesc;
    CExtendedTagTable       *   pExtendedTagTableMarkupContext = NULL;

    // Check arguments
    Assert( pExtendedTagTable || pMarkupContext );
    Assert( !fEnsureNamespace || fEnsureTag );

    // Initialize
    pDesc = NULL;
    if( pfQueryHost )
        *pfQueryHost = FALSE;

    // First check the specific tag table
    if( pExtendedTagTable )
    {
        pDesc = pExtendedTagTable->FindTagDesc( pchNamespace, pchTagName );
        if( pDesc )
            goto Cleanup;
    }

    // Then check the context markup
    if( pMarkupContext )
    {
        pDesc = pMarkupContext->GetExtendedTagDesc( pchNamespace, pchTagName );
        if( pDesc )
            goto Cleanup;
#if 0
        // The table may be in the behavior context or the HtmCtx
        if( pMarkupContext->BehaviorContext() &&
            pMarkupContext->BehaviorContext()->_pExtendedTagTable )
        {
            pExtendedTagTableMarkupContext = pMarkupContext->BehaviorContext()->_pExtendedTagTable;
        }
        else if( pMarkupContext->HtmCtx() )
        {
            pExtendedTagTableMarkupContext = pMarkupContext->HtmCtx()->GetExtendedTagTable();
        }

        if( pExtendedTagTableMarkupContext )
        {
            pDesc = pExtendedTagTableMarkupContext->FindTagDesc( pchNamespace, pchTagName );
            if( pDesc )
                goto Cleanup;
        }
#endif // 0
    }

    // Then check the host tag table
    if( pExtendedTagTableHost )
    {
        pDesc = pExtendedTagTableHost->FindTagDesc( pchNamespace, pchTagName, pfQueryHost );
        if( pDesc )
            goto Cleanup;
    }

    // If we were asked to ensure, and we're not waiting to query, then go ahead
    if( fEnsureTag && pExtendedTagTable && ( !pfQueryHost || FALSE == *pfQueryHost ) )
    {
        if( pExtendedTagTable )
        {
            Verify( pDesc = pExtendedTagTable->EnsureTagDesc( pchNamespace, pchTagName, fEnsureNamespace ) );
            if( pDesc )
                goto Cleanup;
        }
        else
        {
            Assert( pMarkupContext );
            Verify( pDesc = pMarkupContext->GetExtendedTagDesc( pchNamespace, pchTagName, TRUE ) );
            if( pDesc )
                goto Cleanup;
        }
    }

Cleanup:
    return pDesc;
}
#endif // GETDHELPER


//+----------------------------------------------------------------------------
//
//  Method:     CExtendedTagTable::ResolveUnknownTag
//
//  Synopsis:   Queries the host to see if they want to add the tag to the
//              table
//
//  Returns:    HRESULT
//
//  Arguments:
//          CHtmTag * pht - The tag to resolve
//
//+----------------------------------------------------------------------------

HRESULT
CExtendedTagTable::ResolveUnknownTag( CHtmTag * pht )
{
    HRESULT                     hr;
    IElementNamespaceFactoryCallback * pNSResolver = NULL;
    CExtendedTagDesc         *  pDesc;
    BSTR                        bstrHTMLString = NULL;
    BSTR                        bstrNamespace = NULL;
    BSTR                        bstrTagname = NULL;

    // Sanity check arguments
    Assert( this == _pDoc->_pExtendedTagTableHost );
    Assert( pht && pht->Is(ETAG_RAW_RESOLVE) && !pht->IsEnd() );

    pht->SetTag( ETAG_UNKNOWN );

    //
    // Cook up the HTML BSTR to pass.
    // Do this before we create the tagname cracker, just for simplicity
    //
    if( pht->GetAttrCount() )
    {
        long                        cchHTMLString = 0;
        ULONG                       cAttr;
        CHtmTag::CAttr           *  pAttr;
        TCHAR                    *  pch;

        for( cAttr = 0; cAttr < pht->GetAttrCount(); cAttr++ )
        {
            pAttr = pht->GetAttr(cAttr);
            cchHTMLString += 2 +                                // Two terminators
                             pAttr->_cchName +                  // Add the name
                             pAttr->_cchVal;                    // Add the value
        }

        // Allocate a BSTR of the right length, but don't do initialize it
        hr = THR( FormsAllocStringLen( NULL, cchHTMLString, &bstrHTMLString ) );
        if( hr )
            goto Cleanup;

        pch = bstrHTMLString;

        for( cAttr = 0; cAttr < pht->GetAttrCount(); cAttr++ )
        {
            pAttr = pht->GetAttr(cAttr);

            // Copy name
            memcpy( pch, pAttr->_pchName, pAttr->_cchName * sizeof( TCHAR ) );
            pch += pAttr->_cchName;
            *pch = _T('\0');
            pch += 1;

            // Copy the value
            memcpy( pch, pAttr->_pchVal, pAttr->_cchVal * sizeof( TCHAR ) );
            pch += pAttr->_cchVal;
            *pch = _T('\0');
            pch += 1;
        }

        // Terminate (I don't think this is necessary for BSTR)
        *pch = _T('\0');
    }

    {   // Scope for TagNameCracker
        CExtendedTagNamespace    *  pNamespace;
        CTagNameCracker             tagNameCracker( pht->GetPch() );

        pNamespace = FindNamespace( tagNameCracker._pchNamespace, NULL );

        Assert( pNamespace && pNamespace->_fQueryForUnknownTags );
        Assert( pNamespace && pNamespace->_pPeerFactory );

        hr = THR( pNamespace->_pPeerFactory->GetElementNamespaceFactoryCallback( &pNSResolver ) );
        if( hr )
            goto Cleanup;

        hr = THR( FormsAllocString( tagNameCracker._pchNamespace, &bstrNamespace) );
        if (hr)
            goto Cleanup;

        hr = THR( FormsAllocString( tagNameCracker._pchTagName, &bstrTagname) );
        if (hr)
            goto Cleanup;

        {   // Scope for ExternalUpdateLock
            CExtendedTagNamespace::CExternalUpdateLock  updateLock(pNamespace, pNamespace->_pPeerFactory);

            hr = THR( pNSResolver->Resolve( bstrNamespace, bstrTagname, bstrHTMLString, pNamespace ) );
            if( hr )
                goto Cleanup;
        }

        pDesc = pNamespace->FindTagDesc( tagNameCracker._pchTagName );
        if( !pDesc )
            goto Cleanup;
    }

    pht->SetTag( pDesc->_etagBase );
    pht->SetExtendedTag();

Cleanup:
    FormsFreeString( bstrHTMLString );
    FormsFreeString( bstrNamespace );
    FormsFreeString( bstrTagname );
    ReleaseInterface( pNSResolver );

    RRETURN( hr );
}

///////////////////////////////////////////////////////////////////////////
//
//  CHTMLNamespace
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Member:     CHTMLNamespace constructor
//
//-------------------------------------------------------------------------

CHTMLNamespace::CHTMLNamespace(CExtendedTagNamespace * pNamespace)
{
    Assert (pNamespace);
    _pNamespace = pNamespace;
    _pNamespace->AddRef();
}

//+------------------------------------------------------------------------
//
//  Member:     CHTMLNamespace destructor
//
//-------------------------------------------------------------------------

CHTMLNamespace::~CHTMLNamespace()
{
    _pNamespace->_pCollectionItem = NULL;
    _pNamespace->Release();
}

//+------------------------------------------------------------------------
//
//  Member:     CHTMLNamespace::PrivateQueryInterface, per IUnknown
//
//-------------------------------------------------------------------------

//..todo move to core\include\qi_impl.h
#define Data1_IHTMLNamespace 0x3050f6bb

HRESULT
CHTMLNamespace::PrivateQueryInterface(REFIID iid, LPVOID * ppv)
{
    if(!ppv)
        return E_POINTER;

    *ppv = NULL;

    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_TEAROFF_DISPEX(this, NULL)
        QI_INHERITS(this, IHTMLNamespace)
    }

    if (*ppv)
    {
        ((IUnknown*)*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

//+------------------------------------------------------------------------
//
//  Member:     CHTMLNamespace::Create
//
//-------------------------------------------------------------------------

HRESULT
CHTMLNamespace::Create (CExtendedTagNamespace * pNamespace, CHTMLNamespace ** ppHTMLNamespace, IDispatch ** ppdispHTMLNamespace)
{
    HRESULT                 hr;
    CHTMLNamespace *        pHTMLNamespace = NULL;
    CHTMLNamespace *        pHTMLNamespaceCreated = NULL;

    Assert (pNamespace);

    if (!ppHTMLNamespace)
        ppHTMLNamespace = &pHTMLNamespace;

    if (!pNamespace->_pCollectionItem)
    {
        pHTMLNamespaceCreated = pNamespace->_pCollectionItem = new CHTMLNamespace(pNamespace);
        if (!pHTMLNamespaceCreated)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }

    *ppHTMLNamespace = pHTMLNamespace = pNamespace->_pCollectionItem;

    Assert (pHTMLNamespace);

    hr = THR(pHTMLNamespace->PrivateQueryInterface(IID_IDispatch, (void**)ppdispHTMLNamespace));
    if (hr)
        goto Cleanup;

Cleanup:
    if (pHTMLNamespaceCreated)
        pHTMLNamespaceCreated->Release();

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHTMLNamespace::get_name, per IHTMLNamespace
//
//-------------------------------------------------------------------------

HRESULT
CHTMLNamespace::get_name(BSTR * pbstrName)
{
    HRESULT     hr = E_NOTIMPL;

    Assert (_pNamespace && _pNamespace->_cstrNamespace.Length());

    if (!pbstrName)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR(FormsAllocString(_pNamespace->_cstrNamespace, pbstrName));

Cleanup:
    RRETURN (SetErrorInfo(hr));
}

//+------------------------------------------------------------------------
//
//  Member:     CHTMLNamespace::get_urn, per IHTMLNamespace
//
//-------------------------------------------------------------------------

HRESULT
CHTMLNamespace::get_urn(BSTR * pbstrUrn)
{
    HRESULT     hr = S_OK;

    Assert (_pNamespace);

    if (!pbstrUrn)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (_pNamespace->_cstrUrn)
    {
        hr = THR(FormsAllocString(_pNamespace->_cstrUrn, pbstrUrn));
    }
    else
    {
        *pbstrUrn = NULL;
    }

Cleanup:
    RRETURN (SetErrorInfo(hr));
}

//+------------------------------------------------------------------------
//
//  Member:     CHTMLNamespace::get_tagNames, per IHTMLNamespace
//
//-------------------------------------------------------------------------

HRESULT
CHTMLNamespace::get_tagNames(IDispatch ** ppdispTagNameCollection)
{
    HRESULT     hr = E_NOTIMPL;

    RRETURN (SetErrorInfo(hr));
}

//+------------------------------------------------------------------------
//
//  Member:     CHTMLNamespace::get_readyState, helper
//
//-------------------------------------------------------------------------

HRESULT
CHTMLNamespace::get_readyState(VARIANT * pvarRes)
{
    HRESULT hr = S_OK;

    if (!pvarRes)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR(s_enumdeschtmlReadyState.StringFromEnum(_cDownloads ? READYSTATE_LOADING : READYSTATE_COMPLETE, &V_BSTR(pvarRes)));
    if (S_OK == hr)
        V_VT(pvarRes) = VT_BSTR;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//+------------------------------------------------------------------------
//
//  Member:     CHTMLNamespace::doImport, helper
//
//-------------------------------------------------------------------------

HRESULT
CHTMLNamespace::doImport(BSTR bstrImplementationUrl)
{
    HRESULT     hr = S_OK;

    //TODO understand and get rid of this
#if 1
    if (0 == StrCmpIC(bstrImplementationUrl, _T("null")))
        bstrImplementationUrl = NULL;
#endif

    if (!bstrImplementationUrl)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR(Import(bstrImplementationUrl));

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHTMLNamespace::Import, helper
//
//-------------------------------------------------------------------------

HRESULT
CHTMLNamespace::Import(LPTSTR pchImplementationUrl)
{
    HRESULT     hr;

    if( !_pNamespace->_pTable )
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    hr = THR(_pNamespace->SetFactory(_pNamespace->_pTable->_pMarkup, pchImplementationUrl));
    if (hr ||                           // if fatal failure or
        !_pNamespace->_pPeerFactory)    // could not create factory (non existent file? security error?)
    {
        goto Cleanup;                   // bail out
    }

    if (0 == _cDownloads)
    {
        Fire_onreadystatechange();
    }

    _cDownloads++;

    // expected return values are S_OK and E_PENDING
    hr = THR(_pNamespace->Sync1(CExtendedTagNamespace::SYNCMODE_COLLECTIONITEM));
    if (E_PENDING == hr)
    {
        hr = S_OK;
    }

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHTMLNamespace::OnImportComplete, helper
//
//-------------------------------------------------------------------------

HRESULT
CHTMLNamespace::OnImportComplete()
{
    HRESULT     hr = S_OK;

    _cDownloads--;

    Assert (0 <= _cDownloads);

    if (0 == _cDownloads)
    {
        Fire_onreadystatechange();
    }

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHTMLNamespace::attachEvent, helper
//
//-------------------------------------------------------------------------

HRESULT
CHTMLNamespace::attachEvent(BSTR bstrEvent, IDispatch * pdispFunc, VARIANT_BOOL * pResult)
{
    RRETURN(super::attachEvent(bstrEvent, pdispFunc, pResult));
}

//+------------------------------------------------------------------------
//
//  Member:     CHTMLNamespace::detachEvent, helper
//
//-------------------------------------------------------------------------

HRESULT
CHTMLNamespace::detachEvent(BSTR bstrEvent, IDispatch * pdispFunc)
{
    RRETURN(super::detachEvent(bstrEvent, pdispFunc));
}

//+------------------------------------------------------------------------
//
//  Member:     CHTMLNamespace::Fire_onreadystatechange
//
//-------------------------------------------------------------------------

void
CHTMLNamespace::Fire_onreadystatechange()
{
    if (_pNamespace && _pNamespace->_pTable)
    {
        FireEvent(Doc(), NULL, _pNamespace->_pTable->_pMarkup, DISPID_EVMETH_ONREADYSTATECHANGE, DISPID_EVPROP_ONREADYSTATECHANGE, _T("readystatechange"));
    }
}


///////////////////////////////////////////////////////////////////////////
//
//  CHTMLNamespaceCollection
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Member:     CHTMLNamespaceCollection constructor
//
//-------------------------------------------------------------------------

CHTMLNamespaceCollection::CHTMLNamespaceCollection(CExtendedTagTable * pTable)
{
    Assert (pTable);
    _pTable = pTable;
    _pTable->AddRef();
}

//+------------------------------------------------------------------------
//
//  Member:     CHTMLNamespaceCollection destructor
//
//-------------------------------------------------------------------------

CHTMLNamespaceCollection::~CHTMLNamespaceCollection()
{
    _pTable->_pCollection = NULL;
    _pTable->Release();
}

//+------------------------------------------------------------------------
//
//  Member:     CHTMLNamespaceCollection::PrivateQueryInterface
//
//-------------------------------------------------------------------------

//..todo move to core\include\qi_impl.h
#define Data1_IHTMLNamespaceCollection 0x3050f6b8

HRESULT
CHTMLNamespaceCollection::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    if(!ppv)
        return E_POINTER;

    *ppv = NULL;

    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_TEAROFF_DISPEX(this, NULL)
        QI_INHERITS(this, IHTMLNamespaceCollection)
    }

    if (*ppv)
    {
        ((IUnknown*)*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

//+------------------------------------------------------------------------
//
//  Member:     CHTMLNamespaceCollection::Create
//
//-------------------------------------------------------------------------

HRESULT
CHTMLNamespaceCollection::Create (CMarkup * pMarkup, IDispatch ** ppdispCollection)
{
    HRESULT                     hr = E_UNEXPECTED;
    CExtendedTagTable *         pTable;
    CMarkupBehaviorContext *    pContext;
    CHTMLNamespaceCollection *  pCollection = NULL;
    CHTMLNamespaceCollection *  pCollectionCreated = NULL;

    Assert (pMarkup);

    //
    // get or ensure the table in the right place
    //

    if (pMarkup->LoadStatus() < LOADSTATUS_DONE && pMarkup->HtmCtx() )
    {
        Assert (pMarkup->HtmCtx());

        hr = THR(pMarkup->HtmCtx()->EnsureExtendedTagTable(&pTable));
        if (hr)
            goto Cleanup;
    }
    else
    {
        Assert (LOADSTATUS_DONE <= pMarkup->LoadStatus() ||
                LOADSTATUS_UNINITIALIZED == pMarkup->LoadStatus() && !pMarkup->HtmCtx());

        Assert (pMarkup->Doc()->_dwTID == GetCurrentThreadId());

        // ensure behavior context
        hr = THR(pMarkup->EnsureBehaviorContext(&pContext));
        if (hr)
            goto Cleanup;

        // ensure the table in the context
        if (!pContext->_pExtendedTagTable)
        {
            pContext->_pExtendedTagTable = new CExtendedTagTable(pMarkup->Doc(), pMarkup, /* fShareBooster =*/TRUE);
            if (!pContext->_pExtendedTagTable)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }
        }

        // get the table
        pTable = pContext->_pExtendedTagTable;
    }

    Assert (pTable);

    //
    // ensure collection for the table
    //

    if (!pTable->_pCollection)
    {
        pCollectionCreated = pTable->_pCollection = new CHTMLNamespaceCollection(pTable);
        if (!pCollectionCreated)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        pTable->EnsureContextLifetime();
    }

    pCollection = pTable->_pCollection;

    Assert (pCollection);

    //
    // return the collection
    //

    hr = THR(pCollection->PrivateQueryInterface(IID_IDispatch, (void**)ppdispCollection));

Cleanup:
    if (pCollectionCreated)
        pCollectionCreated->Release();

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHTMLNamespaceCollection::get_length
//
//-------------------------------------------------------------------------

HRESULT
CHTMLNamespaceCollection::get_length(LONG * plLength)
{
    HRESULT     hr = S_OK;

    if (!plLength)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    Assert (_pTable);

    *plLength = _pTable->_aryItems.Size();

Cleanup:
    RRETURN (SetErrorInfo(hr));
}

//+------------------------------------------------------------------------
//
//  Member:     CHTMLNamespaceCollection::item
//
//  TODO VARIANT -> VARIANT*
//
//-------------------------------------------------------------------------

HRESULT
CHTMLNamespaceCollection::item (VARIANT varIndex, IDispatch** ppNamespace)
{
    HRESULT     hr;
    VARIANT     varRes;

    if (!ppNamespace)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR(GetItemHelper(&varIndex, &varRes));
    if (hr)
        goto Cleanup;

    Assert (VT_DISPATCH == V_VT(&varRes));

    *ppNamespace = V_DISPATCH(&varRes);

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//+------------------------------------------------------------------------
//
//  Member:     CHTMLNamespaceCollection::add
//
//  TODO VARIANT -> VARIANT*
//
//-------------------------------------------------------------------------

HRESULT
CHTMLNamespaceCollection::add(BSTR bstrNamespace, BSTR bstrUrn, VARIANT varImplementationUrl, IDispatch ** ppdispHTMLNamespace)
{
    HRESULT                     hr = E_NOTIMPL;
    CExtendedTagNamespace *     pNamespace;
    CHTMLNamespace *            pHTMLNamespace;
    LPTSTR                      pchImplementationUrl = NULL;

    //TODO understand and get rid of this
#if 1
    if (bstrNamespace && 0 == StrCmpIC(bstrNamespace, _T("null")))
        bstrUrn = NULL;
    if (bstrUrn && 0 == StrCmpIC(bstrUrn, _T("null")))
        bstrUrn = NULL;
#endif

    if (!bstrNamespace || !ppdispHTMLNamespace)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    Assert (_pTable);

    switch (V_VT(&varImplementationUrl))
    {
    case VT_BSTR:
    case VT_LPWSTR:
        pchImplementationUrl = V_BSTR(&varImplementationUrl);
        break;

    case VT_NULL:
    case VT_EMPTY:
    case VT_ERROR:
        break;

    default:
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR(_pTable->EnsureNamespace(bstrNamespace, bstrUrn, &pNamespace));
    if (hr)
        goto Cleanup;

    Assert (pNamespace);

    hr = THR(CHTMLNamespace::Create(pNamespace, &pHTMLNamespace, ppdispHTMLNamespace));
    if (hr)
        goto Cleanup;



    if (pchImplementationUrl)
    {
        hr = THR(pHTMLNamespace->Import(pchImplementationUrl));
        if(hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN (SetErrorInfo(hr));
}

//+------------------------------------------------------------------------
//
//  Member:     CHTMLNamespaceCollection::FindByName
//
//-------------------------------------------------------------------------

LONG
CHTMLNamespaceCollection::FindByName(LPCTSTR pchName, BOOL fCaseSensitive)
{
    LONG        idx = -1;

    Assert (_pTable);

    _pTable->FindNamespace((LPTSTR)pchName, /* pchUrn = */NULL, &idx);

    return idx;
}

//+------------------------------------------------------------------------
//
//  Member:     CHTMLNamespaceCollection::GetName
//
//-------------------------------------------------------------------------

LPCTSTR
CHTMLNamespaceCollection::GetName(LONG idx)
{
    CExtendedTagNamespace *     pNamespace = _pTable->GetNamespace(idx);

    if (!pNamespace)
        return NULL;

    return pNamespace->_cstrNamespace;
}

//+------------------------------------------------------------------------
//
//  Member:     CHTMLNamespaceCollection::GetItem
//
//-------------------------------------------------------------------------

HRESULT
CHTMLNamespaceCollection::GetItem(LONG idx, VARIANT * pvar)
{
    HRESULT                     hr = S_OK;
    CExtendedTagNamespace *     pNamespace = _pTable->GetNamespace(idx);

    if (!pNamespace)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // (if pvar is NULL, we are just validating index. TODO (alexz) perf?)

    if (pvar)
    {
        V_VT(pvar) = VT_DISPATCH;

        hr = THR(CHTMLNamespace::Create(pNamespace, NULL, &V_DISPATCH(pvar)));
    }

Cleanup:
    RRETURN (hr);
}

///////////////////////////////////////////////////////////////////////////
//
//  CExtendedTagTableBooster
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagTableBooster constructor
//
//-------------------------------------------------------------------------

CExtendedTagTableBooster::CExtendedTagTableBooster()
{
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagTableBooster destructor
//
//-------------------------------------------------------------------------

CExtendedTagTableBooster::~CExtendedTagTableBooster()
{
    ResetMap();
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagTableBooster::ResetMap
//
//-------------------------------------------------------------------------

void
CExtendedTagTableBooster::ResetMap()
{
    delete _pMap;
    _pMap = NULL;
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagTableBooster::EnsureMap
//
//-------------------------------------------------------------------------

HRESULT
CExtendedTagTableBooster::EnsureMap()
{
    HRESULT hr = S_OK;

    if (!_pMap)
    {
        _pMap = new CStringTable(CStringTable::CASEINSENSITIVE);
        if (!_pMap)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagTableBooster::GetHint
//
//-------------------------------------------------------------------------

LONG
CExtendedTagTableBooster::GetHint(LPCVOID pv, LPTSTR pch)
{
    HRESULT     hr2;
    LONG        idx;

    hr2 = THR(EnsureMap());
    if (hr2)
    {
        idx = -1;
        goto Cleanup;
    }

    hr2 = THR_NOTRACE(_pMap->Find(pch, (LPVOID*)&idx, /* pvAdditionalKey =*/pv));
    if (hr2)
        idx = -1;

Cleanup:
    TraceTag((
        tagPeerExtendedTagTableBooster,
        "CExtendedTagTableBooster::GetHint: %ls idx = %ld for [%lx] %ls",
        (LPTSTR)((-1 == idx) ? _T("MISS,") : _T("HIT, ")),
        idx, pv, pch));

    return idx;
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagTableBooster::SetHint
//
//-------------------------------------------------------------------------

void
CExtendedTagTableBooster::SetHint(LPCVOID pv, LPTSTR pch, LONG idx)
{
    HRESULT     hr2;

    Assert (-1 != idx);

    hr2 = THR(EnsureMap());
    if (hr2)
        goto Cleanup;

    IGNORE_HR(_pMap->Add(pch, LongToPtr(idx), /* pvAdditionalKey =*/pv));

    TraceTag((
        tagPeerExtendedTagTableBooster,
        "CExtendedTagTableBooster::SetHint: SET,  idx = %ld for [%lx] %ls",
        idx, pv, pch));

Cleanup:
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\privacy.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Internet Explorer
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       PRIVACY.CXX
//
//  Contents:   Implementation of privacy list management
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_PRIVACY_HXX_
#define X_PRIVACY_HXX_
#include "privacy.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_LOCKS_HXX_
#define X_LOCKS_HXX_
#include "locks.hxx"
#endif

#define ENUM_ENSURE_LIST_DOC        if (_pList->IsShutDown()) \
                                    {                         \
                                        hr = E_FAIL;          \
                                        goto Cleanup;         \
                                    }                         \

#define ENSURE_LIST_DOC             if (_fShutDown)           \
                                    {                         \
                                        hr = E_FAIL;          \
                                        goto Cleanup;         \
                                    }                         \

MtDefine(PrivacyList, Mem, "PrivacyList");
MtDefine(CEnumPrivacyRecords, PrivacyList, "CEnumPrivacyRecords")
MtDefine(CPrivacyList, PrivacyList, "CPrivacyList")
MtDefine(CStringAtomizer, PrivacyList, "CStringAtomizer")
MtDefine(CPrivacyRecord, PrivacyList, "CPrivacyRecord")
MtDefine(PrivacyUrl, PrivacyList, "Privacy Url - string")
MtDefine(CPrivacyRecord_pchUrl, PrivacyList, "CPrivacyRecord_pchUrl")
MtDefine(CPrivacyRecord_pchPolicyRefUrl, PrivacyList, "CPrivacyRecord_pchPolicyRefUrl")
MtDefine(StringAtom, PrivacyList, "StringAtom")
DeclareTag(tagPrivacyAddToList, "Privacy", "trace additions to CPrivacyList")
DeclareTag(tagPrivacySwitchList, "Privacy", "trace when pending and regular lists merge/switch")


CPrivacyList::~CPrivacyList()
{   
    ClearNodes();
    if (_pSA)
        delete _pSA;
}

HRESULT
CPrivacyList::QueryInterface(REFIID iid, LPVOID * ppv)
{
    HRESULT hr = THR(E_NOTIMPL);

    ENSURE_LIST_DOC

    if (!ppv)
    {
        hr = THR(E_POINTER);
        goto Cleanup;
    }    

    switch(iid.Data1)
    {
    QI_CASE(IUnknown)
        AddRef();
        *ppv = (LPVOID)this;
        hr = S_OK;
        goto Cleanup;
    }

Cleanup:
    RRETURN(hr);
}

ULONG
CPrivacyList::AddRef()
{
    return ++_ulRefs;
}

ULONG 
CPrivacyList::Release()
{
    _ulRefs--;

    if (!_ulRefs)
    {
        delete this;
        return 0;
    }

    return _ulRefs;
}

HRESULT
CPrivacyList::Init()
{
    HRESULT hr = S_OK;

    _pSA = new(Mt(CStringAtomizer)) CStringAtomizer();
    if (!_pSA)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = _cs.Init();

Cleanup:
    RRETURN(hr);
}

HRESULT 
CPrivacyList::ClearNodes()
{
    // Don't check for shutdown state here since we call this from the destructor
    // In Doc passivate we set the shutdown state and release our reference but
    // there may be others who hold on to this via the enumerator

    HRESULT          hr       = S_OK;
    CPrivacyRecord * pTemp    = NULL;    

    // If InitializeCriticalSection for _cs fails, the doc will delete the privacy list obj
    // which will end up calling ClearNodes and will die on these CriticalSection calls
    // This is the only function where we need this check
    if (_cs.IsInited())
        EnterCriticalSection();

    CPrivacyRecord * pCurrent = _pHeadRec;
        
    _fPrivacyImpacted = 0;
    _pHeadRec = _pTailRec = _pPruneRec = _pSevPruneRec = NULL;    
       
    while (pCurrent != NULL)
    {
        IGNORE_HR(pCurrent->GetNext(&pTemp));        
        DeleteNode(pCurrent, pCurrent->IsGood());
        pCurrent = pTemp;
    }

    if (_pSA)
    {        
        _pSA->Clear();
    }

    Assert(_ulSize == 0);
    Assert(_ulGood == 0);

    if (_cs.IsInited())
        LeaveCriticalSection();

    RRETURN(hr);
}

CPrivacyRecord * 
CPrivacyList::CreateRecord(const TCHAR * pchUrl, const TCHAR * pchPolicyRef, DWORD dwFlags)
{
    CPrivacyRecord * pPR            = NULL;
    HRESULT          hr             = S_OK;
    TCHAR *          pchAtomizedUrl = NULL;
    TCHAR *          pchAtomizedRef = NULL;
    
    if (pchPolicyRef && *pchPolicyRef && _pSA)
    {
        pchAtomizedRef = _pSA->GetString(pchPolicyRef);
        if (!pchAtomizedRef)
        {
            hr = THR(E_OUTOFMEMORY);
            goto Cleanup;
        }
    }

    if (pchUrl && *pchUrl && _pSA)
    {
        pchAtomizedUrl = _pSA->GetString(pchUrl);
        if (!pchAtomizedUrl)
        {
            hr = THR(E_OUTOFMEMORY);
            goto Cleanup;
        }
    }

    pPR = new(Mt(CPrivacyRecord)) CPrivacyRecord(pchAtomizedUrl, pchAtomizedRef, dwFlags);
    
    if (!pPR)
    {
        hr = THR(E_OUTOFMEMORY);
        goto Cleanup;
    }
    
Cleanup:
    return pPR;
}

HRESULT 
CPrivacyList::AddNode(const TCHAR * pchUrl, const TCHAR * pchPolicyRef, DWORD dwFlags)
{
    HRESULT          hr         = S_OK;
    CPrivacyRecord * pRecord    = NULL;
    ENSURE_LIST_DOC
    
    if (!*pchUrl && !(dwFlags & PRIVACY_URLISTOPLEVEL))
        goto Cleanup;
        
    EnterCriticalSection();

    pRecord = CreateRecord(pchUrl, pchPolicyRef, dwFlags);
    if (!pRecord)
    {
        hr = E_OUTOFMEMORY;
        goto Error;
    }

    if (pRecord->IsGood())
        _ulGood++;

    if (pRecord)
    {
        if (!_ulSize || !_pTailRec) // second clause is to fix a stress case
        {   
            AssertSz(!_ulSize, "Privacy list corruption!"); // hopefully this assert will allow us to
                                                            // catch that situation in the debugger
            _pHeadRec = _pTailRec = pRecord;
        }
        else
        {
            Assert(_pTailRec);
            _pTailRec->SetNext(pRecord);
            _pTailRec = pRecord;
        }
        _ulSize++;
    }        

    // Has global privacy been impacted?
    if ( (dwFlags & COOKIEACTION_REJECT) ||
         (dwFlags & COOKIEACTION_SUPPRESS) ||
         (dwFlags & COOKIEACTION_DOWNGRADE)) 
    {
        _fPrivacyImpacted = TRUE;
    }
        
Error:
    LeaveCriticalSection();

Cleanup:
    if (_ulSize >= MAX_ENTRIES)
    {
        AddRef();
        GWPostMethodCallEx(_pts, (void*)this,ONCALL_METHOD(CPrivacyList, PruneList, prunelist), 0, TRUE, "CPrivacyList::PruneList");
    }

    RRETURN(hr);
}

HRESULT
CPrivacyList::GetEnumerator(IEnumPrivacyRecords ** ppEnum)
{
    HRESULT               hr   = S_OK;
    CEnumPrivacyRecords * pEPR = NULL;
    
    ENSURE_LIST_DOC

    if (!ppEnum)
    {
        hr = THR(E_POINTER);
        goto Cleanup;
    }

    pEPR = new(Mt(CEnumPrivacyRecords)) CEnumPrivacyRecords(this);

    if (!pEPR)
    {
        hr = THR(E_OUTOFMEMORY);
        goto Cleanup;
    }

    *ppEnum = (IEnumPrivacyRecords*)pEPR;

Cleanup:
    RRETURN(hr);
}

void CPrivacyList::DeleteNode(CPrivacyRecord * pNode, BOOL fIsGood)
{
    if (fIsGood)
        _ulGood--;

    _ulSize--;

    if (pNode->GetUrl())
        _pSA->ReleaseString(pNode->GetUrl());

    if (pNode->GetPolicyRefUrl())
        _pSA->ReleaseString(pNode->GetPolicyRefUrl());

    delete pNode;      
}

void
CPrivacyList::PruneList(DWORD_PTR dwFlags)
{
    int i = 0;

    int refs = Release();
           
    if (refs == 0 || _fShutDown || _ulSize == 0)
        return;

    EnterCriticalSection();

    CPrivacyRecord * pNextRec = _pPruneRec ? _pPruneRec->GetNextNode() : _pHeadRec;

    Assert(pNextRec);  // shouldn't be calling this function if there are no nodes
  
    if (_ulSize < MAX_ENTRIES) // if we've been posted too many times
        goto Cleanup;

    if (_ulGood == 0)
    {
        SeverePruneList(0);
        goto Cleanup;
    }

    // handle the case when we're looking at the head of the list
    while (_pPruneRec == NULL && pNextRec != NULL && i < PRUNE_SIZE && _ulGood > 0) 
    {
        if (pNextRec->IsGood())
        {
            _pHeadRec = pNextRec->GetNextNode();
            DeleteNode(pNextRec, TRUE);
            pNextRec = _pHeadRec;
        }
        else
        {
            _pPruneRec = pNextRec;
            pNextRec = pNextRec->GetNextNode();
        }
        i++;
    }

    for (; i < PRUNE_SIZE && _ulGood > 0 && pNextRec != NULL; i++)
    {

        if (pNextRec->IsGood())
        {
            _pPruneRec->SetNext(pNextRec->GetNextNode());
            DeleteNode(pNextRec, TRUE);            
        }      
        else if (_pPruneRec->GetNextNode())   // _pPruneRec should never fall off the end of the list
        {
            _pPruneRec = _pPruneRec->GetNextNode();
        }

        pNextRec = _pPruneRec->GetNextNode();
    }

    if (_ulSize >= MAX_ENTRIES)
        SeverePruneList(0);

Cleanup:

    LeaveCriticalSection();    

    return;
}

void
CPrivacyList::SeverePruneList(DWORD_PTR dwFlags)
{

    if (_fShutDown || _ulSize == 0)
            return;

    CPrivacyRecord * pNextRec = _pSevPruneRec ? _pSevPruneRec->GetNextNode() : _pHeadRec; 
    CPrivacyRecord * pTempRec = pNextRec;

    for (int i = 0; i < PRUNE_SIZE && pNextRec != NULL; i++)
    {
        Assert(!pNextRec->IsGood());
        pTempRec = pNextRec->GetNextNode();
        DeleteNode(pNextRec, FALSE);
        pNextRec = pTempRec;        
    }

    // _pSevPruneRec shouldn't fall off end of the list
    if (_pSevPruneRec)
    {
        _pSevPruneRec->SetNext(pNextRec);
    }
    else
    {
        _pHeadRec = pNextRec;
    }

    _pPruneRec = _pSevPruneRec;

    Assert(_ulSize < MAX_ENTRIES); // all these prunes should be successful
    
    return;
}

inline void 
CPrivacyList::EnterCriticalSection() 
{
    _cs.Enter();
}

inline void 
CPrivacyList::LeaveCriticalSection() 
{
    _cs.Leave();
}

HRESULT
CPrivacyRecord::GetNext(CPrivacyRecord ** ppNextRec)
{
    HRESULT hr = S_OK;
    if (!ppNextRec)
    {
        hr = THR(E_POINTER);
        goto Cleanup;
    }

    *ppNextRec = _pNextNode;

Cleanup:
    RRETURN(hr);
}

HRESULT
CPrivacyRecord::SetNext(CPrivacyRecord * pNextRec)
{
    _pNextNode = pNextRec;
    return S_OK;
}

inline BOOL
CPrivacyRecord::IsGood()
{
    return (!(   _dwFlags & COOKIEACTION_REJECT 
              || _dwFlags & COOKIEACTION_SUPPRESS 
              || _dwFlags & COOKIEACTION_DOWNGRADE));
}

CEnumPrivacyRecords::CEnumPrivacyRecords(CPrivacyList * pList)
    : _ulRefs(1)
{
    Assert(pList);
    _pList = pList;
    _pList->AddRef();
    _pNextRec = _pList->GetHeadRec();
    _fAtEnd = FALSE;
}

CEnumPrivacyRecords::~CEnumPrivacyRecords()
{
    _pList->Release();
}

HRESULT
CEnumPrivacyRecords::QueryInterface(REFIID iid, LPVOID * ppv)
{
    HRESULT hr = E_NOTIMPL;
        
    ENUM_ENSURE_LIST_DOC

    if (!ppv)
    {
        hr = THR(E_POINTER);
        goto Cleanup;
    }

    switch (iid.Data1)
    {
    QI_CASE(IUnknown)
    QI_CASE(IEnumPrivacyRecords)    
        AddRef();
        *ppv = (void *)this;
        hr = S_OK;
        goto Cleanup;    
    }

Cleanup:
    RRETURN(hr);
}

ULONG
CEnumPrivacyRecords::AddRef()
{
    return ++_ulRefs;
}

ULONG
CEnumPrivacyRecords::Release()
{
    _ulRefs--;

    if (!_ulRefs)
    {
        delete this;
        return 0;
    }

    return _ulRefs;
}

HRESULT
CEnumPrivacyRecords::Reset()
{
    HRESULT hr = S_OK;
    
    ENUM_ENSURE_LIST_DOC

    _pNextRec = _pList->GetHeadRec();

Cleanup:
    RRETURN(hr);
}


HRESULT
CEnumPrivacyRecords::GetSize(ULONG * pSize)
{
    HRESULT hr = S_OK;
    
    ENUM_ENSURE_LIST_DOC

    if (!pSize)
    {
        hr = THR(E_POINTER);
        goto Cleanup;
    }

    *pSize = _pList->GetSize();

Cleanup:
    RRETURN(hr);
}

HRESULT
CEnumPrivacyRecords::GetPrivacyImpacted(BOOL * pImpacted)
{
    HRESULT hr = S_OK;
    
    ENUM_ENSURE_LIST_DOC

    if (!pImpacted)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pImpacted = _pList->GetPrivacyImpacted();

Cleanup:
    RRETURN(hr);
}

HRESULT 
CEnumPrivacyRecords::Next(BSTR  * pbstrUrl, 
                          BSTR  * pbstrPolicyRef, 
                          LONG  * pdwReserved, 
                          DWORD * pdwFlags)
{
    HRESULT hr = S_OK;
    
    ENUM_ENSURE_LIST_DOC

    if (!pbstrUrl|| !pbstrPolicyRef || !pdwFlags)
    {
        hr = THR(E_POINTER);
        goto Cleanup;
    }

    if (_fAtEnd)
    {
        if (_pNextRec->GetNextNode())  // at the end, is there more now?
        {
            _pNextRec = _pNextRec->GetNextNode();
            _fAtEnd = FALSE;
        }
        else
        {
            hr = S_FALSE;
            goto Cleanup;
        }

    }
    else if (!_pNextRec)   // no nodes when we were created
    {
        if (_pList->GetHeadRec())
        {
            _pNextRec = _pList->GetHeadRec();
        }
        else
        {
            hr = S_FALSE;
            goto Cleanup;
        }
    }

    if (_pNextRec->HasUrl())
    {
        hr = FormsAllocString(_pNextRec->GetUrl(), pbstrUrl);
        if (hr)
            goto Cleanup;
    }
    else
    {
        *pbstrUrl = NULL;
    }    

    if (_pNextRec->HasPolicyRefUrl())
    {
        hr = FormsAllocString(_pNextRec->GetPolicyRefUrl(), pbstrPolicyRef);
        if (hr)
            goto Cleanup;
    }
    else
    {
        *pbstrPolicyRef = NULL;
    }    

    *pdwFlags     = _pNextRec->GetPrivacyFlags();
    
    if (_pNextRec->GetNextNode())
        _pNextRec     = _pNextRec->GetNextNode();
    else
        _fAtEnd = TRUE;

Cleanup:
    RRETURN1(hr, S_FALSE);
}

TCHAR *
PrivacyUrlFromUrl(const TCHAR * pchUrl)
{
    BOOL    fDone      = FALSE;
    TCHAR * pchPrivUrl = NULL;
    int     cSize      = 0;

    if (!pchUrl || !_tcslen(pchUrl))
        return NULL;

    for (const TCHAR * pchCur = pchUrl; !fDone; pchCur++)
    {                
        cSize++;
        switch(*pchCur)
        {
        case _T(':'):
            // if it's not http or https, don't add it
            if (   (cSize != 5 && cSize != 6)
                || (cSize == 5 && _tcsnicmp(pchUrl, 5, _T("http:"), 5))
                || (cSize == 6 && _tcsnicmp(pchUrl, 6, _T("https:"), 6)))
            {
                return NULL;
            }
            if (*(pchCur+1) == _T('/') && *(pchCur+2) == _T('/'))
            {
                pchCur += 2;
                cSize += 2;
            }
            break;
        case _T('/'):
        case _T('\0'):
            cSize--;
            fDone = TRUE;
            break;
        default:            
            break;
        }
    }

    // now we have a size for the shortened URL
    
    pchPrivUrl = new(Mt(PrivacyUrl)) TCHAR[cSize + 1];
    if (!pchPrivUrl)
        return NULL;

    _tcsncpy(pchPrivUrl, pchUrl, cSize);
    pchPrivUrl[cSize] = _T('\0');

    return pchPrivUrl;
}

void
CStringAtomizer::Clear()
{    
    WHEN_DBG (void * pResult;)
    DWORD            dwHash;

    _ht.WriterClaim();

    UINT             uiIndex  = 0;
    CStringAtom *    pAtom   = (CStringAtom*)_ht.GetFirstEntryUnsafe(&uiIndex);

    while (pAtom != NULL)
    {
        Assert(pAtom->_cRefs == 0);

        dwHash = HashString(pAtom->_pchString, _tcslen(pAtom->_pchString), 0);
        dwHash <<= 2;
        if (dwHash == 0) dwHash = 1<<2;
    
        WHEN_DBG(pResult =) _ht.RemoveUnsafe((void*)((DWORD_PTR)dwHash), (void*)pAtom->_pchString);
        Assert(pResult);
        MemFree(pAtom);
        pAtom = (CStringAtom*)_ht.GetNextEntryUnsafe(&uiIndex);
    }

    _ht.WriterRelease();

    _ht.ReInit();
}

TCHAR * 
CStringAtomizer::GetString (const TCHAR * pchUrl)
{

    HRESULT        hr      = S_OK;
    int            iLen    = _tcslen(pchUrl);
    DWORD          dwHash  = HashString(pchUrl, iLen, 0);
    CStringAtom *  pAtom   = NULL;

    dwHash <<= 2;
    if (dwHash == 0) dwHash = 1<<2;

    hr = _ht.LookupSlow((void*)((DWORD_PTR)dwHash), (void*)pchUrl, (void**)&pAtom);

    if (!hr)
    {
        Assert(!_tcscmp(pAtom->_pchString, pchUrl));
        pAtom->_cRefs++;
        return pAtom->_pchString;
    }

    pAtom = (CStringAtom*)MemAlloc(Mt(StringAtom),(sizeof(CStringAtom) + (iLen+1)*sizeof(TCHAR)));
    if (!pAtom)
        return NULL;
    
    pAtom->_cRefs = 1;
    _tcscpy(pAtom->_pchString, pchUrl);

    THR(_ht.Insert((void*)((DWORD_PTR)dwHash), (void*)pAtom DBG_COMMA WHEN_DBG(pAtom->_pchString)));

    return pAtom->_pchString;
}

void    
CStringAtomizer::ReleaseString (const TCHAR * pchUrl)
{
    CStringAtom *  pAtom = NULL;
    
    pAtom = (CStringAtom *)((DWORD_PTR)pchUrl - (DWORD_PTR)sizeof(int));

    pAtom->_cRefs--;

    if (pAtom->_cRefs == 0)
    {        
        int            iLen    = _tcslen(pchUrl);
        DWORD          dwHash  = HashString(pchUrl, iLen, 0);

        dwHash <<= 2;
        if (dwHash == 0) dwHash = 1<<2;

        if (_ht.Remove((void*)((DWORD_PTR)dwHash), (void*)pAtom->_pchString))
            MemFree(pAtom);   
        else
            AssertSz(0, "Releasing a string not in the table");
    }
}

BOOL
CStringAtomizer::HashCompare(const void *pObject, const void * pvDataPassedIn, const void * pvVal2)
{
    TCHAR       * str1 = (TCHAR*)pvDataPassedIn;
    CStringAtom * str2 = (CStringAtom*)pvVal2;

    return !_tcscmp(str1, str2->_pchString);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\progsink.cxx ===
//+------------------------------------------------------------------------
//
//  File:       progsink.cxx
//
//  Contents:   IProgSink implementation for CDoc
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_DOCGLBS_HXX_
#define X_DOCGLBS_HXX_
#include "docglbs.hxx"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_PRGSNK_H_
#define X_PRGSNK_H_
#include "prgsnk.h"
#endif

#ifndef X_PROGSINK_HXX_
#define X_PROGSINK_HXX_
#include "progsink.hxx"
#endif

//+---------------------------------------------------------------------------
//  Debugging Support
//----------------------------------------------------------------------------

DeclareTag(tagProgSink, "ProgSink", "Trace ProgSink");
DeclareTag(tagProgSinkCookie, "ProgSink", "Don't reuse cookies for progsinks");

MtDefine(CProgSink, CDoc, "CProgSink")
MtDefine(CProgSink_aryProg_pv, CProgSink, "CProgSink::_aryProg::_pv")
MtDefine(CProgSinkText, CProgSink, "CProgSink (item text)")
MtDefine(CProgSinkFormat, CProgSink, "CProgSink (formatted text)")

#if DBG==1

static LPCSTR _apchProgClass[] =
{
    "HTML",
    "MULTIMEDIA",
    "CONTROL",
    "DATABIND",
    "OTHER",
    "NOREMAIN",
    "FRAME"
};

static LPCSTR _apchProgState[] =
{
    "IDLE",
    "FINISHING",
    "CONNECTING",
    "LOADING"
};

#endif

//+---------------------------------------------------------------------------
//  Definitions
//----------------------------------------------------------------------------

#define PROGSINK_CHANGE_COUNTERS    0x0001
#define PROGSINK_CHANGE_CURRENT     0x0002
#define PROGSINK_CHANGE_RESCAN      0x0004
#define PROGSINK_CHANGE_PROGRESS    0x0008

// these numbers should be scaled all togather not individually
// These numbers are intentionally set to a large number to take into account
// small download framents

#define PROGSINK_POTEN_HTML         4000    // potential for html
#define PROGSINK_POTEN_FRAME        2000    // potential for frame
#define PROGSINK_POTEN_BELOW        1000    // potential substract for lower level HTML/FRAME

#define PROGSINK_ADJUST_SCALE       1000    // adjust factor scale 1000 represent
#define PROGSINK_PROG_INIT          1000    // initial minimum
#define PROGSINK_PROG_MAX           10000   // total gauge range

#define PROGSINK_POTEN_MIN          100     // PROGSINK_ADJUST_SCALE * PROGSINK_PROG_INIT/PROGSINK_PROG_MAX
#define PROGSINK_POTEN_END          1

#define PROGSINK_PROG_MIN           0       // we start from this position

#define PROGSINK_PROG_STEP          100     // small progress step

#define PROGSINK_TEXT_LENGTH        512

//+---------------------------------------------------------------------------
//
//  Member:     FormatProgress
//
//  Synopsis:   Computes the final progress string for the entry
//
//----------------------------------------------------------------------------

void
FormatProgress(CDoc * pDoc, PROGDATA * ppd)
{
    Assert(ppd->pchFormat == NULL);

    TCHAR * pch = ppd->pchText;

    if (ppd->dwIds)
    {
        const TCHAR * pchArg   = pch ? pch : g_Zero.ach;
        TCHAR * pchAlloc = NULL;

        if (    *pchArg
            &&  (   ppd->dwIds == IDS_BINDSTATUS_DOWNLOADINGDATA_PICTURE
                ||  ppd->dwIds == IDS_BINDSTATUS_DOWNLOADINGDATA_TEXT
                ||  ppd->dwIds == IDS_BINDSTATUS_DOWNLOADINGDATA_BITS))
        {
            pchAlloc = GetFriendlyUrl(pchArg, NULL,
                pDoc->_pOptionSettings->fShowFriendlyUrl, FALSE);

            if (pchAlloc && *pchAlloc)
            {
                pchArg = pchAlloc;
            }
        }

        IGNORE_HR(Format(FMT_OUT_ALLOC, &ppd->pchFormat, 0,
            MAKEINTRESOURCE(ppd->dwIds), pchArg));

        MemFree(pchAlloc);

        if (ppd->pchFormat)
        {
            IGNORE_HR(MemRealloc(Mt(CProgSinkFormat), (void **)&ppd->pchFormat,
                (_tcslen(ppd->pchFormat) + 1) * sizeof(TCHAR)));
        }
    }
    else if (pch)
    {
        IGNORE_HR(MemAllocString(Mt(CProgSinkFormat), pch, &ppd->pchFormat));
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CProgSink::CProgSink
//
//  Synopsis:   Constructor
//
//----------------------------------------------------------------------------

CProgSink::CProgSink(CDoc * pDoc, CMarkup * pMarkup)
    : CBaseFT(&_cs)
{
    _fCSInited = FALSE;

    _pDoc = pDoc;
    _pDoc->SubAddRef();

    _pMarkup = pMarkup;
    _pMarkup->SubAddRef();

    _pts = GetThreadState();

    SubAddRef();

#if DBG==1
    MemSetName((this, "CProgSink pDoc=%08x pProgSinkFwd=%08x", _pDoc, _pProgSinkFwd));

    if (_pProgSinkFwd)
        TraceTag((tagProgSink, "[%08lX] Construct (Forward to [%08lX])",
            this, _pProgSinkFwd));
    else
        TraceTag((tagProgSink, "[%08lX] Construct", this));
#endif
}

//+---------------------------------------------------------------------------
//
//  Member:     CProgSink::Init
//
//  Synopsis:   Work around the error handling for InitializeCriticalSection
//
//----------------------------------------------------------------------------
HRESULT
CProgSink::Init()
{
    HRESULT     hr;

    hr = HrInitializeCriticalSection(&_cs);
    if (!hr)
        _fCSInited = TRUE;

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CProgSink::~CProgSink
//
//  Synopsis:   Destructor
//
//----------------------------------------------------------------------------

CProgSink::~CProgSink()
{
    if (_fCSInited)
        DeleteCriticalSection(&_cs);

    TraceTag((tagProgSink, "[%08lX] Destruct", this));
}

//+---------------------------------------------------------------------------
//
//  Member:     CProgSink::Passivate
//
//  Synopsis:   Releases all resources used by this object.  Puts it into
//              the passive state whereby all further progress calls are
//              rejected.
//
//----------------------------------------------------------------------------

void
CProgSink::Passivate()
{
    PROGDATA * ppd;
    UINT cSize;

    TraceTag((tagProgSink, "[%08lX] Passivate (enter)", this));

    EnterCriticalSection();

    _fPassive = TRUE;

    LeaveCriticalSection();

    if(_fSentSignal)
    {
        GWKillMethodCallEx(_pts, this, ONCALL_METHOD(CProgSink, OnMethodCall, onmethodcall), 0);
        // If we killed the pending window we need to Update the spin status synchronously
        // because the markup will go away soon, and we killed the posted message to update
        // the spin
        if(_pMarkup->_fWindowPending)
            DoUpdate(TRUE);
        _fSentSignal = FALSE;
    }

    cSize = _aryProg.Size();
    ppd = _aryProg;

    for (; cSize > 0; --cSize, ++ppd)
    {
        if (ppd->bFlags & PDF_FREE)
            continue;

        if (ppd->pchText)
            MemFree(ppd->pchText);

        if (ppd->pchFormat)
            MemFree(ppd->pchFormat);
    }

    _aryProg.DeleteAll();

    if (_fGotDefault)
    {
        MemFree(_pdDefault.pchText);
        _pdDefault.pchText = NULL;

        MemFree(_pdDefault.pchFormat);
        _pdDefault.pchFormat = NULL;

        _fGotDefault = FALSE;
    }


    _pDoc->SubRelease();
    _pDoc = NULL;

    _pMarkup->SubRelease();
    _pMarkup = NULL;

    ReleaseInterface(_pProgSinkFwd);

    TraceTag((tagProgSink, "[%08lX] Passivate (leave)", this));
}

//+---------------------------------------------------------------------------
//
//  Member:     CProgSink::Detach
//
//  Synopsis:   Called by CDoc before it releases it's final reference on
//              the CProgSink object.
//
//----------------------------------------------------------------------------

void
CProgSink::Detach()
{
    TraceTag((tagProgSink, "[%08lX] Detach", this));
    super::Release();
}

//+---------------------------------------------------------------------------
//
//  Member:     CProgSink::QueryInterface, IUnknown
//
//  Synopsis:   As per IUnknown
//
//----------------------------------------------------------------------------

STDMETHODIMP
CProgSink::QueryInterface(REFIID iid, void **ppv)
{
    if (iid == IID_IProgSink || iid == IID_IUnknown)
    {
        *ppv = (IProgSink *)this;
    }
    else
    {
        *ppv = 0;
        return E_NOINTERFACE;
    }

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CProgSink::AddRef, IUnknown
//
//  Synopsis:   As per IUnknown
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG)
CProgSink::AddRef()
{
    return(super::SubAddRef());
}

//+---------------------------------------------------------------------------
//
//  Member:     CProgSink::Release, IUnknown
//
//  Synopsis:   As per IUnknown
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG)
CProgSink::Release()
{
    return(super::SubRelease());
}

//+---------------------------------------------------------------------------
//
//  Member:     CProgSink::AddProgress, IProgSink
//
//  Synopsis:   Allocates a slot in the progress vector
//
//----------------------------------------------------------------------------

STDMETHODIMP
CProgSink::AddProgress(DWORD dwClass, DWORD * pdwCookie)
{
    PROGDATA    pd;
    PROGDATA *  ppd;
    UINT        cSize;
    DWORD       dwCookie;
    HRESULT     hr = S_OK;

    if ((dwClass & ~(PROGSINK_CLASS_FORWARDED|PROGSINK_CLASS_NOSPIN)) > PROGSINK_CLASS_FRAME)
        RRETURN(E_INVALIDARG);

    memset(&pd, 0, sizeof(PROGDATA));
    pd.bClass = (BYTE)dwClass;
    pd.bState = PROGSINK_STATE_IDLE;
    pd.bBelow = !!(dwClass & PROGSINK_CLASS_FORWARDED);
    pd.bFlags = (dwClass & PROGSINK_CLASS_NOSPIN) ? PDF_NOSPIN : 0;

    EnterCriticalSection();

    if (_fPassive)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    if (_pProgSinkFwd)
    {
        hr = THR(_pProgSinkFwd->AddProgress(dwClass | PROGSINK_CLASS_FORWARDED,
                pdwCookie));
        if (hr)
            goto Cleanup;

        SetCounters(pd.bClass, FALSE, TRUE, FALSE);
        goto Cleanup;
    }

    if (_cFree > 0 WHEN_DBG(&& !IsTagEnabled(tagProgSinkCookie) ) )
    {
        // Look for a free slot to reuse

        ppd   = &_aryProg[0];
        cSize = _aryProg.Size();

        for (; cSize > 0; --cSize, ++ppd)
            if (ppd->bFlags & PDF_FREE)
                break;

        Assert(cSize > 0);

        *ppd = pd;
        _cFree -= 1;

        dwCookie = _aryProg.Size() - cSize + 1;
    }
    else
    {
        // Add a new slot to the end of the array

        hr = THR(_aryProg.AppendIndirect(&pd));
        if (hr)
            goto Cleanup;

        dwCookie = _aryProg.Size();
    }

    *pdwCookie = (dwCookie << 8) | pd.bClass;

    SetCounters(pd.bClass, !!pd.bBelow, TRUE, !(pd.bFlags & PDF_NOSPIN));

    TraceTag((tagProgSink, "[%08lX] AddProgress %2d%s %s",
        this, *pdwCookie >> 8, pd.bBelow ? "/b" : "",
        _apchProgClass[pd.bClass]));

Cleanup:
    LeaveCriticalSection();
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CProgSink::SetProgress, IProgSink
//
//  Synopsis:   Sets the data associated with a progress slot
//
//----------------------------------------------------------------------------

STDMETHODIMP
CProgSink::SetProgress(DWORD dwCookie, DWORD dwFlags, DWORD dwState,
    LPCTSTR pchText, DWORD dwIds, DWORD dwPos, DWORD dwMax)
{
    PROGDATA * ppd;
    DWORD dwSlot;
    HRESULT hr = S_OK;

    EnterCriticalSection();

    if (_fPassive)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    if (_pProgSinkFwd)
    {
        hr = THR(_pProgSinkFwd->SetProgress(dwCookie, dwFlags, dwState,
                pchText, dwIds, dwPos, dwMax));
        goto Cleanup;
    }

    dwSlot = (dwCookie >> 8);

    if (dwSlot == 0 || dwSlot > (UINT)_aryProg.Size())
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    ppd = &_aryProg[dwSlot - 1];

    if (ppd->bFlags & PDF_FREE)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (dwFlags & PROGSINK_SET_STATE)
    {
        ppd->bState = (BYTE)dwState;
    }

    if (dwFlags & PROGSINK_SET_IDS)
    {
        ppd->dwIds = dwIds;

        if (ppd->pchFormat)
        {
            MemFree(ppd->pchFormat);
            ppd->pchFormat = NULL;
        }
    }

    if (dwFlags & PROGSINK_SET_TEXT)
    {
        if (pchText == NULL)
        {
            MemFree(ppd->pchText);
            ppd->pchText = NULL;
        }
        else
        {
            hr = THR(MemReplaceString(Mt(CProgSinkText), pchText, &ppd->pchText));
            if (hr)
                goto Cleanup;
        }

        if (ppd->pchFormat)
        {
            MemFree(ppd->pchFormat);
            ppd->pchFormat = NULL;
        }
    }

    if (dwFlags & (PROGSINK_SET_MAX | PROGSINK_SET_POS))
    {
        // update the progress
        // signal only if a progress is made
        if (UpdateProgress(ppd, dwFlags, dwPos, dwMax)
                    && !(_uChange & (PROGSINK_CHANGE_PROGRESS
                                    | PROGSINK_CHANGE_RESCAN
                                    | PROGSINK_CHANGE_CURRENT)))
        {
            Signal(PROGSINK_CHANGE_PROGRESS);
        }
    }

    if (!(_uChange & PROGSINK_CHANGE_RESCAN))
    {
        if (dwSlot == _dwSlotCur)
        {
            if (ppd->bState < _bStateCur || (!ppd->pchText && !ppd->dwIds))
                Signal(PROGSINK_CHANGE_RESCAN);
            else
                Signal(PROGSINK_CHANGE_CURRENT);
        }
        else if (   (ppd->pchText || ppd->dwIds)
                &&  ppd->bState > PROGSINK_STATE_IDLE
                &&  (   ppd->bBelow < _bBelowCur
                    ||  ppd->bState > _bStateCur))
        {
            Signal(PROGSINK_CHANGE_RESCAN);
        }
    }

#if DBG==1
    TraceTagEx((tagProgSink, TAG_NONEWLINE, "[%08lX] SetProgress %2d%s ",
        this, dwSlot, ppd->bBelow ? "/b" : ""));
    if (dwFlags & PROGSINK_SET_STATE)
        TraceTagEx((tagProgSink, TAG_NONAME|TAG_NONEWLINE, "%s ",
            _apchProgState[dwState]));
    if (dwFlags & (PROGSINK_SET_POS|PROGSINK_SET_MAX))
        TraceTagEx((tagProgSink, TAG_NONAME|TAG_NONEWLINE, "[%d/%d] ",
            ppd->dwPos, ppd->dwMax));
    if (dwFlags & PROGSINK_SET_IDS)
        TraceTagEx((tagProgSink, TAG_NONAME|TAG_NONEWLINE, "ids=%ld ",
            ppd->dwIds));
    if (dwFlags & PROGSINK_SET_TEXT)
        TraceTagEx((tagProgSink, TAG_NONAME|TAG_NONEWLINE, "\"%ls\"",
            pchText ? pchText : _T("")));
    TraceTagEx((tagProgSink, TAG_NONAME, ""));
#endif

Cleanup:
    LeaveCriticalSection();

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CProgSink::DelProgress, IProgSink
//
//  Synopsis:   Frees the given progress slot
//
//----------------------------------------------------------------------------

STDMETHODIMP
CProgSink::DelProgress(DWORD dwCookie)
{
    PROGDATA * ppd;
    DWORD dwSlot;
    HRESULT hr = S_OK;

    EnterCriticalSection();

    if (_fPassive)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    if (_pProgSinkFwd)
    {
        hr = THR(_pProgSinkFwd->DelProgress(dwCookie));
        if (hr)
            goto Cleanup;

        SetCounters((BYTE)dwCookie, FALSE, FALSE, FALSE);
        goto Cleanup;
    }

    dwSlot = (dwCookie >> 8);

    if (dwSlot == 0 || dwSlot > (UINT)_aryProg.Size())
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    ppd = &_aryProg[dwSlot - 1];

    if (ppd->bFlags & PDF_FREE)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (!ppd->bBelow && ppd->bClass == PROGSINK_CLASS_HTML && !_fGotDefault)
    {
        _pdDefault = *ppd;
        _fGotDefault = TRUE;
    }
    else
    {
        if (ppd->pchText)
            MemFree(ppd->pchText);
        if (ppd->pchFormat)
            MemFree(ppd->pchFormat);
    }

    if (ppd->dwPos && ppd->dwPos < ppd->dwMax)  // aborted download
    {
        _cOngoing --;
        // adjust dwMaxTotal so that we can let other download take the bar
        _dwMaxTotal = _dwMaxTotal - (ppd->dwMax - ppd->dwPos);
    }

    SetCounters(ppd->bClass, !!ppd->bBelow, FALSE, !(ppd->bFlags & PDF_NOSPIN));

    ppd->bFlags |= PDF_FREE;
    ppd->dwPos   = 0;
    ppd->dwMax   = 0;
    _cFree += 1;

    TraceTag((tagProgSink, "[%08lX] DelProgress %2d%s", this, dwSlot,
        ppd->bBelow ? "/b" : ""));

    if (_cFree == (UINT)_aryProg.Size())
    {
        _aryProg.DeleteAll();
        _cFree = 0;
    }

    // If we are currently displaying this progress slot, it's time to
    // look for a different one.

    if (dwSlot == _dwSlotCur)
    {
        Signal(PROGSINK_CHANGE_RESCAN);
    }

Cleanup:
    LeaveCriticalSection();

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CProgSink::SetCounters
//
//  Synopsis:   Adjusts the class counters to reflect the addition or
//              deletion of a progress slot.
//
//----------------------------------------------------------------------------

void
CProgSink::SetCounters(DWORD dwClass, BOOL fFwd, BOOL fAdd, BOOL fSpin)
{
    UINT *  pacClass = fFwd ? _acClassBelow : _acClass;
    UINT    cClass   = pacClass[dwClass];

    Assert(!fSpin || !_pProgSinkFwd);

    if (fAdd)
    {
        cClass += 1;
        _cActive += 1;
        _cSpin += !!fSpin;

        if (_cActive == 1)
        {
            _fSendProgDone = TRUE;
        }
    }
    else
    {
        Assert(cClass > 0);
        cClass -= 1;
        Assert(_cActive > 0);
        _cActive -= 1;
        Assert(!fSpin || _cSpin > 0);
        _cSpin -= !!fSpin;
        Assert(_cActive || !_cSpin);
    }

    pacClass[dwClass] = cClass;

    AdjustProgress(dwClass, fFwd, fAdd);

    // Certain transitions are interesting enough to wake up the client:
    //  a) If the HTML file is parsed
    //  b) If the HTML file, frames and controls have finished loading (connect scripts)
    //  c) If the total number of downloads reaches zero (send all done)
    //  d) If the total number of spin requests reaches zero (stop spinning)
    //  e) If the total number of spin requests reaches one (start spinning)

    if (_acClass[PROGSINK_CLASS_HTML] == 1)
    {
        _fSendParseDone = TRUE;
    }

    if (    !(_uChange & PROGSINK_CHANGE_COUNTERS)
        &&  (   (   !fFwd
                &&  !fAdd
                &&  dwClass == PROGSINK_CLASS_HTML
                &&  _acClass[PROGSINK_CLASS_HTML] == 0)
            ||  (   !fFwd
                &&  !fAdd
                &&  (   dwClass == PROGSINK_CLASS_HTML
                    ||  dwClass == PROGSINK_CLASS_FRAME
                    ||  dwClass == PROGSINK_CLASS_CONTROL)
                &&  _acClass[PROGSINK_CLASS_HTML] == 0
                &&  _acClass[PROGSINK_CLASS_FRAME] == 0
                &&  _acClass[PROGSINK_CLASS_CONTROL] == 0)
            ||  (!fAdd && _cActive == 0)
            ||  (!fAdd && fSpin && _cSpin == 0)
            ||  ( fAdd && fSpin && _cSpin == 1)))
    {
        Signal(PROGSINK_CHANGE_COUNTERS);
    }

    // If we are showing (n items remaining) and we've just removed one of
    // those items, then signal that client to update it.

    if (    !(_uChange & PROGSINK_CHANGE_RESCAN)
        &&  (!fAdd && _fShowItemsRemaining))
    {
        Signal(_dwSlotCur ? PROGSINK_CHANGE_CURRENT : PROGSINK_CHANGE_RESCAN);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CProgSink::Signal
//
//  Synopsis:   Posts a message to the creation thread and requests a call
//              to OnProgSink.
//
//----------------------------------------------------------------------------

void
CProgSink::Signal(UINT uChange)
{
    TraceTag((tagProgSink, "[%08lX] Signal %s%s%s%s", this,
        (uChange & PROGSINK_CHANGE_COUNTERS) ? "COUNTERS " : "",
        (uChange & PROGSINK_CHANGE_CURRENT) ? "CURRENT " : "",
        (uChange & PROGSINK_CHANGE_RESCAN) ? "RESCAN " : "",
        (uChange & PROGSINK_CHANGE_PROGRESS) ? "PROGRESS " : ""));

    _uChange |= uChange;

    if (!_fSentSignal)
    {
        _fSentSignal = TRUE;

        IGNORE_HR(GWPostMethodCallEx(_pts, this,
            ONCALL_METHOD(CProgSink, OnMethodCall, onmethodcall), (DWORD_PTR)this, FALSE, "CProgSink::OnMethodCall"));
    }
}



//+---------------------------------------------------------------------------
//
//  Member:     CProgSink::OnMethodCall
//
//  Synopsis:   Updates the status bar and sends progress feedback to the
//              doc in response to changes in the state of the progress sink.
//
//----------------------------------------------------------------------------

void BUGCALL
CProgSink::OnMethodCall(DWORD_PTR dwContext)
{
    Assert(dwContext == (DWORD_PTR)this);
    DoUpdate(FALSE);
    }

void BUGCALL
CProgSink::DoUpdate(BOOL fCleanupOnly)
{
    BOOL    fSendProgDone  = FALSE;
    BOOL    fSendSpin      = FALSE;
    BOOL    fSpin          = FALSE;
    DWORD   dwFlagsProg    = 0;
    DWORD   dwPos          = 0;
    DWORD   dwMax          = 0;
    TCHAR   achText[PROGSINK_TEXT_LENGTH];
    LOADSTATUS loadstatus  = LOADSTATUS_UNINITIALIZED;
    CDoc *  pDoc;

    Assert(GetCurrentThreadId() == _pts->dll.idThread);

    Assert(fCleanupOnly || !_fPassive);

    TraceTag((tagProgSink, "[%08lX] OnMethodCall (enter)", this));

    // Progsink refcounts are odd - this really is a SubAddRef.  We
    // only have 1 real ref, which is the creation ref the markup has,
    // and he releases that by calling Detach() which calls super::Release.
    // We don't want a real ref here, we just want to keep our memory around
    // because CDoc::SetProgress below can tear down our markup.
    AddRef();

    // Hack for ThumbNailView (IE5 bug #66938, #68010)
    // May need to compute formats now to initiate download of background
    // images, etc. Hosts like THUMBVW never make us inplace-active or give
    // us a window/view. This causes us to fire onload without ever needing
    // to compute formats. However, they call Draw() on us as soon as we fire
    // onload. We need the images loaded by then to be be able to render them.
    if (    _pDoc
        && !fCleanupOnly
        &&  _pDoc->_fThumbNailView
        &&  _pMarkup
        &&  (_uChange & PROGSINK_CHANGE_COUNTERS)
        &&  _fSendParseDone
        &&  !_fSentParseDone
        && _acClass[PROGSINK_CLASS_HTML] == 0
       )
    {
        _pMarkup->EnsureFormats();
    }

    EnterCriticalSection();

    if (_uChange & PROGSINK_CHANGE_COUNTERS)
    {
        if (!fCleanupOnly)
        {
            if (_fSendParseDone)
            {
                if (!_fSentParseDone && _acClass[PROGSINK_CLASS_HTML] == 0)
                {
                    TraceTag((tagProgSink, "[%08lX]   Sending ParseDone", this));
                    _fSentParseDone = TRUE;
                    if (loadstatus < LOADSTATUS_PARSE_DONE)
                        loadstatus = LOADSTATUS_PARSE_DONE;
                }

                if (    !_fSentQuickDone && _fSentParseDone
                    &&  _acClass[PROGSINK_CLASS_CONTROL] == 0
                    &&  _acClass[PROGSINK_CLASS_FRAME] == 0)
                {
                    TraceTag((tagProgSink, "[%08lX]   Sending QuickDone", this));
                    _fSentQuickDone = TRUE;
                    if (loadstatus < LOADSTATUS_QUICK_DONE)
                        loadstatus = LOADSTATUS_QUICK_DONE;
                }

                if (!_fSentDone && _cActive == 0)
                {
                    TraceTag((tagProgSink, "[%08lX]   Sending Done", this));
                    _fSentDone = TRUE;
                    if (loadstatus < LOADSTATUS_DONE)
                        loadstatus = LOADSTATUS_DONE;
                }
            }
        }
        if (!_pProgSinkFwd)
        {
            if (!!_fSpin != !!_cSpin)
            {
                TraceTag((tagProgSink, "[%08lX]   Setting fSpin to %s", this,
                    _fSpin ? "FALSE" : "TRUE"));
                _fSpin = !_fSpin;
                fSendSpin = TRUE;
                fSpin     = _fSpin;
            }

            if (_fSendProgDone && _cActive == 0)
            {
                fSendProgDone  = TRUE;
                _fSendProgDone = FALSE;
            }
        }
    }

    if (    (_uChange & (PROGSINK_CHANGE_RESCAN | PROGSINK_CHANGE_CURRENT | PROGSINK_CHANGE_PROGRESS))
        ||  fSendProgDone)
    {
        Assert(!_pProgSinkFwd);

        _bStateCur = PROGSINK_STATE_IDLE;
        achText[0] = 0;

        if (fSendProgDone)
        {
            Assert(_cActive == 0);
            LoadString(GetResourceHInst(), IDS_DONE,
                achText, ARRAY_SIZE(achText));

            if (_fGotDefault)
            {
                MemFree(_pdDefault.pchText);
                _pdDefault.pchText = NULL;

                MemFree(_pdDefault.pchFormat);
                _pdDefault.pchFormat = NULL;

                _fGotDefault = FALSE;
            }

            dwFlagsProg  = PROGSINK_SET_POS|PROGSINK_SET_MAX|PROGSINK_SET_TEXT;
            dwPos        = (ULONG)(-1);
            dwMax        = 0;

            _dwSlotCur   = 0;
            _bBelowCur   = TRUE;
            _dwMaxTotal  = 0;
            _dwProgCur   = 0;
            _dwProgMax   = 0;
            _dwProgDelta = 0;
            _cOngoing    = 0;
            _cPotential  = 0;
            _cPotTotal   = PROGSINK_POTEN_MIN;
            _cPotDelta   = 0;
            _fShowItemsRemaining = FALSE;
        }
        else
        {
            // If necessary, rescan for the best progress slot to show.

            if (_uChange & PROGSINK_CHANGE_RESCAN)
            {
                PROGDATA * ppd = &_aryProg[0];
                UINT cSize = _aryProg.Size();

                _dwSlotCur = 0;
                _bBelowCur = TRUE;

                for (UINT iSlot = 1; iSlot <= cSize; ++iSlot, ++ppd)
                {
                    if (    (ppd->bFlags & PDF_FREE)
                        ||  (!ppd->pchText && !ppd->dwIds)
                        ||  ppd->bState <= PROGSINK_STATE_IDLE
                        ||  ppd->bBelow > _bBelowCur
                        ||  (   ppd->bBelow == _bBelowCur
                            &&  ppd->bState <= _bStateCur))
                        continue;

                    _dwSlotCur = iSlot;
                    _bStateCur = ppd->bState;
                    _bBelowCur = ppd->bBelow;

                    if (_bStateCur == PROGSINK_STATE_LOADING && !_bBelowCur)
                        break;
                }
            }

            if (_uChange & (PROGSINK_CHANGE_RESCAN|PROGSINK_CHANGE_CURRENT))
            {
                // The progress text needs to be recomputed.

                LPTSTR pchText = achText;
                UINT   cchText = PROGSINK_TEXT_LENGTH;
                LPTSTR pchFormat = NULL;
                PROGDATA * ppd = NULL;

                if (_dwSlotCur)
                {
                    Assert(_dwSlotCur <= (UINT)_aryProg.Size());
                    ppd = &_aryProg[_dwSlotCur - 1];
                    _bStateCur = ppd->bState;
                }
                else if (_fGotDefault)
                {
                    ppd = &_pdDefault;
                }

                if (ppd)
                {
                    pchFormat = ppd->pchFormat;

                    if (pchFormat == NULL)
                    {
                        FormatProgress(_pDoc, ppd);
                        pchFormat = ppd->pchFormat;
                    }

                    if (pchFormat && !*pchFormat)
                    {
                        pchFormat = NULL;
                    }
                }

                // Prepend "(n items remaining)" if desired.

                if (_cPotential == 0)
                {
                    UINT cActive = _cActive -
                            _acClass[PROGSINK_CLASS_NOREMAIN] -
                            _acClassBelow[PROGSINK_CLASS_NOREMAIN];

                    if (_fShowItemsRemaining || cActive > 1)
                    {
                        _fShowItemsRemaining = TRUE;

                        if (cActive > 0)
                        {
                            Format(0, achText, cchText,
                                MAKEINTRESOURCE(IDS_BINDSTATUS_DOWNLOADING),
                                cActive);

                            UINT cch = _tcslen(achText);
                            pchText += cch;
                            cchText -= cch;
                        }
                    }
                }

                // Now append either the selected slot or the default string.

                if (pchFormat && cchText > 1)
                {
                    _tcsncpy(pchText, pchFormat, cchText - 1);
                    achText[ARRAY_SIZE(achText) - 1] = 0;
                }

                if (achText[0])
                {
                    dwFlagsProg |= PROGSINK_SET_TEXT;
                }
            }

            if (_uChange & PROGSINK_CHANGE_PROGRESS)
            {
                dwPos = _dwProgCur;
                dwMax = PROGSINK_PROG_MAX;
                dwFlagsProg |= PROGSINK_SET_POS | PROGSINK_SET_MAX;
            }
        }

        #if DBG==1
        if (dwFlagsProg)
            TraceTag((tagProgSink,
                "[%08lX]   SetProgress %c%c%c [%ld/%ld] \"%ls\" %s",
                this, (dwFlagsProg & PROGSINK_SET_POS) ? 'P' : ' ',
                (dwFlagsProg & PROGSINK_SET_MAX) ? 'M' : ' ',
                (dwFlagsProg & PROGSINK_SET_TEXT) ? 'T' : ' ',
                dwPos, dwMax, achText, fSendProgDone ? "(flash)" : ""));
        #endif
    }

     _fSentSignal = FALSE;
    _uChange = 0;
     GWKillMethodCallEx(_pts, this, ONCALL_METHOD(CProgSink, OnMethodCall, onmethodcall), 0);

    if (_pMarkup &&
        !fCleanupOnly &&
        _pMarkup->HtmCtx() &&
        _pMarkup->HtmCtx()->IsNoProgressUI())
    {
        dwFlagsProg &= ~PROGSINK_SET_TEXT;
    }

    LeaveCriticalSection();

    Assert(_pDoc->GetRefs());
// NOTE (lmollico): we need a local copy of _pDoc because CDoc::OnLoadStatus can cause
// this (CProgSink) to be destroyed if the doc is unloaded
    pDoc = _pDoc;
    // TODO (sramani): The doc could be passivated and if someone holds on to the markup
    // we could get here, so need to safeguard against it.
    if (pDoc && pDoc->_pWindowPrimary && pDoc->PrimaryMarkup())
    {
        pDoc->AddRef();

        if (dwFlagsProg)
            pDoc->SetProgress(dwFlagsProg, achText, dwPos, dwMax, fSendProgDone);

        if ( fSendSpin )
        {
            pDoc->SetSpin(fSpin);
        }
        
        // _pMarkup may be NULLed out here from passivation during SetProgress.  This is fine
        if (loadstatus > LOADSTATUS_UNINITIALIZED && _pMarkup && !_pMarkup->_fHardStopDone && !fCleanupOnly)
            _pMarkup->OnLoadStatus(loadstatus);

        pDoc->Release();
    }

    // Matched to addref above
    Release();

    TraceTag((tagProgSink, "[%08lX] OnMethodCall (leave)", this));
}



//+---------------------------------------------------------------------------
//
//  Member:     CProgSink::AdjustProgress
//
//  Synopsis:   Adjust the current progress
//
//
//----------------------------------------------------------------------------

void CProgSink::AdjustProgress(DWORD dwClass, BOOL fFwd, BOOL fAdd)
{
    UINT    uiDelta = 0;
    UINT    cHtml   = _acClassBelow[PROGSINK_CLASS_HTML] +  _acClass[PROGSINK_CLASS_HTML];
    UINT    cFrame  = _acClassBelow[PROGSINK_CLASS_FRAME] +  _acClass[PROGSINK_CLASS_FRAME];

    switch(dwClass)
    {
    case    PROGSINK_CLASS_HTML:
        uiDelta = PROGSINK_POTEN_HTML;
        break;
    case    PROGSINK_CLASS_FRAME:
        uiDelta= PROGSINK_POTEN_FRAME;
        break;
    }

    if (!_cPotTotal)
    {
        _cPotTotal = PROGSINK_POTEN_MIN;
    }

    if (!cHtml && !cFrame)
    {
        if (!_cPotential)
        {
            return;
        }
        else if (!fAdd)
        {
            _cPotential     = 0;
            _dwProgMax      = PROGSINK_PROG_MAX;
            return;
        }
    }

    if (uiDelta)
    {
        uiDelta -= (!!fFwd) * PROGSINK_POTEN_BELOW;
        if (fAdd)
        {
            _cPotential += uiDelta;
            _cPotTotal  += uiDelta;
        }
        else
        {
            _cPotential += _cPotDelta;
            if (_cPotential <= uiDelta)
            {
                _cPotential = 1;            // set to 0 later
            }
            else
            {
                _cPotential -= uiDelta;
            }
            _cPotDelta = 0;
        }
    }

    Assert((cHtml + cFrame) || !_cPotential);
    TraceTag((tagProgSink,
        "[%08lX] AdjustProgress: a/f/h/p/pt/pd [%2d-(%2d, %2d) - %6d %6d %6d]",
                    this, _cActive, cFrame,
                    cHtml, _cPotential, _cPotTotal, _cPotDelta));
}

//+---------------------------------------------------------------------------
//
//  Member:     CProgSink::UpdateProgress
//
//  Synopsis:   Recalculate the current progress status
//
//  TODO:     need to add Databinding/OLE Controls
//----------------------------------------------------------------------------

BOOL
CProgSink::UpdateProgress(PROGDATA *ppd, DWORD dwFlags, DWORD dwPos, DWORD dwMax)
{
    DWORD       dwMaxOld    = ppd->dwMax;
    DWORD       dwPosOld    = ppd->dwPos;
    DWORD       dwProgDlt   = 0;            // progress delta
    BOOL        fSignal     = FALSE;

    TraceTag((tagProgSink,
            "[%08lX] UpdateProgress BEGIN [%08lX: <class=%2d,state=%2d,below=%2d,flags=%2d,pos=%2d,max=%2d> dwpos=%2d dwmax=%2d, setmax=%d, setpos=%d]",
            this, ppd, ppd->bClass, ppd->bState, ppd->bBelow, ppd->bFlags, ppd->dwPos, ppd->dwMax, dwPos, dwMax, dwFlags & PROGSINK_SET_MAX, dwFlags & PROGSINK_SET_POS));

    Assert (_dwProgMax <= PROGSINK_PROG_MAX);

    // TODO (mikhaill) - fixing bug 106536:
    // Code fragments that handle _dwMaxTotal and _cOngoing seem were
    // inconsistent with one another and contradicted comments
    // in header file. While making changes I used following definitions,
    // which I hope match author[s] ideas and require minimal amount
    // of correction.

    // CProgSink serves a number of clients caled "downloads".
    // Each download come into scope by calling AddProgress()
    // and run out of scope by DelProgress().
    // Downloads in scope are called "active downloads".
    // _cActive contains the number of active downloads.
    // Each active download is supplied with slot represented by
    // the struct PROGDATA that is allocated on AddProgress().
    // The PROGDATA values dwPos and dwMax reflect client progress state.
    // Initially dwPos and dwMax both contain zeros.
    // Their values can be changed only by SetProgress() call.
    // The download is considered "ongoing" if 0 < dwPos < dwMax
    // (i.e. download already started but not yet finished).
    // _cOngoing contains the number of ongoing downloads.
    // _dwMaxTotal contains the sum of (dwMax - dwPos) for all ongoing downloads.

    // Cleanup required!!

    if (ppd->dwPos && ppd->dwPos < ppd->dwMax)   // is ongoing?
    {
        // temporary remove this slot's affect from _dwMaxTotal & _cOngoing
        _dwMaxTotal -= ppd->dwMax - ppd->dwPos;
        _cOngoing--;
    }

    if (dwFlags & PROGSINK_SET_MAX)
    {
        ppd->dwMax = dwMax;
        if ( ppd->dwMax < dwMaxOld)
        {
            if (ppd->dwPos && ppd->dwPos < ppd->dwMax)   // is ongoing now?
            {
                // update this slot's affect to _dwMaxTotal & _cOngoing
                _dwMaxTotal += ppd->dwMax - ppd->dwPos;
                _cOngoing++;
            }
            goto Cleanup;
        }
    }

    if (dwFlags & PROGSINK_SET_POS)
    {
        ppd->dwPos = dwPos;
        if (dwPos < dwPosOld)
        {
            if (ppd->dwPos && ppd->dwPos < ppd->dwMax)   // is ongoing now?
            {
                // update this slot's affect to _dwMaxTotal & _cOngoing
                _dwMaxTotal += ppd->dwMax - ppd->dwPos;
                _cOngoing++;
            }
            goto Cleanup;
        }

        // adjust bogus data
        if (dwPos > ppd->dwMax)
        {
            ppd->dwMax = dwPos;
        }

        if (dwPos == 0 && _dwProgMax == 0)
        {
            _dwProgMax = PROGSINK_PROG_INIT;
            _dwProgCur = PROGSINK_PROG_MIN;
        }
        else if (_cPotential && (ppd->dwPos > dwPosOld) &&
                    (ppd->bClass == PROGSINK_CLASS_HTML ||
                    ppd->bClass == PROGSINK_POTEN_FRAME))
        {
            UINT    uiPotCur    = 0;              // Current potential pos
            UINT    uiDelta     = 0;

            switch (ppd->bClass)
            {
            case PROGSINK_CLASS_HTML:
                uiDelta = PROGSINK_POTEN_HTML;
                break;
            case PROGSINK_CLASS_FRAME:
                uiDelta = PROGSINK_POTEN_FRAME;
                break;
            }

            Assert(uiDelta);

            uiDelta = uiDelta  + (ppd->bBelow ? -PROGSINK_POTEN_BELOW : 0);
            Assert(ppd->dwMax);
            uiDelta = MulDivQuick(ppd->dwPos - dwPosOld,
                                    uiDelta, ppd->dwMax);

            if (_cPotential <= uiDelta)
            {
                // we consumed all the potential
                // but we will set _cPotential to 0 only later
                _cPotential     = PROGSINK_POTEN_END;
            }
            else
            {
                _cPotential -= uiDelta;

                _cPotDelta += uiDelta;

                Assert(_cPotTotal && _cPotTotal >= _cPotential);
                uiPotCur = MulDivQuick(_cPotTotal - _cPotential,
                                        PROGSINK_ADJUST_SCALE, _cPotTotal);

                if (uiPotCur < PROGSINK_POTEN_MIN)
                    uiPotCur = PROGSINK_POTEN_MIN;

                _dwProgMax = MulDivQuick(uiPotCur, PROGSINK_PROG_MAX,
                                            PROGSINK_ADJUST_SCALE);
                Assert(_dwProgMax <= PROGSINK_PROG_MAX);
            }
        }
    }

    if (ppd->dwPos && ppd->dwPos < ppd->dwMax)   // is ongoing now?
    {
        // update this slot's affect to _dwMaxTotal & _cOngoing
        _dwMaxTotal += ppd->dwMax - ppd->dwPos;
        _cOngoing++;
    }
    else
        goto Cleanup;

    Assert(_dwMaxTotal && _cOngoing);

    if (dwMaxOld && ppd->dwMax > dwMaxOld || ppd->dwPos <= dwPosOld) // we receive contradictory info
    {
        goto Cleanup;
    }

    if (_dwProgMax < _dwProgCur)
    {
        _dwProgCur = _dwProgMax;
        _dwProgDelta = 0;
        goto Cleanup;
    }

    // calculate the weight of this new progress against the current total
    // get relative delta
    // Assert(_cOngoing && _cActive >= _cOngoing);

    // We adjust the divider so that we allocate 100% more space for the
    // the last 50% of active downloads
    dwProgDlt = MulDivQuick(ppd->dwPos - dwPosOld,
                            _cOngoing * (_dwProgMax - _dwProgCur),
                            _dwMaxTotal * (_cActive + (_cActive >> 1)));

    // get absolute delta and add it to the last remaining delta
    _dwProgDelta += dwProgDlt;

    if (_dwProgDelta > (_dwProgMax - _dwProgCur))
    {
        _dwProgDelta = _dwProgMax - _dwProgCur;
    }

    if (_cPotential == PROGSINK_POTEN_END)
    {
         _dwProgMax      = PROGSINK_PROG_MAX;
    }

Cleanup:

    if (_dwProgDelta >= PROGSINK_PROG_STEP)
    {
        _dwProgCur += _dwProgDelta;
        _dwProgCur  = (_dwProgCur > _dwProgMax)? _dwProgMax : _dwProgCur;
        _dwProgDelta = 0;
        fSignal = TRUE;
    }

#if  DBG==1
    TraceTag((tagProgSink,
            "[%08lX] UpdateProgress [%2d/%2d/%2d - max = %-6d delta = %-3d - a/o %2d/%2d]",
            this, _dwProgCur, _dwProgMax, PROGSINK_PROG_MAX, _dwMaxTotal,
            _dwProgDelta, _cActive,_cOngoing));
#endif

    return fSignal;
}

//+---------------------------------------------------------------------------
//
//  Member:     CProgSink::GetClassCounter
//
//  Synopsis:   Returns quantity of class we are waiting for.
//
//----------------------------------------------------------------------------

UINT
CProgSink::GetClassCounter(DWORD dwClass, BOOL fBelow)
{
    UINT cQuantity;

    // IMPORTANT: We are not using a critical section here because we check
    // up often on this, and faulty readings will not make a difference
    // because they will be corrected in time.

    if (dwClass == (DWORD) -1)
        return _cActive;

    Assert(PROGSINK_CLASS_HTML == 0);
    Assert(dwClass <= PROGSINK_CLASS_FRAME);

    cQuantity = (fBelow ? (_acClassBelow[dwClass]) : (_acClass[dwClass]));

    return cQuantity;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\recalchost.cxx ===
// ---------------------------------------------------------
//
// Microsoft Trident
// Copyright Microsoft corporation 1998
//
// File: recalchost.cxx
//
// Recalc engine hosting code
//
// ---------------------------------------------------------

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_DOCGLBS_HXX_
#define X_DOCGLBS_HXX_
#include "docglbs.hxx"
#endif

#ifndef X_ELEMENT_HXX_
#define X_ELEMENT_HXX_
#include "element.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_MSHTMDID_H_
#define X_MSHTMDID_H_
#include "mshtmdid.h"
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_SITECNST_HXX_
#define X_SITECNST_HXX_
#include "sitecnst.hxx"
#endif

#ifndef X_CSITE_HXX_
#define X_CSITE_HXX_
#include "csite.hxx"
#endif

#ifndef X_STYLE_HXX_
#define X_STYLE_HXX_
#include "style.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include <treepos.hxx>
#endif

#ifndef X_ATOM_HXX
#define X_ATOM_HXX
#include "atomtbl.hxx"
#endif

#ifndef X_SHOLDER_HXX_
#define X_SHOLDER_HXX_
#include "sholder.hxx"
#endif

#ifndef X_RECALC_HXX_
#define X_RECALC_HXX_
#include "recalc.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_SCRIPT_HXX_
#define X_SCRIPT_HXX_
#include "script.hxx"
#endif

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx"
#endif

#ifndef X_CBUFSTR_HXX_
#define X_CBUFSTR_HXX_
#include "cbufstr.hxx"
#endif

ExternTag(tagRecalcInfo);
ExternTag(tagRecalcDetail);
ExternTag(tagRecalcStyle);

DeclareTag(tagRecalcSync, "Recalc Sync", "Do recalc synchronously")
DeclareTag(tagRecalcHost, "Recalc Host", "Trace recalc host support")
DeclareTag(tagRecalcInfo, "Recalc", "Trace recalc behaviour")
DeclareTag(tagRecalcGetInfo, "Recalc", "Enable GetObjectInfo to get object id and prop name")
DeclareTag(tagRecalcDetail, "Recalc detail", "Detailed recalc trace")
DeclareTag(tagRecalcDisable, "Recalc", "Disable all recalc")
DeclareTag(tagRecalcDisableCSS, "Recalc", "Disable CSS expressions");
DeclareTag(tagRecalcDumpBefore, "Recalc", "Dump before every recalc");
DeclareTag(tagRecalcDumpAfter, "Recalc", "Dump after every recalc")
//------------------------------------
//
// CDoc::CRecalcHost::QueryInterface
//
// Description: IUnknown::QueryInterface
//
//------------------------------------

STDMETHODIMP
CDoc::CRecalcHost::QueryInterface(REFIID iid, LPVOID *ppv)
{
    if (ppv == 0)
        RRETURN(E_INVALIDARG);
    *ppv = 0;
    
    switch (iid.Data1)
    {
        QI_INHERITS((IRecalcHost *)this, IUnknown)
        QI_INHERITS(this, IRecalcHost)
        QI_INHERITS(this, IServiceProvider)
#if DBG == 1
        QI_INHERITS(this, IRecalcHostDebug)
#endif
    }

    if (*ppv == NULL)
        RRETURN(E_NOINTERFACE);

    (*(IUnknown **)ppv)->AddRef();
    return S_OK;
}

//------------------------------------
//
// CDoc::CRecalcHost::AddRef
//
// Description: IUnknown::AddRef
//
//------------------------------------

STDMETHODIMP_(ULONG)
CDoc::CRecalcHost::AddRef()
{
    return MyDoc()->SubAddRef();
}

//------------------------------------
//
// CDoc::CRecalcHost::Release
//
// Description: IUnknown::Release
//
//------------------------------------

STDMETHODIMP_(ULONG)
CDoc::CRecalcHost::Release()
{
    return MyDoc()->SubRelease();
}

//------------------------------------
//
// CDoc::CRecalcHost::QueryService
//
// Description: IServiceProvider::QueryService
//
//------------------------------------

STDMETHODIMP
CDoc::CRecalcHost::QueryService(REFGUID guidService, REFIID riid, LPVOID *ppv)
{
    RRETURN(MyDoc()->QueryService(guidService, riid, ppv));
}

//------------------------------------
//
// CDoc::CRecalcHost::Init
//
// Description: Actually creates the recalc engine
//
//------------------------------------

HRESULT
CDoc::CRecalcHost::Init()
{
    if (_pEngine)
        return S_OK;

    HRESULT hr;
    IRecalcEngine *pEngine = 0;
    IObjectWithSite *pObject = 0;

    hr = THR(CoCreateInstance(CLSID_CRecalcEngine, NULL, CLSCTX_INPROC_SERVER, IID_IRecalcEngine, (LPVOID *)&pEngine));
    if (hr)
        goto Cleanup;

    hr = THR(pEngine->QueryInterface(IID_IObjectWithSite, (LPVOID *)&pObject));
    if (hr)
        goto Cleanup;

    hr = THR(pObject->SetSite((IRecalcHost *)this));
    if (hr)
        goto Cleanup;

    _pEngine = pEngine;
    _pEngine->AddRef();

Cleanup:
    TraceTag((tagRecalcHost, "Creating recalc engine %08x", pEngine));
    ReleaseInterface(pObject);
    ReleaseInterface(pEngine);

    RRETURN(hr);
}

//------------------------------------
//
// CDoc::CRecalcHost::Detach
//
// Description: Cleanup, release the recalc engine
//
//------------------------------------

void
CDoc::CRecalcHost::Detach()
{
    if (_pEngine)
    {
        IObjectWithSite *pObject;

        if (SUCCEEDED(THR(_pEngine->QueryInterface(IID_IObjectWithSite, (LPVOID *)&pObject))))
        {
            pObject->SetSite(NULL);
            pObject->Release();
        }
        ClearInterface(&_pEngine);
    }
}

HRESULT
CDoc::CRecalcHost::SuspendRecalc(VARIANT_BOOL fSuspend)
{
    if (fSuspend)
    {
        _ulSuspend++;
        Assert(_ulSuspend != 0);
    }
    else if (_ulSuspend > 0)
    {
        _ulSuspend--;
        if (_ulSuspend == 0 && _fRecalcRequested)
        {
            MyDoc()->GetView()->RequestRecalc();
        }
    }
    else
        RRETURN(E_UNEXPECTED);

    return S_OK;
}

//------------------------------------
//
// CDoc::CRecalcHost::setExpression
//
// Description: A helper function for CElement and CStyle
//
//------------------------------------
HRESULT
CDoc::CRecalcHost::setExpression(CBase *pBase, BSTR strPropertyName, BSTR strExpression, BSTR strLanguage)
{
    WHEN_DBG(if (IsTagEnabled(tagRecalcDisable)) return S_OK; )

    HRESULT hr;
    DISPID dispid = 0;

    TraceTag((tagRecalcInfo, "setExpression(%08x, \"%ls\", \"%ls\", \"%ls\")", pBase, strPropertyName, strExpression, strLanguage));

    // Don't do this while we're in recalc!
    if (_fInRecalc)
        RRETURN(E_UNEXPECTED);

    if (!strPropertyName || !strExpression)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // If there are any pending tasks, do them now so that all
    // expressions are either applied or cleared before we actually
    // try to do any work.
    MyDoc()->ExecuteExpressionTasks();

    hr = THR(pBase->GetDispID(strPropertyName, fdexNameCaseSensitive | fdexNameEnsure, &dispid));
    if (hr)
        goto Cleanup;

    hr = THR(Init());
    if (hr)
        goto Cleanup;

    if (!strLanguage || (*strLanguage == 0))        // For consistency, the default is always javascript
    {
        strLanguage = _T("javascript");
    }

    hr = THR(_pEngine->SetExpression((IUnknown *)(IPrivateUnknown *)pBase, dispid, strExpression, strLanguage));
Cleanup:
    RRETURN(hr);
}

//---------------------------------------------------------
//
// Member:      CDoc::CRecalcHost::removeAllExpressions
//
// Description: Called when an element goes out of view
//
//---------------------------------------------------------

HRESULT
CDoc::CRecalcHost::removeAllExpressions(CElement *pElement)
{
    HRESULT              hr = S_OK;
    CRecalcObject * pObject = NULL;
    CRecalcEngine * pEngine = NULL;
    CStyle        * pStyle  = NULL;

    if ( ! _pEngine || _fInRecalc) // if engine is already gone or in recalc - just bail.
        goto Cleanup;

    // Get the CRecalcEngine from IRecalcEngine

    pEngine = DYNCAST( CRecalcEngine, _pEngine ); Assert(pEngine);

    // Get the CRecalcObject corresponding to this element (CElement or CStyle)

    hr = THR(pEngine->FindObject((IUnknown *)(IPrivateUnknown *)pElement, FALSE, &pObject));

    if (!hr)
    {
        Assert(pObject);

        // Remove the object from the recalc engine - By passing the "TRUE" 
        // argument we clean up the dependency graph for all its properties

        pEngine->RemoveObject(pObject, TRUE);
    }

    // Do the same thing for any expressions on CStyle

    hr = THR(pElement->GetStyleObject(&pStyle));
    
    if (!hr)
    {
        Assert(pStyle);
        hr = THR(pEngine->FindObject((IUnknown *)(IPrivateUnknown *)pStyle, FALSE, &pObject));

        if (!hr)
        {
            Assert(pObject);

            // Remove the object from the recalc engine 
            pEngine->RemoveObject(pObject, TRUE);
        }
    }

Cleanup:    
    hr = S_OK;
    RRETURN( hr );
}


//---------------------------------------------------------
//
// Member:      CDoc::CRecalcHost::setStyleExpression
//
// Description: Called by the stylesheet 
//
//---------------------------------------------------------
HRESULT
CDoc::CRecalcHost::setStyleExpressions(CElement *pElement)
{
    WHEN_DBG(if (IsTagEnabled(tagRecalcDisableCSS)) return S_OK; )

    HRESULT hr = S_OK;
    CStyle *pStyle;


    int iExpandos = pElement->GetFirstBranch()->GetFancyFormat()->_iExpandos;

    // It is possible for the element cache to have been cleared before
    // we get a chance to run.  In this case iExpandos will be negative.
    // Some later pass through ComputeFormats will once again determine
    // the appropriate set of expressions for this element.
    // REVIEW (michaelw) Is it possible that we will never be called
    // again because try to be so lazy?  If so will expressions that are
    // currently applied to the object not be removed when they should?

    if (iExpandos < 0)
        goto Cleanup;

    // No expressions in print media.
    // REVIEW: May not need to bother blocking here
    if ( pElement->IsPrintMedia() )
        goto Cleanup;

    // If we are in the middle of setting a value then we don't want to do anything
    if (_pElemSetValue)
        goto Cleanup;

    hr = Init();
    if (hr)
        goto Cleanup;

    hr = THR(pElement->GetStyleObject(&pStyle));
    if (hr)
        goto Cleanup;

    if (SUCCEEDED(_pEngine->BeginStyle((IUnknown *)pStyle)))
    {
        CAttrArray *pAA = GetExpandosAttrArrayFromCacheEx(iExpandos);
        CAttrValue *pAV = (CAttrValue *)*pAA;

        Assert(pAA);

        for ( int i = 0 ; i < pAA->Size() ; i++, pAV++ )
        {
            if (pAV->AAType() == CAttrValue::AA_Expression)
            {
                TraceTag((tagRecalcStyle, "\tsetting expression: this: %08x dispid: %08x expression:%ls", this, pAV->GetDISPID(), pAV->GetLPWSTR()));
                IGNORE_HR(_pEngine->SetExpression((IUnknown *)(IPrivateUnknown *)pStyle, pAV->GetDISPID(), pAV->GetLPWSTR(), _T("javascript")));
            }
        }
        IGNORE_HR(_pEngine->EndStyle((IUnknown *)(IPrivateUnknown *)pStyle));
    }

Cleanup:
    RRETURN(hr);
}


//---------------------------------------------------------------
//
//  Member:     CDoc::CRecalcHost::getExpression
//
// REVIEW michaelw : need to add a language parameter to allow
//                   the caller to get the expression language
//
//---------------------------------------------------------------
HRESULT
CDoc::CRecalcHost::getExpression(CBase *pBase, BSTR strPropertyName, VARIANT *pvExpression)
{
    HRESULT hr;
    BSTR strLanguage = 0;
    BSTR strExpression = 0;
    DISPID dispid = 0;

    TraceTag((tagRecalcInfo, "getExpression(%08x, \"%ls\")", pBase, strPropertyName));

    if (!strPropertyName || (*strPropertyName == 0) || (pvExpression == 0))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // If there are any pending tasks, do them now so that all
    // expressions are either applied or cleared before we actually
    // try to do any work.
    MyDoc()->ExecuteExpressionTasks();

    hr = THR(pBase->GetDispID(strPropertyName, fdexNameCaseSensitive, &dispid));
    if (hr == DISP_E_UNKNOWNNAME)
    {
        hr = S_FALSE;
        goto Cleanup;
    }
    else if (hr)
        goto Cleanup;

    if (!_pEngine)
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    hr = THR(_pEngine->GetExpression((IUnknown *)(IPrivateUnknown *)pBase, dispid, &strExpression, &strLanguage));
    if (!hr)
    {
        V_VT(pvExpression) = VT_BSTR;
        V_BSTR(pvExpression) = strExpression;
    }

Cleanup:
    if (hr == S_FALSE)
    {
        V_VT(pvExpression) = VT_EMPTY;
        hr = S_OK;
    }

    SysFreeString(strLanguage);
    RRETURN(hr);
}

//---------------------------------------------------------------
//
//  Member:     CDoc::CRecalcHost::removeExpression
//
//---------------------------------------------------------------
HRESULT
CDoc::CRecalcHost::removeExpression(CBase *pBase, BSTR strPropertyName, VARIANT_BOOL *pfSuccess)
{
    HRESULT hr = S_OK;
    DISPID dispid = 0;

    if (pfSuccess)
        *pfSuccess = VB_FALSE;

    TraceTag((tagRecalcInfo, "removeExpression(%08x, \"%ls\")", pBase, strPropertyName));

    // Don't do this while we're in recalc
    if (_fInRecalc)
        RRETURN(E_UNEXPECTED);

    if (!strPropertyName || (*strPropertyName == 0))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // If there are any pending tasks, do them now so that all
    // expressions are either applied or cleared before we actually
    // try to do any work.
    MyDoc()->ExecuteExpressionTasks();

    // Get the dispid for strPropertyName.  
    hr = THR(pBase->GetDispID(strPropertyName, fdexNameCaseSensitive, &dispid));
    if (hr == DISP_E_UNKNOWNNAME)
    {
        hr = S_OK;
        goto Cleanup;
    }
    else if (hr)
        goto Cleanup;

    if (!_pEngine)
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    hr = THR(_pEngine->ClearExpression((IUnknown *)(IPrivateUnknown *)pBase, dispid));
    if (hr)
        goto Cleanup;

    if (pfSuccess)
        *pfSuccess = VB_TRUE;

Cleanup:
    if (hr == S_FALSE)
        hr = S_OK;

    RRETURN(hr);
}

//------------------------------------
//
// CDoc::CRecalcHost::EngineRecalcAll
//
// Description: A little wrapper to RecalcAll on the engine.
//              Does not create the engine if it doesn't exist
//
//------------------------------------

HRESULT
CDoc::CRecalcHost::EngineRecalcAll(BOOL fForce)
{
    HRESULT hr = S_OK;

#if DBG==1
    if (IsTagEnabled(tagRecalcDumpBefore))
        Dump(0);
#endif

    // If someone explicitly calls document.recalc while we are actually
    // doing the recalc, we fail.
    if (_fInRecalc)
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    // TODO (sramani): Need context markup here?
    if (MyDoc()->_fEngineSuspended)
    {
        hr = S_OK;
        goto Cleanup;
    }

    if (_ulSuspend == 0)
    {
        // Do any pending work for style expressions to be applied.
        MyDoc()->ExecuteExpressionTasks();

        if (_pEngine)
        {
            BOOL fRunScript;
            hr = THR(MyDoc()->PrimaryMarkup()->ProcessURLAction(URLACTION_SCRIPT_RUN, &fRunScript));
            if (hr || !fRunScript)
                goto Cleanup;

            // We clear the flag before calling RecalcAll
            // so that we don't ignore requests generated
            // while we're in recalc.
            _fRecalcRequested = FALSE;
 
            _fInRecalc = TRUE;
            if (SUCCEEDED(hr))
                hr = THR(_pEngine->RecalcAll(fForce));
            _fInRecalc = FALSE;
        }
    }
    else
        hr = S_OK;

Cleanup:
#if DBG==1
    if (IsTagEnabled(tagRecalcDumpBefore))
        Dump(0);
#endif

    RRETURN(hr);
}

//---------------------------------------------------------------
//
// Function:    CRecalcHost::RequestRecalc
//
// Description: The recalc engine has requested a recalc.  We choose
//              to do this async.
//
//---------------------------------------------------------------
STDMETHODIMP
CDoc::CRecalcHost::RequestRecalc()
{
    Assert(_pEngine);
#if DBG == 1
    if (IsTagEnabled(tagRecalcSync))
    {
        EngineRecalcAll(FALSE);
        return S_OK;
    }
#endif

    if (!_fRecalcRequested)
    {
        //
        // If we are suspended then the request to the view will be issued when we unsuspend
        //
        if (!_ulSuspend)
            MyDoc()->GetView()->RequestRecalc();
        _fRecalcRequested = TRUE;
    }

    return _fRecalcRequested ? S_OK : E_FAIL;
}
//------------------------------------
//
// CDoc::CRecalcHost::CompileExpression
//
// Description: IRecaclHost::ParseExpressionText
//
//------------------------------------

STDMETHODIMP
CDoc::CRecalcHost::CompileExpression(IUnknown *pUnk, DISPID dispid, BSTR strExpression, BSTR strLanguage, IDispatch **ppExpressionObject, IDispatch **ppThis)
{
    TraceTag((tagRecalcHost, "CompileExpression %ls %ls", strExpression, strLanguage));
    HRESULT     hr;
    CStr        sExpression;
    CElement    * pElement = NULL;

    // TODO this should be done by the script engine (beta 2)
    if (strLanguage[0] == _T('J') || strLanguage[0] == _T('j'))
    {
        sExpression.Append(_T("return ("));
        sExpression.Append(strExpression);
        sExpression.Append(_T(")"));
    }
    else
        RRETURN(E_INVALIDARG);

    TraceTag((tagRecalcHost, "CompileExpression generated: %ls", sExpression));

    //
	// pUnk can only be CElement or CStyle
	// Even if an expression is applied to the style of an element,
	// we need to make sure that the "this" pointer of the expression 
	// code is the element and not element.style.
	//

    pElement = GetElementFromUnk(pUnk);
    hr = pElement->PrivateQueryInterface(IID_IDispatch, (LPVOID *)ppThis);

    if (!hr)
    {
        CScriptCollection *pScriptCollection = pElement->GetNearestMarkupForScriptCollection()->GetScriptCollection();

        if (pScriptCollection)
        {
            BOOL fSafe = FALSE;
            hr = THR(pElement->GetNearestMarkupForScriptCollection()->ProcessURLAction(URLACTION_SCRIPT_RUN ,&fSafe));
            if(!hr && fSafe) 
            {
                hr = THR(pScriptCollection->ConstructCode(
                    NULL,                           // pchScope
                    sExpression,                    // pchCode
                    NULL,                           // pchFormalParams
                    strLanguage,                    // pchLanguage
                    NULL,                           // pMarkup
                    NULL,                           // pchType
                    0,                              // ulOffset
                    0,                              // ulStartingLine
                    NULL,                           // pSourceObject
                    SCRIPTPROC_HOSTMANAGESSOURCE,   // dwFlags
                    ppExpressionObject,             // ppDispCode result
                    TRUE));                         // fSingleLine
            }
            else
            {
                hr = E_ACCESSDENIED;
            }
        }
        else
            hr = E_UNEXPECTED;
    }

    RRETURN(hr);
}

CElement *CDoc::CRecalcHost::GetElementFromUnk(IUnknown *pUnk)
{
    HRESULT hr;
    CStyle *pStyle;
    CElement *pElement = NULL;

    // pUnk can only be CElement or CStyle
    hr = THR(pUnk->QueryInterface(CLSID_CStyle, (LPVOID *)&pStyle));
    if (hr)
    {
        IGNORE_HR(pUnk->QueryInterface(CLSID_CElement, (LPVOID *)&pElement)); 
    }
    else
    {
        pElement = pStyle->GetElementPtr();
    }

    Assert(pElement);      

    return pElement;
}

//------------------------------------
//
// CDoc::CRecalcHost::EvalExpression
//
// Description: IRecalcHost::EvalExpression
//
// Apparently has no support for DISPID_THIS
//
STDMETHODIMP
CDoc::CRecalcHost::EvalExpression(IUnknown *pUnk, DISPID dispid, BSTR strExpression, BSTR strLanguage, VARIANT *pvResult)
{
    HRESULT hr;
    CScriptCollection * pScriptCollection;
    CElement *pElement;
    TCHAR *pchNamespace = NULL;

    if (!pvResult)
        RRETURN(E_INVALIDARG);

    TraceTag((tagRecalcHost, "Evaluating expression %ls", strExpression));

    VariantInit(pvResult);

    pElement = GetElementFromUnk(pUnk);
    pScriptCollection = pElement->GetNearestMarkupForScriptCollection()->GetScriptCollection();

    if (pScriptCollection)
    {
        CExcepInfo excepinfo;
        BOOL fSafe = FALSE;
        CMarkup *pMarkup = pElement->GetMarkup();
  
        if (pMarkup && !pMarkup->HasWindowPending())
        {
            CMarkupScriptContext *pScriptContext;
            hr = THR(pMarkup->EnsureScriptContext(&pScriptContext));
            if (!hr)
                pchNamespace = pScriptContext->_cstrNamespace;
        }

        hr = THR(pMarkup->ProcessURLAction(URLACTION_SCRIPT_RUN, &fSafe));
        if(!hr && fSafe) 
        {
            hr = THR(pScriptCollection->ParseScriptText(
                strLanguage,                    // pchLanguage
                NULL,                           // pMarkup
                NULL,                           // pchType
                strExpression,                  // pchCode
                pchNamespace,                   // pchItemName
                _T("\""),                       // pchDelimiter
                0,                              // ulOffset
                0,                              // ulStartingLine
                NULL,                           // pSourceObject
                SCRIPTTEXT_ISEXPRESSION,        // dwFlags
                pvResult,                       // pvarResult
                &excepinfo));                   // pExcepInfo
        }
        else
        {
            hr = E_ACCESSDENIED;
        }
    }
    else
        hr = E_FAIL;
  
    RRETURN(hr);
}
	
//------------------------------------
//
// CDoc::CRecalcHost::resolveName
//
// Description: An internal helper to resolve a single name
//
// This function walks the object.sub-object.sub-object.property string
//
// It doesn't handle arrays or anything other than strings
// This is by design.  Names involing arrays are very ambiguous
//
//------------------------------------

HRESULT
CDoc::CRecalcHost::resolveName(IDispatch *pDispatchThis, DISPID dispidThis,
                               LPOLESTR szName, IDispatch **ppDispatch, DISPID *pDispid)
{
    IDispatch *pDispatch = 0;
    CVariant v;
    HRESULT hr = S_OK;
    LPTSTR pchTemp;

    TraceTag((tagRecalcHost, "resolveName: %ls", szName));

    //
    // parsing a name of the form object.sub-object.sub-object.sub-object.property
    // need to know about scope so that "this" works properly.
    //
    // we tolerate nothing but name.name.name.name
    // no spaces, no nulls, no array references
    //

    CStr sTemp;
    
    hr = sTemp.Set(szName);
    if (hr)
        goto Cleanup;

    pchTemp = sTemp;

    // Check for "this."
    if (_tcsncmp(pchTemp, sTemp.Length(), _T("this."), 5) == 0)
    {
        //
        // Our initial scope is this
        //
        pDispatch = pDispatchThis;
        pDispatch->AddRef();

        pchTemp += 5;          // skip past "this."
    }
    else
    {
        //
        // The default initial scope is the "window" object or in the case of
        // htc's it is the default dispatch object
        //
        // REVIEW michaelw: this should also look for form objects
        //
        CBase *pDefaultInitialScope;
        CElement *pElement = GetElementFromUnk(pDispatchThis);
        CMarkup *pMarkup = pElement->GetMarkup();

        if (pMarkup && pMarkup->IsHtcMarkup())
        {
            pDefaultInitialScope = pMarkup->GetDefaultDocument();
        }
        else
        {
            pDefaultInitialScope = pElement->GetWindowedMarkupContext()->Window();
        }

        if (!pDefaultInitialScope)
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }

        hr = THR(pDefaultInitialScope->PrivateQueryInterface(IID_IDispatchEx, (void **)&pDispatch));
        if (hr)
            goto Cleanup;
    }

    //
    // Now work our way through the names until we reach the end or something
    // doesn't map to sub-object
    //
    // REVIEW michaelw: is there any benefit (apart from complexity and case sensitivity)
    // REVIEW michaelw: to using IDispatchEx::GetDispID ?
    //

    while (*pchTemp)
    {
        LPTSTR pchEnd = pchTemp;

        // Skip over token characters
        while ((*pchEnd) && (*pchEnd != _T('.')))
            pchEnd++;

        if (pchEnd == pchTemp)
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }

        BSTR strName = SysAllocStringLen(pchTemp, pchEnd - pchTemp);
        if (!strName)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        // The token was terminated by a delimiter or the end of the string
        // in the case of a delimiter we need to skip past it.
        if (*pchEnd)
        {
            Assert(*pchEnd == _T('.'));
            pchTemp = pchEnd + 1;
            Assert(*pchTemp != _T('.'));
        }
        else
            pchTemp = pchEnd;

        hr = THR(GetNamedProp(pDispatch, strName, g_lcidUserDefault, &v, pDispid, NULL, FALSE, TRUE));

#if DBG == 1
        if (hr)
            TraceTag((tagRecalcHost, "resolveName: GetNamedProp(%ls) failed", strName));
#endif

        SysFreeString(strName);

        if (hr)
            goto Cleanup;

        if (*pchEnd == 0)
        {
            break;
        }
        else if (V_VT(&v) != VT_DISPATCH)
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }
        else if (V_DISPATCH(&v) == 0)
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }

        // We still have tokens and we still have a valid IDispatch, next token please!
        ReplaceInterface(&pDispatch, V_DISPATCH(&v));
        v.Clear();
    }

    Assert(*pchTemp == 0);

    //
    // CONSIDER (michaelw)
    // This is where we could try to detec if the object we've found is a 
    // builtin function or user-defined function.  In the case of a user-defined
    // function we would look for a ._recalcIgnore property that would allow us
    // to ignore this property for recalc purposes
    //

Cleanup:
    if (!hr)
    {
        TraceTag((tagRecalcHost, "resolveName %ls => %08x dispid: %08x", szName, pDispatch, *pDispid));
        *ppDispatch = pDispatch;
    }
    else
    {
        TraceTag((tagRecalcHost, "resolveName %ls failed", szName));
        *ppDispatch = 0;
        if (pDispatch)
            ReleaseInterface(pDispatch);
    }
    RRETURN(hr);
}


//------------------------------------
//
// CDoc::CRecalcHost::ResolveNames
//
// Description: IRecalcHost::ResolveNames
//
//------------------------------------

STDMETHODIMP
CDoc::CRecalcHost::ResolveNames(IUnknown *pUnk, DISPID dispid, unsigned cNames, BSTR *pstrNames, IDispatch **ppObjects, DISPID *pDispids)
{
    HRESULT hr;
    IDispatch *pDispatch = 0;
    unsigned i;

    if (pUnk == 0 || ppObjects == 0 || pDispids == 0)
        RRETURN(E_INVALIDARG);

    hr = THR(pUnk->QueryInterface(IID_IDispatch, (LPVOID *)&pDispatch));
    if (hr)
        goto Cleanup;

    for (i = 0 ; i < cNames ; i++)
    {
        hr = THR(resolveName(pDispatch, dispid, pstrNames[i], &ppObjects[i], &pDispids[i]));
        if (hr)
            goto Cleanup;
    }
Cleanup:
    ReleaseInterface(pDispatch);
    return hr;
}

STDMETHODIMP
CDoc::CRecalcHost::SetValue(IUnknown *pUnk, DISPID dispid, VARIANT *pv, BOOL fStyle)
{
    HRESULT hr;
    IDispatch *pDispatch = 0;
    CStyle *pStyle = 0;

    if (fStyle)
    {

        hr = pUnk->QueryInterface(CLSID_CStyle, (LPVOID *)&pStyle); // no AddRef
        if (hr)
            goto Cleanup;

        _pElemSetValue = pStyle->GetElementPtr();
        _dispidSetValue = dispid;
    }

    hr = THR(pUnk->QueryInterface(IID_IDispatch, (LPVOID *)&pDispatch));
    if (hr)
        goto Cleanup;

    hr = THR(SetDispProp(pDispatch, dispid, g_lcidUserDefault, pv));

    TraceTag((tagRecalcHost, "SetValue: put to %08x.%08x failed", pUnk, dispid));

    // Now we need to mark the value as something put there by an expression
    // so that we know to delete it when the expression goes away
    //
    // We only need to do this for style props (ie expressions that came in via the stylesheet)
    // Any other expression will have to be explicitly removed and the removeExpression will
    // remove the value at that time.
    //
    if (SUCCEEDED(hr) && fStyle)
    {
        CAttrArray **ppAA = 0;
        CAttrValue *pAV = 0;

        ppAA = pStyle->GetAttrArray();

        if (ppAA && *ppAA)
            pAV = (*ppAA)->Find(dispid, pStyle->IsExpandoDISPID(dispid) ? CAttrValue::AA_Expando : CAttrValue::AA_Attribute);
        
        if (pAV)
            pAV->SetExpression(TRUE);
    }

    _pElemSetValue = 0;

Cleanup:
    ReleaseInterface(pDispatch);
    RRETURN(hr);
}

//------------------------------------------------------------------
//
// Method:      RemoveValue
//
// Description: If the value in the target was put there by an expression
//              remove it.  If not then the value was explicitly put there
//              by someone else and we don't want to or need to remove it
//
//-------------------------------------------------------------------
STDMETHODIMP
CDoc::CRecalcHost::RemoveValue(IUnknown *pUnk, DISPID dispid)
{
    HRESULT hr = S_OK;
    CBase *pBase = (CBase *)pUnk;   // There really should be a better way!
    CAttrArray *pAA = *(pBase->GetAttrArray());
    if (pAA)
    {
        CAttrValue *pAV = pAA->Find(dispid);
        if (pAV && pAV->IsExpression())
        {
            PROPERTYDESC *pDesc = 0;
            hr = THR(pBase->FindPropDescFromDispID(dispid, &pDesc, 0, 0));
            if (!hr)
                hr = THR(pBase->removeAttributeDispid(dispid, pDesc) ? S_OK : E_FAIL);
        }
    }

    RRETURN(hr);
}

STDMETHODIMP
CDoc::CRecalcHost::GetScriptTextAttributes(LPCOLESTR szLanguage, LPCOLESTR pchCode, ULONG cch, LPCOLESTR szDelim, DWORD dwFlags, WORD *pattr)
{
    CScriptHolder *psholder = 0;
    IActiveScriptDebug *pdebug = 0;
    HRESULT hr = E_UNEXPECTED;
    CScriptCollection *pScriptCollection = MyDoc()->PrimaryMarkup()->GetScriptCollection();

    if (pScriptCollection)
    {
        hr = THR(pScriptCollection->GetHolderForLanguage(const_cast<LPOLESTR>(szLanguage), NULL, NULL, NULL, &psholder, NULL));
        if (hr)
            goto Cleanup;

        hr = THR(psholder->GetDebug(&pdebug));
        if (hr)
            goto Cleanup;

        hr = THR(pdebug->GetScriptTextAttributes(pchCode, cch, szDelim, dwFlags, pattr));
        if (hr)
            goto Cleanup;
    }

Cleanup:
    ReleaseInterface(pdebug);
    RRETURN(hr);
}

#if DBG == 1
STDMETHODIMP
CDoc::CRecalcHost::GetObjectInfo(IUnknown *pUnk, DISPID dispid, BSTR *pstrID, BSTR *pstrMember, BSTR *pstrTag)
{
    if (pstrID)
        *pstrID = 0;
    if (pstrMember)
        *pstrMember = 0;
    if (pstrTag)
        *pstrTag = 0;

    if (!IsTagEnabled(tagRecalcGetInfo))
        RRETURN(E_FAIL);

    CElement *pElement = 0;
    IHTMLElement *pHTMLElement = 0;
    CStyle *pStyle = 0;
    HRESULT hr;
    BSTR bstrID = 0;

    // try to get the element
    hr = pUnk->QueryInterface(CLSID_CElement, (LPVOID *)&pElement);
    if (FAILED(hr))
    {
        // See if it's a style object and find the element

        hr = pUnk->QueryInterface(CLSID_CStyle, (LPVOID *)&pStyle);
        if (SUCCEEDED(hr))
        {
            pElement = pStyle->GetElementPtr();
        }
    }

    if (SUCCEEDED(hr))
    {
        // We have the element, now get the id, tag and member names

        if (pstrID)
        {
            hr = pElement->PrivateQueryInterface(IID_IHTMLElement, (LPVOID *)&pHTMLElement);
            Assert(!hr);

            IGNORE_HR(pHTMLElement->get_id(&bstrID));

            // No ID?  Try the name
            if (!bstrID || *bstrID == 0)
            {
                IGNORE_HR(pElement->get_name(&bstrID));
            }

            if (pStyle)
            {
                CBufferedStr cbuf;
                cbuf.Set(bstrID);
                cbuf.QuickAppend(_T(".style"));

                *pstrID = SysAllocString(cbuf);
            }
            else
            {
                *pstrID = bstrID;
                bstrID = 0; // prevent this from being freed
            }
        }

        if (pstrTag)
            pElement->get_tagName(pstrTag);

        if (pstrMember)
        {
            if (pStyle)
            {
                DISPID expDispid;
                LPCTSTR pszName = 0;

                PROPERTYDESC *ppropdesc = 0;
                if (pStyle->FindPropDescFromDispID(dispid, &ppropdesc, NULL, NULL) == S_OK)
                {
                    pszName = ppropdesc->pstrExposedName ? ppropdesc->pstrExposedName : ppropdesc->pstrName;
                }
                else if (pStyle->IsExpandoDISPID(dispid, &expDispid))
                {
                    pStyle->GetExpandoName(expDispid, &pszName);
                }

                *pstrMember = SysAllocString(pszName);
            }
            else
            {
                pElement->GetMemberName(dispid, pstrMember);
            }
        }
    }

    if (pHTMLElement)
        pHTMLElement->Release();
    if (bstrID)
        FormsFreeString(bstrID);

    RRETURN(hr);
}

int
CDoc::CRecalcHost::Dump(DWORD dwFlags)
{
    extern BOOL RecalcDumpOpen();
    if (!RecalcDumpOpen())
        return 0;

    r_p(_T("<div class=recalchost>Recalc Host<br>\n"));
    r_p(_T("\t<div class=recalcmembers>Members\n"));
    r_p(_T("\t\t<div class=recalcvalues>"));

    r_pp(_pElemSetValue);
    r_pn(_dispidSetValue);
    r_pb(_fRecalcRequested);
    r_pb(_fInRecalc);
    r_pn(_ulSuspend);
    r_p(_T("\t\t</div>\n"));
    r_p(_T("\t</div>\n"));

    if (_pEngine)
    {
        ((CRecalcEngine *)_pEngine)->Dump(dwFlags);
    }

    r_p(_T("</div>\n"));
    if (g_hfileRecalcDump)
    {
        CloseHandle(g_hfileRecalcDump);
        g_hfileRecalcDump = INVALID_HANDLE_VALUE;
    }
    return 0;
}
#endif


//+----------------------------------------------------------------------------
//
//  Function:   CElement::GetCanonicalProperty
//
//  Synopsis:   Returns the canonical pUnk/dispid pair for a particular dispid
//              Used by the recalc engine to catch aliased properties.
//
//  Parameters: ppUnk will contain the canonical object
//              pdispid will contain the canonical dispid
//
//  Returns:    S_OK if successful
//              S_FALSE if property has no alias
//
//-----------------------------------------------------------------------------

HRESULT
CElement::GetCanonicalProperty(DISPID dispid, IUnknown **ppUnk, DISPID *pdispid)
{
    HRESULT hr = S_OK;

    switch (dispid)
    {
    case DISPID_IHTMLELEMENT2_CLIENTLEFT:
        hr = THR(PrivateQueryInterface(IID_IUnknown, (LPVOID *) ppUnk));
        *pdispid = DISPID_IHTMLELEMENT_OFFSETLEFT;
        break;
    case DISPID_IHTMLELEMENT2_CLIENTTOP:
        hr = THR(PrivateQueryInterface(IID_IUnknown, (LPVOID *) ppUnk));
        *pdispid = DISPID_IHTMLELEMENT_OFFSETTOP;
        break;
    case DISPID_IHTMLELEMENT2_CLIENTWIDTH:
        hr = THR(PrivateQueryInterface(IID_IUnknown, (LPVOID *) ppUnk));
        *pdispid = DISPID_IHTMLELEMENT_OFFSETWIDTH;
        break;
    case DISPID_IHTMLELEMENT2_CLIENTHEIGHT:
        hr = THR(PrivateQueryInterface(IID_IUnknown, (LPVOID *) ppUnk));
        *pdispid = DISPID_IHTMLELEMENT_OFFSETHEIGHT;
        break;
    default:
        *ppUnk = 0;
        *pdispid = 0;
        hr = S_FALSE;
    }
    
    RRETURN1(hr, S_FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\rtftohtm.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       rtftohtm.cxx
//
//  Contents:   CRtfToHtmlConverter
//
//----------------------------------------------------------------------------


#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_RTFTOHTM_HXX_
#define X_RTFTOHTM_HXX_
#include "rtftohtm.hxx"
#endif

MtDefine(CRtfToHtmlConverter, Locals, "CRtfToHtmlConverter")
MtDefine(CRtfToHtmlConverter_pchModuleName, CRtfToHtmlConverter, "CRtfToHtmlConverter::_pchModuleName")

// TODO (johnv) Taken from convapi.h which is not part of our project
// Tells RTF converter to not show any UI.
#define fRegAppPreview      4

#ifdef WIN16
#define CharToOem(x, y)
#endif
 
struct RTF_CONVERTER
{
    void *  pOut;
    HANDLE  hTransferBuffer;
    HRESULT hr;
}
g_RtfConverter;

CRITICAL_SECTION CRtfToHtmlConverter::_cs;
BOOL             CRtfToHtmlConverter::_fCSInited = FALSE;

//+---------------------------------------------------------------------------
//
//  Function:   AcceptRtfForExternalWrite
//
//  Synopsis:   Accepts chunks of RTF from the Word RTF to HTML converter.
//              Writes them to disk in a file opened by
//              CRtfToHtmlConverter::InternalHtmlToExternalRtf().
//
//----------------------------------------------------------------------------
SHORT PASCAL
AcceptRtfForExternalWrite(LONG cch, INT nPercentComplete)
{
    BOOL    fWriteOpSuccess;
    LONG    lSetFpRetVal;
    HANDLE  hFile;
    char *  pchTransferBuffer;
    DWORD   dwBytesWritten;

    Assert(g_RtfConverter.pOut);
    Assert(cch <= (LONG) GlobalSize(g_RtfConverter.hTransferBuffer));

    if (cch >0)
    {
        hFile = (HANDLE) g_RtfConverter.pOut;

        lSetFpRetVal = SetFilePointer(hFile, 0, NULL, FILE_END);
        if (lSetFpRetVal == -1)
            return -1;

        pchTransferBuffer = (char *) GlobalLock(g_RtfConverter.hTransferBuffer);
        if (!pchTransferBuffer)
            return -1;
        fWriteOpSuccess = WriteFile(
                hFile,
                pchTransferBuffer,
                cch,
                &dwBytesWritten,
                NULL);
        GlobalUnlock(g_RtfConverter.hTransferBuffer);

        if (!fWriteOpSuccess)
            return -1;
    }

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   FeedExternalRtfToConverter
//
//  Synopsis:   Sends chunks of HTML to the Word RTF to HTML converter.  Reads
//              from the file opened by
//              CRtfToHtmlConverter::ExternalRtfToInternalHtml().
//
//----------------------------------------------------------------------------
SHORT PASCAL
FeedExternalRtfToConverter(BOOL * afFlags /* array of size 16 */, INT nZero)
{
    BOOL    fReadOpSuccess;
    DWORD   dwBytesRead;
    HANDLE  hFile;
    char *  pchTransferBuffer;

    Assert(g_RtfConverter.pOut);

    hFile = (HANDLE) g_RtfConverter.pOut;

    pchTransferBuffer = (char *) GlobalLock(g_RtfConverter.hTransferBuffer);
    if (!pchTransferBuffer)
        return -1;
    fReadOpSuccess = ReadFile(
            hFile,
            pchTransferBuffer,
            (DWORD) GlobalSize(g_RtfConverter.hTransferBuffer),
            &dwBytesRead,
            NULL);
    GlobalUnlock(g_RtfConverter.hTransferBuffer);

    if (fReadOpSuccess)
        return dwBytesRead; // 0 indicates completion
    else
        return -1;
}

//+---------------------------------------------------------------------------
//
//  Function:   AcceptRtfForStreamWrite
//
//  Synopsis:   Accepts chunks of RTF from the Word RTF to HTML converter.
//              Writes them to disk in a file opened by
//              CRtfToHtmlConverter::InternalHtmlToExternalRtf().
//
//----------------------------------------------------------------------------
SHORT PASCAL
AcceptRtfForStreamWrite(LONG cch, INT nPercentComplete)
{
    HRESULT     hr;
    IStream *   pstm;
    char *      pchTransferBuffer;

    Assert(g_RtfConverter.pOut);
    Assert(cch <= (LONG) GlobalSize(g_RtfConverter.hTransferBuffer));

    if (cch > 0)
    {
        pstm = (IStream *) g_RtfConverter.pOut;

        pchTransferBuffer = (char *) GlobalLock(g_RtfConverter.hTransferBuffer);
        if (!pchTransferBuffer)
        {
            hr = E_FAIL;
            goto Error;
        }
        hr = THR(pstm->Write(pchTransferBuffer, cch, NULL));
        if (hr)
            goto Error;
        GlobalUnlock(g_RtfConverter.hTransferBuffer);

        g_RtfConverter.hr = hr;
        if (hr)
            goto Error;
    }

    return 0;

Error:
    g_RtfConverter.hr = hr;
    return -1;
}



//+---------------------------------------------------------------------------
//
//  Member:     CRtfToHtmlConverter::Create
//  Factory method
//----------------------------------------------------------------------------
HRESULT 
CRtfToHtmlConverter::Create(CRtfToHtmlConverter  **ppConverter, CDoc *pDoc)
{
    HRESULT   hr = S_OK;
    HKEY    hkey = NULL;
    DWORD   dwLength;
    TCHAR   achConverterPath[MAX_PATH];
    static const TCHAR* s_szImportPath = _T("Software\\Microsoft\\Shared Tools\\Text Converters\\Import\\HTML");
    static const TCHAR* s_szExportPath = _T("Software\\Microsoft\\Shared Tools\\Text Converters\\Export\\HTML");

    Assert( ppConverter );
    *ppConverter = new CRtfToHtmlConverter(pDoc);
    if (!*ppConverter)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    (*ppConverter)->_hTransferBuffer = GlobalAlloc(GMEM_MOVEABLE, 2048);
    (*ppConverter)->_pchModuleName = new(Mt(CRtfToHtmlConverter_pchModuleName)) char[7+1];
    if( !(*ppConverter)->_hTransferBuffer || !(*ppConverter)->_pchModuleName )
    {
        // should have used GetLastError for the GlobalAlloc failure
        // simplify it for now
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    strcpy((*ppConverter)->_pchModuleName, "HTMLPAD") ;

    
    // Try to load it from the path.
#ifdef _WIN64
    (*ppConverter)->_hConverter = LoadLibraryEx(_T("html64.iec"), NULL, 0);
#else
    (*ppConverter)->_hConverter = LoadLibraryEx(_T("html32.cnv"), NULL, 0);
#endif

    // Can't find the converter in the path, check the registry.
    if (!(*ppConverter)->_hConverter)
    {
        // Try the import and export file paths as specified in the registry
        if ( RegOpenKey( HKEY_LOCAL_MACHINE, s_szImportPath, &hkey ) == ERROR_SUCCESS ||
             RegOpenKey( HKEY_LOCAL_MACHINE, s_szExportPath, &hkey ) == ERROR_SUCCESS )
        {

            dwLength = sizeof(TCHAR) * MAX_PATH;
            if (ERROR_SUCCESS == RegQueryValueEx(
                        hkey,
                        _T("Path"),
                        NULL,
                        NULL,
                        (BYTE *) achConverterPath,
                        &dwLength))
            {
                (*ppConverter)->_hConverter = LoadLibraryEx(achConverterPath, NULL, 0);
            }

            RegCloseKey (hkey);
        }
    }

    if ((*ppConverter)->_hConverter)
    {
        long (WINAPI * pfnInitConverter)(HWND, char *);
        HGLOBAL (WINAPI * pfnRegisterApp)(long, void *);
        
        pfnInitConverter = (long (WINAPI *)(HWND, char *)) GetProcAddress(
                (*ppConverter)->_hConverter,
                "InitConverter32");

        pfnRegisterApp = (HGLOBAL (WINAPI *)(long, void *)) GetProcAddress(
                (*ppConverter)->_hConverter,
                "RegisterApp");

        (*ppConverter)->_pfnIsFormatCorrect = (short (WINAPI *)(HANDLE, HANDLE)) GetProcAddress(
                (*ppConverter)->_hConverter,
                "IsFormatCorrect32");
        (*ppConverter)->_pfnHtmlToRtf = (short (WINAPI *)(
                    HANDLE,
                    IStorage *,
                    HANDLE,
                    HANDLE,
                    HANDLE,
                    short (FAR PASCAL *)(LONG, INT))) GetProcAddress(
                (*ppConverter)->_hConverter,
                "ForeignToRtf32");
        (*ppConverter)->_pfnRtfToHtml = (short (WINAPI *)(
                    HANDLE,
                    IStorage *,
                    HANDLE,
                    HANDLE,
                    short (FAR PASCAL *)(BOOL *, INT))) GetProcAddress(
                (*ppConverter)->_hConverter,
                "RtfToForeign32");

        //
        // The RTF convert is not multi-threaded, so syncronize access
        //
        //
        g_RtfConverter.hTransferBuffer = (*ppConverter)->_hTransferBuffer;

        if (pfnInitConverter
            && (*ppConverter)->_pfnIsFormatCorrect
            && (*ppConverter)->_pfnHtmlToRtf
            && (*ppConverter)->_pfnRtfToHtml
            && (*ppConverter)->_hTransferBuffer)
        {
            (*ppConverter)->_fInitSuccessful = (BOOL) (*pfnInitConverter)(
                    GetForegroundWindow(),
                    (*ppConverter)->_pchModuleName);

            if (pfnRegisterApp)
            {
                // Disable any UI from the converter
                HGLOBAL hGlobal = pfnRegisterApp(fRegAppPreview, NULL);
                
                if (hGlobal)
                {
                    // We do not care about the converter's prefs
                    GlobalFree(hGlobal);
                }
            }
        }
    }
    
Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CRtfToHtmlConverter::CRtfToHtmlConverter
//
//----------------------------------------------------------------------------
CRtfToHtmlConverter::CRtfToHtmlConverter(CDoc * pDoc)
{
    memset(this, 0, sizeof(*this));
    _pDoc = pDoc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRtfToHtmlConverter::~CRtfToHtmlConverter
//
//----------------------------------------------------------------------------
CRtfToHtmlConverter::~CRtfToHtmlConverter(void)
{
    if (_hConverter)
    {
        FreeLibrary(_hConverter);
    }

    if (_hExternalFile)
    {
        CloseHandle(_hExternalFile);
    }

    if (_hTransferBuffer)
    {
        GlobalFree(_hTransferBuffer);
    }
    
    delete _pchModuleName;
 }

//+---------------------------------------------------------------------------
//
//  Member:     CRtfToHtmlConverter::InternalHtmlToExternalRtf
//
//  Synopsis:   Uses the Word RTF to HTML converter to convert HTML
//              to RTF, writing it into a file on disk. If _pDoc is not
//              NULL, it is used as the source of HTML. Otheriwse,
//              pszHtmlPath is assumed to be the name of the HTML source
//              file.
//
//  Arguments:  pszRtfPath  Specifies the name the file in which the RTF is
//                       to be saved.
//              pszHtmlPath Ignored if _pDoc is not NULL. Otherwise, it
//                          specifies the name of the HTML source file.
//  Returns:    TRUE if the conversion was successful, FALSE if it was not.
//
//----------------------------------------------------------------------------
HRESULT
CRtfToHtmlConverter::InternalHtmlToExternalRtf(LPCTSTR pszRtfPath,
                                               LPCTSTR pszHtmlPath)
{
    HRESULT hr = S_OK;
    HANDLE  hPath = 0;
    TCHAR   achTmpPath[MAX_PATH];
    TCHAR   achTmpFile[MAX_PATH];  
    char *  pchPath;
    INT     i;

    if (!_fInitSuccessful)
        goto Error;

    if (!pszRtfPath || !pszRtfPath[0] || (_tcslen(pszRtfPath) <= 4))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    Assert((!StrCmpIC(_T(".rtf"), pszRtfPath+_tcslen(pszRtfPath)-4))
        || (!StrCmpIC(_T(".tmp"), pszRtfPath+_tcslen(pszRtfPath)-4)));

    if (!_pDoc)
    {
        if (!pszHtmlPath || !pszHtmlPath[0] || (_tcslen(pszHtmlPath) <= 4))
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }
        Assert((!StrCmpIC(_T(".htm"), pszHtmlPath+_tcslen(pszHtmlPath)-4))
            || (!StrCmpIC(_T(".tmp"), pszHtmlPath+_tcslen(pszHtmlPath)-4)));
        _tcsncpy(achTmpFile, pszHtmlPath, MAX_PATH);
        achTmpFile[MAX_PATH-1] = _T('\0');
    }
    else
    {
        GetTempPath(MAX_PATH, achTmpPath);
        GetTempFileName(achTmpPath, _T("h2r"), 0, achTmpFile);
        
        for (i = 0; achTmpFile[i] != _T('.') && achTmpFile[i]; ++i)
            ;   // empty loop
        Assert(achTmpFile[i] == _T('.'));
        _tcscpy(achTmpFile+i+1, _T("htm"));
        hr = THR(_pDoc->Save(achTmpFile, FALSE));
        if (hr)
            goto Cleanup;
    }

    _hExternalFile = CreateFile(
            pszRtfPath,
            GENERIC_WRITE,
            0,
            NULL,
            CREATE_ALWAYS,
            FILE_ATTRIBUTE_NORMAL,
            NULL);

    if (_hExternalFile == INVALID_HANDLE_VALUE)
        goto Error;

    hPath = GlobalAlloc(GMEM_MOVEABLE, sizeof(char) * MAX_PATH);

    if (!hPath)
        goto Error;


    pchPath = (char *) GlobalLock(hPath);
    if (!pchPath)
        goto Error;
    CharToOem(achTmpFile, pchPath);
    GlobalUnlock(hPath);

    g_RtfConverter.pOut = (void *) _hExternalFile;

    // IEV6-26193
    // Per smueller, this call is indeed redundant for both
    // 32-bit and 64-bit. _pfnHtmlToRtf will call this function
    // internally.  This call caused reentrancy into the 
    // converter DLL.
    // [zhenbinx]
    // if ((*_pfnIsFormatCorrect)(hPath, hBuffer) == 1)
    {
        BOOL    fRet;

        fRet = (*_pfnHtmlToRtf)(
                hPath,
                NULL,
                _hTransferBuffer,
                NULL,
                NULL,
                AcceptRtfForExternalWrite);

        if (fRet)
            goto Error;
    }

Cleanup:
    
    if (_hExternalFile)
    {    CloseHandle(_hExternalFile);
        _hExternalFile = NULL;
    }
    if (hPath)
        GlobalFree(hPath);
    RRETURN(hr);

Error:
    hr = E_FAIL;
    goto Cleanup;
}


//+---------------------------------------------------------------------------
//
//  Member:     CRtfToHtmlConverter::ExternalRtfToInternalHtml
//
//  Synopsis:   Uses the Word RTF to HTML converter to convert external RTF
//              to HTML, loading it from a file on disk.
//
//  Arguments:  pszPath specifies the filename of the file to load. If _pDoc
//              is NULL,this returns the name of the file that contains HTML.
//
//  Returns:    TRUE if the conversion was successful, FALSE if it was not.
//
//----------------------------------------------------------------------------
HRESULT
CRtfToHtmlConverter::ExternalRtfToInternalHtml(TCHAR * pszPath)
{
    HRESULT hr = S_OK;
    HANDLE  hPath = 0;
    TCHAR   achTmpPath[MAX_PATH];
    TCHAR   achTmpFile[MAX_PATH];  
    char *  pchPath;
    INT     i;
    BOOL    fRet;


    if (!pszPath || !pszPath[0] || (_tcslen(pszPath) <= 4))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    Assert((!StrCmpIC(_T(".rtf"), pszPath+_tcslen(pszPath)-4))
        || (!StrCmpIC(_T(".tmp"), pszPath+_tcslen(pszPath)-4)));

    // We do not Assert(_pDoc) because if _pDoc is NULL this function will return the path of the 
    // HTML file created.

    if (!_fInitSuccessful)
        goto Error;

    hPath = GlobalAlloc(GMEM_MOVEABLE, sizeof(char) * MAX_PATH);

    if (!hPath)
        goto Error;

    _hExternalFile = CreateFile(
            pszPath,
            GENERIC_READ,
            0,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL);

    if (_hExternalFile == INVALID_HANDLE_VALUE)
        goto Error;

    GetTempPath(MAX_PATH, achTmpPath);
    GetTempFileName(achTmpPath, _T("h2r"), 0, achTmpFile);
    
    for (i = 0; achTmpFile[i] != _T('.') && achTmpFile[i]; ++i)
        ;   // empty loop
    Assert(achTmpFile[i] == _T('.'));
    _tcscpy(achTmpFile+i+1, _T("htm"));

    pchPath = (char *) GlobalLock(hPath);
    if (!pchPath)
        goto Error;
    CharToOem(achTmpFile, pchPath);
    GlobalUnlock(hPath);

    g_RtfConverter.pOut= (void *) _hExternalFile;

    fRet = (*_pfnRtfToHtml)(
            hPath,
            NULL,
            _hTransferBuffer,
            NULL,
            FeedExternalRtfToConverter);

    
    if (fRet)
        goto Error;

    // This function will return the name and location of the new file if _pDoc is NULL,
    // otherwise it will call pDoc's load function.

    if(_pDoc)
    { 
        hr = THR(_pDoc->Load(achTmpFile,0));
        if (hr)
           goto Cleanup;
    }
    else
        _tcscpy(pszPath, achTmpFile);

Cleanup:

    if (hPath)
        GlobalFree(hPath);
    RRETURN(hr);

Error:
    hr = E_FAIL;
    goto Cleanup;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRtfToHtmlConverter::InternalHtmlToStreamRtf
//
//  Synopsis:   Uses the Word RTF to HTML converter to convert internal HTML
//              to RTF, writing it into the specified stream.
//
//  Arguments:  pstm   the stream into which the RTF should be written
//
//----------------------------------------------------------------------------
HRESULT
CRtfToHtmlConverter::InternalHtmlToStreamRtf(IStream * pstm)
{
    HRESULT hr;
    HANDLE  hPath = 0;
    TCHAR   achTmpPath[MAX_PATH];
    TCHAR   achTmpFile[MAX_PATH];
    char *  pchPath;
    INT     i;

    Assert(pstm);
    Assert(_pDoc);

    if (!_fInitSuccessful)
        goto Error;

    hPath = GlobalAlloc(0, sizeof(char) * MAX_PATH);

    if (!hPath)
        goto Error;

    GetTempPath(MAX_PATH, achTmpPath);
    GetTempFileName(achTmpPath, _T("h2r"), 0, achTmpFile);
    
    for (i = 0; achTmpFile[i] != _T('.') && achTmpFile[i]; ++i)
        ;   // empty loop
    Assert(achTmpFile[i] == _T('.'));
    _tcscpy(achTmpFile+i+1, _T("htm"));

    hr = THR(_pDoc->Save(achTmpFile, FALSE));
    if (hr)
        goto Cleanup;

    pchPath = (char *) GlobalLock(hPath);
    if (!pchPath)
        goto Error;
    CharToOem(achTmpFile, pchPath);
    GlobalUnlock(hPath);

    g_RtfConverter.hr = E_FAIL;
    g_RtfConverter.pOut= (void *) pstm;
    
    // IEV6-26193
    // Per smueller, this call is indeed redundant for both
    // 32-bit and 64-bit. _pfnHtmlToRtf will call this function
    // internally.  This call caused reentrancy into the 
    // converter DLL.
    // [zhenbinx]
    // if ((*_pfnIsFormatCorrect)(hPath, hBuffer) == 1)
    {
        BOOL    fRet;

        fRet = (*_pfnHtmlToRtf)(
                hPath,
                NULL,
                _hTransferBuffer,
                NULL,
                NULL,
                AcceptRtfForStreamWrite);

        hr = g_RtfConverter.hr;

        if (hr)
            goto Cleanup;
        if (fRet)
            goto Error;
    }

Cleanup:

    if (hPath)
        GlobalFree(hPath);
    RRETURN1(hr, S_FALSE);

Error:
    hr = E_FAIL;
    goto Cleanup;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRtfToHtmlConverter::StringHtmlToStringRtf
//
//  Synopsis:   Uses the Word HTML to RTF converter to convert a string of HTML
//              to a string of RTF.
//
//----------------------------------------------------------------------------
HRESULT
CRtfToHtmlConverter::StringHtmlToStringRtf(LPSTR pszHtml, HGLOBAL *phglobalRtf)
{
    HRESULT  hr = S_OK;
    HANDLE   hfileRTF, hfileHTM;
    TCHAR    achTmpPath[MAX_PATH];
    TCHAR    achHtmlFile[MAX_PATH];
    TCHAR    achRtfFile[MAX_PATH];
    DWORD    nBytesToRead, nBytesRead, nBytesWritten = 0;
    BOOL     fRet;
    char *   szTemp = NULL; 

    GetTempPath(MAX_PATH, achTmpPath);
    GetTempFileName(achTmpPath, _T("h2r"), 0, achHtmlFile);

    GetTempFileName(achTmpPath, _T("h2r"), 0, achRtfFile);
 
    hfileHTM = CreateFile(
                achHtmlFile,
                GENERIC_WRITE,
                0,
                NULL,
                CREATE_ALWAYS,
                FILE_ATTRIBUTE_NORMAL,
                NULL);
    

    if (hfileHTM == INVALID_HANDLE_VALUE)
        goto Error;

    fRet = WriteFile(
            hfileHTM,
            pszHtml,
            strlen(pszHtml),
            &nBytesWritten,
            NULL);

    CloseHandle(hfileHTM);

    if(fRet == FALSE)
        goto Error;

    hr = THR(InternalHtmlToExternalRtf(achRtfFile, achHtmlFile));

    if(hr)
        goto Error;

    hfileRTF = CreateFile(
                achRtfFile,
                GENERIC_READ,
                0,
                NULL,
                OPEN_EXISTING,
                FILE_FLAG_DELETE_ON_CLOSE,
                NULL);

    if (hfileRTF == INVALID_HANDLE_VALUE)
        goto Error;

    nBytesToRead = GetFileSize(hfileRTF, NULL);

    if (nBytesToRead == 0xFFFFFFFF)
        goto Error;

    *phglobalRtf = GlobalAlloc(0, nBytesToRead + 1);

    szTemp = (LPSTR)GlobalLock(*phglobalRtf);
    if (szTemp == NULL)
    	goto Error;

    fRet = ReadFile(
            hfileRTF,
            szTemp,
            nBytesToRead,
            &nBytesRead,
            NULL);

    CloseHandle(hfileRTF);

    if(fRet == FALSE)
        goto Error;

    szTemp[nBytesRead] = '\0';

Cleanup:
    if (szTemp)
        GlobalUnlock(*phglobalRtf);
    
    // No need to delete RtfFile - we used FILE_FLAG_DELETE_ON_CLOSE.
    DeleteFile(achHtmlFile);
    RRETURN(hr);

Error:
    hr = E_FAIL;
    goto Cleanup;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRtfToHtmlConverter::StringRtfToStringHtml
//
//  Synopsis:   Uses the Word RTF to HTML converter to convert a string of RTF
//              to a string of HTML.
//
//  Arguments:  lptsz   the stream into which the RTF should be written
//
//----------------------------------------------------------------------------
HRESULT
CRtfToHtmlConverter::StringRtfToStringHtml(LPSTR pszRtf, HGLOBAL * phglobalHtml)
{
    HRESULT  hr = S_OK;
    HANDLE   hfileRTF, hfileHTM;
    TCHAR    achTmpPath[MAX_PATH];
    TCHAR    achTmpFile[MAX_PATH];
    DWORD    nBytesToRead, nBytesRead, nBytesWritten = 0;
    BOOL     fRet;
    char    *szPtrHead, *szPtrClose, *szTemp = NULL; 
    int      iClosing, iHeading;

    GetTempPath(MAX_PATH, achTmpPath);
    GetTempFileName(achTmpPath, _T("r2h"), 0, achTmpFile);
    
    // Keep a copy of the file location so we can delete it when we are done with it...
    _tcscpy(achTmpPath, achTmpFile);

    hfileRTF = CreateFile(
                achTmpFile,
                GENERIC_WRITE,
                0,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL);
    

    if (hfileRTF == INVALID_HANDLE_VALUE)
        goto Error;

    fRet = WriteFile(
            hfileRTF,
            pszRtf,
            strlen(pszRtf),
            &nBytesWritten,
            NULL);

    CloseHandle(hfileRTF);

    if(fRet == FALSE)
        goto Error;

    hr = THR(ExternalRtfToInternalHtml(achTmpFile));

    if(hr)
        goto Error;

    hfileHTM = CreateFile(
                achTmpFile,
                GENERIC_READ,
                0,
                NULL,
                OPEN_EXISTING,
                FILE_FLAG_DELETE_ON_CLOSE,
                NULL);

    if (hfileHTM == INVALID_HANDLE_VALUE)
        goto Error;

    nBytesToRead = GetFileSize(hfileHTM, NULL);

    if (nBytesToRead == 0xFFFFFFFF)
        goto Error;

    *phglobalHtml = GlobalAlloc(0, nBytesToRead + 1);

    szTemp = (LPSTR)GlobalLock(*phglobalHtml);    
    if (szTemp == NULL)
    	goto Error;

    fRet = ReadFile(
            hfileHTM,
            szTemp,
            nBytesToRead,
            &nBytesRead,
            NULL);

    CloseHandle(hfileHTM);

    if(fRet == FALSE)
        goto Error;

    szTemp[nBytesRead] = '\0';

    // The RTFtoHTML converter will put header information on the HTML file.  
    // We want to remove these headers, since this is just supposed to return an HTML string.

    szPtrHead = szTemp;
    while(strncmp(szPtrHead, "<BODY", 5) != 0)
    {
        szPtrHead ++;
        szPtrHead = strchr(szPtrHead, '<');
        if(!szPtrHead)
            goto Error;
    }
    
    szPtrHead = strchr(szPtrHead, '>');
    szPtrHead ++;

    szPtrClose = szPtrHead;
    while(strncmp(szPtrClose, "</BODY", 6) != 0)
    {
        szPtrClose ++;
        szPtrClose = strchr(szPtrClose, '<');
        if(!szPtrClose)
            goto Error;
    }
 
    iHeading = strlen(szTemp) - strlen(szPtrHead);
    iClosing = strlen(szPtrClose);

    memcpy(szTemp, szPtrHead, nBytesToRead - iHeading - iClosing);

    szPtrClose = szTemp + nBytesToRead - iHeading - iClosing;
    // szPtrClose[0] = '\0';
    memset(szPtrClose, '\0', iHeading + iClosing);

Cleanup:
    if (szTemp)
        GlobalUnlock(*phglobalHtml);

    DeleteFile(achTmpPath);
    
    RRETURN(hr);

Error:

    hr = E_FAIL;
    goto Cleanup;
}


//+---------------------------------------------------------------------------
//
//  Member:     CRtfToHtmlConverter::Init, static
//
//  Synopsis:   Initializes the critical section for the RTF convert.  Since
//              the RTF converter isn't multi-threaded, we need to make sure that 
//              we serialize access.
//
//----------------------------------------------------------------------------
HRESULT
CRtfToHtmlConverter::Init()
{
    HRESULT hr = HrInitializeCriticalSection(&_cs);

    if (!hr)
        _fCSInited = TRUE;

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CRtfToHtmlConverter::Deinit, static
//
//  Synopsis:   Deletes the critical section for the RTF convert.
//
//----------------------------------------------------------------------------
void
CRtfToHtmlConverter::Deinit()
{
    if (_fCSInited)
        DeleteCriticalSection(&_cs);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\rootelem.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1998
//
//  File:       rootelem.cxx
//
//  Contents:   Implementation of CRootElement
//
//  Classes:    CRootElement
//
//----------------------------------------------------------------------------

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_SWITCHES_HXX_
#define X_SWITCHES_HXX_
#include "switches.hxx"
#endif

#ifndef X_ROOTELEM_HXX
#define X_ROOTELEM_HXX
#include "rootelem.hxx"
#endif

#ifndef X_ELEMENTP_HXX_
#define X_ELEMENTP_HXX_
#include "elementp.hxx"
#endif

#ifndef X_INPUTTXT_HXX_
#define X_INPUTTXT_HXX_
#include "inputtxt.hxx"
#endif

MtDefine(CRootElement, Elements, "CRootElement")


//////////////
//  Globals //
//////////////

const CElement::CLASSDESC CRootElement::s_classdesc =
{
    {
        NULL,                   // _pclsid
        0,                      // _idrBase
#ifndef NO_PROPERTY_PAGE
        0,                      // _apClsidPages
#endif // NO_PROPERTY_PAGE
        NULL,                   // _pcpi
        ELEMENTDESC_NOLAYOUT,   // _dwFlags
        NULL,                   // _piidDispinterface
        NULL
    },
    NULL,

    NULL                        // _paccelsRun
};

void
CRootElement::Notify(CNotification *pNF)
{
    NOTIFYTYPE              ntype = pNF->Type();

    CMarkup *               pMarkup = GetMarkup();

    super::Notify(pNF);

    switch (ntype)
    {
    case NTYPE_SET_CODEPAGE:
        //
        // Directly switch the codepage (do not call SwitchCodePage)
        //
        {
            ULONG ulData;
            UINT WindowsCodePageFromCodePage( CODEPAGE cp );
        
            pNF->Data(&ulData);

            IGNORE_HR(pMarkup->SetCodePage(CODEPAGE(ulData)));
            IGNORE_HR(pMarkup->SetFamilyCodePage(WindowsCodePageFromCodePage(CODEPAGE(ulData))));
        }
        break;

    case NTYPE_END_PARSE:
        pMarkup->SetLoaded(TRUE);
        break;

    case NTYPE_ELEMENT_ENTERVIEW_1:
        // Inherit media property from our master
        if (HasMasterPtr())
        {
            CElement *pMasterElem = GetMasterPtr();
            CMarkup  *pMasterMarkup = pMasterElem->GetMarkup();
            CMarkup  *pMarkup = GetMarkup();
            mediaType mtMasterMarkup;

            Assert( pMasterMarkup && pMarkup );

            mtMasterMarkup = pMasterMarkup->GetMedia();

            // Only inherit if the master has a media set.
            if ( mtMasterMarkup != mediaTypeNotSet )
                pMarkup->SetMedia( mtMasterMarkup );
        }
        break;
    }
    return;
}

HRESULT
CRootElement::ComputeFormatsVirtual(CFormatInfo * pCFI, CTreeNode * pNodeTarget FCCOMMA FORMAT_CONTEXT FCPARAM )
{
    BOOL fParentFrameHidden      = FALSE;   
    BOOL fParentFrameDisplayNone = FALSE;              
    BOOL fInheritEditableFalse   = FALSE;
    BOOL fParentEditable         = IsDesignMode();

    if (HasMasterPtr())
    {
        CElement *          pElemMaster = GetMasterPtr();        
        ELEMENT_TAG         etag        = pElemMaster->TagType();

        fInheritEditableFalse = (etag==ETAG_GENERIC) || (etag==ETAG_FRAME) || (etag==ETAG_IFRAME);                 
        fParentEditable = pElemMaster->IsEditable(/*fCheckContainerOnly*/TRUE);        

        if (etag == ETAG_IFRAME || etag == ETAG_FRAME)
        {
            fParentFrameHidden      = pElemMaster->IsVisibilityHidden();  
            fParentFrameDisplayNone = pElemMaster->IsDisplayNone();                  
        }            

        if (pElemMaster->IsInMarkup())
        {
            CDefaults *pDefaults = pElemMaster->GetDefaults();                 
        
            if (    (!pDefaults && pElemMaster->TagType() == ETAG_GENERIC)
                ||  (pDefaults && pDefaults->GetAAviewInheritStyle())
                ||  pElemMaster->Tag() == ETAG_INPUT)
            {
                return super::ComputeFormatsVirtual(pCFI, pNodeTarget FCCOMMA FCPARAM);
            }          
        }       
    }

    SwitchesBegTimer(SWITCHES_TIMER_COMPUTEFORMATS);

    CDoc *       pDoc = Doc();
    THREADSTATE *pts = GetThreadState();
    CColorValue  cv;
    COLORREF     cr;
    HRESULT      hr = S_OK;
    CMarkup *   pMarkup = GetMarkup();
    BOOL        fEditable;

    Assert(pCFI);
    Assert(SameScope( this, pNodeTarget));
#ifdef MULTI_FORMAT    
    Assert(   pCFI->_eExtraValues != ComputeFormatsType_Normal 
           || (    !pNodeTarget->HasFormatAry()
                && IS_FC(FCPARAM)
              )
           || (   (    pNodeTarget->GetICF(FCPARAM) == -1 
                    && pNodeTarget->GetIPF(FCPARAM) == -1
                  ) 
               || pNodeTarget->GetIFF(FCPARAM) == -1
              )
          );
#else
    Assert(   pCFI->_eExtraValues != ComputeFormatsType_Normal 
           || (   (    pNodeTarget->GetICF(FCPARAM) == -1 
                    && pNodeTarget->GetIPF(FCPARAM) == -1
                  ) 
               || pNodeTarget->GetIFF(FCPARAM) == -1
              )
          );
#endif //MULTI_FORMAT

    AssertSz(!TLS(fInInitAttrBag), "Trying to compute formats during InitAttrBag! This is bogus and must be corrected!");

    pCFI->Reset();
    pCFI->_pNodeContext = pNodeTarget;

    //
    // Setup Char Format
    //
    
    if (!pMarkup->_fDefaultCharFormatCached)
    {
        hr = THR(pMarkup->CacheDefaultCharFormat());
        if (hr)
            goto Cleanup;
    }

    if (pMarkup->_fHasDefaultCharFormat)
    {
        pCFI->_icfSrc = pMarkup->GetDefaultCharFormatIndex();
        pCFI->_pcfSrc = pCFI->_pcf = &(*pts->_pCharFormatCache)[pCFI->_icfSrc];
    }
    else
    {
        pCFI->_icfSrc = pDoc->_icfDefault;
        pCFI->_pcfSrc = pCFI->_pcf = pDoc->_pcfDefault;
    }
   
    if (pMarkup->_fInheritDesignMode) 
    {        
        if (fInheritEditableFalse)
        {
            fEditable = FALSE;
        }
        else
        {
            fEditable = fParentEditable;
        }
    } 
    else
    {
        fEditable = IsDesignMode();
    }

    if (pCFI->_pcf->_fEditable != fEditable)
    {
        pCFI->PrepareCharFormat();
        pCFI->_cf()._fEditable = fEditable;
        pCFI->UnprepareForDebug();
    }

    //
    // Setup Para Format
    //

    pCFI->_ipfSrc = pts->_ipfDefault;
    pCFI->_ppfSrc = pCFI->_ppf = pts->_ppfDefault;

    //
    // Setup Fancy Format
    //

    pCFI->_iffSrc = pts->_iffDefault;
    pCFI->_pffSrc = pCFI->_pff = pts->_pffDefault;
    
    if (fParentFrameHidden)
    {
        pCFI->PrepareCharFormat();
        pCFI->_cf()._fVisibilityHidden = TRUE;
        pCFI->UnprepareForDebug();
    }

    if (fParentFrameDisplayNone)
    {
        pCFI->PrepareCharFormat();
        pCFI->_cf()._fDisplayNone = TRUE;
        pCFI->UnprepareForDebug();
    }

    // TODO (JHarding): Per stress bug 90174, we think we have a window
    // here, but we really don't, so adding extra protection.
    // NB: (jbeda) I checked this out and it looks kosher.
    if (IsInMarkup() && GetMarkup()->HasWindow() && GetMarkup()->HasWindow() )
    {
        cv = GetMarkup()->Document()->GetAAbgColor();
    }

    if (cv.IsDefined())
        cr = cv.GetColorRef();
    else
        cr = pDoc->_pOptionSettings->crBack();

    if (   !pCFI->_pff->_ccvBackColor.IsDefined() 
        ||  pCFI->_pff->_ccvBackColor.GetColorRef() != cr)
    {
        pCFI->PrepareFancyFormat();
        pCFI->_ff()._ccvBackColor = cr;
        pCFI->UnprepareForDebug();
    }

    Assert(pCFI->_pff->_ccvBackColor.IsDefined());

    if(pCFI->_eExtraValues == ComputeFormatsType_Normal)
    {
        hr = THR(pNodeTarget->CacheNewFormats(pCFI FCCOMMA FCPARAM ));
        if (hr)
            goto Cleanup;

        // If the markup codepage is Hebrew visual order, set the flag.
        GetMarkup()->_fVisualOrder = (GetMarkup()->GetCodePage() == CP_ISO_8859_8);
    }

Cleanup:

    SwitchesEndTimer(SWITCHES_TIMER_COMPUTEFORMATS);

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CRootElement::YieldCurrency
//
//  Synopsis:
//
//----------------------------------------------------------------------------

HRESULT
CRootElement::YieldCurrency(CElement *pElemNew)
{
    return super::YieldCurrency( pElemNew );
}

//+---------------------------------------------------------------------------
//
//  Member:     CRootElement::YieldUI
//
//  Synopsis:
//
//----------------------------------------------------------------------------

void
CRootElement::YieldUI(CElement *pElemNew)
{
    // Note: We call Doc()->RemoveUI() if an embedded control
    // calls IOIPF::SetBorderSpace or IOIPF::SetMenu with non-null
    // values.

    Doc()->ShowUIActiveBorder(FALSE);
}


//+---------------------------------------------------------------------------
//
//  Member:     CRootElement::BecomeUIActive
//
//  Synopsis:
//
//----------------------------------------------------------------------------

HRESULT
CRootElement::BecomeUIActive()
{
    HRESULT hr = S_OK;
    CDoc *pDoc = Doc();

    // Nothing to do?

    // if the doc is not currently UIActive but a UIActive site exists, allow the
    // doc to go into UIACTIVE state.
    if (!pDoc->InPlace())
    {
        return E_FAIL;
    }

    if (    pDoc->_pElemUIActive == this 
        &&  GetFocus() == pDoc->InPlace()->_hwnd
        &&  pDoc->State() >= OS_UIACTIVE)
    {
        return S_OK;
    }

    // Tell the document that we are now the UI active site.
    // This will deactivate the current UI active site.

    hr = THR(pDoc->SetUIActiveElement(this));
    if (hr || pDoc->State() < OS_UIACTIVE)
        goto Cleanup;

    if (!pDoc->_pInPlace->_fDeactivating)
    {
        // We're now the UI active object, so tell the frame that.

        IGNORE_HR(pDoc->SetActiveObject());

#ifndef NO_OLEUI
        // Get our menus and toolbars up.

        IGNORE_HR(pDoc->InstallUI(FALSE));

        // If appropriate, show our grab handles.

        if (    !pDoc->_fMsoDocMode 
           &&   !pDoc->_fInWindowsXP_HSS 
           &&   (   pDoc->GetAmbientBool(DISPID_AMBIENT_SHOWHATCHING, TRUE)
                ||  pDoc->GetAmbientBool(DISPID_AMBIENT_SHOWGRABHANDLES, TRUE)))
        {
            pDoc->ShowUIActiveBorder(TRUE);
        }
#endif // NO_OLEUI
    }

Cleanup:
    RRETURN(hr);
}

//+-------------------------------------------------------------------
//
//  Method:     CRootElement::QueryStatusUndoRedo
//
//  Synopsis:   Helper function for QueryStatus(). Check if in our current
//              state we suport these commands.
//
//--------------------------------------------------------------------

#ifndef NO_EDIT
HRESULT
CRootElement::QueryStatusUndoRedo(
        BOOL fUndo,
        MSOCMD * pcmd,
        MSOCMDTEXT * pcmdtext)
{
    BSTR        bstr = NULL;
    HRESULT     hr;

    // Get the Undo/Redo state.
    if (fUndo)
        hr = THR_NOTRACE(Doc()->_pUndoMgr->GetLastUndoDescription(&bstr));
    else
        hr = THR_NOTRACE(Doc()->_pUndoMgr->GetLastRedoDescription(&bstr));

    // Return the command state.
    pcmd->cmdf = hr ? MSOCMDSTATE_DISABLED : MSOCMDSTATE_UP;

    // Return the command text if requested.
    if (pcmdtext && pcmdtext->cmdtextf == MSOCMDTEXTF_NAME)
    {


#if !defined(_MAC)
        if (hr)
        {
            pcmdtext->cwActual = LoadString(
                    GetResourceHInst(),
                    fUndo ? IDS_CANTUNDO : IDS_CANTREDO,
                    pcmdtext->rgwz,
                    pcmdtext->cwBuf);
        }
        else
        {
            hr = Format(
                    0,
                    pcmdtext->rgwz,
                    pcmdtext->cwBuf,
                    MAKEINTRESOURCE(fUndo ? IDS_UNDO : IDS_REDO),
                    bstr);
            if (!hr)
                pcmdtext->cwActual = _tcslen(pcmdtext->rgwz);
        }
#endif
    }

    if (bstr)
        FormsFreeString(bstr);

    return S_OK;
}
#endif // NO_EDIT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\saver.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996.
//
//  File:       Saver.cxx
//
//  Contents:   Object to save to a stream
//
//  Class:      CTreeSaver
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_HTMTAGS_HXX_
#define X_HTMTAGS_HXX_
#include "htmtags.hxx"
#endif

#ifndef X_SAVER_HXX_
#define X_SAVER_HXX_
#include "saver.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include <treepos.hxx>
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#ifndef X__TEXT_H_
#define X__TEXT_H_
#include "_text.h"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X_COMMENT_HXX_
#define X_COMMENT_HXX_
#include "comment.hxx"
#endif

#ifndef X_WCHDEFS_H_
#define X_WCHDEFS_H_
#include "wchdefs.h"
#endif

#ifndef X_PEER_HXX_
#define X_PEER_HXX_
#include "peer.hxx"
#endif


MtDefine(CTreeSaver, Locals, "CTreeSaver")

//+---------------------------------------------------------------
//
//  Member:     CTreeSaver constructor from element
//
//  Synopsis:   Construct a range saver object for saving everything
//              under a specified element.  This is the normal case.
//
//---------------------------------------------------------------

CTreeSaver::CTreeSaver(CElement* pelToSave, CStreamWriteBuff * pswb, CElement * pelContainer /* = NULL */) :
        _mpStart( pelToSave->GetDocPtr() ), _mpEnd( pelToSave->GetDocPtr() )
{
    CTreePos * ptpStart, * ptpEnd;

    _pMarkup        = pelToSave->GetMarkup();

    pelToSave->GetTreeExtent( & ptpStart, & ptpEnd );

    Assert( ptpStart && ptpEnd );

    Verify( ! _tpgStart.MoveTo( ptpStart, TPG_RIGHT ) );
    Verify( ! _tpgEnd.MoveTo( ptpEnd, TPG_LEFT ) );
    Verify( ! _tpgEnd.MoveLeft( TPG_VALIDGAP | TPG_OKNOTTOMOVE ) );

    _pelFragment  = pelToSave;
    _pswb         = pswb;
    _fSymmetrical = FALSE;
    _fLBStartLeft = FALSE;
    _fSaveTextFrag= FALSE;
    _fLBEndLeft   = !!LineBreakChar( &_tpgEnd );
    _pelContainer = pelContainer;

    _mpStart.SetGravity( POINTER_GRAVITY_Left );
    _mpEnd.SetGravity( POINTER_GRAVITY_Right );
}


//+----------------------------------------------------------------------------
//  
//  Method:     CTreeSaver
//  
//  Synopsis:   Constructor from markup.  Only used by range saver
//  
//+----------------------------------------------------------------------------

CTreeSaver::CTreeSaver( CMarkup * pMarkup ) : 
    _mpStart( pMarkup->Doc() ), _mpEnd( pMarkup->Doc() )
{ 
    _fSaveTextFrag = FALSE; 
    _mpStart.SetGravity(POINTER_GRAVITY_Left); 
    _mpEnd.SetGravity(POINTER_GRAVITY_Right);
}

//+---------------------------------------------------------------
//
//  Member:     CTreeSaver::Save
//
//  Synopsis:   Dump our guts to the stream _pswb.
//
//---------------------------------------------------------------

MtDefine(CTreeSaver_aryElements_pv, Locals, "CTreeSaver::Save aryElements::_pv");
HRESULT
CTreeSaver::Save()
{
    HRESULT     hr = S_OK;
    CTreePos *  ptpWalk, * ptpAfterEnd, *ptpEnd, *ptpNext;
    CElement *  pelPendingForce = NULL;
    CElement *  pel;
    BOOL        fSelectionEndSaved = FALSE;
    BOOL        fSuppressingPrettyCRLF = FALSE;
    BOOL        fSeenContent = FALSE;
    MarkupTextFrag *ptf = NULL;
    long            ctf = 0;

    Assert( _tpgStart.Branch()->SearchBranchToRootForScope( _pelFragment ) );
    Assert( _tpgEnd.Branch()->SearchBranchToRootForScope( _pelFragment ) );

    if (_pelFragment && _pelFragment->Doc()->_fContentSavePeersPossible)
    {
        hr = THR( SaveGapsToPointers() );
        if( hr )
            goto Cleanup;

        hr = THR(CPeerHolder::ContentSavePass(this, _pswb->TestFlag(WBF_SAVE_PLAINTEXT)));
        if (hr)
            goto Cleanup;

        hr = THR( RestoreGapsFromPointers() );
        if( hr )
            goto Cleanup;
    }

    // If we are saving out text frags, then we must be starting at the beginning of the 
    // markup.  To change this later, we would need to search in the text frag list to
    // find the correct place to start.
    Assert( !_fSaveTextFrag || _tpgStart.AdjacentTreePos( TPG_LEFT ) == _pMarkup->FirstTreePos() );

    //
    // Initialize saver state
    //

    _pelLastBlockScope = NULL;
    _fPendingNBSP      = FALSE;

    if(     _fSaveTextFrag 
        &&  _pMarkup->HasTextFragContext() 
        &&  ! _pswb->TestFlag(WBF_SAVE_PLAINTEXT)
        &&  ! _pswb->TestFlag(WBF_FOR_RTF_CONV) )
    {
        CMarkupTextFragContext * ptfc = _pMarkup->GetTextFragContext();

        Assert( ptfc );

        ctf = ptfc->_aryMarkupTextFrag.Size();
        ptf = ptfc->_aryMarkupTextFrag;
    }

    //
    // If we are symmetrical then we want to save begin tags
    // from under the _pelFragment down to the node above _ptpStart
    //

    if( _fSymmetrical )
    {
        CTreeNode * pNodeCur = _tpgStart.Branch();
        CStackPtrAry<CElement *, 16> aryBeginElements(Mt(CTreeSaver_aryElements_pv));

        for( ; pNodeCur->Element() != _pelFragment; pNodeCur = pNodeCur->Parent() )
        {
            hr = THR( aryBeginElements.Append( pNodeCur->Element() ) );
            if (hr)
                goto Cleanup;
        }
        
        {
            int iElement = aryBeginElements.Size() - 1;

            while( iElement >= 0 )
            {
                hr = THR( SaveElement( aryBeginElements[iElement--], FALSE) );
                if (hr)
                    goto Cleanup;
            }
        }
    }

    //
    // Tell any derived classes that the selection is started
    //
    hr = THR( SaveSelection( FALSE ) );
    if (hr)
        goto Cleanup;

    // Start supressing all pretty CRLF until
    // we output real content (BUG 3844)
    if (!_pswb->TestFlag(WBF_NO_PRETTY_CRLF))
    {
        _pswb->SetFlags(WBF_NO_PRETTY_CRLF);
        fSuppressingPrettyCRLF = TRUE;
    }

    //
    // Handle any leading block breaks
    //
    if(     ! _fLBStartLeft 
        &&  _pswb->TestFlag(WBF_SAVE_PLAINTEXT)
        &&  LineBreakChar( &_tpgStart ) & BREAK_BLOCK_BREAK )
    {
        hr = THR(_pswb->NewLine());
        if (hr)
            goto Cleanup;
    }

    //
    // Walk the tree and save out tags and text
    //
    ptpEnd      = _tpgEnd.AdjacentTreePos( TPG_LEFT );
    ptpAfterEnd = _tpgEnd.AdjacentTreePos( TPG_RIGHT );

    for( ptpWalk = _tpgStart.AdjacentTreePos( TPG_RIGHT );
         ptpWalk != ptpAfterEnd;
         ptpWalk = ptpNext )
    {
        // Make sure we haven't somehow passed the top of our text frag list
        Assert( ctf <= 0 || ptpWalk->InternalCompare(ptf->_ptpTextFrag) != 1 );

        ptpNext = ptpWalk->NextTreePos();

        switch( ptpWalk->Type() )
        {
        case CTreePos::Pointer:
            if( ctf > 0 && ptpWalk == ptf->_ptpTextFrag )
            {
                // Write out the text frag...
                DWORD dwOldFlags = _pswb->ClearFlags(WBF_ENTITYREF);
                _pswb->SetFlags(WBF_SAVE_VERBATIM | WBF_NO_WRAP);
                _pswb->BeginPre();

                hr = THR(_pswb->Write(ptf->_pchTextFrag));

                _pswb->EndPre();
                _pswb->RestoreFlags(dwOldFlags);

                if (hr)
                    goto Cleanup;

                ctf--;
                ptf++;

                fSeenContent = TRUE;
            }
            break;
        case CTreePos::Text:
            if( ptpWalk->Cch() && pelPendingForce )
            {
                hr = THR( ForceClose( pelPendingForce ) );
                if (hr)
                    goto Cleanup;

                pelPendingForce = NULL;
            }

            hr = THR( SaveTextPos( ptpWalk ) );
            if (hr)
                goto Cleanup;

            fSeenContent = TRUE;

            break;
        case CTreePos::NodeBeg:
            if (!ptpWalk->IsEdgeScope())
                break;

            if(     pelPendingForce 
                &&  !TagProhibitedContainer( ptpWalk->Branch()->Tag(), 
                                             pelPendingForce->Tag() ) )
            {
                hr = THR( ForceClose( pelPendingForce ) );
                if (hr)
                    goto Cleanup;
            }

            pelPendingForce = NULL;

            hr = THR( SaveElement( ptpWalk->Branch()->Element(), FALSE ) );
            if (hr)
                goto Cleanup;

            fSeenContent = TRUE;

            break;
        case CTreePos::NodeEnd:
            if (!ptpWalk->IsEdgeScope())
                break;

            pel = ptpWalk->Branch()->Element();

            if( pel->HasFlag(TAGDESC_DONTSAVEAFTERIMPEND) && 
                !pel->_fExplicitEndTag )
                goto Cleanup;

            if(     pelPendingForce
                &&  !TagEndContainer( pel->Tag(),
                                      pelPendingForce->Tag() ) )
            {
                hr = THR( ForceClose( pelPendingForce ) );
                if (hr)
                    goto Cleanup;
            }

            pelPendingForce = pel;

            hr = THR( SaveElement( pel, TRUE ) );
            if (hr)
                goto Cleanup;

            fSeenContent = TRUE;

            break;
        }

        if ( fSuppressingPrettyCRLF && fSeenContent )
        {
            _pswb->ClearFlags(WBF_NO_PRETTY_CRLF);
            fSuppressingPrettyCRLF = FALSE;
        }


        // Handle any LB at this gap, but not if we are at the end
        // and the LB is not to the left
        if( _fLBEndLeft || ptpWalk != ptpEnd )
        {
            CTreePosGap tpgLB( ptpNext, TPG_LEFT );

            DWORD dwBreaks = LineBreakChar( &tpgLB );

            if( dwBreaks )
            {
                // To IE4, this looks like text so
                // write out the end tag
                if( pelPendingForce )
                {
                    hr = THR( ForceClose( pelPendingForce ) );
                    if (hr)
                        goto Cleanup;

                    pelPendingForce = NULL;
                }

                if(     _pswb->TestFlag(WBF_SAVE_PLAINTEXT)
                    &&  dwBreaks & BREAK_BLOCK_BREAK )
                {

                    hr = THR(_pswb->NewLine());
                    if (hr)
                        goto Cleanup;
                }

                // In IE4, anything besides BB and LB would
                // cause us to clear _fPendingNBSP
                if (dwBreaks & ~( BREAK_BLOCK_BREAK | BREAK_LINE_BREAK ))
                    _fPendingNBSP = FALSE;
            }
        } // LB Check

    }

    if ( fSuppressingPrettyCRLF )
    {
        _pswb->ClearFlags(WBF_NO_PRETTY_CRLF);
        fSuppressingPrettyCRLF = FALSE;
    }

    if (!pelPendingForce)
    {
        hr = THR( SaveSelection( TRUE ) );
        if (hr)
            goto Cleanup;

        fSelectionEndSaved = TRUE;
    }

    //
    // If we are symmetrical, then save out all the end tags starting
    // from above the end gap to _pelFragment
    //
     
    if( _fSymmetrical )
    {
        CTreeNode * pNodeCur = _tpgEnd.Branch();

        for( ; pNodeCur->Element() != _pelFragment ; pNodeCur = pNodeCur->Parent() )
        {
            CElement * pElementCur = pNodeCur->Element();

            if(     pelPendingForce
                &&  !TagEndContainer( pElementCur->Tag(),
                                      pelPendingForce->Tag() ) )
            {
                hr = THR( ForceClose( pelPendingForce ) );
                if (hr)
                    goto Cleanup;
            }

            if (!fSelectionEndSaved)
            {
                hr = THR( SaveSelection( TRUE ) );
                if (hr)
                    goto Cleanup;

                fSelectionEndSaved = TRUE;
            }

            pelPendingForce = pElementCur;

            hr = THR( SaveElement( pElementCur, TRUE ) );
            if (hr)
                goto Cleanup;
        }
    }

    //
    // Force the save of any pending close tag.
    //

    if (pelPendingForce)
    {
        hr = THR( ForceClose( pelPendingForce ) );
        if (hr)
            goto Cleanup;

        if (!fSelectionEndSaved)
        {
            hr = THR( SaveSelection( TRUE ) );
            if (hr)
                goto Cleanup;

            fSelectionEndSaved = TRUE;
        }
    }

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------
//
//  Member:     CTreeSaver::SaveElement
//
//  Synopsis:   Open and close tags.
//
//---------------------------------------------------------------

HRESULT
CTreeSaver::SaveElement(CElement * pel, BOOL fEnd)
{
    HRESULT    hr;
    BOOL       fPersistWhitespacePre;

    if (fEnd)
    {
        if (_fPendingNBSP && pel == _pelLastBlockScope)
        {
            if (!_pswb->TestFlag(WBF_SAVE_PLAINTEXT))
            {
                TCHAR ch = TCHAR(160);          // &nbsp;
                hr = _pswb->Write(&ch, 1);
                if (hr)
                    goto Cleanup;
            }

            _fPendingNBSP = FALSE;
        }
    }
    else
    {
        // TODO: perhaps we should is IsBlockElement()
        if (pel->HasFlag(TAGDESC_BLOCKELEMENT))
        {
            // Remember the last block element which came into scope
            _pelLastBlockScope = pel;

            // We may have to write an nbsp if this block element has
            // break on empty set (the bit will get cleared in the event
            // that we see a non-empty run before closing).
            _fPendingNBSP = _pelLastBlockScope->_fBreakOnEmpty &&
                _pelLastBlockScope->HasFlag(TAGDESC_SAVENBSPIFEMPTY);
        }
    }

    fPersistWhitespacePre = _pMarkup->SupportsCollapsedWhitespace() 
                            && pel->GetFirstBranch()->IsPre();
    
    if (!fEnd && fPersistWhitespacePre)
        _pswb->BeginPre();

    hr = pel->Save(_pswb, fEnd);

    if (fEnd && fPersistWhitespacePre)
        _pswb->EndPre();


Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------
//
//  Member:     CTreeSaver::SaveTextPos
//
//  Synopsis:   Write out the entire text pos.
//
//---------------------------------------------------------------
HRESULT
CTreeSaver::SaveTextPos(CTreePos *ptp)
{
    Assert( ptp->IsText() );

    HRESULT hr = S_OK;
    LONG    cpStart  = ptp->GetCp();
    LONG    cchTotal = ptp->Cch();

    Assert( cpStart >= 0 );
    Assert( cchTotal >= 0 );

    if( cchTotal > 0 )
    {
        CTxtPtr tp(_pMarkup, cpStart );

        DWORD dwOldFlags;
        dwOldFlags = _pswb->SetFlags(WBF_NO_DQ_ENTITY); // IE5 bug 26812
        
        while (cchTotal > 0)
        {
            long            cch;
            const TCHAR *   pch = tp.GetPch(cch);  // sets cch

            if(!pch || cch == 0 )
                break;

            cch = min(cchTotal, cch);

            hr = _pswb->Write(pch, cch);
            if (hr)
                goto Cleanup;

            cchTotal -= cch;
            tp.AdvanceCp(cch);
            Assert( cch );

            Assert( cchTotal >= 0 );
        }

        _fPendingNBSP = FALSE;
        
Cleanup:

        _pswb->RestoreFlags(dwOldFlags);
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------
//
//  Helper:     CTreeSaver::ForceClose
//
//  Synopsis:   Writes a close tag for the specified element if
//              the tag can have an end and it hasn't already been
//              written.
//
//---------------------------------------------------------------

HRESULT
CTreeSaver::ForceClose ( CElement * pel )
{
    HRESULT hr = S_OK;

    if (!pel->_fExplicitEndTag)
    {
        BOOL fHasNoEndTag = TagHasNoEndTag( pel->Tag() );

        if (pel->Tag() == ETAG_COMMENT && DYNCAST( CCommentElement, pel )->_fAtomic)
            fHasNoEndTag = TRUE;

        if (!fHasNoEndTag && !pel->HasFlag( TAGDESC_SAVEALWAYSEND ))
            hr = pel->WriteTag(_pswb, TRUE, TRUE);
    }

    return hr;
}

//+---------------------------------------------------------------
//
//  IE4 Compat helpers
//
//---------------------------------------------------------------

// simulates the IE4 CTxtEdit::IsElementBlockInContext
BOOL 
CTreeSaver::IsElementBlockInContainer( CElement * pElement )
{
    Assert( pElement );

    if (pElement->IsBlockElement())
        return TRUE;

    if (pElement->Tag() == ETAG_ROOT)
        return TRUE;

    if (    pElement->HasFlowLayout()
        &&  pElement->GetFlowLayout()->GetContentMarkup() == _pMarkup )
        return TRUE;

    // TODO: what about text slaves?  Should we see if pElementContainer
    // has a flow layout and compare against it's content element?
    if( pElement == _pelContainer )
        return TRUE;
    
    return FALSE;
}

DWORD
CTreeSaver::LineBreakChar( CTreePosGap * ptpg )
{
    DWORD      dwBreaks = BREAK_NONE;
    CTreePos * ptpRight = ptpg->AdjacentTreePos( TPG_RIGHT );
    CTreePos * ptpLeft = ptpg->AdjacentTreePos( TPG_LEFT );
    CElement * pElement;

    // If we have an end node to the right and 
    // we don't have an end non edge to the left, then
    // we are at the beginning of an inclusion and
    // we go with it...
    if (    ptpRight->IsEndNode() 
        &&  !(  ptpLeft->IsEndNode() 
            &&  !ptpLeft->IsEdgeScope() ))
    {
        while( ! ptpRight->IsEndElementScope() )
            ptpRight = ptpRight->NextTreePos();
    }
    else if (!ptpRight->IsBeginElementScope())
        return dwBreaks;

    pElement = ptpRight->Branch()->Element();

    if( ptpRight->IsEndElementScope() )
    {
        // [TSE] at the end of text sites
        // [BB] at the end of block elements
        IGNORE_HR( _breaker.QueryBreaks( ptpg, & dwBreaks ) );

        // no scope elements (BR, IMG, etc.)
        if(     pElement->IsNoScope()
            ||  pElement->Tag() == ETAG_SELECT
            ||  pElement->Tag() == ETAG_OPTGROUP
            ||  pElement->Tag() == ETAG_OPTION)
        {
            switch( pElement->Tag() )
            {
            case ETAG_BR:
                dwBreaks |= BREAK_LINE_BREAK;
                break;
            case ETAG_WBR:
                dwBreaks |= BREAK_WORD_BREAK;
                break;
            default:
                // TODO: (jbeda) WCH_EMBEDDING/WCH_NOSCOPE?
                dwBreaks |= BREAK_NOSCOPE;
                break;
            }
        }
    }
    else if( ptpRight->IsBeginElementScope() )
    {
        // [TSB] when a new text site comes into scope
        // [BB] when a new block element comes into scope
        IGNORE_HR( _breaker.QueryBreaks( ptpg, & dwBreaks ) );
    }

    return dwBreaks;
}

// simulates the IE4 CElementRuns::ScopesLeft
BOOL 
CTreeSaver::ScopesLeftOfStart( CElement * pel )
{
    CTreePosGap     tpgCur( TPG_LEFT );

    Verify( ! tpgCur.MoveTo( &_tpgStart ) );

    Assert( tpgCur.Branch()->SearchBranchToRootForScope( pel ) );

    // If there is a LB to the left, then it
    // must scope
    if (_fLBStartLeft)
        return FALSE;

    while(  !(  tpgCur.AttachedTreePos()->IsText() 
            &&  tpgCur.AttachedTreePos()->Cch() ) )
    {
        // Check if we are about to cross that elements boundry
        if (tpgCur.AttachedTreePos()->IsBeginElementScope(pel))
            return FALSE;

        // never cross container boundries
        if(     tpgCur.AttachedTreePos()->IsNode()
            &&  tpgCur.AttachedTreePos()->IsEdgeScope()
            &&  tpgCur.AttachedTreePos()->Branch()->IsContainer() )
            return TRUE;

        // Move the gap left
        Verify( ! tpgCur.MoveLeft() );

        // Check for line break here
        if (LineBreakChar( &tpgCur ))
            break;
    }

    return TRUE;
}

// simulates the IE4 CElementRuns::ScopesRight
BOOL 
CTreeSaver::ScopesRightOfEnd( CElement * pel )
{
    CTreePosGap     tpgCur( TPG_RIGHT );
    BOOL            fLBLeft = _fLBEndLeft;

    Verify( ! tpgCur.MoveTo( &_tpgEnd ) );

    Assert( tpgCur.Branch()->SearchBranchToRootForScope( pel ) );

    while(  !(  tpgCur.AttachedTreePos()->IsText() 
            &&  tpgCur.AttachedTreePos()->Cch() ) )
    {
        // Check LB to our right
        if(     !fLBLeft 
            &&  LineBreakChar( &tpgCur ) )
            return TRUE;

        // Check edge of pel to our right
        if( tpgCur.AttachedTreePos()->IsEndElementScope(pel) )
            return FALSE;

        // never cross container boundries
        if(     tpgCur.AttachedTreePos()->IsNode()
            &&  tpgCur.AttachedTreePos()->IsEdgeScope()
            &&  tpgCur.AttachedTreePos()->Branch()->IsContainer() )
            return TRUE;

        fLBLeft = FALSE;

        Verify( ! tpgCur.MoveRight() );
    }

    return TRUE;
}


//+----------------------------------------------------------------------------
//  
//  Method:     CTreeSaver::SaveGapsToPointers
//  
//  Synopsis:   Saves our internal TreePosGaps to pointers, for when we're
//              calling out to code that can mess with the tree.
//  
//  Returns:    HRESULT 
//  
//  Arguments:
//  
//+----------------------------------------------------------------------------

HRESULT 
CTreeSaver::SaveGapsToPointers()
{
    HRESULT hr;

    Assert( _tpgStart.IsPositioned() &&
            _tpgEnd.IsPositioned() );
    // TODO (JHarding): I'd like to be able to assert _mpStart/_mpEnd are unpositioned here

    // Remember the gaps
    hr = THR( _mpStart.MoveToGap( &_tpgStart, _pMarkup, TRUE ) );
    if( hr )
        goto Cleanup;
    hr = THR( _mpEnd.MoveToGap( &_tpgEnd, _pMarkup, TRUE ) );
    if( hr )
        goto Cleanup;

    // And unposition
    _tpgStart.UnPosition();
    _tpgEnd.UnPosition();

#if DBG==1
    AssertSz( !_fHaveSavedGaps, "Trying to save gaps after already saving them" );
    _fHaveSavedGaps = TRUE;
#endif // DBG

Cleanup:
    RRETURN( hr );
}


//+----------------------------------------------------------------------------
//  
//  Method:     CTreeSaver::RestoreGapsFromPointers
//  
//  Synopsis:   Retores our interanl TreePosGaps from our saved pointers, 
//              after calling dangerous code
//  
//  Returns:    HRESULT 
//  
//  Arguments:
//  
//+----------------------------------------------------------------------------

HRESULT 
CTreeSaver::RestoreGapsFromPointers()
{
    HRESULT hr;

    Assert( !_tpgStart.IsPositioned() &&
            !_tpgEnd.IsPositioned() &&
            _mpStart.IsPositioned() &&
            _mpEnd.IsPositioned() );

    Assert( !_mpEnd.IsLeftOf( &_mpStart ) );

    if( !_mpStart.GetEmbeddedTreePos() ||
        !_mpEnd.GetEmbeddedTreePos() )
    {
        return E_FAIL;
    }

    // Replace the gaps
    hr = THR( _tpgStart.MoveTo(_mpStart.GetEmbeddedTreePos(), TPG_RIGHT ) );
    if( hr )
        goto Cleanup;
    _tpgStart.SetAttachPreference( TPG_LEFT );
    hr = THR( _tpgStart.MoveLeft( TPG_OKNOTTOMOVE | TPG_SKIPPOINTERS ) );
    if( hr )
        goto Cleanup;
    hr = THR( _tpgEnd.MoveTo(_mpEnd.GetEmbeddedTreePos(), TPG_LEFT ) );
    if( hr )
        goto Cleanup;
    _tpgEnd.SetAttachPreference( TPG_RIGHT );
    hr = THR( _tpgEnd.MoveRight( TPG_OKNOTTOMOVE | TPG_SKIPPOINTERS ) );
    if( hr )
        goto Cleanup;

    // TODO (JHarding): I'd like to be able to unposition _mpStart/_mpEnd here.

#if DBG==1
    AssertSz( _fHaveSavedGaps, "Trying to restore gaps without ever saving them" );
    _fHaveSavedGaps = FALSE;
#endif // DBG

Cleanup:
    RRETURN( hr );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\scollect.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       scollect.cxx
//
//  Contents:   Implementation of CScriptCollection class
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_SCRIPT_HXX_
#define X_SCRIPT_HXX_
#include "script.hxx"
#endif

#ifndef X_COLLECT_HXX_
#define X_COLLECT_HXX_
#include "collect.hxx"
#endif

#ifndef X_SAFETY_HXX_
#define X_SAFETY_HXX_
#include "safety.hxx"
#endif

#ifndef X_SHOLDER_HXX_
#define X_SHOLDER_HXX_
#include "sholder.hxx"
#endif

#ifndef X_ESCRIPT_HXX_
#define X_ESCRIPT_HXX_
#include "escript.hxx"
#endif

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx"
#endif

#ifndef X_HTC_HXX_
#define X_HTC_HXX_
#include "htc.hxx"
#endif

#ifndef X_HEDELEMS_HXX_
#define X_HEDELEMS_HXX_
#include "hedelems.hxx"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_UWININET_H_
#define X_UWININET_H_
#include "uwininet.h"
#endif

#ifndef X_DEBUGGER_HXX_
#define X_DEBUGGER_HXX_
#include "debugger.hxx"
#endif

#define MAX_PROGID_LENGTH 39

MtDefine(CScriptCollection, ObjectModel, "CScriptCollection")
MtDefine(CScriptCollection_aryHolder_pv, CScriptCollection, "CScriptCollection::_aryHolder::_pv")
MtDefine(CScriptCollection_aryCloneHolder_pv, CScriptCollection, "CScriptCollection::_aryCloneHolder::_pv")
MtDefine(CScriptCollection_aryNamedItems_pv, CScriptCollection, "CScriptCollection::_aryNamedItems::_pv")
MtDefine(CNamedItemsTable_CItemsArray, CScriptCollection, "CNamedItemsTable::CItemsArray")
MtDefine(CScriptCollection_CScriptMethodsArray, CScriptCollection, "CScriptCollection::CScriptMethodsArray")
MtDefine(CScriptContext, ObjectModel, "CScriptContext")

const GUID CATID_ActiveScriptParse = { 0xf0b7a1a2, 0x9847, 0x11cf, { 0x8f, 0x20, 0x0, 0x80, 0x5f, 0x2c, 0xd0, 0x64 } };

const CLSID CLSID_VBScript = {0xB54F3741, 0x5B07, 0x11CF, 0xA4, 0xB0, 0x00, 0xAA, 0x00, 0x4A, 0x55, 0xE8};
const CLSID CLSID_JScript  = {0xF414C260, 0x6AC0, 0x11CF, 0xB6, 0xD1, 0x00, 0xAA, 0x00, 0xBB, 0xBB, 0x58};

#ifndef NO_SCRIPT_DEBUGGER
interface IProcessDebugManager *g_pPDM;
interface IDebugApplication *g_pDebugApp;


static BOOL g_fScriptDebuggerInitFailed;
static DWORD g_dwAppCookie;

HRESULT InitScriptDebugging();
void DeinitScriptDebugging();
#endif

DeclareTag(tagScriptCollection, "Script Collection", "Script collection methods")
ExternTag(tagSecureScriptWindow);

//---------------------------------------------------------------------------
//
//  Function:   CLSIDFromLanguage
//
//  Synopsis:   Given name of script language, find clsid of script engine.
//
//---------------------------------------------------------------------------

HRESULT
CLSIDFromLanguage(TCHAR *pchLanguage, REFGUID catid, CLSID *pclsid)
{
    HKEY    hkey;
    HRESULT hr;
    TCHAR   achBuf[256];
    long    lResult;

    if ( _tcslen(pchLanguage)> MAX_PROGID_LENGTH)
    {
        // Progid can ONLY have no more than 39 characters.
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR(CLSIDFromProgID(pchLanguage, pclsid));
    if (hr)
        goto Cleanup;
#if !defined(WIN16) && !defined(WINCE) && !defined(_MAC)
    // Check to see that class supports required category.

    hr = THR(Format(0,
            achBuf,
            ARRAY_SIZE(achBuf),
            _T("CLSID\\<0g>\\Implemented Categories\\<1g>"),
            pclsid,
            &catid));
    if (hr)
        goto Cleanup;

    lResult = RegOpenKey(HKEY_CLASSES_ROOT, achBuf, &hkey);
    if (lResult == ERROR_SUCCESS)
    {
        RegCloseKey(hkey);
    }
    else
    {
        hr = REGDB_E_CLASSNOTREG;
        goto Cleanup;
    }
#endif // WINCE

Cleanup:
    RRETURN(hr);
}

//+--------------------------------------------------------------------------
//
//  Member:     CScriptCollection::CDebugDocumentStack constructor
//
//---------------------------------------------------------------------------

CScriptCollection::CDebugDocumentStack::CDebugDocumentStack(CScriptCollection * pScriptCollection)
{
    _pScriptCollection = pScriptCollection;
    
    //FerhanE:  This class instances are created in the stack mostly. There
    //          is a chance that the function using them will give control to the 
    //          outside (script or script engine) and cause the script engine 
    //          to be released. Since the class instances are in stack, the subref is
    //          released when the function exits. 
    _pScriptCollection->SubAddRef();

    _pDebugDocumentPrevious = pScriptCollection->_pCurrentDebugDocument;
}

//+--------------------------------------------------------------------------
//
//  Member:     CScriptCollection::CDebugDocumentStack destructor
//
//---------------------------------------------------------------------------

CScriptCollection::CDebugDocumentStack::~CDebugDocumentStack()
{
    if (_pScriptCollection->_pCurrentDebugDocument)
        _pScriptCollection->_pCurrentDebugDocument->UpdateDocumentSize();

    _pScriptCollection->_pCurrentDebugDocument = _pDebugDocumentPrevious;

    _pScriptCollection->SubRelease();
}

//+--------------------------------------------------------------------------
//
//  Function:   CScriptCollection::CScriptCollection
//
//---------------------------------------------------------------------------

CScriptCollection::CScriptCollection()
    : _aryHolder(Mt(CScriptCollection_aryHolder_pv)),
      _aryCloneHolder(Mt(CScriptCollection_aryCloneHolder_pv))
{
    _ulRefs = 1;
    _ulAllRefs = 1;
    Assert (!_fInEnginesGetDispID);
    Assert (!_fHasPendingMarkup);
}

//---------------------------------------------------------------------------
//
//  Function:   CScriptCollection::Init
//
//---------------------------------------------------------------------------

HRESULT
CScriptCollection::Init(CDoc * pDoc, COmWindowProxy * pOmWindowProxy)
{
    HRESULT hr = S_OK;

    TraceTag((tagScriptCollection, "Init"));

    MemSetName((this, "ScrptColl pDoc=%08x %ls", pDoc, pDoc->GetPrimaryUrl() ? pDoc->GetPrimaryUrl() : _T("")));

    Assert (pDoc && !_pDoc);

    _pDoc = pDoc;
    _pDoc->SubAddRef();

    _pOmWindowProxy = pOmWindowProxy;
    _pOmWindowProxy->SubAddRef();

    if(_pOmWindowProxy->Window()->_pMarkupPending)
    {
        _fHasPendingMarkup = TRUE;
    }

#ifndef NO_SCRIPT_DEBUGGER
    // Has the user has chosen to disable script debugging?
    _pDoc->UpdateFromRegistry();
    if (!_pDoc->_pOptionSettings->fDisableScriptDebugger)
    {
        // If this fails we just won't have smart host debugging
        IGNORE_HR(InitScriptDebugging());
    }
#endif

#if DBG==1
    // optionally get a secure window proxy to be given to script engine
    if (IsTagEnabled(tagSecureScriptWindow))
    {
        if (_pOmWindowProxy->_fTrusted)
        {
            IHTMLWindow2 *pw2Secured;
            hr = THR(pOmWindowProxy->SecureObject(pOmWindowProxy->Window(), &pw2Secured));
            if (!hr)
            {
                hr = pw2Secured->QueryInterface(CLSID_HTMLWindowProxy, (void**) &_pSecureWindowProxy);
                Assert(!hr);
                _pSecureWindowProxy->AddRef();
                pw2Secured->Release();
            }
        }
        else
        {
            _pSecureWindowProxy = _pOmWindowProxy;
            _pSecureWindowProxy->AddRef();
        }
    }
#endif

    RRETURN (hr);
}

//---------------------------------------------------------------------------
//
//  Function:   CScriptCollection::~CScriptCollection
//
//---------------------------------------------------------------------------

CScriptCollection::~CScriptCollection()
{
    int             c;

    _NamedItemsTable.FreeAll();

    for (c = _aryHolder.Size(); --c >= 0; )
    {
        IGNORE_HR(_aryHolder[c]->Close());
        _aryHolder[c]->Release();
    }
    _aryHolder.DeleteAll();

    for (c = _aryCloneHolder.Size(); --c >= 0; )
    {
        if (_aryCloneHolder[c] == NULL)
            continue;
        IGNORE_HR(_aryCloneHolder[c]->Close());
        _aryCloneHolder[c]->Release();
    }
    _aryCloneHolder.DeleteAll();

    _pDoc->SubRelease();
    _pOmWindowProxy->SubRelease();

#if DBG==1
    if (_pSecureWindowProxy)
        _pSecureWindowProxy->Release();
#endif
}


//---------------------------------------------------------------------------
//
//  Function:   CScriptCollection::Release
//
//  Synposis:   Per IUnknown
//
//---------------------------------------------------------------------------

ULONG
CScriptCollection::Release()
{
    ULONG ulRefs;
    if (--_ulRefs == 0)
    {
        _ulRefs = ULREF_IN_DESTRUCTOR;
        Deinit();
        _ulRefs = 0;
    }
    ulRefs = _ulRefs;
    SubRelease();
    return ulRefs;
}


//---------------------------------------------------------------------------
//
//  Method:     CScriptCollection::SubRelease
//
//---------------------------------------------------------------------------

ULONG
CScriptCollection::SubRelease()
{
#ifndef NO_SCRIPT_DEBUGGER
    if (_pDoc->_dwTID != GetCurrentThreadId())
    {
        Assert(0 && "Debugger called across thread boundary (not an MSHTML bug)");
        return TRUE;
    }
#endif //NO_SCRIPT_DEBUGGER

    if (--_ulAllRefs == 0)
    {
        _ulRefs = ULREF_IN_DESTRUCTOR;
        _ulAllRefs = ULREF_IN_DESTRUCTOR;
        delete this;
        return 0;
    }
    return _ulAllRefs;
}


//---------------------------------------------------------------------------
//
//  Function:   CScriptCollection::Deinit
//
//---------------------------------------------------------------------------

void
CScriptCollection::Deinit()
{
    TraceTag((tagScriptCollection, "Deinit"));

    //
    // Disconnect any VBScript event sinks.  Need to do this to ensure that
    // other events are not continually fired if the document is reused.
    //
    SetState(SCRIPTSTATE_DISCONNECTED);
}


CMarkup* 
CScriptCollection::GetMarkup()
{
    if(_fHasPendingMarkup && _pOmWindowProxy->Window()->_pMarkupPending)
    {
        return _pOmWindowProxy->Window()->_pMarkupPending;
    }    
    return _pOmWindowProxy->Markup();
}

//---------------------------------------------------------------------------
//
//  Function:   CScriptCollection::AddNamedItem
//
//  Synopsis:   Let script engine know about any named items that were
//              added.
//
//  Notes:      Assumed to be added with SCRIPTITEM_ISVISIBLE|SCRIPTITEM_ISSOURCE
//
//---------------------------------------------------------------------------

HRESULT
CScriptCollection::AddNamedItem(CElement *pElement)
{
    TraceTag((tagScriptCollection, "AddNamedItem"));

    HRESULT             hr = S_OK;
    CStr                cstr;
    LPTSTR              pch;
    BOOL                fDidCreate;
    CDoc *              pDoc;
    CCollectionCache *  pCollectionCache;

    Assert(pElement->Tag() == ETAG_FORM);

    pch = (LPTSTR) pElement->GetIdentifier();
    if (!pch || !*pch)
    {
        hr = THR(pElement->GetUniqueIdentifier(&cstr, TRUE, &fDidCreate));
        if (hr)
            goto Cleanup;
        pch = cstr;
        pDoc = Doc();

        pCollectionCache = pDoc->PrimaryMarkup()->CollectionCache();
        if ( fDidCreate && pCollectionCache)
            pCollectionCache->InvalidateItem(CMarkup::WINDOW_COLLECTION);
    }

    hr = THR(AddNamedItem(pch, NULL, (IUnknown*)(IPrivateUnknown*)pElement));

Cleanup:

    RRETURN(hr);
}


//---------------------------------------------------------------------------
//
//  Function:   CScriptCollection::AddNamedItem
//
//---------------------------------------------------------------------------

HRESULT
CScriptCollection::AddNamedItem(LPTSTR pchName, CScriptContext * pScriptContext, IUnknown * pUnkItem)
{
    HRESULT             hr;
    int                 c;
    CScriptHolder **    ppHolder;

    //
    // ensure name
    //

    if (!pchName)
    {
        Assert (pScriptContext);

        hr = THR(_pDoc->GetUniqueIdentifier(&pScriptContext->_cstrNamespace));
        if (hr)
            goto Cleanup;

        pchName = pScriptContext->_cstrNamespace;
    }

    //
    // register it in our table
    //

    hr = THR(_NamedItemsTable.AddItem(pchName, pUnkItem));
    if (hr)
        goto Cleanup;

    //
    // broadcast to script engines
    //

    for (c = _aryHolder.Size(), ppHolder = _aryHolder; c > 0; c--, ppHolder++)
    {
        // (do not pass in the ISVISIBLE flag.  This will break form access by name from the window collection)
        IGNORE_HR((*ppHolder)->_pScript->AddNamedItem(pchName, SCRIPTITEM_ISSOURCE));
    }

Cleanup:
    RRETURN (hr);
}

//---------------------------------------------------------------------------
//
//  Function:   CScriptCollection::SetState
//
//---------------------------------------------------------------------------

HRESULT
CScriptCollection::SetState(SCRIPTSTATE ss)
{
    TraceTag((tagScriptCollection, "SetState"));
    HRESULT hr = S_OK;
    int c;

    CDoc::CLock Lock(_pDoc);

    for (c = _aryHolder.Size(); --c >= 0; )
    {
        hr = THR(_aryHolder[c]->SetScriptState(ss));
        if (hr)
            goto Cleanup;
    }

    for (c = _aryCloneHolder.Size(); --c >= 0; )
    {
        if (_aryCloneHolder[c] == NULL)
            continue;

        hr = THR(_aryCloneHolder[c]->SetScriptState(ss));
        if (hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN(hr);
}


//---------------------------------------------------------------------------
//
//  Function:   CScriptCollection::AddHolderForObject
//
//---------------------------------------------------------------------------

HRESULT
CScriptCollection::AddHolderForObject(IActiveScript *pScript, CLSID *pClsid)
{
    TraceTag((tagScriptCollection, "AddHolderForObject"));

    HRESULT                 hr=S_OK;
    CScriptHolder *         pHolder;
    IActiveScriptParse *    pScriptParse = NULL;
    BOOL                    fRunScripts;
    IUnknown *              pUnk;

    hr = THR(GetMarkup()->ProcessURLAction(URLACTION_SCRIPT_RUN, &fRunScripts));    
    if (hr || !fRunScripts)
        goto Cleanup;
        
    // Ok for this to fail
    THR_NOTRACE(pScript->QueryInterface(
        IID_IActiveScriptParse,
        (void **)&pScriptParse));

    if (pScriptParse)
    {
        pUnk = pScriptParse;
    }
    else
    {
        pUnk = pScript;
    }
    
    if (!IsSafeToRunScripts(pClsid, pUnk))
        goto Cleanup;
        
    {
        CDoc::CLock Lock(_pDoc);

        pHolder = new CScriptHolder(this);
        if (!pHolder)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = THR(pHolder->Init(IsEqualGUID(*pClsid, CLSID_JScript), pScript, pScriptParse, pClsid));
        if (hr)
            goto Error;

        hr = THR(_aryHolder.Append(pHolder));
        if (hr)
            goto Error;
    }

Cleanup:
    ReleaseInterface(pScriptParse);
    RRETURN(hr);

Error:
    delete pHolder;
    pHolder = NULL;
    goto Cleanup;
}


//---------------------------------------------------------------------------
//
//  Method:     CScriptCollection::IsSafeToRunScripts
//
//  Synopsis:   Decide whether script engine is safe to instantiate.
//
//---------------------------------------------------------------------------

BOOL 
CScriptCollection::IsSafeToRunScripts(CLSID *pClsid, IUnknown *pUnk, BOOL fCheckScriptOverrideSafety)
{
    BOOL    fSafe = FALSE;
    HRESULT hr;
    
    // We need a clsid and an interface pointer!
    if (!pClsid || !pUnk)
        goto Cleanup;

    if (fCheckScriptOverrideSafety)
    {
        hr = THR(GetMarkup()->ProcessURLAction(
                    URLACTION_SCRIPT_OVERRIDE_SAFETY,
                    &fSafe));

        if (hr || fSafe)
            goto Cleanup;
    }

    // WINCEREVIEW - ignore script safety checking !!!!!!!!!!!!!!!!
#ifndef WINCE

    fSafe = ::IsSafeTo(
                SAFETY_SCRIPTENGINE, 
                IID_IActiveScriptParse, 
                *pClsid, 
                pUnk, 
                GetMarkup());
    if (fSafe)
        goto Cleanup;

    fSafe = ::IsSafeTo(
                SAFETY_SCRIPTENGINE, 
                IID_IActiveScript, 
                *pClsid, 
                pUnk, 
                GetMarkup());


#else // !WINCE
      // blindly say that this is safe.
    fSafe = TRUE;
#endif // !WINCE
    
Cleanup:
    return fSafe;
}


//---------------------------------------------------------------------------
//
//  Function:   CScriptCollection::GetHolderForLanguage
//
//---------------------------------------------------------------------------

HRESULT
CScriptCollection::GetHolderForLanguage(
    TCHAR *             pchLanguage,
    CMarkup *           pMarkup,
    TCHAR *             pchType,
    TCHAR *             pchCode,
    CScriptHolder **    ppHolder,
    TCHAR **            ppchCleanCode,
    CHtmlComponent *    pComponent,
    CStr *              pcstrNamespace)
{
    HRESULT     hr;
    TCHAR *     pchColon;

    // ( TODO perf(alexz) this functions shows up in perf numbers, up to 4%, on pages with lots of HTCs.
    // By hashing and caching pchLanguage, pMarkup, etc we should be able to speed it up and remove
    // the 4% from the picture )

    if (pchCode)
    {
        // check if this is a case like "javascript: alert('hello')"

        pchColon = _tcschr (pchCode, _T(':'));

        if (pchColon)
        {
            // we assume here that we can modify string at pchColon temporarily
            *pchColon = 0;

            // We shouldn't get a "fooLanguage:" w/ a type.
            Assert(!pchType || (StrCmpIC(pchCode, _T("javascript")) && StrCmpIC(pchCode, _T("vbscript")) && (pchColon-pchCode > 15)));
            hr = THR_NOTRACE(GetHolderForLanguageHelper(pchCode, pMarkup, pchType, pComponent, pcstrNamespace, ppHolder));

            *pchColon = _T(':');

            if (S_OK == hr)                         // if successful
            {
                if (ppchCleanCode)
                {
                    *ppchCleanCode = pchColon + 1;  // adjust ppchCleanCode so to skip prefix 'fooLanguage:'
                }
                goto Cleanup;                       // and nothing more to do
            }
        }
    }

    if (ppchCleanCode)
    {
        *ppchCleanCode = pchCode;
    }

    hr = THR_NOTRACE(GetHolderForLanguageHelper(pchLanguage, pMarkup, pchType, pComponent, pcstrNamespace, ppHolder));

Cleanup:

    RRETURN (hr);
}


//---------------------------------------------------------------------------
//
//  Function:   CScriptCollection::GetHolderForLanguageHelper
//
//---------------------------------------------------------------------------

HRESULT
CScriptCollection::GetHolderForLanguageHelper(
    TCHAR *             pchLanguage,
    CMarkup *           pMarkup,
    TCHAR *             pchType,
    CHtmlComponent *    pComponent,
    CStr *              pcstrNamespace,
    CScriptHolder **    ppHolder)
{
    HRESULT                 hr = S_OK;
    int                     idx = -1;
    int                     cnt;
    CLSID                   clsid;
    BOOL                    fNoClone = FALSE;
    BOOL                    fCaseSensitive = FALSE;
    IActiveScript *         pScript = NULL;
    IActiveScriptParse *    pScriptParse = NULL;
    CHtmlComponent *        pFactory = NULL;
    CMarkupScriptContext *  pMarkupScriptContext = NULL;

    // (sramani) FaultInIEFeatureHelper can throw up a dlg that can push a msg loop causing this
    // scriptcollection to be passivated. See Stress bug #105268
    Assert(_ulRefs);
    AddRef();

    Assert(ppHolder);
    *ppHolder = NULL;

    if (pComponent)
    {
        // for lightweight htc's with one script element, the component is passed in.
        Assert(pComponent && !pComponent->_fFactoryComponent);
        pFactory = pComponent->_pConstructor->_pFactoryComponent;
        Assert(pFactory && pFactory->_fLightWeight);
        
        // does htc contain only one SE?
        if (!pFactory->_fClonedScript)
        {
            // No, create engine\holder the old way but use factory markup's script context
            pFactory = NULL;
            Assert(pMarkup && pMarkup->HasScriptContext());
            pMarkupScriptContext = pMarkup->ScriptContext();
            Assert(pMarkupScriptContext);
            Assert(!pMarkupScriptContext->_fClonedScript);
        }
        else
        {
            // Yes, use this component instance's script context 
            hr = THR(pComponent->GetScriptContext((CScriptContext **)&pMarkupScriptContext));
            Assert(pMarkupScriptContext->_fClonedScript);
        }

        if (hr)
            goto Cleanup;
    }
    else if (pMarkup)
    {
        // Non-lightweight htc's and non-htc holders
        Assert(!pComponent);
        hr = THR(pMarkup->EnsureScriptContext(&pMarkupScriptContext));
        if (hr)
            goto Cleanup;

        if (pMarkup->HasBehaviorContext())
        {
            pComponent = pMarkup->BehaviorContext()->_pHtmlComponent;
            if (pComponent)
            {
                Assert(!pComponent->_fFactoryComponent);
                pFactory = pComponent->_pConstructor->_pFactoryComponent;
                Assert(pFactory && !pFactory->_fLightWeight);
                // does normal htc contain only one SE?
                if (!pFactory->_fClonedScript)
                {
                    // No, create engine\holder the old way and use this htc instance markup's script context
                    Assert(!pMarkupScriptContext->_fClonedScript);
                    pFactory = NULL;
                }
                else
                    Assert(pMarkupScriptContext->_fClonedScript); // yes, create clone
            }
        }
    }

    if (pFactory)
    {
        // Clone to be created
        Assert(pComponent);
        Assert(pFactory->_fClonedScript);
        Assert(pMarkupScriptContext);
        idx = pMarkupScriptContext->_idxDefaultScriptHolder;
        if (idx != -1)
        {
            // clone already created.
            Assert (_aryCloneHolder.Size() > idx &&
                    _aryCloneHolder[idx] &&
                    _aryCloneHolder[idx]->_pScriptParse);

            // if language of current SE being requested is not specified, then we are done as it uses the first created
            // engine (the clone) as the default, else check further down if they are different.
            if((!pchType || !*pchType) && (!pchLanguage || !*pchLanguage))
                goto Cleanup;
        }
    }

    //
    // The type attribute should be of the form:
    // text/script-type.  If it is not of this 
    // type, then it's invalid.
    // Additionally, the type attribute takes precedence
    // over the language attribute, so if it's present,
    // we use it instead.
    //
    if(pchType && *pchType)
    {
        // TODO (t-johnh): Maybe we should do a check on the
        // type attribute as a MIME type instead of checking
        // for text/fooLanguage

        // Make sure we've got text/fooLanguage
        if(!_tcsnipre(_T("text"), 4, pchType, 4))
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        // Skip to what's past the "text/"
        pchLanguage = pchType + 5;
    }
    else if (!pchLanguage || !pchLanguage[0]) // if no language nor type specified 
    {
        if (pMarkup)
        {
            AssertSz ((pMarkup->GetScriptCollection(FALSE) == this), "Script collection of markup does not match. Contact sramani if this happpens.");

            if (pMarkupScriptContext &&                                 // if default holder is indicated                      
                pMarkupScriptContext->_idxDefaultScriptHolder != -1 &&  // in the markup context
                pMarkup->GetScriptCollection(FALSE) == this)               
            {
                Assert (0 <= pMarkupScriptContext->_idxDefaultScriptHolder &&
                             pMarkupScriptContext->_idxDefaultScriptHolder < _aryHolder.Size());

                idx = pMarkupScriptContext->_idxDefaultScriptHolder;

                Assert (   _aryHolder.Size() > idx 
                        && _aryHolder[idx] 
                        && _aryHolder[idx]->_pScriptParse);

                goto Cleanup;   // done
            }
        }
        else if (!pFactory)
        {
            // pick the first script holder that supports scripting
            for (idx = 0, cnt = _aryHolder.Size(); idx < cnt; idx++)
            {
                if (_aryHolder[idx]->_pScriptParse)
                {
                    goto Cleanup;   // done
                }
            }
        }

        // if not found: there were no script holders (for scripting) created so use JavaScript as default
        pchLanguage = _T("JavaScript");
    }
    else if (0 == StrCmpIC(pchLanguage, _T("LiveScript")))
    {
        // LiveScript is the old name for JavaScript, so convert if necessary
        pchLanguage = _T("JavaScript");
    }

    //
    // Get the clsid for this language.
    //

    // Perf optimization for Win98 and Win95 to not hit the registry with
    // CLSIDFromPROGID.

    // TODO: ***TLL*** better solution is to remember
    // the language name and clsid in the script holder as a cache and check
    // in the holder first.
    if ((*pchLanguage == _T('j') || *pchLanguage == _T('J'))    &&
        (0 == StrCmpIC(pchLanguage, _T("jscript"))          ||
         0 == StrCmpIC(pchLanguage, _T("javascript"))))
    {
        clsid = CLSID_JScript;
        fCaseSensitive = TRUE;
        if (pFactory)
        {
            if (idx != -1)
            {
                // There is already a cloned SE, check to see if it is for the same language as the one being requested
                Assert (_aryCloneHolder.Size() > idx &&
                        _aryCloneHolder[idx] &&
                        _aryCloneHolder[idx]->_pScriptParse);

                if (_aryCloneHolder[idx] == NULL)
                {
                    hr = E_FAIL;
                    goto Cleanup;
                }

                if (_aryCloneHolder[idx]->_fCaseSensitive)
                    goto Cleanup; // engine matched, done
                else
                {
                    fNoClone = TRUE;
                    pFactory = NULL; // need to create new engine the old way (no clone), default is cloned engine
                }
            }
            else
            {
                // There is one only Script element, but no holder is created for it yet. Check to see if the language
                // of the SE being requested is the same as the one that will be cloned later
                Assert(pComponent && pComponent->_pConstructor);
                Assert(pFactory == pComponent->_pConstructor->_pFactoryComponent);
                Assert(pComponent->_pConstructor->_pelFactoryScript);
                LPCTSTR pchLang = pComponent->_pConstructor->_pelFactoryScript->GetAAlanguage();
                if (pchLang &&
                    (*pchLang == _T('v') || *pchLang == _T('V')) &&
                    (0 == StrCmpIC(pchLang, _T("vbs")) ||
                     0 == StrCmpIC(pchLang, _T("vbscript"))))
                {
                    // No match.
                    fNoClone = TRUE;
                    pFactory = NULL; // need to create new engine the old way (no clone), default is cloned engine
                }
            }
        }
    }
    else if ((*pchLanguage == _T('v') || *pchLanguage == _T('V'))    &&
             (0 == StrCmpIC(pchLanguage, _T("vbs"))         ||
              0 == StrCmpIC(pchLanguage, _T("vbscript"))))
    {
        clsid = CLSID_VBScript;
        if (pFactory)
        {
            if (idx != -1)
            {
                // There is already a cloned SE, check to see if it is for the same language as the one being requested
                Assert (_aryCloneHolder.Size() > idx &&
                        _aryCloneHolder[idx] &&
                        _aryCloneHolder[idx]->_pScriptParse);

                if (_aryCloneHolder[idx] == NULL)
                {
                    hr = E_FAIL;
                    goto Cleanup;
                }

                if (_aryCloneHolder[idx]->_fCaseSensitive)
                {
                    fNoClone = TRUE;
                    pFactory = NULL;  // need to create new engine the old way (no clone), default is cloned engine
                }
                else
                    goto Cleanup;  // engine matched, done
            }
            else
            {
                // There is one only Script element, but no holder is created for it yet. Check to see if the language
                // of the SE being requested is the same as the one that will be cloned later
                Assert(pComponent && pComponent->_pConstructor);
                Assert(pFactory == pComponent->_pConstructor->_pFactoryComponent);
                Assert(pComponent->_pConstructor->_pelFactoryScript);
                if (pComponent->_pConstructor->_pelFactoryScript->_fJScript)
                {
                    // No match.
                    fNoClone = TRUE;
                    pFactory = NULL; // need to create new engine the old way (no clone), default is cloned engine
                }
            }
        }
    }
    else
    {
        hr = THR(CLSIDFromLanguage(pchLanguage, CATID_ActiveScriptParse, &clsid));
        if (hr)
        {
            goto Cleanup;
        }
        if (pFactory)
        {
            BOOL fOtherScript = TRUE;

            Assert(pComponent && pComponent->_pConstructor);
            Assert(pFactory == pComponent->_pConstructor->_pFactoryComponent);
            Assert(pComponent->_pConstructor->_pelFactoryScript);

            // there is only one Script Element (js or vbs), but the current SE requested is for another
            // language, so not not clone this one as only the engine for the script element can be cloned.
            if (idx == -1 && !pComponent->_pConstructor->_pelFactoryScript->_fJScript)
            {
                LPCTSTR pchLang = pComponent->_pConstructor->_pelFactoryScript->GetAAlanguage();
                fOtherScript = (pchLang &&
                                (*pchLang == _T('v') || *pchLang == _T('V')) &&
                                (0 == StrCmpIC(pchLang, _T("vbs")) ||
                                 0 == StrCmpIC(pchLang, _T("vbscript"))));
                    
            }

            if (fOtherScript)
            {
                fNoClone = TRUE;
                pFactory = NULL;
            }
        }
    }

    //
    // Do we already have one on hand?
    //
    if (!pFactory)
    {
        if (fNoClone)
        {
            Assert(pMarkupScriptContext &&
                   pMarkupScriptContext->_fClonedScript &&
                   pMarkupScriptContext->GetNamespace());

            Assert(pComponent &&
                   !pComponent->_fFactoryComponent &&
                   pComponent->_pConstructor->_pFactoryComponent->_fClonedScript);

            // lang of current Se is different from already exisiting or to be created clone, so create a new namespace
            // if one is being requested (from ConstructCode() only)
            if (pcstrNamespace)
            {
                hr = THR(_pDoc->GetUniqueIdentifier(pcstrNamespace));
                if (hr)
                    goto Cleanup;

                hr = THR(_NamedItemsTable.AddItem(*pcstrNamespace, (IUnknown*)(IPrivateUnknown*)&(pComponent->_DD)));
                if (hr)
                    goto Cleanup;
            }
        }

        for (idx = 0, cnt = _aryHolder.Size(); idx < cnt; idx++)
        {
            if (*(_aryHolder[idx]->_pclsid) == clsid)
            {
                if (fNoClone && pcstrNamespace)
                {
                    // if a namespace was created above add it to the already created SE just found.
                    Assert((LPTSTR)*pcstrNamespace);
                    Assert(_aryHolder[idx]->_pScript);
                    hr = THR(_aryHolder[idx]->_pScript->AddNamedItem(*pcstrNamespace, SCRIPTITEM_ISVISIBLE | SCRIPTITEM_ISSOURCE));
                }

                goto Cleanup;   // done - found
            }
        }
    }

    // Create one.
    if (!pFactory || pComponent->_fFirstInstance)
    {
        if (IsEqualGUID(clsid, CLSID_VBScript))
        {
            uCLSSPEC classpec;

            classpec.tyspec = TYSPEC_CLSID;
            classpec.tagged_union.clsid = clsid;

            hr = THR(FaultInIEFeatureHelper(_pDoc->GetHWND(), &classpec, NULL, 0));

            // TODO (lmollico): should Assert(hr != S_FALSE) before we ship
            if (FAILED(hr))
            {
                hr = REGDB_E_CLASSNOTREG;
                goto Cleanup;
            }
        }

        hr = THR(CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER, IID_IActiveScript, (void **)&pScript));
        if (hr)
            goto Cleanup;

        hr = THR(pScript->QueryInterface(IID_IActiveScriptParse, (void **)&pScriptParse));
        if (hr)
            goto Cleanup;

        if (!IsSafeToRunScripts(&clsid, pScript))
        {
            hr = E_FAIL;
            goto Cleanup;
        }
    }
    
    *ppHolder = new CScriptHolder(this);
    if (!*ppHolder)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    if (!pFactory || pComponent->_fFirstInstance)
    {
        if (pFactory)
        {
            // init SE for first instance of htc. This will be the original for other instances to clone from
            Assert(pMarkupScriptContext->GetNamespace());
            (*ppHolder)->_fOriginal = TRUE;
            (*ppHolder)->_pUnkItem = (IUnknown*)(IPrivateUnknown*)&(pComponent->_DD);
            (*ppHolder)->_pUnkItem->AddRef();
        }

        // Clones need not store the classid and can share the same namespace string as each clone has a unique holder
        // and there is a 1:1 relationship between the two -- The _idxDefaultScriptHolder of the corresponding instance's
        // script context always refers to the correct clone in _aryCloneHolder
        hr = THR((*ppHolder)->Init(fCaseSensitive,
                                   pScript,
                                   pScriptParse,
                                   pFactory ? NULL : &clsid,
                                   pFactory ? pMarkupScriptContext->GetNamespace() : NULL));
    }
    else if (pFactory->_pMarkup->ScriptContext()->_idxDefaultScriptHolder != -1)
    {
        // Clone the SE from original is this htc instance is not the first one. the factory markup's _idxDefaultScriptHolder
        // stores the index of the original holder\engine in _aryCloneHolder.
        (*ppHolder)->_pUnkItem = (IUnknown*)(IPrivateUnknown*)&(pComponent->_DD);
        (*ppHolder)->_pUnkItem->AddRef();

        Assert(pFactory->_pMarkup && pFactory->_pMarkup->HasScriptContext());
        Assert(pFactory->_pMarkup->ScriptContext()->_idxDefaultScriptHolder != -1);
        hr = THR(_aryCloneHolder[pFactory->_pMarkup->ScriptContext()->_idxDefaultScriptHolder]->Clone(&clsid, *ppHolder));
    }
    else
    {
        // we are here because the original holder was n't created for some reason. So fail the clones too.
        hr = E_FAIL;
    }

    if (hr)
        goto Cleanup;

    if (pFactory)
    {
        hr = THR(_aryCloneHolder.Append(*ppHolder));
        idx = _aryCloneHolder.Size() - 1;
    }
    else
        hr = THR(_aryHolder.Append(*ppHolder));

    if (hr)
        goto Cleanup;

    Assert ((!pFactory && idx == _aryHolder.Size() - 1) || (pFactory && idx == _aryCloneHolder.Size() - 1));

Cleanup:

    // (sramani) FaultInIEFeatureHelper can throw up a dlg that can push a msg loop causing this
    // scriptcollection to be passivated. See Stress bug #105268
    if (_ulRefs == 1)
        hr = E_FAIL;

    if (S_OK == hr)
    {
        Assert (0 <= idx && ((!pFactory && idx < _aryHolder.Size()) || (pFactory && idx < _aryCloneHolder.Size())));

        (*ppHolder) = pFactory ? _aryCloneHolder[idx] : _aryHolder[idx];

        if (!fNoClone && 
            pMarkupScriptContext &&                                 // if default holder is not yet set in the
            pMarkupScriptContext->_idxDefaultScriptHolder == -1)    // markup context
        {
            pMarkupScriptContext->_idxDefaultScriptHolder = idx;
            if (pFactory && pComponent->_fFirstInstance)
            {
                // index of original script holder in factory markup script context
                Assert(pFactory->_pMarkup && pFactory->_pMarkup->HasScriptContext());
                pFactory->_pMarkup->ScriptContext()->_idxDefaultScriptHolder = idx; 
                pFactory->_fOriginalSECreated = TRUE;
            }
        }
    }
    else // if (hr)
    {
        delete *ppHolder;
        *ppHolder = NULL;
    }

    ReleaseInterface(pScript);
    ReleaseInterface(pScriptParse);

    Assert(_ulRefs);
    Release();

    RRETURN(hr);
}


//---------------------------------------------------------------------------
//
//  Function:   CScriptCollection::AddScriptlet
//
//---------------------------------------------------------------------------

HRESULT
CScriptCollection::AddScriptlet(
    LPTSTR      pchLanguage,
    CMarkup *   pMarkup,
    LPTSTR      pchType,
    LPTSTR      pchCode,
    LPTSTR      pchItemName,
    LPTSTR      pchSubItemName,
    LPTSTR      pchEventName,
    LPTSTR      pchDelimiter,
    ULONG       ulOffset,
    ULONG       ulStartingLine,
    CBase *     pSourceObject,
    DWORD       dwFlags,
    BSTR *      pbstrName,
    CHtmlComponent *pComponent)
{
    TraceTag((tagScriptCollection, "AddScriplet"));

    HRESULT                 hr = S_OK;
    CScriptHolder *         pHolder;
    CExcepInfo              ExcepInfo;
    DWORD_PTR               dwSourceContextCookie = NO_SOURCE_CONTEXT;
    TCHAR *                 pchCleanCode = NULL;
    CDebugDocumentStack     debugDocumentStack(this);
    CDoc::CLock             Lock(_pDoc);

    hr = THR(GetHolderForLanguage(pchLanguage, pMarkup, pchType, pchCode, &pHolder, &pchCleanCode, pComponent));
    if (hr)
        goto Cleanup;

    if (!pchCleanCode)
    {
        Assert (!hr);
        goto Cleanup;
    }

    Assert(pHolder->_pScriptParse);
    if(!pHolder->_pScriptParse)
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    // If the engine supports IParseProcedure then we don't need to do AddScriptlet
    // instead we'll use function pointers.
    if (pchCleanCode && !pHolder->_pParseProcedure)
    {

        hr = THR(CreateSourceContextCookie(
            pHolder->_pScript, pchCode, ulOffset, /* fScriptlet = */ TRUE, pSourceObject, dwFlags, &dwSourceContextCookie));
        if (hr)
            goto Cleanup;

        hr = THR(pHolder->_pScriptParse->AddScriptlet (
                         NULL,
                         pchCleanCode,
                         pchItemName,
                         pchSubItemName,
                         pchEventName,
                         pchDelimiter,
                         dwSourceContextCookie,
                         ulStartingLine,
                         dwFlags,
                         pbstrName,
                         &ExcepInfo));
    }

Cleanup:
    RRETURN(hr);
}

//#define COMPLUS_SCRIPTENGINES 1

#ifdef COMPLUS_SCRIPTENGINES

DeclareTag(tagComplusScriptEngines, "COMPLUS", "hook up COM+ script engines")

const CLSID CLSID_ScriptEngineHost = {0x63B38C13, 0x5D5D, 0x39AF, 0x8E, 0x24, 0xBF, 0x6B, 0xCE, 0xEF, 0x05, 0xCA};

static IDispatch * g_pdispScriptEngineHost = NULL; // TODO (alexz) (1) make this ref a member of CDoc or script collection
                                                   //              (2) release it on shutdown

//---------------------------------------------------------------------------
//
//  Function:   CorEnsureScriptEngine
//
//---------------------------------------------------------------------------

HRESULT
CorEnsureScriptEngine(CDoc * pDoc)
{
    HRESULT             hr = S_OK;
    IUnknown *          punk = NULL;
    IUnknown *          punkEngine = NULL;
    IUnknown *          punkHost = NULL;
    LPTSTR              pchInit = _T("Init");
    DISPID              dispid;
    CInvoke             invoke;

    if (g_pdispScriptEngineHost)
        goto Cleanup;

    //
    // create scriptEngineHost
    //

    hr = THR(CoCreateInstance(CLSID_ScriptEngineHost, NULL, CLSCTX_INPROC_SERVER, IID_IUnknown, (void **)&punkHost));
    if (hr)
        goto Cleanup;

    hr = THR(punkHost->QueryInterface(IID_IDispatch, (void **)&g_pdispScriptEngineHost));
    if (hr)
        goto Cleanup;

    //
    // init
    //

    hr = THR(g_pdispScriptEngineHost->GetIDsOfNames(IID_NULL, &pchInit, 1, LCID_SCRIPTING, &dispid));
    if (hr)
        goto Cleanup;
    
    hr = THR(invoke.Init(g_pdispScriptEngineHost));
    if (hr)
        goto Cleanup;

    invoke.AddArg();
    V_VT(invoke.Arg(0)) = VT_UI4;
    V_UI4(invoke.Arg(0)) = (UINT) pDoc->_pOmWindow;

    hr = THR(invoke.Invoke(dispid, DISPATCH_METHOD));
    if (hr)
        goto Cleanup;

    invoke.Clear();

    //
    // cleanup
    //

Cleanup:
    ReleaseInterface(punkHost);
    ReleaseInterface(punkEngine);
    ReleaseInterface(punk);

    RRETURN (hr);
}

//---------------------------------------------------------------------------
//
//  Function:   CorCompileScript
//
//---------------------------------------------------------------------------

HRESULT
CorCompileScript(LPTSTR pchCode)
{
    HRESULT             hr;
    DISPID              dispid;
    LPTSTR              pchExecute = _T("execute");
    CInvoke             invoke;

    //
    // call execute
    //

    hr = THR(g_pdispScriptEngineHost->GetIDsOfNames(IID_NULL, &pchExecute, 1, LCID_SCRIPTING, &dispid));
    if (hr)
        goto Cleanup;

    hr = THR(invoke.Init(g_pdispScriptEngineHost));
    if (hr)
        goto Cleanup;

    invoke.AddArg();
    V_VT(invoke.Arg(0)) = VT_BSTR;
    hr = THR(FormsAllocString(pchCode, &V_BSTR(invoke.Arg(0))));
    if (hr)
        goto Cleanup;

    hr = THR(invoke.Invoke(dispid, DISPATCH_METHOD));
    if (hr)
        goto Cleanup;

    invoke.Clear();

    //
    // cleanup
    //

Cleanup:

    RRETURN (hr);
}
#endif

//---------------------------------------------------------------------------
//
//  Function:   CScriptCollection::ParseScriptText
//
//---------------------------------------------------------------------------

HRESULT
CScriptCollection::ParseScriptText(
    LPTSTR          pchLanguage,
    CMarkup *       pScriptMarkup,  
    LPTSTR          pchType,
    LPTSTR          pchCode,
    LPTSTR          pchItemName,
    LPTSTR          pchDelimiter,
    ULONG           ulOffset,
    ULONG           ulStartingLine,
    CBase *         pSourceObject,
    DWORD           dwFlags,
    VARIANT  *      pvarResult,
    EXCEPINFO *     pexcepinfo,
    BOOL            fCommitOutOfMarkup,
    CHtmlComponent *pComponent)
{
    TraceTag((tagScriptCollection, "ParseScriptText"));

    HRESULT                 hr = S_OK;
    CScriptHolder *         pHolder;
    CMarkup *               pScriptCollectionMarkup = _pOmWindowProxy->Markup();
    DWORD_PTR               dwSourceContextCookie;
    CDebugDocumentStack     debugDocumentStack(this);

    pScriptCollectionMarkup->ProcessPeerTasks(0); // this call is important to prevent processing the queue while in the middle of
                                                  // executing inline escripts. See scenario listed past the end of this method

#if DBG == 1
    if (pScriptMarkup &&
        pScriptMarkup->HasBehaviorContext() &&
        pScriptMarkup->BehaviorContext()->_pHtmlComponent)
    {
        AssertSz (pScriptMarkup != pScriptCollectionMarkup, "an HTC appears to be using script collection on the HTC markup");
    }
#endif

#ifdef COMPLUS_SCRIPTENGINES

#if DBG==1
    if (IsTagEnabled(tagComplusScriptEngines))
#endif
    {
        hr = THR(Doc()->EnsureOmWindow());
        if (hr)
            goto Cleanup;

        Assert (Doc()->_pOmWindow);

        hr = CorEnsureScriptEngine(Doc());
        if (hr)
            goto Cleanup;

        hr = CorCompileScript(pchCode);

        goto Cleanup; // done;
    }
#endif

    if (!CMarkup::CanCommitScripts(fCommitOutOfMarkup ? NULL : pScriptMarkup))
        goto Cleanup;

    {
        CDoc::CLock     Lock(_pDoc);

        hr = THR(GetHolderForLanguage(pchLanguage, pScriptMarkup, pchType, NULL, &pHolder, NULL, pComponent));
        if (hr)
            goto Cleanup;

        Assert(pHolder->_pScriptParse);
        if(!pHolder->_pScriptParse)
        {
            hr = E_UNEXPECTED;
            goto Cleanup;
        }

        hr = THR(CreateSourceContextCookie(
            pHolder->_pScript, pchCode, ulOffset, /* fScriptlet = */ FALSE,
            pSourceObject, dwFlags, &dwSourceContextCookie));
        if (hr)
            goto Cleanup;

        if (pHolder->_fClone)
        {
            hr = THR(pHolder->_pScript->SetScriptState(SCRIPTSTATE_STARTED));
        }
        else
        {
            hr = THR(pHolder->_pScriptParse->ParseScriptText(
                             STRVAL(pchCode),
                             pchItemName,
                             NULL,
                             pchDelimiter,
                             dwSourceContextCookie,
                             ulStartingLine,
                             dwFlags | (pHolder->_fOriginal ? SCRIPTTEXT_ISPERSISTENT : 0),
                             pvarResult,
                             pexcepinfo));
        }
    }


Cleanup:

    RRETURN(hr);
}

//
// (alexz)
//
// Scenario why dequeuing is necessary before doing ParseScriptText:
//
// <PROPERTY name = foo put = put_foo />
// <SCRIPT>
//    alert (0);
//    function put_foo()
//    {
//      alert (1);
//    }
// </SCRIPT>
//
//      - HTC PROPERTY element is in the queue waiting for PROPERTY behavior to be attached
//      - inline script runs, and executes "alert(0)"
//      - HTC DD is being asked for name "alert"
//      - HTC DD asks element for name "alert"
//      - element makes call to dequeue the queue
//      - HTC PROPERTY is constructed
//      - it attempts to load property from element (EnsureHtmlLoad)
//      - it successfully finds property to load, finds putter to invoke, and calls put_foo
//      - now we are trying to execute put_foo, before even inline script completed executing - which is bad
//
//

//---------------------------------------------------------------------------
//
//  Member:     CScriptCollection::CreateSourceContextCookie
//
//---------------------------------------------------------------------------

HRESULT
CScriptCollection::CreateSourceContextCookie(
    IActiveScript *     pActiveScript, 
    LPTSTR              pchSource,
    ULONG               ulOffset, 
    BOOL                fScriptlet, 
    CBase *             pSourceObject,
    DWORD               dwFlags,
    DWORD_PTR *         pdwSourceContextCookie)
{
    HRESULT                 hr = S_OK;
    CScriptCookieTable *    pScriptCookieTable;

    if (!pSourceObject)
    {
        *pdwSourceContextCookie = NO_SOURCE_CONTEXT;
        goto Cleanup;
    }

    *pdwSourceContextCookie = (DWORD_PTR)pSourceObject;

#ifndef NO_SCRIPT_DEBUGGER
    if (!g_pPDM || !g_pDebugApp)
    {
        WHEN_DBG(CMarkup *pDbgMarkup=NULL;)
        Assert((S_OK == pSourceObject->PrivateQueryInterface(CLSID_CMarkup, (void **)&pDbgMarkup)) && (pSourceObject == pDbgMarkup));
        goto Cleanup;
    }

    *pdwSourceContextCookie = NO_SOURCE_CONTEXT;

    hr = THR(_pDoc->EnsureScriptCookieTable(&pScriptCookieTable));
    if (hr)
        goto Cleanup;

    //
    // if there is script debugger installed and we want to use it
    //

    hr = THR(GetScriptDebugDocument(pSourceObject, &_pCurrentDebugDocument));
    if (hr)
        goto Cleanup;

    if ((dwFlags & SCRIPTPROC_HOSTMANAGESSOURCE) && _pCurrentDebugDocument)
    {
        ULONG ulCodeLen = _tcslen(STRVAL(pchSource));

        hr = THR(_pCurrentDebugDocument->DefineScriptBlock(
            pActiveScript, ulOffset, ulCodeLen, fScriptlet, pdwSourceContextCookie));
        if (hr)
        {
            hr = S_OK;      // return S_OK and NO_SOURCE_CONTEXT
            goto Cleanup;
        }

        hr = THR(_pCurrentDebugDocument->RequestDocumentSize(ulOffset + ulCodeLen));
        if (hr)
            goto Cleanup;

        hr = THR(pScriptCookieTable->MapCookieToSourceObject(*pdwSourceContextCookie, pSourceObject));

        goto Cleanup;// done
    }
#endif // NO_SCRIPT_DEBUGGER

Cleanup:
    RRETURN (hr);
}

#ifndef NO_SCRIPT_DEBUGGER
//+---------------------------------------------------------------------------
//
//  Member:     CScriptCollection::ViewSourceInDebugger
//
//  Synopsis:   Launches the script debugger at a particular line
//
//----------------------------------------------------------------------------

HRESULT
CScriptCollection::ViewSourceInDebugger (const ULONG ulLine, const ULONG ulOffsetInLine)
{
    HRESULT                 hr = S_OK;
    CScriptDebugDocument *  pDebugDocument = NULL;
    CMarkupScriptContext *  pMarkupScriptContext = _pDoc->PrimaryMarkup()->ScriptContext();

    pDebugDocument = pMarkupScriptContext ? pMarkupScriptContext->_pScriptDebugDocument : NULL;

    if (pDebugDocument)
    {
        hr = THR(pDebugDocument->ViewSourceInDebugger(ulLine, ulOffsetInLine));
    }

    RRETURN(hr);
}
#endif // !NO_SCRIPT_DEBUGGER

//+---------------------------------------------------------------------------
//
//  Member:     CScriptCollection::ConstructCode
//
//----------------------------------------------------------------------------

HRESULT
CScriptCollection::ConstructCode(
    TCHAR *      pchScope,
    TCHAR *      pchCode,
    TCHAR *      pchFormalParams,
    TCHAR *      pchLanguage,
    CMarkup *    pMarkup,
    TCHAR *      pchType,
    ULONG        ulOffset,
    ULONG        ulStartingLine,
    CBase *      pSourceObject,
    DWORD        dwFlags,
    IDispatch ** ppDispCode,
    BOOL         fSingleLine,
    CHtmlComponent *pComponent)
{
    TraceTag((tagScriptCollection, "ConstructCode"));

    HRESULT                 hr = S_OK;
    CScriptHolder *         pHolder;
    DWORD_PTR               dwSourceContextCookie;
    TCHAR *                 pchCleanSource;
    CStr                    cstrNamespace;
    CDebugDocumentStack     debugDocumentStack(this);

    dwFlags |= SCRIPTPROC_IMPLICIT_THIS | SCRIPTPROC_IMPLICIT_PARENTS | SCRIPTPROC_HOSTMANAGESSOURCE;

    if (!ppDispCode)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    
    ClearInterface(ppDispCode);

    if (!pchCode)
        goto Cleanup;

    if (fSingleLine)
    {
        hr = THR (GetHolderForLanguage (pchLanguage, pMarkup, pchType, pchCode, &pHolder, &pchCleanSource, pComponent, &cstrNamespace));
        if (hr)
            goto Cleanup;
    }
    else
    {
        pchCleanSource = pchCode;

        if (!pchCleanSource || !*pchCleanSource)
            goto Cleanup;

        hr = THR (GetHolderForLanguage (pchLanguage, pMarkup, pchType, NULL, &pHolder, NULL, pComponent, &cstrNamespace));
        if (hr)
            goto Cleanup;
    }

    Assert (pchCleanSource);

    if (!pHolder->_pParseProcedure)
    {
        hr = E_NOTIMPL;
        goto Cleanup;
    }

    hr = THR(CreateSourceContextCookie(
        pHolder->_pScript, pchCleanSource, ulOffset, /* fScriptlet = */ TRUE,
        pSourceObject, dwFlags, &dwSourceContextCookie));
    if (hr)
        goto Cleanup;

    hr = THR(pHolder->_pParseProcedure->ParseProcedureText(
        pchCleanSource,
        pchFormalParams,
        _T("\0"),                                   // procedure name
        cstrNamespace ? cstrNamespace : pchScope,   // item name
        NULL,                                       // pUnkContext
        fSingleLine ? _T("\"") : _T("</SCRIPT>"),   // delimiter
        dwSourceContextCookie,                      // source context cookie
        ulStartingLine,                             // starting line number
        dwFlags,
        ppDispCode));

Cleanup:
    RRETURN (hr);
}


#ifndef NO_SCRIPT_DEBUGGER

//+---------------------------------------------------------------------------
//
//  Function:     InitScriptDebugging
//
//----------------------------------------------------------------------------

// don't hold the global lock because InitScriptDebugging makes RPC calls (bug 26308)
static CGlobalCriticalSection g_csInitScriptDebugger;

HRESULT 
InitScriptDebugging()
{
   TraceTag((tagScriptCollection, "InitScriptDebugging"));
    if (g_fScriptDebuggerInitFailed || g_pDebugApp)
        return S_OK;

    HRESULT hr = S_OK;
    HKEY hkeyProcessDebugManager = NULL;
    LPOLESTR pszClsid = NULL;
    TCHAR *pchAppName = NULL;
    LONG lResult;
    TCHAR pchKeyName[MAX_PROGID_LENGTH+8];   // only needs to be MAX_PROGID_LENGTH+6, but let's be paranoid

    g_csInitScriptDebugger.Enter();

    // Need to check again after locking the globals.
    if (g_fScriptDebuggerInitFailed || g_pDebugApp)
        goto Cleanup;

    //
    // Check to see if the ProcessDebugManager is registered before
    // trying to CoCreate it, as CoCreating can be expensive.
    //
    hr = THR(StringFromCLSID(CLSID_ProcessDebugManager, &pszClsid));
    if (hr)
        goto Cleanup;

    hr = THR(Format(0, &pchKeyName, MAX_PROGID_LENGTH+8, _T("CLSID\\<0s>"), pszClsid));
    if (hr)
        goto Cleanup;

    lResult = RegOpenKeyEx(HKEY_CLASSES_ROOT, pchKeyName, 0, KEY_READ, &hkeyProcessDebugManager);
    if (lResult != ERROR_SUCCESS)
    {
        hr = GetLastWin32Error();
        goto Cleanup;
    }

    hr = THR_NOTRACE(CoCreateInstance(
            CLSID_ProcessDebugManager,
            NULL,
            CLSCTX_ALL,
            IID_IProcessDebugManager,
            (void **)&g_pPDM));
    if (hr)
        goto Cleanup;

    hr = THR(g_pPDM->CreateApplication(&g_pDebugApp));
    if (hr)
        goto Cleanup;

    hr = THR(Format(FMT_OUT_ALLOC, &pchAppName, 0, MAKEINTRESOURCE(IDS_MESSAGE_BOX_TITLE)));
    if (hr)
        goto Cleanup;

    hr = THR(g_pDebugApp->SetName(pchAppName));
    if (hr)
        goto Cleanup;

    // This will fail if there is no MDM on the machine. That is OK.
    THR_NOTRACE(g_pPDM->AddApplication(g_pDebugApp, &g_dwAppCookie));

Cleanup:
    CoTaskMemFree(pszClsid);
    delete pchAppName;

    if (hkeyProcessDebugManager)
        RegCloseKey(hkeyProcessDebugManager);

    if (hr)
    {
        g_fScriptDebuggerInitFailed = TRUE;
        DeinitScriptDebugging();
    }

    g_csInitScriptDebugger.Leave();
    
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Function:     DeinitScriptDebugging
//
//----------------------------------------------------------------------------

void 
DeinitScriptDebugging()
{
    TraceTag((tagScriptCollection, "DeinitScriptDebugging"));

    g_csInitScriptDebugger.Enter();

    if (g_pPDM)
        g_pPDM->RemoveApplication( g_dwAppCookie );

    if (g_pDebugApp)
        g_pDebugApp->Close();

    ClearInterface(&g_pPDM);
    ClearInterface(&g_pDebugApp);

    g_csInitScriptDebugger.Leave();
}

#endif // NO_SCRIPT_DEBUGGER

//---------------------------------------------------------------------------
//
//  Member:   CNamedItemsTable::AddItem
//
//---------------------------------------------------------------------------

HRESULT
CNamedItemsTable::AddItem(LPTSTR pchName, IUnknown * pUnkItem)
{
    HRESULT         hr;
    CNamedItem *    pItem;

    pItem = new CNamedItem(pchName, pUnkItem);
    if (!pItem)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(Append(pItem));

Cleanup:
    RRETURN (hr);
}

//---------------------------------------------------------------------------
//
//  Member:   CNamedItemsTable::GetItem
//
//---------------------------------------------------------------------------

HRESULT
CNamedItemsTable::GetItem(LPTSTR pchName, IUnknown ** ppUnkItem)
{
    int             c;
    CNamedItem **   ppItem;

    // ( TODO perf(alexz) this search actually shows up on perf numbers, by
    // introducing quadratic behavior (on pages with lots of HTCs).
    // It should be optimized to do access by hashing. )

    for (c = Size(), ppItem = (CNamedItem**)PData(); c; c--, ppItem++)
    {
        if (0 == StrCmpIC(pchName, (*ppItem)->_cstrName))
        {
            *ppUnkItem = (*ppItem)->_pUnkItem;
            (*ppUnkItem)->AddRef();
            RRETURN (S_OK);
        }
    }
    RRETURN (DISP_E_MEMBERNOTFOUND);
}

//---------------------------------------------------------------------------
//
//  Member:   CNamedItemsTable::FreeAll
//
//---------------------------------------------------------------------------

HRESULT
CNamedItemsTable::FreeAll()
{
    int             c;
    CNamedItem **   ppItem;

    for (c = Size(), ppItem = (CNamedItem**)PData(); c; c--, ppItem++)
    {
        delete (*ppItem);
    }
    super::DeleteAll();

    RRETURN (S_OK);
}

//---------------------------------------------------------------------------
//
//  Member:   CScriptMethodsTable::FreeAll
//
//---------------------------------------------------------------------------

CScriptMethodsTable::~CScriptMethodsTable()
{
    int             c;
    SCRIPTMETHOD *  pScriptMethod;

    for (c = Size(), pScriptMethod = (SCRIPTMETHOD*)PData();
         c > 0;
         c--, pScriptMethod++)
    {
        pScriptMethod->cstrName.Free();
    }
    DeleteAll();
}

//---------------------------------------------------------------------------
//
//  Member:   CScriptCollection::GetDispID
//
//---------------------------------------------------------------------------

HRESULT
CScriptCollection::GetDispID(
    CScriptContext *        pScriptContext,
    BSTR                    bstrName,
    DWORD                   grfdex,
    DISPID *                pdispid)
{
    HRESULT                 hr;
    HRESULT                 hr2;
    LPTSTR                  pchNamespace;
    CScriptMethodsTable *   pScriptMethodsTable;
    int                     i, c;
    STRINGCOMPAREFN         pfnStrCmp;
    CScriptHolder **        ppHolder;
    SCRIPTMETHOD            scriptMethod;
    SCRIPTMETHOD *          pScriptMethod;
    IDispatch *             pdispEngine = NULL;
    IDispatchEx *           pdexEngine  = NULL;
    int                     idx;
    DISPID                  dispidEngine;

    //
    // startup
    //

    grfdex &= (~fdexNameEnsure);    // don't allow name to be ensured here
    pfnStrCmp = (grfdex & fdexNameCaseSensitive) ? StrCmpC : StrCmpIC;

    Assert(pScriptContext);

    pchNamespace        =  pScriptContext->GetNamespace();
    pScriptMethodsTable = &pScriptContext->_ScriptMethodsTable;

    //
    // try existing cached names
    //

    for (i = 0, c = pScriptMethodsTable->Size(); i < c; i++)
    {
        if (0 == pfnStrCmp((*pScriptMethodsTable)[i].cstrName, bstrName))
        {
            *pdispid = DISPID_OMWINDOWMETHODS + i;
            hr = S_OK;
            goto Cleanup;
        }
    }

    //
    // query all the engines for the name
    //

    hr = DISP_E_UNKNOWNNAME;

    if (pScriptContext->_fClonedScript)
    {
        Assert(pScriptContext->_idxDefaultScriptHolder != -1);
        c = 1;
        ppHolder = &_aryCloneHolder[pScriptContext->_idxDefaultScriptHolder];
        Assert(ppHolder && *ppHolder);
        if (!ppHolder || !(*ppHolder))
            c = 0;
    }
    else
    {
        c = _aryHolder.Size();
        ppHolder = _aryHolder;
    }

    for (; c > 0; c--, ppHolder++)
    {
        Assert (!pdispEngine && !pdexEngine);

        // get IDispatch and IDispatchEx

        if (!(*ppHolder)->_pScript)
            continue;

        hr2 = THR((*ppHolder)->_pScript->GetScriptDispatch(pchNamespace, &pdispEngine));
        if (hr2)
            continue;

        _fInEnginesGetDispID = TRUE;

        if (0 == (grfdex & fdexFromGetIdsOfNames))
        {
            IGNORE_HR(pdispEngine->QueryInterface(IID_IDispatchEx, (void **)&pdexEngine));
        }

        // query for the name

        if (pdexEngine)
        {
            hr2 = THR_NOTRACE(pdexEngine->GetDispID(bstrName, grfdex, &dispidEngine));
        }
        else
        {
            hr2 = THR_NOTRACE(pdispEngine->GetIDsOfNames(IID_NULL, &bstrName, 1, LCID_SCRIPTING, &dispidEngine));
        }

        _fInEnginesGetDispID = FALSE;

        if (S_OK != hr2)        // if name is unknown to this engine
            goto LoopCleanup;   // this is not a fatal error; goto loop cleanup and then continue

        // name is known; assign it our own dispid, and append all the info to our list for remapping

        hr = THR(pScriptMethodsTable->AppendIndirect(&scriptMethod));
        if (hr)
            goto Cleanup;

        idx = pScriptMethodsTable->Size() - 1;
        *pdispid = DISPID_OMWINDOWMETHODS + idx;

        pScriptMethod = &((*pScriptMethodsTable)[idx]);
        pScriptMethod->dispid  = dispidEngine;
        pScriptMethod->pHolder = *ppHolder;
        hr = THR(pScriptMethod->cstrName.Set(bstrName));
        if (hr)
            goto Cleanup;

        // loop cleanup

LoopCleanup:
        ClearInterface(&pdispEngine);
        ClearInterface(&pdexEngine);
    }

Cleanup:
    RRETURN (hr);
}

//---------------------------------------------------------------------------
//
//  Member:   CScriptCollection::InvokeEx
//
//---------------------------------------------------------------------------

HRESULT
CScriptCollection::InvokeEx(
    CScriptContext *        pScriptContext,
    DISPID                  dispid,
    LCID                    lcid,
    WORD                    wFlags,
    DISPPARAMS *            pDispParams,
    VARIANT *               pvarRes,
    EXCEPINFO *             pExcepInfo,
    IServiceProvider *      pServiceProvider)
{
    HRESULT                 hr;
    HRESULT                 hr2;
    LPTSTR                  pchNamespace;
    CScriptMethodsTable *   pScriptMethodsTable;
    IDispatch *             pdispEngine = NULL;
    IDispatchEx *           pdexEngine  = NULL;
    SCRIPTMETHOD *          pScriptMethod;
    int                     idx = dispid - DISPID_OMWINDOWMETHODS;

    //
    // startup
    //

    Assert (pScriptContext);

    AddRef();

    pchNamespace        =  pScriptContext->GetNamespace();
    pScriptMethodsTable = &pScriptContext->_ScriptMethodsTable;

    if (idx < 0 || pScriptMethodsTable->Size() <= idx)
    {
        hr = DISP_E_MEMBERNOTFOUND;
        goto Cleanup;
    }

    //
    // invoke
    //

    pScriptMethod = &((*pScriptMethodsTable)[idx]);

    hr = THR(pScriptMethod->pHolder->_pScript->GetScriptDispatch(pchNamespace, &pdispEngine));
    if (hr)
        goto Cleanup;

    hr2 = THR_NOTRACE(pdispEngine->QueryInterface(IID_IDispatchEx, (void**)&pdexEngine));

    if (pdexEngine)
    {
        hr = THR(pdexEngine->InvokeEx(
                pScriptMethod->dispid, lcid, wFlags, pDispParams,pvarRes, pExcepInfo, pServiceProvider));

        ReleaseInterface(pdexEngine);
    }
    else
    {
        hr = THR(pdispEngine->Invoke(
                pScriptMethod->dispid, IID_NULL, lcid, wFlags, pDispParams, pvarRes, pExcepInfo, NULL));
    }

Cleanup:
    ReleaseInterface (pdispEngine);
    Release();
    RRETURN (hr);
}

//---------------------------------------------------------------------------
//
//  Member:   CScriptCollection::InvokeName
//
//---------------------------------------------------------------------------

HRESULT
CScriptCollection::InvokeName(
    CScriptContext *        pScriptContext,
    LPTSTR                  pchName,
    LCID                    lcid,
    WORD                    wFlags,
    DISPPARAMS *            pDispParams,
    VARIANT *               pvarRes,
    EXCEPINFO *             pExcepInfo,
    IServiceProvider *      pServiceProvider)
{
    HRESULT             hr = S_OK;
    HRESULT             hr2;
    CScriptHolder **    ppHolder = NULL;
    IDispatch *         pdispEngine = NULL;
    IDispatchEx *       pdexEngine  = NULL;
    BSTR                bstrName = NULL;
    DISPID              dispid;
    int                 c;

    Assert (pScriptContext);

    //
    // startup
    //

    if (pScriptContext->_fClonedScript)
    {
        if (pScriptContext->_idxDefaultScriptHolder == -1)
        {
            c = 0;
        }
        else
        {
            c = 1;
            ppHolder = &_aryCloneHolder[pScriptContext->_idxDefaultScriptHolder];
            Assert(ppHolder && *ppHolder);
            if (!ppHolder || !(*ppHolder))
                c = 0;
        }
    }
    else
    {
        c = _aryHolder.Size();
        ppHolder = _aryHolder;
    }

    if (0 == c)
    {
        hr = DISP_E_UNKNOWNNAME;
        goto Cleanup;
    }

    hr = THR(FormsAllocString (pchName, &bstrName));
    if (hr)
        goto Cleanup;

    //
    // find an engine that knows the name and invoke it
    //

    hr = DISP_E_UNKNOWNNAME;
    for (; c > 0; c--, ppHolder++)
    {
        // get IDispatch / IDispatchEx

        hr2 = THR((*ppHolder)->_pScript->GetScriptDispatch(pScriptContext->GetNamespace(), &pdispEngine));
        if (hr2)
            continue;

        hr2 = THR_NOTRACE(pdispEngine->QueryInterface(IID_IDispatchEx, (void **)&pdexEngine));
        if (S_OK == hr2)
        {
            // invoke via IDispatchEx

            hr2 = THR_NOTRACE(pdexEngine->GetDispID(bstrName, fdexNameCaseInsensitive, &dispid));
            if (S_OK == hr2)
            {
                hr = THR(pdexEngine->InvokeEx(
                    dispid, lcid, wFlags, pDispParams, pvarRes, pExcepInfo, pServiceProvider));

                goto Cleanup; // done
            }
            ClearInterface(&pdexEngine);
        }
        else
        {
            // invoke via IDispatch

            hr2 = THR_NOTRACE(pdispEngine->GetIDsOfNames(IID_NULL, &pchName, 1, lcid, &dispid));
            if (S_OK == hr2)
            {
                hr = THR(pdispEngine->Invoke(
                    dispid, IID_NULL, lcid, wFlags, pDispParams, pvarRes, pExcepInfo, NULL));

                goto Cleanup; // done
            }
        }

        // loop cleanup

        ClearInterface(&pdispEngine);
    }

Cleanup:

    ReleaseInterface(pdispEngine);
    ReleaseInterface(pdexEngine);

    FormsFreeString(bstrName);

    RRETURN (hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\security.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       security.cxx
//
//  Contents:   Implementation of the security proxy for CWindow
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_DISPEX_H_
#define X_DISPEX_H_
#include "dispex.h"
#endif

#ifndef X_CONNECT_HXX_
#define X_CONNECT_HXX_
#include "connect.hxx"
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_COLLECT_HXX_
#define X_COLLECT_HXX_
#include "collect.hxx"
#endif

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx"
#endif

#ifndef X_IMGELEM_HXX_
#define X_IMGELEM_HXX_
#include "imgelem.hxx"
#endif

#ifndef X_EOPTION_HXX_
#define X_EOPTION_HXX_
#include "eoption.hxx"
#endif

#ifndef X_JSPROT_HXX_
#define X_JSPROT_HXX_
#include "jsprot.hxx"
#endif

#ifndef X_OTHRGUID_H_
#define X_OTHRGUID_H_
#include "othrguid.h"
#endif

#ifndef X_UWININET_H_
#define X_UWININET_H_
#include <uwininet.h>
#endif

#ifndef X_HISTORY_H_
#define X_HISTORY_H_
#include "history.h"
#endif

#ifndef X_WINABLE_H_
#define X_WINABLE_H_
#include "winable.h"
#endif

#ifndef X_EVENTOBJ_HXX_
#define X_EVENTOBJ_HXX_
#include "eventobj.hxx"
#endif

#ifndef X_EVNTPRM_HXX_
#define X_EVNTPRM_HXX_
#include "evntprm.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_TEAROFF_HXX_
#define X_TEAROFF_HXX_
#include "tearoff.hxx"
#endif

#ifndef X_MSHTMHST_H_
#define X_MSHTMHST_H_
#include <mshtmhst.h>
#endif

#ifndef X_OLEACC_H
#define X_OLEACC_H
#include <oleacc.h>
#endif

#ifndef X_SHELL_H_
#define X_SHELL_H_
#include <shell.h>
#endif

#ifndef X_SHLOBJP_H_
#define X_SHLOBJP_H_
#include <shlobjp.h>
#endif

#ifndef X_ROOTELEM_HXX_
#define X_ROOTELEM_HXX_
#include "rootelem.hxx"
#endif

#ifndef X_FRAMET_H_
#define X_FRAMET_H_
#include "framet.h"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_FRAME_HXX_
#define X_FRAME_HXX_
#include "frame.hxx"
#endif

#ifndef X_HTIFRAME_H_
#define X_HTIFRAME_H_
#include <htiframe.h>
#endif

#if DBG==1
#ifndef X_VERIFYCALLSTACK_HXX_
#define X_VERIFYCALLSTACK_HXX_
#include "VerifyCallStack.hxx"
#endif
#ifndef X_DEBUGWINDOW_HXX_
#define X_DEBUGWINDOW_HXX_
#include "DebugWindow.h"
#endif
#endif

#define WINDOWDEAD() (RPC_E_SERVER_DIED_DNE == hr || RPC_E_DISCONNECTED == hr)

extern BOOL IsGlobalOffline(void);
extern BOOL g_fInInstallShield;

BOOL IsSpecialUrl(LPCTSTR pchUrl);   // TRUE for javascript, vbscript, about protocols
BOOL IsInIEBrowser(CDoc * pDoc);

DeclareTag(tagSecurity, "Security", "Security methods")
DeclareTag(tagSecurityProxyCheck, "Security Debug", "Check window proxy security");
DeclareTag(tagSecurityProxyCheckMore, "Security Debug", "More window proxy asserts");
DeclareTag(tagSecureScriptWindow, "Security Debug", "Secure window proxy for script engine")
ExternTag(tagSecurityContext);

PerfDbgTag(tagNFNav, "NF", "NF Navigation")

MtDefine(COmWindowProxy, ObjectModel, "COmWindowProxy")
MtDefine(COmWindowProxy_pbSID, COmWindowProxy, "COmWindowProxy::_pbSID")
MtDefine(CAryWindowTbl, ObjectModel, "CAryWindowTbl")
MtDefine(CAryWindowTbl_pv, CAryWindowTbl, "CAryWindowTbl::_pv")
MtDefine(CAryWindowTblAddTuple_pbSID, CAryWindowTbl, "CAryWindowTbl::_pv::_pbSID")

BEGIN_TEAROFF_TABLE(COmWindowProxy, IMarshal)
    TEAROFF_METHOD(COmWindowProxy, GetUnmarshalClass, getunmarshalclass, (REFIID riid,void *pvInterface,DWORD dwDestContext,void *pvDestContext,DWORD mshlflags,CLSID *pCid))
    TEAROFF_METHOD(COmWindowProxy, GetMarshalSizeMax, getmarshalsizemax, (REFIID riid,void *pvInterface,DWORD dwDestContext,void *pvDestContext,DWORD mshlflags,DWORD *pSize))
    TEAROFF_METHOD(COmWindowProxy, MarshalInterface, marshalinterface, (IStream *pistm,REFIID riid,void *pvInterface,DWORD dwDestContext,void *pvDestContext,DWORD mshlflags))
    TEAROFF_METHOD(COmWindowProxy, UnmarshalInterface, unmarshalinterface, (IStream *pistm,REFIID riid,void ** ppvObj))
    TEAROFF_METHOD(COmWindowProxy, ReleaseMarshalData, releasemarshaldata, (IStream *pStm))
    TEAROFF_METHOD(COmWindowProxy, DisconnectObject, disconnectobject, (DWORD dwReserved))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE_(COmLocationProxy, IDispatchEx)
    TEAROFF_METHOD(COmLocationProxy, GetTypeInfoCount, gettypeinfocount, (UINT *pcTinfo))
    TEAROFF_METHOD(COmLocationProxy, GetTypeInfo, gettypeinfo, (UINT itinfo, ULONG lcid, ITypeInfo ** ppTI))
    TEAROFF_METHOD(COmLocationProxy, GetIDsOfNames, getidsofnames, (REFIID riid,
                                   LPOLESTR *prgpsz,
                                   UINT cpsz,
                                   LCID lcid,
                                   DISPID *prgid))
    TEAROFF_METHOD(COmLocationProxy, Invoke, invoke, (DISPID dispidMember,
                            REFIID riid,
                            LCID lcid,
                            WORD wFlags,
                            DISPPARAMS * pdispparams,
                            VARIANT * pvarResult,
                            EXCEPINFO * pexcepinfo,
                            UINT * puArgErr))
    TEAROFF_METHOD(COmLocationProxy, GetDispID, getdispid, (BSTR bstrName,
                               DWORD grfdex,
                               DISPID *pid))
    TEAROFF_METHOD(COmLocationProxy, InvokeEx, invokeex, (DISPID id,
                        LCID lcid,
                        WORD wFlags,
                        DISPPARAMS *pdp,
                        VARIANT *pvarRes,
                        EXCEPINFO *pei,
                        IServiceProvider *pSrvProvider)) 
    TEAROFF_METHOD(COmLocationProxy, DeleteMemberByName, deletememberbyname, (BSTR bstr,DWORD grfdex))
    TEAROFF_METHOD(COmLocationProxy, DeleteMemberByDispID, deletememberbydispid, (DISPID id))    
    TEAROFF_METHOD(COmLocationProxy, GetMemberProperties, getmemberproperties, (DISPID id,
                                         DWORD grfdexFetch,
                                         DWORD *pgrfdex))
    TEAROFF_METHOD(COmLocationProxy, GetMemberName, getmembername, (DISPID id,
                                   BSTR *pbstrName))
    TEAROFF_METHOD(COmLocationProxy, GetNextDispID, getnextdispid, (DWORD grfdex,
                                   DISPID id,
                                   DISPID *pid))
    TEAROFF_METHOD(COmLocationProxy, GetNameSpaceParent, getnamespaceparent, (IUnknown **ppunk))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE_(COmWindowProxy, IServiceProvider)
    TEAROFF_METHOD(COmWindowProxy, QueryService, queryservice, (REFGUID guidService, REFIID riid, void **ppvObject))
END_TEAROFF_TABLE()

#if DBG==1
BEGIN_TEAROFF_TABLE(COmWindowProxy, IDebugWindowProxy)
    TEAROFF_METHOD(COmWindowProxy, get_isSecureProxy, GET_isSecureProxy, (VARIANT_BOOL *))
    TEAROFF_METHOD(COmWindowProxy, get_trustedProxy, GET_trustedProxy, (IDispatch**))
    TEAROFF_METHOD(COmWindowProxy, get_internalWindow, GET_internalWindow, (IDispatch**))
    TEAROFF_METHOD(COmWindowProxy, enableSecureProxyAsserts, EnableSecureProxyAsserts, (VARIANT_BOOL))
END_TEAROFF_TABLE()
#endif

const BYTE byOnErrorParamTypes[4] = {VT_BSTR, VT_BSTR, VT_I4, 0};

HRESULT GetCallerURL(CStr &cstr, CBase *pBase, IServiceProvider *pSP);
HRESULT GetCallerCommandTarget (CBase *pBase, IServiceProvider *pSP, BOOL fFirstScriptSite, IOleCommandTarget **ppCommandTarget);
HRESULT GetCallerSecurityStateAndURL(SSL_SECURITY_STATE *pSecState, CStr &cstr, CBase *pBase, IServiceProvider * pSP);
#if DBG==1
HRESULT GetCallerIDispatch(IServiceProvider *pSP, IDispatch ** ppID);
#endif

extern void  ProcessValueEntities(TCHAR *pch, ULONG *pcch);

#ifndef WIN16
STDAPI HlinkFindFrame(LPCWSTR pszFrameName, LPUNKNOWN *ppunk);
#endif

extern CDummySecurityDispatchEx g_DummySecurityDispatchEx;

//+-------------------------------------------------------------------------
//
//  Member:     Free
//
//  Synopsis:   Clear out the contents of a WINDOWTBL structure
//
//--------------------------------------------------------------------------

void
WINDOWTBL::Free()
{
    delete [] pbSID;
    pbSID = NULL;
    cbSID = 0;
}


//+-------------------------------------------------------------------------
//
//  Function:   EnsureWindowInfo
//
//  Synopsis:   Ensures that a thread local window table exists
//
//--------------------------------------------------------------------------

HRESULT 
EnsureWindowInfo()
{
    if (!TLS(windowInfo.paryWindowTbl))
    {
        TLS(windowInfo.paryWindowTbl) = new CAryWindowTbl;
        if (!TLS(windowInfo.paryWindowTbl))
            RRETURN(E_OUTOFMEMORY);
    }

    if (!TLS(windowInfo.pSecMgr))
    {
        IInternetSecurityManager *  pSecMgr = NULL;
        HRESULT                     hr;
        
        hr = THR(CoInternetCreateSecurityManager(NULL, &pSecMgr, 0));
        if (hr)
            RRETURN(hr);
        
        TLS(windowInfo.pSecMgr) = pSecMgr;  // Implicit addref/release
    }
    
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Function:   DeinitWindowInfo
//
//  Synopsis:   Clear out the thread local window table
//
//--------------------------------------------------------------------------

void 
DeinitWindowInfo(THREADSTATE *pts)
{
    WINDOWTBL * pwindowtbl;
    long        i;
    
    if (pts->windowInfo.paryWindowTbl)
    {
        for (i = pts->windowInfo.paryWindowTbl->Size(), pwindowtbl=*(pts->windowInfo.paryWindowTbl);
             i > 0;
             i--, pwindowtbl++)
        {
            pwindowtbl->Free();
        }
        delete pts->windowInfo.paryWindowTbl;
        pts->windowInfo.paryWindowTbl = NULL;
    }

    ClearInterface(&(pts->windowInfo.pSecMgr));
}


//+-------------------------------------------------------------------------
//
//  Member:     CAryWindowTbl::FindProxy
//
//  Synopsis:   Search in window table and return proxy given
//              a window and a string.
//
//--------------------------------------------------------------------------

HRESULT
CAryWindowTbl::FindProxy(
    IHTMLWindow2 *pWindow, 
    BYTE *pbSID, 
    DWORD cbSID, 
    BOOL fTrust,
    IHTMLWindow2 **ppProxy,
    BOOL fForceSecureProxy)
{
    WINDOWTBL * pwindowtbl;
    long        i;

    Assert(pWindow);
    
    for (i = Size(), pwindowtbl = *this;
         i > 0;
         i--, pwindowtbl++)
    {
        // Should we QI for IUnknown here?
        if (IsSameObject(pWindow, pwindowtbl->pWindow))
        {
            if ((!pbSID && pwindowtbl->pbSID) ||
                (pbSID && !pwindowtbl->pbSID))
                continue;

            // Trust status must match for this comparison to succeed.
            if (fTrust != pwindowtbl->fTrust)
                continue;
                
            if ((!pbSID && !pwindowtbl->pbSID) ||
                (cbSID == pwindowtbl->cbSID &&
                 !memcmp(pbSID, pwindowtbl->pbSID, cbSID)))
            {
                HRESULT             hr;
                COmWindowProxy *    pProxyListed = NULL;

                // the pProxyListed we receive here is a weak ref. no need to release.
                hr = THR(pwindowtbl->pProxy->QueryInterface(CLSID_HTMLWindowProxy, 
                                                            (void **)&pProxyListed));
                
                // we can only check for _fTrusted if the pProxyListed is provided
                if (!hr && pProxyListed)
                {
                    //
                    // found a proxy that is created for the window that we want
                    // to access from the domain that we are on. The last check is
                    // make sure that we don't return a main (_fTrusted=1) proxy to
                    // the script, or a non trusted object to the internal callers.
                    //
                    if ((fForceSecureProxy && pProxyListed->_fTrusted) ||
                        (!fForceSecureProxy && !pProxyListed->_fTrusted))
                        continue;
                }

                //
                // We have what we want, return this proxy.
                // This is a weak ref.
                //

                if (ppProxy)
                {
                    *ppProxy = pwindowtbl->pProxy;
                }
                return S_OK;
            }
        }
    }
    
    RRETURN(E_FAIL);
}


//+-------------------------------------------------------------------------
//
//  Member:     CAryWindowTbl::AddTuple
//
//  Synopsis:   Search in window table and return proxy given
//              a window and a string.
//
//--------------------------------------------------------------------------


HRESULT
CAryWindowTbl::AddTuple(
    IHTMLWindow2 *pWindow, 
    BYTE *pbSID,
    DWORD cbSID,
    BOOL fTrust,
    IHTMLWindow2 *pProxy)
{
    WINDOWTBL   windowtbl;
    WINDOWTBL * pwindowtbl;
    HRESULT     hr = S_OK;
    BYTE *      pbSIDTmp = NULL;
    
#if DBG == 1
    long        lProxyCount = 0;

    //
    // We better not be adding a proxy for an already existing tuple.
    //

    if (!(FindProxy(pWindow, pbSID, cbSID, fTrust, NULL, TRUE)))
        lProxyCount++;

    if (!(FindProxy(pWindow, pbSID, cbSID, fTrust, NULL, FALSE)))
        lProxyCount++;

    if (lProxyCount == 2)
        Assert(0 && "Adding a window proxy tuple twice");
#endif

    //
    // Weak ref.  The proxy deletes itself from this array upon 
    // its destruction.
    //
    
    windowtbl.pProxy = pProxy;
    windowtbl.cbSID = cbSID;
    windowtbl.fTrust = fTrust;
    windowtbl.pWindow = pWindow;    // No nead to addref here because the proxy already is

    
    pbSIDTmp = new(Mt(CAryWindowTblAddTuple_pbSID)) BYTE[cbSID];
    if (!pbSIDTmp)
    {
        hr = E_OUTOFMEMORY;
        goto Error;
    }

    memcpy(pbSIDTmp, pbSID, cbSID);
    windowtbl.pbSID = pbSIDTmp;
    
    hr = THR(TLS(windowInfo.paryWindowTbl)->AppendIndirect(&windowtbl, &pwindowtbl));
    if (hr)
        goto Error;

    MemSetName(( *(GetThreadState()->windowInfo.paryWindowTbl), "paryWindowTbl c=%d", (TLS(windowInfo.paryWindowTbl))->Size()));

Cleanup:
    RRETURN(hr);

Error:
    delete [] pbSIDTmp;
    goto Cleanup;
}


//+-------------------------------------------------------------------------
//
//  Member:     CAryWindowTbl::DeleteProxyEntry
//
//  Synopsis:   Search in window table for the given proxy
//              and delete its entry.  Every proxy should appear
//              only once in the window table.
//
//--------------------------------------------------------------------------

void 
CAryWindowTbl::DeleteProxyEntry(IHTMLWindow2 *pProxy)
{
    WINDOWTBL * pwindowtbl;
    long        i;
    
    Assert(pProxy);
    
    for (i = Size(), pwindowtbl = *this;
         i > 0;
         i--, pwindowtbl++)
    {
        if (pProxy == pwindowtbl->pProxy)
        {
            pwindowtbl->Free();
            Delete(Size() - i);
            break;
        }
    }

#if DBG == 1
    //
    // In debug mode, just ensure that this proxy is not appearing
    // anywhere else in the table.
    //

    for (i = Size(), pwindowtbl = *this;
         i > 0;
         i--, pwindowtbl++)
    {
        // Should we QI for IUnknown here?
        Assert(pProxy != pwindowtbl->pProxy);
    }
#endif
}


//+-------------------------------------------------------------------------
//
//  Function:   GetSIDOfDispatch
//
//  Synopsis:   Retrieve the host name given an IHTMLDispatch *
//
//--------------------------------------------------------------------------

HRESULT 
GetSIDOfDispatch(IDispatch *pDisp, BYTE *pbSID, DWORD *pcbSID, BOOL *pfDomainExist = NULL)
{
    HRESULT         hr;
    CVariant        VarUrl;
    CVariant        VarDomain;
    TCHAR           ach[pdlUrlLen];
    DWORD           dwSize;

    //[kusumav]When this function is called by COleSite, if the control doesn't not support DISPID_SECURITYCTX 
    //we will allow access since the control is not placing any access restrictions. But in the case where 
    //the object supports this DISPID_SECURITYCTX but some call after this fails here (eg: object returned 
    //a value that could not be converted into a SID blob or we could not generate a blob bcos of memory failure,
    //we need to communicate back so that we don't allow access to the control by default. We do this by
    //setting the size to Zero, since all callers pass in the correct buffer size (MAX_SIZE_SECURITY_ID) initially

    BOOL            fGotSecurityCtx = FALSE;

    if (pfDomainExist)
        *pfDomainExist = FALSE;

    // call invoke DISPID_SECURITYCTX off pDisp to get SID
    hr = THR_NOTRACE(GetDispProp(
            pDisp,
            DISPID_SECURITYCTX,
            LOCALE_SYSTEM_DEFAULT,
            &VarUrl,
            NULL,
            FALSE));
    if (hr) 
        goto Cleanup;

    if (V_VT(&VarUrl) != VT_BSTR || !V_BSTR(&VarUrl))
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    fGotSecurityCtx = TRUE;

    if (!OK(THR_NOTRACE(GetDispProp(
            pDisp,
            DISPID_SECURITYDOMAIN,
            LOCALE_SYSTEM_DEFAULT,
            &VarDomain,
            NULL,
            FALSE))))
    {
        VariantClear(&VarDomain);
    }
    else if (pfDomainExist)
        *pfDomainExist = TRUE;


    hr = THR(EnsureWindowInfo());
    if (hr)
        goto Cleanup;
    
    extern DWORD g_dwAppCompat;

    if (g_dwAppCompat)
    {
        hr = THR(CoInternetParseUrl(
            V_BSTR(&VarUrl), 
            PARSE_ENCODE, 
            0, 
            ach, 
            ARRAY_SIZE(ach), 
            &dwSize, 
            0));
        if (hr)
            goto Cleanup;

        //UnescapeAndTruncateUrl appears to be used to prevent %01 spoofing.
        //It is needed only if we unescape the URL before calling GetSecurityID()
        UnescapeAndTruncateUrl (ach, FALSE);
    }
    else
    {
        StrCpyN(ach, V_BSTR(&VarUrl), sizeof(ach)/sizeof(ach[0]));
    }

    hr = THR(TLS(windowInfo.pSecMgr)->GetSecurityId(
            ach, 
            pbSID, 
            pcbSID,
            (DWORD_PTR)(V_VT(&VarDomain) == VT_BSTR ? V_BSTR(&VarDomain) : NULL)));
    if (hr)
        goto Cleanup;

Cleanup:
    if (FAILED(hr) && fGotSecurityCtx)
    {
        if (pcbSID)
        {
            *pcbSID = 0;
        }
    }
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Function:   CreateSecurityProxy
//
//  Synopsis:   Creates a new security proxy for marshalling across
//              thread & process boundaries.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
CreateSecurityProxy(
        IUnknown * pUnkOuter,
        IUnknown **ppUnk)
{
    COmWindowProxy *    pProxy;
    
    if (pUnkOuter)
        RRETURN(CLASS_E_NOAGGREGATION);

    pProxy = new COmWindowProxy();
    if (!pProxy)
        RRETURN(E_OUTOFMEMORY);

    Verify(!pProxy->QueryInterface(IID_IUnknown, (void **)ppUnk));
    pProxy->Release();
    
    return S_OK;
}


const CONNECTION_POINT_INFO COmWindowProxy::s_acpi[] =
{
    CPI_ENTRY(IID_IDispatch, DISPID_A_EVENTSINK)
    CPI_ENTRY(DIID_HTMLWindowEvents, DISPID_A_EVENTSINK)
    CPI_ENTRY(IID_ITridentEventSink, DISPID_A_EVENTSINK)
    CPI_ENTRY(DIID_HTMLWindowEvents2, DISPID_A_EVENTSINK)
    CPI_ENTRY_NULL
};


const CBase::CLASSDESC COmWindowProxy::s_classdesc =
{
    &CLSID_HTMLWindowProxy,         // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif // NO_PROPERTY_PAGE
    s_acpi,                         // _pcpi
    0,                              // _dwFlags
    &IID_IHTMLWindow2,              // _piidDispinterface
    &s_apHdlDescs,                  // _apHdlDesc
};




//+-------------------------------------------------------------------------
//
//  Method:     COmWindowProxy::COmWindowProxy
//
//  Synopsis:   ctor
//
//--------------------------------------------------------------------------

COmWindowProxy::COmWindowProxy() : super()
{
#ifdef WIN16
    m_baseOffset = ((BYTE *) (void *) (CBase *)this) - ((BYTE *) this);
#endif
    IncrementObjectCount(&_dwObjCnt);

    _dwMyPicsState       = 0;      // Used to make sure we only get zero or one at a time
    _bDisabled           = FALSE;  // If user disabled for session
    _pMyPics             = NULL;   // Pointer to attached MyPics object
}    


//+-------------------------------------------------------------------------
//
//  Method:     COmWindowProxy::Passivate
//
//  Synopsis:   1st phase destructor
//
//--------------------------------------------------------------------------

void
COmWindowProxy::Passivate()
{
    //
    // Go through the cache and delete the entry for this proxy
    //

    if (TLS(windowInfo.paryWindowTbl))
    {
        TLS(windowInfo.paryWindowTbl)->DeleteProxyEntry((IHTMLWindow2 *)this);
    }

    GWKillMethodCall (this, NULL, 0);
    
    ClearInterface(&_pWindow);
    _pCWindow = NULL;
    delete [] _pbSID;
    _pbSID = NULL;
    _fDomainChanged = 0;
    _cbSID = 0;
    super::Passivate();
    DecrementObjectCount(&_dwObjCnt);
}


//+-------------------------------------------------------------------------
//
//  Method:     COmWindowProxy::Init
//
//  Synopsis:   Initializer
//
//--------------------------------------------------------------------------

HRESULT
COmWindowProxy::Init(IHTMLWindow2 *pWindow, BYTE *pbSID, DWORD cbSID)
{
    HRESULT hr = S_OK;

    Assert(pbSID && cbSID);

    _fDomainChanged = 0;
    delete [] _pbSID;
    
    _pbSID = new(Mt(COmWindowProxy_pbSID)) BYTE[cbSID];
    if (!_pbSID)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    _cbSID = cbSID;
    memcpy(_pbSID, pbSID, cbSID);
    
    if (_pWindow != pWindow)
    {
        ReplaceInterface(&_pWindow, pWindow);
        _pCWindow = NULL;
        if(_pWindow && _fTrusted)
        {
            IGNORE_HR(_pWindow->QueryInterface(CLSID_HTMLWindow2, (void**)&_pCWindow));
        }
    }

Cleanup:
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     COmWindowProxy::SecureObject
//
//  Synopsis:   Wrap the correct proxy around this object if
//              necessary.
//
//--------------------------------------------------------------------------

HRESULT
COmWindowProxy::SecureObject(VARIANT *pvarIn,                   //
                             VARIANT *pvarOut,                  //
                             IServiceProvider *pSrvProvider,    //
                             CBase * pAttrAryBase,              //
                             BOOL fInvoked)                     //
{
    IHTMLWindow2 *      pWindow = NULL;
    IOleCommandTarget * pCommandTarget = NULL;
    HRESULT             hr = E_FAIL;
    BOOL                fForceSecureProxy = TRUE;
    BOOL                fSecurityCheck = TRUE;

    if (!pvarOut)
    {
        hr = S_OK;
        goto Cleanup;
    }
    
    // No need for a security check if this is a trusted context.
    if (_fTrustedDoc)
        fSecurityCheck = FALSE;

    if (V_VT(pvarIn) == VT_UNKNOWN && V_UNKNOWN(pvarIn))
    {
        hr = THR_NOTRACE(V_UNKNOWN(pvarIn)->QueryInterface(
                IID_IHTMLWindow2, (void **)&pWindow));
    }
    else if (V_VT(pvarIn) == VT_DISPATCH && V_DISPATCH(pvarIn))
    {
        hr = THR_NOTRACE(V_DISPATCH(pvarIn)->QueryInterface(
                IID_IHTMLWindow2, (void **)&pWindow));
    }

    if (hr)
    {
        //
        // Object being retrieved is not a window object.
        // Just proceed normally.
        //

        VariantCopy(pvarOut, pvarIn);
        hr = S_OK;
    }
    else
    {
        IHTMLWindow2 *  pWindowOut;

        if (fSecurityCheck)
        {
            BYTE        abSID[MAX_SIZE_SECURITY_ID];
            DWORD       cbSID = ARRAY_SIZE(abSID);
            CVariant    varCallerSID;
            CVariant    varCallerWindow;

            hr = THR(GetCallerCommandTarget(pAttrAryBase, pSrvProvider, FALSE, &pCommandTarget));
            if (FAILED(hr))
                goto Cleanup;

            if (hr == S_FALSE && pSrvProvider==NULL)
            {
                // the ONLY way for this to happen is if the call has come in on the VTable
                // rather than through script.  But lets be paranoid about that.
                // To work properly, and to be consistent with
                // the Java VM, if we don't have a securityProvicer in the AA, or passed in
                // then assume trusted.
                 if (pAttrAryBase && 
                     (AA_IDX_UNKNOWN == pAttrAryBase->FindAAIndex (DISPID_INTERNAL_INVOKECONTEXT,CAttrValue::AA_Internal)))
                 {

                    fForceSecureProxy = FALSE;
                 }
                 hr = S_OK;      // succeed anyhow, else leave the hr=S_FALSE
            }
            else if (pCommandTarget)
            {
                // get the security ID of the caller window.
                hr = THR(pCommandTarget->Exec(
                        &CGID_ScriptSite,
                        CMDID_SCRIPTSITE_SID,
                        0,
                        NULL,
                        &varCallerSID));
                if (hr)
                    goto Cleanup;

                Assert(V_VT(&varCallerSID) == VT_BSTR);

                Assert(FormsStringLen(V_BSTR(&varCallerSID)) == MAX_SIZE_SECURITY_ID);

                memset(abSID, 0, cbSID);
                hr = THR(GetSIDOfDispatch(_pWindow, abSID, &cbSID));
                if (hr)
                    goto Cleanup;

                if (memcmp(abSID, V_BSTR(&varCallerSID), MAX_SIZE_SECURITY_ID))
                {
                    DWORD dwPolicy = 0;
                    DWORD dwContext = 0;
                    CStr cstrCallerUrl;

                    hr = THR(GetCallerURL(cstrCallerUrl, pAttrAryBase, pSrvProvider));
                    if (hr)
                        goto Cleanup;

                    if (!SUCCEEDED(ZoneCheckUrlEx(cstrCallerUrl, &dwPolicy, sizeof(dwPolicy), &dwContext, sizeof(dwContext),
                                    URLACTION_HTML_SUBFRAME_NAVIGATE, 0, NULL))
                        ||  GetUrlPolicyPermissions(dwPolicy) != URLPOLICY_ALLOW)
                    {
                        hr = E_ACCESSDENIED;
                        goto Cleanup;
                    }
                }
            }
        }
        else
        {
            fForceSecureProxy = FALSE;
        }

        Assert(S_OK == hr);
        if (hr)
            goto Cleanup;

        Assert(pWindow);
        hr = THR(SecureObject(pWindow, &pWindowOut, fForceSecureProxy));
        if (hr)
            goto Cleanup;

        if (fInvoked && ((COmWindowProxy *)pWindowOut)->_fTrusted)
        {
            hr = pWindowOut->QueryInterface(IID_IDispatch, (LPVOID*)&V_DISPATCH(pvarOut));
            ReleaseInterface(pWindowOut);
            if (hr)
                goto Cleanup;
        }
        else
        {
            V_DISPATCH(pvarOut) = pWindowOut;
        }

        V_VT(pvarOut) = VT_DISPATCH;
    }
    
Cleanup:
    ReleaseInterface(pCommandTarget);
    ReleaseInterface(pWindow);
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     COmWindowProxy::SecureWindow
//
//  Synopsis:   Wrap the correct proxy around this object if
//              necessary.  Check in cache if a proxy already exists
//              for this combination.
//
//--------------------------------------------------------------------------
HRESULT
COmWindowProxy::SecureObject(
    IHTMLWindow2 *pWindowIn, 
    IHTMLWindow2 **ppWindowOut, 
    BOOL    fForceSecureProxy ) /*= TRUE*/
    {
    IHTMLWindow2 *      pWindow = NULL;
    HRESULT             hr = S_OK;
    COmWindowProxy *    pProxy = NULL;
    COmWindowProxy *    pProxyIn = NULL;

    if (!pWindowIn)
    {
        *ppWindowOut = NULL;
        goto Cleanup;
    }

    //
    // First if pWindowIn is itself a proxy, delve all the way
    // through to find the real IHTMLWindow2 that it's bound to
    //

    hr = THR_NOTRACE(pWindowIn->QueryInterface(
            CLSID_HTMLWindowProxy, (void **)&pProxyIn));
    if (!hr)
    {
        //
        // No need to further delve down because with this check
        // we're asserting that a proxy to a proxy can never exist.
        // Remember that pProxyIn is a weak ref.
        //
        
        pWindowIn = pProxyIn->_pWindow;
    }

    //
    // Create a new proxy with this window's security context for the 
    // new window.  Test the cache to see if we already have a proxy 
    // created for this combination first.
    //

    hr = THR(EnsureWindowInfo());
    if (hr)
        goto Cleanup;

    hr = THR_NOTRACE(TLS(windowInfo.paryWindowTbl)->FindProxy(
            pWindowIn, 
            _pbSID,
            _cbSID,
            _fTrustedDoc,
            &pWindow, 
            fForceSecureProxy));     // fForceSecureProxy = TRUE.
    if (!hr)
    {
        //
        // We found an entry, just return this one.
        //

        *ppWindowOut = pWindow;
        pWindow->AddRef();
    }
    else
    {
        //
        // No entry in cache for this tuple, so create a new proxy
        // and add to cache
        //
        
        pProxy = new COmWindowProxy;
        if (!pProxy)
            RRETURN(E_OUTOFMEMORY);

        hr = THR(pProxy->Init(pWindowIn, _pbSID, _cbSID));
        if (hr)
            goto Cleanup;

        // Set the trusted attribute for this new proxy.  If this proxy is 
        // for a trusted doc, the new one should be too.
        pProxy->_fTrustedDoc = _fTrustedDoc;
        pProxy->_fDomainChanged = _fDomainChanged;

        // Implicit AddRef/Release for pProxy
        *ppWindowOut = (IHTMLWindow2 *)pProxy;

        hr = THR(TLS(windowInfo.paryWindowTbl)->AddTuple(
                pWindowIn, 
                _pbSID, 
                _cbSID,
                _fTrustedDoc,
                *ppWindowOut));
        if (hr)
            goto Cleanup;
    }
    
Cleanup:
    RRETURN(hr);
}



//+-------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::AccessAllowed
//
//  Synopsis:   Tell if access is allowed based on urls.
//
//  Returns:    TRUE if allowed, FALSE otherwise.
//
//  Notes:      Access is allowed if the second tier domain is the
//              same.  I.e. www.usc.edu and ftp.usc.edu can access
//              each other.  However, www.usc.com and www.usc.edu 
//              cannot.  Neither can www.stanford.edu and www.usc.edu.
//
//--------------------------------------------------------------------------

BOOL
COmWindowProxy::AccessAllowed()
{
    HRESULT hr;
    BOOL    fDomainChanged;
    BYTE    abSID[MAX_SIZE_SECURITY_ID];
    DWORD   cbSID = ARRAY_SIZE(abSID);
    
    if (_fTrusted || _fTrustedDoc)
        return TRUE;

    hr = THR(GetSIDOfDispatch(_pWindow, abSID, &cbSID, &fDomainChanged));
    if (hr)
        return FALSE;
        
    return (cbSID == _cbSID && !memcmp(abSID, _pbSID, cbSID) && (!!_fDomainChanged) == fDomainChanged);
}

// Same as above but use passed in IDispatch *
//
BOOL
COmWindowProxy::AccessAllowed(IDispatch *pDisp)
{
    HRESULT hr;
    BOOL    fDomainChanged;
    CStr    cstr;
    BYTE    abSID[MAX_SIZE_SECURITY_ID];
    DWORD   cbSID = ARRAY_SIZE(abSID);


    hr = THR(GetSIDOfDispatch(pDisp, abSID, &cbSID, &fDomainChanged));
    if (hr)
        return FALSE;
        
    return (cbSID == _cbSID && !memcmp(abSID, _pbSID, cbSID) && (!!_fDomainChanged) == fDomainChanged);
}



//+-------------------------------------------------------------------------
//
//  Method:     COmWindowProxy::FireEvent
//
//  Synopsis:   CBase doesn't allow an EVENTPARAM, which we need.
//
//--------------------------------------------------------------------------

HRESULT
COmWindowProxy::FireEvent(
    DISPID dispidEvent, 
    DISPID dispidProp, 
    LPCTSTR pchEventType,
    CVariant *pVarRet,
    BOOL *pfRet)
{
    HRESULT         hr;
    CWindow *       pWindow = Window();

    IHTMLEventObj  *pEventObj = NULL;
    CVariant        Var;

    AssertSz(pWindow && pWindow->Doc(),"Possible Async Problem Causing Watson Crashes");

#if DBG==1 
    // return secure object on QI while firing the event. otherwise script uses trusted proxy.
    if (IsTagEnabled(tagSecureScriptWindow))
        DebugHackSecureProxyForOm(pWindow->Markup()->GetScriptCollection()->_pSecureWindowProxy);
#endif

    // Creating this causes it to be added to a linked list on the
    // doc. Even though this looks like param is not used, DON'T REMOVE
    // THIS CODE!!
    EVENTPARAM param(pchEventType ? pWindow->Doc() : NULL, NULL, pWindow->Markup(), TRUE);

    if (pchEventType)
    {
        Assert(pWindow->Doc()->_pparam == &param);
        param.SetType(pchEventType);
    }

    if (pfRet && !pVarRet)
        pVarRet = &Var;

    // Get the eventObject.
    Assert(pWindow->Doc()->_pparam);
    CEventObj::Create(&pEventObj, pWindow->Doc(), NULL, pWindow->Markup());

    hr = THR(InvokeEvent(dispidEvent, 
                            dispidProp,
                            pEventObj,
                            pVarRet));

    if (pfRet)
    {
        Assert(pVarRet);
        VARIANT_BOOL vb;
        vb = (V_VT(pVarRet) == VT_BOOL) ? V_BOOL(pVarRet) : VB_TRUE;
        *pfRet = !pWindow->Doc()->_pparam->IsCancelled() && (VB_TRUE == vb);
    }

    // Any attachEvents?  Need to fire on window itself.
    hr = THR(pWindow->InvokeAttachEvents(dispidProp, NULL, NULL, pWindow, NULL, NULL, pEventObj));

    ReleaseInterface(pEventObj);

#if DBG==1 
    if (IsTagEnabled(tagSecureScriptWindow))
        DebugHackSecureProxyForOm(NULL);
#endif
    
    RRETURN(hr);
}

//+-------------------------------------------------------------------------
//
//  Method:     COmWindowProxy::Fire_onerror
//
//  Synopsis:   Fires the onerror event and returns S_FALSE if ther was not script
//              or the script returned S_FALSE requesting default processing
//
//       NOTE:  While this event handler returns TRUE to tell the browser to take no 
//                further action, most Form and form element event handles return false to 
//                prevent the browser from performing some action such as submitting a form.
//              This inconsistency can be confusing.
//--------------------------------------------------------------------------

BOOL 
COmWindowProxy::Fire_onerror(BSTR bstrMessage, BSTR bstrUrl,
                             long lLine, long lCharacter, long lCode,
                             BOOL fWindow)
{
    HRESULT         hr;
    VARIANT_BOOL    fRet = VB_FALSE;
    CWindow *       pWindow = Window();
    CDoc *          pDoc = pWindow ? pWindow->Doc() : NULL;

    // sanity check...
    // This window proxy MUST be a trusted proxy, since we only give 
    // trusted proxies to script engines
    Assert(_fTrusted && AccessAllowed());

    EVENTPARAM param(pDoc, NULL, pWindow ? pWindow->Markup() : NULL, TRUE);

    if (!pWindow || !pDoc)
    {
        AssertSz(0,"Possible Async Problem Causing Watson Crashes");
        hr = E_FAIL;
        goto Cleanup;
    }

    param.SetType(_T("error"));
    param.errorParams.pchErrorMessage = bstrMessage;
    param.errorParams.pchErrorUrl = bstrUrl;
    param.errorParams.lErrorLine = lLine;
    param.errorParams.lErrorCharacter = lCharacter;
    param.errorParams.lErrorCode = lCode;

    if (fWindow)
    {
        Assert(pWindow);

        hr = THR(pWindow->FireEventV(DISPID_EVMETH_ONERROR, DISPID_EVPROP_ONERROR, NULL, &fRet,
            byOnErrorParamTypes, bstrMessage, bstrUrl, lLine));
        if (hr)
            goto Cleanup;

        hr = pWindow->ShowErrorDialog(&fRet);
    }
    else
        hr = THR(FireEventV(DISPID_EVMETH_ONERROR, DISPID_EVPROP_ONERROR, NULL, &fRet,
            byOnErrorParamTypes, bstrMessage, bstrUrl, lLine));

    if (hr)
        goto Cleanup;

    if (    (fRet != VB_TRUE)
        &&  (V_VT(&param.varReturnValue) == VT_BOOL)
        &&  (V_BOOL(&param.varReturnValue) == VB_TRUE))
        fRet = VB_TRUE;

Cleanup:  
    return (fRet == VB_TRUE);
}

//+-------------------------------------------------------------------------
//
//  Method:     COmWindowProxy::Fire_onscroll
//
//  Synopsis:
//
//--------------------------------------------------------------------------

void
COmWindowProxy::Fire_onscroll()
{
    FireEvent(DISPID_EVMETH_ONSCROLL, DISPID_EVPROP_ONSCROLL, _T("scroll"));
    Window()->Fire_onscroll();
}

void
COmWindowProxy::EnableAutoImageResize()
{

    CDoc             *pDoc     = Window()->Doc();
    ITridentService2 *pTriSvc2 = NULL;
    HRESULT           hr       = S_OK;
    
    // check to see if this is flagged as a single image on a page
    if (!pDoc->_fShouldEnableAutoImageResize)
        return; 

    // init CAutoImageResize
    if (pDoc->_pTridentSvc)
        hr = pDoc->_pTridentSvc->QueryInterface(IID_ITridentService2, (void **)&pTriSvc2);

    if (SUCCEEDED(hr) && pTriSvc2)
    {
        pTriSvc2->InitAutoImageResize();
        pTriSvc2->Release();
    }

}
    
void
COmWindowProxy::DisableAutoImageResize()
{
    
    CDoc             *pDoc     = Window()->Doc();
    ITridentService2 *pTriSvc2 = NULL;
    HRESULT           hr       = S_OK;
    
    if (pDoc->_pTridentSvc)
        hr = pDoc->_pTridentSvc->QueryInterface(IID_ITridentService2, (void **)&pTriSvc2);

    // uninit CAutoImageResize
    if (SUCCEEDED(hr) && pTriSvc2)
    {
        pTriSvc2->UnInitAutoImageResize();
        pTriSvc2->Release();
    }

    // turn off the feature
    pDoc->_fShouldEnableAutoImageResize = FALSE;

}

//+-------------------------------------------------------------------------
//
//  Method:     COmWindowProxy::AttachMyPics
//
//  Synopsis:   Creates a new CMyPics instance for this window via
//              ITridentService2
//
//--------------------------------------------------------------------------

HRESULT COmWindowProxy::AttachMyPics() 
{
    HRESULT           hr        = S_OK;
    CDoc             *pDoc      = Window() ? Window()->Doc() : NULL;
    CDocument        *pDocument = Document();
    IHTMLDocument2   *pDoc2     = NULL;
    ITridentService2 *pTriSvc2  = NULL;

    if (_pMyPics)
        ReleaseMyPics();
    
    if (!pDocument)
        goto Cleanup;

    if (_bDisabled || _dwMyPicsState != 0 )
        return (hr);

    if (pDocument)
        hr = pDocument->QueryInterface(IID_IHTMLDocument2, (void **)&pDoc2);
    if (FAILED(hr))
        goto Cleanup;

    if (!Window() || !Window()->Doc())
    {
        AssertSz(0,"Possible Async Problem Causing Watson Crashes");
        return(E_FAIL);
    }

    if (pDoc->_pTridentSvc)
        hr = pDoc->_pTridentSvc->QueryInterface(IID_ITridentService2, (void **)&pTriSvc2);
    if (FAILED(hr))
        goto Cleanup;

    if (pDoc2 && pTriSvc2) 
    {
        pTriSvc2->AttachMyPics(pDoc2, &_pMyPics);
        if (pDocument->GetGalleryMeta() == FALSE)
        {
            pTriSvc2->IsGalleryMeta(FALSE, _pMyPics);
        }
        hr = S_OK;
    }

    if (_pMyPics)
        _dwMyPicsState++;

Cleanup:
    if (pDoc2)
        pDoc2->Release();

    if (pTriSvc2)
        pTriSvc2->Release();

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Method:     COmWindowProxy::ReleaseMyPics
//
//  Synopsis:   Destroys the CMyPics instance for this window via
//              ITridentService2
//
//--------------------------------------------------------------------------

HRESULT COmWindowProxy::ReleaseMyPics() 
{

    HRESULT           hr        = S_OK;
    CDoc             *pDoc      = Window()->Doc();
    ITridentService2 *pTriSvc2  = NULL;


    if (pDoc->_pTridentSvc)
        hr = pDoc->_pTridentSvc->QueryInterface(IID_ITridentService2, (void **)&pTriSvc2);

    if (FAILED(hr))
        goto Cleanup; 

    if (_pMyPics && pTriSvc2) {
        void *p = _pMyPics;
        _pMyPics = NULL;
        _bDisabled = pTriSvc2->ReleaseMyPics(p);
        _dwMyPicsState--;
    }

Cleanup:

    if (pTriSvc2)
        pTriSvc2->Release();

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Method:     COmWindowProxy::DestroyMyPics
//
//  Synopsis:   Destroys the CMyPics instance for this window via
//              ITridentService2
//
//--------------------------------------------------------------------------

HRESULT COmWindowProxy::DestroyMyPics()
{
    if (_pMyPics)
        ReleaseMyPics();

    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Method:     COmWindowProxy::Fire_onload, Fire_onunload
//
//  Synopsis:   Fires the onload/onunload events of the window
//      these all call the CBase::FireEvent variant that takes the CBase *
//
//--------------------------------------------------------------------------

void
COmWindowProxy::Fire_onload()
{
    CWindow * pWindow = Window();
    CFrameSite * pFrameSite = NULL;

    if (!pWindow || !pWindow->Markup() || !pWindow->Markup()->Doc())
    {
        AssertSz(0,"Possible Async Problem Causing Watson Crashes");
        return;
    }

    pFrameSite = pWindow->GetFrameSite();

    // Bugfix:27622: GWPostMethodCall is skipped only for InstallShield (g_fInInstallShield=TRUE)
    if (!_fQueuedOnload && 
        pWindow->Markup()->Doc()->GetView()->HasDeferredTransition() && !g_fInInstallShield)
    {
        IGNORE_HR(GWPostMethodCall(this, 
                                    ONCALL_METHOD(COmWindowProxy, DeferredFire_onload, deferredfire_onload), 
                                    0, FALSE, "COmWindowProxy::DeferredFire_onload"));
        _fQueuedOnload = TRUE;
    }
    else
    {
        // prepare for the next navigation of this window
        _fQueuedOnload = FALSE;

        if (pFrameSite)
            pFrameSite->AddRef();

        FireEvent(DISPID_EVMETH_ONLOAD, DISPID_EVPROP_ONLOAD, _T("load"));

        pWindow->Fire_onload();
    
        if (pFrameSite)
        {
            pFrameSite->FireEvent(&s_propdescCFrameSiteonload);
            pFrameSite->Release();
        }

        if (pWindow->IsPrimaryWindow())
        {
            CMarkupBehaviorContext * pContext = NULL;

            if (S_OK == Markup()->EnsureBehaviorContext(&pContext))
            {
                ClearInterface(&(pContext->_pXMLHistoryUserData));
                pContext->_cstrHistoryUserData.Free();
            }

            ClearInterface(&(pWindow->Doc()->_pShortcutUserData));
        }

        AttachMyPics();
        EnableAutoImageResize();

        IGNORE_HR(pWindow->FireAccessibilityEvents(DISPID_EVMETH_ONLOAD));

#ifdef V4FRAMEWORK
        {
            IExternalDocument *pFactory;
            pFactory = pWindow->Doc()->EnsureExternalFrameWork();
            if (pFactory) 
                IGNORE_HR(pFactory->OnLoad());
        }
#endif V4FRAMEWORK
    }
}

void
COmWindowProxy::DeferredFire_onload( DWORD_PTR dwContext )
{
    Fire_onload();
}

void
COmWindowProxy::Fire_onunload()
{
    CWindow * pWindow = Window();

    if (!pWindow || !pWindow->Markup() || !pWindow->Markup()->Doc())
    {
        AssertSz(0,"Possible Async Problem Causing Watson Crashes");
        return;
    }

    FireEvent(DISPID_EVMETH_ONUNLOAD, DISPID_EVPROP_ONUNLOAD, _T("unload"));

    // fire for window connection points 
    pWindow->Fire_onunload();

    IGNORE_HR(pWindow->FireAccessibilityEvents(DISPID_EVMETH_ONUNLOAD));
        
    CMarkup *pMarkup = Markup(); 
    Assert(pMarkup);

    if (pMarkup->_fHasFrames)
    {
        CNotification   nf;    
                               
        nf.OnUnload(pMarkup->Root());
        pMarkup->Notify(&nf);
    }

    if (pMarkup->Doc()->_pClientSite)
    {
        IGNORE_HR(CTExec(pMarkup->Doc()->_pClientSite, &CGID_DocHostCmdPriv,
                         DOCHOST_READYSTATE_INTERACTIVE, NULL, NULL , NULL));
    }                                     

    if (_dwMyPicsState)
        ReleaseMyPics();

}

BOOL 
COmWindowProxy::Fire_onhelp()
{
    BOOL fRet = TRUE;
    FireEvent(DISPID_EVMETH_ONHELP, DISPID_EVPROP_ONHELP, _T("help"), NULL, &fRet);
    return (fRet && Window()->Fire_onhelp());
}

void 
COmWindowProxy::Fire_onresize()
{
    FireEvent(DISPID_EVMETH_ONRESIZE, DISPID_EVPROP_ONRESIZE, _T("resize"));
    Window()->Fire_onresize();
}

BOOL
COmWindowProxy::Fire_onbeforeunload()
{
    CWindow * pOmWindow2 = Window();
    BOOL fRetval = TRUE;
    CDocument *pDocument = Document();

    if (!pOmWindow2 || !pOmWindow2->Doc())
    {
        AssertSz(0,"Possible Async Problem Causing Watson Crashes");
        return FALSE;
    }

    if (!pOmWindow2->_fOnBeforeUnloadFiring)
    {
        HRESULT hr = S_OK;
        CDoc *pDoc = pOmWindow2->Doc();
        CVariant    varRetval;
        CVariant  * pvarString = NULL;
        EVENTPARAM  param(pDoc, NULL, pOmWindow2->Markup(), TRUE);

        pOmWindow2->_fOnBeforeUnloadFiring = TRUE;

        param.SetType(_T("beforeunload"));

        hr = THR(FireEvent(DISPID_EVMETH_ONBEFOREUNLOAD, DISPID_EVPROP_ONBEFOREUNLOAD, NULL, &varRetval));

        // if we have an event.retValue use that rather then the varRetval
        if (S_FALSE != param.varReturnValue.CoerceVariantArg(VT_BSTR))
        {
            pvarString = &param.varReturnValue;
        }
        else if (S_FALSE != varRetval.CoerceVariantArg(VT_BSTR))
        {
            pvarString = &varRetval;
        }

        // if we have a return string, show it
        if (!hr && pvarString)
        {
            int iResult = 0;
            TCHAR *pstr;
            Format(FMT_OUT_ALLOC,
                   &pstr,
                   64,
                   _T("<0i>\n\n<2s>\n\n<3i>"),
                   GetResourceHInst(),
                   IDS_ONBEFOREUNLOAD_PREAMBLE,
                   V_BSTR(pvarString),
                   GetResourceHInst(),
                   IDS_ONBEFOREUNLOAD_POSTAMBLE);
            pDoc->ShowMessageEx(&iResult,
                          MB_OKCANCEL | MB_ICONWARNING | MB_SETFOREGROUND,
                          NULL,
                          0,
                          pstr);
            delete pstr;
            if (iResult == IDCANCEL)
                fRetval = FALSE;
        }

        CMarkup *pMarkup = Markup();        
        Assert(pMarkup);

        if (fRetval && pMarkup->_fHasFrames)
        {
            CNotification   nf;
            
            nf.BeforeUnload(pMarkup->Root(), &fRetval);        
            pMarkup->Notify(&nf);        
        }

        if (fRetval)
            fRetval = pOmWindow2->Fire_onbeforeunload();

        pOmWindow2->_fOnBeforeUnloadFiring = FALSE;
    }

    if (pDocument)
        pDocument->SetGalleryMeta(TRUE);

    DisableAutoImageResize();

    return fRetval;
}


//+-------------------------------------------------------------------------
//
//  Method:     COmWindowProxy::Fire_onfocus, Fire_onblur
//
//  Synopsis:   Fires the onfocus/onblur events of the window
//
//--------------------------------------------------------------------------

void COmWindowProxy::Fire_onfocus(DWORD_PTR dwContext)
{                   
    CWindow *       pWindow = Window();

    if (pWindow->Doc()->IsPassivated())
        return;
    
    CDoc::CLock LockForm(pWindow->Doc(), FORMLOCK_CURRENT);

    FireEvent(DISPID_EVMETH_ONFOCUS, DISPID_EVPROP_ONFOCUS, _T("focus"));

    // fire for window connection points 
    pWindow->Fire_onfocus();


    // fire for accessibility, if its enabled
    IGNORE_HR(pWindow->FireAccessibilityEvents(DISPID_EVMETH_ONFOCUS));
}

void COmWindowProxy::Fire_onblur(DWORD_PTR dwContext)
{
    CWindow *       pWindow = Window();

    if (pWindow->Doc()->IsPassivated())
        return;

    CDoc::CLock LockForm(pWindow->Doc(), FORMLOCK_CURRENT);

    pWindow->Doc()->_fModalDialogInOnblur = (BOOL)dwContext;
    FireEvent(DISPID_EVMETH_ONBLUR, DISPID_EVPROP_ONBLUR, _T("blur"));

    // fire for window connection points 
    pWindow->Fire_onblur();

    // fire for accessibility, if its enabled
    IGNORE_HR(pWindow->FireAccessibilityEvents(DISPID_EVMETH_ONBLUR));

    pWindow->Doc()->_fModalDialogInOnblur = FALSE;
}

void COmWindowProxy::Fire_onbeforeprint()
{
    FireEvent(DISPID_EVMETH_ONBEFOREPRINT, DISPID_EVPROP_ONBEFOREPRINT, _T("beforeprint"));
    Window()->Fire_onbeforeprint();
}

void COmWindowProxy::Fire_onafterprint()
{
    FireEvent(DISPID_EVMETH_ONAFTERPRINT, DISPID_EVPROP_ONAFTERPRINT, _T("afterprint"));
    Window()->Fire_onafterprint();
}

//+-------------------------------------------------------------------------
//
//  Method:     COmWindowProxy::CanMarshallIID
//
//  Synopsis:   Return TRUE if this iid can be marshalled.
//              Keep in sync with QI below.
//
//--------------------------------------------------------------------------

BOOL
COmWindowProxy::CanMarshalIID(REFIID riid)
{
    return (riid == IID_IUnknown ||
            riid == IID_IDispatch ||
            riid == IID_IHTMLFramesCollection2 ||
            riid == IID_IHTMLWindow2 ||
            riid == IID_IHTMLWindow3 ||
            riid == IID_IHTMLWindow4 ||
            riid == IID_IDispatchEx ||
            riid == IID_IObjectIdentity ||
            riid == IID_IServiceProvider) ? TRUE : FALSE;
}


//+---------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::IsOleProxy
//
//  Returns:    BOOL      True if _pWindow is actually an OLE proxy.
//
//  Notes:      It performs this check by QI'ing for IClientSecurity.
//              Only OLE proxies implement this interface.
//
//----------------------------------------------------------------------------

BOOL
COmWindowProxy::IsOleProxy()
{
    BOOL                fRet = FALSE;

#ifndef WIN16       //BUGWIN16 deal with this for cross process support
    IClientSecurity *   pCL;

    if (OK(_pWindow->QueryInterface(IID_IClientSecurity, (void **)&pCL)))
    {
        ReleaseInterface(pCL);

        // Only proxy objects should support this interface.
        fRet = TRUE;
    }
#endif

    return fRet;
}

//+-------------------------------------------------------------------------
//
//  Method:     COmWindowProxy::GetSecurityThunk
//
//--------------------------------------------------------------------------

HRESULT
COmWindowProxy::GetSecurityThunk(LPVOID * ppv, BOOL fPending)
{
    HRESULT                 hr = S_OK;
    CSecurityThunkSub *     pThunkSub;
    LPVOID  *               ppvSecurityThunk;


    // get the address of the variable we want to update.
    if (fPending)
    {
        ppvSecurityThunk = &_pvSecurityThunkPending;
    }
    else
    {
        ppvSecurityThunk = &_pvSecurityThunk;
    }

    if (!(*ppvSecurityThunk))
    {
        pThunkSub = new CSecurityThunkSub(this, 
                                          fPending ? CSecurityThunkSub::EnumSecThunkTypePendingWindow 
                                                   : CSecurityThunkSub::EnumSecThunkTypeWindow);
        if (!pThunkSub)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = CreateTearOffThunk(
            this,                                   // pvObject1
            (void*) s_apfnIDispatchEx,              // apfn1
            NULL,                                   // pUnkOuter
            ppvSecurityThunk,                       // ppvThunk
            pThunkSub,                              // pvObject2
            *(void **)(IUnknown*)pThunkSub,         // apfn2
            QI_MASK | ADDREF_MASK | RELEASE_MASK,   // dwMask
            g_apIID_IDispatchEx);                   // appropdescsInVtblOrder            

        if (hr)
            goto Cleanup;
    }

    // set the return value
    *ppv = *ppvSecurityThunk;

Cleanup:
    RRETURN (hr);
}

//+-------------------------------------------------------------------------
//
//  Method:     COmWindowProxy::PrivateQueryInterface
//
//  Synopsis:   Per IPrivateUnknown
//
//--------------------------------------------------------------------------

HRESULT
COmWindowProxy::PrivateQueryInterface(REFIID iid, LPVOID * ppv)
{
    void *  pvObject = NULL;
    HRESULT hr = S_OK;
    
    *ppv = NULL;

    if (_fTrusted && 
        (iid == IID_IUnknown || 
        iid == IID_IDispatch || 
        iid == IID_IDispatchEx))
    {
#if DBG==1
        if (_pSecureProxyForOmHack)
            return _pSecureProxyForOmHack->PrivateQueryInterface(iid, ppv);
#endif
        // create a security thunk and give its reference instead of giving this object.
        hr = GetSecurityThunk(ppv, FALSE);
        goto Cleanup;
    }
    //  else do nothing
    
    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_INHERITS(this, IHTMLWindow2)
        QI_INHERITS(this, IHTMLWindow3)
        QI_INHERITS(this, IHTMLWindow4)
        QI_INHERITS2(this, IHTMLFramesCollection2, IHTMLWindow2)

        QI_TEAROFF_DISPEX(this, NULL)
        QI_TEAROFF(this, IMarshal, NULL)
        QI_TEAROFF(this, IObjectIdentity, NULL)
        QI_TEAROFF(this, IServiceProvider, NULL);

#if DBG==1
        QI_TEAROFF(this,  IDebugWindowProxy, NULL)
#endif

        // NOTE: Any new tearoffs or inheritance classes in the QI need to have
        //       the appropriate IID placed in the COmWindowProxy::CanMarshallIID
        //       function.  This allows the marshaller/unmarshaller to actually
        //       support this object being created if any of the above interface
        //       are asked for first.  Once the object is marshalled all
        //       subsequent QI's are to the same marshalled object.

        QI_CASE(IConnectionPointContainer)
        {
            if (IsOleProxy())
            {
                // IConnectionPointerContainer interface is to the real
                // window object not this marshalled proxy.  The IUknown
                // will be this objects (for identity). 
                goto DelegateToWindow;
            }
            else
            {
                *((IConnectionPointContainer **)ppv) =
                        new CConnectionPointContainer(this, NULL);

                if (!*ppv)
                    RRETURN(E_OUTOFMEMORY);
            }
            break;
        }
            
        QI_FALLTHRU(IProvideMultipleClassInfo, IHTMLPrivateWindow2)
        QI_FALLTHRU(IProvideClassInfo, IHTMLPrivateWindow2)
        QI_FALLTHRU(IProvideClassInfo2, IHTMLPrivateWindow2)
        QI_FALLTHRU(ITravelLogClient, IHTMLPrivateWindow2)
        QI_FALLTHRU(IHTMLPrivateWindow, IHTMLPrivateWindow2)
        QI_CASE(IHTMLPrivateWindow2)
        {
DelegateToWindow:
            //
            // For these cases, just delegate on down to the real window
            // with our IUnknown.
            //
            hr = THR_NOTRACE(_pWindow->QueryInterface(iid, &pvObject));
            if (hr)
                RRETURN(hr);

            hr = THR(CreateTearOffThunk(
                    pvObject, 
                    *(void **)pvObject,
                    NULL,
                    ppv,
                    (IUnknown *)(IPrivateUnknown *)this,
                    *(void **)(IUnknown *)(IPrivateUnknown *)this,
                    1,      // Call QI on object 2.
                    NULL));

            ((IUnknown *)pvObject)->Release();
            if (!*ppv)
                RRETURN(E_OUTOFMEMORY);
            break;
        }
        
        default:
            if (DispNonDualDIID(iid))
            {
                *ppv = (IHTMLWindow2 *)this;
            }
            else if (iid == CLSID_HTMLWindowProxy)
            {
                *ppv = this; // Weak ref.
                return S_OK;
            }
            break;
    }

Cleanup:
    if (*ppv)
    {
        ((IUnknown *)*ppv)->AddRef();
        DbgTrackItf(iid, "COmWindowProxy", FALSE, ppv);
        return S_OK;
    }

    return E_NOINTERFACE;
}

//+-------------------------------------------------------------------------
//
//  Method:     COmWindowProxy::PrivateAddRef
//
//  Synopsis:   Per IPrivateUnknown
//
//--------------------------------------------------------------------------

ULONG
COmWindowProxy::PrivateAddRef()
{
    //
    // Transfer external references to markup.  
    //
    
    if (_ulRefs == 1 && 
        _fTrusted && 
        Window()->_pMarkup && 
        Window()->_pMarkup->Window() == this)
    {
        Window()->_pMarkup->AddRef();
    }

    return super::PrivateAddRef();
}


//+------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::PrivateRelease, IUnknown
//
//  Synopsis:   Private unknown Release.
//
//-------------------------------------------------------------------------

ULONG
COmWindowProxy::PrivateRelease()
{
    CMarkup * pMarkup = NULL;

    if (_ulRefs == 2 && 
        _fTrusted &&
        Window()->_pMarkup->Window() == this)
    {
        pMarkup = Window()->_pMarkup;
    }

    ULONG ret = super::PrivateRelease();

    if (pMarkup)
    {
        pMarkup->Release();
    }

    return ret;
}


//+------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::OnSetWindow
//
//  Synopsis:   Ref counting fixup as tree entered.
//
//-------------------------------------------------------------------------

void
COmWindowProxy::OnSetWindow()
{
    Assert(_fTrusted);

    // This is a ref from the Markup to the TWP
    super::PrivateAddRef();

    // One ref from the Markup to TWP
    // One ref from the stack
    Assert( _ulRefs >= 2 );
    Window()->_pMarkup->AddRef();
}


//+------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::OnClearWindow
//
//  Synopsis:   Ref counting fixup as tree exited.
//
//-------------------------------------------------------------------------

void
COmWindowProxy::OnClearWindow(CMarkup * pMarkupOld, BOOL fFromRestart /* FALSE */)
{
    CWindow * pWindow;
    CDocument *pDocument = Document();
    BOOL      fReleaseMarkup = _ulRefs > 1;

    Assert(_fTrusted);
    pWindow = Window();

    TraceTag((tagSecurity, "COmWindowProxy::OnClearWindow() - this:[0x%x] pWindow:[0x%x]", this, pWindow));

    // Kill all the timers
    pWindow->CleanupScriptTimers();  
    pWindow->KillMetaRefreshTimer();

    pWindow->ClearCachedDialogs();

    ClearInterface(&pWindow->_pBindCtx);

    if (!fFromRestart)
    {
        if (*pWindow->GetAttrArray())
        {
            (*pWindow->GetAttrArray())->FreeSpecial();
        }

        delete *GetAttrArray();
        SetAttrArray(NULL);

        if (*pDocument->GetAttrArray())
        {
            (*pDocument->GetAttrArray())->FreeSpecial();
        }
    }

    pDocument->_eHTMLDocDirection = htmlDirNotSet;
    
    GWKillMethodCall(Document(), ONCALL_METHOD(CDocument, FirePostedOnPropertyChange, firepostedonpropertychange), 0);

    pMarkupOld->TerminateLookForBookmarkTask();

    Assert(pWindow->_pMarkup == pMarkupOld);

    pWindow->_pMarkup->SubRelease();
    pWindow->_pMarkup = NULL;

    pWindow->_fNavFrameCreation = FALSE;

    super::PrivateRelease();
    if (fReleaseMarkup)
    {
        pMarkupOld->Release();
    }
}

void
CWindow::ReleaseMarkupPending(CMarkup * pMarkup)
{
    Assert(!pMarkup->_fWindow);
    Assert(pMarkup->_fWindowPending);

    // (jbeda) cover our asses here
    if (   !pMarkup->HasWindowPending() 
        || (pMarkup->GetWindowPending()->Window() != this)
        || (pMarkup->GetWindowPending()->Window()->_pMarkupPending != pMarkup))
    {
        TraceTag((tagSecurity, "CWindow::ReleaseMarkupPending inconsistent information about pending markups and windows"));
        return;
    }

    if (pMarkup->IsPendingPrimaryMarkup())
    {
        CDoc * pDoc = Doc();
        if (pDoc)
            pDoc->_fBlockNonPending = FALSE;
    }

    // handle the pending script errors without firing any events
    HandlePendingScriptErrors(FALSE);
    if (pMarkup != _pMarkupPending)
        return;

    ReleaseViewLinkedWebOC();
    if (pMarkup != _pMarkupPending)
        return;

    IGNORE_HR(pMarkup->CMarkup::UnloadContents(FALSE));
    if (pMarkup != _pMarkupPending)
        return;

    Assert(!pMarkup->_fWindow);
    Assert(pMarkup->_fWindowPending);

    Assert(  !(   pMarkup->IsPassivated()
               || pMarkup->IsPassivating())
           &&  pMarkup->GetWindowPending()->Window() == this);

    // TODO: (jbeda) this shouldn't be necessary but...
    pMarkup->_fWindow = FALSE;

    pMarkup->_fWindowPending = FALSE;
    pMarkup->DelWindow();

    pMarkup->Release();

    Assert(_pMarkupPending == pMarkup);
    _pMarkupPending = NULL;
}


BOOL    
CWindow::CanNavigate() 
{ 
    return !_ulDisableModeless && (!Doc()->_fDisableModeless && (Doc()->_ulDisableModeless == 0)); 
}

void
CWindow::EnableModelessUp( BOOL fEnable, BOOL fFirst /*=TRUE*/ )
{
    if (fEnable)
    {
        AssertSz(_ulDisableModeless > 0, "CWindow::EnableModeless(TRUE) called more than CWindow::EnableModeless(FALSE)");
        _ulDisableModeless--;

        if (_ulDisableModeless == 0)
        {
            // If we hit zero, then prop to parent
            if (_pWindowParent)
                _pWindowParent->EnableModelessUp( fEnable, FALSE );

            // If we are the first guy, kick all waiting markups
            if (fFirst)
                Doc()->NotifyMarkupsModelessEnable();
        }
    }
    else
    {
        _ulDisableModeless++;

        // first time, prop to parent
        if (_ulDisableModeless == 1 && _pWindowParent)
            _pWindowParent->EnableModelessUp( fEnable, FALSE );
    }
}

//+------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::SwitchMarkup
//
//  Synopsis:   Switch the current markup with the pending one.
//
//-------------------------------------------------------------------------

HRESULT
COmWindowProxy::SwitchMarkup(CMarkup * pMarkupNew,
                             BOOL      fViewLinkWebOC,          /* = FALSE */
                             DWORD     dwTravelLogFlags,        /* = 0     */
                             BOOL      fKeepSecurityIdentity,   /* = 0     */
                             BOOL      fFromRestart             /* = FALSE */)
{
    CWindow *       pWindow = NULL;
    CMarkup *       pMarkupOld = NULL;
    CElement *      pElementMaster;
    CDoc *          pDoc;
    CHtmCtx *       pHtmCtx = pMarkupNew->HtmCtx();
    HRESULT         hr = S_OK;
    htmlDesignMode  designMode;
    BOOL            fDispatchExThunkTrust;
    BOOL            fSetCurrentElementToNewRoot = FALSE;
    BOOL            fClearNewFormats = FALSE;
    BOOL            fPrimarySwitch;
    HRESULT         hrOnStopBind = S_OK;
    CBase::CLock    lock(this);  // we do this so that viewlinks don't crash
    IDispatch*      pIDispXML = NULL;
    IDispatch*      pIDispXSL = NULL;    

    TraceTag((tagSecurityContext, "COmWindowProxy::SwitchMarkup"));
    PerfDbgLog1(tagNFNav, this, "+COmWindowProxy::SwitchMarkup pWindow: %x", Window());

    if (!pMarkupNew->_fWindowPending)
        goto Cleanup;

    Assert( !pMarkupNew->_fPicsProcessPending );

    PerfDbgLog2(tagNFNav, this, "Old Markup %x \"%ls\"", pMarkupOld, pMarkupOld ? pMarkupOld->Url() : _T(""));


    pWindow = Window();

    // Work around because we should save ViewLinkedWebOC stuff on the markup
    // This is so I don't have to pass this flag through multiple levels

    pWindow->_fDelegatedSwitchMarkup = fViewLinkWebOC;

    if (pHtmCtx)
    {
        hr = pHtmCtx->GetBindResult(); 
        hrOnStopBind = pHtmCtx->GetDwnBindDataResult();
    }
    
    if (!fViewLinkWebOC || hr == INET_E_UNKNOWN_PROTOCOL)
        pWindow->ReleaseViewLinkedWebOC();

    ////////////////////////////////////////////////
    // Abort the switch if we have a bad bind result

    if (    (hr == INET_E_UNKNOWN_PROTOCOL)
        || ((hr == INET_E_TERMINATED_BIND || hr == INET_E_REDIRECT_TO_DIR)
            && !fViewLinkWebOC))
    {                   
        pMarkupNew->_fBindResultPending = TRUE;
        goto Cleanup;     
    }
    
    if (   hr == INET_E_RESOURCE_NOT_FOUND
       ||  hr == INET_E_DATA_NOT_AVAILABLE
       ||  hr == E_ACCESSDENIED 
       ||  hr == E_ABORT
       ||  pMarkupNew->_fStopDone
       ||  ( hrOnStopBind == INET_E_DOWNLOAD_FAILURE 
             && IsGlobalOffline() ) )
    {            
        pWindow->ReleaseMarkupPending(pMarkupNew);
        goto Cleanup;
    }

    pDoc       = pWindow->Doc();
	
    if (!pDoc)
    {
        AssertSz(0,"Possible Async Problem Causing Watson Crashes");
        hr = E_FAIL;
        goto Cleanup;
    }

    pMarkupOld = pWindow->_pMarkup;
    pMarkupOld->AddRef();   // ClearWindow could passivate it

    fPrimarySwitch = pWindow->IsPrimaryWindow();

    if (_fFiredOnLoad)
    {
        _fFiredOnLoad = FALSE;
        Fire_onunload();

        if (!pMarkupOld->Window() || !pMarkupNew->GetWindowPending())
        {
            // We've been reentered!
            hr = S_OK;
            goto Cleanup;
        }
    }

    // Update the travel log if we are told to do so.
    //
    if (dwTravelLogFlags & TLF_UPDATETRAVELLOG)
    {
        pDoc->UpdateTravelLog(pWindow,
                              FALSE,
                              !pMarkupNew->_fLoadingHistory,
                              !(dwTravelLogFlags & TLF_UPDATEIFSAMEURL),
                              pMarkupNew);
    }

    hr = S_OK;

    ////////////////////////////////////////////////
    ////////////////////////////////////////////////
    //
    // Start tearing down the old markup
    //
    ////////////////////////////////////////////////
    ////////////////////////////////////////////////

    // This is the latest possible point we need to apply the page transitions, because
    // the old markup will be destroyed soon. We need to do this as late as possible, because
    // we need to give the new markup a chance to parse the head section and META tags.
    // Right now SwitchMarkup is called too soon whenever there is a script block in the head
    // so META tags should come before the script tags.
    IGNORE_HR(Document()->ApplyPageTransitions(pMarkupOld, pMarkupNew));

    // TODO (alexz) SwitchMarkup causes events to fire and external code executed,
    // so it has to be called at a safce moment of time. Enable this in IE5.5 B3  (in B2 it asserts
    // all over the place)
    // AssertSz(!pMarkupNew->__fDbgLockTree, "SwitchMarkup is called when the new markup is unstable. This will lead to crashes, memory leaks, and script errors");
    // AssertSz(!pMarkupOld->__fDbgLockTree, "SwitchMarkup is called when the old markup is unstable. This will lead to crashes, memory leaks, and script errors");

    ////////////////////////////////////////////////
    // Tear down the editor for the old markup
    CMarkup* pSelectionMarkup ;
    IGNORE_HR( pDoc->GetSelectionMarkup( & pSelectionMarkup ));
    if (fPrimarySwitch || 
        pSelectionMarkup && pSelectionMarkup->GetElementTop()->IsConnectedToThisMarkup( pMarkupOld ) )
    {
        //
        // Release our edit router, however don't release the editor since this could be in iframe
        //
        if( pMarkupOld->HasEditRouter() )
        {
            pMarkupOld->GetEditRouter()->Passivate();
        }
        
        if (fPrimarySwitch || !pMarkupOld->GetParentMarkup()) // this is the topmost markup
        {
            IGNORE_HR( pDoc->NotifySelection(EDITOR_NOTIFY_DOC_ENDED, NULL) );
            pDoc->ReleaseEditor();
        }
        else
        {
            IUnknown* pUnknown = NULL;
            IGNORE_HR( pMarkupOld->QueryInterface( IID_IUnknown, ( void**) & pUnknown ));
            IGNORE_HR( pDoc->NotifySelection(EDITOR_NOTIFY_CONTAINER_ENDED, pUnknown) );
            ReleaseInterface( pUnknown );
        }
    }

    if ( fPrimarySwitch )
    {
        pDoc->_view.Unload();
        pDoc->_cDie++;
    }
    
    pDoc->FlushUndoData();

    if (fPrimarySwitch || 
        pDoc->GetCurrentMarkup() == pMarkupOld)
    {
        pDoc->_fCurrencySet = FALSE;
        pDoc->_fFirstTimeTab = IsInIEBrowser(pDoc);

        // let go of the security manager and its settings, so we can get it reset
        ClearInterface(&(pDoc->_pSecurityMgr));
    }

    

    ////////////////////////////////////////////////
    // Release nodes in old markup
    if (    pDoc->_pNodeLastMouseOver
        &&  pMarkupOld == pDoc->_pNodeLastMouseOver->GetMarkup())
        CTreeNode::ClearPtr(&pDoc->_pNodeLastMouseOver);
    if (    pDoc->_pNodeGotButtonDown
        &&  pMarkupOld == pDoc->_pNodeGotButtonDown->GetMarkup())
        CTreeNode::ClearPtr(&pDoc->_pNodeGotButtonDown);

    ////////////////////////////////////////////////
    // Reset view link info and copy over 
    // frame options
    pElementMaster = pMarkupOld->Root()->GetMasterPtr();
    if (pElementMaster)
    {
        Assert(pElementMaster->GetSlavePtr() == pMarkupOld->Root());
        hr = THR(pElementMaster->SetViewSlave(pMarkupNew->Root()));
        if (hr)
            goto Cleanup;
    }

    fSetCurrentElementToNewRoot = pDoc->_pElemCurrent->IsConnectedToThisMarkup(pMarkupOld);
    if( fSetCurrentElementToNewRoot )
    {
        pDoc->_pElemUIActive = NULL;
        pDoc->_pElemCurrent = (CElement *)pMarkupOld->Root();
        pDoc->_fCurrencySet = FALSE;
    }

    ////////////////////////////////////////////////
    // Clear the focus flag
    // Should fire window.onblur here?
    _fFiredWindowFocus = FALSE;

    fDispatchExThunkTrust = pMarkupNew->AccessAllowed(pMarkupOld);

    // VID hack (#106628) : allow initial transition from "about:blank"
    if (    !fDispatchExThunkTrust
        &&  fPrimarySwitch
        &&  pDoc->_fVID
        &&  pDoc->_fStartup
        &&  pMarkupOld->_fDesignMode
        &&  pMarkupNew->_fDesignMode
        &&  !(      pMarkupOld->HasLocationContext()
                &&  pMarkupOld->GetLocationContext()->_pchUrl
             )
       )
    {
        fDispatchExThunkTrust = TRUE;
    }


    //
    // Copy the zero grey border bit - IE5 behavior
    //
    if ( pMarkupOld->IsShowZeroBorderAtDesignTime() )
    {
        pMarkupNew->SetShowZeroBorderAtDesignTime( TRUE );
    }
    
    ////////////////////////////////////////////////
    // Actually tear down the old tree
    if( pMarkupOld->IsOrphanedMarkup() )
    {
        // Propagate the orphan-ness of the old markup 
        pMarkupNew->SetOrphanedMarkup( TRUE );
    }
    pMarkupOld->TearDownMarkup(TRUE, TRUE);   // fStop, fSwitch

    if (fPrimarySwitch && pDoc->_pInPlace && pDoc->_pInPlace->_hwnd)
    {
        ValidateRect(pDoc->_pInPlace->_hwnd, NULL);
    }

    ////////////////////////////////////////////////
    // 
    //  Important Note:  This above code can 
    //  cause this code to reenter.  We want
    //  to catch that situation and bail out
    //  of this switch.  Clear the window on
    //  the old markup just to be safe
    // 
    ////////////////////////////////////////////////
    {
        BOOL fEarlyExit = !pMarkupOld->Window() || !pMarkupNew->GetWindowPending();

        if (fEarlyExit)
        {
            // We've been reentered!
            hr = S_OK;
            goto Cleanup;
        }
    }

    ////////////////////////////////////////////////
    // Release current element
    if( fSetCurrentElementToNewRoot )
    {
        pDoc->_pElemUIActive = NULL;
        pDoc->_pElemCurrent = (CElement *) pMarkupNew->Root();  
        pDoc->_fCurrencySet = FALSE;
    }

    // We have to get the designMode before we call ClearWindow
    // because ClearWindow also clears the attrarrays on both 
    // the document and the window.
    designMode = Document()->GetAAdesignMode();

    //
    // IE6 Bug # 19870
    // MSXML has put special expandos on the document - before SwitchMarkup
    // We cache and restore these expandos....
    //
    if ( pMarkupNew->_fLoadingHistory &&
         pDoc->_fStartup &&                 // for XML/XSL viewer - doc has just been created. 
         *Document()->GetAttrArray() &&
         (*Document()->GetAttrArray())->HasExpandos() )
    {
        IGNORE_HR( Document()->GetXMLExpando( & pIDispXML, & pIDispXSL ));
    }
    

    pMarkupOld->ClearWindow(fFromRestart);

    ////////////////////////////////////////////////
    ////////////////////////////////////////////////
    //
    // Swap in the new markup!
    //
    ////////////////////////////////////////////////
    ////////////////////////////////////////////////

    pMarkupNew->_fWindowPending = FALSE;
    pMarkupNew->_fWindow = TRUE;

    if (fPrimarySwitch)
        pDoc->_fBlockNonPending = FALSE;

    // TODO: (jbeda) this if shouldn't be necessary but...
    if (!pMarkupNew->Window())
    {
        pMarkupNew->_fWindow = FALSE;
    }

    Assert(pMarkupNew->Window() == this);

    IGNORE_HR(Document()->SetAAdesignMode(designMode));


    // If either our design mode of the fact that we might inherit our
    // design mode has changed, then we must invalidate all formats (ouch).
    // This is necessary because we render differently depending on design mode.
    // We don't have to check the parent wrt inherit changing since our
    // parent isn't changing.
    if (    pMarkupNew->_fInheritDesignMode != pMarkupOld->_fInheritDesignMode 
        ||  pMarkupNew->_fDesignMode != pMarkupOld->_fDesignMode)
    {
        fClearNewFormats = TRUE;
    }

    // copy the design mode bits
    pMarkupNew->_fInheritDesignMode = pMarkupOld->_fInheritDesignMode;
    pMarkupNew->_fDesignMode = pMarkupOld->_fDesignMode;  

    pWindow->_pMarkup = pMarkupNew;
    pMarkupNew->SubAddRef();

    Assert(pWindow->_pMarkupPending == pMarkupNew);

    OnSetWindow();  // OnSetWindow will addref pMarkupNew

    pMarkupNew->UpdateSecurityID();

    if (pMarkupOld->HasCollectionCache())
    {
        CCollectionCacheItem *pCItem = pMarkupOld->CollectionCache()->GetCacheItem(CMarkup::ELEMENT_COLLECTION);
        Assert(pCItem);
        DYNCAST(CAllCollectionCacheItem, pCItem)->SetMarkup(NULL);
    }

    TraceTag((tagSecurityContext, "COmWindowProxy::SwitchMarkup - Switched markups from 0x%x to 0x%x", pMarkupOld, pMarkupNew));
    TraceTag((tagSecurityContext, "COmWindowProxy::SwitchMarkup - Reset Security Thunk is set to : %x", !fKeepSecurityIdentity && !fDispatchExThunkTrust));

    if ( pWindow->_pLicenseMgr )
    {
        ((IUnknown*) (pWindow->_pLicenseMgr))->Release();
        pWindow->_pLicenseMgr = NULL;

    }
    
    // if we are not asked to keep the security identity and 
    // the two markups are on different domains, then reset.
    if (!fKeepSecurityIdentity && !fDispatchExThunkTrust)
    {
        Document()->ResetSecurityThunk();
        ResetSecurityThunk();

        if (_pvSecurityThunkPending)
        {
            TEAROFF_THUNK *tmpThunk;
            CSecurityThunkSub *tmpThunkSub;

            _pvSecurityThunk = _pvSecurityThunkPending;
            _pvSecurityThunkPending = NULL;

            // We'll need to change the status of the SecurityThunk from Pending.
            tmpThunk = (TEAROFF_THUNK *)_pvSecurityThunk;
            tmpThunkSub = (CSecurityThunkSub *)(tmpThunk->pvObject2);
            Assert(tmpThunkSub->_dwThunkType == CSecurityThunkSub::EnumSecThunkTypePendingWindow);
            tmpThunkSub->_dwThunkType = CSecurityThunkSub::EnumSecThunkTypeWindow;
        }
    }

    pWindow->_pMarkupPending->Release();
    pWindow->_pMarkupPending = NULL;

    if (fPrimarySwitch)
    {
        LONG c;
        CStr *pcstr;

        for (pcstr = pDoc->_acstrStatus, c = STL_LAYERS; c; pcstr += 1, c -= 1)
            pcstr->Free();

        //
        // if we were fully embedded - clear the bit. 
        // 
        if ( pDoc->_fFullWindowEmbed )
        {
            pDoc->_fFullWindowEmbed = FALSE;
            pDoc->_cstrPluginCacheFilename.Free();
            pDoc->_cstrPluginContentType.Free();
        }                
        
        pDoc->_iStatusTop = STL_LAYERS;
        pDoc->_fSeenDefaultStatus = FALSE;

        pDoc->UpdateStatusText();
        pDoc->DeferUpdateUI();
        pDoc->DeferUpdateTitle(pMarkupNew);
        pDoc->Invalidate();

        // Move the SSL state over and update the host
        {
            SSL_SECURITY_STATE sss;
            SSL_PROMPT_STATE sps;

            pDoc->GetRootSslState( TRUE, &sss, &sps );

            pDoc->SetRootSslState( FALSE, sss, sps, TRUE );
        }


        if (pDoc->_pClientSite)
        {
            IGNORE_HR(pDoc->UpdateDocHostUI(TRUE));
        }
    }

    // initializes the window with any temporary dispids stored on the markup
    Verify (!pMarkupNew->InitWindow ());  

    PerfDbgLog2(tagNFNav, this, "New Markup %x \"%ls\"", pMarkupNew, pMarkupNew ? pMarkupNew->Url() : _T(""));

    pWindow->NoteNavEvent();           

    if (fClearNewFormats)
    {
        pMarkupNew->EnsureFormatCacheChange(ELEMCHNG_CLEARCACHES|ELEMCHNG_REMEASUREALLCONTENTS);         
    }

    // Now that the markup is ready to be seen by the outside world, make sure that
    // any pending identity peer is hooked up
    if (pMarkupNew->HasIdentityPeerTask())
        pMarkupNew->ProcessIdentityPeerTask();
    
    if ( pIDispXML || pIDispXSL )
    {
        IGNORE_HR( Document()->SetXMLExpando( pIDispXML, pIDispXSL ));
    }
    
    // Hide any tooltips from the old markup
    FormsHideTooltip((DWORD_PTR)pMarkupOld);

Cleanup:

    if (pWindow)
    {
        pWindow->_fDelegatedSwitchMarkup = FALSE;
    }

    ReleaseInterface( pIDispXML );
    ReleaseInterface( pIDispXSL );

    if (pMarkupOld)
        pMarkupOld->Release();

    pMarkupNew->UnblockScriptExecutionHelper();

    PerfDbgLog(tagNFNav, this, "-COmWindowProxy::SwitchMarkup");

    RRETURN(hr);
}

//+-------------------------------------------------------------------------
//
//  Method:     COmWindowProxy::GetTypeInfoCount
//
//  Synopsis:   Per IDispatch
//
//--------------------------------------------------------------------------

HRESULT
COmWindowProxy::GetTypeInfoCount(UINT FAR* pctinfo)
{
    TraceTag((tagSecurity, "GetTypeInfoCount"));

    RRETURN(_pWindow->GetTypeInfoCount(pctinfo));
}


//+-------------------------------------------------------------------------
//
//  Method:     COmWindowProxy::GetTypeInfo
//
//  Synopsis:   Per IDispatch
//
//--------------------------------------------------------------------------

HRESULT
COmWindowProxy::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo ** pptinfo)
{
    TraceTag((tagSecurity, "GetTypeInfo"));

    RRETURN(_pWindow->GetTypeInfo(itinfo, lcid, pptinfo));
}


//+-------------------------------------------------------------------------
//
//  Method:     COmWindowProxy::GetIDsOfNames
//
//  Synopsis:   Per IDispatch
//
//--------------------------------------------------------------------------

HRESULT
COmWindowProxy::GetIDsOfNames(
    REFIID                riid,
    LPOLESTR *            rgszNames,
    UINT                  cNames,
    LCID                  lcid,
    DISPID FAR*           rgdispid)
{
    HRESULT hr;
    
    hr = THR(_pWindow->GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid));

#ifndef WIN16
    if (OK(hr))
        goto Cleanup;

    //
    // Catch the case where the thread has already gone down.  Remember
    // that _pWindow may be a marshalled pointer to a window object.
    // In this case we want to try our own GetIDsOfNames to come up with
    // plausible responses.
    //
    
    if (WINDOWDEAD())
    {
        if (OK(super::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid)))
        {
            hr = S_OK;
            goto Cleanup;
        }
    }
Cleanup:
#endif //!WIN16    
    RRETURN(hr);
}

HRESULT
COmWindowProxy::Invoke(
    DISPID          dispid,
    REFIID,
    LCID            lcid,
    WORD            wFlags,
    DISPPARAMS *    pdispparams,
    VARIANT *       pvarResult,
    EXCEPINFO *     pexcepinfo,
    UINT *)
{
    return InvokeEx(dispid,
                    lcid,
                    wFlags,
                    pdispparams,
                    pvarResult,
                    pexcepinfo,
                    NULL);
}
//+-------------------------------------------------------------------------
//
//  Method:     COmWindowProxy::InvokeEx
//
//  Synopsis:   Per IDispatch
//
//--------------------------------------------------------------------------

HRESULT
COmWindowProxy::InvokeEx(DISPID dispidMember,
                         LCID lcid,
                         WORD wFlags,
                         DISPPARAMS *pdispparams,
                         VARIANT *pvarResult,
                         EXCEPINFO *pexcepinfo,
                         IServiceProvider *pSrvProvider)
{
    TraceTag((tagSecurity, "Invoke dispid=0x%x", dispidMember));

    HRESULT     hr = S_OK;
    CVariant    Var;


#if DBG==1
    if (IsTagEnabled(tagSecurityProxyCheck))
    {
        // InvokeEx should only be called on secure proxy, with some exceptions
        if (_fTrusted)
        {
            // oh no!!! It is not a secure proxy! 
            // Look for known exceptions
            if (
                    dispidMember >=  DISPID_OMWINDOWMETHODS     // call from script engine
                ||  dispidMember <=  DISPID_WINDOWOBJECT        // reserved dispids aren't reacheable from script
               )
            {
                Assert(TRUE);   // benign call
            }
            else
            {
                BOOL fIgnoreThisOne = FALSE;

                if (!fIgnoreThisOne)
                {
                    AssertSz(FALSE, "COmWindowProxy::InvokeEx called on trusted proxy (shift+Ingore to debug script)");

                    // DEBUG FEATURE: deny access if verification failed and SHIFT pressed - shows the problem in script debugger
                    if (GetAsyncKeyState(VK_SHIFT) & 0x8000)
                    {
                        RRETURN(E_ACCESSDENIED);
                    }
                }
            }
        }

        AssertSz(hr == S_OK, "Failure in debug code");
    }
#endif


    //
    // In case this proxy is pointing to a viewlinked WebOC document ( such as XML document ) we
    // know that the window we want to talk to is not the _pWindow but the viewlinked window inside.
    // We try and delegate the call to the inner window first, if that fails we execute the invoke on 
    // _pWindow.
    //
    {
        IHTMLPrivateWindow2 * pPrivateWindow;
        BOOL fInnerInvoke = FALSE;

        if (S_OK == _pWindow->QueryInterface(IID_IHTMLPrivateWindow2, (void **) &pPrivateWindow))
        {
            IUnknown * pUnknown = NULL;

            if (S_OK == pPrivateWindow->GetInnerWindowUnknown(&pUnknown))
            {
                IHTMLWindow2 * pWindow = NULL;

                if (S_OK == pUnknown->QueryInterface(IID_IHTMLWindow2, (void **) &pWindow))
                {
                    IHTMLWindow2 * pWindowOut;

                    if (S_OK == SecureObject(pWindow, &pWindowOut))
                    {
                        IDispatchEx * pDispatchEx;

                        if (S_OK == pWindowOut->QueryInterface(IID_IDispatchEx, (void **) &pDispatchEx))
                        {
                            fInnerInvoke = TRUE;
                            
                            hr = THR(pDispatchEx->InvokeEx(dispidMember,
                                                           lcid,
                                                           wFlags,
                                                           pdispparams,
                                                           pvarResult,
                                                           pexcepinfo,
                                                           pSrvProvider));
                            pDispatchEx->Release();
                        }

                        pWindowOut->Release();
                    }

                    pWindow->Release();
                }

                pUnknown->Release();
            }

            pPrivateWindow->Release();
        }

        if (fInnerInvoke)
            RRETURN(hr);
    }

#if DBG==1
    // Let CWindow verify correct call sequence 
    CSecureProxyLock secureProxyLock(_pWindow, this);
#endif

    //
    // Look for known negative dispids that we can answer
    // or forward safely.
    //

    switch (dispidMember)
    {
    case DISPID_WINDOWOBJECT:
        //
        // Return a ptr to the real window object.
        //

        V_VT(pvarResult) = VT_DISPATCH;
        V_DISPATCH(pvarResult) = _pWindow;
        _pWindow->AddRef();
        hr = S_OK;
        goto Cleanup;

    case DISPID_LOCATIONOBJECT:
    case DISPID_NAVIGATOROBJECT:
    case DISPID_HISTORYOBJECT:
    case DISPID_SECURITYCTX:
    case DISPID_SECURITYDOMAIN:
        //
        // Forward these on safely.
        //

        // TODO rgardner need to QI for Ex2 & Invoke ??
        hr = THR(_pWindow->Invoke(dispidMember,
                                  IID_NULL,
                                  lcid,
                                  wFlags,
                                  pdispparams,
                                  pvarResult,
                                  pexcepinfo,
                                  NULL));
        goto Cleanup;

#if DBG==1
    case DISPID_DEBUG_ISSECUREPROXY:
        //
        // isSecureProxy - debug-only proxy property
        //
        if (pvarResult)
        {
            V_VT(pvarResult) = VT_BOOL;
            hr = THR(get_isSecureProxy((VARIANT_BOOL *)&pvarResult->iVal));
        }
        goto Cleanup;
        
    case DISPID_DEBUG_TRUSTEDPROXY:
        //
        // trustedProxy - debug-only trusted proxy access
        //
        if (pvarResult)
        {
            V_VT(pvarResult) = VT_DISPATCH;
            hr = THR(get_trustedProxy((IDispatch **)&pvarResult->pdispVal));
        }
        goto Cleanup;
    
    case DISPID_DEBUG_INTERNALWINDOW:
        //
        // internalWindow - debug-only CWindow access
        //
        if (pvarResult)
        {
            V_VT(pvarResult) = VT_DISPATCH;
            hr = THR(get_internalWindow((IDispatch **)&pvarResult->pdispVal));
        }
        goto Cleanup;

    case DISPID_DEBUG_ENABLESECUREPROXYASSERTS:
        if (pdispparams->cArgs == 1 && V_VT(&(pdispparams->rgvarg[0])) == VT_BOOL)
            hr = THR(enableSecureProxyAsserts(V_BOOL(&(pdispparams->rgvarg[0]))));
        else
            hr = E_INVALIDARG;
        goto Cleanup;
#endif

    default:
        break;
    }

    //
    // If dispid is within range for named or indexed frames
    // pass through and secure the returned object.
    //

    // Note that we don't try & verify which collection it's in - we just
    // want to know if its in any collection at all
    if ( dispidMember >= CMarkup::FRAME_COLLECTION_MIN_DISPID && 
        dispidMember <=  CMarkup::FRAME_COLLECTION_MAX_DISPID )
    {
        //
        // get the frame with the information in hand (name/index)
        //
        hr = THR(_pWindow->Invoke(dispidMember,
                                  IID_NULL,
                                  lcid,
                                  wFlags,
                                  pdispparams,
                                  &Var,
                                  pexcepinfo,
                                  NULL));
        if (!hr)
        {
            hr = THR(SecureObject(&Var, pvarResult, pSrvProvider, this, TRUE)); // fInvoked = TRUE
        }
        goto Cleanup;
    }
    
    //
    // Now try automation based invoke as long as the dispid
    // is not an expando or omwindow method dispid.
    //

    // also, disable getting in super::InvokeEx when DISPID_COmWindow_showModalDialog:
    // this will make us to invoke _pWindow directly so caller chain will be available there.

    if (!IsExpandoDISPID(dispidMember) && 
        dispidMember < DISPID_OMWINDOWMETHODS &&
        dispidMember != DISPID_CWindow_showModalDialog)
    {
        hr = THR(super::InvokeEx(dispidMember,
                                 lcid,
                                 wFlags,
                                 pdispparams,
                                 pvarResult,
                                 pexcepinfo,
                                 pSrvProvider));

        // if above failed, allow the dialogTop\Left\Width\Height properties to go through else bailout
        // Note that these std dispids are defined only for the dlg objeect and not the window object,
        // so if they fall in this range, it must be an invoke for the dialog properties
        if (!(hr && dispidMember >= STDPROPID_XOBJ_LEFT && dispidMember <= STDPROPID_XOBJ_HEIGHT))
            goto Cleanup;
    }
    
    //
    // If automation invoke also failed, then only allow the invoke to
    // pass through if the security allows it.
    // Is this too stringent?
    //

    if (AccessAllowed())
    {
        IDispatchEx *pDEX2=NULL;
        hr = THR(_pWindow->QueryInterface ( IID_IDispatchEx, (void**)&pDEX2 ));
        if ( hr )
            goto Cleanup;

        Assert(pDEX2);
        hr = THR(pDEX2->InvokeEx(dispidMember,
                                 lcid,
                                 wFlags,
                                 pdispparams,
                                 &Var,
                                 pexcepinfo,
                                 pSrvProvider));

        ReleaseInterface(pDEX2);


        if (!hr)
        {
            hr = THR(SecureObject(&Var, pvarResult, pSrvProvider, this, TRUE));  // fInvoked = TRUE

            if (hr)
                goto Cleanup;
        }
    }
    else
    {
        hr = SetErrorInfo(E_ACCESSDENIED);
    }
    
Cleanup:
    // for IE3 backward compat, map the below old dispids to their corresponding new
    // ones, on failure.
    if (hr && hr != E_ACCESSDENIED)
    {
        switch(dispidMember)
        {
        case 1:             dispidMember = DISPID_CWindow_length;
                            break;

        case 0x60020000:    dispidMember = DISPID_CWindow_name;
                            break;

        case 0x60020003:    dispidMember = DISPID_CWindow_item;
                            break;

        case 0x60020006:    dispidMember = DISPID_CWindow_location;
                            break;

        case 0x60020007:    dispidMember = DISPID_CWindow_frames;
                            break;

        default:
                            RRETURN_NOTRACE(hr);
        }

        hr = THR(super::InvokeEx(dispidMember,
                                 lcid,
                                 wFlags,
                                 pdispparams,
                                 pvarResult,
                                 pexcepinfo,
                                 pSrvProvider));
    }

    RRETURN_NOTRACE(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     COmWindowProxy::GetDispID
//
//  Synopsis:   Per IDispatchEx
//
//--------------------------------------------------------------------------

HRESULT
COmWindowProxy::GetDispID(BSTR bstrName, DWORD grfdex, DISPID *pid)
{
    HRESULT          hr = S_OK;
    IDispatchEx *    pDispEx2 = NULL;
    BOOL             fDenied = FALSE;

    {
        IHTMLPrivateWindow2 * pPrivateWindow;
        BOOL fInnerGetDispID = FALSE;

        if (S_OK == _pWindow->QueryInterface(IID_IHTMLPrivateWindow2, (void **) &pPrivateWindow))
        {
            IUnknown * pUnknown = NULL;

            if (S_OK == pPrivateWindow->GetInnerWindowUnknown(&pUnknown))
            {
                IDispatchEx * pDispatchEx;

                if (S_OK == pUnknown->QueryInterface(IID_IDispatchEx, (void **) &pDispatchEx))
                {
                    fInnerGetDispID = TRUE;
                    
                    hr = THR(pDispatchEx->GetDispID(bstrName, grfdex, pid));

                    pDispatchEx->Release();
                }

                pUnknown->Release();
            }

            pPrivateWindow->Release();
        }

        if (fInnerGetDispID)
            RRETURN(hr);
    }

    // Cache the IDispatchEx ptr?
    hr = THR(_pWindow->QueryInterface(IID_IDispatchEx, (void **)&pDispEx2));
    if (hr)
        goto Cleanup;
        
    if ((grfdex & fdexNameEnsure) && !AccessAllowed())
    {
        //
        // If access is not allowed, don't even allow creation of an
        // expando on the remote side.
        //
        
        grfdex &= ~fdexNameEnsure;
        fDenied = TRUE;
    }

    hr = THR_NOTRACE(pDispEx2->GetDispID(bstrName, grfdex, pid));

    if (fDenied && DISP_E_UNKNOWNNAME == hr)
    {
        hr = E_ACCESSDENIED;
    }

#if DBG==1
    // DEBUG_ONLY: expose proxy's own interfaces (isSecureProxy)
    // note - this will occur even if access to window is not allowed
    if (hr && !(grfdex & fdexNameEnsure))
    {
        // TODO:alexmog: can we do anything more inteligent here?
        // debug-only, don't bother checking other flags
        if (0 == StrCmpC(bstrName, L"isSecureProxy"))
        {
            *pid = DISPID_DEBUG_ISSECUREPROXY;
            hr = S_OK;
        }
        else if (0 == StrCmpC(bstrName, L"trustedProxy"))
        {
            *pid = DISPID_DEBUG_TRUSTEDPROXY;
            hr = S_OK;
        }
        else if (0 == StrCmpC(bstrName, L"internalWindow"))
        {
            *pid = DISPID_DEBUG_INTERNALWINDOW;
            hr = S_OK;
        }
        else if (0 == StrCmpC(bstrName, L"enableSecureProxyAsserts"))
        {
            *pid = DISPID_DEBUG_ENABLESECUREPROXYASSERTS;
            hr = S_OK;
        }
    }
#endif

Cleanup:
#ifndef WIN16
    if (WINDOWDEAD())
    {
        //
        // This means the thread on the remote side has gone down.
        // Try to get out a plausible answer from CBase.  Otherwise
        // just bail.  Of course, never create an expando in such a
        // situation.
        //
        
        grfdex &= ~fdexNameEnsure;
        if (OK(super::GetDispID(bstrName, grfdex, pid)))
        {
            hr = S_OK;
        }
    }
#endif //!WIN16
    ReleaseInterface(pDispEx2);
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CBase::DeleteMember, IDispatchEx
//
//--------------------------------------------------------------------------

HRESULT
COmWindowProxy::DeleteMemberByName(BSTR bstr,DWORD grfdex)
{
    return E_NOTIMPL;
}

HRESULT
COmWindowProxy::DeleteMemberByDispID(DISPID id)
{
    return E_NOTIMPL;
}



//+-------------------------------------------------------------------------
//
//  Method:     CBase::GetMemberProperties, IDispatchEx
//
//--------------------------------------------------------------------------

HRESULT
COmWindowProxy::GetMemberProperties(
                DISPID id,
                DWORD grfdexFetch,
                DWORD *pgrfdex)
{
    return E_NOTIMPL;
}


HRESULT
COmWindowProxy::GetMemberName (DISPID id, BSTR *pbstrName)
{
    HRESULT         hr;
    IDispatchEx *  pDispEx2 = NULL;
    
    // Cache the IDispatchEx ptr?
    hr = THR(_pWindow->QueryInterface(IID_IDispatchEx, (void **)&pDispEx2));
    if (hr)
        goto Cleanup;
        
    hr = THR(pDispEx2->GetMemberName(id, pbstrName));

Cleanup:
    ReleaseInterface(pDispEx2);
    RRETURN1(hr,S_FALSE);
}


//+-------------------------------------------------------------------------
//
//  Method:     COmWindowProxy::GetNextDispID
//
//  Synopsis:   Per IDispatchEx
//
//--------------------------------------------------------------------------
HRESULT
COmWindowProxy::GetNextDispID(DWORD grfdex,
                              DISPID id,
                              DISPID *prgid)
{
    HRESULT         hr;
    IDispatchEx *  pDispEx2 = NULL;
    
    // Cache the IDispatchEx ptr?
    hr = THR(_pWindow->QueryInterface(IID_IDispatchEx, (void **)&pDispEx2));
    if (hr)
        goto Cleanup;
        
    hr = THR(pDispEx2->GetNextDispID(grfdex, id, prgid));

Cleanup:
    ReleaseInterface(pDispEx2);
    RRETURN1(hr,S_FALSE);
}


//+-------------------------------------------------------------------------
//
//  Method:     COmWindowProxy::GetNameSpaceParent
//
//  Synopsis:   Per IDispatchEx
//
//--------------------------------------------------------------------------
HRESULT
COmWindowProxy::GetNameSpaceParent(IUnknown **ppunk)
{
    HRESULT         hr;
    IDispatchEx *  pDEX = NULL;

    if (!ppunk)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppunk = NULL;

    hr = THR(_pWindow->QueryInterface(IID_IDispatchEx, (void**) &pDEX));
    if (hr)
        goto Cleanup;
        
    hr = THR(pDEX->GetNameSpaceParent(ppunk));

#if DBG==1
    // optionally secure the window proxy given to script engine
    if (IsTagEnabled(tagSecureScriptWindow))
    {
        hr = THR(SecureProxyIUnknown(ppunk));
    }
#endif


Cleanup:
    ReleaseInterface (pDEX);
    RRETURN(hr);
}

#define IMPLEMENT_SECURE_OBJECTGET(meth)            \
    HRESULT hr = E_ACCESSDENIED;                    \
    *ppOut = NULL;                                  \
                                                    \
    if (AccessAllowed())                            \
    {                                               \
      hr = THR(_pWindow->meth(&pReal));             \
      if (SUCCEEDED(hr))                            \
      {                                             \
        *ppOut = pReal;                             \
        if (pReal)                                  \
            pReal->AddRef();                        \
      }                                             \
    }                                               \
    ReleaseInterface(pReal);                        

#define IMPLEMENT_SECURE_PROPGET(meth)              \
    HRESULT hr = E_ACCESSDENIED;                    \
    *ppOut = NULL;                                  \
                                                    \
    if (AccessAllowed())                            \
    {                                               \
       hr = THR(_pWindow->meth(ppOut));             \
    }                                               

#define IMPLEMENT_SECURE_PROPGET3(meth)             \
    HRESULT hr = E_ACCESSDENIED;                    \
    if (AccessAllowed())                            \
    {                                               \
        IHTMLWindow3 *pWin3 = NULL;                 \
        hr = THR(_pWindow->QueryInterface(IID_IHTMLWindow3, (void **)&pWin3));  \
        if (SUCCEEDED(hr))                          \
        {                                           \
          hr = THR(pWin3->meth);                    \
          ReleaseInterface(pWin3);                  \
        }                                           \
    }                                               


#define IMPLEMENT_SECURE_WINDOWGET_WITHIDCHECK(meth) \
    HRESULT             hr = S_OK;                   \
    IHTMLWindow2 *      pWindow = NULL;              \
                                                     \
    *ppOut = NULL;                                   \
    hr = THR(_pWindow->meth(&pWindow));              \
    if (hr)                                          \
        goto Cleanup;                                \
                                                     \
    hr = THR(SecureObject(pWindow,ppOut));           \
    if (hr)                                          \
        goto Cleanup;                                \
                                                     \
Cleanup:                                             \
    ReleaseInterface(pWindow);                       \

#define IMPLEMENT_SECURE_METHOD(meth)               \
    HRESULT hr = E_ACCESSDENIED;                    \
                                                    \
    if (AccessAllowed())                            \
    {                                               \
        hr = THR(_pWindow->meth);                   \
    }                                               


#define IMPLEMENT_SECURE_METHOD3(meth)              \
    HRESULT hr = E_ACCESSDENIED;                    \
    if (AccessAllowed())                            \
    {                                               \
        IHTMLWindow3 *pWin3 ;                       \
        hr = THR(_pWindow->QueryInterface(IID_IHTMLWindow3, (void **)&pWin3)); \
        if (SUCCEEDED(hr))                          \
        {                                           \
          hr = THR(pWin3->meth);                    \
          ReleaseInterface(pWin3);                  \
        }                                           \
    }                                               


#define IMPLEMENT_SECURE_METHOD4(meth)              \
    HRESULT hr = E_ACCESSDENIED;                    \
    if (AccessAllowed())                            \
    {                                               \
        IHTMLWindow4 *pWin4 ;                       \
        hr = THR(_pWindow->QueryInterface(IID_IHTMLWindow4, (void **)&pWin4)); \
        if (SUCCEEDED(hr))                          \
        {                                           \
          hr = THR(pWin4->meth);                    \
          ReleaseInterface(pWin4);                  \
        }                                           \
    }                                               

//+-------------------------------------------------------------------------
//
//  Method:     COmWindowProxy::get_document
//
//  Synopsis:   Per IOmWindow
//
//--------------------------------------------------------------------------

HRESULT
COmWindowProxy::get_document(IHTMLDocument2 **ppOut)
{
    IHTMLDocument2 *    pReal = NULL;

    IMPLEMENT_SECURE_OBJECTGET(get_document)
    RRETURN(SetErrorInfo(hr));    
}


//+-------------------------------------------------------------------------
//
//  Method:     COmWindowProxy::get_frames
//
//  Synopsis:   Per IOmWindow
//
//--------------------------------------------------------------------------

HRESULT
COmWindowProxy::get_frames(IHTMLFramesCollection2 ** ppOut)
{
    IHTMLFramesCollection2 *    pColl = NULL;
    HRESULT                     hr = S_OK;
    IHTMLWindow2 *              pWindow = NULL;
    IHTMLWindow2 *              pWindowOut = NULL;
    
    *ppOut = NULL;

    hr = THR(_pWindow->get_frames(&pColl));
    if (hr)
        goto Cleanup;

    hr = THR(pColl->QueryInterface(
            IID_IHTMLWindow2, (void **)&pWindow));
    if (hr)
        goto Cleanup;
      
    hr = THR(SecureObject(pWindow, &pWindowOut));

    if (hr)
        goto Cleanup;

    *ppOut = pWindowOut;

Cleanup:
    ReleaseInterface(pWindow);
    ReleaseInterface(pColl);
    RRETURN(SetErrorInfo(hr));    
}


//+----------------------------------------------------------------------------------
//
//  Member:     item
//
//  Synopsis:   object model implementation
//
//              we handle the following parameter cases:
//                  0 params:               returns IDispatch of this
//                  1 param as number N:    returns IDispatch of om window of
//                                          frame # N, or fails if doc is not with
//                                          frameset
//                  1 param as string "foo" returns the om window of the frame
//                                          element that has NAME="foo"
//
//-----------------------------------------------------------------------------------

HRESULT
COmWindowProxy::item(VARIANTARG *pvarArg1, VARIANTARG * pvarRes)
{
    HRESULT     hr = S_OK;
    CVariant    Var;

    hr = THR(_pWindow->item(pvarArg1, &Var));
    if (hr)
        goto Cleanup;

    hr = THR(SecureObject(&Var, pvarRes, NULL, this));  // fInvoked = FALSE
    if (hr)
        goto Cleanup;
        
Cleanup:
    RRETURN(SetErrorInfo(hr));    
}


//+------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::Get_newEnum
//
//  Synopsis:   collection object model
//
//-------------------------------------------------------------------------

HRESULT
COmWindowProxy::get__newEnum(IUnknown **ppOut)
{
    IUnknown *          pReal = NULL;

    IMPLEMENT_SECURE_OBJECTGET(get__newEnum)
    RRETURN(SetErrorInfo(hr));    
}


//+-------------------------------------------------------------------------
//
//  Method:     COmWindowProxy::get_event
//
//  Synopsis:   Per IOmWindow
//
//--------------------------------------------------------------------------

HRESULT
COmWindowProxy::get_event(IHTMLEventObj **ppOut)
{
    IHTMLEventObj * pReal = NULL;

    IMPLEMENT_SECURE_OBJECTGET(get_event)
    RRETURN(SetErrorInfo(hr));
}


//+---------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::setTimeout
//
//  Synopsis:  Runs <Code> after <msec> milliseconds and returns a bstr <TimeoutID>
//      in case ClearTimeout is called.
//
//----------------------------------------------------------------------------

HRESULT
COmWindowProxy::setTimeout(
    BSTR strCode, 
    LONG lMSec, 
    VARIANT *language, 
    LONG * pTimerID)
{
    IMPLEMENT_SECURE_METHOD(setTimeout(strCode, lMSec, language, pTimerID))
    RRETURN(SetErrorInfo(hr));
}

//+---------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::setTimeout (w/ VARIANT pCode)
//
//  Synopsis:  Runs <Code> after <msec> milliseconds and returns a bstr <TimeoutID>
//      in case ClearTimeout is called.
//
//----------------------------------------------------------------------------

HRESULT
COmWindowProxy::setTimeout(
    VARIANT *pCode, 
    LONG lMSec, 
    VARIANT *language, 
    LONG * pTimerID)
{
    IMPLEMENT_SECURE_METHOD3(setTimeout(pCode, lMSec, language, pTimerID))
    RRETURN(SetErrorInfo(hr));
}

//+---------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::clearTimeout
//
//  Synopsis:
//
//----------------------------------------------------------------------------

HRESULT
COmWindowProxy::clearTimeout(LONG timerID)
{
    IMPLEMENT_SECURE_METHOD(clearTimeout(timerID))
    RRETURN(SetErrorInfo(hr));
}

//+---------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::setInterval
//
//  Synopsis:  Runs <Code> every <msec> milliseconds 
//
//----------------------------------------------------------------------------

HRESULT
COmWindowProxy::setInterval(
    BSTR strCode, 
    LONG lMSec, 
    VARIANT *language, 
    LONG * pTimerID)
{
    IMPLEMENT_SECURE_METHOD(setInterval(strCode, lMSec, language, pTimerID))
    RRETURN(SetErrorInfo(hr));    
}

//+---------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::setInterval (w/ VARIANT pCode)
//
//  Synopsis:  Runs <Code> after <msec> milliseconds and returns a bstr <TimeoutID>
//      in case ClearTimeout is called.
//
//----------------------------------------------------------------------------

HRESULT
COmWindowProxy::setInterval(
    VARIANT *pCode, 
    LONG lMSec, 
    VARIANT *language, 
    LONG * pTimerID)
{
    IMPLEMENT_SECURE_METHOD3(setInterval(pCode, lMSec, language, pTimerID))
    RRETURN(SetErrorInfo(hr));    
}

//+---------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::clearInterval
//
//  Synopsis:   deletes the period timer set by setInterval
//
//----------------------------------------------------------------------------

HRESULT
COmWindowProxy::clearInterval(LONG timerID)
{
    IMPLEMENT_SECURE_METHOD(clearInterval(timerID))
    RRETURN(SetErrorInfo(hr));    
}

//+-------------------------------------------------------------------------
//
//  Method:     COmWindowProxy::get_screen
//
//--------------------------------------------------------------------------

HRESULT
COmWindowProxy::get_screen(IHTMLScreen **ppOut)
{
    IHTMLScreen *   pReal = NULL;
    
    IMPLEMENT_SECURE_OBJECTGET(get_screen)
    RRETURN(SetErrorInfo(hr));    
}

//+---------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::showModalDialog
//
//  Synopsis:   Interface method to bring up a HTMLdialog given a url
//
//----------------------------------------------------------------------------

HRESULT
COmWindowProxy::showModalDialog(
    BSTR         bstrUrl,
    VARIANT *    pvarArgIn,
    VARIANT *    pvarOptions,
    VARIANT *    pvarArgOut)
{
    IMPLEMENT_SECURE_METHOD(showModalDialog(bstrUrl, pvarArgIn, pvarOptions, pvarArgOut))
    RRETURN(SetErrorInfo(hr));    
}


//+----------------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::alert
//
//  Synopsis:   object model implementation
//
//
//-----------------------------------------------------------------------------------

HRESULT
COmWindowProxy::alert(BSTR message)
{
    IMPLEMENT_SECURE_METHOD(alert(message))
    RRETURN(SetErrorInfo(hr));    
}

//+----------------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::confirm
//
//  Synopsis:   object model implementation
//
//
//-----------------------------------------------------------------------------------

HRESULT
COmWindowProxy::confirm(BSTR message, VARIANT_BOOL *pConfirmed)
{
    IMPLEMENT_SECURE_METHOD(confirm(message, pConfirmed))
    RRETURN(SetErrorInfo(hr));    
}


//+-------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::get_length
//
//  Synopsis:   object model implementation
//
//              returns number of frames in frameset of document;
//              fails if the doc does not contain frameset
//
//--------------------------------------------------------------------------

HRESULT
COmWindowProxy::get_length(long *ppOut)
{
    RRETURN(SetErrorInfo(_pWindow->get_length(ppOut)));
}



//+---------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::showHelp
//
//----------------------------------------------------------------------------

HRESULT
COmWindowProxy::showHelp(BSTR helpURL, VARIANT helpArg, BSTR features)
{
    IMPLEMENT_SECURE_METHOD(showHelp(helpURL, helpArg, features))
    RRETURN(SetErrorInfo(hr));    
}


//+------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::prompt
//
//  Synopsis:   Show a prompt dialog
//
//-------------------------------------------------------------------------

HRESULT
COmWindowProxy::prompt(BSTR message, BSTR defstr, VARIANT *retval)
{
    IMPLEMENT_SECURE_METHOD(prompt(message, defstr, retval))
    RRETURN(SetErrorInfo(hr));    
}


HRESULT
COmWindowProxy::toString(BSTR* String)
{
    IMPLEMENT_SECURE_METHOD(toString(String))
    RRETURN(SetErrorInfo(hr));    
};


//+------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::get_defaultStatus
//
//  Synopsis:   Retrieve the default status property
//
//-------------------------------------------------------------------------

HRESULT 
COmWindowProxy:: get_defaultStatus(BSTR *ppOut)
{
    IMPLEMENT_SECURE_PROPGET(get_defaultStatus)
    RRETURN(SetErrorInfo(hr));    
}


//+-------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::get_status
//
//  Synopsis:   Retrieve the status property
//
//--------------------------------------------------------------------------

HRESULT 
COmWindowProxy:: get_status(BSTR *ppOut)
{
    IMPLEMENT_SECURE_PROPGET(get_status)
    RRETURN(SetErrorInfo(hr));    
}


//+-------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::put_defaultStatus
//
//  Synopsis:   Set the default status property
//
//--------------------------------------------------------------------------

HRESULT 
COmWindowProxy:: put_defaultStatus(BSTR bstr)
{
    RRETURN(SetErrorInfo(_pWindow->put_defaultStatus(bstr)));
}


//+------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::put_status
//
//  Synopsis:   Set the default status property
//
//-------------------------------------------------------------------------

HRESULT 
COmWindowProxy:: put_status(BSTR bstr)
{
    RRETURN(SetErrorInfo(_pWindow->put_status(bstr)));
}


//+------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::get_Image
//
//  Synopsis:   Retrieve the image element factory
//
//-------------------------------------------------------------------------

HRESULT 
COmWindowProxy:: get_Image(IHTMLImageElementFactory **ppOut)
{
    IHTMLImageElementFactory *  pReal = NULL;

    IMPLEMENT_SECURE_OBJECTGET(get_Image)
    RRETURN(SetErrorInfo(hr));    
}


//+------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::get_location
//
//  Synopsis:   Retrieve the location object
//-------------------------------------------------------------------------

HRESULT 
COmWindowProxy::get_location(IHTMLLocation **ppOut)
{
    HRESULT         hr = S_OK;

    if (!_pWindow)
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    if (!ppOut)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    
    if (_fTrusted)
    {        
        IHTMLWindow2 * pNewWindow = NULL;

        IGNORE_HR(SecureObject(this, (IHTMLWindow2**)&pNewWindow, TRUE));

        hr =THR(pNewWindow->get_location(ppOut));

        ReleaseInterface(pNewWindow);
    }
    else
    {
        hr = THR(_Location.QueryInterface(IID_IHTMLLocation, (void **)ppOut));
    }
    
Cleanup:
    RRETURN(SetErrorInfo(hr));    
}


//+-------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::get_history
//
//  Synopsis:   Retrieve the history object
//
//--------------------------------------------------------------------------

HRESULT 
COmWindowProxy:: get_history(IOmHistory **ppOut)
{
    IOmHistory *    pReal = NULL;

    IMPLEMENT_SECURE_OBJECTGET(get_history)
    RRETURN(SetErrorInfo(hr));    
}


//+--------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::close
//
//  Synopsis:   Close this windows
//
//---------------------------------------------------------------------------

HRESULT 
COmWindowProxy:: close()
{
    HRESULT hr;

    hr = THR(_pWindow->close());
#ifndef WIN16
    if (WINDOWDEAD())
    {
        hr = S_OK;
    }
#endif //!WIN16
    RRETURN(SetErrorInfo(hr));    
}


//+--------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::put_opener
//
//  Synopsis:   Set the opener (which window opened me) property
//
//  Notes:      This might allow the inner window to contain a
//              as it's opener a window with a bad security id.
//              However, when retrieving in get_opener, we check
//              for this and wrap it correctly.
//
//---------------------------------------------------------------------------

HRESULT 
COmWindowProxy:: put_opener(VARIANT v)
{
    RRETURN(SetErrorInfo(_pWindow->put_opener(v)));
}


//+--------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::get_opener
//
//  Synopsis:   Retrieve the opener (which window opened me) property
//
//---------------------------------------------------------------------------

HRESULT 
COmWindowProxy::get_opener(VARIANT *pvarOut)
{
    CVariant            Real;
    HRESULT             hr;
    IHTMLWindow2 *      pWindow = NULL;

    V_VT(pvarOut) = VT_EMPTY;
    
    hr = THR(_pWindow->get_opener(&Real));
    if (hr)
        goto Cleanup;

    hr = E_FAIL;
    
    if (V_VT(&Real) == VT_UNKNOWN)
    {
        hr = THR_NOTRACE(V_UNKNOWN(&Real)->QueryInterface(
                IID_IHTMLWindow2, (void **)&pWindow));
    }
    else if (V_VT(&Real) == VT_DISPATCH)
    {
        hr = THR_NOTRACE(V_DISPATCH(&Real)->QueryInterface(
                IID_IHTMLWindow2, (void **)&pWindow));
    }

    if (hr)
    {
        //
        // Object being retrieved is not a window object.
        // Allow if the security allows it.
        //
      
        if (Real.IsEmpty() || AccessAllowed())
        {
            hr = THR(VariantCopy(pvarOut, &Real));
        }
        else
        {
            hr = SetErrorInfo(E_ACCESSDENIED);
        }
    }
    else
    {
        //
        // Object is a window object, so wrap it.
        // See note above in put_opener.
        //
        
        IHTMLWindow2 *  pWindowOut;
        
        Assert(pWindow);
        hr = THR(SecureObject(pWindow, &pWindowOut));
        if (hr)
            goto Cleanup;

        V_VT(pvarOut) = VT_DISPATCH;
        V_DISPATCH(pvarOut) = pWindowOut;
    }

Cleanup:
    ReleaseInterface(pWindow);
    RRETURN(SetErrorInfo(hr));
}


//+--------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::get_navigator
//
//  Synopsis:   Get the navigator object
//
//---------------------------------------------------------------------------

HRESULT 
COmWindowProxy:: get_navigator(IOmNavigator **ppOut)
{
    IOmNavigator *  pReal = NULL;

    IMPLEMENT_SECURE_OBJECTGET(get_navigator)
    RRETURN(SetErrorInfo(hr));    
}


//+--------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::get_clientInformation
//
//  Synopsis:   Get the navigator object though the client alias
//
//---------------------------------------------------------------------------

HRESULT 
COmWindowProxy:: get_clientInformation(IOmNavigator **ppOut)
{
    IOmNavigator *  pReal = NULL;

    IMPLEMENT_SECURE_OBJECTGET(get_clientInformation)
    RRETURN(SetErrorInfo(hr));    
}

//+--------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::put_name
//
//  Synopsis:   Set the name property
//
//---------------------------------------------------------------------------

HRESULT 
COmWindowProxy:: put_name(BSTR bstr)
{
    RRETURN(SetErrorInfo(_pWindow->put_name(bstr)));
}


//+--------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::get_name
//
//  Synopsis:   Get the name property
//
//---------------------------------------------------------------------------

HRESULT 
COmWindowProxy:: get_name(BSTR *ppOut)
{
    IMPLEMENT_SECURE_PROPGET(get_name)
    RRETURN(SetErrorInfo(hr));    
}


//+--------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::get_screenTop
//
//  Synopsis:   Get the name property
//
//---------------------------------------------------------------------------

HRESULT 
COmWindowProxy::get_screenTop(long *ppOut)
{
    IMPLEMENT_SECURE_PROPGET3(get_screenTop(ppOut));
    RRETURN(SetErrorInfo(hr));
}


//+--------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::get_screenLeft
//
//  Synopsis:   Get the name property
//
//---------------------------------------------------------------------------

HRESULT 
COmWindowProxy::get_screenLeft(long *ppOut)
{
    IMPLEMENT_SECURE_PROPGET3(get_screenLeft(ppOut));
    RRETURN(SetErrorInfo(hr));
}

//+-------------------------------------------------------------------------
//
//  Method:     COmWindowProxy::get_clipboardData
//
//  Synopsis:   Per IOmWindow
//
//--------------------------------------------------------------------------

HRESULT
COmWindowProxy::get_clipboardData(IHTMLDataTransfer **ppOut)
{
    IMPLEMENT_SECURE_PROPGET3(get_clipboardData(ppOut));
    RRETURN(SetErrorInfo(hr));
}

//+--------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::createModelessDialog
//
//  Synopsis:   interface method, does what the name says.
//
//---------------------------------------------------------------------------

HRESULT 
COmWindowProxy::showModelessDialog(BSTR strUrl, 
                                   VARIANT * pvarArgIn, 
                                   VARIANT * pvarOptions, 
                                   IHTMLWindow2 ** ppOut)
{
    HRESULT        hr = S_OK;
    IHTMLWindow3 * pWin3 = NULL;
    IHTMLWindow2 * pWindow=NULL;

    if (!ppOut)
        return E_POINTER;

    *ppOut = NULL;

    if (AccessAllowed())
    {
        hr = THR(_pWindow->QueryInterface(IID_IHTMLWindow3, (void **)&pWin3));
        if(hr)
            goto Cleanup;

        hr = THR(pWin3->showModelessDialog(strUrl, pvarArgIn, pvarOptions, &pWindow));
        if (hr)
            goto Cleanup;

        hr = THR(SecureObject(pWindow, ppOut));
        if (hr)
            goto Cleanup;
    }

Cleanup:
    ReleaseInterface(pWindow);
    ReleaseInterface(pWin3);
    RRETURN(SetErrorInfo(hr));
}


//+--------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::attachEvent
//
//  Synopsis:   Attach the event
//
//---------------------------------------------------------------------------

HRESULT 
COmWindowProxy::attachEvent(BSTR event, IDispatch* pDisp, VARIANT_BOOL *pResult)
{
    IMPLEMENT_SECURE_METHOD3(attachEvent(event, pDisp, pResult));
    RRETURN(SetErrorInfo(hr));
}
        

//+--------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::detachEvent
//
//  Synopsis:   Detach the event
//
//---------------------------------------------------------------------------

HRESULT
COmWindowProxy::detachEvent(BSTR event, IDispatch* pDisp)
{
    IMPLEMENT_SECURE_METHOD3(detachEvent(event, pDisp));
    RRETURN(SetErrorInfo(hr));
}


//+--------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::get_parent
//
//  Synopsis:   Retrieve the parent window of this window
//
//---------------------------------------------------------------------------

HRESULT 
COmWindowProxy::get_parent(IHTMLWindow2 **ppOut)
{
    IMPLEMENT_SECURE_WINDOWGET_WITHIDCHECK(get_parent);
    RRETURN(SetErrorInfo(hr));    
}

//+--------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::get_frameElement
//
//  Synopsis:   Retrieve the frame Element that contains this window
//
//---------------------------------------------------------------------------

HRESULT 
COmWindowProxy::get_frameElement(IHTMLFrameBase **ppOut)
{
    HRESULT             hr = E_ACCESSDENIED;
    IHTMLWindow4 *      pWindow4 = NULL;
    IHTMLWindow2 *      pProxyParent = NULL;
    CWindow *           pWindow;
    // Can we give access to the window we are pointing to ? 
    if (!AccessAllowed())
    {
        hr = E_ACCESSDENIED;
        goto Cleanup;
    }

    // if we have granted access to the window, then get the CWindow 
    // object from the IHTMLWindow2 * _pWindow
    hr = THR(_pWindow->QueryInterface( CLSID_HTMLWindow2, (void **)&pWindow));
    if (hr)
        goto Cleanup;

    Assert(pWindow);

    // Check if we have access rights to the parent window's object model.
    if (pWindow->_pWindowParent && pWindow->_pWindowParent->_pMarkup)
    {
        COmWindowProxy * pCProxy;

        // Get a secured window proxy for the parent window to check access rights.
        hr = THR(SecureObject((IHTMLWindow2*)(pWindow->_pWindowParent), &pProxyParent));
        if (hr)
            goto Cleanup;

        // get a weak ref for the COMWindowProxy within...
        hr = THR(pProxyParent->QueryInterface( CLSID_HTMLWindowProxy, (void**)&pCProxy));
        if (hr)
            goto Cleanup;

        // check security
        if (!pCProxy || !pCProxy->AccessAllowed())
        {
            hr = E_ACCESSDENIED;
            goto Cleanup;
        }
    }

    // We have access to the parent window too. Return the frame element pointer
    hr = THR(_pWindow->QueryInterface(IID_IHTMLWindow4, (void **)&pWindow4));
    if (hr)
        goto Cleanup;

    hr = THR(pWindow4->get_frameElement(ppOut));

Cleanup:
    ReleaseInterface(pProxyParent);
    ReleaseInterface(pWindow4);

    RRETURN(SetErrorInfo(hr));
}


//+---------------------------------------------------------------------------
//
//  Helper:     GetFullyExpandedUrl
//
//  Synopsis:   Helper method,
//              gets the fully expanded url from the calling document. 
//----------------------------------------------------------------------------

HRESULT GetFullyExpandedUrl(CBase *pBase, 
                            BSTR bstrUrl, 
                            BSTR *pbstrFullUrl, 
                            BSTR *pbstrBaseUrl = NULL,
                            IServiceProvider *pSP = NULL)
{
    HRESULT         hr = S_OK;
    CStr            cstrBaseURL;
    TCHAR           achBuf[pdlUrlLen];
    DWORD           cchBuf;
    TCHAR           achUrl[pdlUrlLen];
    ULONG           len;
    SSL_SECURITY_STATE sssCaller;
    TCHAR *         pchFinalUrl = NULL;

    if (!pbstrFullUrl)
        return E_INVALIDARG;

    if (pbstrBaseUrl)
        *pbstrBaseUrl = NULL;

    // Get the URL of the caller
    hr = THR(GetCallerSecurityStateAndURL(&sssCaller, cstrBaseURL,
                                          pBase, pSP));
    if(!SUCCEEDED(hr))
        goto Cleanup;
        
    //
    // Expand the URL before we pass it on.
    //

    len = bstrUrl ? SysStringLen(bstrUrl) : 0;

    if (len)
    {
        if (len > pdlUrlLen-1)
            len = pdlUrlLen-1;

        _tcsncpy(achUrl, bstrUrl, len);
        ProcessValueEntities(achUrl, &len);
    }

    achUrl[len] = _T('\0');

    if (cstrBaseURL.Length())
    {
        hr = THR(CoInternetCombineUrl(
                cstrBaseURL, 
                achUrl,
                URL_ESCAPE_SPACES_ONLY | URL_BROWSER_MODE, 
                achBuf, 
                ARRAY_SIZE(achBuf), 
                &cchBuf, 0));
        if (hr)
            goto Cleanup;

        pchFinalUrl = achBuf;
        if (pbstrBaseUrl)
        {
            hr = THR(cstrBaseURL.AllocBSTR(pbstrBaseUrl));
            if (hr)
                goto Cleanup;
        }
    }
    else
    {
        pchFinalUrl = achUrl;
    }

    // Change the URL to the fully expanded URL.
    hr = THR(FormsAllocString(pchFinalUrl, pbstrFullUrl));

Cleanup:
    if (hr && pbstrBaseUrl)
    {
        FormsFreeString(*pbstrBaseUrl);
    }

    RRETURN(hr);
}

// Determine if access is allowed to the named frame (by comparing the SID of the proxy with the SID
// of the direct parent of the target frame).
//
BOOL 
COmWindowProxy::AccessAllowedToNamedFrame(LPCTSTR pchTarget)
{
    HRESULT              hr;
    IUnknown           * pUnkTarget = NULL;
    ITargetFrame2      * pTargetFrame = NULL;
    IWebBrowser        * pWB = NULL;
    IDispatch          * pDispDoc = NULL;
    BSTR                 bstrURL = NULL;
    BOOL                 fAccessAllowed = TRUE;
    TARGET_TYPE          eTargetType;

    if (!pchTarget || !pchTarget[0])
        goto Cleanup;

    // Obtain a target frame pointer for the source window
    hr = THR(QueryService(IID_ITargetFrame2, IID_ITargetFrame2, (void**)&pTargetFrame));
    if (hr)
        goto Cleanup;

    // Find the target frame using the source window as context
    hr = THR(pTargetFrame->FindFrame(pchTarget, FINDFRAME_JUSTTESTEXISTENCE, &pUnkTarget));
    if (hr || !pUnkTarget)
        goto Cleanup;

    // Perform a cross-domain check on the pUnkTarget we've received.
    //

    // QI for IWebBrowser to determine frameness.
    //
    hr = THR(pUnkTarget->QueryInterface(IID_IWebBrowser,(void**)&pWB));
    if (hr)
        goto Cleanup;

    eTargetType = GetTargetType(pchTarget);
    if (   (eTargetType != TARGET_SEARCH)
        && (eTargetType != TARGET_MEDIA))
    {
        // Get the IDispatch of the container.  This is the containing Trident if a frameset.
        //
        hr = THR_NOTRACE(pWB->get_Container(&pDispDoc));
        if (hr || !pDispDoc)
            goto Cleanup;
    }
    else
    {
        hr = THR_NOTRACE(pWB->get_Document(&pDispDoc));
        if (hr || !pDispDoc)
            goto Cleanup;
    }

    fAccessAllowed = AccessAllowed(pDispDoc);

Cleanup:
    ReleaseInterface(pWB);
    ReleaseInterface(pDispDoc);
    ReleaseInterface(pTargetFrame);
    ReleaseInterface(pUnkTarget);
    SysFreeString(bstrURL);

    return fAccessAllowed;
}

//+--------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::open
//
//  Synopsis:   Open a new window
//
//---------------------------------------------------------------------------

HRESULT
COmWindowProxy::open(BSTR bstrUrl,
                     BSTR bstrName,
                     BSTR bstrFeatures,
                     VARIANT_BOOL vbReplace,
                     IHTMLWindow2** ppWindow)
{
    HRESULT                 hr = S_OK;
    IHTMLWindow2 *          pWindow = NULL;
    TARGET_TYPE             eTargetType;    
    BSTR                    bstrFullUrl = NULL;
    BSTR                    bstrBaseUrl = NULL;
    IHTMLPrivateWindow3 *   pPrivWnd3 = NULL;

    if (bstrUrl && *bstrUrl)
    {
        hr = THR(GetFullyExpandedUrl(this, bstrUrl, &bstrFullUrl, &bstrBaseUrl));
        if (hr)
            goto Cleanup;
    }

    eTargetType = GetTargetType(bstrName);
    
    // If a frame name was given
    if (!_fTrustedDoc && bstrName && bstrName[0]
        && (   eTargetType == TARGET_FRAMENAME
            || eTargetType == TARGET_SEARCH
            || eTargetType == TARGET_MEDIA
           )
       )
    {
        // Determine if access is allowed to it
        if (!AccessAllowedToNamedFrame(bstrName))
        {
            CStr cstrCallerUrl;
            DWORD dwPolicy = 0;
            DWORD dwContext = 0;

            hr = THR(GetCallerURL(cstrCallerUrl, this, NULL));
            if (hr)
                goto Cleanup;

            if (    !SUCCEEDED(ZoneCheckUrlEx(cstrCallerUrl, &dwPolicy, sizeof(dwPolicy), &dwContext, sizeof(dwContext),
                              URLACTION_HTML_SUBFRAME_NAVIGATE, 0, NULL))
                ||  GetUrlPolicyPermissions(dwPolicy) != URLPOLICY_ALLOW)
            {
                hr = E_ACCESSDENIED;
                goto Cleanup;
            }
        }
    }

    *ppWindow = NULL;

    // get the IHTMLPrivateWindow3 
    hr = THR(_pWindow->QueryInterface(IID_IHTMLPrivateWindow3, (void**)&pPrivWnd3));
    if (hr)
        goto Cleanup;

    hr = THR(pPrivWnd3->OpenEx(
            bstrFullUrl ? bstrFullUrl : bstrUrl,
            bstrBaseUrl,
            bstrName, 
            bstrFeatures, 
            vbReplace, 
            &pWindow));
    if (hr)
    {
        if (hr == S_FALSE)  // valid return value
            hr = S_OK;
        else
            goto Cleanup;
    }
    
    if (pWindow)
    {
        hr = THR(SecureObject(pWindow, ppWindow));
        if (hr)
        {
            AssertSz(FALSE, "Window.open proxy: returning a secure object pointer failed");
            goto Cleanup;
        }
    }
    
Cleanup:
    ReleaseInterface(pPrivWnd3);
    ReleaseInterface(pWindow);
    FormsFreeString(bstrFullUrl);
    FormsFreeString(bstrBaseUrl);
    RRETURN(SetErrorInfo(hr));    
}

//+--------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::print
//
//  Synopsis:   Send the print cmd to this window
//
//---------------------------------------------------------------------------

HRESULT
COmWindowProxy::print()
{
    IMPLEMENT_SECURE_METHOD3(print())
    RRETURN(SetErrorInfo(hr));    
}


//+--------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::get_self
//
//  Synopsis:   Retrieve this window
//
//---------------------------------------------------------------------------

HRESULT 
COmWindowProxy::get_self(IHTMLWindow2**ppOut)
{
    IMPLEMENT_SECURE_WINDOWGET_WITHIDCHECK(get_self)
    RRETURN(SetErrorInfo(hr));
}


//+--------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::get_top
//
//  Synopsis:   Retrieve the topmost window from this window
//
//---------------------------------------------------------------------------

HRESULT 
COmWindowProxy:: get_top(IHTMLWindow2**ppOut)
{
    IMPLEMENT_SECURE_WINDOWGET_WITHIDCHECK(get_top)
    RRETURN(SetErrorInfo(hr));    
}


//+--------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::get_window
//
//  Synopsis:   Retrieve this window
//
//---------------------------------------------------------------------------

HRESULT 
COmWindowProxy:: get_window(IHTMLWindow2**ppOut)
{
    IMPLEMENT_SECURE_WINDOWGET_WITHIDCHECK(get_window);
    RRETURN(SetErrorInfo(hr));    
}

//+----------------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::execScript
//
//  Synopsis:   object model method implementation
//
//
//-----------------------------------------------------------------------------------

HRESULT
COmWindowProxy::execScript(BSTR bstrCode, BSTR bstrLanguage, VARIANT * pvarRet)
{
    if(_pCWindow)
    {
        BOOL fRunScript = FALSE;
        HRESULT hres = Markup()->ProcessURLAction(URLACTION_SCRIPT_RUN, &fRunScript);
        if(hres || !fRunScript)
        {
            return E_ACCESSDENIED;
        }
    }

    IMPLEMENT_SECURE_METHOD(execScript(bstrCode, bstrLanguage, pvarRet))
    RRETURN(SetErrorInfo(hr));    
}

//+--------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::navigate
//
//  Synopsis:   Navigate to this url
//
//---------------------------------------------------------------------------

HRESULT 
COmWindowProxy::navigate(BSTR url)
{
    HRESULT                 hr = S_OK;
    BSTR                    bstrFullUrl = NULL;
    BSTR                    bstrBaseUrl = NULL;
    IHTMLPrivateWindow2 *   pPrivateWnd = NULL;
    
    hr = THR(GetFullyExpandedUrl(this, url, &bstrFullUrl, &bstrBaseUrl));
    if (hr)
        goto Cleanup;

    // get the IHTMLPrivateWindow2 pointer to call NavigateEx
    hr = THR(_pWindow->QueryInterface( IID_IHTMLPrivateWindow2, (void**)&pPrivateWnd));
    if (hr)
        goto Cleanup;
    
    hr = THR(pPrivateWnd->NavigateEx(bstrFullUrl,
                                     NULL,
                                     NULL,
                                     bstrBaseUrl,
                                     NULL,
                                     0,
                                     CDoc::FHL_SETURLCOMPONENT | CDoc::FHL_DONTEXPANDURL));

Cleanup:
    FormsFreeString(bstrFullUrl);
    FormsFreeString(bstrBaseUrl);
    ReleaseInterface(pPrivateWnd);

    RRETURN(SetErrorInfo(hr));    
}


//+--------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::get_Option
//
//  Synopsis:   Retrieve the option element factory
//
//---------------------------------------------------------------------------

HRESULT 
COmWindowProxy:: get_Option(IHTMLOptionElementFactory **ppOut)
{
    IHTMLOptionElementFactory * pReal = NULL;

    IMPLEMENT_SECURE_OBJECTGET(get_Option)
    RRETURN(SetErrorInfo(hr));    
}

//+----------------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::focus
//
//  Synopsis:   object model implementation
//
//
//-----------------------------------------------------------------------------------

HRESULT
COmWindowProxy::focus()
{
    HRESULT hr;
    hr = THR(_pWindow->focus());
    RRETURN(SetErrorInfo(hr));
}

//+----------------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::blur
//
//  Synopsis:   object model implementation
//
//
//-----------------------------------------------------------------------------------

HRESULT
COmWindowProxy::blur()
{
    HRESULT hr;
    hr = THR(_pWindow->blur());
    RRETURN(SetErrorInfo(hr));
}

//+----------------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::focus
//
//  Synopsis:   object model implementation
//
//
//-----------------------------------------------------------------------------------

HRESULT
COmWindowProxy::get_closed(VARIANT_BOOL *p)
{
    HRESULT hr;
    
    //
    // No security check for the closed property.
    //

    hr = THR(_pWindow->get_closed(p));

    if (WINDOWDEAD())
    {
        *p = VB_TRUE;
        hr = S_OK;
    }

    RRETURN(SetErrorInfo(hr));    
}


//+----------------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::scroll
//
//  Synopsis:   object model implementation
//
//
//-----------------------------------------------------------------------------------

HRESULT
COmWindowProxy::scroll(long x, long y)
{
    IMPLEMENT_SECURE_METHOD(scroll(x, y))
    RRETURN(SetErrorInfo(hr));
}


//+----------------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::scrollBy
//
//  Synopsis:   object model implementation
//
//
//-----------------------------------------------------------------------------------
HRESULT
COmWindowProxy::scrollBy(long x, long y)
{
    IMPLEMENT_SECURE_METHOD(scrollBy(x, y))
    RRETURN(SetErrorInfo(hr));
}


//+----------------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::scrollTo
//
//  Synopsis:   object model implementation
//
//
//-----------------------------------------------------------------------------------
HRESULT
COmWindowProxy::scrollTo(long x, long y)
{
    // This method performs exactly the same action as scroll
    IMPLEMENT_SECURE_METHOD(scrollTo(x, y))
    RRETURN(SetErrorInfo(hr));
}

//+----------------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::moveBy
//
//  Synopsis:   object model implementation
//
//
//-----------------------------------------------------------------------------------
HRESULT
COmWindowProxy::moveBy(long x, long y)
{
    IMPLEMENT_SECURE_METHOD(moveBy(x, y))
    RRETURN(SetErrorInfo(hr));
}


//+----------------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::moveTo
//
//  Synopsis:   object model implementation
//
//
//-----------------------------------------------------------------------------------
HRESULT
COmWindowProxy::moveTo(long x, long y)
{
    // This method performs exactly the same action as scroll
    IMPLEMENT_SECURE_METHOD(moveTo(x, y))
    RRETURN(SetErrorInfo(hr));
}

//+----------------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::resizeBy
//
//  Synopsis:   object model implementation
//
//
//-----------------------------------------------------------------------------------
HRESULT
COmWindowProxy::resizeBy(long x, long y)
{
    // This method performs exactly the same action as scroll
    IMPLEMENT_SECURE_METHOD(resizeBy(x, y))
    RRETURN(SetErrorInfo(hr));
}

//+----------------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::resizeTo
//
//  Synopsis:   object model implementation
//
//
//-----------------------------------------------------------------------------------
HRESULT
COmWindowProxy::resizeTo(long x, long y)
{
    // This method performs exactly the same action as scroll
    IMPLEMENT_SECURE_METHOD(resizeTo(x, y))
    RRETURN(SetErrorInfo(hr));
}

HRESULT
COmWindowProxy::createPopup(VARIANT *pVarInArg, IDispatch** ppPopup)
{
    IMPLEMENT_SECURE_METHOD4(createPopup(pVarInArg, ppPopup))
    RRETURN(SetErrorInfo(hr));
}

//+------------------------------------------------------------------------
//
//  Method: COmWindowProxy : IsEqualObject
//
//  Synopsis; IObjectIdentity method implementation
//
//  Returns : S_OK if objects are equal, E_FAIL otherwise
//
//-------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
COmWindowProxy::IsEqualObject( IUnknown * pUnk)
{
    HRESULT             hr = E_POINTER;
    IHTMLWindow2      * pWindow = NULL;
    IServiceProvider  * pISP = NULL;

    if (!pUnk)
        goto Cleanup;

    hr = THR_NOTRACE(pUnk->QueryInterface(IID_IServiceProvider, (void **) &pISP));
    if (hr)
        goto Cleanup;

    hr = THR_NOTRACE(pISP->QueryService(SID_SHTMLWindow2, 
                                         IID_IHTMLWindow2,
                                         (void **) &pWindow));
    if (hr)
        goto Cleanup;

    // are the objects the same
    hr = IsSameObject(_pWindow, pWindow) ? S_OK : S_FALSE;

Cleanup:
    ReleaseInterface(pWindow);
    ReleaseInterface(pISP);
    RRETURN1(hr, S_FALSE);
}

//+-------------------------------------------------------------------------
//
//  Method : COmWindowProxy
//
//  Synopsis : IServiceProvider method Implementaion.
//
//--------------------------------------------------------------------------

HRESULT
COmWindowProxy::QueryService(REFGUID guidService, REFIID riid, void **ppvObject)
{
    HRESULT            hr = E_POINTER;
    IServiceProvider * pISP = NULL;

    if (!ppvObject)
        goto Cleanup;

    *ppvObject = NULL;

    hr = THR_NOTRACE(_pWindow->QueryInterface(IID_IServiceProvider, (void**)&pISP));
    if (!hr)
        hr = THR_NOTRACE(pISP->QueryService(guidService, riid, ppvObject));

    ReleaseInterface(pISP);

Cleanup:
    RRETURN1(hr, E_NOINTERFACE);
}


//+---------------------------------------------------------------------------
//
//  Method:     COmWindowProxy::ValidateMarshalParams
//
//  Synopsis:   Validates the standard set parameters that are passed into most
//              of the IMarshal methods
//
//----------------------------------------------------------------------------

HRESULT 
COmWindowProxy::ValidateMarshalParams(
    REFIID riid,
    void *pvInterface,
    DWORD dwDestContext,
    void *pvDestContext,
    DWORD mshlflags)
{
    HRESULT hr = NOERROR;
 
    if (CanMarshalIID(riid))
    {
        if ((dwDestContext != MSHCTX_INPROC && 
             dwDestContext != MSHCTX_LOCAL && 
             dwDestContext != MSHCTX_NOSHAREDMEM) ||
            (mshlflags != MSHLFLAGS_NORMAL && 
             mshlflags != MSHLFLAGS_TABLESTRONG))
        {
            Assert(0 && "Invalid argument");
            hr = E_INVALIDARG;
        }
    }
    else
    {
        hr = E_NOINTERFACE;
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Method:     COmWindowProxy::GetUnmarshalClass
//
//  Synopsis:
//
//----------------------------------------------------------------------------

STDMETHODIMP
COmWindowProxy::GetUnmarshalClass(
    REFIID riid,
    void *pvInterface,
    DWORD dwDestContext, 
    void *pvDestContext, 
    DWORD mshlflags, 
    CLSID *pclsid)
{
    HRESULT hr;

    hr = THR(ValidateMarshalParams(
            riid, 
            pvInterface, 
            dwDestContext,
            pvDestContext, 
            mshlflags));
    if (!hr)
    {
        *pclsid = CLSID_HTMLWindowProxy;
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Method:     COmWindowProxy::GetMarshalSizeMax
//
//  Synopsis:
//
//----------------------------------------------------------------------------

STDMETHODIMP
COmWindowProxy::GetMarshalSizeMax(
    REFIID riid,
    void *pvInterface,
    DWORD dwDestContext,
    void *pvDestContext,
    DWORD mshlflags,
    DWORD *pdwSize)
{
#ifdef WIN16
    return E_FAIL;
#else
    HRESULT hr;

    if (!pdwSize)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR(ValidateMarshalParams(
            riid, 
            pvInterface, 
            dwDestContext,
            pvDestContext, 
            mshlflags));
    if (hr) 
        goto Cleanup;

    //
    // Size is the _cbSID + sizeof(DWORD) +
    // size of marshalling _pWindow
    //

    hr = THR(CoGetMarshalSizeMax(
            pdwSize,
            riid,
            _pWindow,
            dwDestContext,
            pvDestContext,
            mshlflags));
    if (hr)
        goto Cleanup;
        
    (*pdwSize) += sizeof(DWORD) + _cbSID;

Cleanup:
    RRETURN(hr);
#endif //ndef WIN16
}


//+---------------------------------------------------------------------------
//
//  Method:     COmWindowProxy::MarshalInterface
//
//  Synopsis:   Write data of current proxy into a stream to read
//              out on the other side.
//
//----------------------------------------------------------------------------

HRESULT
COmWindowProxy::MarshalInterface(
    IStream *pStm,
    REFIID riid,
    void *pvInterface, 
    DWORD dwDestContext,
    void *pvDestContext, 
    DWORD mshlflags)
{
    HRESULT hr;

    hr = THR(ValidateMarshalParams(
            riid, 
            pvInterface, 
            dwDestContext,
            pvDestContext, 
            mshlflags));
    if (hr)
        goto Cleanup;

    //
    // Call the real worker
    //

    hr = THR(MarshalInterface(
            TRUE,
            pStm,
            riid,
            pvInterface,
            dwDestContext,
            pvDestContext,
            mshlflags));
    
Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Method:     COmWindowProxy::MarshalInterface
//
//  Synopsis:   Actual worker of marshalling.  Takes an additional 
//              BOOL to signify what is actually getting marshalled,
//              the window proxy or location proxy.
//
//----------------------------------------------------------------------------

HRESULT
COmWindowProxy::MarshalInterface(
    BOOL fWindow,
    IStream *pStm,
    REFIID riid,
    void *pvInterface, 
    DWORD dwDestContext,
    void *pvDestContext, 
    DWORD mshlflags)
{
    HRESULT hr;

    //  Marshal _pWindow
    hr = THR(CoMarshalInterface(
            pStm,
            IID_IHTMLWindow2,
            _pWindow,
            dwDestContext,
            pvDestContext,
            mshlflags));
    if (hr)
        goto Cleanup;

    //  Write _pbSID
    hr = THR(pStm->Write(&_cbSID, sizeof(DWORD), NULL));
    if (hr)
        goto Cleanup;

    hr = THR(pStm->Write(_pbSID, _cbSID, NULL));
    if (hr)
        goto Cleanup;

    hr = THR(pStm->Write(&fWindow, sizeof(BOOL), NULL));
    if (hr)
        goto Cleanup;

    {
        BOOL fTrustedDoc = !!_fTrustedDoc; // convert from unsigned:1 to BOOL
        hr = THR(pStm->Write(&fTrustedDoc, sizeof(BOOL), NULL));
        if (hr)
            goto Cleanup;
    }

    {
        BOOL fDomainChanged = !!_fDomainChanged; // convert from unsigned:1 to BOOL
        hr = THR(pStm->Write(&fDomainChanged, sizeof(BOOL), NULL));
        if (hr)
            goto Cleanup;
    }
Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Method:     COmWindowProxy::UnmarshalInterface
//
//  Synopsis:   Unmarshals the interface out of a stream
//
//----------------------------------------------------------------------------

HRESULT
COmWindowProxy::UnmarshalInterface(
    IStream *pStm,
    REFIID riid,
    void ** ppvObj)
{
    HRESULT         hr = S_OK;
    IHTMLWindow2 *  pWindow = NULL;
    IHTMLWindow2 *  pProxy = NULL;
    BOOL            fWindow = FALSE;
    BOOL            fTrustedDoc = FALSE;
    BOOL            fDomainChanged = FALSE;
    BYTE            abSID[MAX_SIZE_SECURITY_ID];
    DWORD           cbSID;
    
    if (!ppvObj)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *ppvObj = NULL;
    if (!CanMarshalIID(riid))
    {
        hr = E_NOINTERFACE;
        goto Cleanup;
    }

    hr = THR(CoUnmarshalInterface(pStm, IID_IHTMLWindow2, (void **)&pWindow));
    if (hr)
        goto Cleanup;

    //  Read abSID
    hr = THR(pStm->Read(&cbSID, sizeof(DWORD), NULL));
    if (hr)
        goto Cleanup;

    hr = THR(pStm->Read(abSID, cbSID, NULL));
    if (hr)
        goto Cleanup;

    hr = THR(pStm->Read(&fWindow, sizeof(BOOL), NULL));
    if (hr)
        goto Cleanup;
        
    hr = THR(pStm->Read(&fTrustedDoc, sizeof(BOOL), NULL));
    if (hr)
        goto Cleanup;

    hr = THR(pStm->Read(&fDomainChanged, sizeof(DWORD), NULL));
    if (hr)
        goto Cleanup;

    
    //
    // Initialize myself with these values.  This is so the SecureObject
    // call below will know what to do.
    //

    _fTrustedDoc = !!fTrustedDoc;

    hr = THR(Init(pWindow, abSID, cbSID));
    if (hr)
        goto Cleanup;

    _fDomainChanged = !!fDomainChanged;
    //
    // Finally call SecureObject to return the right proxy.  This will
    // look in thread local storage to see if a security proxy for this
    // window already exists.  If so, it'll return that one, otherwise
    // it will create a new one with cstrSID as the security
    // context.  When OLE releases this object it will just disappear.
    //

    hr = THR(SecureObject(pWindow, &pProxy));
    if (hr)
        goto Cleanup;

    if (fWindow)
    {
        hr = THR_NOTRACE(pProxy->QueryInterface(riid, ppvObj));
    }
    else
    {
        COmWindowProxy *    pCProxy;

        Verify(!pProxy->QueryInterface(CLSID_HTMLWindowProxy, (void **)&pCProxy));
        hr = THR_NOTRACE(pCProxy->_Location.QueryInterface(riid, ppvObj));
    }
    if (hr)
        goto Cleanup;
        
Cleanup:
    ReleaseInterface(pWindow);
    ReleaseInterface(pProxy);
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Method:     COmWindowProxy::ReleaseMarshalData
//
//  Synopsis:   Free up any data used while marshalling
//
//----------------------------------------------------------------------------

HRESULT
COmWindowProxy::ReleaseMarshalData(IStream *pStm)
{
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Method:     COmWindowProxy::DisconnectObject
//
//  Synopsis:   Unmarshals the interface out of a stream
//
//----------------------------------------------------------------------------

HRESULT
COmWindowProxy::DisconnectObject(DWORD dwReserved)
{
    return S_OK;
}


class CGetLocation
{
public:
    CGetLocation(COmWindowProxy *pWindowProxy)
        { _pLoc = NULL; pWindowProxy->_pWindow->get_location(&_pLoc); }
    ~CGetLocation()
        { ReleaseInterface(_pLoc); }

    IHTMLLocation * _pLoc;
};

//+--------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::put_offscreenBuffering
//
//  Synopsis:   Set the name property
//
//---------------------------------------------------------------------------

HRESULT 
COmWindowProxy::put_offscreenBuffering(VARIANT var)
{
    RRETURN(SetErrorInfo(_pWindow->put_offscreenBuffering(var)));
}


//+--------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::get_offscreenBuffering
//
//  Synopsis:   Get the name property
//
//---------------------------------------------------------------------------
HRESULT 
COmWindowProxy::get_offscreenBuffering(VARIANT *ppOut)
{
    // can't use IMPLEMENT_SECURE_PROPGET(get_offscreenBuffering) because of ppOut = NULL; line
    HRESULT hr = E_ACCESSDENIED;                              
                                                    
    if (AccessAllowed())                           
    {                                               
      hr = THR(_pWindow->get_offscreenBuffering(ppOut));                
    }                                               
    RRETURN(SetErrorInfo(hr));    
}


//+--------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::get_external
//
//  Synopsis:   Get IDispatch object associated with the IDocHostUIHandler
//
//---------------------------------------------------------------------------
HRESULT 
COmWindowProxy::get_external(IDispatch **ppOut)
{
    IDispatch * pReal = NULL;

    IMPLEMENT_SECURE_OBJECTGET(get_external)
    RRETURN(SetErrorInfo(hr));    
}

#ifndef UNIX
//
// IEUNIX: Due to vtable pointer counts (I believe), the size is 8, not 4
//

StartupAssert(sizeof(void *) == sizeof(COmLocationProxy));
#endif

BEGIN_TEAROFF_TABLE_NAMED(COmLocationProxy, s_apfnLocationVTable)
    TEAROFF_METHOD(COmLocationProxy, QueryInterface, queryinterface, (REFIID riid, void **ppv))
    TEAROFF_METHOD_(COmLocationProxy, AddRef, addref, ULONG, ())
    TEAROFF_METHOD_(COmLocationProxy, Release, release, ULONG, ())
    TEAROFF_METHOD_NULL
    TEAROFF_METHOD_NULL
    TEAROFF_METHOD(COmLocationProxy, MarshalInterface, marshalinterface, (IStream *pistm,REFIID riid,void *pvInterface,DWORD dwDestContext,void *pvDestContext,DWORD mshlflags))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE_(COmLocationProxy, IObjectIdentity)
    TEAROFF_METHOD(CCOmLocationProxy, IsEqualObject, isequalobject, (IUnknown*))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE_(COmLocationProxy, IServiceProvider)
    TEAROFF_METHOD(COmLocationProxy, QueryService, queryservice, (REFGUID guidService, REFIID riid, void **ppvObject))
END_TEAROFF_TABLE()

//+-------------------------------------------------------------------------
//
//  Method:     COmLocationProxy::QueryInterface
//
//  Synopsis:   Per IUnknown
//
//--------------------------------------------------------------------------

HRESULT
COmLocationProxy::QueryInterface(REFIID iid, LPVOID * ppv)
{
    HRESULT         hr = S_OK;
    
    *ppv = NULL;

    switch (iid.Data1)
    {
        QI_INHERITS2(this, IUnknown, IHTMLLocation)
        QI_TEAROFF(this, IDispatchEx, NULL)
        QI_TEAROFF(this, IObjectIdentity, NULL)
        QI_TEAROFF(this, IServiceProvider, NULL)
        QI_INHERITS(this, IHTMLLocation)
        QI_INHERITS2(this, IDispatch, IHTMLLocation)
        QI_CASE(IMarshal)
        {
            IMarshal *  pMarshal = NULL;
            
            hr = THR(MyWindowProxy()->QueryInterface(
                    IID_IMarshal,
                    (void **)&pMarshal));
            if (hr)
                RRETURN(hr);
                
            hr = THR(CreateTearOffThunk(
                    pMarshal,
                    *(void **)pMarshal,
                    NULL,
                    ppv,
                    (IHTMLLocation *)this,
                    (void *)s_apfnLocationVTable,
                    QI_MASK + ADDREF_MASK + RELEASE_MASK + METHOD_MASK(5), NULL));
            ReleaseInterface(pMarshal);
            if (hr)
                RRETURN(hr);
            break;
        }
    }

    if (*ppv)
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}


//+-------------------------------------------------------------------------
//
//  Method:     COmLocationProxy::GetTypeInfoCount
//
//  Synopsis:   Per IDispatch
//
//--------------------------------------------------------------------------

HRESULT
COmLocationProxy::GetTypeInfoCount(UINT FAR* pctinfo)
{
    TraceTag((tagSecurity, "GetTypeInfoCount"));
    CGetLocation    cg(MyWindowProxy());
    
    if (!cg._pLoc)
        RRETURN(E_FAIL);
    
    RRETURN(cg._pLoc->GetTypeInfoCount(pctinfo));
}


//+-------------------------------------------------------------------------
//
//  Method:     COmLocationProxy::GetTypeInfo
//
//  Synopsis:   Per IDispatch
//
//--------------------------------------------------------------------------

HRESULT
COmLocationProxy::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo ** pptinfo)
{
    TraceTag((tagSecurity, "GetTypeInfo"));

    CGetLocation    cg(MyWindowProxy());
    
    if (!cg._pLoc)
        RRETURN(E_FAIL);
    

    RRETURN(cg._pLoc->GetTypeInfo(itinfo, lcid, pptinfo));
}


//+-------------------------------------------------------------------------
//
//  Method:     COmLocationProxy::GetIDsOfNames
//
//  Synopsis:   Per IDispatch
//
//--------------------------------------------------------------------------

HRESULT
COmLocationProxy::GetIDsOfNames(
    REFIID                riid,
    LPOLESTR *            rgszNames,
    UINT                  cNames,
    LCID                  lcid,
    DISPID FAR*           rgdispid)
{
    CGetLocation    cg(MyWindowProxy());
    
    if (!cg._pLoc)
        RRETURN(DISP_E_UNKNOWNNAME);
    
    RRETURN(cg._pLoc->GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid));
}

HRESULT
COmLocationProxy::Invoke(DISPID dispid,
                         REFIID riid,
                         LCID lcid,
                         WORD wFlags,
                         DISPPARAMS *pdispparams,
                         VARIANT *pvarResult,
                         EXCEPINFO *pexcepinfo,
                         UINT *puArgErr)
{
    return InvokeEx(dispid,
                    lcid,
                    wFlags,
                    pdispparams,
                    pvarResult,
                    pexcepinfo,
                    NULL);
}


HRESULT GetCallerIDispatch(IServiceProvider *pSP, IDispatch ** ppID)
{
    HRESULT             hr;
    IOleCommandTarget * pCommandTarget = NULL;
    VARIANT            Var;

    VariantInit(&Var);
    Assert(ppID);
    
    hr = THR(GetCallerCommandTarget(NULL, pSP, TRUE, &pCommandTarget));
    if (hr)
    {
        goto Cleanup;
    }

    // Get the security state
    hr = THR(pCommandTarget->Exec(
            &CGID_ScriptSite,
            CMDID_SCRIPTSITE_SECURITY_WINDOW,
            0,
            NULL,
            &Var));

    
    //in the case of pad, this command is not supported
    //so we return S_OK without setting the ppID...
    if (hr == OLECMDERR_E_NOTSUPPORTED)
    {
        hr = S_OK;
        goto Cleanup;
    }

    if (hr)
    {
        goto Cleanup;
    }


    Assert(V_VT(&Var) == VT_DISPATCH);
    *ppID = (IDispatch *)(V_DISPATCH(&Var));

Cleanup:
    ReleaseInterface(pCommandTarget);
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Method:     COmLocationProxy::Invoke
//
//  Synopsis:   Per IDispatch
//
//--------------------------------------------------------------------------

HRESULT
COmLocationProxy::InvokeEx(DISPID dispidMember,
                           LCID lcid,
                           WORD wFlags,
                           DISPPARAMS *pdispparams,
                           VARIANT *pvarResult,
                           EXCEPINFO *pexcepinfo,
                           IServiceProvider *pSrvProvider)
{
    TraceTag((tagSecurity, "Invoke dispid=0x%x", dispidMember));

    HRESULT         hr = S_OK;
    CGetLocation    cg(MyWindowProxy());
    BSTR            bstrOld = NULL;
    BSTR            bstrNew = NULL;
    BSTR            bstrBaseUrl = NULL;
    CStr            cstrSpecialURL;
    IDispatch     * pCaller = NULL;

    if (!cg._pLoc)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    //
    // If Access is allowed or if the invoke is for doing
    // a put on the href property, act as a pass through.
    //

    if (MyWindowProxy()->AccessAllowed() ||
        (!dispidMember && 
            wFlags & (DISPATCH_PROPERTYPUT | DISPATCH_PROPERTYPUTREF)) ||
        (dispidMember == DISPID_COmLocation_replace))
    {
        //
        // If this is a put_href, just expand the url correctly with
        // the base url of the caller.
        //


        if ( (!dispidMember || 
              dispidMember == DISPID_COmLocation_replace ||
              dispidMember == DISPID_COmLocation_assign ||
              dispidMember == DISPID_COmLocation_reload) &&
            pdispparams->cArgs==1 && 
            pdispparams->rgvarg[0].vt == VT_BSTR && 
            pSrvProvider )
        {
            IHTMLPrivateWindow2 * pPrivateWnd;

            bstrOld = V_BSTR(&pdispparams->rgvarg[0]);

            if (bstrOld)
            {
                hr = THR(GetFullyExpandedUrl(NULL, bstrOld, &bstrNew, &bstrBaseUrl, pSrvProvider));
                if (hr)
                    goto Cleanup;

                V_BSTR(&pdispparams->rgvarg[0]) = bstrNew;

                // get the IHTMLPrivateWindow2 pointer to call NavigateEx
                hr = THR(MyWindowProxy()->_pWindow->QueryInterface( IID_IHTMLPrivateWindow2, (void**)&pPrivateWnd));
                if (hr)
                    goto Cleanup;
    
                hr = THR(pPrivateWnd->NavigateEx(bstrNew, 
                                                 V_BSTR(&pdispparams->rgvarg[0]), 
                                                 NULL, 
                                                 bstrBaseUrl, 
                                                 NULL, (DWORD)(dispidMember == DISPID_COmLocation_replace),
                                                 CDoc::FHL_SETURLCOMPONENT | 
                                                 (dispidMember == DISPID_COmLocation_replace ? CDoc::FHL_REPLACEURL : 0 ) ));

                ReleaseInterface(pPrivateWnd);
            }
        }
        
        // if the call was not handled in the above if statement, then use the invoke        
        if ((!bstrOld || !bstrNew))
        {
            if (pSrvProvider)
                hr = GetCallerIDispatch(pSrvProvider, &pCaller);

            if (!pCaller || MyWindowProxy()->AccessAllowed(pCaller))
            {
                hr = THR(cg._pLoc->Invoke(
                        dispidMember,
                        IID_NULL,
                        lcid,
                        wFlags,
                        pdispparams,
                        pvarResult,
                        pexcepinfo,
                        NULL));
            }
            else 
            {
                hr = E_ACCESSDENIED;
            }
        }

        if (hr)
            hr = MyWindowProxy()->SetErrorInfo(hr);
    }
    else
    {
        //
        // Deny access otherwise.  
        // CONSIDER: Is this too stringent?
        //

        hr = MyWindowProxy()->SetErrorInfo(E_ACCESSDENIED);
    }
    
Cleanup:
    if (bstrOld || bstrNew)
    {
        // replace the original arg - supposed top be [in] parameter only
        V_BSTR(&pdispparams->rgvarg[0]) = bstrOld;
    }
    FormsFreeString(bstrNew);
    FormsFreeString(bstrBaseUrl);
    ReleaseInterface(pCaller);
    RRETURN_NOTRACE(hr);
}


HRESULT
COmLocationProxy::GetMemberName (DISPID id, BSTR *pbstrName)
{
    HRESULT         hr;
    IDispatchEx *  pDispEx2 = NULL;
    CGetLocation    cg(MyWindowProxy());
    
    if (!cg._pLoc)
    {
        hr = E_FAIL;
        goto Cleanup;
    }
    
    hr = THR(cg._pLoc->QueryInterface(IID_IDispatchEx, (void **)&pDispEx2));
    if (hr)
        goto Cleanup;
        
    hr = THR_NOTRACE(pDispEx2->GetMemberName(id, pbstrName));
            
Cleanup:
    ReleaseInterface(pDispEx2);
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     COmLocationProxy::GetDispID
//
//  Synopsis:   Per IDispatchEx
//
//--------------------------------------------------------------------------

HRESULT
COmLocationProxy::GetDispID(BSTR bstrName, DWORD grfdex, DISPID *pid)
{
    HRESULT         hr;
    IDispatchEx *  pDispEx2 = NULL;
    CGetLocation    cg(MyWindowProxy());
    
    if (!cg._pLoc)
    {
        hr = E_FAIL;
        goto Cleanup;
    }
    
    hr = THR(cg._pLoc->QueryInterface(IID_IDispatchEx, (void **)&pDispEx2));
    if (hr)
        goto Cleanup;
        
    hr = THR_NOTRACE(pDispEx2->GetDispID(bstrName, grfdex, pid));
            
Cleanup:
    ReleaseInterface(pDispEx2);
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CBase::DeleteMember, IDispatchEx
//
//--------------------------------------------------------------------------

HRESULT
COmLocationProxy::DeleteMemberByName(BSTR bstr,DWORD grfdex)
{
    return E_NOTIMPL;
}

HRESULT
COmLocationProxy::DeleteMemberByDispID(DISPID id)
{
    return E_NOTIMPL;
}

//+-------------------------------------------------------------------------
//
//  Method:     CBase::GetMemberProperties, IDispatchEx
//
//--------------------------------------------------------------------------

HRESULT
COmLocationProxy::GetMemberProperties(
                DISPID id,
                DWORD grfdexFetch,
                DWORD *pgrfdex)
{
    return E_NOTIMPL;
}


//+-------------------------------------------------------------------------
//
//  Method:     COmLocationProxy::GetNextDispID
//
//  Synopsis:   Per IDispatchEx
//
//--------------------------------------------------------------------------
HRESULT
COmLocationProxy::GetNextDispID(DWORD grfdex,
                     DISPID id,
                     DISPID *prgid)
{
    HRESULT         hr;
    IDispatchEx *  pDispEx2 = NULL;
    CGetLocation    cg(MyWindowProxy());
    
    if (!cg._pLoc)
    {
        hr = E_FAIL;
        goto Cleanup;
    }
    
    // Cache the IDispatchEx ptr?
    hr = THR(cg._pLoc->QueryInterface(IID_IDispatchEx, (void **)&pDispEx2));
    if (hr)
        goto Cleanup;
        
    hr = THR(pDispEx2->GetNextDispID(grfdex, id, prgid));

Cleanup:
    ReleaseInterface(pDispEx2);
    RRETURN1(hr,S_FALSE);
}


//+-------------------------------------------------------------------------
//
//  Method:     COmLocationProxy::GetNameSpaceParent
//
//  Synopsis:   Per IDispatchEx
//
//--------------------------------------------------------------------------

HRESULT
COmLocationProxy::GetNameSpaceParent(IUnknown **ppunk)
{
    HRESULT         hr;
    IDispatchEx *  pDEX = NULL;
    CGetLocation    cg(MyWindowProxy());
    
    if (!cg._pLoc)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    if (!ppunk)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppunk = NULL;

    Verify (!THR(cg._pLoc->QueryInterface(IID_IDispatchEx, (void**) &pDEX)));

    hr = THR(pDEX->GetNameSpaceParent(ppunk));

Cleanup:
    ReleaseInterface (pDEX);
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Method:     COmLocationProxy::MarshalInterface
//
//  Synopsis:   Write data of current proxy into a stream to read
//              out on the other side.
//
//----------------------------------------------------------------------------

HRESULT
COmLocationProxy::MarshalInterface(
    IStream *pStm,
    REFIID riid,
    void *pvInterface, 
    DWORD dwDestContext,
    void *pvDestContext, 
    DWORD mshlflags)
{
    HRESULT hr;

    hr = THR(MyWindowProxy()->ValidateMarshalParams(
            riid, 
            pvInterface, 
            dwDestContext,
            pvDestContext, 
            mshlflags));
    if (hr)
        goto Cleanup;

    //
    // Call the real worker
    //

    hr = THR(MyWindowProxy()->MarshalInterface(
            FALSE,
            pStm,
            riid,
            pvInterface,
            dwDestContext,
            pvDestContext,
            mshlflags));
    
Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Method: COmLocationProxy : IsEqualObject
//
//  Synopsis; IObjectIdentity method implementation
//
//  Returns : S_OK if objects are equal, E_FAIL otherwise
//
//-------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
COmLocationProxy::IsEqualObject( IUnknown * pUnk)
{
    HRESULT          hr = E_POINTER;
    IServiceProvider *pISP = NULL;
    IHTMLLocation    *pShdcvwLoc = NULL;
    CGetLocation     cg(MyWindowProxy());

    if (!pUnk || !cg._pLoc)
        goto Cleanup;

    hr = THR_NOTRACE(pUnk->QueryInterface(IID_IServiceProvider, (void**)&pISP));
    if (hr)
        goto Cleanup;

    hr = THR_NOTRACE(pISP->QueryService(SID_SOmLocation, 
                                        IID_IHTMLLocation,
                                        (void**)&pShdcvwLoc));
    if (hr)
        goto Cleanup;

    // are the unknowns equal?
    hr = (IsSameObject(pShdcvwLoc, cg._pLoc)) ? S_OK : S_FALSE;

Cleanup:
    ReleaseInterface(pShdcvwLoc);
    ReleaseInterface(pISP);
    RRETURN1(hr, S_FALSE);
}


//+-------------------------------------------------------------------------
//
//  Method : COmLocationProxy
//
//  Synopsis : IServiceProvider methoid Implementaion.
//
//--------------------------------------------------------------------------

HRESULT
COmLocationProxy::QueryService(REFGUID guidService, REFIID riid, void **ppvObject)
{
    HRESULT hr = E_POINTER;

    if (!ppvObject)
        goto Cleanup;

    *ppvObject = NULL;

    if ( guidService == SID_SOmLocation)
    {
        CGetLocation    cg(MyWindowProxy());

        if (!cg._pLoc)
        {
            hr = E_FAIL;
        }
        else
        {
            hr = THR_NOTRACE(cg._pLoc->QueryInterface(riid, ppvObject));
        }
    }
    else
        hr = E_NOINTERFACE;

Cleanup:
    RRETURN1(hr, E_NOINTERFACE);
}

//+-------------------------------------------------------------------------
//
//  Method:     COmLocationProxy::put_href
//
//  Synopsis:   Per IHTMLLocation
//
//--------------------------------------------------------------------------

HRESULT
COmLocationProxy::put_href(BSTR bstr)
{
    CGetLocation    cg(MyWindowProxy());
    HRESULT         hr;
    
    if (!cg._pLoc)
    {
        hr = E_FAIL;
        goto Cleanup;
    }
    
    // Expand the URL using the base HREF of the caller

    //
    // Always allow puts on the href to go thru for netscape compat.
    //
    
    hr = THR(cg._pLoc->put_href(bstr));
    
Cleanup:
    RRETURN(MyWindowProxy()->SetErrorInfo(hr));
}


#define IMPLEMENT_SECURE_LOCATION_METH(meth)        \
    HRESULT         hr = S_OK;                      \
    CGetLocation    cg(MyWindowProxy());            \
                                                    \
    if (!cg._pLoc)                                  \
    {                                               \
        hr = E_FAIL;                                \
        goto Cleanup;                               \
    } \
    hr = MyWindowProxy()->AccessAllowed() ?         \
            cg._pLoc->meth(bstr) :                  \
            E_ACCESSDENIED;                         \
Cleanup:                                            \
    return MyWindowProxy()->SetErrorInfo(hr);       \



  
//+-------------------------------------------------------------------------
//
//  Method:     COmLocationProxy::get_href
//
//  Synopsis:   Per IHTMLLocation
//
//--------------------------------------------------------------------------

HRESULT
COmLocationProxy::get_href(BSTR *bstr)
{
    IMPLEMENT_SECURE_LOCATION_METH(get_href)
}


//+-------------------------------------------------------------------------
//
//  Method:     COmLocationProxy::put_protocol
//
//  Synopsis:   Per IHTMLLocation
//
//--------------------------------------------------------------------------

HRESULT
COmLocationProxy::put_protocol(BSTR bstr)
{
    IMPLEMENT_SECURE_LOCATION_METH(put_protocol)
}


//+-------------------------------------------------------------------------
//
//  Method:     COmLocationProxy::get_protocol
//
//  Synopsis:   Per IHTMLLocation
//
//--------------------------------------------------------------------------

HRESULT
COmLocationProxy::get_protocol(BSTR *bstr)
{
    IMPLEMENT_SECURE_LOCATION_METH(get_protocol)
}


//+-------------------------------------------------------------------------
//
//  Method:     COmLocationProxy::put_host
//
//  Synopsis:   Per IHTMLLocation
//
//--------------------------------------------------------------------------

HRESULT
COmLocationProxy::put_host(BSTR bstr)
{
    IMPLEMENT_SECURE_LOCATION_METH(put_host)
}


//+-------------------------------------------------------------------------
//
//  Method:     COmLocationProxy::get_host
//
//  Synopsis:   Per IHTMLLocation
//
//--------------------------------------------------------------------------

HRESULT
COmLocationProxy::get_host(BSTR *bstr)
{
    IMPLEMENT_SECURE_LOCATION_METH(get_host)
}


//+-------------------------------------------------------------------------
//
//  Method:     COmLocationProxy::put_hostname
//
//  Synopsis:   Per IHTMLLocation
//
//--------------------------------------------------------------------------

HRESULT
COmLocationProxy::put_hostname(BSTR bstr)
{
    IMPLEMENT_SECURE_LOCATION_METH(put_hostname)
}


//+-------------------------------------------------------------------------
//
//  Method:     COmLocationProxy::get_hostname
//
//  Synopsis:   Per IHTMLLocation
//
//--------------------------------------------------------------------------

HRESULT
COmLocationProxy::get_hostname(BSTR *bstr)
{
    IMPLEMENT_SECURE_LOCATION_METH(get_hostname)
}


//+-------------------------------------------------------------------------
//
//  Method:     COmLocationProxy::put_port
//
//  Synopsis:   Per IHTMLLocation
//
//--------------------------------------------------------------------------

HRESULT
COmLocationProxy::put_port(BSTR bstr)
{
    IMPLEMENT_SECURE_LOCATION_METH(put_port)
}


//+-------------------------------------------------------------------------
//
//  Method:     COmLocationProxy::get_port
//
//  Synopsis:   Per IHTMLLocation
//
//--------------------------------------------------------------------------

HRESULT
COmLocationProxy::get_port(BSTR *bstr)
{
    IMPLEMENT_SECURE_LOCATION_METH(get_port)
}


//+-------------------------------------------------------------------------
//
//  Method:     COmLocationProxy::get_pathname
//
//  Synopsis:   Per IHTMLLocation
//
//--------------------------------------------------------------------------

HRESULT
COmLocationProxy::get_pathname(BSTR *bstr)
{
    IMPLEMENT_SECURE_LOCATION_METH(get_pathname)
}


//+-------------------------------------------------------------------------
//
//  Method:     COmLocationProxy::put_pathname
//
//  Synopsis:   Per IHTMLLocation
//
//--------------------------------------------------------------------------

HRESULT
COmLocationProxy::put_pathname(BSTR bstr)
{
    IMPLEMENT_SECURE_LOCATION_METH(put_pathname)
}


//+-------------------------------------------------------------------------
//
//  Method:     COmLocationProxy::get_search
//
//  Synopsis:   Per IHTMLLocation
//
//--------------------------------------------------------------------------

HRESULT
COmLocationProxy::get_search(BSTR *bstr)
{
    IMPLEMENT_SECURE_LOCATION_METH(get_search)
}


//+-------------------------------------------------------------------------
//
//  Method:     COmLocationProxy::put_search
//
//  Synopsis:   Per IHTMLLocation
//
//--------------------------------------------------------------------------

HRESULT
COmLocationProxy::put_search(BSTR bstr)
{
    IMPLEMENT_SECURE_LOCATION_METH(put_search)
}


//+-------------------------------------------------------------------------
//
//  Method:     COmLocationProxy::put_hash
//
//  Synopsis:   Per IHTMLLocation
//
//--------------------------------------------------------------------------

HRESULT
COmLocationProxy::put_hash(BSTR bstr)
{
    IMPLEMENT_SECURE_LOCATION_METH(put_hash)
}


//+-------------------------------------------------------------------------
//
//  Method:     COmLocationProxy::get_hash
//
//  Synopsis:   Per IHTMLLocation
//
//--------------------------------------------------------------------------

HRESULT
COmLocationProxy::get_hash(BSTR *bstr)
{
    IMPLEMENT_SECURE_LOCATION_METH(get_hash)
}


//+-------------------------------------------------------------------------
//
//  Method:     COmLocationProxy::reload
//
//  Synopsis:   Per IHTMLLocation
//
//--------------------------------------------------------------------------

HRESULT
COmLocationProxy::reload(VARIANT_BOOL flag)
{
    CGetLocation    cg(MyWindowProxy());
    HRESULT         hr = S_OK;
    
    if (!cg._pLoc)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = MyWindowProxy()->AccessAllowed() ? 
            cg._pLoc->reload(flag) : E_ACCESSDENIED;

Cleanup:
    RRETURN(MyWindowProxy()->SetErrorInfo(hr));
}


//+-------------------------------------------------------------------------
//
//  Method:     COmLocationProxy::replace
//
//  Synopsis:   Per IHTMLLocation
//
//--------------------------------------------------------------------------

HRESULT
COmLocationProxy::replace(BSTR bstr)
{
    CGetLocation    cg(MyWindowProxy());
    HRESULT         hr = S_OK;
    
    if (!cg._pLoc)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = THR(cg._pLoc->replace(bstr));

Cleanup:
    RRETURN(MyWindowProxy()->SetErrorInfo(hr));
}

//+-------------------------------------------------------------------------
//
//  Method:     COmLocationProxy::assign
//
//  Synopsis:   Per IHTMLLocation
//
//--------------------------------------------------------------------------

HRESULT
COmLocationProxy::assign(BSTR bstr)
{
    IMPLEMENT_SECURE_LOCATION_METH(assign)
}

//+-------------------------------------------------------------------------
//
//  Method:     COmLocationProxy::toString
//
//  Synopsis:   Per IHTMLLocation
//
//--------------------------------------------------------------------------

HRESULT
COmLocationProxy::toString(BSTR * bstr)
{
    IMPLEMENT_SECURE_LOCATION_METH(toString)
}

//****************************************************************************
//
//  sub* IDispatchEx methods.
//
//****************************************************************************

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
HRESULT
COmWindowProxy::subGetTypeInfoCount(UINT FAR* pctinfo)
{
    RRETURN(GetTypeInfoCount(pctinfo));
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
HRESULT
COmWindowProxy::subGetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo ** pptinfo)
{
    RRETURN(GetTypeInfo(itinfo, lcid, pptinfo));
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
HRESULT
COmWindowProxy::subGetIDsOfNames(
    REFIID                riid,
    LPOLESTR *            rgszNames,
    UINT                  cNames,
    LCID                  lcid,
    DISPID FAR*           rgdispid)
{
    RRETURN(GetIDsOfNames( riid, rgszNames, cNames, lcid, rgdispid));
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
HRESULT
COmWindowProxy::subInvoke(
    DISPID          dispid,
    REFIID          riid,
    LCID            lcid,
    WORD            wFlags,
    DISPPARAMS *    pdispparams,
    VARIANT *       pvarResult,
    EXCEPINFO *     pexcepinfo,
    UINT *          puArgErr)
{
    RRETURN(Invoke(dispid, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr));
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
HRESULT
COmWindowProxy::subGetDispID(BSTR bstrName, DWORD grfdex, DISPID *pid)
{
    RRETURN(GetDispID(bstrName, grfdex, pid));
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
HRESULT
COmWindowProxy::subInvokeEx(DISPID dispidMember,
                         LCID lcid,
                         WORD wFlags,
                         DISPPARAMS *pdispparams,
                         VARIANT *pvarResult,
                         EXCEPINFO *pexcepinfo,
                         IServiceProvider *pSrvProvider)
{
    RRETURN(InvokeEx(dispidMember, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, pSrvProvider));
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
HRESULT
COmWindowProxy::subDeleteMemberByName(BSTR bstr,DWORD grfdex)
{
    RRETURN(DeleteMemberByName(bstr, grfdex));
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
HRESULT
COmWindowProxy::subDeleteMemberByDispID(DISPID id)
{
    RRETURN(DeleteMemberByDispID(id));
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
HRESULT
COmWindowProxy::subGetMemberProperties(
                DISPID id,
                DWORD grfdexFetch,
                DWORD *pgrfdex)
{
    RRETURN(GetMemberProperties( id, grfdexFetch, pgrfdex));
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
HRESULT
COmWindowProxy::subGetMemberName (DISPID id, BSTR *pbstrName)
{
    RRETURN(GetMemberName(id, pbstrName));
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
HRESULT
COmWindowProxy::subGetNextDispID(DWORD grfdex,
                              DISPID id,
                              DISPID *prgid)
{
    RRETURN(GetNextDispID(grfdex, id, prgid));
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
HRESULT
COmWindowProxy::subGetNameSpaceParent(IUnknown **ppunk)
{
    RRETURN(GetNameSpaceParent(ppunk));
}


#if DBG==1
//  
//  COmWindowProxy::get_isSecureProxy -- IDebugWindowProxy
//
//  debug-only read-only boolean property
//
HRESULT
COmWindowProxy::get_isSecureProxy(VARIANT_BOOL * p)
{
    if (!p)
        return E_INVALIDARG;
    
    if (_fTrusted)
        *p = VB_FALSE;
    else
        *p = VB_TRUE;

    return S_OK;
}

//  
//  COmWindowProxy::get_trustedProxy -- IDebugWindowProxy
//
// debug-only trusted proxy access
//
HRESULT
COmWindowProxy::get_trustedProxy(IDispatch ** p)
{
    if (!p)
        return E_INVALIDARG;
     *p = NULL;
    
    CWindow *pCWindow;
    HRESULT hr = _pWindow->QueryInterface(CLSID_HTMLWindow2, (void**)&pCWindow);
    if (hr == S_OK && pCWindow && pCWindow->_pWindowProxy)
    {
        hr = pCWindow->_pWindowProxy->QueryInterface(IID_IHTMLWindow2, (void**)p);
    }

    return hr;
}

//  
//  COmWindowProxy::get_internalWindow -- IDebugWindowProxy
//
//  debug-only unsafe CWindow access
//
HRESULT
COmWindowProxy::get_internalWindow(IDispatch ** p)
{
    if (!p)
        return E_INVALIDARG;
    *p = NULL;

    IHTMLWindow2 *pWindow2;
    HRESULT hr = _pWindow->get_window(&pWindow2);
    if (hr == S_OK)
    {
        *p = (IDispatch *)pWindow2;
    }

    return hr;
}

//  
//  COmWindowProxy::enableSecureProxyAsserts -- IDebugWindowProxy
//
//  debug-only read-only boolean property
//
HRESULT
COmWindowProxy::enableSecureProxyAsserts(VARIANT_BOOL vbEnable)
{
    BOOL fEnable = (vbEnable != VB_FALSE);
    
    EnableTag(tagSecurityProxyCheck, fEnable);
    EnableTag(tagSecurityProxyCheckMore, fEnable);
    EnableTag(tagSecureScriptWindow, fEnable);
    
    return S_OK;
}

//
// COmWindowProxy::CSecureProxyLock - must be set by a secure proxy before calling
// sript-accessible methods on CWindow (such as CWindow::Invoke) 
//
COmWindowProxy::CSecureProxyLock::CSecureProxyLock(IUnknown *pUnkWindow, COmWindowProxy *pProxy)
{
    _pWindow = NULL;
    
    if (S_OK == pUnkWindow->QueryInterface(IID_IDebugWindow, (void**)&_pWindow))
    {
        _pWindow->SetProxyCaller((IUnknown*)(void*)(IPrivateUnknown *) pProxy);
    }
}

COmWindowProxy::CSecureProxyLock::~CSecureProxyLock()
{
    if (_pWindow)
    {
        _pWindow->SetProxyCaller(NULL);
        _pWindow->Release();
    }
}

// helper
BOOL IsThisASecureProxy(IUnknown *punk)
{
    VARIANT vSecure = {VT_BOOL, VB_FALSE};
    DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};
    IDispatch *pdisp = NULL;
    
    if (S_OK == punk->QueryInterface(IID_IDispatch, (void **)&pdisp))
    {
        IGNORE_HR(pdisp->Invoke(DISPID_DEBUG_ISSECUREPROXY,
                                IID_NULL,
                                LCID_SCRIPTING,
                                DISPATCH_PROPERTYGET,
                                &dispparamsNoArgs,
                                &vSecure, NULL, NULL));
        pdisp->Release();
    }
    else
        Assert(FALSE);

    return V_BOOL(&vSecure) == VB_TRUE;
}

//
// secure a window proxy given its IDispatch
//
HRESULT COmWindowProxy::SecureProxyIUnknown(/*in, out*/IUnknown **ppunkProxy)
{
    IHTMLWindow2 *pw2Trusted;
    IHTMLWindow2 *pw2Secured;
    HRESULT hr = E_FAIL;

    if (ppunkProxy == NULL || *ppunkProxy == NULL)
        return S_OK;

    // check if it already secure
    if (IsThisASecureProxy(*ppunkProxy))
        return S_OK;
 
    if (S_OK == (hr = (*ppunkProxy)->QueryInterface(IID_IHTMLWindow2, (void **)&pw2Trusted)))
    {
        if (S_OK == (hr = SecureObject(pw2Trusted, &pw2Secured)))
        {
            (*ppunkProxy)->Release();
            (*ppunkProxy) = pw2Secured;
        }
        pw2Trusted->Release();
    }

    // Assert it is now actually secure
    AssertSz(IsThisASecureProxy(*ppunkProxy), "Failed to secure proxy");

    return hr;
}

void COmWindowProxy::DebugHackSecureProxyForOm(COmWindowProxy *pProxy)
{
    // No nesting or anything. hacks don't have to be robust
    Assert(pProxy == NULL || _pSecureProxyForOmHack == NULL);
    _pSecureProxyForOmHack = pProxy;
}

#endif // DBG==1

//----------------------------------------------------------------------------
// Checks if pMarkup can initiate navigation to pchurltarget.  Determines this
// by checking if pchurltarget is in the MyComputer zone and pMarkup is in
// the internet or restricted zone.  If pchurlcontext is provided, that will
// be used instead of pMarkup.
//----------------------------------------------------------------------------
BOOL
COmWindowProxy::CanNavigateToUrlWithLocalMachineCheck(CMarkup *pMarkup, LPCTSTR pchurlcontext,
                                                      LPCTSTR pchurltarget)
{
    // These are secure defaults, don't change unless for a good reason!
    HRESULT hr = E_ACCESSDENIED;
    BOOL bCanNavigate = FALSE;
    DWORD dwZoneIDSource = URLZONE_UNTRUSTED;
    DWORD dwZoneIDTarget = URLZONE_LOCAL_MACHINE;
    LPCTSTR pchurlsource = NULL;
    CMarkup *pWindowedMarkupContext = NULL;
    CDoc *pDoc = pMarkup->Doc();
    extern DWORD g_dwAppCompat;

    // Check the DOCHOSTUI flags.
    if (g_dwAppCompat && !(pDoc->_dwFlagsHostInfo & DOCHOSTUIFLAG_LOCAL_MACHINE_ACCESS_CHECK))
    {
        bCanNavigate = TRUE;
        goto Cleanup;
    }

    // Check the registry option setting.
    if (!pDoc->_pOptionSettings->fLocalMachineCheck)
    {
        bCanNavigate = TRUE;
        goto Cleanup;
    }

    // Get the windowed markup context.
    pWindowedMarkupContext = pMarkup->GetWindowedMarkupContext();
    if (!pWindowedMarkupContext)
    {
        bCanNavigate = FALSE;
        goto Cleanup;
    }

    // Check if this is print media.
    if (pWindowedMarkupContext->IsPrintMedia())
    {
        bCanNavigate = TRUE;
        goto Cleanup;
    }

    // Set the source url, this is the initiator of the navigation.
    pchurlsource = pchurlcontext ? pchurlcontext : pWindowedMarkupContext->Url();
    if (!pchurlcontext && (!pchurlsource  || IsSpecialUrl(pchurlsource)))
    {
        // If the markup is a special url, get the creator url.
        pchurlsource = pWindowedMarkupContext->GetAAcreatorUrl();
    }

    // Get the security manager.
    pWindowedMarkupContext->Doc()->EnsureSecurityManager();
    IInternetSecurityManager *pSecMgr = pWindowedMarkupContext->GetSecurityManager();

    // Get the security zone for the initiating url.
    if (!pchurlsource || IsSpecialUrl(pchurlsource))
    {
        // Treat special urls as restricted.
        dwZoneIDSource = URLZONE_UNTRUSTED;
    }
    else if (!pchurlcontext && pWindowedMarkupContext->HasWindowPending() &&
             pWindowedMarkupContext->GetWindowPending()->Window()->_fRestricted)
    {
        // If there is no urlcontext specified, honor the restricted bit.
        dwZoneIDSource = URLZONE_UNTRUSTED;
    }
    else if (!SUCCEEDED(hr = pSecMgr->MapUrlToZone(pchurlsource, &dwZoneIDSource, 0)))
    {
        // If MapUrlToZone fails, treat the url as restricted.
        dwZoneIDSource = URLZONE_UNTRUSTED;
    }

    // Get the security zone for the target url.

    DWORD   cchWindowUrl = pdlUrlLen;
    TCHAR   achWindowUrl[pdlUrlLen];

    hr = UrlCanonicalize(
            pchurltarget,
            (LPTSTR) achWindowUrl,
            &cchWindowUrl,
            URL_FILE_USE_PATHURL);
    
    if(FAILED(hr) || (!SUCCEEDED(hr = pSecMgr->MapUrlToZone(achWindowUrl, &dwZoneIDTarget, 0))))
    {
        // If MapUrlToZone fails, treat the url as MyComputer.  This is safe.
        dwZoneIDTarget = URLZONE_LOCAL_MACHINE;
    }

    // Check if there is a zone elevation.
    if ((dwZoneIDSource != URLZONE_INTERNET &&
         dwZoneIDSource != URLZONE_UNTRUSTED) ||
        dwZoneIDTarget != URLZONE_LOCAL_MACHINE)
    {
        // There is no zone elevation.
        bCanNavigate = TRUE;
        goto Cleanup;
    }
    else
    {
        // There is zone elevation.
        bCanNavigate = FALSE;
        goto Cleanup;
    }

Cleanup:
    return bCanNavigate;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\selecobj.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       selecobj.cxx
//
//  Contents:   Implementation of the CSelectionObj class.
//
//  Classes:    CSelectionObj
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_SELECOBJ_HXX_
#define X_SELECOBJ_HXX_
#include "selecobj.hxx"
#endif

#ifndef X_CTLRANGE_HXX_
#define X_CTLRANGE_HXX_
#include "ctlrange.hxx"
#endif

#ifndef X_IRANGE_HXX_
#define X_IRANGE_HXX_
#include "irange.hxx"
#endif

#ifndef X_ROOTELEM_HXX
#define X_ROOTELEM_HXX
#include "rootelem.hxx"
#endif

#ifndef X_TPOINTER_HXX_
#define X_TPOINTER_HXX_
#include "tpointer.hxx"
#endif

#define _cxx_
#include "selecobj.hdl"

MtDefine(CSelectionObject, ObjectModel, "CSelectionObject")

extern BOOL g_fInAccess;
extern BOOL g_fInVisualStudio;

const CBase::CLASSDESC CSelectionObject::s_classdesc =
{
    0,                          // _pclsid
    0,                          // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                       // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                       // _pcpi
    0,                          // _dwFlags
    &IID_IHTMLSelectionObject,  // _piidDispinterface
    &s_apHdlDescs,              // _apHdlDesc
};

#define IFC(expr) {hr = THR(expr); if (FAILED(hr)) goto Cleanup;}

//------------------------------------------------------------
//  Member   : CSelectionObject
//
//  Synopsis : Constructor
//
//------------------------------------------------------------

CSelectionObject::CSelectionObject(CDocument * pDocument)
: super(), _pDocument(pDocument)
{
    _pMarkup = _pDocument->Markup();
    _pMarkup->SubAddRef();
    _pDocument->SubAddRef();
}

//------------------------------------------------------------
//  Member   : CSelectionObject
//
//  Synopsis : Destructor:
//       clear out the storage that knows about this Interface.
//
//------------------------------------------------------------

CSelectionObject::~CSelectionObject()
{
    if (_pDocument->_pCSelectionObject == this)
        _pDocument->_pCSelectionObject = NULL;
    _pMarkup->SubRelease();
    _pDocument->SubRelease();
}

//------------------------------------------------------------
//  Member   : PrivateQUeryInterface
//
//------------------------------------------------------------

STDMETHODIMP
CSelectionObject::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    if (iid == IID_IUnknown ||
        iid == IID_IDispatch ||
        iid == IID_IHTMLSelectionObject /*||
        iid == IID_IHTMLSelectionObject2*/ )
    {
        *ppv = (IHTMLSelectionObject *)this;
    }
    else if ( iid == IID_IHTMLSelectionObject2 )
    {
        *ppv = (IHTMLSelectionObject2 *)this;
    }
    else if (iid == IID_IDispatchEx)
    {
        *ppv = (IDispatchEx *)this;
    }
    else if (iid == IID_IObjectIdentity)
    {
        HRESULT hr = CreateTearOffThunk(this,
            (void *)s_apfnIObjectIdentity,
            NULL,
            ppv);
        if (hr)
            RRETURN(hr);
    }
    else
    {
        *ppv = NULL;
        RRETURN(E_NOINTERFACE);
    }

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     SameMarkup
//
//  Synopsis:   Helper function that determines if the segment list has segments
//              in the same markup as our own.
//
//  Arguments:  pIList = INPUT - Segment list to check
//              pfSameMarkup = OUTPUT - Same markup?
//
//  Returns:    HRESULT indicating success
//
//----------------------------------------------------------------------------

HRESULT
CSelectionObject::SameMarkup(BOOL *pfSameMarkup, ISelectionServices *pISelServIn /* = NULL */ )
{
    HRESULT             hr = S_OK;
    CMarkup             *pMarkup = NULL;
    
    Assert( pfSameMarkup );

    *pfSameMarkup = FALSE;

    IFC( _pDocument->Doc()->GetSelectionMarkup(& pMarkup));
    
    // Check that the markups are the same
    if( pMarkup == _pDocument->Markup())
    {
        *pfSameMarkup = TRUE;
    }
    else if( pMarkup && pMarkup->Root()->HasMasterPtr())
    {
        // For INPUT, expose the selection slave markup

        CElement * pElemMaster = pMarkup->Root()->GetMasterPtr();

        if (    pElemMaster->Tag() == ETAG_INPUT
            &&  pElemMaster->GetMarkup() == _pDocument->Markup())
        {
            *pfSameMarkup = TRUE;
        }
    }

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     GetCreateRange
//
//  Synopsis: returns the specified item from the selection.
//              CElementCollection if structural
//              CRange             if text
//              CTable????         if table
//
//  Returns: S_OK if item found and the IDispatch * to the item
//
//----------------------------------------------------------------------------

HRESULT
CSelectionObject::createRange( IDispatch ** ppDisp )
{
    HRESULT                 hr = S_OK;
    IMarkupPointer          *pStart = NULL;
    IMarkupPointer          *pEnd = NULL;
    ISelectionServices      *pSelServ = NULL;
    ISegmentListIterator    *pIter = NULL;
    ISegmentList            *pList = NULL;
    ISegment                *pSegment = NULL;
    IHTMLElement            *pCurElement = NULL;
    CDoc                    *pDoc = _pDocument->Doc();
    BOOL                    fSameMarkup;
    CElement                *pElement =pDoc->_pElemCurrent;
    CMarkup                 *pMarkup = NULL;
    BOOL                    fEmpty = FALSE;
    IHTMLElement            *pIHTMLElement = NULL;
    htmlSelection           htmlSel;
    BOOL                    fIE4CompatControlRange = FALSE;
    IElementSegment         *pIElementSegment = NULL;
    CMarkupPointer          *pStartPointer = NULL;
    CMarkup                 *pTestMarkup = NULL;

    if (! pElement)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // APPCOMPAT (CHANDRAS) : ACCESS CHECK: not to break in MSAccess, access hack is added with if condition below 
    if (!(g_fInAccess || g_fInVisualStudio) && (!_pMarkup || !_pMarkup->AccessAllowed(pElement->GetMarkup())))
    {
	   hr = E_ACCESSDENIED;
      	   goto Cleanup;
    }
        
    // TODO (MohanB) Hack for INPUT's slave markup. Need to figure out
    // how to generalize this.
    if (pElement->Tag() == ETAG_INPUT && pElement->HasSlavePtr())
    {
        pElement = pElement->GetSlavePtr();
        pMarkup = pElement->GetMarkup();
        Assert( pMarkup );
    }
    else
    {
        pMarkup = pElement->GetMarkup();
        Assert( pMarkup );
        pElement = pMarkup->GetElementTop();        
    }

    if ( pDoc->GetHTMLEditor( FALSE ))
    {
        // HACK ALERT! We send this notification so the selection manager will complete any 
        // pending tasks. See bug 103144.
        hr = pDoc->GetHTMLEditor( FALSE )->Notify(EDITOR_NOTIFY_BEGIN_SELECTION_UNDO, NULL, 0);
        if (hr)
            goto Cleanup;

        hr = THR( pDoc->GetSelectionServices( & pSelServ));
        if ( hr )
            goto Cleanup;

        hr = THR( SameMarkup( &fSameMarkup, pSelServ ) );
        if( hr || !fSameMarkup )
        {
            //
            // Not in the same markup, we have an empty
            // selection.
            //
            fEmpty = TRUE;
        }
        else
        {
            hr = THR( pSelServ->QueryInterface(IID_ISegmentList, (void **)&pList ) );
            if ( hr )
                goto Cleanup;

            hr = THR( pList->IsEmpty( &fEmpty ) );
            if ( hr )
                goto Cleanup;
        }
    }
    else
    {
        fEmpty = TRUE;
    }
    
    hr = THR( GetType( & htmlSel, & fIE4CompatControlRange ));
    if ( hr )
        goto Cleanup;
        
    if ( htmlSel == htmlSelectionControl )
    {           
        //
        // Create a control range
        //
        CAutoTxtSiteRange* pControlRange =  new CAutoTxtSiteRange(pElement);

        if (! pControlRange)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        // Put each selected element in to the control range
        if( fEmpty  || fIE4CompatControlRange )
        {
#if DBG == 1        
            //
            // If we didn't have something in the array - then we must be a UI-Active adorned
            // edit context with the caret not visible. So we double-check, and then assume pSelected
            // Element is the EditContext.
            //
            IHTMLEditor* ped = pDoc->GetHTMLEditor(FALSE);
            Assert(ped);
            AssertSz(( fEmpty ||
                       ( ped->IsEditContextUIActive() == S_OK && !pDoc->IsCaretVisible() ) ||
                       pDoc->_pElemCurrent->IsNoScope() ),
                         "Nothing UI-Active - why is selection type control ?" );

#endif            
            //
            // This handles the UI-active case.
            //
            if ( fIE4CompatControlRange )
            {
                pControlRange->AddElement(pDoc->_pElemCurrent);
            }
        }
        else 
        {   
            CElement* pSelectedElement = NULL;

            hr = THR( pDoc->CreateMarkupPointer( & pStart ));
            if ( hr )
                goto Cleanup;

            hr = THR( pDoc->CreateMarkupPointer( & pEnd ));
            if ( hr )
                goto Cleanup;

            hr = THR( pList->CreateIterator( &pIter ) );
            if( hr )
                goto Cleanup;

            while( pIter->IsDone() == S_FALSE )
            {
            
                hr = THR( pIter->Current(&pSegment) );
                if ( hr )
                    goto Cleanup;

                hr = THR( pSegment->QueryInterface( IID_IElementSegment , (void**) & pIElementSegment ));
                if ( hr )
                    goto Cleanup;
                    
                hr = THR( pIElementSegment->GetElement( & pCurElement ));
                if ( hr )
                    goto Cleanup;                

                if ( ! pCurElement)
                {
                    hr = E_FAIL;
                    goto Cleanup;
                }
                
                hr = THR( pCurElement->QueryInterface( CLSID_CElement, (void**) & pSelectedElement ));
                if ( hr )
                    goto Cleanup;

                if ( ! pSelectedElement->GetFirstBranch())
                {
                    AssertSz(0,"Creating a control range on an element not in the Tree");
                    hr = E_FAIL;
                    goto Cleanup;
                }
                
                ClearInterface( &pCurElement );
                ClearInterface( &pSegment);
                ClearInterface( &pIElementSegment);
                Assert( pSelectedElement );
            
                pControlRange->AddElement( pSelectedElement );

                hr = THR( pIter->Advance() );
                if( hr )
                    goto Cleanup;
            }
        }

        hr = THR( pControlRange->QueryInterface(IID_IDispatch, (void **) ppDisp) );
        pControlRange->Release();
        if (hr)
        {
            *ppDisp = NULL;
            goto Cleanup;
        }            
    }
    else
    {

        hr = THR( pDoc->CreateMarkupPointer( & pStart ));
        if ( hr ) 
            goto Cleanup;
        hr = THR( pDoc->CreateMarkupPointer( & pEnd ));
        if ( hr ) 
            goto Cleanup;
            
        if( !fEmpty )
        {
            CMarkupPointer *pStartPointer = NULL;
            
            hr = THR( pList->CreateIterator( &pIter ) );
            if( hr )
                goto Cleanup;
        
            //
            //
            // Set the range pointers
            //

            hr = pIter->Current(&pSegment);
            if ( hr )
                goto Cleanup;
                
            //
            // Set pStart and pEnd using the segment list
            //
            hr = THR( pSegment->GetPointers( pStart, pEnd ));
            if ( hr )
                goto Cleanup;

            //
            // Retrieve the element and markup that owns selection
            //
            hr = THR( pStart->QueryInterface(CLSID_CMarkupPointer, (void **)&pStartPointer) );
            if( FAILED(hr) || !pStartPointer )
                goto Cleanup;

            pMarkup = pStartPointer->Markup();
            pElement = pMarkup->GetElementTop();

            if( !pElement || !pMarkup )
                goto Cleanup;
        }
        else
        {
            //  Bug 88110: There is no selection. If we have a caret, create an empty range
            //  at the caret location.  This is the functionality of IE 5.0.

            if ( pDoc->_pCaret && pDoc->_pCaret->IsPositioned() &&
                 (  pDoc->_pCaret->IsVisible() ||
                   (pDoc->_pInPlace && pDoc->_pInPlace->_pDataObj)) )
            {
                hr = THR( pDoc->_pCaret->MoveMarkupPointerToCaret(pStart) );
                if ( hr )
                    goto Cleanup;
                hr = THR( pDoc->_pCaret->MoveMarkupPointerToCaret(pEnd) );
                if ( hr )
                    goto Cleanup;
        
                // Make sure that the markup for the range is the same as the markup on the element

                hr = THR( pStart->QueryInterface(CLSID_CMarkupPointer, (void **)&pStartPointer) );
                pTestMarkup = pStartPointer->Markup();
                if (pTestMarkup != pMarkup)
                {
                    pElement = pTestMarkup->GetElementTop();
                    pMarkup = pElement->GetMarkup();
                }
            }
            else
            {
                hr = THR_NOTRACE(
                    pElement->QueryInterface( IID_IHTMLElement, (void**) & pIHTMLElement ) );
                Assert( pIHTMLElement );

                hr = THR( pStart->MoveAdjacentToElement( pIHTMLElement, ELEM_ADJ_AfterBegin ) );
                if ( hr )
                    goto Cleanup;
                hr = THR( pEnd->MoveAdjacentToElement( pIHTMLElement, ELEM_ADJ_AfterBegin ) );
                if ( hr )
                    goto Cleanup;
            }
        }

        // Create a Text Range
        //
        hr = THR( pMarkup->createTextRange(
                (IHTMLTxtRange **) ppDisp, pElement, pStart, pEnd, TRUE ) );
        if (hr)
            goto Cleanup;
    }

Cleanup:
    ReleaseInterface( pSelServ );
    ReleaseInterface( pCurElement );
    ReleaseInterface( pIter );
    ReleaseInterface( pList );
    ReleaseInterface( pSegment );
    ReleaseInterface( pStart );
    ReleaseInterface( pEnd );
    ReleaseInterface( pIHTMLElement );
    ReleaseInterface( pIElementSegment );
    RRETURN ( SetErrorInfo(hr) );
}


//+---------------------------------------------------------------------------
//
//  Member:     createRangeCollection
//
//  Synopsis:   returns the current selection.as a range collection
//
//----------------------------------------------------------------------------

HRESULT
CSelectionObject::createRangeCollection( IDispatch ** ppDisp )
{
    HRESULT hr;
    ISelectionServices* pSelServ = NULL;    
    ISegmentList* pSegmentList = NULL;
    ISegmentListIterator    *pIter = NULL; 
    ISegment* pSegment = NULL;
    htmlSelection eSelType;
    CDoc *pDoc = _pDocument->Doc();    
    CElement* pElement = pDoc->_pElemCurrent ;
    IMarkupPointer* pStart = NULL;
    IMarkupPointer* pEnd = NULL;
    IHTMLTxtRange* pITxtRange = NULL;
    CAutoRange* pRange = NULL;
    CMarkup* pMarkup;
    BOOL fSameMarkup=FALSE;
    BOOL fEmpty = FALSE;
    IHTMLElement* pIHTMLElement = NULL;
    
    if (!_pMarkup || !_pMarkup->AccessAllowed(pElement->GetMarkup()))
    {
        hr = E_ACCESSDENIED;
        goto Cleanup;
    }

    IFC(GetType ( &eSelType ));

    if ( eSelType == htmlSelectionControl )
    {
        IFC( createRange( ppDisp ));
    }
    else
    {
        // TODO (MohanB) Hack for INPUT's slave markup. Need to figure out
        // how to generalize this.
        if (pElement->Tag() == ETAG_INPUT && pElement->HasSlavePtr())
        {
            pElement = pElement->GetSlavePtr();
            pMarkup = pElement->GetMarkup();
            Assert(pMarkup);
        }
        else
        {
            pMarkup = pElement->GetMarkup();
            Assert(pMarkup);
            pElement = pMarkup->GetElementTop();        
        }

        if ( pDoc->GetHTMLEditor( FALSE ))
        {
            IFC( pDoc->GetSelectionServices( & pSelServ));

            hr = THR( SameMarkup( &fSameMarkup, pSelServ ) );
            if( hr || !fSameMarkup )
            {
                //
                // Not in the same markup, we have an empty
                // selection.
                //
                fEmpty = TRUE;
            }
            else
            {       
                IFC( pSelServ->QueryInterface(IID_ISegmentList, (void **)&pSegmentList ) );
                IFC( pSegmentList->IsEmpty( &fEmpty ) );
            }
        }
        else
        {
            fEmpty = TRUE;
        }

        CAutoRangeCollection* pRangeColl = new CAutoRangeCollection();
        if(!pRangeColl)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        
        IFC( pDoc->CreateMarkupPointer( & pStart ));
        IFC( pDoc->CreateMarkupPointer( & pEnd ));
        
        if ( ! fEmpty )
        {
            IFC( pSelServ->QueryInterface( IID_ISegmentList, (void**) & pSegmentList ));
            IFC( pSegmentList->CreateIterator( & pIter ));

            while( pIter->IsDone() == S_FALSE )
            {
                IFC( pIter->Current( &pSegment ) );
                IFC( pSegment->GetPointers( pStart, pEnd ));

                //
                // Create a Text Range
                //
                IFC( pMarkup->createTextRange(
                        & pITxtRange, pElement, pStart, pEnd, TRUE ) );

                IFC( pITxtRange->QueryInterface( CLSID_CRange, ( void**) & pRange ));

                pRange->AddRef();
                pRangeColl->AddRange( pRange );
                
                IFC( pIter->Advance() );
                
                ClearInterface( & pITxtRange );
            }
        }
        else
        {
            IFC( pElement->QueryInterface( IID_IHTMLElement, (void**) & pIHTMLElement ) );
            Assert( pIHTMLElement );

            IFC( pStart->MoveAdjacentToElement( pIHTMLElement, ELEM_ADJ_AfterBegin ) );
            IFC( pEnd->MoveAdjacentToElement( pIHTMLElement, ELEM_ADJ_AfterBegin ) );

            //
            // Create a Text Range
            //
            IFC( pMarkup->createTextRange(
                    & pITxtRange, pElement, pStart, pEnd, TRUE ) );

            IFC( pITxtRange->QueryInterface( CLSID_CRange, ( void**) & pRange ));

            pRange->AddRef();
            pRangeColl->AddRange( pRange );
                
        }

        IFC( pRangeColl->QueryInterface( IID_IDispatch, (void**) ppDisp ));
        
    }
    
Cleanup:
    ReleaseInterface( pSelServ );
    ReleaseInterface( pSegmentList );
    ReleaseInterface( pIter );
    ReleaseInterface( pSegment );
    ReleaseInterface( pStart );
    ReleaseInterface( pEnd );
    ReleaseInterface( pIHTMLElement );
    
    RRETURN ( SetErrorInfo(hr ) );
}

//+---------------------------------------------------------------------------
//
//  Member:     get_typeDetail
//
//  Synopsis:   returns the detailed type of the current selection
//
//----------------------------------------------------------------------------

HRESULT
CSelectionObject::get_typeDetail(BSTR * pbstrTypeDetail )
{
    HRESULT hr = S_OK ;
    ISelectionServices* pSelServ = NULL;
    ISelectionServicesListener* pSelServListener = NULL;
    CDoc *pDoc = _pDocument->Doc();    

    if (!pbstrTypeDetail)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    IFC( pDoc->GetSelectionServices(& pSelServ ));

    hr = THR( pSelServ->GetSelectionServicesListener( & pSelServListener ));
    if ( FAILED( hr ))
    {
        *pbstrTypeDetail = SysAllocString(_T("undefined"));
        goto Cleanup;
    }        

    if ( pSelServListener )
    {
        IFC( pSelServListener->GetTypeDetail( pbstrTypeDetail ));
    }
    else
    {
        *pbstrTypeDetail = SysAllocString(_T("undefined"));
    }
    
Cleanup:
    ReleaseInterface( pSelServ );
    ReleaseInterface( pSelServListener );
    
    RRETURN (SetErrorInfo(hr));
}

//+---------------------------------------------------------------------------
//
//  Member:     Gettype
//
//  Synopsis: returns, on the parameter, the enumerated value indicating the type
//              of the selection (htmlSelectionText, htmlSelectionTable,
//              htmlSelectionStructure)
//
//  Returns: S_OK if properly executes
//
//----------------------------------------------------------------------------

HRESULT
CSelectionObject::get_type( BSTR *pbstrSelType )
{
    HRESULT hr;
    htmlSelection eSelType;

    if (!pbstrSelType )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR(GetType ( &eSelType ));
    if ( hr )
        goto Cleanup;

    hr = THR( STRINGFROMENUM ( htmlSelection, (long)eSelType, pbstrSelType ) );

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CSelectionObject::GetType( htmlSelection *pSelType , BOOL* pfIE4CompatControlRange )
{
    HRESULT             hr = S_FALSE;
    ISelectionServices  *pSelServ = NULL;
    ISegmentList        *pList = NULL;
    SELECTION_TYPE      eType = SELECTION_TYPE_None;
    
    BOOL                bSameMarkup;
    CDoc                *pDoc = _pDocument->Doc();

    CElement *  pElement    = pDoc->_pElemCurrent;
    CMarkup *   pMarkup;
    
    if ( pfIE4CompatControlRange )                         
        *pfIE4CompatControlRange = FALSE;
        
    // TODO (MohanB) Hack for INPUT's slave markup. Need to figure out
    // how to generalize this.
    if (pElement->Tag() == ETAG_INPUT && pElement->HasSlavePtr())
    {
        pElement = pElement->GetSlavePtr();
    }
    pMarkup = pElement->GetMarkup();

    if ( pDoc->GetHTMLEditor( FALSE )) 
    {
        hr = THR( pDoc->GetSelectionServices(& pSelServ ));
        if ( hr )
            goto Cleanup;

        //
        // Check to make sure the segment list is 
        // on the same markup as we are
        //
        hr = THR( SameMarkup( &bSameMarkup, pSelServ ) );
        if( hr || !bSameMarkup )
        {
            *pSelType = htmlSelectionNone;
            goto Cleanup;
        }

        hr = THR( pSelServ->QueryInterface(IID_ISegmentList, (void **)&pList ) );
        if ( hr )
            goto Cleanup;
           
        hr = THR( pList->GetType( &eType ));
        if ( hr )
            goto Cleanup;
    }
    else
    {
        eType = SELECTION_TYPE_None; // if we don't have an editor - how can we have a selection ?
        hr = S_OK;
    }
    
    switch( eType )
    {
        case SELECTION_TYPE_Control:
            *pSelType = htmlSelectionControl;
            break;

        case SELECTION_TYPE_Text:
            *pSelType = htmlSelectionText;
            break;

        //
        // A Caret should return a Selection of 'None', for IE 4.01 Compat
        //
        default:  
            //
            // We return 'none' - unless we're a UI-Active ActiveX Control
            // with an invisible caret - in which case we return "control"
            // for IE 4 compat.
                        
            *pSelType = htmlSelectionNone;

            IHTMLEditor* ped = pDoc->GetHTMLEditor(FALSE);
            if ( ped )
            {
                if ( pDoc->_pElemCurrent && ped->IsEditContextUIActive() == S_OK )
                {
                    *pSelType = ( !pDoc->IsCaretVisible() ) || 
                                  pDoc->_pElemCurrent->IsNoScope() ? 
                                    htmlSelectionControl : htmlSelectionNone;

                    if ( ( *pSelType == htmlSelectionControl ) && pfIE4CompatControlRange )
                    {
                        *pfIE4CompatControlRange = TRUE;
                    }
                }
            }
    }

Cleanup:
    ReleaseInterface( pSelServ );
    ReleaseInterface( pList );

    RRETURN(hr);
}




//+---------------------------------------------------------------------------
//
//  Member:     clear
//
//  Synopsis: clears the selection and sets the selction type to NONE
//              this is spec'd to behave the same as edit.clear
//
//  Returns: S_OK if executes properly.
//
//----------------------------------------------------------------------------

HRESULT
CSelectionObject::clear()
{
    HRESULT hr;
    BOOL    bSameMarkup;

    //
    // Check to make sure the segment list is 
    // on the same markup as we are
    //
    hr = THR( SameMarkup( &bSameMarkup ) );
    if( FAILED(hr) || !bSameMarkup )
    {
        hr = S_OK;
        goto Cleanup;
    }

    hr  =   _pDocument->Doc()->ExecHelper(
            _pDocument,
            (GUID *) &CGID_MSHTML,
            IDM_DELETE,
            0,
            NULL,
            NULL);
Cleanup:

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:   empty
//
//  Synopsis: Nulls the selection and sets the selction type to NONE
//
//  Returns: S_OK if executes properly.
//
//----------------------------------------------------------------------------

HRESULT
CSelectionObject::empty()
{
    HRESULT hr;
    BOOL    bSameMarkup;
      
    hr = THR( SameMarkup( &bSameMarkup ) );
    if( FAILED(hr) || !bSameMarkup )
    {
        hr = S_OK;
        goto Cleanup;
    }

    hr = THR( _pDocument->Doc()->EmptySelection() );
    if( FAILED(hr) )
        goto Cleanup;

Cleanup:

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\sholder.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       sholder.cxx
//
//  Contents:   Implementation of CScriptHolder class
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_SCRIPT_HXX_
#define X_SCRIPT_HXX_
#include "script.hxx"
#endif

#ifndef X_SHOLDER_HXX_
#define X_SHOLDER_HXX_
#include "sholder.hxx"
#endif

#ifndef X_DEBUGGER_HXX_
#define X_DEBUGGER_HXX_
#include "debugger.hxx"
#endif

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx"
#endif

#ifndef X_COLLECT_HXX_
#define X_COLLECT_HXX_
#include "collect.hxx"
#endif

#ifndef X_OTHRGUID_H_
#define X_OTHRGUID_H_
#include "othrguid.h"
#endif

#ifndef X_OPTSHOLD_HXX_
#define X_OPTSHOLD_HXX_
#include "optshold.hxx"
#endif

#ifndef X_CLIENT_HXX_
#define X_CLIENT_HXX_
#include "client.hxx"
#endif

const CLSID CLSID_JScript  = {0xF414C260, 0x6AC0, 0x11CF, 0xB6, 0xD1, 0x00, 0xAA, 0x00, 0xBB, 0xBB, 0x58};

EXTERN_C const IID IID_IHTMLDialog;

BOOL IsSpecialUrl(LPCTSTR pszURL);

#ifndef NO_SCRIPT_DEBUGGER
extern interface IProcessDebugManager * g_pPDM;
extern interface IDebugApplication *g_pDebugApp;
#endif // ndef NO_SCRIPT_DEBUGGER

MtDefine(CScriptHolder, ObjectModel, "CScriptHolder")
MtDefine(CScriptHolder_pclsid, CScriptHolder, "CScriptHolder::_pclsid")
DeclareTag(tagScriptSite, "Script Holder", "Script Holder methods")
ExternTag(tagDisableLockAR);
ExternTag(tagSecureScriptWindow);


CScriptHolder::CLock::CLock(CScriptHolder *pHolder, WORD wLockFlags)
{
    _pHolder = pHolder;
    _wLock = pHolder->_wLockFlags;
#if DBG==1
    if (!IsTagEnabled(tagDisableLockAR))
#endif
    {
        _pHolder->AddRef();
    }
    
    pHolder->_wLockFlags |= wLockFlags;
}


CScriptHolder::CLock::~CLock()
{
    _pHolder->_wLockFlags = _wLock;
#if DBG==1
    if (!IsTagEnabled(tagDisableLockAR))
#endif
    {
        _pHolder->Release();
    }
}


//---------------------------------------------------------------------------
//
//  Method:     CScriptHolder::CScriptHolder
//
//  Synopsis:   ctor
//
//---------------------------------------------------------------------------

CScriptHolder::CScriptHolder(CScriptCollection *pCollection)
{
    _ulRefs = 1;
    _pCollection = pCollection;
    _pScript = NULL;
    _pScriptParse = NULL;
    _pParseProcedure = NULL;
    _pclsid = NULL;
    _pUnkItem = NULL;
    _fCaseSensitive = FALSE;
    _fErrorHandlerSet = FALSE;
    _fOriginal = FALSE;
    _fClone = FALSE;
    _wLockFlags = 0;
}


//---------------------------------------------------------------------------
//
//  Method:     CScriptHolder::~CScriptHolder
//
//  Synopsis:   dtor
//
//---------------------------------------------------------------------------

CScriptHolder::~CScriptHolder()
{
    IGNORE_HR(Close());
}


//---------------------------------------------------------------------------
//
//  Method:     CScriptHolder::Close
//
//  Synopsis:   Close the script and clear interfaces to it.
//
//---------------------------------------------------------------------------

HRESULT
CScriptHolder::Close()
{
    TraceTag((tagScriptSite, "Close"));

    HRESULT hr = S_OK;

    ClearInterface(&_pParseProcedure);
    ClearInterface(&_pScriptParse);
    ClearInterface(&_pUnkItem);
    
    delete _pclsid;
    _pclsid = NULL;

    if (_pScript)
    {
        hr = THR(_pScript->Close());
    }

    ClearInterface(&_pScript);
    _pCollection = NULL;
    RRETURN(hr);
}

//---------------------------------------------------------------------------
//
//  Method:     CScriptHolder::IllegalCall
//
//  Synopsis:   Return TRUE/FALSE if this method call is legal.
//
//---------------------------------------------------------------------------

BOOL
CScriptHolder::IllegalCall()
{
    if (!_pCollection || !_pCollection->Doc())
        return TRUE;
        
    if (_pCollection->Doc()->_dwTID != GetCurrentThreadId())
    {
        Assert(0 && "Script site called across apartment thread boundary (not an MSHTML bug)");
        return TRUE;
    }

    return FALSE;
}


//---------------------------------------------------------------------------
//
//  Method:     CScriptHolder::QueryInterface
//
//  Synopsis:   per IUnknown
//
//---------------------------------------------------------------------------

STDMETHODIMP
CScriptHolder::QueryInterface(REFIID iid, LPVOID * ppv)
{
    if (IllegalCall())
        RRETURN(E_NOINTERFACE);
        
    if (iid == IID_IActiveScriptSite ||
        iid == IID_IUnknown)
    {
        *ppv = (IActiveScriptSite *) this;
    }
    else if (iid == IID_IActiveScriptSiteWindow)
    {
        *ppv = (IActiveScriptSiteWindow *) this;
    }
    else if (iid == IID_IServiceProvider)
    {
        *ppv = (IServiceProvider *)this;
    }
#ifndef NO_SCRIPT_DEBUGGER
    else if (iid == IID_IActiveScriptSiteDebug)
    {
        *ppv = (IActiveScriptSiteDebug *)this;
    }
#endif
    else if (iid == IID_IOleCommandTarget)
    {
        *ppv = (IOleCommandTarget *)this;
    }
    else if (iid == IID_IActiveScriptSiteInterruptPoll)
    {
        *ppv = (IActiveScriptSiteInterruptPoll *)this;
    }
    else
    {
        *ppv = NULL;
        RRETURN(E_NOINTERFACE);
    }

    AddRef();
    return S_OK;
}


//---------------------------------------------------------------------------
//
//  Method:     CScriptHolder::AddRef
//
//  Synopsis:   per IUnknown
//
//---------------------------------------------------------------------------

ULONG
CScriptHolder::AddRef()
{
    _ulRefs += 1;
    return _ulRefs;
}


//---------------------------------------------------------------------------
//
//  Method:     CScriptHolder::Release
//
//  Synopsis:   per IUnknown
//
//---------------------------------------------------------------------------

ULONG
CScriptHolder::Release()
{
    if (--_ulRefs == 0)
    {
        _ulRefs = ULREF_IN_DESTRUCTOR;
        delete this;
        return 0;
    }

    return _ulRefs;
}

// TODO: ***TLL*** #define needs to go when new script engine and activscp.idl.
#define SCRIPTPROP_CONVERSIONLCID        0x00001002

void CScriptHolder::TurnOnFastSinking ()
{
    IActiveScriptProperty *pprop;

    Assert(_pScript);

    if (SUCCEEDED(_pScript->QueryInterface(IID_IActiveScriptProperty, (void **)&pprop)))
    {
        CVariant varValue(VT_BOOL);

        V_BOOL(&varValue) = VARIANT_TRUE;

        pprop->SetProperty(SCRIPTPROP_HACK_TRIDENTEVENTSINK, NULL, &varValue);

        pprop->Release();
    }
}


void CScriptHolder::SetConvertionLocaleToENU()
{
    IActiveScriptProperty *pprop;

    Assert(_pScript);

    if (SUCCEEDED(_pScript->QueryInterface(IID_IActiveScriptProperty, (void **)&pprop)))
    {
        CVariant varLocale(VT_I4);

        V_I4(&varLocale) = 0x409;       // English ENU

        // Turn on ENU for script locale.
        pprop->SetProperty(SCRIPTPROP_CONVERSIONLCID, NULL, &varLocale);

        pprop->Release();
    }
}

HRESULT
CScriptHolder::Clone(CLSID *pclsid, CScriptHolder *pHolderTarget)
{
    HRESULT hr;
    Assert(pHolderTarget && _pScript && _pScriptParse && _fOriginal);
    Assert(!pHolderTarget->_pScript && !pHolderTarget->_pScriptParse && !pHolderTarget->_pParseProcedure);
    Assert(!pHolderTarget->_fOriginal && !pHolderTarget->_fClone);

    hr = THR(_pScript->Clone(&pHolderTarget->_pScript));
    if (hr)
        goto Cleanup;

    hr = THR(pHolderTarget->_pScript->QueryInterface(IID_IActiveScriptParse, (void **)&pHolderTarget->_pScriptParse));
    if (hr)
        goto Cleanup;

    Assert(_pCollection);
    // (sramani) Need to explicity call SE to fill security info as it is not automatically cloned. This is
    // a workaround (albeit costly) until the SE is fixed.
    if (!_pCollection->IsSafeToRunScripts(pclsid, pHolderTarget->_pScript, FALSE))
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // If cloned script engine supports fast sinking (uses ITridentEventSink) then tell
    // the cloned script engine we support it.
    pHolderTarget->TurnOnFastSinking();

    // if the QI fails that means that the script engine does not support the new IASPP code construction
    if (THR_NOTRACE(pHolderTarget->_pScript->QueryInterface(IID_IActiveScriptParseProcedure2, (void**)&pHolderTarget->_pParseProcedure)))
    {
        // Try the old IASPP IID for old engines that haven't been re-compiled.
        hr = THR(pHolderTarget->_pScript->QueryInterface(IID_IActiveScriptParseProcedure, (void**)&pHolderTarget->_pParseProcedure));
        if (hr)
            goto Cleanup;
    }

    pHolderTarget->_fCaseSensitive = _fCaseSensitive;
    pHolderTarget->_fClone = TRUE;

    hr = THR(pHolderTarget->_pScript->SetScriptSite(pHolderTarget));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(hr);
}

//---------------------------------------------------------------------------
//
//  Method:     CScriptHolder::Init
//
//  Synopsis:   Second phase of construction.
//
//---------------------------------------------------------------------------

HRESULT
CScriptHolder::Init(
        BOOL fCaseSensitive,
        IActiveScript *pScript,
        IActiveScriptParse *pScriptParse,
        CLSID *pclsid,
        LPTSTR pchNameSpace)
{
    TraceTag((tagScriptSite, "Init"));

    HRESULT                         hr;
    long                            c;
    CNamedItem **                   ppNamedItem;
    SCRIPTSTATE                     ss = SCRIPTSTATE_STARTED;

    ReplaceInterface(&_pScript, pScript);
    ReplaceInterface(&_pScriptParse, pScriptParse);

    if (pclsid)
    {
        _pclsid = new(Mt(CScriptHolder_pclsid)) CLSID;
        *_pclsid = *pclsid;
    }

    // NOTE (alexz) - we need some generic protocol allowing us to ask script engine
    // about it's case-sensitivity.
    _fCaseSensitive = fCaseSensitive;

    // If script engine supports fast sinking (uses ITridentEventSink) then tell
    // the script engine we support it.
    TurnOnFastSinking();

    if (_pScriptParse)
    {
        hr = THR(_pScriptParse->InitNew());
        if (hr)
            goto Cleanup;
    }
    
    hr = THR(_pScript->SetScriptSite(this));
    if (hr)
        goto Cleanup;

    // Need to set conversion locale after call to SetScriptSite, as LCID is over-written
    // in a callback to GetLCID. (IE5 Bug# 83217)
    // 
    // Removing call to SetConvertionLocaleToENU()  (IE5 Bug 86509)
    //
    // SetConvertionLocaleToENU();

    // we check the state of the scriptengine first, there are objects out there
    // who connect during their download time (HTMLLAYOUT)
    hr = THR(_pScript->GetScriptState(&ss));
    if (hr)
    {
        if (E_NOTIMPL != hr)
            goto Cleanup;

        ss = SCRIPTSTATE_UNINITIALIZED;
        hr = S_OK;
    }

    if (ss == SCRIPTSTATE_INITIALIZED || ss == SCRIPTSTATE_UNINITIALIZED)
    {
        // This is a requirement for gets VBScript/JScript into a runnable state.

#ifdef NEVER
        //
        // Not used anymore because we won't treat solstice as a 
        // script engine due to security problems.
        //
        
        // BAD BETA 1 Bugfix for 24019
        // GaryBu and frankman decided to use the same for BETA2 due to simplicity reasons
        // we should change this to compat flags in case we have to do anything else
        // for the layoutcontrol
        if (!IsEqualCLSID(*pclsid, CLSID_IISForm))
#endif
        {
            // we ignore the error because some script engines might not support this operation
            // (e.g. java vm 2057.1+), yet we still want to finish creating script holder for them
            IGNORE_HR(_pScript->SetScriptState(SCRIPTSTATE_STARTED));
        }
    }

    //
    // Add the window as a global named item.
    //
    
    hr = THR(_pScript->AddNamedItem(
        DEFAULT_OM_SCOPE,
        SCRIPTITEM_ISVISIBLE | SCRIPTITEM_ISSOURCE | SCRIPTITEM_GLOBALMEMBERS | (_fOriginal ? SCRIPTITEM_ISPERSISTENT : 0)));
    if (S_OK == hr)
    {
        //
        // So the script engine supports operation AddNamedItem.
        //
        // Now add any existing forms also as named items.
        //

        if (!pchNameSpace)
        {
            for (c = _pCollection->_NamedItemsTable.Size(), 
                    ppNamedItem = _pCollection->_NamedItemsTable;
                 c > 0; 
                 c--, ppNamedItem++)
            {
                // Fixing bug 37010
                // fScriptItemVisible is FALSE only for "MCSE Readiness Review Exam xx-xxx" hta applications
                BOOL fScriptItemVisible = TRUE;
                if (_pCollection->Doc()->_fHostedInHTA && (*ppNamedItem)->_pUnkItem)
                {
                    CElement* pElem = NULL;
                    HRESULT hr2 = THR((*ppNamedItem)->_pUnkItem->QueryInterface(CLSID_CElement, (void**)&pElem));
                    if (hr2 == S_OK && pElem && pElem->Tag() == ETAG_FORM)
                    {
                        if (_pCollection->Doc()->_pClientSite)
                        {
                            char szModule[MAX_PATH];
                            GetModuleFileNameA(NULL, szModule, MAX_PATH);
                            if (StrStrIA(szModule, "mshta.exe"))
                            {
                                CClient* pClient = (CClient*)(_pCollection->Doc()->_pClientSite);
                                LPCTSTR pchAppName = pClient->GetAppName();
                                if (pchAppName && !StrCmpN(pchAppName, _T("MCSE"), 4))
                                    fScriptItemVisible = FALSE;
                            }
                        }
                    }
                }
                    
                hr = THR(_pScript->AddNamedItem(
                        (*ppNamedItem)->_cstrName,
                        SCRIPTITEM_ISSOURCE | (fScriptItemVisible ? SCRIPTITEM_ISVISIBLE : 0)));
                if (hr)
                    goto Cleanup;
            }
        }
        else
        {
            Assert(_fOriginal);
            hr = THR(_pScript->AddNamedItem(pchNameSpace, SCRIPTITEM_ISVISIBLE | SCRIPTITEM_ISSOURCE | SCRIPTITEM_ISPERSISTENT));
            if (hr)
                goto Cleanup;
        }
    }
    else
    {
        Assert (hr);
        if (E_NOTIMPL == hr)
        {
            // we ignore the error because some script engines might not support this operation
            // (e.g. java vm 2057.1+), yet we still want to finish creating script holder for them
            hr = S_OK;
        }
        else
            goto Cleanup;
    }


    //
    // cache _pParseProcedure
    //

    Assert (!_pParseProcedure);

    // if the QI fails that means that the script engine does not support the new IASPP code construction
    if (THR_NOTRACE(_pScript->QueryInterface(
        IID_IActiveScriptParseProcedure2, 
        (void**)&_pParseProcedure)))
    {
        // Try the old IASPP IID for old engines that haven't been re-compiled.
        THR_NOTRACE(_pScript->QueryInterface(
            IID_IActiveScriptParseProcedure, 
            (void**)&_pParseProcedure));
    }

Cleanup:
    RRETURN(hr);
}


//---------------------------------------------------------------------------
//
//  Method:     CScriptHolder::SetScriptState
//
//  Synopsis:   Set the script to some state using enum SCRIPTSTATE
//
//---------------------------------------------------------------------------

HRESULT
CScriptHolder::SetScriptState(SCRIPTSTATE ss)
{
    TraceTag((tagScriptSite, "SetScriptState"));

    HRESULT hr = S_OK;
    
    if (!_pScript)
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    hr = THR(_pScript->SetScriptState(ss));
    if (E_NOTIMPL == hr)
    {
        hr = S_OK;
    }

    // script engines which do not support IActiveScriptParseProcedure (as indicated by
    // condition (!_pParseProcedure)) might rely on actions (AddScriptlet calls) done in 
    // BuildObjectTypeInfo, so for them we ensure ObjectTypeInfo
    if (!_pParseProcedure && SCRIPTSTATE_CONNECTED == ss)
    {
        hr = THR(_pCollection->Doc()->EnsureObjectTypeInfo());
    }

Cleanup:
    RRETURN(hr);
}


//---------------------------------------------------------------------------
//
//  Method:     CScriptHolder::GetLCID
//
//  Synopsis:   per IActiveScriptSite
//
//  Arguments:  plcid       Returned locale info
//
//---------------------------------------------------------------------------

HRESULT
CScriptHolder::GetLCID(LCID *plcid)
{
    TraceTag((tagScriptSite, "GetLCID"));

    if (IllegalCall())
        RRETURN(E_UNEXPECTED);
        
    // Return the user locale ID, this make VBS locale sensitive and means
    // that VBS pages can not be written to be locale neutral (a page cannot
    // be written to run on different locales).  Only JScript can do this. 
    // However, VBS can be written for Intra-net style apps where functions
    // like string comparisons, UCase, LCase, etc. are used.  Also, some
    // pages could be written in both VBS and JS.  Where JS has the locale 
    // neutral things like floating point numbers, etc.
    *plcid = g_lcidLocalUserDefault;

    return S_OK;
}


//---------------------------------------------------------------------------
//
//  Method:     CScriptHolder::GetItemInfo
//
//  Synopsis:   per IActiveScriptSite
//
//  Arguments:  pstrName        Name to get info of
//              dwReturnMask    Mask for which item are needed
//              ppunkItemOut    IUnknown for item returned
//              pptinfoOut      ITypeInfo for item returned
//
//---------------------------------------------------------------------------

HRESULT
CScriptHolder::GetItemInfo(
      LPCOLESTR   pchName,
      DWORD       dwReturnMask,
      IUnknown**  ppunkItemOut,
      ITypeInfo** pptinfoOut)
{
    TraceTag((tagScriptSite, "GetItemInfo"));

    if (IllegalCall())
        RRETURN(E_UNEXPECTED);
        
    HRESULT         hr = S_OK;
    IUnknown *      pUnkItem = NULL;
    IDispatch *     pDispItem = NULL;

    //
    // validation
    //

    if (!_pCollection)
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    if (dwReturnMask & SCRIPTINFO_ITYPEINFO)
    {
        if (!pptinfoOut)
        {
            hr = E_POINTER;
            goto Cleanup;
        }
        *pptinfoOut = NULL;
    }

    if (dwReturnMask & SCRIPTINFO_IUNKNOWN)
    {
        if (!ppunkItemOut)
        {
            hr = E_POINTER;
            goto Cleanup;
        }
        *ppunkItemOut = NULL;
    }


    //
    // find the item
    //

    if (StrCmpIC(DEFAULT_OM_SCOPE, pchName) == 0)
    {
        //
        // If we have a pending markup and we will need to change the security thunk later for that
        // markup during the SwitchMarkup, create and hold on to the new thunk here. 
        //
        CWindow * pWindow  = _pCollection->_pOmWindowProxy->Window();

        if (pWindow->_pMarkupPending && 
            !pWindow->_pMarkupPending->AccessAllowed(pWindow->Markup()))
        {

            hr = _pCollection->_pOmWindowProxy->GetSecurityThunk((LPVOID *)&pDispItem, TRUE);
            if (hr)
                goto Cleanup;

            // complete the QI call functionality by addrefing the pointer.
            pDispItem->AddRef();
        }
        else
        {
            // just use the existing window proxy's IDispatch tearoff thunk.
            hr = THR(_pCollection->_pOmWindowProxy->QueryInterface(IID_IDispatch, (void **) &pDispItem));
            if (hr)
                goto Cleanup;
        }

#if DBG==1
    if (IsTagEnabled(tagSecureScriptWindow) && _pCollection->_pOmWindowProxy->_fTrusted)
    {
        // use secure proxy instead
        pDispItem->Release();
        hr = THR(_pCollection->_pSecureWindowProxy->QueryInterface(IID_IDispatch, (void **) &pDispItem));
        if (hr)
            goto Cleanup;
    }
#endif

        pUnkItem = pDispItem;
        pUnkItem->AddRef();
    }
    else if (_fClone || _fOriginal)
    {
        Assert(_pUnkItem);
        pUnkItem = _pUnkItem;
        pUnkItem->AddRef();

        if (dwReturnMask & SCRIPTINFO_ITYPEINFO)
        {
            hr = THR(pUnkItem->QueryInterface(IID_IDispatch, (void**)&pDispItem));
            if (hr)
                goto Cleanup;
        }
    }
    else
    {
        Assert(!_pUnkItem);
        hr = THR(_pCollection->_NamedItemsTable.GetItem((LPTSTR)pchName, &pUnkItem));
        if (hr)
            goto Cleanup;

        if (dwReturnMask & SCRIPTINFO_ITYPEINFO)
        {
            hr = THR(pUnkItem->QueryInterface(IID_IDispatch, (void**)&pDispItem));
            if (hr)
                goto Cleanup;
        }
    }

    //
    // get the info
    //

    if (dwReturnMask & SCRIPTINFO_IUNKNOWN)
    {
        *ppunkItemOut = pUnkItem;
        (*ppunkItemOut)->AddRef();
    }

    if (dwReturnMask & SCRIPTINFO_ITYPEINFO)
    {
        hr = THR(pDispItem->GetTypeInfo(
            0,
            LOCALE_SYSTEM_DEFAULT,
            pptinfoOut));
        if (hr)
            goto Cleanup;
    }
    
Cleanup:
    ReleaseInterface(pUnkItem);
    ReleaseInterface(pDispItem);
    RRETURN(hr);
}


//---------------------------------------------------------------------------
//
//  Method:     CScriptHolder::GetDocVersionString
//
//  Synopsis:   per IActiveScriptSite
//
//  Arguments:  pbstrVersion    Returned version string
//
//---------------------------------------------------------------------------

HRESULT
CScriptHolder::GetDocVersionString(BSTR *pbstrVersion)
{
    TraceTag((tagScriptSite, "GetDocVersionString"));

    if (IllegalCall())
        RRETURN(E_UNEXPECTED);
        
    // TODO need to return empty stirng?
    return E_NOTIMPL;
}


//---------------------------------------------------------------------------
//
//  Method:     CScriptHolder::RequestItems
//
//  Synopsis:   per IActiveScriptSite
//
//---------------------------------------------------------------------------

HRESULT
CScriptHolder::RequestItems()
{
    TraceTag((tagScriptSite, "RequestItems"));

    if (IllegalCall())
        RRETURN(E_UNEXPECTED);
        
    if (!_pCollection)
        RRETURN(E_UNEXPECTED);

    // TODO add named items
    return E_NOTIMPL;
}


//---------------------------------------------------------------------------
//
//  Method:     CScriptHolder::RequestTypeLibs
//
//  Synopsis:   per IActiveScriptSite
//
//---------------------------------------------------------------------------

HRESULT
CScriptHolder::RequestTypeLibs()
{
    TraceTag((tagScriptSite, "RequestTypeLibs"));

    if (IllegalCall())
        RRETURN(E_UNEXPECTED);
        
    if (!_pCollection)
        RRETURN(E_UNEXPECTED);

    // TODO add type library
    return E_NOTIMPL;
}


//---------------------------------------------------------------------------
//
//  Method:     CScriptHolder::OnScriptTerminate
//
//  Synopsis:   per IActiveScriptSite
//
//  Arguments:  pvarResult      Resultant variant
//              pexcepinfo      Exception info for errors
//
//---------------------------------------------------------------------------

HRESULT
CScriptHolder::OnScriptTerminate(
    const VARIANT *pvarResult,
    const EXCEPINFO *pexcepinfo)
{
    TraceTag((tagScriptSite, "OnScriptTerminate"));

    if (IllegalCall())
        RRETURN(E_UNEXPECTED);
        
    if (!_pCollection)
        RRETURN(E_UNEXPECTED);

    // TODO what should we do?
    return S_OK;
}


//---------------------------------------------------------------------------
//
//  Method:     CScriptHolder::OnStateChange
//
//  Synopsis:   per IActiveScriptSite
//
//  Arguments:  ssScriptState   New state of script
//
//---------------------------------------------------------------------------

HRESULT
CScriptHolder::OnStateChange(SCRIPTSTATE ssScriptState)
{
    TraceTag((tagScriptSite, "OnStateChange"));

    if (IllegalCall())
        RRETURN(E_UNEXPECTED);
        
    if (!_pCollection)
        RRETURN(E_UNEXPECTED);

    // TODO what should we do?
    return S_OK;
}

BOOL OutLook98HackReqd(CMarkup * pMarkup, ULONG uLine, ULONG uCol)
{
    if (((36 == uLine) && (35 == uCol) || 
         (51 == uLine) && (28 == uCol)) && 
        !_tcsicmp( (TCHAR *)CMarkup::GetUrl(pMarkup), _T("outday://")))
        return TRUE;

    return FALSE;
}

//---------------------------------------------------------------------------
//
//  Method:     CScriptHolder::OnScriptError
//
//  Synopsis:   per IActiveScriptSite
//
//  Arguments:  pScriptError    Error info interface
//
//---------------------------------------------------------------------------

HRESULT
CScriptHolder::OnScriptError(IActiveScriptError *pScriptError)
{
    TraceTag((tagScriptSite, "OnScriptError"));

    if (IllegalCall())
        RRETURN(E_UNEXPECTED);
        
    HRESULT          hr = S_OK;
    ErrorRecord      errRecord;

    if (!_pCollection || (g_pHtmPerfCtl && (g_pHtmPerfCtl->dwFlags & HTMPF_DISABLE_ALERTS)))
        RRETURN(E_UNEXPECTED);

    if (TestLock(SCRIPTLOCK_SCRIPTERROR))
        goto Cleanup;

    {
        CLock   Lock(this, SCRIPTLOCK_SCRIPTERROR);

        COmWindowProxy *    pWndProxy = _pCollection->_pOmWindowProxy;
        CMarkup *           pMarkup = pWndProxy->Markup();

        Assert(!!CMarkup::GetUrl(pMarkup));

        hr = errRecord.Init(pScriptError, pWndProxy);
        if (hr)
            goto Cleanup;

        // HACK fix for IE5 bug# 58568
        if (OutLook98HackReqd(pMarkup, errRecord._uLine, errRecord._uColumn))
            goto Cleanup;

#ifndef NO_SCRIPT_DEBUGGER
        if (!_fErrorHandlerSet && errRecord._pScriptDebugDocument)
        {
            BOOL        fEnterDebugger;

            hr = THR(DoYouWishToDebug(pScriptError, &fEnterDebugger));
            if (hr)
                goto Cleanup;

            if (fEnterDebugger)
            {
                hr = THR(errRecord._pScriptDebugDocument->ViewSourceInDebugger(
                    errRecord._uLine - 1, errRecord._uColumn));
            }

            goto Cleanup; // done
        }
#endif // NO_SCRIPT_DEBUGGER

        if (!TestLock(SCRIPTLOCK_FIREONERROR))
        {
            CLock   Lock(this, SCRIPTLOCK_FIREONERROR);

            hr = pMarkup->ReportScriptError(errRecord);
        }
    }
    
Cleanup:
    RRETURN(hr);
}


//---------------------------------------------------------------------------
//
//  Method:     CScriptHolder::OnEnterScript
//
//  Synopsis:   per IActiveScriptSite
//
//---------------------------------------------------------------------------

HRESULT
CScriptHolder::OnEnterScript()
{
    HRESULT hr;

    TraceTag((tagScriptSite, "OnEnterScript"));

    if (IllegalCall())
        RRETURN(E_UNEXPECTED);
        
    if (!_pCollection)
        RRETURN(E_UNEXPECTED);

#ifndef NO_SCRIPT_DEBUGGER
    if (_pCollection->_pCurrentDebugDocument)
    {
        IGNORE_HR(_pCollection->_pCurrentDebugDocument->UpdateDocumentSize());
    }
#endif

    Assert(_pCollection->_pOmWindowProxy);
    Assert(_pCollection->_pOmWindowProxy->Window());
    hr = THR(_pCollection->_pOmWindowProxy->Window()->EnterScript());

    RRETURN(hr);
}


//---------------------------------------------------------------------------
//
//  Method:     CScriptHolder::OnLeaveScript
//
//  Synopsis:   per IActiveScriptSite
//
//  Arguments:  plcid       Returned locale info
//
//---------------------------------------------------------------------------

HRESULT
CScriptHolder::OnLeaveScript()
{
    TraceTag((tagScriptSite, "OnLeaveScript"));

    if (IllegalCall())
        RRETURN(E_UNEXPECTED);
        
    if (!_pCollection)
        RRETURN(E_UNEXPECTED);

    Assert(_pCollection->_pOmWindowProxy);
    Assert(_pCollection->_pOmWindowProxy->Window());
    _pCollection->_pOmWindowProxy->Window()->LeaveScript();

    return(S_OK);
}


//---------------------------------------------------------------------------
//
//  Method:     CScriptHolder::DoYouWishToDebug
//
//---------------------------------------------------------------------------

HRESULT
CScriptHolder::DoYouWishToDebug(IActiveScriptError * pScriptError, BOOL * pfEnterDebugger)
{
    int                   iRes = IDYES;
    CDoc                 *pDoc;
    HRESULT               hr = S_OK;
    BOOL                  fExcepInfo = TRUE;
    CExcepInfo            ExcepInfo;
    ULONG                 ulLine = 0;
    LONG                  ichError;
    DWORD                 dwSrcContext;
    TCHAR                *pchDescription = NULL;
    TCHAR                 achError[256];
    TCHAR                 achDescription[512];
    AAINDEX               aaidx;
    CWindow              *pWindow;

    *pfEnterDebugger = FALSE; 

    pDoc = _pCollection->Doc();
    Assert(pDoc);

    Assert(_pCollection->_pOmWindowProxy);
    pWindow = _pCollection->_pOmWindowProxy->Window();
    Assert(pWindow);

    // Stack overflow
    if (pWindow->_fStackOverflow || pWindow->_fOutOfMemory)
    {
        // If we are in last script, stack has been unwound, so prevent 2nd dialog in OnLeaveScript
        if (pWindow->_cScriptNesting == 1)
        {
            pWindow->_fStackOverflow = FALSE;
            pWindow->_fOutOfMemory = FALSE;
        }

        goto Cleanup;
    }

    aaidx = _pCollection->_pOmWindowProxy->FindAAIndex(DISPID_EVPROP_ONERROR, CAttrValue::AA_Internal);

    // Do not dispay error dialog if error handler is hooked up.
    if (aaidx == AA_IDX_UNKNOWN)
    {
        _fErrorHandlerSet = FALSE;

        // Get the ExcepInfo
        if (!(pDoc->_dwLoadf & DLCTL_SILENT))
        {
            // TODO (alexz) this should use ErrorRecord - otherwise this is largely duplicated code

            hr = THR(pScriptError->GetExceptionInfo(&ExcepInfo));
            if (!hr)
            {
                // If the script was aborted (through the script debugger),
                // don't put up any UI.
                if (ExcepInfo.scode == E_ABORT)
                    goto Cleanup;

                pScriptError->GetSourcePosition(&dwSrcContext, &ulLine, &ichError);

                // HACK fix for IE5 bug# 58568
                if (OutLook98HackReqd(_pCollection->_pOmWindowProxy->Markup(), ulLine, ichError))
                    goto Cleanup;

                // vbscript passes empty strings and jscript passes NULL, so check for both
                if (ExcepInfo.bstrDescription && *ExcepInfo.bstrDescription)
                {
                    pchDescription = ExcepInfo.bstrDescription;
                }
                else
                {
                    GetErrorText(ExcepInfo.scode, achError, ARRAY_SIZE(achError));
                    pchDescription = achError;
                }
            }
            else
            {
                fExcepInfo = FALSE;
            }

            if (!hr)
            {
                // Note that ulLine MUST have been set if HR == S_OK (0).
                hr = Format(0, achDescription, ARRAY_SIZE(achDescription), MAKEINTRESOURCE(IDS_FMTDEBUGCONTINUE),
                            GetResourceHInst(), MAKEINTRESOURCE(IDS_DEBUGCONTINUE), ulLine, pchDescription);
            }
            else
            {
                hr = Format(0, achDescription, ARRAY_SIZE(achDescription), _T("<0i>"),
                            GetResourceHInst(), MAKEINTRESOURCE(IDS_DEBUGCONTINUE));
            }

            // Display "Do you wish to debug?" dialog
            if (!hr && !pDoc->_fPopupDoc)
            {
                CDoEnableModeless   dem(pDoc, pWindow);
                iRes = ::MessageBox(
                    dem._hwnd, achDescription, NULL, MB_YESNO | MB_ICONERROR);
            }

            iRes = pDoc->_fPopupDoc ? IDNO : iRes;
        }

        // If out of memory, iRes == 0, enter debugger
        if (iRes == IDYES || iRes == 0)
        { 
            hr = S_OK;
            *pfEnterDebugger = TRUE; 
            goto Cleanup;
        }
    }
    else
        _fErrorHandlerSet = TRUE;

    // Unwind the stack on stack overflow, if user decided to continue
    // Also unwind while calls are nested on the stack and if no excepinfo is available or if
    // the error is VBSERR_OutOfMemory. (It is possible to get out of memory before out of stack!
    if (!fExcepInfo || ExcepInfo.scode == VBSERR_OutOfStack)
    {
        if (pWindow->_cScriptNesting > 1)
            pWindow->_fStackOverflow = TRUE;
    }
    else if (ExcepInfo.scode == VBSERR_OutOfMemory)
    {
        if (pWindow->_cScriptNesting > 1)
            pWindow->_fOutOfMemory = TRUE;
    }

Cleanup:
    RRETURN (hr);
}

//---------------------------------------------------------------------------
//
//  Method:     CScriptHolder::OnScriptErrorDebug
//
//  Synopsis:   per IActiveScriptSite
//
//  Arguments:  pErrorDebug:       Error info
//              pfEnterDebugger:   Whether to pass the error to the debugger
//                                 to do JIT debugging
//              pfCallOnScriptErrorWhenContinuing:
//                                 Whether to call IActiveScriptSite::OnScriptError()
//                                 when the user decides to continue by returning
//                                 the error
//                                       
//---------------------------------------------------------------------------

HRESULT
CScriptHolder::OnScriptErrorDebug(IActiveScriptErrorDebug* pErrorDebug, BOOL *pfEnterDebugger,
                                  BOOL *pfCallOnScriptErrorWhenContinuing)
{
    TraceTag((tagScriptSite, "OnScriptErrorDebug"));

    HRESULT                 hr;
    IActiveScriptError *    pScriptError = NULL;

    if (IllegalCall())
        RRETURN(E_UNEXPECTED);

    hr = THR(pErrorDebug->QueryInterface(IID_IActiveScriptError, (void**)&pScriptError));
    if (hr)
        goto Cleanup;

    hr = THR(DoYouWishToDebug(pScriptError, pfEnterDebugger));

Cleanup:
    if (pfCallOnScriptErrorWhenContinuing)
    {
        *pfCallOnScriptErrorWhenContinuing = _fErrorHandlerSet; 
    }

    ReleaseInterface(pScriptError);

    RRETURN (hr);
}



//---------------------------------------------------------------------------
//
//  Method:     CScriptHolder::GetWindow
//
//  Synopsis:   per IActiveScriptWindow
//
//  Arguments:  phwnd       Resultant hwnd
//
//---------------------------------------------------------------------------

HRESULT
CScriptHolder::GetWindow(HWND *phwnd)
{
    TraceTag((tagScriptSite, "GetWindow"));

    if (IllegalCall())
        RRETURN(E_UNEXPECTED);
        
    if (!_pCollection)
        RRETURN(E_UNEXPECTED);

    *phwnd = _pCollection->Doc()->_state >= OS_INPLACE ?
            _pCollection->Doc()->_pInPlace->_hwnd :
            NULL;

    return S_OK;
}


//---------------------------------------------------------------------------
//
//  Method:     CScriptHolder::EnableModeless
//
//  Synopsis:   per IActiveScriptWindow
//
//  Arguments:  fEnable         TRUE to enable, FALSE to disable
//
//---------------------------------------------------------------------------

HRESULT
CScriptHolder::EnableModeless(BOOL fEnable)
{
    TraceTag((tagScriptSite, "EnableModeless"));

    if (IllegalCall())
        RRETURN(E_UNEXPECTED);
        
    if (!_pCollection || (g_pHtmPerfCtl && (g_pHtmPerfCtl->dwFlags & HTMPF_DISABLE_ALERTS)))
        RRETURN(E_UNEXPECTED);

    CDoEnableModeless   dem(_pCollection->Doc(), _pCollection->_pOmWindowProxy->Window(), FALSE);

    if (fEnable)
    {
        dem.EnableModeless(TRUE);
    }
    else
    {
        dem.DisableModeless();

        // Return an explicit failure here if we couldn't do it.
        // This is needed to ensure that the count does not go
        // out of sync.
        if (!dem._fCallEnableModeless)
            return E_FAIL;
    }
    
    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Method:     CScriptHolder::QueryContinue
//
//  Synopsis:   per IActiveScriptSiteInterruptPoll
//
//---------------------------------------------------------------------------
HRESULT
CScriptHolder::QueryContinue(void)
{
    HRESULT hr;
    IActiveScriptStats *pScriptStats=NULL;
    ULONG ulLow,ulHigh = 0;

    if (IllegalCall())
        RRETURN(E_UNEXPECTED);
        
    TraceTag((tagScriptSite, "QueryContinue"));

    if (!_pCollection||!_pScript)
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    // Find out how many statements have executed. This is an optional interface
    // so allow QI to fail
    hr = THR(_pScript->QueryInterface(IID_IActiveScriptStats,
        (void**)&pScriptStats ));
    if ( !hr )
    {
        hr = THR(pScriptStats->GetStat ( SCRIPTSTAT_STATEMENT_COUNT,
            &ulLow, &ulHigh ));
        if ( hr )
            goto Cleanup;

        hr = THR(pScriptStats->ResetStats());
        if ( hr )
            goto Cleanup;
    }
    else if ( hr != E_NOINTERFACE )
    {
        goto Cleanup;
    }

    Assert(_pCollection->_pOmWindowProxy);
    Assert(_pCollection->_pOmWindowProxy->Window());
    hr = THR(_pCollection->_pOmWindowProxy->Window()->QueryContinueScript(ulHigh));

Cleanup:
    ReleaseInterface(pScriptStats);
    RRETURN(hr);
}


//---------------------------------------------------------------------------
//
//  Method:     CScriptHolder::QueryService
//
//  Synopsis:   per IServiceProvider
//
//---------------------------------------------------------------------------

HRESULT
CScriptHolder::QueryService(REFGUID sid, REFIID iid, LPVOID *ppv)
{
    TraceTag((tagScriptSite, "QueryService"));

    if (IllegalCall())
        RRETURN(E_UNEXPECTED);
        
    RRETURN(_pCollection->_pOmWindowProxy->Document()->QueryService(sid, iid, ppv));
}



#ifndef NO_SCRIPT_DEBUGGER

//---------------------------------------------------------------------------
//
//  Method:     CScriptHolder::GetDocumentContextFromPosition
//
//  Synopsis:   per IActiveScriptSiteDebug
//
//---------------------------------------------------------------------------

HRESULT
CScriptHolder::GetDocumentContextFromPosition(
    DWORD_PTR                   dwCookie,
    ULONG                       uCharacterOffset,
    ULONG                       uNumChars,
    IDebugDocumentContext **    ppDebugDocumentContext)
{
    HRESULT                 hr;
    CScriptCookieTable *    pScriptCookieTable;

#ifndef NO_SCRIPT_DEBUGGER
    Assert(g_pPDM && g_pDebugApp);
#endif

    hr = THR(_pCollection->Doc()->EnsureScriptCookieTable(&pScriptCookieTable));
    if (hr)
        goto Cleanup;

    hr = THR(pScriptCookieTable->GetScriptDebugDocumentContext(
        dwCookie, uCharacterOffset, uNumChars, ppDebugDocumentContext));

Cleanup:
    RRETURN (hr);
}


//---------------------------------------------------------------------------
//
//  Method:     CScriptHolder::GetRootApplicationNode
//
//  Note:       This method can be called on a non-apartment thread
//              because the debugger may need access to this method
//              when the ui thread is hung inside a breakpoint.
//
//---------------------------------------------------------------------------

HRESULT
CScriptHolder::GetRootApplicationNode (IDebugApplicationNode ** ppDebugApplicationNode)
{
    TraceTag((tagScriptSite, "GetRootApplicationNode"));

    HRESULT                 hr = E_UNEXPECTED;
    CScriptDebugDocument *  pDebugDocument = NULL;
    CMarkupScriptContext *  pMarkupScriptContext = _pCollection->Doc()->PrimaryMarkup()->ScriptContext();
    IDebugDocumentHelper *  pDebugHelper = NULL;

    if (!ppDebugApplicationNode)
        RRETURN(E_POINTER);

    *ppDebugApplicationNode = NULL;

    pDebugDocument = pMarkupScriptContext ? pMarkupScriptContext->_pScriptDebugDocument : NULL;

    if (pDebugDocument)
    {
        pDebugDocument->GetDebugHelper(&pDebugHelper);
        if (!pDebugHelper)
        {
            goto Cleanup;
        }
    
        hr = THR(pDebugHelper->GetDebugApplicationNode(ppDebugApplicationNode));
        if (hr)
        {
            goto Cleanup;
        }
    }

Cleanup:
    if (pDebugDocument)
        pDebugDocument->ReleaseDebugHelper(pDebugHelper);

    RRETURN(hr);
}


//---------------------------------------------------------------------------
//
//  Method:     CScriptHolder::GetApplication
//
//  Synopsis:   per IActiveScriptSiteDebug
//
//  Note:       This method can be called on a non-apartment thread
//              because the debugger may need access to this method
//              when the ui thread is hung inside a breakpoint.
//
//---------------------------------------------------------------------------

HRESULT
CScriptHolder::GetApplication( IDebugApplication **ppApp )
{
    TraceTag((tagScriptSite, "GetApplication"));
    Assert( ppApp );
    
    if( !ppApp )
        RRETURN(E_POINTER);
    if (!g_pDebugApp )
        RRETURN(E_UNEXPECTED);
    *ppApp = g_pDebugApp;
    (*ppApp)->AddRef( );

    RRETURN(S_OK);
}


//---------------------------------------------------------------------------
//
//  Method:     CScriptHolder::EnterBreakPoint
//
//  Synopsis:   per IActiveScriptSiteDebug
//
//  NOTE:       No longer used.  Replaced by IRemoteDebugApplicationEvents::OnEnterBreakPoint
//
//---------------------------------------------------------------------------

HRESULT
CScriptHolder::EnterBreakPoint( void )
{
   TraceTag((tagScriptSite, "EnterBreakPoint"));
   Assert (!"CScriptHolder::EnterBreakPoint: obsolete member called");
   RRETURN(E_UNEXPECTED);
}


//---------------------------------------------------------------------------
//
//  Method:     CScriptHolder::LeaveBreakPoint
//
//  Synopsis:   per IActiveScriptSiteDebug
//
//  NOTE:       No longer used.  Replaced by IRemoteDebugApplicationEvents::OnLeaveBreakPoint
//
//---------------------------------------------------------------------------

HRESULT
CScriptHolder::LeaveBreakPoint( void )
{
    TraceTag((tagScriptSite, "LeaveBreakPoint"));
    Assert (!"CScriptHolder::EnterBreakPoint: obsolete member called");
    RRETURN(E_UNEXPECTED);
}

#endif // NO_SCRIPT_DEBUGGER

HRESULT 
CScriptHolder::QueryStatus (
        const GUID * pguidCmdGroup,
        ULONG cCmds,
        MSOCMD rgCmds[],
        MSOCMDTEXT * pcmdtext)
{
    TraceTag((tagScriptSite, "QueryStatus"));
    if (IllegalCall())
        RRETURN(E_UNEXPECTED);
        
    return S_OK;
}

HRESULT 
CScriptHolder::Exec (
        const GUID * pguidCmdGroup,
        DWORD nCmdID,
        DWORD nCmdexecopt,
        VARIANTARG * pvarargIn,
        VARIANTARG * pvarargOut)
{
    TraceTag((tagScriptSite, "Exec"));

    if (IllegalCall())
        RRETURN(E_UNEXPECTED);
        
    HRESULT hr = S_OK;
    CDoc *  pDoc = _pCollection->Doc();

    if (!pguidCmdGroup || *pguidCmdGroup != CGID_ScriptSite)
    {
        hr = OLECMDERR_E_UNKNOWNGROUP;
        goto Cleanup;
    }

    switch (nCmdID)
    {
    case CMDID_SCRIPTSITE_URL:
    case CMDID_SCRIPTSITE_SID:

        if (!pvarargOut)
        {
            hr = E_POINTER;
            goto Cleanup;
        }
        
        V_VT(pvarargOut) = VT_BSTR;

        //
        // For security reasons, we use the actual URL of the calling doc
        // as opposed to the base URL. (We used the base URL in beta 2.)
        // Also this behavior is compat with Nav - dbau.
        //

        if (nCmdID == CMDID_SCRIPTSITE_URL)
        {
            CMarkup *pMarkup = _pCollection->_pOmWindowProxy->Markup();
            LPCTSTR pchUrl = CMarkup::GetUrl(pMarkup);

            if (IsSpecialUrl(pchUrl))
            {
                LPCTSTR pchCreatorUrl = pMarkup->GetAAcreatorUrl();
                Assert(pchCreatorUrl && *pchCreatorUrl);
                // Just to be on the safe side, as we it in other places!
                if (pchCreatorUrl && *pchCreatorUrl)
                    pchUrl = pchCreatorUrl;
            }

            hr = THR(FormsAllocString(pchUrl, &V_BSTR(pvarargOut)));
            if (hr)
                goto Cleanup;
        }
        else    // nCmdID == CMDID_SCRIPTSITE_SID
        {
            BYTE    abSID[MAX_SIZE_SECURITY_ID];
            DWORD   cbSID = ARRAY_SIZE(abSID);

            memset(abSID, 0, cbSID);

            hr = THR(_pCollection->_pOmWindowProxy->Markup()->GetSecurityID(abSID, &cbSID));
            if (hr)
                goto Cleanup;

            hr = FormsAllocStringLen(NULL, MAX_SIZE_SECURITY_ID, &V_BSTR(pvarargOut));
            if (hr)
                goto Cleanup;

            memcpy(V_BSTR(pvarargOut), abSID, MAX_SIZE_SECURITY_ID);
        }

        break;

    case CMDID_SCRIPTSITE_SECURITY_WINDOW:
        V_VT(pvarargOut) = VT_DISPATCH;
        V_DISPATCH(pvarargOut) = (IHTMLWindow2 *)_pCollection->_pOmWindowProxy;

        _pCollection->_pOmWindowProxy->AddRef();

#if DBG==1
        if (IsTagEnabled(tagSecureScriptWindow))
        {
            V_DISPATCH(pvarargOut) = (IHTMLWindow2 *)_pCollection->_pSecureWindowProxy;
            _pCollection->_pSecureWindowProxy->AddRef();
            _pCollection->_pOmWindowProxy->Release();
        }
#endif

        break;

    case CMDID_SCRIPTSITE_TRUSTEDDOC:
        if (!pvarargOut)
        {
            hr = E_POINTER;
            goto Cleanup;
        }

        V_VT(pvarargOut) = VT_BOOL;
        V_BOOL(pvarargOut) = (_pCollection->_pOmWindowProxy->Markup()->IsMarkupTrusted()) ? VARIANT_TRUE : VARIANT_FALSE;
        hr = S_OK;
        break;
        
    case CMDID_SCRIPTSITE_HTMLDLGTRUST:

        {
            if (!pvarargOut)
            {
                hr = E_POINTER;
                goto Cleanup;
            }
        
            V_VT(pvarargOut) = VT_EMPTY;

            if (pDoc->_fInHTMLDlg)
            {
                hr = THR(CTExec(
                    pDoc->_pClientSite,
                    &CGID_ScriptSite,
                    CMDID_SCRIPTSITE_HTMLDLGTRUST,
                    0,
                    NULL,
                    pvarargOut));

                if (hr)
                    goto Cleanup;
            }
            else
            {
                hr = OLECMDERR_E_NOTSUPPORTED;
            }

            break;
        }

    case CMDID_SCRIPTSITE_SECSTATE:
        {
            SSL_SECURITY_STATE sss;
            SSL_PROMPT_STATE   sps;
            BOOL               fPendingRoot;
            
            if (!pvarargOut)
            {
                hr = E_POINTER;
                goto Cleanup;
            }

            V_VT(pvarargOut) = VT_I4;

            fPendingRoot = _pCollection->_pOmWindowProxy->Markup()->IsPendingRoot();

            pDoc->GetRootSslState(fPendingRoot, &sss, &sps);

            V_I4(pvarargOut) = (long)sss;
            
            break;
        }

    default:
        hr = OLECMDERR_E_NOTSUPPORTED;
        break;

    }

Cleanup:
    RRETURN(hr);
}

HRESULT
CScriptHolder::GetDebug(IActiveScriptDebug **ppDebug)
{
    HRESULT hr = S_OK;

    hr = THR(_pScript->QueryInterface(IID_IActiveScriptDebug, (LPVOID *)ppDebug));

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\secmgr.cxx ===
//+------------------------------------------------------------------------
//
//  File:       secmgr.cxx
//
//  Contents:   Security manager call implementation
//
//  Classes:    (part of) CDoc, CSecurityMgrSite
//
//  History:    05-07-97  AnandRa   Created
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_SAFETY_HXX_
#define X_SAFETY_HXX_
#include "safety.hxx"
#endif

#ifndef X_MARKUP_HXX_
#define X_MARKUP_HXX_
#include "markup.hxx"
#endif

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx"
#endif

#ifndef X_FRAME_HXX_
#define X_FRAME_HXX_
#include "frame.hxx"
#endif

#ifndef X_ACTIVSCP_H_
#define X_ACTIVSCP_H_
#include <activscp.h>
#endif

#ifndef X_OTHRGUID_H_
#define X_OTHRGUID_H_
#include "othrguid.h"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

ExternTag(tagCDoc);
ExternTag(tagSecurityContext);

// external reference
BOOL IsSpecialUrl(LPCTSTR pszURL);

extern BOOL     g_IEHardened;
extern BOOL     g_fInKnownBrowserApp;
extern TCHAR*   g_tszModuleFileName;

const GUID GUID_CUSTOM_CONFIRMOBJECTSAFETY = 
        { 0x10200490, 0xfa38, 0x11d0, { 0xac, 0xe, 0x0, 0xa0, 0xc9, 0xf, 0xff, 0xc0 }};

// Custom policy used to query before the scriptlet runtime creates an 
// interface handler. The semantics of this call are similar to the standard
// policy URLACTION_ACTIVEX_RUN. e.g. Input is the CLSID of the handler. Output
// is the policy in a DWORD.
static const GUID GUID_CUSTOM_CONFIRMINTERFACEHANDLER = 
        { 0x02990d50, 0xcd96, 0x11d1, { 0xa3, 0x75, 0x0, 0x60, 0x8, 0xc3, 0xfb, 0xfc }};

// automation handler
static const GUID CLSID_DexHandlerConstructor =
    { 0xc195d550, 0xa068, 0x11d1, { 0x89, 0xb6, 0x0, 0x60, 0x8, 0xc3, 0xfb, 0xfc }};
// event handler
static const GUID CLSID_CpcHandlerConstructor =
    { 0x3af5262e, 0x4e6e, 0x11d1, { 0xbf, 0xa5, 0x00, 0xc0, 0x4f, 0xc3, 0x0c, 0x45}};

static const GUID* knownScriptletHandlers[] = {
        &CLSID_CPeerHandler,
        &CLSID_DexHandlerConstructor,
        &CLSID_CpcHandlerConstructor,
        &CLSID_CHiFiUses,
        &CLSID_CCSSFilterHandler,
    &CLSID_CSvrOMUses,
};

//+------------------------------------------------------------------------
//
//  Member:     CDoc::EnsureSecurityManager
//
//  Synopsis:   Verify that the security manager is created
//
//-------------------------------------------------------------------------

HRESULT
CDoc::EnsureSecurityManager( BOOL fForPrinting /*=FALSE*/ )
{
    TraceTag((tagCDoc, "CDoc::EnsureSecurityManager"));

    HRESULT hr = S_OK;
    IInternetSecurityManager **ppISM = &_pSecurityMgr; 

    // (KTam) The doc may maintain an instance of a security manager to be used for
    // print content inside a printing dialog.  Because dialogs have their own
    // (very permissive) security model, if we make a call to a _pSecurityMgr
    // belonging to a dialog, it won't enforce browser zone restrictions.  Our
    // solution is to instantiate a separate security manager that doesn't get set to
    // delegate back to the dialog -- we avoid this delegation by _never_ calling
    // the new security manager's IInternetSecurityManager::SetSecuritySite() after
    // the dialog has attached itself to the CDoc via IOleObject::SetClientSite().
    // See also CDoc::SetClientSite() and CHTMLDlg::Create().
    if ( fForPrinting )
        ppISM = &_pPrintSecurityMgr;

    if (*ppISM)
    {
        // Do not use the cached security manager until the doc is inplace active
        // when we are being hosted within an ATL framework application that hosts 
        // the WebOC.
        if (_fATLHostingWebOC && (State() < OS_INPLACE))
        {
            ClearInterface(ppISM);
        }
        else
            goto Cleanup;
    }

    //
    // If we're ensuring the security manager for some reason, we
    // will be using the url down the road, so ensure that too.
    //
    Assert(!!GetDocumentSecurityUrl());

    hr = THR(CoInternetCreateSecurityManager(NULL, ppISM, 0));
    if (hr)
        goto Cleanup;

    hr = THR((*ppISM)->SetSecuritySite(&_SecuritySite));
    if (hr)
        goto Cleanup;

    AssertSz(!IsPrintDialog() || _pPrintSecurityMgr, "PrintPreview should always have a print security manager.");

Cleanup:
    RRETURN(hr);
}

HRESULT
CMarkup::AllowClipboardAccess(TCHAR *pchCmdId, BOOL *pfAllow)
{
    HRESULT    hr = E_FAIL;
    DWORD     dwCmdId;

    *pfAllow = FALSE;
    
    // (rolandt) Convert the command ID from string to number.  For *pfAllow=true, the command
    // must be in our command list.  We'll call ProcessURLAction for clipboard related commands
    // we know of now.  This is our inclusion list.  The inclusion list will need to be updated as
    // necessary as new commands are added to CBase::cmdTable[] in basemso.cxx.

    // (rolandt) May be prudent to add a security check member to CBase::CMDINFOSTRUCT as a
    // general security measure so that as new commands are added this member will need to be
    // explicitly set.  We could then check for that member here and see what security check we
    // need to do for the command.  Downside is adding at least a dword for every command (~100).
    
    hr = THR_NOTRACE(CmdIDFromCmdName(pchCmdId, &dwCmdId));
    if(hr)
    {
        *pfAllow = FALSE;
        goto Cleanup;
    }

    if (    dwCmdId == IDM_PASTE /* "Paste" */
        ||  dwCmdId == IDM_COPY /* "Copy" */
        ||  dwCmdId == IDM_CUT /* "Cut" */
        ||  dwCmdId == IDM_PARAGRAPH /* "InsertParagraph" */)
    {
        RRETURN(ProcessURLAction(URLACTION_SCRIPT_PASTE, pfAllow));
    }

    *pfAllow = TRUE;
    hr = S_OK;

Cleanup:
    return hr;
}

//+------------------------------------------------------------------------
//
//  Member:     CDoc::ProcessURLAction
//
//  Synopsis:   Query the security manager for a given action
//              and return the response.  This is basically a true/false
//              or allow/disallow return value.
//
//  Arguments:  dwAction [in]  URLACTION_* from urlmon.h
//              pfReturn [out] TRUE on allow, FALSE on any other result
//              fNoQuery [in]  TRUE means don't query
//              pfQuery  [out] TRUE if query was required
//              pchURL   [in]  The acting URL or NULL for the doc itself
//              pbArg    [in]  pbContext for IInternetSecurityManager::PUA
//              cbArg    [in]  cbContext for IInternetSecurityManager::PUA
//
//-------------------------------------------------------------------------

HRESULT
CMarkup::ProcessURLAction(
    DWORD dwAction,
    BOOL *pfReturn,
    DWORD dwPuaf,
    DWORD *pdwPolicy,
    LPCTSTR pchURL,
    BYTE *pbArg,
    DWORD cbArg,
    PUA_Flags pua)
{
    HRESULT hr = S_OK;
    DWORD   dwPolicy = 0;
    DWORD   dwMask = 0;
    ULONG   cDie;
    BOOL    fDisableNoShowElement = pua & PUA_DisableNoShowElements;
    BOOL    fIgnoreLoadf = pua & PUA_NoLoadfCheckForScripts;
    IInternetSecurityManager *pSecMgr = NULL;
    LPTSTR  pchSecurityURL = NULL;

    *pfReturn = FALSE;

    // TODO (alexz) ProcessUrlAction can push message loop for a message box,
    // so it has to be called at a safe moment of time. Enable this in IE5.5 B3
    // (in B2 it asserts all over the place)
    // AssertSz(!__fDbgLockTree, "ProcessURLAction is called when the new markup is unstable. This will lead to crashes, memory leaks, and script errors");

    hr = THR(Doc()->EnsureSecurityManager());
    if (hr)
        goto Error;

    //
    // Check the action for special known guids.  In these cases
    // we want the min of the security settings and the _dwLoadf
    // that the host provided.
    //

    switch (dwAction)
    {
    case URLACTION_SCRIPT_RUN:
        dwMask = DLCTL_NO_SCRIPTS;
        break;

    case URLACTION_ACTIVEX_RUN:
        dwMask = DLCTL_NO_RUNACTIVEXCTLS;
        break;

    case URLACTION_HTML_JAVA_RUN:
        dwMask = DLCTL_NO_JAVA;
        break;

    case URLACTION_JAVA_PERMISSIONS:
        dwMask = DLCTL_NO_JAVA;
        break;
    }

    // TODO (KTam, JHarding) Temporary hack to stop scripts from
    // running when printing.  Right fix involves figuring out how
    // to read from the markup's _dwLoadF, and where we ought to be
    // checking DontRunScripts.
    // TODO again (Jharding): Verify this is no longer needed.
    if (   dwAction == URLACTION_SCRIPT_RUN
        && !fDisableNoShowElement               // only NOSCRIPT/NOEMBED parsing passes fDisableNoShowElement == TRUE
        && DontRunScripts() )
    {
        goto Cleanup;
    }

    // $$ktam: TODO In the insertAdjacentHTML case (and probably others),
    // we don't go through CMarkup::LoadFromInfo(), so we don't have a
    // CDwnDoc!  For now we'll delegate back to the CDoc in those situations.
    if (!fIgnoreLoadf && dwMask && ( (GetDwnDoc() ? GetDwnDoc()->GetLoadf() : _pDoc->_dwLoadf) & dwMask))
    {
        // 69976: If we are not running scripts only because we are printing,
        // don't disable noshow elements NOSCRIPT and NOEMBED.
        if (   !fDisableNoShowElement
            || dwMask != DLCTL_NO_SCRIPTS
            || !DontRunScripts())
        {
            goto Error;
        }
    }

    if (!pchURL)
    {
        pchURL = GetUrl(this);
        
    }

    if (g_IEHardened && !g_fInKnownBrowserApp 
        && (_tcsicmp(pchURL, _T("about:blank")) == 0))
    {
        AssertSz(g_tszModuleFileName && *g_tszModuleFileName, "ModuleFileName not set for calling ProcessUrlAction");
        pchSecurityURL = new TCHAR[_tcslen(g_tszModuleFileName) + 15 /*about:security_*/ + 1 /*NULL*/];
        _tcscpy(pchSecurityURL, _T("about:security_"));
        _tcscat(pchSecurityURL, g_tszModuleFileName);
        pchURL = (LPCTSTR)pchSecurityURL;
    }
    

    cDie = Doc()->_cDie;

    if (GetWindowedMarkupContext()->HasWindow() || _fWindowPending)
    {
        COmWindowProxy * pProxy;

        if (!_fWindowPending)
        {
            pProxy = GetWindowedMarkupContext()->Window();
        }
        else
        {
            pProxy = GetWindowPending();            
        }

        if (pProxy->Window()->_fRestricted)
        {
            dwPuaf |= PUAF_ENFORCERESTRICTED;
        }
        else if (pProxy->_fTrustedDoc)
        {
            dwPuaf |= PUAF_TRUSTED;
        }

        if (Doc()->_fInTrustedHTMLDlg)
        {
            // If we're in a trusted HTML dialog, then toplevel pages
            // are considered trusted. Frames are considered trusted only
            // if application="yes", which means that _fTrustedFrame is
            // set on the CFrameSite. See CHTMLDlgSite::ProcessUrlAction
            // for more info.
            CFrameSite * pFrameSite = pProxy->Window()->GetFrameSite();

            if (pFrameSite == NULL || pFrameSite->_fTrustedFrame)
            {
                dwPuaf |= PUAF_TRUSTED;
            }
        }
        
    }

    pSecMgr = GetSecurityManager();

    // if NULL - see EnsureSecurityManager/GetSecurityManager for trouble.
    // or we have a low mem condition.
    Check(pSecMgr); 

    if(!pSecMgr) 
    {
        goto Error; //this will return FALSE (disallow)
    }
    
    hr = THR(pSecMgr->ProcessUrlAction(
        pchURL,
        dwAction,
        (BYTE *)&dwPolicy,
        sizeof(DWORD),
        pbArg,
        cbArg,
        dwPuaf,
        0));

    if (hr == S_FALSE)
        hr = S_OK;

    if (Doc()->_cDie != cDie)
        hr = E_ABORT;

    if (hr)
        goto Error;

    if (pdwPolicy)
        *pdwPolicy = dwPolicy;

    if (dwAction != URLACTION_JAVA_PERMISSIONS)
    {
        *pfReturn = (GetUrlPolicyPermissions(dwPolicy) == URLPOLICY_ALLOW);
    }
    else
    {
        // query was for URL_ACTION_JAVA_PERMISSIONS
        *pfReturn = (dwPolicy != URLPOLICY_JAVA_PROHIBIT);
    }

Cleanup:
    delete [] pchSecurityURL;
    TraceTag((tagCDoc, "CDoc::ProcessURLAction, Action=0x%x URL=%s Allowed=%d", dwAction, pchURL, *pfReturn));

    RRETURN(hr);

Error:
    *pfReturn = FALSE;

    goto Cleanup;
}

//+------------------------------------------------------------------------
//
//  Member:     CDoc::GetSecurityID
//
//  Synopsis:   Retrieve a security ID from a url from the system sec mgr.
//
//-------------------------------------------------------------------------

void
CMarkup::UpdateSecurityID()
{
    HRESULT hr;

    COmWindowProxy *    pProxy = Window();

    if (pProxy)
    {
        BYTE    abSID[MAX_SIZE_SECURITY_ID];
        DWORD   cbSID = ARRAY_SIZE(abSID);

        hr = THR(GetSecurityID(abSID, &cbSID));
        if (hr)
            return;

        TraceTag((tagSecurityContext, "Update security id on proxy 0x%x to %s", pProxy, abSID));

        hr = THR(pProxy->Init(pProxy->_pWindow, abSID, cbSID));
        if (hr)
            return;

        //
        // Find and replace the main proxy. fOMAccess = FALSE
        //
        if ((TLS(windowInfo.paryWindowTbl)->FindProxy(pProxy->_pWindow, 
                                                        abSID, 
                                                        cbSID, 
                                                        IsMarkupTrusted(), 
                                                        NULL, 
                                                        /*fOMAccess = */ FALSE )))
        {
            TLS(windowInfo.paryWindowTbl)->DeleteProxyEntry(pProxy);

            THR(TLS(windowInfo.paryWindowTbl)->AddTuple(
                    pProxy->_pWindow,
                    abSID,
                    cbSID,
                    IsMarkupTrusted(),
                    pProxy));
        }
    }
}

//+------------------------------------------------------------------------
//
//  Member:     CMarkup::AccessAllowed
//
//-------------------------------------------------------------------------

BOOL
CMarkup::AccessAllowed(LPCTSTR pchUrl)
{
    HRESULT hr = S_OK;
    BYTE    abSID1[MAX_SIZE_SECURITY_ID];
    BYTE    abSID2[MAX_SIZE_SECURITY_ID];
    DWORD   cbSID1 = ARRAY_SIZE(abSID1);
    DWORD   cbSID2 = ARRAY_SIZE(abSID2);
    BOOL    fAccessAllowed = FALSE;

    hr = THR_NOTRACE(GetSecurityID(abSID1, &cbSID1, pchUrl));
    if (hr)
        goto Cleanup;

    hr = THR_NOTRACE(GetSecurityID(abSID2, &cbSID2)); // get SID of doc itself
    if (hr)
        goto Cleanup;

    fAccessAllowed = (cbSID1 == cbSID2 && 0 == memcmp(abSID1, abSID2, cbSID1));

Cleanup:
    return fAccessAllowed;
}

//+------------------------------------------------------------------------
//
//  Member:     CDoc::AccessAllowed
//
//-------------------------------------------------------------------------

BOOL
CMarkup::AccessAllowed(CMarkup * pMarkupAnother)
{
    HRESULT hr = S_OK;
    BYTE    abSID1[MAX_SIZE_SECURITY_ID];
    BYTE    abSID2[MAX_SIZE_SECURITY_ID];
    DWORD   cbSID1 = ARRAY_SIZE(abSID1);
    DWORD   cbSID2 = ARRAY_SIZE(abSID2);
    BOOL    fAccessAllowed = FALSE;

    hr = THR_NOTRACE(pMarkupAnother->GetSecurityID(abSID1, &cbSID1));
    if (hr)
        goto Cleanup;

    hr = THR_NOTRACE(GetSecurityID(abSID2, &cbSID2)); // get SID of doc itself
    if (hr)
        goto Cleanup;

    fAccessAllowed = (cbSID1 == cbSID2 && 0 == memcmp(abSID1, abSID2, cbSID1));

Cleanup:
    return fAccessAllowed;
}

//+------------------------------------------------------------------------
//
//  Member:     CMarkup::GetFrameZone
//
//  Synopsis:   Pass out the zone of the current markup depending on variant
//              passed in.
//
//  Notes:      If the pvar is VT_EMPTY, nothing has been filled out yet.
//              If it is VT_UI4, it contains the current zone.  We have to
//              check zones with this and update it to mixed if appropriate.
//              If it is VT_NULL, the zone is mixed.
//
//-------------------------------------------------------------------------

HRESULT
CMarkup::GetFrameZone(VARIANT *pvar)
{
    HRESULT hr = S_OK;
    CDoc *  pDoc = Doc();
    DWORD   dwZone;
    DWORD   dwMUTZFlags = 0;
    CElement * pClient;
    TCHAR * pchCreatorUrl;
    TCHAR * pchURL;

    if (V_VT(pvar) == VT_NULL)
        goto Cleanup;

    hr = THR(pDoc->EnsureSecurityManager());
    if (hr)
        goto Cleanup;

    pchURL = (TCHAR *) GetUrl(this);

    if (IsSpecialUrl(pchURL))
    {
        pchCreatorUrl = (TCHAR *) GetAAcreatorUrl();
        if (pchCreatorUrl && *pchCreatorUrl)
        {
            pchURL = pchCreatorUrl;
        }
    }

    //
    // If this markup is attached to or created by a window that is 
    // restricted, then return restricted zone for all enquiries.
    //
    if ((HasWindow() && Window()->Window()->_fRestricted) || 
        (HasWindowedMarkupContextPtr() && 
         GetWindowedMarkupContext()->Window()->Window()->_fRestricted))
    {
        dwMUTZFlags |= MUTZ_ENFORCERESTRICTED;
    }

    hr = THR(pDoc->_pSecurityMgr->MapUrlToZone(pchURL, &dwZone, dwMUTZFlags));
    if (hr)
        goto Cleanup;

    if (V_VT(pvar) == VT_EMPTY)
    {
        V_VT(pvar) = VT_UI4;
        V_UI4(pvar) = dwZone;
    }
    else if (V_VT(pvar) == VT_UI4)
    {
        if (V_UI4(pvar) != dwZone)
        {
            V_VT(pvar) = VT_NULL;
        }
    }
    else
    {
        Assert(0 && "Unexpected value in variant");
    }

    // Send the notification to the Markup
    // TODO (jbeda) this may not work well with frames
    // in viewlinks
    if (_fHasFrames)
    {
        pClient = GetElementClient();

        if (pClient)
        {
            CNotification   nf;

            nf.GetFrameZone(pClient, (void *)pvar);
            Notify(&nf);
        }
    }

Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CDoc::HostGetSecurityId
//
//  Synopsis:   Retrieve a security ID from a url from the system sec mgr.
//
//-------------------------------------------------------------------------
HRESULT
CDocument::HostGetSecurityId(BYTE *pbSID, DWORD *pcb, LPCWSTR pwszDomain)
{
    HRESULT hr;

    CMarkup *   pMarkup = Markup();
    Assert( pMarkup );

    if (_pWindow && _pWindow->_punkViewLinkedWebOC && 
            _pWindow->_pWindowParent)
    {
        return _pWindow->_pWindowParent->Document()->HostGetSecurityId(
                        pbSID, pcb, pwszDomain);
    }

    hr = pMarkup->GetSecurityID(pbSID, pcb, NULL, pwszDomain, TRUE);

    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CDoc::ProcessUrlAction
//
//  Synopsis:   per IInternetHostSecurityManager
//
//-------------------------------------------------------------------------
HRESULT
CDocument::HostProcessUrlAction(
    DWORD dwAction,
    BYTE *pPolicy,
    DWORD cbPolicy,
    BYTE *pContext,
    DWORD cbContext,
    DWORD dwFlags,
    DWORD dwReserved)
{
    HRESULT hr;
    CMarkup *   pMarkup = Markup();
    Assert( pMarkup );
    CDoc *      pDoc = pMarkup->Doc();

    if(dwAction == URLACTION_ACTIVEX_RUN)
    {
        CLSID*  clsid = (CLSID*)pContext;
        WORD		wclsid;

        hr = THR(pDoc->_clsTab.AssignWclsid(pDoc, *clsid, &wclsid));
        if (hr)
        {
            return E_ACCESSDENIED;
        }

        INSTANTCLASSINFO* pici = pDoc->_clsTab.GetInstantClassInfo(wclsid);

        if (pici && (pici->dwCompatFlags & COMPAT_EVIL_DONT_LOAD))
        {
            return E_ACCESSDENIED;
        }
    }


    if (_pWindow && _pWindow->_punkViewLinkedWebOC && 
            _pWindow->_pWindowParent)
    {
        return _pWindow->_pWindowParent->Document()->HostProcessUrlAction(
                        dwAction, pPolicy, cbPolicy, pContext, cbContext,
                        dwFlags, dwReserved);
    }

    hr = pDoc->EnsureSecurityManager();
    if (hr)
        goto Cleanup;

    if ((_pWindow && _pWindow->_fRestricted) || 
        (pMarkup->HasWindowedMarkupContextPtr() && 
         pMarkup->GetWindowedMarkupContext()->Window()->Window()->_fRestricted))
    {
        dwFlags |= PUAF_ENFORCERESTRICTED;
    }
    else if (pMarkup->IsMarkupTrusted())
    {
        dwFlags |= PUAF_TRUSTED;
    }
   
    hr = THR(pDoc->_pSecurityMgr->ProcessUrlAction(
            CMarkup::GetUrl(pMarkup),
            dwAction,
            pPolicy,
            cbPolicy,
            pContext,
            cbContext,
            dwFlags,
            dwReserved));
    if (!OK(hr))
        goto Cleanup;

Cleanup:
    RRETURN1(hr, S_FALSE);
}


//+------------------------------------------------------------------------
//
//  Member:     CDoc::QueryCustomPolicy
//
//  Synopsis:   per IInternetHostSecurityManager
//
//-------------------------------------------------------------------------
HRESULT
CDocument::HostQueryCustomPolicy(
    REFGUID guidKey,
    BYTE **ppPolicy,
    DWORD *pcbPolicy,
    BYTE *pContext,
    DWORD cbContext,
    DWORD dwReserved)
{
    HRESULT         hr;
    IActiveScript * pScript = NULL;
    BYTE            bPolicy = (BYTE)URLPOLICY_DISALLOW;
    CMarkup *       pMarkup = Markup();
    Assert( pMarkup );    
    CDoc *          pDoc = pMarkup->Doc();

    if (_pWindow && _pWindow->_punkViewLinkedWebOC && 
            _pWindow->_pWindowParent)
    {
        return _pWindow->_pWindowParent->Document()->HostQueryCustomPolicy(
                        guidKey, ppPolicy, pcbPolicy, pContext, cbContext,
                        dwReserved);
    }

    hr = pDoc->EnsureSecurityManager();
    if (hr)
        goto Cleanup;

    //
    // Forward all other custom policies to the real security
    // manager.
    //
    hr = THR_NOTRACE(pDoc->_pSecurityMgr->QueryCustomPolicy(
            CMarkup::GetUrl(pMarkup),
            guidKey,
            ppPolicy,
            pcbPolicy,
            pContext,
            cbContext,
            dwReserved));

    if (hr != INET_E_DEFAULT_ACTION &&
        hr != HRESULT_FROM_WIN32(ERROR_NOT_FOUND))
        goto Cleanup;
        
    if (guidKey == GUID_CUSTOM_CONFIRMOBJECTSAFETY)
    {
        CONFIRMSAFETY * pconfirm;
        DWORD           dwAction;
        BOOL            fSafe;
        SAFETYOPERATION safety;
        const IID *     piid;
        
        //
        // This is a special guid meaning that some embedded object
        // within is itself trying to create another object.  This might
        // just be some activex obj or a script engine.  We will need
        // to run through our IObjectSafety code on this object.  We
        // get the clsid and the IUnknown of the object passed in from
        // the context.
        //
        
        if (cbContext != sizeof(CONFIRMSAFETY))
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }

        if (!ppPolicy || !pcbPolicy)
        {
            hr = E_POINTER;
            goto Cleanup;
        }
        
        pconfirm = (CONFIRMSAFETY *)pContext;
        if (!pconfirm->pUnk)
            goto Cleanup;
            
        //
        // Check for script engine.  If so, then we need to use a different
        // action and IObjectSafety has slightly different restrictions.
        //

        if (OK(THR_NOTRACE(pconfirm->pUnk->QueryInterface(
                IID_IActiveScript,
                (void **)&pScript))) && 
            pScript)
        {
            dwAction = URLACTION_SCRIPT_OVERRIDE_SAFETY;
            safety = SAFETY_SCRIPTENGINE;
            piid = &IID_IActiveScript;
        }
        else
        {
            dwAction = URLACTION_ACTIVEX_OVERRIDE_SCRIPT_SAFETY;
            safety = SAFETY_SCRIPT;
            piid = &IID_IDispatch;
        }
        hr = THR(pMarkup->ProcessURLAction(dwAction, &fSafe)); 
        if (hr)
            goto Cleanup;

        if (!fSafe)
        {
            fSafe = IsSafeTo(
                        safety, 
                        *piid, 
                        pconfirm->clsid, 
                        pconfirm->pUnk, 
                        pMarkup);
        }

        if (fSafe)
            bPolicy = (BYTE)URLPOLICY_ALLOW;

        hr = S_OK;
        goto ReturnPolicy;
    }
    else if (guidKey == GUID_CUSTOM_CONFIRMINTERFACEHANDLER)
    {
        if (cbContext == sizeof(GUID))
        {
            CLSID  *pHandlerCLSID = (CLSID *)pContext;

            for (int i = 0; i < ARRAY_SIZE(knownScriptletHandlers); i++)
                if (*pHandlerCLSID == *knownScriptletHandlers[i])
                {
                    bPolicy = (BYTE)URLPOLICY_ALLOW;
                    break;
                }
        }

        hr = S_OK;
        goto ReturnPolicy;
    }
    
Cleanup:
    ReleaseInterface(pScript);
    RRETURN(hr);

ReturnPolicy:
    *pcbPolicy = sizeof(DWORD);
    *ppPolicy = (BYTE *)CoTaskMemAlloc(sizeof(DWORD));
    if (!*ppPolicy)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    *(DWORD *)*ppPolicy = (BYTE)bPolicy;

    goto Cleanup;
}



IMPLEMENT_SUBOBJECT_IUNKNOWN(CSecurityMgrSite, CDoc, Doc, _SecuritySite)


//+------------------------------------------------------------------------
//
//  Member:     CSecurityMgrSite::QueryInterface
//
//  Synopsis:   per IUnknown
//
//-------------------------------------------------------------------------

HRESULT
CSecurityMgrSite::QueryInterface(REFIID riid, void **ppv)
{
    *ppv = NULL;

    if (riid == IID_IUnknown || riid == IID_IInternetSecurityMgrSite)
    {
        *ppv = (IInternetSecurityMgrSite *)this;
    }
    else if (riid == IID_IServiceProvider)
    {
        *ppv = (IServiceProvider *)this;
    }

    if (*ppv)
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }

    RRETURN(E_NOINTERFACE);
}


//+------------------------------------------------------------------------
//
//  Member:     CSecurityMgrSite::GetWindow
//
//  Synopsis:   Return parent window for use in ui
//
//-------------------------------------------------------------------------

HRESULT
CSecurityMgrSite::GetWindow(HWND *phwnd)
{
    HRESULT         hr = S_OK;
    IOleWindow *    pOleWindow = NULL;
    
    if (Doc()->_dwLoadf & DLCTL_SILENT)
    {
        *phwnd = (HWND)INVALID_HANDLE_VALUE;
        hr = S_FALSE;
    }
    else
    {
        hr = THR(Doc()->GetWindow(phwnd));
        if (hr)
        {
            if (Doc()->_pClientSite &&
                S_OK == Doc()->_pClientSite->QueryInterface(IID_IOleWindow, (void **)&pOleWindow))
            {
                hr = THR(pOleWindow->GetWindow(phwnd));
            }
        }
    }

    ReleaseInterface(pOleWindow);  
    RRETURN1(hr, S_FALSE);
}


//+------------------------------------------------------------------------
//
//  Member:     CSecurityMgrSite::EnableModeless
//
//  Synopsis:   Called before & after displaying any ui
//
//-------------------------------------------------------------------------

HRESULT
CSecurityMgrSite::EnableModeless(BOOL fEnable)
{
    // TODO: having window context would be good here.
    CDoEnableModeless   dem(Doc(), NULL, FALSE);

    if (fEnable)
    {
        dem.EnableModeless(TRUE);
    }
    else
    {
        dem.DisableModeless();

        // Return an explicit failure here if we couldn't do it.
        // This is needed to ensure that the count does not go
        // out of sync.
        if (!dem._fCallEnableModeless)
            return E_FAIL;
    }
    
    return S_OK;
}


//+------------------------------------------------------------------------
//
//  Member:     CSecurityMgrSite::QueryService
//
//  Synopsis:   per IServiceProvider
//
//-------------------------------------------------------------------------

HRESULT
CSecurityMgrSite::QueryService(REFGUID guidService, REFIID riid, void **ppv)
{
    RRETURN(Doc()->QueryService(guidService, riid, ppv));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\stable.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft IE4/Trident
//
//  Copyright (C) Microsoft Corporation, 1998
//
//  File:       stable.cxx
//
//  Contents:   Implementation of validity/stablity of the tree
//
//  Classes:    CMarkup
//
//  Author:     alexa
//
//----------------------------------------------------------------------------

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

// Right now we don't use the stability code.  I'm sure we will need
// this eventually.
#ifdef MARKUP_STABLE

#ifndef X_ELEMENT_HXX
#define X_ELEMENT_HXX
#include "element.hxx"
#endif

#ifndef X_TREEPOS_HXX
#define X_TREEPOS_HXX
#include "treepos.hxx"
#endif

#if DBG == 1
    char * gs_unstable[] = 
        {
            "No violation - tree/html is stable",
            "Violation of NESTED containers rule",
            "Violation of TEXTSCOPE rule",
            "Violation of OVERLAPING tags rule",
            "Violation of MASKING container rule",
            "Violation of PROHIBITED container rule",
            "Violation of REQUIRED container rule",
            "Violation of IMPLICITCHILD rule",
            "Violation of LITERALTAG rule",
            "Violation of TREE rules",
            "Vialotion of EMPTY TAG rule",
            "Vialotion of the tree pointer rule",
            "Can not determine if stable or not due to the other probelms (OUT_OF_MEMEORY)"
        };
#endif

MtDefine(Stability_aryScopeNodes_pv, Locals, "CRootSite::ValidateParserRules aryScopeNodes::_pv")

//+---------------------------------------------------------------------------
//
//  Member:     CRootSite::IsStable
//
//  Synopsis:   returns TRUE if tree is stable.
//
//----------------------------------------------------------------------------

BOOL CMarkup::IsStable()
{
    if (_fUnstable || Doc()->_lTreeVersion != _lStableTreeVersion)
    {
        // 1. do we have a dirty range/for now do the whole tree
        // 2. Walk the subtree of the dirty range and determine if the tree is stable
        _fUnstable = ValidateParserRules() != UNSTABLE_NOT;
    }
    if (!_fUnstable)
    {
        UpdateStableTreeVersionNumber();
    }
    return !_fUnstable;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRootSite::IsStable
//
//  Synopsis:   Returns TRUE if tree is stable.
//
//----------------------------------------------------------------------------

HRESULT CMarkup::MakeItStable()
{
    HRESULT hr = S_OK;

    if (_fUnstable)
    {
    }

    _fUnstable = FALSE;
    UpdateStableTreeVersionNumber();

    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CRootSite::UpdateStableTreeVersionNumber
//
//  Synopsis:   Update stable tree version number with the new tree version number
//
//+---------------------------------------------------------------------------
void    
CMarkup::UpdateStableTreeVersionNumber()
{
    _lStableTreeVersion = Doc()? Doc()->_lTreeVersion : 1; 
    return; 
}


//+---------------------------------------------------------------------------
//
//  Member:     CRootSite::ValidateParserRules
//
//  Synopsis:   Validate html and tree rules for each element of the tree.
//
//+---------------------------------------------------------------------------

UNSTABLE_CODE 
CMarkup::ValidateParserRules()
{
    CStackPtrAry < CTreeNode *, 8 > aryScopeNodes(Mt(Stability_aryScopeNodes_pv));
    UNSTABLE_CODE   iReturnCode = UNSTABLE_NOT;
    HRESULT         hr = S_OK;
    long            iRun = 0;
    long            cpTotal = 0;
    long            cch = 0;
    CTreeNode     * pNode = NULL;
    CTreeNode     * pNodei;
    CTreeNode     * pNodeConflict = NULL;
    CTreeNode     * pNodeOverlap = NULL;// overlaping node (the first of the 2 overlaping nodes)
    CHtmlParseClass * phpc;
    CHtmlParseClass * phpcOverlap=NULL; // phpc of the overlaping node
    const CTagDesc  * ptd;
    int             i;
    int             cInclusion = 0;     // depth of inclusion (overalping case)
    BOOL            fLiteralTag = FALSE;
    BOOL            fEmptyTag = FALSE;
    ELEMENT_TAG     etagImplicitChild = ETAG_NULL;
    ELEMENT_TAG     etagCurNode;        // tag of the current node
    BOOL            fNeedToValidateTextScope;
    BOOL            fNeedToValidateMasking;
    BOOL            fNeedToValidateProhibited;
    BOOL            fNeedToValidateRequired;
    BOOL            fNeedToCheckBeginContainer;

    // We need to perform the following checking of each element of the tree
    //+---------------------------------------------------------------------------
    // 0. Tree should be stable
    //+---------------------------------------------------------------------------
    // 1. Check if the NESTED RULE is preserved.
    // IF   X is a NESTED element (_scope field of the parseclass is == SCOPE_NESTED)
    //      and Y is NESTED element
    // THEN if there is a position P, where P->X->Y, then for all the other positions
    //      if P'->X it should be also P'->X->Y
    //+---------------------------------------------------------------------------
    // 2. Check if TEXTSCOPE RULE is preserved
    // IF   T is a text (_textScope) or T is textLike (_fTextLike is TRUE)
    // THEN there should be a parent  element X with TEXTSCOPE_INCLUDE
    //      AND all the Y elements between the T and X should be TEXTSCOPE_NEUTRAL
    // ex: T->N->N->I is legal; T->N->E->I is illegal
    //+---------------------------------------------------------------------------
    // 3. Check the ENDCONTAINER RULE is preserved (NO OVERLAPPING relationship between 2 tags)
    // IF   Y is an endcontainer of X
    // THEN if X is inside Y then Y should enclose X completely
    //      else if Y is inside X then X should enclose Y completely
    // ex: <TD><B>...</B></TD> - legal; <TD><B>....</TD></B> - is illegal
    // ex: <B><TD>...</TD></B> - legal; <B><TD>....</B></TD> - is illegal
    //+---------------------------------------------------------------------------
    // 4. Check for MASKING rule.
    // IF   X is masked by Y
    // THEN if X->Y then it should be a B in between X->B->Y , 
    //      where B is a BEGIN container of X (X has to be protected by B)
    // EX: X->(NOT B)->Y is illegal (Y shouldn't be a masking container)
    //+---------------------------------------------------------------------------
    // 5: Check for PROHIBITED containers RULE
    // IF   X has a prohibited container Y
    // THEN X->Y means that there is another container in between X->B->Y
    // EX: <P><P> - is illegal because X->NOT B->Y is illegal , <P><TD><P> - ???
    //+---------------------------------------------------------------------------
    // 6. Check for REQUIRED container
    // IF X has a begin container B (so X->...->B
    // THEN should exists Y (required container of X) in between
    // X->Y->B(or ROOT)
    // EX: TR->TBODY(THEAD,TFOOT)->TABLE
    //+---------------------------------------------------------------------------
    // 7. Check for IMPLICIT CHILD rule.
    // IF   X has implicit child Y
    // THEN the first immediate child of X should be Y
    // ex: HTML-(has IC)->HEAD-(has IC)->TITLE
    //+---------------------------------------------------------------------------
    // 8. Check for LITERALTAG rule
    // IF   X is a literal tag
    // THEN only a TEXT should be it's child
    // ex: <IMG>-><LITERALTAG> - is illegal
    //+---------------------------------------------------------------------------

  if (GetElementClient()->Tag() != ETAG_BODY)   // TODO: remove this when ericvas to checkin.
  {
    goto Conflict;
  }
  else
  {
    CTreePosGap     tpgWalker (FirstTreePos(), TPG_RIGHT, TPG_LEFT);

    tpgWalker.SetMoveDirection(TPG_RIGHT);
    do 
    {
        CTreePos *ptp = tpgWalker.AdjacentTreePos(TPG_LEFT);
        switch( ptp->Type() )
        {
        case CTreePos::NodeBeg:
        case CTreePos::NodeEnd:
            pNode = ptp->Branch();
            if(ptp->IsBeginNode())
            {
                // this is begin node

                // VALIDATE RULE #0: Tree should be stable
                if (!(aryScopeNodes.Size() == 0 || pNode->Parent() == aryScopeNodes[aryScopeNodes.Size() - 1]))
                {
                    Assert (FALSE && "The tree is totaly not safe");
                    iReturnCode = UNSTABLE_TREE;
                    goto Conflict;
                }

                etagCurNode = pNode->Tag();
                phpc = HpcFromEtag(etagCurNode);   // get a parser descriptor of the TAG

                fNeedToValidateTextScope  = (phpc->_texttype == TEXTTYPE_ALWAYS);
                fNeedToValidateMasking = phpc->_atagMaskingContainers != NULL;
                fNeedToValidateProhibited = phpc->_atagProhibitedContainers != NULL;
                fNeedToValidateRequired = phpc->_atagRequiredContainers != NULL;

                for ( pNodei = pNode->Parent();
                      (fNeedToValidateTextScope || fNeedToValidateMasking || fNeedToValidateProhibited || fNeedToValidateRequired) && pNodei;
                      pNodei = pNodei->Parent())                      
                {
                    fNeedToCheckBeginContainer = FALSE;
                    if (fNeedToValidateTextScope)
                    {
                        // VALIDATE RULE #2. Check if TEXTSCOPE RULE is preserved
                        CHtmlParseClass *phpci = HpcFromEtag(pNodei->Tag());
                        if (phpci->_textscope == TEXTSCOPE_INCLUDE)
                        {
                            fNeedToValidateTextScope = FALSE;   // means TEXTSCOPE is valid, there is an TEXTSCOPE_INCLUDE tag above
                        }
                        if (phpci->_textscope == TEXTSCOPE_EXCLUDE)
                        {
                            iReturnCode = UNSTABLE_TEXTSCOPE;
                            goto Conflict;
                        }
                    }
                    if (fNeedToValidateMasking)
                    {
                        // VALIDATE RULE #4: MASKING CONTAINERS RULE
                        if (IsEtagInSet(pNodei->Tag(), phpc->_atagMaskingContainers))
                        {
                            iReturnCode = UNSTABLE_MASKING;
                            pNodeConflict = pNodei;
                            goto Conflict;
                        }
                        fNeedToCheckBeginContainer = TRUE;
                    }
                    if (fNeedToValidateProhibited)
                    {
                        // VALIDATE RULE #5: PROHIBITED CONTAINERS RULE
                        if (IsEtagInSet(pNodei->Tag(), phpc->_atagProhibitedContainers))
                        {
                            iReturnCode = UNSTABLE_PROHIBITED;
                            pNodeConflict = pNodei;
                            goto Conflict;
                        }
                        fNeedToCheckBeginContainer = TRUE;
                    }
                    if (fNeedToValidateRequired)
                    {
                        // VALIDATE RULE #6: REQUIRED CONTAINERS RULE
                        if (IsEtagInSet(pNodei->Tag(), phpc->_atagRequiredContainers))
                        {
                            fNeedToValidateRequired = FALSE;// means REQUIRED rule is validated, there is a required container above
                        }
                        else
                        {
                            fNeedToCheckBeginContainer = TRUE;
                        }
                    }

                    if (fNeedToCheckBeginContainer && IsEtagInSet(pNodei->Tag(), phpc->_atagBeginContainers))
                    {
                        fNeedToValidateMasking = FALSE;     // means MASKING rule is valid, there is a BEGIN container in between
                        fNeedToValidateProhibited = FALSE;  // means PROHIBITED rule is valid, there is a BEGIN container in between
                        if (fNeedToValidateRequired)
                        {
                            iReturnCode = UNSTABLE_REQUIRED;
                            goto Conflict;
                        }
                    }
                }
                if (fNeedToValidateRequired)    // if still we need the required container after searching all the parenets, then
                {
                    iReturnCode = UNSTABLE_REQUIRED;
                    goto Conflict;
                }

                // VALIDATE RULE #7. IMPLICIT CHILD rule.
                if (etagImplicitChild && etagImplicitChild != etagCurNode)
                {
                    iReturnCode = UNSTABLE_IMPLICITCHILD;
                    goto Conflict;
                }

                etagImplicitChild = phpc->_etagImplicitChild;

                // VALIDATE RULE #8. Check for LITERALTAG rule
                if (fLiteralTag)
                {
                    iReturnCode = UNSTABLE_LITERALTAG;
                    goto Conflict;
                }
                ptd = TagDescFromEtag(pNode->Tag());
                fLiteralTag = ptd->HasFlag(TAGDESC_LITERALTAG) && 
                              etagCurNode != ETAG_GENERIC;  // generic tag can be both literal and not (alexz);

                // VALIDATE RULE #9: Empty tags
				if (fEmptyTag)
				{
					iReturnCode = UNSTABLE_EMPTYTAG;
					goto Conflict;
				}

                fEmptyTag = phpc->_scope == SCOPE_EMPTY;

                // this is a new element coming into scope. PUSH it to the aryScopeNodes (stack)
                hr = THR( aryScopeNodes.Append( pNode ) );
                if (hr)
                {
                    iReturnCode = UNSTABLE_CANTDETERMINE;
                    goto Conflict;
                }
                if (!ptp->IsEdgeScope())
                {
                    // this is the proxied branch (overlapping case)
                    Assert (cInclusion);
                    Assert (pNodeOverlap);

                    // VALIDATE RULE #3. (ILLEGAL OVERLAPPING relationship between 2 tags)
                    if (IsEtagInSet(etagCurNode, phpcOverlap->_atagEndContainers) ||
                        IsEtagInSet(pNodeOverlap->Tag(), phpc->_atagEndContainers))
                    {
                        iReturnCode = UNSTABLE_OVERLAPING;
                        goto Conflict;
                    }

                    // VALIDATE RULE #1. Check if the NESTED RULE is preserved.
                    if (phpcOverlap->_scope == SCOPE_NESTED && phpc->_scope == SCOPE_NESTED)
                    {
                        iReturnCode = UNSTABLE_NESTED;
						goto Conflict;
                    }

                    cInclusion--;
                    if (!cInclusion)
                    {
                        pNodeOverlap = NULL;
                        phpcOverlap = NULL;
                    }
                }
            }
            else
            {
                // this is the end node

				if (pNode != aryScopeNodes[aryScopeNodes.Size() - 1])
				{
					iReturnCode = UNSTABLE_TREE;
					goto Conflict;
				}


                if (ptp->IsEdgeScope())
                {
                    // this is the real end of the scope
                    if (cInclusion)
                    {
						Assert (pNodeOverlap == NULL);
                        pNodeOverlap = aryScopeNodes[aryScopeNodes.Size() - 1];
                        phpcOverlap = HpcFromEtag(pNodeOverlap->Tag());
                    }
                }
                else
                {
                    // this is temproary end of the scope (overlapping case)
					if (fLiteralTag)
					{
						iReturnCode = UNSTABLE_LITERALTAG;
						goto Conflict;
					}
					if (fEmptyTag)
					{
						iReturnCode = UNSTABLE_EMPTYTAG;
						goto Conflict;
					}

                    cInclusion++;
					Assert (pNodeOverlap == NULL);
                }

                fLiteralTag = FALSE;
				fEmptyTag = FALSE;

                // this element going out of scope. POP it from the aryScopeNodes (stack)
                aryScopeNodes.Delete(aryScopeNodes.Size() - 1);
            }
            break;
        case CTreePos::Text:
            cch = ptp->Cch();

            // VALIDATE RULE #2. Check if TEXTSCOPE RULE is preserved
            for ( i = aryScopeNodes.Size() - 1 ; cch && i >= 0 ; i-- )
            {
                pNode = aryScopeNodes[ i ];
                phpc = HpcFromEtag(pNode->Tag());
                if (phpc->_textscope == TEXTSCOPE_INCLUDE)
                    break;
                if (phpc->_textscope == TEXTSCOPE_EXCLUDE)
                {
                    iReturnCode = UNSTABLE_TEXTSCOPE;
                    goto Conflict;
                }
            }

            cpTotal += cch;
            iRun++;
            break;
        case CTreePos::Pointer:
            // make sure the tree pointer is not inside inclusion
			if (cInclusion)
			{
				Assert (0 && "We have an illegal tree pointer");
				iReturnCode = UNSTABLE_MARKUPPOINTER;
				goto Conflict;
			}
            break;
        }

        hr = THR_NOTRACE( tpgWalker.Move() );
    }
    while (!hr);

    if (cInclusion)
    {
        Assert (FALSE && "The tree is totaly not safe");
        iReturnCode = UNSTABLE_TREE;
        goto Conflict;
    }

    // TODO: we don't walk past the last element for now, it will change with ericvas checkin
    Assert (aryScopeNodes.Size() == 1 && aryScopeNodes[0]->Tag() == ETAG_BODY);

  }

Conflict:
#ifdef NEVER
#if DBG == 1
    if (iReturnCode)
    {
        AssertSz(0, gs_unstable[iReturnCode]);
    }
#endif
#endif
    return iReturnCode;

}

#endif //MARKUP_STABLE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\sui.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1995
//
//  File:       sui.cxx
//
//  Contents:   Implementation of CServer UI
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_COMMCTRL_H_
#define X_COMMCTRL_H_
#include "commctrl.h"
#endif

#ifndef X_DOCGLBS_HXX_
#define X_DOCGLBS_HXX_
#include "docglbs.hxx"
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx"
#endif

#ifndef X_MSHTMHST_H_
#define X_MSHTMHST_H_
#include "mshtmhst.h"
#endif

#ifndef X_SHELL_H_
#define X_SHELL_H_
#include "shell.h"
#endif

#ifndef X_FRAMESET_HXX_
#define X_FRAMESET_HXX_
#include "frameset.hxx"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_XBAG_HXX_
#define X_XBAG_HXX_
#include "xbag.hxx"
#endif

#ifndef X_FRAMELYT_HXX_
#define X_FRAMELYT_HXX_
#include "framelyt.hxx"
#endif

#ifndef X_HTIFRAME_H_
#define X_HTIFRAME_H_
#include <htiframe.h>
#endif

#ifndef X_ROOTELEM_HXX_
#define X_ROOTELEM_HXX_
#include "rootelem.hxx"
#endif

#ifndef X_EVNTPRM_HXX_
#define X_EVNTPRM_HXX_
#include "evntprm.hxx"
#endif

#include "eventobj.h"

#ifndef NO_IME
extern HRESULT DeactivateDIMM(); // imm32.cxx
#endif // ndef NO_IME

#if DBG == 1
#define MAXLABELLEN 32

static HMENU hMenuHelp;

//+---------------------------------------------------------------
//
//  Member:     CDoc::InsertSharedMenus
//
//  Synopsis:   Inserts the objects menus into a shared menu after
//              the top-level application has inserted its menus
//
//  Arguments:  [hmenuShared] -- the shared menu to recieve the objects menus
//              [hmenuObject] -- all of the objects menus
//              [lpmgw] -- menu group widths indicating where the menus
//                          should be inserted
//              [lOffset] -- Server position offset for hmenuObject
//
//  Returns:    Success if the menus were merged successfully
//
//  Notes:      The function does most of the shared menu work
//              by the object between the IOleInPlaceFrame::InsertMenus and
//              IOleInPlaceFrame::SetMenu method calls.
//              c.f. RemoveServerMenus
//
//----------------------------------------------------------------

HRESULT
CDoc::InsertSharedMenus(
        HMENU hmenuShared,
        HMENU hmenuObject,
        LPOLEMENUGROUPWIDTHS lpmgw)
{
    int i, j;
    UINT SvrPos, ShdPos;
    HMENU hmenuXfer;
    TCHAR szLabel[MAXLABELLEN];

    SvrPos = 0;
    ShdPos = 0;

    // for each of the Edit, Object, and Help menu groups
    for (j = 1; j <= 5; j += 2)
    {
        // advance over container menus
        ShdPos += (UINT)lpmgw->width[j-1];

        // special consideration for j = 5 because of
        // DocObject HELP menu merging.

        if (j == 5)
        {
            if (lpmgw->width[j] != 0)
            {
                BOOL    fHide = FALSE;

                // check if host want hide our help menu,
                if (_pHostUIHandler &&
                    (_dwFlagsHostInfo & DOCHOSTUIFLAG_DISABLE_HELP_MENU))
                {
                    fHide = TRUE;
                }

                if (!fHide)
                {
                    GetMenuString(
                                hmenuObject,
                                ++SvrPos,
                                szLabel,
                                MAXLABELLEN,
                                MF_BYPOSITION);

                    hMenuHelp = GetSubMenu(hmenuShared, ShdPos);
                    hmenuXfer = GetSubMenu(hmenuObject, SvrPos);
                    if (!AppendMenu(
                            hMenuHelp,
                            MF_POPUP | MF_STRING,
                            (UINT_PTR) hmenuXfer,
                            szLabel))
                    {
                        return HRESULT_FROM_WIN32(GetLastError());
                    }
                }

                lpmgw->width[j - 1] += lpmgw->width[j];
                lpmgw->width[j]      = 0;
                continue;
            }
            else
            {
                // no HELP menu in the container
                //
                hMenuHelp = NULL;
                lpmgw->width[j] = 1;
            }
        }

        // pull out the popup menus from servers menu
        for (i = 0; i < lpmgw->width[j]; i++)
        {
            GetMenuString(hmenuObject,
                    SvrPos,
                    szLabel,
                    MAXLABELLEN,
                    MF_BYPOSITION);
            hmenuXfer = GetSubMenu(hmenuObject, SvrPos++);
            if (!InsertMenu(hmenuShared,
                        ShdPos++,
                        MF_BYPOSITION | MF_POPUP | MF_STRING,
                        (UINT_PTR)hmenuXfer,
                        szLabel))
            {
                return HRESULT_FROM_WIN32(GetLastError());
            }
        }
    }
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     CDoc::RemoveSharedMenus
//
//  Synopsis:   Removes the objects menus from a shared menu
//
//  Arguments:  [hmenuShared] -- the menu contain both the application's
//                              and the object's menus
//              [lpmgw] -- menu group widths indicating which menus should
//                          be removed
//
//  Notes:      c.f. InsertServerMenus
//
//----------------------------------------------------------------

void
CDoc::RemoveSharedMenus(HMENU hmenuShared, LPOLEMENUGROUPWIDTHS lpmgw)
{
    int i, j;
    UINT ShdPos;

    ShdPos = 0;

    if (hMenuHelp)
    {
        // remove the Object part of the merged HELP menu
        //
        RemoveMenu(hMenuHelp, GetMenuItemCount(hMenuHelp) - 1, MF_BYPOSITION);
    }

    // for each of the Edit, Object, and Help menu groups
    for (j = 1; j <= 5; j += 2)
    {
        // advance over container menus
        ShdPos += (UINT)lpmgw->width[j-1];

        // pull out the popup menus from shared menu
        for (i = 0; i < lpmgw->width[j]; i++)
        {
            RemoveMenu(hmenuShared, ShdPos, MF_BYPOSITION);
        }
    }

    return;
}


//+---------------------------------------------------------------
//
//  Member:     CDoc::CreateMenuUI
//
//  Synopsis:   Creates menu UI elements using menu specified
//              in class descriptor.
//
//---------------------------------------------------------------


HRESULT
CDoc::CreateMenuUI()
{
    HRESULT             hr = S_OK;
#ifndef NO_OLEUI
    HMENU               hmenu;
    HMENU               hmenuShared;
    OLEMENUGROUPWIDTHS *pmgw;

    Assert(InPlace());

    //  We ignore any failures; a failure just means some part of
    //    the UI won't appear.

    Assert((InPlace()->_hmenuShared) == NULL);
    Assert((InPlace()->_hmenu) == NULL);

    pmgw = &(InPlace()->_mgw);

    if (DesignMode())
    {
        hmenu = TFAIL_NOTRACE(0, LoadMenu(
                GetResourceHInst(),
                MAKEINTRESOURCE(IDR_HTMLFORM_MENUDESIGN)));
        *pmgw = s_amgw[0];
    }
    else
    {
        hmenu = TFAIL_NOTRACE(0, LoadMenu(
                GetResourceHInst(),
                MAKEINTRESOURCE(IDR_HTMLFORM_MENURUN)));
#if 0
        // Note: this will go away with BeomOh's com work
        extern HMENU CreateMimeCSetMenu();

        // Dynamic adding language menu
        if (hmenu)
        {
            // Get "View" menu
            HMENU hmenuView = GetSubMenu(hmenu, 1);

            // Consider: Write a wrapper for SetMenuItemInfo.  We are using
            //  SetMenuItemInfo directly since we never need to set the one
            //  LPTSTR member of the MENUITEMINFO structure.
            MENUITEMINFO mii;

            mii.cbSize = sizeof(mii);
            mii.fMask  = MIIM_SUBMENU;
            mii.hSubMenu = CreateMimeCSetMenu();
            SetMenuItemInfo(hmenuView, IDM_LANGUAGE, FALSE, &mii);
        }
#endif
        *pmgw = s_amgw[1];
    }
    if (!hmenu)
        goto Cleanup;

    hmenuShared = TFAIL(0, CreateMenu());
    if (!hmenuShared)
        goto Cleanup;

    hr = THR(InPlace()->_pFrame->InsertMenus(hmenuShared, pmgw));
    if (hr)
        goto Cleanup;

    hr = THR(InsertSharedMenus(hmenuShared, hmenu, pmgw));
    if (hr)
        goto Cleanup;

    InPlace()->_hmenu = hmenu;
    InPlace()->_hmenuShared = hmenuShared;
    InPlace()->_hOleMenu = OleCreateMenuDescriptor(hmenuShared, pmgw);

Cleanup:
#endif // NO_OLEUI
    RRETURN(hr);
}


//+---------------------------------------------------------------
//
//  Member:     CDoc::DestroyMenuUI, protected
//
//  Synopsis:   This method "undoes" everything that was done in
//              CreateMenuUI -- destroys the shared menu and OLE menu
//              descriptor.
//---------------------------------------------------------------

void
CDoc::DestroyMenuUI(void)
{
#ifndef NO_OLEUI
    Assert(InPlace());

    if (InPlace()->_hmenuShared)
    {
        HMENU hmenu = InPlace()->_hmenuShared;

        RemoveSharedMenus(hmenu, &InPlace()->_mgw);
        InPlace()->_pFrame->RemoveMenus(hmenu);
        DestroyMenu(hmenu);
        InPlace()->_hmenuShared = NULL;
    }

    if (InPlace()->_hmenu)
    {
        DestroyMenu(InPlace()->_hmenu);
        InPlace()->_hmenu = NULL;
    }
    if (InPlace()->_hOleMenu)
    {
        OleDestroyMenuDescriptor(InPlace()->_hOleMenu);
        InPlace()->_hOleMenu = NULL;
    }
#endif // NO_OLEUI
}


//+---------------------------------------------------------------
//
//  Member:     CDoc::InstallMenuUI, protected
//
//  Synopsis:   This method uses IOleInPlaceFrame::SetMenu to
//              install the shared menu constructed in CreateMenuUI.
//
//---------------------------------------------------------------

HRESULT
CDoc::InstallMenuUI()
{
#ifdef NO_OLEUI
    return S_OK;
#else
    // Ignore spurious WM_ERASEBACKGROUNDs generated by SetMenu
    CLock   Lock(this, SERVERLOCK_IGNOREERASEBKGND);
    HRESULT hr;

    if (!InPlace()->_hOleMenu)
    {
        hr = CreateMenuUI();
        if (hr)
            goto Cleanup;
    }

    hr = THR(InPlace()->_pFrame->SetMenu(
            InPlace()->_hmenuShared,
            InPlace()->_hOleMenu,
            InPlace()->_hwnd));
    if (hr)
        goto Cleanup;

    InPlace()->_fMenusMerged = 1;

Cleanup:
    RRETURN(hr);
#endif // NO_OLEUI
}

//+-------------------------------------------------------------------
//
//  Window Procedure: ComboWndProc
//
//  Synopsis:
//
//--------------------------------------------------------------------

#if defined(DBG_TOOLTIPS)

static WNDPROC lpfnDefCombo;

LRESULT CALLBACK
ComboWndProc(HWND hWnd,
             UINT uMessage,
             WPARAM wParam,
             LPARAM lParam)
{
    MSG        msg;
    HWND       hwndTooltip;

    switch (uMessage)
    {
    case WM_MOUSEMOVE :
    case WM_LBUTTONDOWN :
    case WM_LBUTTONUP :
        msg.lParam  = lParam;
        msg.wParam  = wParam;
        msg.message = uMessage;
        msg.hwnd    = hWnd;
        hwndTooltip = (HWND) SendMessage(GetParent(hWnd), TB_GETTOOLTIPS, 0, 0);
        SendMessage(hwndTooltip, TTM_RELAYEVENT, 0, (LPARAM)(LPMSG)&msg);
        break;

    case WM_CHAR:
        // Don't allow the user to type anything into the combo
        return 0;
    }
    return CallWindowProc(lpfnDefCombo, hWnd, uMessage, wParam, lParam);
}

#endif

//+-------------------------------------------------------------------
//
// Local Helper Function: InstallComboboxTooltip
//
//--------------------------------------------------------------------

#if defined(DBG_TOOLTIPS)

void InstallComboboxTooltip(HWND hwndCombo, UINT IDMmessage)
{
    HWND     hwndTooltip;
    TOOLINFO tbToolInfo;

    hwndTooltip = (HWND) SendMessage(
            GetParent(hwndCombo),
            TB_GETTOOLTIPS,
            0,
            0);

    SetWindowLongPtr(hwndCombo, GWLP_WNDPROC, (LONG_PTR)ComboWndProc);

    tbToolInfo.cbSize   = sizeof(TOOLINFO);
    tbToolInfo.uFlags   = TTF_IDISHWND;
    tbToolInfo.hwnd     = GetParent(hwndCombo);
    tbToolInfo.uId      = (UINT) hwndCombo;
    tbToolInfo.hinst    = 0;

#ifndef WINCE
    DWORD dwVersion = GetVersion();
#else
    DWORD dwVersion = 0;
#endif

#ifdef WIN16
    // BUGWIN16: something different for Win16 ??
    // vamshi - 1/24/97
#else
    tbToolInfo.lpszText = (dwVersion < 0x80000000) ?
            ((LPTSTR) LPSTR_TEXTCALLBACKW) : ((LPTSTR) LPSTR_TEXTCALLBACKA);
    SendMessage(
            hwndTooltip,
            (dwVersion < 0x80000000) ? (TTM_ADDTOOLW) : (TTM_ADDTOOLA),
            0,
            (LPARAM)(LPTOOLINFO)&tbToolInfo);
#endif
}

#endif

//+-------------------------------------------------------------------
//
//  Callback:   FillFontProc
//
//  This procedure is called by the EnumFontFamilies call.
//  It fills the combobox with the font facename.
//
//--------------------------------------------------------------------

int CALLBACK
FillFontProc(LOGFONT FAR *    lplf,
             TEXTMETRIC FAR * lptm,
             int              iFontType,
             LPARAM           lParam)
{
    int  fontStyle[3];
    char szFontName[128];

    // We don't want to list the vertical fonts.
    // These by convention start with an @ symbol.
    if (lplf->lfFaceName[0] == L'@')
        return TRUE;

    fontStyle[0] = (lplf->lfWeight == FW_BOLD) ? (1) : (0);
    fontStyle[1] = (lplf->lfItalic == TRUE)    ? (1) : (0);
    fontStyle[2] = (lplf->lfUnderline == TRUE) ? (1) : (0);
    WideCharToMultiByte(
            CP_ACP,
            0,
            (const WCHAR *) lplf->lfFaceName,
            -1,
            szFontName,
            ARRAY_SIZE(szFontName),
            NULL,
            NULL);
    if (CB_ERR == (WPARAM) SendMessage((HWND) lParam,CB_FINDSTRING,
                  (WPARAM) -1,(LPARAM)(lplf->lfFaceName)))
    {
        SendMessage((HWND)lParam,CB_ADDSTRING,
                    (WPARAM) 0,(LPARAM)(lplf->lfFaceName));
    }
    return TRUE;
}

//+-------------------------------------------------------------------
//
// Local Helper Functions: AddComboboxItems, ConvColorrefToString
//
//--------------------------------------------------------------------

struct ComboItem {
        INT     iIdm;
        LONG    lData;
};

static const ComboItem ComboColorItems[] =
{
    {IDS_COLOR_BLACK,      RGB(0, 0, 0)},
    {IDS_COLOR_NAVY,       RGB(0, 0, 128)},
    {IDS_COLOR_BLUE,       RGB(0, 0, 255)},
    {IDS_COLOR_CYAN,       RGB(0, 255, 255)},
    {IDS_COLOR_RED,        RGB(255, 0, 0)},
    {IDS_COLOR_LIME,       RGB(0, 255, 0)},
    {IDS_COLOR_GRAY,       RGB(128, 128, 128)},
    {IDS_COLOR_GREEN,      RGB(0, 128, 0)},
    {IDS_COLOR_YELLOW,     RGB(255, 255, 0)},
    {IDS_COLOR_PINK,       RGB(255, 192, 203)},
    {IDS_COLOR_VIOLET,     RGB(238, 130, 238)},
    {IDS_COLOR_WHITE,      RGB(255, 255, 255)},
    {0, 0L}
};


void ConvColorrefToString(COLORREF crColor, LPTSTR szName, int cchName )
{
    int     i;
    BOOL fFound = FALSE;

    if(crColor == (COLORREF)-1)
    {
        szName[0] = 0;
        return;
    }

    // Reset the upper 8 bits because palettergb type color values have them
    // set to 0x20 and the compare will fail
    crColor &= 0xFFFFFF;

    for(i = 0; ComboColorItems[i].iIdm != 0; i++)
    {
        if(ComboColorItems[i].lData == (LONG)crColor)  {
            fFound = TRUE;
            break;
        }
    }

    if(fFound)
        Format(0, szName, cchName, MAKEINTRESOURCE(ComboColorItems[i].iIdm));
    else
        szName[0] = 0;
}


DWORD AddComboboxItems(HWND hwndCombo,
                       BOOL fItemData,
                       const ComboItem * pComboItems)
{
    DWORD   dwIndex = 0;
    TCHAR   achColor[128];

    while(pComboItems->iIdm)
    {
        Format(0, achColor, ARRAY_SIZE(achColor),
                  MAKEINTRESOURCE(pComboItems->iIdm));

        dwIndex = SendMessage(
                hwndCombo,
                CB_ADDSTRING,
                0,
                (LPARAM) achColor);
        if (fItemData)
        {
            SendMessage(
                    hwndCombo,
                    CB_SETITEMDATA,
                    dwIndex,
                    (LPARAM) pComboItems->lData);
        }
        pComboItems ++;
    }
    return dwIndex;
}
#endif // DBG == 1

//+---------------------------------------------------------------
//
//  Member:     CDoc::OnFrameWindowActivate, IOleInPlaceActiveObject
//
//  Synopsis:   Method of IOleInPlaceObject interface
//
//---------------------------------------------------------------

HRESULT
CDoc::OnFrameWindowActivate(BOOL fActivate)
{  
    if (_pHostUIHandler)
    {
        _pHostUIHandler->OnFrameWindowActivate(fActivate);
    }

    if (_fIsPrintWithNoUI)
        return S_OK;

    return super::OnFrameWindowActivate(fActivate);
}


//+---------------------------------------------------------------
//
//  Member:     CDoc::OnDocWindowActivate, IOleInPlaceActiveObject
//
//  Synopsis:   Method of IOleInPlaceObject interface
//
//  Notes:      This method will install or remove the frame
//              U.I. elements using the InstallFrameUI or RemoveFrameUI
//              methods.  This is to properly handle the MDI application
//              case.  It also updates our shading color.
//
//---------------------------------------------------------------

HRESULT
CDoc::OnDocWindowActivate(BOOL fActivate)
{
    if (_pHostUIHandler)
    {
        _pHostUIHandler->OnDocWindowActivate(fActivate);
    }

    return super::OnDocWindowActivate(fActivate);

}


//+---------------------------------------------------------------
//
//  Member:     CDoc::ResizeBorder, IOleInPlaceActiveObject
//
//  Synopsis:   Handle border space change.
//
//---------------------------------------------------------------

HRESULT
CDoc::ResizeBorder(
        LPCOLERECT prc,
        LPOLEINPLACEUIWINDOW pUIWindow,
        BOOL fFrameWindow)
{
    HRESULT hr = S_OK;

    if (!_pInPlace)
        return S_OK;

    if(InPlace()->_fHostShowUI)
    {
        Assert(_pHostUIHandler);
        _pHostUIHandler->ResizeBorder((RECT *)prc, pUIWindow, fFrameWindow); //RECT * is for win16. doesn't affect 32bit.
        return S_OK;
    }

    RRETURN_NOTRACE(hr);
}


//+---------------------------------------------------------------
//
//  Member:     CDoc::EnableModeless, IOleInPlaceActiveObject
//
//  Synopsis:   Method of IOleInPlaceObject interface
//
//---------------------------------------------------------------
HRESULT
CDoc::EnableModeless(BOOL fEnable)
{
    return EnableModelessImpl(fEnable, FALSE, FALSE);
}

HRESULT
CDoc::EnableModelessImpl(BOOL fEnable, BOOL fLocalDisable, BOOL fBottomUp)
{
    // NOTE: (jbeda)
    // When hosted in shdocvw in the IE5.0 scenario, 
    // all navigation is prevented when the host does 
    // an EnableModeless(FALSE).  We do the same
    // thing by using a CDoc flag instead of
    // broadcasting down to each individual window

    // We don't need to set/rest the CDoc block if our call originate from Trident
    // However, if Trident does not have a context fInside is false, so we know we
    // are from Trident if we are bottom up.

    if (!fBottomUp)
    {
        if (fEnable)
        {
            _fDisableModeless = FALSE;
        }
        else
        {
            _fDisableModeless = TRUE;
        }
    }

    // Despite being from Trident we may not have a context
    if (!fLocalDisable && fBottomUp)
    { 
        if (fEnable)
            _ulDisableModeless--;
        else
            _ulDisableModeless++;
    }


    if(_pHostUIHandler)
    {
        _pHostUIHandler->EnableModeless(fEnable);
    }

    if (_pIHTMLEditor)
    {
        _pIHTMLEditor->EnableModeless(fEnable);
    }
    
    // This is just a hack for PumpMessageHelper(0 to know
    // if a modal dialog has been brought in an event handler.
    // The flag is cleared by PumpMessageHelper().
    if (!fEnable)
        _fModalDialogInScript = TRUE;

    if (!fLocalDisable && !_fDisableModeless && _ulDisableModeless == 0)
    {
        NotifyMarkupsModelessEnable();
    }

    return S_OK;
}


//+---------------------------------------------------------------
//
//  Member:     CDoEnableModeless::CDoEnableModeless
//
//  Synopsis:   ctor of object which wraps enable modeless 
//              functionality.
//
//---------------------------------------------------------------

CDoEnableModeless::CDoEnableModeless(CDoc * pDoc, CWindow * pWindow, BOOL fAuto)
{
    _pWindow = pWindow;
    _pDoc = pDoc;
    _fCallEnableModeless = FALSE;
    _fAuto = FALSE;

    if (!_pDoc)
        return;

    if (fAuto)
    {
        if ((pWindow && pWindow->CanNavigate()) || 
            (!pDoc->_fDisableModeless && (pDoc->_ulDisableModeless == 0)))
        {
            _fAuto = TRUE;
            DisableModeless();
        }
        else
        {
            _hwnd = _pDoc->GetHWND();
            if (!_hwnd)
            {
                IOleWindow *pOleWindow = NULL;

                if (_pDoc->_pClientSite && !_pDoc->_pClientSite->QueryInterface(
                        IID_IOleWindow, (void **)&pOleWindow))
                {
                    IGNORE_HR(pOleWindow->GetWindow(&_hwnd));
                }

                ReleaseInterface(pOleWindow);
            }
        }
    }
}


//+---------------------------------------------------------------
//
//  Member:     CDoEnableModeless::~CDoEnableModeless
//
//  Synopsis:   dtor
//
//---------------------------------------------------------------

CDoEnableModeless::~CDoEnableModeless()
{
    if (_fAuto)
    {
        EnableModeless();
    }
}


//+---------------------------------------------------------------
//
//  Member:     CDoEnableModeless::DisableModeless
//
//  Synopsis:   Worker which goes about disabling modeless.
//              Sets state on whether or not EnableModeless does
//              any work.
//
//---------------------------------------------------------------

void
CDoEnableModeless::DisableModeless()
{
    IOleWindow *    pOleWindow = NULL;

    if (_pDoc->_state >= OS_INPLACE)
    {
        // If we're not interactive yet, we should be.
        _pDoc->PrimaryMarkup()->OnLoadStatus(LOADSTATUS_INTERACTIVE);
    }

    // if we have a _pWindow, then do that window and up
    // othwerwise disable the entire doc
    _pDoc->EnableModelessImpl(FALSE, !!_pWindow, TRUE);
    if (_pWindow)
        _pWindow->EnableModelessUp(FALSE);

    if (_pDoc->_pInPlace && _pDoc->_pInPlace->_pFrame)
    {
        _fCallEnableModeless = TRUE;
        _pDoc->_pInPlace->_pFrame->EnableModeless(FALSE);
    }

    _hwnd = _pDoc->GetHWND();
    if (!_hwnd)
    {
        if (_pDoc->_pClientSite && !_pDoc->_pClientSite->QueryInterface(
                IID_IOleWindow, (void **)&pOleWindow))
        {
            IGNORE_HR(pOleWindow->GetWindow(&_hwnd));
        }
    }

    _pDoc->SetCapture(FALSE);

    ReleaseInterface(pOleWindow);
}


//+---------------------------------------------------------------
//
//  Member:     CDoEnableModeless::EnableModeless
//
//  Synopsis:   Worker which does opposite of DisableModeless
//
//---------------------------------------------------------------

void
CDoEnableModeless::EnableModeless(BOOL fForce)
{
    _pDoc->EnableModelessImpl(TRUE, !!_pWindow, TRUE);
    if (_pWindow)
        _pWindow->EnableModelessUp(TRUE);
    if (_fCallEnableModeless || fForce)
    {
        if (_pDoc->_pInPlace && _pDoc->_pInPlace->_pFrame)
        {
            _pDoc->_pInPlace->_pFrame->EnableModeless(TRUE);
        }
    }
}


//+-------------------------------------------------------------------------
//
//  Method:     CDoc::ShowMessage/ShowMessageV
//
//  Synopsis:   Show display a message box to the user.
//
//  Arguments:  pnResult      Return result per Windows MessageBox. Can be null.
//              dwFlags       Flags taken from the Windows MB_ enumeration.
//              dwHelpContext Help context in Forms^3 help file
//              idsMessage    String id of message. Use null terminator in
//                            message to separate message parts (bold/norma).
//
//--------------------------------------------------------------------------

HRESULT __cdecl
CDoc::ShowMessage(        
        int * pnResult,
        DWORD dwFlags,
        DWORD dwHelpContext,
        UINT  idsMessage, ...) 
{
    HRESULT hr;
    va_list arg;

    va_start(arg, idsMessage);
    hr = THR(ShowMessageV(pnResult, dwFlags, dwHelpContext, idsMessage, &arg));
    va_end(arg);
    RRETURN(hr);
}

HRESULT
CDoc::ShowMessageV(      
        int *pnResult,
        DWORD dwFlags,
        DWORD dwHelpContext,
        UINT idsMessage,
        void *pvArgs)    
{
    HRESULT hr = S_OK;
    TCHAR * pch = NULL;

    if (THR(VFormat(FMT_OUT_ALLOC,
            &pch,
            0,
            MAKEINTRESOURCE(idsMessage),
            pvArgs)))                
        goto Cleanup;

    hr = THR(ShowMessageEx(            
            pnResult,
            dwFlags,
            GetFormsHelpFile(),
            dwHelpContext,
            pch));          

Cleanup:
    delete [] pch;
    RRETURN(hr);
}

//+-------------------------------------------------------------------------
//
//  Method:     CDoc::ShowMessageEx
//
//  Synopsis:   Show a message to the user. This is a helper function
//              for ShowMessage, ShowMessageV, and DisplayLastError.
//              We first query the IDocHostUIHandler, if that fails,
//              we make an Exec call on the host, if that fails,
//              we make an Exec call on the backup shdocvw.              
//             
//--------------------------------------------------------------------------

HRESULT
CDoc::ShowMessageEx(       
        int   *     pnResult,
        DWORD       dwStyle,
        TCHAR *     pchHelpFile,
        DWORD       dwHelpContext,
        TCHAR *     pchText)       
{       
    int                 nResult = 0;
    HWND                hwnd = NULL;          
    IOleCommandTarget * pBackupUICommandHandler = NULL;           
    TCHAR             * pchCaption = NULL;
    EVENTPARAM          param(this, NULL, NULL, TRUE);
    VARIANT             varIn, varOut;
    
    // TODO: (jbeda) window context would be good here
    CDoEnableModeless   dem(this, NULL);
    
    //
    // TODO: allowing alert in popup might cause hang
    // however, since some stability work has been done
    // in the popup, this is allowed again
    //
#ifdef  NEVER

    if (_fPopupDoc)
    {
        //
        // dismiss popup if this is a popup doc
        //
        IGNORE_HR(DoVerb(OLEIVERB_HIDE,
                                    NULL,
                                    _pClientSite,
                                    0,
                                    NULL,
                                    NULL));
    }
#endif

    hwnd = dem._hwnd;
    if (hwnd)                   
        MakeThisTopBrowserInProcess(hwnd);
    
    if (Format(FMT_OUT_ALLOC, &pchCaption, 0, MAKEINTRESOURCE(IDS_MESSAGE_BOX_TITLE)))
        goto Cleanup;             

    // See if the IDocHostShowUI interface is implemented
    if (InPlace() && InPlace()->_pHostShowUI)
    {         
        if (!InPlace()->_pHostShowUI->ShowMessage(
                _pInPlace->_hwnd,
                pchText,
                pchCaption,
                dwStyle,
                pchHelpFile,
                dwHelpContext,
                (LRESULT *)&nResult))             
            goto Cleanup;
    }

    // Fill out expandos
    param.SetType(_T("message"));
    param.messageParams.pchMessageText          = pchText;
    param.messageParams.pchMessageCaption       = pchCaption;
    param.messageParams.dwMessageStyle          = dwStyle;
    param.messageParams.pchMessageHelpFile      = pchHelpFile;   
    param.messageParams.dwMessageHelpContext    = dwHelpContext;                            

    V_VT(&varIn) = VT_UNKNOWN;
    V_UNKNOWN(&varIn) = (IUnknown*)(IPrivateUnknown *)this;

    // Query the host to handle showing the message
    if (_pHostUICommandHandler && !_fOutlook98)
    {        
         // If host displayed message box, Forms3 will not display its own.
        if (!_pHostUICommandHandler->Exec(
                &CGID_DocHostCommandHandler, 
                OLECMDID_SHOWMESSAGE, 
                0, 
                &varIn,
                &varOut))
        {
            nResult = V_I4(&varOut);
            goto Cleanup;        
        }
    }
              
    // Let backup show the message          
    EnsureBackupUIHandler();
    if (!_pBackupHostUIHandler)                            
        goto Cleanup;       
                        
    if (_pBackupHostUIHandler->QueryInterface(IID_IOleCommandTarget,
            (void **) &pBackupUICommandHandler))  
        goto Cleanup;                               
    
    if (!THR(pBackupUICommandHandler->Exec(
            &CGID_DocHostCommandHandler,         
            OLECMDID_SHOWMESSAGE,         
            0,         
            &varIn,        
            &varOut)))
        nResult = V_I4(&varOut);
                                                                                           
Cleanup:
    if (pnResult)            
        *pnResult = nResult;
    
    ReleaseInterface(pBackupUICommandHandler);  

    MemFreeString(pchCaption);

    RRETURN (S_OK);
}

//+-------------------------------------------------------------------------
//
//  Method:     CDoc::ShowLastErrorInfo
//
//  Synopsis:   Show the current error object.
//
//--------------------------------------------------------------------------

HRESULT
CDoc::ShowLastErrorInfo(HRESULT hrError, int idsDefault)
{
    if (OK(hrError))
        return S_OK;

    HRESULT      hr;
    IErrorInfo * pErrorInfo = NULL;
    CErrorInfo * pEI;
    BSTR         bstrDescription = NULL;
    BSTR         bstrSolution = NULL;
    BSTR         bstrHelpFile = NULL;
    BSTR         bstrSource = NULL;
    TCHAR *      pchSolution = NULL;
    TCHAR *      pchDescription = NULL;
    DWORD        dwHelpContext = 0;
    TCHAR *      pch = NULL;
    TCHAR *      pchText = NULL;   

    hr = THR(::GetErrorInfo(0, &pErrorInfo));
    if (hr)
        goto Cleanup;

    hr = THR_NOTRACE(pErrorInfo->QueryInterface(
            CLSID_CErrorInfo,
            (void **)&pEI));
    if (OK(hr))
    {
        hr = THR(pEI->GetDescriptionEx(
                &bstrDescription,
                &bstrSolution));
        if (hr)
            goto Cleanup;

        if (bstrSolution)
        {
            hr = THR(Format(FMT_OUT_ALLOC, &pchSolution, 0,
                    MAKEINTRESOURCE(IDS_ERROR_SOLUTION), bstrSolution));
            if (hr)
                goto Cleanup;
        }
    }
    else
    {
        hr = THR(pErrorInfo->GetDescription(&bstrDescription));
        if (hr)
            goto Cleanup;
    }

    if (!bstrDescription)
    {
        // we got no default text, therefore we will use
        // a standard error text, passed in iIDSDefault
        // that fixes the allpage
        // propertysettings (bug6525).
        Assert(idsDefault);

        hr = THR(Format(FMT_OUT_ALLOC, &pchDescription, 0,
                    MAKEINTRESOURCE(idsDefault), bstrSolution));

        if (hr)
            goto Cleanup;
    }


    THR_NOTRACE(pErrorInfo->GetHelpFile(&bstrHelpFile));
    THR_NOTRACE(pErrorInfo->GetHelpContext(&dwHelpContext));
    THR_NOTRACE(pErrorInfo->GetSource(&bstrSource));

    // Glue header and body together for message box.

    pchText = bstrDescription? bstrDescription : pchDescription;

    if (pchSolution)
    {
        hr = THR(Format(FMT_OUT_ALLOC,
                &pch,
                0,
                TEXT("<0s>\n\n<1s>"), pchText, pchSolution));
        if (hr)
            goto Cleanup;
        pchText = pch;
    }

    hr = THR(ShowMessageEx(NULL,
            MB_ICONEXCLAMATION | MB_OK,
            bstrHelpFile,
            dwHelpContext,
            pchText));            

Cleanup:

    delete pchSolution;
    delete pchDescription;
    delete pch;

    FormsFreeString(bstrSolution);
    FormsFreeString(bstrDescription);
    FormsFreeString(bstrHelpFile);
    FormsFreeString(bstrSource);

    ReleaseInterface(pErrorInfo);

    RRETURN1(hr, S_FALSE);   
}

//+-------------------------------------------------------------------------
//
//  Method:     CDoc::ShowHelp
//
//  Synopsis:   Show help to the user.
//
//--------------------------------------------------------------------------

HRESULT
CDoc::ShowHelp(TCHAR * szHelpFile, DWORD dwData, UINT uCmd, POINT pt)
{
    HRESULT             hr;
    IDispatch *         pDispatch = NULL;

    if (InPlace() && InPlace()->_pHostShowUI)
    {
        hr = QueryInterface(
                IID_IDispatch,
                (void **) &pDispatch);
        if (hr)
            goto Cleanup;

        hr = InPlace()->_pHostShowUI->ShowHelp(
                _pInPlace->_hwnd,
                szHelpFile,
                uCmd,
                dwData,
                pt,
                pDispatch);

        // If host displayed help, we will not display our own.
        if (!hr)
            goto Cleanup;
    }

    if (szHelpFile)
    {
        // TODO: Temporary fix for beta1 to append window style.
        // Append ">LangRef"
        _tcscat(szHelpFile, _T(">LangRef"));
        if (WinHelp(TLS(gwnd.hwndGlobalWindow), szHelpFile, uCmd, dwData))
            hr = S_OK;                        
        else
            hr = E_FAIL;               
    }
    else
        hr = E_NOTIMPL;

Cleanup:
    ReleaseInterface(pDispatch);
    RRETURN(hr);
}

//+---------------------------------------------------------------
//
//  Function:   InvalidateBorder
//
//  Synopsis:   Invalidates the 1 pixel border which is drawn
//              around frames
//
//---------------------------------------------------------------

static void
InvalidateBorder(CDoc *pDoc)
{
    if ((pDoc->PrimaryMarkup()->GetFrameOptions() & FRAMEOPTIONS_NO3DBORDER) == 0 &&
        (pDoc->_dwFlagsHostInfo  & DOCHOSTUIFLAG_NO3DBORDER) == 0)
    {
        // invalidate a 4 pixel-wide area at the perimeter
        // of the rect

        long    cBorder =   CFrameSetSite::iPixelFrameHighlightWidth  +
                            CFrameSetSite::iPixelFrameHighlightBuffer + 1;

        if (cBorder > 1)
        {
            pDoc->GetView()->InvalidateBorder(cBorder);
        }
    }
}


//+---------------------------------------------------------------
//
//  Member:     CDoc::InstallFrameUI, CServer
//
//  Synopsis:   Installs the U.I. elements on the frame window.
//              This function assumes the server has does not
//              have any UI.  Derived classes should override
//              to provide their own UI.
//
//---------------------------------------------------------------

#ifndef NO_OLEUI
HRESULT
CDoc::InstallFrameUI()
{
    HRESULT hr = S_OK;
    IOleCommandTarget * pCommandTarget = NULL;
    IOleInPlaceActiveObject * pInPlaceActiveObject = NULL;

    Assert(InPlace());
    if(_pHostUIHandler)
    {
        hr = THR(PrivateQueryInterface(IID_IOleCommandTarget, (void **) &pCommandTarget));
        if (hr)
            goto Cleanup;

        hr = THR(PrivateQueryInterface(IID_IOleInPlaceActiveObject, (void **)&pInPlaceActiveObject));
        if (hr)
            goto Cleanup;

        hr = _pHostUIHandler->ShowUI(
                DesignMode() ? DOCHOSTUITYPE_AUTHOR : DOCHOSTUITYPE_BROWSE,
                pInPlaceActiveObject,
                pCommandTarget,
                InPlace()->_pFrame,
                InPlace()->_pDoc);

        InPlace()->_fHostShowUI = hr != S_FALSE;
        if (hr == S_FALSE)
            hr = S_OK;
    }
    else
    {
        InPlace()->_fHostShowUI = FALSE;
    }

#if DBG == 1
    if (DbgExIsFullDebug())
    {
        if (!InPlace()->_fHostShowUI)
        {
            hr = THR(InstallMenuUI());
            if (hr)
                goto Cleanup;

            DeferUpdateUI();
            InvalidateBorder(this);
        }
    }
#endif // DBG == 1

Cleanup:
    ReleaseInterface(pCommandTarget);
    ReleaseInterface(pInPlaceActiveObject);
    RRETURN(hr);
}
#endif // NO_OLEUI

//+---------------------------------------------------------------
//
//  Member:     CDoc::RemoveFrameUI, CServer
//
//  Synopsis:   Removes the U.I. elements on the frame window
//
//  Notes:      This method "undoes" everything that was done in
//              InstallFrameUI -- it removes the shared menu from
//              the frame.
//
//---------------------------------------------------------------

#ifndef NO_OLEUI
void
CDoc::RemoveFrameUI()
{
    if (!InPlace()->_fHostShowUI)
    {
#if DBG == 1
        if (DbgExIsFullDebug())
        {
            super::RemoveFrameUI();

            InPlace()->_fMenusMerged = 0;

            DestroyMenuUI();    // Must clear menus cached in the doc's inplace
                                // object.
        }
#endif // DBG == 1
    }
    else
    {
        Assert(_pHostUIHandler);
        _pHostUIHandler->HideUI();
        InPlace()->_fHostShowUI = FALSE;
    }

    InvalidateBorder(this);
}
#endif // NO_OLEUI

//+-------------------------------------------------------------------
//
//  Member:     CDoc::DetachWin
//
//  Synopsis:   Our window is going down. Cleanup our UI.
//
//--------------------------------------------------------------------

void
CDoc::DetachWin()
{
    THREADSTATE *   pts;

#if DBG == 1
    if (DbgExIsFullDebug())
    {
        DestroyMenuUI();
    }
#endif // DBG == 1

#ifndef NO_IME
    // if a DIMM is installed, shut down it's ui
    DeactivateDIMM();
#endif // ndef NO_IME

    pts = GetThreadState();

    if (_pInPlace->_hwnd)
    {
        LRESULT lResult;
        
        // A bug in Win9x sometimes causes a stack overflow fault if our inplace window has
        // the focus and set attempt to hide the window (or SetParent).  By throwing the
        // focus away from our window, we work around the bug in the OS.

        if (_fInHTMLPropPage && ::GetFocus() == _pInPlace->_hwnd)
            ::SetFocus(NULL);

        ShowWindow (_pInPlace->_hwnd, SW_HIDE);
        OnWindowMessage (WM_KILLFOCUS, 0, 0, &lResult);
        if (!_fPopupDoc && SetParent (_pInPlace->_hwnd, pts->gwnd.hwndGlobalWindow))
        {
            // TODO: can killing of all timers be done better?
            KillTimer (_pInPlace->_hwnd, 1);                    // mouse move timer
            KillTimer (_pInPlace->_hwnd, TIMER_DEFERUPDATEUI);  // defer update UI timer
            _fUpdateUIPending = FALSE;                          // clear update UI pending flag
            _fNeedUpdateUI = FALSE;
            _fNeedUpdateTitle = FALSE;
            SetWindowLongPtr(_pInPlace->_hwnd, GWLP_USERDATA, 0);  // disconnect the window from this CDoc
            OnDestroy();    // this call is necessary to balance all ref-counting and init-/deinitialization;
                            // normally in CServer this happens upon WM_DESTROY message; however, as we reuse
                            // the window, we don't get WM_DESTROY in this codepath so we explicitly call OnDestroy

            PrivateRelease();
            _hwndCached = _pInPlace->_hwnd;
            _pInPlace->_hwnd = NULL;
        }
        else // SetParent failed
        {
            super::DetachWin();
        }
    }
}


HRESULT
CDoc::HostTranslateAccelerator ( LPMSG lpmsg )
{
    HRESULT     hr = S_FALSE;

    // Give host a change to handle first
    if(_pHostUIHandler)
    {
        DWORD cmdID;
        const GUID *pcmdSetGuid = &CGID_MSHTML;

        Assert(_pElemCurrent);

        if (lpmsg->message < WM_KEYFIRST || lpmsg->message > WM_KEYLAST)
        {
            cmdID = 0;
            pcmdSetGuid = NULL;
        }
        else
            cmdID = _pElemCurrent->GetCommandID(lpmsg);

        hr = THR(_pHostUIHandler->TranslateAccelerator(
                    lpmsg,
                    pcmdSetGuid,
                    cmdID));
    }
    RRETURN1(hr, S_FALSE);
}


HRESULT
CDoc::TranslateAccelerator ( LPMSG lpmsg )
{
    HRESULT hr = S_FALSE;    
    
    //  Give tooltips a chance to dismiss.
    {
        // Ignore spurious WM_ERASEBACKGROUNDs generated by tooltips
        CServer::CLock Lock(this, SERVERLOCK_IGNOREERASEBKGND);

        FormsTooltipMessage(lpmsg->message, lpmsg->wParam, lpmsg->lParam);
    }

    // No_File_Menu restriction enabled   
    if (g_fNoFileMenu)
    {             
        DWORD nCmdID;

        Assert(_pElemCurrent);
        nCmdID = _pElemCurrent->GetCommandID(lpmsg);
        if (nCmdID==IDM_OPEN || nCmdID==IDM_SAVE || nCmdID==IDM_PRINT)
        {
            hr = S_OK;
            goto Cleanup;
        }
    }

    hr = THR(HostTranslateAccelerator(lpmsg));
    if (hr == S_OK)
        goto Cleanup;

    if (lpmsg->message < WM_KEYFIRST || lpmsg->message > WM_KEYLAST)
        return S_FALSE;

    hr = THR(super::TranslateAccelerator (lpmsg));

Cleanup:
    RRETURN1(hr, S_FALSE);
}

//+---------------------------------------------------------------------------
//
// Member:   CWindow::SetDataObjectSecurity
//
// Synopsis: Set Security Domain
//
//----------------------------------------------------------------------------
HRESULT
CWindow::SetDataObjectSecurity(IDataObject * pDataObj)
{
    HRESULT      hr;
    CVariant     var(VT_BSTR);
    BYTE         abSID[MAX_SIZE_SECURITY_ID];
    DWORD        cbSID = ARRAY_SIZE(abSID);

    memset(abSID, 0, cbSID);
    hr = THR(Markup()->GetSecurityID(abSID, &cbSID));
    if (hr)
        goto Cleanup;

    hr = FormsAllocStringLen(NULL, MAX_SIZE_SECURITY_ID, &V_BSTR(&var));
    if (hr)
        goto Cleanup;

    memcpy(V_BSTR(&var), abSID, MAX_SIZE_SECURITY_ID);
    IGNORE_HR(CTExec(
            pDataObj,
            &CGID_DATAOBJECTEXEC,
            IDM_SETSECURITYDOMAIN,
            0,
            &var,
            NULL));

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
// Member:   CWindow::CheckDataObjectSecurity
//
// Synopsis: Check Security Domain
//
//----------------------------------------------------------------------------
HRESULT
CWindow::CheckDataObjectSecurity(IDataObject * pDataObj)
{
    HRESULT     hr;
    CVariant    var(VT_BSTR);
    BYTE        abSID[MAX_SIZE_SECURITY_ID];
    DWORD       cbSID = ARRAY_SIZE(abSID);

    memset(abSID, 0, cbSID);

    hr = THR(Markup()->GetSecurityID(abSID, &cbSID));
    if (hr)
        goto Cleanup;

    hr = FormsAllocStringLen(NULL, MAX_SIZE_SECURITY_ID, &V_BSTR(&var));
    if (hr)
        goto Cleanup;

    memcpy(V_BSTR(&var), abSID, MAX_SIZE_SECURITY_ID);
    hr = THR_NOTRACE(CTExec(
            pDataObj,
            &CGID_DATAOBJECTEXEC,
            IDM_CHECKSECURITYDOMAIN,
            0,
            &var,
            NULL));

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
// Member:   CWindow::SetClipboard
//
// Synopsis: Set Security Domain before actual FormSetClipboard
//
//----------------------------------------------------------------------------
HRESULT
CWindow::SetClipboard(IDataObject * pDO)
{
    IGNORE_HR(SetDataObjectSecurity(pDO));

    RRETURN(FormSetClipboard(pDO));
}

//+---------------------------------------------------------------------------
//
// Member:   CDoc::AllowPaste
//
// Synopsis: Check if Paste is allowed to be executed.
//           Trident allows Paste execution if Paste is from
//           1) UI (menu command, toolbar, ...)
//           2) Script, after user confirms
//
//-----------------------------------------------------------------------------
HRESULT
CMarkup::AllowPaste(IDataObject * pDO)
{
    HRESULT hr = S_OK;

    CWindow * pWindow;

    Assert(GetWindowedMarkupContext()->GetWindowPending());

    pWindow = GetWindowedMarkupContext()->GetWindowPending()->Window();

    if (pWindow->IsInScript())
    {
        hr = pWindow->CheckDataObjectSecurity(pDO);

        if (hr)
            goto Cleanup;
#if 0
        int fYesNo;

        hr = Doc()->ShowMessageEx(
                        &fYesNo,
                        MB_ICONQUESTION | MB_YESNO | MB_DEFBUTTON2,
                        NULL,
                        0,
                        _T("Scripting code is trying to PASTE data from clipboard to one of the controls, the data is from the same security domain (that is, from the same server).\n\n Do you allow this to happen?"));
        hr = (fYesNo == IDYES) ? (S_OK) : (OLECMDERR_E_DISABLED);
#endif
    }

Cleanup:
    if (hr)
    {
        // cannot programatic paste accross application or security
        // domain.
        //
        hr = OLECMDERR_E_DISABLED;
    }
    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
// Member: CheckDoc3DBorder
//
// Synopsis: Based on which 3D border edges are needed for this CDoc,
//           determine which extra 3D border edges are needed for pDoc, which
//           should be a child CDoc for this CDoc.
//           the function is called in CBodyElement::GetBorderInfo() as
//               Doc()->_pDocParent->CheckDoc3DBorder(Doc());
//----------------------------------------------------------------------------
void
CWindow::CheckDoc3DBorder(CWindow * pWindow)
{
    CElement * pElement = CMarkup::GetElementClientHelper(_pMarkup);
    Assert(pWindow->_pWindowParent == this);

    if (!pElement)
        return;
    
    if (pElement->Tag() == ETAG_BODY)
    {
        // If _pElemClient is a CBodyElement, pDoc is a CDoc defined inside
        // one <iframe> tag, need all 3D borders.
        //
        pWindow->_b3DBorder = NEED3DBORDER_TOP | NEED3DBORDER_LEFT
                         | NEED3DBORDER_BOTTOM | NEED3DBORDER_RIGHT;
    }
    else
    {
        // Since the request is from inner CDoc, _pElemClient must be frameset.
        //
        Assert(pElement->Tag() == ETAG_FRAMESET);
        CFrameSetSite * pFrameSet =
            DYNCAST( CFrameSetSite, pElement );

        // determine which 3D border edges are needed for this CDoc.
        // If this is the root CDoc (_pDocParent == NULL), we begin with that
        // we do not need to draw any 3D border edges for potential
        // CBodyElement in pDoc, since _pElemClient (top level CFrameSetSite)
        // will draw the 3D border for us.
        // Otherwise, let _pDocParent decide which 3D border edges this CDoc
        // need to draw (assume that there is a CBodyElement inside this).
        //
        if (_pWindowParent)
        {
            _pWindowParent->CheckDoc3DBorder(this);
        }
        else
        {
            // This must be the top-level frameset case, assume no 3D border at
            // first since top-level frameset (_pElemClient) already draw the
            // outmost 3D borders.
            //
            _b3DBorder = NEED3DBORDER_NO;
        }

        // calculate which extra 3D border edges are needed for pDoc
        //
        if (_b3DBorder == (NEED3DBORDER_TOP | NEED3DBORDER_LEFT
                                | NEED3DBORDER_BOTTOM | NEED3DBORDER_RIGHT))
        {
            // If this CWindow already needs all 3D border edges, child CWindow
            // should need also.
            //
            pWindow->_b3DBorder = NEED3DBORDER_TOP | NEED3DBORDER_LEFT
                             | NEED3DBORDER_BOTTOM | NEED3DBORDER_RIGHT;
        }
        else
        {
            // let CFrameSetSite decides whether more 3D border edges are
            // needed.
            //
            // Recall that framesets are never contained within more than
            // one context, so passing GUL_USEFIRSTLAYOUT is always the right
            // thing to do.
            AssertSz( pFrameSet->CurrentlyHasAnyLayout(), "Frameset should have layout by now -- don't want the following call to force creation" );
            pFrameSet->Layout( GUL_USEFIRSTLAYOUT )->CheckFrame3DBorder(pWindow, _b3DBorder);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\tempfile.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#include "tempfile.hxx"
#include <wincrypt.h>       // Used to generate random filename

//+====================================================================================
//
// Method: GetTempFilename
//
// Synopsis: Makes up a (path + 8.3) unique filename for use in directory pchPathName.
//           Uses specified prefix and extension for filename.
//           Ensures that file with generated filename doesn't yet exist. 
//           Does not actually create the file, does not test for permissions,
//           Does not verify presence of temp directory itself
//           Does not check for sufficient space on the disk.
//           Returns FALSE if unable to generate unique filename.
// Sideeffect:
//           If _pTempFileList has a reference to active file list object,
//           registers the new name with it for later deletion (for
//           temp files used when print or printpreview)
//------------------------------------------------------------------------------------
BOOL CDoc::GetTempFilename(
        const TCHAR *pchPrefixString,       //needed prefix (4 chars max)
        const TCHAR *pchExtensionString,    //needed extension (3 chars max)
              TCHAR *pchTempFileName)       //should point to TCHAR[MAX_PATH], allocated by caller
{
    BOOL  fRet = FALSE;
    const DWORD nTempPathLength = MAX_PATH - 13;  // temp path size == (MAX_PATH - ([8].[3] + '\0'))
    TCHAR szTempPath[nTempPathLength];
    TCHAR szFullName[MAX_PATH];
    HCRYPTPROV hProv = NULL;

    //verify that combined name will not be too long
    Assert(pchPrefixString && pchExtensionString);
    //verify that we are able to produce 8.3 filename
    Assert((_tcslen(pchPrefixString) <= 4) && (_tcslen(pchExtensionString) <= 3));

    // Verify input args to avoid buffer overrun.
    if (    !pchTempFileName
        ||  _tcslen(pchPrefixString) > 4
        ||  _tcslen(pchExtensionString) > 3)
        goto Cleanup;

    //set the return string to be empty
    *pchTempFileName = 0;

    // Get temp directory path
    {
        DWORD nTempPathLengthWritten = GetTempPath(nTempPathLength, szTempPath);

        // GetTempPath has two error conditions:
        // 1) If it fails (for some reason):    nTempPathLengthWritten is zero;
        // 2) If provided buffer is too small:  nTempPathLengthWritten > nTempPathLength;
        if (    nTempPathLengthWritten == 0
            ||  nTempPathLengthWritten > nTempPathLength) 
            goto Cleanup;
    }

    //verify that directory name ends with slash
    Assert(szTempPath[_tcslen(szTempPath)-1] == '\\');

    if (!CryptAcquireContextA(&hProv, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT))
    {
#ifdef DEBUG    
        DWORD dwErr;
        dwErr = GetLastError();
#endif
        hProv = NULL;
        goto Cleanup;
    }

    // Attempt to find an unused random file name 100 times.
    for(int nAttempts = 100; nAttempts; nAttempts--)
    {
        // Need 8 alphanumeric characters.
        BYTE abRand[8];
        if (!CryptGenRandom(hProv, sizeof(abRand), abRand))
            goto Cleanup;

        //generate 'random' part of filename
        TCHAR   szRnd[9];
        int     iLen = 8 - _tcslen(pchPrefixString); //the rest of filename except prefix

        for(int i=0;i<iLen;i++)
        {
            BYTE bTemp = abRand[i] % 36;

            if (bTemp < 26)
                szRnd[i] = 'A' + bTemp;
            else
                szRnd[i] = '0' + bTemp - 26;
        }
        szRnd[iLen] = 0;

        _tcscpy(szFullName, szTempPath);
        _tcscat(szFullName, pchPrefixString);
        _tcscat(szFullName, szRnd);
        _tcscat(szFullName, _T("."));
        _tcscat(szFullName, pchExtensionString);

        //check if file doesn't exist.
        if(0xFFFFFFFF == GetFileAttributes(szFullName))
        {

            //good, it doesn't exist. Copy result.
            _tcscpy(pchTempFileName, szFullName);

            //if we are tracking, add the filename into the list
            if (    TLS(pTempFileList)
                &&  TLS(pTempFileList)->IsTracking())
            {
                TLS(pTempFileList)->AddFilename(pchTempFileName);
            }

            fRet = TRUE;
            break;
        }

    }

Cleanup:
    if (hProv)
        CryptReleaseContext(hProv, 0);

    return fRet;
}

//+====================================================================================
//
// Method: SetTempFileTracking
//
// Synopsis: Turns on/off tempfile tracking. When Tracking is on, all filenames
//           generated by CDoc::GetTempFilename will be stored in a list 
//           and files will be deleted when CDoc is passivated or 
//           CDoc::DeleteTempFiles() will be called.
//------------------------------------------------------------------------------------
BOOL CDoc::SetTempFileTracking(BOOL fTrack)
{
    if(fTrack)
    {
        if (!TLS(pTempFileList))
            TLS(pTempFileList) = new CTempFileList;

        if (!TLS(pTempFileList))
            return FALSE;

        TLS(pTempFileList)->SetTracking(fTrack);
        return TLS(pTempFileList)->IsTracking();
    }
    else
    {
        if TLS(pTempFileList)
        {
            delete TLS(pTempFileList);
            TLS(pTempFileList) = NULL;
        }

        return FALSE;
    }
}

//+====================================================================================
//
// Method: TransferTempFileList
//
// Synopsis: Packages all accumulated filenames into SAFEARRAY and
//           removes them from the list.
//------------------------------------------------------------------------------------
BOOL CDoc::TransferTempFileList(VARIANT *pvarList)
{
    if(TLS(pTempFileList))
       return TLS(pTempFileList)->TransferTempFileList(pvarList);
    else
    {
        VariantInit(pvarList);
        return TRUE;
    }
}

//+====================================================================================
//
// Implementation of CTempFileName list.
//
//------------------------------------------------------------------------------------

struct CTempFileName
{   
    TCHAR _achFileName[MAX_PATH];
    CTempFileName *_pNext;
};

CTempFileList::CTempFileList()
{
    _pHead = NULL;
    _fRememberingFiles = FALSE;
}

CTempFileList::~CTempFileList()
{
    while(_pHead)
    {
        CTempFileName *pTemp = _pHead->_pNext;
        delete _pHead;
        _pHead = pTemp;
    }
}

void CTempFileList::SetTracking(BOOL doTrack)
{
    _fRememberingFiles = doTrack;
}


BOOL CTempFileList::IsTracking()
{
    return _fRememberingFiles;
}
    

BOOL CTempFileList::AddFilename(TCHAR *pchFilename)
{
    if(IsTracking())
    {
        CTempFileName *pTemp = new CTempFileName;

        if (!pTemp)
            return FALSE;

        _tcsncpy(pTemp->_achFileName, pchFilename, MAX_PATH);
        // Just in case. _tcsncpy doesn't add zero if destination is smaller then source
        pTemp->_achFileName[MAX_PATH-1] = 0;

        //put into the list
        pTemp->_pNext = _pHead;
        _pHead = pTemp;

        return TRUE;
    }

    return FALSE;
}

BOOL CTempFileList::TransferTempFileList(VARIANT *pvarList)
{
    SAFEARRAYBOUND sabound;
    SAFEARRAY *    psa = NULL;
    LONG           cnt;
    BSTR           bstrName;
    
    if(!pvarList) return FALSE;

    VariantInit(pvarList);

    //count the length
    cnt = 0;
    for(CTempFileName *pTemp = _pHead; pTemp; pTemp = pTemp->_pNext) 
        cnt++;

    //if we don't have files, leave retval in VT_EMPTY state
    if(cnt > 0)
    {
        //allocate SAFEARRAY
        sabound.cElements = cnt;
        sabound.lLbound = 0;
        psa = SafeArrayCreate(VT_BSTR, 1, &sabound);

        cnt = 0;
        while(_pHead)
        {
            CTempFileName *pTemp = _pHead->_pNext;

            bstrName = SysAllocString(_pHead->_achFileName);
            if( !bstrName ) goto Error;

            if(S_OK != SafeArrayPutElement(psa, &cnt, bstrName)) goto Error;
           
            cnt++;

            delete _pHead;
            _pHead = pTemp;
        }


        V_ARRAY(pvarList) = psa;
        V_VT(pvarList) = VT_ARRAY | VT_BSTR;
    }

    return TRUE;
    
Error:
    if(psa) SafeArrayDestroy(psa);
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\treenode.cxx ===
//+---------------------------------------------------------------------
//
//  File:       brptr.cxx
//
//  Contents:   CTreeNode class implementation
//
//  Classes:    CTreeNode
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ELEMENT_HXX_
#define X_ELEMENT_HXX_
#include "element.hxx"
#endif

#ifndef X_ELEMENTP_HXX_
#define X_ELEMENTP_HXX_
#include "elementp.hxx"
#endif

#ifndef X_CSITE_HXX_
#define X_CSITE_HXX_
#include "csite.hxx"
#endif

#ifndef X_TXTSITE_HXX_
#define X_TXTSITE_HXX_
#include "txtsite.hxx"
#endif

#ifndef X__DOC_H_
#define X__DOC_H_
#include "_doc.h"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_ROOTELEM_HXX_
#define X_ROOTELEM_HXX_
#include "rootelem.hxx"
#endif

#ifndef X_MISCPROT_H_
#define X_MISCPROT_H_
#include "miscprot.h"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

MtDefine(CTreeNode, Tree, "CTreeNode")
MtDefine(CTreeNodeCLock, Locals, "CTreeNode::CLock")

#if DBG == 1 || defined(DUMPTREE)
int CTreeNode::s_NextSerialNumber = 0;
int s_nSNTrace = -1;
#endif

extern BOOL IsPreLikeTag(ELEMENT_TAG eTag);


CTreeNode::CTreeNode ( CTreeNode * pParent, CElement * pElement /* = NULL */ )
#if DBG == 1 || defined(DUMPTREE)
            : _nSerialNumber( s_NextSerialNumber++ )
#endif
{
    Assert( _pNodeParent == NULL);
    Assert( _pElement == NULL);

    _iFF = _iCF = _iPF = -1;

    SetElement( pElement );
    SetParent( pParent );

    Assert( pElement && pElement->Doc() && pElement->Doc()->AreLookasidesClear( this, LOOKASIDE_NODE_NUMBER ) );

    SetPre(pElement ? IsPreLikeTag(Tag()) : FALSE);
    
}

#if DBG == 1
CTreeNode::~CTreeNode()
{
    Assert( _fInDestructor );
    Assert( IsDead() );
    Assert( _iCF == -1 && _iPF == -1 && _iFF == -1 );
    Assert( !_pNodeParent );
    Assert( _iCF == -1 && _iPF == -1 && _iFF == -1 );
    Assert( !HasPrimaryTearoff() );
    Assert( !HasCurrentStyle() );
}
#endif

CTreeNode *
CTreeNode::NextBranch()
{
    Assert( IsInMarkup() );

    CTreePos * ptpCurr = GetEndPos();

    if( ptpCurr->IsEdgeScope() )
        return NULL;
    else
    {
        CElement *  pElement = Element();
        CTreeNode * pNodeCurr;

        do
        {
            ptpCurr = ptpCurr->NextTreePos();

            Assert( ptpCurr->IsNode() );

            pNodeCurr = ptpCurr->Branch();
        }
        while( pNodeCurr->Element() != pElement );

        return pNodeCurr;
    }
}

CTreeNode *
CTreeNode::ParanoidNextBranch()
{
    Assert( IsInMarkup() );

    CTreePos * ptpCurr = GetEndPos();

    if( ptpCurr->IsEdgeScope() )
        return NULL;
    else
    {
        CElement *  pElement = Element();
        CTreeNode * pNodeCurr;

        if (!pElement)
            return NULL;

        do
        {
            ptpCurr = ptpCurr->NextTreePos();

            Assert( ptpCurr && ptpCurr->IsNode() );

            if (!ptpCurr || !ptpCurr->IsNode())
                return NULL;

            pNodeCurr = ptpCurr->Branch();

            if (!pNodeCurr)
                return NULL;
        }
        while( pNodeCurr->Element() != pElement );

        return pNodeCurr;
    }
}

CTreeNode *
CTreeNode::PreviousBranch()
{
    Assert( IsInMarkup() );

    CTreePos * ptpCurr = GetBeginPos();

    if( ptpCurr->IsEdgeScope() )
        return NULL;
    else
    {
        CElement *  pElement = Element();
        CTreeNode * pNodeCurr;

        do
        {
            ptpCurr = ptpCurr->PreviousTreePos();

            Assert( ptpCurr->IsNode() );

            pNodeCurr = ptpCurr->Branch();
        }
        while( pNodeCurr->Element() != pElement );

        return pNodeCurr;
    }
}

CTreeNode *
CTreeNode::Ancestor (const ELEMENT_TAG *arytag)
{
    CTreeNode * context = this;
    ELEMENT_TAG etag;
    const ELEMENT_TAG *petag;

    while (context)
    {
        etag = context->Tag();

        for (petag = arytag; *petag; petag++)
        {
            if (etag == *petag)
                return context;
        }

        context = context->Parent();
    }

    return context; // NULL context
}

CTreeNode *
CTreeNode::GetContainerBranch()
{
    CTreeNode *pNode = this;

    for (   ; 
            pNode;
            pNode = pNode->Element()->HasMasterPtr() ?
                pNode->Element()->GetMasterPtr()->GetFirstBranch() :
                pNode->Parent() )
    {
        if (pNode->IsContainer())
            break;
    }

    return pNode;
}

BOOL
CTreeNode::SupportsHtml()
{
    // see if behaviour set default canHaveHTML
    CDefaults *pDefaults = Element()->GetDefaults();
    VARIANT_BOOL fSupportsHTML;
    if (pDefaults && pDefaults->GetAAcanHaveHTML(&fSupportsHTML))
        return !!fSupportsHTML;
    else
    {
        CElement * pContainer = GetContainer();
        return ( pContainer && pContainer->HasFlag( TAGDESC_ACCEPTHTML ) );
    }
}

//+---------------------------------------------------------------------------
//
// CTreeNode::RenderParent()
// CTreeNode::ZParent()
// CTreeNode::ClipParent()
//
// Parent accessor methods used for positioning support.
//
// The following chart defines the different parents that are used for
// positioning.  Each parent determines different parameters for any
// relatively positioned or absolutely positioned element.
//
//     PARENT        RELATIVE            ABSOLUTE               PARENT TYPE       USED IN
//     ------        --------            --------               -----------       -------
//
//  "ElementParent"  Coordinates       Not meaningful             Element         GetRenderPosition/PositionObjects (implicit)
//
//  "ParentSite"           Percent/Auto/CalcSize (both)             Site          Measuring (implicit)
//
//  "RenderParent"                Painting (both)                   Site          GetSiteDrawList/HitTestPoint
//
//  "ZParent"        Z-Order            Z-Order/Coordinates    Element or Site    GetElementsInZOrder/GetRenderPosition
//
//  "Clip Parent"  Clip Rect/Auto/SetPos   Clip Rect/SetPos     Absolute Site     SetPosition/PositionObjects
//
//
//  If the ZParent is a site, then it is the same as the RenderParent.
//
//----------------------------------------------------------------------------

CTreeNode *
CTreeNode::ZParentBranch()
{
    CTreeNode * pNode;

    Assert(this);

    if (Element()->IsPositionStatic() && !GetCharFormat()->_fRelative)
    {
        return GetUpdatedParentLayoutNode();
    }
   
    // start with the master if one exists
    if (Element()->HasMasterPtr())
    {
        pNode = Element()->GetMasterPtr()->GetFirstBranch();
    }
    else
    {
        pNode = this;
    }
          
    // walk up the tree until we find a ZParent
    while ( (pNode = pNode->Parent()) != NULL)
    {
        if (pNode->Element()->HasMasterPtr())
        {
            pNode = pNode->Element()->GetMasterPtr()->GetFirstBranch();          
        }
        
        if (!pNode || pNode->Element()->IsZParent())
            break;               
    }
                
    //
    // If pNode is NULL then 'this' is the BODY or this node is not parented
    //   into the main document tree.  Return the body branch for the first
    //   case and NULL for the second.
    //
    return pNode
             ? pNode
    //  We always return the BODY as its own ZParent... but we don't do this for the frameset.
    //  In HTML Layout, this is even more suspect...
    //  It looks as if commenting out the special case for the BODY is safe.
    //  9/15/00 (greglett) (dmitryt)
    //         : ((Tag() == ETAG_BODY)
    //              ? this
                  : NULL;
}

CTreeNode *
CTreeNode::RenderParentBranch()
{
    CTreeNode * pNode;

    if (Element()->IsPositionStatic())
    {
        return GetUpdatedParentLayoutNode();
    }


    pNode = this;
    if (pNode)
    {
        pNode = pNode->Parent();
    }
    for (;
         pNode;
         pNode = pNode->Parent())
    {
        if (pNode->ShouldHaveLayout() && pNode->Element()->IsZParent())
        {
            break;
        }
    }

    return pNode
             ? pNode
             : ((Tag() == ETAG_BODY)
                  ? this
                  : NULL);
}

CTreeNode *
CTreeNode::ClipParentBranch()
{
    CTreeNode * pNode;

    if (Element()->IsPositionStatic())
    {
        return GetUpdatedParentLayoutNode();
    }

    pNode = this;
    if (pNode)
    {
        pNode = pNode->Parent();
    }
    for (;
         pNode;
         pNode = pNode->Parent())
    {
        if (pNode->ShouldHaveLayout() && pNode->Element()->IsClipParent())
        {
            break;
        }
    }

    Assert(pNode);

    return pNode;
}

CTreeNode *
CTreeNode::ScrollingParentBranch()
{
    CTreeNode * pNode = NULL;

    if (Parent())
    {
        pNode = GetUpdatedParentLayoutNode();

        for (;
             pNode;
             pNode = pNode->GetUpdatedParentLayoutNode())
        {
            if (pNode->Element()->IsScrollingParent())
                break;
        }
    }

    return pNode;
}


//+----------------------------------------------------------------------------
//
// Member:      GetCascadedbackgroundColor
//
// Synopsis:    Return the background color of the element
//
//-----------------------------------------------------------------------------

CColorValue
CTreeNode::GetCascadedbackgroundColor(FORMAT_CONTEXT FCPARAM)
{
    return (CColorValue) CTreeNode::GetFancyFormat(FCPARAM)->_ccvBackColor;
}


// The following function is used by CTxtRange::GetExtendedSelectionInfo

CTreeNode *
CTreeNode::SearchBranchForPureBlockElement ( CFlowLayout * pFlowLayout )
{
    return pFlowLayout->GetContentMarkup()->SearchBranchForBlockElement( this, pFlowLayout );
}

//+----------------------------------------------------------------------------
//
//  Member:     CTreeNode::SearchBranchToFlowLayoutForTag
//
//  Synopsis:   Looks up the parent chain for the first element which
//              matches the tag.  No stopper element here, but stops
//              at the first text site it encounters.
//
//-----------------------------------------------------------------------------

CTreeNode *
CTreeNode::SearchBranchToFlowLayoutForTag ( ELEMENT_TAG etag )
{
    CTreeNode * pNode = this;

    do
    {
        if (pNode->Tag() == etag)
            return pNode;

        pNode = pNode->Parent();
    }
    while (pNode && !pNode->HasFlowLayout(GUL_USEFIRSTLAYOUT));

    return NULL;
}

//+-----------------------------------------------------
//
//  Member  : GetFontHeightInTwips
//
//  Sysnopsis : helper function that returns the base font
//          height in twips. by default this will return 1
//
//          for now only EMs are wired up to the point that
//          it makes sense to pass through fontsize.
//--------------------------------------------------------

long
CTreeNode::GetFontHeightInTwips(const CUnitValue * pCuv)
{
    long lFontHeight = 1;

    if (  pCuv->GetUnitType() == CUnitValue::UNIT_EM 
       || pCuv->GetUnitType() == CUnitValue::UNIT_EX)
    {
        const CCharFormat * pCF = GetCharFormat();
        if (pCF)
        {
            lFontHeight = pCF->GetHeightInTwips(Doc());
        }
    }

    return lFontHeight;
}

//+----------------------------------------------------------------------------
//
//  Member:     CTreeNode::SearchBranchToRootForScope
//
//  Synopsis:   Looks up the parent chain for the first element which
//              has the same scope as the given element.  Will not stop
//              until there is no parent.
//
//-----------------------------------------------------------------------------

CTreeNode *
CTreeNode::SearchBranchToRootForScope( CElement * pElementFindMe )
{
    CTreeNode * pNode = this;

    do
    {
        if (pNode->Element() == pElementFindMe)
            return pNode;
    }
    while ( (pNode = pNode->Parent()) != NULL );

    return NULL;
}

//+----------------------------------------------------------------------------
//
//  Member:     CTreeNode::SearchBranchToRootForNode
//
//  Synopsis:   Looks up the parent chain for the given element. Will not stop
//              until there is no parent.
//
//-----------------------------------------------------------------------------

BOOL
CTreeNode::SearchBranchToRootForNode( CTreeNode * pNodeFindMe )
{
    CTreeNode * pNode = this;

    do
    {
        if (pNode == pNodeFindMe)
            return TRUE;
    }
    while ( (pNode = pNode->Parent()) != NULL );

    return FALSE;
}
//+----------------------------------------------------------------------------
//
//  Member:     CElement::SearchBranchToRootForTag
//
//  Synopsis:   Looks up the parent chain for the first element which
//              matches the tag.  No stopper element here, goes all the
//              way up to the <HTML> tag.
//
//-----------------------------------------------------------------------------

CTreeNode *
CTreeNode::SearchBranchToRootForTag ( ELEMENT_TAG etag )
{
    CTreeNode * pNode = this;

    do
    {
        if (pNode->Tag() == etag)
            return pNode;
    }
    while ( (pNode = pNode->Parent()) != NULL );

    return NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTreeNode::GetFirstCommonAncestor, public
//
//  Synopsis:   Returns the first branch whose element is common to
//              both of the branches specified.
//
//  Arguments:  [pNode] -- branch to find common parent of with [this]
//              [pEltStop]  -- Stop walking tree if you hit this element.
//                             If NULL then search to root.
//
//  Returns:    Branch with common element from first starting point.
//
//----------------------------------------------------------------------------

CTreeNode *
CTreeNode::GetFirstCommonAncestor(CTreeNode * pNodeTwo, CElement* pEltStop)
{
    CTreeNode * pNode;
    CElement * pElement;

    if( pNodeTwo->Element() == Element() )
        return this;

    for ( pNode = this; pNode; pNode = pNode->Parent() )
    {
        pElement = pNode->Element();

        pElement->_fFirstCommonAncestor = 0;

        if (pElement == pEltStop)
            break;
    }

    for ( pNode = pNodeTwo; pNode; pNode = pNode->Parent() )
    {
        pElement = pNode->Element();

        pElement->_fFirstCommonAncestor = 1;

        if (pElement == pEltStop)
            break;
    }

    for ( pNode = this; pNode; pNode = pNode->Parent() )
    {
        pElement = pNode->Element();

        if (pElement->_fFirstCommonAncestor)
            return pNode;

        Assert( pElement != pEltStop );
    }

    return NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTreeNode::GetFirstCommonBlockOrLayoutAncestor, public
//
//  Synopsis:   Returns the first branch whose element is common to
//              both of the branches specified and is a block or layout element
//
//  Arguments:  [pNode] -- branch to find common parent of with [this]
//              [pEltStop]  -- Stop walking tree if you hit this element.
//                             If NULL then search to root.
//
//  Returns:    Branch with common element from first starting point.
//
//----------------------------------------------------------------------------

CTreeNode *
CTreeNode::GetFirstCommonBlockOrLayoutAncestor(CTreeNode * pNodeTwo, CElement* pEltStop)
{
    CTreeNode * pNode;
    CElement * pElement;

    if( pNodeTwo->Element() == Element() )
        return this;

    for ( pNode = this; pNode; pNode = pNode->Parent() )
    {
        pElement = pNode->Element();

        pElement->_fFirstCommonAncestor = 0;

        if (pElement == pEltStop)
            break;
    }

    for ( pNode = pNodeTwo; pNode; pNode = pNode->Parent() )
    {
        pElement = pNode->Element();

        pElement->_fFirstCommonAncestor = 1;

        if (pElement == pEltStop)
            break;
    }

    for ( pNode = this; pNode; pNode = pNode->Parent() )
    {
        pElement = pNode->Element();

        if ((pElement->ShouldHaveLayout() || pElement->IsBlockElement())
            && pElement->_fFirstCommonAncestor)
        {
            return pNode;
        }

        Assert( pElement != pEltStop );
    }

    return NULL;
}
//+---------------------------------------------------------------------------
//
//  Member:     CTreeNode::GetFirstCommonAncestorNode, public
//
//  Synopsis:   Returns the first node that is common to
//              both of the branches specified.
//
//  Arguments:  [pNode] -- branch to find common parent of with [this]
//              [pEltStop]  -- Stop walking tree if you hit this element.
//                             If NULL then search to root.
//
//  Returns:    Branch with common node from first starting point.
//
//----------------------------------------------------------------------------

CTreeNode *
CTreeNode::GetFirstCommonAncestorNode(CTreeNode * pNodeTwo, CElement* pEltStop)
{
    CTreeNode * pNode;

    if( this == pNodeTwo )
        return this;

    for ( pNode = this; pNode; pNode = pNode->Parent() )
    {
        pNode->_fFirstCommonAncestorNode = 0;

        if (pNode->Element() == pEltStop)
            break;
    }

    for ( pNode = pNodeTwo; pNode; pNode = pNode->Parent() )
    {
        pNode->_fFirstCommonAncestorNode = 1;

        if (pNode->Element() == pEltStop)
            break;
    }

    for ( pNode = this; pNode; pNode = pNode->Parent() )
    {
        if (pNode->_fFirstCommonAncestorNode)
            return pNode;

        Assert( pNode->Element() != pEltStop );
    }

    return NULL;
}


//+------------------------------------------------------------------------
//
//  Member:     CTreeNode::Depth
//
//  Synopsis:   Finds the depth of the node in the html tree
//
//  Returns:    int
//
//-------------------------------------------------------------------------

int
CTreeNode::Depth() const
{
    CTreeNode * pNode = const_cast<CTreeNode *>(this);
    int nDepth = 0;

    while ( pNode)
        nDepth++, pNode = pNode->Parent();

    Assert( nDepth > 0);

    return nDepth;
}


BEGIN_TEAROFF_TABLE_NAMED(CTreeNode, s_apfnNodeVTable)
    TEAROFF_METHOD(CTreeNode, GetInterface, getinterface, (REFIID riid, void **ppv))
    TEAROFF_METHOD_(CTreeNode, PutRef, putref, ULONG, ())
    TEAROFF_METHOD_(CTreeNode, RemoveRef, removeref, ULONG, ())
    TEAROFF_METHOD_NULL
    TEAROFF_METHOD_NULL
    TEAROFF_METHOD_NULL
    TEAROFF_METHOD_NULL
    TEAROFF_METHOD_NULL
    TEAROFF_METHOD_NULL
    TEAROFF_METHOD_NULL
    TEAROFF_METHOD_NULL
    TEAROFF_METHOD_NULL
    TEAROFF_METHOD_NULL
    TEAROFF_METHOD_NULL
    TEAROFF_METHOD_NULL
    TEAROFF_METHOD_NULL
END_TEAROFF_TABLE()

//+---------------------------------------------------------------------------
//
//  Member:     QueryInterface
//
//  Synopsis:
//
//----------------------------------------------------------------------------

HRESULT
CTreeNode::GetInterface(REFIID iid, void **ppv)
{
    void *  pv = NULL;
    void *  pvWhack;
    void *  apfnWhack;
    HRESULT hr = E_NOINTERFACE;
    BOOL    fReuseTearoff = FALSE;
    const IID * piidDisp;

    *ppv = NULL;

    AssertSz( _pElement, "_pElement is NULL in CTreeNode::GetInterface -- VERY BAD!!!" );

    // handle IUnknown when tearoff is already created
    if (iid == IID_IUnknown && HasPrimaryTearoff())
    {
        IUnknown * pTearoff;

        pTearoff = GetPrimaryTearoff();

        Assert( pTearoff );

        pTearoff->AddRef();

        *ppv = pTearoff;

        return S_OK;
    }

    if (iid == CLSID_CTreeNode)
    {
        *ppv = this;
        return S_OK;
    }
    else if (iid == CLSID_CElement  ||
             iid == CLSID_CTextSite )
    {
        return _pElement->QueryInterface( iid, ppv );
    }

    // Create a tearoff to return

    // Get the interface from the element
    hr = THR_NOTRACE(_pElement->PrivateQueryInterface(iid, &pv));
    if(hr)
    {
        pv = NULL;
        goto Cleanup;
    }

    //
    // Whack in our node information, or the primary tearoff
    //
    if( HasPrimaryTearoff() )
    {
        pvWhack = (void*)GetPrimaryTearoff();
        Assert( pvWhack );
        apfnWhack = *(void**)pvWhack;
    }
    else
    {
        pvWhack = this;
        apfnWhack = (void*)s_apfnNodeVTable;
    }

#if DBG==1
    if( !HasPrimaryTearoff() )
        _fSettingTearoff = TRUE;
#endif

    Assert( apfnWhack );

    // InstallTearOffObject puts a pointer to an object
    // into pvObject2 of the tearoff.  This means that we
    // are assuming that when an element is QI'd, the interfaces
    // listed below will be returned as tearoffs.  Also, every
    // interface that uses the eax trick for passing context
    // through must be in this list.  Otherwise we will
    // create another tearoff pointing to the tearoff.
    //

    piidDisp = _pElement->BaseDesc()->_piidDispinterface;
    piidDisp = piidDisp ? piidDisp : &IID_NULL;

    if(iid == *piidDisp                 ||
       iid == IID_IHTMLElement          ||
       iid == IID_IDispatch             ||
       iid == IID_IDispatchEx           ||
       iid == IID_IHTMLControlElement)
    {
        hr = THR(InstallTearOffObject(pv, pvWhack,
                    apfnWhack, QI_MASK));
        if(hr)
            goto Cleanup;

        *ppv = pv;

        fReuseTearoff = TRUE;
    }
    else
    {
        hr = THR(
            CreateTearOffThunk(
                pv, * (void **) pv, NULL, ppv, pvWhack,
                apfnWhack, QI_MASK, NULL ));
        ((IUnknown *)pv)->Release();
        pv = NULL;
        if(hr)
            goto Cleanup;
    }

    if (!*ppv)
        RRETURN(E_NOINTERFACE);

    if( ! HasPrimaryTearoff() )
    {
        // This tearoff that we just created is now the primary tearoff
        SetPrimaryTearoff( (IUnknown *)*ppv );
        WHEN_DBG( _fSettingTearoff = FALSE );
    }

    if(!fReuseTearoff)
        ((IUnknown *)*ppv)->AddRef();

    hr = S_OK;

Cleanup:
    if(hr && pv)
        ((IUnknown *)pv)->Release();

    RRETURN( hr );
}


ULONG
CTreeNode::PutRef(void)
{
#if DBG==1
    if (s_nSNTrace == _nSerialNumber)
    {
        TraceTag((0, "treenode %d PutRef", _nSerialNumber));
        TraceCallers(0, 0, 12);
    }
#endif

    Assert( ! _fInDestructor );
    Assert( _fSettingTearoff );
    Assert( ! HasPrimaryTearoff() );

    // We do this so that we know that the node will
    // die before the element.  If it was the other way
    // around, we wouldn't be able to get to the doc to
    // del our primary tearoff lookaside pointer
    Element()->AddRef();

    return 1;
}

ULONG
CTreeNode::RemoveRef(void)
{
    CElement * pElement = Element();

#if DBG==1
    if (s_nSNTrace == _nSerialNumber)
    {
        TraceTag((0, "treenode %d RemoveRef", _nSerialNumber));
        TraceCallers(0, 0, 12);
    }
#endif

    Assert( !_fInDestructor );
    Assert( HasPrimaryTearoff() );

    DelPrimaryTearoff();

    if (!_fInMarkup)
    {
        WHEN_DBG( _fInDestructor = TRUE );
        delete this;
    }

    // Release the ref that we put on the element above.
    pElement->Release();

    return 1;
}

HRESULT
CTreeNode::NodeAddRef(void)
{
    HRESULT hr = S_OK;
    IUnknown *pTearoff = NULL;

#if DBG==1
    if (s_nSNTrace == _nSerialNumber)
    {
        TraceTag((0, "treenode %d NodeAddRef", _nSerialNumber));
        TraceCallers(0, 0, 12);
    }
#endif

    Assert( ! _fInDestructor );

    if( ! HasPrimaryTearoff() )
    {
        // Use GetInterface to create the primary interface
        hr = THR( GetInterface( IID_IUnknown, (void**)&pTearoff ) );

        return hr;
    }
    else
    {
        pTearoff = GetPrimaryTearoff();

        Assert( pTearoff );
        pTearoff->AddRef();

        return S_OK;
    }
}

ULONG
CTreeNode::NodeRelease(void)
{
    IUnknown *pTearoff;

#if DBG==1
    if (s_nSNTrace == _nSerialNumber)
    {
        TraceTag((0, "treenode %d ReleaseRef", _nSerialNumber));
        TraceCallers(0, 0, 12);
    }
#endif

    Assert( !_fInDestructor );
    Assert( HasPrimaryTearoff() );

    pTearoff = GetPrimaryTearoff();

    Assert( pTearoff );

    return pTearoff->Release();

}

//
// Ref counting helpers
//

HRESULT
CTreeNode::ReplacePtr      ( CTreeNode * * ppNodelhs, CTreeNode * pNoderhs )
{
    HRESULT hr = S_OK;

    if (ppNodelhs)
    {
        CTreeNode * pNodelhsLocal = *ppNodelhs;
        if (pNoderhs)
        {
            hr = THR( pNoderhs->NodeAddRef() );
            if( hr )
                goto Cleanup;
        }
        *ppNodelhs = pNoderhs;
        if (pNodelhsLocal)
        {
            pNodelhsLocal->NodeRelease();
        }
    }

Cleanup:
    RRETURN( hr );
}

HRESULT
CTreeNode::SetPtr          ( CTreeNode * * pbrlhs, CTreeNode * brrhs )
{
    HRESULT hr = S_OK;

    if (pbrlhs)
    {
        if (brrhs)
        {
            hr = THR( brrhs->NodeAddRef() );
            if( hr )
                goto Cleanup;
        }
        *pbrlhs = brrhs;
    }

Cleanup:
    RRETURN( hr );
}

void
CTreeNode::ClearPtr        ( CTreeNode * * pbrlhs )
{
    if (pbrlhs && * pbrlhs)
    {
        CTreeNode * pNode = *pbrlhs;
        *pbrlhs = NULL;
        pNode->NodeRelease();
    }
}

void
CTreeNode::ReleasePtr        ( CTreeNode * pNode )
{
    if (pNode)
    {
        pNode->NodeRelease();
    }
}

void
CTreeNode::StealPtrSet     ( CTreeNode * * pbrlhs, CTreeNode * brrhs )
{
    SetPtr( pbrlhs, brrhs );

    if (pbrlhs && *pbrlhs)
        (*pbrlhs)->NodeRelease();
}

HRESULT
CTreeNode::StealPtrReplace ( CTreeNode * * pbrlhs, CTreeNode * brrhs )
{
    HRESULT hr;

    hr = THR( ReplacePtr( pbrlhs, brrhs ) );
    if( hr )
        goto Cleanup;

    if (pbrlhs && *pbrlhs)
        (*pbrlhs)->NodeRelease();

Cleanup:
    RRETURN( hr );
}

//+---------------------------------------------------------------------------
//
//  Lookaside storage
//
//----------------------------------------------------------------------------

void *
CTreeNode::GetLookasidePtr(int iPtr)
{
#if DBG == 1
    Assert( Doc() );
    if(HasLookasidePtr(iPtr))
    {
        void * pLookasidePtr =  Doc()->GetLookasidePtr((DWORD *)this + iPtr);

        Assert(pLookasidePtr == _apLookAside[iPtr]);

        return pLookasidePtr;
    }
    else
        return NULL;
#else
    return(HasLookasidePtr(iPtr) ? Doc()->GetLookasidePtr((DWORD *)this + iPtr) : NULL);
#endif
}

HRESULT
CTreeNode::SetLookasidePtr(int iPtr, void * pvVal)
{
    Assert( Doc() );
    Assert (!HasLookasidePtr(iPtr) && "Can't set lookaside ptr when the previous ptr is not cleared");

    HRESULT hr = THR(Doc()->SetLookasidePtr((DWORD *)this + iPtr, pvVal));

    if (hr == S_OK)
    {
        _fHasLookasidePtr |= 1 << iPtr;

#if DBG == 1
        _apLookAside[iPtr] = pvVal;
#endif
    }

    RRETURN(hr);
}

void *
CTreeNode::DelLookasidePtr(int iPtr)
{
    Assert( Doc() );
    if (HasLookasidePtr(iPtr))
    {
        void * pvVal = Doc()->DelLookasidePtr((DWORD *)this + iPtr);
        _fHasLookasidePtr &= ~(1 << iPtr);
#if DBG == 1
        _apLookAside[iPtr] = NULL;
#endif
        return(pvVal);
    }

    return(NULL);
}


//+----------------------------------------------------------------------------
//
// Member:      ConvertFmToCSSBorderStyle
//
// Synopsis:    Converts the border style from the internal type to the type
//                  used to set it.
//-----------------------------------------------------------------------------

styleBorderStyle
ConvertFmToCSSBorderStyle(BYTE bFmBorderStyle)
{
    switch ( bFmBorderStyle )
    {
    case fmBorderStyleDotted:
        return styleBorderStyleDotted;
    case fmBorderStyleDashed:
        return styleBorderStyleDashed;
    case fmBorderStyleDouble:
        return styleBorderStyleDouble;
    case fmBorderStyleSingle:
        return styleBorderStyleSolid;
    case fmBorderStyleEtched:
        return styleBorderStyleGroove;
    case fmBorderStyleBump:
        return styleBorderStyleRidge;

    case fmBorderStyleSunkenMono:
    case fmBorderStyleSunken:
        return styleBorderStyleInset;

    case fmBorderStyleRaisedMono:
    case fmBorderStyleRaised:
        return styleBorderStyleOutset;

    case fmBorderStyleWindowInset:
        return styleBorderStyleWindowInset;
    case fmBorderStyleNone:
        return styleBorderStyleNone;
    case 0xff:
        return styleBorderStyleNotSet;
    }

    Assert( FALSE && "Unknown Border Style!" );
    return styleBorderStyleNotSet;
}


//+----------------------------------------------------------------------------
//
// Member:      GetCascadedborderTopStyle
//
// Synopsis:    Return the top border style value for the node
//
//-----------------------------------------------------------------------------

styleBorderStyle
CTreeNode::GetCascadedborderTopStyle(FORMAT_CONTEXT FCPARAM)
{
    const CFancyFormat *pFF = GetFancyFormat(FCPARAM);
    Assert(pFF);
    return ConvertFmToCSSBorderStyle(pFF->_bd.GetBorderStyle(SIDE_TOP));
}


//+----------------------------------------------------------------------------
//
// Member:      GetCascadedborderRightStyle
//
// Synopsis:    Return the right border style value for the node
//
//-----------------------------------------------------------------------------

styleBorderStyle
CTreeNode::GetCascadedborderRightStyle(FORMAT_CONTEXT FCPARAM)
{
    const CFancyFormat *pFF = GetFancyFormat(FCPARAM);
    Assert(pFF);
    return ConvertFmToCSSBorderStyle(pFF->_bd.GetBorderStyle(SIDE_RIGHT));
}


//+----------------------------------------------------------------------------
//
// Member:      GetCascadedborderBottomStyle
//
// Synopsis:    Return the bottom border style value for the node
//
//-----------------------------------------------------------------------------

styleBorderStyle
CTreeNode::GetCascadedborderBottomStyle(FORMAT_CONTEXT FCPARAM)
{
    const CFancyFormat *pFF = GetFancyFormat(FCPARAM);
    Assert(pFF);
    return ConvertFmToCSSBorderStyle(pFF->_bd.GetBorderStyle(SIDE_BOTTOM));
}


//+----------------------------------------------------------------------------
//
// Member:      GetCascadedborderLeftStyle
//
// Synopsis:    Return the left border style value for the node
//
//-----------------------------------------------------------------------------

styleBorderStyle
CTreeNode::GetCascadedborderLeftStyle(FORMAT_CONTEXT FCPARAM)
{
    const CFancyFormat *pFF = GetFancyFormat(FCPARAM);
    Assert(pFF);
    return ConvertFmToCSSBorderStyle(pFF->_bd.GetBorderStyle(SIDE_LEFT));
}



//+----------------------------------------------------------------------------
//
// Member:      GetCascadedclearLeft
//
// Synopsis:
//
//-----------------------------------------------------------------------------

BOOL
CTreeNode::GetCascadedclearLeft(FORMAT_CONTEXT FCPARAM)
{
    return !!GetFancyFormat(FCPARAM)->_fClearLeft;
}


//+----------------------------------------------------------------------------
//
// Member:      GetCascadedclearRight
//
// Synopsis:
//
//-----------------------------------------------------------------------------

BOOL
CTreeNode::GetCascadedclearRight(FORMAT_CONTEXT FCPARAM)
{
    return !!GetFancyFormat(FCPARAM)->_fClearRight;
}



//+------------------------------------------------------------------------
//
//  Member:     CTreeNode::IsInlinedElement
//
//  Synopsis:   Determines if the element is rendered inflow or not, If the
//              element is not absolutely positioned and is left or right
//              aligned with hr and legend an exception (they can only be
//              aligned but nothing should wrap around them).
//              For non-sites we return TRUE.
//
//  Returns:    BOOL indicating whether or not the site is inlined
//
//-------------------------------------------------------------------------

BOOL
CTreeNode::IsInlinedElement ( FORMAT_CONTEXT FCPARAM )
{
    if (ShouldHaveLayout(FCPARAM))
    {
        const CFancyFormat * pFF = GetFancyFormat(FCPARAM);

        return      pFF->_bPositionType != stylePositionabsolute
                &&  !pFF->_fAlignedLayout;
    }

    return TRUE;
}

void
CTreeNode::GetRelTopLeft(
    CElement    * pElementFL,
    CParentInfo * ppi,
    long * pxRelLeft,
    long * pyRelTop)
{
    CTreeNode * pNode = this;
    CDoc      * pDoc = pElementFL->Doc();
    long        lFontHeight;
    const CCharFormat  * pCF;
    const CFancyFormat * pFF;
    const CCharFormat *pCFFL = pElementFL->GetFirstBranch()->GetCharFormat(); 
    BOOL fElementFLVertical = pCFFL->HasVerticalLayoutFlow();

    Assert(pyRelTop && pxRelLeft);

    *pyRelTop = 0;
    *pxRelLeft = 0;

    while(pNode && pNode->Element() != pElementFL)
    {
        pCF = pNode->GetCharFormat();

        if(!pCF->_fRelative)
            break;

        lFontHeight = pCF->GetHeightInTwips(pDoc);
        pFF = pNode->GetFancyFormat();

        if(pFF->_fRelative)
        {
            *pyRelTop  += pFF->GetLogicalPosition(SIDE_TOP, fElementFLVertical, pCF->_fWritingModeUsed).YGetPixelValue(ppi, ppi->_sizeParent.cy, lFontHeight);
            *pxRelLeft += pFF->GetLogicalPosition(SIDE_LEFT, fElementFLVertical, pCF->_fWritingModeUsed).XGetPixelValue(ppi, ppi->_sizeParent.cx, lFontHeight);
        }

        pNode = pNode->Parent();
    }
}

//+----------------------------------------------------------------------------
//
// Member:      GetCurrentRelativeNode
//
// Synopsis:    Get the node that is relative, which causes the current
//              chunk to be relative.
//
//-----------------------------------------------------------------------------
CTreeNode *
CTreeNode::GetCurrentRelativeNode(CElement * pElementFL)
{
    const CFancyFormat * pFF;
    CTreeNode * pNodeStart = this;

    while(pNodeStart && DifferentScope(pElementFL, pNodeStart))
    {
        pFF = pNodeStart->GetFancyFormat();

        // TODO (jbeda): I'm pretty sure this is wrong for some
        // overlapped cases

        // relatively positioned layout elements are to be ignored
        if(!pNodeStart->Element()->ShouldHaveLayout() && pFF->_fRelative)
            return pNodeStart;

        pNodeStart = pNodeStart->Parent();
    }
    return NULL;
}

//+----------------------------------------------------------------------------
//
// Member:      EnsureFormats
//
// Synopsis:    Compute the formats if dirty
//
//-----------------------------------------------------------------------------
void
CTreeNode::EnsureFormats( FORMAT_CONTEXT FCPARAM )
{
    
    if (_iCF < 0)
    {
        GetCharFormatHelper( FCPARAM );
    }
    if (_iPF < 0)
    {
        GetParaFormatHelper( FCPARAM );
    }
    if (_iFF < 0)
    {
        GetFancyFormatHelper( FCPARAM );
    }

    if (Element()->HasSlavePtr())
    {
        Element()->GetSlavePtr()->GetMarkup()->EnsureFormats( FCPARAM );
    }

}

//----------------------------------------------------------------------------
//  Walks the parent markup chain for a tree node, until it finds the ancestor
//  tree node that lives in the markup that is passed.
//
//  This is needed for multiframe hittesting scenarios and alike, where you have
//  a node in a sub markup, and you want to find the element/node that actually
//  is the parent of that tree in a given markup.
// 
//  May return NULL if the markup given is not in the parent chain of the node given
//---------------------------------------------------------------------------- 
CTreeNode*
CTreeNode::GetNodeInMarkup(CMarkup * pMarkup)
{
    CTreeNode * pNode = this;
    CElement *  pElemRoot;

    while (pNode)
    {
        // if we have reached a node without a markup, return NULL.
        if (!pNode->IsInMarkup())
            return NULL;

        // The node is in a markup. Check if it is the markup
        // we are looking for. If not, continue climbing.
        if (pNode->GetMarkup() == pMarkup)
            break;
        else
        {
            pElemRoot = pNode->GetMarkup()->Root();

            if (!pElemRoot->HasMasterPtr())
                return NULL;

            // Get the node for the master element.
            pNode = pElemRoot->GetMasterPtr()->GetFirstBranch();
        }
    }

    return pNode;
}

BOOL
CTreeNode::IsConnectedToPrimaryMarkup()
{
    return IsConnectedToThisMarkup(Doc()->PrimaryMarkup());
}

//----------------------------------------------------------------------------
//  Walks the parent/master chain for a tree node to determine if the node
//  is in the view. 
//---------------------------------------------------------------------------- 
BOOL
CTreeNode::IsInViewTree()
{
    CTreeNode * pNode = this;
    CTreeNode * pNodePrimaryRoot    = Doc()->PrimaryMarkup()->RootNode();

    Assert(pNode);
    Assert(pNodePrimaryRoot);

    //Fix for IE6 33880. If this markup is going out of viewlink relationship
    //(we are sending ExitView notification SetViewSlave) -- it's not
    // considered to be in view tree.
    if(!IsInMarkup() || GetMarkup()->_fSlaveInExitView)
        return FALSE;

    while (pNode != pNodePrimaryRoot)
    {
        CTreeNode * pNodeParent = pNode->Parent();

        if (pNodeParent)
        {
            // I am not in view, if my parent has a slave
            if (pNodeParent->Element()->HasSlavePtr())
                return FALSE;
            pNode = pNodeParent;
        }
        else
        {
            CElement *  pElem   = pNode->Element();

            Assert(pElem->Tag() == ETAG_ROOT);
            if (!pElem->HasMasterPtr())
                return FALSE;
            pNode = pElem->GetMasterPtr()->GetFirstBranch();
            if (!pNode)
                return FALSE;
        }
    }
    return TRUE;
}

BOOL
CTreeNode::IsEditable(BOOL fCheckContainerOnly /*=FALSE*/ FCCOMMA FORMAT_CONTEXT FCPARAM)
{
    return (fCheckContainerOnly ? IsParentEditable(FCPARAM) : GetEditable(FCPARAM));
}

BOOL
CTreeNode::IsParentEditable(FORMAT_CONTEXT FCPARAM)
{
    CTreeNode* pParent = Parent() ;
    return (pParent && pParent->GetEditable(FCPARAM));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\treeserv.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_TPOINTER_HXX_
#define X_TPOINTER_HXX_
#include "tpointer.hxx"
#endif

#ifndef X_IRANGE_HXX_
#define X_IRANGE_HXX_
#include "irange.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#ifndef X_ROOTELEM_HXX_
#define X_ROOTELEM_HXX_
#include "rootelem.hxx"
#endif

#ifndef X__TEXT_H_
#define X__TEXT_H_
#include "_text.h"
#endif

#ifndef X_WCHDEFS_H_
#define X_WCHDEFS_H_
#include "wchdefs.h"
#endif

#ifndef X_UNDO_HXX_
#define X_UNDO_HXX_
#include "undo.hxx"
#endif

#ifndef X_MARKUPUNDO_HXX_
#define X_MARKUPUNDO_HXX_
#include "markupundo.hxx"
#endif

#ifndef X__DXFROBJ_H_
#define X__DXFROBJ_H_
#include "_dxfrobj.h"
#endif

#ifndef X_ROSTM_HXX_
#define X_ROSTM_HXX_
#include "rostm.hxx"
#endif

#if DBG==1
#ifndef X_CHNGLOG_HXX_
#define X_CHNGLOG_HXX_
#include "chnglog.hxx"
#endif // X_CHNGLOG_HXX_

#ifndef X_FRAME_H_
#define X_FRAME_H_
#include "iframe.h"
#endif // X_FRAME_H_
#endif // DBG==1

PerfDbgExtern(tagPerfWatch)

////////////////////////////////////////////////////////////////
//    IMarkupServices methods

HRESULT
CDoc::CreateMarkupPointer ( CMarkupPointer * * ppPointer )
{
    Assert( ppPointer );

    *ppPointer = new CMarkupPointer( this );

    if (!*ppPointer)
        return E_OUTOFMEMORY;

    return S_OK;
}

HRESULT
CDoc::CreateMarkupPointer ( IMarkupPointer ** ppIPointer )
{
    HRESULT hr;
    CMarkupPointer * pPointer = NULL;

    hr = THR( CreateMarkupPointer( & pPointer ) );

    if (hr)
        goto Cleanup;

    hr = THR(
        pPointer->QueryInterface(
            IID_IMarkupPointer, (void **) ppIPointer ) );

    if (hr)
        goto Cleanup;

Cleanup:

    ReleaseInterface( pPointer );
    
    RRETURN( hr );
}


HRESULT
CDoc::MovePointersToRange (
    IHTMLTxtRange * pIRange,
    IMarkupPointer *  pIPointerStart,
    IMarkupPointer *  pIPointerFinish )
{
    HRESULT hr = S_OK;
    CAutoRange *pRange;
    CMarkupPointer *pPointerStart=NULL, *pPointerFinish=NULL;
    
    // check argument sanity
    if (pIRange==NULL          || !IsOwnerOf(pIRange) ||
        (pIPointerStart !=NULL && !IsOwnerOf(pIPointerStart))  ||
        (pIPointerFinish!=NULL && !IsOwnerOf(pIPointerFinish)) )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // get the internal objects corresponding to the arguments
    hr = pIRange->QueryInterface(CLSID_CRange, (void**)&pRange);
    if (hr)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (pIPointerStart)
    {
        hr = pIPointerStart->QueryInterface(CLSID_CMarkupPointer, (void**)&pPointerStart);
        if (hr)
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }
    }

    if (pIPointerFinish)
    {
        hr = pIPointerFinish->QueryInterface(CLSID_CMarkupPointer, (void**)&pPointerFinish);
        if (hr)
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }
    }

    // move the pointers
    
    if (pPointerStart)
        hr = pRange->GetLeft( pPointerStart );
    
    if (!hr && pPointerFinish)
        hr = pRange->GetRight( pPointerFinish );
    
Cleanup:
    
    RRETURN( hr );
}


HRESULT
CDoc::MoveRangeToPointers (
    IMarkupPointer *  pIPointerStart,
    IMarkupPointer *  pIPointerFinish,
    IHTMLTxtRange * pIRange )
{
    HRESULT        hr = S_OK;
    CAutoRange *   pRange;
    BOOL           fPositioned;

    if (!pIPointerStart || !pIPointerFinish || !pIRange)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    
    if (!IsOwnerOf( pIRange ) ||
        !IsOwnerOf( pIPointerStart )  || !IsOwnerOf( pIPointerFinish ))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR( pIPointerStart->IsPositioned( &fPositioned ) );
    if (hr)
        goto Cleanup;
    if (! fPositioned)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR( pIPointerFinish->IsPositioned( &fPositioned ) );
    if (hr)
        goto Cleanup;
    if (! fPositioned)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // get the internal objects corresponding to the arguments
    hr = THR( pIRange->QueryInterface( CLSID_CRange, (void**) & pRange ) );

    if (hr)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR( pRange->SetLeftAndRight( pIPointerStart, pIPointerFinish, FALSE ));
    
Cleanup:
    
    RRETURN( hr );
}


HRESULT
CDoc::InsertElement (
    CElement *       pElementInsert,
    CMarkupPointer * pPointerStart,
    CMarkupPointer * pPointerFinish,
    DWORD            dwFlags )
{
    HRESULT     hr = S_OK;
    CTreePosGap tpgStart, tpgFinish;

    Assert( pElementInsert );
    Assert( pPointerStart );

    //
    // If the the finish is not specified, set it to the start to make the element span
    // nothing at the start.
    //
    
    if (!pPointerFinish)
        pPointerFinish = pPointerStart;

    Assert( ! pElementInsert->GetFirstBranch() );
    Assert( pElementInsert->Tag() != ETAG_ROOT );

    //
    // If the element is no scope, then we must ignore the finish
    //

    if (pElementInsert->IsNoScope())
        pPointerFinish = pPointerStart;

    //
    // Make sure the start if before the finish
    //

    Assert( pPointerStart->IsLeftOfOrEqualTo( pPointerFinish ) );

    //
    // Make sure both pointers are positioned, and in the same tree
    //

    Assert( pPointerStart->IsPositioned() );
    Assert( pPointerFinish->IsPositioned() );
    Assert( pPointerStart->Markup() == pPointerFinish->Markup() );

    //
    // Make sure unembedded markup pointers go in for the modification
    //

    hr = THR( pPointerStart->Markup()->EmbedPointers() );

    if (hr)
        goto Cleanup;

    //
    // Position the gaps and do the insert
    //

    // Note: We embed to make sure the pointers get updated, but we
    // also take advantage of it to get pointer pos's for the input
    // args.  It would be nice to treat the inputs specially in the
    // operation and not have to embed them......
    
    tpgStart.MoveTo( pPointerStart->GetEmbeddedTreePos(), TPG_LEFT );
    tpgFinish.MoveTo( pPointerFinish->GetEmbeddedTreePos(), TPG_LEFT );

    hr = THR(
        pPointerStart->Markup()->InsertElementInternal(
            pElementInsert, & tpgStart, & tpgFinish, dwFlags ) );

    if (hr)
        goto Cleanup;

Cleanup:
    
    RRETURN( hr );
}

HRESULT
CDoc::InsertElement(
    IHTMLElement *   pIElementInsert,
    IMarkupPointer * pIPointerStart,
    IMarkupPointer * pIPointerFinish)
{
    HRESULT          hr = S_OK;
    CElement *       pElementInsert;
    CMarkupPointer * pPointerStart, * pPointerFinish;

    //
    // If the the finish is not specified, set it to the start to make the element span
    // nothing at the start.
    //
    
    if (!pIPointerFinish)
        pIPointerFinish = pIPointerStart;

    //
    // Make sure all the arguments are specified and belong to this document
    //
    
    if (!pIElementInsert || !IsOwnerOf( pIElementInsert ) ||
        !pIPointerStart  || !IsOwnerOf( pIPointerStart  )  ||
        !pIPointerFinish || !IsOwnerOf( pIPointerFinish ) )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    //
    // get the internal objects corresponding to the arguments
    //
    
    hr = THR( pIElementInsert->QueryInterface( CLSID_CElement, (void **) & pElementInsert ) );

    if (hr)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    Assert( pElementInsert );

    //
    // The element must not already be in a tree
    //

    if ( pElementInsert->GetFirstBranch() )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    //
    // Get the "real" objects associated with these pointer interfaces
    //
    
    hr = THR( pIPointerStart->QueryInterface( CLSID_CMarkupPointer, (void **) & pPointerStart ) );

    if (hr)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    
    hr = THR( pIPointerFinish->QueryInterface( CLSID_CMarkupPointer, (void **) & pPointerFinish ) );

    if (hr)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    //
    // Make sure both pointers are positioned, and in the same tree
    //

    if (!pPointerStart->IsPositioned() || !pPointerFinish->IsPositioned())
    {
        hr = CTL_E_UNPOSITIONEDPOINTER;
        goto Cleanup;
    }
    
    if (pPointerStart->Markup() != pPointerFinish->Markup())
    {
        hr = CTL_E_INCOMPATIBLEPOINTERS;
        goto Cleanup;
    }

    //
    // Make sure the start if before the finish
    //

    EnsureLogicalOrder( pPointerStart, pPointerFinish );
    
    hr = THR( InsertElement( pElementInsert, pPointerStart, pPointerFinish ) );

    if (hr)
        goto Cleanup;

Cleanup:

    RRETURN( hr );
}


HRESULT
CDoc::RemoveElement ( 
    CElement *  pElementRemove,
    DWORD       dwFlags )
{
    HRESULT    hr = S_OK;

    //
    // Element to be removed must be specified and it must be associated
    // with this document.
    //

    Assert( pElementRemove );

    //
    //  Assert that the element is in the markup
    //
    
    Assert( pElementRemove->IsInMarkup() );
    Assert( pElementRemove->Tag() != ETAG_ROOT );

    //
    // Now, remove the element
    //

    hr = THR( pElementRemove->GetMarkup()->RemoveElementInternal( pElementRemove, dwFlags ) );

    if (hr)
        goto Cleanup;

Cleanup:

    RRETURN( hr );
}

HRESULT
CDoc::RemoveElement ( IHTMLElement * pIElementRemove )
{
    HRESULT    hr = S_OK;
    CElement * pElementRemove = NULL;

    //
    // Element to be removed must be specified and it must be associated
    // with this document.
    //
    
    if (!pIElementRemove || !IsOwnerOf( pIElementRemove ))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    //
    // get the interneal objects corresponding to the arguments
    //
    
    hr = THR(
        pIElementRemove->QueryInterface(
            CLSID_CElement, (void **) & pElementRemove ) );
    
    if (hr)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    //
    // Make sure element is in the tree
    //

    if (!pElementRemove->IsInMarkup())
    {
        hr = CTL_E_UNPOSITIONEDELEMENT;
        goto Cleanup;
    }

    //
    // The root element is off limits
    //

    if( pElementRemove->Tag() == ETAG_ROOT )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    //
    // Do the remove
    //

    hr = THR( RemoveElement( pElementRemove ) );

    if (hr)
        goto Cleanup;

Cleanup:

    RRETURN( hr );
}

HRESULT
CDoc::Remove (
    CMarkupPointer * pPointerStart,
    CMarkupPointer * pPointerFinish,
    DWORD            dwFlags )
{
    return CutCopyMove( pPointerStart, pPointerFinish, NULL, TRUE, dwFlags );
}

HRESULT
CDoc::Copy (
    CMarkupPointer * pPointerSourceStart,
    CMarkupPointer * pPointerSourceFinish,
    CMarkupPointer * pPointerTarget,
    DWORD            dwFlags )
{
    return
        CutCopyMove(
            pPointerSourceStart, pPointerSourceFinish,
            pPointerTarget, FALSE, dwFlags );
}

HRESULT
CDoc::Move (
    CMarkupPointer * pPointerSourceStart,
    CMarkupPointer * pPointerSourceFinish,
    CMarkupPointer * pPointerTarget,
    DWORD            dwFlags )
{
    return
        CutCopyMove(
            pPointerSourceStart, pPointerSourceFinish,
            pPointerTarget, TRUE, dwFlags );
}

HRESULT
CDoc::Remove (
    IMarkupPointer * pIPointerStart,
    IMarkupPointer * pIPointerFinish )
{
    return CutCopyMove( pIPointerStart, pIPointerFinish, NULL, TRUE );
}

HRESULT
CDoc::Copy(
    IMarkupPointer * pIPointerStart,
    IMarkupPointer * pIPointerFinish,
    IMarkupPointer * pIPointerTarget )
{
    return CutCopyMove( pIPointerStart, pIPointerFinish, pIPointerTarget, FALSE );
}


HRESULT
CDoc::Move(
    IMarkupPointer * pIPointerStart,
    IMarkupPointer * pIPointerFinish,
    IMarkupPointer * pIPointerTarget )
{
    return CutCopyMove( pIPointerStart, pIPointerFinish, pIPointerTarget, TRUE );
}


HRESULT
CDoc::InsertText (
    CMarkupPointer * pPointerTarget,
    const OLECHAR *  pchText,
    long             cch,
    DWORD            dwFlags )
{
    HRESULT hr = S_OK;

    Assert( pPointerTarget );
    Assert( pPointerTarget->IsPositioned() );

    hr = THR( pPointerTarget->Markup()->EmbedPointers() );

    if (hr)
        goto Cleanup;

    if (cch < 0)
        cch = pchText ? _tcslen( pchText ) : 0;

    hr = THR(
        pPointerTarget->Markup()->InsertTextInternal(
            pPointerTarget->GetEmbeddedTreePos(), pchText, cch, dwFlags ) );

    if (hr)
        goto Cleanup;

Cleanup:

    RRETURN(hr);
}

HRESULT
CDoc::InsertText ( OLECHAR * pchText, long cch, IMarkupPointer * pIPointerTarget )
{
    HRESULT          hr = S_OK;
    CMarkupPointer * pPointerTarget;

    if (!pIPointerTarget || !IsOwnerOf( pIPointerTarget ))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    //
    // Get the internal objects corresponding to the arguments
    //
    
    hr = THR(
        pIPointerTarget->QueryInterface(
            CLSID_CMarkupPointer, (void **) & pPointerTarget ) );
    
    if (hr)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    //
    // more sanity checks
    //
    
    if (!pPointerTarget->IsPositioned())
    {
        hr = CTL_E_UNPOSITIONEDPOINTER;
        goto Cleanup;
    }

    //
    // Do it
    //

    hr = THR( InsertText( pPointerTarget, pchText, cch ) );

    if (hr)
        goto Cleanup;

Cleanup:
    
    RRETURN( hr );
}

HRESULT 
CDoc::ParseString (
            OLECHAR *        pchHTML,
            DWORD            dwFlags,
            CMarkup * *      ppContainerResult,
            CMarkupPointer * pPointerStart,
            CMarkupPointer * pPointerFinish,
            CMarkup *        pMarkupContext)
{
    HRESULT hr;
    HGLOBAL hHtmlText = NULL;

    Assert(ppContainerResult);
    Assert(pchHTML);
    
    extern HRESULT HtmlStringToSignaturedHGlobal (
        HGLOBAL * phglobal, const TCHAR * pStr, long cch );

    hr = THR(
        HtmlStringToSignaturedHGlobal(
            & hHtmlText, pchHTML, _tcslen( pchHTML ) ) );

    if (hr)
        goto Cleanup;

    Assert( hHtmlText );

    hr = THR(
        ParseGlobal(
            hHtmlText, dwFlags, pMarkupContext, ppContainerResult,
            pPointerStart, pPointerFinish ) );

    if (hr)
        goto Cleanup;

Cleanup:

    if (hHtmlText)
        GlobalFree( hHtmlText );
    
    RRETURN( hr );
}



HRESULT
CDoc::ParseString (
    OLECHAR *            pchHTML,
    DWORD                dwFlags,
    IMarkupContainer * * ppIContainerResult,
    IMarkupPointer *     pIPointerStart,
    IMarkupPointer *     pIPointerFinish )
{
    HRESULT             hr = S_OK;
    CMarkupPointer *    pStart = NULL;
    CMarkupPointer *    pFinish = NULL;
    CMarkup *           pMarkup = NULL;

    if (!pchHTML || !ppIContainerResult)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *ppIContainerResult = NULL;

    if (pIPointerStart)
    {
        hr = THR(
            pIPointerStart->QueryInterface(
                CLSID_CMarkupPointer, (void **)&pStart ) );

        if (hr)
            goto Cleanup;
    }

    if (pIPointerFinish)
    {
        hr = THR(
             pIPointerFinish->QueryInterface(
                CLSID_CMarkupPointer, (void **)&pFinish ) );
        
        if (hr)
            goto Cleanup;
    }

    hr = THR(
        ParseString( pchHTML, dwFlags, & pMarkup, pStart, pFinish, /*pMarkupContext = */NULL) );

    if (hr)
        goto Cleanup;

    if (pMarkup)
    {
        hr = THR( pMarkup->SetOrphanedMarkup( TRUE ) );
        if( hr )
            goto Cleanup;

        hr = THR(
            pMarkup->QueryInterface(
                IID_IMarkupContainer, (void **)ppIContainerResult ) );

        if (hr)
            goto Cleanup;
    }
            
Cleanup:

    if (pMarkup)
        pMarkup->Release();


    RRETURN(hr);
}


static HRESULT
PrepareStream (
    HGLOBAL hGlobal,
    IStream * * ppIStream,
    BOOL fInsertFrags,
    HTMPASTEINFO * phtmpasteinfo)
{
    CStreamReadBuff * pstreamReader = NULL;
    LPSTR pszGlobal = NULL;
    long lSize;
    BOOL fIsEmpty, fHasSignature;
    TCHAR szVersion[ 24 ];
    TCHAR szSourceUrl [ pdlUrlLen ];
    long iStartHTML, iEndHTML;
    long iStartFragment, iEndFragment;
    long iStartSelection, iEndSelection;
    DWORD dwGlobalSize;
    ULARGE_INTEGER ul = { 0, 0 };
    HRESULT hr = S_OK;
    CROStmOnHGlobal * pStm = NULL;

    Assert( hGlobal );
    Assert( ppIStream );

    //
    // Get access to the bytes of the global
    //


    pszGlobal = LPSTR( GlobalLock( hGlobal ) );

    if (!pszGlobal)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    //
    // First, compute the size of the global
    //

    lSize = 0;
    dwGlobalSize = GlobalSize( hGlobal );
    if (dwGlobalSize == 0)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // TODO: Support nonnative signature and sizeof(wchar) == 4/2 (davidd)

    fHasSignature = * (WCHAR *) pszGlobal == NATIVE_UNICODE_SIGNATURE;

    // We're forcing a terminator at the end of the global in case any bad
    // clients <coughWord2000cough> don't give us a terminated string. 
    // If our terminator was the only thing ending the string, then we'll
    // count that last character as well (by setting the size of the stream)
    if (fHasSignature)
    {
        TCHAR *pchLast = (TCHAR *)( pszGlobal + dwGlobalSize - sizeof( TCHAR ) );
        TCHAR chTerm = *pchLast;

        *pchLast = _T('\0');
        lSize = _tcslen( (TCHAR *) pszGlobal ) * sizeof( TCHAR );
        *pchLast = chTerm;

        if( (DWORD)lSize == dwGlobalSize - sizeof( TCHAR ) && chTerm != _T('\0') )
            lSize += sizeof( TCHAR );

        fIsEmpty = (lSize - sizeof( TCHAR )) == 0;
    }
    else
    {
        char chTerm = pszGlobal[ dwGlobalSize - 1 ];

        pszGlobal[ dwGlobalSize - 1 ] = '\0';
        lSize = lstrlenA( pszGlobal );
        pszGlobal[ dwGlobalSize - 1 ] = chTerm;

        if( (DWORD)lSize == dwGlobalSize - 1 && chTerm != '\0' )
            ++lSize;

        fIsEmpty = lSize == 0;
    }

    //
    // If the HGLOBAL is effectively empty, do nothing, and return this
    // fact.
    //

    if (fIsEmpty)
    {
        *ppIStream = NULL;
        goto Cleanup;
    }

    //
    // Create if the stream got the load context
    //

    pStm = new CROStmOnHGlobal();
    if( !pStm )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR( pStm->Init( hGlobal, lSize ) );
    if( hr )
        goto Cleanup;

    *ppIStream = pStm;
    pStm = NULL;

    // N.B. (johnv) This is necessary for Win95 support.  Apparently
    // GlobalSize() may return different values at different times for the same
    // hGlobal.  This makes IStream's behavior unpredictable.  To get around
    // this, we set the size of the stream explicitly.

    // Make sure we don't have unicode in the hGlobal

#ifdef UNIX
    U_QUAD_PART(ul)= lSize;
    Assert( U_QUAD_PART(ul) <= GlobalSize( hGlobal ) );
#else
    ul.QuadPart = lSize;
    Assert( ul.QuadPart <= GlobalSize( hGlobal ) );
#endif

    iStartHTML      = -1;
    iEndHTML        = -1;
    iStartFragment  = -1;
    iEndFragment    = -1;
    iStartSelection = -1;
    iEndSelection   = -1;

    //
    // Locate the required contextual information in the stream
    //

    pstreamReader = new CStreamReadBuff ( * ppIStream, CP_UTF_8 );
    if (pstreamReader == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(
        pstreamReader->GetStringValue(
            _T("Version"), szVersion, ARRAY_SIZE( szVersion ) ) );

    if (hr == S_FALSE)
        goto PlainStream;

    if (hr)
        goto Cleanup;

    hr = THR(
        pstreamReader->GetLongValue(
            _T( "StartHTML" ), & iStartHTML ) );

    if (hr == S_FALSE)
        goto PlainStream;

    if (hr)
        goto Cleanup;

    hr = THR(
        pstreamReader->GetLongValue(
            _T( "EndHTML" ), & iEndHTML ) );

    if (hr == S_FALSE)
        goto PlainStream;

    if (hr)
        goto Cleanup;

    hr = THR(
        pstreamReader->GetLongValue(
            _T( "StartFragment" ), & iStartFragment ) );

    if (hr == S_FALSE)
        goto PlainStream;

    if (hr)
        goto Cleanup;

    hr = THR(
        pstreamReader->GetLongValue(
            _T( "EndFragment" ), & iEndFragment ) );

    //
    // Locate optional contextual information
    //

    hr = THR(
        pstreamReader->GetLongValue(
            _T( "StartSelection" ), & iStartSelection ) );

    if (hr && hr != S_FALSE)
        goto Cleanup;

    if (hr != S_FALSE)
    {
        hr = THR(
            pstreamReader->GetLongValue(
                _T( "EndSelection" ), & iEndSelection ) );

        if (hr && hr != S_FALSE)
            goto Cleanup;

        if (hr == S_FALSE)
        {
            hr = E_FAIL;
            goto Cleanup;
        }
    }
    else
    {
        iStartSelection = -1;
    }

    //
    // Get the source URL info
    //

    hr = THR(
        pstreamReader->GetStringValue(
            _T( "SourceURL" ), szSourceUrl, ARRAY_SIZE( szSourceUrl ) ) );

    if (hr && hr != S_FALSE)
        goto Cleanup;

    if (phtmpasteinfo && hr != S_FALSE)
    {
        hr = THR( phtmpasteinfo->cstrSourceUrl.Set( szSourceUrl ) );

        if (hr)
            goto Cleanup;
    }

    //
    // Make sure contextual info is sane
    //

    if (iStartHTML < 0 && iEndHTML < 0)
    {
        //
        // per cfhtml spec, start and end html can be -1 if there is no
        // context.  there must always be a fragment, however
        //
        iStartHTML = iStartFragment;
        iEndHTML   = iEndFragment;
    }

    if (iStartHTML     < 0 || iEndHTML     < 0 ||
        iStartFragment < 0 || iEndFragment < 0 ||
        iStartHTML     > iEndHTML     ||
        iStartFragment > iEndFragment ||
        iStartHTML > iStartFragment ||
        iEndHTML   < iEndFragment)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    if (iStartSelection != -1)
    {
        if (iEndSelection < 0 ||
            iStartSelection > iEndSelection ||
            iStartHTML > iStartSelection ||
            iEndHTML < iEndSelection ||
            iStartFragment > iStartSelection ||
            iEndFragment < iEndSelection)
        {
            hr = E_FAIL;
            goto Cleanup;
        }
    }

    //
    // Rebase the fragment and selection off of the start html
    //

    iStartFragment -= iStartHTML;
    iEndFragment -= iStartHTML;

    if (iStartSelection != -1)
    {
        iStartSelection -= iStartHTML;
        iEndSelection -= iStartHTML;
    }
    else
    {
        iStartSelection = iStartFragment;
        iEndSelection = iEndFragment;
    }

    phtmpasteinfo->cbSelBegin  = iStartSelection;
    phtmpasteinfo->cbSelEnd    = iEndSelection;

    pstreamReader->SetPosition( iStartHTML );

    hr = S_OK;

Cleanup:

    if (pstreamReader)
        phtmpasteinfo->cp = pstreamReader->GetCodePage();

    delete pstreamReader;

    if( pStm )
        pStm->Release();

    if (pszGlobal)
        GlobalUnlock( hGlobal );

    RRETURN( hr );

PlainStream:

    pstreamReader->SetPosition( 0 );
    pstreamReader->SwitchCodePage(g_cpDefault);

    if (fInsertFrags)
    {
        phtmpasteinfo->cbSelBegin  = fHasSignature ? sizeof( TCHAR ) : 0;
        phtmpasteinfo->cbSelEnd    = lSize;
    }
    else
    {
        phtmpasteinfo->cbSelBegin  = -1;
        phtmpasteinfo->cbSelEnd    = -1;
    }

    hr = S_OK;

    goto Cleanup;
}

static HRESULT
MoveToPointer (
    CDoc *           pDoc,
    CMarkupPointer * pMarkupPointer,
    CTreePos *       ptp )
{
    HRESULT hr = S_OK;

    if (!pMarkupPointer)
    {
        if (ptp)
        {
            hr = THR( ptp->GetMarkup()->RemovePointerPos( ptp, NULL, NULL ) );

            if (hr)
                goto Cleanup;
        }
        
        goto Cleanup;
    }

    if (!ptp)
    {
        hr = THR( pMarkupPointer->Unposition() );

        if (hr)
            goto Cleanup;

        goto Cleanup;
    }

    hr = THR( pMarkupPointer->MoveToOrphan( ptp ) );

    if (hr)
        goto Cleanup;

    //
    // NOTE Parser can sometimes put the pointer pos in the
    // inside of a noscope (load <body onload="document.body.innerHTML='<body><script></body>'">)
    // Check forthis here
    //

    if (pMarkupPointer->Branch()->Element()->IsNoScope())
    {
        hr = THR(
            pMarkupPointer->MoveAdjacentToElement(
                pMarkupPointer->Branch()->Element(), ELEM_ADJ_AfterEnd ) );

        if (hr)
            goto Cleanup;
    }

Cleanup:

    RRETURN( hr );
}

HRESULT
CDoc::ParseGlobal (
    HGLOBAL          hGlobal,
    DWORD            dwFlags,
    CMarkup *        pContextMarkup,
    CMarkup * *      ppMarkupResult,
    CMarkupPointer * pPointerSelStart,
    CMarkupPointer * pPointerSelFinish,
    DWORD            dwInternalFlags /* = 0 */)
{
    PerfDbgLog(tagPerfWatch, this, "+CDoc::ParseGlobal");

    HRESULT hr = S_OK;
    IStream * pIStream = NULL;
    HTMPASTEINFO htmpasteinfo;
    CMarkup * pWindowedMarkupContext;

    Assert( pPointerSelStart );
    Assert( pPointerSelFinish );
    Assert( ppMarkupResult );

    //
    // Returning NULL suggests that there was absolutely nothing to parse.
    //
    
    *ppMarkupResult = NULL;
    
    if (!hGlobal)
        goto Cleanup;

    //
    // Prepare the stream ...
    //

    hr = THR( PrepareStream( hGlobal, & pIStream, TRUE, & htmpasteinfo ) );
    if (hr)
        goto Cleanup;

    //
    // If no stream was created, then there is nothing to parse
    //

    if (!pIStream)
        goto Cleanup;

    //
    // Create the new markup container which will receive the the bounty
    // of the parse
    //

    if (!pContextMarkup)
    {
        // WINDOWEDMARKUP - This is only available to binary code
        pContextMarkup = PrimaryMarkup();
        pWindowedMarkupContext = PrimaryMarkup();
    }
    else
    {
        pWindowedMarkupContext = pContextMarkup->GetWindowedMarkupContext();
    }

    hr = THR( CreateMarkup( ppMarkupResult, pWindowedMarkupContext ) );

    if (hr)
        goto Cleanup;

    Assert( *ppMarkupResult );

    (*ppMarkupResult)->_fInnerHTMLMarkup = !!(dwInternalFlags & INTERNAL_PARSE_INNERHTML);
    if (!!(dwInternalFlags & INTERNAL_PARSE_PRINTTEMPLATE))
        (*ppMarkupResult)->SetPrintTemplate(TRUE);
    
    //
    // Prepare the frag/sel begin/end for the return 
    //

    htmpasteinfo.ptpSelBegin = NULL;
    htmpasteinfo.ptpSelEnd = NULL;

    //
    // Parse this
    //

    _fPasteIE40Absolutify = dwFlags & PARSE_ABSOLUTIFYIE40URLS;

    (*ppMarkupResult)->_fMarkupServicesParsing = TRUE;

    hr = THR( (*ppMarkupResult)->Load( pIStream, pContextMarkup, /* fAdvanceLoadStatus = */ FALSE, & htmpasteinfo ) );
    
    (*ppMarkupResult)->_fMarkupServicesParsing = FALSE;

    if (hr)
        goto Cleanup;

    //
    // Move the pointers to the pointer pos' the parser left in
    //

    if( !htmpasteinfo.ptpSelBegin || !htmpasteinfo.ptpSelEnd )
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = THR(
        MoveToPointer(
            this, pPointerSelStart,  htmpasteinfo.ptpSelBegin ) );

    if (hr)
        goto Cleanup;
    
    hr = THR(
        MoveToPointer(
            this, pPointerSelFinish, htmpasteinfo.ptpSelEnd   ) );

    if (hr)
        goto Cleanup;

#if DBG == 1
    pPointerSelStart->SetDebugName( _T( "Selection Start" ) );
    pPointerSelFinish->SetDebugName( _T( "Selection Finish" ) );
#endif

    //
    // Make sure the finish is (totally) ordered properly with
    // respect to the begin
    //

    if (pPointerSelStart->IsPositioned() && pPointerSelFinish->IsPositioned())
        EnsureLogicalOrder( pPointerSelStart, pPointerSelFinish );

Cleanup:
    if (*ppMarkupResult && (*ppMarkupResult)->HasWindow())
        (*ppMarkupResult)->TearDownMarkup(FALSE);  // fStop = FALSE

    ReleaseInterface( pIStream );

    PerfDbgLog(tagPerfWatch, this, "-CDoc::ParseGlobal");

    RRETURN( hr );
}

HRESULT
CDoc::ParseGlobal (
    HGLOBAL              hGlobal,
    DWORD                dwFlags,
    IMarkupContainer * * ppIContainerResult,
    IMarkupPointer *     pIPointerSelStart,
    IMarkupPointer *     pIPointerSelFinish )
{
    HRESULT          hr = S_OK;
    CMarkup *        pMarkup = NULL;
    CMarkupPointer * pPointerSelStart = NULL;
    CMarkupPointer * pPointerSelFinish = NULL;

    if (!ppIContainerResult)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *ppIContainerResult = NULL;

    if (!hGlobal)
        goto Cleanup;

    if (pIPointerSelStart)
    {
        hr = THR(
            pIPointerSelStart->QueryInterface(
                CLSID_CMarkupPointer, (void **) & pPointerSelStart ) );

        if (hr)
            goto Cleanup;
    }

    if (pIPointerSelFinish)
    {
        hr = THR(
            pIPointerSelFinish->QueryInterface(
                CLSID_CMarkupPointer, (void **) & pPointerSelFinish ) );

        if (hr)
            goto Cleanup;
    }

    hr = THR(
        ParseGlobal(
            hGlobal, dwFlags, /* pContextMarkup = */ NULL, & pMarkup, pPointerSelStart, pPointerSelFinish ) );

    if (hr)
        goto Cleanup;

    if (pMarkup)
    {
        hr = THR( pMarkup->SetOrphanedMarkup( TRUE ) );
        if( hr )
            goto Cleanup;

        hr = THR(
            pMarkup->QueryInterface(
                IID_IMarkupContainer, (void **) ppIContainerResult ) );

        if (hr)
            goto Cleanup;
    }

Cleanup:

    if (pMarkup)
        pMarkup->Release();

    RRETURN( hr );
}

//+----------------------------------------------------------------------------
//
//  Functions:  Equal & Compare
//
//  Synopsis:   Helpers for comparing IMarkupPointers
//
//-----------------------------------------------------------------------------

static inline BOOL
IsEqualTo ( IMarkupPointer * p1, IMarkupPointer * p2 )
{
    BOOL fEqual;
    IGNORE_HR( p1->IsEqualTo( p2, & fEqual ) );
    return fEqual;
}

static inline int
OldCompare ( IMarkupPointer * p1, IMarkupPointer * p2 )
{
    int result;
    IGNORE_HR( OldCompare( p1, p2, & result ) );
    return result;
}

//+----------------------------------------------------------------------------
//
//  Function:   ComputeTotalOverlappers
//
//  Synopsis:   This function retunrs a node which can be found above the
//              finish pointer.  All elements starting at this node and above
//              it are in the scope of both the start and finish pointers.
//              
//              If an element were to be inserted between the pointers, that
//              element would finish just above this node.  All elements above
//              the return node, including the return element, begin before
//              the start pointer and finish after the finish pointer.
//
//-----------------------------------------------------------------------------

typedef CStackPtrAry < CTreeNode *, 32 > NodeArray;

MtDefine( ComputeTotalOverlappers_aryNodes_pv, Locals, "ComputeTotalOverlappers aryNodes::_pv" );

static HRESULT
ComputeTotalOverlappers(
    CMarkupPointer * pPointerStart,
    CMarkupPointer * pPointerFinish,
    CTreeNode * *    ppNodeTarget )
{
    HRESULT     hr = S_OK;
    CTreeNode * pNode;
    NodeArray   aryNodesStart( Mt( ComputeTotalOverlappers_aryNodes_pv ) );
    NodeArray   aryNodesFinish( Mt( ComputeTotalOverlappers_aryNodes_pv ) );
    int         iStart, iFinish;

    Assert( ppNodeTarget );
    Assert( pPointerStart && pPointerFinish );
    Assert( pPointerStart->IsPositioned() );
    Assert( pPointerFinish->IsPositioned() );
    Assert( pPointerStart->Markup() == pPointerFinish->Markup() );
    Assert( OldCompare( pPointerStart, pPointerFinish ) <= 0 );

    *ppNodeTarget = NULL;

    for ( pNode = pPointerStart->Branch() ; pNode ; pNode = pNode->Parent() )
        IGNORE_HR( aryNodesStart.Append( pNode ) );

    for ( pNode = pPointerFinish->Branch() ; pNode ; pNode = pNode->Parent() )
        IGNORE_HR( aryNodesFinish.Append( pNode ) );

    iStart = aryNodesStart.Size() - 1;
    iFinish = aryNodesFinish.Size() - 1;

    for ( ; ; )
    {
        if (iStart < 0 || iFinish < 0)
        {
            if (iFinish + 1 < aryNodesFinish.Size())
                *ppNodeTarget = aryNodesFinish[ iFinish + 1 ];

            goto Cleanup;
        }

        if (aryNodesStart [ iStart ] == aryNodesFinish [ iFinish ])
            iFinish--;

        iStart--;
    }

Cleanup:

    RRETURN( hr );
}

//+----------------------------------------------------------------------------
//
//  Function:   ValidateElements
//
//  Synopsis:   
//
//-----------------------------------------------------------------------------

MtDefine( ValidateElements_aryNodes_pv, Locals, "ValidateElements aryNodes::_pv" );

//
// TODO
//
// This function is broken in the general case.  First, we need to add a flag
// to validate copies v.s. moves.  Also, it can only validate either inplace
// (pPointerTarget is NULL) or a tree-to-tree move.  Luckily, these are the
// only ways this function is used in IE5.
//

HRESULT
CDoc::ValidateElements (
    CMarkupPointer *   pPointerStart,
    CMarkupPointer *   pPointerFinish,
    CMarkupPointer *   pPointerTarget,
    DWORD              dwFlags,
    CMarkupPointer *   pPointerStatus,
    CTreeNode * *      ppNodeFailBottom,
    CTreeNode * *      ppNodeFailTop )
{  
    HRESULT     hr = S_OK;
    NodeArray   aryNodes ( Mt( ValidateElements_aryNodes_pv ) );
    long        nNodesOk;
    CTreeNode * pNodeCommon;
    CTreeNode * pNode;
    CTreePos *  ptpWalk;
    CTreePos *  ptpFinish;
    CTreePos *  ptpBeforeIncl = NULL;
    CMarkupPointer  pointerStatus(this);

    Assert( pPointerStart && pPointerFinish);
    Assert( pPointerStart->IsPositioned() );
    Assert( pPointerFinish->IsPositioned() );
    Assert( pPointerStart->Markup() ==pPointerFinish->Markup() );
    Assert( !pPointerTarget  || pPointerTarget->IsPositioned() );

    if (!pPointerStatus)
    {
        pPointerStatus = &pointerStatus;
    }

    //
    // TODO Should not have to embed pointers here!
    //

    hr = THR( pPointerStart->Markup()->EmbedPointers() );

    if (hr)
        goto Cleanup;

    if (pPointerTarget)
    {
        hr = THR( pPointerTarget->Markup()->EmbedPointers() );

        if (hr)
            goto Cleanup;
    }

    //
    // If the status pointer is NULL, then we are validating from the
    // beginning.  Otherwise, we are to continue validating from that
    // position.
    //

    if (!pPointerStatus->IsPositioned())
    {
        hr = THR( pPointerStatus->SetGravity( POINTER_GRAVITY_Left ) );
        if (hr)
            goto Cleanup;

        hr = THR( pPointerStatus->MoveToPointer( pPointerStart ) );
        if (hr)
            goto Cleanup;
    }

    WHEN_DBG( (pPointerStatus->SetDebugName( _T( "Validate Status" ) ) ) );

    //
    // If the status pointer is outside the range to validate, then
    // the validation is ended.  In this case, release the status pointer
    // and return.
    //

    if (OldCompare( pPointerStart, pPointerStatus ) > 0 ||
        OldCompare( pPointerFinish, pPointerStatus ) <= 0)
    {
        hr = THR( pPointerStatus->Unposition() );
        goto Cleanup;
    }

    //
    // Get the common node for the range to validate.  Anything above
    // and including the common node cannot be a candidate for source
    // validation because they must cover the entire range and will not
    // participate in a move.
    //

    {
        CTreeNode * pNodeStart  = pPointerStart->Branch();
        CTreeNode * pNodeFinish = pPointerFinish->Branch();

        pNodeCommon =
            (pNodeStart && pNodeFinish)
                ? pNodeStart->GetFirstCommonAncestorNode( pNodeFinish, NULL )
                : NULL;
    }
    
    //
    // Here we prime the tag array with target elements (if any).
    //

    {
        CTreeNode * pNodeTarget;
        int         nNodesTarget = 0, i;
        
        if (pPointerTarget && pPointerTarget->IsPositioned())
        {
            //
            // If the target is in the range of the source, then compute
            // the branch which consists of elements which totally overlap
            // the range to validate.  These are the elements which would
            // remain of the range were be removed.
            //
            // If the target is not in the validation range, then simply use
            // the base of the target.
            //

            if (pPointerTarget->Markup() == pPointerStart->Markup() &&
                OldCompare( pPointerStart,  pPointerTarget ) < 0 &&
                    OldCompare( pPointerFinish, pPointerTarget ) > 0)
            {
AssertSz( 0, "This path should never be used in IE5" );
                hr = THR(
                    ComputeTotalOverlappers(
                        pPointerStart, pPointerFinish, & pNodeTarget ) );

                if (hr)
                    goto Cleanup;
            }
            else
            {
                pNodeTarget = pPointerTarget->Branch();
            }
        }
        else
        {
            pNodeTarget = pNodeCommon;
        }

        //
        // Now, put tags in the tag array starting from the target
        //

        for ( pNode = pNodeTarget ;
              pNode && pNode->Tag() != ETAG_ROOT ;
              pNode = pNode->Parent() )
        {
            nNodesTarget++;
        }

        hr = THR( aryNodes.Grow( nNodesTarget ) );

        if (hr)
            goto Cleanup;
        
        for ( i = 1, pNode = pNodeTarget ;
              pNode && pNode->Tag() != ETAG_ROOT ;
              pNode = pNode->Parent(), i++ )
        {
            aryNodes [ nNodesTarget - i ] = pNode;
        }
    }
    
    //
    // During the validation walk, the mark bit on the element will
    // indicate whether or not the element will participate in a move
    // if the range to validate were moved to another location.  A mark
    // or 1 indicates that the element participates, 0 means it does not.
    //
    // By setting all the bits (up to the common node) on the left branch
    // to 1 and then clearing all the bits on the right branch, all elements
    // on the first branch which partially overlap the left side of the
    // range to validate.
    //
    // Note, this only applies if a target has been specified.  If we
    // are validating inplacem, then we simply validate all elements
    // in scope.
    //

    for ( pNode = pPointerStart->Branch() ;
          pNode != pNodeCommon ;
          pNode = pNode->Parent() )
    {
        pNode->Element()->_fMark1 = 1;
    }

    //
    // Only clear the bits if a tree-to-tree move validation is being
    // performed.  If not, then we leave all the marks up to the common
    // element on.  Thus, all elements in scope will be validated against.
    //

    if (pPointerTarget)
    {
        for ( pNode = pPointerFinish->Branch() ;
              pNode != pNodeCommon ;
              pNode = pNode->Parent() )
        {
            pNode->Element()->_fMark1 = 0;
        }
    }

    //
    // Now, walk from the start pointer to the status pointer, setting the
    // mark bit to true on any elements comming into scope.  This needs to
    // be done to make sure we include these elements in the validation
    // because they have come into scope.  We also do this as we walk the
    // main loop later, doing the actual validation.
    //
    // Note: We do a Compare here because the pointers may be at the same
    // place in the markup, but the start is after the status pointer.
    //

    ptpWalk = pPointerStart->GetEmbeddedTreePos();
    
    if (! IsEqualTo( pPointerStatus, pPointerStart ))
    {
        CTreePos * ptpStatus = pPointerStatus->GetEmbeddedTreePos();

        for ( ; ptpWalk != ptpStatus ; ptpWalk = ptpWalk->NextTreePos() )
        {
            if (ptpWalk->IsBeginElementScope())
                ptpWalk->Branch()->Element()->_fMark1 = TRUE;
        }
    }

    //
    // Now, prime the tag array with the current set of source elements.
    // As we walk the validation range, we will add or remove elements
    // as they enter and exit scope.
    //

    {
        int i;
        
        for ( pNode = ptpWalk->GetBranch(), i = 0 ;
              pNode != pNodeCommon ;
              pNode = pNode->Parent() )
        {
            if (pNode->Element()->_fMark1)
                i++;
        }

        hr = THR( aryNodes.Grow( aryNodes.Size() + i ) );

        if (hr)
            goto Cleanup;

        i = aryNodes.Size() - 1;
        
        for ( pNode = ptpWalk->GetBranch() ;
              pNode != pNodeCommon ;
              pNode = pNode->Parent() )
        {
            if (pNode->Element()->_fMark1)
                aryNodes[ i-- ] = pNode;
        }
    }

    //
    // This is the 'main' loop where validation actually takes place.
    //

    ptpFinish = pPointerFinish->GetEmbeddedTreePos();
    nNodesOk = 0;
    
    for ( ; ; )
    {
        BOOL fDone;
        long iConflictTop, iConflictBottom;
        
        //
        // Validate the current tag array
        //

        extern HRESULT
            ValidateNodeList (
                CTreeNode **, long, long, BOOL, long *, long *);

        hr = THR(
            ValidateNodeList(
                aryNodes, aryNodes.Size(), nNodesOk,
                dwFlags & VALIDATE_ELEMENTS_REQUIREDCONTAINERS,
                & iConflictTop, & iConflictBottom ) );

        //
        // Returning S_FALSE indicates a conflict
        //

        if (hr == S_FALSE)
        {
            CTreePos * ptpPtr;
            
            if( ptpWalk->IsBeginNode() && !ptpWalk->IsEdgeScope() )
            {
                Assert(     ptpBeforeIncl->IsEndNode()
                        &&  !ptpBeforeIncl->IsEdgeScope()
                        &&  ptpBeforeIncl->Branch()->Element() == ptpWalk->Branch()->Element() );

                ptpPtr = ptpBeforeIncl;
            }
            else
            {
                ptpPtr = ptpWalk;
            }

            CTreePosGap gap ( ptpPtr, TPG_LEFT );
            
            hr = THR( pPointerStatus->MoveToGap( & gap, pPointerStart->Markup() ) );

            if (hr)
                goto Cleanup;

            if (ppNodeFailBottom)
                *ppNodeFailBottom = aryNodes[ iConflictBottom ];
            
            if (ppNodeFailTop)
                *ppNodeFailTop = aryNodes[ iConflictTop ];

            hr = S_FALSE;

            goto Cleanup;
        }

        if (hr)
            goto Cleanup;

        //
        // Since we've just validated the entire array, don't do it again
        // next time 'round.
        //

        nNodesOk = aryNodes.Size();

        //
        // Now, scan forward looking for an interesting event.  If we get
        // to the finish before that, we are done.
        //

        for ( fDone = FALSE ; ; )
        {
            ptpWalk = ptpWalk->NextTreePos();

            if (ptpWalk == ptpFinish)
            {
                fDone = TRUE;
                break;
            }

            //
            // If we run accross an edge, either push that tag onto the
            // stack, or remove it.
            //

            if (ptpWalk->IsNode())
            {
                Assert( ptpWalk->IsBeginNode() || ptpWalk->IsEndNode() );
                
                if (ptpWalk->IsBeginNode())
                {
                    Assert( ptpWalk->IsEdgeScope() );
                    
                    pNode = ptpWalk->Branch();
                    pNode->Element()->_fMark1 = 1;

                    IGNORE_HR( aryNodes.Append( pNode ) );
                }
                else
                {
                    int cIncl, cPop;
                    //
                    // Walk the first half of the inclusion
                    //
                    
                    if( !ptpWalk->IsEdgeScope() )
                    {
                        ptpBeforeIncl = ptpWalk;
                    }

                    for ( cIncl = cPop = 0 ;
                          ! ptpWalk->IsEdgeScope() ;
                          cIncl++, ptpWalk = ptpWalk->NextTreePos() )
                    {
                        Assert( ptpWalk != ptpFinish && ptpWalk->IsEndNode() );
                        
                        Assert(
                            !ptpWalk->Branch()->Element()->_fMark1 ||
                            aryNodes [ aryNodes.Size() - cPop - 1 ] == ptpWalk->Branch() );

                        //
                        // We're counting the number of items to pop off the stack, not
                        // the number of non-edge nodes to the left of the inlcusion
                        //
                        
                        if (ptpWalk->Branch()->Element()->_fMark1)
                            cPop++;
                    }

                    //
                    // Mae sure we got to the kernel of the inclusion
                    //

                    Assert( ptpWalk->IsEndNode() );
                    Assert( aryNodes [ aryNodes.Size() - cPop - 1 ] == ptpWalk->Branch() );
                    
                    //
                    // Pop the number of elements before the one going out of scope plus
                    // the real one going out of scope;
                    //

                    aryNodes.SetSize( aryNodes.Size() - cPop - 1 );

                    //
                    // Reset the number of nodes which have already been verified to the current
                    // size of the stack.
                    //
                    
                    nNodesOk = aryNodes.Size();

                    //
                    // Walk the right hand side of the inclusion, putting the non
                    // kernel nodes back on.
                    //

                    while ( cIncl-- )
                    {
                        ptpWalk = ptpWalk->NextTreePos();

                        Assert( ptpWalk->IsBeginNode() && ! ptpWalk->IsEdgeScope() );

                        //
                        // Make sure we don't put an element on which does not participate
                        // in the "move".
                        //
                        
                        if (ptpWalk->Branch()->Element()->_fMark1)
                            aryNodes.Append( ptpWalk->Branch() );
                    }
                }

                break;
            }
        }

        if (fDone)
            break;
    }

    //
    // If we are here, then the validation got through with out
    // any conflicts.  In this case, clear the status pointer.
    //

    hr = THR( pPointerStatus->Unposition() );
    if (hr)
       goto Cleanup;
    
    Assert( hr == S_OK );

Cleanup:

    RRETURN1( hr, S_FALSE );
}

HRESULT 
CDoc::BeginUndoUnit( OLECHAR * pchDescription )
{
    HRESULT hr = S_OK;
    
    if (!pchDescription)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (!_uOpenUnitsCounter)
    {
        _pMarkupServicesParentUndo = new CParentUndo( this );
        
        if (!_pMarkupServicesParentUndo)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = THR( _pMarkupServicesParentUndo->Start( pchDescription ) );
    }        

    _uOpenUnitsCounter++;

Cleanup:
    
    RRETURN( hr );
}

HRESULT 
CDoc::EndUndoUnit ( )
{
    HRESULT hr = S_OK;

    if (!_uOpenUnitsCounter)
        goto Cleanup;

    _uOpenUnitsCounter--;

    if (_uOpenUnitsCounter == 0)
    {
        Assert( _pMarkupServicesParentUndo );
        
        hr = _pMarkupServicesParentUndo->Finish( S_OK );
        
        delete _pMarkupServicesParentUndo;
    }

Cleanup:
    
    RRETURN( hr );
}

HRESULT
CDoc::IsScopedElement ( IHTMLElement * pIHTMLElement, BOOL * pfScoped )
{
    HRESULT hr = S_OK;
    CElement * pElement = NULL;

    if (!pIHTMLElement || !pfScoped || !IsOwnerOf( pIHTMLElement ))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR( pIHTMLElement->QueryInterface( CLSID_CElement, (void **) & pElement ) );
    
    if (hr)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *pfScoped = ! pElement->IsNoScope();
    
Cleanup:
    
    RRETURN( hr );
}


//
// TODO: These switchs are not the bast way to tdo this.  .asc perhaps ?
//

static ELEMENT_TAG_ID
TagIdFromETag ( ELEMENT_TAG etag )
{
    ELEMENT_TAG_ID tagID = TAGID_NULL;
    
    switch( etag )
    {
#define X(Y) case ETAG_##Y:tagID=TAGID_##Y;break;
    X(UNKNOWN) X(A) X(ACRONYM) X(ADDRESS) X(APPLET) X(AREA) X(B) X(BASE) X(BASEFONT)
    X(BDO) X(BGSOUND) X(BIG) X(BLINK) X(BLOCKQUOTE) X(BODY) X(BR) X(BUTTON) X(CAPTION)
    X(CENTER) X(CITE) X(CODE) X(COL) X(COLGROUP) X(COMMENT) X(DD) X(DEL) X(DFN) X(DIR)
    X(DIV) X(DL) X(DT) X(EM) X(EMBED) X(FIELDSET) X(FONT) X(FORM) X(FRAME)
    X(FRAMESET) X(H1) X(H2) X(H3) X(H4) X(H5) X(H6) X(HEAD) X(HR) X(HTML) X(I) X(IFRAME)
    X(IMG) X(INPUT) X(INS) X(KBD) X(LABEL) X(LEGEND) X(LI) X(LINK) X(LISTING)
    X(MAP) X(MARQUEE) X(MENU) X(META) X(NEXTID) X(NOBR) X(NOEMBED) X(NOFRAMES)
    X(NOSCRIPT) X(OBJECT) X(OL) X(OPTION) X(P) X(PARAM) X(PLAINTEXT) X(PRE) X(Q)
#ifdef  NEVER
    X(HTMLAREA)
#endif
    X(RP) X(RT) X(RUBY) X(S) X(SAMP) X(SCRIPT) X(SELECT) X(SMALL) X(SPAN) 
    X(STRIKE) X(STRONG) X(STYLE) X(SUB) X(SUP) X(TABLE) X(TBODY) X(TC) X(TD) X(TEXTAREA)
    X(TFOOT) X(TH) X(THEAD) X(TR) X(TT) X(U) X(UL) X(VAR) X(WBR) X(XMP) X(ROOT) X(OPTGROUP)
#undef X
        
    case ETAG_TITLE_ELEMENT :
    case ETAG_TITLE_TAG :
        tagID = TAGID_TITLE; break;
        
    case ETAG_GENERIC :
    case ETAG_GENERIC_BUILTIN :
    case ETAG_GENERIC_LITERAL :
        tagID = TAGID_GENERIC; break;
        
    case ETAG_RAW_COMMENT :
        tagID = TAGID_COMMENT_RAW; break;
    }

    AssertSz( tagID != TAGID_NULL, "Invalid ELEMENT_TAG" );

    return tagID;
}
    
ELEMENT_TAG
ETagFromTagId ( ELEMENT_TAG_ID tagID )
{
    ELEMENT_TAG etag = ETAG_NULL;
    
    switch( tagID )
    {
#define X(Y) case TAGID_##Y:etag=ETAG_##Y;break;
    X(UNKNOWN) X(A) X(ACRONYM) X(ADDRESS) X(APPLET) X(AREA) X(B) X(BASE) X(BASEFONT)
    X(BDO) X(BGSOUND) X(BIG) X(BLINK) X(BLOCKQUOTE) X(BODY) X(BR) X(BUTTON) X(CAPTION)
    X(CENTER) X(CITE) X(CODE) X(COL) X(COLGROUP) X(COMMENT) X(DD) X(DEL) X(DFN) X(DIR)
    X(DIV) X(DL) X(DT) X(EM) X(EMBED) X(FIELDSET) X(FONT) X(FORM) X(FRAME)
    X(FRAMESET) X(GENERIC) X(H1) X(H2) X(H3) X(H4) X(H5) X(H6) X(HEAD) X(HR) X(HTML) X(I) X(IFRAME)
    X(IMG) X(INPUT) X(INS) X(KBD) X(LABEL) X(LEGEND) X(LI) X(LINK) X(LISTING)
    X(MAP) X(MARQUEE) X(MENU) X(META) X(NEXTID) X(NOBR) X(NOEMBED) X(NOFRAMES)
    X(NOSCRIPT) X(OBJECT) X(OL) X(OPTION) X(P) X(PARAM) X(PLAINTEXT) X(PRE) X(Q)
#ifdef  NEVER
    X(HTMLAREA)
#endif
    X(RP) X(RT) X(RUBY) X(S) X(SAMP) X(SCRIPT) X(SELECT) X(SMALL) X(SPAN) 
    X(STRIKE) X(STRONG) X(STYLE) X(SUB) X(SUP) X(TABLE) X(TBODY) X(TC) X(TD) X(TEXTAREA) 
    X(TFOOT) X(TH) X(THEAD) X(TR) X(TT) X(U) X(UL) X(VAR) X(WBR) X(XMP) X(ROOT) X(OPTGROUP)
#undef X
            
    case TAGID_TITLE : etag = ETAG_TITLE_ELEMENT; break;
    case TAGID_COMMENT_RAW : etag = ETAG_RAW_COMMENT; break;
    }

    AssertSz( etag != ETAG_NULL, "Invalid ELEMENT_TAG_ID" );

    return etag;
}

HRESULT
CDoc::GetElementTagId ( IHTMLElement * pIHTMLElement, ELEMENT_TAG_ID * ptagId )
{
    HRESULT hr;
    CElement * pElement = NULL;

    if (!pIHTMLElement || !ptagId || !IsOwnerOf( pIHTMLElement ))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR( pIHTMLElement->QueryInterface( CLSID_CElement, (void **) & pElement ) );

    if (hr)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (pElement->HasMasterPtr())
    {
        pElement = pElement->GetMasterPtr();
    }
    *ptagId = TagIdFromETag( pElement->Tag() );
    
Cleanup:

    RRETURN( hr );
}

HRESULT
CDoc::GetTagIDForName ( BSTR bstrName, ELEMENT_TAG_ID * ptagId )
{
    HRESULT hr = S_OK;
    
    if (!bstrName || !ptagId)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *ptagId = TagIdFromETag( EtagFromName( bstrName, SysStringLen( bstrName ) ) );

Cleanup:

    RRETURN( hr );
}

HRESULT
CDoc::GetNameForTagID ( ELEMENT_TAG_ID tagId, BSTR * pbstrName )
{
    HRESULT hr = S_OK;
    
    if (!pbstrName)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR( FormsAllocString( NameFromEtag( ETagFromTagId( tagId ) ), pbstrName ) );

    if (hr)
        goto Cleanup;

Cleanup:

    RRETURN( hr );
}

HRESULT
CDoc::CreateElement (
    ELEMENT_TAG_ID   tagID,
    OLECHAR *        pchAttributes,
    IHTMLElement * * ppIHTMLElement )
{
    HRESULT     hr = S_OK;
    ELEMENT_TAG etag;
    CElement *  pElement = NULL;

    if (!ppIHTMLElement)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    etag = ETagFromTagId( tagID );

    if (etag == ETAG_NULL || etag == ETAG_ROOT )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR(
        CreateElement(
            etag, & pElement,
            pchAttributes, pchAttributes ? _tcslen( pchAttributes ) : 0 ) );

    if (hr)
        goto Cleanup;

    hr = THR( pElement->QueryInterface( IID_IHTMLElement, (void **) ppIHTMLElement ) );

    if (hr)
        goto Cleanup;

Cleanup:

    CElement::ReleasePtr( pElement );

    RRETURN( hr );
}


HRESULT
CDoc::CloneElement (
    IHTMLElement *  pElementCloneThis,
    IHTMLElement ** ppElementClone )
{
    HRESULT hr;
    IHTMLDOMNode *pThisDOMNode = NULL;
    IHTMLDOMNode *pDOMNode = NULL;

    if (!pElementCloneThis || !ppElementClone)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR( pElementCloneThis->QueryInterface( IID_IHTMLDOMNode, (void **) & pThisDOMNode ) );

    if (hr)
        goto Cleanup;

    // BUBUG rgardner - should this be Deep ?
    hr = THR( pThisDOMNode->cloneNode( FALSE /* Not Deep */, &pDOMNode ) );
    if (hr)
        goto Cleanup;

    hr = THR( pDOMNode->QueryInterface ( IID_IHTMLElement, (void**)ppElementClone ));
    if (hr)
        goto Cleanup;

Cleanup:

    ClearInterface( & pThisDOMNode );
    ClearInterface( & pDOMNode );
    
    RRETURN( hr );
}

HRESULT
CDoc::CreateMarkupContainer ( IMarkupContainer * * ppIMarkupContainer )
{
    HRESULT   hr;
    CMarkup * pMarkup = NULL;

    if (!ppIMarkupContainer)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // WINDOWEDMARKUP - This is only available to binary code
    hr = THR( CreateMarkup( & pMarkup, PrimaryMarkup() ) );
    if (hr)
        goto Cleanup;

    hr = THR( pMarkup->SetOrphanedMarkup( TRUE ) );
    if( hr )
        goto Cleanup;

    hr = THR(
        pMarkup->QueryInterface(
            IID_IMarkupContainer, (void **) ppIMarkupContainer ) );
    if (hr)
        goto Cleanup;

Cleanup:

    if (pMarkup)
        pMarkup->Release();

    RRETURN( hr );
}


///////////////////////////////////////////////////////
//  tree service helper functions


BOOL
CDoc::IsOwnerOf ( IHTMLElement * pIElement )
{
    HRESULT    hr;
    BOOL       result = FALSE;
    CElement * pElement;

    hr = THR( pIElement->QueryInterface( CLSID_CElement, (void **) & pElement ) );
    
    if (hr)
        goto Cleanup;

    result = this == pElement->Doc();

Cleanup:
    return result;
}


BOOL
CDoc::IsOwnerOf ( IMarkupPointer * pIPointer )
{
    HRESULT         hr;
    BOOL            result = FALSE;
    CMarkupPointer  *pPointer;

    hr =  THR(pIPointer->QueryInterface( CLSID_CMarkupPointer, (void **) & pPointer ) );
    if (hr)
        goto Cleanup;

    result = (this == pPointer->Doc());

Cleanup:        
    return result;
}

BOOL
CDoc::IsOwnerOf ( IHTMLTxtRange * pIRange )
{
    HRESULT         hr;
    BOOL            result = FALSE;
    CAutoRange *    pRange;

    hr = THR( pIRange->QueryInterface( CLSID_CRange, (void **) & pRange ) );
    
    if (hr)
        goto Cleanup;

    result = this == pRange->GetMarkup()->Doc();

Cleanup:
    
    return result;
}

BOOL
CDoc::IsOwnerOf ( IMarkupContainer * pContainer )
{
    HRESULT          hr;
    BOOL             result = FALSE;
    CMarkup         *pMarkup;

    hr = THR(pContainer->QueryInterface(CLSID_CMarkup, (void **)&pMarkup));
    if (hr)
        goto Cleanup;

    result = (this == pMarkup->Doc());

Cleanup:
    return result;
}

HRESULT
CDoc::CutCopyMove (
    IMarkupPointer * pIPointerStart,
    IMarkupPointer * pIPointerFinish,
    IMarkupPointer * pIPointerTarget,
    BOOL             fRemove )
{
    HRESULT          hr = S_OK;
    CMarkupPointer * pPointerStart;
    CMarkupPointer * pPointerFinish;
    CMarkupPointer * pPointerTarget = NULL;

    //
    // Check argument sanity
    //
    
    if (pIPointerStart  == NULL  || !IsOwnerOf( pIPointerStart  ) ||
        pIPointerFinish == NULL  || !IsOwnerOf( pIPointerFinish ) ||
        (pIPointerTarget != NULL && !IsOwnerOf( pIPointerTarget )) )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    //
    // Get the internal objects
    //
    
    hr = THR(
        pIPointerStart->QueryInterface(
            CLSID_CMarkupPointer, (void **) & pPointerStart ) );

    if (hr)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    
    hr = THR(
        pIPointerFinish->QueryInterface(
            CLSID_CMarkupPointer, (void **) & pPointerFinish ) );

    if (hr)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (pIPointerTarget)
    {
        hr = THR(
            pIPointerTarget->QueryInterface(
                CLSID_CMarkupPointer, (void **) & pPointerTarget ) );

        if (hr)
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }
    }

    //
    // More sanity checks
    //

    if (!pPointerStart->IsPositioned() || !pPointerFinish->IsPositioned())
    {
        hr = CTL_E_UNPOSITIONEDPOINTER;
        goto Cleanup;
    }
    
    if (pPointerStart->Markup() != pPointerFinish->Markup())
    {
        hr = CTL_E_INCOMPATIBLEPOINTERS;
        goto Cleanup;
    }

    //
    // Make sure the start if before the finish
    //

    EnsureLogicalOrder( pPointerStart, pPointerFinish );

    //
    // More checks
    //

    if (pPointerTarget && !pPointerTarget->IsPositioned())
    {
        hr = CTL_E_UNPOSITIONEDPOINTER;
        goto Cleanup;
    }

    //
    // Do it
    //

    hr = THR(
        CutCopyMove(
            pPointerStart, pPointerFinish, pPointerTarget, fRemove, NULL ) );

Cleanup:

    RRETURN( hr );
}

HRESULT
CDoc::CutCopyMove (
    CMarkupPointer * pPointerStart,
    CMarkupPointer * pPointerFinish,
    CMarkupPointer * pPointerTarget,
    BOOL             fRemove,
    DWORD            dwFlags )
{
    HRESULT         hr = S_OK;
    CTreePosGap     tpgStart;
    CTreePosGap     tpgFinish;
    CTreePosGap     tpgTarget;
    CMarkup *       pMarkupSource = NULL;
    CMarkup *       pMarkupTarget = NULL;

    //
    // Sanity check the args
    //

    Assert( pPointerStart );
    Assert( pPointerFinish );
    Assert( OldCompare( pPointerStart, pPointerFinish ) <= 0 );
    Assert( pPointerStart->IsPositioned() );
    Assert( pPointerFinish->IsPositioned() );
    Assert( pPointerStart->Markup() == pPointerFinish->Markup() );
    Assert( ! pPointerTarget || pPointerTarget->IsPositioned() );

    //
    // Make sure unembedded pointers get in before the modification
    //

    hr = THR( pPointerStart->Markup()->EmbedPointers() );

    if (hr)
        goto Cleanup;

    if (pPointerTarget)
    {
        hr = THR( pPointerTarget->Markup()->EmbedPointers() );

        if (hr)
            goto Cleanup;
    }

    //
    // Set up the gaps
    //
    
    tpgStart.MoveTo( pPointerStart->GetEmbeddedTreePos(), TPG_LEFT );
    tpgFinish.MoveTo( pPointerFinish->GetEmbeddedTreePos(), TPG_RIGHT );
    
    if (pPointerTarget)
        tpgTarget.MoveTo( pPointerTarget->GetEmbeddedTreePos(), TPG_LEFT );

    pMarkupSource = pPointerStart->Markup();

    if (pPointerTarget)
        pMarkupTarget = pPointerTarget->Markup();

    //
    // Do it.
    //
    
    if (pPointerTarget)
    {
        hr = THR(
            pMarkupSource->SpliceTreeInternal(
                & tpgStart, & tpgFinish, pPointerTarget->Markup(),
                & tpgTarget, fRemove, dwFlags ) );

        if (hr)
            goto Cleanup;
    }
    else
    {
        Assert( fRemove );
        
        hr = THR(
            pMarkupSource->SpliceTreeInternal(
                & tpgStart, & tpgFinish, NULL, NULL, fRemove, dwFlags ) );

        if (hr)
            goto Cleanup;
    }

Cleanup:

    RRETURN( hr );
}



HRESULT         
CDoc::CreateMarkup(CMarkup ** ppMarkup,
                   CMarkup * pMarkupContext,
                   BOOL fIncrementalAlloc,
                   BOOL fPrimary,
                   COmWindowProxy * pWindowPending
                   DBG_COMMA WHEN_DBG(BOOL fWillHaveWindow))
{
    HRESULT         hr;
    CRootElement *  pRootElement = NULL;
    CMarkup *       pMarkup = NULL;

    Assert(ppMarkup);
    Assert( pMarkupContext || fPrimary || pWindowPending || fWillHaveWindow );

    if( _fClearingOrphanedMarkups )
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    pRootElement = new CRootElement(this);
    
    if (!pRootElement)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    pMarkup = new CMarkup(this, fIncrementalAlloc);
    if (!pMarkup)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    if (fPrimary)
    {

        // Set the flag for trust under HTAs. Since this is the primary markup, 
        // we can use the HTA flag of the CDoc directly.
        // This flag is used within the EnsureWindow, so must set it here.
        pMarkup->SetMarkupTrusted(_fHostedInHTA || _fInTrustedHTMLDlg);

        hr = THR(pMarkup->CreateWindowHelper());
        if (hr)
            goto Cleanup;
            
        _pWindowPrimary = pMarkup->Window();
        Assert(_pWindowPrimary);
        _pWindowPrimary->AddRef();

        _pWindowPrimary->Window()->SetWindowIndex(WID_TOPWINDOW);
    }
    else if( pMarkupContext )
    {
        pMarkup->SetWindowedMarkupContextPtr( pMarkupContext );
        pMarkupContext->SubAddRef();
    }

    if (pWindowPending)
    {
        
        CWindow *   pWindow             = pWindowPending->Window();
        CMarkup *   pMarkupPendingOld   = pWindow->_pMarkupPending;
        DWORD       dwFrameOptionsOld   = pWindow->_pMarkup->GetFrameOptions();
        mediaType   mtOld               = pWindow->_pMarkup->GetMedia();
        
        Assert(pWindow->Doc() == this);
        if (pMarkupPendingOld)
            pWindow->ReleaseMarkupPending(pMarkupPendingOld);

        hr = pMarkup->SetWindow(pWindowPending);
        if (hr)
            goto Cleanup;

        pMarkup->_fWindowPending = TRUE;

        pWindow->_pMarkupPending = pMarkup;
        pMarkup->AddRef();  // The pending CWindow owns the markup

        // TODO (KTam): If we need to copy even more stuff from the
        // old markup, consider a helper fn.

        // Copy frame options from the old markup to the new one
        if (dwFrameOptionsOld)
        {
            hr = THR(pMarkup->SetFrameOptions(dwFrameOptionsOld));
            if (hr)
                goto Cleanup;
        }

        pMarkup->SetMarkupTrusted(pWindow->_pMarkup->IsMarkupTrusted());

        // Copy media from old markup to the new one
        if ( mtOld != mediaTypeNotSet )
        {
            hr = THR(pMarkup->SetMedia(mtOld));
            if (hr)
                goto Cleanup;
        }
    }

    hr = THR(pRootElement->Init());
    if (hr)
        goto Cleanup;

    {
        CElement::CInit2Context   context(NULL, pMarkup);

        hr = THR(pRootElement->Init2(&context));
        if (hr)
            goto Cleanup;
    }

    hr = THR(pMarkup->Init(pRootElement));
    if (hr)
        goto Cleanup;

    SetEditBitsForMarkup( pMarkup );
    
    *ppMarkup = pMarkup;
    pMarkup = NULL;

Cleanup:
    if (pMarkup)
        pMarkup->Release();

    CElement::ReleasePtr(pRootElement);
    RRETURN(hr);
}


HRESULT         
CDoc::CreateMarkupWithElement( 
    CMarkup ** ppMarkup, 
    CElement * pElement,
    BOOL       fIncrementalAlloc)
{
    HRESULT   hr = S_OK;
    CMarkup * pMarkup = NULL;

    Assert( pElement && !pElement->IsInMarkup() );

    hr = THR( CreateMarkup( &pMarkup, pElement->GetWindowedMarkupContext(), fIncrementalAlloc ) );
    if (hr)
        goto Cleanup;

    hr = THR( pMarkup->SetOrphanedMarkup( TRUE ) );
    if( hr )
        goto Cleanup;

    // Insert the element into the empty tree
    
    {
        CTreePos * ptpRootBegin = pMarkup->FirstTreePos();
        CTreePos * ptpNew;
        CTreeNode *pNodeNew;

        Assert( ptpRootBegin );
    
        // Assert that the only thing in this tree is two WCH_NODE characters
        Assert( pMarkup->Cch() == 2 );

        pNodeNew = new CTreeNode( pMarkup->Root()->GetFirstBranch(), pElement );
        if( !pNodeNew )
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        Assert( pNodeNew->GetEndPos()->IsUninit() );
        ptpNew = pNodeNew->InitEndPos( TRUE );
        hr = THR( pMarkup->Insert( ptpNew, ptpRootBegin, FALSE ) );
        if(hr)
        {
            // The node never made it into the tree
            // so delete it
            delete pNodeNew;

            goto Cleanup;
        }

        Assert( pNodeNew->GetBeginPos()->IsUninit() );
        ptpNew = pNodeNew->InitBeginPos( TRUE );
        hr = THR( pMarkup->Insert( ptpNew, ptpRootBegin, FALSE ) );
        if(hr)
            goto Cleanup;

        pNodeNew->PrivateEnterTree();

        pElement->SetMarkupPtr( pMarkup );
        pElement->__pNodeFirstBranch = pNodeNew;
        pElement->PrivateEnterTree();

        {
            CNotification   nf;
            nf.ElementEntertree(pElement);
            pElement->Notify(&nf);
        }

        // Insert the WCH_NODE characters for the element
        // The 2 is hardcoded since we know that there are
        // only 2 WCH_NODE characters for the root
        Verify(
            ULONG(
                CTxtPtr( pMarkup, 2 ).
                    InsertRepeatingChar( 2, WCH_NODE ) ) == 2 );

        // Don't send a notification but do update the 
        // debug character count
        WHEN_DBG( pMarkup->_cchTotalDbg += 2 );
        WHEN_DBG( pMarkup->_cElementsTotalDbg += 1 );

        Assert( pMarkup->IsNodeValid() );

    }

    if (ppMarkup)
    {
        *ppMarkup = pMarkup;
        pMarkup->AddRef();
    }
    
Cleanup:
    if(pMarkup)
        pMarkup->Release();

    RRETURN(hr);
}


#if DBG==1

struct TagPos
{
    IHTMLElement * pel;
    BOOL           fEnd;
    TCHAR *        pText;
    long           cch;
};

void
Stuff ( CDoc * pDoc, IMarkupServices * pms, IHTMLElement * pIElement )
{
    HRESULT            hr = S_OK;
    IHTMLDocument2 *   pDoc2    = NULL;
    IMarkupServices *  pMS      = NULL;
    IMarkupContainer2* pMarkup  = NULL;
    IMarkupPointer *   pPtr1    = NULL, * pPtr2 = NULL;
    IMarkupPointer2 *  pmp2     = NULL;
    TCHAR          *   pstrFrom = _T( "XY" );
    TCHAR          *   pstrTo = _T( "AB" );
    
    pDoc->QueryInterface( IID_IHTMLDocument2, (void **) & pDoc2 );

    pDoc2->QueryInterface( IID_IMarkupContainer2, (void **) & pMarkup );
    pDoc2->QueryInterface( IID_IMarkupServices, (void **) & pMS );

    pMS->CreateMarkupPointer( & pPtr1 );
    pMS->CreateMarkupPointer( & pPtr2 );

    //
    // Set gravity of this pointer so that when the replacement text is inserted
    // it will float to be after it.
    //

    pPtr1->SetGravity( POINTER_GRAVITY_Right );

    //
    // Start the seach at the beginning of the primary container
    //

    pPtr1->MoveToContainer( pMarkup, TRUE );

    for ( ; ; )
    {
        long nFoo;

        hr = pPtr1->FindText( pstrFrom, 0, pPtr2, NULL );


        if (hr == S_FALSE)
            break;

        pMS->Remove( pPtr1, pPtr2 );
        
        pMS->InsertText( pstrTo, -1, pPtr1 );
        nFoo = pMarkup->GetVersionNumber();
    }

    pPtr1->QueryInterface( IID_IMarkupPointer2, (void **)&pmp2 );

    pmp2->MoveToContainer( pMarkup, TRUE );
    pPtr2->MoveToPointer( pmp2 );
    for( int i = 0; i < 5; i++ )
    {
        pPtr2->MoveUnit( MOVEUNIT_NEXTWORDBEGIN );
    }

    pmp2->MoveToContainer( pMarkup, TRUE );
    
    pmp2->MoveUnitBounded( MOVEUNIT_NEXTURLBEGIN, pPtr2 );

    ReleaseInterface( pPtr1 );
    ReleaseInterface( pPtr2 );
    ReleaseInterface( pmp2 );
    ReleaseInterface( pMS );
    ReleaseInterface( pMarkup );
    ReleaseInterface( pDoc2 );
}

void
TestTreeSync2( CDoc * pDoc, IMarkupServices *pms )
{
    IHTMLDocument2          *   pDoc2       = NULL;
    IMarkupContainer2       *   pMarkup2    = NULL;
    IMarkupServices         *   pMS         = NULL;
    IHTMLChangeLog          *   pChangeLog  = NULL;
    static CChangeSink      *   pChangeSink = NULL;
    IHTMLIFrameElement2     *   pFrameSrc   = NULL;
    IHTMLIFrameElement2     *   pFrameDest  = NULL;
    IHTMLFramesCollection2  *   pcolFrames  = NULL;
    IHTMLElement            *   pElemSrc    = NULL;
    IHTMLElement            *   pElemDest   = NULL;
    IDispatchEx             *   pDispSrc    = NULL;
    IDispatchEx             *   pDispDest   = NULL;
    IMarkupPointer2         *   pMP         = NULL;
    IHTMLDocument2          *   pDocSrc     = NULL;
    IHTMLDocument2          *   pDocDest    = NULL;
    IMarkupContainer2       *   pMarkupSrc  = NULL;
    IMarkupContainer2       *   pMarkupDest = NULL;
    BSTR                        bstr        = NULL;
    CMarkup                 *   pMarkup     = NULL;
    VARIANT                     vt;
    VARIANT                     vt2;
    DISPID                      dispid;
    HRESULT                     hr;
    long                        nFrames;

    VariantInit(&vt);
    VariantInit(&vt2);


    if( !pChangeSink )
    {
        hr = pDoc->QueryInterface( IID_IHTMLDocument2, (void **)&pDoc2 );
        hr = pDoc->QueryInterface( IID_IMarkupContainer2, (void **)&pMarkup2);
        hr = pDoc->QueryInterface( IID_IMarkupServices, (void **)&pMS);

#if 0
        // This don't work, because you can't edit a just-inserted IFRAME
        // Create a bunch of stuff
        hr = pMS->CreateElement( TAGID_IFRAME, _T("id=srcFrame"), &pElemSrc );
        hr = pMS->CreateElement( TAGID_IFRAME, _T("id=destFrame"), &pElemDest );
        hr = pElemSrc->QueryInterface( IID_IHTMLIFrameElement2, (void **)&pFrameSrc );
        hr = pElemDest->QueryInterface( IID_IHTMLIFrameElement2, (void **)&pFrameDest );
        hr = pElemSrc->QueryInterface( IID_IDispatchEx, (void **)&pDispSrc);
        hr = pElemDest->QueryInterface( IID_IDispatchEx, (void **)&pDispDest );
        hr = pMS->CreateMarkupPointer( (IMarkupPointer **)&pMP );

        // Insert the IFRAMEs
        hr = pMP->MoveToMarkupPosition( pMarkup2, 9 );
        hr = pMP->SetGravity( POINTER_GRAVITY_Right );
        hr = pMS->InsertElement( pElemSrc, pMP, pMP );
        hr = pMS->InsertElement( pElemDest, pMP, pMP );

        // Make them pretty
        V_VT(&vt) = VT_I4;
        V_I4(&vt) = 100;
        hr = pFrameSrc->put_width( vt );
        hr = pFrameSrc->put_height( vt );
        hr = pFrameDest->put_width( vt );
        hr = pFrameDest->put_height( vt );
#endif // 0

        // Get the frame windows
        hr = pDoc2->get_frames( &pcolFrames );
        hr = pcolFrames->get_length( &nFrames );

        if( nFrames == 2 )
        {
            // If we have 2 frames, have the first one TreeSync into the second
            V_VT(&vt) = VT_I4;
            V_I4(&vt) = 0;
            hr = pcolFrames->item( &vt, &vt2 );
            V_DISPATCH(&vt2)->QueryInterface( IID_IDispatchEx, (void **)&pDispSrc );
            VariantClear(&vt2);
        
            V_I4(&vt) = 1;
            hr = pcolFrames->item( &vt, &vt2 );
            V_DISPATCH(&vt2)->QueryInterface( IID_IDispatchEx, (void **)&pDispDest );
            VariantClear(&vt2);

            // Get their documents
            bstr = SysAllocString( _T("document") );

            hr = pDispSrc->GetDispID( bstr, 0, &dispid );

            hr = GetDispProp( pDispSrc,
                              dispid,
                              g_lcidUserDefault,
                              &vt2,
                              NULL,
                              0);
            hr = V_DISPATCH(&vt2)->QueryInterface( IID_IHTMLDocument2, (void **)&pDocSrc );
            VariantClear(&vt2);

            hr = GetDispProp( pDispDest,
                             dispid,
                             g_lcidUserDefault,
                             &vt2,
                             NULL,
                             0);
            hr = V_DISPATCH(&vt2)->QueryInterface( IID_IHTMLDocument2, (void **)&pDocDest );
            VariantClear(&vt2);

            // Get their markup containers
            hr = pDocSrc->QueryInterface( IID_IMarkupContainer2, (void **)&pMarkupSrc );
            hr = pDocDest->QueryInterface( IID_IMarkupContainer2, (void **)&pMarkupDest );

            // And do this stuff
            pChangeSink = new CChangeSink( NULL );

            hr = pMarkupSrc->CreateChangeLog( pChangeSink, &pChangeLog, TRUE, TRUE );
            hr = pMarkupSrc->QueryInterface( CLSID_CMarkup, (void **)&pMarkup );

            Verify( pChangeSink->_pLogMgr = pMarkup->GetLogManager() );
            Verify( pChangeSink->_pLog = pChangeLog );
            pChangeSink->_pMarkupSync = pMarkupDest;
            pChangeSink->_pMarkupSync->AddRef();
        }
        else
        {
            // Just set up TreeSync dumping on the primary markup
            pChangeSink = new CChangeSink( NULL );
            hr = pMarkup2->CreateChangeLog( pChangeSink, &pChangeLog, TRUE, TRUE );
            hr = pMarkup2->QueryInterface( CLSID_CMarkup, (void **)&pMarkup );
            Verify( pChangeSink->_pLogMgr = pMarkup->GetLogManager() );
            Verify( pChangeSink->_pLog = pChangeLog );
        }
    }
    else
    {
        ClearInterface( &pChangeSink->_pLog );
        pChangeSink->Release();
        pChangeSink = NULL;
    }

//Cleanup:
    ReleaseInterface( pDoc2 );
    ReleaseInterface( pMarkup2 );
    ReleaseInterface( pMS );
    ReleaseInterface( pFrameSrc );
    ReleaseInterface( pFrameDest );
    ReleaseInterface( pcolFrames );
    ReleaseInterface( pElemSrc );
    ReleaseInterface( pElemDest );
    ReleaseInterface( pDispSrc );
    ReleaseInterface( pDispDest );
    ReleaseInterface( pMP );
    ReleaseInterface( pDocSrc );
    ReleaseInterface( pDocDest );
    ReleaseInterface( pMarkupSrc );
    ReleaseInterface( pMarkupDest );
    SysFreeString( bstr );
//    ReleaseInterface();
}

void
TestTreeSync( CDoc * pDoc, IMarkupServices *pms )
{
    IHTMLDocument2      *   pDoc2       = NULL;
    IMarkupContainer2   *   pMarkup2    = NULL;
    IHTMLChangeLog      *   pChangeLog  = NULL;
    static CChangeSink  *   pChangeSink = NULL;
    CMarkup             *   pMarkup     = NULL;
    BOOL                    fCheat      = FALSE;
    HRESULT                 hr;

    pDoc->QueryInterface( IID_IHTMLDocument2, (void **)&pDoc2 );
    pDoc2->QueryInterface( IID_IMarkupContainer2, (void **)&pMarkup2 );
    pMarkup = pDoc->PrimaryMarkup();         // ptr to primary window

    if( !pChangeSink )
    {
        pChangeSink = new CChangeSink( pMarkup->GetLogManager() );

        if( FAILED( pMarkup2->CreateChangeLog( pChangeSink, &pChangeLog, TRUE, TRUE ) ) )
        {
            delete pChangeSink;
            goto Cleanup;
        }

        if( fCheat )
        {
            pChangeSink->_pMarkupSync = pMarkup2;
            pChangeSink->_pMarkupSync->AddRef();
        }
        pChangeSink->Release();
        pChangeSink->_pLog = pChangeLog;
        Verify( pChangeSink->_pLogMgr = pMarkup->GetLogManager() );
    }
    else
    {
        if( fCheat )
        {
            IStream         * pstm;
            IMarkupContainer * pMC;

            hr = pMarkup2->QueryInterface( IID_IMarkupContainer, (void **)&pMC );
            hr = CoMarshalInterThreadInterfaceInStream( IID_IMarkupContainer, pMarkup2, &pstm );
        }

        // Ditch the Log
        ClearInterface( &pChangeSink->_pLog );
        // We should really have held a sub ref on the sink, but it's debug code so I don't care.
        pChangeSink = NULL;
    }

Cleanup:
    ReleaseInterface( pDoc2 );
    ReleaseInterface( pMarkup2 );
}

void
TestMarkupServices ( CElement * pElement )
{
    IMarkupServices * pIMarkupServices = NULL;
    IMarkupContainer * pMarkupContainer = NULL;
    IHTMLElement *pIElement = NULL;
    CDoc *pDoc = pElement->Doc();
    IMarkupPointer * mp1 = NULL, * mp2 = NULL;
#ifdef TESTGLOBAL
    HGLOBAL hGlobal = NULL;
    TCHAR * pch = NULL;
#endif

    pElement->QueryInterface( IID_IHTMLElement, (void * *) & pIElement );
    pDoc->QueryInterface( IID_IMarkupServices, (void * *) & pIMarkupServices );
    pDoc->QueryInterface( IID_IMarkupContainer, (void **) & pMarkupContainer );

    pIMarkupServices->CreateMarkupPointer( & mp1 );
    pIMarkupServices->CreateMarkupPointer( & mp2 );

    mp1->MoveToContainer( pMarkupContainer, TRUE );
    
    mp1->Right( TRUE, NULL, NULL, NULL, NULL );
    mp1->Right( TRUE, NULL, NULL, NULL, NULL );
    mp1->Right( TRUE, NULL, NULL, NULL, NULL );
    mp1->Right( TRUE, NULL, NULL, NULL, NULL );
    mp1->Right( TRUE, NULL, NULL, NULL, NULL );
    mp1->Right( TRUE, NULL, NULL, NULL, NULL );
    mp1->Right( TRUE, NULL, NULL, NULL, NULL );

    mp2->MoveToPointer( mp1 );
    
    mp2->Right( TRUE, NULL, NULL, NULL, NULL );
    mp2->Right( TRUE, NULL, NULL, NULL, NULL );
    mp2->Right( TRUE, NULL, NULL, NULL, NULL );
    mp2->Right( TRUE, NULL, NULL, NULL, NULL );
    mp2->Right( TRUE, NULL, NULL, NULL, NULL );

    // pIMarkupServices->Remove( mp1, mp2 );

    Stuff( pDoc, pIMarkupServices, pIElement );

    // TestTreeSync( pDoc, pIMarkupServices );
    TestTreeSync2( pDoc, pIMarkupServices );

#ifdef TESTGLOBAL
    ReleaseInterface( pMarkupContainer );
    hGlobal = GlobalAlloc( GMEM_MOVEABLE, 4096 );
    pch = (TCHAR *)GlobalLock( hGlobal );
    _tcscpy( pch, _T("<HTML><BODY>Hi</BODY></HTML>") );
    GlobalUnlock( hGlobal );
    pIMarkupServices->ParseGlobal( hGlobal, 0, &pMarkupContainer, mp1, mp2 );
    GlobalFree( hGlobal );
#endif

    ReleaseInterface( pIMarkupServices );
    ReleaseInterface( pIElement );
    ReleaseInterface( pMarkupContainer );
    ReleaseInterface( mp1 );
    ReleaseInterface( mp2 );
}

#endif // DBG==1



HRESULT
CDoc::ValidateElements (
    IMarkupPointer  *pPointerStart,
    IMarkupPointer  *pPointerFinish,
    IMarkupPointer  *pPointerTarget,
    IMarkupPointer  *pPointerStatus,
    IHTMLElement    **ppElemFailBottom,
    IHTMLElement    **ppElemFailTop )
{
    HRESULT         hr;
    HRESULT         hrResult = S_OK;
    CMarkupPointer  *pPointerStartInternal = NULL;
    CMarkupPointer  *pPointerFinishInternal = NULL;
    CMarkupPointer  *pPointerTargetInternal = NULL;
    CMarkupPointer  *pPointerStatusInternal = NULL;
    CTreeNode       *pNodeFailBottom = NULL;
    CTreeNode       *pNodeFailTop = NULL;

    //
    // check argument sanity
    //
    if (!pPointerStart || !pPointerFinish)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (ppElemFailBottom)
        *ppElemFailBottom = NULL;

    if (ppElemFailTop)
        *ppElemFailTop = NULL;

    hr = THR( pPointerStart->QueryInterface(CLSID_CMarkupPointer, (LPVOID *)&pPointerStartInternal) );
    if (hr)
        goto Cleanup;

    hr = THR( pPointerFinish->QueryInterface(CLSID_CMarkupPointer, (LPVOID *)&pPointerFinishInternal) );
    if (hr)
        goto Cleanup;

    //
    // pPointerStart/pPointerEnd should be positioned and in the same markup
    //

    if (!pPointerStartInternal->IsPositioned()
        || !pPointerFinishInternal->IsPositioned()
        || pPointerStartInternal->Markup() != pPointerFinishInternal->Markup())
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (pPointerStatus)
    {
        hr = THR( pPointerStatus->QueryInterface(CLSID_CMarkupPointer, (LPVOID *)&pPointerStatusInternal) );
        if (hr)
            goto Cleanup;

        //
        // Validate pPointerStatus position
        //
        if (pPointerStatusInternal->IsPositioned())
        {
            if (pPointerStatusInternal->Markup() != pPointerStartInternal->Markup()
                || !pPointerStatusInternal->IsRightOfOrEqualTo(pPointerStartInternal)
                || !pPointerStatusInternal->IsLeftOfOrEqualTo(pPointerFinishInternal)
                )
            {
                hr = E_INVALIDARG;
                goto Cleanup;
            }
        }
    }

    if (pPointerTarget)
    {
        hr = THR( pPointerTarget->QueryInterface(CLSID_CMarkupPointer, (LPVOID *)&pPointerTargetInternal) );
        if (hr)
            goto Cleanup;
    }

    if (pPointerTargetInternal && pPointerTargetInternal->Markup() == pPointerStartInternal->Markup())
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    //
    // Delegate and propagate the S_OK/S_FALSE distinction
    //
    hrResult = THR( ValidateElements(
                pPointerStartInternal, 
                pPointerFinishInternal, 
                pPointerTargetInternal, 
                0 /* dwFlags */,
                pPointerStatusInternal,
                &pNodeFailBottom,
                &pNodeFailTop) );

    if (FAILED(hrResult))
    {
        hr = hrResult;
        goto Cleanup;
    }

    if (ppElemFailBottom)
    {
        if (pNodeFailBottom)
        {
            hr = THR( pNodeFailBottom->GetElementInterface(IID_IHTMLElement, (LPVOID *)ppElemFailBottom) );
            if (hr)
                goto Cleanup;
        }
        else
        {
            *ppElemFailBottom = NULL;
        }
    }

    if (ppElemFailTop)
    {
        if (pNodeFailTop)
        {
            hr = THR( pNodeFailTop->GetElementInterface(IID_IHTMLElement, (LPVOID *)ppElemFailTop) );
            if (hr)
                goto Cleanup;
        }
        else
        {
            *ppElemFailTop = NULL;
        }
    }

Cleanup:
    if (SUCCEEDED(hr))
        hr = hrResult;

    RRETURN1(hr, S_FALSE);
}

HRESULT
CDoc::ParseGlobalEx (
    HGLOBAL              hGlobal,
    DWORD                dwFlags,
    IMarkupContainer     *pIContextMarkup,
    IMarkupContainer     **ppIContainerResult,
    IMarkupPointer       *pIPointerSelStart,
    IMarkupPointer       *pIPointerSelFinish )
{
    HRESULT          hr = S_OK;
    CMarkup *        pMarkup = NULL;
    CMarkupPointer * pPointerSelStart = NULL;
    CMarkupPointer * pPointerSelFinish = NULL;
    CMarkup *        pContextMarkup = NULL;

    if (!ppIContainerResult)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *ppIContainerResult = NULL;

    if (!hGlobal)
        goto Cleanup;

    if (pIPointerSelStart)
    {
        hr = THR(
            pIPointerSelStart->QueryInterface(
                CLSID_CMarkupPointer, (void **) & pPointerSelStart ) );

        if (hr)
            goto Cleanup;
    }

    if (pIPointerSelFinish)
    {
        hr = THR(
            pIPointerSelFinish->QueryInterface(
                CLSID_CMarkupPointer, (void **) & pPointerSelFinish ) );

        if (hr)
            goto Cleanup;
    }

    if (pIContextMarkup)
    {
        hr = THR(
            pIContextMarkup->QueryInterface(
                CLSID_CMarkup, (void **)&pContextMarkup) );

        if (hr)
            goto Cleanup;
    }

    hr = THR(
        ParseGlobal(
            hGlobal, dwFlags, pContextMarkup, & pMarkup, pPointerSelStart, pPointerSelFinish ) );

    if (hr)
        goto Cleanup;

    if (pMarkup)
    {
        hr = THR(
            pMarkup->QueryInterface(
                IID_IMarkupContainer, (void **) ppIContainerResult ) );

        if (hr)
            goto Cleanup;
    }

Cleanup:

    if (pMarkup)
        pMarkup->Release();

    RRETURN( hr );
}


//+====================================================================================
//
// Method: SaveSegmentsToClipboard
//
// Synopsis: Saves a SegmentList to the clipboard
//
//------------------------------------------------------------------------------------

HRESULT
#ifndef UNIX
CDoc::SaveSegmentsToClipboard( ISegmentList * pSegmentList,
                               DWORD dwFlags )
#else
CDoc::SaveSegmentsToClipboard( ISegmentList * pSegmentList, 
                               DWORD dwFlags,
                               VARIANTARG *pvarargOut)
#endif
{
    CMarkup      *      pMarkup;
    BOOL                fEqual;
    CTextXBag    *      pBag = NULL;
    IDataObject  *      pDO = NULL;
    HRESULT             hr = S_OK;
    DWORD               dwFlagsInternal = dwFlags & CREATE_FLAGS_ExternalMask;
    IMarkupPointer *    pStart  = NULL;
    IMarkupPointer *    pEnd = NULL;
    CMarkupPointer *    pointerStart = NULL;
    CMarkupPointer *    pointerEnd = NULL;
    CTreeNode *         pNodeStart;
    CTreeNode *         pNodeEnd;
    CTreeNode *         pAncestor;
    CWindow *           pWindow = NULL;

    ISegmentListIterator *pIter = NULL;
    ISegment             *pSegment = NULL;
#if DBG==1
    BOOL                 fEmpty = FALSE;
#endif
    
    hr = THR( CreateMarkupPointer( & pStart ));
    if ( hr )
        goto Cleanup;

    hr = THR( CreateMarkupPointer( & pEnd ));
    if ( hr )
        goto Cleanup;

    hr = THR( pSegmentList->CreateIterator( &pIter ));
    if ( hr )
        goto Cleanup;

#if DBG
    hr = THR( pSegmentList->IsEmpty( &fEmpty ) );
    if ( hr )
        goto Cleanup;

    Assert(!fEmpty);
#endif

    hr = THR( pIter->Current(&pSegment) );
    if ( hr )
        goto Cleanup;

    hr = THR( pSegment->GetPointers( pStart, pEnd ));
    if ( hr )
        goto Cleanup;

    hr = THR( pStart->IsEqualTo ( pEnd, & fEqual ) );
    if (hr)
        goto Cleanup;

    if (fEqual)
    {
        // There is nothing to save
        hr = S_OK;
        goto Cleanup;
    }
    
    hr = THR( pStart->QueryInterface( CLSID_CMarkupPointer, ( void** ) & pointerStart));
    if ( hr )
        goto Cleanup;

    hr = THR( pEnd->QueryInterface( CLSID_CMarkupPointer, ( void** ) & pointerEnd));
    if ( hr )
        goto Cleanup;

    Assert( pointerStart->IsPositioned() && pointerEnd->IsPositioned() );

    pMarkup = pointerStart->Markup();
    if ( pMarkup != pointerEnd->Markup() )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    pNodeStart = pointerStart->CurrentScope( MPTR_SHOWSLAVE );
    pNodeEnd   = pointerEnd->CurrentScope( MPTR_SHOWSLAVE );
    
    if ( !pNodeStart || !pNodeEnd )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    
    pAncestor = pNodeStart->GetFirstCommonAncestor( pNodeEnd, NULL );

    if( pAncestor && pAncestor->SupportsHtml() )
    {
        dwFlagsInternal |= CREATE_FLAGS_SupportsHtml;
    }

    hr = THR( CTextXBag::Create( 
            pMarkup, dwFlagsInternal, pSegmentList, FALSE, & pBag) );
                                                                  
    if (hr)
        goto Cleanup;

#ifdef UNIX // This is used for MMB-paste to save selected text to buffer.
    if (pvarargOut)
    {
        if (pBag->_hUnicodeText)
        {
            hr = THR(g_uxQuickCopyBuffer.GetTextSelection(pBag->_hUnicodeText,
                                                          TRUE,
                                                          pvarargOut));
        }
        else
        {
            hr = THR(g_uxQuickCopyBuffer.GetTextSelection(pBag->_hText,
                                                          FALSE,
                                                          pvarargOut));
        }
        goto Cleanup;
    }
#endif // UNIX

    hr = THR(pBag->QueryInterface(IID_IDataObject, (void **) & pDO ));
    if (hr)
        goto Cleanup;

    Assert(pMarkup->GetWindowedMarkupContext());

    pWindow = pMarkup->GetWindowedMarkupContext()->GetWindowPending()->Window();

    hr = THR( pWindow->SetClipboard( pDO ) );
    if (hr)
        goto Cleanup;

Cleanup:
    if( pBag )
    {
        pBag->Release();
    }
    ReleaseInterface( pDO );
    ReleaseInterface( pStart );
    ReleaseInterface( pEnd );
    ReleaseInterface( pIter );
    ReleaseInterface( pSegment );

    RRETURN( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\treeiter.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_ELEMENT_HXX
#include "element.hxx"
#endif

#include "markup.hxx"

#include "treepos.hxx"

#include "treeiter.hxx"

#ifndef _X_GENERIC_H_
#define _X_GENERIC_H_
#include "generic.hxx"
#endif

#ifdef V4FRAMEWORK


MtDefine(CTreeIterator, ObjectModel, "CTreeIterator")

#include "treeiter.h"

#define _cxx_
#include "treeiter.hdl"



HRESULT
CExternalFrameworkSite::GetNewTreeIterator ( long lRefElement, IDispatch **pTreeIterator )
{
    CElement *pElem = (CElement *)lRefElement;
    HRESULT hr = S_OK;
    CTreeIterator *pIterator = NULL;
    CTreeNode *pChildNode,*pParentNode;

    // If pElem NULL, iterator for root of tree ??

    Assert(pElem);
    Assert(pElem->Tag()==ETAG_GENERIC);

    if ( !pTreeIterator )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pTreeIterator = NULL;

    pChildNode = pElem->GetFirstBranch(); // Ignore overlapping for now
    if (!pChildNode)
        goto Cleanup;

    pParentNode = pChildNode->Parent();
    if(!pParentNode)
        goto Cleanup;

    pIterator = new CTreeIterator(pParentNode, pChildNode);
    if ( !pIterator )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(pIterator->QueryInterface(IID_IDispatch, (void**)pTreeIterator));
    if ( hr )
        goto Cleanup;

    // Refcount of 2 at this point

Cleanup:
    if ( pIterator ) 
        pIterator->Release();
    RRETURN(hr);
}



    //+----------------------------------------------------------------
//
//  member : classdesc
//
//+----------------------------------------------------------------
const CBase::CLASSDESC CTreeIterator::s_classdesc =
{
    &CLSID_TreeIterator,   // _pclsid
    0,                                      // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                                   // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                                   // _pcpi
    0,                                      // _dwFlags
    &IID_ITreeIterator,    // _piidDispinterface
    &s_apHdlDescs                           // _apHdlDesc
};

//+---------------------------------------------------------------
//
//  Member  : CTreeIterator::PrivateQueryInterface
//
//  Sysnopsis : Vanilla implementation for this class
//
//----------------------------------------------------------------
HRESULT
CTreeIterator::PrivateQueryInterface(REFIID iid, void **ppv)
{
    *ppv = NULL;
    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_TEAROFF_DISPEX(this, NULL)
    default:
        if (iid == IID_ITreeIterator)               
        {                                   
        HRESULT hr = CreateTearOffThunk(    
            this,                           
            (void *)this->s_apfnITreeIterator,      
            NULL, //pUnkOuter                     
            ppv);                           
        if (hr)                             
            RRETURN(hr);                    
        }
        break;
    }

    if (*ppv)
    {
        (*(IUnknown**)ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

HRESULT CTreeIterator::MoveToElement ( long lRefElement )
{
    CElement *pElement = (CElement *)lRefElement;

    Assert(pElement);
    Assert(pElement->Tag()==ETAG_GENERIC);



    return S_OK;
}

HRESULT CTreeIterator::Ascend(long *prefScopeElement)
{
    HRESULT hr = S_OK;
    if ( !prefScopeElement )
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    *prefScopeElement = 0;


Cleanup:
    RRETURN(hr);
}

HRESULT CTreeIterator::Next(long *prefScopeElement)
{
    HRESULT hr = S_OK;
    CTreeNode *pNode;
    CGenericElement::COMPLUSREF cpRef;

    if (prefScopeElement)
    {
        *prefScopeElement = 0;
    }

    pNode = _iterator.NextChild(); 
    if (!pNode)
        goto Cleanup;

    if (prefScopeElement)
    {
        CElement *pElem = pNode->Element();
        if (pElem->Tag() != ETAG_GENERIC) // TODO
        {
            hr = THR(Next(prefScopeElement)); // Skip it for now
            if (hr)
                goto Cleanup;
        }
        else
        {
            hr = ((CGenericElement*)pElem)->GetComPlusReference ( &cpRef );
            if (hr)
                goto Cleanup;
            *prefScopeElement = (long)cpRef;
        }
    }
Cleanup:
    RRETURN(hr);
}


HRESULT CTreeIterator::Previous(long *prefScopeElement)
{
    HRESULT hr = S_OK;
    CTreeNode *pNode;
    CGenericElement::COMPLUSREF cpRef;

    if (prefScopeElement)
    {
        *prefScopeElement = 0;
    }

    pNode = _iterator.PreviousChild(); 
    if (!pNode)
        goto Cleanup;

    if (prefScopeElement)
    {
        CElement *pElem = pNode->Element();
        if (pElem->Tag() != ETAG_GENERIC) // TODO
        {
            hr = THR(Next(prefScopeElement)); // Skip it for now
            if (hr)
                goto Cleanup;
        }
        else
        {
            hr = ((CGenericElement*)pElem)->GetComPlusReference ( &cpRef );
            if (hr)
                goto Cleanup;
            *prefScopeElement = (long)cpRef;
        }
    }
Cleanup:
    RRETURN(hr);
}

HRESULT CTreeIterator::Descend(long *prefScopeElement)
{
    // Move to the first Child of the current iterator
    HRESULT hr = S_OK;
    CTreeNode *pNode;
    CGenericElement::COMPLUSREF cpRef;

    if (prefScopeElement)
    {
        *prefScopeElement = 0;
    }

    if (!_iterator.ReInitWithCurrentChild())
        goto Cleanup;

    // Semantics of ReInitWithCurrentChild position me before the begin of the first child
    
    pNode = _iterator.NextChild();
    if ( !pNode )
    {
        // No first child, position me back where I was!
        _iterator.ReInitWithParent();
        goto Cleanup;
    }

    if (prefScopeElement)
    {
        CElement *pElem = pNode->Element();
        if (pElem->Tag() != ETAG_GENERIC) // TODO
        {
            //hr = THR(Next(prefScopeElement)); // Skip it for now
            //if (hr)
            //    goto Cleanup;
            goto Cleanup; // ???
        }
        else
        {
            hr = ((CGenericElement*)pElem)->GetComPlusReference ( &cpRef );
            if (hr)
                goto Cleanup;
            *prefScopeElement = (long)cpRef;
        }
    }
Cleanup:
    RRETURN(hr);
}


#endif V4FRAMEWORK
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\stdform.cxx ===
//+--------------------------------------------------------------------------
//
//  File:       stdform.cxx
//
//  Contents:   IDoc methods of CDoc
//
//  Classes:    (part of) CDoc
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_IRANGE_HXX_
#define X_IRANGE_HXX_
#include "irange.hxx"
#endif

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx"
#endif

#ifndef X_HEDELEMS_HXX_
#define X_HEDELEMS_HXX_
#include "hedelems.hxx"
#endif

#ifndef X_EBODY_HXX_
#define X_EBODY_HXX_
#include "ebody.hxx"
#endif

#ifndef X_SELECOBJ_HXX_
#define X_SELECOBJ_HXX_
#include "selecobj.hxx"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_HTMTAGS_HXX_
#define X_HTMTAGS_HXX_
#include "htmtags.hxx"
#endif

#ifndef X_PROGSINK_HXX_
#define X_PROGSINK_HXX_
#include "progsink.hxx"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif

#ifndef X_JSPROT_HXX_
#define X_JSPROT_HXX_
#include "jsprot.hxx"
#endif

#ifndef X_OTHRGUID_H_
#define X_OTHRGUID_H_
#include "othrguid.h"
#endif

#ifndef X_OBJSAFE_H_
#define X_OBJSAFE_H_
#include "objsafe.h"
#endif

#ifndef X_SHELL_H_
#define X_SHELL_H_
#include "shell.h"
#endif

#ifndef X_FRAME_HXX_
#define X_FRAME_HXX_
#include "frame.hxx"
#endif

#ifndef X_EVENTOBJ_HXX_
#define X_EVENTOBJ_HXX_
#include "eventobj.hxx"
#endif

#ifndef X_ACTIVSCP_H_
#define X_ACTIVSCP_H_
#include <activscp.h>
#endif

#ifndef X_SCRIPT_HXX_
#define X_SCRIPT_HXX_
#include "script.hxx"
#endif

#ifndef X_SHEETS_HXX_
#define X_SHEETS_HXX_
#include "sheets.hxx"
#endif

#ifndef X_EVNTPRM_HXX_
#define X_EVNTPRM_HXX_
#include "evntprm.hxx"
#endif

#ifndef X_MSHTMHST_H_
#define X_MSHTMHST_H_
#include <mshtmhst.h>
#endif

#ifdef WIN16
#ifndef X_SHLGUID_H_
#define X_SHLGUID_H_
#include "shlguid.h"
#endif
#endif

#ifndef X_PEER_HXX_
#define X_PEER_HXX_
#include "peer.hxx"
#endif

#ifndef X_IMGELEM_HXX_
#define X_IMGELEM_HXX_
#include "imgelem.hxx"
#endif

#ifndef X_EMAP_HXX_
#define X_EMAP_HXX_
#include "emap.hxx"
#endif

#ifndef X_EAREA_HXX_
#define X_EAREA_HXX_
#include "earea.hxx"
#endif

#ifndef X_ROOTELEM_HXX_
#define X_ROOTELEM_HXX_
#include "rootelem.hxx"
#endif

#ifndef X_DEBUGGER_HXX_
#define X_DEBUGGER_HXX_
#include "debugger.hxx"
#endif

#define _hxx_
#include "body.hdl"

#ifdef WIN16
UINT CTimeoutEventList::_uNextTimerID = 0xC000;

ExternTag(tagShDocMetaRefresh);
#endif

DeclareTag(tagTimerProblems, "Timer", "Timer problems");
DeclareTag( tagFormsTimerStarvation, "timer", "Trace windows Timer starvation problems" );

MtDefine(CDocGetFile, Utilities, "CDoc::GetFile")
MtDefine(TIMEOUTEVENTINFO, CTimeoutEventList, "TIMEOUTEVENTINFO")
MtDefine(CDocPersistLoad_aryElements_pv, Locals, "Persistence stuff")


extern HRESULT CreateStreamOnFile(
        LPCTSTR lpstrFile,
        DWORD dwSTGM,
        LPSTREAM * ppstrm);

HRESULT GetFullyExpandedUrl(CBase *pBase, BSTR bstrUrl, BSTR *pbstrFullUrl, BSTR * pbstrBaseUrl = NULL, IServiceProvider *pSP = NULL);

//+---------------------------------------------------------------------------
//
//  Helper:     GetScriptSite
//
//----------------------------------------------------------------------------

HRESULT
GetScriptSiteCommandTarget (IServiceProvider * pSP, IOleCommandTarget ** ppCommandTarget)
{
    RRETURN(THR_NOTRACE(pSP->QueryService(SID_GetScriptSite,
                                          IID_IOleCommandTarget,
                                          (void**) ppCommandTarget)));
}

//+---------------------------------------------------------------------------
//
//  Member:     GetCallerCommandTarget
//
//  Synopsis:   walks up caller chain getting either first or last caller
//              and then gets it's command target
//
//----------------------------------------------------------------------------

HRESULT
GetCallerCommandTarget (
    CBase *              pBase,
    IServiceProvider *   pBaseSP,
    BOOL                 fFirstScriptSite,
    IOleCommandTarget ** ppCommandTarget)
{
    HRESULT                 hr = S_OK;
    IUnknown *              pUnkCaller = NULL;
    IServiceProvider    *   pCallerSP = NULL;
    IServiceProvider    *   pSP = NULL;
    IOleCommandTarget   *   pCmdTarget = NULL;
    BOOL                    fGoneUp = FALSE;


    Assert (ppCommandTarget);
    *ppCommandTarget = NULL;

    if (pBaseSP)
    {
        ReplaceInterface (&pSP, pBaseSP);
    }
    else if (pBase)
    {
        pBase->GetUnknownObjectAt(
            pBase->FindAAIndex (DISPID_INTERNAL_INVOKECONTEXT,CAttrValue::AA_Internal),
            &pUnkCaller);
        if (!pUnkCaller)
            goto Cleanup;

        hr = THR(pUnkCaller->QueryInterface(
                IID_IServiceProvider,
                (void**) &pSP));
        if (hr || !pSP)
            goto Cleanup;
    }
    else
    {
        // We have neither a CBase object nor a service provider. Impossible to 
        // determine the command target.
        goto Cleanup;
    }

    Assert(pSP);

    // Crawl up the caller chain to find the first script engine in the Invoke chain.
    // Always hold onto the last valid command target you got
    for(;;)
    {
        hr = THR_NOTRACE(GetScriptSiteCommandTarget(pSP, &pCmdTarget));

        if ( !hr && pCmdTarget )
        {
            ReplaceInterface(ppCommandTarget, pCmdTarget ); // pCmdTarget now has 2 Addrefs
            ClearInterface (&pCmdTarget); // pCmdTarget now has 1 addref
        }
        if ( fFirstScriptSite && fGoneUp )
            break;

        // Skip up to the previous caller in the Invoke chain
        hr = THR_NOTRACE(pSP->QueryService(SID_GetCaller, IID_IServiceProvider, (void**)&pCallerSP));
        if (hr || !pCallerSP)
            break;

        fGoneUp = TRUE;

        ReplaceInterface(&pSP, pCallerSP);
        ClearInterface(&pCallerSP);
    }

Cleanup:
    ReleaseInterface(pUnkCaller);
    ReleaseInterface(pCallerSP);
    ReleaseInterface(pSP);

    hr = *ppCommandTarget ? S_OK : S_FALSE;
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Helper:     GetCallerURL
//
//  Synopsis:   Helper method,
//              gets the base url from the calling document.
//----------------------------------------------------------------------------


HRESULT
GetCallerURL(CStr &cstr, CBase *pBase, IServiceProvider * pSP)
{
    HRESULT             hr = S_OK;
    IOleCommandTarget * pCommandTarget;
    CVariant            Var;

    hr = THR(GetCallerCommandTarget(pBase, pSP, FALSE, &pCommandTarget));
    if (hr)
    {
        hr = S_OK;
        goto Cleanup;
    }

    hr = THR(pCommandTarget->Exec(
            &CGID_ScriptSite,
            CMDID_SCRIPTSITE_URL,
            0,
            NULL,
            &Var));
    if (hr)
        goto Cleanup;

    Assert(V_VT(&Var) == VT_BSTR);
    hr = THR(cstr.Set(V_BSTR(&Var)));
    if (hr)
        goto Cleanup;

Cleanup:
    ReleaseInterface(pCommandTarget);

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Helper:     GetCallerSecurityStateAndURL
//
//  Synopsis:   Helper method,
//              gets the security state from the calling document
//              and URL.  
//
//----------------------------------------------------------------------------


HRESULT
GetCallerSecurityStateAndURL(SSL_SECURITY_STATE *pSecState, 
                             CStr &cstr, 
                             CBase *pBase, 
                             IServiceProvider * pSP)
{
    HRESULT             hr;
    IOleCommandTarget * pCommandTarget = NULL;
    CVariant            Var;

    *pSecState = SSL_SECURITY_UNSECURE;

    hr = THR(GetCallerCommandTarget(pBase, pSP, FALSE, &pCommandTarget));
    if (hr)
    {
        hr = S_OK;
        goto Cleanup;
    }


    // Get the security state
    hr = THR(pCommandTarget->Exec(
            &CGID_ScriptSite,
            CMDID_SCRIPTSITE_SECSTATE,
            0,
            NULL,
            &Var));
    if (hr)
        goto Cleanup;

    Assert(V_VT(&Var) == VT_I4);
    *pSecState = (SSL_SECURITY_STATE)(V_I4(&Var));

    // Get the caller URL
    hr = THR(pCommandTarget->Exec(
            &CGID_ScriptSite,
            CMDID_SCRIPTSITE_URL,
            0,
            NULL,
            &Var));
    if (hr)
        goto Cleanup;

    Assert(V_VT(&Var) == VT_BSTR);
    hr = THR(cstr.Set(V_BSTR(&Var)));
    if (hr)
        goto Cleanup;

Cleanup:
    ReleaseInterface(pCommandTarget);

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     GetCallerHTMLDlgTrust
//
//----------------------------------------------------------------------------

BOOL
GetCallerHTMLDlgTrust(CBase *pBase)
{
    HRESULT             hr = S_OK;
    IOleCommandTarget * pCommandTarget = NULL;
    CVariant            var;
    BOOL                fTrusted = FALSE;

    hr = THR(GetCallerCommandTarget(pBase, NULL, TRUE, &pCommandTarget));
    if (hr)
    {
        goto Cleanup;
    }

    if (pCommandTarget)
    {
        hr = THR_NOTRACE(pCommandTarget->Exec(
                &CGID_ScriptSite,
                CMDID_SCRIPTSITE_HTMLDLGTRUST,
                0,
                NULL,
                &var));
        if (hr)
            goto Cleanup;

        Assert (VT_BOOL == V_VT(&var));
        fTrusted = V_BOOL(&var);
    }
    else
    {
        fTrusted = FALSE;
    }

Cleanup:
    ReleaseInterface(pCommandTarget);

    return fTrusted;
}

#ifdef WIN16

// The meta refresh callback is distinguished from real
// scripts by the fact that the 'language' and 'script'
// strings are identical, and begin with refresh:

HRESULT MetaRefreshCallback(CDoc * pDoc, BSTR lang, BSTR script)
{
    LPCSTR pszUrl;
    HRESULT hr = S_OK;

    if (!lang || !script
        || _tcscmp(lang, script)
        || _tcsnicmp(lang, 8, "refresh:", 8))
    {
        // they don't match, so we don't want to handle this.
        TraceTag((tagShDocMetaRefresh, "MetaRefreshCallback not useable--is real script.", pszUrl));
        return S_FALSE;
    }

    // everything should already be parsed, so we shouldn't have
    // to go through the complex parser again. Just find the first , or ;
    // (Note that this also skips over the http-equiv:).
    pszUrl = script;
    while (*pszUrl && *pszUrl != '=')
    {
        pszUrl++;
    }

    if (*pszUrl)
    {
        // found a URL
        pszUrl++;
        TraceTag((tagShDocMetaRefresh, "Want to jump to %s.", pszUrl));
        // BUGWIN16? Should this be made asynchronous?
        pDoc->FollowHyperlink(pszUrl);
    }
    else
    {
        // BUGWIN16: what flags should we use? This looks like what win32 uses 18jun97.
        DWORD dwBindf = BINDF_GETNEWESTVERSION|BINDF_PRAGMA_NO_CACHE;

        TraceTag((tagShDocMetaRefresh, "Want to refresh, time=%d", pszUrl, GetTickCount()));

        if (pDoc->_pPrimaryMarkup)
        {
            hr = GWPostMethodCall(pDoc,
                        ONCALL_METHOD(CDoc, ExecRefreshCallback, execrefreshcallback), dwBindf, FALSE, "CDoc::ExecRefreshCallback");
        }
    }


    return hr;
}
#endif // win16

//+------------------------------------------------------------------------
//
//  Function:   GetLastModDate
//
//  Synopsis:   Sets the mod date used by the OM and the History code
//
//-------------------------------------------------------------------------

FILETIME
CMarkup::GetLastModDate()
{
    if (HtmCtx())
    {
        return(HtmCtx()->GetLastMod());
    }
    else
    {
        FILETIME ft = {0};
        return ft;
    }
}


//+------------------------------------------------------------------------
//
//  IDoc implementation
//
//-------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//
//  Method:     CDoc::GetcanPaste
//
//  Synopsis:   Returns whether the clipboard has readable data.
//
//--------------------------------------------------------------------------

HRESULT
CDoc::canPaste(VARIANT_BOOL * pfCanPaste)
{
    HRESULT         hr;
    IDataObject *   pDataObj = NULL;

    if (!pfCanPaste)
        RRETURN(SetErrorInfoInvalidArg());

    hr = THR(OleGetClipboard(&pDataObj));
    if (hr)
        goto Cleanup;

    hr = THR(FindLegalCF(pDataObj));

Cleanup:
    ReleaseInterface(pDataObj);
    *pfCanPaste = (hr == S_OK) ? VB_TRUE : VB_FALSE;
    return S_OK;
}




struct CTRLPOS
{
    IHTMLControlElement *  pCtrl;
    long        x;
    long        y;
};

int __cdecl
CompareCPTop(const void * pv1, const void * pv2)
{
    return (**(CTRLPOS **)pv1).y - (**(CTRLPOS **)pv2).y;
}

//---------------------------------------------------------------------------
//
//  Modes
//
//---------------------------------------------------------------------------

//----------------------------------------------------------------------------
//
//  Mode update functions.  They update the state of the mode and perform
//      any required side-effect.
//
//----------------------------------------------------------------------------


HRESULT
CDoc::UpdateDesignMode(CDocument * pContextDoc, BOOL fMode)
{        
    CMarkup           * pMarkup     = pContextDoc->Markup();
    
    Assert(pMarkup);

    COmWindowProxy    * pWindow     = pMarkup->Window();   
    BOOL                fOrgMode    = pMarkup->_fDesignMode;
    HRESULT             hr;
  
    // Cannot edit image files or when we have no window.
    if (!pWindow || pMarkup->IsImageFile() && fMode)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = THR(pMarkup->ExecStop(FALSE, FALSE));
    if (hr)
        goto Cleanup;

    hr = THR(pMarkup->EnsureDirtyStream());
    if (hr)
        goto Cleanup;

    // we should set this before we do anything with refreshing the page,
    // This way, the document flags will be set to disable the scripts, if 
    // we are in design mode.
    pMarkup->_fDesignMode = fMode;


    {
        //
        // IEV6 4726
        // We cannot release editor since it is
        // shared across markups. 
        //    
        if (!pMarkup->GetParentMarkup()) // this is the topmost markup
        {
            IGNORE_HR( NotifySelection(EDITOR_NOTIFY_DOC_ENDED, NULL) );
            ReleaseEditor();
        }
        else
        {
            IUnknown* pUnknown = NULL;
            IGNORE_HR( pMarkup->QueryInterface( IID_IUnknown, ( void**) & pUnknown ));
            IGNORE_HR( NotifySelection(EDITOR_NOTIFY_CONTAINER_ENDED, pUnknown) );
            ReleaseInterface( pUnknown );
        }
    }

    if (!pMarkup->_fInheritDesignMode)
        IGNORE_HR(pContextDoc->SetAAdesignMode(fMode ? htmlDesignModeOn : htmlDesignModeOff));      
    
    // TODO: This switch is bad.  What if we are not ready to switch (PICS? EnableModeless?)
    if (pWindow->Window()->_pMarkupPending)
            IGNORE_HR(pWindow->SwitchMarkup(pWindow->Window()->_pMarkupPending));

    hr = THR(pWindow->ExecRefresh());
    if (FAILED(hr))
        goto Error;

    if (hr==S_FALSE)
    {
        // onbeforeunload was canceled, so restore
        // and get out of here.
        pWindow->Markup()->_fDesignMode = fOrgMode;
        hr = S_OK;
        goto Cleanup;
    }   

    if (_state == OS_UIACTIVE)
    {
#ifndef NO_OLEUI
        RemoveUI();
        hr = THR(InstallUI(FALSE));
        if (hr)
            goto Error;
#endif // NO_OLEUI

        // force to rebuild all collections
        //

// TODO - This invalidates too much.  Need to clear the caches,
// not dirty the document.  Unless this operation does dirty the
// document implicitly.
        pWindow->Markup()->UpdateMarkupTreeVersion();
        
        Invalidate();
    }   

Cleanup:
    RRETURN(hr);

Error:
    pWindow->Markup()->_fDesignMode = fOrgMode;
    THR_NOTRACE(pWindow->ExecRefresh());
    goto Cleanup;
}

HRESULT
CDoc::SetDesignMode ( CDocument * pContextDoc, htmlDesignMode mode )
{    
    HRESULT            hr = S_OK;
    CMarkup            *pMarkup = pContextDoc->Markup();
    IHTMLDocument4     *pIDocument4 = NULL;
    CWindow            *pWindow; 
/*
    if (mode == htmlDesignModeOn && _fFrameSet )
    {
        // Do nothing for frameset
        hr = MSOCMDERR_E_DISABLED;
        goto Cleanup;
    }
*/
    Assert(pContextDoc->GetWindowedMarkupContext()->GetWindowPending());
    pWindow = pContextDoc->GetWindowedMarkupContext()->GetWindowPending()->Window();
    if (pWindow->IsInScript())
    {
        // Cannot set mode while script is executing.

        hr = MSOCMDERR_E_DISABLED;

        // Make sure the design mode attribute returns the true state of design mode when
        // we fail to change it.

        IGNORE_HR(pContextDoc->SetAAdesignMode(pWindow->Markup()->_fDesignMode ? htmlDesignModeOn : htmlDesignModeOff));      

        goto Cleanup;
    }

    if (mode != htmlDesignModeOn && mode != htmlDesignModeOff && mode != htmlDesignModeInherit)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }    

    if (mode == htmlDesignModeInherit)
    {
        pMarkup->_fInheritDesignMode = TRUE;
        hr = THR(OnAmbientPropertyChange(DISPID_AMBIENT_USERMODE));
    }
    else
    {
        // update is needed if design inheritance is being disabled 
        // or the current designMode is different from the desired designMode
        BOOL fNeedToUpdate = (pMarkup->_fInheritDesignMode) ||
                             (!!pMarkup->_fDesignMode != (mode==htmlDesignModeOn));
        
        pMarkup->_fInheritDesignMode = FALSE;
        if (fNeedToUpdate)
        {
            hr = THR(UpdateDesignMode(pContextDoc, mode==htmlDesignModeOn));
        }
    }    

    if (mode == htmlDesignModeOn)
    {
       VARIANT_BOOL fRet = VB_TRUE;

       IGNORE_HR(this->QueryInterface(IID_IHTMLDocument4, (void **)&pIDocument4));
       if (pIDocument4)
            IGNORE_HR(pIDocument4->fireEvent(_T("onselectionchange"), NULL, &fRet));
    }

Cleanup:
    ReleaseInterface(pIDocument4);
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  member: GetBodyElement
//
//  synopsis : helper for the get_/put_ functions that need the body
//
//-----------------------------------------------------------------------------

HRESULT
CMarkup::GetBodyElement(IHTMLBodyElement ** ppBody)
{
    HRESULT hr = S_OK;
    CElement * pElement = GetElementClient();

    if (!ppBody)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppBody = NULL;

    if (!pElement)
    {
        hr = S_OK;
        goto Cleanup;
    }

    hr = THR_NOTRACE(pElement->QueryInterface(
        IID_IHTMLBodyElement, (void **) ppBody));

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  member: GetBodyElement
//
//  synopsis : helper for the get_/put_ functions that need the CBodyElement
//             returns S_FALSE if body element is not found
//
//-----------------------------------------------------------------------------
HRESULT
CMarkup::GetBodyElement(CBodyElement **ppBody)
{
    HRESULT hr = S_OK;
    CElement * pElementClient = GetElementClient();

    if (ppBody == NULL)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppBody = NULL;

    if (!pElementClient)
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    if (pElementClient->Tag() == ETAG_BODY)
        *ppBody = DYNCAST(CBodyElement, pElementClient);
    else
        hr = S_FALSE;

Cleanup:
    RRETURN1(hr, S_FALSE);
}

//+------------------------------------------------------------------
//
//  member:   GetMyDomain
//
//  Synopsis ;  The domain of the current doc :
//                 GetUrlComponenetHelper properly handles Http://
//              however, "file://..." either returns ""  for a local file
//              or returns the (?) share name for intranet files
//
//      since setting domains is irrelevant for files, this will
//      return the proper "doamin" for files, but an HR of S_FALSE.
//      the Get_ code ignores this, the put_code uses it to determine
//      wether to bother checking or not.
//
//-------------------------------------------------------------------

HRESULT
CDoc::GetMyDomain(const TCHAR * pchUrl, CStr * pcstrOut)
{
    HRESULT  hr = E_INVALIDARG;
    TCHAR    ach[pdlUrlLen];
    DWORD    dwSize;

    if (!pchUrl || !pcstrOut)
        goto Cleanup;

    memset(ach, 0,sizeof(ach));

    // Clear the Output parameter
    pcstrOut->Set(_T("\0"));

    if (!*pchUrl)
        goto Cleanup;

    hr = THR(CoInternetParseUrl( pchUrl,
                             PARSE_DOMAIN,
                             0,
                             ach,
                             ARRAY_SIZE(ach),
                             &dwSize,
                             0));

    if (hr)
        goto Cleanup;

    // set the return value
    pcstrOut->Set(ach);

Cleanup:
    RRETURN(hr);
}

void
CDoc::ReleaseOMCapture()
{
    SetMouseCapture(NULL, NULL);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDoc::FireTimeout
//
//  Synopsis:   save the code associated with a TimerID
//
//----------------------------------------------------------------------------

HRESULT BUGCALL
CWindow::FireTimeOut(UINT uTimerID)
{
    TIMEOUTEVENTINFO * pTimeout = NULL;
    LONG               id;
    HRESULT            hr = S_OK;
    thisclass::CLock   Lock(this);

    // CanNavigate relfects the EnableModeless state -- don't
    // do this if we are modeless disabled
    if (!CanNavigate())
        goto Cleanup;


    // Check the list and if ther are timers with target time less then current
    //      execute them and remove from the list. Only events occured earlier then
    //      timer uTimerID will be retrieved
    // TODO: check with Nav compat to see if Nav wraps to prevent clears during script exec.
    _cProcessingTimeout++;
    TraceTag((tagTimerProblems, "Got a timeout. Looking for a match to id %d",
                  uTimerID));


    while(_TimeoutEvents.GetFirstTimeoutEvent(uTimerID, &pTimeout) == S_OK)
    {
        // Now execute the given script
        hr = ExecuteTimeoutScript(pTimeout);
        if ( 0 == pTimeout->_dwInterval || hr )
            // setTimeout (or something wrong with script): delete the timer
            delete pTimeout;
        else
        {
            // setInterval: put timeout back in queue with next time to fire
            _TimeoutEvents.AddPendingTimeout( pTimeout );
        }
    }
    _cProcessingTimeout--;

    // deal with any clearTimeouts (clearIntervals) that may have occurred as
    // a result of processing the scripts.  Only clear pending timeouts when
    // we have finished processing all other timeouts.
    while ( _TimeoutEvents.GetPendingClear(&id) && !_cProcessingTimeout )
    {
        if ( !_TimeoutEvents.ClearPendingTimeout((UINT)id) )
            ClearTimeout( id );
    }

    // we cleanup here because clearTimeout might have been called from setTimeout code
    // before an error occurred which we want to get rid of above (nav compat)
    if (hr)
        goto Cleanup;

    // Requeue pending timeouts (from setInterval)
    while ( _TimeoutEvents.GetPendingTimeout(&pTimeout) )
    {
        pTimeout->_dwTargetTime = (DWORD)GetTargetTime(pTimeout->_dwInterval);
        hr = THR(_TimeoutEvents.InsertIntoTimeoutList(pTimeout, NULL, FALSE));
        if (hr)
        {
            ClearTimeout( pTimeout->_uTimerID );
            goto Cleanup;
        }

        hr = THR(FormsSetTimer( this, ONTICK_METHOD(thisclass, FireTimeOut, firetimeout),
                                pTimeout->_uTimerID, pTimeout->_dwInterval ));
        if (hr)
        {
            ClearTimeout( pTimeout->_uTimerID );
            goto Cleanup;
        }
    }

Cleanup:
    RRETURN(hr);
}


// This function executes given timeout script and kills the associated timer

HRESULT
CWindow::ExecuteTimeoutScript(TIMEOUTEVENTINFO * pTimeout)
{
    HRESULT     hr = S_OK;
    CScriptCollection * pScriptCollection = _pMarkup->GetScriptCollection();

    if (pScriptCollection)
        pScriptCollection->AddRef();

    Assert(pTimeout != NULL);

    Verify(FormsKillTimer(this, pTimeout->_uTimerID) == S_OK);

    if (pTimeout->_pCode)
    {
        if (pScriptCollection)
        {
            DISPPARAMS  dp = g_Zero.dispparams;
            CVariant    varResult;
            EXCEPINFO   excepinfo;

            // Can't disconnect script engine while we're executing script.
            thisclass::CLock Lock(this);

            hr = THR(pTimeout->_pCode->Invoke(DISPID_VALUE,
                                              IID_NULL,
                                              0,
                                              DISPATCH_METHOD,
                                              &dp,
                                              &varResult,
                                              &excepinfo,
                                              NULL));
        }
    }
    else if (pTimeout->_code.Length() != 0)
    {
        CExcepInfo       ExcepInfo;
        CVariant         Var;

        if (pScriptCollection)
        {
            hr = THR(pScriptCollection->ParseScriptText(
                pTimeout->_lang,            // pchLanguage
                NULL,                       // pMarkup
                NULL,                       // pchType
                pTimeout->_code,            // pchCode
                NULL,                       // pchItemName
                _T("\""),                   // pchDelimiter
                0,                          // ulOffset
                0,                          // ulStartingLine
                NULL,                       // pSourceObject
                SCRIPTTEXT_ISVISIBLE,       // dwFlags
                &Var,                       // pvarResult
                &ExcepInfo));               // pExcepInfo
        }

    }

    if (pScriptCollection)
        pScriptCollection->Release();

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::AddTimeoutCode
//
//  Synopsis:   save the code associated with a TimerID
//
//----------------------------------------------------------------------------

HRESULT
CWindow::AddTimeoutCode(VARIANT *theCode, BSTR strLanguage, LONG lDelay, LONG lInterval,
                     UINT * uTimerID)
{
    HRESULT             hr;
    TIMEOUTEVENTINFO  * pTimeout;

    pTimeout = new(Mt(TIMEOUTEVENTINFO)) TIMEOUTEVENTINFO;
    if(pTimeout == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Error;
    }

    if (V_VT(theCode) == VT_BSTR)
    {
        // Call the code associated with the timer.
        CScriptCollection *pScriptCollection = _pMarkup->GetScriptCollection();

        if (pScriptCollection)
        {
            hr = THR_NOTRACE(pScriptCollection->ConstructCode(
                                NULL,                   // pchScope
                                V_BSTR(theCode),        // pchCode
                                NULL,                   // pchFormalParams
                                strLanguage,            // pchLanguage
                                NULL,                   // pMarkup
                                NULL,                   // pchType
                                0,                      // ulOffset
                                0,                      // ulStartingLine
                                NULL,                   // pSourceObject
                                0,                      // dwFlags
                                &(pTimeout->_pCode),    // ppDispCode result
                                TRUE));                 // fSingleLine
        }
        else
            hr = E_FAIL;

        // Script engine can't produce PCODE so we'll do it the old way compiling on
        // each timer event.
        if (hr)
        {
            Assert(pTimeout->_pCode == NULL);

            // Set various data
            hr = THR(pTimeout->_code.SetBSTR(V_BSTR(theCode)));
            if (hr)
                goto Error;

            hr = THR(pTimeout->_lang.SetBSTR(strLanguage));
            if (hr)
                goto Error;
        }
    }
    else if (V_VT(theCode) == VT_DISPATCH)
    {
        pTimeout->_pCode = V_DISPATCH(theCode);
        if (pTimeout->_pCode)
        {
            pTimeout->_pCode->AddRef();
        }
        hr = S_OK;
    }
    else
    {
        hr = E_INVALIDARG;
        goto Error;
    }

    // Save the time when the timeout happens
    pTimeout->_dwTargetTime = (DWORD)GetTargetTime(lDelay);

    // If lInterval=0, then called by setTimeout, otherwise called by setInterval
    pTimeout->_dwInterval = (DWORD)lInterval;

    // add the new element to the right position of the list
    // fills the timer id filed into the struct and returns
    // the value
    hr = THR(_TimeoutEvents.InsertIntoTimeoutList(pTimeout, uTimerID));
    if (hr)
        goto Error;

Cleanup:
    RRETURN(hr);

Error:
    delete pTimeout;
    goto Cleanup;
}



//+---------------------------------------------------------------------------
//
//  Member:     CDoc::ClearTimeout
//
//  Synopsis:   Clears a previously setTimeout and setInterval
//
//----------------------------------------------------------------------------

HRESULT
CWindow::ClearTimeout(LONG lTimerID)
{
    HRESULT hr = S_OK;
    TIMEOUTEVENTINFO * pCurTimeout;

    if ( _cProcessingTimeout )
    {
        _TimeoutEvents.AddPendingClear( lTimerID );
    }
    else
    {
        // Get the timeout struct with given ID and remove it from the list
        hr = _TimeoutEvents.GetTimeout((DWORD)lTimerID, &pCurTimeout);
        if(hr == S_FALSE)
        {
            // Netscape just ignores the invalid arg silently - so do we.
            hr = S_OK;
            goto Cleanup;
        }

        if(pCurTimeout != NULL)
        {
            Verify(FormsKillTimer(this, pCurTimeout->_uTimerID) == S_OK);
            delete pCurTimeout;
        }
    }
Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDoc::SetTimeout
//
//  Synopsis:   Runs <Code> after <msec> milliseconds and returns a
//              timeout ID to be used by clearTimeout or clearInterval.
//              Also used for SetInterval.
//
//----------------------------------------------------------------------------

HRESULT
CWindow::SetTimeout(
    VARIANT *pCode,
    LONG lMSec,
    BOOL fInterval,     // periodic, repeating
    VARIANT *pvarLang,
    LONG * plTimerID)
{
    HRESULT   hr = E_INVALIDARG;
    UINT      uTimerID;
    CVariant  varLanguage;

    if (!plTimerID )
        goto Cleanup;

    *plTimerID = -1;

    hr = THR(varLanguage.CoerceVariantArg(pvarLang, VT_BSTR));
    if (hr == S_FALSE)
    {
        // language not supplied
        V_BSTR(&varLanguage) = NULL;
        hr = S_OK;
    }
    if (!OK(hr))
        goto Cleanup;

    // Perform indirection if it is appropriate:
    if (V_VT(pCode) == (VT_BYREF | VT_VARIANT))
        pCode = V_VARIANTREF(pCode);

     // Do we have code.
    if ((V_VT(pCode) == VT_DISPATCH && V_DISPATCH(pCode)) || (V_VT(pCode) == VT_BSTR))
    {
        // Accept empty strings, just don't do anything with an empty string.
        if ((V_VT(pCode) == VT_BSTR) && SysStringLen(V_BSTR(pCode)) == 0)
            goto Cleanup;

        // Register the Code.  If no language send NULL.
        hr = THR(AddTimeoutCode(pCode,
                                V_BSTR(&varLanguage),
                                lMSec,
                                (fInterval? lMSec : 0),    // Nav 4 treats setInterval w/ 0 as a setTimeout
                                &uTimerID));
        if (hr)
            goto Cleanup;

        // Register the Timeout,

        hr = THR(FormsSetTimer(
                this,
                ONTICK_METHOD(thisclass, FireTimeOut, firetimeout),
                uTimerID,
                lMSec));
        if (hr)
            goto Error;

        // Return value
        *plTimerID = (LONG)uTimerID;
    }
    else
        hr = E_INVALIDARG;

Cleanup:
    RRETURN(hr);

Error:
    // clear out registered code
    ClearTimeout((LONG)uTimerID);
    goto Cleanup;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::CleanupScriptTimers
//
//----------------------------------------------------------------------------

void
CWindow::CleanupScriptTimers()
{
    _TimeoutEvents.KillAllTimers(this);
}

//+----------------------------------------------------------------------
//
//
//-----------------------------------------------------------------------

static void
ChopToPath(TCHAR *szURL)
{
    TCHAR *szPathEnd;

    // Start scanning at terminating null the end of the string
    // Go back until we hit the last '/'  or the beginning of the string
    for ( szPathEnd = szURL + _tcslen(szURL);
        szPathEnd>szURL && *szPathEnd != _T('/');
        szPathEnd-- );

    // If we found the slash (and we're not looking at '//')
    // then terminate the string at the character following the slash
    // (If we didn't find the slash, then something is weird and we don't do anything)
    if (*szPathEnd == _T('/') && szPathEnd>szURL && szPathEnd[-1] != _T('/'))
    {
            // we are at the slash so set the character after the slash to NULL
        szPathEnd[1] = _T('\0');
    }
}

//+-------------------------------------------------------------------
//
//  Member:     CDocument::GetDocDirection(pfRTL)
//
//  Synopsis:   Gets the document reading order. This is just a
//              reflection of the direction of the HTML element.
//
//  Returns:    S_OK if the direction was successfully set/retrieved.
//
//--------------------------------------------------------------------
HRESULT
CDocument::GetDocDirection(BOOL * pfRTL)
{
    long eHTMLDir = htmlDirNotSet;
    BSTR bstrDir = NULL;
    HRESULT hr;
    
    if (!pfRTL)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pfRTL = FALSE;

    hr = THR(get_dir(&bstrDir));
    if (hr)
        goto Cleanup;

    hr = THR(s_enumdeschtmlDir.EnumFromString(bstrDir, &eHTMLDir));
    if (hr)
        goto Cleanup;

    if (eHTMLDir == htmlDirNotSet && _eHTMLDocDirection != htmlDirNotSet)
        *pfRTL = (_eHTMLDocDirection == htmlDirRightToLeft);
    else
        *pfRTL = (eHTMLDir == htmlDirRightToLeft);

Cleanup:
    FormsFreeString(bstrDir);
    RRETURN(hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CDocument::SetDocDirection(eHTMLDir)
//
//  Synopsis:   Sets the document reading order. This is just a
//              reflection of the direction of the HTML element.
//
//  Returns:    S_OK if the direction was successfully set/retrieved.
//
//--------------------------------------------------------------------
HRESULT
CDocument::SetDocDirection(LONG eHTMLDir)
{
    BSTR bstrDir = NULL;
    HRESULT hr;

    hr = THR(s_enumdeschtmlDir.StringFromEnum(eHTMLDir, &bstrDir));
    if (hr)
        goto Cleanup;
        
    hr = THR(put_dir(bstrDir));
    if (hr)
        goto Cleanup;
        
Cleanup:
    FormsFreeString(bstrDir);
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
// Member: GetUrlCachedFileName gets the filename of the cached file
//         in Wininet's cache
//
//----------------------------------------------------------------------------
HRESULT
CMarkup::GetFile(TCHAR ** ppchFile)
{
    const TCHAR * pchUrl = CMarkup::GetUrl(this);
    HRESULT hr = S_OK;

    Assert(!!pchUrl);
    Assert(ppchFile);

    *ppchFile = NULL;

    if (!pchUrl)
        goto Cleanup;

    if (GetUrlScheme(pchUrl) == URL_SCHEME_FILE)
    {
        TCHAR achPath[MAX_PATH];
        DWORD cchPath;

        hr = THR(CoInternetParseUrl(pchUrl, PARSE_PATH_FROM_URL, 0, achPath, ARRAY_SIZE(achPath), &cchPath, 0));
        if (hr)
            goto Cleanup;
        hr = THR(MemAllocString(Mt(CDocGetFile), achPath, ppchFile));
    }
    else
    {
        BYTE                        buf[MAX_CACHE_ENTRY_INFO_SIZE];
        INTERNET_CACHE_ENTRY_INFO * pInfo = (INTERNET_CACHE_ENTRY_INFO *) buf;
        DWORD                       cInfo = sizeof(buf);

        if (RetrieveUrlCacheEntryFile(pchUrl, pInfo, &cInfo, 0))
        {
            DoUnlockUrlCacheEntryFile(pchUrl, 0);
            hr = THR(MemAllocString(Mt(CDocGetFile), pInfo->lpszLocalFileName, ppchFile));
        }
        else
            hr = E_FAIL;
    }

Cleanup:
    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
// Protocol Identifier and Protocol Friendly Name
// Adapted from wc_html.h and wc_html.c of classic MSHTML
//
//-----------------------------------------------------------------------------
typedef struct {
        TCHAR * szName;
        TCHAR * szRegKey;
} ProtocolRec;

static ProtocolRec ProtocolTable[] = {
        _T("file:"),     _T("file"),
        _T("mailto:"),   _T("mailto"),
        _T("gopher://"), _T("gopher"),
        _T("ftp://"),    _T("ftp"),
        _T("http://"),   _T("http"),
        _T("https://"),  _T("https"),
        _T("news:"),     _T("news"),
        NULL, NULL
};

TCHAR * ProtocolFriendlyName(TCHAR * szURL)
{
    TCHAR szBuf[MAX_PATH];
    int   i;

    if (!szURL)
        return NULL;

    LoadString(GetResourceHInst(), IDS_UNKNOWNPROTOCOL, szBuf,
        ARRAY_SIZE(szBuf));
    for (i = 0; ProtocolTable[i].szName; i ++)
    {
        if (_tcsnipre(ProtocolTable[i].szName, -1, szURL, -1))
            break;
    }
    if (ProtocolTable[i].szName)
    {
        DWORD dwLen = sizeof(szBuf);
        //DWORD dwValueType;
        HKEY  hkeyProtocol;

        LONG lResult = RegOpenKeyEx(
                HKEY_CLASSES_ROOT,
                ProtocolTable[i].szRegKey,
                0,
                KEY_QUERY_VALUE,
                &hkeyProtocol);
        if (lResult != ERROR_SUCCESS)
            goto Cleanup;

        lResult = RegQueryValue(
                hkeyProtocol,
                NULL,
                szBuf,
                (long *) &dwLen);
        RegCloseKey(hkeyProtocol);
    }

Cleanup:
    return SysAllocString(szBuf);
}

//+----------------------------------------------------------------------------
//
// Member:      CDoc::GetInterfaceSafetyOptions
//
// Synopsis:    per IObjectSafety
//
//-----------------------------------------------------------------------------

HRESULT
CDoc::GetInterfaceSafetyOptions(
    REFIID riid,
    DWORD *pdwSupportedOptions,
    DWORD *pdwEnabledOptions)
{
    *pdwSupportedOptions = *pdwEnabledOptions =
        INTERFACESAFE_FOR_UNTRUSTED_CALLER | INTERFACESAFE_FOR_UNTRUSTED_DATA;
    return S_OK;
}


//+----------------------------------------------------------------------------
//
// Member:      CDoc::SetInterfaceSafetyOptions
//
// Synopsis:    per IObjectSafety
//
//-----------------------------------------------------------------------------

HRESULT
CDoc::SetInterfaceSafetyOptions(
    REFIID riid,
    DWORD dwOptionSetMask,
    DWORD dwEnabledOptions)
{
    // This needs to hook into the IObjectSafety calls we make on objects.
    // (anandra)
    return S_OK;
}


//+----------------------------------------------------------------------------
//
// Member:      CDoc::SetUIHandler
//
// Synopsis:    per ICustomDoc
//
//-----------------------------------------------------------------------------

HRESULT
CDoc::SetUIHandler(IDocHostUIHandler *pUIHandler)
{
    IOleCommandTarget * pHostUICommandHandler = NULL;

    ReplaceInterface(&_pHostUIHandler, pUIHandler);
    if (pUIHandler && _pHostUIHandler == pUIHandler)
        _fUIHandlerSet = TRUE;

    if (_pHostUIHandler)
    {
        // We don't care if this succeeds (for now), we init pHostUICommandHandler to NULL.
        //
        IGNORE_HR(_pHostUIHandler->QueryInterface(IID_IOleCommandTarget,
                                            (void**)&pHostUICommandHandler));
    }
    ReplaceInterface(&_pHostUICommandHandler, pHostUICommandHandler);
    ReleaseInterface(pHostUICommandHandler);
    
    return S_OK;
}


//+------------------------------------------------------------------------------
//
//      Member : FirePersistOnloads ()
//
//      Synopsis : temporary helper function to fire the history and shortcut onload
//          events.
//
//+------------------------------------------------------------------------------
void
CMarkup::FirePersistOnloads()
{
    CNotification   nf;
    long            i;
    CStackPtrAry<CElement *, 64>  aryElements(Mt(CDocPersistLoad_aryElements_pv));
    CMarkupBehaviorContext * pContext = NULL;

    if (S_OK != EnsureBehaviorContext(&pContext))
        return;
                
    if (pContext->_cstrHistoryUserData)
    {
        nf.XtagHistoryLoad(Root(), &aryElements);
        Notify(&nf);

        for (i = 0; i < aryElements.Size(); i++)
        {
            aryElements[i]->TryPeerPersist(XTAG_HISTORY_LOAD, 0);
        }
    }
    else if (Doc()->_pShortcutUserData)
    {
        FAVORITES_NOTIFY_INFO   sni;

        // load the favorites
        sni.pINPB = Doc()->_pShortcutUserData;
        sni.bstrNameDomain = SysAllocString(_T("DOC"));
        if (sni.bstrNameDomain != NULL)
        {
            nf.FavoritesLoad(Root(), &aryElements);
            Notify(&nf);

            for (i = 0; i < aryElements.Size(); i++)
            {
                aryElements[i]->TryPeerPersist(FAVORITES_LOAD, &sni);
            }

            SysFreeString(sni.bstrNameDomain);
        }
    }
}


HRESULT
CDoc::PersistFavoritesData(CMarkup *pMarkup,
                           INamedPropertyBag * pINPB,
                           LPCWSTR strDomain)
{
    HRESULT      hr = S_OK;
    PROPVARIANT  varValue;

    Assert (pINPB);

    // now load the variant, and save each property we are
    // interested in
    V_VT(&varValue) = VT_BSTR;
    V_BSTR(&varValue) = (TCHAR *) CMarkup::GetUrl(pMarkup);

    // for the document.. ALWAYS save the baseurl. this
    //  is used later for the security checkes fo the subframes.
    hr = THR(pINPB->WritePropertyNPB(strDomain,
                                     _T("BASEURL"),
                                     &varValue));

    RRETURN(hr);
}

//+-------------------------------------------------------------------------
//
//  Method:     CTimeoutEventList::GetFirstTimeoutEvent
//
//  Synopsis:   Returns the first timeout event if given event is found in the
//                 list. Im most cases the returned event will be the one
//                 with given id, but if WM_TIMER messages came out of order
//                 it can be another one with smaller target time.
//              Removes the event from the list before returning.
//
//              Return value is S_FALSE if given event is not in the list
//--------------------------------------------------------------------------

HRESULT
CTimeoutEventList::GetFirstTimeoutEvent(UINT uTimerID, TIMEOUTEVENTINFO **ppTimeout)
{
    HRESULT           hr = S_OK;
    int  nNumEvents = _aryTimeouts.Size();
    int               i;

    Assert(ppTimeout != NULL);

    // Find the event first
    for(i = nNumEvents - 1; i >= 0  ; i--)
    {
        if(_aryTimeouts[i]->_uTimerID == uTimerID)
            break;
    }

    if(i < 0)
    {
        // The event is no longer active, or there is an error
        *ppTimeout = NULL;
        hr = S_FALSE;
        goto Cleanup;
    }

    // Elements are sorted and given event is in the list.
    // As long as given element is in the list we can return the
    //      last element without further checks
    *ppTimeout = _aryTimeouts[nNumEvents - 1];

#ifndef WIN16
    // Win16: Use GetTimeout(pTimeout->_uTimerID, dummy pTimeout) to delete this.

    // Remove it from the array
    _aryTimeouts.Delete(nNumEvents - 1);
#endif


Cleanup:
    RRETURN1(hr, S_FALSE);
}



//+-------------------------------------------------------------------------
//
//  Method:     CTimeoutEventList::GetTimeout
//
//  Synopsis:   Gets timeout event with given timer id and removes it from the list
//
//              Return value is S_FALSE if given event is not in the list
//--------------------------------------------------------------------------

HRESULT
CTimeoutEventList::GetTimeout(UINT uTimerID, TIMEOUTEVENTINFO **ppTimeout)
{
    int                   i;
    HRESULT               hr;

    for(i = _aryTimeouts.Size() - 1; i >= 0  ; i--)
    {
        if(_aryTimeouts[i]->_uTimerID == uTimerID)
            break;
    }

    if(i >= 0)
    {
        *ppTimeout = _aryTimeouts[i];
        // Remove the pointer
        _aryTimeouts.Delete(i);
        hr = S_OK;
    }
    else
    {
        *ppTimeout = NULL;
        hr = S_FALSE;
    }

    RRETURN1(hr, S_FALSE);
}


//+-------------------------------------------------------------------------
//
//  Method:     CTimeoutEventList::InsertIntoTimeoutList
//
//  Synopsis:   Saves given timeout info pointer in the list
//
//              Returns the ID associated with timeout entry
//--------------------------------------------------------------------------

HRESULT
CTimeoutEventList::InsertIntoTimeoutList(TIMEOUTEVENTINFO *pTimeoutToInsert, UINT *puTimerID, BOOL fNewID)
{
    HRESULT hr = S_OK;
    int  i;
    int  nNumEvents = _aryTimeouts.Size();

    Assert(pTimeoutToInsert != NULL);

    // Fill the timer ID field with the next unused timer ID
    // We add this to make its appearance random
    if ( fNewID )
    {
#ifdef WIN16
        pTimeoutToInsert->_uTimerID = _uNextTimerID;
        _uNextTimerID = (_uNextTimerID < (UINT)0xFFFF) ? (_uNextTimerID+1) : 0xC000;
#else
        pTimeoutToInsert->_uTimerID = _uNextTimerID++ + (DWORD)(DWORD_PTR)this;
#endif
    }

    // Find the appropriate position. Current implementation keeps the elements
    // sorted by target time, with the one having min target time near the top
    for(i = 0; i < nNumEvents  ; i++)
    {
        if(pTimeoutToInsert->_dwTargetTime >= _aryTimeouts[i]->_dwTargetTime)
        {
            // Insert before current element
            hr = THR(_aryTimeouts.Insert(i, pTimeoutToInsert));
            if (hr)
                goto Cleanup;

            break;
        }
    }

    if(i == nNumEvents)
    {
        /// Append at the end
        hr = THR(_aryTimeouts.Append(pTimeoutToInsert));
        if (hr)
            goto Cleanup;
    }

    if (puTimerID)
        *puTimerID = pTimeoutToInsert->_uTimerID;

Cleanup:
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CTimeoutEventList::KillAllTimers
//
//  Synopsis:   Stops all the timers in the list and removes events from the list
//
//--------------------------------------------------------------------------

void
CTimeoutEventList::KillAllTimers(void * pvObject)
{
    int i;

    for(i = _aryTimeouts.Size() - 1; i >= 0; i--)
    {
        if (!FormsKillTimer(pvObject, _aryTimeouts[i]->_uTimerID))
        {
            delete _aryTimeouts[i];
            _aryTimeouts.Delete(i);
        }
    }

    for(i = _aryPendingTimeouts.Size() - 1; i >= 0; i--)
    {
        delete _aryPendingTimeouts[i];
    }
    _aryPendingTimeouts.DeleteAll();
    _aryPendingClears.DeleteAll();
}

//+-------------------------------------------------------------------------
//
//  Method:     CTimeoutEventList::GetPendingTimeout
//
//  Synopsis:   Gets a pending Timeout, and removes it from the list
//
//--------------------------------------------------------------------------
BOOL
CTimeoutEventList::GetPendingTimeout( TIMEOUTEVENTINFO **ppTimeout )
{
    int i;
    Assert( ppTimeout );
    if ( (i=_aryPendingTimeouts.Size()-1) < 0 )
    {
        *ppTimeout = NULL;
        return FALSE;
    }

    *ppTimeout = _aryPendingTimeouts[i];
    _aryPendingTimeouts.Delete(i);
    return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Method:     CTimeoutEventList::ClearPendingTimeout
//
//  Synopsis:   Removes a timer from the pending list and returns TRUE.
//              If timer with ID not found, returns FALSE
//
//--------------------------------------------------------------------------
BOOL
CTimeoutEventList::ClearPendingTimeout( UINT uTimerID )
{
    BOOL fFound = FALSE;

    for ( int i=_aryPendingTimeouts.Size() - 1; i >= 0; i-- )
    {
        if ( _aryPendingTimeouts[i]->_uTimerID == uTimerID )
        {
            delete _aryPendingTimeouts[i];
            _aryPendingTimeouts.Delete(i);
            fFound = TRUE;
            break;
        }
    }
    return fFound;
}

//+-------------------------------------------------------------------------
//
//  Method:     CTimeoutEventList::GetPendingClear
//
//  Synopsis:   Returns TRUE and an ID of a timer that was cleared during
//              timer processing. If there are none left, it returns FALSE.
//
//--------------------------------------------------------------------------
BOOL
CTimeoutEventList::GetPendingClear( LONG *plTimerID )
{
    int i;
    if ( (i=_aryPendingClears.Size()-1) < 0 )
    {
        *plTimerID = 0;
        return FALSE;
    }

    *plTimerID = (LONG)_aryPendingClears[i];
    _aryPendingClears.Delete(i);
    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Method:     ReportScriptletError
//
//  Synopsis:   Displays the scriptlet error that occurred.  The pContext
//              is either CPeerSite or CPeerFactoryUrl.  Depending
//              on that context we'll either return compile time or runtime
//              errors.
//
//--------------------------------------------------------------------------

HRESULT
ErrorRecord::Init(IScriptletError *pSErr, LPTSTR pchDocURL)
{
    HRESULT     hr;

    Assert(pSErr);

    hr = THR(pSErr->GetExceptionInfo(&_ExcepInfo));
    if (hr)
        goto Cleanup;

    hr = THR(pSErr->GetSourcePosition(&_uLine, &_uColumn));
    if (hr)
        goto Cleanup;

    _pchURL = pchDocURL;

Cleanup:
    RRETURN(hr);
}

HRESULT
ErrorRecord::Init(IActiveScriptError *pASErr, COmWindowProxy * pWndProxy)
{
    HRESULT     hr;
    long        uColumn;
    LPTSTR      pchMarkupURL = NULL;
    CDoc *      pDoc = pWndProxy->Markup()->Doc();
    Assert(pASErr);

    hr = THR(pASErr->GetExceptionInfo(&_ExcepInfo));
    if (hr)
        goto Cleanup;

#if defined(_WIN64)
    IActiveScriptError64 *pASErr64 = NULL;

    hr = THR(pASErr->QueryInterface(IID_IActiveScriptError64, (void **)&pASErr64));
    if (hr)
        goto Cleanup;

    hr = THR(pASErr64->GetSourcePosition64(&_dwSrcContext, &_uLine, &uColumn));
    ReleaseInterface(pASErr64);
#else
    hr = THR(pASErr->GetSourcePosition(&_dwSrcContext, &_uLine, &uColumn));
#endif
    if (hr)
        goto Cleanup;

    if (NO_SOURCE_CONTEXT != _dwSrcContext)
    {
        CMarkup *pMarkup = NULL;

        if (pDoc->_pScriptCookieTable)
        {
            HRESULT hr2 = THR(pDoc->_pScriptCookieTable->GetSourceObjects(_dwSrcContext, &pMarkup, NULL, &_pScriptDebugDocument));
            if (hr2 != S_OK)
                pMarkup = NULL;
        }
        else
        {
            pMarkup = (CMarkup *)_dwSrcContext;
            WHEN_DBG(CMarkup *pDbgMarkup=NULL;)
            Assert(pMarkup && (S_OK == pMarkup->QueryInterface(CLSID_CMarkup, (void **)&pDbgMarkup)) && (pMarkup == pDbgMarkup));
            Assert(!_pScriptDebugDocument);
        }

        if (pMarkup)
        {
            // There is a markup script context. We use its relative markup's Url.
            pchMarkupURL = (LPTSTR)CMarkup::GetUrl(pMarkup);
        }
    }

    _uColumn = uColumn;
    // IActiveScriptError assumes line #s/column #s are zero based.
    _uLine++;
    _uColumn++;

    // If the markup found from the cookie table has a script context, then use its URL, 
    // otherwise use the URL from the markup that is related to the window proxy we received.
    _pchURL = pchMarkupURL ? pchMarkupURL : (TCHAR *)CMarkup::GetUrl(pWndProxy->Markup());

Cleanup:
    RRETURN(hr);
}

HRESULT
ErrorRecord::Init(HRESULT hrError, LPTSTR pchErrorMessage, LPTSTR pchDocURL)
{
    HRESULT     hr;

    _pchURL = pchDocURL;
    _ExcepInfo.scode = hrError;

    hr = THR(FormsAllocString(pchErrorMessage, &_ExcepInfo.bstrDescription));

    RRETURN (hr);
}

HRESULT
CMarkup::ReportScriptError(ErrorRecord &errRecord)
{
    HRESULT     hr = S_OK;
    TCHAR      *pchDescription;
    TCHAR       achDescription[256];
    BSTR        bstrURL = NULL;
    BSTR        bstrDescr = NULL;
    BOOL        fContinueScript = FALSE;
    BOOL        fErrorHandled;
    COmWindowProxy *    pWindow = Window(); 
    CWindow     *pCWindow;
    CScriptCollection * pScriptCollection = GetScriptCollection();
    CMarkup::CLock      markupLock(this);

#ifdef UNIX // support scripting error dialog option.
    HKEY        key;
    TCHAR       ach[10];
    DWORD       dwType, dwLength = 10 * sizeof(TCHAR);
    BOOL        fShowDialog = TRUE;
#endif

    // No more messages to return or if the script was aborted (through the
    // script debugger) then don't put up any UI.
    Assert(this == GetWindowedMarkupContext());
    Assert(pWindow);
    pCWindow = pWindow->Window();
    Assert(pCWindow);

    if (pCWindow->_fEngineSuspended || errRecord._ExcepInfo.scode == E_ABORT)
        goto Cleanup;

    // These errors are reported on LeaveScript where we're guaranteed to have
    // enough memory and stack space for the error message.
    if (pCWindow->_fStackOverflow || pCWindow->_fOutOfMemory)
    {
        if (!pCWindow->_fEngineSuspended)
        {
            pCWindow->_badStateErrLine = errRecord._uLine;
            goto StopAllScripts;
        }
        else
            goto Cleanup;
    }

    //
    // Get a description of the error.
    //

    // vbscript passes empty strings and jscript passes NULL, so check for both

    if (errRecord._ExcepInfo.bstrDescription && *errRecord._ExcepInfo.bstrDescription)
    {
        pchDescription = errRecord._ExcepInfo.bstrDescription;
    }
    else
    {
        GetErrorText(errRecord._ExcepInfo.scode, achDescription, ARRAY_SIZE(achDescription));
        pchDescription = achDescription;
    }

    if (pWindow)
    {
        if (errRecord._pchURL)
        {
            hr = THR(FormsAllocString(errRecord._pchURL, &bstrURL));
            if (hr)
                goto Cleanup;
        }

        // Allocate a BSTR for the description string
        hr = THR(FormsAllocString(pchDescription, &bstrDescr));
        if (hr)
            goto Cleanup;

        fErrorHandled = pWindow->Fire_onerror(bstrDescr,
                                                 bstrURL,
                                                 errRecord._uLine,
                                                 errRecord._uColumn,
                                                 errRecord._ExcepInfo.wCode,
                                                 FALSE);

        if (!fErrorHandled)
        {
    #ifdef UNIX // Popup error-dialog? No script error dialog = No script debugger ?
            if (ERROR_SUCCESS == RegOpenKey( HKEY_CURRENT_USER,
                                             _T("Software\\MICROSOFT\\Internet Explorer\\Main"),
                                             &key))
            {
                if (ERROR_SUCCESS == RegQueryValueEx( key, _T("Disable Scripting Error Dialog"),
                                                      0, &dwType, (LPBYTE)ach, &dwLength))
                {
                    fShowDialog = (_tcscmp(ach, _T("no")) == 0);
                }
                RegCloseKey(key);
            }

            if ( !fShowDialog )
            {
                fContinueScript = TRUE; //Keep script running.
                hr = S_OK;
                goto StopAllScripts;
            }
    #endif

            if (errRecord._ExcepInfo.scode == VBSERR_OutOfStack)
            {
                if (!pCWindow->_fStackOverflow)
                {
                    pCWindow->_badStateErrLine = errRecord._uLine;
                    pCWindow->_fStackOverflow = TRUE;
                }
            }
            else if (errRecord._ExcepInfo.scode == VBSERR_OutOfMemory)
            {
                if (!pCWindow->_fOutOfMemory)
                {
                    pCWindow->_badStateErrLine = errRecord._uLine;
                    pCWindow->_fOutOfMemory = TRUE;
                }
            }

            // Stack overflow or out of memory error?
            if (pCWindow->_fStackOverflow || pCWindow->_fOutOfMemory)
            {
                // If pending stack overflow/out of memory have we
                // unwound the stack enough before displaying the
                // message.  These CDoc::LeaveScript function will
                // actually display the message when we leave the
                // last script.
                if (!pCWindow->_fEngineSuspended)
                    goto StopAllScripts;
                else
                    goto Cleanup;
            }

            fContinueScript = pWindow->Fire_onerror(bstrDescr,
                                                       bstrURL,
                                                       errRecord._uLine,
                                                       errRecord._uColumn,
                                                       errRecord._ExcepInfo.wCode,
                                                       TRUE);


StopAllScripts:
            //
            // If our container has asked us to refrain from using dialogs, we
            // should abort the script.  Otherwise we could end up in a loop
            // where we just sit and spin.
            //
            if ((_pDoc->_dwLoadf & DLCTL_SILENT) || !fContinueScript)
            {
                // Shutoff non-function object based script engines (VBSCRIPT)
                if (pScriptCollection && (pScriptCollection == GetScriptCollection(FALSE)))
                    IGNORE_HR(pScriptCollection->SetState(SCRIPTSTATE_DISCONNECTED));

                // Shutoff function object based script engines (JSCRIPT)
                _pDoc->_dwLoadf |= DLCTL_NO_SCRIPTS;

                pCWindow->_fEngineSuspended = TRUE;

                // Need to set this on the Doc as well so that the recalc engine can
                // use this, as it has no context markup.
                _pDoc->_fEngineSuspended = TRUE;
 
                hr = S_OK;
            }
        }
    }

Cleanup:
    FormsFreeString(bstrDescr);
    FormsFreeString(bstrURL);

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\unitmeas.cxx ===
//+---------------------------------------------------------------------
//
//   File:      uniutmeas.cxx
//
//  Contents:   Unit Measurement element class, etc..
//
//  Classes:    CUnitMeasurement, etc..
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_UNITMEAS_HXX_
#define X_UNITMEAS_HXX_
#include "unitmeas.hxx"
#endif

#ifndef X_STYLE_HXX_
#define X_STYLE_HXX_
#include "style.hxx"
#endif

#define _cxx_
#include "unitmeas.hdl"

DEFINE_SUBOBJECT_CREATOR(CUnitMeasurement );

CBase::CLASSDESC CUnitMeasurement::s_classdesc =
{
    &CLSID_UnitMeasurement,         // _pclsid
    0,                              // _idrBase
    NULL,                           // property pages
    0,                              // _ccp
    0,                              // _pcpi
    0,                              // _dwFlags
    &IID_IUnitMeasurement,          // _piidDispinterface
    0,                              // _lAccRole
    0,                              // _pPropCats;
    0,                              // _appropdescs;
    s_apVTableInterf,               // _apvtableinterf
};

CUnitMeasurement::CUnitMeasurement ( CElement *pElemObj,
    PROPERTYDESC *pPropdesc,
    MEASURETYPE MeasureType )
{
    Assert ( pElemObj );
    Assert ( pPropdesc );
    _pElem = pElemObj;
    _pPropdesc = pPropdesc;
    _MeasureType = MeasureType;
    // Ref count the main object so it doesn't go away
    _pElem -> AddRef();
}

HRESULT CUnitMeasurement::PrivateQueryInterface(REFIID iid, void **ppv)
{
    *ppv = NULL;
    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_INHERITS(this, IDispatch)
    default:
        if (iid == IID_IUnitMeasurement)
        {
           *ppv = (IUnitMeasurement *) this;
        }
        else if ( iid == CLSID_UnitMeasurement )
        {
            // Internaly used QI to get the object ptr, just cast return type to class ptr
            *ppv = this;
            // Weak ref, don't AddRef() object
            return S_OK;
        }
    }

    if (*ppv)
    {
        ((IUnknown*)*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

HRESULT CUnitMeasurement::GetStoredUnitValue ( CUnitValue *puvValue )
{
    HRESULT hr = CallHandler ( HANDLEPROP_AUTOMATION, (void *)puvValue );
    RRETURN ( hr );
}

HRESULT CUnitMeasurement::CallHandler ( DWORD dwFlags, void *pvArg )
{
    BASICPROPPARAMS *pbpp = (BASICPROPPARAMS *)(_pPropdesc+1);
    HRESULT hr;
    CBase  *pBaseObject;
    void *pSubObject;

    if ( pbpp->dwPPFlags & PROPPARAM_ATTRARRAY )
    {
        pSubObject = (void *)&_pElem->_pAA;
    }
    else
    {
        pSubObject = (void *)_pElem;
    }
    pBaseObject = _pElem;

    hr = THR ( CALL_METHOD(_pPropdesc, _pPropdesc->pfnHandleProperty,
        ( dwFlags  , pvArg, pBaseObject, (CVoid *)pSubObject ) ));

    RRETURN ( hr );
}

HRESULT CUnitMeasurement::SetStoredUnitValue ( CUnitValue uvValue )
{
    HRESULT hr;

    hr = CallHandler ( HANDLEPROP_SET | HANDLEPROP_AUTOMATION, (void *)&uvValue );
    RRETURN ( hr );
}

long CUnitMeasurement::GetValueFromPixelRect ( void )
{
    POINT pos;
    SIZE  size;

    pos.x = pos.y = szie.cx size.cy = 0;

    if ( OTHERX != _MeasureType && OTHERY != _MeasureType &&
         STYLEOTHERX != _MeasureType && STYLEOTHERY != _MeasureType)
    {   // get's the layout position of site regardless if it is parked
        CLayout *pLayout = _pElem->GetUpdatedLayout();

        if(pLayout)
            pLayout->GetUnparkedPosition( &pos, &size );
    }

    switch ( _MeasureType )
    {
    case TOP:
    case STYLETOP:
        return pos.y;

    case LEFT:
    case STYLELEFT:
        return pos.x;

    case WIDTH:
    case STYLEWIDTH:
        return size.cx;

    case HEIGHT:
    case STYLEHEIGHT:
        return size.cy;

    default:
        return 0;
    }
}


HRESULT CUnitMeasurement::SetPixelValue ( long lValue )
{
    CUnitValue uvValue;
    HRESULT hr;

    // Set the value to the equivalent value of lValue pixels when expressed in
    // the current units of the unit value
    hr = GetStoredUnitValue ( &uvValue );
    if ( hr )
        goto Cleanup;

    if ( IsMeasureInXDirection() )
        hr = THR(uvValue.XSetFloatValueKeepUnits ( (float)lValue, CUnitValue::UNIT_PIXELS,
            GetValueFromPixelRect(), 1 ));
    else
        hr = THR(uvValue.YSetFloatValueKeepUnits ( (float)lValue, CUnitValue::UNIT_PIXELS,
            GetValueFromPixelRect(),1  ) );

    if ( hr )
        goto Cleanup;

    hr = THR(SetStoredUnitValue ( uvValue ));

Cleanup:
    RRETURN ( SetErrorInfo ( hr ) );
}

HRESULT CUnitMeasurement::put_value (float vValue)
{
    CUnitValue uvValue;
    CUnitValue::UNITVALUETYPE uvt;
    HRESULT hr;

#ifdef RGARDNER
    if ( !_pElem->ShouldHaveLayout() )
    {
        // Not Valid to set unit measurements on non-site objects
        hr = CTL_E_METHODNOTAPPLICABLE;
        goto Cleanup;
    }
#endif

    // vValue represents the value of the property in the current
    // document units ( document.DefaultUnits ). Set the internal
    // value but keep the persisted unit the same.
    hr = THR ( GetStoredUnitValue ( &uvValue ) );
    if ( hr )
        goto Cleanup;

    uvt = uvValue.GetUnitType();

    // TODO rgardner. If we are put'ing an OTHERX/OTHERY, which has no
    // pixel value to get, we won't be able to convert if the unit is
    // currently in percent.
    if ( ( _MeasureType == OTHERX || _MeasureType == OTHERY || _MeasureType == STYLEOTHERX || _MeasureType == STYLEOTHERY ) &&
        ( uvt == CUnitValue::UNIT_PERCENT || uvt == CUnitValue::UNIT_TIMESRELATIVE ) )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if ( IsMeasureInXDirection() )
    
        hr = THR(uvValue.XSetFloatValueKeepUnits ( vValue, GetDocUnits(),
            GetValueFromPixelRect(), 1 ));
    else
        hr = THR(uvValue.YSetFloatValueKeepUnits ( vValue, GetDocUnits(),
            GetValueFromPixelRect(), 1 ) );

    if ( hr )
        goto Cleanup;

    hr = SetStoredUnitValue ( uvValue );

Cleanup:
    RRETURN ( SetErrorInfo ( hr ) );
}



HRESULT CUnitMeasurement::get_value ( float *pvValue )
{
    // Get the current value into pvValue, expressed in the
    // default document units
    CUnitValue uvValue;
    HRESULT hr;

#ifdef RGARDNER
    if ( !_pElem->ShouldHaveLayout() )
    {
        hr = CTL_E_METHODNOTAPPLICABLE;
        goto Cleanup;
    }
#endif
	
    if ( !pvValue )
    {
        // Not Valid to set unit measurements on non-site objects
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR ( GetStoredUnitValue ( &uvValue ) );
    if ( hr )
        goto Cleanup;

    if ( ! ( _MeasureType == OTHERX || _MeasureType == OTHERY || _MeasureType == STYLEOTHERX || _MeasureType == STYLEOTHERY ||
        CUnitValue::IsScalerUnit ( uvValue.GetUnitType() ) ) )
    {
        uvValue.SetValue ( GetValueFromPixelRect(), CUnitValue::UNIT_PIXELS );
    }

    if ( IsMeasureInXDirection() )
        *pvValue = uvValue.XGetFloatValueInUnits ( GetDocUnits()); 
    else
        *pvValue = uvValue.YGetFloatValueInUnits ( GetDocUnits());
Cleanup:
    RRETURN ( SetErrorInfo ( hr ) );

}

HRESULT CUnitMeasurement::put_unit ( BSTR bstrUnit )
{
    HRESULT hr;
    CUnitValue uvValue;
    DWORD dwPPFlags;
    CUnitValue::UNITVALUETYPE uvt;

    htmlUnits Unit;

    hr = ENUMFROMSTRING ( htmlUnits, bstrUnit, (long *)&Unit );
    if ( hr )
        goto Cleanup;

#ifdef RGARDNER
    if ( !_pElem->ShouldHaveLayout() )
    {
        // Not Valid to set unit measurements on non-site objects
        hr = CTL_E_METHODNOTAPPLICABLE;
        goto Cleanup;
    }
#endif

    // Convert unit value into new units
    uvt =  (CUnitValue::UNITVALUETYPE) Unit;

    if ( uvt < 0 || uvt > CUnitValue::UNIT_TIMESRELATIVE )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    dwPPFlags = _pPropdesc -> GetPPFlags();

    // Is the unit valid as identified in the propdesc
    // but pixels are always valid
    if ( ( CUnitValue::IsScalerUnit ( uvt ) && 
                (uvt != CUnitValue::UNIT_PIXELS) && 
                !(dwPPFlags & PROPPARAM_LENGTH ) ) ||
         ( uvt == CUnitValue::UNIT_TIMESRELATIVE && !(dwPPFlags & PROPPARAM_TIMESRELATIVE) ) ||
         ( uvt == CUnitValue::UNIT_PERCENT && !(dwPPFlags & PROPPARAM_PERCENTAGE) ) )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // Set the persisted HTML unit,
    // Convert value to new units
    hr = THR ( GetStoredUnitValue ( &uvValue ) );
    if ( hr )
        goto Cleanup;

    if ( IsMeasureInXDirection() )
        hr = uvValue.XConvertToUnitType ( uvt, GetValueFromPixelRect(), 1 );
    else
        hr = uvValue.YConvertToUnitType ( uvt, GetValueFromPixelRect(), 1 );

    if ( hr )
        goto Cleanup;


    // Store the new value away
    hr = SetStoredUnitValue ( uvValue );

Cleanup:
    RRETURN ( SetErrorInfo ( hr ) );
}

HRESULT CUnitMeasurement::get_unit (BSTR *pbstrUnit)
{
    HRESULT hr ;
    CUnitValue uvValue;
    htmlUnits Unit;

#ifdef RGARDNER
    if ( !_pElem->ShouldHaveLayout() )
    {
        // Not Valid to set unit measurements on non-site objects
        hr = CTL_E_METHODNOTAPPLICABLE;
        goto Cleanup;
    }
#endif
    if ( !pbstrUnit )
    {
        // Not Valid to set unit measurements on non-site objects
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // Get the unit type from the persisted value
    hr = THR ( GetStoredUnitValue ( &uvValue ) );
    if ( hr )
        goto Cleanup;

    Unit = (htmlUnits) uvValue.GetUnitType() ;

    hr = STRINGFROMENUM ( htmlUnits, (long)Unit, pbstrUnit );

Cleanup:
    RRETURN ( SetErrorInfo ( hr ) );
}

HRESULT CUnitMeasurement::put_unitValue ( float fValue )
{
    CUnitValue uvValue;
    HRESULT hr;

#ifdef RGARDNER
    if ( !_pElem->ShouldHaveLayout() )
    {
        // Not Valid to set unit measurements on non-site objects
        hr = CTL_E_METHODNOTAPPLICABLE;
        goto Cleanup;
    }
#endif

    // vValue represents the value of the property in the current
    // document units ( document.DefaultUnits ). Set the internal
    // value but keep the persisted unit the same.
    hr = THR ( GetStoredUnitValue ( &uvValue ) );
    if ( hr )
        goto Cleanup;

    hr = THR ( uvValue.SetFloatUnitValue ( fValue ) );

    if ( hr )
        goto Cleanup;

    // Store the new value away
    hr = SetStoredUnitValue ( uvValue );

Cleanup:
    RRETURN ( SetErrorInfo ( hr ) );
}

HRESULT CUnitMeasurement::get_unitValue (float * pfUnitValue)
{
    HRESULT hr ;
    CUnitValue uvValue;

    if ( !pfUnitValue )
    {
        // Not Valid to set unit measurements on non-site objects
        hr = E_INVALIDARG;
        goto Cleanup;
    }    
#ifdef RGARDNER
    if ( !_pElem->ShouldHaveLayout() )
    {
        // Not Valid to set unit measurements on non-site objects
        hr = CTL_E_METHODNOTAPPLICABLE;
        goto Cleanup;
    }
#endif

    hr = THR ( GetStoredUnitValue ( &uvValue ) );
    if ( hr )
        goto Cleanup;

    if ( uvValue.IsNull() )
    {
        *pfUnitValue = 0.0;
    }
    else
    {
        if ( IsMeasureInXDirection() )
            *pfUnitValue = uvValue.XGetFloatValueInUnits ( uvValue.GetUnitType() );
        else
            *pfUnitValue = uvValue.YGetFloatValueInUnits ( uvValue.GetUnitType() );
    }
Cleanup:
    RRETURN ( SetErrorInfo ( hr ) );
}

HRESULT CUnitMeasurement::put_htmlText ( BSTR bstrText )
{
    HRESULT hr;
    
#ifdef RGARDNER
    if ( !_pElem->ShouldHaveLayout() )
    {
        // Not Valid to set unit measurements on non-site objects
        hr = CTL_E_METHODNOTAPPLICABLE;
        goto Cleanup;
    }
#endif
    
    hr = CallHandler ( HANDLEPROP_SET | HANDLEPROP_AUTOMATION |
        (PROPTYPE_LPWSTR << 16), (void *)bstrText );
#ifdef RGARDNER
Cleanup:
#endif
    RRETURN ( SetErrorInfo ( hr ) );
}

HRESULT CUnitMeasurement::get_htmlText (BSTR * pbstrText)
{
    VARIANT vt;
    HRESULT hr;

    if ( !pbstrText )
    {
        // Not Valid to set unit measurements on non-site objects
        hr = E_INVALIDARG;
        goto Cleanup;
    }
#ifdef RGARDNER
    if ( !_pElem->ShouldHaveLayout() )
    {
        // Not Valid to set unit measurements on non-site objects
        hr = CTL_E_METHODNOTAPPLICABLE;
        goto Cleanup;
    }
#endif

    hr = CallHandler ( HANDLEPROP_AUTOMATION | (PROPTYPE_VARIANT << 16),
        (void *)&vt );

    // I know the UnitValue handler will put a BSTR in the variant
    // for me
    *pbstrText = V_BSTR ( &vt );

Cleanup:
    RRETURN ( SetErrorInfo ( hr ) );
}



/*static*/
HRESULT CUnitMeasurement::CreateSubObject ( CElement *pElemObj,
    PROPERTYDESC *pPropdesc, MEASURETYPE MeasureType, IUnitMeasurement **ppObj )
{
    HRESULT hr = S_OK;

    Assert ( ppObj );

    *ppObj = (IUnitMeasurement *) new CUnitMeasurement ( pElemObj, pPropdesc, MeasureType );
    if ( !*ppObj )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

Cleanup:
    RRETURN ( hr );
}

CUnitMeasurement::~CUnitMeasurement()
{
    _pElem -> Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\unknown.cxx ===
//+---------------------------------------------------------------------
//
//   File:      unknown.cxx
//
//  Contents:   Element class
//
//  Classes:    CUnknownElement
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_CONNECT_HXX_
#define X_CONNECT_HXX_
#include "connect.hxx"
#endif

#ifndef X_MSHTMLRC_H_
#define X_MSHTMLRC_H_
#include "mshtmlrc.h"
#endif

#ifndef X_ELEMENT_HXX_
#define X_ELEMENT_HXX_
#include "element.hxx"
#endif

#ifndef X_CFPF_HXX_
#define X_CFPF_HXX_
#include "cfpf.hxx"
#endif

#ifndef X_HTMTAGS_HXX_
#define X_HTMTAGS_HXX_
#include "htmtags.hxx"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#ifndef X__DOC_H_
#define X__DOC_H_
#include "_doc.h"
#endif

#define _cxx_
#include "unknown.hdl"

MtDefine(CUnknownElement, Elements, "CUnknownElement")

//+----------------------------------------------------------------------------
//
//  Class:      CUnknownElement
//
//-----------------------------------------------------------------------------
             
const CElement::CLASSDESC CUnknownElement::s_classdesc =
{
    {
        &CLSID_HTMLUnknownElement,          // _pclsid
        0,                                  // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                     // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                             // _pcpi
        ELEMENTDESC_NOLAYOUT,               // _dwFlags
        &IID_IHTMLUnknownElement,           // _piidDispinterface
        &s_apHdlDescs,                      // _apHdlDesc
    },
    (void *)s_apfnIHTMLUnknownElement,      //_apfnTearOff

    NULL                                    // _pAccelsRun
};


//+-----------------------------------------------------------
//
//  Class: CUnknownElement
//
//------------------------------------------------------------

CUnknownElement::CUnknownElement (CHtmTag *pht, CDoc *pDoc)
  : CElement(ETAG_UNKNOWN, pDoc)
{
    const TCHAR *pchTagName;
    HRESULT     hr;
    
    if (pht->GetTag() == ETAG_UNKNOWN)
        pchTagName = pht->GetPch();
    else
        pchTagName = NameFromEtag(pht->GetTag());

    if (pchTagName && pht->IsEnd() && *pchTagName != _T('/'))
    {
        // If this is an end tag and there is no slash in the tag name,
        // add one now.
        hr = THR(_cstrTagName.Set(_T("/")));
        if (hr)
            goto Error;
    }
    else
    {
        hr = THR(_cstrTagName.Set(_T("")));
        if (hr)
            goto Error;
    }
    
    if (pchTagName)
    {
        hr = THR(_cstrTagName.Append(pchTagName));
        if (hr)
            goto Error;
    }

    CharUpper(_cstrTagName);

    _fAttemptAtomicSave = pht->IsEmpty();

Error:
    return;
}

HRESULT CUnknownElement::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElement)
{
    Assert(ppElement);
    *ppElement = new CUnknownElement(pht, pDoc);
    return *ppElement ? S_OK : E_OUTOFMEMORY;
}

//+------------------------------------------------------------------------
//
//  Method:     CUnknownElement::Init2
//
//-------------------------------------------------------------------------

HRESULT
CUnknownElement::Init2(CInit2Context * pContext)
{
    HRESULT     hr;

    hr = THR(super::Init2(pContext));

    RRETURN (hr);
}



//+----------------------------------------------------------------------------
//  
//  Method:     CUnknownElement::Save
//  
//  Synopsis:   Saves an uknown element
//  
//  Returns:    HRESULT
//  
//  Arguments:
//          CStreamWriteBuff * pStreamWriteBuff - stream to save to
//          BOOL fEnd - save begin vs. save end
//  
//+----------------------------------------------------------------------------

HRESULT
CUnknownElement::Save( CStreamWriteBuff * pStreamWriteBuff, BOOL fEnd )
{
    HRESULT hr = S_OK;

    // Unknown elements are no-scope, so we don't need to check for contents
    hr = THR( WriteTag(pStreamWriteBuff, fEnd, FALSE, _fAttemptAtomicSave) );
    if(hr)
        goto Cleanup;

Cleanup:
    RRETURN( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\urlcomp.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994
//
//  File:       urlcomp.cxx
//
//  Contents:   URL compatibility code
//
//              Provides compatibility bits for specific URLs
//
//  Classes:    CDoc (partial)
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_URLCOMP_HXX_
#define X_URLCOMP_HXX_
#include "urlcomp.hxx"
#endif

#ifndef X_ASSOC_HXX_
#define X_ASSOC_HXX_
#include "assoc.hxx"
#endif

#ifndef X_UWININET_H_
#define X_UWININET_H_
#include "uwininet.h"
#endif

static TCHAR achUrlCompatRootKey[] = _T("Software\\Microsoft\\Internet Explorer\\URL Compatibility");
static TCHAR achCompatFlags[] =      _T("Compatibility Flags");
static TCHAR achIcwKey[] = _T("Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\ICWCONN1.EXE");
static TCHAR szIcwPath[MAX_PATH];
extern const TCHAR szOurVersion[];

static CPtrBagCi<DWORD> g_bCompatUrls(TRUE);

static DWORD g_dwDefaultUrlCompatFlags;

//+---------------------------------------------------------------------------
//
//  Function:   ShouldWeRegisterUrlCompatibilityTable
//
//  Synopsis:   Determine whether we should write our compatibility table,
//              as recorded in selfreg.inf, to the registry.
//  
//              We do if the table is not in the registry at all, or if
//              our version of the table is more recent than that in the
//              registry.
//
//              NOTE: szOurVersion comes from clstab.cxx
//
//  Returns:    TRUE - yes, write the table please.
//
//----------------------------------------------------------------------------

BOOL 
ShouldWeRegisterUrlCompatibilityTable()
{
    BOOL fOurRet = TRUE;
    LRESULT lr;
    HKEY hkeyRoot = NULL;
    DWORD dwSize, dwType;
    TCHAR szVersion[10];

    lr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, achUrlCompatRootKey, 0, KEY_READ, &hkeyRoot);
    if (lr != ERROR_SUCCESS)
        return(TRUE);

    dwSize = sizeof(szVersion);
    lr = RegQueryValueEx(hkeyRoot, _T("Version"), NULL, &dwType, (BYTE*)szVersion, &dwSize);
    if (lr == ERROR_SUCCESS)
        fOurRet = (_tcscmp(szVersion, szOurVersion) < 0);

    RegCloseKey(hkeyRoot);

    return(fOurRet);
}

void AppendIcwPath(TCHAR * pch)
{
    TCHAR ach[MAX_PATH];

    _tcscpy(ach, szIcwPath);
    _tcscat(ach, pch + 1);  // ignoring the leading '~'
    _tcscpy(pch, ach);
}
//+---------------------------------------------------------------------------
//
//  Function:   LegalKeyCharFromChar
//
//  Synopsis:   Some chars are not legal in a registry key, so replace them
//              with legal chars.
//
//  Returns:    TCHAR
//
//----------------------------------------------------------------------------

inline TCHAR
LegalKeyCharFromChar(TCHAR ch)
{
    if (ch <= _T(' '))
        return _T('!');

    if (ch >= 127)
        return _T('~');

    if (ch == _T('\\'))
        return _T('/');
        
    if (ch == _T('?') || ch == _T('*'))
        return _T('_');

    return ch;
}

//+---------------------------------------------------------------------------
//
//  Function:   CleanupUrl
//
//  Synopsis:   Remove \'s etc from the URL (by converting to / etc)
//
//  Returns:    void
//
//----------------------------------------------------------------------------

void CleanupUrl(TCHAR * pchTo, TCHAR * pch, ULONG cch)
{
    cch--;
    while (*pch && cch)
    {
        *pchTo++ = LegalKeyCharFromChar(*pch++);
        cch--;
    }
    *pchTo = 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   InitUrlCompatTable
//
//  Synopsis:   Reads URL compat bits from the registry and puts them in
//              a hash table for fast lookup.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
InitUrlCompatTable()
{
    HKEY hkeyRoot = NULL;
    HKEY hkey = NULL;
    ULONG iKey;
    static TCHAR ach[pdlUrlLen];
    ULONG cch;
    ULONG cb;
    DWORD dwType;
    DWORD dwFlags;
    HRESULT hr = S_OK;
    LRESULT lr;
    static TCHAR achAppWiz[MAX_PATH] = _T("res://%SystemRoot%\\system32\\appwiz.cpl/default.hta");
    static TCHAR achExpandedAppWiz[MAX_PATH];

    
    lr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, achIcwKey, 0, KEY_READ, &hkeyRoot);
    if (lr != ERROR_SUCCESS)
        return S_OK;

    cb = ARRAY_SIZE(szIcwPath);
    lr = RegQueryValueEx(hkeyRoot, _T("Path"), NULL, &dwType, (BYTE*) szIcwPath, &cb);
    if (lr != ERROR_SUCCESS)
        goto Win32Error;

    lr = RegCloseKey(hkeyRoot);
    if (lr != ERROR_SUCCESS)
        goto Win32Error;

    // replace drive letter with '_' and remove the trailing ';'
    if (*szIcwPath)
    {
        szIcwPath[_tcslen(szIcwPath) - 1] = 0;
        GetShortPathName(szIcwPath, szIcwPath, ARRAY_SIZE(szIcwPath));
        szIcwPath[0]=_T('_');
    }

    CleanupUrl(szIcwPath, szIcwPath, ARRAY_SIZE(szIcwPath));

    
    // Open root key
    lr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, achUrlCompatRootKey, 0, KEY_READ, &hkeyRoot);
    if (lr != ERROR_SUCCESS)
        goto Win32Error;

    // Add Add/Remove programs to the url compat table.
    if (0 == ExpandEnvironmentStrings(achAppWiz, achExpandedAppWiz, ARRAY_SIZE(achExpandedAppWiz)))
        goto Win32Error;

    CleanupUrl(achExpandedAppWiz, achExpandedAppWiz, ARRAY_SIZE(achExpandedAppWiz));

    hr = THR(g_bCompatUrls.SetCi(achExpandedAppWiz, URLCOMPAT_ALLOWBIND));
    if (hr)
        goto Cleanup;
    
    // Read each table entry
    for (iKey = 0; ; iKey++)
    {
        cch = ARRAY_SIZE(ach);
        lr = RegEnumKeyEx(hkeyRoot, iKey, ach, &cch, NULL, NULL, NULL, NULL);
        if (lr != ERROR_SUCCESS )
            break;
            
        ach[cch] = _T('\0');

        lr = RegOpenKeyEx(hkeyRoot, ach, 0, KEY_READ, &hkey);
        if (lr != ERROR_SUCCESS)
            continue;

        cb = sizeof(dwFlags);
        lr = RegQueryValueEx(hkey, achCompatFlags, NULL, &dwType, (BYTE*)&dwFlags, &cb);
        
        if (lr == ERROR_SUCCESS && dwType == REG_DWORD && cb == sizeof(dwFlags))
        {
            if (ach[0] == _T('~'))
                AppendIcwPath(ach);

            hr = THR(g_bCompatUrls.SetCi(ach, dwFlags));
            if (hr)
                goto Cleanup;
        }

        lr = RegCloseKey(hkey);
        if (lr != ERROR_SUCCESS)
            goto Win32Error;
            
        hkey = NULL;
    }
    
    g_dwDefaultUrlCompatFlags = g_bCompatUrls.GetCi(_T("Default"));
    
Cleanup:
    if (hkey)
        RegCloseKey(hkey);
    if (hkeyRoot)
        RegCloseKey(hkeyRoot);

    RRETURN(hr);

Win32Error:
    hr = HRESULT_FROM_WIN32(lr);
    goto Cleanup;
}

//+---------------------------------------------------------------------------
//
//  Function:   CompatBitsFromUrl
//
//  Synopsis:   Looks up URL in a case-insensitive hash table and returns
//              compat bits.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CompatBitsFromUrl(TCHAR *pchUrl, DWORD *dwUrlCompat)
{
    TCHAR *pch;
    TCHAR ach[pdlUrlLen];
    ULONG cch = ARRAY_SIZE(ach);
    DWORD dwFlags;
    HRESULT hr = S_OK;

    // File URLs become paths

    if (GetUrlScheme(pchUrl) == URL_SCHEME_FILE)
    {
        hr = THR(PathCreateFromUrl(pchUrl, ach, &cch, 0));
        if (hr)
            goto Cleanup;

        GetShortPathName(ach, ach, ARRAY_SIZE(ach));

        // replace drive letter with '_'
        if (*ach)
        {
            ach[0]=_T('_');
        }

        pch = ach;
        cch = ARRAY_SIZE(ach);
    }
    else
    {
        pch = pchUrl;
    }

    CleanupUrl(ach, pch, cch);

    dwFlags = g_bCompatUrls.GetCi(ach);

    *dwUrlCompat = dwFlags ? dwFlags : g_dwDefaultUrlCompatFlags;

Cleanup:
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\verifycallstack.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       window.cxx
//
//  Contents:   Implementation of CWindow, CScreen classes
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#if DBG==1

#ifndef X_VERIFYCALLSTACK_HXX_
#define X_VERIFYCALLSTACK_HXX_
#include "VerifyCallStack.hxx"
#endif

//
// Walk call stack to verify that the call is coming from the right caller
//
// PARAMS:
// pchOneModule - if specified, Assert if no good caller was found before a caller from a different module
// pCallers - array of VERIFYSTACK_CALLERINFO
// cCallers - size of the array
//
// RETURN: S_OK if a good caller is found, E_FAIL otherwise
//
HRESULT VerifyCallStack(const char *pchOneModule, 
                        const VERIFYSTACK_CALLERINFO *aCallers, 
                        int cCallers, 
                        VERIFYSTACK_SYMBOLINFO *pBuffer, 
                        int cbBuffer,
                        int *piBadCaller)   // index of problem caller in the buffer
{
    const int iFirstCaller = 1; // this is how far we are from the first caller or interest
    
    int cMaxStack = cbBuffer / sizeof(VERIFYSTACK_SYMBOLINFO);
    int iFirstFrame = cMaxStack;
    int iLastFrame = 0;
    int iCaller;
    int cStack;
    HRESULT hr = S_OK;

    if (piBadCaller)
        *piBadCaller = 0;

    // get the widest frame range
    for (iCaller = 0; iCaller < cCallers; iCaller++)
    {
        if (iFirstFrame > aCallers[iCaller].iFirstToCheck)
            iFirstFrame = aCallers[iCaller].iFirstToCheck;
        
        if (iLastFrame < aCallers[iCaller].iLastToCheck)
            iLastFrame = aCallers[iCaller].iLastToCheck;
    }

    // we handle at most cMaxStack frames
    if (iLastFrame - iFirstFrame + 1 > cMaxStack)
        iLastFrame = iFirstFrame - 1 + cMaxStack;

    // Get stack
    cStack = DbgExGetStackTrace(iFirstCaller + iFirstFrame, 
                                iLastFrame - iFirstFrame + 1, 
                                (BYTE *) pBuffer, 
                                cbBuffer, 
                                VERIFYSTACK_SYMBOLINFO::cchMaxModule, 
                                VERIFYSTACK_SYMBOLINFO::cchMaxSymbol); 
    
    if (!cStack)
    {
        AssertSz(FALSE, "VerifyCallStack: failed to get stack symbols");
        goto Cleanup;
    }

    // look for the modules/symbols
    int iFrame = iFirstCaller + iFirstFrame;
    BOOL fHaveGood = FALSE;
    for (int i = 0; i < cStack; i++, iFrame++)
    {
        // If must stay in one module, check that
        if (pchOneModule && *pchOneModule &&
            0 != strncmp(pBuffer[i].achModule, pchOneModule, VERIFYSTACK_SYMBOLINFO::cchMaxModule))
        {
            break;
        }

        // Check for callers of interest
        const VERIFYSTACK_CALLERINFO *pCaller = aCallers;
        for (iCaller = 0; iCaller < cCallers; iCaller++, pCaller++)
        {
            if ((pCaller->pchSymbol == NULL ||
                 !*pCaller->pchSymbol ||
                 0 == strncmp(pBuffer[i].achSymbol, pCaller->pchSymbol, VERIFYSTACK_SYMBOLINFO::cchMaxSymbol)
                )
                &&
                0 == strncmp(pBuffer[i].achModule, pCaller->pchModule, VERIFYSTACK_SYMBOLINFO::cchMaxModule))
            {
                // it's a match!
                switch (pCaller->kCaller)
                {
                case CALLER_GOOD:
                    fHaveGood = TRUE;
                    break;
                case CALLER_BAD:
                    goto BadCaller;
                case CALLER_BAD_IF_FIRST:
                    if (!fHaveGood)
                        goto BadCaller;
                    break;
                default:
                    AssertSz(FALSE, "Bad Caller Kind");
                }
            }
        }
    }

    // All checked. If there were no good callers, assert
    if (fHaveGood)
        goto Cleanup;
            
BadCaller:
    // too bad, something went wrong
    hr = E_FAIL;
    if (piBadCaller)
        *piBadCaller = max(i, cStack);

Cleanup:
    return hr;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\window.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       window.cxx
//
//  Contents:   Implementation of CWindow, CScreen classes
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_SCRIPT_HXX_
#define X_SCRIPT_HXX_
#include "script.hxx"
#endif

#ifndef X_STYLE_HXX_
#define X_STYLE_HXX_
#include "style.hxx"
#endif

#ifndef X_DOM_HXX_
#define X_DOM_HXX_
#include "dom.hxx"
#endif



#ifndef X_CONNECT_HXX_
#define X_CONNECT_HXX_
#include "connect.hxx"
#endif

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx"
#endif

#ifndef X_COLLECT_HXX_
#define X_COLLECT_HXX_
#include "collect.hxx"
#endif

#ifndef X_FRAME_HXX_
#define X_FRAME_HXX_
#include "frame.hxx"   // for a brief reference to cframesite.
#endif

#ifndef X_EXDISP_H_
#define X_EXDISP_H_
#include "exdisp.h"
#endif

#ifndef X_DISPEX_H_
#define X_DISPEX_H_
#include "dispex.h" // idispatchex
#endif

#ifndef X_UWININET_H_
#define X_UWININET_H_
#include "uwininet.h"
#endif

#ifndef X_EOPTION_HXX_
#define X_EOPTION_HXX_
#include "eoption.hxx"
#endif

#ifndef X_IMGELEM_HXX_
#define X_IMGELEM_HXX_
#include "imgelem.hxx"
#endif

#ifndef X_TXTSITE_HXX_
#define X_TXTSITE_HXX_
#include "txtsite.hxx"
#endif

#ifndef X_DOCGLBS_HXX_
#define X_DOCGLBS_HXX_
#include "docglbs.hxx"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_TEAROFF_HXX_
#define X_TEAROFF_HXX_
#include "tearoff.hxx"
#endif

#ifndef X_EVNTPRM_HXX_
#define X_EVNTPRM_HXX_
#include "evntprm.hxx"
#endif

#ifndef X_MSHTMHST_H_
#define X_MSHTMHST_H_
#include <mshtmhst.h>
#endif

#ifndef X_EVENTOBJ_HXX_
#define X_EVENTOBJ_HXX_
#include "eventobj.hxx"
#endif

#ifndef X_HTMLHELP_H_
#define X_HTMLHELP_H_
#include "htmlhelp.h"
#endif

#ifndef X_DISPNODE_HXX_
#define X_DISPNODE_HXX_
#include "dispnode.hxx"
#endif

#ifndef X_XBAG_HXX_
#define X_XBAG_HXX_
#include "xbag.hxx"
#endif

#ifndef X_CUTIL_HXX_
#define X_CUTIL_HXX_
#include "cutil.hxx"
#endif

#ifndef X_CBUFSTR_HXX_
#define X_CBUFSTR_HXX_
#include "cbufstr.hxx"
#endif

#ifndef X__DXFROBJ_H_
#define X__DXFROBJ_H_
#include "_dxfrobj.h"
#endif

#ifndef X_ROOTELEM_HXX
#define X_ROOTELEM_HXX
#include "rootelem.hxx"
#endif

#ifndef X_TXTDEFS_H_
#define X_TXTDEFS_H_
#include "txtdefs.h"
#endif

#ifndef X_HTMLPOP_HXX_
#define X_HTMLPOP_HXX_
#include "htmlpop.hxx"
#endif

#ifndef X_HTMLDLG_HXX_
#define X_HTMLDLG_HXX_
#include "htmldlg.hxx"
#endif

#ifndef X_HTIFRAME_H_
#define X_HTIFRAME_H_
#include "htiframe.h"
#endif

#ifndef X_HTIFACE_H_
#define X_HTIFACE_H_
#include "htiface.h"
#endif

#ifndef X_HLINK_H_
#define X_HLINK_H_
#include "hlink.h"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_TPOINTER_HXX_
#define X_TPOINTER_HXX_
#include "tpointer.hxx"
#endif

#ifndef X_ESTYLE_HXX_
#define X_ESTYLE_HXX_
#include "estyle.hxx"
#endif

#ifndef X_ELINK_HXX_
#define X_ELINK_HXX_
#include "elink.hxx"
#endif

#ifndef X_EMAP_HXX_
#define X_EMAP_HXX_
#include "emap.hxx"
#endif

#ifndef X_EAREA_HXX_
#define X_EAREA_HXX_
#include "earea.hxx"
#endif

#ifndef X_ROOTELEM_HXX_
#define X_ROOTELEM_HXX_
#include "rootelem.hxx"
#endif

#ifndef X_HEDELEMS_HXX_
#define X_HEDELEMS_HXX_
#include "hedelems.hxx"
#endif

#ifndef X_EBODY_HXX_
#define X_EBODY_HXX_
#include "ebody.hxx"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif

#ifndef X_PROGSINK_HXX_
#define X_PROGSINK_HXX_
#include "progsink.hxx"
#endif

#ifndef X_SELECOBJ_HXX_
#define X_SELECOBJ_HXX_
#include "selecobj.hxx"
#endif

#ifndef X_OTHRGUID_H_
#define X_OTHRGUID_H_
#include "othrguid.h"
#endif

#ifndef X_PERHIST_H_
#define X_PERHIST_H_
#include "perhist.h"
#endif

#ifndef X_PERHIST_HXX_
#define X_PERHIST_HXX_
#include "perhist.hxx"
#endif

#ifndef X_FRAMET_H_
#define X_FRAMET_H_
#include "framet.h"
#endif

#ifndef X_ACCWIND_HXX_
#define X_ACCWIND_HXX_
#include "accwind.hxx"
#endif

#ifndef X_WEBOCUTIL_H_
#define X_WEBOCUTIL_H_
#include "webocutil.h"
#endif

#ifndef X_FRAMEWEBOC_HXX_
#define X_FRAMEWEBOC_HXX_
#include "frameweboc.hxx"
#endif

#ifndef X_OLESITE_HXX_
#define X_OLESITE_HXX_
#include "olesite.hxx"
#endif

#ifndef X_PRIVACY_HXX_
#define X_PRIVACY_HXX_
#include "privacy.hxx"
#endif


#ifndef X_OBJSAFE_H_
#define X_OBJSAFE_H_
#include "objsafe.h"
#endif

#ifndef X_THEMEHLP_HXX_
#define X_THEMEHLP_HXX_
#include "themehlp.hxx"
#endif

#if DBG==1
#ifndef X_VERIFYCALLSTACK_HXX_
#define X_VERIFYCALLSTACK_HXX_
#include "VerifyCallStack.hxx"
#endif
#ifndef X_DEBUGWINDOW_HXX_
#define X_DEBUGWINDOW_HXX_
#include "DebugWindow.h"
#endif
#endif


// external reference.
HRESULT WrapSpecialUrl(TCHAR *pchURL, CStr *pcstr, const TCHAR *pchBaseURL, BOOL fNotPrivate, BOOL fIgnoreUrlScheme);
extern BOOL IsSpecialUrl(LPCTSTR pszUrl);

extern BOOL g_fInPip;

EXTERN_C const GUID CLSID_CDocument;
extern BOOL IsScriptUrl(LPCTSTR pszURL);

BOOL GetCallerHTMLDlgTrust(CBase *pBase);

#define _cxx_
#include "window.hdl"

#define _cxx_
#include "document.hdl"

extern BOOL g_fInVizAct2000;
extern BOOL g_fInPhotoSuiteIII;

DeclareTag(tagOmWindow, "OmWindow", "OmWindow methods");
DeclareTag(tagSecurityContext, "Security", "Security Context Information Traces");
ExternTag(tagSecurityProxyCheck);
ExternTag(tagSecurityProxyCheckMore);
ExternTag(tagSecureScriptWindow);

MtDefine(CTimeoutEventList, CDoc, "CDoc::_TimeoutEvents");
MtDefine(CTimeoutEventList_aryTimeouts_pv, CTimeoutEventList, "CDoc::_TimeoutEvents::_aryTimeouts::_pv");
MtDefine(CTimeoutEventList_aryPendingTimeouts_pv, CTimeoutEventList, "CDoc::_TimeoutEvents::_aryPendingTimeouts::_pv");
MtDefine(CTimeoutEventList_aryPendingClears_pv, CTimeoutEventList, "CDoc::_TimeoutEvents::_aryPendingClears::_pv");
DeclareTag(tagReadystateAssert, "IgnoreRS", "ReadyState Assert");
HRESULT GetFullyExpandedUrl(CBase *pBase, BSTR bstrUrl, BSTR *pbstrFullUrl, BSTR * pbstrBaseUrl = NULL, IServiceProvider *pSP = NULL);
HRESULT GetCallerURL(CStr &cstr, CBase *pBase, IServiceProvider * pSP);
HRESULT GetCallerSecurityStateAndURL(SSL_SECURITY_STATE *pSecState, CStr &cstr, CBase *pBase, IServiceProvider * pSP);
TCHAR * ProtocolFriendlyName(TCHAR * szUrl);
#define ISVARIANTEMPTY(var) (V_VT(var) == VT_ERROR  || V_VT(var) == VT_EMPTY)
MtDefine(CWindow, ObjectModel, "CWindow");
MtDefine(CDocument, ObjectModel, "CDocument");
MtDefine(CWindowFindNamesFromOtherScripts_aryScript_pv, Locals, "CWindow::FindNamesFromOtherScripts aryScript::_pv");
MtDefine(CWindowFindNamesFromOtherScripts_pdispid, Locals, "CWindow::FindNamesFromOtherScripts pdispid");
MtDefine(EVENTPARAM, Locals, "EVENTPARAM");
MtDefine(CDataTransfer, ObjectModel, "CDataTransfer");
MtDefine(CFramesCollection, ObjectModel, "CFramesCollection");
MtDefine(CWindow_aryActiveModelessDlgs, CWindow, "CWindow::ClearCachedDialogs");
MtDefine(CWindow_aryPendingScriptErr, CWindow, "CWindow::ReportPendingScriptErrors");

BEGIN_TEAROFF_TABLE(CWindow, IProvideMultipleClassInfo)
    TEAROFF_METHOD(CWindow, GetClassInfo, getclassinfo, (ITypeInfo ** ppTI))
    TEAROFF_METHOD(CWindow, GetGUID, getguid, (DWORD dwGuidKind, GUID * pGUID))
    TEAROFF_METHOD(CWindow, GetMultiTypeInfoCount, getmultitypeinfocount, (ULONG *pcti))
    TEAROFF_METHOD(CWindow, GetInfoOfIndex, getinfoofindex, (
            ULONG iti,
            DWORD dwFlags,
            ITypeInfo** pptiCoClass,
            DWORD* pdwTIFlags,
            ULONG* pcdispidReserved,
            IID* piidPrimary,
            IID* piidSource))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE_(CWindow, IServiceProvider)
        TEAROFF_METHOD(CWindow, QueryService, queryservice, (REFGUID guidService, REFIID riid, void **ppvObject))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CDocument, IServiceProvider)
        TEAROFF_METHOD(CDocument, QueryService, queryservice, (REFGUID guidService, REFIID riid, void **ppvObject))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CDataTransfer, IServiceProvider)
        TEAROFF_METHOD(CDataTransfer, QueryService, queryservice, (REFGUID guidService, REFIID riid, void **ppvObject))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CWindow, ITravelLogClient)
    TEAROFF_METHOD (CWindow, FindWindowByIndex, findwindowbyindex, (DWORD dwID, IUnknown ** ppunk))
    TEAROFF_METHOD (CWindow, GetWindowData, getwindowdata, (LPWINDOWDATA pWinData))
    TEAROFF_METHOD (CWindow, LoadHistoryPosition, loadhistoryposition, (LPOLESTR pszUrlLocation, DWORD dwCookie))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CWindow, IPersistHistory)
    // IPersist methods
    TEAROFF_METHOD(CWindow, GetClassID, getclassid, (LPCLSID lpClassID))
    // IPersistHistory methods
    TEAROFF_METHOD(CWindow, LoadHistory, loadhistory, (IStream *pStream, IBindCtx *pbc))
    TEAROFF_METHOD(CWindow, SaveHistory, savehistory, (IStream *pStream))
    TEAROFF_METHOD(CWindow, SetPositionCookie, setpositioncookie, (DWORD dwCookie))
    TEAROFF_METHOD(CWindow, GetPositionCookie, getpositioncookie, (DWORD *pdwCookie))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CDocument, IPersistFile)
    // IPersist methods
    TEAROFF_METHOD(CDocument, GetClassID, getclassid, (CLSID *))
    // IPersistFile methods
    TEAROFF_METHOD(CDocument, IsDirty, isdirty, ())
    TEAROFF_METHOD(CDocument, Load, load, (LPCOLESTR pszFileName, DWORD dwMode))
    TEAROFF_METHOD(CDocument, Save, save, (LPCOLESTR pszFileName, BOOL fRemember))
    TEAROFF_METHOD(CDocument, SaveCompleted, savecompleted, (LPCOLESTR pszFileName))
    TEAROFF_METHOD(CDocument, GetCurFile, getcurfile, (LPOLESTR *ppszFileName))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CDocument, IPersistMoniker)
    TEAROFF_METHOD(CDocument, GetClassID, getclassid, (LPCLSID lpClassID))
    TEAROFF_METHOD(CDocument, IsDirty, isdirty, ())
    TEAROFF_METHOD(CDocument, Load, load, (BOOL fFullyAvailable, IMoniker *pmkName, LPBC pbc, DWORD grfMode))
    TEAROFF_METHOD(CDocument, Save, save, (IMoniker *pmkName, LPBC pbc, BOOL fRemember))
    TEAROFF_METHOD(CDocument, SaveCompleted, savecompleted, (IMoniker *pmkName, LPBC pibc))
    TEAROFF_METHOD(CDocument, GetCurMoniker, getcurmoniker, (IMoniker  **ppimkName))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CDocument, IPersistStreamInit)  // also IPersistStream
    // IPersist methods
    TEAROFF_METHOD(CDocument, GetClassID, getclassid, (CLSID * pclsid ))
    // IPersistStream and IPersistStreamInit methods
    TEAROFF_METHOD(CDocument, IsDirty, isdirty, ())
    TEAROFF_METHOD(CDocument, Load, load, (LPSTREAM pStream ))
    TEAROFF_METHOD(CDocument, Save, save, (LPSTREAM pStream, BOOL fClearDirty ))
    TEAROFF_METHOD(CDocument, GetSizeMax, getsizemax, (ULARGE_INTEGER FAR * pcbSize ))
    //IPersistStreamInit only methods
    TEAROFF_METHOD(CDocument, InitNew, initnew, ())
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CDocument, IPersistHistory)
    // IPersist methods
    TEAROFF_METHOD(CDocument, GetClassID, getclassid, (LPCLSID lpClassID))
    // IPersistHistory methods
    TEAROFF_METHOD(CDocument, LoadHistory, loadhistory, (IStream *pStream, IBindCtx *pbc))
    TEAROFF_METHOD(CDocument, SaveHistory, savehistory, (IStream *pStream))
    TEAROFF_METHOD(CDocument, SetPositionCookie, setpositioncookie, (DWORD dwCookie))
    TEAROFF_METHOD(CDocument, GetPositionCookie, getpositioncookie, (DWORD *pdwCookie))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CDocument, IObjectSafety)
    TEAROFF_METHOD(CDocument, GetInterfaceSafetyOptions, getinterfacesafetyoptions, (REFIID riid, DWORD *pdwSupportedOptions, DWORD *pdwEnabledOptions))
    TEAROFF_METHOD(CDocument, SetInterfaceSafetyOptions, setinterfacesafetyoptions, (REFIID riid, DWORD dwOptionSetMask, DWORD dwEnabledOptions))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CWindow, ITargetNotify2)
    // ITargetNotify methods
    TEAROFF_METHOD(CWindow, OnCreate, oncreate, (IUnknown * pUnkDestination, ULONG cbCookie))
    TEAROFF_METHOD(CWindow, OnReuse, onreuse, (IUnknown * pUnkDestination))

    // ITargetNotify2 methods
    TEAROFF_METHOD(CWindow, GetOptionString, getoptionstring, (BSTR * pbstrOptions))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CWindow, IHTMLPrivateWindow)
    TEAROFF_METHOD(CWindow, SuperNavigate, supernavigate, (BSTR      bstrURL,
                                                           BSTR      bstrLocation,
                                                           BSTR      bstrShortcut,
                                                           BSTR      bstrFrameName,
                                                           VARIANT * pvarPostData,
                                                           VARIANT * pvarHeaders,
                                                           DWORD     dwFlags))
    TEAROFF_METHOD(CWindow, GetPendingUrl, getpendingurl, (LPOLESTR* pstrURL))
    TEAROFF_METHOD(CWindow, SetPICSTarget, setpicstarget, (IOleCommandTarget* pctPICS))
    TEAROFF_METHOD(CWindow, PICSComplete, picscomplete,   (BOOL fApproved))
    TEAROFF_METHOD(CWindow, FindWindowByName, findwindowbyname, (LPCOLESTR pstrTargetName, IHTMLWindow2 ** ppWindow))
    TEAROFF_METHOD(CWindow, GetAddressBarUrl, getaddressbarurl, (BSTR * pbstrURL))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CWindow, IHTMLPrivateWindow3)
    // IHTMLPrivateWindow2 methods
    TEAROFF_METHOD(CWindow, NavigateEx, navigateex, (BSTR bstrURL, BSTR bstrOriginal, BSTR bstrLocation, BSTR bstrContext, IBindCtx* pBindCtx, DWORD dwNavOptions, DWORD dwFHLFlags))
    TEAROFF_METHOD(CWindow, GetInnerWindowUnknown, getinnerwindowunknown, (IUnknown** ppUnknown))

    // IHTMLPrivateWindow3 methods
    TEAROFF_METHOD(CWindow, OpenEx, openex, (BSTR url, BSTR urlContext, BSTR name, BSTR features, VARIANT_BOOL replace, IHTMLWindow2 **pomWindowResult))
END_TEAROFF_TABLE()

#if DBG==1
BEGIN_TEAROFF_TABLE(CWindow, IDebugWindow)
    TEAROFF_METHOD(CWindow, SetProxyCaller, setproxycaller, (IUnknown *pProxy))
END_TEAROFF_TABLE()
#endif

const CONNECTION_POINT_INFO CWindow::s_acpi[] =
{
    CPI_ENTRY(IID_IDispatch, DISPID_A_EVENTSINK)
    CPI_ENTRY(DIID_HTMLWindowEvents, DISPID_A_EVENTSINK)
    CPI_ENTRY(IID_ITridentEventSink, DISPID_A_EVENTSINK)
    CPI_ENTRY(DIID_HTMLWindowEvents2, DISPID_A_EVENTSINK)
    CPI_ENTRY_NULL
};

const CBase::CLASSDESC CWindow::s_classdesc =
{
    &CLSID_HTMLWindow2,             // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif // NO_PROPERTY_PAGE
    s_acpi,                         // _pcpi
    0,                              // _dwFlags
    &IID_IHTMLWindow2,              // _piidDispinterface
    &s_apHdlDescs,                  // _apHdlDesc
};

CDummySecurityDispatchEx g_DummySecurityDispatchEx;

class COptionsHolder;


HRESULT InternalShowModalDialog( HTMLDLGINFO * pdlgInfo );
HRESULT InternalModelessDialog( HTMLDLGINFO * pdlgInfo );
HRESULT EnsureAccWindow( CWindow * pWindow );

//+----------------------------------------------------------------------------------
//
//  Helper:     VariantToPrintableString
//
//  Synopsis:   helper for alert and confirm methods of window, etc.
//
//              Converts VARIANT to strings that conform with the JavaScript model.
//
//-----------------------------------------------------------------------------------

HRESULT
VariantToPrintableString (VARIANT * pvar, CStr * pstr)
{
    HRESULT     hr = S_OK;
    TCHAR       szBuf[64];

    Assert (pstr);

    switch (V_VT(pvar))
    {
        case VT_EMPTY :
        case VT_ERROR :
            LoadString(GetResourceHInst(), IDS_VAR2STR_VTERROR, szBuf, ARRAY_SIZE(szBuf));
            hr =THR(pstr->Set(szBuf));
            break;
        case VT_NULL :
            LoadString(GetResourceHInst(), IDS_VAR2STR_VTNULL, szBuf, ARRAY_SIZE(szBuf));
            hr = THR(pstr->Set(szBuf));
            break;
        case VT_BOOL :
            if (VARIANT_TRUE == V_BOOL(pvar))
            {
                LoadString(GetResourceHInst(), IDS_VAR2STR_VTBOOL_TRUE, szBuf, ARRAY_SIZE(szBuf));
                hr = THR(pstr->Set(szBuf));
            }
            else
            {
                LoadString(GetResourceHInst(), IDS_VAR2STR_VTBOOL_FALSE, szBuf, ARRAY_SIZE(szBuf));
                hr = THR(pstr->Set(szBuf));
            }
            break;
        case VT_BYREF:
        case VT_VARIANT:
            pvar = V_VARIANTREF(pvar);
            // fall thru
        default:
        {
            VARIANT varNew;
            VariantInit(&varNew);
            hr = THR(VariantChangeTypeSpecial(&varNew, pvar,VT_BSTR));
            if (!hr)
            {
                hr = THR(pstr->Set(V_BSTR(&varNew)));
                VariantClear(&varNew);
            }
        }

    }

    RRETURN (hr);
}

//+-------------------------------------------------------------------------
//
//  Method:     CWindow::CWindow
//
//  Synopsis:   ctor
//
//--------------------------------------------------------------------------

CWindow::CWindow(CMarkup *pMarkup)
{
    _pMarkup = pMarkup;
    pMarkup->SubAddRef();

    _dwPositionCookie  = NO_POSITION_COOKIE;

    IncrementObjectCount(&_dwObjCnt);
}

//+-------------------------------------------------------------------------
//
//  Method:     CWindow::CWindow
//
//  Synopsis:   dtor
//
//--------------------------------------------------------------------------
CWindow::~CWindow()
{
    Assert( !_pMarkup );
    Assert( !_pMarkupPending );

    if (_pAccWindow)
        delete _pAccWindow;

    // It is safe to delete here as we will get here only when
    // all refs to these subobjects are gone.
    delete _pHistory;
    delete _pLocation;
    delete _pNavigator;
}

CDoc *CWindow::Doc()
{
    if(_pMarkup && (_pMarkup->Doc())!= NULL)
    {
        return _pMarkup->Doc();
    }
    else
    {
        return NULL;
    }
}

CMarkup *
CWindow::Markup()
{
    // assert integrity of the links
    Assert (_pDocument);
    Assert (!_pDocument->_pMarkup && this == _pDocument->_pWindow);
    Assert ( _pMarkupPending || !_pMarkup->HasDocumentPtr());
    Assert ( _pMarkup || _pMarkupPending );

    // return the markup
    return _pMarkup;
};

//+-------------------------------------------------------------------------
//
//  Method:     CWindow::Passivate
//
//  Synopsis:   1st phase destructor
//
//--------------------------------------------------------------------------
void
CWindow::Passivate()
{
    // Work around for to asyncronous issues of IWebBrowser2
    if (_pFrameWebOC)
    {
        _pFrameWebOC->DetachFromWindow();
    }
        
    DetachOnloadEvent();
    
    // Free the name string
    _cstrName.Free();
    VariantClear(&_varOpener);

    if (_pMarkupPending)
        ReleaseMarkupPending( _pMarkupPending );

    Assert( !_pMarkupPending );

    if (_pDocument)
        GWKillMethodCall(Document(), ONCALL_METHOD(CDocument, FirePostedOnPropertyChange, firepostedonpropertychange), 0);

    ClearMetaRefresh();

    Assert( !_pMarkup );

    ClearWindowData();

    if (_pWindowParent)
    {
        _pWindowParent->SubRelease();
        _pWindowParent = NULL;

        // If we go away without reenable modeless on
        // our parent markup, the parent will never
        // be able to navigate again.
        Assert( !_ulDisableModeless );
    }

    // In an error/out of memory condition, we may not have ever hooked up the document
    if (_pDocument)
    {
        Document()->PrivateRelease();
    }

    // Note: If there is no ViewLinked WebOC this is still okay.
    // This call is now being used with the changes in ViewLinkedWebOC.
    // We no longer disconnect on DocumentComplete

    ReleaseViewLinkedWebOC();

    if (_pFrameWebOC)
    {
        _pFrameWebOC->Release();
        _pFrameWebOC = NULL;
    }

    if ( _pLicenseMgr )
    {
        ((IUnknown*)_pLicenseMgr)->Release();
        _pLicenseMgr = NULL;
    }

    Assert(!_pOpenedWindow);
    Assert(!_pMarkupProgress);
    Assert(_dwProgCookie == 0);

    // passivate embedded objects
    _Screen.Passivate();

    super::Passivate();

    DecrementObjectCount(&_dwObjCnt);
}


//+-------------------------------------------------------------------------
//
//  Method:     CWindow::ReleaseViewLinkedWebOC
//
//  Synopsis:   helper to let go of WebOC correctly
//
//--------------------------------------------------------------------------
void
CWindow::ReleaseViewLinkedWebOC()
{
    Assert(!_dwWebBrowserEventCookie || _punkViewLinkedWebOC);

    if (_dwWebBrowserEventCookie && _punkViewLinkedWebOC)
    {
        DisconnectSink(_punkViewLinkedWebOC,
                       DIID_DWebBrowserEvents2,
                       &_dwWebBrowserEventCookie);
    }

    ClearInterface(&_punkViewLinkedWebOC);
}


//+-------------------------------------------------------------------------
//
//  Method:     CWindow::PrivateQueryInterface
//
//  Synopsis:   Per IPrivateUnknown
//
//--------------------------------------------------------------------------

HRESULT
CWindow::PrivateQueryInterface(REFIID iid, LPVOID * ppv)
{
    *ppv = NULL;
    switch (iid.Data1)
    {
    // The IOmWindow * cast is required to distinguish between CBase vs/
    // IOmWindow IDispatch methods.
    QI_TEAROFF(this, IProvideMultipleClassInfo, NULL)
    QI_TEAROFF2(this, IProvideClassInfo, IProvideMultipleClassInfo, NULL)
    QI_TEAROFF2(this, IProvideClassInfo2, IProvideMultipleClassInfo, NULL)
    QI_INHERITS(this, IHTMLWindow2)
    QI_INHERITS(this, IHTMLWindow3)
    QI_INHERITS(this, IHTMLWindow4)
    QI_INHERITS(this, IDispatchEx)
    QI_INHERITS2(this, IDispatch, IHTMLWindow2)
    QI_INHERITS2(this, IUnknown, IHTMLWindow2)
    QI_INHERITS2(this, IHTMLFramesCollection2, IHTMLWindow2)
    QI_TEAROFF(this,  IServiceProvider, NULL)
    QI_TEAROFF(this,  ITravelLogClient, NULL)
    QI_TEAROFF(this,  IPersistHistory, NULL)
    QI_TEAROFF2(this, IPersist, IPersistHistory, NULL)
    QI_TEAROFF(this,  ITargetNotify2, NULL)
    QI_TEAROFF2(this, ITargetNotify, ITargetNotify2, NULL)
    QI_TEAROFF(this,  IHTMLPrivateWindow, NULL)
    QI_TEAROFF(this,  IHTMLPrivateWindow3, NULL)
    QI_TEAROFF2(this,  IHTMLPrivateWindow2, IHTMLPrivateWindow3, NULL)

#if DBG==1
    QI_TEAROFF(this,  IDebugWindow, NULL)
#endif

    QI_CASE(IConnectionPointContainer)
    {
        *((IConnectionPointContainer **)ppv) =
                new CConnectionPointContainer(this, NULL);

        if (!*ppv)
            RRETURN(E_OUTOFMEMORY);
        break;
    }

    default:
        if (iid == CLSID_HTMLWindow2)
        {
            *ppv = this;
            // do not do AddRef()
            return S_OK;
        }
    }

    if (!*ppv)
        RRETURN(E_NOINTERFACE);

    ((IUnknown *)*ppv)->AddRef();

    DbgTrackItf(iid, "CWindow", FALSE, ppv);

    return S_OK;
}


//+------------------------------------------------------------------------
//
//  Member:     CWindow::PrivateAddRef, IUnknown
//
//  Synopsis:   Private unknown AddRef.
//
//-------------------------------------------------------------------------
ULONG
CWindow::PrivateAddRef()
{
    if( _ulRefs == 1 && _pWindowProxy )
    {
        _pWindowProxy->AddRef();
    }

    return super::PrivateAddRef();
}

//+------------------------------------------------------------------------
//
//  Member:     CWindow::PrivateRelease, IUnknown
//
//  Synopsis:   Private unknown Release.
//
//-------------------------------------------------------------------------
ULONG
CWindow::PrivateRelease()
{
    COmWindowProxy * pProxyRelease = NULL;

    if( _ulRefs == 2 )
        pProxyRelease = _pWindowProxy;

    ULONG ret =  super::PrivateRelease();

    if( pProxyRelease )
    {
        pProxyRelease->Release();
    }

    return ret;
}

//+------------------------------------------------------------------------
//
//  Member:     CWindow::SetProxy
//
//  Synopsis:   Play ref counting games when the proxy is set
//
//-------------------------------------------------------------------------
void
CWindow::SetProxy( COmWindowProxy * pProxyTrusted )
{
    Assert( pProxyTrusted );

    // The stack is holding on to us and the
    // proxy is already holding on to us
    Assert( _ulRefs >= 2 );
    _pWindowProxy = pProxyTrusted;
    _pWindowProxy->AddRef();
}

//+-------------------------------------------------------------------------
//
//  Method : COmWindow::QueryService
//
//  Synopsis : IServiceProvider methoid Implementaion.
//
//--------------------------------------------------------------------------

HRESULT
CWindow::QueryService(REFGUID guidService, REFIID riid, void **ppvObject)
{
    HRESULT hr = E_POINTER;

    if (!ppvObject)
        goto Cleanup;

    *ppvObject = NULL;

    if (   _punkViewLinkedWebOC
        && !Doc()->_fActiveDesktop
        && IsEqualIID(guidService, IID_ITargetFrame2)
        && GetInnerWindow()
        && GetInnerWindow()->Markup()->IsXML()       )
    {
        hr = IUnknown_QueryService(_punkViewLinkedWebOC, guidService, riid, ppvObject);
        goto Cleanup;
    }
    else if (  _punkViewLinkedWebOC
            && IsEqualIID(guidService, SID_STopFrameBrowser)
            && IsEqualIID(riid, IID_IBrowserService))
    {
        hr = EnsureFrameWebOC();
        if (hr)
            goto Cleanup;

        hr = _pFrameWebOC->QueryService(guidService, riid, ppvObject);
        goto Cleanup;
    }
    else if (!_pMarkup->IsPrimaryMarkup() && IsEqualIID(riid, IID_IBrowserService))
    {
        goto Cleanup;
    }
    else if (   _pMarkup
             && !_pMarkup->IsPrimaryMarkup()
             && (   IsEqualIID(guidService, IID_IWebBrowserApp)
                 || IsEqualIID(guidService, SID_SHlinkFrame)
                 || IsEqualIID(guidService, IID_ITargetFrame)))
    {
        hr = EnsureFrameWebOC();
        if (hr)
            goto Cleanup;

        hr = _pFrameWebOC->PrivateQueryInterface(riid, ppvObject);
        goto Cleanup;
    }
    else if (IsEqualIID(guidService, SID_SHTMLWindow2))
    {
        hr = PrivateQueryInterface(riid, ppvObject);
        goto Cleanup;
    }
    else if (IsEqualIID(guidService, CLSID_HTMLWindow2))
    {
        hr = S_OK;

        // return a weak reference to ourselves.
        *ppvObject = this;

        goto Cleanup;
    }

    hr = THR_NOTRACE(Doc()->QueryService(guidService,
                                         riid,
                                         ppvObject));

Cleanup:
    RRETURN1(hr, E_NOINTERFACE);
}

CDocument *
CWindow::Document()
{
    Assert (_pDocument);
    Assert (!_pMarkup || !_pMarkup->HasDocumentPtr());

    return _pDocument;
}

HRESULT
CWindow::AttachOnloadEvent(CMarkup * pMarkup)
{
    Assert(pMarkup);

    if (_pMarkupProgress == pMarkup)
    {
        return S_OK;
    }

    IProgSink * pProgSink = CMarkup::GetProgSinkHelper(pMarkup);

    if (pProgSink)
    {
        _pMarkupProgress = pMarkup;
        _pMarkupProgress->SubAddRef();

        RRETURN(pProgSink->AddProgress(PROGSINK_CLASS_FRAME, &_dwProgCookie));
    }

    return S_OK;
}

void
CWindow::DetachOnloadEvent()
{
    if (_pMarkupProgress && _dwProgCookie)
    {
        IProgSink * pProgSink = CMarkup::GetProgSinkHelper(_pMarkupProgress);

        if (pProgSink)
        {
            IGNORE_HR(pProgSink->DelProgress(_dwProgCookie));
        }

        _dwProgCookie = 0;
        _pMarkupProgress->SubRelease();
        _pMarkupProgress = NULL;
    }
}

//+-------------------------------------------------------------------------
//
//  Method    : CWindow::FindWindowByIndex
//
//  Interface : ITravelLogClient
//
//  Synopsis  : Returns the window with the given index. This method
//              recursively searches the frames collection for the window
//              with the given ID. If there are no frames contained in
//              the current window, this method only checks the ID of the
//              current window.
//
//--------------------------------------------------------------------------
HRESULT
CWindow::FindWindowByIndex(DWORD dwID, IUnknown ** ppunk)
{
    HRESULT      hr = E_FAIL;
    long         cFrames;
    CElement   * pElement;
    CFrameSite * pFrameSite;

    Assert(ppunk);

    *ppunk = NULL;

    // dwID = 0 in some cases when this method
    // is called by shdocvw. Return immediately,
    // if that is the case.
    //
    if (!dwID)
        goto Cleanup;

    if (dwID == _dwWindowID)
    {
        *ppunk = DYNCAST(IHTMLWindow2, this);
        AddRef();

        return S_OK;
    }
    else
    {
        // Do not set hr to the return value of any of these method
        // calls except FindWindowByIndex. The return value from
        // this method must only reflect whether or not the window was found.
        //
        cFrames = GetFramesCollectionLength();

        for (long i = 0; i < cFrames; i++)
        {
            if (THR(_pMarkup->CollectionCache()->GetIntoAry(CMarkup::FRAMES_COLLECTION, i, &pElement)))
                goto Cleanup;

            Assert(pElement);

            pFrameSite = DYNCAST(CFrameSite, pElement);

            if (pFrameSite->_pWindow)
            {
                hr = THR(pFrameSite->_pWindow->Window()->FindWindowByIndex(dwID, ppunk));
            }

            // Found it!!
            if (S_OK == hr)
                goto Cleanup;
        }
    }

Cleanup:
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Method    : CWindow::GetWindowData
//
//  Interface : ITravelLogClient
//
//  Synopsis  : Returns a WINDOWDATA structure containing pertinent
//              window information needed for the travel log..
//
//--------------------------------------------------------------------------

HRESULT
CWindow::GetWindowData(LPWINDOWDATA pWinData)
{
    HRESULT hr = S_OK;
    ULARGE_INTEGER cb;
    LARGE_INTEGER  liZero = {0, 0};

    Assert(_windowData.lpszUrl);
    Assert(_windowData.lpszTitle);
    Assert(_windowData.pStream);

    if (   !_windowData.lpszUrl
        || !_windowData.lpszTitle
        || !_windowData.pStream)
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    pWinData->dwWindowID = _windowData.dwWindowID;
    pWinData->uiCP       = _windowData.uiCP;
    pWinData->pidl       = NULL;

    TaskReplaceString(_windowData.lpszUrl,   &pWinData->lpszUrl);
    TaskReplaceString(_windowData.lpszTitle, &pWinData->lpszTitle);

    TaskReplaceString(_windowData.lpszUrlLocation, &pWinData->lpszUrlLocation);

    if (!pWinData->pStream)
    {
        hr = CreateStreamOnHGlobal(NULL, FALSE, &pWinData->pStream);
        if (hr)
            goto Cleanup;
    }

    cb.LowPart = cb.HighPart = ULONG_MAX;

    Verify(!_windowData.pStream->Seek(liZero, STREAM_SEEK_SET, NULL));
    hr = _windowData.pStream->CopyTo(pWinData->pStream, cb, NULL, NULL);

Cleanup:
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Method    : CWindow::LoadHistoryPosition
//
//  Interface : ITravelLogClient
//
//  Synopsis  : Sets the Url location and position cookie. This is used
//              during a history navigation in a frame that involves a
//              local anchor.
//
//--------------------------------------------------------------------------

HRESULT
CWindow::LoadHistoryPosition(LPOLESTR pszUrlLocation, DWORD dwCookie)
{
    Assert(_pMarkup);

    HRESULT hr      = E_FAIL;
    CDoc  * pDoc    = Doc();
    BOOL    fCancel = FALSE;
    LPCTSTR pszUrl  = CMarkup::GetUrl(_pMarkup);
    DWORD   dwPositionCookie = 0;
    COmWindowProxy * pWindowPrxy = _pMarkup->Window();

    // The window data must be updated before navigating
    // because the window can actually change and the
    // window stream will be incorrect. The travel log
    // is only updated if the navigation is successful.
    // Note that this window data is the current window
    // because the travel entry will contain the stream
    // for this window.
    //
    Markup()->GetPositionCookie(&dwPositionCookie);
    UpdateWindowData(dwPositionCookie);

    if (pWindowPrxy && !IsPrimaryWindow())
    {
        pWindowPrxy->Window()->_fNavFrameCreation = FALSE;

        pDoc->_webOCEvents.BeforeNavigate2(pWindowPrxy,
                                           &fCancel,
                                           pszUrl,
                                           pszUrlLocation,
                                           _cstrName,
                                           NULL,
                                           0,
                                           NULL,
                                           TRUE);

        if (!fCancel)
        {
            hr = SetPositionCookie(dwCookie);
            if (hr)
                goto Cleanup;
        }

        Doc()->UpdateTravelLog(this,
                               TRUE, /* fIsLocalAnchor */
                               FALSE /* fAddEntry */);

        CMarkup::SetUrlLocation(_pMarkup, pszUrlLocation);

        pDoc->_webOCEvents.NavigateComplete2(pWindowPrxy);
        pDoc->_webOCEvents.DocumentComplete(pWindowPrxy, pszUrl, pszUrlLocation);
    }

Cleanup:
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Method    : CWindow::UpdateWindowData
//
//  Synopsis  : Updates the data associated with the current data.
//
//--------------------------------------------------------------------------

void
CWindow::UpdateWindowData(DWORD dwPositionCookie)
{
    HRESULT hr;

    ClearWindowData();

    hr = GetUrl(&_windowData.lpszUrl);
    if (hr)
    {
        goto Cleanup;
    }

    GetUrlLocation(&_windowData.lpszUrlLocation);

    Assert(_windowData.lpszUrl);
    Assert(*_windowData.lpszUrl);

    _windowData.dwWindowID = GetWindowIndex();
    _windowData.uiCP       = _pMarkup->GetURLCodePage();

    GetTitle(&_windowData.lpszTitle);

    Assert(_windowData.lpszTitle);

    _dwPositionCookie = dwPositionCookie;

    hr = CreateStreamOnHGlobal(NULL, TRUE, &_windowData.pStream);
    
    if (FAILED(hr))
        _windowData.pStream = NULL;

    Assert(S_OK == hr || E_OUTOFMEMORY == hr);

    if (!hr)
    {
        //
        // Only save user data in history if this is not a Https and the advanced option
        // settings allows it
        //

        DWORD   dwOptions =     GetUrlScheme(_windowData.lpszUrl) != URL_SCHEME_HTTPS
                            || !Doc()->_pOptionSettings->fDisableCachingOfSSLPages
                            ?   SAVEHIST_INPUT : 0;

        IGNORE_HR(_pMarkup->SaveHistoryInternal(_windowData.pStream, dwOptions));
    }

Cleanup:
    return;
}

//+-------------------------------------------------------------------------
//
//  Method    : CWindow::ClearWindowData
//
//  Synopsis  : Clears the window data.
//
//--------------------------------------------------------------------------

void
CWindow::ClearWindowData()
{
    Assert(_windowData.lpszUrl || (!_windowData.lpszTitle && !_windowData.pStream));

    if (!_windowData.lpszUrl)  // Already cleared
        return;

    _windowData.dwWindowID = _windowData.uiCP = 0;
    _windowData.pidl = NULL;

    CoTaskMemFree(_windowData.lpszUrl);
    _windowData.lpszUrl = NULL;

    CoTaskMemFree(_windowData.lpszUrlLocation);
    _windowData.lpszUrlLocation = NULL;

    CoTaskMemFree(_windowData.lpszTitle);
    _windowData.lpszTitle = NULL;

    ClearInterface(&_windowData.pStream);
}

//+---------------------------------------------------------------
//
//  Member:     CWindow::ClearCachedDialogs
//
//  Synopsis:
//
//---------------------------------------------------------------
void
CWindow::ClearCachedDialogs()
{
    HWND hwndDlg = NULL;
    int i = 0;

    for (i=0; i < _aryActiveModeless.Size(); i++ )
    {
        hwndDlg = _aryActiveModeless[i];
        if (hwndDlg && !!IsWindow(hwndDlg))
        {
            PostMessage(hwndDlg, WM_CLOSE, 0, 0);
        }
    }
    _aryActiveModeless.DeleteAll();
}

//+-------------------------------------------------------------------------
//
//  Method    : CWindow::GetWindowIndex
//
//  Synopsis  : Returns the index of the current window.
//
//--------------------------------------------------------------------------
DWORD
CWindow::GetWindowIndex()
{
    //  the first time we request the index, we init it.
    if (!_dwWindowID)
    {
        Assert(_pMarkup);

        if (_pMarkup->IsPrimaryMarkup())
        {
            _dwWindowID = WID_TOPWINDOW;
        }
        else do
        {
            _dwWindowID = CreateRandomNum();

        } while (!_dwWindowID || _dwWindowID == WID_TOPWINDOW || WID_TOPBROWSER == _dwWindowID);
    }

    TraceTag((tagOmWindow, "CWindow::GetWindowIndex - ID: 0x%x", _dwWindowID));

    return _dwWindowID;
}

//+-------------------------------------------------------------------------
//
//  Method    : CWindow::GetUrl
//
//  Synopsis  : Returns the URL of the current window.
//
//--------------------------------------------------------------------------

HRESULT
CWindow::GetUrl(LPOLESTR * lpszUrl) const
{
    Assert(lpszUrl);
    Assert(_pMarkup);

    if (_pMarkup->HasUrl())
    {
        TaskReplaceString(CMarkup::GetUrl(_pMarkup), lpszUrl);

        Assert(*lpszUrl);
        TraceTag((tagOmWindow, "CWindow::GetUrl - URL: %ws", *lpszUrl));
    }

    return *lpszUrl ? S_OK : E_FAIL;
}

//+-------------------------------------------------------------------------
//
//  Method    : CWindow::GetUrlLocation
//
//  Synopsis  : Returns Url location associated with the current window.
//
//--------------------------------------------------------------------------

void
CWindow::GetUrlLocation(LPOLESTR * lpszUrlLocation) const
{
    Assert(lpszUrlLocation);
    Assert(_pMarkup);
    Assert(_pMarkup->HasWindowPending());

    LPCTSTR pszUrlLoc = CMarkup::GetUrlLocation(_pMarkup->GetWindowPending()->Markup());

    if (pszUrlLoc && *pszUrlLoc)
    {
        TaskReplaceString(pszUrlLoc, lpszUrlLocation);

        Assert(*lpszUrlLocation);
        TraceTag((tagOmWindow, "CWindow::GetUrlLocation - UrlLocation: %ws", *lpszUrlLocation));
    }
}

//+-------------------------------------------------------------------------
//
//  Method    : CWindow::GetTitle
//
//  Synopsis  : Returns the title of the current window.
//
//--------------------------------------------------------------------------
HRESULT
CWindow::GetTitle(LPOLESTR * lpszTitle)
{
    Assert(_pMarkup);
    Assert(lpszTitle);

    HRESULT hr;
    CTitleElement * pTitleElement = _pMarkup->GetTitleElement();
    TCHAR         * pchTitle      = pTitleElement ? pTitleElement->GetTitle() : NULL;

    *lpszTitle = NULL;

    if (pTitleElement && pchTitle)
        TaskAllocString(pchTitle, lpszTitle);

    // No title was specified in the document
    if (!*lpszTitle)
    {
        const TCHAR * pchUrl = CMarkup::GetUrl(_pMarkup);

        if (pchUrl && GetUrlScheme(pchUrl) == URL_SCHEME_FILE)
        {
            TCHAR achFile[pdlUrlLen];
            ULONG cchFile = ARRAY_SIZE(achFile);

            hr = THR(PathCreateFromUrl(pchUrl, achFile, &cchFile, 0));
            if (hr)
                goto Cleanup;

            PathStripPath(achFile);

            TaskAllocString(achFile, lpszTitle);
        }
        else if (pchUrl && !(_pMarkup && _pMarkup->_fDesignMode))
        {
            TCHAR achUrl[pdlUrlLen + sizeof(DWORD)/sizeof(TCHAR)];
            DWORD cchUrl;

            // need to unescape the url when setting title

            if (S_OK == CoInternetParseUrl(pchUrl, PARSE_ENCODE, 0,
                                           achUrl + sizeof(DWORD) / sizeof(TCHAR),
                                           ARRAY_SIZE(achUrl) - sizeof(DWORD) / sizeof(TCHAR),
                                           &cchUrl, 0))
            {
                TaskAllocString(achUrl + sizeof(DWORD) / sizeof(TCHAR), lpszTitle);
            }
            else
            {
                TaskAllocString(pchUrl, lpszTitle);
            }
        }
        else
        {
            TCHAR szBuf[1024];

            *((DWORD *)szBuf) = LoadString(GetResourceHInst(),
                                           IDS_NULL_TITLE,
                                           szBuf + sizeof(DWORD) / sizeof(TCHAR),
                                           ARRAY_SIZE(szBuf) - sizeof(DWORD) / sizeof(TCHAR));
            Assert(*((DWORD *)szBuf) != 0);
            TaskAllocString(szBuf + sizeof(DWORD) / sizeof(TCHAR), lpszTitle);
        }
    }

    TraceTag((tagOmWindow, "CWindow::GetTitle - Title: %ws", *lpszTitle));

Cleanup:
    Assert(*lpszTitle);
    return *lpszTitle ? S_OK : E_FAIL;
}

//+-------------------------------------------------------------------------
//
//  Method    : CWindow::FindWindowByName
//
//  Synopsis  : Returns the window with the given name. This method calls
//              GetTargetWindow to find the window with the name
//              specified in pszTargetName. If the window is found,
//              this method attempts to retrieve the COmWindowProxy of
//              the window so that better performance may be achieved.
//
//  Input     : pszTargetName      - the name of the window to locate.
//  Output    : ppTargOmWindowPrxy - the COmWindowProxy of the window
//              ppTargHTMLWindow   - the IHTMLWindow2 of the window.
//                                   If the COmWindowProxy could be
//                                   retrieved, this parameter will
//                                   be null upon return.
//
//  Returns   : S_OK if found, OLE error code otherwise.
//
//--------------------------------------------------------------------------

HRESULT
CWindow::FindWindowByName(LPCOLESTR         pszTargetName,
                          COmWindowProxy ** ppTargOmWindowPrxy,
                          IHTMLWindow2   ** ppTargHTMLWindow,
                          IWebBrowser2   ** ppTopWebOC /* = NULL */)
{
    HRESULT        hr = E_FAIL;
    BOOL           fIsCurProcess;
    TARGET_TYPE    eTargetType;
    IHTMLWindow2 * pHTMLWindow = NULL;
    CWindow      * pTargetWindow;

    Assert(pszTargetName);
    Assert(*pszTargetName);
    Assert(ppTargHTMLWindow);

    *ppTargHTMLWindow = NULL;

    if (ppTargOmWindowPrxy)
        *ppTargOmWindowPrxy = NULL;

    eTargetType = GetTargetType(pszTargetName);

    if (eTargetType != TARGET_FRAMENAME)
    {
        hr = GetWindowByType(eTargetType, this, &pHTMLWindow, ppTopWebOC);

        // If *ppTopWebOC is set, there was a
        // problem retrieving the target window.
        //
        if (ppTopWebOC && *ppTopWebOC)
        {
            goto Cleanup;
        }
    }

    if (pHTMLWindow)
    {
        hr = pHTMLWindow->QueryInterface(CLSID_HTMLWindow2, (void**)&pTargetWindow);

        // If the QI fails, pHTMLWindow is a COmWindowProxy, which
        // means the target window was on another thread. Therefore,
        // we must use the proxy window itself. If the QI
        // succeeds, the target window is on the current thread so
        // we can safely use the CWindow object of the target window.
        //
        if (hr)
        {
            *ppTargHTMLWindow = pHTMLWindow;
            pHTMLWindow = NULL; // Don't release.
        }
        else if (ppTargOmWindowPrxy)
        {
            *ppTargOmWindowPrxy = pTargetWindow->_pMarkup->Window();
        }

        goto Cleanup;
    }

    hr = GetTargetWindow(this, pszTargetName, &fIsCurProcess, ppTargHTMLWindow);

    if (!hr)
    {
        Assert(*ppTargHTMLWindow);

        // If the window was found in the current process, get a ptr
        // to the window proxy. That way DoNavigate can
        // be called in FollowHyperlink instead of window.navigate.
        // If the window proxy is retrieved, release ppTargHTMLWindow
        // so that it won't be used.
        //
        if (fIsCurProcess && ppTargOmWindowPrxy)
        {
            if (S_OK == (*ppTargHTMLWindow)->QueryInterface(CLSID_HTMLWindowProxy,
                                                            (void**)ppTargOmWindowPrxy))
            {
                ClearInterface(ppTargHTMLWindow);
            }
            else
            {
                CWindow * pWindow;

                if (S_OK == (*ppTargHTMLWindow)->QueryInterface(CLSID_HTMLWindow2, (void **) &pWindow))
                {
                    *ppTargOmWindowPrxy = pWindow->_pMarkup->Window();
                    ClearInterface(ppTargHTMLWindow);
                }
            }
        }
    }

Cleanup:
    ReleaseInterface(pHTMLWindow);

    RRETURN1(hr, S_FALSE);
}

//+-------------------------------------------------------------------------
//
//  Method    : CWindow::GetFramesCollectionLength
//
//  Synopsis  : Ensures that the collection cache exists and returns the
//              length of the frames collection.
//
//  Returns   : The length of the collection cache.
//
//--------------------------------------------------------------------------

long
CWindow::GetFramesCollectionLength() const
{
    long cFrames = 0;

    Assert(_pMarkup);

    if (THR(_pMarkup->EnsureCollectionCache(CMarkup::FRAMES_COLLECTION)))
        goto Cleanup;

    Assert(_pMarkup->CollectionCache());

    _pMarkup->CollectionCache()->GetLength(CMarkup::FRAMES_COLLECTION, &cFrames);

Cleanup:
    return cFrames;
}

//+------------------------------------------------------------------------
//
//  Member   : CWindow::GetClassID
//
//  Synopsis : Per IPersist
//
//-------------------------------------------------------------------------

STDMETHODIMP
CWindow::GetClassID(CLSID * pclsid)
{
    if (!pclsid)
    {
        RRETURN(E_INVALIDARG);
    }

    *pclsid = CLSID_HTMLWindow2;
    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Member   : CWindow::GetPositionCookie
//
//  Synopsis : Per IPersistHistory
//
//-------------------------------------------------------------------------

HRESULT
CWindow::GetPositionCookie(DWORD * pdwCookie)
{
    if (_pMarkup)
    {
        if (NO_POSITION_COOKIE != _dwPositionCookie)
        {
            *pdwCookie = _dwPositionCookie;
            _dwPositionCookie = NO_POSITION_COOKIE;

            return S_OK;
        }

        RRETURN (_pMarkup->GetPositionCookie(pdwCookie));
    }
    else
    {
        *pdwCookie = 0;
        return S_OK;
    }
}

//+------------------------------------------------------------------------
//
//  Member   : CWindow::SetPositionCookie
//
//  Synopsis : Per IPersistHistory
//
//-------------------------------------------------------------------------

HRESULT
CWindow::SetPositionCookie(DWORD dwCookie)
{
    if (_pMarkup)
    {
        IGNORE_HR(_pMarkup->SetPositionCookie(dwCookie));
    }

    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Member   : CWindow::SaveHistory
//
//  Synopsis : Recursively saves the history on all frame windows.
//
//-------------------------------------------------------------------------

HRESULT
CWindow::SaveHistory(IStream * pStream)
{
    Assert(_pMarkup);
    Assert(pStream);

    ULARGE_INTEGER cb;
    LARGE_INTEGER  liZero = {0, 0};

    if (_windowData.pStream)
    {
        cb.LowPart = cb.HighPart = ULONG_MAX;

        Verify(!_windowData.pStream->Seek(liZero, STREAM_SEEK_SET, NULL));
        THR(_windowData.pStream->CopyTo(pStream, cb, NULL, NULL));

        return S_OK;
    }

    RRETURN(_pMarkup->SaveHistoryInternal(pStream, SAVEHIST_INPUT));
}

//+---------------------------------------------------------------------------
//
//  Member:     GetURLFromIStreamHelper
//
//  Synopsis: Read through the history stream - to find the URL
//            all other history codes are skipped over.
//
//
//            Note that changes to history in CMarkup::LoadHistoryHelper must be
//            propagated here.
//
//----------------------------------------------------------------------------


HRESULT
CWindow::GetURLFromIStreamHelper(IStream  * pStream,
                                 TCHAR   ** ppURL)
{
    HRESULT         hr = S_OK;
    DWORD historyCode;

    CDataStream ds(pStream);

    for (;;)
    {
        hr = THR(ds.LoadDword((DWORD*)&historyCode));
        if (hr)
            goto Cleanup;

        switch (historyCode)
        {
        case HISTORY_PCHURL:
            hr = THR(ds.LoadString( ppURL ));

            goto Cleanup; // we've got the string - so bail.
            break;

        //
        // Streams
        //
        case HISTORY_STMDIRTY:
        case HISTORY_STMREFRESH:
        case HISTORY_POSTDATA:
        case HISTORY_STMHISTORY:

            hr = THR(ds.SeekSubstream());
            if (hr)
                goto Cleanup;

            break;

        //
        // Strings
        //
        case HISTORY_PCHFILENAME:
        case HISTORY_PCHURLORIGINAL:
        case HISTORY_PCHURLLOCATION:
        case HISTORY_PCHDOCREFERER:
        case HISTORY_PCHSUBREFERER:
        case HISTORY_BOOKMARKNAME:
        case HISTORY_USERDATA:
        case HISTORY_CREATORURL:

            hr = THR(ds.SeekString());
            if (hr)
                goto Cleanup;
            break;

        //
        // Dwords
        //
        case HISTORY_NAVIGATED:
        case HISTORY_SCROLLPOS:
        case HISTORY_HREFCODEPAGE:
        case HISTORY_CODEPAGE:
        case HISTORY_FONTVERSION:
        case HISTORY_WINDOWID:

            hr = THR(ds.SeekDword());
            if (hr)
                goto Cleanup;
            break;

        //
        // No data
        //
        case HISTORY_BINDONAPT:
        case HISTORY_NONHTMLMIMETYPE:

            break;

        //
        // Specials
        //
        case HISTORY_PMKNAME:
            hr = THR(ds.SeekDword());
            if (hr)
                goto Cleanup;

            hr = THR(ds.SeekData( sizeof(CLSID)));
            if (hr)
                goto Cleanup;

            hr = THR(ds.SeekSubstream());
            if (hr)
                goto Cleanup;

            break;

        case HISTORY_FTLASTMOD:
            hr = THR(ds.SeekData( sizeof(FILETIME)));
            if (hr)
                goto Cleanup;
            break;

        case HISTORY_CURRENTSITE:
            {
                hr = THR(ds.SeekDword());
                if (hr)
                    goto Cleanup;
                hr = THR(ds.SeekDword());
                if (hr)
                    goto Cleanup;
                hr = THR(ds.SeekDword());
                if (hr)
                    goto Cleanup;
            }
            break;

        case HISTORY_REQUESTHEADERS:
        {
            DWORD dwSize;

            hr = THR(ds.LoadDword(& dwSize ));
            if (hr)
                goto Cleanup;

            hr = THR(ds.SeekData( dwSize ));
            if (hr)
                goto Cleanup;
            break;
        }


        case HISTORY_DOCDIRECTION:
            hr = THR(ds.SeekData(sizeof(WORD)));
            if (hr)
                goto Cleanup;
            break;

        case HISTORY_END:
            goto Cleanup;
#if DBG==1
        default:
            AssertSz( FALSE, "Unknown code found in history!" );
            break;
#endif // DBG
        }
    }

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CheckIfOffline
//
//  Synopsis: Check if the URL in a given Stream is offline. We do this by
//            getting the URL for a stream, and then
//            execing a command into shdocvw.
//
//----------------------------------------------------------------------------


HRESULT
CWindow::CheckIfOffline( IStream* pIStream )
{
    HRESULT hr;
    TCHAR*  pchURL = NULL ;
    CVariant varURL ;
    IStream*         pIStreamClone = NULL;
    CVariant          varContinue;

    if (!Doc())
    {
        AssertSz(0,"Possible Async Problem Causing Watson Crashes");
        RRETURN(E_FAIL);
    }

    hr = THR( pIStream->Clone( & pIStreamClone ));
    if ( FAILED( hr ))
        goto Cleanup;

    hr = THR( GetURLFromIStreamHelper( pIStreamClone, & pchURL ));
    if ( FAILED(hr))
        goto Cleanup;

    V_VT( & varContinue ) = VT_BOOL;
    V_VT( &varURL ) = VT_BSTR;
    V_BSTR( &varURL ) = ::SysAllocString( pchURL );

    // Check if the browser is offline. If so, only
    // navigate if the page is in the cache or if
    // the user has chosen to connect to the Web.
    //

    V_BOOL(&varContinue) = VARIANT_TRUE; // init to variant true - incase we aren't hosted by shdocvw.
    
    Assert(Doc()->_pClientSite);
    IGNORE_HR(CTExec(Doc()->_pClientSite, &CGID_ShellDocView,
                     SHDVID_CHECKINCACHEIFOFFLINE, 0, &varURL, & varContinue));

    if (VARIANT_FALSE == V_BOOL(&varContinue))  // Stay Offline
    {
        hr = E_FAIL;
        goto Cleanup;
    }
    else
    {
        hr = S_OK;
    }

Cleanup:
    MemFree( pchURL );
    ReleaseInterface( pIStreamClone );

    RRETURN1( hr , S_FALSE );
}

HRESULT
CDocument::GetXMLExpando(IDispatch** ppIDispXML, IDispatch** ppIDispXSL)
{
    CAttrValue* pAV;
    DISPID dispid;

    if ( ppIDispXML &&
         SUCCEEDED( GetExpandoDISPID(_T("XMLDocument"), & dispid , fdexNameCaseSensitive)))
    {
        AAINDEX aaIdx = AA_IDX_UNKNOWN;
    
        pAV = (*this->GetAttrArray())->Find( dispid, 
                                    CAttrValue::AA_Expando,
                                    & aaIdx);
        if (pAV)
        {
            *ppIDispXML = pAV->GetDispatch();
            if (*ppIDispXML)
                (*ppIDispXML)->AddRef();
        }
    }  

    if ( ppIDispXSL &&
         SUCCEEDED( GetExpandoDISPID(_T("XSLDocument"), & dispid , fdexNameCaseSensitive)))
    {
        AAINDEX aaIdx = AA_IDX_UNKNOWN;
    
        pAV = (*this->GetAttrArray())->Find( dispid, 
                                    CAttrValue::AA_Expando,
                                    & aaIdx);
        if (pAV)
        {
            *ppIDispXSL = pAV->GetDispatch();
            if (*ppIDispXSL)
                (*ppIDispXSL)->AddRef();
        }
    } 

    return S_OK;
}

HRESULT
CDocument::SetXMLExpando(IDispatch* pIDispXML, IDispatch* pIDispXSL)
{
    HRESULT hr = S_OK ;
    DISPID dispid, putid;
    DISPPARAMS dispparams = {NULL, NULL, 0, 0};
    VARIANT var;
    
    putid = DISPID_PROPERTYPUT;
    var.vt = VT_DISPATCH;

    dispparams.rgvarg = &var;
    dispparams.rgdispidNamedArgs = &putid;
    dispparams.cArgs = 1;
    dispparams.cNamedArgs = 1;

    if ( pIDispXML )
    {
        var.pdispVal = pIDispXML;
        GetExpandoDISPID(_T("XMLDocument"), & dispid , fdexNameEnsure);

        hr = THR( InvokeEx(dispid, LOCALE_USER_DEFAULT, DISPATCH_PROPERTYPUT, &dispparams, NULL, NULL, NULL));
        if ( FAILED(hr) )
            goto Cleanup;
    }

    if ( pIDispXSL )
    {
        var.pdispVal = pIDispXSL;
        GetExpandoDISPID(_T("XSLDocument"), & dispid , fdexNameEnsure);

        hr = THR( InvokeEx(dispid, LOCALE_USER_DEFAULT, DISPATCH_PROPERTYPUT, &dispparams, NULL, NULL, NULL));
        if ( FAILED(hr) )
            goto Cleanup;
    }

Cleanup:

    RRETURN( hr) ;
}

//+------------------------------------------------------------------------
//
//  Member   : CWindow::LoadHistory
//
//  Synopsis : Per IPersistHistory.
//
//-------------------------------------------------------------------------

HRESULT
CWindow::LoadHistory(IStream * pStream, IBindCtx * pbc)
{
    Assert(pStream);
    Assert(_pMarkup);

    HRESULT hr;
    CMarkup * pMarkupNew = NULL;
    CDoc    * pDoc = Doc();
    COmWindowProxy * pOmWindow = _pMarkup->Window();

    Assert(pOmWindow);

    if (!pOmWindow->Fire_onbeforeunload())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    //
    // Check to see if this stream is offline. If it is then we don't load
    //
    hr = THR(CheckIfOffline(pStream));
    if (FAILED(hr))
        goto Cleanup;

    // freeze the old markup and nuke any pending readystate changes
    _pMarkup->ExecStop(FALSE, FALSE);

    ClearMetaRefresh();

    hr = pDoc->CreateMarkup(&pMarkupNew, NULL, NULL, FALSE, pOmWindow);
    if (hr)
        goto Cleanup;

    // Privacy list handling for history navigations
    // If this is a top level navigation, then 
    // 1. If it is user initiated, reset the list ELSE
    // 2. Add a blank record to demarcate the set of urls pertaining to this new top level url
    if (_pMarkup->IsPrimaryMarkup() && !pDoc->_fViewLinkedInWebOC)
    {
        if (pDoc->_cScriptNestingTotal)
            THR(pDoc->AddToPrivacyList(_T(""), NULL, PRIVACY_URLISTOPLEVEL));
        else
            THR(pDoc->ResetPrivacyList());
    }

    hr = THR(pMarkupNew->LoadHistoryInternal(pStream, pbc, BINDF_FWD_BACK, NULL, NULL, NULL, 0));
    if (hr)
        goto Cleanup;

    UpdateWindowData(NO_POSITION_COOKIE);

    // The setting of this flag MUST be after LoadHistoryInternal.
    // This is basically so that navigation clicks won't occur
    // when they shouldn't. If this flag needs to be moved
    // before LoadHistoryInternal, you must create a new flag on
    // the markup and set it to TRUE before calling
    // LoadHistoryInternal in DoNavigate.
    //
    if (_pMarkupPending)
    {
        _pMarkupPending->_fLoadingHistory = TRUE;
    }

Cleanup:
    if (pMarkupNew)
    {
        pMarkupNew->Release();
    }

    RRETURN(hr);
}

//+-------------------------------------------------------------------------
//
//  Method:     CWindow::GetTypeInfoCount
//
//  Synopsis:   Per IDispatch
//
//--------------------------------------------------------------------------

STDMETHODIMP
CWindow::GetTypeInfoCount(UINT FAR* pctinfo)
{
    TraceTag((tagOmWindow, "GetTypeInfoCount"));

    RRETURN(super::GetTypeInfoCount(pctinfo));
}


//+-------------------------------------------------------------------------
//
//  Method:     CWindow::GetTypeInfo
//
//  Synopsis:   Per IDispatch
//
//--------------------------------------------------------------------------

STDMETHODIMP
CWindow::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo ** pptinfo)
{
    TraceTag((tagOmWindow, "GetTypeInfo"));

    RRETURN(super::GetTypeInfo(itinfo, lcid, pptinfo));
}


//+-------------------------------------------------------------------------
//
//  Method:     CWindow::GetIDsOfNames
//
//  Synopsis:   Per IDispatch
//
//--------------------------------------------------------------------------

STDMETHODIMP
CWindow::GetIDsOfNames(
    REFIID                riid,
    LPOLESTR *            rgszNames,
    UINT                  cNames,
    LCID                  lcid,
    DISPID FAR*           rgdispid)
{
    HRESULT     hr;

    hr = THR_NOTRACE(GetDispID(rgszNames[0], fdexFromGetIdsOfNames, rgdispid));

    // If we get no error but a DISPID_UNKNOWN then we'll want to return error
    // this mechanism is used for JScript to return a null for undefine name
    // sort of a passive expando.
    if (!hr && rgdispid[0] == DISPID_UNKNOWN)
    {
        hr = DISP_E_UNKNOWNNAME;
    }

    RRETURN(hr);
}


HRESULT
CWindow::Invoke(DISPID dispid,
                   REFIID riid,
                   LCID lcid,
                   WORD wFlags,
                   DISPPARAMS *pdispparams,
                   VARIANT *pvarResult,
                   EXCEPINFO *pexcepinfo,
                   UINT *puArgErr)
{
    return InvokeEx(dispid,
                    lcid,
                    wFlags,
                    pdispparams,
                    pvarResult,
                    pexcepinfo,
                    NULL);
}

//+-------------------------------------------------------------------------
//
//  Method:     CWindow::InvokeEx
//
//  Synopsis:   Per IDispatch
//
//--------------------------------------------------------------------------
STDMETHODIMP
CWindow::InvokeEx(DISPID       dispidMember,
                  LCID         lcid,
                  WORD         wFlags,
                  DISPPARAMS * pdispparams,
                  VARIANT    * pvarResult,
                  EXCEPINFO  * pexcepinfo,
                  IServiceProvider * pSrvProvider)
{
    TraceTag((tagOmWindow, "Invoke dispid=0x%x", dispidMember));

    HRESULT                 hr;
    RETCOLLECT_KIND         collectionCreation;
    IDispatch *             pDisp = NULL;
    IDispatchEx *           pDispEx = NULL;
    CCollectionCache *      pCollectionCache;
    CScriptCollection *     pScriptCollection;
    CMarkupScriptContext *  pMarkupScriptContext;


    CDoc               *pDoc = Doc();
    CStr                cstrSecurityCtx;
    LPCTSTR             pchCreatorUrl = NULL;

    // TODO:  ***TLL*** Should be removed when IActiveScript is fixed to
    //        refcount the script site so we don't have the addref the
    //        _pScriptCollection.
    CDoc::CLock Lock(pDoc);

#if DBG == 1
    // Debug verification of caller security
    // TAG DISABLED BY DEFAULT (1) for perf reasons (2) to pass BVT on initial checkin
    if (IsTagEnabled(tagSecurityProxyCheck))
    {
        // Assert the call is coming from COmWindowProxy or other secure caller (e.g. AccessAllowed)
        // No one should have IDispatch to CWindow - that would be a major security hole!
        static const VERIFYSTACK_CALLERINFO aCallers[] =
        {
            { "mshtml",     "COmWindowProxy::InvokeEx", 1, 4,   CALLER_GOOD },
            { "mshtml",     "COmWindowProxy::Invoke",   1, 4,   CALLER_GOOD },
            { "mshtml",     "GetSIDOfDispatch",         1, 10,  CALLER_GOOD },
            { "jscript",    "",                         1, 10,  CALLER_BAD_IF_FIRST },
            { "vbscript",   "",                         1, 10,  CALLER_BAD_IF_FIRST },
        };
        
        static const int cMaxStack = 32; // max stack depth to analyze
        VERIFYSTACK_SYMBOLINFO asi[cMaxStack];
        int iBadCaller;
        
        static const int cMaxIgnore = 32; // max cases to ignore
        static VERIFYSTACK_SYMBOLINFO asiIgnore[cMaxIgnore];
        static int cIgnored = 0; 

        // DEBUG FEATURE: deny access if verification failed and SHIFT pressed - shows the problem in script debugger
        if (S_OK != VerifyCallStack("mshtml", aCallers, ARRAY_SIZE(aCallers), asi, sizeof(asi), &iBadCaller))
        {
            Assert(0 <= iBadCaller && iBadCaller < cMaxStack);

            // Somebody calls DISPID_SECURITYCTX directly on CWindow (from oleaut32)
            if (!IsTagEnabled(tagSecurityProxyCheckMore) 
                && (
                        dispidMember ==  DISPID_SECURITYCTX     // security context 
                    ||  dispidMember ==  DISPID_SECURITYDOMAIN  // security domain 
                   )   
               )
            {
                goto IgnoreThisCaller;
            }
            
             
            // look in ignore list - no assert if it is there
            for (int iIgnore = 0; iIgnore < cIgnored; iIgnore++)
            {
                if (0 == memcmp(&asiIgnore[iIgnore], &asi[iBadCaller], sizeof(VERIFYSTACK_SYMBOLINFO)))
                    goto IgnoreThisCaller;
            }
            
            AssertSz(FALSE, "CWindow: Wrong call stack (shift+Ignore to debug script, alt+click to ignore this caller)");

            if (GetAsyncKeyState(VK_SHIFT) & 0x8000)
            {
                // deny access to see the caller in script debugger
                hr = E_ACCESSDENIED;
                goto Cleanup;
            }

            if (GetAsyncKeyState(VK_MENU) & 0x8000)
            {
                // ignore this occurance
                // TRICKY - since we haven't found a good caller, which of unknown callers to ignore?
                //          the stack verifier has returned a "bad" index, which is 
                //          usually the first caller outside mshtml - we'll remember that one.
                if (cIgnored < cMaxIgnore)
                {
                    memcpy(&asiIgnore[cIgnored], &asi[iBadCaller], sizeof(VERIFYSTACK_SYMBOLINFO));
                    cIgnored++;
                }
            }
            
IgnoreThisCaller:
            ;
        }

        // If we are actually called from a proxy, assert it is not trusted
        if (_pProxyCaller)
        {
            IDebugWindowProxy *pIDebugProxy = NULL;
            if (S_OK == _pProxyCaller->QueryInterface(IID_IDebugWindowProxy, (void**)&pIDebugProxy))
            {
                BOOL fDenyAccess = FALSE;
                VARIANT_BOOL vbSecure = VB_FALSE;
                
                // check if we are called from secure proxy
                if (S_OK != pIDebugProxy->get_isSecureProxy(&vbSecure) || vbSecure != VB_TRUE)
                {
                    // oh no!!! It is not a secure proxy! 
                    // Look for known exceptions
                    if (
                            dispidMember >=  DISPID_OMWINDOWMETHODS // call from script engine
                        ||  dispidMember ==  DISPID_SECURITYCTX     // security context - called from AccessAllowed
                        ||  dispidMember ==  DISPID_SECURITYDOMAIN  // security domain - called from AccessAllowed
                       )
                    {
                        Assert(TRUE);   // benign call
                    }
                    else
                    {
                        AssertSz(FALSE, "CWindow::InvokeEx called from trusted proxy (shift+Ingore to debug script)");

                        // DEBUG FEATURE: deny access if verification failed and SHIFT pressed - shows the problem in script debugger
                        if (GetAsyncKeyState(VK_SHIFT) & 0x8000)
                        {
                            fDenyAccess = TRUE;
                        }
                    }
                }
                pIDebugProxy->Release();

                // Deny access when shift pressed
                if (fDenyAccess)
                {
                    hr = E_ACCESSDENIED;
                    goto Cleanup;
                }
            }
            else
                AssertSz(FALSE, "Failed to QI(IDebugWindowProxy) from proxy caller");
        }
    }
#endif

    //
    // Handle magic dispids which are used to serve up certain objects to the
    // browser:
    //

    switch(dispidMember)
    {
    case DISPID_BEFORENAVIGATE2:
    case DISPID_NAVIGATECOMPLETE2:
    case DISPID_DOWNLOADBEGIN:
    case DISPID_DOWNLOADCOMPLETE:
    case DISPID_TITLECHANGE:
    case DISPID_PROGRESSCHANGE:
    case DISPID_STATUSTEXTCHANGE:
        {
            // Fire ViewLinkedWebOC events at the frame level
            if (_punkViewLinkedWebOC)
            {
                _pFrameWebOC->InvokeEvent(dispidMember, DISPID_UNKNOWN, NULL, NULL, pdispparams);
            }

            break;
        }

    case DISPID_FILEDOWNLOAD:
        {
            Assert(pdispparams);
            Assert(pdispparams->cArgs == 2);

            // the second parameter is an indicator of a doc object being loaded
            Assert(V_VT(&(pdispparams->rgvarg[1])) == VT_BOOL);

            if (V_BOOL(&(pdispparams->rgvarg[1])) == VARIANT_TRUE)
            {
                _fFileDownload = FALSE;
            }
            else
            {
                _fFileDownload = TRUE;
            }

            // Fire DISPID_FILEDOWNLOAD events at the frame level
            if (_punkViewLinkedWebOC)
            {
                _pFrameWebOC->InvokeEvent(dispidMember, DISPID_UNKNOWN, NULL, NULL, pdispparams);
            }

            hr = S_OK;
            goto Cleanup;
        }

    case DISPID_DOCUMENTCOMPLETE:
        {
            if (_pMarkupPending)
            {
                if (_fFileDownload)
                {
                    // For file download, we must fire a DocumentComplete
                    // to match our BeforeNavigate2. Note: NavigateComplete2
                    // is not fired in this case for IE 5.0 compatibility.
                    //
                    pDoc->_webOCEvents.DocumentComplete(_pMarkupPending->GetWindowPending(),
                                                        CMarkup::GetUrl(_pMarkupPending),
                                                        CMarkup::GetUrlLocation(_pMarkupPending));

                    ReleaseMarkupPending(_pMarkupPending);
                }
                else
                {
                    _pMarkup->Window()->SwitchMarkup(_pMarkupPending,
                                                     TRUE,
                                                     COmWindowProxy::TLF_UPDATETRAVELLOG);
                }

            }

            _pMarkup->_fLoadingHistory = FALSE;

            _pMarkup->OnLoadStatus(LOADSTATUS_DONE);

            _fFileDownload = FALSE;

            // Fire DISPID_DOCUMENTCOMPLETE events at the frame level

            if (_punkViewLinkedWebOC)
            {
                _pFrameWebOC->InvokeEvent(dispidMember, DISPID_UNKNOWN, NULL, NULL, pdispparams);
            }

            hr = S_OK;
            goto Cleanup;
        }

    case DISPID_WINDOWOBJECT:
        //
        // Return a ptr to the real window object.
        //

        IHTMLWindow2 * pWindow;
        hr = THR(QueryInterface(IID_IHTMLWindow2, (void **) &pWindow));
        if (hr)
            goto Cleanup;

        V_VT(pvarResult) = VT_DISPATCH;
        V_DISPATCH(pvarResult) = pWindow;
        hr = S_OK;
        goto Cleanup;

    case DISPID_SECURITYCTX:
        TCHAR * pchBuf;
        TCHAR   achURL[pdlUrlLen];
        DWORD   dwSize;

        //
        // Return the url of the document and it's domain (if set)
        // in an array.
        //

        if (!pvarResult)
        {
            hr = E_POINTER;
            goto Cleanup;
        }

        V_VT(pvarResult) = VT_BSTR;

        pchCreatorUrl = _pMarkup->GetAAcreatorUrl();

        Assert(!!CMarkup::GetUrl(_pMarkup));

        // Do we have a File: protocol URL?
        hr = THR(CoInternetParseUrl(CMarkup::GetUrl(_pMarkup),
                                    PARSE_PATH_FROM_URL,
                                    0,
                                    achURL,
                                    ARRAY_SIZE(achURL),
                                    &dwSize,
                                    0));

        // hr == S_OK indicates that we do have a file: URL.
        if (!hr)
        {
            pchBuf = achURL;
        }
        else
        {
            pchBuf = (TCHAR *)CMarkup::GetUrl(_pMarkup);
        }

        //
        // If there is a creator window, then use its url as the domain url
        // If there is a creator it means that this is a special URL frame
        // or a window opened by a window.open call.
        //
        if (pchCreatorUrl && *pchCreatorUrl)
        {
            // Prepare a URL to give to the URLMON.
            hr = THR(WrapSpecialUrl(pchBuf,
                                    &cstrSecurityCtx,
                                    pchCreatorUrl,
                                    FALSE,
                                    FALSE));
        }
        else
        {
            cstrSecurityCtx.Set(pchBuf);
        }

        hr = THR(FormsAllocString(cstrSecurityCtx, &V_BSTR(pvarResult)));

        goto Cleanup;

    case DISPID_SECURITYDOMAIN:
        //
        // If set, return the domain property of the document.
        // Fail otherwise.
        //

        if (_pMarkup->Domain() && *(_pMarkup->Domain()))
        {
            if (!pvarResult)
            {
                hr = E_POINTER;
                goto Cleanup;
            }

            V_VT(pvarResult) = VT_BSTR;
            hr = THR(FormsAllocString(_pMarkup->Domain(), &V_BSTR(pvarResult)));
        }
        else
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }
        goto Cleanup;

    case DISPID_HISTORYOBJECT:
        if (!_pHistory)
        {
            _pHistory = new COmHistory(this);
            if (!_pHistory)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }
        }
        hr = THR(_pHistory->QueryInterface(IID_IDispatch, (void**)&pvarResult->punkVal));
        goto FinishVTAndReturn;

    case DISPID_LOCATIONOBJECT:
        if(!_pLocation)
        {
            _pLocation = new COmLocation(this);
            if (!_pLocation)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }
        }
        hr = THR(_pLocation->QueryInterface(IID_IDispatch, (void**)&pvarResult->punkVal));
        goto FinishVTAndReturn;

    case DISPID_NAVIGATOROBJECT:
        if(!_pNavigator)
        {
            _pNavigator = new COmNavigator(this);
            if (!_pNavigator)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }
        }

        hr = THR(_pNavigator->QueryInterface(IID_IDispatch, (void**)&pvarResult->punkVal));
        goto FinishVTAndReturn;

    default:
        break;

FinishVTAndReturn:
        if (hr)
            goto Cleanup;
        pvarResult->vt = VT_DISPATCH;
        goto Cleanup;   // successful termination.
    }

    hr = THR(_pMarkup->EnsureCollectionCache(CMarkup::FRAMES_COLLECTION));
    if (hr)
        goto Cleanup;

    pCollectionCache = _pMarkup->CollectionCache();
    if ( pCollectionCache->IsDISPIDInCollection ( CMarkup::FRAMES_COLLECTION, dispidMember ) )
    {
        if ( pCollectionCache->IsOrdinalCollectionMember (
            CMarkup::FRAMES_COLLECTION, dispidMember ) )
        {
            // Resolve ordinal access to Frames
            //
            // If this dispid is one that maps to the numerically indexed
            // items, then simply use the index value with our Item() mehtod.
            // This handles the frames[3] case.
            //

            hr = THR(_pMarkup->GetCWindow(dispidMember -
                pCollectionCache->GetOrdinalMemberMin ( CMarkup::FRAMES_COLLECTION ),
                (IHTMLWindow2**)&V_DISPATCH(pvarResult) ));

            if (!hr) // if successfull, nothing to do more
            {
                V_VT(pvarResult) = VT_DISPATCH;
                goto Cleanup;
            }
        }
        else
        {
            // Resolve named frame

            // dispid from FRAMES_COLLECTION GIN/GINEX
            CAtomTable *pAtomTable;
            LPCTSTR     pch = NULL;
            long        lOffset;
            BOOL        fCaseSensitive;

            lOffset = pCollectionCache->GetNamedMemberOffset(CMarkup::FRAMES_COLLECTION,
                                        dispidMember, &fCaseSensitive);

            pAtomTable = pCollectionCache->GetAtomTable(FALSE);
            if( !pAtomTable )
                goto Cleanup;

            hr = THR(pAtomTable->GetNameFromAtom(dispidMember - lOffset, &pch));

            if (!hr)
            {
                CElement *      pElem;
                IHTMLWindow2 *  pCWindow;
                CFrameSite *    pFrameSite;

                hr = pCollectionCache->GetIntoAry( CMarkup::FRAMES_COLLECTION,
                                            pch, FALSE, &pElem, 0, fCaseSensitive);

                // The FRAMES_COLLECTION is marked to always return the last matching name in
                // the returned pElement - rather than the default first match - For Nav compat.
                // GetIntoAry return S_FALSE if more than one item found - like Nav
                // though we ignore this
                if ( hr && hr != S_FALSE )
                    goto Cleanup;

                pFrameSite = DYNCAST (CFrameSite, pElem );

                hr = pFrameSite->GetCWindow( &pCWindow );
                if (!hr)
                {
                    V_VT(pvarResult) = VT_DISPATCH;
                    V_DISPATCH(pvarResult) = pCWindow;
                }
                goto Cleanup;
            }
            // else name not found in atom table, try the other routes
            // to resolve the Dispid.
        }
    }

    // If the DISPID came from the dynamic typelib collection, adjust the DISPID into
    // the WINDOW_COLLECTION, and record that the Invoke should only return a single item
    // Not a collection

    if ( dispidMember >= DISPID_COLLECTION_MIN &&
        dispidMember < pCollectionCache->GetMinDISPID( CMarkup::WINDOW_COLLECTION ) )
    {
        // DISPID Invoke from the dynamic typelib collection
        // Adjust it into the WINDOW collection
        dispidMember = dispidMember - DISPID_COLLECTION_MIN +
            pCollectionCache->GetMinDISPID( CMarkup::WINDOW_COLLECTION );
        // VBScript only wants a dipatch ptr to the first element that matches the name
        collectionCreation = RETCOLLECT_FIRSTITEM;
    }
    else if (dispidMember >= DISPID_EVENTHOOK_SENSITIVE_BASE &&
             dispidMember <= DISPID_EVENTHOOK_INSENSITIVE_MAX)
    {
        // Quick VBS event hookup always hooks to the last item in the collection.  This is for
        // IE4 VBS compatibility when foo_onclick is used if foo returns a collection of elements
        // with the name foo.  The only element to hookup for the onclick event would be the last
        // item in the collection of foo's.
        if (dispidMember <= DISPID_EVENTHOOK_SENSITIVE_MAX)
        {
            dispidMember -= DISPID_EVENTHOOK_SENSITIVE_BASE;
            dispidMember += pCollectionCache->GetSensitiveNamedMemberMin(CMarkup::WINDOW_COLLECTION);
        }
        else
        {
            dispidMember -= DISPID_EVENTHOOK_INSENSITIVE_BASE;
            dispidMember += pCollectionCache->GetNotSensitiveNamedMemberMin(CMarkup::WINDOW_COLLECTION);
        }

        collectionCreation = RETCOLLECT_LASTITEM;
    }
    else
    {
        collectionCreation = RETCOLLECT_ALL;
    }

    // If we Invoke on the dynamic collection, only return 1 item
    hr = THR_NOTRACE(DispatchInvokeCollection(this,
                                              &super::InvokeEx,
                                              pCollectionCache,
                                              CMarkup::WINDOW_COLLECTION,
                                              dispidMember,
                                              IID_NULL,
                                              lcid,
                                              wFlags,
                                              pdispparams,
                                              pvarResult,
                                              pexcepinfo,
                                              NULL,
                                              pSrvProvider,
                                              collectionCreation ));
    if (!hr) // if successfull, nothing more to do.
        goto Cleanup;

    if ( dispidMember >= DISPID_OMWINDOWMETHODS)
    {
        pScriptCollection = _pMarkup->GetScriptCollection();

        if (pScriptCollection)
        {
            hr = THR(_pMarkup->EnsureScriptContext(&pMarkupScriptContext));
            if (hr)
                goto Cleanup;

            hr = THR(pScriptCollection->InvokeEx(
                pMarkupScriptContext, dispidMember, lcid, wFlags, pdispparams,
                pvarResult, pexcepinfo, pSrvProvider));
        }
        else
        {   // Handle this on retail builds - don't crash:
            hr = DISP_E_MEMBERNOTFOUND;
        }
    }

    // Finally try the external object iff we're in a dialog.  Reason for
    // this is compat with existing pages from beta1/2 which are already
    // using old syntax.

    if (hr && pDoc->_fInHTMLDlg)
    {
        if (OK(get_external(&pDisp)) &&
            OK(pDisp->QueryInterface(IID_IDispatchEx, (void **)&pDispEx)))
        {
            hr = THR_NOTRACE(pDispEx->InvokeEx(
                    dispidMember,
                    lcid,
                    wFlags,
                    pdispparams,
                    pvarResult,
                    pexcepinfo,
                    pSrvProvider));
        }
    }

Cleanup:
    ReleaseInterface(pDisp);
    ReleaseInterface(pDispEx);
    RRETURN_NOTRACE(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CWindow::GetDispid
//
//  Synopsis:   Per IDispatchEx.  This is called by script engines to lookup
//              dispids of expando properties and of named elements such as
//              <FRAME NAME="AFrameName">
//
//--------------------------------------------------------------------------

STDMETHODIMP
CWindow::GetDispID(BSTR bstrName, DWORD grfdex, DISPID *pid)
{
    HRESULT                 hr = DISP_E_UNKNOWNNAME;
    IDispatchEx *           pDispEx = NULL;
    IDispatch *             pDisp = NULL;
    CMarkup *               pMarkup;
    BOOL                    fNoDynamicProperties = !!(grfdex & fdexNameNoDynamicProperties);
    CScriptCollection *     pScriptCollection;
    CMarkupScriptContext *  pMarkupScriptContext;

    // don't bother doing anything if we don't have a markup since we will crash shortly
    if (!_pMarkup)
        goto Cleanup;

    pMarkup = _pMarkup;
    pScriptCollection = pMarkup->GetScriptCollection();

    if (pScriptCollection && pScriptCollection->_fInEnginesGetDispID)
        goto Cleanup;

    // Quick event hookup for VBS.
    if (fNoDynamicProperties)
    {
        // Yes, if the name is window then let the script engine resolve everything
        // else better be a real object (frame, or all collection).
        STRINGCOMPAREFN pfnCompareString = (grfdex & fdexNameCaseSensitive)
                                                   ? StrCmpC : StrCmpIC;

        // If "window" or "document" is found then we'll turn fNoDynamicProperties off so that
        // the script engine is searched for "window" which is the global object
        // for the script engine.
        fNoDynamicProperties = !(pfnCompareString(s_propdescCWindowwindow.a.pstrName, bstrName)   == 0 ||
                                 pfnCompareString(s_propdescCWindowdocument.a.pstrName, bstrName) == 0);
    }

    // Does the script engine want names of object only (window, element ID).
    // If so then no functions or names in the script engine and no expandos.
    // This is for quick event hookup in VBS.
    if (!fNoDynamicProperties)
    {
        //
        // Try script collection namespace first.
        //

        if (pScriptCollection)
        {
            hr = THR(pMarkup->EnsureScriptContext(&pMarkupScriptContext));
            if (hr)
                goto Cleanup;

            hr = THR_NOTRACE(pScriptCollection->GetDispID(pMarkupScriptContext, bstrName, grfdex, pid));
            if (S_OK == hr)
                goto Cleanup;   // done;
        }

        // Next, try the external object iff we're in a dialog.  Reason for
        // this is compat with existing pages from beta1/2 which are already
        // using old syntax.

        if (hr && Doc()->_fInHTMLDlg)
        {
            if (OK(get_external(&pDisp)) &&
                OK(pDisp->QueryInterface(IID_IDispatchEx, (void **)&pDispEx)))
            {
                hr = THR_NOTRACE(pDispEx->GetDispID(bstrName, grfdex, pid));
            }
        }

        // Try property and expandos on the object.
        if (hr)
        {
            // Pass the special name on to CBase::GINEx.
            hr = THR_NOTRACE(super::GetDispID(bstrName, grfdex, pid));
        }

        // Next try named frames in the FRAMES_COLLECTION
        if (hr)
        {
            hr = THR(pMarkup->EnsureCollectionCache(CMarkup::FRAMES_COLLECTION));
            if (hr)
                goto Cleanup;

            hr = THR_NOTRACE(pMarkup->CollectionCache()->GetDispID(CMarkup::FRAMES_COLLECTION,
                                                                 bstrName,
                                                                 grfdex,
                                                                 pid));

            // The collectionCache GetDispid will return S_OK w/ DISPID_UNKNOWN
            // if the name isn't found, catastrophic errors are of course returned.
            if (!hr && *pid == DISPID_UNKNOWN)
            {
                hr = DISP_E_UNKNOWNNAME;
            }
        }
    }

    // Next try WINDOW collection name space.
    if (hr)
    {
        CCollectionCache   *pCollectionCache;

        hr = THR(pMarkup->EnsureCollectionCache(CMarkup::WINDOW_COLLECTION));
        if (hr)
            goto Cleanup;

        pCollectionCache = pMarkup->CollectionCache();

        hr = THR_NOTRACE(pCollectionCache->GetDispID(CMarkup::WINDOW_COLLECTION,
                                                     bstrName,
                                                     grfdex,
                                                     pid));
        // The collectionCache GetDispid will return S_OK w/ DISPID_UNKNOWN
        // if the name isn't found, catastrophic errors are of course returned.
        if (!hr && *pid == DISPID_UNKNOWN)
        {
            hr = DISP_E_UNKNOWNNAME;
        }
        else if (fNoDynamicProperties && pCollectionCache->IsNamedCollectionMember(CMarkup::WINDOW_COLLECTION, *pid))
        {
            DISPID dBase;
            DISPID dMax;

            if (grfdex & fdexNameCaseSensitive)
            {
                *pid -= pCollectionCache->GetSensitiveNamedMemberMin(CMarkup::WINDOW_COLLECTION);
                dBase = DISPID_EVENTHOOK_SENSITIVE_BASE;
                dMax =  DISPID_EVENTHOOK_SENSITIVE_MAX;
            }
            else
            {
                *pid -= pCollectionCache->GetNotSensitiveNamedMemberMin(CMarkup::WINDOW_COLLECTION);
                dBase = DISPID_EVENTHOOK_INSENSITIVE_BASE;
                dMax =  DISPID_EVENTHOOK_INSENSITIVE_MAX;
            }

            *pid += dBase;
            if (*pid > dMax)
            {
                hr = DISP_E_UNKNOWNNAME;
                *pid = DISPID_UNKNOWN;
            }
        }
    }

Cleanup:

    ReleaseInterface(pDisp);
    ReleaseInterface(pDispEx);
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CWindow::DeleteMember, IDispatchEx
//
//--------------------------------------------------------------------------


STDMETHODIMP
CWindow::DeleteMemberByName(BSTR bstr,DWORD grfdex)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CWindow::DeleteMemberByDispID(DISPID id)
{
    return E_NOTIMPL;
}

//+-------------------------------------------------------------------------
//
//  Method:     CWindow::GetMemberProperties, IDispatchEx
//
//--------------------------------------------------------------------------

STDMETHODIMP
CWindow::GetMemberProperties(
                DISPID id,
                DWORD grfdexFetch,
                DWORD *pgrfdex)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CWindow::GetNextDispID(DWORD grfdex,
                          DISPID id,
                          DISPID *prgid)
{
    HRESULT     hr;
    CMarkup *   pMarkup = _pMarkup;

    hr = THR(pMarkup->EnsureCollectionCache(CMarkup::FRAMES_COLLECTION));
    if (hr)
        goto Cleanup;

    hr = DispatchGetNextDispIDCollection(this,
                                         &super::GetNextDispID,
                                         pMarkup->CollectionCache(),
                                         CMarkup::FRAMES_COLLECTION,
                                         grfdex,
                                         id,
                                         prgid);

Cleanup:
    RRETURN1(hr, S_FALSE);
}

STDMETHODIMP
CWindow::GetMemberName(DISPID id,
                          BSTR *pbstrName)
{
    HRESULT     hr;
    CMarkup *   pMarkup = _pMarkup;

    hr = THR(pMarkup->EnsureCollectionCache(CMarkup::FRAMES_COLLECTION));
    if (hr)
        goto Cleanup;

    hr = DispatchGetMemberNameCollection(this,
                                         super::GetMemberName,
                                         pMarkup->CollectionCache(),
                                         CMarkup::FRAMES_COLLECTION,
                                         id,
                                         pbstrName);

Cleanup:
    RRETURN(hr);
}

STDMETHODIMP
CWindow::GetNameSpaceParent(IUnknown **ppunk)
{
    HRESULT     hr;

    if (!ppunk)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppunk = NULL;

    hr = S_OK;

Cleanup:
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CWindow::get_frameElement
//
//--------------------------------------------------------------------------

STDMETHODIMP
CWindow::get_frameElement(IHTMLFrameBase** p)
{
    HRESULT hr;
    CFrameSite * pFrameSite;

    if (!p)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    *p = NULL;
    hr = S_OK;
    if (!_pMarkup)
        goto Cleanup;

    pFrameSite = GetFrameSite();

    if (pFrameSite)
        hr = pFrameSite->QueryInterface(IID_IHTMLFrameBase, (void **) p);

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//+-------------------------------------------------------------------------
//
//  Method:     CWindow::get_document
//
//  Synopsis:   Per IOmWindow
//
//--------------------------------------------------------------------------

STDMETHODIMP
CWindow::get_document(IHTMLDocument2 **p)
{
    TraceTag((tagOmWindow, "get_Document"));

    HRESULT hr = S_OK;
    IDispatch * pDispatch = NULL;

    *p = NULL;

    if (_punkViewLinkedWebOC)
    {
        hr = GetWebOCDocument(_punkViewLinkedWebOC, &pDispatch);
        if (hr)
            goto Cleanup;

        hr = pDispatch->QueryInterface(IID_IHTMLDocument2, (void **) p);
    }
    else
    {
        if (!Document())
        {
            AssertSz(0,"Possible Async Problem Causing Watson Crashes");
            hr = E_FAIL;
            goto Cleanup;
        }

        hr = Document()->QueryInterface(IID_IHTMLDocument2, (void **) p);
    }

Cleanup:
    ReleaseInterface(pDispatch);

    RRETURN(SetErrorInfo(hr));
}

//+-------------------------------------------------------------------------
//
//  Method:     CWindow::get_frames
//
//  Synopsis:   Per IOmWindow
//
//--------------------------------------------------------------------------

STDMETHODIMP
CWindow::get_frames(IHTMLFramesCollection2 ** ppOmWindow)
{
    HRESULT hr = E_INVALIDARG;

    if (!ppOmWindow)
        goto Cleanup;

    hr = THR_NOTRACE(QueryInterface(IID_IHTMLWindow2, (void**) ppOmWindow));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//+----------------------------------------------------------------------------------
//
//  Member:     item
//
//  Synopsis:   object model implementation
//
//              we handle the following parameter cases:
//                  0 params:               returns IDispatch of this
//                  1 param as number N:    returns IDispatch of om window of
//                                          frame # N, or fails if doc is not with
//                                          frameset
//                  1 param as string "foo" returns the om window of the frame
//                                          element that has NAME="foo"
//
//-----------------------------------------------------------------------------------

STDMETHODIMP
CWindow::item(VARIANTARG *pvarArg1, VARIANTARG * pvarRes)
{
    Assert(Document());

    if (!Document())
    {
        AssertSz(0,"Possible Async Problem Causing Watson Crashes");
        RRETURN(E_FAIL);
    }
    
    RRETURN(SetErrorInfo(Document()->item(pvarArg1, pvarRes)));
}


HRESULT
CDocument::item(VARIANTARG *pvarArg1, VARIANTARG * pvarRes)
{
    HRESULT             hr = S_OK;
    IHTMLWindow2 *      pCWindow;
    CMarkup *           pMarkup = Markup();

    Assert(pMarkup);

    if (!pvarRes)
        RRETURN (E_POINTER);

    // Perform indirection if it is appropriate:
    if( V_VT(pvarArg1) == (VT_BYREF | VT_VARIANT) )
        pvarArg1 = V_VARIANTREF(pvarArg1);

    VariantInit (pvarRes);

    if (VT_EMPTY == V_VT(pvarArg1))
    {
        // this is one of the following cases if the call is from a script engine:
        //      window
        //      window.value
        //      window.frames
        //      window.frames.value

        V_VT(pvarRes) = VT_DISPATCH;
        hr = THR(QueryInterface(IID_IHTMLWindow2, (void**)&V_DISPATCH(pvarRes)));
    }
    else if( VT_BSTR == V_VT(pvarArg1) )
    {
        CElement *pElem;

        hr = THR(pMarkup->EnsureCollectionCache(CMarkup::WINDOW_COLLECTION));
        if (hr)
            goto Cleanup;

        hr = pMarkup->CollectionCache()->GetIntoAry( CMarkup::WINDOW_COLLECTION,
                                    V_BSTR(pvarArg1), FALSE, &pElem );
        if (hr || (pElem->Tag() != ETAG_FRAME && pElem->Tag() != ETAG_IFRAME))
        {
            hr = DISP_E_MEMBERNOTFOUND;
            goto Cleanup;
        }

        CFrameSite *pFrameSite = DYNCAST (CFrameSite, pElem);
        hr = pFrameSite->GetCWindow(&pCWindow);
        if (hr)
            goto Cleanup;

        V_VT(pvarRes) = VT_DISPATCH;
        V_DISPATCH(pvarRes) = pCWindow;
    }
    else
    {
        // this is one of the following cases if the call is from a script engine:
        //      window(<index>)
        //      window.frames(<index>)

        hr = THR(VariantChangeTypeSpecial(pvarArg1, pvarArg1, VT_I4));
        if (hr)
            goto Cleanup;

        hr = THR(pMarkup->GetCWindow(V_I4(pvarArg1), &pCWindow));
        if (hr)
            goto Cleanup;

        V_VT(pvarRes) = VT_DISPATCH;
        V_DISPATCH(pvarRes) = pCWindow;
    }

Cleanup:
    // don't release pOmWindow as it is copied to pvarRes without AddRef-ing
    RRETURN (hr);
}


//+------------------------------------------------------------------------
//
//  Member:     Get_newEnum
//
//  Synopsis:   collection object model
//
//-------------------------------------------------------------------------

STDMETHODIMP
CWindow::get__newEnum(IUnknown ** ppEnum)
{
    HRESULT hr = E_NOTIMPL;

    RRETURN(SetErrorInfo( hr));
}

//+-------------------------------------------------------------------------
//
//  Method:     CWindow::get_event
//
//  Synopsis:   Per IOmWindow. but if we are not in an event handler (there is
//              nothing on the "EVENTPARAM" stack) then just return NULL.
//
//--------------------------------------------------------------------------

STDMETHODIMP
CWindow::get_event(IHTMLEventObj ** ppEventObj)
{
    HRESULT hr = S_OK;
    CDoc * pDoc;
    EVENTPARAM * pparam;

    if (!ppEventObj)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppEventObj = NULL;
    // are we in an event?

    pDoc = Doc();
    pparam = pDoc->_pparam;

    if (pparam)
    {
        Ass