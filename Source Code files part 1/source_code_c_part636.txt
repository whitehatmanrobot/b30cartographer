        
                UlReleaseSpinLock(&pConnection->SpinLock, *OldIrql);

                Status = UcSendData(pConnection,    
                                    pEntity->pMdlHead,
                                    pEntity->BytesBuffered,
                                    &UcpRestartEntityMdlSend,
                                    (PVOID)pEntity,
                                    pEntity->pIrp,
                                    FALSE);
    
                if(STATUS_PENDING != Status)
                {
                    UcpRestartEntityMdlSend(pRequest, Status, 0);
                }

                
                // Acquire the spinlock so we can check again.
                
                UlAcquireSpinLock(&pConnection->SpinLock, OldIrql);
            }
        }
    }
    
    return bLast;
}


/***************************************************************************++

Routine Description:

    Free a client connection structure after the reference count has gone to
    zero. Freeing the structure means putting it back onto our free list.
                    
Arguments:

    pConnection         - Pointer to the connection structure to be freed.
                            
    
Return Value:


--***************************************************************************/
NTSTATUS
UcpCleanupConnection(
    IN PUC_CLIENT_CONNECTION pConnection,
    IN KIRQL                 OldIrql,
    IN BOOLEAN               Final
    )
{
    PLIST_ENTRY       pList;
    PUC_HTTP_REQUEST  pRequest;
    USHORT            FreeAddressType;
    PUC_TDI_OBJECTS   pTdiObject;

    ASSERT( UC_IS_VALID_CLIENT_CONNECTION(pConnection) );

    //
    // First, we flag this connection to make sure that no new requests 
    // The connect state is used to do this. We don't have to explicitly
    // do it here, but we'll just make sure that this is the case.
    //

    ASSERT(!(pConnection->Flags  & CLIENT_CONN_FLAG_CLEANUP_PENDED));

    //
    // If there's a thread that is issuing requests, we'll resume cleanup 
    // when it's done.
    //

    if(pConnection->Flags & CLIENT_CONN_FLAG_SEND_BUSY || 
       pConnection->Flags & CLIENT_CONN_FLAG_RECV_BUSY)
    {
        UC_WRITE_TRACE_LOG(
            g_pUcTraceLog,
            UC_ACTION_CONNECTION_CLEAN_PENDED,
            pConnection,
            NULL,
            UlongToPtr(pConnection->ConnectionState),
            UlongToPtr(pConnection->Flags)
            );
    
        pConnection->Flags |= CLIENT_CONN_FLAG_CLEANUP_PENDED;

        UlReleaseSpinLock(&pConnection->SpinLock, OldIrql);
    
        return STATUS_PENDING;
    }

    //
    // Walk the sent-request list to pick of the requests that got submitted. 
    //

    while(!IsListEmpty(&pConnection->SentRequestList))
    {
        pList    = pConnection->SentRequestList.Flink;

        pRequest = CONTAINING_RECORD(pList, 
                                     UC_HTTP_REQUEST, 
                                     Linkage);

        ASSERT( UC_IS_VALID_HTTP_REQUEST(pRequest) );

        pRequest->RequestStatus = pConnection->ConnectionStatus;

        if(UcCompleteParsedRequest(pRequest, 
                                   pRequest->RequestStatus, 
                                   FALSE,
                                   OldIrql
                                   ) == STATUS_PENDING)
        {
            UlAcquireSpinLock(&pConnection->SpinLock, &OldIrql);

            // 
            // There could be a window where the request gets cleaned up
            // after the lock gets released & before we acquire it again.
            // So, before we actually pend connection cleanup, we'll make
            // sure that the request is still on the list.
            //

            if(pList == pConnection->SentRequestList.Flink)
            {

                UC_WRITE_TRACE_LOG(
                    g_pUcTraceLog,
                    UC_ACTION_CONNECTION_CLEAN_PENDED,
                    pConnection,
                    pRequest,
                    UlongToPtr(pRequest->RequestState),
                    UlongToPtr(pConnection->Flags)
                    );
    
                pConnection->Flags |= CLIENT_CONN_FLAG_CLEANUP_PENDED;

                UlReleaseSpinLock(&pConnection->SpinLock, OldIrql);
        
                return STATUS_PENDING;
            }
            else
            {
                // This request really got cleaned, so we'll move on to the 
                // next. 
            }
        }
        else
        {
            UlAcquireSpinLock(&pConnection->SpinLock, &OldIrql);
        }
    }
    
    if(Final ||
       (!IsListEmpty(&pConnection->PendingRequestList) &&
        !(pConnection->Flags & CLIENT_CONN_FLAG_CONNECT_READY)))
    {
        //
        // If we are doing final cleanup, then ideally these lists should 
        // be empty, since we would have kicked these guys off in the 
        // Cleanup Handler. However, it does not hurt us to check these
        // here & clean if there are some entries. 
        //

        // A pended request initiates a connection setup, which can go through
        // various phases (e.g. connect failures, wait for server cert, 
        // proxy SSL, etc), before it's actually ready to be used. 
        //
        // If we get called in the cleanup handler before we move to the 
        // ready state, then our connection setup has failed and we are 
        // required to fail all pended requests. If we don't fail the pended 
        // requests, we'll get into a infinite loop, where we'll constantly 
        // try to set  up a connection (which could fail again).
        //

        if(Final)
        {
            while(!IsListEmpty(&pConnection->ProcessedRequestList))
            {
                pList    = RemoveHeadList(&pConnection->ProcessedRequestList);
    
                pRequest = CONTAINING_RECORD(pList, 
                                             UC_HTTP_REQUEST, 
                                             Linkage);
    
                InitializeListHead(pList);
        
                pRequest->RequestStatus = STATUS_CANCELLED;
    
                ASSERT(pRequest->RequestState == UcRequestStateResponseParsed);
    
                if(UcRemoveRequestCancelRoutine(pRequest))
                {
                    UC_WRITE_TRACE_LOG(
                    g_pUcTraceLog,
                    UC_ACTION_REQUEST_CANCELLED,
                    pConnection,
                    pRequest,
                    pRequest->RequestIRP,
                    UlongToPtr((ULONG)STATUS_CANCELLED)
                    );
                }
                else
                {
                    pRequest->RequestState = UcRequestStateDone;
        
                    UcCompleteParsedRequest(pRequest, 
                                            pRequest->RequestStatus, 
                                            FALSE,
                                            OldIrql
                                            );
        
                    UlAcquireSpinLock(&pConnection->SpinLock, &OldIrql);
                }
            }
        }

        while(!IsListEmpty(&pConnection->PendingRequestList))
        {
            pList    = RemoveHeadList(&pConnection->PendingRequestList);
            pRequest = CONTAINING_RECORD(pList, 
                                         UC_HTTP_REQUEST, 
                                         Linkage);
    
            InitializeListHead(pList);

            pRequest->RequestStatus = pConnection->ConnectionStatus;

            ASSERT(pRequest->RequestState == UcRequestStateCaptured);

            if(UcRemoveRequestCancelRoutine(pRequest))
            {
                UC_WRITE_TRACE_LOG(
                    g_pUcTraceLog,
                    UC_ACTION_REQUEST_CANCELLED,
                    pConnection,
                    pRequest,
                    pRequest->RequestIRP,
                    UlongToPtr((ULONG)STATUS_CANCELLED)
                    );
            }
            else
            {
                pRequest->RequestState = UcRequestStateDone;
    
                UcCompleteParsedRequest(pRequest, 
                                        pRequest->RequestStatus, 
                                        FALSE,
                                        OldIrql
                                        );
        
                UlAcquireSpinLock(&pConnection->SpinLock, &OldIrql);
            }
        }
    }

    //
    // Reset the flags. 
    //

    pConnection->Flags = 0;

    UC_WRITE_TRACE_LOG(
        g_pUcTraceLog,
        UC_ACTION_CONNECTION_CLEANED,
        pConnection,
        UlongToPtr(pConnection->ConnectionStatus),
        UlongToPtr(pConnection->ConnectionState),
        UlongToPtr(pConnection->Flags)
        );


    pTdiObject =  pConnection->pTdiObjects;

    pConnection->pTdiObjects = NULL;

    UlReleaseSpinLock(&pConnection->SpinLock, OldIrql);

    //
    // Let's assume that we did a active close & push this object back
    // on the list.
    //

    if(pTdiObject)
    {
        FreeAddressType = pTdiObject->ConnectionType;
        pTdiObject->pConnection = NULL;
        UcpPushTdiObject(pTdiObject, FreeAddressType);
    }


    //
    // Get rid of our opaque id if we're a filtered connection.
    // Also make sure we stop delivering AppWrite data to the parser.
    //

    if (pConnection->FilterInfo.pFilterChannel)
    {
        HTTP_RAW_CONNECTION_ID ConnectionId;

        UlUnbindConnectionFromFilter(&pConnection->FilterInfo);

        ConnectionId = pConnection->FilterInfo.ConnectionId;

        HTTP_SET_NULL_ID( &pConnection->FilterInfo.ConnectionId );

        if (!HTTP_IS_NULL_ID( &ConnectionId ))
        {
            UlFreeOpaqueId(ConnectionId, UlOpaqueIdTypeRawConnection);

            DEREFERENCE_CLIENT_CONNECTION(pConnection);
        }

        UlDestroyFilterConnection(&pConnection->FilterInfo);

        DEREFERENCE_FILTER_CHANNEL(pConnection->FilterInfo.pFilterChannel);

        pConnection->FilterInfo.pFilterChannel = NULL;
    }

    //
    // Get rid of any buffers we allocated for
    // certificate information.
    //
    if (pConnection->FilterInfo.SslInfo.pServerCertData)
    {
        UL_FREE_POOL(
            pConnection->FilterInfo.SslInfo.pServerCertData,
            UL_SSL_CERT_DATA_POOL_TAG
            );

        pConnection->FilterInfo.SslInfo.pServerCertData = NULL;
    }

    if (pConnection->FilterInfo.SslInfo.pCertEncoded)
    {
        UL_FREE_POOL(
            pConnection->FilterInfo.SslInfo.pCertEncoded,
            UL_SSL_CERT_DATA_POOL_TAG
            );

        pConnection->FilterInfo.SslInfo.pCertEncoded = NULL;
    }

    if (pConnection->FilterInfo.SslInfo.Token)
    {
        HANDLE Token;

        Token = (HANDLE) pConnection->FilterInfo.SslInfo.Token;

        //
        // If we are not running under the system process. And if the
        // thread we are running under has some APCs queued currently
        // KeAttachProcess won't allow us to attach to another process
        // and will bugcheck 5. We have to be queued as a work item and
        // should be running on the passive IRQL.
        //

        ASSERT( PsGetCurrentProcess() == (PEPROCESS) g_pUlSystemProcess );

        ZwClose(Token);
    }

    //
    // Free any allocated memory
    //
   
    if(pConnection->MergeIndication.pBuffer)
    { 
        UL_FREE_POOL_WITH_QUOTA(
            pConnection->MergeIndication.pBuffer, 
            UC_RESPONSE_TDI_BUFFER_POOL_TAG,
            NonPagedPool,
            pConnection->MergeIndication.BytesAllocated,
            pConnection->pServerInfo->pProcess
            );

        pConnection->MergeIndication.pBuffer = NULL;
    }

    // Free serialized server certificate, if any
    UC_FREE_SERIALIZED_CERT(&pConnection->ServerCertInfo,
                            pConnection->pServerInfo->pProcess);

    // Free certificate issuer list, if any
    UC_FREE_CERT_ISSUER_LIST(&pConnection->ServerCertInfo,
                             pConnection->pServerInfo->pProcess);
    
    return STATUS_SUCCESS;
}


/***************************************************************************++

Routine Description:

    The common connect complete routine. Called from the TDI UcpConnectComplete
    handler.

Arguments:

    pConnection         - Pointer to the connection structure to be freed.
    Status              - Connection Status.
    
Return Value:


--***************************************************************************/
VOID
UcRestartClientConnect(
    IN PUC_CLIENT_CONNECTION pConnection,
    IN NTSTATUS              Status
    )
{
    KIRQL                 OldIrql;
    BOOLEAN               bCloseConnection;

    bCloseConnection = FALSE;


    UlAcquireSpinLock(&pConnection->SpinLock, &OldIrql);

    pConnection->ConnectionStatus = Status;

    UC_WRITE_TRACE_LOG(
        g_pUcTraceLog,
        UC_ACTION_CONNECTION_RESTART_CONNECT,
        pConnection,
        UlongToPtr(pConnection->ConnectionStatus),
        UlongToPtr(pConnection->ConnectionState),
        UlongToPtr(pConnection->Flags)
        );


    //
    // First, we check to see if we have received a Cleanup/Close IRP.
    // If that's the case, we proceed directly to cleanup, regardless of 
    // the status. 
    //
    // Now, if the connection was successfully established, we have to tear
    // it down. This will eventually cleanup the connection & complete the
    // pended Cleanup/Close IRP.
    //

    if(pConnection->pEvent)
    {
        pConnection->Flags &= ~CLIENT_CONN_FLAG_TDI_ALLOCATE;

        if(Status == STATUS_SUCCESS)
        {
            pConnection->ConnectionState  = UcConnectStateConnectComplete;
    
            bCloseConnection = TRUE;

        }
        else
        {
            UC_WRITE_TRACE_LOG(
                g_pUcTraceLog,
                UC_ACTION_CONNECTION_CLEANUP,
                pConnection,
                UlongToPtr(pConnection->ConnectionStatus),
                UlongToPtr(pConnection->ConnectionState),
                UlongToPtr(pConnection->Flags)
                );

            pConnection->ConnectionState  = UcConnectStateConnectCleanup;
            pConnection->ConnectionStatus = STATUS_CANCELLED;
        }
    }
    else if (Status == STATUS_SUCCESS)
    {
        // It did, we connected. Now make sure we're still in the connecting
        // state, and get pending requests going.

        ASSERT(pConnection->ConnectionState == UcConnectStateConnectPending);

        pConnection->Flags &= ~CLIENT_CONN_FLAG_TDI_ALLOCATE;

        pConnection->ConnectionState = UcConnectStateConnectComplete;

    }
    else if (Status == STATUS_ADDRESS_ALREADY_EXISTS)
    {
        // If a connection attempt fails with STATUS_ADDRESS_ALREADY_EXISTS
        // it means that the TCB that is represented by the AO+CO object
        // is in TIME_WAIT. We'll put this AO+CO back on our list & 
        // proceed to allocate a new one from TCP.
        //
        // If a newly allocated AO+CO also fails with TIME_WAIT, then we'll 
        // just give up & show the error to the application. 
        //
        if(pConnection->Flags & CLIENT_CONN_FLAG_TDI_ALLOCATE)
        {
            // Darn. An newly allocated TDI object also failed with TIME_WAIT.
            // we'll have to fail the connection attempt. This is our 
            // recursion breaking condition.

            pConnection->Flags &= ~CLIENT_CONN_FLAG_TDI_ALLOCATE;

            goto ConnectFailure;
        }
        else
        {
            // The actual free of the AO+CO will happen in the
            // Connection State Machine.
            pConnection->ConnectionState = UcConnectStateConnectIdle;
        }
    }
    else
    {
        // This connect attempt failed. See if there are any more addresses.
        // getaddrinfo can pass back a list of addresses & we'll try all those
        // addresses before giving up & bouncing the error to the app. 
        // Some of these maybe IPv4 address & some others maybe IPv6 addresses.

        //
        // We use pConnection->NextAddressCount to make sure that we don't
        // overflow the address-list that's stored in the ServInfo structure.
        //

        pConnection->NextAddressCount = 
            (pConnection->NextAddressCount + 1) % 
                   pConnection->pServerInfo->pTransportAddress->TAAddressCount;

        //
        // pConnection->pNextAddress points to a TA_ADDRESS structure in the
        // TRANSPORT_ADDRESS list that is stored off the ServInfo structure.
        // This will be used for the "next" connect attempt.
        //

        pConnection->pNextAddress = (PTA_ADDRESS)
                                    ((PCHAR) pConnection->pNextAddress + 
                                      FIELD_OFFSET(TA_ADDRESS, Address) +
                                      pConnection->pNextAddress->AddressLength);

        if(pConnection->NextAddressCount == 0)
        {
            // We've rolled back (i.e we've cycled through all the IP addresses
            // Let's treat this as a real failure & propogate the error to the
            // application.
            //
ConnectFailure:

            // The connect failed. We need to fail any pending requests.

            pConnection->Flags &= ~CLIENT_CONN_FLAG_TDI_ALLOCATE;
        
            UC_WRITE_TRACE_LOG(
                g_pUcTraceLog,
                UC_ACTION_CONNECTION_CLEANUP,
                pConnection,
                UlongToPtr(Status),
                UlongToPtr(pConnection->ConnectionState),
                UlongToPtr(pConnection->Flags)
                );
    
            pConnection->ConnectionState = UcConnectStateConnectCleanup;
        }
        else
        {
            // Set the state to IDLE, so that we use the next address to 
            // connect.

            pConnection->Flags          &= ~CLIENT_CONN_FLAG_TDI_ALLOCATE;
            pConnection->ConnectionState = UcConnectStateConnectIdle;
        }
    }

    //
    // We can't be sending any reqeusts when a connection attempt is in 
    // progress.
    //

    ASSERT(IsListEmpty(&pConnection->SentRequestList));

    UlReleaseSpinLock(&pConnection->SpinLock, OldIrql);

    if(bCloseConnection)
    {
        UC_CLOSE_CONNECTION(pConnection, TRUE, STATUS_CANCELLED);
    }
}

/***************************************************************************++

Routine Description:

    Cancel a pending request. This routine is called when we're canceling
    a request that's on the pending list, hasn't been sent and hasn't caused
    a connect request.
    
Arguments:

    pDeviceObject           - Pointer to device object.
    Irp                     - Pointer to IRP being canceled.
    
Return Value:
    
    

--***************************************************************************/
VOID
UcpCancelPendingRequest(
    PDEVICE_OBJECT          pDeviceObject,
    PIRP                    Irp
    )
{
    PUC_HTTP_REQUEST     pRequest;
    PUC_CLIENT_CONNECTION         pConnection;
    KIRQL                           OldIrql;

    UNREFERENCED_PARAMETER(pDeviceObject);

    // Release the cancel spin lock, since we're not using it.

    IoReleaseCancelSpinLock(Irp->CancelIrql);

    // Retrieve the pointers we need. The request pointer is stored inthe
    // driver context array, and a back pointer to the connection is stored
    // in the request. Whoever set the cancel routine is responsible for
    // referencing the connection for us.

    pRequest = (PUC_HTTP_REQUEST)Irp->Tail.Overlay.DriverContext[0];

    pConnection = pRequest->pConnection;

    ASSERT(UC_IS_VALID_CLIENT_CONNECTION(pConnection));

    UC_WRITE_TRACE_LOG(
        g_pUcTraceLog,
        UC_ACTION_REQUEST_CANCELLED,
        pConnection,
        pRequest,
        Irp,
        UlongToPtr((ULONG)STATUS_CANCELLED)
        );

    //
    // Note: We cannot just call UcFailRequest from here. UcFailRequest
    // is supposed to be called when a request is failed (e.g. parseer
    // error) or canceled (HttpCancelRequest API) & hence has code to 
    // not double complete the IRP if the cancel routine kicked in.
    // 
    // Since we are the IRP cancel routine,  we  have to manually
    // complete the IRP. An IRP in this state has not hit the wire.
    // so, we just free send MDLs & cancel it. Note that we call 
    // UcFailRequest to handle common IRP cleanup.  
    //

    UlAcquireSpinLock(&pConnection->SpinLock, &OldIrql);

    UcFreeSendMdls(pRequest->pMdlHead);

    pRequest->pMdlHead = NULL;

    pRequest->RequestIRP = NULL;

    Irp->IoStatus.Status = STATUS_CANCELLED;
    Irp->RequestorMode   = pRequest->AppRequestorMode;
    Irp->MdlAddress      = pRequest->AppMdl;

    UcSetFlag(&pRequest->RequestFlags.Value,  UcMakeRequestCancelledFlag());

    UcFailRequest(pRequest, STATUS_CANCELLED, OldIrql);

    // For the IRP
    UC_DEREFERENCE_REQUEST(pRequest);

    UlCompleteRequest(Irp, IO_NO_INCREMENT);
}


/***************************************************************************++

Routine Description:

    Send an entity body on a connection.

Arguments:


Return Value:



--***************************************************************************/
NTSTATUS
UcSendEntityBody(
    IN  PUC_HTTP_REQUEST          pRequest, 
    IN  PUC_HTTP_SEND_ENTITY_BODY pEntity,
    IN  PIRP                      pIrp,
    IN  PIO_STACK_LOCATION        pIrpSp,
    OUT PBOOLEAN                  bDontFail,
    IN  BOOLEAN                   bLast
    )
{
    NTSTATUS              Status;
    PUC_CLIENT_CONNECTION pConnection;
    KIRQL                 OldIrql;
    BOOLEAN               RequestCancelled;
    BOOLEAN               bCloseConnection = FALSE;

    pConnection = pRequest->pConnection;
    
    ASSERT(UC_IS_VALID_CLIENT_CONNECTION(pConnection));
    ASSERT(UC_IS_VALID_HTTP_REQUEST(pRequest));

    UlAcquireSpinLock(&pConnection->SpinLock, &OldIrql);

    if(pRequest->RequestState == UcRequestStateDone ||
       pRequest->RequestFlags.Cancelled == TRUE     ||
       pRequest->RequestFlags.LastEntitySeen
       )
    {
        UlReleaseSpinLock(&pConnection->SpinLock, OldIrql);

        return STATUS_INVALID_PARAMETER;
    }

    if(bLast)
    {
        UcSetFlag(&pRequest->RequestFlags.Value,
                  UcMakeRequestLastEntitySeenFlag());
    }

    if(pRequest->RequestFlags.RequestBuffered)
    {
        if(pRequest->RequestFlags.LastEntitySeen)
        {
            //
            // We have seen the last entity for this request. We had already 
            // pinned the request on a connection (by inserting it in the 
            // pending list), we just need to issue the request.
            //

            UC_WRITE_TRACE_LOG(
                g_pUcTraceLog,
                UC_ACTION_ENTITY_LAST,
                pConnection,
                pRequest,
                pEntity,
                pIrp
                );

            InsertTailList(&pRequest->SentEntityList, &pEntity->Linkage);

            //
            // If the request IRP is around, we'll just use it. Otherwise, 
            // we'll use the entity IRP.
            //

            if(pRequest->RequestIRP)
            {
                // If the request IRP is around, it means that the app has
                // passed a receive buffer. In such cases, we will use the
                // request IRP to call TDI.
                //
                // We can complete the entity IRP with status_success since
                // we don't need it. If this thread return something that is
                // not STATUS_PENDING, then the IOCTL handler will complete 
                // the IRP. 
                

                ASSERT(pRequest->RequestFlags.ReceiveBufferSpecified == TRUE);

                pEntity->pIrp = 0;

                Status = UcSendRequestOnConnection(pConnection, 
                                                   pRequest, 
                                                   OldIrql);

                // If we get STATUS_PENDING, we want the IOCTL handler to 
                // complete the entity IRP with success, since we used the 
                // request IRP. However, if we get any other status, then 
                // we want to propogate it to the IOCTL handler. This will
                // fail the request, which will complete the request IRP.

                return ((Status == STATUS_PENDING)?STATUS_SUCCESS:Status);

            }
            else
            {
                pEntity->pIrp = 0;
    
                pRequest->AppRequestorMode   = pIrp->RequestorMode;
                pRequest->AppMdl             = pIrp->MdlAddress;
                pRequest->RequestIRP         = pIrp;
                pRequest->RequestIRPSp       = pIrpSp;
                ASSERT(pRequest->pFileObject == pIrpSp->FileObject);

                // Take a ref for the IRP.
                UC_REFERENCE_REQUEST(pRequest);

                return UcSendRequestOnConnection(pConnection, 
                                                 pRequest, 
                                                 OldIrql);
            }
    
        }
        else
        {
            // 
            // We have buffered the request & hence we have completed it early.
            // Let's do the same with the entity body also.
            //

            UC_WRITE_TRACE_LOG(
                g_pUcTraceLog,
                UC_ACTION_ENTITY_BUFFERED,
                pConnection,
                pRequest,
                pEntity,
                pIrp
                );

            InsertTailList(&pRequest->SentEntityList, &pEntity->Linkage);
            
            pEntity->pIrp->IoStatus.Status = STATUS_SUCCESS;

            UlReleaseSpinLock(&pConnection->SpinLock, OldIrql);

            return STATUS_SUCCESS;
        }
    }

    //
    // If the request has not been buffered earlier, we can send right 
    // away.
    //

    UC_WRITE_TRACE_LOG(
        g_pUcTraceLog,
        UC_ACTION_ENTITY_READY_TO_SEND,
        pConnection,
        pRequest,
        pEntity,
        pIrp
        );

    if(pConnection->Flags & CLIENT_CONN_FLAG_SEND_BUSY ||
       (pRequest->RequestState == UcRequestStateCaptured) ||
       (!IsListEmpty(&pRequest->PendingEntityList))
      )
    {
        //
        // We can't send this request now. Either
        //   a. This request itself has not been sent to TDI.
        //   b. Other send-entities are ahead of us.
        //   c. This request has not seen all of it's entity bodies.
        //
   
        UC_WRITE_TRACE_LOG(
            g_pUcTraceLog,
            UC_ACTION_ENTITY_QUEUED,
            pConnection,
            pRequest,
            pEntity,
            pIrp
            );

        InsertTailList(&pRequest->PendingEntityList, &pEntity->Linkage);

        IoMarkIrpPending(pEntity->pIrp);

        RequestCancelled = UcSetEntityCancelRoutine(
                                pEntity,
                                UcpCancelSendEntity
                                );
        if(RequestCancelled)
        {
            UC_WRITE_TRACE_LOG(
                g_pUcTraceLog,
                UC_ACTION_ENTITY_CANCELLED,
                pConnection,
                pRequest,
                pEntity,
                pIrp
                );

            pEntity->pIrp = NULL;
        }


        UlReleaseSpinLock(&pConnection->SpinLock, OldIrql);

        return STATUS_PENDING;
    
    }

    if(pConnection->ConnectionState == UcConnectStateConnectReady &&
            pRequest->RequestState != UcRequestStateResponseParsed &&
            pRequest->RequestState != UcRequestStateNoSendCompleteFullData)
    {

        // We can send now as we are doing chunked sends. Rather than
        // calling UcSendData directly, we'll call UcIssueEntities. 
        // We could get multiple send-entities, and we don't want them
        // to go out of order.

        pConnection->Flags |= CLIENT_CONN_FLAG_SEND_BUSY;
    
        Status = STATUS_PENDING;

        InsertTailList(&pRequest->PendingEntityList, &pEntity->Linkage);

        IoMarkIrpPending(pEntity->pIrp);

        UC_REFERENCE_REQUEST(pRequest);
    
        if(UcIssueEntities(pRequest, pConnection, &OldIrql))
        {
            // We have sent the last entity. Now, we can see if we want to 
            // send the next request or clear the flag.

            if(pRequest->RequestConnectionClose)
            {
                //
                // Remember that we've to close the connection. We'll do this
                // after we release the spin lock.
                //

                bCloseConnection = TRUE;
            }
            else if(
                   pConnection->ConnectionState == UcConnectStateConnectReady &&
                   !IsListEmpty(&pConnection->PendingRequestList) &&
                   IsListEmpty(&pConnection->SentRequestList)
                   )
            {
                UC_DEREFERENCE_REQUEST(pRequest);

                ASSERT(pConnection->Flags & CLIENT_CONN_FLAG_SEND_BUSY);

                pConnection->Flags &= ~CLIENT_CONN_FLAG_SEND_BUSY;

                // 
                // Connection is still ready, see if we can send any more 
                // requests. Note that we have to check the state again, because
                // we are releasing the lock above.
                //

                UcIssueRequests(pConnection, OldIrql);

                return STATUS_PENDING;
            }
        }

        UC_DEREFERENCE_REQUEST(pRequest);

        UcClearConnectionBusyFlag(
            pConnection,
            CLIENT_CONN_FLAG_SEND_BUSY,
            OldIrql,
            bCloseConnection
            );
    
    }
    else
    {
        // It appears as if the connection was torn down for some reason.
        // let's propogate this error to the app.

        //
        // We don't want to fail the request because of this error code. 
        // The connection could be torn down because of a 401, and we want to 
        // give the app a chance to read the response buffer. If we fail the
        // request, we are preventing the app from reading the response.
        //

        UlReleaseSpinLock(&pConnection->SpinLock, OldIrql);

        *bDontFail = TRUE;

        Status =  STATUS_CONNECTION_DISCONNECTED;
    }

    return Status;
}


/***************************************************************************++

Routine Description:

    Reference a client connection structure.
        
Arguments:

    pConnection     - Pointer to the connection structure to be referenced.

    
Return Value:

--***************************************************************************/
VOID
UcReferenceClientConnection(
    PVOID pObject
    REFERENCE_DEBUG_FORMAL_PARAMS
    )
{
    LONG                   RefCount;
    PUC_CLIENT_CONNECTION  pConnection;

    pConnection = (PUC_CLIENT_CONNECTION) pObject;

    ASSERT( UC_IS_VALID_CLIENT_CONNECTION(pConnection) );

    RefCount = InterlockedIncrement(&pConnection->RefCount);

    WRITE_REF_TRACE_LOG(
        g_pTdiTraceLog,
        REF_ACTION_REFERENCE_UL_CONNECTION,
        RefCount,
        pConnection,
        pFileName,
        LineNumber
        );

    ASSERT( RefCount > 0 );
}

        
/***************************************************************************++

Routine Description:

    Dereference a client connection structure. If the reference count goes
    to 0, we'll free the structure.
        
Arguments:

    pConnection         - Pointer to the connection structure to be
                            dereferenced.

    
Return Value:

--***************************************************************************/
VOID
UcDereferenceClientConnection(
    PVOID pObject
    REFERENCE_DEBUG_FORMAL_PARAMS
    )
{
    LONG                      RefCount;
    PUC_CLIENT_CONNECTION     pConnection;

    pConnection = (PUC_CLIENT_CONNECTION) pObject;

    ASSERT( UC_IS_VALID_CLIENT_CONNECTION(pConnection) );

    RefCount = InterlockedDecrement(&pConnection->RefCount);

    WRITE_REF_TRACE_LOG(
        g_pTdiTraceLog,
        REF_ACTION_DEREFERENCE_UL_CONNECTION,
        RefCount,
        pConnection,
        pFileName,
        LineNumber
        );

    ASSERT(RefCount >= 0);

    if (RefCount == 0)
    {
        ASSERT(pConnection->pTdiObjects == NULL);

        DESTROY_REF_TRACE_LOG(pConnection->pTraceLog, 
                              UL_REF_TRACE_LOG_POOL_TAG);

        if(pConnection->pEvent)
        {
            KeSetEvent(pConnection->pEvent, 0, FALSE);

            pConnection->pEvent = NULL;
        }

        ExFreeToNPagedLookasideList(
                &g_ClientConnectionLookaside,
                pConnection
                );
    }
}


/***************************************************************************++

Routine Description:

    The worker thread that calls the connection state machine.
        
Arguments:

    pWorkItem - Pointer to the work-item
    
Return Value:
    None

--***************************************************************************/
VOID
UcpConnectionStateMachineWorker(
    IN PUL_WORK_ITEM pWorkItem
    )
{
    KIRQL                 OldIrql;
    PUC_CLIENT_CONNECTION pConnection;

    //
    // Sanity check.
    //
    ASSERT( KeGetCurrentIrql() == PASSIVE_LEVEL );

    //
    // Grab the connection.
    //

    pConnection = CONTAINING_RECORD(
                        pWorkItem,
                        UC_CLIENT_CONNECTION,
                        WorkItem
                        );
                        
    ASSERT( UC_IS_VALID_CLIENT_CONNECTION(pConnection) );                        
    UlAcquireSpinLock(&pConnection->SpinLock, &OldIrql);

    ASSERT(pConnection->bWorkItemQueued);
    pConnection->bWorkItemQueued = FALSE;

    UcConnectionStateMachine(pConnection, OldIrql);

    DEREFERENCE_CLIENT_CONNECTION(pConnection);
}


/***************************************************************************++

Routine Description:

    This routine kicks off the worker thread that fires the connection state
    machine. This is always called with the connection spin lock held. If
    the worker has already been issued but not fired, we don't do anything.
        
Arguments:

    pConnection - Pointer to the connection structure
    OldIrql     - The IRQL that we have to use when calling UlReleaseSpinLock.
    
Return Value:
    None

--***************************************************************************/
VOID
UcKickOffConnectionStateMachine(
    IN PUC_CLIENT_CONNECTION      pConnection,
    IN KIRQL                      OldIrql,
    IN UC_CONNECTION_WORKER_TYPE  WorkerType
    )
{
    if(!pConnection->bWorkItemQueued)
    {
        pConnection->bWorkItemQueued = TRUE;
       
        REFERENCE_CLIENT_CONNECTION(pConnection);
 
        UlReleaseSpinLock(&pConnection->SpinLock, OldIrql);

        if(UcConnectionPassive == WorkerType)
        {
            // If we are already at PASSIVE, UL_CALL_PASSIVE calls the callback
            // in the context of the same thread.

            UL_CALL_PASSIVE(&pConnection->WorkItem, 
                            &UcpConnectionStateMachineWorker);
        }
        else
        {
            ASSERT(UcConnectionWorkItem == WorkerType);

            UL_QUEUE_WORK_ITEM(&pConnection->WorkItem,
                               &UcpConnectionStateMachineWorker);
        }
    }
    else
    {
        //
        // Someone else has already done this.
        //

        UlReleaseSpinLock(&pConnection->SpinLock, OldIrql);
    }
}


/***************************************************************************++

Routine Description:

   This routine computes the size required to store HTTP_RAW_CONNECTION_INFO
   structure.  The computation takes into account the space needed to store
   embedded pointers to structures.  See the diagram below.

Arguments:

    pConnectionContext - Pointer to UC_CLIENT_CONNECTION.

Return Value:

    Length (in bytes) needed to generate raw connection info structure.

--***************************************************************************/
ULONG
UcComputeHttpRawConnectionLength(
    IN PVOID pConnectionContext
    )
{
    PUC_CLIENT_CONNECTION pConnection;
    ULONG                 ReturnLength;

    pConnection = (PUC_CLIENT_CONNECTION) pConnectionContext;

    ASSERT(UC_IS_VALID_CLIENT_CONNECTION(pConnection));

    //
    //  Memory layout: (must be in sync with UcGenerateHttpRawConnectionInfo)
    //
    //  +---------------------------------------------------------------+
    //  | H_R_C_I |\\\| T_A_L_I |\\| T_A_L_I |\\| H_C_S_C | Server Name |
    //  +---------------------------------------------------------------+
    //

    ReturnLength = ALIGN_UP(sizeof(HTTP_RAW_CONNECTION_INFO), PVOID);

    ReturnLength += 2 * ALIGN_UP(TDI_ADDRESS_LENGTH_IP6, PVOID);

    ReturnLength += sizeof(HTTP_CLIENT_SSL_CONTEXT);

    ReturnLength += pConnection->pServerInfo->pServerInfo->ServerNameLength;

    return ReturnLength;
}


/***************************************************************************++

Routine Description:

    Builds the HTTP_RAW_CONNECTION structure

Arguments:

    pContext           - Pointer to the UL_CONNECTION
    pKernelBuffer      - Pointer to kernel buffer
    pUserBuffer        - Pointer to user buffer
    OutputBufferLength - Length of output buffer
    pBuffer            - Buffer for holding any data
    InitialLength      - Size of input data.

--***************************************************************************/
ULONG
UcGenerateHttpRawConnectionInfo(
    IN  PVOID   pContext,
    IN  PUCHAR  pKernelBuffer,
    IN  PVOID   pUserBuffer,
    IN  ULONG   OutputBufferLength,
    IN  PUCHAR  pBuffer,
    IN  ULONG   InitialLength
    )
{
    PHTTP_RAW_CONNECTION_INFO   pConnInfo;
    PTDI_ADDRESS_IP6            pLocalAddress;
    PTDI_ADDRESS_IP6            pRemoteAddress;
    PHTTP_TRANSPORT_ADDRESS     pAddress;
    PUC_CLIENT_CONNECTION       pConnection;
    ULONG                       BytesCopied = 0;
    PUCHAR                      pInitialData;
    PUCHAR                      pCurr;
    PWSTR                       pServerName;
    USHORT                      ServerNameLength = 0;
    PHTTP_CLIENT_SSL_CONTEXT    pClientSSLContext;


    pConnection = (PUC_CLIENT_CONNECTION) pContext;

    ASSERT( UC_IS_VALID_CLIENT_CONNECTION(pConnection) );

    //
    // We'll assume that the kernel buffer is PVOID aligned.  Based on this,
    // pointer, other pointers must be aligned.
    //

    ASSERT(pKernelBuffer == ALIGN_UP_POINTER(pKernelBuffer, PVOID));

    //
    // N.B. pCurr must always be PVOID aligned.
    //

    pCurr = pKernelBuffer;

    //
    // Create HTTP_RAW_CONNECTION_INFO structure.
    //

    pConnInfo = (PHTTP_RAW_CONNECTION_INFO)pCurr;

    pCurr += ALIGN_UP(sizeof(HTTP_RAW_CONNECTION_INFO), PVOID);

    //
    // Create Local TDI_ADDRESS_IP6 structure.
    //

    pLocalAddress = (PTDI_ADDRESS_IP6)pCurr;

    pCurr += ALIGN_UP(sizeof(TDI_ADDRESS_IP6), PVOID);

    //
    // Create Remote TDI_ADDRESS_IP6 structure.
    //

    pRemoteAddress = (PTDI_ADDRESS_IP6)pCurr;

    pCurr += ALIGN_UP(sizeof(TDI_ADDRESS_IP6), PVOID);

    //
    // Create HTTP_CLIENT_SSL_CONTEXT structure.
    //

    pClientSSLContext = (PHTTP_CLIENT_SSL_CONTEXT)pCurr;

    //
    // The rest of the space is used to store the server name followed by
    // initialize data.
    //

    pServerName = &pClientSSLContext->ServerName[0];

    ServerNameLength = pConnection->pServerInfo->pServerInfo->ServerNameLength;

    pInitialData = (PUCHAR) ((PUCHAR)pServerName + ServerNameLength);

    pConnInfo->pClientSSLContext = (PHTTP_CLIENT_SSL_CONTEXT)
                                    FIXUP_PTR(
                                    PVOID,
                                    pUserBuffer,
                                    pKernelBuffer,
                                    pClientSSLContext,
                                    OutputBufferLength
                                    );

    //
    // The last element of HTTP_CLIENT_SSL_CONTEXT is an array WCHAR[1].
    // The following calculation takes that WCHAR into account.
    //

    pConnInfo->ClientSSLContextLength = sizeof(HTTP_CLIENT_SSL_CONTEXT) 
                                        - sizeof(WCHAR)
                                        + ServerNameLength;

    // Ssl protocol version to be used for this connection
    pClientSSLContext->SslProtocolVersion =
        pConnection->pServerInfo->SslProtocolVersion;

    // Client certificate to be used for this connection
    pClientSSLContext->pClientCertContext =
        pConnection->pServerInfo->pClientCert;

    // Copy the server certificate validation mode.
    pClientSSLContext->ServerCertValidation =
        pConnection->pServerInfo->ServerCertValidation;

    pClientSSLContext->ServerNameLength = ServerNameLength;

    RtlCopyMemory(
        pServerName,
        pConnection->pServerInfo->pServerInfo->pServerName,
        ServerNameLength
        );

    //
    // Now fill in the raw connection data structure.
    //

    pConnInfo->ConnectionId = pConnection->FilterInfo.ConnectionId;

    pAddress = &pConnInfo->Address;

    pAddress->pRemoteAddress = FIXUP_PTR(
                                    PVOID,
                                    pUserBuffer,
                                    pKernelBuffer,
                                    pRemoteAddress,
                                    OutputBufferLength
                                    );

    pAddress->pLocalAddress = FIXUP_PTR(
                                    PVOID,
                                    pUserBuffer,
                                    pKernelBuffer,
                                    pLocalAddress,
                                    OutputBufferLength
                                    );

    RtlZeroMemory(pRemoteAddress, sizeof(TDI_ADDRESS_IP6));
    RtlZeroMemory(pLocalAddress, sizeof(TDI_ADDRESS_IP6));

    //
    // Copy any initial data.
    //
    if (InitialLength)
    {
        ASSERT(pBuffer);

        pConnInfo->InitialDataSize = InitialLength;

        pConnInfo->pInitialData = FIXUP_PTR(
                                        PVOID,              // Type
                                        pUserBuffer,        // pUserPtr
                                        pKernelBuffer,      // pKernelPtr
                                        pInitialData,       // pOffsetPtr
                                        OutputBufferLength  // BufferLength
                                        );

        RtlCopyMemory(
            pInitialData,
            pBuffer,
            InitialLength
            );

        BytesCopied += InitialLength;
    }

    return BytesCopied;
}


/****************************************************************************++

Routine Description:

    Triggers the connection state machine
    Called when a server certificate is received from the filter.

Arguments:

    None.

Return Value:

    None.

--****************************************************************************/
VOID
UcServerCertificateInstalled(
    IN PVOID    pConnectionContext,
    IN NTSTATUS Status
    )
{
    PUC_CLIENT_CONNECTION pConnection;
    KIRQL                 OldIrql;

    pConnection = (PUC_CLIENT_CONNECTION) pConnectionContext;

    ASSERT( UC_IS_VALID_CLIENT_CONNECTION(pConnection) );

    if (!NT_SUCCESS(Status))
    {
        UC_CLOSE_CONNECTION(pConnection, TRUE, Status);
    }
    else
    {
        UlAcquireSpinLock(&pConnection->SpinLock, &OldIrql);

        ASSERT(pConnection->ConnectionState ==
                   UcConnectStatePerformingSslHandshake);

        ASSERT(pConnection->SslState == UcSslStateServerCertReceived);

        UcKickOffConnectionStateMachine(
            pConnection, 
            OldIrql, 
            UcConnectionWorkItem
            );
    }
}


/***************************************************************************++

Routine Description:

    This routine is the connection state machine
        
Arguments:

    pConnection - Pointer to the connection structure
    OldIrql     - The IRQL that we have to use when calling UlReleaseSpinLock.
    
Return Value:
    None

--***************************************************************************/

VOID 
UcConnectionStateMachine(
    IN PUC_CLIENT_CONNECTION pConnection,
    IN KIRQL                 OldIrql
    )
{
    ULONG                          TakenLength;
    NTSTATUS                       Status;
    PUC_HTTP_REQUEST               pHeadRequest;
    PLIST_ENTRY                    pEntry;
    PUC_PROCESS_SERVER_INFORMATION pServInfo;
    USHORT                         AddressType, FreeAddressType;
    PUC_TDI_OBJECTS                pTdiObjects;

    // Sanity check.
    ASSERT(UlDbgSpinLockOwned(&pConnection->SpinLock));

    UC_WRITE_TRACE_LOG(
        g_pUcTraceLog,
        UC_ACTION_CONNECTION_STATE_ENTER,
        pConnection,
        UlongToPtr(pConnection->Flags),
        UlongToPtr(pConnection->ConnectionState),
        0
        );

    pServInfo = pConnection->pServerInfo;

Begin:

    ASSERT( UlDbgSpinLockOwned(&pConnection->SpinLock) );

    switch(pConnection->ConnectionState)
    {

    case UcConnectStateConnectCleanup:
Cleanup:

        ASSERT(pConnection->ConnectionState == UcConnectStateConnectCleanup);

        pConnection->ConnectionState = UcConnectStateConnectCleanupBegin;

        if(pConnection->pEvent)
        {
            //
            // We have been called in the cleanup handler, so we just clean
            // the connection & not initialize it again. This connection will
            // make its' way into the SLIST & will be there for re-use.
            //

            UcpCleanupConnection(pConnection, OldIrql, TRUE);

            break;
        }
        else
        {
            //
            // We have come here from a Disconnect handler or a Abort handler.
            // We have to clean up the connection & then re-initialize it. In
            // the process of cleaning up the connection, we will release the
            // lock. So we move to an interim state, so that we dont' cleanup
            // twice.
            //

            Status = UcpCleanupConnection(pConnection, OldIrql, FALSE);

            if(Status == STATUS_PENDING)
            {
                // Our cleanup is pended because we are waiting for sends
                // to complete. 

                break;
            }

            Status = UcpInitializeConnection(pConnection,
                                             pServInfo);

            if(!NT_SUCCESS(Status))
            {
                LIST_ENTRY       TempList;
                PUC_HTTP_REQUEST pRequest;

                InitializeListHead(&TempList);

                //
                // What do we do here ? This connection is not usable but
                // we have not been called in the cleanup handler. We'll remove
                // this connection from the active list, which will prevent it
                // from being used by any new requests.
                //

                UlAcquirePushLockExclusive(&pServInfo->PushLock);

                // Make the connection unaccessible from ServInfo
                ASSERT(pConnection->ConnectionIndex < 
                       pServInfo->MaxConnectionCount);
                ASSERT(pServInfo->Connections[pConnection->ConnectionIndex]
                       == pConnection);
                pServInfo->Connections[pConnection->ConnectionIndex] = NULL;

                // Invalidate connection index
                pConnection->ConnectionIndex = HTTP_REQUEST_ON_CONNECTION_ANY;

                pServInfo->CurrentConnectionCount--;

                UlReleasePushLock(&pServInfo->PushLock);

                UlAcquireSpinLock(&pConnection->SpinLock, &OldIrql);

                //
                // Get rid of all requests from the processed & pended lists.
                //
                
                while(!IsListEmpty(&pConnection->ProcessedRequestList))
                {
                    pEntry = RemoveHeadList(&pConnection->ProcessedRequestList);

                    pRequest = CONTAINING_RECORD(
                                    pEntry,
                                    UC_HTTP_REQUEST,
                                    Linkage
                                    );

                    ASSERT( UC_IS_VALID_HTTP_REQUEST(pRequest) );

                    UC_REFERENCE_REQUEST(pRequest);
    
                    InsertHeadList(&TempList, &pRequest->Linkage);
                }

                while(!IsListEmpty(&pConnection->PendingRequestList))
                {
                    pEntry = RemoveHeadList(&pConnection->PendingRequestList);

                    InsertHeadList(&TempList, pEntry);
                }

                ASSERT(IsListEmpty(&pConnection->SentRequestList));

                //
                // Dereference for the ServInfo.
                //

                DEREFERENCE_CLIENT_CONNECTION(pConnection);

                UC_WRITE_TRACE_LOG(
                    g_pUcTraceLog,
                    UC_ACTION_CONNECTION_CLEANUP,
                    pConnection,
                    UlongToPtr(pConnection->ConnectionStatus),
                    UlongToPtr(pConnection->ConnectionState),
                    UlongToPtr(pConnection->Flags)
                    );

                pConnection->ConnectionState = UcConnectStateConnectCleanup;

    
                while(!IsListEmpty(&TempList))
                {
                     pEntry = TempList.Flink;
            
                     pRequest = CONTAINING_RECORD(pEntry,
                                                  UC_HTTP_REQUEST,
                                                  Linkage);

                     UcFailRequest(pRequest, Status, OldIrql);

                     UlAcquireSpinLock(&pConnection->SpinLock, &OldIrql);
                }

                UlReleaseSpinLock(&pConnection->SpinLock, OldIrql);

                break;
            }
            else
            {
                UlAcquireSpinLock(&pConnection->SpinLock, &OldIrql);

                if(pConnection->pEvent)
                {
                    pConnection->ConnectionState = UcConnectStateConnectCleanup;

                    UcpCleanupConnection(pConnection, OldIrql, TRUE); 

                    break;
                }
                else
                {
                    pConnection->ConnectionState = UcConnectStateConnectIdle;
    
                    //
                    // FALL Through!
                    //
                }
            }
        }

    case UcConnectStateConnectIdle:

        ASSERT(pConnection->ConnectionState == UcConnectStateConnectIdle);

        if(!IsListEmpty(&pConnection->PendingRequestList))
        {

            pConnection->ConnectionState = UcConnectStateConnectPending;

            AddressType = pConnection->pNextAddress->AddressType; 

            if(NULL == pConnection->pTdiObjects)
            {
                //
                // If there is no TDI object, then grab one for this connect
                // attempt
                //

                pTdiObjects = UcpPopTdiObject(AddressType);
            }
            else
            {
                //
                // If we are here, we have a old TDI object that failed
                // a connection attempt. This could be because the old one 
                // was in TIME_WAIT (Failed with STATUS_ADDRESS_ALREADY_EXISTS)
                //

                // We have to free the old one & allocate a new one. Since
                // both free and allocate have to happen at Passive IRQL,
                // we'll do it after we release the lock (below).

                pTdiObjects = NULL;
            }

            if(NULL == pTdiObjects)
            {
                UlReleaseSpinLock(&pConnection->SpinLock, OldIrql);

                //
                // If there is an old one, free it.
                //
                if(NULL != pConnection->pTdiObjects)
                {
                    FreeAddressType = pConnection->pTdiObjects->ConnectionType;

                    pConnection->pTdiObjects->pConnection = NULL;

                    UcpPushTdiObject(pConnection->pTdiObjects, FreeAddressType);

                    pConnection->pTdiObjects = NULL;
                }

                //
                // Allocate a new one.
                //

                Status = UcpAllocateTdiObject(
                             &pTdiObjects, 
                             AddressType
                             );

                UlAcquireSpinLock(&pConnection->SpinLock, &OldIrql);

                ASSERT(pConnection->ConnectionState ==
                            UcConnectStateConnectPending);

                if(!NT_SUCCESS(Status))
                {
                    ASSERT(Status != STATUS_ADDRESS_ALREADY_EXISTS);

                    pConnection->ConnectionState = UcConnectStateConnectCleanup;

                    goto Begin;
                }

                pConnection->Flags |= CLIENT_CONN_FLAG_TDI_ALLOCATE;
            } 

            pConnection->pTdiObjects = pTdiObjects;
            pTdiObjects->pConnection = pConnection;

            //
            // The address information in the connection has been filled out. 
            // Reference the connection, and call the appropriate connect 
            // routine.
            //
        
            REFERENCE_CLIENT_CONNECTION(pConnection);
        
            UC_WRITE_TRACE_LOG(
                g_pUcTraceLog,
                UC_ACTION_CONNECTION_BEGIN_CONNECT,
                pConnection,
                UlongToPtr(pConnection->ConnectionStatus),
                UlongToPtr(pConnection->ConnectionState),
                UlongToPtr(pConnection->Flags)
                );

            //
            // Fill out the current TDI address & go to the next one.
            //
            ASSERT(pConnection->NextAddressCount < 
                        pServInfo->pTransportAddress->TAAddressCount);

            UlReleaseSpinLock(&pConnection->SpinLock, OldIrql);

            Status = UcClientConnect(
                        pConnection, 
                        pConnection->pTdiObjects->pIrp
                        );
        
            if (STATUS_PENDING != Status)
            {
                UcRestartClientConnect(pConnection, Status);

                UlAcquireSpinLock(&pConnection->SpinLock, &OldIrql);

                //
                // In the normal case, UcpConnectComplete calls 
                // UcRestartClientConnect, does the de-ref & kicks off 
                // the connection state machine. 
                //
                // Since we are calling UcRestartClientConnect directly,
                // we should deref.

                DEREFERENCE_CLIENT_CONNECTION(pConnection);

                goto Begin;
            }
        }
        else
        {
            UlReleaseSpinLock(&pConnection->SpinLock, OldIrql);
        }
            
        break;

    case UcConnectStateConnectPending:
    case UcConnectStateProxySslConnect:
    case UcConnectStateConnectCleanupBegin:
    case UcConnectStateDisconnectIndicatedPending:
    case UcConnectStateDisconnectPending:
    case UcConnectStateDisconnectComplete:
    case UcConnectStateAbortPending:

        //
        // We have already issued a connect, we don't have to do anything
        // here.
        //

        UlReleaseSpinLock(&pConnection->SpinLock, OldIrql);

        break;

    case UcConnectStateConnectComplete:

        //
        // The TCP has connected.
        //

        if(!IsListEmpty(&pConnection->PendingRequestList))
        {
            if(pConnection->Flags & CLIENT_CONN_FLAG_PROXY_SSL_CONNECTION)
            {
                PUC_HTTP_REQUEST pConnectRequest;
                //
                // We are going through a proxy. We need to send
                // a CONNECT verb.  
                //
    
                pEntry = pConnection->PendingRequestList.Flink;
    
                pHeadRequest = CONTAINING_RECORD(pEntry,
                                                 UC_HTTP_REQUEST,
                                                 Linkage);

                pConnection->ConnectionState = UcConnectStateProxySslConnect;


                UlReleaseSpinLock(&pConnection->SpinLock, OldIrql);

                pConnectRequest = 
                        UcBuildConnectVerbRequest(pConnection, pHeadRequest);
    
                if(pConnectRequest == NULL)
                {
                    //
                    // The CONNECT verb failed, we can't do much so we'll
                    // acquire the lock & fail it.
                    //

                    UlAcquireSpinLock(&pConnection->SpinLock, &OldIrql);

                    pConnection->ConnectionState = UcConnectStateConnectCleanup;

                    goto Cleanup;

                }
                else
                {
                    UlAcquireSpinLock(&pConnection->SpinLock, &OldIrql);
    
                    REFERENCE_CLIENT_CONNECTION(pConnection);
    
                    InsertHeadList(&pConnection->SentRequestList,
                                   &pConnectRequest->Linkage);
    
                    ASSERT(pConnection->ConnectionState == 
                                UcConnectStateProxySslConnect);

                    pConnectRequest->RequestState = UcRequestStateSent;
    
                    UlReleaseSpinLock(&pConnection->SpinLock, OldIrql);
    
                    //
                    // go ahead & issue the request.
                    //
    
                    ASSERT(pConnectRequest->RequestConnectionClose == FALSE);
    
                    Status = UcSendData(pConnection,    
                                        pConnectRequest->pMdlHead,
                                        pConnectRequest->BytesBuffered,
                                        &UcRestartMdlSend,
                                        (PVOID) pConnectRequest,
                                        pConnectRequest->RequestIRP,
                                        TRUE);
    
                    if(STATUS_PENDING != Status)
                    {
                         UcRestartMdlSend(pConnectRequest, Status, 0);
                    }
                }
            }
            else if(pConnection->FilterInfo.pFilterChannel)
            {
                pConnection->ConnectionState =
                    UcConnectStatePerformingSslHandshake;

                pConnection->SslState = UcSslStateConnectionDelivered;
    
                UlReleaseSpinLock(&pConnection->SpinLock, OldIrql);

                UlDeliverConnectionToFilter(
                        &pConnection->FilterInfo,
                        NULL,
                        0,
                        &TakenLength
                        );
    
                ASSERT(TakenLength == 0);
            }
            else
            {
                pConnection->ConnectionState = UcConnectStateConnectReady;
    
                goto IssueRequests;
            }
        }
        else
        {
            //
            // There are no requests that need to be sent out, let's 
            // remain in this state. 
            //

            UlReleaseSpinLock(&pConnection->SpinLock, OldIrql);
        }

        break;


    case UcConnectStateProxySslConnectComplete:

        if(!IsListEmpty(&pConnection->PendingRequestList))
        {
            pConnection->ConnectionState =
                UcConnectStatePerformingSslHandshake;

            pConnection->SslState = UcSslStateConnectionDelivered;
    
            ASSERT(pConnection->FilterInfo.pFilterChannel);
        
            UlReleaseSpinLock(&pConnection->SpinLock, OldIrql);
        
            UlDeliverConnectionToFilter(
                    &pConnection->FilterInfo,
                    NULL,
                    0,
                    &TakenLength
                    );
        
            ASSERT(TakenLength == 0);
        }
        else
        {
            UlReleaseSpinLock(&pConnection->SpinLock, OldIrql);
        }

        break;

    case UcConnectStateConnectReady:

IssueRequests:
        ASSERT(pConnection->ConnectionState == UcConnectStateConnectReady);

        // It's connected. If no one is using the connection to write right
        // now, and either the remote server supports pipeling and this
        // request does also or the sent request list is empty, go ahead and 
        // send it.

        pConnection->Flags |= CLIENT_CONN_FLAG_CONNECT_READY;

        if ( !IsListEmpty(&pConnection->PendingRequestList) && 
             !(pConnection->Flags & CLIENT_CONN_FLAG_SEND_BUSY) &&
             UcpCheckForPipelining(pConnection)
            )
        {
            // It's OK to send now.

            UcIssueRequests(pConnection, OldIrql);
        }
        else
        {
            UlReleaseSpinLock(&pConnection->SpinLock, OldIrql);
        }

        break;

    case UcConnectStateIssueFilterClose:

        pConnection->ConnectionState = UcConnectStateDisconnectPending;

        UlReleaseSpinLock(&pConnection->SpinLock, OldIrql);

        UlFilterCloseHandler(
                        &pConnection->FilterInfo,
                         NULL,
                         NULL
                         );

        break;

    case UcConnectStateIssueFilterDisconnect:

        pConnection->ConnectionState = UcConnectStateDisconnectIndicatedPending;

        UlReleaseSpinLock(&pConnection->SpinLock, OldIrql);

        UlFilterDisconnectHandler(&pConnection->FilterInfo);

        break;

    case UcConnectStatePerformingSslHandshake:

        //
        // Perform Ssl handshake.
        //

        if (pConnection->SslState == UcSslStateServerCertReceived)
        {
            UlReleaseSpinLock(&pConnection->SpinLock, OldIrql);

            if(UcpCompareServerCert(pConnection))
            {
                // Okay to move the connection state machine forward.

                UlAcquireSpinLock(&pConnection->SpinLock, &OldIrql);
                goto Begin;
            }
        }
        else
        {
            UlReleaseSpinLock(&pConnection->SpinLock, OldIrql);
        }

        break;

    default:
        ASSERT(!"Invalid Connection state");

        UlReleaseSpinLock(&pConnection->SpinLock, OldIrql);
        break;
    }

    ASSERT(!UlDbgSpinLockOwned(&pConnection->SpinLock));

    UC_WRITE_TRACE_LOG(
        g_pUcTraceLog,
        UC_ACTION_CONNECTION_STATE_LEAVE,
        pConnection,
        UlongToPtr(pConnection->Flags),
        UlongToPtr(pConnection->ConnectionState),
        0
        );
}

/***************************************************************************++

Routine Description:

    Initializes a UC_CLIENT_CONNECTION for use.

Arguments:

    pConnection - Pointer to the UL_CONNECTION to initialize.

    SecureConnection - TRUE if this connection is for a secure endpoint.

--***************************************************************************/
NTSTATUS
UcpInitializeConnection(
    IN PUC_CLIENT_CONNECTION          pConnection,
    IN PUC_PROCESS_SERVER_INFORMATION pInfo
    )
{
    NTSTATUS           Status;
    PUL_FILTER_CHANNEL pChannel;

    //
    // Initialization.
    //

    pConnection->MergeIndication.pBuffer         = NULL;
    pConnection->MergeIndication.BytesWritten    = 0;
    pConnection->MergeIndication.BytesAvailable  = 0;
    pConnection->MergeIndication.BytesAllocated  = 0;

    pConnection->NextAddressCount = 0;
    pConnection->pNextAddress = pInfo->pTransportAddress->Address;

    if(pInfo->bSecure)
    {
        pChannel = UxRetrieveClientFilterChannel(pInfo->pProcess);

        if(!pChannel)
        {
            return STATUS_NO_TRACKING_SERVICE;
        }

        if(pInfo->bProxy)
        {
            pConnection->Flags |= CLIENT_CONN_FLAG_PROXY_SSL_CONNECTION;
        }
        else
        {
            pConnection->Flags &= ~CLIENT_CONN_FLAG_PROXY_SSL_CONNECTION;
        }
    }
    else
    {
        pChannel = NULL;
        pConnection->Flags &= ~CLIENT_CONN_FLAG_PROXY_SSL_CONNECTION;
    }

    Status = UxInitializeFilterConnection(
                    &pConnection->FilterInfo,
                     pChannel,
                     pInfo->bSecure,
                     &UcReferenceClientConnection,
                     &UcDereferenceClientConnection,
                     &UcCloseRawFilterConnection,
                     &UcpSendRawData,
                     &UcpReceiveRawData,
                     &UcHandleResponse,
                     &UcComputeHttpRawConnectionLength,
                     &UcGenerateHttpRawConnectionInfo,
                     &UcServerCertificateInstalled,
                     &UcDisconnectRawFilterConnection,
                     NULL,                     // Listen Context
                     pConnection
                     );
    
    if(Status != STATUS_SUCCESS)
    {
        if(pChannel)
        {
            //
            // Undo the Retrieve
            //

            DEREFERENCE_FILTER_CHANNEL(pChannel);
        }
    }

    return Status;
}

/***************************************************************************++

Routine Description:

    Opens the TDI connection & address objects, called from connection init
    code.

Arguments:

    pTdi - a pointer to TDI Objects

Return Value:

    NTSTATUS - STATUS_SUCCESS if IO should continue processing this
        IRP, STATUS_MORE_PROCESSING_REQUIRED if IO should stop processing
        this IRP.

--***************************************************************************/
NTSTATUS
UcpOpenTdiObjects(
    IN PUC_TDI_OBJECTS pTdi
    )
{
    USHORT          AddressType;
    NTSTATUS        status;

    AddressType = pTdi->ConnectionType;

    //
    // First, open the TDI connection object for this connection.
    //

    status = UxOpenTdiConnectionObject(
                    AddressType,
                    (CONNECTION_CONTEXT)pTdi,
                    &pTdi->ConnectionObject
                    );

    if (!NT_SUCCESS(status))
    {
        return status;
    }

    //
    // Now open an address object for this connection.
    //
    
    status = UxOpenTdiAddressObject(
                G_LOCAL_ADDRESS(AddressType),
                G_LOCAL_ADDRESS_LENGTH(AddressType),
                &pTdi->AddressObject
                );

    if (!NT_SUCCESS(status))
    {
        UxCloseTdiObject(&pTdi->ConnectionObject);

        return status;
    }
    else 
    {
    
        //
        // Hook up a receive handler.   
        //
        status = UxSetEventHandler(
                        &pTdi->AddressObject,
                        TDI_EVENT_RECEIVE,
                        (ULONG_PTR) &UcpTdiReceiveHandler,
                        pTdi
                        );
    }
    
    if(!NT_SUCCESS(status))
    {
        UxCloseTdiObject(&pTdi->ConnectionObject);
        UxCloseTdiObject(&pTdi->AddressObject);
        return status;
    }
    else
    {

        //
        // Hook up a Disconnect handler.
        //
        status = UxSetEventHandler(
                        &pTdi->AddressObject,
                        TDI_EVENT_DISCONNECT,
                        (ULONG_PTR) &UcpTdiDisconnectHandler,
                        pTdi
                        );
    }

    if(!NT_SUCCESS(status))
    {
        UxCloseTdiObject(&pTdi->ConnectionObject);
        UxCloseTdiObject(&pTdi->AddressObject);
        return status;
    }

    return status;
}

/***************************************************************************++

Routine Description:

    Allocates a TDI object, which contains a AO & CO. This routine is called 
    when we don't have any TDI objects in the pool. associate it with a 
    local address.
    
Arguments:

    ppTdiObjects - A pointer to the TDI object.
    AddressType  - IPv4 or IPv6
    
Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UcpAllocateTdiObject(
    OUT PUC_TDI_OBJECTS       *ppTdiObjects,
    IN  USHORT                 AddressType
    )
{
    PUC_TDI_OBJECTS       pTdiObjects;
    NTSTATUS              status;
    PUX_TDI_OBJECT        pTdiObject;
    KEVENT                Event;
    PIRP                  pIrp;
    IO_STATUS_BLOCK       ioStatusBlock;

    PAGED_CODE();

    *ppTdiObjects = NULL;

    //
    // Allocate the pool for the connection structure.
    //

    pTdiObjects = UL_ALLOCATE_STRUCT(
                        NonPagedPool,
                        UC_TDI_OBJECTS,
                        UC_TDI_OBJECTS_POOL_TAG
                        );

    if (pTdiObjects == NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    pTdiObjects->ConnectionType              = AddressType;
    pTdiObjects->TdiInfo.UserDataLength      = 0;
    pTdiObjects->TdiInfo.UserData            = NULL;
    pTdiObjects->TdiInfo.OptionsLength       = 0;
    pTdiObjects->TdiInfo.Options             = NULL;
    pTdiObjects->pConnection                 = NULL;

    //   
    // Open the TDI address & connection objects. We need one AO per connection
    // as we will have to open multiple TCP connections to the same server.
    //

    if((status = UcpOpenTdiObjects(pTdiObjects)) != STATUS_SUCCESS)
    {
        UL_FREE_POOL(pTdiObjects, UC_TDI_OBJECTS_POOL_TAG);

        return status;
    }

    //
    // Allocate an IRP for calling into TDI (e.g. Disconnects, Connects, etc)
    //

    pTdiObject = &pTdiObjects->ConnectionObject;

    pTdiObjects->pIrp = UlAllocateIrp(
                            pTdiObject->pDeviceObject->StackSize,
                            FALSE
                            );

    if(!pTdiObjects->pIrp)
    {
        UcpFreeTdiObject(pTdiObjects);

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Init the IrpContext.
    //
    pTdiObjects->IrpContext.Signature = UL_IRP_CONTEXT_SIGNATURE;

    //
    // Now, associate the Address Object with the Connection Object.
    //

    KeInitializeEvent(&Event, SynchronizationEvent, FALSE);

    pIrp = TdiBuildInternalDeviceControlIrp(
                TDI_ASSOCIATE_ADDRESS,
                pTdiObjects->ConnectionObject.pDeviceObject,
                pTdiObjects->ConnectionObject.pFileObject,
                &Event,
                &ioStatusBlock
                );

    if (pIrp != NULL)
    {
        TdiBuildAssociateAddress(
            pIrp,                                        // IRP
            pTdiObjects->ConnectionObject.pDeviceObject, // Conn. device object.
            pTdiObjects->ConnectionObject.pFileObject,   // Conn. File object.
            NULL,                                        // Completion routine
            NULL,                                        // Context
            pTdiObjects->AddressObject.Handle            // Address obj handle.
            );
   
        //
        // We don't want to call UlCallDriver, since we did not allocate this
        // IRP using UL.
        //
 
        status = IoCallDriver(
                    pTdiObjects->ConnectionObject.pDeviceObject,
                    pIrp
                    );
    
        // If it didn't complete, wait for it.
    
        if (status == STATUS_PENDING)
        {
            status = KeWaitForSingleObject(
                        &Event,
                        Executive,
                        KernelMode,
                        FALSE,
                        NULL
                        );
    
            ASSERT( status == STATUS_SUCCESS);
            status = ioStatusBlock.Status;
        }
    }
    else
    { 
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    if(!NT_SUCCESS(status))
    {
        UcpFreeTdiObject(pTdiObjects);

        return status;
    }

    *ppTdiObjects = pTdiObjects;
    return STATUS_SUCCESS;
}

/***************************************************************************++

Routine Description:

    Free's the TDI object to the list.
    
Arguments:

    pTdiObjects - A pointer to the TDI object.
    AddressType - IPv4 or IPv6
    
Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
VOID
UcpFreeTdiObject(
    IN  PUC_TDI_OBJECTS pTdiObjects
    )
{
    PAGED_CODE();

    if(pTdiObjects->pIrp)
    {
        UlFreeIrp(pTdiObjects->pIrp);
    }
    
    UxCloseTdiObject(&pTdiObjects->ConnectionObject);
    UxCloseTdiObject(&pTdiObjects->AddressObject);

    UL_FREE_POOL(pTdiObjects, UC_TDI_OBJECTS_POOL_TAG);
}

/***************************************************************************++

Routine Description:

    Retrieves a TDI object from a list. IF not found, allocates a new one.
    
Arguments:

    ppTdiObjects - A pointer to the TDI object.
    AddressType  - IPv4 or IPv6
    
Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
PUC_TDI_OBJECTS
UcpPopTdiObject(
    IN  USHORT           AddressType
    )
{
    PLIST_ENTRY               pListEntry;
    PUC_TDI_OBJECTS           pTdiObjects;
    KIRQL                     OldIrql;

    //
    // Get a AO/CO pair from the address object list.
    //

    UlAcquireSpinLock(&G_CLIENT_CONN_SPIN_LOCK(AddressType), &OldIrql);

    if(IsListEmpty(&G_CLIENT_TDI_CONNECTION_SLIST_HEAD(AddressType)))
    {
        pTdiObjects = NULL;
    }
    else
    {
        (*G_CLIENT_CONN_LIST_COUNT(AddressType)) --;

        pListEntry = RemoveHeadList(
                          &G_CLIENT_TDI_CONNECTION_SLIST_HEAD(AddressType)
                          );
                                                                           
        pTdiObjects = CONTAINING_RECORD(
                            pListEntry,
                            UC_TDI_OBJECTS,
                            Linkage
                            );

        ASSERT(pTdiObjects->pConnection == NULL);

    }

    UlReleaseSpinLock(&G_CLIENT_CONN_SPIN_LOCK(AddressType), OldIrql);

    return pTdiObjects;

}

/***************************************************************************++

Routine Description:

    Free's the TDI object to the list.
    
Arguments:

    pTdiObjects - A pointer to the TDI object.
    AddressType - IPv4 or IPv6
    
Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
VOID
UcpPushTdiObject(
    IN  PUC_TDI_OBJECTS pTdiObjects,
    IN  USHORT          AddressType
    )
{
    KIRQL OldIrql;

    ASSERT(pTdiObjects->pConnection == NULL);

    PAGED_CODE();

    UlAcquireSpinLock(&G_CLIENT_CONN_SPIN_LOCK(AddressType), &OldIrql);

    if((*G_CLIENT_CONN_LIST_COUNT(AddressType)) < CLIENT_CONN_TDI_LIST_MAX)
    {
        (*G_CLIENT_CONN_LIST_COUNT(AddressType))++;
 
        InsertTailList(
            &G_CLIENT_TDI_CONNECTION_SLIST_HEAD(AddressType),
            &pTdiObjects->Linkage
            );

        UlReleaseSpinLock(&G_CLIENT_CONN_SPIN_LOCK(AddressType), OldIrql);
    }
    else
    {
        UlReleaseSpinLock(&G_CLIENT_CONN_SPIN_LOCK(AddressType), OldIrql);

        UcpFreeTdiObject(pTdiObjects);
    }
}


/***************************************************************************++

Routine Description:

  Clears the send or receive busy flag & re-kicks the connection state machine 

Arguments:

    pConnection      - The UC_CLIENT_CONNECTION structure.
    Flag             - CLIENT_CONN_FLAG_SEND_BUSY or CLIENT_CONN_FLAG_RECV_BUSY
    OldIrql          - Irql at which lock was acquired.
    bCloseConnection - Whether we shoudl close the connection after releasing
                       lock.

Return Value:

    None

--***************************************************************************/
VOID
UcClearConnectionBusyFlag(
    IN PUC_CLIENT_CONNECTION pConnection,
    IN ULONG                 Flags,
    IN KIRQL                 OldIrql,
    IN BOOLEAN               bCloseConnection
    )
{
    ASSERT( UlDbgSpinLockOwned(&pConnection->SpinLock) );

    ASSERT((Flags & CLIENT_CONN_FLAG_SEND_BUSY) ||
           (Flags & CLIENT_CONN_FLAG_RECV_BUSY));

    ASSERT(pConnection->Flags & Flags);

    pConnection->Flags &= ~Flags;

    if(pConnection->Flags & CLIENT_CONN_FLAG_CLEANUP_PENDED)
    {
        //
        // The connection got torn down in between. We've pended the
        // cleanup let's resume it now.
        //
        UC_WRITE_TRACE_LOG(
            g_pUcTraceLog,
            UC_ACTION_CONNECTION_CLEAN_RESUMED,
            pConnection,
            UlongToPtr(pConnection->ConnectionStatus),
            UlongToPtr(pConnection->ConnectionState),
            UlongToPtr(pConnection->Flags)
            );

        ASSERT(pConnection->ConnectionState == 
                    UcConnectStateConnectCleanupBegin);

        pConnection->ConnectionState = UcConnectStateConnectCleanup;

        pConnection->Flags &= ~CLIENT_CONN_FLAG_CLEANUP_PENDED;

        UcKickOffConnectionStateMachine(
            pConnection, 
            OldIrql, 
            UcConnectionWorkItem
            );
    }
    else
    {
        UlReleaseSpinLock(&pConnection->SpinLock, OldIrql);
        
        if(bCloseConnection)
        {
            UC_CLOSE_CONNECTION(pConnection, 
                                FALSE, 
                                STATUS_CONNECTION_DISCONNECTED);
        }
    }

    return; 
}


/***************************************************************************++

Routine Description:

    Attaches captured SSL server certificate to a connection.

    Called with the pConnection->FilterConnLock held. The connection is
    assumed to be in the connected state.

Arguments:

    pConnection - the connection that gets the info
    pServerCertInfo - input server cert info

--***************************************************************************/
NTSTATUS
UcAddServerCertInfoToConnection(
    IN PUX_FILTER_CONNECTION      pConnection,
    IN PHTTP_SSL_SERVER_CERT_INFO pServerCertInfo
    )
{
    NTSTATUS                       Status;
    PUC_CLIENT_CONNECTION          pClientConn;

    //
    // Sanity check.
    //
    ASSERT(IS_VALID_FILTER_CONNECTION(pConnection));
    ASSERT(pServerCertInfo);
    ASSERT(UlDbgSpinLockOwned(&pConnection->FilterConnLock));
    ASSERT(pConnection->ConnState == UlFilterConnStateConnected);

    //
    // Initialize local variables
    //
    Status = STATUS_INVALID_PARAMETER;

    //
    // Get client connection
    //
    pClientConn = (PUC_CLIENT_CONNECTION)pConnection->pConnectionContext;
    ASSERT(UC_IS_VALID_CLIENT_CONNECTION(pClientConn));

    //
    // We are already at DPC, so aquire spin lock at DPC
    // BUGBUG: deadlock? (acquiring filter lock followed by connection lock)
    // (Is there a place we acquire connection lock before filter lock?
    //
    UlAcquireSpinLockAtDpcLevel(&pClientConn->SpinLock);

    //
    // The server certinfo can be passed only during initial handshake or
    // after receiving ssl renegotiate from the server - in which case 
    // the connection must be ready (for a request to be sent out on it)
    //
    if (pServerCertInfo->Status == SEC_E_OK)
    {
        // Did a renegotiation happen?
        if (pClientConn->ConnectionState == UcConnectStateConnectReady)
        {
            // Renegotiation must yield the same server certificate
            if (!UC_COMPARE_CERT_HASH(pServerCertInfo,
                                      &pClientConn->ServerCertInfo))
            {
                goto quit;
            }
        }
        else if (pClientConn->ConnectionState !=
                     UcConnectStatePerformingSslHandshake ||
                 pClientConn->SslState != UcSslStateConnectionDelivered)
        {
            goto quit;
        }
    }
    else 
    {
        // BUGBUG: handle the error case more gracefully!
        goto quit;
    }

    // Go back to ssl handshake state
    pClientConn->ConnectionState = UcConnectStatePerformingSslHandshake;
    pClientConn->SslState        = UcSslStateServerCertReceived;

    //
    // Before overwriting ServerCertInfo, make sure it does not
    // contain any serialized blobs or Issuer List
    //
    ASSERT(pClientConn->ServerCertInfo.Cert.pSerializedCert      == NULL);
    ASSERT(pClientConn->ServerCertInfo.Cert.pSerializedCertStore == NULL);
    ASSERT(pClientConn->ServerCertInfo.IssuerInfo.pIssuerList    == NULL);

    RtlCopyMemory(&pClientConn->ServerCertInfo,
                  pServerCertInfo,
                  sizeof(pClientConn->ServerCertInfo));

    Status = STATUS_SUCCESS;

 quit:
    UlReleaseSpinLockFromDpcLevel(&pClientConn->SpinLock);

    if (!NT_SUCCESS(Status))
    {
        // An error occured.

        // Free serialized server certificate if any
        UC_FREE_SERIALIZED_CERT(pServerCertInfo,
                                pClientConn->pServerInfo->pProcess);

        // Free issuer list if any
        UC_FREE_CERT_ISSUER_LIST(pServerCertInfo,
                                 pClientConn->pServerInfo->pProcess);
    }

    return Status;
}


/**************************************************************************++

Routine Description:

    This routine fails 

Arguments:

    pConnection - Pointer to client connection.

Return Value:

    TRUE  - A request was failed.
    FALSE - Could not fail arequest.

--**************************************************************************/
PUC_HTTP_REQUEST
UcpFindRequestToFail(
    PUC_CLIENT_CONNECTION pConnection
    )
{
    PUC_HTTP_REQUEST pRequest = NULL;
    PLIST_ENTRY      pListEntry;
    PIRP             pIrp;

    //
    // Sanity checks.
    //

    ASSERT(UC_IS_VALID_CLIENT_CONNECTION(pConnection));
    ASSERT(UlDbgSpinLockOwned(&pConnection->SpinLock));

    //
    // Try to fail a pending request.  Start searching from the head of the
    // pending request list.
    //

    for (pListEntry = pConnection->PendingRequestList.Flink;
         pListEntry != &pConnection->PendingRequestList;
         pListEntry = pListEntry->Flink)
    {
        pRequest = CONTAINING_RECORD(pConnection->PendingRequestList.Flink,
                                     UC_HTTP_REQUEST,
                                     Linkage);

        ASSERT(UC_IS_VALID_HTTP_REQUEST(pRequest));
        ASSERT(pRequest->RequestState == UcRequestStateCaptured);

        pIrp = UcPrepareRequestIrp(pRequest, STATUS_RETRY);

        if (pIrp)
        {
            // Prepared the request IRP for completion. Now complete it.
            UlCompleteRequest(pIrp, 0);
            break;
        }

        // Set to NULL so that it not returned.
        pRequest = NULL;
    }

    return pRequest;
}


/***************************************************************************++

Routine Description:

    Compares a server certificate present on a connection to a server
    certificate on a server context.

Arguments:

    pConnection   - Client connection

Return Value:

    TRUE - Continue sending requests.
    FALSE - Do not send requests.

--***************************************************************************/
BOOLEAN
UcpCompareServerCert(
    IN PUC_CLIENT_CONNECTION pConnection
    )
{
    BOOLEAN                         action = FALSE;
    KIRQL                           OldIrql;
    PUC_PROCESS_SERVER_INFORMATION  pServInfo;
    PUC_HTTP_REQUEST                pRequest = NULL;

    // Sanity check.
    ASSERT(UC_IS_VALID_CLIENT_CONNECTION(pConnection));

    //
    // Retrieve server information from the connection.
    //

    pServInfo = pConnection->pServerInfo;
    ASSERT(IS_VALID_SERVER_INFORMATION(pServInfo));

    //
    // Acquire the server information push lock followed by the
    // connection spinlock.
    //

    UlAcquirePushLockExclusive(&pServInfo->PushLock);
    UlAcquireSpinLock(&pConnection->SpinLock, &OldIrql);

    //
    // Make sure the connection is still in ssl handshake state
    // (This check is needed since we released the connection spinlock
    // before calling this function.)
    //

    if (pConnection->ConnectionState != UcConnectStatePerformingSslHandshake
        || pConnection->SslState != UcSslStateServerCertReceived)
    {
        action = FALSE;
        goto Release;
    }

    //
    // Cert::Flags is used to optimize certain cases.
    // If HTTP_SSL_SERIALIZED_CERT_PRESENT is not set,
    // the server certificate was accepted and was not
    // stored in the connection.
    //

    if (!(pConnection->ServerCertInfo.Cert.Flags &
          HTTP_SSL_SERIALIZED_CERT_PRESENT))
    {
        // Okay to send request on this connection.
        action = TRUE;
        goto Release;
    }

    //
    // Unoptimized cases.
    //

    //
    // For Ignore and Automatic modes, no validation is needed.
    // If there is not server cert info on pServInfo, copy now.
    //

    if (pServInfo->ServerCertValidation ==HttpSslServerCertValidationIgnore ||
        pServInfo->ServerCertValidation ==HttpSslServerCertValidationAutomatic)
    {
        if (pServInfo->ServerCertInfoState == 
            HttpSslServerCertInfoStateNotPresent)
        {
            // Update the state of server cert info on servinfo.
            pServInfo->ServerCertInfoState = 
                HttpSslServerCertInfoStateNotValidated;

            // Move Cert Issuer List from connection to server info.
            UC_MOVE_CERT_ISSUER_LIST(pServInfo, pConnection);

            // Move certificate from connection to servinfo.
            UC_MOVE_SERIALIZED_CERT(pServInfo, pConnection);
        }

        // Okay to send requests on this connection.
        action = TRUE;
        goto Release;
    }

    //
    // Take action based on the server cert info state in pServInfo.
    //

    switch (pServInfo->ServerCertInfoState)
    {
    case HttpSslServerCertInfoStateNotPresent:
    NotPresent:

        ASSERT(pServInfo->ServerCertValidation == 
                   HttpSslServerCertValidationManual ||
               pServInfo->ServerCertValidation == 
                   HttpSslServerCertValidationManualOnce);

        //
        // Find a pending request to fail.
        //

        pRequest = UcpFindRequestToFail(pConnection);

        if (pRequest == NULL)
        {
            //
            // We could not find a request to fail.
            // Hence, we can't send requests on this pConnection.
            //

            action = FALSE;
        }
        else
        {
            // Update the state of server cert info on servinfo.
            pServInfo->ServerCertInfoState = 
                HttpSslServerCertInfoStateNotValidated;

            // Move Cert Issuer List from connection to server info.
            UC_MOVE_CERT_ISSUER_LIST(pServInfo, pConnection);

            // Move certificate from connection to servinfo.
            UC_MOVE_SERIALIZED_CERT(pServInfo, pConnection);

            // Update the ssl state on the connection.
            pConnection->SslState = UcSslStateValidatingServerCert;

            //
            // Reference the request so that it doesn't go away
            // before we fail it below.
            //

            UC_REFERENCE_REQUEST(pRequest);

            //
            // Can't send request on pConnection as we are waiting for
            // server certificate validation.
            //

            action = FALSE;
        }

        break;

    case HttpSslServerCertInfoStateNotValidated:

        //
        // Server Certificate is already present on servinfo but has not
        // been validated.
        //

        ASSERT(pServInfo->ServerCertValidation == 
                   HttpSslServerCertValidationManual ||
               pServInfo->ServerCertValidation == 
                   HttpSslServerCertValidationManualOnce);

        // Can't send any requests on pConnection right now.
        action = FALSE;
        break;

    case HttpSslServerCertInfoStateValidated:

        ASSERT(pServInfo->ServerCertValidation == 
                   HttpSslServerCertValidationManual ||
               pServInfo->ServerCertValidation == 
                   HttpSslServerCertValidationManualOnce);

        if (pServInfo->ServerCertValidation == 
                HttpSslServerCertValidationManualOnce)
        {
            // Is the new certificate same as old one?
            if (UC_COMPARE_CERT_HASH(&pServInfo->ServerCertInfo,
                                     &pConnection->ServerCertInfo))
            {
                // New certificate is same as the old one.

                // Just move Cert Issuer List from connection to server info.
                UC_MOVE_CERT_ISSUER_LIST(pServInfo, pConnection);

                // Okay to send requests on this connection.
                action = TRUE;
            }
            else
            {
                goto NotPresent;
            }
        }
        else // HttpSslServerCertValidationManual
        {
            // Treat this case as if the certificate was not present.
            goto NotPresent;
        }

        break;

    default:
        ASSERT(FALSE);
        break;
    }

 Release:

    if (action)
    {
        //
        // Handshake is complete.  Requests can be sent out on this connection.
        //

        pConnection->SslState = UcSslStateHandshakeComplete;
        pConnection->ConnectionState = UcConnectStateConnectReady;

        //
        // Free any certificate and issuers list on this connection.
        //

        UC_FREE_SERIALIZED_CERT(&pConnection->ServerCertInfo,
                                pConnection->pServerInfo->pProcess);

        UC_FREE_CERT_ISSUER_LIST(&pConnection->ServerCertInfo,
                                 pConnection->pServerInfo->pProcess);
    }

    //
    // Release the connection spinlock and server information pushlock.
    //

    UlReleaseSpinLock(&pConnection->SpinLock, OldIrql);
    UlReleasePushLock(&pServInfo->PushLock);

    if (pRequest)
    {
        UlAcquireSpinLock(&pConnection->SpinLock, &OldIrql);

        UcFailRequest(pRequest, STATUS_RETRY, OldIrql);

        UC_DEREFERENCE_REQUEST(pRequest);
    }

    return action;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\close.c ===
/*++

Copyright (c) 1998-2002 Microsoft Corporation

Module Name:

    close.c

Abstract:

    This module contains code for cleanup and close IRPs.

Author:

    Keith Moore (keithmo)       10-Jun-1998

Revision History:

--*/


#include "precomp.h"


#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, UlClose )
#endif  // ALLOC_PRAGMA

#if 0
NOT PAGEABLE -- UlCleanup
#endif


/*


Relationship between Cleanup & Close IRPs --> IOCTLs won't be called after the 
handle has been "Cleaned", but there can be a race between IOCTLs & Cleanup. 
Close is called only when all IOCTLs are completed. Abnormal termination of an 
application (e.g. AV) will exercize the cleanup paths in a different way than 
CloseHandle(). Make sure we have tests that do abnormal termination. 


*/

//
// Public functions.
//

/***************************************************************************++

Routine Description:

    This is the routine that handles Cleanup IRPs in UL. Cleanup IRPs
    are issued after the last handle to the file object is closed.

Arguments:

    pDeviceObject - Supplies a pointer to the target device object.

    pIrp - Supplies a pointer to IO request packet.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlCleanup(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    )
{
    NTSTATUS status;
    PIO_STACK_LOCATION pIrpSp;

    UL_ENTER_DRIVER( "UlCleanup", pIrp );

    //
    // Snag the current IRP stack pointer.
    //

    pIrpSp = IoGetCurrentIrpStackLocation( pIrp );

    //
    // app pool or control channel?
    //

    if (pDeviceObject == g_pUlAppPoolDeviceObject &&
        IS_APP_POOL( pIrpSp->FileObject ))
    {
        //
        // App pool, let's detach this process from the app pool.
        // The detach will also take care of the Irp completion
        // for us.
        //

        UlTrace(OPEN_CLOSE,(
                "UlCleanup: cleanup on AppPool object %p\n",
                pIrpSp->FileObject
                ));

        status = UlDetachProcessFromAppPool( pIrp, pIrpSp );

        UL_LEAVE_DRIVER("UlCleanup");
        RETURN(status); 
    }

    if (pDeviceObject == g_pUlFilterDeviceObject &&
             IS_FILTER_PROCESS( pIrpSp->FileObject ))
    {
        //
        // filter channel
        //

        UlTrace(OPEN_CLOSE,(
                "UlCleanup: cleanup on FilterProcess object %p\n",
                pIrpSp->FileObject
                ));

        status = UlDetachFilterProcess(
                        GET_FILTER_PROCESS(pIrpSp->FileObject)
                        );

        MARK_INVALID_FILTER_CHANNEL( pIrpSp->FileObject );
    }
    else if (pDeviceObject == g_pUlControlDeviceObject && 
             IS_CONTROL_CHANNEL( pIrpSp->FileObject ))
    {
        PUL_CONTROL_CHANNEL pControlChannel =
            GET_CONTROL_CHANNEL( pIrpSp->FileObject );
        
        UlTrace(OPEN_CLOSE,(
                "UlCleanup: cleanup on ControlChannel object %p, %p\n",
                pIrpSp->FileObject,pControlChannel
                ));

        MARK_INVALID_CONTROL_CHANNEL( pIrpSp->FileObject );
        
        UlCleanUpControlChannel( pControlChannel );

        status = STATUS_SUCCESS;
    }
    else if (pDeviceObject == g_pUcServerDeviceObject && 
             IS_SERVER( pIrpSp->FileObject ))
    {
        UlTrace(OPEN_CLOSE,(
                "UlCleanup: cleanup on Server object %p\n",
                pIrpSp->FileObject
                ));

        MARK_INVALID_SERVER( pIrpSp->FileObject );

        status = STATUS_SUCCESS;
    }
    else
    {
        UlTrace(OPEN_CLOSE,(
                "UlCleanup: cleanup on invalid object %p\n",
                pIrpSp->FileObject
                ));

        status = STATUS_INVALID_DEVICE_REQUEST;
    }

    pIrp->IoStatus.Status = status;

    UlCompleteRequest( pIrp, IO_NO_INCREMENT );

    UL_LEAVE_DRIVER( "UlCleanup" );
    RETURN(status);

}   // UlCleanup


/***************************************************************************++

Routine Description:

    This is the routine that handles Close IRPs in UL. Close IRPs are
    issued after the last reference to the file object is removed.

    Once the close IRP is called, it is guaranteed by IO Manager that no
    other IOCTL call will happen for the object we are about to close.
    Therefore actual cleanup for the object must happen at this time,
    but * not * at the cleanup time.
    
Arguments:

    pDeviceObject - Supplies a pointer to the target device object.

    pIrp - Supplies a pointer to IO request packet.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlClose(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    )
{

    NTSTATUS status;
    PIO_STACK_LOCATION pIrpSp;

    UNREFERENCED_PARAMETER( pDeviceObject );

    //
    // Sanity check.
    //

    PAGED_CODE();
    UL_ENTER_DRIVER( "UlClose", pIrp );

    status = STATUS_SUCCESS;

    //
    // Snag the current IRP stack pointer.
    //

    pIrpSp = IoGetCurrentIrpStackLocation( pIrp );

    //
    // We have to delete the associated object.
    //
    if (pDeviceObject == g_pUlAppPoolDeviceObject &&
        IS_EX_APP_POOL( pIrpSp->FileObject ))
    {
        UlTrace(OPEN_CLOSE, (
            "UlClose: closing AppPool object %p\n",
            pIrpSp->FileObject
            ));

        UlCloseAppPoolProcess(GET_APP_POOL_PROCESS(pIrpSp->FileObject));
    }
    else if (pDeviceObject == g_pUlFilterDeviceObject &&
             IS_EX_FILTER_PROCESS( pIrpSp->FileObject ))
    {
        UlTrace(OPEN_CLOSE, (
            "UlClose: closing Filter object %p\n",
            pIrpSp->FileObject
            ));

        UlCloseFilterProcess(GET_FILTER_PROCESS(pIrpSp->FileObject));
    }
    else if (pDeviceObject == g_pUcServerDeviceObject && 
             IS_EX_SERVER(pIrpSp->FileObject ))
    {
        PUC_PROCESS_SERVER_INFORMATION pServInfo;

        pServInfo = (PUC_PROCESS_SERVER_INFORMATION)
                        pIrpSp->FileObject->FsContext;

        UlTrace(OPEN_CLOSE, (
            "UlClose: closing Server object %p, %p\n",
            pIrpSp->FileObject, pServInfo
            ));

        //
        // Free our context.
        //
        UcCloseServerInformation(pServInfo);
    }
    else if (pDeviceObject == g_pUlControlDeviceObject && 
             IS_EX_CONTROL_CHANNEL( pIrpSp->FileObject ))
    {
        PUL_CONTROL_CHANNEL pControlChannel =
            GET_CONTROL_CHANNEL( pIrpSp->FileObject );
    
        UlTrace(OPEN_CLOSE, (
            "UlClose: closing control channel object %p, %p\n",
            pIrpSp->FileObject, pControlChannel
            ));

        UlCloseControlChannel( pControlChannel );
    }    
    else
    {
        ASSERT(!"Invalid Device Object !");
    }

    pIrp->IoStatus.Status = status;

    UlCompleteRequest( pIrp, IO_NO_INCREMENT );

    UL_LEAVE_DRIVER( "UlClose" );
    RETURN(status);

}   // UlClose
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\config.h ===
/*++

Copyright (c) 1998-2002 Microsoft Corporation

Module Name:

    config.h

Abstract:

    This module contains global configuration constants.

Author:

    Keith Moore (keithmo)       10-Jun-1998

Revision History:

--*/


#ifndef _CONFIG_H_
#define _CONFIG_H_


//
// Set REFERENCE_DEBUG to a non-zero value to enable ref trace logging.
//
// Set USE_FREE_POOL_WITH_TAG to a non-zero value to enable use of
// the new-for-NT5 ExFreePoolWithTag() API.
//
// Set ENABLE_IRP_TRACE to a non-zero value to enable IRP tracing.
//
// Set ENABLE_TIME_TRACE to a non-zero value to enable time tracing.
//
// Set TRACE_TO_STRING_LOG to have all UlTrace output written to an
// in-memory STRING_LOG instead of to the debug port (DBG only).
//
// Set ENABLE_TC_STATS to a non-zero value to ...
//
// Set ENABLE_MDL_TRACKER to a non-zero value to ...
//

#if DBG
#define REFERENCE_DEBUG                 1
#define ENABLE_THREAD_DBEUG             0
#define ENABLE_IRP_TRACE                0
#define ENABLE_TIME_TRACE               0
#define ENABLE_APP_POOL_TIME_TRACE      1
#define ENABLE_HTTP_CONN_STATS          1
#define TRACE_TO_STRING_LOG             0
#define ENABLE_TC_STATS                 1
#define ENABLE_MDL_TRACKER              0
#else   // !DBG
#define REFERENCE_DEBUG                 0
#define ENABLE_THREAD_DBEUG             0
#define ENABLE_IRP_TRACE                0
#define ENABLE_TIME_TRACE               0
#define ENABLE_APP_POOL_TIME_TRACE      0
#define ENABLE_TC_STATS                 0
#define ENABLE_MDL_TRACKER              0
#endif  // !DBG

#define USE_FREE_POOL_WITH_TAG  0


//
// ENABLE_*_TRACE flags require REFERENCE_DEBUG to get the logging
// stuff. Enforce this here.
//

#if (ENABLE_TIME_TRACE || ENABLE_IRP_TRACE) && !REFERENCE_DEBUG
#undef REFERENCE_DEBUG
#define REFERENCE_DEBUG 1
#endif


//
// Define the additional formal and actual parameters used for the
// various Reference/Dereference functions when reference debugging
// is enabled.
//

#if REFERENCE_DEBUG

#define REFERENCE_DEBUG_FORMAL_PARAMS ,PCSTR pFileName,USHORT LineNumber
#define REFERENCE_DEBUG_ACTUAL_PARAMS ,(PCSTR)__FILE__,(USHORT)__LINE__

#else   // !REFERENCE_DEBUG

#define REFERENCE_DEBUG_FORMAL_PARAMS
#define REFERENCE_DEBUG_ACTUAL_PARAMS

#endif  // REFERENCE_DEBUG


#if USE_FREE_POOL_WITH_TAG

# define MAKE_POOL_TAG(tag)   ( REVERSE_CHAR_CONSTANT(tag) | PROTECTED_POOL )
# define MyFreePoolWithTag(a,t) ExFreePoolWithTag(a,t)

#else   // !USE_FREE_POOL_WITH_TAG

# define MAKE_POOL_TAG(tag)   ( REVERSE_CHAR_CONSTANT(tag) )
# define MyFreePoolWithTag(a,t) ExFreePool(a)

#endif  // USE_FREE_POOL_WITH_TAG

#include <PoolTag.h>

//
// UL_RESOURCE and UL_PUSH_LOCK tags. These are NOT passed to
// UL_ALLOCATE_POOL*() and should not appear in .\pooltag.txt.
//

#define UC_SERVINFO_PUSHLOCK_TAG            MAKE_SIGNATURE( 'UcSp' )
#define UL_APP_POOL_RESOURCE_TAG            MAKE_SIGNATURE( 'UlAR' )
#define UL_CG_RESOURCE_TAG                  MAKE_SIGNATURE( 'UlCq' )
#define UL_CONTROL_CHANNEL_PUSHLOCK_TAG     MAKE_SIGNATURE( 'UlCc' )
#define UL_DATE_HEADER_PUSHLOCK_TAG         MAKE_SIGNATURE( 'UlDH' )
#define UL_DISCONNECT_RESOURCE_TAG          MAKE_SIGNATURE( 'UlDq' )
#define UL_HTTP_CONNECTION_PUSHLOCK_TAG     MAKE_SIGNATURE( 'UlHq' )
#define UL_INTERNAL_RESPONSE_PUSHLOCK_TAG   MAKE_SIGNATURE( 'UlIr' )
#define UL_LOG_LIST_PUSHLOCK_TAG            MAKE_SIGNATURE( 'UlLR' )
#define UL_PSCHED_STATE_PUSHLOCK_TAG        MAKE_SIGNATURE( 'UlQP' )
#define UL_TCI_PUSHLOCK_TAG                 MAKE_SIGNATURE( 'UlQR' )
#define UL_ZOMBIE_RESOURCE_TAG              MAKE_SIGNATURE( 'UlZR' )


//
// Registry paths.
// If you change or add a setting, please update the ConfigTable
// in ..\util\tul.c.
//

#define REGISTRY_PARAMETERS                     L"Parameters"
#define REGISTRY_UL_INFORMATION                 L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Http"
#define REGISTRY_IIS_INFORMATION                L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Inetinfo"

#define REGISTRY_URLACL_INFORMATION             REGISTRY_UL_INFORMATION L"\\Parameters\\UrlAclInfo"
#define REGISTRY_COMPUTER_NAME_PATH             L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\ComputerName"
#define REGISTRY_COMPUTER_NAME                  L"ComputerName"
#define REGISTRY_NLS_PATH                       L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Nls"
#define REGISTRY_NLS_CODEPAGE_KEY               L"CodePage"
#define REGISTRY_ACP_NAME                       L"ACP"
#define REGISTRY_DEBUG_FLAGS                    L"DebugFlags"
#define REGISTRY_BREAK_ON_STARTUP               L"BreakOnStartup"
#define REGISTRY_BREAK_ON_ERROR                 L"BreakOnError"
#define REGISTRY_VERBOSE_ERRORS                 L"VerboseErrors"
#define REGISTRY_IDLE_CONNECTIONS_HIGH_MARK     L"IdleConnectionsHighMark"
#define REGISTRY_IDLE_CONNECTIONS_LOW_MARK      L"IdleConnectionsLowMark"
#define REGISTRY_IDLE_LIST_TRIMMER_PERIOD       L"IdleListTrimmerPeriod"
#define REGISTRY_MAX_ENDPOINTS                  L"MaxEndpoints"
#define REGISTRY_IRP_CONTEXT_LOOKASIDE_DEPTH    L"IrpContextLookasideDepth"
#define REGISTRY_RCV_BUFFER_SIZE                L"ReceiveBufferSize"
#define REGISTRY_RCV_BUFFER_LOOKASIDE_DEPTH     L"ReceiveBufferLookasideDepth"
#define REGISTRY_RESOURCE_LOOKASIDE_DEPTH       L"ResourceLookasideDepth"
#define REGISTRY_REQ_BUFFER_LOOKASIDE_DEPTH     L"RequestBufferLookasideDepth"
#define REGISTRY_INT_REQUEST_LOOKASIDE_DEPTH    L"InternalRequestLookasideDepth"
#define REGISTRY_RESP_BUFFER_SIZE               L"ResponseBufferSize"
#define REGISTRY_RESP_BUFFER_LOOKASIDE_DEPTH    L"ResponseBufferLookasideDepth"
#define REGISTRY_SEND_TRACKER_LOOKASIDE_DEPTH   L"SendTrackerLookasideDepth"
#define REGISTRY_LOG_BUFFER_LOOKASIDE_DEPTH     L"LogBufferLookasideDepth"
#define REGISTRY_LOG_DATA_BUFFER_LOOKASIDE_DEPTH  L"LogDataBufferLookasideDepth"
#define REGISTRY_MAX_INTERNAL_URL_LENGTH        L"MaxInternalUrlLength"
#define REGISTRY_MAX_REQUESTS_QUEUED            L"MaxRequestsQueued"
#define REGISTRY_MAX_REQUEST_BYTES              L"MaxRequestBytes"
#define REGISTRY_MAX_FIELD_LENGTH               L"MaxFieldLength"
#define REGISTRY_OPT_FOR_INTR_MOD               L"OptimizeForInterruptModeration"
#define REGISTRY_ENABLE_NAGLING                 L"EnableNagling"
#define REGISTRY_ENABLE_THREAD_AFFINITY         L"EnableThreadAffinity"
#define REGISTRY_THREAD_AFFINITY_MASK           L"ThreadAffinityMask"
#define REGISTRY_THREADS_PER_CPU                L"ThreadsPerCpu"
#define REGISTRY_MAX_WORK_QUEUE_DEPTH           L"MaxWorkQueueDepth"
#define REGISTRY_MIN_WORK_DEQUEUE_DEPTH         L"MinWorkDequeueDepth"
#define REGISTRY_MAX_COPY_THRESHOLD             L"MaxCopyThreshold"
#define REGISTRY_MAX_BUFFERED_SENDS             L"MaxBufferedSends"
#define REGISTRY_MAX_BYTES_PER_SEND             L"MaxBytesPerSend"
#define REGISTRY_MAX_BYTES_PER_READ             L"MaxBytesPerRead"
#define REGISTRY_MAX_PIPELINED_REQUESTS         L"MaxPipelinedRequests"
#define REGISTRY_ENABLE_COPY_SEND               L"EnableCopySend"
#define REGISTRY_MAX_CONNECTIONS                L"MaxConnections"
#define REGISTRY_CONNECTION_SEND_LIMIT          L"ConnectionSendLimit"
#define REGISTRY_GLOBAL_SEND_LIMIT              L"GlobalSendLimit"
#define REGISTRY_OPAQUE_ID_TABLE_SIZE           L"OpaqueIdTableSize"
#define REGISTRY_DISABLE_LOG_BUFFERING          L"DisableLogBuffering"
#define REGISTRY_LOG_BUFFER_SIZE                L"LogBufferSize"
#define REGISTRY_DISABLE_SERVER_HEADER          L"DisableServerHeader"
#define REGISTRY_ERROR_LOGGING_ENABLED          L"EnableErrorLogging"
#define REGISTRY_ERROR_LOGGING_TRUNCATION_SIZE  L"ErrorLogFileTruncateSize"
#define REGISTRY_ERROR_LOGGING_DIRECTORY        L"ErrorLoggingDir"


#define REGISTRY_ENABLE_NON_UTF8_URL            L"EnableNonUTF8"
#define REGISTRY_FAVOR_UTF8_URL                 L"FavorUTF8"
#define REGISTRY_PERCENT_U_ALLOWED              L"PercentUAllowed"
#define REGISTRY_ALLOW_RESTRICTED_CHARS         L"AllowRestrictedChars"
#define REGISTRY_URL_SEGMENT_MAX_LENGTH         L"UrlSegmentMaxLength"
#define REGISTRY_URL_SEGMENT_MAX_COUNT          L"UrlSegmentMaxCount"

#define REGISTRY_CACHE_ENABLED                  L"UriEnableCache"
#define REGISTRY_MAX_CACHE_URI_COUNT            L"UriMaxCacheUriCount"
#define REGISTRY_MAX_CACHE_MEGABYTE_COUNT       L"UriMaxCacheMegabyteCount"
#define REGISTRY_CACHE_SCAVENGER_PERIOD         L"UriScavengerPeriod"
#define REGISTRY_MAX_URI_BYTES                  L"UriMaxUriBytes"
#define REGISTRY_HASH_TABLE_BITS                L"HashTableBits"

#define REGISTRY_MAX_ZOMBIE_HTTP_CONN_COUNT     L"MaxZombieHttpConnectionCount"

#define REGISTRY_HTTP_CLIENT_ENABLED            L"EnableHttpClient"

// List of addresses to override INADDR_ANY/in6addr_any (REG_MULTI_SZ)
#define REGISTRY_LISTEN_ONLY_LIST               L"ListenOnlyList"

// Amount of memory to free on each low memory event
#define REGISTRY_SCAVENGER_TRIM_MB              L"ScavengerTrimMB"

// Foward declaration; defined in data.h
typedef struct _UL_CONFIG *PUL_CONFIG;


//
// IO parameters.
//

#define DEFAULT_IRP_STACK_SIZE              4


//
// Debugging parameters.
//

#define DEFAULT_DEBUG_FLAGS                 0x0000000000000000ui64
#define DEFAULT_BREAK_ON_STARTUP            FALSE
#define DEFAULT_BREAK_ON_ERROR              FALSE
#define DEFAULT_VERBOSE_ERRORS              FALSE
#define DEFAULT_ENABLE_SECURITY             TRUE


//
// URI Cache parameters.
//

#define DEFAULT_CACHE_ENABLED               1           /* enabled by default */
#define DEFAULT_MAX_CACHE_URI_COUNT         0           /* max cache entries: 0 => none*/
#define DEFAULT_MAX_CACHE_MEGABYTE_COUNT    0           /* adaptive limit by default */
#define DEFAULT_CACHE_SCAVENGER_PERIOD      120         /* two-minute scavenger */
#define DEFAULT_MAX_URI_BYTES               (256*1024)  /* 256KB per entry */
#define DEFAULT_HASH_TABLE_BITS             (-1)        /* -1: determined by system mem size later */

#define DEFAULT_HTTP_CLIENT_ENABLED         0           /* client http stack */


//
// Queueing and timeouts
//

#define DEFAULT_APP_POOL_QUEUE_MAX          3000


//
// Miscellaneous
//

#define POOL_VERIFIER_OVERHEAD  16  // no extra page allocation with verifier on
#define UL_PAGE_SIZE            (PAGE_SIZE - POOL_VERIFIER_OVERHEAD)


//
// Server header config
// 0 - Enable Server Header
// 1 - Disable Server Header for driver generated responses (400, 503, etc.)
// 2 - Disable Server Header on all responses
//
// Algorithm for generating the Server: header:
//
// If (DisableServerHeader != 2)
// {
//    if (Driver-generated response)
//    {
//        if (DisableServerHeader != 1)
//        {
//            Set header to "Server: Microsoft-HTTPAPI/1.0"
//        }
//        else
//        {
//            Suppress "Server: " header completely in response;
//        }
//    }
//    else // Application-generated response
//    {
//        If (Application specifies a HttpHeaderServer string AppServerName in its response)
//        {
//            Set header to "Server: AppServerName Microsoft-HTTPAPI/1.0"
//        }
//        else if (Application requests that the header be suppressed) 
//        {
//            Suppress "Server: " header completely in response;
//        }
//        else
//        {
//            // Application did not set the header, i.e. it is NULL
//            Set header to "Server: Microsoft-HTTP/1.0"
//        }
//}
//else
//{
//    // Server header generation disabled globally via registry
//    Suppress "Server: " header completely in response;
//}
//
//

#define UL_ENABLE_SERVER_HEADER             0
#define UL_DISABLE_SERVER_HEADER_DRIVER     1
#define UL_DISABLE_SERVER_HEADER_ALL        2
#define DEFAULT_DISABLE_SERVER_HEADER   UL_ENABLE_SERVER_HEADER

//
// Other parameters.
//

#define DEFAULT_IDLE_CONNECTIONS_HIGH_MARK      0
#define DEFAULT_IDLE_CONNECTIONS_LOW_MARK       0
#define DEFAULT_IDLE_LIST_TRIMMER_PERIOD        30
#define DEFAULT_MAX_ENDPOINTS                   0
#define DEFAULT_LOOKASIDE_DEPTH                 64
#define DEFAULT_IRP_CONTEXT_LOOKASIDE_DEPTH     64
#define DEFAULT_RCV_BUFFER_SIZE                 (8192-POOL_VERIFIER_OVERHEAD)
#define DEFAULT_RCV_BUFFER_LOOKASIDE_DEPTH      64
#define DEFAULT_RESOURCE_LOOKASIDE_DEPTH        32
#define DEFAULT_REQ_BUFFER_LOOKASIDE_DEPTH      64
#define DEFAULT_INT_REQUEST_LOOKASIDE_DEPTH     64
#define DEFAULT_RESP_BUFFER_LOOKASIDE_DEPTH     64
#define DEFAULT_RESP_BUFFER_SIZE                0
#define DEFAULT_SEND_TRACKER_LOOKASIDE_DEPTH    64
#define DEFAULT_LOG_BUFFER_LOOKASIDE_DEPTH      16
#define DEFAULT_LOG_DATA_BUFFER_LOOKASIDE_DEPTH 64
#define DEFAULT_ERROR_LOG_BUFFER_LOOKASIDE_DEPTH 64
#define DEFAULT_MAX_REQUESTS_QUEUED             (64*1024)
#define DEFAULT_MAX_REQUEST_BYTES               (16*1024)
#define DEFAULT_OPT_FOR_INTR_MOD                FALSE
#define DEFAULT_ENABLE_NAGLING                  FALSE
#define DEFAULT_ENABLE_THREAD_AFFINITY          FALSE
#define DEFAULT_THREADS_PER_CPU                 1
#define DEFAULT_MAX_WORK_QUEUE_DEPTH            1
#define DEFAULT_MIN_WORK_DEQUEUE_DEPTH          1
#define DEFAULT_MAX_FIELD_LENGTH                (16*1024)
#define DEFAULT_ENABLE_NON_UTF8_URL             DEFAULT_C14N_ENABLE_NON_UTF8_URL
#define DEFAULT_FAVOR_UTF8_URL                  DEFAULT_C14N_FAVOR_UTF8_URL
#define DEFAULT_PERCENT_U_ALLOWED               DEFAULT_C14N_PERCENT_U_ALLOWED
#define DEFAULT_ALLOW_RESTRICTED_CHARS          DEFAULT_C14N_ALLOW_RESTRICTED_CHARS
#define DEFAULT_URL_SEGMENT_MAX_LENGTH          DEFAULT_C14N_URL_SEGMENT_MAX_LENGTH
#define DEFAULT_URL_SEGMENT_MAX_COUNT           DEFAULT_C14N_URL_SEGMENT_MAX_COUNT
#define DEFAULT_MAX_REQUEST_BUFFER_SIZE         512
#define DEFAULT_MAX_INTERNAL_URL_LENGTH         256
#define DEFAULT_MAX_ROUTING_TOKEN_LENGTH        272
#define DEFAULT_MAX_UNKNOWN_HEADERS             8
#define DEFAULT_MAX_IRP_STACK_SIZE              8
#define DEFAULT_MAX_FIXED_HEADER_SIZE           1024
#define DEFAULT_MAX_CONNECTION_ACTIVE_LISTS     64
#define DEFAULT_LARGE_MEM_MEGABYTES             (-1)
#define DEFAULT_MAX_BUFFERED_BYTES              (16*1024)
#define DEFAULT_MAX_COPY_THRESHOLD              2048
#define DEFAULT_MAX_BUFFERED_SENDS              (4)
#define DEFAULT_MAX_BYTES_PER_SEND              (64*1024)
#define DEFAULT_MAX_BYTES_PER_READ              (64*1024)
#define DEFAULT_ENABLE_COPY_SEND                FALSE
#define DEFAULT_MAX_PIPELINED_REQUESTS          2
#define DEFAULT_CONNECTION_SEND_LIMIT           (128*1024)
#define DEFAULT_GLOBAL_SEND_LIMIT               0
#define DEFAULT_OPAQUE_ID_TABLE_SIZE            1024
#define DEFAULT_DISABLE_LOG_BUFFERING           FALSE
#define DEFAULT_LOG_BUFFER_SIZE                 0
#define DEFAULT_MAX_ZOMBIE_HTTP_CONN_COUNT      (128)
#define DEFAULT_SCAVENGER_TRIM_MB               0
#define DEFAULT_ENABLE_ERROR_LOGGING            TRUE
#define DEFAULT_DEMAND_START_THRESHOLD          400
#define DEFAULT_ERROR_FILE_TRUNCATION_SIZE      (1 * 1024 * 1024)  
#define DEFAULT_MIN_ERROR_FILE_TRUNCATION_SIZE  (HTTP_MIN_ALLOWED_TRUNCATE_SIZE_FOR_LOG_FILE)

//
// The default error logging directory is always under %SystemRoot%
//

#define DEFAULT_ERROR_LOGGING_DIR               L"\\SystemRoot\\System32\\LogFiles"

C_ASSERT(DEFAULT_MAX_FIELD_LENGTH <= DEFAULT_MAX_REQUEST_BYTES);

#define MAX_THREADS_PER_CPU                     4

//
// DBCS Code page constants as currently listed on
// http://www.microsoft.com/globaldev/reference/WinCP.asp
//
// 932 (Japanese Shift-JIS) 
// 936 (Simplified Chinese GBK) 
// 949 (Korean) 
// 950 (Traditional Chinese Big5) 
//
#define CP_JAPANESE_SHIFT_JIS                   932
#define CP_SIMPLIFIED_CHINESE_GBK               936
#define CP_KOREAN                               949
#define CP_TRADITIONAL_CHINESE_BIG5             950

#endif  // _CONFIG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\cgroupp.h ===
/*++

Copyright (c) 1998-2002 Microsoft Corporation

Module Name:

    CGroupP.h

Abstract:

    The private definitions of config group module.

Author:

    Paul McDaniel (paulmcd)       11-Jan-1999


Revision History:

--*/


#ifndef _CGROUPP_H_
#define _CGROUPP_H_


//
// The tree.
//
// This is used to do all url prefix matching to decide what app pool
// a url lives in, along with other config group information.
//
// it's a sorted tree made up of 2 data structures: HEADER + ENTRY.
//
// a header is an array of ENTRY pointers that represent siblings
// at a level in the tree.  This is sorted by ENTRY::TokenLength.  the
// pointers are seperately allocated, and not embedded in the HEADER
// memory.
//
// ENTRY represents a node in the tree.  there are 2 types of ENTRY's.
// FullUrl ENTRY's and "dummy" entries.  Dummy ENTRY's exist simple as
// place holders.  they have children that are FullUrl ENTRY's.  they
// are auto-deleted when they are no longer needed.
//
// each ENTRY stores in it the part of the url it is responsible for.
// this is pToken.  For all non-site entries this is the string without
// the preceding '/' or the trailing '/'.  for top level site ENTRY's
// it is everything up the, and not including, the 3rd '/'.
// e.g. "http://www.microsoft.com:80".  These top level sites also
// have NULL ENTRY::pParent.
//
// a tree with these url's in it:
//
//      http://www.microsoft.com:80/
//      http://www.microsoft.com:80/app1
//      http://www.microsoft.com:80/app1/app2
//      http://www.microsoft.com:80/dir1/dir2/app3
//
//      http://www.msnbc.com:80/dir1/dir2/app1
//
// looks like this:
//
//  +-------------------------------------------------------------+
//  |   +---------------------------+   +-----------------------+ |
//  |   |http://www.microsoft.com:80|   |http://www.msnbc.com:80| |
//  |   +---------------------------+   +-----------------------+ |
//  +-------------------------------------------------------------+
//                 |                               |
//      +-------------------+                 +----------+
//      | +----+     +----+ |                 |  +----+  |
//      | |app1|     |dir1| |                 |  |dir1|  |
//      | +----+     +----+ |                 |  +----+  |
//      +-------------------+                 +----------+
//           |         |                           |
//      +--------+ +--------+                 +----------+
//      | +----+ | | +----+ |                 |  +----+  |
//      | |app2| | | |dir2| |                 |  |dir2|  |
//      | +----+ | | +----+ |                 |  +----+  |
//      +--------+ +--------+                 +----------+
//                     |                           |
//                 +--------+                 +----------+
//                 | +----+ |                 |  +----+  |
//                 | |app3| |                 |  |app3|  |
//                 | +----+ |                 |  +----+  |
//                 +--------+                 +----------+
//
//  and this:
//
//      g_pSites->UsedCount == 2;
//      g_pSites->ppEntries[0] == 0x10;
//      g_pSites->ppEntries[1] == 0x20;
//
//      0x10->pParent       == NULL;
//      0x10->pChildren     == 0x100;
//      0x10->TokenLength   == 0x0036;
//      0x10->FullUrl       == 1;
//      0x10->pToken        == L"http://www.microsoft.com:80"
//
//          0x100->UsedCount    == 2;
//          0x100->ppEntries[0] == 0x110;
//          0x100->ppEntries[1] == 0x300;
//
//          0x110->pParent       == 0x10;
//          0x110->pChildren     == 0x200;
//          0x110->TokenLength   == 0x0008;
//          0x110->FullUrl       == 1;
//          0x110->pToken        == L"app1"
//
//              0x200->UsedCount    == 1;
//              0x200->ppEntries[0] == 0x210;
//
//              0x210->pParent       == 0x110;
//              0x210->pChildren     == NULL;
//              0x210->TokenLength   == 0x0008;
//              0x210->FullUrl       == 1;
//              0x210->pToken        == L"app2"
//
//          0x300->pParent       == 0x10;
//          0x300->pChildren     == 0x400;
//          0x300->TokenLength   == 0x0008;
//          0x300->FullUrl       == 0;
//          0x300->pToken        == L"dir1"
//
//              0x400->UsedCount    == 1;
//              0x400->ppEntries[0] == 0x410;
//
//              0x410->pParent       == 0x300;
//              0x410->pChildren     == 0x500;
//              0x410->TokenLength   == 0x0008;
//              0x410->FullUrl       == 0;
//              0x410->pToken        == L"dir2"
//
//                  0x500->UsedCount    == 1;
//                  0x500->ppEntries[0] == 0x510;
//
//                  0x510->pParent       == 0x300;
//                  0x510->pChildren     == NULL;
//                  0x510->TokenLength   == 0x0008;
//                  0x510->FullUrl       == 1;
//                  0x510->pToken        == L"app3"
//
//      0x20->pParent       == NULL;
//      0x20->pChildren     == 0x600;
//      0x20->TokenLength   == 0x002E;
//      0x20->FullUrl       == 0;
//      0x20->pToken        == L"http://www.msnbc.com:80"
//
//          0x600->pParent       == 0x20;
//          0x600->pChildren     == 0x700;
//          0x600->TokenLength   == 0x0008;
//          0x600->FullUrl       == 0;
//          0x600->pToken        == L"dir1"
//
//              0x700->UsedCount    == 1;
//              0x700->ppEntries[0] == 0x710;
//
//              0x710->pParent       == 0x600;
//              0x710->pChildren     == 0x800;
//              0x710->TokenLength   == 0x0008;
//              0x710->FullUrl       == 0;
//              0x710->pToken        == L"dir2"
//
//                  0x800->UsedCount    == 1;
//                  0x800->ppEntries[0] == 0x810;
//
//                  0x810->pParent       == 0x710;
//                  0x810->pChildren     == NULL;
//                  0x810->TokenLength   == 0x0008;
//                  0x810->FullUrl       == 1;
//                  0x810->pToken        == L"app1"
//
//

typedef struct _UL_DEFERRED_REMOVE_ITEM
UL_DEFERRED_REMOVE_ITEM, *PUL_DEFERRED_REMOVE_ITEM;

typedef struct _UL_CG_URL_TREE_HEADER
UL_CG_URL_TREE_HEADER, * PUL_CG_URL_TREE_HEADER;

typedef struct _UL_CG_URL_TREE_ENTRY
UL_CG_URL_TREE_ENTRY, * PUL_CG_URL_TREE_ENTRY;


#define IS_VALID_TREE_ENTRY(pObject)                        \
    HAS_VALID_SIGNATURE(pObject, UL_CG_TREE_ENTRY_POOL_TAG)


typedef struct _UL_CG_URL_TREE_ENTRY
{

    //
    // PagedPool
    //

    //
    // base properties for dummy nodes
    //

    ULONG                   Signature;      // UL_CG_TREE_ENTRY_POOL_TAG

    PUL_CG_URL_TREE_ENTRY   pParent;        // points to the parent entry
    PUL_CG_URL_TREE_HEADER  pChildren;      // points to the child header

    ULONG                   TokenLength;    // byte count of pToken

    BOOLEAN                 Reservation;    // a reservation ?
    BOOLEAN                 Registration;   // a registration ?  
                                            // Formally known as FullUrl.

    //
    // if the site has been successfully added to the endpoint list
    //

    BOOLEAN                  SiteAddedToEndpoint;
    PUL_DEFERRED_REMOVE_ITEM pRemoveSiteWorkItem;

    //
    // type of entry (name, ip or wildcard)
    //

    HTTP_URL_SITE_TYPE      UrlType;


    //
    // extended properties for full nodes
    //

    HTTP_URL_CONTEXT        UrlContext;             // context for this url
    PUL_CONFIG_GROUP_OBJECT pConfigGroup;           // the cfg group for the url
    LIST_ENTRY              ConfigGroupListEntry;   // links into pConfigGroup

    //
    // security descriptor (for reservations)
    //

    PSECURITY_DESCRIPTOR    pSecurityDescriptor;
    LIST_ENTRY              ReservationListEntry;

    //
    // the token string follows the struct header
    //

    WCHAR                   pToken[0];


} UL_CG_URL_TREE_ENTRY, * PUL_CG_URL_TREE_ENTRY;

//
// this allows us to duplicate the hash value of the entry
// inline with the header.  this makes the search faster as
// the hash value is in the cache line and no pointer deref
// is necessary.
//

typedef struct _UL_CG_HEADER_ENTRY
{
    PUL_CG_URL_TREE_ENTRY   pEntry;

} UL_CG_HEADER_ENTRY, *PUL_CG_HEADER_ENTRY;


#define IS_VALID_TREE_HEADER(pObject)                           \
    HAS_VALID_SIGNATURE(pObject, UL_CG_TREE_HEADER_POOL_TAG)


typedef struct _UL_CG_URL_TREE_HEADER
{

    //
    // PagedPool
    //

    ULONG                   Signature;      // UL_CG_TREE_HEADER_POOL_TAG

    ULONG                   AllocCount;     // the count of allocated space
    ULONG                   UsedCount;      // how many entries are used

    LONG                    NameSiteCount;      // how many sites are name based
    LONG                    IPSiteCount;        // how many sites are IPv4 or IPV6 based
    LONG                    StrongWildcardCount;// how many sites are strong wildcards
    LONG                    WeakWildcardCount;  // how many sites are weak wildcards
    LONG                    NameIPSiteCount;    // how many sites are name based and IP Bound

    UL_CG_HEADER_ENTRY      pEntries[0];    // the entries

} UL_CG_URL_TREE_HEADER, * PUL_CG_URL_TREE_HEADER;


//
// default settings, CODEWORK move these to the registry ?
//

#define UL_CG_DEFAULT_TREE_WIDTH    10  // used to initially allocate sibling
                                        // arrays + the global site array
                                        //


//
// Global list of reservations.
//

extern LIST_ENTRY g_ReservationListHead;

//
// Private macros
//

#define IS_CG_LOCK_OWNED_WRITE() \
    (UlDbgResourceOwnedExclusive(&g_pUlNonpagedData->ConfigGroupResource))


//
// Find node criteria.
//

#define FNC_DONT_CARE            0
#define FNC_LONGEST_RESERVATION  1
#define FNC_LONGEST_REGISTRATION 2
#define FNC_LONGEST_EITHER       (FNC_LONGEST_RESERVATION       \
                                  | FNC_LONGEST_REGISTRATION)


//
// Internal helper functions used in the module
//

//
// misc helpers
//

NTSTATUS
UlpCreateConfigGroupObject(
    OUT PUL_CONFIG_GROUP_OBJECT * ppObject
    );

NTSTATUS
UlpCleanAllUrls(
    IN PUL_CONFIG_GROUP_OBJECT pObject
    );

VOID
UlpDeferredRemoveSite(
    IN PUL_CG_URL_TREE_ENTRY pEntry
    );

VOID
UlpDeferredRemoveSiteWorker(
    IN PUL_WORK_ITEM pWorkItem
    );

NTSTATUS
UlpExtractSchemeHostPortIp(
    IN  PWSTR  pUrl,
    OUT PULONG pCharCount
    );

//
// tree helpers
//

NTSTATUS
UlpTreeFindNodeHelper(
    IN  PUL_CG_URL_TREE_ENTRY   pSiteEntry,
    IN  PWSTR                   pNextToken,
    IN  ULONG                   Criteria      OPTIONAL,
    OUT PUL_CG_URL_TREE_ENTRY * ppMatchEntry  OPTIONAL,
    OUT PUL_CG_URL_TREE_ENTRY * ppExactEntry
    );

NTSTATUS
UlpTreeFindNodeWalker(
    IN     PUL_CG_URL_TREE_ENTRY       pEntry,
    IN     PWSTR                       pNextToken,
    IN OUT PUL_URL_CONFIG_GROUP_INFO   pInfo       OPTIONAL,
    OUT    PUL_CG_URL_TREE_ENTRY     * ppEntry     OPTIONAL
    );

NTSTATUS
UlpTreeFindNode(
    IN  PWSTR pUrl,
    IN  PUL_INTERNAL_REQUEST pRequest OPTIONAL,
    OUT PUL_URL_CONFIG_GROUP_INFO pInfo OPTIONAL,
    OUT PUL_CG_URL_TREE_ENTRY * ppEntry OPTIONAL
    );

NTSTATUS
UlpTreeFindReservationNode(
    IN PWSTR                   pUrl,
    IN PUL_CG_URL_TREE_ENTRY * ppEntry
    );

NTSTATUS
UlpTreeFindRegistrationNode(
    IN PWSTR                   pUrl,
    IN PUL_CG_URL_TREE_ENTRY * ppEntry
    );

NTSTATUS
UlpTreeFindWildcardSite(
    IN  PWSTR pUrl,
    IN  BOOLEAN StrongWildcard,
    OUT PWSTR * ppNextToken,
    OUT PUL_CG_URL_TREE_ENTRY * ppEntry
    );

NTSTATUS
UlpTreeFindSite(
    IN  PWSTR pUrl,
    OUT PWSTR * ppNextToken,
    OUT PUL_CG_URL_TREE_ENTRY * ppEntry
    );

NTSTATUS
UlpTreeFindSiteIpMatch(
    IN  PUL_INTERNAL_REQUEST pRequest,
    OUT PUL_CG_URL_TREE_ENTRY * ppEntry
    );

NTSTATUS
UlpTreeBinaryFindEntry(
    IN  PUL_CG_URL_TREE_HEADER pHeader OPTIONAL,
    IN  PWSTR pToken,
    IN  ULONG TokenLength,
    OUT PULONG pIndex
    );

NTSTATUS
UlpTreeCreateSite(
    IN  PWSTR                   pUrl,
    IN  HTTP_URL_SITE_TYPE      UrlType,
    OUT PWSTR *                 ppNextToken,
    OUT PUL_CG_URL_TREE_ENTRY*  ppSiteEntry
    );

NTSTATUS
UlpTreeFreeNode(
    IN PUL_CG_URL_TREE_ENTRY pEntry
    );

NTSTATUS
UlpTreeDeleteRegistration(
    IN PUL_CG_URL_TREE_ENTRY pEntry
    );

NTSTATUS
UlpTreeDeleteReservation(
    IN PUL_CG_URL_TREE_ENTRY pEntry
    );

NTSTATUS
UlpTreeInsert(
    IN  PWSTR                     pUrl,
    IN  HTTP_URL_SITE_TYPE        UrlType,
    IN  PWSTR                     pNextToken,
    IN  PUL_CG_URL_TREE_ENTRY     pEntry,
    OUT PUL_CG_URL_TREE_ENTRY   * ppEntry
    );

NTSTATUS
UlpTreeInsertEntry(
    IN OUT PUL_CG_URL_TREE_HEADER * ppHeader,
    IN PUL_CG_URL_TREE_ENTRY        pParent OPTIONAL,
    IN HTTP_URL_SITE_TYPE           UrlType,
    IN PWSTR                        pToken,
    IN ULONG                        TokenLength,
    IN ULONG                        Index
    );

//
// url info helpers
//

NTSTATUS
UlpSetUrlInfo(
    IN OUT PUL_URL_CONFIG_GROUP_INFO pInfo,
    IN PUL_CG_URL_TREE_ENTRY pMatchEntry
    );

NTSTATUS
UlpSetUrlInfoSpecial(
    IN OUT PUL_URL_CONFIG_GROUP_INFO pInfo,
    IN PUL_CG_URL_TREE_ENTRY pMatchEntry
    );

VOID
UlCGLockWriteSyncRemoveSite(
    VOID
    );

#endif // _CGROUPP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\clientconn.h ===
/*++

Copyright (c) 2000-2002 Microsoft Corporation

Module Name:

    clientconn.h

Abstract:

    This file contains the header defintions for the HTTP.SYS client connection
    structures

Author:

    Henry Sanders (henrysa)         14-Aug-2000

Revision History:

--*/


#ifndef _CLIENTCONN_H_
#define _CLIENTCONN_H_


//
// Forward references.
//



//
// Private constants.
//
#define CLIENT_CONN_TDI_LIST_MAX 30

//
// Private types.
//

//
// Private prototypes.
//

//
// Public constants
//

//
// Public types
//

//
// Connection flags/state. These flags indicate the current state of a
// connection.
//
// Some of these flags may be simply updated directly. Others require
// UlInterlockedCompareExchange() to avoid race conditions.
//
// The following flags may be updated directly:
//
//     AcceptPending - SET in the TDI connection handler, just before the
//         accept IRP is returned to the transport. RESET only if the accept
//         IRP fails.
//
// The following flags must be updated using UlInterlockedCompareExchange():
//
//     AcceptComplete - SET in the accept IRP completion handler if the IRP
//         completed successfully. Once this flag is set, the connection must
//         be either gracefully disconnected or aborted before the connection
//         can be closed or reused.
//
//     DisconnectPending - SET just before a graceful disconnect IRP is
//         issued.
//
//     DisconnectComplete - SET in the graceful disconnect IRP completion
//         handler.
//
//     AbortPending - SET just before an abortive disconnect IRP is issued.
//
//     AbortComplete - SET in the abortive disconnect IRP completion handler.
//
//     DisconnectIndicated - SET in the TDI disconnect handler for graceful
//         disconnects issued by the remote client.
//
//     AbortIndicated - SET in the TDI disconnect handler for abortive
//         disconnects issued by the remote client.
//
//     CleanupPending - SET when cleanup is begun for a connection. This
//         is necessary to know when the final reference to the connection
//         can be removed.
//
//         CODEWORK: We can get rid of the CleanupPending flag. It is
//         only set when either a graceful or abortive disconnect is
//         issued, and only tested in UlpRemoveFinalReference(). The
//         test in UlpRemoveFinalReference() can just test for either
//         (DisconnectPending | AbortPending) instead.
//
//     FinalReferenceRemoved - SET when the final (i.e. "connected")
//         reference is removed from the connection.
// Note that the flags requiring UlInterlockedCompareExchange() are only SET,
// never RESET. This makes the implementation a bit simpler.
//
// And now a few words about connection management, TDI, and other mysteries.
//
// Some of the more annoying "features" of TDI are related to connection
// management and lifetime. Two of the most onerous issues are:
//
//     1. Knowing when a connection object handle can be closed without
//        causing an unwanted connection reset.
//
//     2. Knowing when TDI has given its last indiction on a connection
//        so that resources can be released, reused, recycled, whatever.
//
// And, of course, this is further complicated by the inherent asynchronous
// nature of the NT I/O architecture and the parallelism of SMP systems.
//
// There are a few points worth keeping in mind while reading/modifying this
// source code or writing clients of this code:
//
//     1. As soon as an accept IRP is returned from the TDI connection
//        handler to the transport, the TDI client must be prepared for
//        any incoming indications, including data receive and disconnect.
//        In other words, incoming data & disconnect may occur *before* the
//        accept IRP actually completes.
//
//     2. A connection is considered "in use" until either both sides have
//        gracefully disconnected OR either side has aborted the connection.
//        Closing an "in use" connection will usually result in an abortive
//        disconnect.
//
//     3. The various flavors of disconnect (initiated by the local server,
//        initiated by the remote client, graceful, abortive, etc) may occur
//        in any order
//

typedef enum _UC_CONNECTION_STATE
{
/* 0 */    UcConnectStateConnectCleanup,
/* 1 */    UcConnectStateConnectCleanupBegin,
/* 2 */    UcConnectStateConnectIdle,
/* 3 */    UcConnectStateConnectPending,
/* 4 */    UcConnectStateIssueFilterClose,         // we send a FIN
/* 5 */    UcConnectStateIssueFilterDisconnect,    // we recv a FIN
/* 6 */    UcConnectStateConnectComplete,
/* 7 */    UcConnectStateProxySslConnect,
/* 8 */    UcConnectStateProxySslConnectComplete,
/* 9 */    UcConnectStatePerformingSslHandshake,
/* a */    UcConnectStateConnectReady,
/* b */    UcConnectStateDisconnectIndicatedPending,
/* c */    UcConnectStateDisconnectPending,
/* d */    UcConnectStateDisconnectComplete,
/* e */    UcConnectStateAbortPending
} UC_CONNECTION_STATE;

typedef enum _UC_CONNECTION_WORKER_TYPE
{
    UcConnectionPassive,
    UcConnectionWorkItem
} UC_CONNECTION_WORKER_TYPE, *PUC_CONNECTION_WORKER_TYPE;


//
// The states of SSL state machine
//
// Informal description:
//
// NoSslState          - Every connection is initialized to this state.
//
// ConnectionDelivered - Ssl connection was delivered to the filter by 
//                       completing its accept irp
//
// ServerCertReceived       - Certificate was attached to this connection
//
// ValidatingServerCert     - Waiting for app's approval of the certificate
//
// HandshakeComplete        - OK to send request on this connection
//
typedef enum _UC_SSL_CONNECTION_STATE
{
    UcSslStateNoSslState,
    UcSslStateConnectionDelivered,
    UcSslStateServerCertReceived,
    UcSslStateValidatingServerCert,
    UcSslStateHandshakeComplete,

    UcSslStateConnMaximum
} UC_SSL_CONNECTION_STATE;

//
// This wraps the TDI address object & Connection objects. 
//
typedef struct _UC_TDI_OBJECTS
{
    LIST_ENTRY                  Linkage;
    UX_TDI_OBJECT               ConnectionObject;       
    UX_TDI_OBJECT               AddressObject;
    TDI_CONNECTION_INFORMATION  TdiInfo;
    USHORT                      ConnectionType; // either TDI_ADDRESS_TYPE_IP or
                                                //        TDI_ADDRESS_TYPE_IP6
    PIRP                        pIrp;
    UL_IRP_CONTEXT              IrpContext;
    PUC_CLIENT_CONNECTION       pConnection;

} UC_TDI_OBJECTS, *PUC_TDI_OBJECTS;

//
// The structure that represents a TCP connection to us. This
// is a wrapper for the UX_TDI_OBJECT plus some associated state.
//

typedef struct _UC_CLIENT_CONNECTION
{
    ULONG               Signature;             // Structure signature
    UL_SPIN_LOCK        SpinLock;


    ULONG               ConnectionIndex;       // What is the index of this
                                               // connection on servinfo

    LIST_ENTRY          PendingRequestList;    // List of unsent requests.

    LIST_ENTRY          SentRequestList;       // List of sent but
                                               // uncompleted requests

    LIST_ENTRY          ProcessedRequestList;  // List of requests 
                                               // for which we have
                                               // completly processed
                                               // the response.

    //
    // A back pointer to the server information structure on which this
    // connection is linked. We don't explictly reference the server
    // information using REFERENCE_SERVER_INFORMATION. This is because
    // the server information is implictly referenced by requests, in the
    // following fashion. The server information structure is explictly
    // referenced by the file object, and the file object won't go away and
    // dereference the server information until we complete a cleanup IRP. We

    // won't complete the cleanup IRP until all outstanding requests on the
    // file object have been completed. Therefore the server information
    // pointer in this structure is guaranteed to be valid *only as long as
    // there are pending requests queued on this structure*.
    //

    PUC_PROCESS_SERVER_INFORMATION      pServerInfo;

    LONG                        RefCount;

    UC_CONNECTION_STATE         ConnectionState;
    UC_SSL_CONNECTION_STATE     SslState;

    NTSTATUS                    ConnectionStatus;

    ULONG                       Flags;

    struct {
        PUCHAR                    pBuffer;
        ULONG                     BytesWritten;
        ULONG                     BytesAvailable;
        ULONG                     BytesAllocated;
    } MergeIndication;

#if REFERENCE_DEBUG
    //
    // Private Reference trace log.
    //

    PTRACE_LOG  pTraceLog;
#endif // REFERENCE_DEBUG

    PUC_TDI_OBJECTS pTdiObjects;

    //
    // TDI wants us to pass a TRANSPORT_ADDRESS structure. Make sure that
    // we have a structure that can hold a IP4 or IP6 address.
    //

    union
    {
        TA_IP_ADDRESS     V4Address;
        TA_IP6_ADDRESS    V6Address;
        TRANSPORT_ADDRESS GenericTransportAddress;
    } RemoteAddress;

    //
    // Thread work item for deferred actions.
    //

    BOOLEAN      bWorkItemQueued;
    UL_WORK_ITEM WorkItem;

    //
    // Pointer to a event that will get set when the client
    // ref drops to 0.
    //
    PKEVENT  pEvent;


    UX_FILTER_CONNECTION FilterInfo;

    HTTP_SSL_SERVER_CERT_INFO ServerCertInfo;

    LONG        NextAddressCount;
    PTA_ADDRESS pNextAddress;

} UC_CLIENT_CONNECTION, *PUC_CLIENT_CONNECTION;


#define UC_CLIENT_CONNECTION_SIGNATURE   MAKE_SIGNATURE('HCON')
#define UC_CLIENT_CONNECTION_SIGNATURE_X MAKE_FREE_SIGNATURE(\
                                              UC_CLIENT_CONNECTION_SIGNATURE)


#define DEFAULT_REMOTE_ADDR_SIZE    MAX(TDI_ADDRESS_LENGTH_IP,      \
                                        TDI_ADDRESS_LENGTH_IP6)

#define UC_IS_VALID_CLIENT_CONNECTION(pConnection)                        \
    HAS_VALID_SIGNATURE(pConnection, UC_CLIENT_CONNECTION_SIGNATURE)

#define REFERENCE_CLIENT_CONNECTION(s)              \
            UcReferenceClientConnection(            \
            (s)                                     \
            REFERENCE_DEBUG_ACTUAL_PARAMS           \
            )
        
#define DEREFERENCE_CLIENT_CONNECTION(s)            \
            UcDereferenceClientConnection(          \
            (s)                                     \
            REFERENCE_DEBUG_ACTUAL_PARAMS           \
            )

#define UC_CLOSE_CONNECTION(pConn, Abortive, Status)                     \
    do                                                                   \
    {                                                                    \
        UC_WRITE_TRACE_LOG(                                              \
            g_pUcTraceLog,                                               \
            UC_ACTION_CONNECTION_CLOSE,                                  \
            (pConn),                                                     \
            UlongToPtr(Abortive),                                        \
            UlongToPtr((pConn)->ConnectionState),                        \
            UlongToPtr((pConn)->Flags)                                   \
            );                                                           \
                                                                         \
        UcCloseConnection((pConn), (Abortive), NULL, NULL, Status);      \
    } while(FALSE, FALSE)

#define CLIENT_CONN_FLAG_SEND_BUSY               0x00000002
#define CLIENT_CONN_FLAG_FILTER_CLEANUP          0x00000004
#define CLIENT_CONN_FLAG_TDI_ALLOCATE            0x00000008
#define CLIENT_CONN_FLAG_CONNECT_READY           0x00000010
#define CLIENT_CONN_FLAG_ABORT_RECEIVED          0x00000020
#define CLIENT_CONN_FLAG_ABORT_PENDING           0x00000040
#define CLIENT_CONN_FLAG_DISCONNECT_RECEIVED     0x00000080
#define CLIENT_CONN_FLAG_PROXY_SSL_CONNECTION    0x00000100
#define CLIENT_CONN_FLAG_DISCONNECT_COMPLETE     0x00000200
#define CLIENT_CONN_FLAG_ABORT_COMPLETE          0x00000400
#define CLIENT_CONN_FLAG_CONNECT_COMPLETE        0x00000800
#define CLIENT_CONN_FLAG_CLEANUP_PENDED          0x00001000
#define CLIENT_CONN_FLAG_FILTER_CLOSED           0x00002000
#define CLIENT_CONN_FLAG_RECV_BUSY               0x00008000

//
// Private prototypes.
//

NTSTATUS
UcpOpenTdiObjects(
    IN PUC_TDI_OBJECTS pTdiObjects
    );

NTSTATUS
UcpAllocateTdiObject(
    OUT PUC_TDI_OBJECTS *ppTdiObjects,
    IN  USHORT           AddressType
    );

VOID
UcpFreeTdiObject(
    IN  PUC_TDI_OBJECTS pTdiObjects
    );

PUC_TDI_OBJECTS
UcpPopTdiObject(
    IN  USHORT           AddressType
    );

VOID
UcpPushTdiObject(
    IN  PUC_TDI_OBJECTS pTdiObjects,
    IN  USHORT          AddressType
    );

NTSTATUS
UcpCleanupConnection(
    IN PUC_CLIENT_CONNECTION pConnection,
    IN KIRQL                 OldIrql,
    IN BOOLEAN               Final
    );


VOID
UcpCancelPendingRequest(
    PDEVICE_OBJECT          pDeviceObject,
    PIRP                    Irp
    );

VOID
UcpCancelConnectingRequest(
    PDEVICE_OBJECT          pDeviceObject,
    PIRP                    Irp
    );

NTSTATUS
UcpInitializeConnection(
    IN PUC_CLIENT_CONNECTION          pConnection,
    IN PUC_PROCESS_SERVER_INFORMATION pInfo
    );

NTSTATUS
UcpAssociateClientConnection(
    IN  PUC_CLIENT_CONNECTION    pUcConnection
    );



VOID
UcpTerminateClientConnectionsHelper(
    IN USHORT AddressType
    );


VOID
UcpRestartEntityMdlSend(
    IN PVOID        pCompletionContext,
    IN NTSTATUS     Status,
    IN ULONG_PTR    Information
    );

VOID
UcCancelConnectingRequest(
    PDEVICE_OBJECT          pDeviceObject,
    PIRP                    Irp
    );

VOID
UcpConnectionStateMachineWorker(
    IN PUL_WORK_ITEM pWorkItem
    );

BOOLEAN
UcpCompareServerCert(
    IN PUC_CLIENT_CONNECTION pConnection
    );

PUC_HTTP_REQUEST
UcpFindRequestToFail(
    IN PUC_CLIENT_CONNECTION pConnection
    );

//
// Public prototypes
//

NTSTATUS
UcInitializeClientConnections(
    VOID
    );

VOID
UcTerminateClientConnections(
    VOID
    );


NTSTATUS
UcOpenClientConnection(
    IN  PUC_PROCESS_SERVER_INFORMATION pServInfo,
    OUT PUC_CLIENT_CONNECTION         *pUcConnection
    );

VOID
UcReferenceClientConnection(
    PVOID pObject
    REFERENCE_DEBUG_FORMAL_PARAMS
    );
        
VOID
UcDereferenceClientConnection(
    PVOID pObject
    REFERENCE_DEBUG_FORMAL_PARAMS
    );

NTSTATUS
UcSendRequestOnConnection(
    PUC_CLIENT_CONNECTION  pConnection, 
    PUC_HTTP_REQUEST       pRequest,
    KIRQL                  OldIrql
    );


VOID
UcIssueRequests(
    PUC_CLIENT_CONNECTION         pConnection,
    KIRQL                         OldIrql
    );

BOOLEAN
UcIssueEntities(
    PUC_HTTP_REQUEST              pRequest,
    PUC_CLIENT_CONNECTION         pConnection,
    PKIRQL                        OldIrql
    );

VOID
UcCleanupConnection(
    IN PUC_CLIENT_CONNECTION pConnection,
    IN NTSTATUS              Status
    );

NTSTATUS
UcSendEntityBody(
    IN  PUC_HTTP_REQUEST          pRequest, 
    IN  PUC_HTTP_SEND_ENTITY_BODY pEntity,
    IN  PIRP                      pIrp,
    IN  PIO_STACK_LOCATION        pIrpSp,
    OUT PBOOLEAN                  bDontFail,
    IN  BOOLEAN                   bLast
    );

VOID
UcKickOffConnectionStateMachine(
    IN PUC_CLIENT_CONNECTION      pConnection,
    IN KIRQL                      OldIrql,
    IN UC_CONNECTION_WORKER_TYPE  WorkerType
    );

ULONG
UcGenerateHttpRawConnectionInfo(
    IN  PVOID   pContext,
    IN  PUCHAR  pKernelBuffer,
    IN  PVOID   pUserBuffer,
    IN  ULONG   OutLength,
    IN  PUCHAR  pBuffer,
    IN  ULONG   InitialLength
    );

ULONG
UcComputeHttpRawConnectionLength(
    IN PVOID pConnectionContext
    );

VOID
UcServerCertificateInstalled(
    IN PVOID    pConnectionContext,
    IN NTSTATUS Status
    );

VOID
UcConnectionStateMachine(
    IN PUC_CLIENT_CONNECTION pConnection,
    IN KIRQL                 OldIrql
    );

VOID
UcRestartClientConnect(
    IN PUC_CLIENT_CONNECTION pConnection,
    IN NTSTATUS              Status
    );


VOID
UcRestartMdlSend(
    IN PVOID      pCompletionContext,
    IN NTSTATUS   Status,
    IN ULONG_PTR  Information
    );

VOID
UcCancelSentRequest(
    PDEVICE_OBJECT          pDeviceObject,
    PIRP                    Irp
    );

VOID
UcClearConnectionBusyFlag(
    IN PUC_CLIENT_CONNECTION pConnection,
    IN ULONG                 Flag,
    IN KIRQL                 OldIrql,
    IN BOOLEAN               bCloseConnection
    );

BOOLEAN
UcpCheckForPipelining(
    IN PUC_CLIENT_CONNECTION pConnection
    );

NTSTATUS
UcAddServerCertInfoToConnection(
    IN PUX_FILTER_CONNECTION      pConnection,
    IN PHTTP_SSL_SERVER_CERT_INFO pServerCert
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\control.h ===
/*++

Copyright (c) 1999-2002 Microsoft Corporation

Module Name:

    control.h

Abstract:

    This module contains public declarations for the UL control channel.

Author:

    Keith Moore (keithmo)       09-Feb-1999

Revision History:

--*/


#ifndef _CONTROL_H_
#define _CONTROL_H_


//
// The control channel
//

#define IS_VALID_CONTROL_CHANNEL(pControlChannel)                       \
    HAS_VALID_SIGNATURE(pControlChannel, UL_CONTROL_CHANNEL_POOL_TAG)

#define IS_ACTIVE_CONTROL_CHANNEL(pControlChannel)                      \
    ( (pControlChannel) != NULL   &&                                    \
      (pControlChannel)->InCleanUp == FALSE &&                          \
      (pControlChannel)->Signature == UL_CONTROL_CHANNEL_POOL_TAG       \
      )

typedef struct _UL_CONTROL_CHANNEL
{
    //
    // UL_CONTROL_CHANNEL_POOL_TAG
    //
    ULONG                               Signature;      

    //
    // RefCounting for cgroups
    //
    LONG                                RefCount;

    //
    // For list of control channels.
    //

    LIST_ENTRY                          ControlChannelListEntry;    

    //
    // Shows if this control channel is about to get closed.
    //

    BOOLEAN                             InCleanUp;
    
    //
    // All of the config groups created off this control channel
    //
    UL_NOTIFY_HEAD                      ConfigGroupHead;
                               
    //                                                            
    // NOTE: The Site Counter members are protected by g_SiteCounterListMutex
    // All site counter blocks created off this control channel
    //
    LIST_ENTRY                          SiteCounterHead;

    //
    // Number of Site Counters on list
    //
    LONG                                SiteCounterCount;

    //
    // The current state    
    //
    HTTP_ENABLED_STATE                  State;

    //
    // Demand Start Threshold -- limit the completion of demand start 
    // Irps if the number of UL_APP_POOL_PROCESSes exceed this limit
    //
    ULONG                               DemandStartThreshold;

    //
    // The current count of non-Controller App Pool Processes associated
    // with this control channel.
    //
    ULONG                               AppPoolProcessCount;

    //
    // The global Bandwidth throttling limit (if it exists)
    //
    HTTP_BANDWIDTH_LIMIT                MaxBandwidth;

    //
    // All of the qos flows created off this control channel.
    //
    LIST_ENTRY                          FlowListHead;

    //
    // Shows if Utf8 Logging is on or off
    //
    HTTP_CONTROL_CHANNEL_UTF8_LOGGING   UTF8Logging;

    //
    // Logging config for binary format
    //
    HTTP_CONTROL_CHANNEL_BINARY_LOGGING BinaryLoggingConfig;

    //
    // Corresponding global binary log file entry
    //
    PUL_BINARY_LOG_FILE_ENTRY           pBinaryLogEntry;

    //
    // Note, filter channel information is stored in a separate data
    // structure instead of here so that ultdi can query it when it
    // creates new endpoints.
    //

} UL_CONTROL_CHANNEL, *PUL_CONTROL_CHANNEL;

VOID
UlReferenceControlChannel(
    IN PUL_CONTROL_CHANNEL pControlChannel
    REFERENCE_DEBUG_FORMAL_PARAMS
    );

#define REFERENCE_CONTROL_CHANNEL( pControlChannel )                        \
    UlReferenceControlChannel(                                              \
        (pControlChannel)                                                   \
        REFERENCE_DEBUG_ACTUAL_PARAMS                                       \
        )

VOID
UlDereferenceControlChannel(
    IN PUL_CONTROL_CHANNEL pControlChannel
    REFERENCE_DEBUG_FORMAL_PARAMS
    );

#define DEREFERENCE_CONTROL_CHANNEL( pControlChannel )                      \
    UlDereferenceControlChannel(                                            \
        (pControlChannel)                                                   \
        REFERENCE_DEBUG_ACTUAL_PARAMS                                       \
        )

//
// Initialize/terminate functions.
//

NTSTATUS
UlInitializeControlChannel(
    VOID
    );

VOID
UlTerminateControlChannel(
    VOID
    );


//
// Open a new control channel.
//

NTSTATUS
UlCreateControlChannel(
    OUT PUL_CONTROL_CHANNEL *ppControlChannel
    );

VOID
UlCleanUpControlChannel(
    IN PUL_CONTROL_CHANNEL pControlChannel
    );

VOID
UlCloseControlChannel(
    IN PUL_CONTROL_CHANNEL pControlChannel
    );

NTSTATUS
UlSetControlChannelInformation(
    IN PUL_CONTROL_CHANNEL pControlChannel,
    IN HTTP_CONTROL_CHANNEL_INFORMATION_CLASS InformationClass,
    IN PVOID pControlChannelInformation,
    IN ULONG Length,
    IN KPROCESSOR_MODE RequestorMode    
    );

NTSTATUS
UlGetControlChannelInformation(
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PUL_CONTROL_CHANNEL pControlChannel,
    IN  HTTP_CONTROL_CHANNEL_INFORMATION_CLASS InformationClass,
    IN  PVOID   pControlChannelInformation,
    IN  ULONG   Length,
    OUT PULONG  pReturnLength
    );

NTSTATUS
UlGetControlChannelFromHandle(
    IN HANDLE                   ControlChannel,
    IN KPROCESSOR_MODE          AccessMode,
    OUT PUL_CONTROL_CHANNEL *   ppControlChannel
    );


/***************************************************************************++

Routine Description:

    Small utility to check whether binary logging is disabled or not
    on the control channel.
        
--***************************************************************************/
__inline
BOOLEAN
UlBinaryLoggingEnabled(
    IN PUL_CONTROL_CHANNEL pControlChannel
    )
{        
    if (pControlChannel &&
        pControlChannel->BinaryLoggingConfig.Flags.Present &&
        pControlChannel->BinaryLoggingConfig.LoggingEnabled &&
        pControlChannel->pBinaryLogEntry)
    {            
        ASSERT(IS_VALID_CONTROL_CHANNEL(pControlChannel));
    
        ASSERT(IS_VALID_BINARY_LOG_FILE_ENTRY(
            pControlChannel->pBinaryLogEntry));
        
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


#define BWT_ENABLED_FOR_CONTROL_CHANNEL(pControlChannel)                    \
    ((pControlChannel) != NULL &&                                           \
     (pControlChannel)->MaxBandwidth   != HTTP_LIMIT_INFINITE)


#endif  // _CONTROL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\controlp.h ===
/*++

Copyright (c) 1999-2002 Microsoft Corporation

Module Name:

    controlp.h

Abstract:

    This module contains private declarations for the UL control channel.

Author:

    Keith Moore (keithmo)       09-Feb-1999

Revision History:

--*/


#ifndef _CONTROLP_H_
#define _CONTROLP_H_


VOID
UlpSetFilterChannel(
    IN PUL_FILTER_CHANNEL pFilterChannel,
    IN BOOLEAN FilterOnlySsl
    );

#if DBG

extern LIST_ENTRY      g_ControlChannelListHead;

/***************************************************************************++

Routine Description:

    Finds a control channel in the global list.

Arguments:

    pControlChannel - Supplies the control channel to search.

Return Value:

    BOOLEAN - Found or Not Found.

--***************************************************************************/

__inline
BOOLEAN
UlFindControlChannel(
    IN PUL_CONTROL_CHANNEL pControlChannel
    )
{
    PLIST_ENTRY         pLink   = NULL;
    PUL_CONTROL_CHANNEL pEntry  = NULL;
    BOOLEAN             bFound  = FALSE;
    
    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // A good pointer ?
    //
    
    if (pControlChannel != NULL)
    {
        UlAcquirePushLockShared(
                &g_pUlNonpagedData->ControlChannelPushLock
                );
    
        for (pLink  =  g_ControlChannelListHead.Flink;
             pLink != &g_ControlChannelListHead;
             pLink  =  pLink->Flink
             )
        {        
            pEntry = CONTAINING_RECORD(
                        pLink,
                        UL_CONTROL_CHANNEL,
                        ControlChannelListEntry
                        );

            if (pEntry == pControlChannel)
            {
                bFound = TRUE;
                break;
            }            
        }
             
        UlReleasePushLockShared(
                &g_pUlNonpagedData->ControlChannelPushLock
                );                     
    }

    return bFound;
    
}   // UlFindControlChannel

#define VERIFY_CONTROL_CHANNEL(pChannel)                    \
    if ( FALSE == UlFindControlChannel((pChannel)))         \
    {                                                       \
        ASSERT(!"ControlChannel is not on the list !");     \
    }                                                       \
    else                                                    \
    {                                                       \
        ASSERT(IS_VALID_CONTROL_CHANNEL((pChannel)));       \
    }
    
#else 

#define VERIFY_CONTROL_CHANNEL(pChannel)

#endif  // DBG
    
#endif  // _CONTROLP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\countersp.h ===
/*++

Copyright (c) 1998-2002 Microsoft Corporation

Module Name:

    countersp.h

Abstract:

    Contains the performance monitoring counter management code

Author:

    Eric Stenson (ericsten)      25-Sep-2000

Revision History:

--*/

#ifndef __COUNTERSP_H__
#define __COUNTERSP_H__


BOOLEAN
UlpIsInSiteCounterList(
    IN PUL_CONTROL_CHANNEL pControlChannel,
    IN ULONG SiteId
    );


#endif // __COUNTERSP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\control.c ===
/*++

Copyright (c) 1999-2002 Microsoft Corporation

Module Name:

    control.c

Abstract:

    This module implements the UL control channel.

Author:

    Keith Moore (keithmo)       09-Feb-1999

Revision History:

--*/


#include "precomp.h"
#include "controlp.h"


//
// Private constants.
//

//
// Private globals.
//

LIST_ENTRY      g_ControlChannelListHead        = {NULL,NULL};
LONG            g_ControlChannelCount           = 0;
BOOLEAN         g_InitControlChannelCalled      = FALSE;


#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, UlInitializeControlChannel )
#pragma alloc_text( PAGE, UlTerminateControlChannel )
#pragma alloc_text( PAGE, UlCreateControlChannel )
#pragma alloc_text( PAGE, UlCloseControlChannel )

#endif  // ALLOC_PRAGMA

#if 0
NOT PAGEABLE -- UlQueryFilterChannel
#endif


//
// Public functions.
//

/***************************************************************************++

Routine Description:

    Performs global initialization of this module.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlInitializeControlChannel(
    VOID
    )
{
    if (!g_InitControlChannelCalled)
    {
    
        InitializeListHead(&g_ControlChannelListHead);

        UlInitializePushLock(
            &g_pUlNonpagedData->ControlChannelPushLock,
            "ControlChannelPushLock",
            0,
            UL_CONTROL_CHANNEL_PUSHLOCK_TAG
            );

        g_InitControlChannelCalled = TRUE;        
    }
    
    return STATUS_SUCCESS;

}   // UlInitializeControlChannel


/***************************************************************************++

Routine Description:

    Performs global termination of this module.

--***************************************************************************/
VOID
UlTerminateControlChannel(
    VOID
    )
{

    if (g_InitControlChannelCalled)
    {
        ASSERT( IsListEmpty( &g_ControlChannelListHead )) ;
        ASSERT( 0 == g_ControlChannelCount );
        
        UlDeletePushLock(
            &g_pUlNonpagedData->ControlChannelPushLock
            );

        g_InitControlChannelCalled = FALSE;
    }

}   // UlTerminateControlChannel


/***************************************************************************++

Routine Description:

    Opens a control channel.

Arguments:

    pControlChannel - Receives a pointer to the newly created control
        channel if successful.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlCreateControlChannel(
    OUT PUL_CONTROL_CHANNEL *ppControlChannel
    )
{
    PUL_CONTROL_CHANNEL pControlChannel;

    //
    // Sanity check.
    //

    PAGED_CODE();

    pControlChannel = UL_ALLOCATE_STRUCT(
                            NonPagedPool,
                            UL_CONTROL_CHANNEL,
                            UL_CONTROL_CHANNEL_POOL_TAG
                            );

    if (pControlChannel == NULL)
        return STATUS_NO_MEMORY;

    RtlZeroMemory(pControlChannel, sizeof(*pControlChannel));

    pControlChannel->Signature = UL_CONTROL_CHANNEL_POOL_TAG;

    pControlChannel->State = HttpEnabledStateInactive;

    pControlChannel->RefCount = 1;

    // Init Site Counter List info
    InitializeListHead( &pControlChannel->SiteCounterHead );
    pControlChannel->SiteCounterCount = 0;

    UlInitializeNotifyHead(
        &pControlChannel->ConfigGroupHead,
        &g_pUlNonpagedData->ConfigGroupResource
        );

    // No Qos limit as default
    pControlChannel->MaxBandwidth = HTTP_LIMIT_INFINITE;
    InitializeListHead( &pControlChannel->FlowListHead );

    // No binary logging yet.
    pControlChannel->BinaryLoggingConfig.LoggingEnabled = FALSE;

    // TODO: Pick up default Connection Timeout Limits

    // Init process count & demand start default
    pControlChannel->DemandStartThreshold = DEFAULT_DEMAND_START_THRESHOLD;
    pControlChannel->AppPoolProcessCount  = 0;

    // This will be set when the CleanUp Irp called on the associated
    // file object.
    
    pControlChannel->InCleanUp = 0;   

    // Add this to the global list of channels

    UlAcquirePushLockExclusive(
            &g_pUlNonpagedData->ControlChannelPushLock
            );

    InsertHeadList( 
            &g_ControlChannelListHead, 
            &pControlChannel->ControlChannelListEntry
            );

    g_ControlChannelCount++;
    ASSERT(g_ControlChannelCount >= 1);

    UlReleasePushLockExclusive(
            &g_pUlNonpagedData->ControlChannelPushLock
            );

    WRITE_REF_TRACE_LOG(
        g_pControlChannelTraceLog,
        REF_ACTION_CREATE_CONTROL_CHANNEL,
        pControlChannel->RefCount,
        pControlChannel,
        __FILE__,
        __LINE__
        );

    // Set the callers variable
    
    *ppControlChannel = pControlChannel;

    return STATUS_SUCCESS;

}   // UlCreateControlChannel


/***************************************************************************++

Routine Description:

    When the last handle on the associated file object is closed, IoManager
    sends the CleanUp Irp and we come here and;
    
    Mark   the control channel in clean-up.

    An extra refcount on the control channel still stays intact until close.
    The marked control channel stays on the list of control channels.

    After this point on, it is impossible for a server app to add a cgroup
    to this control channel.

Arguments:

    pControlChannel - Supplies the control channel.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/

VOID
UlCleanUpControlChannel(
    IN PUL_CONTROL_CHANNEL pControlChannel
    )
{
    //
    // Sanity check.
    //

    PAGED_CODE();
    ASSERT(pControlChannel);
    
    //
    // Acquire the lock and find the cchannel.
    //

    VERIFY_CONTROL_CHANNEL(pControlChannel);
        
    //
    // Mark this control channel being cleaned-up so that we
    // won't be adding new cgroups to this channel anymore.
    //
    
    pControlChannel->InCleanUp = TRUE;
    
    WRITE_REF_TRACE_LOG(
        g_pControlChannelTraceLog,
        REF_ACTION_CLEANUP_CONTROL_CHANNEL,
        pControlChannel->RefCount,
        pControlChannel,
        __FILE__,
        __LINE__
        );

    //
    // NOTE: We will hold on to the last ref on control channel
    // NOTE: a little bit more, until the close iotcl is called
    //

}   // UlCleanUpControlChannel

/***************************************************************************++

Routine Description:

    Closes a control channel.

    When the total refcount on the associated file object hits zero.
    IoManager sends the close Irp and we come here and .

    Orphan the cgroups belong to this control channel.
    Remove the possibly existings global flow for the bandwidth throttling.
    Drop the last ref on the control channel and free it up.
    
Arguments:

    pControlChannel - Supplies the control channel to be closed.

--***************************************************************************/

VOID
UlCloseControlChannel(
    IN PUL_CONTROL_CHANNEL pControlChannel
    )
{
    //
    // Sanity check.
    //

    PAGED_CODE();
    ASSERT(pControlChannel);
    
    //
    // Acquire the lock and find the cchannel.
    //

    VERIFY_CONTROL_CHANNEL(pControlChannel);
        
    ASSERT(TRUE == pControlChannel->InCleanUp);

    //
    // Free all the orphaned config groups.
    //
    
    UlNotifyAllEntries(
        &UlNotifyOrphanedConfigGroup,
        &pControlChannel->ConfigGroupHead,
        NULL
        );

    //
    // Remove QoS flows if they exist.
    //
    
    if (!IsListEmpty(&pControlChannel->FlowListHead))
    {
        UlTcRemoveFlows(pControlChannel, TRUE);
    }

    //
    // Remove from the list of control channels.
    //
    
    UlAcquirePushLockExclusive(
            &g_pUlNonpagedData->ControlChannelPushLock
            );
    
    RemoveEntryList(&pControlChannel->ControlChannelListEntry);

    pControlChannel->ControlChannelListEntry.Flink = NULL;

    ASSERT(g_ControlChannelCount >= 1);
    g_ControlChannelCount--;

    UlReleasePushLockExclusive(
            &g_pUlNonpagedData->ControlChannelPushLock
            );        

    WRITE_REF_TRACE_LOG(
        g_pControlChannelTraceLog,
        REF_ACTION_CLOSE_CONTROL_CHANNEL,
        pControlChannel->RefCount,
        pControlChannel,
        __FILE__,
        __LINE__
        );

    //
    // Close control channel does not wait on individual cgroups
    // to go away. While an already parsed and routed request
    // holding a pointer to control channel we cannot go away.
    // We should wait until all the cgroups releases its 
    // references to us. Remove the final reference so that we 
    // can get cleaned up.
    // Because requests may still be in flight, the site counter
    // entries may still be around and on the control channel.
    //

    DEREFERENCE_CONTROL_CHANNEL(pControlChannel);     

}   // UlCloseControlChannel


/***************************************************************************++

Routine Description:

    Sets control channel information.

Arguments:


Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlSetControlChannelInformation(
    IN PUL_CONTROL_CHANNEL pControlChannel,
    IN HTTP_CONTROL_CHANNEL_INFORMATION_CLASS InformationClass,
    IN PVOID pControlChannelInformation,
    IN ULONG Length,
    IN KPROCESSOR_MODE RequestorMode
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    HTTP_BANDWIDTH_LIMIT NewMaxBandwidth;
    HTTP_CONTROL_CHANNEL_BINARY_LOGGING LoggingInfo;
    HTTP_CONTROL_CHANNEL_TIMEOUT_LIMIT TimeoutInfo;
    HTTP_ENABLED_STATE NewControlChannelState;

    UNREFERENCED_PARAMETER(Length);

    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // no buffer?
    //

    ASSERT(IS_VALID_CONTROL_CHANNEL(pControlChannel));
    ASSERT(NULL != pControlChannelInformation);

    CG_LOCK_WRITE();

    //
    // What are we being asked to do?
    //

    switch (InformationClass)
    {
    case HttpControlChannelStateInformation:

        NewControlChannelState =  
             *((PHTTP_ENABLED_STATE)pControlChannelInformation);

        if(NewControlChannelState == HttpEnabledStateActive ||
           NewControlChannelState == HttpEnabledStateInactive)
        {
            pControlChannel->State = NewControlChannelState;

            //
            // flush the URI cache.
            // CODEWORK: if we were smarter we might not need to flush
            //
            UlFlushCache(pControlChannel);

        }
        else
        {
            Status = STATUS_INVALID_PARAMETER;
            goto end;
        }

        break;

    case HttpControlChannelFilterInformation:
        {
            PHTTP_CONTROL_CHANNEL_FILTER pFiltInfo;

            //
            // This property is for admins only.
            //

            Status = UlThreadAdminCheck(
                        FILE_WRITE_DATA, 
                        RequestorMode,
                        HTTP_CONTROL_DEVICE_NAME 
                        );

            if(!NT_SUCCESS(Status))
            {
                goto end;
            }

            pFiltInfo = (PHTTP_CONTROL_CHANNEL_FILTER) pControlChannelInformation;

            //
            // Record the new information.
            //
            if (pFiltInfo->Flags.Present)
            {
                if(pFiltInfo->FilterHandle != NULL)
                {
                    Status = STATUS_INVALID_PARAMETER;
                    goto end;
                }

                UxSetFilterOnlySsl(pFiltInfo->FilterOnlySsl);
            }
            else
            {
                UxSetFilterOnlySsl(FALSE);
            }
        }
        break;

    case HttpControlChannelBandwidthInformation:
        {
            //
            // This property is for admins only.
            //
            Status = UlThreadAdminCheck(
                        FILE_WRITE_DATA, 
                        RequestorMode,
                        HTTP_CONTROL_DEVICE_NAME 
                        );

            if(!NT_SUCCESS(Status))
            {
                goto end;
            }
            
            NewMaxBandwidth = *((PHTTP_BANDWIDTH_LIMIT) pControlChannelInformation);

            //
            // Rate can not be lower than the min allowed.
            //
            if (NewMaxBandwidth < HTTP_MIN_ALLOWED_BANDWIDTH_THROTTLING_RATE)
            {
                Status = STATUS_INVALID_PARAMETER;
                goto end;
            }

            //
            // But check to see if PSched is installed or not before proceeding.
            // By returning an error here, WAS will raise an event warning but
            // proceed w/o terminating the web server
            //
            if (!UlTcPSchedInstalled())
            {
                NTSTATUS TempStatus;

                if (NewMaxBandwidth == HTTP_LIMIT_INFINITE)
                {
                    //
                    // By default Config Store has HTTP_LIMIT_INFINITE. Therefore
                    // return success for non-actions to prevent unnecessary event
                    // warnings.
                    //
                    
                    Status = STATUS_SUCCESS;
                    goto end;                
                }

                //
                // Try to wake up psched state.
                //

                TempStatus = UlTcInitPSched();
                
                if (!NT_SUCCESS(TempStatus))
                {
                    //
                    // There's a BWT limit coming down but PSched is not installed
                    //
                    
                    Status = STATUS_INVALID_DEVICE_REQUEST;
                    goto end;
                }                
            }

            //
            // Take a look at the similar "set cgroup ioctl" for 
            // detailed comments.
            //
            
            if (pControlChannel->MaxBandwidth != HTTP_LIMIT_INFINITE)
            {
                //
                // See if there is really a change.
                //
                if (NewMaxBandwidth != pControlChannel->MaxBandwidth)
                {
                    if (NewMaxBandwidth != HTTP_LIMIT_INFINITE)
                    {
                        Status = UlTcModifyFlows(
                                    (PVOID) pControlChannel,                            
                                    NewMaxBandwidth,
                                    TRUE
                                    );
                        if (!NT_SUCCESS(Status))
                            goto end;
                    }
                    else
                    {
                        UlTcRemoveFlows(
                            (PVOID) pControlChannel,
                            TRUE
                            );
                    }

                    //
                    // Don't forget to update the control channel 
                    // if it was a success.
                    //
                    
                    pControlChannel->MaxBandwidth = NewMaxBandwidth;
                }
            }
            else
            {
                //
                // Create the global flows on all interfaces.
                //
                if (NewMaxBandwidth != HTTP_LIMIT_INFINITE)
                {
                    Status = UlTcAddFlows(
                                (PVOID) pControlChannel,                        
                                NewMaxBandwidth,
                                TRUE
                                );

                    if (NT_SUCCESS(Status))
                    {
                        //
                        // Success! Remember the global bandwidth limit 
                        // in control channel.
                        //
                        pControlChannel->MaxBandwidth = NewMaxBandwidth;
                    }
                }

                //
                // When UlCloseControlChannel is called, the global flows on
                // all interfaces are also going to be removed.Alternatively 
                // the flows might be removed by explicitly setting the limit 
                // to infinite 
                //
            }
        }
        break;

    case HttpControlChannelTimeoutInformation:
        // CODEWORK: scope timeout monitor info to Control Channel

        //
        // This property is for admins only.
        //
        Status = UlThreadAdminCheck(
                    FILE_WRITE_DATA, 
                    RequestorMode,
                    HTTP_CONTROL_DEVICE_NAME 
                    );

        if( !NT_SUCCESS(Status) )
        {
            goto end;
        }

        //
        // Validate before setting
        //
        TimeoutInfo = *((PHTTP_CONTROL_CHANNEL_TIMEOUT_LIMIT) 
                            pControlChannelInformation);

        // NOTE: 64K seconds ~= 18.2 hours
        if (TimeoutInfo.ConnectionTimeout > 0xFFFF ||
            TimeoutInfo.HeaderWaitTimeout > 0xFFFF )
        {
            Status = STATUS_INVALID_PARAMETER;
            goto end;
        }
       
        UlSetTimeoutMonitorInformation(
            &TimeoutInfo
            );

        Status = STATUS_SUCCESS;
        break;

    case HttpControlChannelUTF8Logging:
        //
        // This property is for admins only.
        //
        Status = UlThreadAdminCheck(
                    FILE_WRITE_DATA, 
                    RequestorMode,
                    HTTP_CONTROL_DEVICE_NAME 
                    );

        if( NT_SUCCESS(Status) )
        {
            BOOLEAN bDoUTF8Logging;

            bDoUTF8Logging = 
                (0 == *((PHTTP_CONTROL_CHANNEL_UTF8_LOGGING)pControlChannelInformation) ? 
                    FALSE : TRUE );
            
            pControlChannel->UTF8Logging = bDoUTF8Logging;

            UlSetUTF8Logging( bDoUTF8Logging );
        }
        break;

    case HttpControlChannelBinaryLogging:
        {
            UNICODE_STRING LogFileDir;

            //
            // This property is for admins only.
            //
            Status = UlThreadAdminCheck(
                        FILE_WRITE_DATA, 
                        RequestorMode,
                        HTTP_CONTROL_DEVICE_NAME 
                        );

            if(!NT_SUCCESS(Status))
            {
                goto end;
            }
                
            RtlInitEmptyUnicodeString(&LogFileDir, NULL, 0);
            RtlZeroMemory(&LoggingInfo, sizeof(LoggingInfo));

            __try
            {
                // Copy the input buffer into a local variable, we may
                // overwrite some of the fields
                
                LoggingInfo = 
                    (*((PHTTP_CONTROL_CHANNEL_BINARY_LOGGING)
                                    pControlChannelInformation));

                //
                // Do the range check for the configuration params.
                //

                Status = UlCheckLoggingConfig(&LoggingInfo, NULL);
                if (!NT_SUCCESS(Status))
                {                
                    goto end;
                }
                
                //
                // If the logging is -being- turned off. Fields other than the
                // LoggingEnabled are discarded. And the directory string might
                // be null, therefore we should only probe it if the logging is
                // enabled.
                //
                
                if (LoggingInfo.LoggingEnabled)
                {
                    Status = 
                        UlProbeAndCaptureUnicodeString(
                            &LoggingInfo.LogFileDir,
                            RequestorMode,
                            &LogFileDir,
                            MAX_PATH
                            );    

                    if (NT_SUCCESS(Status))
                    {
                        //
                        // Validity check for the logging directory.
                        //
                        
                        if (!UlIsValidLogDirectory(
                                &LogFileDir,
                                 TRUE,        // UncSupport
                                 FALSE        // SystemRootSupport
                                 ))
                        {
                            Status = STATUS_INVALID_PARAMETER;
                            UlFreeCapturedUnicodeString(&LogFileDir);
                        }    
                    }
                }                

            }
            __except( UL_EXCEPTION_FILTER() )
            {
                Status = UL_CONVERT_EXCEPTION_CODE(GetExceptionCode());
            }
                
            if (!NT_SUCCESS(Status))
            {
                goto end;
            }

            // Now reinit the unicode_string in LoggingInfo struct
            // to point to the captured one.
            
            LoggingInfo.LogFileDir = LogFileDir;
                
            if (pControlChannel->BinaryLoggingConfig.Flags.Present)
            {
                Status = 
                    UlReConfigureBinaryLogEntry(
                        pControlChannel,
                       &pControlChannel->BinaryLoggingConfig,  // The old
                       &LoggingInfo                            // The new
                        );                    
            }
            else
            {               
                //
                // Delay the creation until it becomes enabled.
                //
                
                if (LoggingInfo.LoggingEnabled)
                {
                    Status = 
                        UlCreateBinaryLogEntry(
                            pControlChannel,
                            &LoggingInfo
                            );                
                }                
            }

            // Cleanup the captured LogFileDir now.

            UlFreeCapturedUnicodeString(&LogFileDir);
        }
        break;

   case HttpControlChannelDemandStartThreshold:
       {
            PHTTP_CONTROL_CHANNEL_DEMAND_START_THRESHOLD pDST;
            
            if ( Length < sizeof(HTTP_CONTROL_CHANNEL_DEMAND_START_THRESHOLD) )
            {
                Status = STATUS_BUFFER_TOO_SMALL;
            }
            else
            {
                pDST = (PHTTP_CONTROL_CHANNEL_DEMAND_START_THRESHOLD)
                        pControlChannelInformation;
                
                if (pDST->Flags.Present)
                {
                    InterlockedExchange(
                        (PLONG)&pControlChannel->DemandStartThreshold,
                        pDST->DemandStartThreshold
                        );
                }

                Status = STATUS_SUCCESS;
            }
        }        
            break;

    default:
            //
            // Should have been caught in UlSetControlChannelIoctl.
            //
            ASSERT(FALSE);
            Status = STATUS_INVALID_PARAMETER;
            break;
    }

end:

    CG_UNLOCK_WRITE();
    return Status;

}   // UlSetControlChannelInformation

/***************************************************************************++

Routine Description:

    Gets control channel information. For each element of the control channel
    if the supplied buffer is NULL, then we return the required length in the
    optional length field.

Arguments:

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlGetControlChannelInformation(
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PUL_CONTROL_CHANNEL pControlChannel,
    IN  HTTP_CONTROL_CHANNEL_INFORMATION_CLASS InformationClass,
    IN  PVOID   pControlChannelInformation,
    IN  ULONG   Length,
    OUT PULONG  pReturnLength
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    UNREFERENCED_PARAMETER(Length);

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(IS_VALID_CONTROL_CHANNEL(pControlChannel));
    ASSERT(NULL != pControlChannelInformation);
    ASSERT(pReturnLength);

    CG_LOCK_READ();

    //
    // What are we being asked to do?
    //

    switch (InformationClass)
    {
    case HttpControlChannelStateInformation:
        *((PHTTP_ENABLED_STATE)pControlChannelInformation)
            = pControlChannel->State;

        *pReturnLength = sizeof(HTTP_ENABLED_STATE);
        break;

    case HttpControlChannelBandwidthInformation:

        //
        // This property is for admins only.
        //

        Status = UlThreadAdminCheck(
                    FILE_READ_DATA, 
                    RequestorMode,
                    HTTP_CONTROL_DEVICE_NAME 
                    );

        if(NT_SUCCESS(Status))
        {
            *((PHTTP_BANDWIDTH_LIMIT)pControlChannelInformation) =
                pControlChannel->MaxBandwidth;

            *pReturnLength = sizeof(HTTP_BANDWIDTH_LIMIT);
        }
        
        break;

    case HttpControlChannelConnectionInformation:
        *((PHTTP_CONNECTION_LIMIT)pControlChannelInformation) =
            UlGetGlobalConnectionLimit();

        *pReturnLength = sizeof(HTTP_CONNECTION_LIMIT);
        break;

    default:
        //
        // Should have been caught in UlQueryControlChannelIoctl.
        //
        ASSERT(FALSE);

        Status = STATUS_INVALID_PARAMETER;
    }

    CG_UNLOCK_READ();
    return Status;

}   // UlGetControlChannelInformation


//
// Private functions.
//


/***************************************************************************++

Routine Description:

    Addref's the control channel object

Arguments:

    PUL_CONTROL_CHANNEL pControlChannel

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
VOID
UlReferenceControlChannel(
    IN PUL_CONTROL_CHANNEL pControlChannel
    REFERENCE_DEBUG_FORMAL_PARAMS
    )
{
    LONG refCount;

    //
    // Sanity check.
    //

    ASSERT(IS_VALID_CONTROL_CHANNEL(pControlChannel));

    refCount = InterlockedIncrement(&pControlChannel->RefCount);

    WRITE_REF_TRACE_LOG(
        g_pControlChannelTraceLog,
        REF_ACTION_REFERENCE_CONTROL_CHANNEL,
        refCount,
        pControlChannel,
        pFileName,
        LineNumber
        );

    UlTrace(REFCOUNT,(
        "Http!UlReferenceControlChannel pControlChannel=%p refcount=%d\n",
        pControlChannel,
        refCount)
        );

}   // UlReferenceControlChannel

/***************************************************************************++

Routine Description:

    Releases the control channel object.

Arguments:

    PUL_CONTROL_CHANNEL pControlChannel

--***************************************************************************/
VOID
UlDereferenceControlChannel(
    IN PUL_CONTROL_CHANNEL pControlChannel
    REFERENCE_DEBUG_FORMAL_PARAMS
    )
{
    LONG refCount;    

    //
    // Sanity check.
    //

    ASSERT(IS_VALID_CONTROL_CHANNEL(pControlChannel));

    refCount = InterlockedDecrement( &pControlChannel->RefCount );

    WRITE_REF_TRACE_LOG(
        g_pControlChannelTraceLog,
        REF_ACTION_DEREFERENCE_CONTROL_CHANNEL,
        refCount,
        pControlChannel,
        pFileName,
        LineNumber
        );

    UlTrace(REFCOUNT, (
        "http!UlDereferenceControlChannel pControlChannel=%p refcount=%d\n",
        pControlChannel,
        refCount)
        );

    if (refCount == 0)
    {
        //
        // Now it's time to free the object
        //

        if (pControlChannel->BinaryLoggingConfig.Flags.Present &&
            pControlChannel->BinaryLoggingConfig.LogFileDir.Buffer != NULL)
        {
            UlRemoveBinaryLogEntry(pControlChannel);
            pControlChannel->pBinaryLogEntry = NULL;
        }
        else
        {
            ASSERT( NULL == pControlChannel->pBinaryLogEntry );
        }

        //
        // Flow list must also be empty here.
        //

        ASSERT(IsListEmpty(&pControlChannel->FlowListHead));
        
        //
        // Check Site Counter List: should be empty by this point
        //
        ASSERT(IsListEmpty(&pControlChannel->SiteCounterHead));

        UL_FREE_POOL(pControlChannel, UL_CONTROL_CHANNEL_POOL_TAG);
    }
    
}   // UlDereferenceControlChannel


/******************************************************************************

Routine Description:

    This will return the control channel object reference by this handle, bumping 
    the refcount on the control channel.

    This is called by UlSetAppPoolInformation when user mode wants to
    associate a control channel to an app pool by handle.

    The app pool keeps a pointer to the control channel.

Arguments:

    ControlChannel   - the handle of the control channel
    AccessMode       - KernelMode or UserMode
    ppControlChannel - returns the control channel object the handle represented.

Return Value:

    NTSTATUS - Completion status.

******************************************************************************/
NTSTATUS
UlGetControlChannelFromHandle(
    IN HANDLE                   ControlChannel,
    IN KPROCESSOR_MODE          AccessMode,
    OUT PUL_CONTROL_CHANNEL *   ppControlChannel
    )
{
    NTSTATUS        Status;
    PFILE_OBJECT    pFileObject = NULL;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(ppControlChannel != NULL);

    Status = ObReferenceObjectByHandle(
                    ControlChannel,             // Handle
                    FILE_READ_ACCESS,           // DesiredAccess
                    *IoFileObjectType,          // ObjectType
                    AccessMode,                 // AccessMode
                    (PVOID *) &pFileObject,     // Object
                    NULL                        // HandleInformation
                    );

    if (NT_SUCCESS(Status) == FALSE)
    {
        goto end;
    }

    if (IS_CONTROL_CHANNEL(pFileObject) == FALSE ||
        IS_VALID_CONTROL_CHANNEL(GET_CONTROL_CHANNEL(pFileObject)) == FALSE)
    {
        Status = STATUS_INVALID_HANDLE;
        goto end;
    }

    *ppControlChannel = GET_CONTROL_CHANNEL(pFileObject);

    REFERENCE_CONTROL_CHANNEL(*ppControlChannel);

end:

    if (pFileObject != NULL)
    {
        ObDereferenceObject(pFileObject);
    }

    return Status;

}   // UlGetControlChannelFromHandle
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\counters.h ===
/*++

Copyright (c) 1998-2002 Microsoft Corporation

Module Name:

    counters.h

Abstract:

    Contains the performance monitoring counter management
    function declarations

Author:

    Eric Stenson (ericsten)      25-Sep-2000

Revision History:

--*/


#ifndef __COUNTERS_H__
#define __COUNTERS_H__


//
// structure to hold info for Site Counters.
//

typedef struct _UL_SITE_COUNTER_ENTRY {

    //
    // Signature is UL_SITE_COUNTER_ENTRY_POOL_TAG
    //

    ULONG               Signature;

    //
    // Ref count for this Site Counter Entry
    //
    LONG                RefCount;

    //
    // links Control Channel site counter entries
    //

    LIST_ENTRY          ListEntry;

    //
    // links Global site counter entries
    //

    LIST_ENTRY          GlobalListEntry;

    //
    // Lock protets counter data; used primarily when touching
    // 64-bit counters and reading counters
    //

    FAST_MUTEX          EntryMutex;

    //
    // the block which actually contains the counter data to be
    // passed back to WAS
    //

    HTTP_SITE_COUNTERS  Counters;

} UL_SITE_COUNTER_ENTRY, *PUL_SITE_COUNTER_ENTRY;

#define IS_VALID_SITE_COUNTER_ENTRY( entry )                                  \
    HAS_VALID_SIGNATURE(entry, UL_SITE_COUNTER_ENTRY_POOL_TAG)


//
// Private globals
//

extern BOOLEAN                  g_InitCountersCalled;
extern HTTP_GLOBAL_COUNTERS     g_UlGlobalCounters;
extern FAST_MUTEX               g_SiteCounterListMutex;
extern LIST_ENTRY               g_SiteCounterListHead;
extern LONG                     g_SiteCounterListCount;

extern HTTP_PROP_DESC           aIISULGlobalDescription[];
extern HTTP_PROP_DESC           aIISULSiteDescription[];


//
// Init
//

NTSTATUS
UlInitializeCounters(
    VOID
    );

VOID
UlTerminateCounters(
    VOID
    );


//
// Site Counter Entry
//

NTSTATUS
UlCreateSiteCounterEntry(
    IN OUT PUL_CONFIG_GROUP_OBJECT pConfigGroup,
    IN ULONG SiteId
    );


//
// DO NOT CALL THESE REF FUNCTIONS DIRECTLY: 
// These are the backing implementations; use the 
// REFERENCE_*/DEREFERENCE_* macros instead.
//
  
__inline
LONG
UlReferenceSiteCounterEntry(
    IN PUL_SITE_COUNTER_ENTRY pEntry
    )
{
    return InterlockedIncrement(&pEntry->RefCount);
}

__inline
LONG
UlDereferenceSiteCounterEntry(
    IN PUL_SITE_COUNTER_ENTRY pEntry
    )
{
    LONG    ref;

    ref = InterlockedDecrement(&pEntry->RefCount);
    if ( 0 == ref )
    {
        //
        // Remove from Site Counter List(s)
        // 
        
        ExAcquireFastMutex(&g_SiteCounterListMutex);

        // we should already be removed from the control channel's list
        ASSERT(NULL == pEntry->ListEntry.Flink);

        RemoveEntryList(&(pEntry->GlobalListEntry));
        pEntry->GlobalListEntry.Flink = pEntry->GlobalListEntry.Blink = NULL;
        
        g_SiteCounterListCount--;

        ExReleaseFastMutex(&g_SiteCounterListMutex);

        UL_FREE_POOL_WITH_SIG(pEntry, UL_SITE_COUNTER_ENTRY_POOL_TAG);
    }

    return ref;
} // UlDereferenceSiteCounterEntry

#if REFERENCE_DEBUG
VOID
UlDbgDereferenceSiteCounterEntry(
    IN PUL_SITE_COUNTER_ENTRY pEntry
    REFERENCE_DEBUG_FORMAL_PARAMS
    );

#define DEREFERENCE_SITE_COUNTER_ENTRY( pSC )                               \
    UlDbgDereferenceSiteCounterEntry(                                          \
        (pSC)                                                               \
        REFERENCE_DEBUG_ACTUAL_PARAMS                                       \
        )

VOID
UlDbgReferenceSiteCounterEntry(
    IN  PUL_SITE_COUNTER_ENTRY pEntry
    REFERENCE_DEBUG_FORMAL_PARAMS
    );

#define REFERENCE_SITE_COUNTER_ENTRY( pSC )                                 \
    UlDbgReferenceSiteCounterEntry(                                            \
    (pSC)                                                                   \
    REFERENCE_DEBUG_ACTUAL_PARAMS                                           \
    )
#else
#define REFERENCE_SITE_COUNTER_ENTRY    (VOID)UlReferenceSiteCounterEntry
#define DEREFERENCE_SITE_COUNTER_ENTRY  (VOID)UlDereferenceSiteCounterEntry
#endif


/*++

Routine Description:

    Removes Site Counter from UL_CONFIG_GROUP_OBJECT, removing it
    fromt the Control Channel's Site Counter List.

    Object should remain on Global list if there are still references

Arguments:

    pConfigGroup - the UL_CONFIG_GROUP_OBJECT from which we should 
      decouple the UL_SITE_COUNTER_ENTRY

 --*/
__inline
VOID
UlDecoupleSiteCounterEntry(
    IN PUL_CONFIG_GROUP_OBJECT pConfigGroup
    )
{
    ASSERT(IS_VALID_CONFIG_GROUP(pConfigGroup));
    ASSERT(IS_VALID_CONTROL_CHANNEL(pConfigGroup->pControlChannel));

    if (pConfigGroup->pSiteCounters)
    {
        // Remove from Control Channel's list
        ExAcquireFastMutex(&g_SiteCounterListMutex);

        RemoveEntryList(&pConfigGroup->pSiteCounters->ListEntry);
        pConfigGroup->pSiteCounters->ListEntry.Flink = NULL;
        pConfigGroup->pSiteCounters->ListEntry.Blink = NULL;

        pConfigGroup->pControlChannel->SiteCounterCount--;

        ExReleaseFastMutex(&g_SiteCounterListMutex);

        // Remove Config Group's reference outside of Mutex : we 
        // might take ref to 0 and need to remove from Global 
        // Site Counter list
        
        DEREFERENCE_SITE_COUNTER_ENTRY(pConfigGroup->pSiteCounters);
        pConfigGroup->pSiteCounters = NULL;
    }
}


//
// Global (cache) counters
//
__inline
VOID
UlIncCounterRtl(
    IN HTTP_GLOBAL_COUNTER_ID CounterId
    )
{
    PCHAR pCounter;

    pCounter = (PCHAR)&g_UlGlobalCounters;
    pCounter += aIISULGlobalDescription[CounterId].Offset;

    if (sizeof(ULONG) == aIISULGlobalDescription[CounterId].Size)
    {
        InterlockedIncrement((PLONG)pCounter);
    }
    else
    {
        UlInterlockedIncrement64((PLONGLONG)pCounter);
    }
}

__inline
VOID
UlDecCounterRtl(
    IN HTTP_GLOBAL_COUNTER_ID CounterId
    )
{
    PCHAR pCounter;

    pCounter = (PCHAR)&g_UlGlobalCounters;
    pCounter += aIISULGlobalDescription[CounterId].Offset;

    if (sizeof(ULONG) == aIISULGlobalDescription[CounterId].Size)
    {
        InterlockedDecrement((PLONG)pCounter);
    }
    else
    {
        UlInterlockedDecrement64((PLONGLONG)pCounter);
    }
}

__inline
VOID
UlAddCounterRtl(
    IN HTTP_GLOBAL_COUNTER_ID CounterId,
    IN ULONG Value
    )
{
    PCHAR pCounter;

    pCounter = (PCHAR)&g_UlGlobalCounters;
    pCounter += aIISULGlobalDescription[CounterId].Offset;

    if (sizeof(ULONG) == aIISULGlobalDescription[CounterId].Size)
    {
        InterlockedExchangeAdd((PLONG)pCounter, Value);
    }
    else
    {
        UlInterlockedAdd64((PLONGLONG)pCounter, Value);
    }
}

__inline
VOID
UlResetCounterRtl(
    IN HTTP_GLOBAL_COUNTER_ID CounterId
    )
{
    PCHAR pCounter;

    pCounter = (PCHAR)&g_UlGlobalCounters;
    pCounter += aIISULGlobalDescription[CounterId].Offset;

    if (sizeof(ULONG) == aIISULGlobalDescription[CounterId].Size)
    {
        InterlockedExchange((PLONG)pCounter, 0);
    }
    else
    {
        UlInterlockedExchange64((PLONGLONG)pCounter, 0);
    }
}

#if DBG
VOID
UlIncCounterDbg(
    HTTP_GLOBAL_COUNTER_ID Ctr
    );

VOID
UlDecCounterDbg(
    HTTP_GLOBAL_COUNTER_ID Ctr
    );

VOID
UlAddCounterDbg(
    HTTP_GLOBAL_COUNTER_ID Ctr,
    ULONG Value
    );

VOID
UlResetCounterDbg(
    HTTP_GLOBAL_COUNTER_ID Ctr
    );

#define UlIncCounter UlIncCounterDbg
#define UlDecCounter UlDecCounterDbg
#define UlAddCounter UlAddCounterDbg
#define UlResetCounter UlResetCounterDbg
#else // DBG

#define UlIncCounter UlIncCounterRtl
#define UlDecCounter UlDecCounterRtl
#define UlAddCounter UlAddCounterRtl
#define UlResetCounter UlResetCounterRtl

#endif // DBG


//
// Instance (site) counters
//

__inline
VOID
UlIncSiteNonCriticalCounterUlong(
    PUL_SITE_COUNTER_ENTRY pEntry,
    HTTP_SITE_COUNTER_ID CounterId
    )
{
    PCHAR       pCounter;
    PLONG       plValue;

    pCounter = (PCHAR) &(pEntry->Counters);
    pCounter += aIISULSiteDescription[CounterId].Offset;

    plValue = (PLONG) pCounter;
    ++(*plValue);
}

__inline
VOID
UlIncSiteNonCriticalCounterUlonglong(
    PUL_SITE_COUNTER_ENTRY pEntry,
    HTTP_SITE_COUNTER_ID CounterId
    )
{
    PCHAR       pCounter;
    PLONGLONG   pllValue;


    pCounter = (PCHAR) &(pEntry->Counters);
    pCounter += aIISULSiteDescription[CounterId].Offset;

    pllValue = (PLONGLONG) pCounter;
    ++(*pllValue);
}

//
// NOTE: DO NOT CALL *Rtl vesrions directly!
//

__inline
LONGLONG
UlIncSiteCounterRtl(
    IN PUL_SITE_COUNTER_ENTRY pEntry,
    IN HTTP_SITE_COUNTER_ID CounterId
    )
{
    PCHAR pCounter;

    pCounter = (PCHAR)&pEntry->Counters;
    pCounter += aIISULSiteDescription[CounterId].Offset;

    switch(aIISULSiteDescription[CounterId].Size)
    {
    case sizeof(ULONG):
        return (LONGLONG)InterlockedIncrement((PLONG)pCounter);

    case sizeof(LONGLONG):
        return UlInterlockedIncrement64((PLONGLONG)pCounter);

    default:
        ASSERT(!"UlIncSiteCounterRtl: ERROR: Invalid counter size!\n");
    }
    return 0L;
}

__inline
VOID
UlDecSiteCounterRtl(
    IN PUL_SITE_COUNTER_ENTRY pEntry,
    IN HTTP_SITE_COUNTER_ID CounterId
    )
{
    PCHAR pCounter;

    pCounter = (PCHAR)&pEntry->Counters;
    pCounter += aIISULSiteDescription[CounterId].Offset;

    switch(aIISULSiteDescription[CounterId].Size)
    {
    case sizeof(ULONG):
        InterlockedDecrement((PLONG)pCounter);
        break;

    case sizeof(ULONGLONG):
        UlInterlockedDecrement64((PLONGLONG)pCounter);
        break;

    default:
        ASSERT(!"UlDecSiteCounterRtl: ERROR: Invalid counter size!\n");
    }
}

__inline
VOID
UlAddSiteCounterRtl(
    IN PUL_SITE_COUNTER_ENTRY pEntry,
    IN HTTP_SITE_COUNTER_ID CounterId,
    IN ULONG Value
    )
{
    PCHAR pCounter;

    pCounter = (PCHAR)&pEntry->Counters;
    pCounter += aIISULSiteDescription[CounterId].Offset;

    InterlockedExchangeAdd((PLONG)pCounter, Value);
}

__inline
VOID
UlAddSiteCounter64Rtl(
    IN PUL_SITE_COUNTER_ENTRY pEntry,
    IN HTTP_SITE_COUNTER_ID CounterId,
    IN ULONGLONG Value
    )
{
    PCHAR pCounter;

    pCounter = (PCHAR)&pEntry->Counters;
    pCounter += aIISULSiteDescription[CounterId].Offset;

    UlInterlockedAdd64((PLONGLONG)pCounter, Value);
}

__inline
VOID
UlResetSiteCounterRtl(
    IN PUL_SITE_COUNTER_ENTRY pEntry,
    IN HTTP_SITE_COUNTER_ID CounterId
    )
{
    PCHAR pCounter;

    pCounter = (PCHAR)&pEntry->Counters;
    pCounter += aIISULSiteDescription[CounterId].Offset;

    switch(aIISULSiteDescription[CounterId].Size)
    {
    case sizeof(ULONG):
        InterlockedExchange((PLONG)pCounter, 0);
        break;
        
    case sizeof(ULONGLONG):
        UlInterlockedExchange64((PLONGLONG)pCounter, 0);
        break;
        
    default:
        ASSERT(!"UlResetSiteCounterRtl: ERROR: Invalid counter size!\n");
    }
}

__inline
VOID
UlMaxSiteCounterRtl(
    IN PUL_SITE_COUNTER_ENTRY pEntry,
    IN HTTP_SITE_COUNTER_ID CounterId,
    IN ULONG Value
    )
{
    PCHAR pCounter;
    LONG LocalMaxed;

    pCounter = (PCHAR)&pEntry->Counters;
    pCounter += aIISULSiteDescription[CounterId].Offset;

    do {
        LocalMaxed = *((volatile LONG *)pCounter);
        if ((LONG)Value <= LocalMaxed)
        {
            break;
        }

        PAUSE_PROCESSOR;
    } while (LocalMaxed != InterlockedCompareExchange(
                                (PLONG)pCounter,
                                Value,
                                LocalMaxed
                                ));
}

__inline
VOID
UlMaxSiteCounter64Rtl(
    IN PUL_SITE_COUNTER_ENTRY pEntry,
    IN HTTP_SITE_COUNTER_ID CounterId,
    IN LONGLONG Value
    )
{
    PCHAR pCounter;
    LONGLONG LocalMaxed;

    pCounter = (PCHAR)&pEntry->Counters;
    pCounter += aIISULSiteDescription[CounterId].Offset;

    do {
        LocalMaxed = *((volatile LONGLONG *)pCounter);
        if (Value <= LocalMaxed)
        {
            break;
        }

        PAUSE_PROCESSOR;
    } while (LocalMaxed != InterlockedCompareExchange64(
                                (PLONGLONG)pCounter,
                                Value,
                                LocalMaxed
                                ));
}


#if DBG

LONGLONG
UlIncSiteCounterDbg(
    PUL_SITE_COUNTER_ENTRY pEntry,
    HTTP_SITE_COUNTER_ID Ctr
    );

VOID
UlDecSiteCounterDbg(
    PUL_SITE_COUNTER_ENTRY pEntry,
    HTTP_SITE_COUNTER_ID Ctr
    );

VOID
UlAddSiteCounterDbg(
    PUL_SITE_COUNTER_ENTRY pEntry,
    HTTP_SITE_COUNTER_ID Ctr,
    ULONG Value
    );

VOID
UlAddSiteCounter64Dbg(
    PUL_SITE_COUNTER_ENTRY pEntry,
    HTTP_SITE_COUNTER_ID Ctr,
    ULONGLONG llValue
    );

VOID
UlResetSiteCounterDbg(
    PUL_SITE_COUNTER_ENTRY pEntry,
    HTTP_SITE_COUNTER_ID Ctr
    );

VOID
UlMaxSiteCounterDbg(
    PUL_SITE_COUNTER_ENTRY pEntry,
    HTTP_SITE_COUNTER_ID Ctr,
    ULONG Value
    );

VOID
UlMaxSiteCounter64Dbg(
    PUL_SITE_COUNTER_ENTRY pEntry,
    HTTP_SITE_COUNTER_ID Ctr,
    LONGLONG llValue
    );

#define UlIncSiteCounter UlIncSiteCounterDbg
#define UlDecSiteCounter UlDecSiteCounterDbg
#define UlAddSiteCounter UlAddSiteCounterDbg
#define UlAddSiteCounter64 UlAddSiteCounter64Dbg
#define UlResetSiteCounter UlResetSiteCounterDbg
#define UlMaxSiteCounter UlMaxSiteCounterDbg
#define UlMaxSiteCounter64 UlMaxSiteCounter64Dbg

#else // !DBG

#define UlIncSiteCounter UlIncSiteCounterRtl
#define UlDecSiteCounter UlDecSiteCounterRtl
#define UlAddSiteCounter UlAddSiteCounterRtl
#define UlAddSiteCounter64 UlAddSiteCounter64Rtl
#define UlResetSiteCounter UlResetSiteCounterRtl
#define UlMaxSiteCounter UlMaxSiteCounterRtl
#define UlMaxSiteCounter64 UlMaxSiteCounter64Rtl

#endif // DBG

//
// Collection
//

NTSTATUS
UlGetGlobalCounters(
    IN OUT PVOID    pCounter,
    IN ULONG        BlockSize,
    OUT PULONG      pBytesWritten
    );

NTSTATUS
UlGetSiteCounters(
    IN PUL_CONTROL_CHANNEL pControlChannel,
    IN OUT PVOID           pCounter,
    IN ULONG               BlockSize,
    OUT PULONG             pBytesWritten,
    OUT PULONG             pBlocksWritten OPTIONAL
    );


#endif // __COUNTERS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\counters.c ===
/*++

Copyright (c) 1998-2002 Microsoft Corporation

Module Name:

    counters.c

Abstract:

    Contains the performance monitoring counter management code

Author:

    Eric Stenson (ericsten)      25-Sep-2000

Revision History:

--*/

#include    "precomp.h"
#include    "countersp.h"


#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, UlInitializeCounters )
#pragma alloc_text( PAGE, UlTerminateCounters )
#pragma alloc_text( PAGE, UlCreateSiteCounterEntry )

#if REFERENCE_DEBUG
#pragma alloc_text( PAGE, UlDbgReferenceSiteCounterEntry )
#pragma alloc_text( PAGE, UlDbgDereferenceSiteCounterEntry )
#endif

#pragma alloc_text( PAGE, UlGetGlobalCounters )
#endif  // ALLOC_PRAGMA

#if 0
NOT PAGEABLE -- UlIncCounter
NOT PAGEABLE -- UlDecCounter
NOT PAGEABLE -- UlAddCounter
NOT PAGEABLE -- UlResetCounter

NOT PAGEABLE -- UlIncSiteCounter
NOT PAGEABLE -- UlDecSiteCounter
NOT PAGEABLE -- UlAddSiteCounter
NOT PAGEABLE -- UlResetSiteCounter
NOT PAGEABLE -- UlMaxSiteCounter
NOT PAGEABLE -- UlMaxSiteCounter64

NOT PAGEABLE -- UlGetSiteCounters
#endif


BOOLEAN                  g_InitCountersCalled = FALSE;
HTTP_GLOBAL_COUNTERS     g_UlGlobalCounters;
FAST_MUTEX               g_SiteCounterListMutex;
LIST_ENTRY               g_SiteCounterListHead;
LONG                     g_SiteCounterListCount;


/***************************************************************************++

Routine Description:

    Performs global initialization of the global (cache) and instance (per
    site) counters.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlInitializeCounters(
    VOID
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT( !g_InitCountersCalled );

    UlTrace(PERF_COUNTERS, ("http!UlInitializeCounters\n"));

    if (!g_InitCountersCalled)
    {
        //
        // zero out global counter block
        //

        RtlZeroMemory(&g_UlGlobalCounters, sizeof(HTTP_GLOBAL_COUNTERS));

        //
        // init Global Site Counter List
        //

        ExInitializeFastMutex(&g_SiteCounterListMutex);
        InitializeListHead(&g_SiteCounterListHead);
        g_SiteCounterListCount = 0;


        // done!
        g_InitCountersCalled = TRUE;
    }

    RETURN( Status );

} // UlInitializeCounters


/***************************************************************************++

Routine Description:

    Performs global cleanup of the global (cache) and instance (per
    site) counters.

--***************************************************************************/
VOID
UlTerminateCounters(
    VOID
    )
{
    //
    // [debug only] Walk list of counters and check the ref count for each counter block.
    //

#if DBG
    PLIST_ENTRY             pEntry;
    PUL_SITE_COUNTER_ENTRY  pCounterEntry;
    BOOLEAN                 MutexTaken = FALSE;

    if (!g_InitCountersCalled)
    {
        goto End;
    }

    // Take Site Counter List Mutex
    ExAcquireFastMutex(&g_SiteCounterListMutex);
    MutexTaken = TRUE;


    if (IsListEmpty(&g_SiteCounterListHead))
    {
        ASSERT(0 == g_SiteCounterListCount);
        // Good!  No counters left behind!
        goto End;
    }

    //
    // Walk list of Site Counter Entries
    //

    pEntry = g_SiteCounterListHead.Flink;
    while (pEntry != &g_SiteCounterListHead)
    {
        pCounterEntry = CONTAINING_RECORD(
                            pEntry,
                            UL_SITE_COUNTER_ENTRY,
                            GlobalListEntry
                            );

        ASSERT(IS_VALID_SITE_COUNTER_ENTRY(pCounterEntry));

        UlTrace(PERF_COUNTERS,
                ("http!UlTerminateCounters: Error: pCounterEntry %p SiteId %d RefCount %d\n",
                 pCounterEntry,
                 pCounterEntry->Counters.SiteId,
                 pCounterEntry->RefCount
                 ));

        pEntry = pEntry->Flink;
    }

End:
    if (MutexTaken)
    {
        ExReleaseFastMutex(&g_SiteCounterListMutex);
    }

    return;
#endif // DBG
}


///////////////////////////////////////////////////////////////////////////////
// Site Counter Entry
//


/***************************************************************************++

Routine Description:

    Creates a new site counter entry for the given SiteId.

    This code assumes that the config group is strictly "contained" by the
    control channel. In other words, if a config group exists, it will ALWAYS
    have a valid control channel.

Arguments:

    pConfigGroup - The Config group on which to add the new Site Counter block

    SiteId - The site id for the site counters.  Does not need to be unique.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlCreateSiteCounterEntry(
        IN OUT PUL_CONFIG_GROUP_OBJECT pConfigGroup,
        IN ULONG SiteId
    )
{
    NTSTATUS                Status = STATUS_SUCCESS;
    PUL_SITE_COUNTER_ENTRY  pNewEntry;
    PUL_CONTROL_CHANNEL     pControlChannel;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(IS_VALID_CONFIG_GROUP(pConfigGroup));

    pControlChannel = pConfigGroup->pControlChannel;
    ASSERT(IS_VALID_CONTROL_CHANNEL(pControlChannel));

    //
    // Make sure we don't clobber an existing one.
    //
    
    if( pConfigGroup->pSiteCounters )
    {
        UlTrace( PERF_COUNTERS,
            ("http!UlCreateSiteCounterEntry: Error: Site counter already exists on UL_CONFIG_GROUP_OBJECT %p\n",
            pConfigGroup->pSiteCounters
            ));

        return STATUS_OBJECTID_EXISTS;
    }
    
    //
    // Check to see if the SiteId is already in the list of existing 
    // Site Counter Entries.
    //
    
    ASSERT(!UlpIsInSiteCounterList(pControlChannel, SiteId));

    // Alloc new struct w/space from Non Paged Pool
    pNewEntry = UL_ALLOCATE_STRUCT(
                        NonPagedPool,
                        UL_SITE_COUNTER_ENTRY,
                        UL_SITE_COUNTER_ENTRY_POOL_TAG);
    if (pNewEntry)
    {
        UlTrace( PERF_COUNTERS,
            ("http!UlCreateSiteCounterEntry: pNewEntry %p, pConfigGroup %p, SiteId %d\n",
            pNewEntry,
            pConfigGroup,
            SiteId )
            );

        pNewEntry->Signature = UL_SITE_COUNTER_ENTRY_POOL_TAG;

        // Reference belongs to Config Group; covers the Control Channel's
        // Site Counter List.
        pNewEntry->RefCount = 1;

        // Zero out counters
        RtlZeroMemory(&(pNewEntry->Counters), sizeof(HTTP_SITE_COUNTERS));

        // Set Site ID
        pNewEntry->Counters.SiteId = SiteId;

        // Init Counter Mutex
        ExInitializeFastMutex(&(pNewEntry->EntryMutex));

        //
        // Add to Site Counter List(s)
        // 
        
        ExAcquireFastMutex(&g_SiteCounterListMutex);

        // Add to Global Site Counter List
        InsertTailList(
            &g_SiteCounterListHead,
            &(pNewEntry->GlobalListEntry)
            );
        g_SiteCounterListCount++;

        // Check for wrap-around of g_SiteCounterListCount
        ASSERT( 0 != g_SiteCounterListCount );

        // Add to Control Channel's Site Counter List
        InsertTailList(
                &pControlChannel->SiteCounterHead,
                &(pNewEntry->ListEntry)
                );
        pControlChannel->SiteCounterCount++;
        
        // Check for wrap-around of SiteCounterCount
        ASSERT( 0 != pControlChannel->SiteCounterCount );

        ExReleaseFastMutex(&g_SiteCounterListMutex);

    }
    else
    {
        UlTrace( PERF_COUNTERS,
            ("http!UlCreateSiteCounterEntry: Error: NO_MEMORY pConfigGroup %p, SiteId %d\n",
            pNewEntry,
            pConfigGroup,
            SiteId )
            );

        Status = STATUS_NO_MEMORY;
    }

    pConfigGroup->pSiteCounters = pNewEntry;

    if (pNewEntry)
    {
        // Rememeber Site ID
        pConfigGroup->SiteId = SiteId;
    }

    RETURN( Status );
}

#if REFERENCE_DEBUG
/***************************************************************************++

Routine Description:

    increments the refcount.

Arguments:

    pEntry - the object to increment.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
VOID
UlDbgReferenceSiteCounterEntry(
    IN PUL_SITE_COUNTER_ENTRY pEntry
    REFERENCE_DEBUG_FORMAL_PARAMS
    )
{
    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT( IS_VALID_SITE_COUNTER_ENTRY(pEntry) );

    UlReferenceSiteCounterEntry(pEntry);

    //
    // Tracing.
    //
    WRITE_REF_TRACE_LOG(
        g_pSiteCounterTraceLog,
        REF_ACTION_REFERENCE_SITE_COUNTER_ENTRY,
        pEntry->RefCount,
        pEntry,
        pFileName,
        LineNumber
        );

    UlTrace(
        REFCOUNT,
        ("http!UlReferenceSiteCounterEntry pEntry=%p refcount=%d SiteId=%d\n",
         pEntry,
         pEntry->RefCount,
         pEntry->Counters.SiteId)
        );

}   // UlReferenceAppPool


/***************************************************************************++

Routine Description:

    decrements the refcount.  if it hits 0, destruct's the site counter entry
    block.

Arguments:

    pEntry - the object to decrement.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
VOID
UlDbgDereferenceSiteCounterEntry(
    IN PUL_SITE_COUNTER_ENTRY pEntry
    REFERENCE_DEBUG_FORMAL_PARAMS
    )
{
    LONG refCount;
    ULONG OldSiteId;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT( IS_VALID_SITE_COUNTER_ENTRY(pEntry) );

    OldSiteId = pEntry->Counters.SiteId;
    refCount = UlDereferenceSiteCounterEntry(pEntry);
    
    //
    // Tracing.
    //
    WRITE_REF_TRACE_LOG(
        g_pSiteCounterTraceLog,
        REF_ACTION_DEREFERENCE_SITE_COUNTER_ENTRY,
        refCount,
        pEntry,
        pFileName,
        LineNumber
        );

    UlTrace(
        REFCOUNT,
        ("http!UlDereferenceSiteCounter pEntry=%p refcount=%d SiteId=%d\n",
         pEntry,
         refCount,
         OldSiteId)
        );

    if (refCount == 0)
    {
        UlTrace(
            PERF_COUNTERS,
            ("http!UlDereferenceSiteCounter: Removing pEntry=%p  SiteId=%d\n",
             pEntry,
             OldSiteId)
            );
    }
}
#endif // REFERENCE_DEBUG


///////////////////////////////////////////////////////////////////////////////
// Collection
//

/***************************************************************************++

Routine Description:

    Gets the Global (cache) counters.

Arguments:
    pCounter - pointer to block of memory where the counter data should be
    written.

    BlockSize - Maximum size available at pCounter.

    pBytesWritten - On success, count of bytes written into the block of
    memory at pCounter.  On failure, the required count of bytes for the
    memory at pCounter.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlGetGlobalCounters(
    IN OUT PVOID    pCounter,
    IN ULONG        BlockSize,
    OUT PULONG      pBytesWritten
    )
{
    PAGED_CODE();

    ASSERT( pBytesWritten );

    UlTraceVerbose(PERF_COUNTERS,
              ("http!UlGetGlobalCounters\n"));

    if ( (BlockSize < sizeof(HTTP_GLOBAL_COUNTERS))
         || !pCounter )
    {
        //
        // Tell the caller how many bytes are required.
        //

        *pBytesWritten = sizeof(HTTP_GLOBAL_COUNTERS);
        RETURN( STATUS_BUFFER_OVERFLOW );
    }

    RtlCopyMemory(
        pCounter,
        &g_UlGlobalCounters,
        sizeof(g_UlGlobalCounters)
        );

    *pBytesWritten = sizeof(HTTP_GLOBAL_COUNTERS);

    RETURN( STATUS_SUCCESS );

} // UlpGetGlobalCounters


/***************************************************************************++

Routine Description:

    Gets the Site (instance) counters for all sites

Arguments:

    pCounter - pointer to block of memory where the counter data should be
      written.

    BlockSize - Maximum size available at pCounter.

    pBytesWritten - On success, count of bytes written into the block of
      memory at pCounter.  On failure, the required count of bytes for the
      memory at pCounter.

    pBlocksWritten - (optional) On success, count of site counter blocks
      written to pCounter.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlGetSiteCounters(
    IN PUL_CONTROL_CHANNEL pControlChannel,
    IN OUT PVOID           pCounter,
    IN ULONG               BlockSize,
    OUT PULONG             pBytesWritten,
    OUT PULONG             pBlocksWritten OPTIONAL
    )
{
    NTSTATUS        Status;
    ULONG           i;
    ULONG           BytesNeeded;
    ULONG           BytesToGo;
    ULONG           BlocksSeen;
    PUCHAR          pBlock;
    PLIST_ENTRY     pEntry;
    PUL_SITE_COUNTER_ENTRY pCounterEntry;

    ASSERT( pBytesWritten );

    UlTraceVerbose(PERF_COUNTERS,
            ("http!UlGetSiteCounters\n"));

    //
    // Setup locals so we know how to cleanup on exit.
    //
    Status      = STATUS_SUCCESS;
    BytesToGo   = BlockSize;
    BlocksSeen  = 0;
    pBlock      = (PUCHAR) pCounter;

    // grab Site Counter Mutex
    ExAcquireFastMutex(&g_SiteCounterListMutex);

    BytesNeeded = 
      pControlChannel->SiteCounterCount * sizeof(HTTP_SITE_COUNTERS);

    if ( (BytesNeeded > BlockSize)
         || !pCounter )
    {
        // Need more space
        *pBytesWritten = BytesNeeded;
        Status = STATUS_BUFFER_OVERFLOW;
        goto End;
    }

    if (IsListEmpty(&pControlChannel->SiteCounterHead))
    {
        // No counters to return.
        goto End;
    }

    //
    // Walk list of Site Counter Entries
    //

    pEntry = pControlChannel->SiteCounterHead.Flink;

    while (pEntry != &pControlChannel->SiteCounterHead)
    {
        pCounterEntry = CONTAINING_RECORD(
                            pEntry,
                            UL_SITE_COUNTER_ENTRY,
                            ListEntry
                            );

        ASSERT(BytesToGo >= sizeof(HTTP_SITE_COUNTERS));

        RtlCopyMemory(pBlock,
                      &(pCounterEntry->Counters),
                      sizeof(HTTP_SITE_COUNTERS)
                      );

        //
        // Zero out any counters that must be zeroed.
        //

        for ( i = 0; i < HttpSiteCounterMaximum; i++ )
        {
            if (TRUE == aIISULSiteDescription[i].WPZeros)
            {
                // Zero it out
                UlResetSiteCounter(pCounterEntry, (HTTP_SITE_COUNTER_ID) i);
            }
        }

        //
        // Continue to next block
        //

        pBlock     += sizeof(HTTP_SITE_COUNTERS);
        BytesToGo  -= sizeof(HTTP_SITE_COUNTERS);
        BlocksSeen++;

        pEntry = pEntry->Flink;
    }

End:
    
    // Release Mutex
    ExReleaseFastMutex(&g_SiteCounterListMutex);

    //
    // Set callers values
    //

    if (STATUS_SUCCESS == Status)
    {
        // REVIEW: If we failed, *pBytesWritten already contains
        // the bytes required value.
        *pBytesWritten = DIFF(pBlock - ((PUCHAR)pCounter));
    }

    if (pBlocksWritten)
    {
        *pBlocksWritten = BlocksSeen;
    }

    RETURN( Status );

} // UlpGetSiteCounters


#if DBG
///////////////////////////////////////////////////////////////////////////////
// Global Counter functions
//


/***************************************************************************++

Routine Description:

    Increment a Global (cache) performance counter.

Arguments:

    Ctr - ID of Counter to increment

--***************************************************************************/
VOID
UlIncCounterDbg(
    HTTP_GLOBAL_COUNTER_ID Ctr
    )
{
    ASSERT( g_InitCountersCalled );
    ASSERT( Ctr < HttpGlobalCounterMaximum );  // REVIEW: signed/unsigned issues?

    UlTraceVerbose( PERF_COUNTERS,
            ("http!UlIncCounter (Ctr == %d)\n", Ctr) );

    UlIncCounterRtl(Ctr);

} // UlIncCounter

/***************************************************************************++

Routine Description:

    Decrement a Global (cache) performance counter.

Arguments:

    Ctr - ID of Counter to decrement

--***************************************************************************/
VOID
UlDecCounterDbg(
    HTTP_GLOBAL_COUNTER_ID Ctr
    )
{
    ASSERT( g_InitCountersCalled );
    ASSERT( Ctr < HttpGlobalCounterMaximum );  // REVIEW: signed/unsigned issues?

    UlTraceVerbose( PERF_COUNTERS,
            ("http!UlDecCounter (Ctr == %d)\n", Ctr));
    
    UlDecCounterRtl(Ctr);
}


/***************************************************************************++

Routine Description:

    Add a ULONG value to a Global (cache) performance counter.

Arguments:

    Ctr - ID of counter to which the Value should be added

    Value - The amount to add to the counter


--***************************************************************************/
VOID
UlAddCounterDbg(
    HTTP_GLOBAL_COUNTER_ID Ctr,
    ULONG Value
    )
{
    ASSERT( g_InitCountersCalled );
    ASSERT( Ctr < HttpGlobalCounterMaximum );  // REVIEW: signed/unsigned issues?

    UlTraceVerbose( PERF_COUNTERS,
            ("http!UlAddCounter (Ctr == %d, Value == %d)\n", Ctr, Value));

    UlAddCounterRtl(Ctr, Value);
} // UlAddCounter


/***************************************************************************++

Routine Description:

    Zero-out a Global (cache) performance counter.

Arguments:

    Ctr - ID of Counter to be reset.


--***************************************************************************/
VOID
UlResetCounter(
    HTTP_GLOBAL_COUNTER_ID Ctr
    )
{
    ASSERT( g_InitCountersCalled );
    ASSERT( Ctr < HttpGlobalCounterMaximum );  // REVIEW: signed/unsigned issues?

    UlTraceVerbose(PERF_COUNTERS,
            ("http!UlResetCounter (Ctr == %d)\n", Ctr));
    
    UlResetCounterRtl(Ctr);
} // UlResetCounter


///////////////////////////////////////////////////////////////////////////////
// Site Counter functions
//

// NOTE: There is no Dbg implementation for the following:
//   UlIncSiteNonCriticalCounterUlong
//   UlIncSiteNonCriticalCounterUlonglong

/***************************************************************************++

Routine Description:

    Increment a Site performance counter.

Arguments:

    pEntry - pointer to Site Counter entry

    Ctr - ID of Counter to increment

Returns:

    Value of counter after incrementing

--***************************************************************************/
LONGLONG
UlIncSiteCounterDbg(
    PUL_SITE_COUNTER_ENTRY pEntry,
    HTTP_SITE_COUNTER_ID Ctr
    )
{
    PCHAR   pCtr;
    LONGLONG   llValue;

    ASSERT( g_InitCountersCalled );
    ASSERT( Ctr < HttpSiteCounterMaximum );  // REVIEW: signed/unsigned issues?
    ASSERT( IS_VALID_SITE_COUNTER_ENTRY(pEntry) );

    UlTraceVerbose( PERF_COUNTERS,
            ("http!UlIncSiteCounter Ctr=%d SiteId=%d\n",
             Ctr,
             pEntry->Counters.SiteId
            ));

    //
    // figure out offset of Ctr in HTTP_SITE_COUNTERS
    //

    pCtr = (PCHAR) &(pEntry->Counters);
    pCtr += aIISULSiteDescription[Ctr].Offset;

    // figure out data size of Ctr and do
    // apropriate thread-safe increment

    if (sizeof(ULONG) == aIISULSiteDescription[Ctr].Size)
    {
        // ULONG
        llValue = (LONGLONG) InterlockedIncrement((PLONG) pCtr);
    }
    else
    {
        // ULONGLONG
        llValue = UlInterlockedIncrement64((PLONGLONG) pCtr);
    }

    return llValue;
}

/***************************************************************************++

Routine Description:

    Decrement a Site performance counter.

Arguments:

    pEntry - pointer to Site Counter entry

    Ctr - ID of Counter to decrement

--***************************************************************************/
VOID
UlDecSiteCounter(
    PUL_SITE_COUNTER_ENTRY pEntry,
    HTTP_SITE_COUNTER_ID Ctr
    )
{
    PCHAR   pCtr;

    ASSERT( g_InitCountersCalled );
    ASSERT( Ctr < HttpSiteCounterMaximum );  // REVIEW: signed/unsigned issues?
    ASSERT( IS_VALID_SITE_COUNTER_ENTRY(pEntry) );

    UlTraceVerbose( PERF_COUNTERS,
            ("http!UlDecSiteCounter Ctr=%d SiteId=%d\n",
             Ctr,
             pEntry->Counters.SiteId
            ));

    //
    // figure out offset of Ctr in HTTP_SITE_COUNTERS
    //

    pCtr = (PCHAR) &(pEntry->Counters);
    pCtr += aIISULSiteDescription[Ctr].Offset;

    // figure out data size of Ctr and do
    // apropriate thread-safe increment

    if (sizeof(ULONG) == aIISULSiteDescription[Ctr].Size)
    {
        // ULONG
        InterlockedDecrement((PLONG) pCtr);
    }
    else
    {
        // ULONGLONG
        UlInterlockedDecrement64((PLONGLONG) pCtr);
    }
}

/***************************************************************************++

Routine Description:

    Add a ULONG value to a 32-bit site performance counter.

Arguments:

    pEntry - pointer to Site Counter entry

    Ctr - ID of counter to which the Value should be added

    Value - The amount to add to the counter


--***************************************************************************/
VOID
UlAddSiteCounter(
    PUL_SITE_COUNTER_ENTRY pEntry,
    HTTP_SITE_COUNTER_ID Ctr,
    ULONG Value
    )
{
    PCHAR   pCtr;

    ASSERT( g_InitCountersCalled );
    ASSERT( Ctr < HttpSiteCounterMaximum );  // REVIEW: signed/unsigned issues?
    ASSERT( IS_VALID_SITE_COUNTER_ENTRY(pEntry) );

    UlTraceVerbose( PERF_COUNTERS,
            ("http!UlAddSiteCounter Ctr=%d SiteId=%d Value=%d\n",
             Ctr,
             pEntry->Counters.SiteId,
             Value
            ));

    //
    // figure out offset of Ctr in HTTP_SITE_COUNTERS
    //

    pCtr = (PCHAR) &(pEntry->Counters);
    pCtr += aIISULSiteDescription[Ctr].Offset;

    // figure out data size of Ctr and do
    // apropriate thread-safe increment

    ASSERT(sizeof(ULONG) == aIISULSiteDescription[Ctr].Size);
    InterlockedExchangeAdd((PLONG) pCtr, Value);
}

/***************************************************************************++

Routine Description:

    Add a ULONGLONG value to a 64-bit site performance counter.

Arguments:

    pEntry - pointer to Site Counter entry

    Ctr - ID of counter to which the Value should be added

    Value - The amount to add to the counter


--***************************************************************************/
VOID
UlAddSiteCounter64(
    PUL_SITE_COUNTER_ENTRY pEntry,
    HTTP_SITE_COUNTER_ID Ctr,
    ULONGLONG llValue
    )
{
    PCHAR   pCtr;

    ASSERT( g_InitCountersCalled );
    ASSERT( Ctr < HttpSiteCounterMaximum );  // REVIEW: signed/unsigned issues?
    ASSERT( IS_VALID_SITE_COUNTER_ENTRY(pEntry) );

    
    UlTraceVerbose( PERF_COUNTERS,
            ("http!UlAddSiteCounter64 Ctr=%d SiteId=%d Value=%I64d\n",
             Ctr,
             pEntry->Counters.SiteId,
             llValue
            ));
             

    //
    // figure out offset of Ctr in HTTP_SITE_COUNTERS
    //

    pCtr = (PCHAR) &(pEntry->Counters);
    pCtr += aIISULSiteDescription[Ctr].Offset;

    ASSERT(sizeof(ULONGLONG) == aIISULSiteDescription[Ctr].Size);
    UlInterlockedAdd64((PLONGLONG) pCtr, llValue);
}



/***************************************************************************++

Routine Description:

    Reset a Site performance counter.

Arguments:

    pEntry - pointer to Site Counter entry

    Ctr - ID of counter to be reset


--***************************************************************************/
VOID
UlResetSiteCounter(
    PUL_SITE_COUNTER_ENTRY pEntry,
    HTTP_SITE_COUNTER_ID Ctr
    )
{
    PCHAR   pCtr;

    ASSERT( g_InitCountersCalled );
    ASSERT( Ctr < HttpSiteCounterMaximum );  // REVIEW: signed/unsigned issues?
    ASSERT( IS_VALID_SITE_COUNTER_ENTRY(pEntry) );

   
    UlTraceVerbose( PERF_COUNTERS,
            ("http!UlResetSiteCounter Ctr=%d SiteId=%d\n",
             Ctr,
             pEntry->Counters.SiteId
            ));

    //
    // figure out offset of Ctr in HTTP_SITE_COUNTERS
    //

    pCtr = (PCHAR) &(pEntry->Counters);
    pCtr += aIISULSiteDescription[Ctr].Offset;

    //
    // do apropriate "set" for data size of Ctr
    //

    if (sizeof(ULONG) == aIISULSiteDescription[Ctr].Size)
    {
        // ULONG
        InterlockedExchange((PLONG) pCtr, 0);
    }
    else
    {
        // ULONGLONG
        LONGLONG localCtr;
        LONGLONG originalCtr;
        LONGLONG localZero = 0;

        do {

            localCtr = *((volatile LONGLONG *) pCtr);

            originalCtr = InterlockedCompareExchange64( (PLONGLONG) pCtr,
                                                        localZero,
                                                        localCtr );

        } while (originalCtr != localCtr);

    }

}


/***************************************************************************++

Routine Description:

    Determine if a new maximum value of a Site performance counter has been
    hit and set the counter to the new maximum if necessary. (ULONG version)

Arguments:

    pEntry - pointer to Site Counter entry

    Ctr - ID of counter

    Value - possible new maximum (NOTE: Assumes that the counter Ctr is a
      32-bit value)

--***************************************************************************/
VOID
UlMaxSiteCounter(
    PUL_SITE_COUNTER_ENTRY pEntry,
    HTTP_SITE_COUNTER_ID Ctr,
    ULONG Value
    )
{
    PCHAR   pCtr;

    ASSERT( g_InitCountersCalled );
    ASSERT( Ctr < HttpSiteCounterMaximum );  // REVIEW: signed/unsigned issues?
    ASSERT( IS_VALID_SITE_COUNTER_ENTRY(pEntry) );

    UlTraceVerbose( PERF_COUNTERS,
            ("http!UlMaxSiteCounter Ctr=%d SiteId=%d Value=%d\n",
             Ctr,
             pEntry->Counters.SiteId,
             Value
             ));

    //
    // figure out offset of Ctr in HTTP_SITE_COUNTERS
    //

    pCtr = (PCHAR) &(pEntry->Counters);
    pCtr += aIISULSiteDescription[Ctr].Offset;

    // Grab counter block mutex
    ExAcquireFastMutex(&pEntry->EntryMutex);

    if (Value > (ULONG) *pCtr)
    {
        InterlockedExchange((PLONG) pCtr, Value);
    }

    // Release counter block mutex
    ExReleaseFastMutex(&pEntry->EntryMutex);

}


/***************************************************************************++

Routine Description:

    Determine if a new maximum value of a Site performance counter has been
    hit and set the counter to the new maximum if necessary. (LONGLONG version)

Arguments:

    pEntry - pointer to Site Counter entry

    Ctr - ID of counter

    Value - possible new maximum (NOTE: Assumes that the counter Ctr is a
      64-bit value)

--***************************************************************************/
VOID
UlMaxSiteCounter64(
    PUL_SITE_COUNTER_ENTRY pEntry,
    HTTP_SITE_COUNTER_ID Ctr,
    LONGLONG llValue
    )
{
    PCHAR   pCtr;

    ASSERT( g_InitCountersCalled );
    ASSERT( Ctr < HttpSiteCounterMaximum );  // REVIEW: signed/unsigned issues?
    ASSERT( IS_VALID_SITE_COUNTER_ENTRY(pEntry) );

    UlTraceVerbose( PERF_COUNTERS,
            ("http!UlMaxSiteCounter64 Ctr=%d SiteId=%d Value=%I64d\n",
             Ctr,
             pEntry->Counters.SiteId,
             llValue
            ));

    //
    // figure out offset of Ctr in HTTP_SITE_COUNTERS
    //

    pCtr = (PCHAR) &(pEntry->Counters);
    pCtr += aIISULSiteDescription[Ctr].Offset;

    // Grab counter block mutex
    ExAcquireFastMutex(&pEntry->EntryMutex);

    if (llValue > (LONGLONG) *pCtr)
    {
        *((PLONGLONG) pCtr) = llValue;
#if 0
        // REVIEW: There *must* be a better way to do this...
        // REVIEW: I want to do: (LONGLONG) *pCtr = llValue;
        // REVIEW: But casting something seems to make it a constant.
        // REVIEW: Also, there isn't an "InterlockedExchange64" for x86.
        // REVIEW: Any suggestions? --EricSten
        RtlCopyMemory(
            pCtr,
            &llValue,
            sizeof(LONGLONG)
            );
#endif // 0
    }

    // Release counter block mutex
    ExReleaseFastMutex(&pEntry->EntryMutex);

}
#endif


/***************************************************************************++

Routine Description:

    Predicate to test if a site counter entry already exists for the given
    SiteId

Arguments:

    SiteId - ID of site

Return Value:

    TRUE if found

    FALSE if not found

--***************************************************************************/
BOOLEAN
UlpIsInSiteCounterList(
    IN PUL_CONTROL_CHANNEL pControlChannel,
    IN ULONG SiteId)
{
    PLIST_ENTRY             pEntry;
    PUL_SITE_COUNTER_ENTRY  pCounterEntry;
    BOOLEAN                 IsFound = FALSE;

    //
    // Take Site Counter mutex
    // 
    
    ExAcquireFastMutex(&g_SiteCounterListMutex);

    if ( IsListEmpty(&pControlChannel->SiteCounterHead) )
    {
        ASSERT(0 == pControlChannel->SiteCounterCount);
        // Good!  No counters left behind!
        goto End;
    }

    //
    // Walk list of Site Counter Entries
    //

    pEntry = pControlChannel->SiteCounterHead.Flink;
    while (pEntry != &pControlChannel->SiteCounterHead)
    {
        pCounterEntry = CONTAINING_RECORD(
                            pEntry,
                            UL_SITE_COUNTER_ENTRY,
                            ListEntry
                            );

        ASSERT(IS_VALID_SITE_COUNTER_ENTRY(pCounterEntry));

        if (SiteId == pCounterEntry->Counters.SiteId)
        {
            IsFound = TRUE;
            goto End;
        }

        pEntry = pEntry->Flink;
    }

End:
    //
    // Release Site Counter mutex
    //

    ExReleaseFastMutex(&g_SiteCounterListMutex);

    return IsFound;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\data.c ===
/*++

Copyright (c) 1998-2002 Microsoft Corporation

Module Name:

    data.c

Abstract:

    This module contains global data for UL.

Author:

    Keith Moore (keithmo)       10-Jun-1998

Revision History:

--*/


#include "precomp.h"


#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, UlInitializeData )
#pragma alloc_text( PAGE, UlTerminateData )
#endif  // ALLOC_PRAGMA


//
// The number of processors in the system.
//

CLONG     g_UlNumberOfProcessors = 1;
ULONGLONG g_UlThreadAffinityMask = 1;

BOOLEAN   g_HttpClientEnabled; // Will be initialized in init.c

//
// The largest cache line size the system
//

ULONG g_UlCacheLineSize = 0;
ULONG g_UlCacheLineBits = 0; // see init.c

//
// Total memory in the system
//

SIZE_T g_UlTotalPhysicalMemMB = 0;
SIZE_T g_UlTotalNonPagedPoolBytes = 0;

//
// Our nonpaged data.
//

PUL_NONPAGED_DATA g_pUlNonpagedData = NULL;


//
// A pointer to the system process.
//

PKPROCESS g_pUlSystemProcess = NULL;


//
// Our device objects and their container.
//

HANDLE  g_UlDirectoryObject = NULL;

PDEVICE_OBJECT g_pUlControlDeviceObject = NULL;
PDEVICE_OBJECT g_pUlFilterDeviceObject  = NULL;
PDEVICE_OBJECT g_pUlAppPoolDeviceObject = NULL;
PDEVICE_OBJECT g_pUcServerDeviceObject  = NULL;

//
// This handle references all the client functions. This allows us to quickly
// demand page the client code.
//

PVOID g_ClientImageHandle = NULL;

//
// Cached Date header string.
//

LARGE_INTEGER g_UlSystemTime;
UCHAR g_UlDateString[DATE_HDR_LENGTH+1];
ULONG g_UlDateStringLength;

//
// Security descriptor that has fileAll for Admin & Local System
//
PSECURITY_DESCRIPTOR g_pAdminAllSystemAll;

//
// ComputerName string.
//

WCHAR g_UlComputerName[MAX_COMPUTER_NAME_LEN+1];

//
// Error logging config
//

HTTP_ERROR_LOGGING_CONFIG g_UlErrLoggingConfig;

//
// Various pieces of configuration information, with default values.
//

ULONG g_UlMaxWorkQueueDepth = DEFAULT_MAX_WORK_QUEUE_DEPTH;
ULONG g_UlMinWorkDequeueDepth = DEFAULT_MIN_WORK_DEQUEUE_DEPTH;
USHORT g_UlIdleConnectionsHighMark = DEFAULT_IDLE_CONNECTIONS_HIGH_MARK;
USHORT g_UlIdleConnectionsLowMark = DEFAULT_IDLE_CONNECTIONS_LOW_MARK;
ULONG g_UlIdleListTrimmerPeriod = DEFAULT_IDLE_LIST_TRIMMER_PERIOD;
USHORT g_UlMaxEndpoints = DEFAULT_MAX_ENDPOINTS;
ULONG g_UlReceiveBufferSize = DEFAULT_RCV_BUFFER_SIZE;
ULONG g_UlMaxRequestBytes = DEFAULT_MAX_REQUEST_BYTES;
BOOLEAN g_UlOptForIntrMod = DEFAULT_OPT_FOR_INTR_MOD;
BOOLEAN g_UlEnableNagling = DEFAULT_ENABLE_NAGLING;
BOOLEAN g_UlEnableThreadAffinity = DEFAULT_ENABLE_THREAD_AFFINITY;
ULONG g_UlMaxFieldLength = DEFAULT_MAX_FIELD_LENGTH;
BOOLEAN g_UlDisableLogBuffering = DEFAULT_DISABLE_LOG_BUFFERING;
ULONG g_UlLogBufferSize = DEFAULT_LOG_BUFFER_SIZE;
ULONG g_UlResponseBufferSize = DEFAULT_RESP_BUFFER_SIZE;
URL_C14N_CONFIG g_UrlC14nConfig;
ULONG g_UlMaxInternalUrlLength = DEFAULT_MAX_INTERNAL_URL_LENGTH;
ULONG g_UlMaxBufferedBytes = DEFAULT_MAX_BUFFERED_BYTES;
ULONG g_UlMaxCopyThreshold = DEFAULT_MAX_COPY_THRESHOLD;
ULONG g_UlMaxBufferedSends = DEFAULT_MAX_BUFFERED_SENDS;
ULONG g_UlMaxBytesPerSend = DEFAULT_MAX_BYTES_PER_SEND;
ULONG g_UlMaxBytesPerRead = DEFAULT_MAX_BYTES_PER_READ;
ULONG g_UlMaxPipelinedRequests = DEFAULT_MAX_PIPELINED_REQUESTS;
BOOLEAN g_UlEnableCopySend = DEFAULT_ENABLE_COPY_SEND;
ULONG g_UlOpaqueIdTableSize = DEFAULT_OPAQUE_ID_TABLE_SIZE;
ULONG g_UlMaxZombieHttpConnectionCount = DEFAULT_MAX_ZOMBIE_HTTP_CONN_COUNT;
ULONG g_UlDisableServerHeader = DEFAULT_DISABLE_SERVER_HEADER;
ULONG g_UlConnectionSendLimit = DEFAULT_CONNECTION_SEND_LIMIT;
ULONGLONG g_UlGlobalSendLimit = DEFAULT_GLOBAL_SEND_LIMIT;

//
// The following are generated during initialization.
//

ULONG g_UlMaxVariableHeaderSize = 0;
ULONG g_UlMaxFixedHeaderSize = 0;
ULONG g_UlFixedHeadersMdlLength = 0;
ULONG g_UlVariableHeadersMdlLength = 0;
ULONG g_UlContentMdlLength = 0;
ULONG g_UlChunkTrackerSize = 0;
ULONG g_UlFullTrackerSize = 0;
ULONG g_UlMaxRequestsQueued = (ULONG) DEFAULT_MAX_REQUESTS_QUEUED;

//
// Make life easier for the debugger extension.
//

#if DBG
ULONG g_UlCheckedBuild = TRUE;
#else
ULONG g_UlCheckedBuild = FALSE;
#endif


//
// Debug stuff.
//

#if DBG
ULONGLONG g_UlDebug = DEFAULT_DEBUG_FLAGS;
ULONG g_UlBreakOnError = DEFAULT_BREAK_ON_ERROR;
ULONG g_UlVerboseErrors = DEFAULT_VERBOSE_ERRORS;
#endif  // DBG

#if REFERENCE_DEBUG

// If you add tracelogs here, please update !ulkd.glob

PTRACE_LOG g_pEndpointUsageTraceLog = NULL;
PTRACE_LOG g_pMondoGlobalTraceLog = NULL;
PTRACE_LOG g_pPoolAllocTraceLog = NULL;
PTRACE_LOG g_pUriTraceLog = NULL;
PTRACE_LOG g_pTdiTraceLog = NULL;
PTRACE_LOG g_pHttpRequestTraceLog = NULL;
PTRACE_LOG g_pHttpConnectionTraceLog = NULL;
PTRACE_LOG g_pHttpResponseTraceLog = NULL;
PTRACE_LOG g_pAppPoolTraceLog = NULL;
PTRACE_LOG g_pAppPoolProcessTraceLog = NULL;
PTRACE_LOG g_pConfigGroupTraceLog = NULL;
PTRACE_LOG g_pControlChannelTraceLog = NULL;
PTRACE_LOG g_pThreadTraceLog = NULL;
PTRACE_LOG g_pFilterTraceLog = NULL;
PTRACE_LOG g_pIrpTraceLog = NULL;
PTRACE_LOG g_pTimeTraceLog = NULL;
PTRACE_LOG g_pAppPoolTimeTraceLog = NULL;
PTRACE_LOG g_pReplenishTraceLog = NULL;
PTRACE_LOG g_pMdlTraceLog = NULL;
PTRACE_LOG g_pSiteCounterTraceLog = NULL;
PTRACE_LOG g_pConnectionCountTraceLog = NULL;
PTRACE_LOG g_pConfigGroupInfoTraceLog = NULL;
PTRACE_LOG g_pChunkTrackerTraceLog = NULL;
PTRACE_LOG g_pWorkItemTraceLog = NULL;
PTRACE_LOG g_pUcTraceLog = NULL;

#endif  // REFERENCE_DEBUG


PSTRING_LOG g_pGlobalStringLog = NULL;

//
// Generic access map for url acls
//

GENERIC_MAPPING g_UrlAccessGenericMapping = {
    0,
    HTTP_ALLOW_DELEGATE_URL,
    HTTP_ALLOW_REGISTER_URL,
    HTTP_ALLOW_DELEGATE_URL | HTTP_ALLOW_REGISTER_URL
};


//
// Public functions.
//

/***************************************************************************++

Routine Description:

    Performs global data initialization.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlInitializeData(
    PUL_CONFIG pConfig
    )
{
    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // Initialize the nonpaged data.
    //

    g_pUlNonpagedData = UL_ALLOCATE_STRUCT(
                            NonPagedPool,
                            UL_NONPAGED_DATA,
                            UL_NONPAGED_DATA_POOL_TAG
                            );

    if (g_pUlNonpagedData == NULL )
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(g_pUlNonpagedData, sizeof(*g_pUlNonpagedData));

#if DBG
    //
    // Initialize any debug-specific data.
    //

    UlDbgInitializeDebugData( );
#endif  // DBG

    //
    // Initialize the maximum variable header size.
    //

    g_UlMaxVariableHeaderSize = UlComputeMaxVariableHeaderSize();
    g_UlMaxVariableHeaderSize = ALIGN_UP(g_UlMaxVariableHeaderSize, PVOID);

    g_UlMaxFixedHeaderSize = DEFAULT_MAX_FIXED_HEADER_SIZE;

    //
    // MDL Length for FixedHeaders or UserBuffer.
    //

    g_UlFixedHeadersMdlLength = (ULONG)
        MmSizeOfMdl(
            (PVOID)(PAGE_SIZE - 1),
            MAX(
                g_UlMaxBytesPerSend,
                g_UlMaxFixedHeaderSize
                )
            );

    g_UlFixedHeadersMdlLength = ALIGN_UP(g_UlFixedHeadersMdlLength, PVOID);

    //
    // MDL Length for VariableHeaders or FixedHeaders + VariablesHeaders +
    // CopiedBuffer.
    //

    g_UlVariableHeadersMdlLength = (ULONG)
        MmSizeOfMdl(
            (PVOID)(PAGE_SIZE - 1),
            g_UlMaxFixedHeaderSize +
                g_UlMaxVariableHeaderSize +
                g_UlMaxCopyThreshold
            );

    g_UlVariableHeadersMdlLength = ALIGN_UP(g_UlVariableHeadersMdlLength, PVOID);

    //
    // MDL Length for Content.
    //

    g_UlContentMdlLength = (ULONG)
        MmSizeOfMdl(
            (PVOID)(PAGE_SIZE - 1),
            pConfig->UriConfig.MaxUriBytes
            );

    g_UlContentMdlLength = ALIGN_UP(g_UlContentMdlLength, PVOID);

    //
    // Initialize the default internal response buffer size.
    //

    if (DEFAULT_RESP_BUFFER_SIZE == g_UlResponseBufferSize)
    {
        g_UlResponseBufferSize =
            ALIGN_UP(sizeof(UL_INTERNAL_RESPONSE), PVOID) +
                UL_LOCAL_CHUNKS * sizeof(UL_INTERNAL_DATA_CHUNK) +
                g_UlMaxVariableHeaderSize +
                g_UlMaxFixedHeaderSize;
    }
 
    //
    // Initialize chunk and cache tracker size.
    //

    g_UlChunkTrackerSize =
        ALIGN_UP(sizeof(UL_CHUNK_TRACKER), PVOID) +
            ALIGN_UP(IoSizeOfIrp(DEFAULT_MAX_IRP_STACK_SIZE), PVOID);

    g_UlFullTrackerSize =
        ALIGN_UP(sizeof(UL_FULL_TRACKER), PVOID) +
            ALIGN_UP(IoSizeOfIrp(DEFAULT_MAX_IRP_STACK_SIZE), PVOID) +
            g_UlMaxFixedHeaderSize +
            g_UlMaxVariableHeaderSize +
            g_UlMaxCopyThreshold +
            g_UlFixedHeadersMdlLength +
            g_UlVariableHeadersMdlLength +
            g_UlContentMdlLength;

    g_UlFullTrackerSize = ALIGN_UP(g_UlFullTrackerSize, PVOID);

    if (DEFAULT_MAX_COPY_THRESHOLD == g_UlMaxCopyThreshold &&
        g_UlFullTrackerSize > UL_PAGE_SIZE &&
        (g_UlFullTrackerSize - UL_PAGE_SIZE) < (g_UlMaxFixedHeaderSize / 2))
    {
        g_UlMaxFixedHeaderSize -= (g_UlFullTrackerSize - UL_PAGE_SIZE);
        g_UlFullTrackerSize = UL_PAGE_SIZE;

        ASSERT(g_UlMaxFixedHeaderSize >= DEFAULT_MAX_FIXED_HEADER_SIZE / 2);
    }

    if (DEFAULT_GLOBAL_SEND_LIMIT == g_UlGlobalSendLimit)
    {
        //
        // Set GlobalSendLimit based on the size of NonPagedPool. Our
        // rudimentary algorithm says we want to use 1/8 of the total NPP
        // memory.
        //

        g_UlGlobalSendLimit = g_UlTotalNonPagedPoolBytes / 8;
    }

    //
    // Initialize the lookaside lists.
    //

    g_pUlNonpagedData->IrpContextLookaside =
        PplCreatePool(
            &UlAllocateIrpContextPool,              // Allocate
            &UlFreeIrpContextPool,                  // Free
            0,                                      // Flags
            sizeof(UL_IRP_CONTEXT),                 // Size
            UL_IRP_CONTEXT_POOL_TAG,                // Tag
            pConfig->IrpContextLookasideDepth       // Depth
            );

    if (!g_pUlNonpagedData->IrpContextLookaside)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    g_pUlNonpagedData->ReceiveBufferLookaside =
        PplCreatePool(
            &UlAllocateReceiveBufferPool,           // Allocate
            &UlFreeReceiveBufferPool,               // Free
            0,                                      // Flags
            sizeof(UL_RECEIVE_BUFFER),              // Size
            UL_RCV_BUFFER_POOL_TAG,                 // Tag
            pConfig->ReceiveBufferLookasideDepth    // Depth
            );

    if (!g_pUlNonpagedData->ReceiveBufferLookaside)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    g_pUlNonpagedData->ResponseBufferLookaside =
        PplCreatePool(
            &UlAllocateResponseBufferPool,          // Allocate
            &UlFreeResponseBufferPool,              // Free
            0,                                      // Flags
            g_UlResponseBufferSize,                 // Size
            UL_INTERNAL_RESPONSE_POOL_TAG,          // Tag
            pConfig->ResponseBufferLookasideDepth   // Depth
            );

    if (!g_pUlNonpagedData->ResponseBufferLookaside)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    g_pUlNonpagedData->RequestBufferLookaside =
        PplCreatePool(
            &UlAllocateRequestBufferPool,           // Allocate
            &UlFreeRequestBufferPool,               // Free
            0,                                      // Flags
            DEFAULT_MAX_REQUEST_BUFFER_SIZE,        // Size
            UL_REQUEST_BUFFER_POOL_TAG,             // Tag
            pConfig->RequestBufferLookasideDepth    // Depth
            );

    if (!g_pUlNonpagedData->RequestBufferLookaside)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    g_pUlNonpagedData->InternalRequestLookaside =
        PplCreatePool(
            &UlAllocateInternalRequestPool,         // Allocate
            &UlFreeInternalRequestPool,             // Free
            0,                                      // Flags
            sizeof(UL_INTERNAL_REQUEST),            // Size
            UL_INTERNAL_REQUEST_POOL_TAG,           // Tag
            pConfig->InternalRequestLookasideDepth  // Depth
            );

    if (!g_pUlNonpagedData->InternalRequestLookaside)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    g_pUlNonpagedData->ChunkTrackerLookaside =
        PplCreatePool(
            &UlAllocateChunkTrackerPool,            // Allocate
            &UlFreeChunkTrackerPool,                // Free
            0,                                      // Flags
            g_UlChunkTrackerSize,                   // Size
            UL_CHUNK_TRACKER_POOL_TAG,              // Tag
            pConfig->SendTrackerLookasideDepth      // Depth
            );

    if (!g_pUlNonpagedData->ChunkTrackerLookaside)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    g_pUlNonpagedData->FullTrackerLookaside =
        PplCreatePool(
            &UlAllocateFullTrackerPool,             // Allocate
            &UlFreeFullTrackerPool,                 // Free
            0,                                      // Flags
            g_UlFullTrackerSize,                    // Size
            UL_FULL_TRACKER_POOL_TAG,               // Tag
            pConfig->SendTrackerLookasideDepth      // Depth
            );

    if (!g_pUlNonpagedData->FullTrackerLookaside)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    g_pUlNonpagedData->LogFileBufferLookaside =
        PplCreatePool(
            &UlAllocateLogFileBufferPool,           // Allocate
            &UlFreeLogFileBufferPool,               // Free
            0,                                      // Flags
            sizeof(UL_LOG_FILE_BUFFER),             // Size
            UL_LOG_FILE_BUFFER_POOL_TAG,            // Tag
            pConfig->LogFileBufferLookasideDepth    // Depth
            );

    if (!g_pUlNonpagedData->LogFileBufferLookaside)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    g_pUlNonpagedData->BinaryLogDataBufferLookaside =
        PplCreatePool(
            &UlAllocateLogDataBufferPool,                                // Allocate
            &UlFreeLogDataBufferPool,                                    // Free
            0,                                                           // Flags
            sizeof(UL_LOG_DATA_BUFFER) + UL_BINARY_LOG_LINE_BUFFER_SIZE, // Size
            UL_BINARY_LOG_DATA_BUFFER_POOL_TAG,                          // Tag
            pConfig->LogDataBufferLookasideDepth                         // Depth
            );

    if (!g_pUlNonpagedData->BinaryLogDataBufferLookaside)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    g_pUlNonpagedData->AnsiLogDataBufferLookaside =
        PplCreatePool(
            &UlAllocateLogDataBufferPool,                              // Allocate
            &UlFreeLogDataBufferPool,                                  // Free
            0,                                                         // Flags
            sizeof(UL_LOG_DATA_BUFFER) + UL_ANSI_LOG_LINE_BUFFER_SIZE, // Size
            UL_ANSI_LOG_DATA_BUFFER_POOL_TAG,                          // Tag
            pConfig->LogDataBufferLookasideDepth                       // Depth
            );

    if (!g_pUlNonpagedData->AnsiLogDataBufferLookaside)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    g_pUlNonpagedData->ErrorLogBufferLookaside =
        PplCreatePool(
            &UlAllocateErrorLogBufferPool,              // Allocate
            &UlFreeErrorLogBufferPool,                  // Free
            0,                                          // Flags
            UL_ERROR_LOG_BUFFER_SIZE,                   // Size
            UL_ERROR_LOG_BUFFER_POOL_TAG,               // Tag
            pConfig->ErrorLogBufferLookasideDepth       // Depth
            );

    if (!g_pUlNonpagedData->ErrorLogBufferLookaside)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    return STATUS_SUCCESS;

}   // UlInitializeData


/***************************************************************************++

Routine Description:

    Performs global data termination.

--***************************************************************************/
VOID
UlTerminateData(
    VOID
    )
{
    //
    // Sanity check.
    //

    PAGED_CODE();
    ASSERT(g_UlTotalSendBytes == 0);

    if (g_pUlNonpagedData != NULL)
    {
        //
        // Kill the lookaside lists.
        //

        if (g_pUlNonpagedData->IrpContextLookaside)
        {
            PplDestroyPool( g_pUlNonpagedData->IrpContextLookaside, UL_IRP_CONTEXT_POOL_TAG);
        }

        if (g_pUlNonpagedData->ReceiveBufferLookaside)
        {
            PplDestroyPool( g_pUlNonpagedData->ReceiveBufferLookaside, UL_RCV_BUFFER_POOL_TAG );
        }

        if (g_pUlNonpagedData->RequestBufferLookaside)
        {
            PplDestroyPool( g_pUlNonpagedData->RequestBufferLookaside, UL_REQUEST_BUFFER_POOL_TAG );
        }

        if (g_pUlNonpagedData->InternalRequestLookaside)
        {
            PplDestroyPool( g_pUlNonpagedData->InternalRequestLookaside, UL_INTERNAL_REQUEST_POOL_TAG );
        }

        if (g_pUlNonpagedData->ChunkTrackerLookaside)
        {
            PplDestroyPool( g_pUlNonpagedData->ChunkTrackerLookaside, UL_CHUNK_TRACKER_POOL_TAG );
        }

        if (g_pUlNonpagedData->FullTrackerLookaside)
        {
            PplDestroyPool( g_pUlNonpagedData->FullTrackerLookaside, UL_FULL_TRACKER_POOL_TAG );
        }

        if (g_pUlNonpagedData->ResponseBufferLookaside)
        {
            PplDestroyPool( g_pUlNonpagedData->ResponseBufferLookaside, UL_INTERNAL_RESPONSE_POOL_TAG );
        }

        if (g_pUlNonpagedData->LogFileBufferLookaside)
        {
            PplDestroyPool( g_pUlNonpagedData->LogFileBufferLookaside, UL_LOG_FILE_BUFFER_POOL_TAG );
        }
        if (g_pUlNonpagedData->BinaryLogDataBufferLookaside)
        {
            PplDestroyPool( g_pUlNonpagedData->BinaryLogDataBufferLookaside,UL_BINARY_LOG_DATA_BUFFER_POOL_TAG );
        }
        if (g_pUlNonpagedData->AnsiLogDataBufferLookaside)
        {
            PplDestroyPool( g_pUlNonpagedData->AnsiLogDataBufferLookaside,UL_ANSI_LOG_DATA_BUFFER_POOL_TAG );
        }
        if (g_pUlNonpagedData->ErrorLogBufferLookaside)
        {
            PplDestroyPool( g_pUlNonpagedData->ErrorLogBufferLookaside,UL_ERROR_LOG_BUFFER_POOL_TAG );
        }

        //
        // Free the nonpaged data.
        //

        UL_FREE_POOL( g_pUlNonpagedData, UL_NONPAGED_DATA_POOL_TAG );
    }

}   // UlTerminateData
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\debug.h ===
/*++

Copyright (c) 1998-2002 Microsoft Corporation

Module Name:

    debug.h

Abstract:

    This module contains debug-specific declarations.

Author:

    Keith Moore (keithmo)       10-Jun-1998

Revision History:

--*/


#ifndef _DEBUG_H_
#define _DEBUG_H_


#define UL_DEFAULT_ERROR_ON_EXCEPTION       STATUS_INVALID_PARAMETER


#if DBG

//
// Initialization/termination functions.
//

VOID
UlDbgInitializeDebugData(
    VOID
    );

VOID
UlDbgTerminateDebugData(
    VOID
    );

//
// Driver entry/exit notifications.
//

VOID
UlDbgEnterDriver(
    IN PCSTR pFunctionName,
    IN PIRP pIrp OPTIONAL,
    IN PCSTR pFileName,
    IN USHORT LineNumber
    );

VOID
UlDbgLeaveDriver(
    IN PCSTR pFunctionName,
    IN PCSTR pFileName,
    IN USHORT LineNumber
    );

#define UL_ENTER_DRIVER( function, pirp )                                   \
    UlDbgEnterDriver(                                                       \
        (function),                                                         \
        (pirp),                                                             \
        __FILE__,                                                           \
        __LINE__                                                            \
        )

#define UL_LEAVE_DRIVER( function )                                         \
    UlDbgLeaveDriver(                                                       \
        (function),                                                         \
        __FILE__,                                                           \
        __LINE__                                                            \
        )


//
// An instrumented resource.
//

#define MAX_RESOURCE_NAME_LENGTH    64

typedef struct _UL_ERESOURCE
{
    //
    // The actual resource.
    //
    // N.B. This must be the first entry in the structure to make the
    //      debugger extension work properly!
    //

    ERESOURCE Resource;

    //
    // Links onto the global resource list.
    //

    LIST_ENTRY GlobalResourceListEntry;

    //
    // Pointer to the thread that owns this lock exclusively.
    //

    PETHREAD pExclusiveOwner;
    PETHREAD pPreviousOwner;

    //
    // The number of times this lock has been acquired recursively (in
    // exclusive acquisition case.)
    //

    LONG ExclusiveRecursionCount;

    //
    // Statistics.
    //

    LONG ExclusiveCount;
    LONG SharedCount;
    LONG ReleaseCount;

    //
    // The object that created this lock
    //

    ULONG OwnerTag;

    //
    // The name of the resource, for display purposes.
    //

    UCHAR ResourceName[MAX_RESOURCE_NAME_LENGTH];

} UL_ERESOURCE, *PUL_ERESOURCE;

NTSTATUS
UlDbgInitializeResource(
    IN PUL_ERESOURCE pResource,
    IN PCSTR pResourceName,
    IN ULONG_PTR Parameter,
    IN ULONG OwnerTag,
    IN PCSTR pFileName,
    IN USHORT LineNumber
    );

NTSTATUS
UlDbgDeleteResource(
    IN PUL_ERESOURCE pResource,
    IN PCSTR pFileName,
    IN USHORT LineNumber
    );

BOOLEAN
UlDbgAcquireResourceExclusive(
    IN PUL_ERESOURCE pResource,
    IN BOOLEAN Wait,
    IN PCSTR pFileName,
    IN USHORT LineNumber
    );

BOOLEAN
UlDbgAcquireResourceShared(
    IN PUL_ERESOURCE pResource,
    IN BOOLEAN Wait,
    IN PCSTR pFileName,
    IN USHORT LineNumber
    );

VOID
UlDbgReleaseResource(
    IN PUL_ERESOURCE pResource,
    IN PCSTR pFileName,
    IN USHORT LineNumber
    );

VOID
UlDbgConvertExclusiveToShared(
    IN PUL_ERESOURCE pResource,
    IN PCSTR pFileName,
    IN USHORT LineNumber
    );

BOOLEAN
UlDbgTryToAcquireResourceExclusive(
    IN PUL_ERESOURCE pResource,
    IN PCSTR pFileName,
    IN USHORT LineNumber
    );

BOOLEAN
UlDbgResourceOwnedExclusive(
    IN PUL_ERESOURCE pResource
    );

BOOLEAN
UlDbgResourceUnownedExclusive(
    IN PUL_ERESOURCE pResource
    );

PDRIVER_CANCEL
UlDbgIoSetCancelRoutine(
    PIRP             pIrp, 
    PDRIVER_CANCEL   pCancelRoutine
    );

#define UlInitializeResource( resource, name, param, tag )                  \
    UlDbgInitializeResource(                                                \
        (resource),                                                         \
        (name),                                                             \
        (ULONG_PTR)(param),                                                 \
        (tag),                                                              \
        __FILE__,                                                           \
        __LINE__                                                            \
        )

#define UlDeleteResource( resource )                                        \
    UlDbgDeleteResource(                                                    \
        (resource),                                                         \
        __FILE__,                                                           \
        __LINE__                                                            \
        )

#define UlAcquireResourceExclusive( resource, wait )                        \
    UlDbgAcquireResourceExclusive(                                          \
        (resource),                                                         \
        (wait),                                                             \
        __FILE__,                                                           \
        __LINE__                                                            \
        )

#define UlAcquireResourceShared( resource, wait )                           \
    UlDbgAcquireResourceShared(                                             \
        (resource),                                                         \
        (wait),                                                             \
        __FILE__,                                                           \
        __LINE__                                                            \
        )

#define UlReleaseResource( resource )                                       \
    UlDbgReleaseResource(                                                   \
        (resource),                                                         \
        __FILE__,                                                           \
        __LINE__                                                            \
        )

#define UlConvertExclusiveToShared( resource )                              \
    UlDbgConvertExclusiveToShared(                                          \
        (resource),                                                         \
        __FILE__,                                                           \
        __LINE__                                                            \
        )

#define UlTryToAcquireResourceExclusive( resource )                         \
    UlDbgTryToAcquireResourceExclusive(                                     \
        (resource),                                                         \
        __FILE__,                                                           \
        __LINE__                                                            \
        )

#define IS_RESOURCE_INITIALIZED( resource )                                 \
    ((resource)->Resource.SystemResourcesList.Flink != NULL)


//
// An instrumented push lock.
//

#define MAX_PUSHLOCK_NAME_LENGTH    64

typedef struct _UL_PUSH_LOCK
{
    //
    // The actual push lock.
    //
    // N.B. This must be the first entry in the structure to make the
    //      debugger extension work properly!
    //

    EX_PUSH_LOCK PushLock;

    //
    // Links onto the global push lock list.
    //

    LIST_ENTRY GlobalPushLockListEntry;

    //
    // Pointer to the thread that owns this lock exclusively.
    //

    PETHREAD pExclusiveOwner;
    PETHREAD pPreviousOwner;

    //
    // Statistics.
    //

    LONG ExclusiveCount;
    LONG SharedCount;
    LONG ReleaseCount;

    //
    // The object that created this lock
    //

    ULONG OwnerTag;

    //
    // The name of the push lock, for display purposes.
    //

    UCHAR PushLockName[MAX_PUSHLOCK_NAME_LENGTH];

} UL_PUSH_LOCK, *PUL_PUSH_LOCK;

VOID
UlDbgInitializePushLock(
    IN PUL_PUSH_LOCK pPushLock,
    IN PCSTR pPushLockName,
    IN ULONG_PTR Parameter,
    IN ULONG OwnerTag,
    IN PCSTR pFileName,
    IN USHORT LineNumber
    );

VOID
UlDbgDeletePushLock(
    IN PUL_PUSH_LOCK pPushLock,
    IN PCSTR pFileName,
    IN USHORT LineNumber
    );

VOID
UlDbgAcquirePushLockExclusive(
    IN PUL_PUSH_LOCK pPushLock,
    IN PCSTR pFileName,
    IN USHORT LineNumber
    );

VOID
UlDbgReleasePushLockExclusive(
    IN PUL_PUSH_LOCK pPushLock,
    IN PCSTR pFileName,
    IN USHORT LineNumber
    );

VOID
UlDbgAcquirePushLockShared(
    IN PUL_PUSH_LOCK pPushLock,
    IN PCSTR pFileName,
    IN USHORT LineNumber
    );

VOID
UlDbgReleasePushLockShared(
    IN PUL_PUSH_LOCK pPushLock,
    IN PCSTR pFileName,
    IN USHORT LineNumber
    );

VOID
UlDbgReleasePushLock(
    IN PUL_PUSH_LOCK pPushLock,
    IN PCSTR pFileName,
    IN USHORT LineNumber
    );

BOOLEAN
UlDbgPushLockOwnedExclusive(
    IN PUL_PUSH_LOCK pPushLock
    );

BOOLEAN
UlDbgPushLockUnownedExclusive(
    IN PUL_PUSH_LOCK pPushLock
    );

#define UlInitializePushLock( pushlock, name, param, tag )                  \
    UlDbgInitializePushLock(                                                \
        (pushlock),                                                         \
        (name),                                                             \
        (ULONG_PTR)(param),                                                 \
        (tag),                                                              \
        __FILE__,                                                           \
        __LINE__                                                            \
        )

#define UlDeletePushLock( pushlock )                                        \
    UlDbgDeletePushLock(                                                    \
        (pushlock),                                                         \
        __FILE__,                                                           \
        __LINE__                                                            \
        )

#define UlAcquirePushLockExclusive( pushlock )                              \
    UlDbgAcquirePushLockExclusive(                                          \
        (pushlock),                                                         \
        __FILE__,                                                           \
        __LINE__                                                            \
        )

#define UlReleasePushLockExclusive( pushlock )                              \
    UlDbgReleasePushLockExclusive(                                          \
        (pushlock),                                                         \
        __FILE__,                                                           \
        __LINE__                                                            \
        )

#define UlAcquirePushLockShared( pushlock )                                 \
    UlDbgAcquirePushLockShared(                                             \
        (pushlock),                                                         \
        __FILE__,                                                           \
        __LINE__                                                            \
        )

#define UlReleasePushLockShared( pushlock )                                 \
    UlDbgReleasePushLockShared(                                             \
        (pushlock),                                                         \
        __FILE__,                                                           \
        __LINE__                                                            \
        )

#define UlReleasePushLock( pushlock )                                       \
    UlDbgReleasePushLock(                                                   \
        (pushlock),                                                         \
        __FILE__,                                                           \
        __LINE__                                                            \
        )


//
// An instrumented spinlock.
//

typedef struct _UL_SPIN_LOCK    // SpinLock
{
    //
    // The actual lock.
    //
    // N.B. This must be the first entry in the structure to make the
    //      debugger extension work properly!
    //

    KSPIN_LOCK KSpinLock;

    //
    // The name of the spinlock, for display purposes.
    //

    PCSTR pSpinLockName;

    //
    // Pointer to the thread that owns this lock.
    //

    PETHREAD pOwnerThread;

    //
    // Statistics.
    //

    PCSTR pLastAcquireFileName;
    PCSTR pLastReleaseFileName;
    USHORT LastAcquireLineNumber;
    USHORT LastReleaseLineNumber;
    ULONG OwnerProcessor;
    LONG Acquisitions;
    LONG Releases;
    LONG AcquisitionsAtDpcLevel;
    LONG ReleasesFromDpcLevel;
    LONG Spare;

} UL_SPIN_LOCK, *PUL_SPIN_LOCK;

#define KSPIN_LOCK_FROM_UL_SPIN_LOCK( pLock )                               \
    &((pLock)->KSpinLock)

VOID
UlDbgInitializeSpinLock(
    IN PUL_SPIN_LOCK pSpinLock,
    IN PCSTR pSpinLockName,
    IN PCSTR pFileName,
    IN USHORT LineNumber
    );

VOID
UlDbgAcquireSpinLock(
    IN PUL_SPIN_LOCK pSpinLock,
    OUT PKIRQL pOldIrql,
    IN PCSTR pFileName,
    IN USHORT LineNumber
    );

VOID
UlDbgReleaseSpinLock(
    IN PUL_SPIN_LOCK pSpinLock,
    IN KIRQL OldIrql,
    IN PCSTR pFileName,
    IN USHORT LineNumber
    );

VOID
UlDbgAcquireSpinLockAtDpcLevel(
    IN PUL_SPIN_LOCK pSpinLock,
    IN PCSTR pFileName,
    IN USHORT LineNumber
    );

VOID
UlDbgReleaseSpinLockFromDpcLevel(
    IN PUL_SPIN_LOCK pSpinLock,
    IN PCSTR pFileName,
    IN USHORT LineNumber
    );

VOID
UlDbgAcquireInStackQueuedSpinLock(
    IN PUL_SPIN_LOCK pSpinLock,
    OUT PKLOCK_QUEUE_HANDLE pLockHandle,
    IN PCSTR pFileName,
    IN USHORT LineNumber
    );

VOID
UlDbgReleaseInStackQueuedSpinLock(
    IN PUL_SPIN_LOCK pSpinLock,
    IN PKLOCK_QUEUE_HANDLE pLockHandle,
    IN PCSTR pFileName,
    IN USHORT LineNumber
    );

VOID
UlDbgAcquireInStackQueuedSpinLockAtDpcLevel(
    IN PUL_SPIN_LOCK pSpinLock,
    OUT PKLOCK_QUEUE_HANDLE pLockHandle,
    IN PCSTR pFileName,
    IN USHORT LineNumber
    );

VOID
UlDbgReleaseInStackQueuedSpinLockFromDpcLevel(
    IN PUL_SPIN_LOCK pSpinLock,
    IN PKLOCK_QUEUE_HANDLE pLockHandle,
    IN PCSTR pFileName,
    IN USHORT LineNumber
    );

BOOLEAN
UlDbgSpinLockOwned(
    IN PUL_SPIN_LOCK pSpinLock
    );

BOOLEAN
UlDbgSpinLockUnowned(
    IN PUL_SPIN_LOCK pSpinLock
    );

#define UlInitializeSpinLock( spinlock, name )                              \
    UlDbgInitializeSpinLock(                                                \
        (spinlock),                                                         \
        (name),                                                             \
        __FILE__,                                                           \
        __LINE__                                                            \
        )

#define UlAcquireSpinLock( spinlock, oldirql )                              \
    UlDbgAcquireSpinLock(                                                   \
        (spinlock),                                                         \
        (oldirql),                                                          \
        __FILE__,                                                           \
        __LINE__                                                            \
        )

#define UlReleaseSpinLock( spinlock, oldirql )                              \
    UlDbgReleaseSpinLock(                                                   \
        (spinlock),                                                         \
        (oldirql),                                                          \
        __FILE__,                                                           \
        __LINE__                                                            \
        )

#define UlAcquireSpinLockAtDpcLevel( spinlock )                             \
    UlDbgAcquireSpinLockAtDpcLevel(                                         \
        (spinlock),                                                         \
        __FILE__,                                                           \
        __LINE__                                                            \
        )

#define UlReleaseSpinLockFromDpcLevel( spinlock )                           \
    UlDbgReleaseSpinLockFromDpcLevel(                                       \
        (spinlock),                                                         \
        __FILE__,                                                           \
        __LINE__                                                            \
        )

#define UlAcquireInStackQueuedSpinLock( spinlock, lockhandle )              \
    UlDbgAcquireInStackQueuedSpinLock(                                      \
        (spinlock),                                                         \
        (lockhandle),                                                       \
        __FILE__,                                                           \
        __LINE__                                                            \
        )

#define UlReleaseInStackQueuedSpinLock( spinlock, lockhandle )              \
    UlDbgReleaseInStackQueuedSpinLock(                                      \
        (spinlock),                                                         \
        (lockhandle),                                                       \
        __FILE__,                                                           \
        __LINE__                                                            \
        )

#define UlAcquireInStackQueuedSpinLockAtDpcLevel( spinlock, lockhandle )    \
    UlDbgAcquireInStackQueuedSpinLockAtDpcLevel(                            \
        (spinlock),                                                         \
        (lockhandle),                                                       \
        __FILE__,                                                           \
        __LINE__                                                            \
        )

#define UlReleaseInStackQueuedSpinLockFromDpcLevel( spinlock, lockhandle )  \
    UlDbgReleaseInStackQueuedSpinLockFromDpcLevel(                          \
        (spinlock),                                                         \
        (lockhandle),                                                       \
        __FILE__,                                                           \
        __LINE__                                                            \
        )


#define DEBUG

#if !TRACE_TO_STRING_LOG
# define WriteGlobalStringLog DbgPrint
#endif

VOID
UlDbgPrettyPrintBuffer(
    IN const UCHAR* pBuffer,
    IN ULONG_PTR    BufferSize
    );

//
// Debug pool allocator.
//

PVOID
UlDbgAllocatePool (
    IN POOL_TYPE PoolType,
    IN SIZE_T    NumberOfBytes,
    IN ULONG     Tag,
    IN PCSTR     pFileName,
    IN USHORT    LineNumber,
    IN PEPROCESS pProcess
    );

VOID
UlDbgFreePool (
    IN PVOID     pPointer,
    IN ULONG     Tag,
    IN PCSTR     pFileName,
    IN USHORT    LineNumber,
    IN POOL_TYPE PoolType,
    IN SIZE_T    NumberOfBytes,
    IN PEPROCESS pProcess
    );

#define UL_ALLOCATE_POOL( type, len, tag )                                  \
    UlDbgAllocatePool(                                                      \
        (type),                                                             \
        (len),                                                              \
        (tag),                                                              \
        __FILE__,                                                           \
        __LINE__,                                                           \
        NULL                                                                \
        )

#define UL_FREE_POOL( ptr, tag )                                            \
    UlDbgFreePool(                                                          \
        (ptr),                                                              \
        (tag),                                                              \
        __FILE__,                                                           \
        __LINE__,                                                           \
        PagedPool,                                                          \
        0,                                                                  \
        NULL                                                                \
        )

#define UL_ALLOCATE_POOL_WITH_QUOTA(type, len, tag, process)                \
    UlDbgAllocatePool(                                                      \
        (type),                                                             \
        (len),                                                              \
        (tag),                                                              \
        __FILE__,                                                           \
        __LINE__,                                                           \
        (process)                                                           \
        )

#define UL_FREE_POOL_WITH_QUOTA( ptr, tag, type, len, process )             \
    UlDbgFreePool(                                                          \
        (ptr),                                                              \
        (tag),                                                              \
        __FILE__,                                                           \
        __LINE__,                                                           \
        (type),                                                             \
        (len),                                                              \
        (process)                                                           \
        )

//
// Exception filter.
//

LONG
UlDbgExceptionFilter(
    IN PEXCEPTION_POINTERS pExceptionPointers,
    IN PCSTR pFileName,
    IN USHORT LineNumber
    );

#define UL_EXCEPTION_FILTER()                                               \
    UlDbgExceptionFilter(                                                   \
        GetExceptionInformation(),                                          \
        (PCSTR)__FILE__,                                                    \
        (USHORT)__LINE__                                                    \
        )

//
// Exception warning converter.
//

NTSTATUS
UlDbgConvertExceptionCode(
    IN NTSTATUS status,
    IN PCSTR pFileName,
    IN USHORT LineNumber
    );

#define UL_CONVERT_EXCEPTION_CODE(status)                                   \
        (NT_WARNING(status)   ?                                             \
                UlDbgConvertExceptionCode(                                  \
                    (status),                                               \
                    (PCSTR)__FILE__,                                        \
                    (USHORT)__LINE__ )                                      \
                :                                                           \
                (status))

//
// Invalid completion routine for catching incomplete IRP contexts.
//

VOID
UlDbgInvalidCompletionRoutine(
    IN PVOID pCompletionContext,
    IN NTSTATUS Status,
    IN ULONG_PTR Information
    );


//
// Error handlers.
//

NTSTATUS
UlDbgStatus(
    IN NTSTATUS Status,
    IN PCSTR pFileName,
    IN USHORT LineNumber
    );

VOID
UlDbgBreakOnError(
    PCSTR   pFilename,
    ULONG   LineNumber
    );

#if KERNEL_PRIV

#define RETURN(status)                                                      \
    return UlDbgStatus(                                                     \
                (status),                                                   \
                (PCSTR) __FILE__,                                           \
                (USHORT) __LINE__                                           \
                )

#define CHECK_STATUS(status)                                                \
    UlDbgStatus(                                                            \
        (status),                                                           \
        (PCSTR)__FILE__,                                                    \
        (USHORT)__LINE__                                                    \
        )

#endif // KERNEL_PRIV

//
// Random structure dumpers.
//

VOID
UlDbgDumpRequestBuffer(
    IN struct _UL_REQUEST_BUFFER *pBuffer,
    IN PCSTR pName
    );

VOID
UlDbgDumpHttpConnection(
    IN struct _UL_HTTP_CONNECTION *pConnection,
    IN PCSTR pName
    );


//
// IO wrappers.
//

PIRP
UlDbgAllocateIrp(
    IN CCHAR StackSize,
    IN BOOLEAN ChargeQuota,
    IN PCSTR pFileName,
    IN USHORT LineNumber
    );

VOID
UlDbgFreeIrp(
    IN PIRP pIrp,
    IN PCSTR pFileName,
    IN USHORT LineNumber
    );

NTSTATUS
UlDbgCallDriver(
    IN PDEVICE_OBJECT pDeviceObject,
    IN OUT PIRP pIrp,
    IN PCSTR pFileName,
    IN USHORT LineNumber
    );

VOID
UlDbgCompleteRequest(
    IN PIRP pIrp,
    IN CCHAR PriorityBoost,
    IN PCSTR pFileName,
    IN USHORT LineNumber
    );

#define UlAllocateIrp( stack, quota )                                       \
    UlDbgAllocateIrp(                                                       \
        (stack),                                                            \
        (quota),                                                            \
        (PCSTR)__FILE__,                                                    \
        (USHORT)__LINE__                                                    \
        )

#define UlFreeIrp( pirp )                                                   \
    UlDbgFreeIrp(                                                           \
        (pirp),                                                             \
        (PCSTR)__FILE__,                                                    \
        (USHORT)__LINE__                                                    \
        )

#define UlCallDriver( pdevice, pirp )                                       \
    UlDbgCallDriver(                                                        \
        (pdevice),                                                          \
        (pirp),                                                             \
        (PCSTR)__FILE__,                                                    \
        (USHORT)__LINE__                                                    \
        )

#define UlCompleteRequest( pirp, boost )                                    \
    UlDbgCompleteRequest(                                                   \
        (pirp),                                                             \
        (boost),                                                            \
        (PCSTR)__FILE__,                                                    \
        (USHORT)__LINE__                                                    \
        )

PMDL
UlDbgAllocateMdl(
    IN PVOID VirtualAddress,
    IN ULONG Length,
    IN BOOLEAN SecondaryBuffer,
    IN BOOLEAN ChargeQuota,
    IN OUT PIRP Irp,
    IN PCSTR pFileName,
    IN USHORT LineNumber
    );

VOID
UlDbgFreeMdl(
    IN PMDL Mdl,
    IN PCSTR pFileName,
    IN USHORT LineNumber
    );

#define UlAllocateMdl( add, len, second, quota, irp )                       \
    UlDbgAllocateMdl(                                                       \
        (add),                                                              \
        (len),                                                              \
        (second),                                                           \
        (quota),                                                            \
        (irp),                                                              \
        (PCSTR)__FILE__,                                                    \
        (USHORT)__LINE__                                                    \
        )

#define UlFreeMdl( mdl )                                                    \
    UlDbgFreeMdl(                                                           \
        (mdl),                                                              \
        (PCSTR)__FILE__,                                                    \
        (USHORT)__LINE__                                                    \
        )

// #define SPECIAL_MDL_FLAG    0x8000

PCSTR
UlDbgFindFilePart(
    IN PCSTR pPath
    );


//
// List Manipulation
//

#define UlRemoveEntryList(pEntry)                                           \
    do {                                                                    \
        ASSERT(NULL != (pEntry));                                           \
        ASSERT(NULL != (pEntry));                                           \
        ASSERT(NULL != (pEntry)->Flink);                                    \
        ASSERT(NULL != (pEntry)->Blink);                                    \
        RemoveEntryList(pEntry);                                            \
        (pEntry)->Flink = (pEntry)->Blink = NULL;                           \
    } while (0, 0)

#define UlIoSetCancelRoutine UlDbgIoSetCancelRoutine


#else   // !DBG  -----------------------------------------------------------


//
// Disable all of the above.
//

#define UL_ENTER_DRIVER( function, pirp )   NOP_FUNCTION
#define UL_LEAVE_DRIVER( function )         NOP_FUNCTION

#define UL_ERESOURCE ERESOURCE
#define PUL_ERESOURCE PERESOURCE

#define UlInitializeResource( resource, name, param, tag )                  \
    ExInitializeResourceLite( (resource) )

#define UlDeleteResource( resource )                                        \
    ExDeleteResourceLite( (resource) )

#define UlAcquireResourceExclusive( resource, wait )                        \
    do                                                                      \
    {                                                                       \
        KeEnterCriticalRegion();                                            \
        ExAcquireResourceExclusiveLite( (resource), (wait) );               \
    } while (0, 0)

#define UlAcquireResourceShared( resource, wait )                           \
    do                                                                      \
    {                                                                       \
        KeEnterCriticalRegion();                                            \
        ExAcquireResourceSharedLite( (resource), (wait) );                  \
    } while (0, 0)

#define UlReleaseResource( resource )                                       \
    do                                                                      \
    {                                                                       \
        ExReleaseResourceLite( (resource) );                                \
        KeLeaveCriticalRegion();                                            \
    } while (0, 0)

#define UlConvertExclusiveToShared( resource )                              \
    ExConvertExclusiveToSharedLite( (resource) )

__inline
BOOLEAN
UlTryToAcquireResourceExclusive(
    IN PERESOURCE Resource
    )
{
    BOOLEAN fLocked;
    KeEnterCriticalRegion();
    fLocked = ExAcquireResourceExclusiveLite( Resource, FALSE );
    if (! fLocked )
        KeLeaveCriticalRegion();
    return fLocked;
}

#define IS_RESOURCE_INITIALIZED( resource )                                 \
    ((resource)->SystemResourcesList.Flink != NULL)

#define UL_PUSH_LOCK  EX_PUSH_LOCK
#define PUL_PUSH_LOCK PEX_PUSH_LOCK

#define UlInitializePushLock( pushlock, name, param, tag )                  \
    ExInitializePushLock( (pushlock) )

#define UlDeletePushLock( pushlock )    NOP_FUNCTION

#define UlAcquirePushLockExclusive( pushlock )                              \
    do                                                                      \
    {                                                                       \
        KeEnterCriticalRegion();                                            \
        ExAcquirePushLockExclusive( (pushlock) );                           \
    } while (0, 0)

#define UlReleasePushLockExclusive( pushlock )                              \
    do                                                                      \
    {                                                                       \
        ExReleasePushLockExclusive( (pushlock) );                           \
        KeLeaveCriticalRegion();                                            \
    } while (0, 0)

#define UlAcquirePushLockShared( pushlock )                                 \
    do                                                                      \
    {                                                                       \
        KeEnterCriticalRegion();                                            \
        ExAcquirePushLockShared( (pushlock) );                              \
    } while (0, 0)

#define UlReleasePushLockShared( pushlock )                                 \
    do                                                                      \
    {                                                                       \
        ExReleasePushLockShared( (pushlock) );                              \
        KeLeaveCriticalRegion();                                            \
    } while (0, 0)

#define UlReleasePushLock( pushlock )                                       \
    do                                                                      \
    {                                                                       \
        ExReleasePushLock( (pushlock) );                                    \
        KeLeaveCriticalRegion();                                            \
    } while (0, 0)

#define UL_SPIN_LOCK  KSPIN_LOCK
#define PUL_SPIN_LOCK PKSPIN_LOCK

#define KSPIN_LOCK_FROM_UL_SPIN_LOCK( pLock ) (pLock)

#define UlInitializeSpinLock( spinlock, name )                              \
    KeInitializeSpinLock( (spinlock) )

#define UlAcquireSpinLock( spinlock, oldirql )                              \
    KeAcquireSpinLock( (spinlock), (oldirql) )

#define UlReleaseSpinLock( spinlock, oldirql )                              \
    KeReleaseSpinLock( (spinlock), (oldirql) )

#define UlAcquireSpinLockAtDpcLevel( spinlock )                             \
    KeAcquireSpinLockAtDpcLevel( (spinlock) )

#define UlReleaseSpinLockFromDpcLevel( spinlock )                           \
    KeReleaseSpinLockFromDpcLevel( (spinlock) )

#define UlAcquireInStackQueuedSpinLock( spinlock, lockhandle )              \
    KeAcquireInStackQueuedSpinLock( (spinlock), (lockhandle) )

#define UlReleaseInStackQueuedSpinLock( spinlock, lockhandle )              \
    KeReleaseInStackQueuedSpinLock( (lockhandle) )

#define KeAcquireInStackQueueddSpinLockAtDpcLevel( spinlock, lockhandle )   \
    KeAcquireInStackQueuedSpinLockAtDpcLevel( (spinlock), (lockhandle) )

#define UlReleaseInStackQueuedSpinLockFromDpcLevel( spinlock, lockhandle )  \
    KeReleaseInStackQueuedSpinLockFromDpcLevel( (lockhandle) )

#define UlDbgPrettyPrintBuffer(pBuffer, BufferSize)     NOP_FUNCTION

#define UL_ALLOCATE_POOL( type, len, tag )                                  \
    ExAllocatePoolWithTagPriority(                                          \
        (type),                                                             \
        (len),                                                              \
        (tag),                                                              \
        (LowPoolPriority)                                                   \
        )

#define UL_FREE_POOL( ptr, tag )                                            \
    MyFreePoolWithTag(                                                      \
        (ptr),                                                              \
        (tag)                                                               \
        )

__inline
PVOID  
UlAllocatePoolWithQuota(
    POOL_TYPE PoolType,
    SIZE_T    Length,
    ULONG     Tag,
    PEPROCESS pProcess
    )
{
    PVOID p;

    if (PsChargeProcessPoolQuota(
            pProcess,
            PoolType,
            Length) == STATUS_SUCCESS)
    {
        if ((p = ExAllocatePoolWithTagPriority(
                    PoolType,
                    Length,
                    Tag,
                    LowPoolPriority)) != NULL)
        {
            return p;
        }
    
        PsReturnPoolQuota(pProcess, PoolType, Length);
    }

    return NULL;
}

#define UL_ALLOCATE_POOL_WITH_QUOTA(type, len, tag, process)                \
    UlAllocatePoolWithQuota(                                                \
        (type),                                                             \
        (len),                                                              \
        (tag),                                                              \
        (process)                                                           \
        )

#define UL_FREE_POOL_WITH_QUOTA( ptr, tag, type, len, process )             \
    do                                                                      \
    {                                                                       \
        PsReturnPoolQuota(                                                  \
            (process),                                                      \
            (type),                                                         \
            (len));                                                         \
        MyFreePoolWithTag(                                                  \
            (ptr),                                                          \
            (tag)                                                           \
            );                                                              \
    } while (0, 0)
         

#define UL_EXCEPTION_FILTER()   EXCEPTION_EXECUTE_HANDLER

#define UL_CONVERT_EXCEPTION_CODE(status)                                   \
        (NT_WARNING(status) ? UL_DEFAULT_ERROR_ON_EXCEPTION : (status))

#if KERNEL_PRIV
# define RETURN(status)         return (status)
# define CHECK_STATUS(Status)   NOP_FUNCTION
#endif

#define UlAllocateIrp( stack, quota )                                       \
    IoAllocateIrp( (stack), (quota) )

#define UlFreeIrp( pirp )                                                   \
    IoFreeIrp( (pirp) )

#define UlCallDriver( pdevice, pirp )                                       \
    IoCallDriver( (pdevice), (pirp) )

#define UlCompleteRequest( pirp, boost )                                    \
    IoCompleteRequest( (pirp), (boost) )

#define UlAllocateMdl( add, len, second, quota, irp )                       \
    IoAllocateMdl(                                                          \
        (add),                                                              \
        (len),                                                              \
        (second),                                                           \
        (quota),                                                            \
        (irp)                                                               \
        )

#define UlFreeMdl( mdl )                                                    \
    IoFreeMdl( (mdl) )

#define UlRemoveEntryList(pEntry)                                           \
    RemoveEntryList(pEntry)

#define UlIoSetCancelRoutine                                                \
    IoSetCancelRoutine

#endif  // DBG


// Allocation wrapper helpers

#define UL_ALLOCATE_STRUCT_WITH_SPACE(pt,ot,cb,t)                           \
    (ot *)(UL_ALLOCATE_POOL(pt,ALIGN_UP(sizeof(ot),PVOID)+(cb),t))

#define UL_ALLOCATE_STRUCT(pt,ot,t)                                         \
    (ot *)(UL_ALLOCATE_POOL(pt,sizeof(ot),t))

#define UL_ALLOCATE_ARRAY(pt,et,c,t)                                        \
    (et *)(UL_ALLOCATE_POOL(pt,sizeof(et)*(c),t))

#define UL_FREE_POOL_WITH_SIG(p,sig)                                        \
    do {                                                                    \
        PREFAST_ASSUME(NULL != (p), "Callers check this");                  \
        (p)->Signature = MAKE_FREE_SIGNATURE(sig);                          \
        UL_FREE_POOL(p,sig);                                                \
        (p) = NULL;                                                         \
    } while (0)

#define HAS_VALID_SIGNATURE(p, sig)                                         \
    ( (NULL != (p))  && ((sig) == (p)->Signature) )


#endif  // _DEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\create.c ===
/*++

Copyright (c) 1998-2002 Microsoft Corporation

Module Name:

    create.c

Abstract:

    This module contains code for opening a handle to UL.

Author:

    Keith Moore (keithmo)       10-Jun-1998

Revision History:

--*/


#include "precomp.h"


#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, UlCreate )
#endif  // ALLOC_PRAGMA

#define IS_NAMED_FILE_OBJECT(pFileObject)         \
     ((pFileObject)->FileName.Length != 0)


//
// Public functions.
//

/***************************************************************************++

Routine Description:

    This is the routine that handles Create IRPs in Http.sys. Create IRPs are
    issued when the file object is created.

Control Channel (\Device\Http\Control)
    - unnamed only
    - open only, create to fail.
    - Open will be allowed by any user.
    - EA must have proper major/minorversion, everything else must be NULL/0

AppPool (\Device\Http\AppPool)
    - can be unnamed or named
    - unnamed --> anyone can create, no one can open (server API customers)
    - named --> admin only can create, anyone with correct SD can open 
      (IIS WAS + Worker process)
    - EA must have proper major/minorversion, everything else must be NULL/0

Filter (\Device\Http\Filter)
    - only named and MUST be either SSLFilterChannel or SSLClientFilterChannel.
    - SSLFilterChannel can be created only by admin/local system, opened with 
      correct SD.
    - SSLClientFilterChannel can be created by anyone, opened by anyone 
      with correct SD, but only if EnableHttpClient is set
    - EA must have proper major/minorversion, everything else must be NULL/0

Server (\Device\Http\Server\)
    - only unnamed
    - Create only, open to fail.
    - can be done by anyone.
    - Should be allowed only if EnableHttpClient is present.
    - EA must have major/minorversion, server & TRANSPORT_ADDRESS structure. 
      Proxy is optional. 

Arguments:

    pDeviceObject - Supplies a pointer to the target device object.

    pIrp - Supplies a pointer to IO request packet.


Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlCreate(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    )
{
    NTSTATUS                   status;
    PIO_STACK_LOCATION         pIrpSp;
    PFILE_OBJECT               pFileObject = NULL;
    PFILE_FULL_EA_INFORMATION  pEaBuffer;
    PHTTP_OPEN_PACKET          pOpenPacket;
    UCHAR                      createDisposition;
    PWSTR                      pName = NULL;
    USHORT                     nameLength;
    PIO_SECURITY_CONTEXT       pSecurityContext;
    STRING                     CompareVersionName;
    STRING                     EaName;
    PWSTR                      pSafeName = NULL;

    //
    // Sanity check.
    //

    PAGED_CODE();
    UL_ENTER_DRIVER( "UlCreate", pIrp );

#if defined(_WIN64)
    //
    // We do not support 32-bit processes on 64-bit platforms.
    //
    if (IoIs32bitProcess(pIrp))
    {
        status = STATUS_NOT_SUPPORTED;
        goto complete;
    }
#endif

    //
    // Find and validate the open packet.
    //
    pEaBuffer = (PFILE_FULL_EA_INFORMATION)(pIrp->AssociatedIrp.SystemBuffer);

    if (pEaBuffer == NULL)
    {
        status = STATUS_INVALID_PARAMETER; 
        goto complete;
    }
    
    RtlInitString(&CompareVersionName,  HTTP_OPEN_PACKET_NAME);
    
    EaName.MaximumLength = pEaBuffer->EaNameLength + 1;
    EaName.Length        = pEaBuffer->EaNameLength;
    EaName.Buffer        = pEaBuffer->EaName;

    if ( RtlEqualString(&CompareVersionName, &EaName, FALSE) )
    {
        //
        // Found the version information in the EA
        //

        if( pEaBuffer->EaValueLength != sizeof(*pOpenPacket) )
        {
            status = STATUS_INVALID_PARAMETER; 
            goto complete;
    
        }

        if(pEaBuffer->NextEntryOffset != 0)
        {
            status = STATUS_INVALID_PARAMETER;
            goto complete;
        }
        
        pOpenPacket = (PHTTP_OPEN_PACKET)
            (pEaBuffer->EaName + pEaBuffer->EaNameLength + 1 );

        ASSERT(pOpenPacket == ALIGN_UP_POINTER(pOpenPacket, PVOID));
    
        //
        // For now, we'll fail if the incoming version doesn't EXACTLY match
        // the expected version. In future, we may need to be a bit more
        // flexible to allow down-level clients.
        //
    
        if (pOpenPacket->MajorVersion != HTTP_INTERFACE_VERSION_MAJOR ||
            pOpenPacket->MinorVersion != HTTP_INTERFACE_VERSION_MINOR)
        {
            status = STATUS_REVISION_MISMATCH;
            goto complete;
        }

        if(pDeviceObject != g_pUcServerDeviceObject &&
           (pOpenPacket->ProxyNameLength != 0        ||
            pOpenPacket->ServerNameLength != 0       ||
            pOpenPacket->TransportAddressLength != 0 ||
            pOpenPacket->pProxyName != NULL          ||
            pOpenPacket->pServerName != NULL         ||
            pOpenPacket->pTransportAddress != NULL))
        {
            status = STATUS_INVALID_PARAMETER;
            goto complete;
        }
    }
    else
    {
        status = STATUS_INVALID_PARAMETER;
        goto complete;
    }
            
    //
    // Snag the current IRP stack pointer, then extract the creation
    // disposition. IO stores this as the high byte of the Options field.
    // Also snag the file object; we'll need it often.
    //

    pIrpSp = IoGetCurrentIrpStackLocation( pIrp );

    createDisposition = (UCHAR)( pIrpSp->Parameters.Create.Options >> 24 );
    pFileObject = pIrpSp->FileObject;
    pSecurityContext = pIrpSp->Parameters.Create.SecurityContext;
    ASSERT( pSecurityContext != NULL );

    //
    // Determine if this is a request to open a control channel or
    // open/create an app pool.
    //

    if (pDeviceObject == g_pUlControlDeviceObject)
    {
        //
        // It's a control channel.
        //
        // Validate the creation disposition. We allow open only.
        //

        if (createDisposition != FILE_OPEN)
        {
            status = STATUS_INVALID_PARAMETER;
            goto complete;
        }

        // These things can't be named

        if (IS_NAMED_FILE_OBJECT(pFileObject))
        {
            status = STATUS_INVALID_PARAMETER;
            goto complete;
        }

        ASSERT(pFileObject->FileName.Buffer == NULL);

        UlTrace(OPEN_CLOSE, (
            "UlCreate: opening a control channel: %p\n",
            pFileObject
            ));

        //
        // Open the control channel.
        //

        status = UlCreateControlChannel(GET_PP_CONTROL_CHANNEL(pFileObject));

        if (NT_SUCCESS(status))
        {
            ASSERT( GET_CONTROL_CHANNEL(pFileObject) != NULL );
            MARK_VALID_CONTROL_CHANNEL( pFileObject );
        }
    }
    else if (pDeviceObject == g_pUlFilterDeviceObject)
    {

        //
        // It's a filter channel - It has to be named and has to be either
        // a client or a server filter channel.
        //

        if (!IS_NAMED_FILE_OBJECT(pFileObject))
        {
            status = STATUS_INVALID_PARAMETER;
            goto complete;
        }

        ASSERT(L'\\' == pFileObject->FileName.Buffer[0]);
        pName = pFileObject->FileName.Buffer + 1;
        nameLength = pFileObject->FileName.Length - sizeof(WCHAR);

        pSafeName = UL_ALLOCATE_POOL(
                        PagedPool,
                        nameLength + sizeof(WCHAR),
                        UL_STRING_LOG_BUFFER_POOL_TAG
                        );

        if(pSafeName == NULL)
        {
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto complete;
        }

        RtlCopyMemory(pSafeName, pName, nameLength);
        pSafeName[nameLength/sizeof(WCHAR)] = L'\0';
        pName = pSafeName;

        if(IsServerFilterChannel(pName, nameLength))
        {
            // Yes - it's a filter channel. We'll allow Create or Open but 
            // both have to be admin only.

            //
            // If it's create, we'll do an access check
            //

            if(createDisposition == FILE_CREATE)
            {
                status =  UlAccessCheck(
                                g_pAdminAllSystemAll,
                                pSecurityContext->AccessState,
                                pSecurityContext->DesiredAccess,
                                pIrp->RequestorMode,
                                pName
                                );
        
                if(!NT_SUCCESS(status))
                {
                    goto complete;
                }
            }
            else if(createDisposition == FILE_OPEN)
            {
                // We are opening an existing channel - the access check 
                // will be done inside UlAttachFilterProcess
            }
            else
            {
                // Neither FILE_CREATE nor FILE_OPEN. Bail!
                status = STATUS_INVALID_PARAMETER;
                goto complete;
                
            }

            UlTrace(OPEN_CLOSE, (
                "UlCreate: opening a server filter channel: %p, %.*ls\n",
                pFileObject, nameLength / sizeof(WCHAR), pName
                ));

        }
        else if(IsClientFilterChannel(pName, nameLength))
        {
            // It's a client - Only Create. Also, make sure that the client
            // code is really enabled.

            if (createDisposition != FILE_CREATE || !g_HttpClientEnabled)
            {
                status = STATUS_INVALID_PARAMETER;
                goto complete;
            }

            UlTrace(OPEN_CLOSE, (
                "UlCreate: opening a client filter channel: %p, %.*ls\n",
                pFileObject, nameLength / sizeof(WCHAR), pName
                ));

            // 
            // No access checks for the client!
            //
        }
        else
        {
            //
            // If it is neither server nor client filter channel, fail the
            // call.
            //

            status = STATUS_INVALID_PARAMETER;
            goto complete;
        }

        status = UlAttachFilterProcess(
                        pName,
                        nameLength,
                        (BOOLEAN)(createDisposition == FILE_CREATE),
                        pSecurityContext->AccessState,
                        pSecurityContext->DesiredAccess,
                        pIrp->RequestorMode,
                        GET_PP_FILTER_PROCESS(pFileObject)
                        );

        if (NT_SUCCESS(status))
        {
            ASSERT( GET_FILTER_PROCESS(pFileObject) != NULL );
            MARK_VALID_FILTER_CHANNEL( pFileObject );
        }
    
    }
    else if(pDeviceObject == g_pUlAppPoolDeviceObject )
    {
        //
        // It's an app pool.
        //

        //
        // Bind to the specified app pool.
        //
    
        if (!IS_NAMED_FILE_OBJECT(pFileObject))
        {
            ASSERT(pFileObject->FileName.Buffer == NULL);

            pName = NULL;
            nameLength = 0;

            // Validate the creation disposition. We allow create only
            // for unnamed app-pools.

            if(createDisposition != FILE_CREATE)
            {
                status = STATUS_INVALID_PARAMETER;
                goto complete;
            }

            UlTrace(OPEN_CLOSE, (
                "UlCreate: opening an unnamed AppPool: %p\n",
                pFileObject
                ));
        }
        else
        {
            if (pFileObject->FileName.Length > UL_MAX_APP_POOL_NAME_SIZE)
            {
                status = STATUS_OBJECT_NAME_INVALID;
                goto complete;
            }

            // Skip the preceding '\' in the FileName added by iomgr.
            //

            ASSERT(L'\\' == pFileObject->FileName.Buffer[0]);
            pName = pFileObject->FileName.Buffer + 1;
            nameLength = pFileObject->FileName.Length - sizeof(WCHAR);

            pSafeName = UL_ALLOCATE_POOL(
                            PagedPool,
                            nameLength + sizeof(WCHAR),
                            UL_STRING_LOG_BUFFER_POOL_TAG
                            );

            if(pSafeName == NULL)
            {
                status = STATUS_INSUFFICIENT_RESOURCES;
                goto complete;
            }

            RtlCopyMemory(pSafeName, pName, nameLength);
            pSafeName[nameLength/sizeof(WCHAR)] = L'\0';
            pName = pSafeName;

            if(createDisposition == FILE_CREATE)
            {
                //
                // Creation of named app-pools must be only for admins.
                //
                // The filter object is has FileAll for Admin/LocalSystem only
                // so, we'll piggy back on that security descriptor.
                //
    
                status =  UlAccessCheck(
                                g_pAdminAllSystemAll,
                                pSecurityContext->AccessState,
                                pSecurityContext->DesiredAccess,
                                pIrp->RequestorMode,
                                pName
                                );
    
                if(!NT_SUCCESS(status))
                {
                    goto complete;
                }
            }
            else if(createDisposition == FILE_OPEN)
            {
                // UlAttachProcessToAppPool will do the appropriate checks
                // to ensure that the security descriptors match.
            }
            else
            {
                // Neither FILE_CREATE nor FILE_OPEN.

                status = STATUS_INVALID_PARAMETER;
                goto complete;
            }

            UlTrace(OPEN_CLOSE, (
                "UlCreate: opening an AppPool: %p, %.*ls\n",
                pFileObject, nameLength / sizeof(WCHAR), pName
                ));
        }

        status = UlAttachProcessToAppPool(
                        pName,
                        nameLength,
                        (BOOLEAN)(createDisposition == FILE_CREATE),
                        pSecurityContext->AccessState,
                        pSecurityContext->DesiredAccess,
                        pIrp->RequestorMode,
                        GET_PP_APP_POOL_PROCESS(pFileObject)
                        );

        if (NT_SUCCESS(status))
        {
            ASSERT( GET_APP_POOL_PROCESS(pFileObject) != NULL );
            MARK_VALID_APP_POOL( pFileObject );
        }
    }
    else 
    {
        ASSERT(pDeviceObject == g_pUcServerDeviceObject );
        ASSERT(g_HttpClientEnabled);

        //
        // It is mandatory for the application to pass in a valid version 
        // and a valid URI. If either of this is missing, we bail.
        //
        //
       
        if(pOpenPacket->ServerNameLength == 0       ||
           pOpenPacket->pServerName == NULL         ||
           pOpenPacket->pTransportAddress == NULL   ||
           pOpenPacket->TransportAddressLength == 0 ||
           IS_NAMED_FILE_OBJECT(pFileObject)
          )
        {
            status =  STATUS_INVALID_PARAMETER;
            goto complete;
        }

        if(createDisposition != FILE_CREATE)
        {
            status =  STATUS_INVALID_PARAMETER;
            goto complete;
        }

        UlTrace(OPEN_CLOSE, (
            "UlCreate: opening a ServInfo: %p\n",
            pFileObject
            ));

        //
        // Create our context here and store it in 
        // pIrpSp->FileObject->FsContext
        //
    
        status = UcCreateServerInformation(
                    (PUC_PROCESS_SERVER_INFORMATION *)
                        &pFileObject->FsContext,
                        pOpenPacket->pServerName,
                        pOpenPacket->ServerNameLength,
                        pOpenPacket->pProxyName,
                        pOpenPacket->ProxyNameLength,
                        pOpenPacket->pTransportAddress,
                        pOpenPacket->TransportAddressLength,
                        pIrp->RequestorMode
                        );
    
        //
        // UC_BUGBUG (INVESTIGATE) 
        //
        // Setting this field to non-NULL value enable fast IO code path
        // for reads and writes.
        //
        // pIrpSp->FileObject->PrivateCacheMap = (PVOID)-1;

        MARK_VALID_SERVER( pFileObject );
    }

    //
    // Complete the request.
    //
    
complete:

    if(pSafeName)
    {
        ASSERT(pSafeName == pName);
        UL_FREE_POOL(pSafeName, UL_STRING_LOG_BUFFER_POOL_TAG);
    }

    UlTrace(OPEN_CLOSE, (
        "UlCreate: %s file object = %p, %s\n",
        (NT_SUCCESS(status) ? "opened" : "did not open"),
        pFileObject,
        HttpStatusToString(status)
        ));
    
    pIrp->IoStatus.Status = status;

    UlCompleteRequest( pIrp, IO_NO_INCREMENT );

    UL_LEAVE_DRIVER( "UlCreate" );
    RETURN(status);
    
}   // UlCreate
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\debug.c ===
/*++

Copyright (c) 1998-2002 Microsoft Corporation

Module Name:

    debug.c

Abstract:

    This module contains debug support routines.

Author:

    Keith Moore (keithmo)       10-Jun-1998

Revision History:

--*/


#include "precomp.h"
#include "debugp.h"


#if DBG


#undef ExAllocatePool
#undef ExFreePool


#ifdef ALLOC_PRAGMA
#if DBG
#pragma alloc_text( INIT, UlDbgInitializeDebugData )
#pragma alloc_text( PAGE, UlDbgTerminateDebugData )
#pragma alloc_text( PAGE, UlDbgAcquireResourceExclusive )
#pragma alloc_text( PAGE, UlDbgAcquireResourceShared )
#pragma alloc_text( PAGE, UlDbgReleaseResource )
#pragma alloc_text( PAGE, UlDbgConvertExclusiveToShared)
#pragma alloc_text( PAGE, UlDbgTryToAcquireResourceExclusive)
#pragma alloc_text( PAGE, UlDbgResourceOwnedExclusive )
#pragma alloc_text( PAGE, UlDbgResourceUnownedExclusive )
#pragma alloc_text( PAGE, UlDbgAcquirePushLockExclusive )
#pragma alloc_text( PAGE, UlDbgReleasePushLockExclusive )
#pragma alloc_text( PAGE, UlDbgAcquirePushLockShared )
#pragma alloc_text( PAGE, UlDbgReleasePushLockShared )
#pragma alloc_text( PAGE, UlDbgReleasePushLock )
#pragma alloc_text( PAGE, UlDbgPushLockOwnedExclusive )
#pragma alloc_text( PAGE, UlDbgPushLockUnownedExclusive )
#endif  // DBG

#if 0
NOT PAGEABLE -- UlDbgAllocatePool
NOT PAGEABLE -- UlDbgFreePool
NOT PAGEABLE -- UlDbgInitializeSpinLock
NOT PAGEABLE -- UlDbgAcquireSpinLock
NOT PAGEABLE -- UlDbgReleaseSpinLock
NOT PAGEABLE -- UlDbgAcquireSpinLockAtDpcLevel
NOT PAGEABLE -- UlDbgReleaseSpinLockFromDpcLevel
NOT PAGEABLE -- UlDbgSpinLockOwned
NOT PAGEABLE -- UlDbgSpinLockUnowned
NOT PAGEABLE -- UlDbgExceptionFilter
NOT PAGEABLE -- UlDbgInvalidCompletionRoutine
NOT PAGEABLE -- UlDbgStatus
NOT PAGEABLE -- UlDbgEnterDriver
NOT PAGEABLE -- UlDbgLeaveDriver
NOT PAGEABLE -- UlDbgInitializeResource
NOT PAGEABLE -- UlDbgDeleteResource
NOT PAGEABLE -- UlDbgInitializePushLock
NOT PAGEABLE -- UlDbgDeletePushLock
NOT PAGEABLE -- UlDbgAllocateIrp
NOT PAGEABLE -- UlDbgFreeIrp
NOT PAGEABLE -- UlDbgCallDriver
NOT PAGEABLE -- UlDbgCompleteRequest
NOT PAGEABLE -- UlDbgAllocateMdl
NOT PAGEABLE -- UlDbgFreeMdl
NOT PAGEABLE -- UlDbgFindFilePart
NOT PAGEABLE -- UlpDbgUpdatePoolCounter
NOT PAGEABLE -- UlpDbgFindThread
NOT PAGEABLE -- UlpDbgDereferenceThread
NOT PAGEABLE -- UlDbgIoSetCancelRoutine
#endif
#endif  // ALLOC_PRAGMA


//
// Private globals.
//

UL_THREAD_HASH_BUCKET g_DbgThreadHashBuckets[NUM_THREAD_HASH_BUCKETS];

// Count of threads
LONG g_DbgThreadCreated;
LONG g_DbgThreadDestroyed;

KSPIN_LOCK g_DbgSpinLock;   // protects global debug data

LIST_ENTRY g_DbgGlobalResourceListHead;
LIST_ENTRY g_DbgGlobalPushLockListHead;

#if ENABLE_MDL_TRACKER
LIST_ENTRY   g_DbgMdlListHead;
#endif


//
// Public functions.
//

/***************************************************************************++

Routine Description:

    Initializes global debug-specific data.

--***************************************************************************/
VOID
UlDbgInitializeDebugData(
    VOID
    )
{
    ULONG i;

    //
    // Initialize the lock lists.
    //

    KeInitializeSpinLock( &g_DbgSpinLock );
    InitializeListHead( &g_DbgGlobalResourceListHead );
    InitializeListHead( &g_DbgGlobalPushLockListHead );


#if ENABLE_MDL_TRACKER
    InitializeListHead( &g_DbgMdlListHead );
#endif

    //
    // Initialize the thread hash buckets.
    //

    for (i = 0 ; i < NUM_THREAD_HASH_BUCKETS ; i++)
    {
        KeInitializeSpinLock(&g_DbgThreadHashBuckets[i].BucketSpinLock); 
        g_DbgThreadHashBuckets[i].Count = 0; 
        g_DbgThreadHashBuckets[i].Max = 0; 
        InitializeListHead(&g_DbgThreadHashBuckets[i].BucketListHead);
    }

}   // UlDbgInitializeDebugData


/***************************************************************************++

Routine Description:

    Undoes any initialization performed in UlDbgInitializeDebugData().

--***************************************************************************/
VOID
UlDbgTerminateDebugData(
    VOID
    )
{
    ULONG i;

    //
    // Ensure the thread hash buckets are empty.
    //

    for (i = 0 ; i < NUM_THREAD_HASH_BUCKETS ; i++)
    {
        ASSERT( IsListEmpty( &g_DbgThreadHashBuckets[i].BucketListHead ) );
        ASSERT( g_DbgThreadHashBuckets[i].Count == 0 ); 

        // UlDeleteMutex(&g_DbgThreadHashBuckets[i].BucketSpinLock);
    }

    //
    // Ensure the lock lists are empty.
    //

    ASSERT( IsListEmpty( &g_DbgGlobalResourceListHead ) );
    ASSERT( IsListEmpty( &g_DbgGlobalPushLockListHead ) );

#if ENABLE_MDL_TRACKER
    ASSERT( IsListEmpty( &g_DbgMdlListHead ) );
#endif

    // UlDeleteMutex( &g_DbgSpinLock );

}   // UlDbgTerminateDebugData


/***************************************************************************++

Routine Description:

    Prettyprints a buffer to DbgPrint output (or the global STRING_LOG).
    More or less turns it back into a C-style string.

    CODEWORK: produce a Unicode version of this helper function

Arguments:

    Buffer - Buffer to prettyprint

    BufferSize - number of bytes to prettyprint

--***************************************************************************/
VOID
UlDbgPrettyPrintBuffer(
    IN const UCHAR* pBuffer,
    IN ULONG_PTR    BufferSize
    )
{
    ULONG   i;
    CHAR    OutputBuffer[200];
    PCHAR   pOut;
    BOOLEAN CrLfNeeded = FALSE, JustCrLfd = FALSE;

#define PRETTY_PREFIX(pOut)                                         \
    pOut = OutputBuffer; *pOut++ = '|'; *pOut++ = '>';              \
    *pOut++ = ' '; *pOut++ = ' '

#define PRETTY_SUFFIX(pOut)                                         \
    *pOut++ = ' '; *pOut++ = '<'; *pOut++ = '|';                    \
    *pOut++ = '\n'; *pOut++ = '\0';                                 \
    ASSERT(DIFF(pOut - OutputBuffer) <= sizeof(OutputBuffer))

    const ULONG SuffixLength = 5;   // strlen(" <|\n\0")
    const ULONG MaxTokenLength = 4; // strlen('\xAB')

    if (pBuffer == NULL  ||  BufferSize == 0)
        return;

    PRETTY_PREFIX(pOut);

    for (i = 0;  i < BufferSize;  ++i)
    {
        UCHAR ch = pBuffer[i];

        if ('\r' == ch)         // CR
        {
            *pOut++ = '\\'; *pOut++ = 'r';
            if (i + 1 == BufferSize  ||  '\n' != pBuffer[i + 1])
                CrLfNeeded = TRUE;
        }
        else if ('\n' == ch)    // LF
        {
            *pOut++ = '\\'; *pOut++ = 'n';
            CrLfNeeded = TRUE;
        }
        else if ('\t' == ch)    // TAB
        {
            *pOut++ = '\\'; *pOut++ = 't';
        }
        else if ('\0' == ch)    // NUL
        {
            *pOut++ = '\\'; *pOut++ = '0';
        }
        else if ('\\' == ch)    // \ (backslash)
        {
            *pOut++ = '\\'; *pOut++ = '\\';
        }
        else if ('%' == ch)     //  an unescaped '%' will confuse printf
        {
            *pOut++ = '%'; *pOut++ = '%';
        }
        else if (ch < 0x20  ||  127 == ch)  // control chars
        {
            const UCHAR HexString[] = "0123456789abcdef";

            *pOut++ = '\\'; *pOut++ = 'x';
            *pOut++ = HexString[ch >> 4];
            *pOut++ = HexString[ch & 0xf];
        }
        else
        {
            *pOut++ = ch;
        }

        if ((ULONG)(pOut - OutputBuffer)
            >= sizeof(OutputBuffer) - MaxTokenLength - SuffixLength)
        {
            CrLfNeeded = TRUE;
        }

        if (CrLfNeeded)
        {
            PRETTY_SUFFIX(pOut);
            WriteGlobalStringLog(OutputBuffer);

            PRETTY_PREFIX(pOut);
            CrLfNeeded = FALSE;
            JustCrLfd  = TRUE;
        }
        else
        {
            JustCrLfd = FALSE;
        }
    }

    if (!JustCrLfd)
    {
        PRETTY_SUFFIX(pOut);
        WriteGlobalStringLog(OutputBuffer);
    }
} // UlDbgPrettyPrintBuffer



/***************************************************************************++

Routine Description:

    Debug memory allocator. Allocates a block of pool with a header
    containing the filename & line number of the caller, plus the
    tag for the data.

Arguments:

    PoolType - Supplies the pool to allocate from. Must be either
        NonPagedPool or PagedPool.

    NumberOfBytes - Supplies the number of bytes to allocate.

    Tag - Supplies a four-byte tag for the pool block. Useful for
        debugging leaks.

    pFileName - Supplies the filename of the caller.
        function.

    LineNumber - Supplies the line number of the caller.

Return Value:

    PVOID - Pointer to the allocated block if successful, NULL otherwise.

--***************************************************************************/
PVOID
UlDbgAllocatePool(
    IN POOL_TYPE PoolType,
    IN SIZE_T    NumberOfBytes,
    IN ULONG     Tag,
    IN PCSTR     pFileName,
    IN USHORT    LineNumber,
    IN PEPROCESS pProcess
    )
{
    //
    // CODEWORK: factor out the different portions that depend
    // on ENABLE_POOL_HEADER, ENABLE_POOL_TRAILER, and
    // ENABLE_POOL_TRAILER_BYTE_SIGNATURE.
    //
    
    PUL_POOL_HEADER  pHeader;
    PUL_POOL_TRAILER pTrailer;
    USHORT           TrailerPadSize;
    USHORT           i;
    PUCHAR           pBody;
    SIZE_T           Size;

    //
    // Sanity check.
    //

    ASSERT( PoolType == NonPagedPool || PoolType == PagedPool );

    ASSERT( IS_VALID_TAG( Tag ) );

    ASSERT(NumberOfBytes > 0);

    TrailerPadSize
        = (USHORT) (sizeof(UL_POOL_TRAILER)
                        - (NumberOfBytes & (sizeof(UL_POOL_TRAILER) - 1)));

    ASSERT(0 < TrailerPadSize  &&  TrailerPadSize <= sizeof(UL_POOL_TRAILER));
    ASSERT(((NumberOfBytes+TrailerPadSize) & (sizeof(UL_POOL_TRAILER)-1)) == 0);

    //
    // Allocate the block with additional space for the header and trailer.
    //

    Size = sizeof(UL_POOL_HEADER) + NumberOfBytes + TrailerPadSize
            + sizeof(UL_POOL_TRAILER);

    pHeader = (PUL_POOL_HEADER)(
                    ExAllocatePoolWithTagPriority(
                        PoolType,
                        Size,
                        Tag,
                        LowPoolPriority
                        )
                    );

    if (pHeader == NULL)
    {
        WRITE_REF_TRACE_LOG(
            g_pPoolAllocTraceLog,
            REF_ACTION_POOL_ALLOC_FAIL_NO_MEM,
            (LONG) NumberOfBytes,
            NULL,
            pFileName,
            LineNumber
            );

        return NULL;
    }

    if (pProcess)
    {
        //
        // We are going to charge this memory to a process.
        //

        if (PsChargeProcessPoolQuota(
                                pProcess,
                                PoolType,
                                Size) != STATUS_SUCCESS)
        {
            WRITE_REF_TRACE_LOG(
                g_pPoolAllocTraceLog,
                REF_ACTION_POOL_ALLOC_FAIL_NO_QUOTA,
                (LONG) NumberOfBytes,
                NULL,
                pFileName,
                LineNumber
                );

            ExFreePoolWithTag(pHeader, Tag);

            return NULL;
        }

    }

    //
    // Initialize the header.
    //

    pHeader->pProcess = pProcess;
    pHeader->pFileName = pFileName;
    pHeader->Size = NumberOfBytes;
    pHeader->Tag = Tag;
    pHeader->LineNumber = LineNumber;
    pHeader->TrailerPadSize = TrailerPadSize;

#ifdef UL_POOL_HEADER_PADDING
    pHeader->Padding = ~ (ULONG_PTR) pHeader;
#endif


    //
    // Fill the body with garbage.
    //

    pBody = (PUCHAR) (pHeader + 1);
    RtlFillMemory( pBody, NumberOfBytes, (UCHAR)'\xC' );

#ifdef ENABLE_POOL_TRAILER_BYTE_SIGNATURE
    //
    // Fill the padding at the end with a distinct, recognizable pattern
    //

    for (i = 0; i < TrailerPadSize; ++i)
    {
        pBody[NumberOfBytes + i]
            = UlpAddressToByteSignature(pBody + NumberOfBytes + i);
    }
#endif // ENABLE_POOL_TRAILER_BYTE_SIGNATURE

    //
    // Initialize the trailer struct
    //
    
    pTrailer = (PUL_POOL_TRAILER) (pBody + NumberOfBytes + TrailerPadSize);
    ASSERT(((ULONG_PTR) pTrailer & (MEMORY_ALLOCATION_ALIGNMENT - 1)) == 0);

    pTrailer->pHeader  = pHeader;
    pTrailer->CheckSum = UlpPoolHeaderChecksum(pHeader);

    WRITE_REF_TRACE_LOG(
        g_pPoolAllocTraceLog,
        REF_ACTION_POOL_ALLOC,
        (LONG) NumberOfBytes,
        pBody,
        pFileName,
        LineNumber
        );

    //
    // Return a pointer to the body.
    //

    return pBody;

}   // UlDbgAllocatePool


/***************************************************************************++

Routine Description:

    Frees memory allocated by UlDbgAllocatePool(), ensuring that the tags
    match.

Arguments:

    pPointer - Supplies a pointer to the pool block to free.

    Tag - Supplies the tag for the block to be freed. If the supplied
        tag does not match the tag of the allocated block, an assertion
        failure is generated.

--***************************************************************************/
VOID
UlDbgFreePool(
    IN PVOID     pPointer,
    IN ULONG     Tag,
    IN PCSTR     pFileName,
    IN USHORT    LineNumber,
    IN POOL_TYPE PoolType,
    IN SIZE_T    NumberOfBytes,
    IN PEPROCESS pProcess
    )
{
    PUL_POOL_HEADER pHeader;
    PUL_POOL_TRAILER pTrailer;
    USHORT          TrailerPadSize;
    USHORT          i;
    PUCHAR          pBody = (PUCHAR) pPointer;
    ULONG_PTR       CheckSum;

    //
    // Get a pointer to the header.
    //

    pHeader  = (PUL_POOL_HEADER) pPointer - 1;
    CheckSum = UlpPoolHeaderChecksum(pHeader);

    ASSERT(pHeader->pProcess == pProcess);

    if (pHeader->pProcess)
    {
        SIZE_T Size;

        ASSERT(NumberOfBytes != 0);
        ASSERT(NumberOfBytes == pHeader->Size);

        Size = sizeof(UL_POOL_HEADER) + 
               NumberOfBytes + 
               pHeader->TrailerPadSize +
               sizeof(UL_POOL_TRAILER);

        PsReturnPoolQuota(
                pHeader->pProcess,
                PoolType,
                Size
                );
    }
                
    //
    // Validate the tag.
    //

    ASSERT(pHeader->Tag == Tag);
    ASSERT( IS_VALID_TAG( Tag ) );

    //
    // Validate the trailer
    //

    TrailerPadSize = pHeader->TrailerPadSize;
    ASSERT(0 < TrailerPadSize  &&  TrailerPadSize <= sizeof(UL_POOL_TRAILER));

#ifdef UL_POOL_HEADER_PADDING
    ASSERT(pHeader->Padding == ~ (ULONG_PTR) pHeader);
#endif

    pTrailer = (PUL_POOL_TRAILER) (pBody + pHeader->Size + TrailerPadSize);
    ASSERT(((ULONG_PTR) pTrailer & (MEMORY_ALLOCATION_ALIGNMENT - 1)) == 0);
    ASSERT(pTrailer->pHeader == pHeader);

    //
    // Has the header been corrupted? Was there a buffer underrun?
    //

    ASSERT(CheckSum == pTrailer->CheckSum);

#ifdef ENABLE_POOL_TRAILER_BYTE_SIGNATURE
    //
    // Is the pattern between the end of pBody and pTrailer still correct?
    // Was there a buffer overrun?
    //
    
    for (i = 0; i < TrailerPadSize; ++i)
    {
        ASSERT(pBody[pHeader->Size + i]
               == UlpAddressToByteSignature(pBody + pHeader->Size + i));
    }
#endif // ENABLE_POOL_TRAILER_BYTE_SIGNATURE

    //
    // Fill the body with garbage.
    //

    RtlFillMemory( pBody, pHeader->Size, (UCHAR)'\xE' );

    pHeader->Tag = MAKE_FREE_TAG( Tag );

    //
    // Actually free the block.
    //

    WRITE_REF_TRACE_LOG(
        g_pPoolAllocTraceLog,
        REF_ACTION_POOL_FREE,
        (LONG) pHeader->Size,
        pBody,
        pFileName,
        LineNumber
        );

    MyFreePoolWithTag(
        (PVOID)pHeader,
        Tag
        );

}   // UlDbgFreePool


/***************************************************************************++

Routine Description:

    Initializes an instrumented spinlock.

--***************************************************************************/
VOID
UlDbgInitializeSpinLock(
    IN PUL_SPIN_LOCK pSpinLock,
    IN PCSTR pSpinLockName,
    IN PCSTR pFileName,
    IN USHORT LineNumber
    )
{
    UNREFERENCED_PARAMETER(pFileName);
    UNREFERENCED_PARAMETER(LineNumber);

    //
    // Initialize the spinlock.
    //

    RtlZeroMemory( pSpinLock, sizeof(*pSpinLock) );
    pSpinLock->pSpinLockName = pSpinLockName;
    KeInitializeSpinLock( &pSpinLock->KSpinLock );
    SET_SPIN_LOCK_NOT_OWNED( pSpinLock );

}   // UlDbgInitializeSpinLock


/***************************************************************************++

Routine Description:

    Acquires an instrumented spinlock.

--***************************************************************************/
VOID
UlDbgAcquireSpinLock(
    IN PUL_SPIN_LOCK pSpinLock,
    OUT PKIRQL pOldIrql,
    IN PCSTR pFileName,
    IN USHORT LineNumber
    )
{
    //
    // Sanity check.
    //

    ASSERT( !UlDbgSpinLockOwned( pSpinLock ) );

    //
    // Acquire the lock.
    //

    KeAcquireSpinLock(
        &pSpinLock->KSpinLock,
        pOldIrql
        );

    //
    // Mark it as owned by the current thread.
    //

    ASSERT( UlDbgSpinLockUnowned( pSpinLock ) );
    SET_SPIN_LOCK_OWNED( pSpinLock );

    //
    // Update the statistics.
    //

    pSpinLock->Acquisitions++;
    pSpinLock->pLastAcquireFileName = pFileName;
    pSpinLock->LastAcquireLineNumber = LineNumber;

}   // UlDbgAcquireSpinLock


/***************************************************************************++

Routine Description:

    Releases an instrumented spinlock.

--***************************************************************************/
VOID
UlDbgReleaseSpinLock(
    IN PUL_SPIN_LOCK pSpinLock,
    IN KIRQL OldIrql,
    IN PCSTR pFileName,
    IN USHORT LineNumber
    )
{
    //
    // Mark it as unowned.
    //

    ASSERT( UlDbgSpinLockOwned( pSpinLock ) );
    SET_SPIN_LOCK_NOT_OWNED( pSpinLock );

    pSpinLock->Releases++;
    pSpinLock->pLastReleaseFileName = pFileName;
    pSpinLock->LastReleaseLineNumber = LineNumber;

    //
    // Release the lock.
    //

    KeReleaseSpinLock(
        &pSpinLock->KSpinLock,
        OldIrql
        );

}   // UlDbgReleaseSpinLock


/***************************************************************************++

Routine Description:

    Acquires an instrumented spinlock while running at DPC level.

--***************************************************************************/
VOID
UlDbgAcquireSpinLockAtDpcLevel(
    IN PUL_SPIN_LOCK pSpinLock,
    IN PCSTR pFileName,
    IN USHORT LineNumber
    )
{
    //
    // Sanity check.
    //

    ASSERT( !UlDbgSpinLockOwned( pSpinLock ) );

    //
    // Acquire the lock.
    //

    KeAcquireSpinLockAtDpcLevel(
        &pSpinLock->KSpinLock
        );

    //
    // Mark it as owned by the current thread.
    //

    ASSERT( !UlDbgSpinLockOwned( pSpinLock ) );
    SET_SPIN_LOCK_OWNED( pSpinLock );

    //
    // Update the statistics.
    //

    pSpinLock->AcquisitionsAtDpcLevel++;
    pSpinLock->pLastAcquireFileName = pFileName;
    pSpinLock->LastAcquireLineNumber = LineNumber;

}   // UlDbgAcquireSpinLockAtDpcLevel


/***************************************************************************++

Routine Description:

    Releases an instrumented spinlock acquired at DPC level.

--***************************************************************************/
VOID
UlDbgReleaseSpinLockFromDpcLevel(
    IN PUL_SPIN_LOCK pSpinLock,
    IN PCSTR pFileName,
    IN USHORT LineNumber
    )
{
    //
    // Mark it as unowned.
    //

    ASSERT( UlDbgSpinLockOwned( pSpinLock ) );
    SET_SPIN_LOCK_NOT_OWNED( pSpinLock );

    pSpinLock->ReleasesFromDpcLevel++;
    pSpinLock->pLastReleaseFileName = pFileName;
    pSpinLock->LastReleaseLineNumber = LineNumber;

    //
    // Release the lock.
    //

    KeReleaseSpinLockFromDpcLevel(
        &pSpinLock->KSpinLock
        );

}   // UlDbgReleaseSpinLockAtDpcLevel


/***************************************************************************++

Routine Description:

    Acquires an instrumented in-stack-queue spinlock.

--***************************************************************************/
VOID
UlDbgAcquireInStackQueuedSpinLock(
    IN PUL_SPIN_LOCK pSpinLock,
    OUT PKLOCK_QUEUE_HANDLE pLockHandle,
    IN PCSTR pFileName,
    IN USHORT LineNumber
    )
{
    //
    // Sanity check.
    //

    ASSERT( !UlDbgSpinLockOwned( pSpinLock ) );

    //
    // Acquire the lock.
    //

    KeAcquireInStackQueuedSpinLock(
        &pSpinLock->KSpinLock,
        pLockHandle
        );

    //
    // Mark it as owned by the current thread.
    //

    ASSERT( UlDbgSpinLockUnowned( pSpinLock ) );
    SET_SPIN_LOCK_OWNED( pSpinLock );

    //
    // Update the statistics.
    //

    pSpinLock->Acquisitions++;
    pSpinLock->pLastAcquireFileName = pFileName;
    pSpinLock->LastAcquireLineNumber = LineNumber;

}   // UlDbgAcquireInStackQueuedSpinLock


/***************************************************************************++

Routine Description:

    Releases an instrumented in-stack-queue spinlock.

--***************************************************************************/
VOID
UlDbgReleaseInStackQueuedSpinLock(
    IN PUL_SPIN_LOCK pSpinLock,
    IN PKLOCK_QUEUE_HANDLE pLockHandle,
    IN PCSTR pFileName,
    IN USHORT LineNumber
    )
{
    //
    // Mark it as unowned.
    //

    ASSERT( UlDbgSpinLockOwned( pSpinLock ) );
    SET_SPIN_LOCK_NOT_OWNED( pSpinLock );

    //
    // Update the statistics.
    //

    pSpinLock->Releases++;
    pSpinLock->pLastReleaseFileName = pFileName;
    pSpinLock->LastReleaseLineNumber = LineNumber;

    //
    // Release the lock.
    //

    KeReleaseInStackQueuedSpinLock(
        pLockHandle
        );

}   // UlDbgReleaseInStackQueuedSpinLock


/***************************************************************************++

Routine Description:

    Acquires an instrumented in-stack-queue spinlock while running at DPC level.

--***************************************************************************/
VOID
UlDbgAcquireInStackQueuedSpinLockAtDpcLevel(
    IN PUL_SPIN_LOCK pSpinLock,
    OUT PKLOCK_QUEUE_HANDLE pLockHandle,
    IN PCSTR pFileName,
    IN USHORT LineNumber
    )
{
    //
    // Sanity check.
    //

    ASSERT( !UlDbgSpinLockOwned( pSpinLock ) );

    //
    // Acquire the lock.
    //

    KeAcquireInStackQueuedSpinLockAtDpcLevel(
        &pSpinLock->KSpinLock,
        pLockHandle
        );

    //
    // Mark it as owned by the current thread.
    //

    ASSERT( !UlDbgSpinLockOwned( pSpinLock ) );
    SET_SPIN_LOCK_OWNED( pSpinLock );

    //
    // Update the statistics.
    //

    pSpinLock->AcquisitionsAtDpcLevel++;
    pSpinLock->pLastAcquireFileName = pFileName;
    pSpinLock->LastAcquireLineNumber = LineNumber;

}   // UlDbgAcquireInStackQueuedSpinLockAtDpcLevel


/***************************************************************************++

Routine Description:

    Releases an instrumented in-stack-queue spinlock acquired at DPC level.

--***************************************************************************/
VOID
UlDbgReleaseInStackQueuedSpinLockFromDpcLevel(
    IN PUL_SPIN_LOCK pSpinLock,
    IN PKLOCK_QUEUE_HANDLE pLockHandle,
    IN PCSTR pFileName,
    IN USHORT LineNumber
    )
{
    //
    // Mark it as unowned.
    //

    ASSERT( UlDbgSpinLockOwned( pSpinLock ) );
    SET_SPIN_LOCK_NOT_OWNED( pSpinLock );

    //
    // Update the statistics.
    //

    pSpinLock->ReleasesFromDpcLevel++;
    pSpinLock->pLastReleaseFileName = pFileName;
    pSpinLock->LastReleaseLineNumber = LineNumber;

    //
    // Release the lock.
    //

    KeReleaseInStackQueuedSpinLockFromDpcLevel(
        pLockHandle
        );

}   // UlDbgReleaseInStackQueuedSpinLockFromDpcLevel


/***************************************************************************++

Routine Description:

    Determines if the specified spinlock is owned by the current thread.

Arguments:

    pSpinLock - Supplies the spinlock to test.

Return Value:

    BOOLEAN - TRUE if the spinlock is owned by the current thread, FALSE
        otherwise.

--***************************************************************************/
BOOLEAN
UlDbgSpinLockOwned(
    IN PUL_SPIN_LOCK pSpinLock
    )
{
    if (pSpinLock->pOwnerThread == PsGetCurrentThread())
    {
        ASSERT( pSpinLock->OwnerProcessor == (ULONG)KeGetCurrentProcessorNumber() );
        return TRUE;
    }

    return FALSE;

}   // UlDbgSpinLockOwned


/***************************************************************************++

Routine Description:

    Determines if the specified spinlock is unowned.

Arguments:

    pSpinLock - Supplies the spinlock to test.

Return Value:

    BOOLEAN - TRUE if the spinlock is unowned, FALSE otherwise.

--***************************************************************************/
BOOLEAN
UlDbgSpinLockUnowned(
    IN PUL_SPIN_LOCK pSpinLock
    )
{
    if (pSpinLock->pOwnerThread == NULL)
    {
        return TRUE;
    }

    return FALSE;

}   // UlDbgSpinLockUnowned


/***************************************************************************++

Routine Description:

    Filter for exceptions caught with try/except.

Arguments:

    pExceptionPointers - Supplies information identifying the source
        and type of exception raised.

    pFileName - Supplies the name of the file generating the exception.

    LineNumber - Supplies the line number of the exception filter that
        caught the exception.

Return Value:

    LONG - Should always be EXCEPTION_EXECUTE_HANDLER

--***************************************************************************/
LONG
UlDbgExceptionFilter(
    IN PEXCEPTION_POINTERS pExceptionPointers,
    IN PCSTR pFileName,
    IN USHORT LineNumber
    )
{
    //
    // Protect ourselves just in case the process is completely messed up.
    //

    __try
    {
        //
        // Whine about it.
        //

        DbgPrint(
            "UlDbgExceptionFilter: exception 0x%08lx @ %p, caught in %s:%d\n",
            pExceptionPointers->ExceptionRecord->ExceptionCode,
            pExceptionPointers->ExceptionRecord->ExceptionAddress,
            UlDbgFindFilePart( pFileName ),
            LineNumber
            );

        if (g_UlBreakOnError)
        {
            DbgBreakPoint();
        }
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        //
        // Not much we can do here...
        //

        NOTHING;
    }

    return EXCEPTION_EXECUTE_HANDLER;

}   // UlDbgExceptionFilter

/***************************************************************************++

Routine Description:

    Sometimes it's not acceptable to proceed with warnings ( as status ) after
    we caught an exception. I.e. Caught a misaligned warning during sendresponse
    and called the IoCompleteRequest with status misaligned. This will cause Io
    Manager to complete request to port, even though we don't want it to happen.

    In that case we have to carefully replace warnings with a generic error.

Arguments:

    pExceptionPointers - Supplies information identifying the source
        and type of exception raised.

    pFileName - Supplies the name of the file generating the exception.

    LineNumber - Supplies the line number of the exception filter that
        caught the exception.

Return Value:

    NTSTATUS - Converted error value : UL_DEFAULT_ERROR_ON_EXCEPTION

--***************************************************************************/

NTSTATUS
UlDbgConvertExceptionCode(
    IN NTSTATUS status,
    IN PCSTR pFileName,
    IN USHORT LineNumber
    )
{
    //
    // Whine about it.
    //

    DbgPrint(
        "UlDbgConvertExceptionCode: "
        "exception 0x%08lx converted to 0x%08lx, at %s:%hu\n",
        status,
        UL_DEFAULT_ERROR_ON_EXCEPTION,
        UlDbgFindFilePart( pFileName ),
        LineNumber
        );

    return UL_DEFAULT_ERROR_ON_EXCEPTION;
}

/***************************************************************************++

Routine Description:

    Completion handler for incomplete IRP contexts.

Arguments:

    pCompletionContext - Supplies an uninterpreted context value
        as passed to the asynchronous API.

    Status - Supplies the final completion status of the
        asynchronous API.

    Information - Optionally supplies additional information about
        the completed operation, such as the number of bytes
        transferred.

--***************************************************************************/
VOID
UlDbgInvalidCompletionRoutine(
    IN PVOID pCompletionContext,
    IN NTSTATUS Status,
    IN ULONG_PTR Information
    )
{
    UlTrace(TDI, (
        "UlDbgInvalidCompletionRoutine called!\n"
        "    pCompletionContext = %p\n"
        "    Status = 0x%08lx\n"
        "    Information = %Iu\n",
        pCompletionContext,
        Status,
        Information
        ));

    ASSERT( !"UlDbgInvalidCompletionRoutine called!" );

}   // UlDbgInvalidCompletionRoutine


/***************************************************************************++

Routine Description:

    Hook for catching failed operations. This routine is called within each
    routine with the completion status.

Arguments:

    Status - Supplies the completion status.

    pFileName - Supplies the filename of the caller.

    LineNumber - Supplies the line number of the caller.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlDbgStatus(
    IN NTSTATUS Status,
    IN PCSTR pFileName,
    IN USHORT LineNumber
    )
{
    UNREFERENCED_PARAMETER(pFileName);
    UNREFERENCED_PARAMETER(LineNumber);

    //
    // paulmcd: ignore STATUS_END_OF_FILE.  this is a non-fatal return value
    //

    if (!NT_SUCCESS(Status) && Status != STATUS_END_OF_FILE)
    {
        if (g_UlVerboseErrors)
        {
            DbgPrint(
                "UlDbgStatus: %s:%hu returning 0x%08lx\n",
                UlDbgFindFilePart( pFileName ),
                LineNumber,
                Status
                );
        }

        if (g_UlBreakOnError)
        {
            DbgBreakPoint();
        }
    }

    return Status;

}   // UlDbgStatus


/***************************************************************************++

Routine Description:

    Stop at a breakpoint if g_UlBreakOnError is set

Arguments:

    pFileName - Supplies the filename of the caller.

    LineNumber - Supplies the line number of the caller.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
VOID
UlDbgBreakOnError(
    PCSTR   pFileName,
    ULONG   LineNumber
    )
{
    if (g_UlBreakOnError)
    {
        DbgPrint(
            "HttpCmnDebugBreakOnError @ %s:%hu\n",
            UlDbgFindFilePart( pFileName ),
            LineNumber
            );

        DbgBreakPoint();
    }
} // UlDbgBreakOnError



/***************************************************************************++

Routine Description:

    Routine invoked upon entry into the driver.

Arguments:

    pFunctionName - Supplies the name of the function used to enter
        the driver.

    pIrp - Supplies an optional IRP to log.

    pFileName - Supplies the filename of the caller.

    LineNumber - Supplies the line number of the caller.

--***************************************************************************/
VOID
UlDbgEnterDriver(
    IN PCSTR pFunctionName,
    IN PIRP pIrp OPTIONAL,
    IN PCSTR pFileName,
    IN USHORT LineNumber
    )
{
#if ENABLE_THREAD_DBEUG
    PUL_DEBUG_THREAD_DATA pData;
#endif

    UNREFERENCED_PARAMETER(pFunctionName);
#if !ENABLE_IRP_TRACE
    UNREFERENCED_PARAMETER(pFileName);
    UNREFERENCED_PARAMETER(LineNumber);
#endif

    //
    // Log the IRP.
    //

    if (pIrp != NULL)
    {
        WRITE_IRP_TRACE_LOG(
            g_pIrpTraceLog,
            IRP_ACTION_INCOMING_IRP,
            pIrp,
            pFileName,
            LineNumber
            );
    }

#if ENABLE_THREAD_DBEUG
    //
    // Find/create an entry for the current thread.
    //

    pData = ULP_DBG_FIND_OR_CREATE_THREAD();

    if (pData != NULL)
    {

        //
        // This should be the first time we enter the driver
        // unless we are stealing this thread due to an interrupt,
        // or we are calling another driver and they are calling
        // our completion routine in-line.
        //

        ASSERT( KeGetCurrentIrql() > PASSIVE_LEVEL ||
                pData->ExternalCallCount > 0 ||
                (pData->ResourceCount == 0 && pData->PushLockCount == 0) );
    }
#endif

}   // UlDbgEnterDriver


/***************************************************************************++

Routine Description:

    Routine invoked upon exit from the driver.

Arguments:

    pFunctionName - Supplies the name of the function used to enter
        the driver.

    pFileName - Supplies the filename of the caller.

    LineNumber - Supplies the line number of the caller.

--***************************************************************************/
VOID
UlDbgLeaveDriver(
    IN PCSTR pFunctionName,
    IN PCSTR pFileName,
    IN USHORT LineNumber
    )
{
#if ENABLE_THREAD_DBEUG
    PUL_DEBUG_THREAD_DATA pData;
#endif

    UNREFERENCED_PARAMETER(pFunctionName);
    UNREFERENCED_PARAMETER(pFileName);
    UNREFERENCED_PARAMETER(LineNumber);

#if ENABLE_THREAD_DBEUG
    //
    // Find an existing entry for the current thread.
    //

    pData = ULP_DBG_FIND_THREAD();

    if (pData != NULL)
    {
        //
        // Ensure no resources are acquired, then kill the thread data.
        //
        // we might have a resource acquired if we borrowed the thread
        // due to an interrupt.
        //
        // N.B. We dereference the thread data twice: once for the
        //      call to ULP_DBG_FIND_THREAD() above, once for the call
        //      made when entering the driver.
        //

        ASSERT( KeGetCurrentIrql() > PASSIVE_LEVEL ||
                pData->ExternalCallCount > 0 ||
                (pData->ResourceCount == 0 && pData->PushLockCount == 0) );

        ASSERT( pData->ReferenceCount >= 2 );
        ULP_DBG_DEREFERENCE_THREAD( pData );
        ULP_DBG_DEREFERENCE_THREAD( pData );
    }
#endif

}   // UlDbgLeaveDriver


/***************************************************************************++

Routine Description:

    Initialize an instrumented resource.

Arguments:

    pResource - Supplies the resource to initialize.

    pResourceName - Supplies a display name for the resource.

    Parameter - Supplies a ULONG_PTR parameter passed into sprintf()
        when creating the resource name.

    pFileName - Supplies the filename of the caller.

    LineNumber - Supplies the line number of the caller.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlDbgInitializeResource(
    IN PUL_ERESOURCE pResource,
    IN PCSTR pResourceName,
    IN ULONG_PTR Parameter,
    IN ULONG OwnerTag,
    IN PCSTR pFileName,
    IN USHORT LineNumber
    )
{
    NTSTATUS status;
    KIRQL oldIrql;

    UNREFERENCED_PARAMETER(pFileName);
    UNREFERENCED_PARAMETER(LineNumber);

    //
    // Initialize the resource.
    //

    status = ExInitializeResourceLite( &pResource->Resource );

    if (NT_SUCCESS(status))
    {
        pResource->ExclusiveRecursionCount = 0;
        pResource->ExclusiveCount = 0;
        pResource->SharedCount = 0;
        pResource->ReleaseCount = 0;
        pResource->OwnerTag = OwnerTag;

        _snprintf(
            (char*) pResource->ResourceName,
            sizeof(pResource->ResourceName) - 1,
            pResourceName,
            Parameter
            );

        pResource->ResourceName[sizeof(pResource->ResourceName) - 1] = '\0';

        SET_RESOURCE_NOT_OWNED_EXCLUSIVE( pResource );

        //
        // Put it on the global list.
        //

        KeAcquireSpinLock( &g_DbgSpinLock, &oldIrql );
        InsertHeadList(
            &g_DbgGlobalResourceListHead,
            &pResource->GlobalResourceListEntry
            );
        KeReleaseSpinLock( &g_DbgSpinLock, oldIrql );
    }
    else
    {
        pResource->GlobalResourceListEntry.Flink = NULL;
    }

    return status;

}   // UlDbgInitializeResource


/***************************************************************************++

Routine Description:

    Deletes an instrumented resource.

Arguments:

    pResource - Supplies the resource to delete.

    pFileName - Supplies the filename of the caller.

    LineNumber - Supplies the line number of the caller.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlDbgDeleteResource(
    IN PUL_ERESOURCE pResource,
    IN PCSTR pFileName,
    IN USHORT LineNumber
    )
{
    NTSTATUS status;
    KIRQL oldIrql;
    PETHREAD pExclusiveOwner;

    UNREFERENCED_PARAMETER(pFileName);
    UNREFERENCED_PARAMETER(LineNumber);

    //
    // Sanity check.
    //

    ASSERT(pResource);
    pExclusiveOwner = pResource->pExclusiveOwner;

    if (pExclusiveOwner != NULL)
    {
        DbgPrint(
            "Resource %p [%s] owned by thread %p\n",
            pResource,
            pResource->ResourceName,
            pExclusiveOwner
            );

        DbgBreakPoint();
    }

//    ASSERT( UlDbgResourceUnownedExclusive( pResource ) );

    //
    // Delete the resource.
    //

    status = ExDeleteResourceLite( &pResource->Resource );

    //
    // Remove it from the global list.
    //

    if (pResource->GlobalResourceListEntry.Flink != NULL)
    {
        KeAcquireSpinLock( &g_DbgSpinLock, &oldIrql );
        RemoveEntryList( &pResource->GlobalResourceListEntry );
        KeReleaseSpinLock( &g_DbgSpinLock, oldIrql );
    }

    return status;

}   // UlDbgDeleteResource


/***************************************************************************++

Routine Description:

    Acquires exclusive access to an instrumented resource.

Arguments:

    pResource - Supplies the resource to acquire.

    Wait - Supplies TRUE if the thread should block waiting for the
        resource.

    pFileName - Supplies the filename of the caller.

    LineNumber - Supplies the line number of the caller.

Return Value:

    BOOLEAN - Completion status.

--***************************************************************************/
BOOLEAN
UlDbgAcquireResourceExclusive(
    IN PUL_ERESOURCE pResource,
    IN BOOLEAN Wait,
    IN PCSTR pFileName,
    IN USHORT LineNumber
    )
{
#if ENABLE_THREAD_DBEUG
    PUL_DEBUG_THREAD_DATA pData;
#endif
    BOOLEAN result;

#if !REFERENCE_DEBUG || !ENABLE_THREAD_DBEUG
    UNREFERENCED_PARAMETER(pFileName);
    UNREFERENCED_PARAMETER(LineNumber);
#endif

    //
    // Sanity check.
    //
    ASSERT(pResource);
    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    //
    // Acquire the resource.
    //

    KeEnterCriticalRegion();
    result = ExAcquireResourceExclusiveLite( &pResource->Resource, Wait );

    // Did we acquire the lock exclusively?
    if (! result)
    {
        KeLeaveCriticalRegion();
        return FALSE;
    }

#if ENABLE_THREAD_DBEUG
    //
    // Find an existing entry for the current thread.
    //

    pData = ULP_DBG_FIND_THREAD();

    if (pData != NULL)
    {
        //
        // Update the resource count.
        //

        pData->ResourceCount++;
        ASSERT( pData->ResourceCount > 0 );

        WRITE_REF_TRACE_LOG(
            g_pThreadTraceLog,
            REF_ACTION_ACQUIRE_RESOURCE_EXCLUSIVE,
            pData->ResourceCount,
            pResource,
            pFileName,
            LineNumber
            );

        ULP_DBG_DEREFERENCE_THREAD( pData );
    }
#endif

    //
    // either we already own it (recursive acquisition), or nobody owns it.
    //

    ASSERT( UlDbgResourceUnownedExclusive( pResource ) ||
            UlDbgResourceOwnedExclusive( pResource ) );

    //
    // Mark it as owned by the current thread.
    //

    if (pResource->ExclusiveRecursionCount == 0)
    {
        ASSERT( UlDbgResourceUnownedExclusive( pResource ) );
        SET_RESOURCE_OWNED_EXCLUSIVE( pResource );
    }
    else
    {
        ASSERT( pResource->ExclusiveRecursionCount > 0 );
        ASSERT( UlDbgResourceOwnedExclusive( pResource ) );
    }

    //
    // Update the statistics.
    //

    InterlockedIncrement( &pResource->ExclusiveRecursionCount );
    InterlockedIncrement( &pResource->ExclusiveCount );

    return result;

}   // UlDbgAcquireResourceExclusive


/***************************************************************************++

Routine Description:

    Acquires shared access to an instrumented resource.

Arguments:

    pResource - Supplies the resource to acquire.

    Wait - Supplies TRUE if the thread should block waiting for the
        resource.

    pFileName - Supplies the filename of the caller.

    LineNumber - Supplies the line number of the caller.

Return Value:

    BOOLEAN - Completion status.

--***************************************************************************/
BOOLEAN
UlDbgAcquireResourceShared(
    IN PUL_ERESOURCE pResource,
    IN BOOLEAN Wait,
    IN PCSTR pFileName,
    IN USHORT LineNumber
    )
{
#if ENABLE_THREAD_DBEUG
    PUL_DEBUG_THREAD_DATA pData;
#endif
    BOOLEAN result;

    //
    // Sanity check.
    //

    ASSERT(pResource);
    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    //
    // Acquire the resource.
    //

    KeEnterCriticalRegion();
    result = ExAcquireResourceSharedLite( &pResource->Resource, Wait );

    // Did we acquire the lock exclusively?
    if (! result)
    {
        KeLeaveCriticalRegion();
        return FALSE;
    }

#if ENABLE_THREAD_DBEUG
    //
    // Find an existing entry for the current thread.
    //

    pData = ULP_DBG_FIND_THREAD();

    if (pData != NULL)
    {
        //
        // Update the resource count.
        //

        pData->ResourceCount++;
        ASSERT( pData->ResourceCount > 0 );

        WRITE_REF_TRACE_LOG(
            g_pThreadTraceLog,
            REF_ACTION_ACQUIRE_RESOURCE_SHARED,
            pData->ResourceCount,
            pResource,
            pFileName,
            LineNumber
            );

        ULP_DBG_DEREFERENCE_THREAD( pData );
    }
#else
    UNREFERENCED_PARAMETER(pFileName);
    UNREFERENCED_PARAMETER(LineNumber);
#endif

    //
    // Sanity check.
    //

    ASSERT( pResource->ExclusiveRecursionCount == 0 );
    ASSERT( UlDbgResourceUnownedExclusive( pResource ) );

    //
    // Update the statistics.
    //

    InterlockedIncrement( &pResource->SharedCount );

    return result;

}   // UlDbgAcquireResourceShared


/***************************************************************************++

Routine Description:

    Releases an instrumented resource.

Arguments:

    pResource - Supplies the resource to release.

    pFileName - Supplies the filename of the caller.

    LineNumber - Supplies the line number of the caller.

--***************************************************************************/
VOID
UlDbgReleaseResource(
    IN PUL_ERESOURCE pResource,
    IN PCSTR pFileName,
    IN USHORT LineNumber
    )
{
#if ENABLE_THREAD_DBEUG
    PUL_DEBUG_THREAD_DATA pData;

    //
    // Find an existing entry for the current thread.
    //

    pData = ULP_DBG_FIND_THREAD();

    if (pData != NULL)
    {
        //
        // Update the resource count.
        //

        ASSERT( pData->ResourceCount > 0 );
        pData->ResourceCount--;

        WRITE_REF_TRACE_LOG(
            g_pThreadTraceLog,
            REF_ACTION_RELEASE_RESOURCE,
            pData->ResourceCount,
            pResource,
            pFileName,
            LineNumber
            );

        ULP_DBG_DEREFERENCE_THREAD( pData );
    }
#else
    UNREFERENCED_PARAMETER(pFileName);
    UNREFERENCED_PARAMETER(LineNumber);
#endif

    //
    // Handle recursive acquisitions.
    //

    if (pResource->ExclusiveRecursionCount > 0)
    {
        ASSERT( UlDbgResourceOwnedExclusive( pResource ) );

        InterlockedDecrement( &pResource->ExclusiveRecursionCount );

        if (pResource->ExclusiveRecursionCount == 0)
        {
            //
            // Mark it as unowned.
            //

            SET_RESOURCE_NOT_OWNED_EXCLUSIVE( pResource );
        }
    }
    else
    {
        ASSERT( pResource->ExclusiveRecursionCount == 0 );
        ASSERT( UlDbgResourceUnownedExclusive( pResource ) );
    }

    //
    // Release the resource.
    //

    ExReleaseResourceLite( &pResource->Resource );
    KeLeaveCriticalRegion();

    //
    // Update the statistics.
    //

    InterlockedIncrement( &pResource->ReleaseCount );


}   // UlDbgReleaseResource


/***************************************************************************++

Routine Description:

    This routine converts the specified resource from acquired for exclusive
    access to acquired for shared access.

Arguments:

    pResource - Supplies the resource to release.

    pFileName - Supplies the filename of the caller.

    LineNumber - Supplies the line number of the caller.

--***************************************************************************/
VOID
UlDbgConvertExclusiveToShared(
    IN PUL_ERESOURCE pResource,
    IN PCSTR pFileName,
    IN USHORT LineNumber
    )
{
#if ENABLE_THREAD_DBEUG
    PUL_DEBUG_THREAD_DATA pData;

    //
    // Find an existing entry for the current thread.
    //

    pData = ULP_DBG_FIND_THREAD();

    if (pData != NULL)
    {
        //
        // Don't update the resource count.
        //

        WRITE_REF_TRACE_LOG(
            g_pThreadTraceLog,
            REF_ACTION_CONVERT_RESOURCE_EXCLUSIVE_TO_SHARED,
            pData->ResourceCount,
            pResource,
            pFileName,
            LineNumber
            );

        ULP_DBG_DEREFERENCE_THREAD( pData );
    }
#else
    UNREFERENCED_PARAMETER(pFileName);
    UNREFERENCED_PARAMETER(LineNumber);
#endif

    ASSERT(UlDbgResourceOwnedExclusive(pResource));

    //
    // Resource will no longer be owned exclusively.
    //

    pResource->ExclusiveRecursionCount = 0;
    SET_RESOURCE_NOT_OWNED_EXCLUSIVE( pResource );

    //
    // Acquire the resource.
    //

    ExConvertExclusiveToSharedLite( &pResource->Resource );

    //
    // Update the statistics.
    //

    InterlockedIncrement( &pResource->SharedCount );


}   // UlDbgConvertExclusiveToShared


/***************************************************************************++

Routine Description:

    The routine attempts to acquire the specified resource for exclusive
    access.

Arguments:

    pResource - Supplies the resource to release.

    pFileName - Supplies the filename of the caller.

    LineNumber - Supplies the line number of the caller.

--***************************************************************************/
BOOLEAN
UlDbgTryToAcquireResourceExclusive(
    IN PUL_ERESOURCE pResource,
    IN PCSTR pFileName,
    IN USHORT LineNumber
    )
{
#if ENABLE_THREAD_DBEUG
    PUL_DEBUG_THREAD_DATA pData;
#endif
    BOOLEAN result;

    //
    // Sanity check.
    //
    ASSERT(pResource);
    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    //
    // Acquire the resource.
    //

    KeEnterCriticalRegion();
    result = ExAcquireResourceExclusiveLite( &pResource->Resource, FALSE );

    //
    // Did we acquire the lock exclusively?
    //

    if (!result)
    {
        KeLeaveCriticalRegion();
        return FALSE;
    }

#if ENABLE_THREAD_DBEUG
    //
    // Find an existing entry for the current thread.
    //

    pData = ULP_DBG_FIND_THREAD();

    if (pData != NULL)
    {
        //
        // Update the resource count.
        //

        pData->ResourceCount++;
        ASSERT( pData->ResourceCount > 0 );

        WRITE_REF_TRACE_LOG(
            g_pThreadTraceLog,
            REF_ACTION_TRY_ACQUIRE_RESOURCE_EXCLUSIVE,
            pData->ResourceCount,
            pResource,
            pFileName,
            LineNumber
            );

        ULP_DBG_DEREFERENCE_THREAD( pData );
    }
#else
    UNREFERENCED_PARAMETER(pFileName);
    UNREFERENCED_PARAMETER(LineNumber);
#endif

    //
    // either we already own it (recursive acquisition), or nobody owns it.
    //

    ASSERT( UlDbgResourceUnownedExclusive( pResource ) ||
            UlDbgResourceOwnedExclusive( pResource ) );

    //
    // Mark it as owned by the current thread.
    //

    if (pResource->ExclusiveRecursionCount == 0)
    {
        ASSERT( UlDbgResourceUnownedExclusive( pResource ) );
        SET_RESOURCE_OWNED_EXCLUSIVE( pResource );
    }
    else
    {
        ASSERT( pResource->ExclusiveRecursionCount > 0 );
        ASSERT( UlDbgResourceOwnedExclusive ( pResource ) );
    }

    //
    // Update the statistics.
    //

    InterlockedIncrement( &pResource->ExclusiveRecursionCount );
    InterlockedIncrement( &pResource->ExclusiveCount );

    return result;

}   // UlDbgTryToAcquireResourceExclusive


/***************************************************************************++

Routine Description:

    Determines if the specified resource is owned exclusively by the
    current thread.

Arguments:

    pResource - Supplies the resource to test.

Return Value:

    BOOLEAN - TRUE if the resource is owned exclusively by the current
        thread, FALSE otherwise.

--***************************************************************************/
BOOLEAN
UlDbgResourceOwnedExclusive(
    IN PUL_ERESOURCE pResource
    )
{
    if (pResource->pExclusiveOwner == PsGetCurrentThread())
    {
        return TRUE;
    }

    return FALSE;

}   // UlDbgResourceOwnedExclusive


/***************************************************************************++

Routine Description:

    Determines if the specified resource is not currently owned exclusively
    by any thread.

Arguments:

    pResource - Supplies the resource to test.

Return Value:

    BOOLEAN - TRUE if the resource is not currently owned exclusively by
        any thread, FALSE otherwise.

--***************************************************************************/
BOOLEAN
UlDbgResourceUnownedExclusive(
    IN PUL_ERESOURCE pResource
    )
{
    if (pResource->pExclusiveOwner == NULL)
    {
        return TRUE;
    }

    return FALSE;

}   // UlDbgResourceUnownedExclusive


/***************************************************************************++

Routine Description:

    Initialize an instrumented push lock.

Arguments:

    pPushLock - Supplies the push lock to initialize.

    pPushLockName - Supplies a display name for the push lock.

    Parameter - Supplies a ULONG_PTR parameter passed into sprintf()
        when creating the push lock name.

    pFileName - Supplies the filename of the caller.

    LineNumber - Supplies the line number of the caller.

Return Value:

    None

--***************************************************************************/
VOID
UlDbgInitializePushLock(
    IN PUL_PUSH_LOCK pPushLock,
    IN PCSTR pPushLockName,
    IN ULONG_PTR Parameter,
    IN ULONG OwnerTag,
    IN PCSTR pFileName,
    IN USHORT LineNumber
    )
{
    KIRQL oldIrql;

    UNREFERENCED_PARAMETER(pFileName);
    UNREFERENCED_PARAMETER(LineNumber);

    //
    // Initialize the push lock.
    //

    ExInitializePushLock( &pPushLock->PushLock );

    pPushLock->ExclusiveCount = 0;
    pPushLock->SharedCount = 0;
    pPushLock->ReleaseCount = 0;
    pPushLock->OwnerTag = OwnerTag;

    _snprintf(
        (char*) pPushLock->PushLockName,
        sizeof(pPushLock->PushLockName) - 1,
        pPushLockName,
        Parameter
        );

    pPushLock->PushLockName[sizeof(pPushLock->PushLockName) - 1] = '\0';

    SET_PUSH_LOCK_NOT_OWNED_EXCLUSIVE( pPushLock );

    //
    // Put it on the global list.
    //

    KeAcquireSpinLock( &g_DbgSpinLock, &oldIrql );
    InsertHeadList(
        &g_DbgGlobalPushLockListHead,
        &pPushLock->GlobalPushLockListEntry
        );
    KeReleaseSpinLock( &g_DbgSpinLock, oldIrql );

}   // UlDbgInitializePushLock


/***************************************************************************++

Routine Description:

    Deletes an instrumented push lock.

Arguments:

    pPushLock - Supplies the push lock to delete.

    pFileName - Supplies the filename of the caller.

    LineNumber - Supplies the line number of the caller.

Return Value:

    None

--***************************************************************************/
VOID
UlDbgDeletePushLock(
    IN PUL_PUSH_LOCK pPushLock,
    IN PCSTR pFileName,
    IN USHORT LineNumber
    )
{
    KIRQL oldIrql;
    PETHREAD pExclusiveOwner;

    UNREFERENCED_PARAMETER(pFileName);
    UNREFERENCED_PARAMETER(LineNumber);

    //
    // Sanity check.
    //

    ASSERT(pPushLock);
    pExclusiveOwner = pPushLock->pExclusiveOwner;

    if (pExclusiveOwner != NULL)
    {
        DbgPrint(
            "PushLock %p [%s] owned by thread %p\n",
            pPushLock,
            pPushLock->PushLockName,
            pExclusiveOwner
            );

        DbgBreakPoint();
    }

    ASSERT( UlDbgPushLockUnownedExclusive( pPushLock ) );

    //
    // Remove it from the global list.
    //

    if (pPushLock->GlobalPushLockListEntry.Flink != NULL)
    {
        KeAcquireSpinLock( &g_DbgSpinLock, &oldIrql );
        RemoveEntryList( &pPushLock->GlobalPushLockListEntry );
        KeReleaseSpinLock( &g_DbgSpinLock, oldIrql );
    }

}   // UlDbgDeletePushLock


/***************************************************************************++

Routine Description:

    Acquires exclusive access to an instrumented push lock.

Arguments:

    pPushLock - Supplies the push lock to acquire.

    pFileName - Supplies the filename of the caller.

    LineNumber - Supplies the line number of the caller.

Return Value:

    None

--***************************************************************************/
VOID
UlDbgAcquirePushLockExclusive(
    IN PUL_PUSH_LOCK pPushLock,
    IN PCSTR pFileName,
    IN USHORT LineNumber
    )
{
#if ENABLE_THREAD_DBEUG
    PUL_DEBUG_THREAD_DATA pData;

    //
    // Find an existing entry for the current thread.
    //

    pData = ULP_DBG_FIND_THREAD();

    if (pData != NULL)
    {
        //
        // Update the push lock count.
        //

        pData->PushLockCount++;
        ASSERT( pData->PushLockCount > 0 );

        WRITE_REF_TRACE_LOG(
            g_pThreadTraceLog,
            REF_ACTION_ACQUIRE_PUSH_LOCK_EXCLUSIVE,
            pData->PushLockCount,
            pPushLock,
            pFileName,
            LineNumber
            );

        ULP_DBG_DEREFERENCE_THREAD( pData );
    }
#else
    UNREFERENCED_PARAMETER(pFileName);
    UNREFERENCED_PARAMETER(LineNumber);
#endif

    //
    // Sanity check.
    //

    ASSERT( pPushLock );
    ASSERT( KeGetCurrentIrql() < DISPATCH_LEVEL );

    //
    // Acquire the push lock.
    //

    KeEnterCriticalRegion();
    ExAcquirePushLockExclusive( &pPushLock->PushLock );

    //
    // Mark it as owned by the current thread.
    //

    ASSERT( UlDbgPushLockUnownedExclusive( pPushLock ) );

    SET_PUSH_LOCK_OWNED_EXCLUSIVE( pPushLock );

    //
    // Update the statistics.
    //

    InterlockedIncrement( &pPushLock->ExclusiveCount );

}   // UlDbgAcquirePushLockExclusive


/***************************************************************************++

Routine Description:

    Releases an instrumented push lock that was acquired exclusive.

Arguments:

    pPushLock - Supplies the push lock to release.

    pFileName - Supplies the filename of the caller.

    LineNumber - Supplies the line number of the caller.

Return Value:

    None

--***************************************************************************/
VOID
UlDbgReleasePushLockExclusive(
    IN PUL_PUSH_LOCK pPushLock,
    IN PCSTR pFileName,
    IN USHORT LineNumber
    )
{
#if ENABLE_THREAD_DBEUG
    PUL_DEBUG_THREAD_DATA pData;

    //
    // Find an existing entry for the current thread.
    //

    pData = ULP_DBG_FIND_THREAD();

    if (pData != NULL)
    {
        //
        // Update the push lock count.
        //

        ASSERT( pData->PushLockCount > 0 );
        pData->PushLockCount--;

        WRITE_REF_TRACE_LOG(
            g_pThreadTraceLog,
            REF_ACTION_RELEASE_PUSH_LOCK,
            pData->PushLockCount,
            pPushLock,
            pFileName,
            LineNumber
            );

        ULP_DBG_DEREFERENCE_THREAD( pData );
    }
#else
    UNREFERENCED_PARAMETER(pFileName);
    UNREFERENCED_PARAMETER(LineNumber);
#endif

    //
    // Mark it as unowned.
    //

    ASSERT( UlDbgPushLockOwnedExclusive( pPushLock ) );

    SET_PUSH_LOCK_NOT_OWNED_EXCLUSIVE( pPushLock );

    //
    // Release the push lock.
    //

    ExReleasePushLockExclusive( &pPushLock->PushLock );
    KeLeaveCriticalRegion();

    //
    // Update the statistics.
    //

    InterlockedIncrement( &pPushLock->ReleaseCount );

}   // UlDbgReleasePushLockExclusive


/***************************************************************************++

Routine Description:

    Acquires shared access to an instrumented push lock.

Arguments:

    pPushLock - Supplies the push lock to acquire.

    pFileName - Supplies the filename of the caller.

    LineNumber - Supplies the line number of the caller.

Return Value:

    None

--***************************************************************************/
VOID
UlDbgAcquirePushLockShared(
    IN PUL_PUSH_LOCK pPushLock,
    IN PCSTR pFileName,
    IN USHORT LineNumber
    )
{
#if ENABLE_THREAD_DBEUG
    PUL_DEBUG_THREAD_DATA pData;

    //
    // Find an existing entry for the current thread.
    //

    pData = ULP_DBG_FIND_THREAD();

    if (pData != NULL)
    {
        //
        // Update the push lock count.
        //

        pData->PushLockCount++;
        ASSERT( pData->PushLockCount > 0 );

        WRITE_REF_TRACE_LOG(
            g_pThreadTraceLog,
            REF_ACTION_ACQUIRE_PUSH_LOCK_SHARED,
            pData->PushLockCount,
            pPushLock,
            pFileName,
            LineNumber
            );

        ULP_DBG_DEREFERENCE_THREAD( pData );
    }
#else
    UNREFERENCED_PARAMETER(pFileName);
    UNREFERENCED_PARAMETER(LineNumber);
#endif

    //
    // Sanity check.
    //

    ASSERT( pPushLock );
    ASSERT( KeGetCurrentIrql() < DISPATCH_LEVEL );

    //
    // Acquire the push lock.
    //

    KeEnterCriticalRegion();
    ExAcquirePushLockShared( &pPushLock->PushLock );

    //
    // Update the statistics.
    //

    InterlockedIncrement( &pPushLock->SharedCount );

}   // UlDbgAcquirePushLockShared


/***************************************************************************++

Routine Description:

    Releases an instrumented push lock that was acquired shared.

Arguments:

    pPushLock - Supplies the push lock to release.

    pFileName - Supplies the filename of the caller.

    LineNumber - Supplies the line number of the caller.

Return Value:

    None

--***************************************************************************/
VOID
UlDbgReleasePushLockShared(
    IN PUL_PUSH_LOCK pPushLock,
    IN PCSTR pFileName,
    IN USHORT LineNumber
    )
{
#if ENABLE_THREAD_DBEUG
    PUL_DEBUG_THREAD_DATA pData;

    //
    // Find an existing entry for the current thread.
    //

    pData = ULP_DBG_FIND_THREAD();

    if (pData != NULL)
    {
        //
        // Update the push lock count.
        //

        ASSERT( pData->PushLockCount > 0 );
        pData->PushLockCount--;

        WRITE_REF_TRACE_LOG(
            g_pThreadTraceLog,
            REF_ACTION_RELEASE_PUSH_LOCK,
            pData->PushLockCount,
            pPushLock,
            pFileName,
            LineNumber
            );

        ULP_DBG_DEREFERENCE_THREAD( pData );
    }
#else
    UNREFERENCED_PARAMETER(pFileName);
    UNREFERENCED_PARAMETER(LineNumber);
#endif

    //
    // Mark it as unowned.
    //

    ASSERT( UlDbgPushLockUnownedExclusive( pPushLock ) );

    SET_PUSH_LOCK_NOT_OWNED_EXCLUSIVE( pPushLock );

    //
    // Release the push lock.
    //

    ExReleasePushLockShared( &pPushLock->PushLock );
    KeLeaveCriticalRegion();

    //
    // Update the statistics.
    //

    InterlockedIncrement( &pPushLock->ReleaseCount );

}   // UlDbgReleasePushLockShared


/***************************************************************************++

Routine Description:

    Releases an instrumented push lock.

Arguments:

    pPushLock - Supplies the push lock to release.

    pFileName - Supplies the filename of the caller.

    LineNumber - Supplies the line number of the caller.

Return Value:

    None

--***************************************************************************/
VOID
UlDbgReleasePushLock(
    IN PUL_PUSH_LOCK pPushLock,
    IN PCSTR pFileName,
    IN USHORT LineNumber
    )
{
#if ENABLE_THREAD_DBEUG
    PUL_DEBUG_THREAD_DATA pData;

    //
    // Find an existing entry for the current thread.
    //

    pData = ULP_DBG_FIND_THREAD();

    if (pData != NULL)
    {
        //
        // Update the push lock count.
        //

        ASSERT( pData->PushLockCount > 0 );
        pData->PushLockCount--;

        WRITE_REF_TRACE_LOG(
            g_pThreadTraceLog,
            REF_ACTION_RELEASE_PUSH_LOCK,
            pData->PushLockCount,
            pPushLock,
            pFileName,
            LineNumber
            );

        ULP_DBG_DEREFERENCE_THREAD( pData );
    }
#else
    UNREFERENCED_PARAMETER(pFileName);
    UNREFERENCED_PARAMETER(LineNumber);
#endif

    //
    // Mark it as unowned.
    //

    SET_PUSH_LOCK_NOT_OWNED_EXCLUSIVE( pPushLock );

    //
    // Release the push lock.
    //

    ExReleasePushLock( &pPushLock->PushLock );
    KeLeaveCriticalRegion();

    //
    // Update the statistics.
    //

    InterlockedIncrement( &pPushLock->ReleaseCount );

}   // UlDbgReleasePushLock


/***************************************************************************++

Routine Description:

    Determines if the specified push lock is owned exclusively by the
    current thread.

Arguments:

    pPushLock - Supplies the push lock to test.

Return Value:

    BOOLEAN - TRUE if the push lock is owned exclusively by the current
        thread, FALSE otherwise.

--***************************************************************************/
BOOLEAN
UlDbgPushLockOwnedExclusive(
    IN PUL_PUSH_LOCK pPushLock
    )
{
    if (pPushLock->pExclusiveOwner == PsGetCurrentThread())
    {
        return TRUE;
    }

    return FALSE;

}   // UlDbgPushLockOwnedExclusive


/***************************************************************************++

Routine Description:

    Determines if the specified push lock is not currently owned exclusively
    by any thread.

Arguments:

    pPushLock - Supplies the push lock to test.

Return Value:

    BOOLEAN - TRUE if the push lock is not currently owned exclusively by
        any thread, FALSE otherwise.

--***************************************************************************/
BOOLEAN
UlDbgPushLockUnownedExclusive(
    IN PUL_PUSH_LOCK pPushLock
    )
{
    if (pPushLock->pExclusiveOwner == NULL)
    {
        return TRUE;
    }

    return FALSE;

}   // UlDbgPushLockUnownedExclusive


VOID
UlDbgDumpRequestBuffer(
    IN struct _UL_REQUEST_BUFFER *pBuffer,
    IN PCSTR pName
    )
{
    DbgPrint(
        "%s @ %p\n"
        "    Signature      = %08lx\n"
        "    ListEntry      @ %p%s\n"
        "    pConnection    = %p\n"
        "    WorkItem       @ %p\n"
        "    UsedBytes      = %lu\n"
        "    AllocBytes     = %lu\n"
        "    ParsedBytes    = %lu\n"
        "    BufferNumber   = %lu\n"
        "    FromLookaside  = %lu\n"
        "    pBuffer        @ %p\n",
        pName,
        pBuffer,
        pBuffer->Signature,
        &pBuffer->ListEntry,
        IsListEmpty( &pBuffer->ListEntry ) ? " EMPTY" : "",
        pBuffer->pConnection,
        &pBuffer->WorkItem,
        pBuffer->UsedBytes,
        pBuffer->AllocBytes,
        pBuffer->ParsedBytes,
        pBuffer->BufferNumber,
        pBuffer->FromLookaside,
        &pBuffer->pBuffer[0]
        );

}   // UlDbgDumpRequestBuffer

VOID
UlDbgDumpHttpConnection(
    IN struct _UL_HTTP_CONNECTION *pConnection,
    IN PCSTR pName
    )
{
    DbgPrint(
        "%s @ %p\n"
        "    Signature          = %08lx\n"
        "    ConnectionId       = %08lx%08lx\n"
        "    WorkItem           @ %p\n"
        "    RefCount           = %lu\n"
        "    NextRecvNumber     = %lu\n"
        "    NextBufferNumber   = %lu\n"
        "    NextBufferToParse  = %lu\n"
        "    pConnection        = %p\n"
        "    pRequest           = %p\n",
        pName,
        pConnection,
        pConnection->Signature,
        pConnection->ConnectionId,
        &pConnection->WorkItem,
        pConnection->RefCount,
        pConnection->NextRecvNumber,
        pConnection->NextBufferNumber,
        pConnection->NextBufferToParse,
        pConnection->pConnection,
        pConnection->pRequest
        );

    DbgPrint(
        "%s @ %p (cont.)\n"
        "    PushLock           @ %p\n"
        "    BufferHead         @ %p%s\n"
        "    pCurrentBuffer     = %p\n"
        "    NeedMoreData       = %lu\n"
#if REFERENCE_DEBUG
        "    pTraceLog          = %p\n"
#endif
        ,
        pName,
        pConnection,
        &pConnection->PushLock,
        &pConnection->BufferHead,
        IsListEmpty( &pConnection->BufferHead ) ? " EMPTY" : "",
        pConnection->pCurrentBuffer,
        pConnection->NeedMoreData
#if REFERENCE_DEBUG
        ,
        pConnection->pConnection->pHttpTraceLog
#endif
        );

}   // UlDbgDumpHttpConnection

PIRP
UlDbgAllocateIrp(
    IN CCHAR StackSize,
    IN BOOLEAN ChargeQuota,
    IN PCSTR pFileName,
    IN USHORT LineNumber
    )
{
    PIRP pIrp;

#if !ENABLE_IRP_TRACE
    UNREFERENCED_PARAMETER(pFileName);
    UNREFERENCED_PARAMETER(LineNumber);
#endif

    pIrp = IoAllocateIrp( StackSize, ChargeQuota );

    if (pIrp != NULL)
    {
        WRITE_IRP_TRACE_LOG(
            g_pIrpTraceLog,
            IRP_ACTION_ALLOCATE_IRP,
            pIrp,
            pFileName,
            LineNumber
            );
    }

    return pIrp;

}   // UlDbgAllocateIrp

BOOLEAN g_ReallyFreeIrps = TRUE;

VOID
UlDbgFreeIrp(
    IN PIRP pIrp,
    IN PCSTR pFileName,
    IN USHORT LineNumber
    )
{
#if !ENABLE_IRP_TRACE
    UNREFERENCED_PARAMETER(pFileName);
    UNREFERENCED_PARAMETER(LineNumber);
#endif

    WRITE_IRP_TRACE_LOG(
        g_pIrpTraceLog,
        IRP_ACTION_FREE_IRP,
        pIrp,
        pFileName,
        LineNumber
        );

    if (g_ReallyFreeIrps)
    {
        IoFreeIrp( pIrp );
    }

}   // UlDbgFreeIrp

NTSTATUS
UlDbgCallDriver(
    IN PDEVICE_OBJECT pDeviceObject,
    IN OUT PIRP pIrp,
    IN PCSTR pFileName,
    IN USHORT LineNumber
    )
{
#if ENABLE_THREAD_DBEUG
    PUL_DEBUG_THREAD_DATA pData;
#endif
    NTSTATUS Status;

#if !ENABLE_IRP_TRACE
    UNREFERENCED_PARAMETER(pFileName);
    UNREFERENCED_PARAMETER(LineNumber);
#endif

#if ENABLE_THREAD_DBEUG
    //
    // Record the fact that we are about to call another
    // driver in the thread data. That way if the driver
    // calls our completion routine in-line our debug
    // code won't get confused about it.
    //

    //
    // Find an existing entry for the current thread.
    //

    pData = ULP_DBG_FIND_THREAD();

    if (pData != NULL)
    {
        //
        // Update the external call count.
        //

        pData->ExternalCallCount++;
        ASSERT( pData->ExternalCallCount > 0 );
    }
#endif

    WRITE_IRP_TRACE_LOG(
        g_pIrpTraceLog,
        IRP_ACTION_CALL_DRIVER,
        pIrp,
        pFileName,
        LineNumber
        );

    //
    // Call the driver.
    //

    Status = IoCallDriver( pDeviceObject, pIrp );

#if ENABLE_THREAD_DBEUG
    //
    // Update the external call count.
    //

    if (pData != NULL)
    {
        pData->ExternalCallCount--;
        ASSERT( pData->ExternalCallCount >= 0 );

        ULP_DBG_DEREFERENCE_THREAD( pData );
    }
#endif

    return Status;

}   // UlDbgCallDriver

VOID
UlDbgCompleteRequest(
    IN PIRP pIrp,
    IN CCHAR PriorityBoost,
    IN PCSTR pFileName,
    IN USHORT LineNumber
    )
{
    WRITE_IRP_TRACE_LOG(
        g_pIrpTraceLog,
        IRP_ACTION_COMPLETE_IRP,
        pIrp,
        pFileName,
        LineNumber
        );

    UlTrace(IOCTL,
            ("UlCompleteRequest(%p): status=0x%x, info=%Iu, boost=%d "
             "@ \"%s\", %hu\n",
             pIrp,
             pIrp->IoStatus.Status,
             pIrp->IoStatus.Information,
             (int) PriorityBoost,
             UlDbgFindFilePart( pFileName ),
             LineNumber
             ));

    IF_DEBUG2BOTH(IOCTL, VERBOSE)
    {
        PIO_STACK_LOCATION pIrpSp = IoGetCurrentIrpStackLocation( pIrp );
        ULONG BufferLength
            = (ULONG) pIrpSp->Parameters.DeviceIoControl.OutputBufferLength;

        if (NULL != pIrp->MdlAddress  &&  0 != BufferLength)
        {
            PUCHAR pOutputBuffer
                = (PUCHAR) MmGetSystemAddressForMdlSafe(
                                pIrp->MdlAddress,
                                LowPagePriority
                                );

            if (NULL != pOutputBuffer)
            {
                UlDbgPrettyPrintBuffer(
                    pOutputBuffer,
                    MIN(pIrp->IoStatus.Information, BufferLength)
                    );
            }
        }
    }

    IoCompleteRequest( pIrp, PriorityBoost );

}   // UlDbgCompleteRequest



PMDL
UlDbgAllocateMdl(
    IN PVOID VirtualAddress,
    IN ULONG Length,
    IN BOOLEAN SecondaryBuffer,
    IN BOOLEAN ChargeQuota,
    IN OUT PIRP Irp,
    IN PCSTR pFileName,
    IN USHORT LineNumber
    )
{
    //
    // Allocate a chunk of memory & store the MDL in it. We'll use this 
    // memory to track MDL leaks.
    //
    PMDL mdl;

#if ENABLE_MDL_TRACKER
    PUL_DEBUG_MDL_TRACKER pMdlTrack;

    pMdlTrack = UL_ALLOCATE_POOL(
                    NonPagedPool,
                    sizeof(UL_DEBUG_MDL_TRACKER),
                    UL_DEBUG_MDL_POOL_TAG
                    );

    if(!pMdlTrack)
    {
        return NULL;
    }
#endif

    mdl = IoAllocateMdl(
                VirtualAddress,
                Length,
                SecondaryBuffer,
                ChargeQuota,
                Irp
                );

    if (mdl != NULL)
    {
#if ENABLE_MDL_TRACKER
        pMdlTrack->pMdl       = mdl;
        pMdlTrack->pFileName  = pFileName;
        pMdlTrack->LineNumber = LineNumber;

        ExInterlockedInsertTailList(
            &g_DbgMdlListHead, 
            &pMdlTrack->Linkage,
            &g_DbgSpinLock);
        
#endif
        WRITE_REF_TRACE_LOG(
            g_pMdlTraceLog,
            REF_ACTION_ALLOCATE_MDL,
            PtrToLong(mdl->Next),   // bugbug64
            mdl,
            pFileName,
            LineNumber
            );

#ifdef SPECIAL_MDL_FLAG
    ASSERT( (mdl->MdlFlags & SPECIAL_MDL_FLAG) == 0 );
#endif
    }
    else
    {
#if ENABLE_MDL_TRACKER
        UL_FREE_POOL(pMdlTrack, UL_DEBUG_MDL_POOL_TAG);
#endif
    }

    return mdl;

}   // UlDbgAllocateMdl

BOOLEAN g_ReallyFreeMdls = TRUE;

VOID
UlDbgFreeMdl(
    IN PMDL Mdl,
    IN PCSTR pFileName,
    IN USHORT LineNumber
    )
{
#if ENABLE_MDL_TRACKER
    PUL_DEBUG_MDL_TRACKER  pMdlTrack = NULL;
    PLIST_ENTRY            pEntry;
    KIRQL                  oldIrql;

    KeAcquireSpinLock( &g_DbgSpinLock, &oldIrql );

    pEntry = g_DbgMdlListHead.Flink;

    while(pEntry != &g_DbgMdlListHead)
    {
        pMdlTrack = CONTAINING_RECORD(
                            pEntry,
                            UL_DEBUG_MDL_TRACKER,
                            Linkage
                            );


        if(pMdlTrack->pMdl == Mdl)
        {
            RemoveEntryList(&pMdlTrack->Linkage);

            UL_FREE_POOL(pMdlTrack, UL_DEBUG_MDL_POOL_TAG);

            break;
        }

        pEntry = pEntry->Flink;
    }

    ASSERT(pMdlTrack != NULL);

    KeReleaseSpinLock(&g_DbgSpinLock, oldIrql);

#endif
        
    WRITE_REF_TRACE_LOG(
        g_pMdlTraceLog,
        REF_ACTION_FREE_MDL,
        PtrToLong(Mdl->Next),   // bugbug64
        Mdl,
        pFileName,
        LineNumber
        );

#ifdef SPECIAL_MDL_FLAG
    ASSERT( (Mdl->MdlFlags & SPECIAL_MDL_FLAG) == 0 );
#endif

    if (g_ReallyFreeMdls)
    {
        IoFreeMdl( Mdl );
    }

}   // UlDbgFreeMdl


/***************************************************************************++

Routine Description:

    Locates the file part of a fully qualified path.

Arguments:

    pPath - Supplies the path to scan.

Return Value:

    PCSTR - The file part.

--***************************************************************************/
PCSTR
UlDbgFindFilePart(
    IN PCSTR pPath
    )
{
    PCSTR pFilePart;

    //
    // Strip off the path from the path.
    //

    pFilePart = strrchr( pPath, '\\' );

    if (pFilePart == NULL)
    {
        pFilePart = pPath;
    }
    else
    {
        pFilePart++;
    }

    return pFilePart;

}   // UlDbgFindFilePart


//
// Private functions.
//

/***************************************************************************++

Routine Description:

    Updates a pool counter.

Arguments:

    pAddend - Supplies the counter to update.

    Increment - Supplies the value to add to the counter.

--***************************************************************************/
VOID
UlpDbgUpdatePoolCounter(
    IN OUT PLARGE_INTEGER pAddend,
    IN SIZE_T Increment
    )
{
    ULONG tmp;

    tmp = (ULONG)Increment;
    ASSERT( (SIZE_T)tmp == Increment );

    ExInterlockedAddLargeStatistic(
        pAddend,
        tmp
        );

}   // UlpDbgUpdatePoolCounter


#if ENABLE_THREAD_DBEUG
/***************************************************************************++

Routine Description:

    Locates and optionally creates per-thread data for the current thread.

Return Value:

    PUL_DEBUG_THREAD_DATA - The thread data if successful, NULL otherwise.

--***************************************************************************/
PUL_DEBUG_THREAD_DATA
UlpDbgFindThread(
    BOOLEAN OkToCreate,
    PCSTR pFileName,
    USHORT LineNumber
    )
{
    PUL_DEBUG_THREAD_DATA pData;
    PUL_THREAD_HASH_BUCKET pBucket;
    PETHREAD pThread;
    KIRQL oldIrql;
    PLIST_ENTRY pListEntry;
    ULONG refCount;

    //
    // Get the current thread, find the correct bucket.
    //

    pThread = PsGetCurrentThread();
    pBucket = &g_DbgThreadHashBuckets[HASH_FROM_THREAD(pThread)];

    //
    // Lock the bucket.
    //

    KeAcquireSpinLock( &pBucket->BucketSpinLock, &oldIrql );

    //
    // Try to find an existing entry for the current thread.
    //

    for (pListEntry = pBucket->BucketListHead.Flink ;
         pListEntry != &pBucket->BucketListHead ;
         pListEntry = pListEntry->Flink)
    {
        pData = CONTAINING_RECORD(
                    pListEntry,
                    UL_DEBUG_THREAD_DATA,
                    ThreadDataListEntry
                    );

        if (pData->pThread == pThread)
        {
            //
            // Found one. Update the reference count, then return the
            // existing entry.
            //

            pData->ReferenceCount++;
            refCount = pData->ReferenceCount;

            KeReleaseSpinLock( &pBucket->BucketSpinLock, oldIrql );

            //
            // Trace it.
            //

            WRITE_REF_TRACE_LOG(
                g_pThreadTraceLog,
                REF_ACTION_REFERENCE_THREAD,
                refCount,
                pData,
                pFileName,
                LineNumber
                );

            return pData;
        }
    }

    //
    // If we made it this far, then data has not yet been created for
    // the current thread. Create & initialize it now if we're allowed.
    // Basically it's only ok if we're called from UlDbgEnterDriver.
    //

    if (OkToCreate)
    {
        pData = (PUL_DEBUG_THREAD_DATA) UL_ALLOCATE_POOL(
                    NonPagedPool,
                    sizeof(*pData),
                    UL_DEBUG_THREAD_POOL_TAG
                    );

        if (pData != NULL)
        {
            RtlZeroMemory( pData, sizeof(*pData) );

            pData->pThread = pThread;
            pData->ReferenceCount = 1;
            pData->ResourceCount = 0;
            pData->PushLockCount = 0;

            InsertHeadList(
                &pBucket->BucketListHead,
                &pData->ThreadDataListEntry
                );

            ++pBucket->Count;

            pBucket->Max = MAX(pBucket->Max, pBucket->Count);

            InterlockedIncrement( &g_DbgThreadCreated );
        }

    }
    else
    {
        pData = NULL;
    }

    KeReleaseSpinLock( &pBucket->BucketSpinLock, oldIrql );

    return pData;

}   // UlpDbgFindThread


/***************************************************************************++

Routine Description:

    Dereferences per-thread data.

Arguments:

    pData - Supplies the thread data to dereference.

--***************************************************************************/
VOID
UlpDbgDereferenceThread(
    IN PUL_DEBUG_THREAD_DATA pData
    REFERENCE_DEBUG_FORMAL_PARAMS
    )
{
    PUL_THREAD_HASH_BUCKET pBucket;
    KIRQL oldIrql;
    ULONG refCount;

    //
    // Find the correct bucket.
    //

    pBucket = &g_DbgThreadHashBuckets[HASH_FROM_THREAD(pData->pThread)];

    //
    // Update the reference count.
    //

    KeAcquireSpinLock( &pBucket->BucketSpinLock, &oldIrql );

    ASSERT( pData->ReferenceCount > 0 );
    pData->ReferenceCount--;

    refCount = pData->ReferenceCount;

    if (pData->ReferenceCount == 0)
    {
        //
        // It dropped to zero, so remove the thread from the bucket
        // and free the resources.
        //

        RemoveEntryList( &pData->ThreadDataListEntry );
        --pBucket->Count;

        KeReleaseSpinLock( &pBucket->BucketSpinLock, oldIrql );

        UL_FREE_POOL( pData, UL_DEBUG_THREAD_POOL_TAG );
        InterlockedIncrement( &g_DbgThreadDestroyed );
    }
    else
    {
        KeReleaseSpinLock( &pBucket->BucketSpinLock, oldIrql );
    }

    //
    // Trace it.
    //

    WRITE_REF_TRACE_LOG(
        g_pThreadTraceLog,
        REF_ACTION_DEREFERENCE_THREAD,
        refCount,
        pData,
        pFileName,
        LineNumber
        );

}   // UlpDbgDereferenceThread
#endif


/***************************************************************************++

Routine Description:

    Allows us to do fancy things with IRP cancellation (e.g. force a cancel
    while a cancel routine is being set or removed). For now, just default 
    to the regular IO manager routine.

Arguments:

    pIrp           - The IRP.
    pCancelRoutine - The cancel routine.


--***************************************************************************/
PDRIVER_CANCEL
UlDbgIoSetCancelRoutine(
    PIRP             pIrp,
    PDRIVER_CANCEL   pCancelRoutine
    )
{
    return IoSetCancelRoutine(pIrp, pCancelRoutine);
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\data.h ===
/*++

Copyright (c) 1998-2002 Microsoft Corporation

Module Name:

    data.h

Abstract:

    This module declares global data for HTTP.SYS.

Author:

    Keith Moore (keithmo)       10-Jun-1998

Revision History:

--*/


#ifndef _DATA_H_
#define _DATA_H_


//
// Some data types.
//

typedef struct _UL_CONFIG
{
    USHORT              ThreadsPerCpu;
    USHORT              IrpContextLookasideDepth;
    USHORT              ReceiveBufferLookasideDepth;
    USHORT              ResourceLookasideDepth;
    USHORT              RequestBufferLookasideDepth;
    USHORT              InternalRequestLookasideDepth;
    USHORT              SendTrackerLookasideDepth;
    USHORT              ResponseBufferLookasideDepth;
    USHORT              LogFileBufferLookasideDepth;
    USHORT              LogDataBufferLookasideDepth;
    USHORT              ErrorLogBufferLookasideDepth;
    USHORT              FilterWriteTrackerLookasideDepth;
    BOOLEAN             EnableHttpClient;

    UL_URI_CACHE_CONFIG UriConfig;

} UL_CONFIG, *PUL_CONFIG;

extern PDRIVER_OBJECT g_UlDriverObject;

//
// The number of processors in the system.
//

extern CLONG g_UlNumberOfProcessors;

//
// The largest cache line in the system
//

extern ULONG g_UlCacheLineSize;
extern ULONG g_UlCacheLineBits;

extern BOOLEAN g_HttpClientEnabled;

//
// Total memory in the system
//

extern SIZE_T g_UlTotalPhysicalMemMB;
extern SIZE_T g_UlTotalNonPagedPoolBytes;

//
// Our nonpaged data.
//

extern PUL_NONPAGED_DATA g_pUlNonpagedData;


//
// A pointer to the system process.
//

extern PKPROCESS g_pUlSystemProcess;


//
// Our device objects and their container.
//

extern HANDLE g_UlDirectoryObject;

extern PDEVICE_OBJECT g_pUlControlDeviceObject;
extern PDEVICE_OBJECT g_pUlFilterDeviceObject;
extern PDEVICE_OBJECT g_pUlAppPoolDeviceObject;
extern PDEVICE_OBJECT g_pUcServerDeviceObject; 

extern PVOID g_ClientImageHandle;


//
// Various pieces of configuration information.
//

extern ULONG g_UlMaxWorkQueueDepth;
extern ULONG g_UlMinWorkDequeueDepth;
extern USHORT g_UlIdleConnectionsHighMark;
extern USHORT g_UlIdleConnectionsLowMark;
extern ULONG g_UlIdleListTrimmerPeriod;
extern USHORT g_UlMaxEndpoints;
extern ULONG g_UlReceiveBufferSize;
extern ULONG g_UlMaxRequestsQueued;
extern ULONG g_UlMaxRequestBytes;
extern BOOLEAN g_UlOptForIntrMod;
extern BOOLEAN g_UlEnableNagling;
extern BOOLEAN g_UlEnableThreadAffinity;
extern ULONGLONG g_UlThreadAffinityMask;
extern ULONG g_UlMaxFieldLength;
extern BOOLEAN g_UlDisableLogBuffering;
extern ULONG  g_UlLogBufferSize;
extern URL_C14N_CONFIG g_UrlC14nConfig;
extern ULONG g_UlMaxInternalUrlLength;
extern ULONG g_UlMaxVariableHeaderSize;
extern ULONG g_UlMaxFixedHeaderSize;
extern ULONG g_UlFixedHeadersMdlLength;
extern ULONG g_UlVariableHeadersMdlLength;
extern ULONG g_UlContentMdlLength;
extern ULONG g_UlChunkTrackerSize;
extern ULONG g_UlFullTrackerSize;
extern ULONG g_UlResponseBufferSize;
extern ULONG g_UlMaxBufferedBytes;
extern ULONG g_UlMaxCopyThreshold;
extern ULONG g_UlMaxBufferedSends;
extern ULONG g_UlMaxBytesPerSend;
extern ULONG g_UlMaxBytesPerRead;
extern ULONG g_UlMaxPipelinedRequests;
extern BOOLEAN g_UlEnableCopySend;
extern ULONG g_UlOpaqueIdTableSize;
extern ULONG g_UlMaxZombieHttpConnectionCount;
extern ULONG g_UlDisableServerHeader;
extern ULONG g_MaxConnections;
extern ULONG g_UlConnectionSendLimit;
extern ULONGLONG g_UlGlobalSendLimit;

//
// Cached Date header string.
//

extern LARGE_INTEGER g_UlSystemTime;
extern UCHAR g_UlDateString[];
extern ULONG g_UlDateStringLength;

//
// Security descriptor that has fileAll for Admin & Local System
//
extern PSECURITY_DESCRIPTOR g_pAdminAllSystemAll;

//
// ComputerName.
//

extern WCHAR g_UlComputerName[];

//
// Driver wide error logging config.
//

#define UL_ERROR_LOG_SUB_DIR         (L"\\HTTPERR")
#define UL_ERROR_LOG_SUB_DIR_LENGTH  (WCSLEN_LIT(UL_ERROR_LOG_SUB_DIR))

C_ASSERT(WCSLEN_LIT(DEFAULT_ERROR_LOGGING_DIR) <= MAX_PATH);

typedef struct _HTTP_ERROR_LOGGING_CONFIG
{
    BOOLEAN         Enabled;            // FALSE if it's disabled

    ULONG           TruncateSize;       // HTTP_LIMIT_INFINITE for no limit

    UNICODE_STRING  Dir;                // Err logging directory.

    WCHAR           _DirBuffer[MAX_PATH + UL_ERROR_LOG_SUB_DIR_LENGTH + 1];
    
} HTTP_ERROR_LOGGING_CONFIG, * PHTTP_ERROR_LOGGING_CONFIG;

extern HTTP_ERROR_LOGGING_CONFIG g_UlErrLoggingConfig;

//
// Debug stuff.
//

#if DBG
extern ULONGLONG g_UlDebug;
extern ULONG g_UlBreakOnError;
extern ULONG g_UlVerboseErrors;
#endif  // DBG

#if REFERENCE_DEBUG

extern PTRACE_LOG g_pEndpointUsageTraceLog;
extern PTRACE_LOG g_pMondoGlobalTraceLog;
extern PTRACE_LOG g_pPoolAllocTraceLog;
extern PTRACE_LOG g_pUriTraceLog;
extern PTRACE_LOG g_pTdiTraceLog;
extern PTRACE_LOG g_pHttpRequestTraceLog;
extern PTRACE_LOG g_pHttpConnectionTraceLog;
extern PTRACE_LOG g_pHttpResponseTraceLog;
extern PTRACE_LOG g_pAppPoolTraceLog;
extern PTRACE_LOG g_pAppPoolProcessTraceLog;
extern PTRACE_LOG g_pConfigGroupTraceLog;
extern PTRACE_LOG g_pControlChannelTraceLog;
extern PTRACE_LOG g_pThreadTraceLog;
extern PTRACE_LOG g_pFilterTraceLog;
extern PTRACE_LOG g_pIrpTraceLog;
extern PTRACE_LOG g_pTimeTraceLog;
extern PTRACE_LOG g_pAppPoolTimeTraceLog;
extern PTRACE_LOG g_pReplenishTraceLog;
extern PTRACE_LOG g_pMdlTraceLog;
extern PTRACE_LOG g_pSiteCounterTraceLog;
extern PTRACE_LOG g_pConnectionCountTraceLog;
extern PTRACE_LOG g_pConfigGroupInfoTraceLog;
extern PTRACE_LOG g_pChunkTrackerTraceLog;
extern PTRACE_LOG g_pWorkItemTraceLog;
extern PTRACE_LOG g_pUcTraceLog;

#endif  // REFERENCE_DEBUG


extern PSTRING_LOG g_pGlobalStringLog;

extern GENERIC_MAPPING g_UrlAccessGenericMapping;


//
// Object types exported by the kernel but not in any header file.
//

extern POBJECT_TYPE *IoFileObjectType;


#endif  // _DATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\devctrl.h ===
/*++

Copyright (c) 2000-2002 Microsoft Corporation

Module Name:

    devctrl.h

Abstract:

Revision History:

--*/

#ifndef _DEVCTRL_H_
#define _DEVCTRL_H_


VOID
UlSetDummyIoctls(
    VOID
    );


#endif  // _ULLOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\devctrl.c ===
/*++

Copyright (c) 1998-2002 Microsoft Corporation

Module Name:

    devctrl.c

Abstract:

    This module contains the dispatcher for device control IRPs.

Author:

    Keith Moore (keithmo)       10-Jun-1998

Revision History:

--*/


#include "precomp.h"
#include "ioctlp.h"


#ifdef ALLOC_PRAGMA
#endif  // ALLOC_PRAGMA
#if 0
NOT PAGEABLE -- UlDeviceControl
#endif


//
// Lookup table to verify incoming IOCTL codes.
//

typedef
NTSTATUS
(NTAPI * PFN_IOCTL_HANDLER)(
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

typedef struct _UL_IOCTL_TABLE
{
    ULONG IoControlCode;

#if DBG
    PCSTR IoControlName;
# define UL_IOCTL(code) IOCTL_HTTP_##code, #code
#else // !DBG
# define UL_IOCTL(code) IOCTL_HTTP_##code
#endif // !DBG

    PFN_IOCTL_HANDLER Handler;
} UL_IOCTL_TABLE, *PUL_IOCTL_TABLE;


UL_IOCTL_TABLE UlIoctlTable[] =
    {
        { UL_IOCTL(QUERY_CONTROL_CHANNEL),
          &UlQueryControlChannelIoctl
        },
        { UL_IOCTL(SET_CONTROL_CHANNEL),
          &UlSetControlChannelIoctl
        },
        { UL_IOCTL(CREATE_CONFIG_GROUP),
          &UlCreateConfigGroupIoctl
        },
        { UL_IOCTL(DELETE_CONFIG_GROUP),
          &UlDeleteConfigGroupIoctl
        },
        { UL_IOCTL(QUERY_CONFIG_GROUP),
          &UlQueryConfigGroupIoctl
        },
        { UL_IOCTL(SET_CONFIG_GROUP),
          &UlSetConfigGroupIoctl
        },
        { UL_IOCTL(ADD_URL_TO_CONFIG_GROUP),
          &UlAddUrlToConfigGroupIoctl
        },
        { UL_IOCTL(REMOVE_URL_FROM_CONFIG_GROUP),
          &UlRemoveUrlFromConfigGroupIoctl
        },
        { UL_IOCTL(REMOVE_ALL_URLS_FROM_CONFIG_GROUP),
          &UlRemoveAllUrlsFromConfigGroupIoctl
        },
        { UL_IOCTL(QUERY_APP_POOL_INFORMATION),
          &UlQueryAppPoolInformationIoctl
        },
        { UL_IOCTL(SET_APP_POOL_INFORMATION),
          &UlSetAppPoolInformationIoctl
        },
        { UL_IOCTL(SHUTDOWN_APP_POOL),
          &UlShutdownAppPoolIoctl
        },
        { UL_IOCTL(RECEIVE_HTTP_REQUEST),
          &UlReceiveHttpRequestIoctl
        },
        { UL_IOCTL(RECEIVE_ENTITY_BODY),
          &UlReceiveEntityBodyIoctl
        },
        { UL_IOCTL(SEND_HTTP_RESPONSE),
          &UlSendHttpResponseIoctl
        },
        { UL_IOCTL(SEND_ENTITY_BODY),
          &UlSendEntityBodyIoctl
        },
        { UL_IOCTL(FLUSH_RESPONSE_CACHE),
          &UlFlushResponseCacheIoctl
        },
        { UL_IOCTL(WAIT_FOR_DEMAND_START),
          &UlWaitForDemandStartIoctl
        },
        { UL_IOCTL(WAIT_FOR_DISCONNECT),
          &UlWaitForDisconnectIoctl
        },
        { UL_IOCTL(FILTER_ACCEPT),
          &UlFilterAcceptIoctl
        },
        { UL_IOCTL(FILTER_CLOSE),
          &UlFilterCloseIoctl
        },
        { UL_IOCTL(FILTER_RAW_READ),
          &UlFilterRawReadIoctl
        },
        { UL_IOCTL(FILTER_RAW_WRITE),
          &UlFilterRawWriteIoctl
        },
        { UL_IOCTL(FILTER_APP_READ),   
          &UlFilterAppReadIoctl
        },
        { UL_IOCTL(FILTER_APP_WRITE),
          &UlFilterAppWriteIoctl
        },
        { UL_IOCTL(FILTER_RECEIVE_CLIENT_CERT),
          &UlReceiveClientCertIoctl
        },
        { UL_IOCTL(SHUTDOWN_FILTER_CHANNEL),
          &UlShutdownFilterIoctl
        },
        { UL_IOCTL(GET_COUNTERS),
          &UlGetCountersIoctl
        },
        { UL_IOCTL(ADD_FRAGMENT_TO_CACHE),
          &UlAddFragmentToCacheIoctl
        },
        { UL_IOCTL(READ_FRAGMENT_FROM_CACHE),
          &UlReadFragmentFromCacheIoctl
        },
        { UL_IOCTL(SEND_REQUEST),
          &UcSendRequestIoctl
        },
        { UL_IOCTL(SEND_REQUEST_ENTITY_BODY),
          &UcSendEntityBodyIoctl
        },
        { UL_IOCTL(RECEIVE_RESPONSE),
          &UcReceiveResponseIoctl
        },
        { UL_IOCTL(QUERY_SERVER_CONTEXT_INFORMATION),
          &UcQueryServerContextInformationIoctl,
        },
        { UL_IOCTL(SET_SERVER_CONTEXT_INFORMATION),
          &UcSetServerContextInformationIoctl,
        },
        { UL_IOCTL(CANCEL_REQUEST),
          &UcCancelRequestIoctl
        },
    };

C_ASSERT( HTTP_NUM_IOCTLS == DIMENSION(UlIoctlTable) );

//
// Private functions.
//

/***************************************************************************++

Routine Description:

    Dummy Handler

Arguments:

    pIrp - Supplies a pointer to the IO request packet.

    pIrpSp - Supplies a pointer to the IO stack location to use for this
        request.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlpDummyIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )
{
    NTSTATUS Status = STATUS_INVALID_DEVICE_REQUEST;

    UNREFERENCED_PARAMETER( pIrpSp );

    PAGED_CODE();

    //
    // OBSOLETE
    //

    COMPLETE_REQUEST_AND_RETURN( pIrp, Status );

}   // UlpDummyIoctl


/***************************************************************************++

Routine Description:

    Disables a particular IOCTL.

Arguments:

    ioctl - The IO control code.

Return Value:

    VOID

--***************************************************************************/
VOID
UlpSetDummyIoctl(
    ULONG ioctl
    )
{
    ULONG request;

    request = _HTTP_REQUEST(ioctl);

    ASSERT(request < HTTP_NUM_IOCTLS && 
           UlIoctlTable[request].IoControlCode == ioctl);

    UlIoctlTable[request].Handler = UlpDummyIoctl;
}

//
// Public functions.
//

/***************************************************************************++

Routine Description:

    This is the dispatch routine for IOCTL IRPs.

Arguments:

    pDeviceObject - Pointer to device object for target device.

    pIrp - Pointer to IO request packet.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--***************************************************************************/
NTSTATUS
UlDeviceControl(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    )
{
    ULONG code;
    ULONG request;
    NTSTATUS status;
    PIO_STACK_LOCATION pIrpSp;

    UNREFERENCED_PARAMETER( pDeviceObject );

    UL_ENTER_DRIVER( "UlDeviceControl", pIrp );

    //
    // Snag the current IRP stack pointer.
    //

    pIrpSp = IoGetCurrentIrpStackLocation( pIrp );

    //
    // Extract the IOCTL control code and process the request.
    //

    code = pIrpSp->Parameters.DeviceIoControl.IoControlCode;
    request = _HTTP_REQUEST(code);

    if (request < HTTP_NUM_IOCTLS &&
        UlIoctlTable[request].IoControlCode == code)
    {
#if DBG
        KIRQL oldIrql = KeGetCurrentIrql();
#endif  // DBG

        UlTrace(IOCTL,
                ("UlDeviceControl: %-30s code=0x%08lx, "
                 "pIrp=%p, pIrpSp=%p.\n",
                 UlIoctlTable[request].IoControlName, code,
                 pIrp, pIrpSp
                 ));

        UlInitializeWorkItem(UL_WORK_ITEM_FROM_IRP( pIrp ));
    
        status = (UlIoctlTable[request].Handler)( pIrp, pIrpSp );

        ASSERT( KeGetCurrentIrql() == oldIrql );
    }
    else
    {
        //
        // If we made it this far, then the ioctl is invalid.
        //

        UlTrace(IOCTL, ( "UlDeviceControl: invalid IOCTL %08lX\n", code ));

        status = STATUS_INVALID_DEVICE_REQUEST;
        pIrp->IoStatus.Status = status;

        UlCompleteRequest( pIrp, IO_NO_INCREMENT );
    }

    UL_LEAVE_DRIVER( "UlDeviceControl" );

    return status;

}   // UlDeviceControl

/***************************************************************************++

Routine Description:

    Disables some of the IOCTLs we don't use.

Arguments:

Return Value:

    None.

--***************************************************************************/
VOID
UlSetDummyIoctls(
    VOID
    )
{
    UlpSetDummyIoctl(IOCTL_HTTP_SEND_REQUEST);
    UlpSetDummyIoctl(IOCTL_HTTP_SEND_REQUEST_ENTITY_BODY);
    UlpSetDummyIoctl(IOCTL_HTTP_RECEIVE_RESPONSE);
    UlpSetDummyIoctl(IOCTL_HTTP_QUERY_SERVER_CONTEXT_INFORMATION);
    UlpSetDummyIoctl(IOCTL_HTTP_SET_SERVER_CONTEXT_INFORMATION);
    UlpSetDummyIoctl(IOCTL_HTTP_CANCEL_REQUEST);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\debugp.h ===
/*++

Copyright (c) 1999-2002 Microsoft Corporation

Module Name:

    debugp.h

Abstract:

    This module contains definitions private to the debug support.
    These declarations are placed in a separate .H file to make it
    easier to access them from within the kernel debugger extension DLL.


Author:

    Keith Moore (keithmo)       07-Apr-1999

Revision History:

--*/


#ifndef _DEBUGP_H_
#define _DEBUGP_H_

//
// MDL tracker
//

typedef struct _UL_DEBUG_MDL_TRACKER
{
    PMDL       pMdl;
    PCSTR      pFileName;
    USHORT     LineNumber;
    LIST_ENTRY Linkage;
} UL_DEBUG_MDL_TRACKER, *PUL_DEBUG_MDL_TRACKER;

//
// Per-thread data.
//

typedef struct _UL_DEBUG_THREAD_DATA
{
    //
    // Links onto the global list.
    //

    LIST_ENTRY ThreadDataListEntry;

    //
    // The thread.
    //

    PETHREAD pThread;

    //
    // Reference count.
    //

    LONG ReferenceCount;

    //
    // Total number of resources held.
    //

    LONG ResourceCount;

    //
    // Total number of resources held.
    //

    LONG PushLockCount;

    //
    // If we call another driver they may call our
    // completion routine in-line. Remember that
    // we are inside an external call to avoid
    // getting confused.
    //

    LONG ExternalCallCount;

} UL_DEBUG_THREAD_DATA, *PUL_DEBUG_THREAD_DATA;


//
// Header and trailer structs for Pool allocations
//

#define ENABLE_POOL_HEADER
#define ENABLE_POOL_TRAILER
#define ENABLE_POOL_TRAILER_BYTE_SIGNATURE


#if !defined(ENABLE_POOL_HEADER)  && defined(ENABLE_POOL_TRAILER)
#error UL_POOL_TRAILER depends on UL_POOL_HEADER
#endif

#if !defined(_WIN64)
# define UL_POOL_HEADER_PADDING
#endif

#ifdef ENABLE_POOL_HEADER

typedef struct _UL_POOL_HEADER
{
    PCSTR     pFileName;
    PEPROCESS pProcess;
    SIZE_T    Size;
    ULONG     Tag;
    USHORT    LineNumber;
    USHORT    TrailerPadSize;

#ifdef UL_POOL_HEADER_PADDING
    ULONG_PTR Padding;
#endif
} UL_POOL_HEADER, *PUL_POOL_HEADER;

// sizeof(UL_POOL_HEADER) must be a multiple of MEMORY_ALLOCATION_ALIGNMENT
C_ASSERT((sizeof(UL_POOL_HEADER) & (MEMORY_ALLOCATION_ALIGNMENT - 1)) == 0);

__inline
ULONG_PTR
UlpPoolHeaderChecksum(
    PUL_POOL_HEADER pHeader
    )
{
    ULONG_PTR Checksum;

    Checksum = ((ULONG_PTR) pHeader
                + ((ULONG_PTR) pHeader->pFileName >> 12)
                + (ULONG_PTR) pHeader->Size
                + (((ULONG_PTR)  pHeader->LineNumber << 19)
                        - pHeader->LineNumber)  // 2^19-1 is prime
                + pHeader->TrailerPadSize);
    Checksum ^= ~ ((ULONG_PTR) pHeader->Tag << 8);

    return Checksum;
} // UlpPoolHeaderChecksum

#endif // ENABLE_POOL_HEADER


#ifdef ENABLE_POOL_TRAILER

typedef struct _UL_POOL_TRAILER
{
    PUL_POOL_HEADER pHeader;
    ULONG_PTR       CheckSum;
} UL_POOL_TRAILER, *PUL_POOL_TRAILER;

// sizeof(UL_POOL_TRAILER) must be a multiple of MEMORY_ALLOCATION_ALIGNMENT
C_ASSERT((sizeof(UL_POOL_TRAILER) & (MEMORY_ALLOCATION_ALIGNMENT - 1)) == 0);

#endif // ENABLE_POOL_TRAILER


#ifdef ENABLE_POOL_TRAILER_BYTE_SIGNATURE

__inline
UCHAR
UlpAddressToByteSignature(
    PVOID pAddress
    )
{
    ULONG_PTR Address = (ULONG_PTR) pAddress;
    UCHAR     Byte    = (UCHAR) (~Address & 0xFF);

    // Don't want to return 0 as it may inadvertently terminate otherwise
    // unterminated strings
    return (Byte == 0) ? 0x5A : Byte;
} // UlpAddressToByteSignature

#endif // ENABLE_POOL_TRAILER_BYTE_SIGNATURE


//
// Keep track of UL_DEBUG_THREAD_DATA for each thread
//

typedef struct _UL_THREAD_HASH_BUCKET
{
    union
    {
        struct
        {
#if 0
            // Have to use a custom spinlock instead of a regular KSPIN_LOCK.
            // If the driver verifier's IRQL checking is enabled, every
            // spinlock acquisition has to trim all system pagable memory---a
            // hugely time-consuming process that radically changes
            // timing. Every workitem in the threadpool requires acquiring
            // this lock at least twice. Can't use an ERESOURCE or a
            // FAST_MUTEX because they cannot be acquired at DISPATCH_LEVEL.
#endif
            KSPIN_LOCK      BucketSpinLock;
            LONG            Count;
            LONG            Max;
            LIST_ENTRY      BucketListHead;
        };

        UCHAR CacheAlignment[UL_CACHE_LINE];
    };
} UL_THREAD_HASH_BUCKET, *PUL_THREAD_HASH_BUCKET;


//
// Private prototypes.
//

VOID
UlpDbgUpdatePoolCounter(
    IN OUT PLARGE_INTEGER pAddend,
    IN SIZE_T Increment
    );

PUL_DEBUG_THREAD_DATA
UlpDbgFindThread(
    BOOLEAN OkToCreate,
    PCSTR pFileName,
    USHORT LineNumber
    );

VOID
UlpDbgDereferenceThread(
    IN PUL_DEBUG_THREAD_DATA pData
    REFERENCE_DEBUG_FORMAL_PARAMS
    );

//
// Private macros.
//
#define ULP_DBG_FIND_THREAD() \
    UlpDbgFindThread(FALSE, (PCSTR)__FILE__, (USHORT)__LINE__)

#define ULP_DBG_FIND_OR_CREATE_THREAD() \
    UlpDbgFindThread(TRUE, (PCSTR)__FILE__, (USHORT)__LINE__)

#define ULP_DBG_DEREFERENCE_THREAD(pData) \
    UlpDbgDereferenceThread((pData) REFERENCE_DEBUG_ACTUAL_PARAMS)

#define SET_RESOURCE_OWNED_EXCLUSIVE( pLock )                               \
    (pLock)->pExclusiveOwner = PsGetCurrentThread()

#define SET_RESOURCE_NOT_OWNED_EXCLUSIVE( pLock )                           \
    (pLock)->pPreviousOwner = (pLock)->pExclusiveOwner;                     \
    (pLock)->pExclusiveOwner = NULL

#define SET_PUSH_LOCK_OWNED_EXCLUSIVE( pLock )                              \
    (pLock)->pExclusiveOwner = PsGetCurrentThread()

#define SET_PUSH_LOCK_NOT_OWNED_EXCLUSIVE( pLock )                          \
    (pLock)->pPreviousOwner = (pLock)->pExclusiveOwner;                     \
    (pLock)->pExclusiveOwner = NULL

#define SET_SPIN_LOCK_OWNED( pLock )                                        \
    do {                                                                    \
        (pLock)->pOwnerThread = PsGetCurrentThread();                       \
        (pLock)->OwnerProcessor = (ULONG)KeGetCurrentProcessorNumber();     \
    } while (FALSE)

#define SET_SPIN_LOCK_NOT_OWNED( pLock )                                    \
    do {                                                                    \
        (pLock)->pOwnerThread = NULL;                                       \
        (pLock)->OwnerProcessor = (ULONG)-1L;                               \
    } while (FALSE)


//
// Private constants.
//

#define NUM_THREAD_HASH_BUCKETS 64
#define NUM_THREAD_HASH_MASK    (NUM_THREAD_HASH_BUCKETS - 1)

// power of 2 required
C_ASSERT((NUM_THREAD_HASH_BUCKETS & NUM_THREAD_HASH_MASK) == 0);


// 8191 = 2^13 - 1 is prime. Grab the middle 6 bits after multiplying by 8191.
#define HASH_FROM_THREAD(thrd)                                              \
    ((ULONG) ((((ULONG_PTR)(thrd)) - ((ULONG_PTR) (thrd) >> 13))            \
              & NUM_THREAD_HASH_MASK))


#endif  // _DEBUGP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\engine.h ===
/*++

Copyright (c) 1999-2002 Microsoft Corporation

Module Name:

    engine.h

Abstract:

    The public definition of HTTP protocol interfaces.

Author:

    Michael Courage (mcourage)      17-Sep-1999

Revision History:

--*/


#ifndef _ENGINE_H_
#define _ENGINE_H_


typedef enum _UL_CONN_HDR
{
    ConnHdrNone,
    ConnHdrClose,
    ConnHdrKeepAlive,

    ConnHdrMax

} UL_CONN_HDR, *PUL_CONN_HDR;


__inline
UL_CONN_HDR
UlChooseConnectionHeader(
    IN HTTP_VERSION Version,
    IN BOOLEAN Disconnect
    )
{
    UL_CONN_HDR ConnHeader;

    //
    // Sanity check
    //
    PAGED_CODE();

    ConnHeader = ConnHdrNone;

    if (Disconnect)
    {
        if (HTTP_GREATER_EQUAL_VERSION(Version, 1, 0)
            || HTTP_EQUAL_VERSION(Version, 0, 0))
        {
            //
            // Connection: close
            //
            ConnHeader = ConnHdrClose;
        }
    }
    else if (HTTP_EQUAL_VERSION(Version, 1, 0))
    {
        //
        // Connection: keep-alive
        //
        ConnHeader = ConnHdrKeepAlive;
    }

    return ConnHeader;

} // UlChooseConnectionHeader


__inline
BOOLEAN
UlCheckDisconnectInfo(
    IN PUL_INTERNAL_REQUEST pRequest
    )
{
    BOOLEAN Disconnect;

    //
    // Sanity check
    //
    PAGED_CODE();
    ASSERT( UL_IS_VALID_INTERNAL_REQUEST( pRequest ) );

    if (
        //
        // pre-version 1.0
        //

        (HTTP_LESS_VERSION(pRequest->Version, 1, 0)) ||

        //
        // or version 1.0 with no Connection: Keep-Alive
        // CODEWORK: and no Keep-Alive header
        //

        (HTTP_EQUAL_VERSION(pRequest->Version, 1, 0) &&
            (pRequest->HeaderValid[HttpHeaderConnection] == FALSE ||
            !(pRequest->Headers[HttpHeaderConnection].HeaderLength
                    == STRLEN_LIT("keep-alive") &&
                (_stricmp(
                    (const char*) pRequest->Headers[HttpHeaderConnection].pHeader,
                    "keep-alive"
                    ) == 0)))) ||

        //
        // or version 1.1 with a Connection: close
        // CODEWORK: move to parser or just make better in general..
        //

        (HTTP_EQUAL_VERSION(pRequest->Version, 1, 1) &&
            pRequest->HeaderValid[HttpHeaderConnection] &&
            pRequest->Headers[HttpHeaderConnection].HeaderLength
                == STRLEN_LIT("close") &&
            _stricmp(
                (const char*) pRequest->Headers[HttpHeaderConnection].pHeader,
                "close"
                ) == 0)
        )
    {
        Disconnect = TRUE;
    }
    else
    {
        Disconnect = FALSE;
    }

    return Disconnect;

} // UlCheckDisconnectInfo


__inline
BOOLEAN
UlNeedToGenerateContentLength(
    IN HTTP_VERB Verb,
    IN USHORT StatusCode,
    IN ULONG Flags
    )
{
    //
    // Fast path: If there is more data on the way, then don't generate
    // the header.
    //

    if ((Flags & HTTP_SEND_RESPONSE_FLAG_MORE_DATA) != 0)
    {
        return FALSE;
    }

    //
    // RFC2616 section 4.3.
    //

    if ((100 <= StatusCode && StatusCode <= 199) || // 1xx (informational)
        (StatusCode == 204) ||                      // 204 (no content)
        (StatusCode == 304))                        // 304 (not modified)
    {
        return FALSE;
    }

    if (Verb == HttpVerbHEAD)
    {
        return FALSE;
    }

    //
    // Otherwise, we can generate a content-length header.
    //

    return TRUE;

} // UlNeedToGenerateContentLength


#endif // _ENGINE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\errlogp.h ===
/*++

Copyright (c) 2000-2001 Microsoft Corporation

Module Name:

    errlogp.h driver wide Error Logging module

Abstract:

    Private header file for the Error Logging.

Author:

    Ali E. Turkoglu (aliTu)       30-Jan-2002

Revision History:

    ---

--*/

#ifndef _ERRLOGP_H_
#define _ERRLOGP_H_

///////////////////////////////////////////////////////////////////////////////
//
// Private definitions for the HTTP Error Logging Module
//
///////////////////////////////////////////////////////////////////////////////

//
// Version numbers for the original raw binary format.
//

#define MAJOR_ERROR_LOG_FILE_VERSION            (1)
#define MINOR_ERROR_LOG_FILE_VERSION            (0)

//
// FileName specific constants
//

#define ERROR_LOG_FILE_NAME_PREFIX              L"\\httperr"

#define ERROR_LOG_FILE_NAME_EXTENSION           L"log"
#define ERROR_LOG_FILE_NAME_EXTENSION_PLUS_DOT  L".log"

#define ERROR_LOG_FIELD_SEPERATOR_CHAR          ' '

#define ERROR_LOG_FIELD_NOT_EXISTS_CHAR         '-'

#define ERROR_LOG_FIELD_BAD_CHAR                '+'

//
// Macro for a max err log file (i.e. "\httperr1234567890.log")
//

#define ERROR_LOG_MAX_FULL_FILE_NAME_LENGTH                     \
        (                                                       \
            WCSLEN_LIT(ERROR_LOG_FILE_NAME_PREFIX)              \
            +                                                   \
            MAX_ULONG_STR                                       \
            +                                                   \
            WCSLEN_LIT(ERROR_LOG_FILE_NAME_EXTENSION_PLUS_DOT)  \
        )

#define ERROR_LOG_MAX_FULL_FILE_NAME_SIZE                       \
            (ERROR_LOG_MAX_FULL_FILE_NAME_LENGTH * sizeof(WCHAR))

C_ASSERT(UL_MAX_FILE_NAME_SUFFIX_LENGTH >= ERROR_LOG_MAX_FULL_FILE_NAME_LENGTH);

C_ASSERT(WCSLEN_LIT(DEFAULT_ERROR_LOGGING_DIR) <= MAX_PATH);


#define ERR_DATE_FIELD_LEN                      (10)

#define ERR_TIME_FIELD_LEN                      (8)

/*

    Error logging Format

    1.  Date-Time (W3C Format)
    2.  Client IP:port
    3.  Server IP:port
    4.  Protocol-version
    5.  Verb
    6.  URL & Query
    7.  Protocol-status-code (401, etc)
    8.  SiteId
    9.  Information field
    10. \r\n

*/

#define MAX_ERROR_LOG_FIX_FIELD_OVERHEAD                                               \
          (   ERR_DATE_FIELD_LEN + 1        /* Date */                                 \
            + ERR_TIME_FIELD_LEN + 1        /* Time */                                 \
            + UL_HTTP_VERSION_LENGTH + 1    /* Protocol Version */                     \
            + MAX_VERB_LENGTH + 1           /* Verb */                                 \
            + 3 + 1                         /* Protocol Status */                      \
            + MAX_IP_ADDR_STRING_LEN + 1 + MAX_PORT_LENGTH + 1  /* Client Ip Port */   \
            + MAX_IP_ADDR_STRING_LEN + 1 + MAX_PORT_LENGTH + 1  /* Server Ip Port */   \
            + 1 + 1                         /* For empty Uri plus seperator */         \
            + MAX_ULONG_STR + 1             /* For SiteId plus seperator */            \
            + 1 + 1                         /* For empty Info plus seperator */        \
            + 2                             /* \r\n */                                 \
            )

//
// Error Log file entry
//

typedef struct _UL_ERROR_LOG_FILE_ENTRY
{
    //
    // Must be UL_ERROR_LOG_FILE_ENTRY_POOL_TAG.
    //

    ULONG               Signature;

    //
    // This lock protects the shared writes and exclusive flushes.
    // It has to be push lock since the ZwWrite operation
    // cannot run at APC_LEVEL.
    //

    UL_PUSH_LOCK        PushLock;

    //
    // The name of the file. Full path including the directory.
    //

    UNICODE_STRING      FileName;
    PWSTR               pShortName;

    //
    // Following will be NULL until a request comes in to the
    // site that this entry represents.
    //

    PUL_LOG_FILE_HANDLE pLogFile;

    //
    // Recycling information.
    //

    ULONG               TruncateSize;

    ULONG               SequenceNumber;

    ULARGE_INTEGER      TotalWritten;

    //
    // For Log File ReCycling based on GMT time.
    // And periodic buffer flushing.
    //

    UL_LOG_TIMER        BufferTimer;
    UL_WORK_ITEM        WorkItem;    // For the pasive worker
    LONG                WorkItemScheduled; // To protect against multiple queueing

    union
    {
        //
        // Flags to show the entry states mostly. Used by
        // recycling.
        //

        ULONG Value;
        struct
        {
            ULONG       StaleSequenceNumber:1;
            ULONG       RecyclePending:1;
            ULONG       Active:1;

            ULONG       WriteFailureLogged:1;
            ULONG       CreateFileFailureLogged:1;
        };

    } Flags;

    //
    // The default buffer size is g_AllocationGranularity.
    // The operating system's allocation granularity.
    //

    PUL_LOG_FILE_BUFFER LogBuffer;

} UL_ERROR_LOG_FILE_ENTRY, *PUL_ERROR_LOG_FILE_ENTRY;

#define IS_VALID_ERROR_LOG_FILE_ENTRY( pEntry )   \
    ( (pEntry != NULL) && ((pEntry)->Signature == UL_ERROR_LOG_FILE_ENTRY_POOL_TAG) )


///////////////////////////////////////////////////////////////////////////////
//
// Private function calls
//
///////////////////////////////////////////////////////////////////////////////

VOID
UlpErrorLogBufferTimerDpcRoutine(
    PKDPC Dpc,
    PVOID DeferredContext,
    PVOID SystemArgument1,
    PVOID SystemArgument2
    );

VOID
UlpErrorLogBufferTimerHandler(
    IN PUL_WORK_ITEM pWorkItem
    );

NTSTATUS
UlpCreateErrorLogFile(
    IN OUT PUL_ERROR_LOG_FILE_ENTRY pEntry
    );

NTSTATUS
UlpFlushErrorLogFile(
    IN PUL_ERROR_LOG_FILE_ENTRY  pEntry
    );

NTSTATUS
UlpDisableErrorLogEntry(
    IN OUT PUL_ERROR_LOG_FILE_ENTRY pEntry
    );

NTSTATUS
UlpRecycleErrorLogFile(
    IN OUT PUL_ERROR_LOG_FILE_ENTRY pEntry
    );

NTSTATUS
UlpHandleErrorLogFileRecycle(
    IN OUT PVOID pContext
    );

PUL_ERROR_LOG_BUFFER
UlpAllocErrorLogBuffer(
    IN ULONG    BufferSize
    );

VOID
UlpFreeErrorLogBuffer(
    IN OUT PUL_ERROR_LOG_BUFFER pErrorLogBuffer
    );

NTSTATUS
UlpBuildErrorLogRecord(
    IN PUL_ERROR_LOG_INFO pLogInfo
    );

NTSTATUS
UlpWriteToErrorLogFileDebug(
    IN PUL_ERROR_LOG_FILE_ENTRY  pEntry,
    IN ULONG                     RecordSize,
    IN PUCHAR                    pUserRecord
    );

NTSTATUS
UlpWriteToErrorLogFileShared(
    IN PUL_ERROR_LOG_FILE_ENTRY  pEntry,
    IN ULONG                     RecordSize,
    IN PUCHAR                    pUserRecord
    );

NTSTATUS
UlpWriteToErrorLogFileExclusive(
    IN PUL_ERROR_LOG_FILE_ENTRY  pEntry,
    IN ULONG                     RecordSize,
    IN PUCHAR                    pUserRecord
    );

NTSTATUS
UlpWriteToErrorLogFile(
    IN PUL_ERROR_LOG_FILE_ENTRY  pEntry,
    IN ULONG                     RecordSize,
    IN PUCHAR                    pUserRecord
    );

/***************************************************************************++

Routine Description:

    Error log files are always recycled based on size.

Arguments:

    pEntry: The error log file entry.
    NewRecordSize: The size of the new record going to the buffer. (Bytes)

--***************************************************************************/

__inline
BOOLEAN
UlpIsErrorLogFileOverFlow(
    IN  PUL_ERROR_LOG_FILE_ENTRY  pEntry,
    IN  ULONG NewRecordSize
    )
{
    //
    // If infinite then no rollover.
    //
    if (pEntry->TruncateSize == HTTP_LIMIT_INFINITE)
    {
        return FALSE;
    }
    else
    {
        //
        // BufferUsed: Amount of log buffer we are >currently< using.
        //

        ULONG BufferUsed = 0;

        if (pEntry->LogBuffer)
        {
            BufferUsed = pEntry->LogBuffer->BufferUsed;
        }

        //
        // TotalWritten get updated >only< with buffer flush. Therefore
        // we have to pay attention to the buffer used.
        //

        if ((pEntry->TotalWritten.QuadPart
             + (ULONGLONG) BufferUsed
             + (ULONGLONG) NewRecordSize
             ) >= (ULONGLONG) pEntry->TruncateSize)
        {
            UlTrace(ERROR_LOGGING,
                ("Http!UlpIsErrorLogFileOverFlow: pEntry %p FileBuffer %p "
                 "TW:%I64d B:%d R:%d T:%d\n",
                  pEntry,
                  pEntry->LogBuffer,
                  pEntry->TotalWritten.QuadPart,
                  BufferUsed,
                  NewRecordSize,
                  pEntry->TruncateSize
                  ));

            return TRUE;
        }
        else
        {
            return FALSE;
        }

    }
}

/***************************************************************************++

Routine Description:

    Error log files are always recycled based on size.

Arguments:

    pRequest: Internal request structure.

Returns

    # of bytes of the picked url. Zero if nothing needs to be logged.

--***************************************************************************/

__inline
ULONG
UlpCalculateUrlSize(
    IN  PUL_INTERNAL_REQUEST pRequest,
    OUT PBOOLEAN             pbLogRawUrl
    )
{

//
// Following macro is to test whether Abs Path is really pointing to
// the original Url buffer rather than to an arbitrary buffer like g_SlashPath.
// See 527947 and 765769.
//

#define ABS_PATH_SAFE(pUrl,pAbs,length)     \
    ((pAbs) &&                              \
     (pUrl) &&                              \
     ((pAbs) >= (pUrl))    &&               \
     (((ULONG_PTR) (length)) >              \
            DIFF_ULONGPTR((PUCHAR)(pAbs) - (PUCHAR)(pUrl)) ) \
     )

    ULONG UrlSize = 0;

    //
    // CookedUrl length and UrlLength are in bytes. Pick cooked url if it
    // exists. Otherwise use the raw url, but only if it is clean  enough
    // for us (State >= ParseVersionState) and pAbsPath is really pointing
    // into Url buffer. In raw url case, parser sometimes init the pAbsPath
    // to a global string. (when there's no abs path in the raw url).
    //

    ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pRequest));

    if (pRequest->CookedUrl.pAbsPath)
    {
        ASSERT(pRequest->CookedUrl.pUrl);

        UrlSize = pRequest->CookedUrl.Length
                  -
                  (ULONG) (DIFF(pRequest->CookedUrl.pAbsPath
                                 -
                                 pRequest->CookedUrl.pUrl
                                 ) * sizeof(WCHAR));

        ASSERT(wcslen(pRequest->CookedUrl.pAbsPath)
                                        == UrlSize/sizeof(WCHAR));

        *pbLogRawUrl = FALSE;

    }
    else if (pRequest->RawUrl.pAbsPath)
    {
        if (pRequest->ParseState > ParseUrlState)
        {
            ASSERT(pRequest->RawUrl.pUrl);

            if (ABS_PATH_SAFE(pRequest->RawUrl.pUrl,
                                pRequest->RawUrl.pAbsPath,
                                pRequest->RawUrl.Length))
            {
                UrlSize = pRequest->RawUrl.Length
                          -
                          (ULONG) DIFF(pRequest->RawUrl.pAbsPath
                                        -
                                        pRequest->RawUrl.pUrl
                                        );

                 *pbLogRawUrl = TRUE;
            }
        }
    }

    UrlSize = MIN(UrlSize, MAX_LOG_EXTEND_FIELD_LEN);

    return UrlSize;
}

#endif  // _ERRLOGP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\errlog.h ===
/*++

Copyright (c) 2000-2001 Microsoft Corporation

Module Name:

    errlog.h (Generic Error Logging v1.0)

Abstract:

    This module implements the generic error logging.

Author:

    Ali E. Turkoglu (aliTu)       24-Jan-2002

Revision History:

    ---

--*/

#ifndef _ERRLOG_H_
#define _ERRLOG_H_

//
// Forwarders
//

typedef struct _UL_INTERNAL_REQUEST *PUL_INTERNAL_REQUEST;

///////////////////////////////////////////////////////////////////////////////
//
// Global definitions
//
///////////////////////////////////////////////////////////////////////////////

//
// Special value to show protol status is not available
//

#define UL_PROTOCOL_STATUS_NA    (0)
#define MAX_LOG_INFO_FIELD_LEN   (1024) 

//
// Lookaside list allocated err log info buffer.
//

typedef struct _UL_ERROR_LOG_BUFFER
{
    SLIST_ENTRY         LookasideEntry;     // Must be the 1st element in the struct

    ULONG               Signature;          // Must be UL_ERROR_LOG_BUFFER_POOL_TAG.

    BOOLEAN             IsFromLookaside;    // True if allocation is from lookaside

    ULONG               Used;               // How much of the buffer is used
    
    PUCHAR              pBuffer;            // Points to directly after the struct
    
} UL_ERROR_LOG_BUFFER, *PUL_ERROR_LOG_BUFFER;

#define IS_VALID_ERROR_LOG_BUFFER( entry )                           \
    ( (entry) != NULL &&                                             \
      (entry)->Signature == UL_ERROR_LOG_BUFFER_POOL_TAG )


typedef struct _UL_ERROR_LOG_INFO
{
    //
    // Request context is usefull for parse errors.
    //
    
    PUL_INTERNAL_REQUEST    pRequest;     

    //
    // Connection context is for timeouts etc ...
    //
    
    PUL_HTTP_CONNECTION     pHttpConn;   

    //
    // Depending of the type of the error, additional 
    // information provided by the caller.
    //
    
    PCHAR                   pInfo;
        
    USHORT                  InfoSize;     // In bytes

    //
    // Protocol status if available. If not it should be
    // zero. 
    //

    USHORT                  ProtocolStatus;

    //
    // The temp logging buffer to hold the log record
    // until the actual error log lock is acquired.
    //

    PUL_ERROR_LOG_BUFFER    pErrorLogBuffer;

    
} UL_ERROR_LOG_INFO, *PUL_ERROR_LOG_INFO;

#define IS_VALID_ERROR_LOG_INFO(pInfo)     (pInfo != NULL)


///////////////////////////////////////////////////////////////////////////////
//
// Exported functions
//
///////////////////////////////////////////////////////////////////////////////


NTSTATUS
UlInitializeErrorLog(
    VOID
    );

VOID
UlTerminateErrorLog(
    VOID
    );

BOOLEAN
UlErrorLoggingEnabled(
    VOID
    );

NTSTATUS
UlBuildErrorLoggingDirStr(
    IN  PCWSTR          pSrc,
    OUT PUNICODE_STRING pDir
    );

NTSTATUS
UlCheckErrorLogConfig(
    IN PHTTP_ERROR_LOGGING_CONFIG  pUserConfig
    );

NTSTATUS
UlConfigErrorLogEntry(
    IN PHTTP_ERROR_LOGGING_CONFIG pUserConfig
    );

VOID
UlCloseErrorLogEntry(
    VOID
    );

NTSTATUS
UlLogHttpError(
    IN PUL_ERROR_LOG_INFO pLogInfo
    );

#endif  // _ERRLOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\fastio.c ===
/*++

Copyright (c) 2000-2002 Microsoft Corporation

Module Name:

    fastio.c

Abstract:

    This module implements the fast I/O logic of HTTP.SYS.

Author:

    Chun Ye (chunye)    09-Dec-2000

Revision History:

--*/


#include "precomp.h"
#include "ioctlp.h"


//
// Private globals.
//

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, UlFastIoDeviceControl )
#pragma alloc_text( PAGE, UlSendHttpResponseFastIo )
#pragma alloc_text( PAGE, UlReceiveHttpRequestFastIo )
#pragma alloc_text( PAGE, UlReadFragmentFromCacheFastIo )
#pragma alloc_text( PAGE, UlFastSendHttpResponse )
#endif  // ALLOC_PRAGMA

#if 0
NOT PAGEABLE -- UlpRestartFastSendHttpResponse
NOT PAGEABLE -- UlpFastSendCompleteWorker
NOT PAGEABLE -- UlpFastReceiveHttpRequest
#endif


FAST_IO_DISPATCH UlFastIoDispatch =
{
    sizeof(FAST_IO_DISPATCH),   // SizeOfFastIoDispatch
    NULL,                       // FastIoCheckIfPossible
    NULL,                       // FastIoRead
    NULL,                       // FastIoWrite
    NULL,                       // FastIoQueryBasicInfo
    NULL,                       // FastIoQueryStandardInfo
    NULL,                       // FastIoLock
    NULL,                       // FastIoUnlockSingle
    NULL,                       // FastIoUnlockAll
    NULL,                       // FastIoUnlockAllByKey
    UlFastIoDeviceControl       // FastIoDeviceControl
};


//
// Public functions.
//

/***************************************************************************++

Routine Description:

    The fast I/O dispatch routine.

Arguments:

    pFileObject - the file object

    Wait - not used

    pInputBuffer - pointer to the input buffer

    InputBufferLength - the input buffer length

    pOutputBuffer - pointer to the output buffer

    OutputBufferLength - the output buffer length

    IoControlCode - the I/O control code for this IOCTL

    pIoStatus - the IoStatus block

    pDeviceObject - the device object

Return Value:

    TRUE - fast path taken and success

    FALSE - fast path not taken

--***************************************************************************/
BOOLEAN
UlFastIoDeviceControl(
    IN PFILE_OBJECT         pFileObject,
    IN BOOLEAN              Wait,
    IN PVOID                pInputBuffer OPTIONAL,
    IN ULONG                InputBufferLength,
    OUT PVOID               pOutputBuffer OPTIONAL,
    IN ULONG                OutputBufferLength,
    IN ULONG                IoControlCode,
    OUT PIO_STATUS_BLOCK    pIoStatus,
    IN PDEVICE_OBJECT       pDeviceObject
    )
{
    UNREFERENCED_PARAMETER( Wait );
    UNREFERENCED_PARAMETER( pDeviceObject );

    if (IoControlCode == IOCTL_HTTP_SEND_HTTP_RESPONSE ||
        IoControlCode == IOCTL_HTTP_SEND_ENTITY_BODY)
    {
        return UlSendHttpResponseFastIo(
                    pFileObject,
                    pInputBuffer,
                    InputBufferLength,
                    pOutputBuffer,
                    OutputBufferLength,
                    pIoStatus,
                    (BOOLEAN) (IoControlCode == IOCTL_HTTP_SEND_ENTITY_BODY),
                    ExGetPreviousMode()
                    );
    }
    else
    if (IoControlCode == IOCTL_HTTP_RECEIVE_HTTP_REQUEST)
    {
        return UlReceiveHttpRequestFastIo(
                    pFileObject,
                    pInputBuffer,
                    InputBufferLength,
                    pOutputBuffer,
                    OutputBufferLength,
                    pIoStatus,
                    ExGetPreviousMode()
                    );
    }
    else
    if (IoControlCode == IOCTL_HTTP_READ_FRAGMENT_FROM_CACHE)
    {
        return UlReadFragmentFromCacheFastIo(
                    pFileObject,
                    pInputBuffer,
                    InputBufferLength,
                    pOutputBuffer,
                    OutputBufferLength,
                    pIoStatus,
                    ExGetPreviousMode()
                    );
    }
    else
    {
        return FALSE;
    }

} // UlFastIoDeviceControl


/***************************************************************************++

Routine Description:

    The fast I/O routine for IOCTL_HTTP_SEND_HTTP_RESPONSE and
    IOCTL_HTTP_SEND_ENTITY_BODY.

Arguments:

    pFileObject - the file object

    pInputBuffer - pointer to the input buffer

    InputBufferLength - the input buffer length

    pOutputBuffer - pointer to the output buffer

    OutputBufferLength - the output buffer length

    IoControlCode - the I/O control code for this IOCTL

    pIoStatus - the IoStatus block

    RawResponse - TRUE  if this is IOCTL_HTTP_SEND_ENTITY_BODY
                - FALSE if this is IOCTL_HTTP_SEND_HTTP_RESPONSE

    RequestorMode - UserMode or KernelMode

Return Value:

    TRUE - fast path taken and success

    FALSE - fast path not taken

--***************************************************************************/
BOOLEAN
UlSendHttpResponseFastIo(
    IN PFILE_OBJECT         pFileObject,
    IN PVOID                pInputBuffer,
    IN ULONG                InputBufferLength,
    OUT PVOID               pOutputBuffer,
    IN ULONG                OutputBufferLength,
    OUT PIO_STATUS_BLOCK    pIoStatus,
    IN BOOLEAN              RawResponse,
    IN KPROCESSOR_MODE      RequestorMode
    )
{
    NTSTATUS                        Status = STATUS_SUCCESS;
    PHTTP_SEND_HTTP_RESPONSE_INFO   pSendInfo;
    PUL_INTERNAL_REQUEST            pRequest = NULL;
    ULONG                           BufferLength = 0;
    ULONG                           BytesSent = 0;
    USHORT                          EntityChunkCount;
    PHTTP_DATA_CHUNK                pEntityChunks;
    HTTP_DATA_CHUNK                 LocalEntityChunks[UL_LOCAL_CHUNKS];
    PHTTP_RESPONSE                  pUserResponse;
    PHTTP_LOG_FIELDS_DATA           pUserLogData;
    HTTP_LOG_FIELDS_DATA            LocalLogData;
    PUL_APP_POOL_PROCESS            pProcess;
    BOOLEAN                         FastIoStatus;
    BOOLEAN                         CloseConnection = FALSE;
    ULONG                           Flags;
    PUL_URI_CACHE_ENTRY             pCacheEntry = NULL;
    HTTP_CACHE_POLICY               CachePolicy;
    HTTP_REQUEST_ID                 RequestId;

    UNREFERENCED_PARAMETER( pOutputBuffer );
    UNREFERENCED_PARAMETER( OutputBufferLength );

    //
    // Sanity check.
    //

    PAGED_CODE();

    __try
    {
        //
        // Initialize IoStatus in the failure case.
        //

        pIoStatus->Information = 0;

        //
        // Ensure this is really an app pool, not a control channel.
        //

        VALIDATE_APP_POOL_FO( pFileObject, pProcess, TRUE );

        //
        // Ensure the input buffer is large enough.
        //

        if (pInputBuffer == NULL || InputBufferLength < sizeof(*pSendInfo))
        {
            //
            // Input buffer too small.
            //

            Status = STATUS_BUFFER_TOO_SMALL;
            goto end;
        }

        pSendInfo = (PHTTP_SEND_HTTP_RESPONSE_INFO) pInputBuffer;

        //
        // To be accurate, the third parameter should be
        // TYPE_ALIGNMENT(HTTP_SEND_HTTP_RESPONSE_INFO). However, this
        // produces alignment fault exceptions.
        //

        UlProbeForRead(
            pSendInfo,
            sizeof(HTTP_SEND_HTTP_RESPONSE_INFO),
            sizeof(PVOID),
            RequestorMode
            );

        pUserResponse = pSendInfo->pHttpResponse;
        pEntityChunks = pSendInfo->pEntityChunks;
        EntityChunkCount = pSendInfo->EntityChunkCount;
        pUserLogData = pSendInfo->pLogData;
        Flags = pSendInfo->Flags;
        RequestId = pSendInfo->RequestId;
        CachePolicy = pSendInfo->CachePolicy;

        //
        // Prevent arithmetic overflows in the multiplication below.
        //

        if (EntityChunkCount >= UL_MAX_CHUNKS)
        {
            Status = STATUS_INVALID_PARAMETER;
            goto end;
        }

        //
        // Sanity check.
        //

        if (Flags & (~HTTP_SEND_RESPONSE_FLAG_VALID))
        {
            Status = STATUS_INVALID_PARAMETER;
            goto end;
        }

        //
        // Capture and make a local copy of LogData.
        //

        if (pUserLogData && UserMode == RequestorMode)
        {
            UlProbeForRead(
                pUserLogData,
                sizeof(HTTP_LOG_FIELDS_DATA),
                sizeof(USHORT),
                RequestorMode
                );

            LocalLogData = *pUserLogData;
            pUserLogData = &LocalLogData;
        }

        //
        // Fast path is only enabled if the response can be buffered.
        //

        if (g_UriCacheConfig.EnableCache &&
            RawResponse == FALSE &&
            CachePolicy.Policy != HttpCachePolicyNocache)
        {
            //
            // Take the slow path if we need to build a cache entry.
            //

            Status = STATUS_NOT_IMPLEMENTED;
            goto end;
        }
        else
        if (EntityChunkCount > UL_LOCAL_CHUNKS && UserMode == RequestorMode)
        {
            //
            // Fast path doesn't handle array of chunks that can't be
            // copied to the on stack chunk arrary.
            //

            Status = STATUS_NOT_SUPPORTED;
            goto end;
        }
        else
        if (EntityChunkCount)
        {
            PHTTP_DATA_CHUNK pChunk;
            ULONG i;

            //
            // Third parameter should be TYPE_ALIGNMENT(HTTP_DATA_CHUNK).
            //

            UlProbeForRead(
                pEntityChunks,
                sizeof(HTTP_DATA_CHUNK) * EntityChunkCount,
                sizeof(PVOID),
                RequestorMode
                );

            //
            // Make a local copy of the chunk array and use it from now on.
            //

            if (UserMode == RequestorMode)
            {
                RtlCopyMemory(
                    LocalEntityChunks,
                    pEntityChunks,
                    sizeof(HTTP_DATA_CHUNK) * EntityChunkCount
                    );

                pEntityChunks = LocalEntityChunks;
            }

            pChunk = pEntityChunks;

            //
            // Make sure we have zero or one FromFragmentCache chunk and
            // all other chunks are from memory and their total size
            // is <= g_UlMaxCopyThreshold. Take the slow path if this is
            // not the case.
            //

            for (i = 0; i < EntityChunkCount; i++, pChunk++)
            {
                ULONG ChunkLength = pChunk->FromMemory.BufferLength;

                //
                // We only allow one FromFragmentCache chunk in the fast path.
                //

                if (HttpDataChunkFromFragmentCache == pChunk->DataChunkType)
                {
                    UNICODE_STRING KernelFragmentName;
                    UNICODE_STRING UserFragmentName;

                    if (pCacheEntry)
                    {
                        Status = STATUS_NOT_SUPPORTED;
                        goto end;
                    }

                    UserFragmentName.Buffer = (PWSTR)
                            pChunk->FromFragmentCache.pFragmentName;
                    UserFragmentName.Length =
                            pChunk->FromFragmentCache.FragmentNameLength;
                    UserFragmentName.MaximumLength =
                            UserFragmentName.Length;

                    Status =
                        UlProbeAndCaptureUnicodeString(
                            &UserFragmentName,
                            RequestorMode,
                            &KernelFragmentName,
                            0
                            );
                    if (!NT_SUCCESS(Status))
                    {
                        goto end;
                    }

                    Status = UlCheckoutFragmentCacheEntry(
                                KernelFragmentName.Buffer,
                                KernelFragmentName.Length,
                                pProcess,
                                &pCacheEntry
                                );

                    UlFreeCapturedUnicodeString(&KernelFragmentName);

                    if (!NT_SUCCESS(Status))
                    {
                        goto end;
                    }

                    ASSERT( pCacheEntry );
                    continue;
                }

                //
                // FromFileHandle chunks are not supported in the fast path.
                //

                if (HttpDataChunkFromMemory != pChunk->DataChunkType)
                {
                    Status = STATUS_NOT_SUPPORTED;
                    goto end;
                }

                if (g_UlMaxCopyThreshold < ChunkLength ||
                    BufferLength > (g_UlMaxCopyThreshold - ChunkLength))
                {
                    Status = STATUS_NOT_SUPPORTED;
                    goto end;
                }

                BufferLength += ChunkLength;
                ASSERT( BufferLength <= g_UlMaxCopyThreshold );
            }
        }

        //
        // SendHttpResponse *must* take a PHTTP_RESPONSE. This will
        // protect us from those whackos who attempt to build their own
        // raw response headers. This is ok for SendEntityBody. The
        // two cases are differentiated by the RawResponse flag.
        //

        if (RawResponse == FALSE)
        {
            if (NULL == pUserResponse)
            {
                Status = STATUS_INVALID_PARAMETER;
                goto end;
            }

            //
            // Third parameter should be TYPE_ALIGNMENT(HTTP_RESPONSE).
            //

            UlProbeForRead(
                pUserResponse,
                sizeof(HTTP_RESPONSE),
                sizeof(PVOID),
                RequestorMode
                );
        }
        else
        {
            //
            // Make sure pUserResponse is NULL for RawResponse.
            //

            pUserResponse = NULL;
        }
    }
     __except( UL_EXCEPTION_FILTER() )
    {
        Status = UL_CONVERT_EXCEPTION_CODE( GetExceptionCode() );
        goto end;
    }

    //
    // Now get the request from the request ID. This gives us a reference
    // to the request.
    //

    pRequest = UlGetRequestFromId( RequestId, pProcess );

    if (pRequest == NULL)
    {
        Status = STATUS_CONNECTION_INVALID;
        goto end;
    }

    ASSERT( UL_IS_VALID_INTERNAL_REQUEST( pRequest ) );
    ASSERT( UL_IS_VALID_HTTP_CONNECTION( pRequest->pHttpConn ) );

    //
    // UL Receives the fast response (WP thread).
    //

    if (ETW_LOG_MIN() && ((Flags & HTTP_SEND_RESPONSE_FLAG_MORE_DATA) == 0))
    {
        UlEtwTraceEvent(
            &UlTransGuid,
            ETW_TYPE_ULRECV_FASTRESP,
            (PVOID) &pRequest->RequestIdCopy,
            sizeof(HTTP_REQUEST_ID),
            NULL,
            0
            );
    }

    //
    // Check if we have exceeded maximum buffered send limit or if an
    // send IRP is pending.
    //

    if (pRequest->SendInProgress ||
        pRequest->SendsPending > g_UlMaxBufferedSends)
    {
        Status = STATUS_ALLOTTED_SPACE_EXCEEDED;
        goto end;
    }

    //
    // Check if a response has already been sent on this request. We can
    // test this without acquiring the request resource, since the flag is
    // only set (never reset).
    //

    if (NULL != pUserResponse)
    {
        //
        // Make sure only one response header goes back.
        //

        if (1 == InterlockedCompareExchange(
                    (PLONG)&pRequest->SentResponse,
                    1,
                    0
                    ))
        {
            CloseConnection = TRUE;
            Status = STATUS_INVALID_DEVICE_STATE;

            UlTraceError(SEND_RESPONSE, (
                "http!UlSendHttpResponseFastIo(pRequest = %p (%I64x)) %s\n"
                "        Tried to send a second response!\n",
                pRequest,
                pRequest->RequestId,
                HttpStatusToString(Status)
                ));

            goto end;
        }
    }
    else
    if (pRequest->SentResponse == 0)
    {
        //
        // Ensure a response has already been sent. If the application is
        // sending entity without first having sent a response header,
        // check the HTTP_SEND_RESPONSE_FLAG_RAW_HEADER flag.
        //

        if ((Flags & HTTP_SEND_RESPONSE_FLAG_RAW_HEADER))
        {
            //
            // Make sure only one response header goes back.
            //

            if (1 == InterlockedCompareExchange(
                        (PLONG)&pRequest->SentResponse,
                        1,
                        0
                        ))
            {
                CloseConnection = TRUE;
                Status = STATUS_INVALID_DEVICE_STATE;

                UlTraceError(SEND_RESPONSE, (
                    "http!UlSendHttpResponseFastIo(pRequest = %p (%I64x))\n"
                    "        Already sent a response, %s!\n",
                    pRequest,
                    pRequest->RequestId,
                    HttpStatusToString(Status)
                    ));

                goto end;
            }
        }
        else
        {
            CloseConnection = TRUE;
            Status = STATUS_INVALID_DEVICE_STATE;

            UlTraceError(SEND_RESPONSE, (
                "http!UlSendHttpResponseFastIo(pRequest = %p (%I64x)) %s\n"
                "        No response yet!\n",
                pRequest,
                pRequest->RequestId,
                HttpStatusToString(Status)
                ));

            goto end;
        }
    }

    //
    // Also ensure that all previous calls to SendHttpResponse
    // and SendEntityBody had the MORE_DATA flag set.
    //

    if ((Flags & HTTP_SEND_RESPONSE_FLAG_MORE_DATA) == 0)
    {
        //
        // Set if we have sent the last response, but bail out if the flag
        // is already set since there can be only one last response.
        //

        if (1 == InterlockedCompareExchange(
                    (PLONG)&pRequest->SentLast,
                    1,
                    0
                    ))
        {
            CloseConnection = TRUE;
            Status = STATUS_INVALID_DEVICE_STATE;

            UlTraceError(SEND_RESPONSE, (
                "http!UlSendHttpResponseFastIo(pRequest = %p (%I64x)) %s\n"
                "        Last send after previous last send!\n",
                pRequest,
                pRequest->RequestId,
                HttpStatusToString(Status)
                ));

            goto end;
        }
    }
    else
    if (pRequest->SentLast == 1)
    {
        CloseConnection = TRUE;
        Status = STATUS_INVALID_DEVICE_STATE;

        UlTraceError(SEND_RESPONSE, (
            "http!UlSendHttpResponseFastIo(pRequest = %p (%I64x)) %s\n"
            "        Tried to send again after last send!\n",
            pRequest,
            pRequest->RequestId,
            HttpStatusToString(Status)
            ));

        goto end;
    }

    //
    // If this is for a zombie connection and not the last sendresponse
    // then we will reject. Otherwise if the logging data is provided
    // we will only do the logging and bail out.
    //

    Status = UlCheckForZombieConnection(
                pRequest,
                pRequest->pHttpConn,
                Flags,
                pUserLogData,
                RequestorMode
                );

    if (!NT_SUCCESS(Status))
    {
        //
        // It's a zombie connection prevent the slow path by
        // returning the successfull status.
        //

        Status = STATUS_SUCCESS;
        goto end;
    }

    //
    // OK, we have the connection. Now capture the incoming HTTP_RESPONSE
    // structure, map it to our internal format and send the response.
    //

    Status = UlFastSendHttpResponse(
                    pUserResponse,
                    pUserLogData,
                    pEntityChunks,
                    EntityChunkCount,
                    BufferLength,
                    pCacheEntry,
                    Flags,
                    pRequest,
                    NULL,
                    RequestorMode,
                    0,
                    0,
                    &BytesSent
                    );

    if (NT_SUCCESS(Status))
    {
        //
        // Record the number of bytes we have sent successfully.
        //

        pIoStatus->Information = BytesSent;

        //
        // No dereference of the cache entry since the send took the
        // reference in the success case.
        //

        pCacheEntry = NULL;
    }
    else
    {
        CloseConnection = TRUE;
    }

end:

    //
    // Complete the fast I/O.
    //

    if (NT_SUCCESS(Status))
    {
        //
        // If we took the fast path, always return success even if completion
        // routine returns failure later.
        //

        pIoStatus->Status = STATUS_SUCCESS;
        FastIoStatus = TRUE;
    }
    else
    {
        //
        // Close the connection in the failure case.
        //

        if (CloseConnection)
        {
            ASSERT( NULL != pRequest );

            UlCloseConnection(
                pRequest->pHttpConn->pConnection,
                TRUE,
                NULL,
                NULL
                );
        }

        pIoStatus->Status = Status;
        FastIoStatus = FALSE;
    }

    if (pRequest)
    {
        UL_DEREFERENCE_INTERNAL_REQUEST( pRequest );
    }

    if (pCacheEntry)
    {
        UlCheckinUriCacheEntry( pCacheEntry );
    }

    return FastIoStatus;

} // UlSendHttpResponseFastIo


//
// Auto-tuning knobs (constants) to promote fast receives.
//

#define MAX_SKIP_COUNT                  ((LONG) 100)
#define SAMPLING_EVALUATE_PERIOD        ((LONG) 100)
#define NO_SAMPLING_EVALUATE_PERIOD     ((LONG) 5000)
#define SUCCESS_THRESHOLD_PERCENTAGE    ((LONG) 80)

C_ASSERT( SAMPLING_EVALUATE_PERIOD > 0 );
C_ASSERT( NO_SAMPLING_EVALUATE_PERIOD > 0 );
C_ASSERT( SUCCESS_THRESHOLD_PERCENTAGE >= 0 &&
          SUCCESS_THRESHOLD_PERCENTAGE <= 100 );

//
// Auto-tuning run-time metrics.
// Access to these is not synchronized since it's ok if they're sometimes
// off. One set of counters is maintained per-processor to improve
// scalability. Note that local static variables are automatically
// initialized to 0.
//

static LONG     SuccessCount[MAXIMUM_PROCESSORS];
static LONG     AttemptCount[MAXIMUM_PROCESSORS];
static LONG     SkipCount[MAXIMUM_PROCESSORS];
static BOOLEAN  Engaged[MAXIMUM_PROCESSORS];


/***************************************************************************++

Routine Description:

    Yield the processor if the given App Pool is out of queued requests.
    This gives http.sys an opportunity to queue requests before the current
    thread regains the processor, thereby allowing the thread to complete
    a Receive without having to post an IRP.

    An auto-tuning heuristic is used to eliminate the possibility of yielding
    repeatedly without an improvement in the fast I/O rate.

Arguments:

    pAppPool - yield only if this App Pool is out of queued requests
               (assumed to be a valid App Pool)

Return Value:

    None

--***************************************************************************/
__inline
VOID
UlpConditionalYield(
    IN PUL_APP_POOL_OBJECT  pAppPool
    )
{
    LONG    EvaluatePeriod;
    ULONG   CurrentProcessor;

    //
    // No need to yield if a request is ready.
    //

    if (!IsListEmpty(&pAppPool->NewRequestHead))
    {
        return;
    }

    //
    // We'll need to consult the per-processor auto-tuning counters.
    //

    CurrentProcessor = KeGetCurrentProcessorNumber();
    ASSERT( CurrentProcessor < g_UlNumberOfProcessors );

    //
    // Yield if we are not limited to sampling.
    //

    if (Engaged[CurrentProcessor])
    {
        goto yield;
    }

    //
    // Yield during sampling if we have skipped enough opportunities.
    //

    if (SkipCount[CurrentProcessor] >= MAX_SKIP_COUNT)
    {
        SkipCount[CurrentProcessor] = 0;
        goto yield;
    }

    //
    // We are skipping this yield opportunity.
    //

    ++SkipCount[CurrentProcessor];

    return;

yield:

    ZwYieldExecution();
    ++AttemptCount[CurrentProcessor];

    //
    // Record whether the yield helped.
    //

    if (!IsListEmpty(&pAppPool->NewRequestHead))
    {
        ++SuccessCount[CurrentProcessor];
    }

    //
    // Re-evaluate every so often whether to only sample occasionally.
    //

    EvaluatePeriod = Engaged[CurrentProcessor]?
                     NO_SAMPLING_EVALUATE_PERIOD:
                     SAMPLING_EVALUATE_PERIOD;

    if (AttemptCount[CurrentProcessor] >= EvaluatePeriod)
    {
        Engaged[CurrentProcessor] = (BOOLEAN)
            ( ( SuccessCount[CurrentProcessor] * 100 / EvaluatePeriod ) >=
              SUCCESS_THRESHOLD_PERCENTAGE );

        AttemptCount[CurrentProcessor] = 0;
        SuccessCount[CurrentProcessor] = 0;
    }

} // UlpConditionalYield


/***************************************************************************++

Routine Description:

    The fast I/O routine for IOCTL_HTTP_RECEIVE_HTTP_REQUEST.

Arguments:

    pInputBuffer - pointer to the input buffer

    InputBufferLength - the input buffer length

    pOutputBuffer - pointer to the output buffer

    OutputBufferLength - the output buffer length

    IoControlCode - the I/O control code for this IOCTL

    pIoStatus - the IoStatus block

    pDeviceObject - the device object

    RequestorMode - UserMode or KernelMode

Return Value:

    TRUE - fast path taken and success

    FALSE - fast path not taken

--***************************************************************************/
BOOLEAN
UlReceiveHttpRequestFastIo(
    IN PFILE_OBJECT         pFileObject,
    IN PVOID                pInputBuffer,
    IN ULONG                InputBufferLength,
    OUT PVOID               pOutputBuffer,
    IN ULONG                OutputBufferLength,
    OUT PIO_STATUS_BLOCK    pIoStatus,
    IN KPROCESSOR_MODE      RequestorMode
    )
{
    NTSTATUS                Status = STATUS_SUCCESS;
    ULONG                   BytesRead = 0;
    PUL_APP_POOL_PROCESS    pProcess;
    HTTP_REQUEST_ID         RequestId;

    //
    // Sanity check.
    //

    PAGED_CODE();

    __try
    {
        //
        // Ensure this is really an app pool, not a control channel.
        //

        VALIDATE_APP_POOL_FO( pFileObject, pProcess, TRUE );

        if (NULL == pInputBuffer)
        {
            Status = STATUS_INVALID_DEVICE_REQUEST;
            goto end;
        }

        if (NULL != pOutputBuffer &&
            OutputBufferLength >= sizeof(HTTP_REQUEST) &&
            InputBufferLength >= sizeof(HTTP_RECEIVE_REQUEST_INFO))
        {
            PHTTP_RECEIVE_REQUEST_INFO pRequestInfo =
                (PHTTP_RECEIVE_REQUEST_INFO) pInputBuffer;

            UlProbeForRead(
                pRequestInfo,
                sizeof(HTTP_RECEIVE_REQUEST_INFO),
                sizeof(PVOID),
                RequestorMode
                );

            RequestId = pRequestInfo->RequestId;

            if (HTTP_IS_NULL_ID(&RequestId))
            {
                //
                // Improve the probability of a successful fast I/O.
                //

                UlpConditionalYield( pProcess->pAppPool );

                //
                // Bail out fast if the receive is for a new request but
                // the queue is empty.
                //

                if (IsListEmpty(&pProcess->pAppPool->NewRequestHead))
                {
                    Status = STATUS_PIPE_EMPTY;
                    goto end;
                }
            }

            UlProbeForWrite(
                pOutputBuffer,
                OutputBufferLength,
                sizeof(PVOID),
                RequestorMode
                );

            Status = UlpFastReceiveHttpRequest(
                            RequestId,
                            pProcess,
                            pRequestInfo->Flags,
                            pOutputBuffer,
                            OutputBufferLength,
                            &BytesRead
                            );

        }
        else
        {
            Status = STATUS_BUFFER_TOO_SMALL;
        }
    }
    __except( UL_EXCEPTION_FILTER() )
    {
        Status = UL_CONVERT_EXCEPTION_CODE( GetExceptionCode() );
    }

end:

    //
    // Complete the fast I/O.
    //

    if (NT_SUCCESS(Status))
    {
        pIoStatus->Status = STATUS_SUCCESS;
        pIoStatus->Information = BytesRead;
        return TRUE;
    }
    else
    {
        pIoStatus->Status = Status;
        pIoStatus->Information = 0;
        return FALSE;
    }

} // UlReceiveHttpRequestFastIo


/***************************************************************************++

Routine Description:

    The fast I/O routine for IOCTL_READ_FRAGMENT_FROM_CACHE.

Arguments:

    pInputBuffer - pointer to the input buffer

    InputBufferLength - the input buffer length

    pOutputBuffer - pointer to the output buffer

    OutputBufferLength - the output buffer length

    IoControlCode - the I/O control code for this IOCTL

    pIoStatus - the IoStatus block

    pDeviceObject - the device object

    RequestorMode - UserMode or KernelMode

Return Value:

    TRUE - fast path taken and success

    FALSE - fast path not taken

--***************************************************************************/
BOOLEAN
UlReadFragmentFromCacheFastIo(
    IN PFILE_OBJECT         pFileObject,
    IN PVOID                pInputBuffer,
    IN ULONG                InputBufferLength,
    OUT PVOID               pOutputBuffer,
    IN ULONG                OutputBufferLength,
    OUT PIO_STATUS_BLOCK    pIoStatus,
    IN KPROCESSOR_MODE      RequestorMode
    )
{
    NTSTATUS                Status = STATUS_SUCCESS;
    ULONG                   BytesRead = 0;
    PUL_APP_POOL_PROCESS    pProcess;

    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // Ensure this is really an AppPool.
    //

    VALIDATE_APP_POOL_FO( pFileObject, pProcess, TRUE );

    Status = UlReadFragmentFromCache(
                    pProcess,
                    pInputBuffer,
                    InputBufferLength,
                    pOutputBuffer,
                    OutputBufferLength,
                    RequestorMode,
                    &BytesRead
                    );

end:

    //
    // Complete the fast I/O.
    //

    if (NT_SUCCESS(Status))
    {
        pIoStatus->Status = STATUS_SUCCESS;
        pIoStatus->Information = BytesRead;
        return TRUE;
    }
    else
    {
        pIoStatus->Status = Status;
        pIoStatus->Information = 0;
        return FALSE;
    }

} // UlReadFragmentFromCacheFastIo


//
// Private functions.
//

/***************************************************************************++

Routine Description:

    The routine to send the following type of response:

    1. One or zero data chunk is "from fragment cache" and all remaining data
       chunks are "from memory" whose total size is <= 2k.

    2. One "from memory" data chunk whose total size is <= 64k.

Arguments:

    pUserResponse - the HTTP_RESPONSE passed in by the user

    pCapturedUserLogData - the optional log data from the user, it must have
        been captured to kernel buffer already.

    pUserDataChunks - a chain of data chunks that we handle in the fast path

    ChunkCount - number of data chunks to process

    FromMemoryLength - total length of all "from memory" data chunks

    Flags - control flags

    pRequest - the internal request that matches the response

    pUserIrp - the optional IRP from the user if this is response type 2 above

    ConnectionSendBytes - send bytes taken in ConnectionSendLimit if > 0

    GlobalSendBytes - send bytes taken in GlobalSendLimit if > 0

    pBytesSent - pointer to store the total bytes sent on success

Return Value:

    TRUE - fast path taken and success

    FALSE - fast path not taken

--***************************************************************************/
NTSTATUS
UlFastSendHttpResponse(
    IN PHTTP_RESPONSE           pUserResponse OPTIONAL,
    IN PHTTP_LOG_FIELDS_DATA    pCapturedUserLogData OPTIONAL,
    IN PHTTP_DATA_CHUNK         pUserDataChunks,
    IN ULONG                    ChunkCount,
    IN ULONG                    FromMemoryLength,
    IN PUL_URI_CACHE_ENTRY      pCacheEntry,
    IN ULONG                    Flags,
    IN PUL_INTERNAL_REQUEST     pRequest,
    IN PIRP                     pUserIrp OPTIONAL,
    IN KPROCESSOR_MODE          RequestorMode,
    IN ULONGLONG                ConnectionSendBytes,
    IN ULONGLONG                GlobalSendBytes,
    OUT PULONG                  pBytesSent
    )
{
    NTSTATUS                Status;
    PUCHAR                  pResponseBuffer;
    ULONG                   ResponseBufferLength;
    ULONG                   HeaderLength;
    ULONG                   FixedHeaderLength;
    ULONG                   VarHeaderLength;
    ULONG                   TotalResponseSize;
    ULONG                   ContentLengthStringLength;
    ULONG                   ContentLength;
    CHAR                    ContentLengthString[MAX_ULONGLONG_STR];
    PUL_FULL_TRACKER        pTracker = NULL;
    PUL_HTTP_CONNECTION     pHttpConnection = NULL;
    PUL_CONNECTION          pConnection;
    CCHAR                   SendIrpStackSize;
    BOOLEAN                 Disconnect;
    UL_CONN_HDR             ConnHeader;
    LARGE_INTEGER           TimeSent;
    BOOLEAN                 LastResponse;
    PMDL                    pSendMdl;
    ULONG                   i;
    BOOLEAN                 ResumeParsing;
    ULONG                   BufferLength;
    PUCHAR                  pBuffer;
    HTTP_DATA_CHUNK_TYPE    DataChunkType;
    PUCHAR                  pAuxiliaryBuffer;
    PUCHAR                  pEndBuffer;
    BOOLEAN                 GenDateHdr;
    USHORT                  StatusCode = 0;
    PMDL                    pMdlUserBuffer = NULL;

    //
    // Sanity check.
    //

    PAGED_CODE();

    __try
    {
        ASSERT( pUserIrp != NULL || FromMemoryLength <= g_UlMaxCopyThreshold );
        ASSERT( pUserIrp == NULL || FromMemoryLength <= g_UlMaxBytesPerSend );

        //
        // Save and check the pUserResponse->StatusCode.
        //

        if (pUserResponse)
        {
            StatusCode = pUserResponse->StatusCode;

            if (StatusCode > UL_MAX_HTTP_STATUS_CODE ||
                (pUserResponse->Flags & ~HTTP_RESPONSE_FLAG_VALID))
            {
                ExRaiseStatus( STATUS_INVALID_PARAMETER );
            }
        }

        //
        // Allocate a fast tracker to send the response.
        //

        pConnection = pRequest->pHttpConn->pConnection;
        SendIrpStackSize =
            pConnection->ConnectionObject.pDeviceObject->StackSize;
        LastResponse =
            (BOOLEAN) (0 == (Flags & HTTP_SEND_RESPONSE_FLAG_MORE_DATA));

        if (LastResponse && SendIrpStackSize <= DEFAULT_MAX_IRP_STACK_SIZE)
        {
            pTracker = pRequest->pTracker;
        }
        else
        {
            pTracker = UlpAllocateFastTracker( 0, SendIrpStackSize );
        }

        if (pTracker == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto end;
        }

        //
        // Partial initialization of pTracker since UlGenerateFixedHeaders
        // can fail with a real error so we need to properly cleanup.
        //

        pTracker->pLogData = NULL;

        //
        // Try to generate the fixed header within the default fixed header
        // buffer first. If this fails, take the normal path.
        //

        pResponseBuffer = pTracker->pAuxiliaryBuffer;
        ResponseBufferLength = g_UlMaxFixedHeaderSize + g_UlMaxCopyThreshold;

        if (!pUserIrp)
        {
            ResponseBufferLength -= FromMemoryLength;
        }

        //
        // Compute the content length to take into account the cache entry
        // passed in.
        //

        ContentLength = FromMemoryLength;

        if (pCacheEntry)
        {
            ContentLength += pCacheEntry->ContentLength;
        }

        if (pUserResponse != NULL)
        {
            Status = UlGenerateFixedHeaders(
                        pRequest->Version,
                        pUserResponse,
                        StatusCode,
                        ResponseBufferLength,
                        RequestorMode,
                        pResponseBuffer,
                        &FixedHeaderLength
                        );

            if (!NT_SUCCESS(Status))
            {
                //
                // Either the buffer was too small or an exception was thrown.
                //

                if (Status != STATUS_INSUFFICIENT_RESOURCES)
                {
                    goto end;
                }

                if (pTracker->FromRequest == FALSE)
                {
                    if (pTracker->FromLookaside)
                    {
                        UlPplFreeFullTracker( pTracker );
                    }
                    else
                    {
                        UL_FREE_POOL_WITH_SIG(
                                pTracker,
                                UL_FULL_TRACKER_POOL_TAG
                                );
                    }
                }

                //
                // Calculate the fixed header size.
                //

                Status = UlComputeFixedHeaderSize(
                                pRequest->Version,
                                pUserResponse,
                                RequestorMode,
                                &HeaderLength
                                );

                if (NT_SUCCESS(Status) == FALSE)
                {
                    goto end;
                }

                ASSERT( HeaderLength > ResponseBufferLength );

                pTracker = UlpAllocateFastTracker(
                                 HeaderLength,
                                 SendIrpStackSize
                                 );

                if (pTracker == NULL)
                {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    goto end;
                }

                pResponseBuffer = pTracker->pAuxiliaryBuffer;

                Status = UlGenerateFixedHeaders(
                                pRequest->Version,
                                pUserResponse,
                                StatusCode,
                                HeaderLength,
                                RequestorMode,
                                pResponseBuffer,
                                &FixedHeaderLength
                                );

                if (NT_SUCCESS(Status) == FALSE)
                {
                    goto end;
                }

                //
                // Fail the response if we detect user has remapped data.
                //

                if (FixedHeaderLength < HeaderLength)
                {
                    Status = STATUS_INVALID_PARAMETER;
                    goto end;
                }
            }

            pResponseBuffer += FixedHeaderLength;

            pTracker->RequestVerb = pRequest->Verb;
            pTracker->ResponseStatusCode = StatusCode;
        }
        else
        {
            FixedHeaderLength = 0;
        }

        //
        // Take a reference of HTTP connection for the tracker.
        //

        pHttpConnection = pRequest->pHttpConn;

        ASSERT( UL_IS_VALID_HTTP_CONNECTION( pHttpConnection ) );

        UL_REFERENCE_HTTP_CONNECTION( pHttpConnection );

        //
        // Take a reference of the request too because logging needs it.
        //

        UL_REFERENCE_INTERNAL_REQUEST( pRequest );

        //
        // Initialization.
        //

        pTracker->Signature = UL_FULL_TRACKER_POOL_TAG;
        pTracker->pRequest = pRequest;
        pTracker->pHttpConnection = pHttpConnection;
        pTracker->Flags = Flags;
        pTracker->pLogData = NULL;
        pTracker->pUserIrp = pUserIrp;
        pTracker->SendBuffered = FALSE;
        pTracker->pUriEntry = NULL;

        //
        // See if we need to capture user log fields.
        //

        if (pCapturedUserLogData && LastResponse)
        {
            //
            // The pCapturedUserLogData is already probed and captured. However
            // we need to probe the individual log fields (pointers) inside the
            // structure.
            //

            UlProbeLogData(pCapturedUserLogData, RequestorMode);

            //
            // Now we will allocate a kernel pLogData and built and format it
            // from the provided user log fields.
            //

            Status = UlCaptureUserLogData(
                        pCapturedUserLogData,
                        pRequest,
                       &pTracker->pLogData
                        );

            if (!NT_SUCCESS(Status))
            {
                goto end;
            }
        }

        //
        // Should we close the connection?
        //

        if ((Flags & HTTP_SEND_RESPONSE_FLAG_DISCONNECT))
        {
            //
            // Caller is forcing a disconnect.
            //

            Disconnect = TRUE;
        }
        else
        {
            Disconnect = UlCheckDisconnectInfo(pRequest);

            if (LastResponse)
            {
                //
                // No more data is coming, should we disconnect?
                //

                if (Disconnect)
                {
                    pTracker->Flags |= HTTP_SEND_RESPONSE_FLAG_DISCONNECT;
                    Flags = pTracker->Flags;
                }
            }
        }

        //
        // Generate the variable header.
        //

        if (FixedHeaderLength > 0)
        {
            PHTTP_KNOWN_HEADER pKnownHeaders;
            USHORT RawValueLength;
            PCSTR pRawValue;

            //
            // No need to probe pKnownHeaders because it is a built-in array
            // within pUserResponse.
            //

            pKnownHeaders = pUserResponse->Headers.KnownHeaders;

            //
            // If the response explicitly deletes the Connection: header,
            // make sure we DON'T generate it.
            //

            RawValueLength = pKnownHeaders[HttpHeaderConnection].RawValueLength;
            pRawValue = pKnownHeaders[HttpHeaderConnection].pRawValue;

            if (0 == RawValueLength && NULL != pRawValue)
            {
                UlProbeAnsiString(
                    pRawValue,
                    sizeof(ANSI_NULL),
                    RequestorMode
                    );

                if (ANSI_NULL == pRawValue[0])
                {
                    ConnHeader = ConnHdrNone;
                }
                else
                {
                    //
                    // Choose the connection header to send back.
                    //

                    ConnHeader = UlChooseConnectionHeader(
                                    pRequest->Version,
                                    Disconnect
                                    );
                }
            }
            else
            {
                //
                // Choose the connection header to send back.
                //

                ConnHeader = UlChooseConnectionHeader(
                                pRequest->Version,
                                Disconnect
                                );
            }

            //
            // Decide if we need to generate a Date: header.
            //

            RawValueLength = pKnownHeaders[HttpHeaderDate].RawValueLength;
            pRawValue = pKnownHeaders[HttpHeaderDate].pRawValue;

            if (0 == RawValueLength && NULL != pRawValue)
            {
                UlProbeAnsiString(
                    pRawValue,
                    sizeof(ANSI_NULL),
                    RequestorMode
                    );

                if (ANSI_NULL == pRawValue[0])
                {
                    //
                    // Only permit non-generation in the "delete" case.
                    //

                    GenDateHdr = FALSE;
                }
                else
                {
                    GenDateHdr = TRUE;
                }
            }
            else
            {
                GenDateHdr = TRUE;
            }

            //
            // Decide if we need to generate a content-length header.
            //

            if (FALSE == UlpIsLengthSpecified(pKnownHeaders) &&
                FALSE == UlpIsChunkSpecified(pKnownHeaders, RequestorMode) &&
                UlNeedToGenerateContentLength(
                    pRequest->Verb,
                    StatusCode,
                    pTracker->Flags
                    ))
            {
                PCHAR pEnd = UlStrPrintUlong(
                                ContentLengthString,
                                ContentLength,
                                ANSI_NULL
                                );

                ContentLengthStringLength = DIFF(pEnd - ContentLengthString);
            }
            else
            {
                ContentLengthString[0] = ANSI_NULL;
                ContentLengthStringLength = 0;
            }

            //
            // Now generate the variable header.
            //

            UlGenerateVariableHeaders(
                ConnHeader,
                GenDateHdr,
                (PUCHAR) ContentLengthString,
                ContentLengthStringLength,
                pResponseBuffer,
                &VarHeaderLength,
                &TimeSent
                );

            ASSERT( VarHeaderLength <= g_UlMaxVariableHeaderSize );

            pResponseBuffer += VarHeaderLength;
        }
        else
        {
            VarHeaderLength = 0;
        }

        TotalResponseSize = FixedHeaderLength + VarHeaderLength;
        pTracker->pMdlAuxiliary->ByteCount = TotalResponseSize;
        TotalResponseSize += ContentLength;

        //
        // Decide whether we need to resume parsing and how. Ideally
        // if we have seen the last response, we should be able to
        // resume parsing right away after the send but before the
        // send completion. When requests are pipelined, this arrangement
        // alleviates the problem of delayed-ACK of 200ms when an odd numbers
        // of TCP frames are sent.
        //

        if (0 == (pTracker->Flags & HTTP_SEND_RESPONSE_FLAG_MORE_DATA))
        {
            if (pHttpConnection->PipelinedRequests < g_UlMaxPipelinedRequests &&
                0 == pRequest->ContentLength &&
                0 == pRequest->Chunked)
            {
                ResumeParsing = TRUE;
                pTracker->ResumeParsingType = UlResumeParsingOnLastSend;
            }
            else
            {
                ResumeParsing = FALSE;
                pTracker->ResumeParsingType = UlResumeParsingOnSendCompletion;
            }
        }
        else
        {
            ResumeParsing = FALSE;
            pTracker->ResumeParsingType = UlResumeParsingNone;
        }

        //
        // For send with a zero length buffer, no call actually goes
        // to TDI but we still need to check if we need to disconnect
        // and complete the send properly. Special treatment is needed
        // because TCP doesn't like zero length MDLs.
        //

        if (TotalResponseSize == 0)
        {
            ASSERT( NULL == pUserIrp );

            if (IS_DISCONNECT_TIME(pTracker))
            {
                UlDisconnectHttpConnection(
                    pTracker->pHttpConnection,
                    NULL,
                    NULL
                    );
            }

            //
            // Adjust SendsPending and while holding the lock, transfer the
            // ownership of pLogData and ResumeParsing information from
            // pTracker to pRequest.
            //

            UlSetRequestSendsPending(
                pRequest,
                &pTracker->pLogData,
                &pTracker->ResumeParsingType
                );

            //
            // Complete the send inline for logging purpose.
            //

            pTracker->IoStatus.Status = STATUS_SUCCESS;
            pTracker->IoStatus.Information = 0;

            UlpFastSendCompleteWorker( &pTracker->WorkItem );

            if (pBytesSent != NULL)
            {
                *pBytesSent = 0;
            }

            if (ETW_LOG_MIN() && LastResponse)
            {
                UlEtwTraceEvent(
                    &UlTransGuid,
                    ETW_TYPE_ZERO_SEND,
                    (PVOID) &pRequest->RequestIdCopy,
                    sizeof(HTTP_REQUEST_ID),
                    (PVOID) &StatusCode,
                    sizeof(USHORT),
                    NULL,
                    0
                    );
            }

            //
            // Resume parsing inline if we haven't stepped over the limit.
            // No need to take an extra reference on pHttpConnection here
            // since the caller is guaranteed to have 1 reference on pRequest
            // which indirectly holds 1 reference on pHttpConnection.
            //

            if (ResumeParsing)
            {
                UlResumeParsing(
                    pHttpConnection,
                    FALSE,
                    (BOOLEAN) (Flags & HTTP_SEND_RESPONSE_FLAG_DISCONNECT)
                    );
            }

            return STATUS_SUCCESS;
        }

        //
        // If this routine is called from the fast I/O path, copy the content
        // to the auxilary buffer inside the tracker and set up the send MDL.
        // Otherwise, we need to MmProbeAndLock the user buffer into another
        // separate MDL.
        //

        if (pUserIrp == NULL)
        {
            //
            // Start with pMdlAuxilary first; if we hit a cache entry and
            // still have chunks remaining, rebuild pMdlUserBuffer to point
            // to the remaing auxiliary buffer space.
            //

            pSendMdl = pTracker->pMdlAuxiliary;

            pAuxiliaryBuffer = pResponseBuffer;
            pEndBuffer = pAuxiliaryBuffer + FromMemoryLength;

            ASSERT( pAuxiliaryBuffer <= pEndBuffer );

            for (i = 0; i < ChunkCount; i++)
            {
                DataChunkType = pUserDataChunks[i].DataChunkType;

                if (HttpDataChunkFromMemory == DataChunkType)
                {
                    BufferLength = pUserDataChunks[i].FromMemory.BufferLength;
                    pBuffer = (PUCHAR) pUserDataChunks[i].FromMemory.pBuffer;

                    if (BufferLength == 0 ||
                        pBuffer == NULL ||
                        BufferLength > DIFF(pEndBuffer - pAuxiliaryBuffer))
                    {
                        ExRaiseStatus( STATUS_INVALID_PARAMETER );
                    }

                    //
                    // Build a new MDL if the "from fragment" chunk is in the
                    // middle of the data chunks.
                    //

                    if (pSendMdl == pTracker->pMdlContent)
                    {
                        pSendMdl->Next = pTracker->pMdlUserBuffer;
                        pSendMdl = pTracker->pMdlUserBuffer;

                        MmInitializeMdl(
                            pSendMdl,
                            pAuxiliaryBuffer,
                            DIFF(pEndBuffer - pAuxiliaryBuffer)
                            );

                        MmBuildMdlForNonPagedPool( pSendMdl );
                        pSendMdl->ByteCount = 0;
                    }

                    UlProbeForRead(
                        pBuffer,
                        BufferLength,
                        sizeof(CHAR),
                        RequestorMode
                        );

                    RtlCopyMemory( pAuxiliaryBuffer, pBuffer, BufferLength );

                    pAuxiliaryBuffer += BufferLength;
                    pSendMdl->ByteCount += BufferLength;
                }
                else
                {
                    ASSERT( HttpDataChunkFromFragmentCache == DataChunkType );
                    ASSERT( pCacheEntry );
                    ASSERT( pCacheEntry->ContentLength );
                    ASSERT( pSendMdl == pTracker->pMdlAuxiliary );

                    //
                    // Build a partial MDL for the cached content.
                    //

                    pSendMdl->Next = pTracker->pMdlContent;
                    pSendMdl = pTracker->pMdlContent;

                    MmInitializeMdl(
                        pSendMdl,
                        MmGetMdlVirtualAddress(pCacheEntry->pMdl),
                        pCacheEntry->ContentLength
                        );

                    IoBuildPartialMdl(
                        pCacheEntry->pMdl,
                        pSendMdl,
                        MmGetMdlVirtualAddress(pCacheEntry->pMdl),
                        pCacheEntry->ContentLength
                        );
                }

                ASSERT( pAuxiliaryBuffer <= pEndBuffer );
            }

            //
            // End the MDL chain.
            //

            pSendMdl->Next = NULL;
        }
        else
        {
            ASSERT( ChunkCount == 1 );
            ASSERT( NULL == pCacheEntry );

            BufferLength = pUserDataChunks->FromMemory.BufferLength;
            pBuffer = (PUCHAR) pUserDataChunks->FromMemory.pBuffer;
            DataChunkType = pUserDataChunks->DataChunkType;

            ASSERT( DataChunkType == HttpDataChunkFromMemory );
            ASSERT( ContentLength == FromMemoryLength );
            ASSERT( ContentLength == BufferLength );

            if (BufferLength == 0 ||
                pBuffer == NULL ||
                DataChunkType != HttpDataChunkFromMemory ||
                ContentLength > BufferLength)
            {
                ExRaiseStatus( STATUS_INVALID_PARAMETER );
            }

            UlProbeForRead(
                pBuffer,
                ContentLength,
                sizeof(CHAR),
                RequestorMode
                );

            Status = UlInitializeAndLockMdl(
                            pTracker->pMdlUserBuffer,
                            pBuffer,
                            ContentLength,
                            IoReadAccess
                            );

            if (!NT_SUCCESS(Status))
            {
                goto end;
            }

            pMdlUserBuffer = pTracker->pMdlUserBuffer;
            pTracker->pMdlAuxiliary->Next = pTracker->pMdlUserBuffer;
        }
    }
    __except( UL_EXCEPTION_FILTER() )
    {
        Status = UL_CONVERT_EXCEPTION_CODE( GetExceptionCode() );
        goto end;
    }

    //
    // Mark the IRP as pending before the send as we are guaranteed to
    // return pending from this point on.
    //

    if (pUserIrp != NULL)
    {
        IoMarkIrpPending( pUserIrp );

        //
        // Remember ConnectionSendBytes and GlobalSendBytes. These are needed
        // to uncheck send limit when the IRP is completed.
        //

        pTracker->ConnectionSendBytes = ConnectionSendBytes;
        pTracker->GlobalSendBytes = GlobalSendBytes;
    }
    else
    {
        //
        // Remember the send has been buffered (vs a special zero-length send)
        // so we need to unset the timer in the send completion.
        //

        pTracker->SendBuffered = TRUE;
    }

    //
    // Remember we have to dereference the cache entry on send completion.
    // We will not take an extra reference here since the caller won't
    // dereference if this routine returns STATUS_PENDING.
    //

    pTracker->pUriEntry = pCacheEntry;

    //
    // Skip the zero length MDL if created one.
    //

    pSendMdl = pTracker->pMdlAuxiliary;

    if (pSendMdl->ByteCount == 0)
    {
        pSendMdl = pSendMdl->Next;
    }

    ASSERT( pSendMdl != NULL );
    ASSERT( pSendMdl->ByteCount != 0 );

    //
    // Adjust SendsPending and while holding the lock, transfer the
    // ownership of pLogData and ResumeParsing information from
    // pTracker to pRequest.
    //

    UlSetRequestSendsPending(
        pRequest,
        &pTracker->pLogData,
        &pTracker->ResumeParsingType
        );

    UlTrace(SEND_RESPONSE,(
        "UlFastSendHttpResponse: pTracker %p, pRequest %p\n",
        pTracker,
        pRequest
        ));

    //
    // Add to MinBytesPerSecond watch list, since we now know
    // TotalResponseSize.
    //

    UlSetMinBytesPerSecondTimer(
        &pHttpConnection->TimeoutInfo,
        TotalResponseSize
        );

    //
    // Send the response. Notice the logic to disconnect the connection is
    // different from sending back a disconnect header.
    //

    Status = UlSendData(
                pHttpConnection->pConnection,
                pSendMdl,
                TotalResponseSize,
                &UlpRestartFastSendHttpResponse,
                pTracker,
                pTracker->pSendIrp,
                &pTracker->IrpContext,
                (BOOLEAN) IS_DISCONNECT_TIME(pTracker),
                (BOOLEAN) (pTracker->pRequest->ParseState >= ParseDoneState)
                );

    ASSERT( Status == STATUS_PENDING );

    if (pBytesSent != NULL)
    {
        *pBytesSent = TotalResponseSize;
    }

    //
    // If last response has been sent, fire send complete event.
    //

    if (ETW_LOG_MIN() && LastResponse)
    {
        UlEtwTraceEvent(
            &UlTransGuid,
            ETW_TYPE_FAST_SEND,
            (PVOID) &pRequest->RequestIdCopy,
            sizeof(HTTP_REQUEST_ID),
            (PVOID) &StatusCode,
            sizeof(USHORT),
            NULL,
            0
            );
    }

    //
    // Kick the parser right away if told so.
    //

    if (ResumeParsing)
    {
        UlTrace(HTTP_IO, (
            "http!UlFastSendHttpResponse(pHttpConn = %p), "
            "RequestVerb=%d, ResponseStatusCode=%hu\n",
            pHttpConnection,
            pRequest->Verb,
            StatusCode
            ));

        UlResumeParsing(
            pHttpConnection,
            FALSE,
            (BOOLEAN) (Flags & HTTP_SEND_RESPONSE_FLAG_DISCONNECT)
            );
    }

    return STATUS_PENDING;

end:

    //
    // Cleanup.
    //

    if (pTracker)
    {
        if (pMdlUserBuffer)
        {
            MmUnlockPages( pMdlUserBuffer );
        }

        UlpFreeFastTracker( pTracker );

        //
        // Let the references go.
        //

        if (pHttpConnection != NULL)
        {
            UL_DEREFERENCE_HTTP_CONNECTION( pHttpConnection );
            UL_DEREFERENCE_INTERNAL_REQUEST( pRequest );
        }
    }

    return Status;

} // UlFastSendHttpResponse


/***************************************************************************++

Routine Description:

    The completion routine for UlFastSendHttpResponse.

Arguments:

    pCompletionContext - the completion context for the send

    Status - tells the return status for the send

    Information - total bytes that has been sent in the success case

Return Value:

    None

--***************************************************************************/
VOID
UlpRestartFastSendHttpResponse(
    IN PVOID        pCompletionContext,
    IN NTSTATUS     Status,
    IN ULONG_PTR    Information
    )
{
    PUL_FULL_TRACKER    pTracker;

    pTracker = (PUL_FULL_TRACKER) pCompletionContext;

    ASSERT( IS_VALID_FULL_TRACKER( pTracker ) );

    UlTrace(SEND_RESPONSE,(
        "UlpRestartFastSendHttpResponse: pTracker %p, Status %x Information %p\n",
        pTracker,
        Status,
        Information
        ));

    //
    // Set status and bytes transferred fields as returned.
    //

    pTracker->IoStatus.Status = Status;
    pTracker->IoStatus.Information = Information;

    UL_QUEUE_WORK_ITEM(
        &pTracker->WorkItem,
        &UlpFastSendCompleteWorker
        );

} // UlpRestartFastSendHttpResponse


/***************************************************************************++

Routine Description:

    The worker routine for things we can't finish inside
    UlpRestartFastSendHttpResponse.

Arguments:

    pWorkItem - a worker item that contains the UL_FULL_TRACKER.

Return Value:

    None

--***************************************************************************/
VOID
UlpFastSendCompleteWorker(
    IN PUL_WORK_ITEM    pWorkItem
    )
{
    PUL_FULL_TRACKER        pTracker;
    PUL_HTTP_CONNECTION     pHttpConnection;
    PUL_INTERNAL_REQUEST    pRequest;
    BOOLEAN                 ResumeParsing;
    BOOLEAN                 InDisconnect;
    NTSTATUS                Status;
    KIRQL                   OldIrql;
    HTTP_VERB               RequestVerb;
    USHORT                  ResponseStatusCode;
    PIRP                    pIrp;
    PUL_LOG_DATA_BUFFER     pLogData;

    //
    // Sanity check.
    //

    PAGED_CODE();

    pTracker = CONTAINING_RECORD(
                    pWorkItem,
                    UL_FULL_TRACKER,
                    WorkItem
                    );

    ASSERT( IS_VALID_FULL_TRACKER( pTracker ) );
    ASSERT( !pTracker->pLogData );
    ASSERT( pTracker->ResumeParsingType != UlResumeParsingOnSendCompletion );

    Status = pTracker->IoStatus.Status;
    ResumeParsing = FALSE;
    pLogData = NULL;
    InDisconnect = (BOOLEAN)
                   (pTracker->Flags & HTTP_SEND_RESPONSE_FLAG_DISCONNECT);
    RequestVerb = pTracker->RequestVerb;
    ResponseStatusCode = pTracker->ResponseStatusCode;

    pHttpConnection = pTracker->pHttpConnection;
    ASSERT( UL_IS_VALID_HTTP_CONNECTION( pHttpConnection ) );

    pRequest = pTracker->pRequest;
    ASSERT( UL_IS_VALID_INTERNAL_REQUEST( pRequest ) );

    UlTrace(SEND_RESPONSE,(
        "UlpFastSendCompleteWorker: pTracker %p, pRequest %p BytesSent %I64\n",
        pTracker,
        pRequest,
        pRequest->BytesSent
        ));

    if (!NT_SUCCESS(Status))
    {
        //
        // Disconnect if there was an error.
        //

        UlCloseConnection(
            pHttpConnection->pConnection,
            TRUE,
            NULL,
            NULL
            );
    }

    //
    // Update the BytesSent counter and LogStatus in the request.
    //

    UlInterlockedAdd64(
        (PLONGLONG) &pRequest->BytesSent,
        (LONGLONG) pTracker->IoStatus.Information
        );

    if (!NT_SUCCESS(Status) && NT_SUCCESS(pRequest->LogStatus))
    {
        pRequest->LogStatus = Status;
    }

    //
    // Stop MinBytesPerSecond timer and start Connection Idle timer
    //

    UlLockTimeoutInfo(
        &pHttpConnection->TimeoutInfo,
        &OldIrql
        );

    //
    // Turn off MinBytesPerSecond timer if we turned it on.
    //

    if (pTracker->pUserIrp || pTracker->SendBuffered)
    {
        //
        // Non-Zero send, we *should* reset MinBytesPerSecond.
        //

        UlResetConnectionTimer(
            &pHttpConnection->TimeoutInfo,
            TimerMinBytesPerSecond
            );
    }

    if (0 == (pTracker->Flags & HTTP_SEND_RESPONSE_FLAG_MORE_DATA) &&
        pRequest->ParseState >= ParseDoneState)
    {
        //
        // Turn on Idle Timer if there's no more response data AND all of
        // the request data has been received.
        //

        UlSetConnectionTimer(
            &pHttpConnection->TimeoutInfo,
            TimerConnectionIdle
            );
    }

    UlUnlockTimeoutInfo(
        &pHttpConnection->TimeoutInfo,
        OldIrql
        );

    UlEvaluateTimerState(
        &pHttpConnection->TimeoutInfo
        );

    //
    // Complete the orignal user send IRP if set and do this only after
    // we have reset the TimerMinBytesPerSecond.
    //

    pIrp = pTracker->pUserIrp;

    if (pIrp != NULL)
    {
        //
        // Don't forget to unlock the user buffer.
        //

        ASSERT( pTracker->pMdlAuxiliary->Next != NULL );
        ASSERT( pTracker->pMdlAuxiliary->Next == pTracker->pMdlUserBuffer );
        ASSERT( pTracker->ConnectionSendBytes || pTracker->GlobalSendBytes );

        MmUnlockPages( pTracker->pMdlUserBuffer );

        //
        // Uncheck either ConnectionSendBytes or GlobalSendBytes.
        //

        UlUncheckSendLimit(
            pHttpConnection,
            pTracker->ConnectionSendBytes,
            pTracker->GlobalSendBytes
            );

        pIrp->IoStatus = pTracker->IoStatus;
        UlCompleteRequest( pIrp, IO_NO_INCREMENT );
    }

    //
    // Unmap pMdlContent if it has been mapped by lower layer and dereference
    // the cache entry if we have sent a cached response.
    //

    if (pTracker->pUriEntry)
    {
        if (pTracker->pMdlContent->MdlFlags & MDL_MAPPED_TO_SYSTEM_VA)
        {
            MmUnmapLockedPages(
                pTracker->pMdlContent->MappedSystemVa,
                pTracker->pMdlContent
                );
        }

        UlCheckinUriCacheEntry( pTracker->pUriEntry );
    }

    //
    // Adjust SendsPending and if that drops to zero, see if we need to log
    // and resume parsing.
    //

    UlUnsetRequestSendsPending(
        pRequest,
        &pLogData,
        &ResumeParsing
        );

    if (pLogData)
    {
        UlLogHttpResponse( pRequest, pLogData );
    }

    //
    // Unlink the request from process if we are done with all sends.
    //

    ASSERT( pRequest->ConfigInfo.pAppPool );

    if (0 == (pTracker->Flags & HTTP_SEND_RESPONSE_FLAG_MORE_DATA) &&
        0 == pRequest->ContentLength &&
        0 == pRequest->Chunked)
    {
        ASSERT( pRequest->SentLast );

        UlUnlinkRequestFromProcess(
            pRequest->ConfigInfo.pAppPool,
            pRequest
            );
    }

    //
    // Cleanup.
    //

    UlpFreeFastTracker( pTracker );
    UL_DEREFERENCE_INTERNAL_REQUEST( pRequest );

    //
    // Kick the parser on the connection and release our hold.
    //

    if (ResumeParsing && STATUS_SUCCESS == Status)
    {
        UlTrace(HTTP_IO, (
            "http!UlpFastSendCompleteWorker(pHttpConn = %p), "
            "RequestVerb=%d, ResponseStatusCode=%hu\n",
            pHttpConnection,
            RequestVerb,
            ResponseStatusCode
            ));

        UlResumeParsing( pHttpConnection, FALSE, InDisconnect );
    }

    UL_DEREFERENCE_HTTP_CONNECTION( pHttpConnection );

} // UlpFastSendCompleteWorker


/***************************************************************************++

Routine Description:

    The routine to receive an HTTP_REQUEST inline if one is available.

Arguments:

    pRequestId - a request ID to tell us which request to receive

    pProcess - the worker process that is issuing the receive

    pOutputBuffer - pointer to the output buffer to copy the request

    OutputBufferLength - the output buffer length

    pBytesRead - pointer to store total bytes we have copied for the request

Return Value:

    TRUE - fast path taken and success

    FALSE - fast path not taken

--***************************************************************************/
NTSTATUS
UlpFastReceiveHttpRequest(
    IN HTTP_REQUEST_ID      RequestId,
    IN PUL_APP_POOL_PROCESS pProcess,
    IN ULONG                Flags,
    IN PVOID                pOutputBuffer,
    IN ULONG                OutputBufferLength,
    OUT PULONG              pBytesRead
    )
{
    NTSTATUS                Status = STATUS_SUCCESS;
    PUL_INTERNAL_REQUEST    pRequest = NULL;
    KLOCK_QUEUE_HANDLE      LockHandle;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT( IS_VALID_AP_PROCESS(pProcess) );
    ASSERT( IS_VALID_AP_OBJECT(pProcess->pAppPool) );
    ASSERT( pOutputBuffer != NULL);

    if (Flags & (~HTTP_RECEIVE_REQUEST_FLAG_VALID))
    {
        return STATUS_INVALID_PARAMETER;
    }

    UlAcquireInStackQueuedSpinLock(
        &pProcess->pAppPool->SpinLock,
        &LockHandle
        );

    //
    // Make sure we're not cleaning up the process.
    //

    if (!pProcess->InCleanup)
    {
        //
        // Obtain the request based on the request ID. This can be from the
        // NewRequestQueue of the AppPool if the ID is NULL, or directly
        // from the matching opaque ID entry.
        //

        if (HTTP_IS_NULL_ID(&RequestId))
        {
            Status = UlDequeueNewRequest(
                            pProcess,
                            OutputBufferLength,
                            &pRequest
                            );

            ASSERT( NT_SUCCESS( Status ) || NULL == pRequest );
        }
        else
        {
            pRequest = UlGetRequestFromId( RequestId, pProcess );
        }
    }

    //
    // Let go the lock since we have taken a short-lived reference of
    // the request in the success case.
    //

    UlReleaseInStackQueuedSpinLock(
        &pProcess->pAppPool->SpinLock,
        &LockHandle
        );

    //
    // Return immediately if no request is found and let the slow path
    // handle this.
    //

    if (NULL == pRequest)
    {
        return STATUS_CONNECTION_INVALID;
    }

    ASSERT( UL_IS_VALID_INTERNAL_REQUEST( pRequest ) );
    ASSERT( STATUS_SUCCESS == Status );

    //
    // Copy it to the output buffer.
    //

    Status = UlCopyRequestToBuffer(
                pRequest,
                (PUCHAR) pOutputBuffer,
                pOutputBuffer,
                OutputBufferLength,
                Flags,
                FALSE,
                pBytesRead
                );

    if (!NT_SUCCESS(Status) && HTTP_IS_NULL_ID(&RequestId))
    {
        //
        // Either the output buffer is bad or we must have hit a hard error
        // in UlCopyRequestToBuffer. Put the request back to the
        // AppPool's NewRequestQueue so the slow path has a chance to pick up
        // this very same request. This is not neccessary however if the
        // caller came in with a specific request ID since the slow path
        // will have no problems finding this request.
        //

        UlRequeuePendingRequest( pProcess, pRequest );
    }

    //
    // Let go our reference.
    //

    UL_DEREFERENCE_INTERNAL_REQUEST( pRequest );

    return Status;

} // UlpFastReceiveHttpRequest
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\fastio.h ===
/*++

Copyright (c) 2000-2002 Microsoft Corporation

Module Name:

    fastio.h

Abstract:

    This module contains declarations related to fast I/O.

Author:

    Chun Ye (chunye)    09-Dec-2000

Revision History:

--*/


#ifndef _FASTIO_H_
#define _FASTIO_H_


//
// Some useful macroes.
//

__inline
BOOLEAN
UlpIsLengthSpecified(
    IN PHTTP_KNOWN_HEADER pKnownHeaders
    )
{
    return (BOOLEAN)(pKnownHeaders[HttpHeaderContentLength].RawValueLength > 0);

} // UlpIsLengthSpecified


__inline
BOOLEAN
UlpIsChunkSpecified(
    IN PHTTP_KNOWN_HEADER pKnownHeaders,
    IN KPROCESSOR_MODE RequestorMode
    )
{
    USHORT RawValueLength;
    PCSTR pRawValue;

    RawValueLength = pKnownHeaders[HttpHeaderTransferEncoding].RawValueLength;
    pRawValue = pKnownHeaders[HttpHeaderTransferEncoding].pRawValue;

    if (CHUNKED_HDR_LENGTH == RawValueLength)
    {
        UlProbeAnsiString(
            pRawValue,
            CHUNKED_HDR_LENGTH,
            RequestorMode
            );

        if (0 == _strnicmp(pRawValue, CHUNKED_HDR, CHUNKED_HDR_LENGTH))
        {
            return TRUE;
        }
    }

    return FALSE;

} // UlpIsChunkSpecified


//
// Inline functions to allocate/free a fast tracker.
//

__inline
PUL_FULL_TRACKER
UlpAllocateFastTracker(
    IN ULONG FixedHeaderLength,
    IN CCHAR SendIrpStackSize
    )
{
    PUL_FULL_TRACKER pTracker;
    ULONG SpaceLength;
    ULONG MaxFixedHeaderSize;
    USHORT MaxSendIrpSize;
    CCHAR MaxSendIrpStackSize;

    //
    // Sanity check.
    //

    PAGED_CODE();

    if (FixedHeaderLength > g_UlMaxFixedHeaderSize ||
        SendIrpStackSize > DEFAULT_MAX_IRP_STACK_SIZE)
    {
        MaxFixedHeaderSize = MAX(FixedHeaderLength, g_UlMaxFixedHeaderSize);
        MaxSendIrpStackSize = MAX(SendIrpStackSize, DEFAULT_MAX_IRP_STACK_SIZE);
        MaxSendIrpSize = (USHORT)ALIGN_UP(IoSizeOfIrp(MaxSendIrpStackSize), PVOID);

        SpaceLength =
            ALIGN_UP(sizeof(UL_FULL_TRACKER), PVOID) +
                MaxSendIrpSize +
                MaxFixedHeaderSize +
                g_UlMaxVariableHeaderSize +
                g_UlMaxCopyThreshold +
                g_UlFixedHeadersMdlLength +
                g_UlVariableHeadersMdlLength +
                g_UlContentMdlLength;

        pTracker = (PUL_FULL_TRACKER)UL_ALLOCATE_POOL(
                                        NonPagedPool,
                                        SpaceLength,
                                        UL_FULL_TRACKER_POOL_TAG
                                        );

        if (pTracker)
        {
            pTracker->Signature = UL_FULL_TRACKER_POOL_TAG;
            pTracker->pLogData = NULL;
            pTracker->IrpContext.Signature = UL_IRP_CONTEXT_SIGNATURE;
            pTracker->FromLookaside = FALSE;
            pTracker->FromRequest = FALSE;
            pTracker->RequestVerb = HttpVerbInvalid;
            pTracker->ResponseStatusCode = 0;
            pTracker->AuxilaryBufferLength =
                MaxFixedHeaderSize +
                g_UlMaxVariableHeaderSize +
                g_UlMaxCopyThreshold;

            UlInitializeFullTrackerPool( pTracker, MaxSendIrpStackSize );
        }
    }
    else
    {
        pTracker = UlPplAllocateFullTracker();

        if (pTracker)
        {
            pTracker->Signature = UL_FULL_TRACKER_POOL_TAG;
            pTracker->pLogData = NULL;
            pTracker->RequestVerb = HttpVerbInvalid;
            pTracker->ResponseStatusCode = 200; // OK
        }
    }

    return pTracker;

} // UlpAllocateFastTracker


__inline
VOID
UlpFreeFastTracker(
    IN PUL_FULL_TRACKER pTracker
    )
{
    //
    // Sanity check.
    //

    ASSERT( IS_VALID_FULL_TRACKER( pTracker ) );

    if (pTracker->pLogData)
    {
        PAGED_CODE();

        UlDestroyLogDataBuffer( pTracker->pLogData );
    }

    if (pTracker->FromRequest == FALSE)
    {
        if (pTracker->FromLookaside)
        {
            UlPplFreeFullTracker( pTracker );
        }
        else
        {
            UL_FREE_POOL_WITH_SIG( pTracker, UL_FULL_TRACKER_POOL_TAG );
        }
    }

} // UlpFreeFastTracker


//
// Dispatch routines for fast I/O.
//

extern FAST_IO_DISPATCH UlFastIoDispatch;


//
// Fast I/O routines.
//

BOOLEAN
UlFastIoDeviceControl (
    IN PFILE_OBJECT pFileObject,
    IN BOOLEAN Wait,
    IN PVOID pInputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID pOutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN ULONG IoControlCode,
    OUT PIO_STATUS_BLOCK pIoStatus,
    IN PDEVICE_OBJECT pDeviceObject
    );


BOOLEAN
UlSendHttpResponseFastIo(
    IN PFILE_OBJECT pFileObject,
    IN PVOID pInputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID pOutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    OUT PIO_STATUS_BLOCK pIoStatus,
    IN BOOLEAN RawResponse,
    IN KPROCESSOR_MODE RequestorMode
    );

BOOLEAN
UlReceiveHttpRequestFastIo(
    IN PFILE_OBJECT pFileObject,
    IN PVOID pInputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID pOutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    OUT PIO_STATUS_BLOCK pIoStatus,
    IN KPROCESSOR_MODE RequestorMode
    );

BOOLEAN
UlReadFragmentFromCacheFastIo(
    IN PFILE_OBJECT pFileObject,
    IN PVOID pInputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID pOutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    OUT PIO_STATUS_BLOCK pIoStatus,
    IN KPROCESSOR_MODE RequestorMode
    );


//
// Private prototypes.
//

NTSTATUS
UlFastSendHttpResponse(
    IN PHTTP_RESPONSE pUserResponse OPTIONAL,
    IN PHTTP_LOG_FIELDS_DATA pLogData OPTIONAL,
    IN PHTTP_DATA_CHUNK pDataChunk,
    IN ULONG ChunkCount,
    IN ULONG FromMemoryLength,
    IN PUL_URI_CACHE_ENTRY pCacheEntry,
    IN ULONG Flags,
    IN PUL_INTERNAL_REQUEST pRequest,
    IN PIRP pUserIrp OPTIONAL,
    IN KPROCESSOR_MODE RequestorMode,
    IN ULONGLONG ConnectionSendBytes,
    IN ULONGLONG GlobalSendBytes,
    OUT PULONG BytesSent
    );

VOID
UlpRestartFastSendHttpResponse(
    IN PVOID pCompletionContext,
    IN NTSTATUS Status,
    IN ULONG_PTR Information
    );

VOID
UlpFastSendCompleteWorker(
    IN PUL_WORK_ITEM pWorkItem
    );

NTSTATUS
UlpFastReceiveHttpRequest(
    IN HTTP_REQUEST_ID RequestId,
    IN PUL_APP_POOL_PROCESS pProcess,
    IN ULONG Flags,
    IN PVOID pOutputBuffer,
    IN ULONG OutputBufferLength,
    OUT PULONG pBytesRead
    );


#endif  // _FASTIO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\filecache.c ===
/*++

Copyright (c) 1998-2002 Microsoft Corporation

Module Name:

    filecache.c

Abstract:

    This module implements the open file handle cache.

Author:

    Keith Moore (keithmo)       21-Aug-1998

Revision History:

--*/


#include "precomp.h"


//
// Private constants.
//


//
// Private types.
//


//
// Private prototypes.
//

NTSTATUS
UlpRestartReadFileEntry(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIRP             pIrp,
    IN PVOID            pContext
    );

NTSTATUS
UlpRestartReadCompleteFileEntry(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIRP             pIrp,
    IN PVOID            pContext
    );


//
// Private globals.
//

#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, InitializeFileCache )
#pragma alloc_text( PAGE, TerminateFileCache )
#pragma alloc_text( PAGE, UlCreateFileEntry )
#pragma alloc_text( PAGE, UlFailMdlReadDev )
#pragma alloc_text( PAGE, UlFailMdlReadCompleteDev )
#pragma alloc_text( PAGE, UlReadFileEntry )
#pragma alloc_text( PAGE, UlReadFileEntryFast )
#pragma alloc_text( PAGE, UlReadCompleteFileEntry )
#pragma alloc_text( PAGE, UlReadCompleteFileEntryFast )
#endif  // ALLOC_PRAGMA
#if 0
NOT PAGEABLE -- UlpRestartReadFileEntry
NOT PAGEABLE -- UlpRestartReadCompleteFileEntry
#endif


//
// Public functions.
//

/***************************************************************************++

Routine Description:

    Performs global initialization of the open file cache.

Arguments:

    None.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
InitializeFileCache(
    VOID
    )
{
    return STATUS_SUCCESS;  // NYI

}   // InitializeFileCache


/***************************************************************************++

Routine Description:

    Performs global termination of the open file cache.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/
VOID
TerminateFileCache(
    VOID
    )
{

}   // TerminateFileCache


/***************************************************************************++

Routine Description:

    Creates a new file entry for the specified file.

Arguments:

    FileHandle - The file handle.

    pFileCacheEntry - Receives the newly created file cache entry if
        successful.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlCreateFileEntry(
    IN HANDLE                   FileHandle,
    IN OUT PUL_FILE_CACHE_ENTRY pFileCacheEntry
    )
{
    NTSTATUS                    Status;
    PFILE_OBJECT                pFileObject;
    IO_STATUS_BLOCK             IoStatusBlock;
    PFAST_IO_DISPATCH           pFastIoDispatch;
    FILE_STANDARD_INFORMATION   FileInfo;
    FILE_FS_SIZE_INFORMATION    SizeInfo;

    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // Setup locals so we know how to cleanup on exit.
    //

    pFileObject = NULL;

    Status = STATUS_SUCCESS;

    RtlZeroMemory( pFileCacheEntry, sizeof(*pFileCacheEntry) );
    pFileCacheEntry->Signature = UL_FILE_CACHE_ENTRY_SIGNATURE;

    UlTrace(FILE_CACHE, (
        "UlCreateFileEntry: handle %p\n",
        (PVOID) FileHandle
        ));

    //
    // Get a referenced pointer to the file object.
    //

    Status = ObReferenceObjectByHandle(
                FileHandle,                 // Handle
                FILE_READ_ACCESS,           // DesiredAccess
                *IoFileObjectType,          // ObjectType
                UserMode,                   // AccessMode
                (PVOID *) &pFileObject,     // Object
                NULL                        // HandleInformation
                );

    if (NT_SUCCESS(Status) == FALSE)
        goto end;

    pFileCacheEntry->pFileObject = pFileObject;

    //
    // Snag the device object from the file object, then fill in the
    // fast I/O routines. The code here was shamelessly stolen from
    // the NT SMB server.
    //

    pFileCacheEntry->pDeviceObject = IoGetRelatedDeviceObject( pFileObject );

    //
    // Assume no fast I/O, and then query the fast I/O dispath routines.
    //

    pFileCacheEntry->pMdlRead = &UlFailMdlReadDev;
    pFileCacheEntry->pMdlReadComplete = &UlFailMdlReadCompleteDev;

    pFastIoDispatch =
        pFileCacheEntry->pDeviceObject->DriverObject->FastIoDispatch;

    //
    // Query MdlRead.
    //

    if (pFastIoDispatch != NULL &&
        pFastIoDispatch->SizeOfFastIoDispatch >
            FIELD_OFFSET(FAST_IO_DISPATCH, MdlRead) &&
        pFastIoDispatch->MdlRead != NULL)
    {
        //
        // Fill in MdlRead call if the file system's vector is large
        // enough. We still need to check if the routines is specified.
        //

        pFileCacheEntry->pMdlRead = pFastIoDispatch->MdlRead;
    }

    //
    // Query MdlReadComplete.
    //

    if (pFastIoDispatch != NULL &&
        pFastIoDispatch->SizeOfFastIoDispatch >
            FIELD_OFFSET(FAST_IO_DISPATCH, MdlReadComplete) &&
        pFastIoDispatch->MdlReadComplete != NULL)
    {
        //
        // Fill in MdlReadComplete call if the file system's vector is large
        // enough. We still need to check if the routines is specified.
        //

        pFileCacheEntry->pMdlReadComplete = pFastIoDispatch->MdlReadComplete;
    }

    //
    // Get the file size, etc from the file. Note that, since we *may*
    // be running in the context of a user-mode thread, we need to
    // use the Zw form of the API rather than the Nt form.
    //

    if (!pFastIoDispatch ||
        pFastIoDispatch->SizeOfFastIoDispatch <=
            FIELD_OFFSET(FAST_IO_DISPATCH, FastIoQueryStandardInfo) ||
        !pFastIoDispatch->FastIoQueryStandardInfo ||
        !pFastIoDispatch->FastIoQueryStandardInfo(
                            pFileObject,
                            TRUE,
                            &FileInfo,
                            &IoStatusBlock,
                            pFileCacheEntry->pDeviceObject
                            ))
    {
        Status = ZwQueryInformationFile(
                    FileHandle,                 // FileHandle
                    &IoStatusBlock,             // IoStatusBlock,
                    &FileInfo,                  // FileInformation,
                    sizeof(FileInfo),           // Length
                    FileStandardInformation     // FileInformationClass
                    );

        if (NT_SUCCESS(Status) == FALSE)
            goto end;
    }

    pFileCacheEntry->EndOfFile = FileInfo.EndOfFile;

    //
    // Get the file size information for the SectorSize.
    //

    if (!(pFileObject->Flags & FO_CACHE_SUPPORTED))
    {
        if (pFileCacheEntry->pDeviceObject->SectorSize)
        {
            pFileCacheEntry->BytesPerSector =
                pFileCacheEntry->pDeviceObject->SectorSize;
        }
        else
        {
            Status = ZwQueryVolumeInformationFile(
                        FileHandle,
                        &IoStatusBlock,
                        &SizeInfo,
                        sizeof(SizeInfo),
                        FileFsSizeInformation
                        );

            if (NT_SUCCESS(Status) == FALSE)
                goto end;

            pFileCacheEntry->BytesPerSector = SizeInfo.BytesPerSector;
        }
    }

    //
    // Success!
    //

    UlTrace(FILE_CACHE, (
        "UlCreateFileEntry: entry %p, handle %lx [%p]\n",
        pFileCacheEntry,
        FileHandle,
        pFileObject
        ));

end:

    if (NT_SUCCESS(Status) == FALSE)
    {
        //
        // If we made it to this point, then the open has failed.
        //

        UlTrace(FILE_CACHE, (
            "UlCreateFileEntry: handle %p, failure %08lx\n",
            FileHandle,
            Status
            ));

        UlDestroyFileCacheEntry( pFileCacheEntry );
    }

    return Status;

}   // UlCreateFileEntry


/***************************************************************************++

Routine Description:

    Reads data from a file. Does a MDL read for filesystems that support
    MDL reads. If the fs doesn't support MDL reads, this function
    allocates a buffer to hold the data.

Arguments:

    pFileBuffer - Contains all the info about the read, and the data
        once that's been read.

    pIrp - This IRP is used to issue the read.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlReadFileEntry(
    IN OUT PUL_FILE_BUFFER  pFileBuffer,
    IN PIRP                 pIrp
    )
{
    NTSTATUS                Status;
    PIO_STACK_LOCATION      pIrpSp;
    PUL_FILE_CACHE_ENTRY    pFile;
    PUCHAR                  pFileData;
    PMDL                    pMdl;
    ULONG                   ReadLength;
    ULONG                   SectorSize;
    ULONG                   RelativeOffset;
    ULONGLONG               ReadOffset;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT( pFileBuffer );
    ASSERT( IS_FILE_BUFFER_IN_USE( pFileBuffer ) );
    ASSERT( IS_VALID_FILE_CACHE_ENTRY( pFileBuffer->pFileCacheEntry ) );
    ASSERT( IS_VALID_IRP( pIrp ) );

    pFile = pFileBuffer->pFileCacheEntry;

    if (pFile->pFileObject->Flags & FO_CACHE_SUPPORTED)
    {
        UlTrace(FILE_CACHE, (
            "UlReadFileEntry(Buffer = %p, pFile = %p, pIrp = %p) MDL Read\n",
            pFileBuffer,
            pFile,
            pIrp
            ));

        //
        // Caching file system. Do a MDL read.
        //

        pIrpSp = IoGetNextIrpStackLocation( pIrp );
        pIrpSp->MajorFunction = IRP_MJ_READ;
        pIrpSp->MinorFunction = IRP_MN_MDL;
        pIrpSp->FileObject = pFile->pFileObject;
        pIrpSp->DeviceObject = pFile->pDeviceObject;

        //
        // Initialize the IRP.
        //

        pIrp->MdlAddress = NULL;
        pIrp->Tail.Overlay.Thread = UlQueryIrpThread();

        //
        // Indicate to the file system that this operation can be handled
        // synchronously. Basically, this means that the file system can
        // use our thread to fault pages in, etc. This avoids
        // having to context switch to a file system thread.
        //

        pIrp->Flags = IRP_SYNCHRONOUS_API;

        //
        // Set the number of bytes to read and the offset.
        //

        pIrpSp->Parameters.Read.Length = pFileBuffer->Length;
        pIrpSp->Parameters.Read.ByteOffset.QuadPart =
            pFileBuffer->FileOffset.QuadPart;

        ASSERT( pIrpSp->Parameters.Read.Key == 0 );

        //
        // Set up the completion routine.
        //

        IoSetCompletionRoutine(
            pIrp,                       // Irp
            UlpRestartReadFileEntry,    // CompletionRoutine
            pFileBuffer,                // Context
            TRUE,                       // InvokeOnSuccess
            TRUE,                       // InvokeOnError
            TRUE                        // InvokeOnCancel
            );

        //
        // Call the driver. Note that we always set status to
        // STATUS_PENDING, since we set the IRP completion routine
        // to *always* be called.
        //

        UlCallDriver( pFile->pDeviceObject, pIrp );

        Status = STATUS_PENDING;
    }
    else
    {
        UlTrace(FILE_CACHE, (
            "UlReadFileEntry(Buffer = %p, pFile = %p, pIrp = %p) NoCache Read\n",
            pFileBuffer,
            pFile,
            pIrp
            ));

        //
        // Non-caching file system. Allocate a buffer and issue a
        // normal read. The buffer needs to be aligned on the sector
        // size to make the read truely async.
        //

        SectorSize = pFile->BytesPerSector;
        ASSERT( SectorSize > 0 );
        ASSERT( 0 == (SectorSize & (SectorSize - 1)) );

        ReadLength = (pFileBuffer->Length + SectorSize - 1) & ~(SectorSize - 1);

        //
        // Align down the offset as well on SectorSize - this is required
        // for NOCACHE read.
        //

        ReadOffset = pFileBuffer->FileOffset.QuadPart;
        ReadOffset &= ~((ULONGLONG) SectorSize - 1);
        ASSERT( ReadOffset <= pFileBuffer->FileOffset.QuadPart );

        RelativeOffset = pFileBuffer->RelativeOffset =
            (ULONG) (pFileBuffer->FileOffset.QuadPart - ReadOffset);

        //
        // We may have to allocate an extra SectorSize of bytes.
        //

        if ((pFileBuffer->Length + RelativeOffset) > ReadLength)
        {
            ReadLength += SectorSize;
        }

        pFileData = (PUCHAR) UL_ALLOCATE_POOL(
                                NonPagedPool,
                                ReadLength,
                                UL_NONCACHED_FILE_DATA_POOL_TAG
                                );

        if (!pFileData)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto end;
        }

        //
        // Get a MDL for our buffer.
        //

        pMdl = UlAllocateMdl(
                    pFileData,
                    ReadLength,
                    FALSE,
                    FALSE,
                    NULL
                    );

        if (!pMdl)
        {
            UL_FREE_POOL(
                pFileData,
                UL_NONCACHED_FILE_DATA_POOL_TAG
                );

            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto end;
        }

        MmBuildMdlForNonPagedPool( pMdl );

        pFileBuffer->pMdl = pMdl;

        //
        // Remember where the data is.
        //

        pFileBuffer->pFileData = pFileData;

        //
        // Set up the read information.
        //

        pIrpSp = IoGetNextIrpStackLocation( pIrp );
        pIrpSp->MajorFunction = IRP_MJ_READ;
        pIrpSp->MinorFunction = IRP_MN_NORMAL;
        pIrpSp->FileObject = pFile->pFileObject;
        pIrpSp->DeviceObject = pFile->pDeviceObject;

        //
        // Initialize the IRP.
        //

        pIrp->MdlAddress = NULL;
        pIrp->Tail.Overlay.Thread = UlQueryIrpThread();

        //
        // Indicate to the file system that this operation can be handled
        // synchronously. Basically, this means that the file system can
        // use the server's thread to fault pages in, etc. This avoids
        // having to context switch to a file system thread.
        //

        pIrp->Flags = IRP_NOCACHE;

        //
        // Set the number of bytes to read and the offset.
        //

        pIrpSp->Parameters.Read.Length = ReadLength;
        pIrpSp->Parameters.Read.ByteOffset.QuadPart = ReadOffset;

        ASSERT( pIrpSp->Parameters.Read.Key == 0 );

        //
        // If the target device does buffered I/O, load the address of the
        // caller's buffer as the "system buffered I/O buffer". If the
        // target device does direct I/O, load the MDL address. If it does
        // neither, load both the user buffer address and the MDL address.
        // (This is necessary to support file systems, such as HPFS, that
        // sometimes treat the I/O as buffered and sometimes treat it as
        // direct.)
        //

        if (pFileBuffer->pFileCacheEntry->pDeviceObject->Flags & DO_BUFFERED_IO)
        {
            pIrp->AssociatedIrp.SystemBuffer = pFileData;
            pIrp->Flags |= IRP_BUFFERED_IO | IRP_INPUT_OPERATION;

        }
        else
        if (pFileBuffer->pFileCacheEntry->pDeviceObject->Flags & DO_DIRECT_IO)
        {
            pIrp->MdlAddress = pMdl;
        }
        else
        {
            pIrp->UserBuffer = pFileData;
            pIrp->MdlAddress = pMdl;
        }

        //
        // Set up the completion routine.
        //

        IoSetCompletionRoutine(
            pIrp,                       // Irp
            UlpRestartReadFileEntry,    // CompletionRoutine
            pFileBuffer,                // Context
            TRUE,                       // InvokeOnSuccess
            TRUE,                       // InvokeOnError
            TRUE                        // InvokeOnCancel
            );

        //
        // Call the driver. Note that we always set status to
        // STATUS_PENDING, since we set the IRP completion routine
        // to *always* be called.
        //

        UlCallDriver( pFile->pDeviceObject, pIrp );

        Status = STATUS_PENDING;

    }

end:

    return Status;

}   // UlReadFileEntry


/***************************************************************************++

Routine Description:

    Reads data from a file. Does a MDL read for filesystems that support
    MDL reads and Fast I/O. If the FS doesn't support fast i/o and MDL
    reads, the function returns with a failure status.

Arguments:

    pFileBuffer - Contains all the info about the read, and the data
                    once that's been read.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlReadFileEntryFast(
    IN OUT PUL_FILE_BUFFER  pFileBuffer
    )
{
    NTSTATUS                Status;
    IO_STATUS_BLOCK         IoStatus;
    PUL_FILE_CACHE_ENTRY    pFile;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT( pFileBuffer );
    ASSERT( IS_FILE_BUFFER_IN_USE( pFileBuffer ) );
    ASSERT( IS_VALID_FILE_CACHE_ENTRY( pFileBuffer->pFileCacheEntry ) );

    pFile = pFileBuffer->pFileCacheEntry;

    if (pFile->pFileObject->Flags & FO_CACHE_SUPPORTED)
    {
        UlTrace(FILE_CACHE, (
            "UlReadFileEntryFast(Buffer = %p, pFile = %p) MDL Read\n",
            pFileBuffer,
            pFile
            ));

        //
        // Cached filesystem. Try to use the fast path for the MDL read
        // complete.
        //

        if (pFileBuffer->pFileCacheEntry->pMdlRead(
                pFileBuffer->pFileCacheEntry->pFileObject,
                (PLARGE_INTEGER) &pFileBuffer->FileOffset,
                pFileBuffer->Length,
                0,
                &pFileBuffer->pMdl,
                &IoStatus,
                pFileBuffer->pFileCacheEntry->pDeviceObject
                ))
        {
            Status = STATUS_SUCCESS;
        }
        else
        {
            //
            // It didn't work. The caller must now use the IRP path
            // by calling UlReadFileEntry.
            //

            Status = STATUS_UNSUCCESSFUL;
        }
    }
    else
    {
        UlTrace(FILE_CACHE, (
            "UlReadFileEntryFast(Buffer = %p, pFile = %p) NoCache Read\n",
            pFileBuffer,
            pFile
            ));

        //
        // Non-caching file system. No fast i/o. The caller should
        // use the IRP path by calling UlReadFileEntry.
        //

        Status = STATUS_UNSUCCESSFUL;

    }

    return Status;

}   // UlReadFileEntryFast


/***************************************************************************++

Routine Description:

    Frees up resources allocated by UlReadFileEntry (or UlReadFileEntryFast).
    Should be called when the file data read is no longer in use.

Arguments:

    pFileBuffer - Contains all the info about the read, and the data
        that was read.

    pIrp - This IRP is used to issue the read completion.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlReadCompleteFileEntry(
    IN PUL_FILE_BUFFER      pFileBuffer,
    IN PIRP                 pIrp
    )
{
    NTSTATUS                Status;
    PIO_STACK_LOCATION      pIrpSp;
    PUL_FILE_CACHE_ENTRY    pFile;
    UL_STATUS_BLOCK         UlStatus;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT( pFileBuffer );
    ASSERT( IS_FILE_BUFFER_IN_USE( pFileBuffer ) );
    ASSERT( IS_VALID_FILE_CACHE_ENTRY( pFileBuffer->pFileCacheEntry ) );
    ASSERT( IS_VALID_IRP( pIrp ) );

    pFile = pFileBuffer->pFileCacheEntry;

    if (pFile->pFileObject->Flags & FO_CACHE_SUPPORTED)
    {
        UlTrace(FILE_CACHE, (
            "UlReadCompleteFileEntry(Buffer = %p, pFile = %p, pIrp = %p) MDL Read\n",
            pFileBuffer,
            pFile,
            pIrp
            ));

        //
        // Caching file system. Do a MDL read completion.
        //

        pIrpSp = IoGetNextIrpStackLocation( pIrp );
        pIrpSp->MajorFunction = IRP_MJ_READ;
        pIrpSp->MinorFunction = IRP_MN_MDL | IRP_MN_COMPLETE;
        pIrpSp->FileObject = pFile->pFileObject;
        pIrpSp->DeviceObject = pFile->pDeviceObject;

        //
        // Initialize the IRP.
        //

        pIrp->MdlAddress = pFileBuffer->pMdl;
        pIrp->Tail.Overlay.Thread = UlQueryIrpThread();

        pFileBuffer->pMdl = NULL;

        //
        // MDL functions are inherently synchronous.
        //

        pIrp->Flags = IRP_SYNCHRONOUS_API;

        //
        // Set the number of bytes to read and the offset.
        //

        pIrpSp->Parameters.Read.Length = pFileBuffer->Length;
        pIrpSp->Parameters.Read.ByteOffset.QuadPart =
            pFileBuffer->FileOffset.QuadPart;

        ASSERT(pIrpSp->Parameters.Read.Key == 0);

        if (pFileBuffer->pCompletionRoutine)
        {
            //
            // Set up the completion routine. We don't need to do anything
            // on the completion, so we'll just have the I/O manager call
            // our callers routine directly.
            //

            IoSetCompletionRoutine(
                pIrp,                               // Irp
                pFileBuffer->pCompletionRoutine,    // CompletionRoutine
                pFileBuffer->pContext,              // Context
                TRUE,                               // InvokeOnSuccess
                TRUE,                               // InvokeOnError
                TRUE                                // InvokeOnCancel
                );

            //
            // Call the driver. Note that we always set status to
            // STATUS_PENDING, since we set the IRP completion routine
            // to *always* be called.
            //

            UlCallDriver( pFile->pDeviceObject, pIrp );

            Status = STATUS_PENDING;
        }
        else
        {
            //
            // Caller has asked us to perform a synchronous operation by
            // passing in a NULL completion routine. Initialize the UlStatus
            // and wait for it to get signaled after calling UlCallDriver.
            //

            UlInitializeStatusBlock( &UlStatus );

            IoSetCompletionRoutine(
                pIrp,                               // Irp
                UlpRestartReadCompleteFileEntry,    // CompletionRoutine
                &UlStatus,                          // Context
                TRUE,                               // InvokeOnSuccess
                TRUE,                               // InvokeOnError
                TRUE                                // InvokeOnCancel
                );

            Status = UlCallDriver( pFile->pDeviceObject, pIrp );

            if (STATUS_PENDING == Status)
            {
                //
                // Wait for it to finish.
                //

                UlWaitForStatusBlockEvent( &UlStatus );

                //
                // Retrieve the updated status.
                //

                Status = UlStatus.IoStatus.Status;
            }
        }
    }
    else
    {
        UlTrace(FILE_CACHE, (
            "UlReadCompleteFileEntry(Buffer = %p, pFile = %p) NoCache Read\n",
            pFileBuffer,
            pFile
            ));

        //
        // Non-caching file system. We allocated this buffer. Just
        // free it and call the completion routine.
        //

        ASSERT( pFileBuffer->pMdl );

        UlFreeMdl( pFileBuffer->pMdl );
        pFileBuffer->pMdl = NULL;

        ASSERT( pFileBuffer->pFileData );

        UL_FREE_POOL(
            pFileBuffer->pFileData,
            UL_NONCACHED_FILE_DATA_POOL_TAG
            );
        pFileBuffer->pFileData = NULL;

        //
        // Fake the completion here.
        //

        if (pFileBuffer->pCompletionRoutine)
        {
            pFileBuffer->pCompletionRoutine(
                pFileBuffer->pFileCacheEntry->pDeviceObject,
                pIrp,
                pFileBuffer->pContext
                );

            //
            // Return pending, since we called their completion routine.
            //

            Status = STATUS_PENDING;
        }
        else
        {
            Status = STATUS_SUCCESS;
        }
    }

    if (!NT_SUCCESS(Status))
    {
        UlTrace(FILE_CACHE, (
            "UlReadCompleteFileEntry(Buffer = %p, pFile = %p) FAILED! %x\n",
            pFileBuffer,
            pFile,
            Status
            ));
    }

    return Status;

}   // UlReadCompleteFileEntry


/***************************************************************************++

Routine Description:

    Frees up resources allocated by UlReadFileEntry (or UlReadFileEntryFast).
    Should be called when the file data read is no longer in use.

Arguments:

    pFileBuffer - Contains all the info about the read, and the data
        that was read.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlReadCompleteFileEntryFast(
    IN PUL_FILE_BUFFER      pFileBuffer
    )
{
    NTSTATUS                Status;
    PUL_FILE_CACHE_ENTRY    pFile;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT( pFileBuffer );
    ASSERT( IS_FILE_BUFFER_IN_USE( pFileBuffer ) );
    ASSERT( IS_VALID_FILE_CACHE_ENTRY( pFileBuffer->pFileCacheEntry ) );

    pFile = pFileBuffer->pFileCacheEntry;

    if (pFile->pFileObject->Flags & FO_CACHE_SUPPORTED)
    {
        UlTrace(FILE_CACHE, (
            "UlReadCompleteFileEntryFast(Buffer = %p, pFile = %p) MDL Read\n",
            pFileBuffer,
            pFile
            ));

        //
        // Cached filesystem. Try to use the fast path for the MDL read
        // complete.
        //

        if (pFileBuffer->pFileCacheEntry->pMdlReadComplete(
                pFileBuffer->pFileCacheEntry->pFileObject,
                pFileBuffer->pMdl,
                pFileBuffer->pFileCacheEntry->pDeviceObject
                ))
        {
            pFileBuffer->pMdl = NULL;
            Status = STATUS_SUCCESS;
        }
        else
        {
            //
            // It didn't work. The caller must now use the IRP path
            // by calling UlReadCompleteFileEntry.
            //

            Status = STATUS_UNSUCCESSFUL;
        }
    }
    else
    {
        UlTrace(FILE_CACHE, (
            "UlReadCompleteFileEntryFast(Buffer = %p, pFile = %p) NoCache Read\n",
            pFileBuffer,
            pFile
            ));

        //
        // Non-caching file system. We allocated this buffer. Just
        // free it.
        //

        ASSERT( pFileBuffer->pMdl );

        UlFreeMdl( pFileBuffer->pMdl );
        pFileBuffer->pMdl = NULL;

        ASSERT( pFileBuffer->pFileData );

        UL_FREE_POOL(
            pFileBuffer->pFileData,
            UL_NONCACHED_FILE_DATA_POOL_TAG
            );
        pFileBuffer->pFileData = NULL;

        Status = STATUS_SUCCESS;
    }

    return Status;

}   // UlReadCompleteFileEntryFast


/***************************************************************************++

Routine Description:

    Helper function to destroy a file cache entry.

Arguments:

    pWorkItem - Supplies a pointer to the work item queued. This should
        point to the WORK_ITEM structure embedded in a UL_FILE_CACHE_ENTRY.

Return Value:

    None.

--***************************************************************************/
VOID
UlDestroyFileCacheEntry(
    PUL_FILE_CACHE_ENTRY pFileCacheEntry
    )
{
    //
    // Sanity check.
    //

    PAGED_CODE();

    UlTrace(FILE_CACHE, (
        "UlDestroyFileCacheEntry: entry %p\n",
        pFileCacheEntry
        ));

    ASSERT( IS_VALID_FILE_CACHE_ENTRY( pFileCacheEntry ) );

    //
    // Cleanup the file system stuff.
    //

    if (pFileCacheEntry->pFileObject != NULL)
    {
        ObDereferenceObject( pFileCacheEntry->pFileObject );
        pFileCacheEntry->pFileObject = NULL;
    }

    //
    // Now release the entry's resources.
    //

    pFileCacheEntry->Signature = UL_FILE_CACHE_ENTRY_SIGNATURE_X;

}   // UlDestroyFileCacheEntry


/***************************************************************************++

Routine Description:

    Dummy function to fail MDL reads.

Arguments:

    Same as FsRtlMdlReadDev().

Return Value:

    BOOLEAN - Always FALSE (failure).

--***************************************************************************/
BOOLEAN
UlFailMdlReadDev(
    IN PFILE_OBJECT         FileObject,
    IN PLARGE_INTEGER       FileOffset,
    IN ULONG                Length,
    IN ULONG                LockKey,
    OUT PMDL                *MdlChain,
    OUT PIO_STATUS_BLOCK    IoStatus,
    IN PDEVICE_OBJECT       DeviceObject
    )
{
    UNREFERENCED_PARAMETER( FileObject );
    UNREFERENCED_PARAMETER( FileOffset );
    UNREFERENCED_PARAMETER( Length );
    UNREFERENCED_PARAMETER( LockKey );
    UNREFERENCED_PARAMETER( MdlChain );
    UNREFERENCED_PARAMETER( IoStatus );
    UNREFERENCED_PARAMETER( DeviceObject );

    PAGED_CODE();

    return FALSE;

}   // UlFailMdlReadDev


/***************************************************************************++

Routine Description:

    Dummy function to fail MDL read completes.

Arguments:

    Same as FsRtlMdlReadCompleteDev().

Return Value:

    BOOLEAN - Always FALSE (failure).

--***************************************************************************/
BOOLEAN
UlFailMdlReadCompleteDev(
    IN PFILE_OBJECT         FileObject,
    IN PMDL                 MdlChain,
    IN PDEVICE_OBJECT       DeviceObject
    )
{
    UNREFERENCED_PARAMETER( FileObject );
    UNREFERENCED_PARAMETER( MdlChain );
    UNREFERENCED_PARAMETER( DeviceObject );

    PAGED_CODE();

    return FALSE;

}   // UlFailMdlReadCompleteDev


//
// Private functions.
//

/***************************************************************************++

Routine Description:

    Completion routine for UlReadFileEntry. Sets the data fields in
    the UL_FILE_BUFFER and calls the completion routine passed to
    UlReadFileEntry.

Arguments:

    pDeviceObject - the file system device object (not used)

    pIrp - the IRP used to do the read

    pContext - pointer to the UL_FILE_BUFFER

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlpRestartReadFileEntry(
    IN PDEVICE_OBJECT       pDeviceObject,
    IN PIRP                 pIrp,
    IN PVOID                pContext
    )
{
    NTSTATUS                Status;
    PUL_FILE_BUFFER         pFileBuffer = (PUL_FILE_BUFFER)pContext;
    PUL_FILE_CACHE_ENTRY    pFile;
    PUCHAR                  pFileData;
    ULONGLONG               EffetiveLength;

    //
    // Sanity check.
    //

    ASSERT( pFileBuffer );
    ASSERT( IS_FILE_BUFFER_IN_USE( pFileBuffer ) );
    ASSERT( IS_VALID_FILE_CACHE_ENTRY( pFileBuffer->pFileCacheEntry ) );

    pFile = pFileBuffer->pFileCacheEntry;

    if (pFile->pFileObject->Flags & FO_CACHE_SUPPORTED)
    {
        //
        // This was a MDL read.
        //

        if (NT_SUCCESS(pIrp->IoStatus.Status))
        {
            pFileBuffer->pMdl = pIrp->MdlAddress;
        }
    }
    else
    {
        //
        // This was a NoCache Read. pFileBuffer->pMdl
        // was already set by UlReadFileEntry.
        //

        ASSERT( pFileBuffer->pMdl );

        if (NT_SUCCESS(pIrp->IoStatus.Status))
        {
            //
            // Set the byte count of the MDL to the true bytes we asked for
            // and adjust the offset to skip the possible extra bytes we
            // have read.
            //

            EffetiveLength =
                pIrp->IoStatus.Information - pFileBuffer->RelativeOffset;

            //
            // Re-initialize the MDL if we have read at least what we have
            // requested, otherwise, fail the read.
            //

            if (pIrp->IoStatus.Information >= pFileBuffer->RelativeOffset &&
                EffetiveLength >= pFileBuffer->Length)
            {
                pFileData = pFileBuffer->pFileData +
                            pFileBuffer->RelativeOffset;

                MmInitializeMdl(
                    pFileBuffer->pMdl,
                    pFileData,
                    pFileBuffer->Length
                    );

                MmBuildMdlForNonPagedPool( pFileBuffer->pMdl );
                pIrp->IoStatus.Information = pFileBuffer->Length;
            }
            else
            {
                pIrp->IoStatus.Status = STATUS_INFO_LENGTH_MISMATCH;
                pIrp->IoStatus.Information = 0;
            }
        }
    }

    if (pFileBuffer->pCompletionRoutine)
    {
        Status = (pFileBuffer->pCompletionRoutine)(
                        pDeviceObject,
                        pIrp,
                        pFileBuffer->pContext
                        );
    }
    else
    {
        Status = STATUS_MORE_PROCESSING_REQUIRED;
    }

    return Status;

}   // UlpRestartReadFileEntry


/***************************************************************************++

Routine Description:

    Completion routine for UlReadCompleteFileEntry. Simply call
    UlSignalStatusBlock to unblock the waiting thread.

Arguments:

    pDeviceObject - the file system device object (not used)

    pIrp - the IRP used to do the read completion

    pContext - pointer to the UL_STATUS_BLOCK

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlpRestartReadCompleteFileEntry(
    IN PDEVICE_OBJECT       pDeviceObject,
    IN PIRP                 pIrp,
    IN PVOID                pContext
    )
{
    PUL_STATUS_BLOCK        pStatus = (PUL_STATUS_BLOCK) pContext;

    UNREFERENCED_PARAMETER( pDeviceObject );

    //
    // Signal the read completion has been completed.
    //

    UlSignalStatusBlock(
        pStatus,
        pIrp->IoStatus.Status,
        pIrp->IoStatus.Information
        );

    return STATUS_MORE_PROCESSING_REQUIRED;

}   // UlpRestartReadCompleteFileEntry
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\errlog.c ===
/*++

Copyright (c) 2000-2001 Microsoft Corporation

Module Name:

    errlogp.c (HTTP.SYS Generic Error Logging)

Abstract:

    This module implements the generic error logging  
    This functionality is driver wide.

Author:

    Ali E. Turkoglu (aliTu)       24-Jan-2002

Revision History:

    --- 

--*/

#include "precomp.h"
#include "iiscnfg.h"
#include "errlogp.h"

//
// Generic Private globals.
//

UL_ERROR_LOG_FILE_ENTRY g_ErrorLogEntry;

BOOLEAN g_InitErrorLogCalled     = FALSE;
LONG    g_ErrorLoggingEnabled    = 0;


#ifdef ALLOC_PRAGMA

#pragma alloc_text( INIT, UlInitializeErrorLog )
#pragma alloc_text( PAGE, UlpErrorLogBufferTimerHandler  )
#pragma alloc_text( PAGE, UlpCreateErrorLogFile )
#pragma alloc_text( PAGE, UlpFlushErrorLogFile )
#pragma alloc_text( PAGE, UlpDisableErrorLogEntry )
#pragma alloc_text( PAGE, UlpRecycleErrorLogFile )
#pragma alloc_text( PAGE, UlCloseErrorLogEntry )
#pragma alloc_text( PAGE, UlLogHttpError )
#pragma alloc_text( PAGE, UlpAllocErrorLogBuffer )
#pragma alloc_text( PAGE, UlErrorLoggingEnabled )
#pragma alloc_text( PAGE, UlpBuildErrorLogRecord )
#pragma alloc_text( PAGE, UlpWriteToErrorLogFileDebug )
#pragma alloc_text( PAGE, UlpWriteToErrorLogFileShared )
#pragma alloc_text( PAGE, UlpWriteToErrorLogFileExclusive )
#pragma alloc_text( PAGE, UlpWriteToErrorLogFile )

#endif // ALLOC_PRAGMA

#if 0

NOT PAGEABLE -- UlpErrorLogBufferTimerDpcRoutine
NOT PAGEABLE -- UlTerminateErrorLog
NOT PAGEABLE -- UlConfigErrorLogEntry
NOT PAGEABLE -- 

#endif


/***************************************************************************++

  Init the generic error logging entry and its fields.
    
--***************************************************************************/

NTSTATUS
UlInitializeErrorLog (
    VOID
    )
{
    PAGED_CODE();

    ASSERT(!g_InitErrorLogCalled);

    if (!g_InitErrorLogCalled)
    {
        //
        // Init the generic log entry.
        //

        RtlZeroMemory(
            (PCHAR)&g_ErrorLogEntry, sizeof(UL_ERROR_LOG_FILE_ENTRY));
        
        g_ErrorLogEntry.Signature = UL_ERROR_LOG_FILE_ENTRY_POOL_TAG;        

        UlInitializePushLock(
            &g_ErrorLogEntry.PushLock,
            "ErrorLogEntryPushLock",
            0,
            UL_ERROR_LOG_FILE_ENTRY_POOL_TAG
            );

        //
        // Initialize the buffer flush timer.
        //
        
        UlInitializeSpinLock(
            &g_ErrorLogEntry.BufferTimer.SpinLock, 
            "ErrorLogEntryBufferTimerSpinLock" );
        
        KeInitializeDpc(
            &g_ErrorLogEntry.BufferTimer.DpcObject,     // DPC object
            &UlpErrorLogBufferTimerDpcRoutine,          // DPC routine
            NULL                         // context
            );

        KeInitializeTimer(&g_ErrorLogEntry.BufferTimer.Timer);

        g_ErrorLogEntry.BufferTimer.Initialized = TRUE;
        g_ErrorLogEntry.BufferTimer.Started       = FALSE;        
        g_ErrorLogEntry.BufferTimer.Period        = -1;
        g_ErrorLogEntry.BufferTimer.PeriodType    = UlLogTimerPeriodNone;
        
        UlInitializeWorkItem(&g_ErrorLogEntry.WorkItem);
        g_ErrorLogEntry.WorkItemScheduled = FALSE;

        g_InitErrorLogCalled = TRUE;
                    
        UlTrace(ERROR_LOGGING,("Http!UlInitializeErrorLog:"
                " g_ErrorLogEntry @ (%p) Initialized.\n",
                &g_ErrorLogEntry
                ));

        //
        // Since the default config is already built from registry,
        // time to configure the global error log entry.
        //
        
        if (g_UlErrLoggingConfig.Enabled)
        {
            NTSTATUS Status = 
            UlConfigErrorLogEntry(&g_UlErrLoggingConfig);

            UlTrace(ERROR_LOGGING,("Http!UlInitializeErrorLog:"
                    " g_ErrorLogEntry @ (%p) Configured Status %08lx\n",
                    &g_ErrorLogEntry,
                    Status
                    ));

            if (!NT_SUCCESS(Status))
            {
                g_UlErrLoggingConfig.Enabled = FALSE;
                    
                UlWriteEventLogEntry(
                       EVENT_HTTP_LOGGING_ERROR_FILE_CONFIG_FAILED,
                       0,
                       0,
                       NULL,
                       sizeof(NTSTATUS),
                       (PVOID) &Status
                       );
            }
        }            
    }
        
    return STATUS_SUCCESS;
}

/***************************************************************************++

    Terminates the error logging entry and its timer.
    
--***************************************************************************/

VOID
UlTerminateErrorLog(
    VOID
    )
{
    KIRQL OldIrql;    

    if (g_InitErrorLogCalled)
    {
        PUL_LOG_TIMER pBufferTimer = &g_ErrorLogEntry.BufferTimer;

        //
        // Terminate the buffer timer 
        //
        
        UlAcquireSpinLock(&pBufferTimer->SpinLock, &OldIrql);

        pBufferTimer->Initialized = FALSE;

        KeCancelTimer(&pBufferTimer->Timer);
        
        UlReleaseSpinLock(&pBufferTimer->SpinLock, OldIrql);

        //
        // Try to cleanup the error log entry in case it has been configured
        // before. Even if not, following call is not dangerous.
        //

        UlCloseErrorLogEntry();
        
        //
        // Delete the push lock
        //
        
        UlDeletePushLock(&g_ErrorLogEntry.PushLock);
        
        g_InitErrorLogCalled = FALSE;
    }
}

/***************************************************************************++

Routine Description:

    Queues a passive worker for the lowered irql.

Arguments:

    Ignored

--***************************************************************************/

VOID
UlpErrorLogBufferTimerDpcRoutine(
    PKDPC Dpc,
    PVOID DeferredContext,
    PVOID SystemArgument1,
    PVOID SystemArgument2
    )
{
    PUL_LOG_TIMER pTimer     = &g_ErrorLogEntry.BufferTimer;
    PUL_WORK_ITEM pWorkItem = &g_ErrorLogEntry.WorkItem;;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(DeferredContext);
    UNREFERENCED_PARAMETER(SystemArgument1);
    UNREFERENCED_PARAMETER(SystemArgument2);

    UlAcquireSpinLockAtDpcLevel(&pTimer->SpinLock);

    if (pTimer->Initialized == TRUE)
    {
        //
        // Protect against multiple queueing with the same item.
        // If threadpool is busy this could happen under stress.
        // In this case drop this flush.
        //

        if (FALSE == InterlockedExchange(
                           &g_ErrorLogEntry.WorkItemScheduled,
                            TRUE
                            ))
        {
            UL_QUEUE_WORK_ITEM(pWorkItem, &UlpErrorLogBufferTimerHandler);        
        }
    }

    UlReleaseSpinLockFromDpcLevel(&pTimer->SpinLock);   
}

/***************************************************************************++

Routine Description:

    Flushes or recycles the error log file.

Arguments:

    PUL_WORK_ITEM - Ignored but cleaned up at the end

--***************************************************************************/

VOID
UlpErrorLogBufferTimerHandler(
    IN PUL_WORK_ITEM pWorkItem
    )
{
    NTSTATUS Status;
    PUL_ERROR_LOG_FILE_ENTRY pEntry = &g_ErrorLogEntry;

    UNREFERENCED_PARAMETER(pWorkItem);

    PAGED_CODE();

    UlTrace(ERROR_LOGGING,
       ("Http!UlpErrorLogBufferTimerHandler: Checking the ErrorLogEntry. \n"));

    InterlockedExchange( 
        &g_ErrorLogEntry.WorkItemScheduled, 
        FALSE 
        );

    UlAcquirePushLockExclusive(&pEntry->PushLock);
    
    if (pEntry->Flags.Active)
    {    
        if (pEntry->Flags.RecyclePending)
        {                
            //
            // Try to resurrect it back.
            //
            
            Status = UlpRecycleErrorLogFile(pEntry);
        }
        else
        {
            //
            // Everything is fine simply flush.
            //
            
            Status = UlpFlushErrorLogFile(pEntry);
        }            
    }

    UlReleasePushLockExclusive(&pEntry->PushLock);
}

/***************************************************************************++

Routine Description:

    Small utility to check whether error logging is disabled or not.

Returns

    TRUE if enabled FALSE otherwise.
    
--***************************************************************************/

BOOLEAN
UlErrorLoggingEnabled(
    VOID
    )
{        
    if (g_ErrorLoggingEnabled && g_InitErrorLogCalled)
    {                
        ASSERT(IS_VALID_ERROR_LOG_FILE_ENTRY(&g_ErrorLogEntry));
        
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

/***************************************************************************++

Routine Description:

    Builds the error logging directory.
    
Arguments:

    pSrc - Source string copied first.
    pDir - Source string + SubDir + UnicodeNull

--***************************************************************************/

NTSTATUS
UlBuildErrorLoggingDirStr(
    IN  PCWSTR          pSrc,
    OUT PUNICODE_STRING pDir
    )
{
    NTSTATUS Status;
    UNICODE_STRING DirStr,SubDirStr;

    //
    // Lets make sure the unicode string's buffer is sufficient.
    //
    
    ASSERT(pDir->MaximumLength
                >= ((  wcslen(pSrc)
                     + UL_ERROR_LOG_SUB_DIR_LENGTH    // SubDir
                     + 1                              // UnicodeNull
                     ) * sizeof(WCHAR))
                );

    //
    // Copy the beginning portion from the source string.
    //

    Status = UlInitUnicodeStringEx(&DirStr, pSrc);
    if (!NT_SUCCESS(Status)) 
    {
        return Status;
    }

    RtlCopyUnicodeString(pDir, &DirStr);

    //
    // Append the sub directory. AppendUnicodeString will null terminate.
    //

    Status = UlInitUnicodeStringEx(&SubDirStr, UL_ERROR_LOG_SUB_DIR);
    ASSERT(NT_SUCCESS(Status));

    Status = RtlAppendUnicodeStringToString(pDir, &SubDirStr);
    if (!NT_SUCCESS(Status)) 
    {
        return Status;
    }

    ASSERT(IS_WELL_FORMED_UNICODE_STRING(pDir));

    return Status;
}

/***************************************************************************++

Routine Description:

    When Error Log File Configuration is provided by registry
    this function provides the basic sanity check on the values.
    
Arguments:
                   
    pUserConfig  - Error Logging config from the registry.

--***************************************************************************/

NTSTATUS
UlCheckErrorLogConfig(
    IN PHTTP_ERROR_LOGGING_CONFIG  pUserConfig
    )
{
    NTSTATUS Status;
    
    //
    // Sanity check.
    //
    
    PAGED_CODE();

    ASSERT(pUserConfig);

    Status = STATUS_SUCCESS;
    
    //
    // Cook the directory if it is enabled.
    //
    
    if (pUserConfig->Enabled)
    {            
        ASSERT(pUserConfig->Dir.Buffer);
        ASSERT(pUserConfig->Dir.Length);

        //
        // Following check must have already been done by the registry code
        // in init.c.
        //

        ASSERT(pUserConfig->TruncateSize 
                          >= DEFAULT_MIN_ERROR_FILE_TRUNCATION_SIZE
                          );
        
        //
        // Directory should be fully qualified.
        //

        if (!UlIsValidLogDirectory(
                &pUserConfig->Dir,
                 FALSE,            // UncSupport
                 TRUE              // SystemRootSupport
                 ))
        {
            Status = STATUS_NOT_SUPPORTED;
        }
   }
    
   if (!NT_SUCCESS(Status))
   {
        UlWriteEventLogEntry(
               EVENT_HTTP_LOGGING_ERROR_FILE_CONFIG_FAILED,
               0,
               0,
               NULL,
               sizeof(NTSTATUS),
               (PVOID) &Status
               );
   
        UlTrace(ERROR_LOGGING,
          ("Http!UlCheckErrorLogDir: failed for : (%S)\n",
            pUserConfig->Dir.Buffer
            ));   
   }
   
   return Status;
}

/***************************************************************************++

Routine Description:

    When logging configuration happens we init the entry but do not create the
    error log file itself yet. That will be created when the first request 
    comes in.
    
Arguments:
                   
    pUserConfig  - Error Logging config from the registry.

--***************************************************************************/

NTSTATUS
UlConfigErrorLogEntry(
    IN PHTTP_ERROR_LOGGING_CONFIG  pUserConfig
    )
{
    KIRQL OldIrql;
    PUL_ERROR_LOG_FILE_ENTRY pEntry = &g_ErrorLogEntry;
        
    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // If disabled do not proceed.
    //

    if (pUserConfig->Enabled == FALSE)
    {
        InterlockedExchange(&g_ErrorLoggingEnabled, 0);

        UlTrace(ERROR_LOGGING,
               ("Http!UlConfigErrorLogEntry: Error Logging Disabled !\n",
                 pEntry
                 ));
        
        return STATUS_SUCCESS;
    }
    
    //
    // Registry reader shouldn't accept an improper config in the
    // first place.
    //

    ASSERT(NT_SUCCESS(UlCheckErrorLogConfig(pUserConfig)));
    
    //
    // Acquire the entry lock and resurrect the entry.
    //
    
    UlAcquirePushLockExclusive(&pEntry->PushLock);

    //
    // Remember the logging directory in the entry for the time
    // being. Also allocate sufficient space to hold the max
    // possible file name plus the existing directory string.
    // So that logutil doesn't need to realloc this buffer again.
    //

    pEntry->FileName.Buffer =
            (PWSTR) UL_ALLOCATE_ARRAY(
                PagedPool,
                UCHAR,
                pUserConfig->Dir.MaximumLength
                + ERROR_LOG_MAX_FULL_FILE_NAME_SIZE,
                UL_CG_LOGDIR_POOL_TAG
                );
    if (pEntry->FileName.Buffer == NULL)
    {
        UlReleasePushLockExclusive(&pEntry->PushLock);
        
        return STATUS_NO_MEMORY;
    }

    pEntry->FileName.Length = 
                pUserConfig->Dir.Length;
    
    pEntry->FileName.MaximumLength = 
                pUserConfig->Dir.MaximumLength 
                + ERROR_LOG_MAX_FULL_FILE_NAME_SIZE;
    
    RtlCopyMemory(
        pEntry->FileName.Buffer ,
        pUserConfig->Dir.Buffer,
        pUserConfig->Dir.MaximumLength
        );

    //
    // Now set the fields on the binary log entry accordingly.
    //

    pEntry->TruncateSize   = pUserConfig->TruncateSize;
    pEntry->SequenceNumber = 1;
    
    pEntry->TotalWritten.QuadPart = (ULONGLONG) 0;

    //
    // Start the buffer flush timer as soon as the configuration
    // happens.
    //
    
    UlAcquireSpinLock(&pEntry->BufferTimer.SpinLock, &OldIrql);
    if (pEntry->BufferTimer.Started == FALSE)
    {
        UlSetBufferTimer(&pEntry->BufferTimer);
        pEntry->BufferTimer.Started = TRUE;
    }
    UlReleaseSpinLock(&pEntry->BufferTimer.SpinLock, OldIrql);

    UlTrace(ERROR_LOGGING,
           ("Http!UlConfigErrorLogEntry: pEntry %p for %S\n",
             pEntry,
             pUserConfig->Dir.Buffer
             ));
    
    UlReleasePushLockExclusive(&pEntry->PushLock);

    //
    // Mark it as enabled.
    //
    
    InterlockedExchange(&g_ErrorLoggingEnabled, 1);

    return STATUS_SUCCESS;
}

/***************************************************************************++

Routine Description:

    Create a new error log file or open an existing one. The fully qualified
    file name should be in the error log entry.
    
Arguments:

    pEntry : Corresponding entry that we are closing and opening 
             the error log files for.
              
--***************************************************************************/

NTSTATUS
UlpCreateErrorLogFile(
    IN OUT PUL_ERROR_LOG_FILE_ENTRY pEntry
    )
{
    NTSTATUS Status;
    PUNICODE_STRING pDir;    
        
    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(IS_VALID_ERROR_LOG_FILE_ENTRY(pEntry));

    pDir = &g_UlErrLoggingConfig.Dir;
        
    //
    // Build the fully qualified error log file name.
    //
    
    Status = UlRefreshFileName(pDir, 
                                 &pEntry->FileName,
                                 &pEntry->pShortName
                                 );
    if (!NT_SUCCESS(Status))
    {
        return Status;  
    }

    //
    // SequenceNumber is stale because we have to scan the existing 
    // directory the first time we open a file.
    //
    
    pEntry->Flags.StaleSequenceNumber = 1;    

    //
    // After that Recycle does the whole job for us.
    //
    
    Status = UlpRecycleErrorLogFile(pEntry);

    if (!NT_SUCCESS(Status))
    {        
        UlTrace(ERROR_LOGGING,
               ("Http!UlpCreateErrorLogFile: Filename: %S Failure %08lx\n",
                pEntry->FileName.Buffer,
                Status
                ));
    }

    UlTrace(ERROR_LOGGING,
            ("Http!UlpCreateErrorLogFile: pEntry %p for %S to %S\n", 
              pEntry,
              pDir->Buffer,
              pEntry->FileName.Buffer
              ));

    return Status;
}

/***************************************************************************++

Routine Description:

    Simple wrapper function around the global buffer flush routine.
    
Arguments:

    pEntry - Error Log file entry

--***************************************************************************/

NTSTATUS
UlpFlushErrorLogFile(
    IN PUL_ERROR_LOG_FILE_ENTRY  pEntry
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    
    ASSERT(IS_VALID_ERROR_LOG_FILE_ENTRY(pEntry));

    if (NULL != pEntry->LogBuffer  && 0 != pEntry->LogBuffer->BufferUsed)
    {
        Status = UlFlushLogFileBuffer(
                   &pEntry->LogBuffer,
                    pEntry->pLogFile,
                    FALSE,
                   &pEntry->TotalWritten.QuadPart                    
                    );

        if (!NT_SUCCESS(Status))
        {
            if (!pEntry->Flags.WriteFailureLogged)
            {
                NTSTATUS TempStatus;
                
                TempStatus = 
                    UlWriteEventLogEntry(
                          (NTSTATUS)EVENT_HTTP_LOGGING_ERROR_FILE_WRITE_FAILED,
                           0,
                           0,
                           NULL,
                           sizeof(NTSTATUS),
                           (PVOID) &Status
                           );

                ASSERT(TempStatus != STATUS_BUFFER_OVERFLOW);
                    
                if (TempStatus == STATUS_SUCCESS)
                {            
                    pEntry->Flags.WriteFailureLogged = 1;
                }
            }
        }
        else
        {
            //
            // If we have successfully flushed some data. 
            // Reset the event log indication.
            //
            
            pEntry->Flags.WriteFailureLogged = 0;
        }        
    }
    
    return Status;
}

/***************************************************************************++

Routine Description:

    Marks the entry inactive, closes the existing file.
    Caller should hold the error log entry pushlock exclusive.
    
Arguments:

    pEntry - The log file entry which we will mark inactive.

--***************************************************************************/

NTSTATUS
UlpDisableErrorLogEntry(
    IN OUT PUL_ERROR_LOG_FILE_ENTRY pEntry
    )
{
    //
    // Sanity checks
    //
    
    PAGED_CODE();

    ASSERT(IS_VALID_ERROR_LOG_FILE_ENTRY(pEntry));

    UlTrace(ERROR_LOGGING,
        ("Http!UlpDisableErrorLogEntry: pEntry %p disabled.\n",
          pEntry
          ));    
    
    //
    // Flush and close the old file until the next recycle.
    //

    if (pEntry->pLogFile)
    {    
        UlpFlushErrorLogFile(pEntry);
    
        UlCloseLogFile(
            &pEntry->pLogFile
            );
    }

    //
    // Mark this inactive so that the next http hit awakens the entry.
    //
    
    pEntry->Flags.Active = 0;

    return STATUS_SUCCESS;    
}

/***************************************************************************++

Routine Description:

    Small wrapper around handle recycle to ensure it happens under the system
    process context. 

Arguments:

    pEntry  - Points to error log file entry to be recycled.

--***************************************************************************/

NTSTATUS
UlpRecycleErrorLogFile(
    IN OUT PUL_ERROR_LOG_FILE_ENTRY pEntry
    )
{
    NTSTATUS Status;

    PAGED_CODE();

    ASSERT(IS_VALID_ERROR_LOG_FILE_ENTRY(pEntry));
    
    Status = UlQueueLoggingRoutine(
                (PVOID) pEntry,
                &UlpHandleErrorLogFileRecycle
                );
    
    return Status;
}

/***************************************************************************++

Routine Description:

    This function requires to have the entry resource to be acquired.

    Sometimes it may be necessary to scan the new directory to figure out
    the correct sequence number and the file name. Especially after a dir
    name reconfig.

Arguments:

    pEntry  - Points to the error log file entry

--***************************************************************************/

NTSTATUS
UlpHandleErrorLogFileRecycle(
    IN OUT PVOID             pContext
    )    
{
    NTSTATUS                 Status;
    PUL_ERROR_LOG_FILE_ENTRY pEntry;
    TIME_FIELDS              TimeFields;
    LARGE_INTEGER            TimeStamp;
    PUL_LOG_FILE_HANDLE      pLogFile;
    WCHAR                    _FileName[UL_MAX_FILE_NAME_SUFFIX_LENGTH + 1];
    UNICODE_STRING           FileName;
    BOOLEAN                  UncShare;
    BOOLEAN                  ACLSupport;

    //
    // Sanity check.
    //

    PAGED_CODE();

    pEntry = (PUL_ERROR_LOG_FILE_ENTRY) pContext;
    ASSERT(IS_VALID_ERROR_LOG_FILE_ENTRY(pEntry));

    Status   = STATUS_SUCCESS;    
    pLogFile = NULL;

    FileName.Buffer        = _FileName;
    FileName.Length        = 0;
    FileName.MaximumLength = sizeof(_FileName);
    
    ASSERT(pEntry->FileName.Length !=0 );

    UlTrace(ERROR_LOGGING, 
        ("Http!UlpHandleErrorLogFileRecycle: pEntry %p \n", pEntry ));

    //
    // This value is computed for the GMT time zone.
    //

    KeQuerySystemTime(&TimeStamp);
    RtlTimeToTimeFields(&TimeStamp, &TimeFields);

    //
    // If we need to scan the directory. Sequence number should start
    // from 1 again. Set this before constructing the log file name.
    //
    
    if (pEntry->Flags.StaleSequenceNumber)
    {
        //
        // Init otherwise if QueryDirectory doesn't find any files
        // in the provided directory, this will not get properly 
        // initialized.
        //
        pEntry->SequenceNumber = 1;
    }

    //
    // Use binary logging settings when constructing the filename.
    //

    UlConstructFileName(
        HttpLoggingPeriodMaxSize,
        ERROR_LOG_FILE_NAME_PREFIX,
        ERROR_LOG_FILE_NAME_EXTENSION,
        &FileName,
        &TimeFields,
        FALSE,
        &pEntry->SequenceNumber
        );

    if (pEntry->FileName.MaximumLength <= FileName.Length)
    {
        ASSERT(!"FileName buffer is not sufficient.");
        Status = STATUS_INVALID_PARAMETER;
        goto end;
    }

    //
    // Do the magic and renew the filename. Replace the old file
    // name with the new one.
    //

    ASSERT(pEntry->pShortName != NULL);
    
    //
    // Get rid of the old filename before scanning the
    // directories.
    //

    *((PWCHAR)pEntry->pShortName) = UNICODE_NULL;
    pEntry->FileName.Length =
        (USHORT) wcslen( pEntry->FileName.Buffer ) * sizeof(WCHAR);

    //
    // Create/Open the director(ies) first. This might be
    // necessary if we get called after an entry reconfiguration
    // and directory name change or for the first time we 
    // try to create/open the log file.
    //

    Status = UlCreateSafeDirectory(&pEntry->FileName, 
                                      &UncShare, 
                                      &ACLSupport
                                      );
    if (!NT_SUCCESS(Status))
        goto eventlog;

    ASSERT(FALSE == UncShare);
    
    //
    // Now Restore the short file name pointer back
    //

    pEntry->pShortName = (PWSTR)
        &(pEntry->FileName.Buffer[pEntry->FileName.Length/sizeof(WCHAR)]);

    //
    // Append the new file name ( based on the updated current time )
    // to the end.
    //

    Status = RtlAppendUnicodeStringToString(&pEntry->FileName, &FileName);
    if (!NT_SUCCESS(Status))
        goto end;

    //
    // Time to close the old file and reopen a new one
    //

    if (pEntry->pLogFile != NULL)
    {
        //
        // Flush,close and mark the entry inactive.
        //

        UlpDisableErrorLogEntry(pEntry);        
    }

    ASSERT(pEntry->pLogFile == NULL);

    //
    // If the sequence is stale because of the nature of the recycle.
    // And if our period is size based then rescan the new directory
    // to figure out the proper file to open.
    // 

    pEntry->TotalWritten.QuadPart = (ULONGLONG) 0;

    if (pEntry->Flags.StaleSequenceNumber)
    {
        // This call may update the filename, the file size and the
        // sequence number if there is an old file in the new dir.

        Status = UlQueryDirectory(
                   &pEntry->FileName,
                    pEntry->pShortName,
                    ERROR_LOG_FILE_NAME_PREFIX,
                    ERROR_LOG_FILE_NAME_EXTENSION_PLUS_DOT,
                   &pEntry->SequenceNumber,
                   &pEntry->TotalWritten.QuadPart
                    );
        if (!NT_SUCCESS(Status))
        {
            if (Status == STATUS_ACCESS_DENIED)
            {
                Status = STATUS_INVALID_OWNER;
                goto eventlog;
            }
            else
            {
                goto end;
            }
        }
    }

    //
    // Allocate a new log file structure for the new log file we are
    // about to open or create.
    //
    
    pLogFile = pEntry->pLogFile = 
        UL_ALLOCATE_STRUCT(
                NonPagedPool,
                UL_LOG_FILE_HANDLE,
                UL_LOG_FILE_HANDLE_POOL_TAG
                );
    if (pLogFile == NULL)
    {
        Status = STATUS_NO_MEMORY;
        goto end;
    }

    pLogFile->Signature = UL_LOG_FILE_HANDLE_POOL_TAG;
    pLogFile->hFile = NULL;
    UlInitializeWorkItem(&pLogFile->WorkItem);

    //
    // Create the new log file.
    //
    
    Status = UlCreateLogFile(&pEntry->FileName,
                               UncShare,
                               ACLSupport,
                               &pLogFile->hFile
                               );    
    if (!NT_SUCCESS(Status))
    {
        goto eventlog;
    }

    ASSERT(pLogFile->hFile);        
    pEntry->TotalWritten.QuadPart = UlGetLogFileLength(pLogFile->hFile);

    //
    // File is successfully opened and the entry is no longer inactive.
    // Update our state flags accordingly.
    //

    pEntry->Flags.Active = 1;
    pEntry->Flags.RecyclePending = 0;    
    pEntry->Flags.StaleSequenceNumber = 0;
    pEntry->Flags.CreateFileFailureLogged = 0;
                
    UlTrace(ERROR_LOGGING,  
             ("Http!UlpHandleErrorLogFileRecycle: entry %p, file %S, handle %lx\n",
               pEntry,
               pEntry->FileName.Buffer,
               pLogFile->hFile
               ));
    
eventlog:    

    if (!NT_SUCCESS(Status))
    {
        if (!pEntry->Flags.CreateFileFailureLogged)
        {
            NTSTATUS TempStatus;

            TempStatus = UlEventLogCreateFailure(
                            Status,
                            UlEventLogError,
                           &pEntry->FileName,
                            0
                            );
                        
            if (TempStatus == STATUS_SUCCESS)
            {
                //
                // Avoid filling up the event log with error entries.
                // This code path might get hit every time a request 
                // arrives.
                //
                
                pEntry->Flags.CreateFileFailureLogged = 1;
            }            
            
            UlTrace(ERROR_LOGGING,(
                    "Http!UlpHandleErrorLogFileRecycle: Event Logging Status %08lx\n",
                    TempStatus
                    ));   
       }
   }
    
end:
    if (!NT_SUCCESS(Status))
    {
        UlTrace(ERROR_LOGGING, 
            ("Http!UlpHandleErrorLogFileRecycle: entry %p, failure %08lx\n",
              pEntry,
              Status
              ));

        if (pLogFile != NULL)
        {
            //
            // This means we have alread closed the old file but failed
            // when we try to create or open the new one.
            //
            
            ASSERT(pLogFile->hFile == NULL);
            
            UL_FREE_POOL_WITH_SIG(pLogFile,UL_LOG_FILE_HANDLE_POOL_TAG);
            pEntry->pLogFile = NULL;
            pEntry->Flags.Active = 0;
        }
        else
        {
            //
            // We were about to recyle the old one but something failed
            // lets try to flush and close the existing file if it's still
            // around.
            //

            if (pEntry->pLogFile)
            {
                UlpDisableErrorLogEntry(pEntry);        
            }
        }

        //
        // Mark this entry RecyclePending so that buffer timer can try to
        // resurrect this back every minute.
        //
        
        pEntry->Flags.RecyclePending = 1;        
    }
    
    return Status;
}


/***************************************************************************++

Routine Description:

    Closes the error log file entry.
    
Arguments:

    - none -
    
--***************************************************************************/

VOID
UlCloseErrorLogEntry(
    VOID
    )
{
    PUL_ERROR_LOG_FILE_ENTRY pEntry = &g_ErrorLogEntry;
    
    //
    // No more error logging !
    //

    PAGED_CODE();

    InterlockedExchange(&g_ErrorLoggingEnabled, 0);
    
    UlAcquirePushLockExclusive(&pEntry->PushLock);
    
    ASSERT(IS_VALID_ERROR_LOG_FILE_ENTRY(pEntry));

    if (pEntry->pLogFile)
    {
        //
        // Flush the buffer, close the file and mark the entry
        // inactive.
        //

        UlpDisableErrorLogEntry(pEntry); 
    }

    //
    // Free up the FileName (allocated when the entry becomes active
    // otherwise it's empty)
    //

    if (pEntry->FileName.Buffer)
    {
        UL_FREE_POOL(pEntry->FileName.Buffer,UL_CG_LOGDIR_POOL_TAG);
        pEntry->FileName.Buffer = NULL;
    }
    
    if (pEntry->LogBuffer)
    {
        // TODO: Is this really necessary here ?

        ASSERT(FALSE);
        
        UlPplFreeLogFileBuffer(pEntry->LogBuffer);
    }

    UlReleasePushLockExclusive(&pEntry->PushLock);    

    UlTrace(ERROR_LOGGING,
            ("Http!UlCloseErrorLogEntry: pEntry %p closed.\n",
             pEntry
             ));    
}

/***************************************************************************++

Routine Description:

    Private allocator if lookaside list entries are not big enough.
    
Arguments:

    pLogInfo  - Log info structure also holds the default allocated buffer.

Return Status

    STATUS_INSUFFICIENT_RESOURCES - if buffer allocation fails.

    STATUS_SUCCESS - Otherwise
    
--***************************************************************************/

PUL_ERROR_LOG_BUFFER
UlpAllocErrorLogBuffer(
    IN ULONG    BufferSize
    )
{
    PUL_ERROR_LOG_BUFFER pErrorLogBuffer = NULL;
    USHORT BytesNeeded = (USHORT) ALIGN_UP(BufferSize, PVOID);

    //
    // It should be bigger than the default size
    //

    ASSERT(BufferSize > UL_ERROR_LOG_BUFFER_SIZE);
        
    pErrorLogBuffer = 
        UL_ALLOCATE_STRUCT_WITH_SPACE(
            PagedPool,
            UL_ERROR_LOG_BUFFER,
            BytesNeeded, 
            UL_ERROR_LOG_BUFFER_POOL_TAG
            );

    if (pErrorLogBuffer)
    {
        pErrorLogBuffer->Signature   = UL_ERROR_LOG_BUFFER_POOL_TAG;
        pErrorLogBuffer->Used        = 0;
        pErrorLogBuffer->pBuffer     = (PUCHAR) (pErrorLogBuffer + 1);

        pErrorLogBuffer->IsFromLookaside = FALSE;        
    }

    return pErrorLogBuffer;    
}

/***************************************************************************++

Routine Description:

    After we are done with writing this record we have to clean up
    the internal error log buffer structure here.

Arguments:

    pErrorLogBuffer - Will be freed up.

--***************************************************************************/

VOID
UlpFreeErrorLogBuffer(
    IN OUT PUL_ERROR_LOG_BUFFER pErrorLogBuffer
    )
{
    if (pErrorLogBuffer->IsFromLookaside)
    {
        UlPplFreeErrorLogBuffer(pErrorLogBuffer);        
    }
    else
    {
        //
        // Large log line get allocated from paged pool we better 
        // be running on lowered IRQL if that's the case.
        //
        
        PAGED_CODE();

        UL_FREE_POOL_WITH_SIG( 
            pErrorLogBuffer, 
            UL_ERROR_LOG_BUFFER_POOL_TAG 
            );
    }
}

/***************************************************************************++

Routine Description:

    This function will build the error log record in a temp buffer
    The provided log info is used to build the individual log fields.
    
Arguments:

    pLogInfo  - Log info structure also holds the default allocated buffer.

Return Status

    STATUS_INSUFFICIENT_RESOURCES - if buffer allocation fails.

    STATUS_SUCCESS - Otherwise
    
--***************************************************************************/

NTSTATUS
UlpBuildErrorLogRecord(
    IN PUL_ERROR_LOG_INFO pLogInfo
    )
{
#define ERROR_LOG_BUILD_SEPERATOR(psz)                      \
        {                                                   \
            *(psz)++ = ERROR_LOG_FIELD_SEPERATOR_CHAR;      \
        }

#define ERROR_LOG_BUILD_EMPTY_FIELD(psz)                    \
        {                                                   \
            *(psz)++ = ERROR_LOG_FIELD_NOT_EXISTS_CHAR;     \
            ERROR_LOG_BUILD_SEPERATOR( psz )                \
        }

#define ERROR_LOG_SANITIZE_UNICODE_FIELD(pszT,psz)          \
        while ((pszT) != (psz))                             \
        {                                                   \
            if (IS_CHAR_TYPE((*(pszT)),HTTP_ISWHITE))       \
            {                                               \
                *(pszT) = ERROR_LOG_FIELD_BAD_CHAR;         \
            }                                               \
            (pszT)++;                                       \
        }

    ULONG    BytesRequired = MAX_ERROR_LOG_FIX_FIELD_OVERHEAD;
    ULONG    BytesConverted = 0;
    ULONG    BytesAllocated = UL_ERROR_LOG_BUFFER_SIZE;
    PUL_INTERNAL_REQUEST pRequest = NULL;  
    PUL_HTTP_CONNECTION  pHttpConn = NULL;
    ULONG    UrlSize = 0;
    BOOLEAN  bRawUrl = FALSE;
    PCHAR    psz = NULL;

    UNREFERENCED_PARAMETER(BytesAllocated);

    //
    // Sanity checks.
    //

    PAGED_CODE();

    //
    // Get the pointers to understand what we need to log.
    //

    ASSERT(IS_VALID_ERROR_LOG_INFO(pLogInfo));

    if (pLogInfo->pRequest)
    {
       ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pLogInfo->pRequest));
       pRequest = pLogInfo->pRequest; 

       ASSERT(UL_IS_VALID_HTTP_CONNECTION(pRequest->pHttpConn));
       pHttpConn = pRequest->pHttpConn;
    }    

    if (pLogInfo->pHttpConn)
    {
       ASSERT(UL_IS_VALID_HTTP_CONNECTION(pLogInfo->pHttpConn));
       pHttpConn = pLogInfo->pHttpConn;            
    }    

    //
    // Precalculate the max required bytes to check against 
    // the default buffer size.
    //
    
    if (pRequest)
    {
        UrlSize = UlpCalculateUrlSize(pRequest, &bRawUrl);
            
        BytesRequired += UrlSize;
    }

    if (pLogInfo->pInfo)
    {
        ASSERT(pLogInfo->InfoSize); 

        BytesRequired += pLogInfo->InfoSize;
    }

    UlTrace(ERROR_LOGGING,
      ("Http!UlPplAllocateErrorLogBuffer: Rb:(%d) Os:(%d) Ls:(%d)\n",
        BytesRequired, MAX_ERROR_LOG_FIX_FIELD_OVERHEAD,
        UL_ERROR_LOG_BUFFER_SIZE
        ));

    if (BytesRequired > UL_ERROR_LOG_BUFFER_SIZE)
    {
        //
        // Lookaside buffer is not big enough to hold the logging data.        
        //

        pLogInfo->pErrorLogBuffer = UlpAllocErrorLogBuffer(BytesRequired);
        BytesAllocated = BytesRequired;
    }
    else
    {
        //
        // Default buffer is big enough, try to pop it from the lookaside list.
        //
        
        pLogInfo->pErrorLogBuffer = UlPplAllocateErrorLogBuffer();
    }

    if (pLogInfo->pErrorLogBuffer == NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    
    psz = (PCHAR) pLogInfo->pErrorLogBuffer->pBuffer;

    //
    // Copy all the fields.
    //
        
    BytesConverted = 0;
    UlGetDateTimeFields(
                           HttpLoggingTypeW3C,      // Date
                           psz,
                          &BytesConverted,
                           NULL,
                           NULL
                           );
    psz += BytesConverted;
    ASSERT(BytesConverted == ERR_DATE_FIELD_LEN);
    ERROR_LOG_BUILD_SEPERATOR(psz);

    BytesConverted = 0;
    UlGetDateTimeFields(
                           HttpLoggingTypeW3C,      // Time
                           NULL,
                           NULL,
                           psz,
                          &BytesConverted
                           );
    psz += BytesConverted;
    ASSERT(BytesConverted == ERR_TIME_FIELD_LEN);
    ERROR_LOG_BUILD_SEPERATOR(psz);

    if (pHttpConn)
    {
        // Client IP & Port      
        psz = UlStrPrintIPAndPort(
                psz,
                pHttpConn->pConnection->RemoteAddress,
                pHttpConn->pConnection->AddressType,
                ERROR_LOG_FIELD_SEPERATOR_CHAR
                );

        // Server IP & Port      
        psz = UlStrPrintIPAndPort(
                psz,
                pHttpConn->pConnection->LocalAddress,
                pHttpConn->pConnection->AddressType,
                ERROR_LOG_FIELD_SEPERATOR_CHAR
                );     
    }
    else
    {
        ERROR_LOG_BUILD_EMPTY_FIELD(psz);
        ERROR_LOG_BUILD_EMPTY_FIELD(psz);
    }

    if (pRequest)
    {
        // Version
        if (pRequest->ParseState > ParseVersionState)
        {
            psz = UlCopyHttpVersion(
                    psz,
                    pRequest->Version,
                    ERROR_LOG_FIELD_SEPERATOR_CHAR
                    );
        }
        else
        {
            ERROR_LOG_BUILD_EMPTY_FIELD(psz);
        }
    
        // Verb
        if (pRequest->ParseState > ParseVerbState)
        {
            psz = UlCopyHttpVerb(
                    psz,
                    pRequest,
                    ERROR_LOG_FIELD_SEPERATOR_CHAR
                    );
        }
        else
        {
            ERROR_LOG_BUILD_EMPTY_FIELD(psz);
        }
    }
    else
    {
        ERROR_LOG_BUILD_EMPTY_FIELD(psz);
        ERROR_LOG_BUILD_EMPTY_FIELD(psz);
    }
        
    //
    // Do LocalCodePage conversion for a cooked Uri.
    // If query exists, it will be at the end of the Uri.
    //    

    if (UrlSize)       
    {
        PCHAR pszT = psz;        
        
        if (bRawUrl)
        {
            ASSERT(pRequest->RawUrl.pAbsPath);

            RtlCopyMemory( psz,
                           pRequest->RawUrl.pAbsPath,
                           UrlSize
                           );    

            psz += UrlSize;        
        }
        else
        {                        
            ASSERT(pRequest->CookedUrl.pAbsPath);
            
            BytesConverted = 0;
            RtlUnicodeToMultiByteN(
                psz,
                MAX_LOG_EXTEND_FIELD_LEN,
               &BytesConverted,
                (PWSTR) pRequest->CookedUrl.pAbsPath,
                UrlSize
                );
            
            psz += BytesConverted;
        }

        ERROR_LOG_SANITIZE_UNICODE_FIELD(pszT, psz);
        ERROR_LOG_BUILD_SEPERATOR(psz);
    }
    else
    {
        ERROR_LOG_BUILD_EMPTY_FIELD(psz);
    }
    
    // Protocol Status
    if (pLogInfo->ProtocolStatus != UL_PROTOCOL_STATUS_NA)
    {
        psz = UlStrPrintProtocolStatus(
                psz,
                pLogInfo->ProtocolStatus,
                ERROR_LOG_FIELD_SEPERATOR_CHAR
                ); 
    }
    else
    {
        ERROR_LOG_BUILD_EMPTY_FIELD(psz);
    }

    // Site Id field. Log this field only if the Site Id 
    // is set. (non-zero)
    if (pRequest && pRequest->ConfigInfo.SiteId)
    {
        psz = UlStrPrintUlong(
                psz, 
                pRequest->ConfigInfo.SiteId,
                ERROR_LOG_FIELD_SEPERATOR_CHAR
                );        
    }
    else
    {
        ERROR_LOG_BUILD_EMPTY_FIELD(psz);
    }    
    
    // No seperator after the Informational field 
    // because it is the last one.
    if (pLogInfo->pInfo)
    {    
        ASSERT(ANSI_NULL != 
                    pLogInfo->pInfo[pLogInfo->InfoSize - 1]);
        
        RtlCopyMemory( psz,
                       pLogInfo->pInfo,
                       pLogInfo->InfoSize
                       );    

        psz += pLogInfo->InfoSize;
    }
    else
    {
        *psz++ = ERROR_LOG_FIELD_NOT_EXISTS_CHAR;
    }

    // Terminate the line with "\r\n"
    *psz++ = '\r'; *psz++ = '\n';
    
    //
    // Done make sure that we didn't buffer overflow
    //

    pLogInfo->pErrorLogBuffer->Used = 
        DIFF(psz - (PCHAR)pLogInfo->pErrorLogBuffer->pBuffer);

    ASSERT(pLogInfo->pErrorLogBuffer->Used <= BytesRequired);
    ASSERT(pLogInfo->pErrorLogBuffer->Used <= BytesAllocated);

    return STATUS_SUCCESS;
}

/***************************************************************************++

Routine Description:

    Error logging for those requests/connections that are not routed up
    to the worker process. Basically requests/connections refused by 
    the driver are logged here. As well as appool process crashes. This is
    a driver wide error logging functionality.
    
Arguments:

    pLogInfo  - This should contains the necessary info and the pointers
                for the error log to be created.
        
--***************************************************************************/

NTSTATUS
UlLogHttpError(
    IN PUL_ERROR_LOG_INFO       pLogInfo
    )
{
    NTSTATUS                    Status = STATUS_SUCCESS;
    PUL_ERROR_LOG_FILE_ENTRY    pEntry = &g_ErrorLogEntry;
        
    //
    // Sanity checks.
    //

    PAGED_CODE();

    ASSERT(IS_VALID_ERROR_LOG_INFO(pLogInfo));
    //ASSERT(UlErrorLoggingEnabled());
    ASSERT(IS_VALID_ERROR_LOG_FILE_ENTRY(pEntry));

    UlTrace(ERROR_LOGGING,("Http!UlLogHttpError: pLogInfo %p\n", pLogInfo ));

    //
    // Bail out if disabled.
    //

    if (!UlErrorLoggingEnabled())
    {
        return STATUS_SUCCESS;    
    }

    //
    // Proceed with building the record from the passed-in info.
    //
    
    Status = UlpBuildErrorLogRecord(pLogInfo);

    if (!NT_SUCCESS(Status))
    {
        return Status;
    }

    ASSERT(IS_VALID_ERROR_LOG_BUFFER(pLogInfo->pErrorLogBuffer));
    ASSERT(pLogInfo->pErrorLogBuffer->Used);
    ASSERT(pLogInfo->pErrorLogBuffer->pBuffer);
    
    //
    // Open the error log file if necessary.
    //

    if (!pEntry->Flags.Active)
    {    
        UlAcquirePushLockExclusive(&pEntry->PushLock);

        //
        // Ping again to see if we have been blocked on the lock, and
        // somebody else already took care of the creation.
        //
        
        if (!pEntry->Flags.Active)
        {
           Status = UlpCreateErrorLogFile(pEntry);
        }
        
        UlReleasePushLockExclusive(&pEntry->PushLock);
    }

    if (NT_SUCCESS(Status))
    {        
        Status =
           UlpWriteToErrorLogFile (
                pEntry,
                pLogInfo->pErrorLogBuffer->Used,
                pLogInfo->pErrorLogBuffer->pBuffer
                );    
    }    

    //
    // Free up the error log record before returning.
    //

    UlpFreeErrorLogBuffer(pLogInfo->pErrorLogBuffer);
    pLogInfo->pErrorLogBuffer = NULL;
    
    return Status;
}

/***************************************************************************++

Routine Description:

    Exclusive (Debug) writer function. Basically it flushes the buffer
    everytime we write a record to the file buffer.

    REQUIRES you to hold the error log entry lock EXCLUSIVE.

Arguments:

    pEntry          - The binary log file entry we are working on.
    RecordSize      - The amount (in bytes) of data will be copied.
    pUserRecord     - The actual log record to go to file buffer.

--***************************************************************************/

NTSTATUS
UlpWriteToErrorLogFileDebug(
    IN PUL_ERROR_LOG_FILE_ENTRY  pEntry,
    IN ULONG                     RecordSize,
    IN PUCHAR                    pUserRecord
    )
{
    NTSTATUS Status;
    PUL_LOG_FILE_BUFFER pLogBuffer;

    PAGED_CODE();
    
    ASSERT(RecordSize);    
    ASSERT(pUserRecord);
    ASSERT(IS_VALID_ERROR_LOG_FILE_ENTRY(pEntry));

    UlTrace(ERROR_LOGGING,
        ("Http!UlpWriteToErrorLogFileDebug: pEntry %p\n", pEntry));

    ASSERT(UlDbgPushLockOwnedExclusive(&pEntry->PushLock));
    ASSERT(g_UlDisableLogBuffering != 0);    

    Status = STATUS_SUCCESS;
    
    //
    // Check the log file for overflow.
    //
    
    if (UlpIsErrorLogFileOverFlow(pEntry, RecordSize))
    { 
        Status = UlpRecycleErrorLogFile(pEntry);
    }
    
    if (pEntry->pLogFile == NULL || !NT_SUCCESS(Status))
    {
        return Status;
    }

    //
    // Prevent against abnormally big record sizes.
    //

    if (pEntry->LogBuffer &&
        RecordSize + pEntry->LogBuffer->BufferUsed > g_UlLogBufferSize)
    {
        ASSERT( !"Abnormally big log record !" );
        return STATUS_INVALID_PARAMETER;        
    }    
    
    //
    // Grab a new file buffer if we need.
    //
    
    pLogBuffer = pEntry->LogBuffer;
    
    if (pLogBuffer == NULL)
    {
        pLogBuffer = pEntry->LogBuffer = UlPplAllocateLogFileBuffer();
        if (!pLogBuffer)
        {
            return STATUS_NO_MEMORY;
        }
    }

    //
    // Finally copy over the log record to file buffer.
    //
    
    RtlCopyMemory(
        pLogBuffer->Buffer + pLogBuffer->BufferUsed,
        pUserRecord,
        RecordSize
        );
    
    pLogBuffer->BufferUsed += RecordSize;
    
    //
    // Now flush what we have.
    //
    
    Status = UlpFlushErrorLogFile(pEntry);
    if (!NT_SUCCESS(Status))
    {            
        return Status;
    }

    return STATUS_SUCCESS;
}

/***************************************************************************++

Routine Description:

    It tries to write to the file buffer with a shared lock.

    Exits and returns STATUS_MORE_PROCESSING_REQUIRED for exclusive access 
    for the following conditions;
    
        1. No log buffer available.
        2. Logging ceased. (NULL file handle)
        3. Recycle is necessary because of a size overflow.
        4. No available space left in the current buffer.
           Need to allocate a new one.

    Otherwise reserves a space in the current buffer, copies the data.
    
Arguments:

    pEntry          - The binary log file entry we are working on.
    RecordSize      - The amount (in bytes) of data will be copied.
    pUserRecord     - The actual log record to go to file buffer.

--***************************************************************************/

NTSTATUS
UlpWriteToErrorLogFileShared(
    IN PUL_ERROR_LOG_FILE_ENTRY  pEntry,
    IN ULONG                     RecordSize,
    IN PUCHAR                    pUserRecord
    )
{
    PUL_LOG_FILE_BUFFER     pLogBuffer;
    LONG                    BufferUsed;

    PAGED_CODE();
    
    ASSERT(RecordSize);
    ASSERT(pUserRecord);    
    ASSERT(IS_VALID_ERROR_LOG_FILE_ENTRY(pEntry));

    pLogBuffer = pEntry->LogBuffer;

    UlTrace(ERROR_LOGGING,
        ("Http!UlpWriteToErrorLogFileShared: pEntry %p\n", pEntry));

    //
    // Bail out and try the exclusive writer for conditions;
    //
    
    if ( pLogBuffer == NULL ||
         pEntry->pLogFile == NULL ||
         UlpIsErrorLogFileOverFlow(pEntry,RecordSize)
       )
    {
        return STATUS_MORE_PROCESSING_REQUIRED;
    }

    //
    // Reserve space in pLogBuffer by InterlockedCompareExchange add
    // RecordSize. If we exceed the limit, bail out and take the
    // exclusive lock to flush the buffer.
    //

    do
    {
        BufferUsed = *((volatile LONG *) &pLogBuffer->BufferUsed);

        if ( RecordSize + BufferUsed > g_UlLogBufferSize )
        {
            return STATUS_MORE_PROCESSING_REQUIRED;
        }

        PAUSE_PROCESSOR;
        
    } while (BufferUsed != InterlockedCompareExchange(
                                &pLogBuffer->BufferUsed,
                                RecordSize + BufferUsed,
                                BufferUsed
                                ));

    //
    // Now we have a reserved space lets proceed with the copying.
    //

    RtlCopyMemory(
        pLogBuffer->Buffer + BufferUsed,
        pUserRecord,
        RecordSize
        );
    
    return STATUS_SUCCESS;
}


/***************************************************************************++

Routine Description:

    Exclusive writer counterpart of the above function..

Arguments:

    pEntry          - The binary log file entry we are working on.
    RecordSize      - The amount (in bytes) of data will be copied.
    pUserRecord     - The actual log record to go to file buffer.

--***************************************************************************/

NTSTATUS
UlpWriteToErrorLogFileExclusive(
    IN PUL_ERROR_LOG_FILE_ENTRY  pEntry,
    IN ULONG                     RecordSize,
    IN PUCHAR                    pUserRecord
    )
{
    PUL_LOG_FILE_BUFFER pLogBuffer;
    NTSTATUS            Status;

    PAGED_CODE();

    ASSERT(RecordSize);
    ASSERT(pUserRecord);    
    ASSERT(IS_VALID_ERROR_LOG_FILE_ENTRY(pEntry));

    UlTrace(ERROR_LOGGING,
        ("Http!UlpWriteToErrorLogFileExclusive: pEntry %p\n", pEntry));

    ASSERT(UlDbgPushLockOwnedExclusive(&pEntry->PushLock));

    //
    // Check the log file for overflow.
    //

    Status = STATUS_SUCCESS;
    
    if (UlpIsErrorLogFileOverFlow(pEntry,RecordSize))
    { 
        Status = UlpRecycleErrorLogFile(pEntry);
    }
    
    if (pEntry->pLogFile==NULL || !NT_SUCCESS(Status))
    {
        return Status;
    }

    pLogBuffer = pEntry->LogBuffer;
    if (pLogBuffer)
    {
        //
        // There is only one condition for which we execute the following if block
        // - We were blocked on eresource exclusive and before us some other 
        // thread already took care of the buffer flush or the recycling.
        //
        
        if (RecordSize + pLogBuffer->BufferUsed <= g_UlLogBufferSize)
        {
            RtlCopyMemory(
                pLogBuffer->Buffer + pLogBuffer->BufferUsed,
                pUserRecord,
                RecordSize
                );
            
            pLogBuffer->BufferUsed += RecordSize;

            return STATUS_SUCCESS;
        }

        //
        // Need to flush the existing buffer before allocating a new one.
        //

        Status = UlpFlushErrorLogFile(pEntry);
        if (!NT_SUCCESS(Status))
        {            
            return Status;
        }
    }

    ASSERT(pEntry->LogBuffer == NULL);
    
    //
    // Now allocate a new buffer for this log record to be copied over.
    // 

    pLogBuffer = pEntry->LogBuffer = UlPplAllocateLogFileBuffer();
    if (pLogBuffer == NULL)
    {
        return STATUS_NO_MEMORY;
    }

    RtlCopyMemory(
        pLogBuffer->Buffer + pLogBuffer->BufferUsed,
        pUserRecord,
        RecordSize
        );
    
    pLogBuffer->BufferUsed += RecordSize;

    return STATUS_SUCCESS;
}


/***************************************************************************++

Routine Description:

    Tries shared write first, if fails then it goes for exclusice lock and
    flushes and/or recycles the file.
    
Arguments:

    pEntry          - The binary log file entry we are working on.
    RecordSize      - The amount (in bytes) of data will be copied.
    pUserRecord     - The actual log record to go to file buffer.
    
--***************************************************************************/

NTSTATUS
UlpWriteToErrorLogFile(
    IN PUL_ERROR_LOG_FILE_ENTRY  pEntry,
    IN ULONG                     RecordSize,
    IN PUCHAR                    pUserRecord
    )
{
    NTSTATUS Status;

    PAGED_CODE();

    ASSERT(RecordSize);
    ASSERT(pUserRecord);
    ASSERT(RecordSize <= g_UlLogBufferSize);
    ASSERT(IS_VALID_ERROR_LOG_FILE_ENTRY(pEntry));

    UlTrace(ERROR_LOGGING,
        ("Http!UlpWriteToErrorLogFile: pEntry %p\n", pEntry));


    if ( pEntry  == NULL || 
         pUserRecord == NULL ||
         RecordSize == 0 ||
         RecordSize > g_UlLogBufferSize      
       )
    {
        return STATUS_INVALID_PARAMETER;
    }

    if (g_UlDisableLogBuffering)
    {        
        UlAcquirePushLockExclusive(&pEntry->PushLock);

        Status = UlpWriteToErrorLogFileDebug(
                    pEntry,
                    RecordSize,
                    pUserRecord
                    );

        UlReleasePushLockExclusive(&pEntry->PushLock);

        return Status;    
    }
    
    //
    // Try Shared write first which merely moves the BufferUsed forward
    // and copy the error record to the file buffer.
    //

    UlAcquirePushLockShared(&pEntry->PushLock);

    Status = UlpWriteToErrorLogFileShared(
                    pEntry,
                    RecordSize,
                    pUserRecord
                    );

    UlReleasePushLockShared(&pEntry->PushLock);

    if (Status == STATUS_MORE_PROCESSING_REQUIRED)
    {
        //
        // If shared write returns STATUS_MORE_PROCESSING_REQUIRED,
        // we need to flush/recycle the buffer and try to log again. 
        // This time, we need to take the entry eresource exclusive.
        //

        UlAcquirePushLockExclusive(&pEntry->PushLock);

        Status = UlpWriteToErrorLogFileExclusive(
                    pEntry,
                    RecordSize,
                    pUserRecord
                    );

        UlReleasePushLockExclusive(&pEntry->PushLock);
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\filecache.h ===
/*++

Copyright (c) 1998-2002 Microsoft Corporation

Module Name:

    filecache.h

Abstract:

    This module contains declarations for the open file handle cache.

Author:

    Keith Moore (keithmo)       21-Aug-1998

Revision History:

--*/


#ifndef _FILECACHE_H_
#define _FILECACHE_H_


//
// Data used to track a file cache entry.
//

typedef struct _UL_FILE_CACHE_ENTRY
{
    //
    // Signature.
    //

    ULONG Signature;

    //
    // Sector-size information gleaned from the file system.
    //

    ULONG BytesPerSector;

    //
    // File-length information gleaned from the file system.
    //

    LARGE_INTEGER EndOfFile;

    //
    // A pre-referenced file object pointer for this file. This pointer
    // is valid in *any* thread/process context.
    //

    PFILE_OBJECT pFileObject;

    //
    // The *correct* device object referenced by the above file object.
    //

    PDEVICE_OBJECT pDeviceObject;

    //
    // Fast I/O routines.
    //

    PFAST_IO_MDL_READ pMdlRead;
    PFAST_IO_MDL_READ_COMPLETE pMdlReadComplete;

} UL_FILE_CACHE_ENTRY, *PUL_FILE_CACHE_ENTRY;

#define UL_FILE_CACHE_ENTRY_SIGNATURE       MAKE_SIGNATURE('FILE')
#define UL_FILE_CACHE_ENTRY_SIGNATURE_X     MAKE_FREE_SIGNATURE(UL_FILE_CACHE_ENTRY_SIGNATURE)

#define IS_VALID_FILE_CACHE_ENTRY( entry )                                  \
    HAS_VALID_SIGNATURE(entry, UL_FILE_CACHE_ENTRY_SIGNATURE)


//
// A file buffer contains the results of a read from a file cache entry.
// The file cache read and read complete routines take pointers to this
// structure. A read fills it in, and a read complete frees the data.
//

typedef struct _UL_FILE_BUFFER
{
    //
    // The file that provided the data.
    //
    PUL_FILE_CACHE_ENTRY    pFileCacheEntry;

    //
    // The data read from the file. Filled in by
    // the read routines.
    //
    PMDL                    pMdl;

    //
    // If we have to allocate our own buffer to hold file data
    // we'll save a pointer to the data buffer here.
    //
    PUCHAR                  pFileData;

    //
    // Information about the data buffers.
    // Filled in by the read routine's caller.
    //
    ULARGE_INTEGER          FileOffset;
    ULONG                   RelativeOffset;
    ULONG                   Length;

    //
    // Completion routine and context information set by the caller.
    //
    PIO_COMPLETION_ROUTINE  pCompletionRoutine;
    PVOID                   pContext;

} UL_FILE_BUFFER, *PUL_FILE_BUFFER;


NTSTATUS
InitializeFileCache(
    VOID
    );

VOID
TerminateFileCache(
    VOID
    );

//
// Routines to create, reference and release a cache entry.
//

NTSTATUS
UlCreateFileEntry(
    IN HANDLE FileHandle,
    IN OUT PUL_FILE_CACHE_ENTRY pFileCacheEntry
    );

VOID
UlDestroyFileCacheEntry(
    IN PUL_FILE_CACHE_ENTRY pFileCacheEntry
    );


//
// Read and read complete routines.
//
// The fast versions complete immediately, but sometimes fail.
// The normal versions use an IRP provided by the caller.
//

NTSTATUS
UlReadFileEntry(
    IN OUT PUL_FILE_BUFFER pFileBuffer,
    IN PIRP pIrp
    );

NTSTATUS
UlReadFileEntryFast(
    IN OUT PUL_FILE_BUFFER pFileBuffer
    );

NTSTATUS
UlReadCompleteFileEntry(
    IN PUL_FILE_BUFFER pFileBuffer,
    IN PIRP pIrp
    );

NTSTATUS
UlReadCompleteFileEntryFast(
    IN PUL_FILE_BUFFER pFileBuffer
    );

//
// UL_FILE_BUFFER macros.
//

#define IS_FILE_BUFFER_IN_USE(fbuf) ((fbuf)->pFileCacheEntry)


//
// Dummy MdlRead and MdlReadComplete routines.
//

BOOLEAN
UlFailMdlReadDev(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
UlFailMdlReadCompleteDev(
    IN PFILE_OBJECT FileObject,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject
    );


#endif  // _FILECACHE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\filter.h ===
/*++

Copyright (c) 2000-2002 Microsoft Corporation

Module Name:

    filter.h

Abstract:

    This module contains public declarations for the UL filter channel.

Author:

    Michael Courage (mcourage)  17-Mar-2000

Revision History:

--*/


#ifndef _FILTER_H_
#define _FILTER_H_


//
// Constants.
//

//
// Filter channel name comparision macros
//

#define UL_MAX_FILTER_NAME_LENGTH                   \
    max(HTTP_SSL_SERVER_FILTER_CHANNEL_NAME_LENGTH, \
        HTTP_SSL_CLIENT_FILTER_CHANNEL_NAME_LENGTH)

#define IsServerFilterChannel(Name, NameLength)                            \
    ((NameLength) == HTTP_SSL_SERVER_FILTER_CHANNEL_NAME_LENGTH &&         \
       _wcsnicmp(                                                          \
           (Name),                                                         \
           HTTP_SSL_SERVER_FILTER_CHANNEL_NAME,                            \
           HTTP_SSL_SERVER_FILTER_CHANNEL_NAME_LENGTH/sizeof(WCHAR)) == 0)

#define IsClientFilterChannel(Name, NameLength)                            \
    ((NameLength) == HTTP_SSL_CLIENT_FILTER_CHANNEL_NAME_LENGTH &&         \
       _wcsnicmp(                                                          \
           (Name),                                                         \
           HTTP_SSL_CLIENT_FILTER_CHANNEL_NAME,                            \
           HTTP_SSL_CLIENT_FILTER_CHANNEL_NAME_LENGTH/sizeof(WCHAR)) == 0)


//
// Forwards.
//
typedef struct _UL_FILTER_WRITE_QUEUE *PUL_FILTER_WRITE_QUEUE;
typedef struct _UL_APP_POOL_PROCESS *PUL_APP_POOL_PROCESS;

//
// The filter channel types.
//

typedef struct _UL_FILTER_CHANNEL *PUL_FILTER_CHANNEL;
typedef struct _UL_FILTER_PROCESS *PUL_FILTER_PROCESS;

#ifndef offsetof
#define offsetof(s,m)     (size_t)&(((s *)0)->m)
#endif

//
// Initialize/terminate functions.
//

NTSTATUS
UlInitializeFilterChannel(
    PUL_CONFIG pConfig
    );

VOID
UlTerminateFilterChannel(
    VOID
    );


//
// Open/close a new filter channel.
//

NTSTATUS
UlAttachFilterProcess(
    IN PWCHAR pName,
    IN USHORT NameLength,
    IN BOOLEAN Create,
    IN PACCESS_STATE pAccessState,
    IN ACCESS_MASK DesiredAccess,
    IN KPROCESSOR_MODE RequestorMode,
    OUT PUL_FILTER_PROCESS *ppFilterProcess
    );

NTSTATUS
UlDetachFilterProcess(
    IN PUL_FILTER_PROCESS pFilterProcess
    );

VOID
UlShutdownFilterProcess(
    IN PUL_FILTER_PROCESS pFilterProcess
    );

VOID
UlCloseFilterProcess(
    IN PUL_FILTER_PROCESS pFilterProcess
    );

//
// Filter channel I/O operations.
//
NTSTATUS
UlFilterAccept(
    IN PUL_FILTER_PROCESS pFilterProcess,
    IN PIRP pIrp
    );

NTSTATUS
UlFilterClose(
    IN PUL_FILTER_PROCESS pFilterProcess,
    IN PUX_FILTER_CONNECTION pConnection,
    IN PIRP pIrp
    );

NTSTATUS
UlFilterRawWriteAndAppRead(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

NTSTATUS
UlFilterAppWriteAndRawRead(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

NTSTATUS
UlFilterRawRead(
    IN PUL_FILTER_PROCESS pFilterProcess,
    IN PUX_FILTER_CONNECTION pConnection,
    IN PIRP pIrp
    );

NTSTATUS
UlFilterRawWrite(
    IN PUL_FILTER_PROCESS pFilterProcess,
    IN PUX_FILTER_CONNECTION pConnection,
    IN ULONG BufferLength,
    IN PIRP pIrp
    );

NTSTATUS
UlFilterAppRead(
    IN PUL_FILTER_PROCESS pFilterProcess,
    IN PUX_FILTER_CONNECTION pConnection,
    IN PIRP pIrp
    );

NTSTATUS
UlFilterAppWrite(
    IN PUL_FILTER_PROCESS pFilterProcess,
    IN PUX_FILTER_CONNECTION pConnection,
    IN PIRP pIrp
    );

//
// SSL related app pool operations.
//

NTSTATUS
UlReceiveClientCert(
    PUL_APP_POOL_PROCESS pProcess,
    PUX_FILTER_CONNECTION pConnection,
    ULONG Flags,
    PIRP pIrp
    );


//
// Filter channel reference counting.
//
VOID
UlReferenceFilterChannel(
    IN PUL_FILTER_CHANNEL pFilterChannel
    REFERENCE_DEBUG_FORMAL_PARAMS
    );

#define REFERENCE_FILTER_CHANNEL( pFilt )                                   \
    UlReferenceFilterChannel(                                               \
        (pFilt)                                                             \
        REFERENCE_DEBUG_ACTUAL_PARAMS                                       \
        )

VOID
UlDereferenceFilterChannel(
    IN PUL_FILTER_CHANNEL pFilterChannel
    REFERENCE_DEBUG_FORMAL_PARAMS
    );

#define DEREFERENCE_FILTER_CHANNEL( pFilt )                                 \
    UlDereferenceFilterChannel(                                             \
        (pFilt)                                                             \
        REFERENCE_DEBUG_ACTUAL_PARAMS                                       \
        )

//
// Interface for ultdi.
//

NTSTATUS
UlFilterReceiveHandler(
    IN PUX_FILTER_CONNECTION pConnection,
    IN PVOID pBuffer,
    IN ULONG IndicatedLength,
    IN ULONG UnreceivedLength,
    OUT PULONG pTakenLength
    );

NTSTATUS
UlFilterSendHandler(
    IN PUX_FILTER_CONNECTION pConnection,
    IN PMDL pMdlChain,
    IN ULONG Length,
    IN PUL_IRP_CONTEXT pIrpContext
    );

NTSTATUS
UlFilterReadHandler(
    IN PUX_FILTER_CONNECTION pConnection,
    OUT PUCHAR pBuffer,
    IN ULONG BufferLength,
    IN PUL_COMPLETION_ROUTINE pCompletionRoutine,
    IN PVOID pCompletionContext
    );

NTSTATUS
UlFilterCloseHandler(
    IN PUX_FILTER_CONNECTION pConnection,
    IN PUL_COMPLETION_ROUTINE pCompletionRoutine,
    IN PVOID pCompletionContext
    );

NTSTATUS
UlFilterDisconnectHandler(
    IN PUX_FILTER_CONNECTION pConnection
    );

VOID
UlUnbindConnectionFromFilter(
    IN PUX_FILTER_CONNECTION pConnection
    );

VOID
UlDestroyFilterConnection(
    IN PUX_FILTER_CONNECTION pConnection
    );

VOID
UlFilterDrainIndicatedData(
    IN PUL_WORK_ITEM  pWorkItem
    );

//
// Interface for apool.
//

NTSTATUS
UlGetSslInfo(
    IN PUX_FILTER_CONNECTION pConnection,
    IN ULONG BufferSize,
    IN PUCHAR pUserBuffer OPTIONAL,
    IN PEPROCESS pProcess OPTIONAL,
    OUT PUCHAR pBuffer OPTIONAL,
    OUT PHANDLE pMappedToken OPTIONAL,
    OUT PULONG pBytesCopied OPTIONAL
    );

//
// Utility.
//


PUX_FILTER_CONNECTION
UlGetRawConnectionFromId(
    IN HTTP_RAW_CONNECTION_ID ConnectionId
    );

VOID
UxReferenceConnection(
    IN PVOID pObject
    REFERENCE_DEBUG_FORMAL_PARAMS
    );

NTSTATUS
UxInitializeFilterConnection(
    IN PUX_FILTER_CONNECTION                    pConnection,
    IN PUL_FILTER_CHANNEL                       pChannel,
    IN BOOLEAN                                  Secure,
    IN PUL_OPAQUE_ID_OBJECT_REFERENCE           pfnReferenceFunction,
    IN PUL_OPAQUE_ID_OBJECT_REFERENCE           pfnDereferenceFunction,
    IN PUX_FILTER_CLOSE_CONNECTION              pfnConnectionClose,
    IN PUX_FILTER_SEND_RAW_DATA                 pfnRawSend,
    IN PUX_FILTER_RECEIVE_RAW_DATA              pfnRawReceive,
    IN PUL_DATA_RECEIVE                         pfnDataReceive,
    IN PUX_FILTER_COMPUTE_RAW_CONNECTION_LENGTH pfnRawConnLength,
    IN PUX_FILTER_GENERATE_RAW_CONNECTION_INFO  pfnGenerateRawConnInfo,
    IN PUX_FILTER_SERVER_CERT_INDICATE          pfnServerCertIndicate,
    IN PUX_FILTER_DISCONNECT_NOTIFICATION       pfnDisconnectNotification,
    IN PVOID                                    pListenContext,
    IN PVOID                                    pConnectionContext
    );

NTSTATUS
UlDeliverConnectionToFilter(
    IN PUX_FILTER_CONNECTION pConnection,
    IN PVOID pBuffer,
    IN ULONG IndicatedLength,
    OUT PULONG pTakenLength
    );

PUL_FILTER_CHANNEL
UxRetrieveServerFilterChannel(
    IN BOOLEAN Secure
    );

PUL_FILTER_CHANNEL
UxRetrieveClientFilterChannel(
    PEPROCESS pProcess
    );

VOID
UxSetFilterOnlySsl(
    BOOLEAN bFilterOnlySsl
    );

BOOLEAN
UlValidateFilterChannel(
    IN PUL_FILTER_CHANNEL pChannel,
    IN BOOLEAN SecureConnection
    );

#endif  // _FILTER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\filterp.h ===
/*++

Copyright (c) 2000-2002 Microsoft Corporation

Module Name:

    filterp.h

Abstract:

    This module contains public declarations for the UL filter channel.

Author:

    Michael Courage (mcourage)  17-Mar-2000

Revision History:

--*/


#ifndef _FILTERP_H_
#define _FILTERP_H_


typedef struct _UX_FILTER_CONNECTION    *PUX_FILTER_CONNECTION;
typedef struct _UX_FILTER_WRITE_TRACKER *PUX_FILTER_WRITE_TRACKER;
typedef struct _UL_IRP_CONTEXT          *PUL_IRP_CONTEXT;
typedef struct _UL_FILTER_CHANNEL       *PUL_FILTER_CHANNEL;

//
// The filter channel types.
//

#define IS_VALID_FILTER_CHANNEL(pFilterChannel) \
    HAS_VALID_SIGNATURE(pFilterChannel, UL_FILTER_CHANNEL_POOL_TAG)


typedef struct _UL_FILTER_CHANNEL
{
    //
    // UL_FILTER_CHANNEL_POOL_TAG
    //
    ULONG                   Signature;

    //
    // Ref count for this object
    //
    LONG                    RefCount;

    //
    // links all filter objects, anchored by g_FilterListHead
    //
    LIST_ENTRY              ListEntry;

    //
    // the demand start irp (OPTIONAL)
    //
    PIRP                    pDemandStartIrp;
    PEPROCESS               pDemandStartProcess;

    //
    // Synchronizes the process list, connection queue,
    // and lists within the process object.
    //
    UL_SPIN_LOCK            SpinLock;

    //
    // List of processes attached to this filter channel.
    //
    LIST_ENTRY              ProcessListHead;

    //
    // Queue of connections ready to be accepted.
    //
    LIST_ENTRY              ConnectionListHead;

    //
    // security on this object
    //
    PSECURITY_DESCRIPTOR    pSecurityDescriptor;

    //
    // the process that created this channel
    //
    PEPROCESS               pProcess;

    //
    // the length of pName
    //
    USHORT                  NameLength;

    //
    // the apool's name
    //
    WCHAR                   pName[0];

} UL_FILTER_CHANNEL, *PUL_FILTER_CHANNEL;

//
// Per-process filter channel object.
//

#define IS_VALID_FILTER_PROCESS(pFilterProcess)                     \
    HAS_VALID_SIGNATURE(pFilterProcess, UL_FILTER_PROCESS_POOL_TAG)

typedef struct _UL_FILTER_PROCESS
{
    //
    // UL_FILTER_PROCESS_POOL_TAG
    //
    ULONG                       Signature;

    //
    // Flags.
    //

    //
    // set if we are in cleanup. You must check this flag before attaching
    // any IRPs to the process.
    //
    ULONG                       InCleanup : 1;

    //
    // Pointer to our UL_FILTER_CHANNEL.
    //
    PUL_FILTER_CHANNEL          pFilterChannel;

    //
    // List entry for UL_FILTER_CHANNEL.
    //
    LIST_ENTRY                  ListEntry;

    //
    // List of connections attached to this process.
    //
    LIST_ENTRY                  ConnectionHead;

    //
    // List of accept IRPs pending on this process.
    //
    LIST_ENTRY                  IrpHead;

    //
    // Pointer to the actual process (for debugging)
    //
    PEPROCESS                   pProcess;

} UL_FILTER_PROCESS, *PUL_FILTER_PROCESS;

//
// An object for tracking MDL chain to IRP copies.
//
typedef struct _UL_MDL_CHAIN_COPY_TRACKER
{
    PMDL   pMdl;            // the current MDL
    ULONG  Offset;          // offset into current MDL

    ULONG  Length;          // length of MDL chain in bytes
    ULONG  BytesCopied;     // number of bytes copied so far

} UL_MDL_CHAIN_COPY_TRACKER, *PUL_MDL_CHAIN_COPY_TRACKER;

//
// A dummy receive buffer for draining remaining bytes on the
// filtered connection.
//
typedef struct _UL_FILTER_RECEIVE_BUFFER
{
    //
    // From NonPagedPool
    //
    ULONG                 Signature;      // UL_FILTER_RECEIVE_BUFFER_POOL_TAG
    PUX_FILTER_CONNECTION pConnection;    // Corresponding filter connection
    UCHAR                 pBuffer[0];     // The actual buffer space (inline)

} UL_FILTER_RECEIVE_BUFFER, *PUL_FILTER_RECEIVE_BUFFER;

#define IS_VALID_FILTER_RECEIVE_BUFFER(pBuffer)                         \
    HAS_VALID_SIGNATURE(pBuffer, UL_FILTER_RECEIVE_BUFFER_POOL_TAG)

typedef
NTSTATUS
(*PUL_DATA_RECEIVE)(
    IN PVOID    pListeningContext,
    IN PVOID    pConnectionContext,
    IN PVOID    pBuffer,
    IN ULONG    IndicatedLength,
    IN ULONG    UnreceivedLength,
    OUT PULONG  pTakenLength
    );

typedef
NTSTATUS
(*PUX_FILTER_CLOSE_CONNECTION)(
    IN PVOID                  pConnectionContext,
    IN BOOLEAN                AbortiveDisconnect,
    IN PUL_COMPLETION_ROUTINE pCompletionRoutine,
    IN PVOID                  pCompletionContext
    );

typedef
NTSTATUS
(*PUX_FILTER_RECEIVE_RAW_DATA)(
    IN PVOID                  pConnectionContext,
    IN PVOID                  pBuffer,
    IN ULONG                  BufferLength,
    IN PUL_COMPLETION_ROUTINE pCompletionRoutine,
    IN PVOID                  pCompletionContext
    );

typedef
NTSTATUS
(*PUX_FILTER_SEND_RAW_DATA)(
    IN PVOID            pConnection,
    IN PMDL             pMdlChain,
    IN ULONG            Length,
    IN PUL_IRP_CONTEXT  pIrpContext,
    IN BOOLEAN          InitiateDisconnect
    );

#define DEREFERENCE_FILTER_CONNECTION( pconn )       \
    ((pconn)->pDereferenceHandler)                   \
        ((pconn)->pConnectionContext                 \
         REFERENCE_DEBUG_ACTUAL_PARAMS               \
    )

#define REFERENCE_FILTER_CONNECTION( pconn )       \
    ((pconn)->pReferenceHandler)                   \
        ((pconn)->pConnectionContext               \
         REFERENCE_DEBUG_ACTUAL_PARAMS             \
    )

#define UX_FILTER_CONNECTION_SIGNATURE     MAKE_SIGNATURE('FILT')
#define UX_FILTER_CONNECTION_SIGNATURE_X   MAKE_FREE_SIGNATURE(UL_CONNECTION_SIGNATURE)

#define IS_VALID_FILTER_CONNECTION(pConnection)                             \
    HAS_VALID_SIGNATURE(pConnection, UX_FILTER_CONNECTION_SIGNATURE)

//
// Connection state related to filtering.
//
// The filtering API (mostly implemented in filter.c) exists
// to enable SSL and raw data filters in a way that is transparent
// to clients of ultdi.
//
// Most of the state is either for tracking the producer/consumer
// relationship between filters and the ultdi client, and
// for simulating TDI behavior so that the client doesn't know
// is really talking to a filter process.
//

//
// Filter Connection state.
//
// The connection is Inactive until the first data is received
// from the network. Then it transitions to Connected if a
// FilterAccept IRP is available, or to Queued if the connection
// must instead be queued on its filter channel. The state will
// move to Disconnected after any disconnect.
//
// If the connection is about to be closed, the state is set
// to WillDisconnect so that further data will not be delivered,
// but the disconnect notification can still be sent.
//

typedef enum _UL_FILTER_CONN_STATE
{
    UlFilterConnStateInactive,
    UlFilterConnStateQueued,
    UlFilterConnStateWillDisconnect,
    UlFilterConnStateConnected,
    UlFilterConnStateDisconnected,

    UlFilterConnStateMaximum

} UL_FILTER_CONN_STATE, *PUL_FILTER_CONN_STATE;


//
// UL_FILTER_WRITE_QUEUE
//
// This queue maintains a list of read IRPs, and synchronizes
// access to that list. Read IRPs are always placed on the
// queue when they arrive. Writers are blocked until there
// are read IRPs available.
//
// If a writer is unblocked, but the available buffers
// can only handle part of its data, then it sets the
// BlockedPartialWrite flag, and waits for the PartialWriteEvent.
// When new buffers arrive, this writer is woken up before
// any others.
//
typedef struct _UL_FILTER_WRITE_QUEUE
{
    ULONG ReadIrps;
    ULONG Writers;
    BOOLEAN WriterActive;

    LIST_ENTRY ReadIrpListHead;
    KEVENT ReadIrpAvailableEvent;

    BOOLEAN BlockedPartialWrite;
    KEVENT PartialWriteEvent;

} UL_FILTER_WRITE_QUEUE, *PUL_FILTER_WRITE_QUEUE;


//
// UX_FILTER_WRITE_QUEUE & UX_FILTER_WRITE_TRACKER
//
// CODEWORK: switch the AppToFilt queue to use this.
//
// This is a producer/consumer queue used for moving
// data between the filter process and the worker
// processes. Both reads are writes are asynchronous.
// The same data structure is used to move data
// from Filter -> App (worker process), and from
// App -> Filter. The UX_FILTER_WRITE_TRACKER is
// used to queue writes.
//
// The operation of the queue is somewhat different
// depending on the direction of the data transfer.
//
// Filter->App:
//
// The data to be sent arrives in FilterAppWrite IRPs.
// Normally this data is "indicated" to the app in
// a callback and completely consumed, however the
// app may consume only some of the indicated data,
// in which case the write must be queued until
// the app grabs the rest of the data with a read.
// The read arrives as a plain buffer.
// Once all the queued bytes are consumed the normal
// indication method of transferring data resumes.
// This system emulates the way TDI sends data to the
// app.
//
// App->Filter:
//
// The data to be sent arrives as a MDL chain and
// UL_IRP_CONTEXT. The data is always consumed by
// FilterAppRead IRPs from the filter process. If there
// are not enough FilterAppRead IRPs around to handle the
// data then we have to queue the write until more IRPs
// arrive.
//


//
// When you initialize a filter write queue you pass in
// a several function pointers that can get called when
// queuing, dequeuing or completing a write.
//

//
// Called before queuing a write tracker.
//
typedef
NTSTATUS
(*PUX_FILTER_WRITE_ENQUEUE)(
    IN PUX_FILTER_WRITE_TRACKER pTracker
    );

//
// Called before dequeuing a tracker.
//
typedef
NTSTATUS
(*PUX_FILTER_WRITE_DEQUEUE)(
    IN PUX_FILTER_WRITE_TRACKER pTracker
    );

//
// Called when a queued write has completed.
//
typedef
VOID
(*PUX_FILTER_WRITE_QUEUE_COMPLETION)(
    IN PVOID pContext,
    IN NTSTATUS Status,
    IN ULONG_PTR Information
    );

typedef
ULONG
(*PUX_FILTER_COMPUTE_RAW_CONNECTION_LENGTH)(
    IN PVOID pConnectionContext
    );

typedef
ULONG
(*PUX_FILTER_GENERATE_RAW_CONNECTION_INFO)(
    IN PVOID pConnectionContext,
    IN PUCHAR pKernelBuffer,
    IN PVOID  pUserBuffer,
    IN ULONG  OutLength,
    IN PUCHAR pBuffer,
    IN ULONG  InitialLength
    );

typedef
VOID
(*PUX_FILTER_SERVER_CERT_INDICATE)(
    IN PVOID    pConnectionContext,
    IN NTSTATUS Status
    );

typedef
VOID
(*PUX_FILTER_DISCONNECT_NOTIFICATION)(
    IN PVOID pConnectionContext
    );

//
// There are two UX_FILTER_WRITE_QUEUEs for each connection.
// FiltToApp and AppToFilt.
//

typedef struct _UX_FILTER_WRITE_QUEUE
{
    //
    // Counts of pending operations.
    //

    ULONG       PendingWriteCount;
    ULONG       PendingReadCount;

    //
    // List of pending writes.
    //

    LIST_ENTRY  WriteTrackerListHead;

    //
    // List of pending read IRPs.
    //

    LIST_ENTRY  ReadIrpListHead;

    //
    // Some function pointers called at various stages
    // of processing a request. In the App -> Filt case
    // the enqueue and dequeue routines are used to
    // do the required magic to queue and dequeue IRPs
    // (which may be cancelled at any time).
    //

    PUX_FILTER_WRITE_ENQUEUE            pWriteEnqueueRoutine;
    PUX_FILTER_WRITE_DEQUEUE            pWriteDequeueRoutine;

} UX_FILTER_WRITE_QUEUE, *PUX_FILTER_WRITE_QUEUE;

//
// There is one UX_FILTER_WRITE_TRACKER for every queued write.
//

#define IS_VALID_FILTER_WRITE_TRACKER(pTracker)                         \
    HAS_VALID_SIGNATURE(pTracker, UX_FILTER_WRITE_TRACKER_POOL_TAG)

typedef struct _UX_FILTER_WRITE_TRACKER
{
    //
    // This MUST be the first field in the structure. This is the linkage
    // used by the lookaside package for storing entries in the lookaside
    // list.
    //

    SLIST_ENTRY             LookasideEntry;

    //
    // A signature.
    //

    ULONG                   Signature;

    //
    // Our write queue entry.
    //

    LIST_ENTRY              ListEntry;

    //
    // Pointers to the connection and write queue
    // which we need to dequeue the tracker if the
    // write gets cancelled.
    //

    PUX_FILTER_CONNECTION   pConnection;
    PUX_FILTER_WRITE_QUEUE  pWriteQueue;

    //
    // The type of write represented by this tracker.
    //

    HTTP_FILTER_BUFFER_TYPE BufferType;

    //
    // Pointer to the current MDL being written and
    // an offset into that MDL.
    //

    PMDL                    pMdl;
    ULONG                   Offset;

    //
    // Total length of the MDL chain being written
    // and the total number of bytes we have copied
    // so far.
    //

    ULONG                   Length;
    ULONG                   BytesCopied;

    //
    // Completion routine to call when the write
    // is completed.
    //

    PUL_COMPLETION_ROUTINE  pCompletionRoutine;
    UL_WORK_ITEM            WorkItem;

    //
    // A context object we use to complete the
    // write operation. In the App -> Filter case
    // this is a UL_IRP_CONTEXT. In the Filter -> App
    // case this is a FilterAppWrite IRP.
    //

    PVOID                   pCompletionContext;


} UX_FILTER_WRITE_TRACKER, *PUX_FILTER_WRITE_TRACKER;


//
// UL_SSL_INFORMATION
//
// This structure is an internal representation of SSL
// connection and certificate information attached
// to the UL_CONNECTION.
//

typedef struct _UL_SSL_INFORMATION
{
    //
    // Standard information.
    //
    USHORT  ServerCertKeySize;
    USHORT  ConnectionKeySize;
    PUCHAR  pServerCertIssuer;
    ULONG   ServerCertIssuerSize;
    PUCHAR  pServerCertSubject;
    ULONG   ServerCertSubjectSize;

    PUCHAR  pServerCertData;

    //
    // Client certificate information.
    //
    ULONG   CertEncodedSize;
    PUCHAR  pCertEncoded;
    ULONG   CertFlags;
    PVOID   Token;

    //
    // Flags
    //
    BOOLEAN SslRenegotiationFailed;
    BOOLEAN CertDeniedByMapper;

    //
    // Work item used to free Token in g_UlSystemProcess if capture fails.
    //
    UL_WORK_ITEM    WorkItem;

} UL_SSL_INFORMATION, *PUL_SSL_INFORMATION;

//
// A UX_FILTER_CONNECTION is a common wrapper that encapsulates filter
// related information for a client (UC_CONNECTION) or a server
// (UL_CONNECTION) entities.
//
typedef struct _UX_FILTER_CONNECTION
{
    ULONG                   Signature;
    PUL_FILTER_CHANNEL      pFilterChannel;
    BOOLEAN                 SecureConnection;
    HTTP_RAW_CONNECTION_ID  ConnectionId;
    LIST_ENTRY              ChannelEntry;

    //
    // Filtered connection state.
    // Synchronized by FilterConnLock.
    //
    UL_FILTER_CONN_STATE    ConnState;
    UX_FILTER_WRITE_QUEUE   AppToFiltQueue;
    UX_FILTER_WRITE_QUEUE   FiltToAppQueue;
    PIRP                    pReceiveCertIrp;

    //
    // Incoming transport data queue.
    // Synchronized by FilterConnLock.
    //
    ULONG                   TransportBytesNotTaken;
    LIST_ENTRY              RawReadIrpHead;
    BOOLEAN                 TdiReadPending;
    UL_WORK_ITEM            WorkItem;

    //
    // Pointers to the functions for holding the ref on the respective
    // connections
    //
    PUL_OPAQUE_ID_OBJECT_REFERENCE           pReferenceHandler;
    PUL_OPAQUE_ID_OBJECT_REFERENCE           pDereferenceHandler;
    PVOID                                    pConnectionContext;
    PUX_FILTER_CLOSE_CONNECTION              pCloseConnectionHandler;
    PUX_FILTER_SEND_RAW_DATA                 pSendRawDataHandler;
    PUX_FILTER_RECEIVE_RAW_DATA              pReceiveDataHandler;
    PUL_DATA_RECEIVE                         pDummyTdiReceiveHandler;
    PUX_FILTER_COMPUTE_RAW_CONNECTION_LENGTH pComputeRawConnectionLengthHandler;
    PUX_FILTER_GENERATE_RAW_CONNECTION_INFO  pGenerateRawConnectionInfoHandler;
    PUX_FILTER_SERVER_CERT_INDICATE          pServerCertIndicateHandler;
    PUX_FILTER_DISCONNECT_NOTIFICATION       pDisconnectNotificationHandler;

    //
    // Filter flags.
    //
    ULONG ConnectionDelivered   : 1;    // Uses TDI callback synch.
    ULONG SslInfoPresent        : 1;    // Uses FilterConnLock
    ULONG SslClientCertPresent  : 1;    // Uses FilterConnLock
    ULONG DrainAfterDisconnect  : 1;    // Uses FilterConnLock
    ULONG DisconnectNotified    : 1;    // Uses FilterConnLock
    ULONG DisconnectDelivered   : 1;    // Uses FilterConnLock

    //
    // SSL information.
    //
    UL_SSL_INFORMATION SslInfo;

    //
    // This should be the last entry in this struct to avoid confusing
    // !ulkd.ulconn when dealing with debug or retail versions of http.sys
    //
    UL_SPIN_LOCK            FilterConnLock;

} UX_FILTER_CONNECTION, *PUX_FILTER_CONNECTION;


//
// Client Filter Channel Hash Table macros
//

#define FILTER_CHANNEL_HASH_TABLE_SIZE    32 // (power of 2, used below)
#define L2_FILTER_CHANNEL_HASH_TABLE_SIZE 5  // Log_2(32)

//
// For the hash function, see Knuth's "Sorting and Searching"
// 0x9E3779B9 = floor((Golden Ratio) * 2^32)
//
#define FILTER_CHANNEL_HASH_FUNCTION(ptr)                                  \
((((ULONG)((ULONGLONG)(ptr) & (ULONGLONG)0xffffffff) * 0x9E3779B9) >>      \
 (32 - L2_FILTER_CHANNEL_HASH_TABLE_SIZE))                                 \
 & (FILTER_CHANNEL_HASH_TABLE_SIZE - 1))



//
// Function prototypes.
//

PUL_FILTER_CHANNEL
UlpFindFilterChannel(
    IN PWCHAR    pName,
    IN USHORT    NameLength,
    IN PEPROCESS pProcess
    );

NTSTATUS
UlpAddFilterChannel(
    IN PUL_FILTER_CHANNEL pChannel
    );

NTSTATUS
UlpCreateFilterChannel(
    IN PWCHAR pName,
    IN USHORT NameLength,
    IN PACCESS_STATE pAccessState,
    OUT PUL_FILTER_CHANNEL *ppFilterChannel
    );

PUL_FILTER_PROCESS
UlpCreateFilterProcess(
    IN PUL_FILTER_CHANNEL pChannel
    );

NTSTATUS
UlpValidateFilterCall(
    IN PUL_FILTER_PROCESS pFilterProcess,
    IN PUX_FILTER_CONNECTION pConnection
    );

VOID
UlpRestartFilterClose(
    IN PVOID pContext,
    IN NTSTATUS Status,
    IN ULONG_PTR Information
    );

VOID
UlpRestartFilterRawRead(
    IN PVOID pContext,
    IN NTSTATUS Status,
    IN ULONG_PTR Information
    );

VOID
UlpRestartFilterRawWrite(
    IN PVOID pContext,
    IN NTSTATUS Status,
    IN ULONG_PTR Information
    );

VOID
UlpRestartFilterAppWrite(
    IN PVOID pContext,
    IN NTSTATUS Status,
    IN ULONG_PTR Information
    );

VOID
UlpRestartFilterSendHandler(
    IN PVOID pContext,
    IN NTSTATUS Status,
    IN ULONG_PTR Information
    );

VOID
UlpCancelFilterAccept(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    );

VOID
UlpCancelFilterAcceptWorker(
    IN PUL_WORK_ITEM pWorkItem
    );

VOID
UlpCancelFilterRawRead(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    );

VOID
UlpCancelFilterAppRead(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    );

VOID
UlpCancelFilterAppWrite(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    );

VOID
UlpCancelReceiveClientCert(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    );

NTSTATUS
UlpFilterAppWriteStream(
    IN PUX_FILTER_CONNECTION pConnection,
    IN PIRP pIrp,
    IN PMDL pMdlData,
    IN PUCHAR pDataBuffer,
    IN ULONG DataBufferSize,
    OUT PULONG pTakenLength
    );

NTSTATUS
UlpEnqueueFilterAppWrite(
    IN PUX_FILTER_WRITE_TRACKER pTracker
    );

NTSTATUS
UlpDequeueFilterAppWrite(
    IN PUX_FILTER_WRITE_TRACKER pTracker
    );

NTSTATUS
UlpCaptureSslInfo(
    IN KPROCESSOR_MODE PreviousMode,
    IN PHTTP_SSL_INFO pHttpSslInfo,
    IN ULONG HttpSslInfoSize,
    OUT PUL_SSL_INFORMATION pUlSslInfo,
    OUT PULONG pTakenLength
    );

NTSTATUS
UlpCaptureSslClientCert(
    IN KPROCESSOR_MODE PreviousMode,
    IN PHTTP_SSL_CLIENT_CERT_INFO pCertInfo,
    IN ULONG SslCertInfoSize,
    OUT PUL_SSL_INFORMATION pUlSslInfo,
    OUT PULONG pTakenLength
    );

NTSTATUS
UlpAddSslInfoToConnection(
    IN PUX_FILTER_CONNECTION pConnection,
    IN PUL_SSL_INFORMATION pSslInfo
    );

VOID
UlpFreeSslInformationWorker(
    IN PUL_WORK_ITEM pWorkItem
    );

NTSTATUS
UlpAddSslClientCertToConnection(
    IN PUX_FILTER_CONNECTION pConnection,
    IN PUL_SSL_INFORMATION pSslInfo
    );

VOID
UlpAddSslClientCertToConnectionWorker(
    IN PUL_WORK_ITEM pWorkItem
    );

NTSTATUS
UlpGetSslClientCert(
    IN PUX_FILTER_CONNECTION pConnection,
    IN PEPROCESS pProcess,
    IN ULONG BufferSize,
    IN PUCHAR pUserBuffer OPTIONAL,
    OUT PUCHAR pBuffer OPTIONAL,
    OUT PHANDLE pMappedToken OPTIONAL,
    OUT PULONG pBytesCopied OPTIONAL
    );

PIRP
UlpPopAcceptIrp(
    IN PUL_FILTER_CHANNEL pFilterChannel,
    OUT PUL_FILTER_PROCESS * ppFilterProcess
    );

PIRP
UlpPopAcceptIrpFromProcess(
    IN PUL_FILTER_PROCESS pProcess
    );

VOID
UlpCompleteAcceptIrp(
    IN PIRP pIrp,
    IN PUX_FILTER_CONNECTION pConnection,
    IN PVOID pBuffer OPTIONAL,
    IN ULONG  IndicatedLength,
    OUT PULONG  pTakenLength OPTIONAL
    );

NTSTATUS
UlpCompleteAppReadIrp(
    IN PUX_FILTER_CONNECTION pConnection,
    IN HTTP_FILTER_BUFFER_TYPE BufferType,
    IN PUL_COMPLETION_ROUTINE pCompletionRoutine,
    IN PVOID pCompletionContext
    );

NTSTATUS
UlpCompleteReceiveClientCertIrp(
    IN PUX_FILTER_CONNECTION pConnection,
    IN PEPROCESS pProcess,
    IN PIRP pIrp
    );

NTSTATUS
UlpDuplicateHandle(
    IN PEPROCESS SourceProcess,
    IN HANDLE SourceHandle,
    IN PEPROCESS TargetProcess,
    OUT PHANDLE pTargetHandle,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG HandleAttributes,
    IN ULONG Options,
    IN KPROCESSOR_MODE PreviousMode
    );


//
// Functions for handling the raw read queue and incoming
// network data.
//

NTSTATUS
UxpQueueRawReadIrp(
    IN PUX_FILTER_CONNECTION pConnection,
    IN PIRP pIrp
    );

PIRP
UxpDequeueRawReadIrp(
    IN PUX_FILTER_CONNECTION pConnection
    );

VOID
UxpCancelAllQueuedRawReads(
    IN PUX_FILTER_CONNECTION pConnection
    );

VOID
UxpSetBytesNotTaken(
    IN PUX_FILTER_CONNECTION pConnection,
    IN ULONG  TransportBytesNotTaken
    );

NTSTATUS
UxpProcessIndicatedData(
    IN PUX_FILTER_CONNECTION pConnection,
    IN PVOID pBuffer,
    IN ULONG  IndicatedLength,
    OUT PULONG  pTakenLength
    );

VOID
UxpProcessRawReadQueue(
    IN PUX_FILTER_CONNECTION pConnection
    );

VOID
UxpProcessRawReadQueueWorker(
    IN PUL_WORK_ITEM pWorkItem
    );

VOID
UxpRestartProcessRawReadQueue(
    IN PVOID pContext,
    IN NTSTATUS Status,
    IN ULONG_PTR Information
    );

//
// Functions for manipulating a UX_FILTER_WRITE_QUEUE.
//

VOID
UxpInitializeFilterWriteQueue(
    IN PUX_FILTER_WRITE_QUEUE pWriteQueue,
    IN PUX_FILTER_WRITE_ENQUEUE pWriteEnqueueRoutine,
    IN PUX_FILTER_WRITE_DEQUEUE pWriteDequeueRoutine
    );

NTSTATUS
UxpQueueFilterWrite(
    IN PUX_FILTER_CONNECTION pConnection,
    IN PUX_FILTER_WRITE_QUEUE pWriteQueue,
    IN PUX_FILTER_WRITE_TRACKER pTracker
    );

NTSTATUS
UxpRequeueFilterWrite(
    IN PUX_FILTER_WRITE_QUEUE pWriteQueue,
    IN PUX_FILTER_WRITE_TRACKER pTracker
    );

PUX_FILTER_WRITE_TRACKER
UxpDequeueFilterWrite(
    IN PUX_FILTER_WRITE_QUEUE pWriteQueue
    );

NTSTATUS
UxpCopyQueuedWriteData(
    IN PUX_FILTER_WRITE_QUEUE pWriteQueue,
    OUT PHTTP_FILTER_BUFFER_TYPE pBufferType,
    OUT PUCHAR pBuffer,
    IN ULONG BufferLength,
    OUT PUX_FILTER_WRITE_TRACKER * pWriteTracker,
    OUT PULONG pBytesCopied
    );

VOID
UxpCompleteQueuedWrite(
    IN NTSTATUS Status,
    IN PUX_FILTER_WRITE_QUEUE pWriteQueue,
    IN PUX_FILTER_WRITE_TRACKER pTracker
    );

NTSTATUS
UxpQueueFilterRead(
    IN PUX_FILTER_CONNECTION pConnection,
    IN PUX_FILTER_WRITE_QUEUE pWriteQueue,
    IN PIRP pReadIrp,
    IN PDRIVER_CANCEL pCancelRoutine
    );

PIRP
UxpDequeueFilterRead(
    IN PUX_FILTER_WRITE_QUEUE pWriteQueue
    );

NTSTATUS
UxpCopyToQueuedRead(
    IN PUX_FILTER_WRITE_QUEUE pWriteQueue,
    IN HTTP_FILTER_BUFFER_TYPE BufferType,
    IN PMDL pMdlChain,
    IN ULONG  Length,
    OUT PMDL * ppCurrentMdl,
    OUT PULONG  pMdlOffset,
    OUT PULONG  pBytesCopied
    );

VOID
UxpCancelAllQueuedIo(
    IN PUX_FILTER_WRITE_QUEUE pWriteQueue
    );

//
// Filter write queue tracker allocators.
//

PUX_FILTER_WRITE_TRACKER
UxpCreateFilterWriteTracker(
    IN HTTP_FILTER_BUFFER_TYPE BufferType,
    IN PMDL pMdlChain,
    IN ULONG  MdlOffset,
    IN ULONG  TotalBytes,
    IN ULONG  BytesCopied,
    IN PUL_COMPLETION_ROUTINE pCompletionRoutine,
    IN PVOID pContext
    );

VOID
UxpDeleteFilterWriteTracker(
    IN PUX_FILTER_WRITE_TRACKER pTracker
    );

PVOID
UxpAllocateFilterWriteTrackerPool(
    IN POOL_TYPE PoolType,
    IN SIZE_T ByteLength,
    IN ULONG Tag
    );

VOID
UxpFreeFilterWriteTrackerPool(
    IN PVOID pBuffer
    );

VOID
UlpRestartFilterDrainIndicatedData(
    IN PVOID pContext,
    IN NTSTATUS Status,
    IN ULONG_PTR Information
    );


#endif  // _FILTERP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\hash.c ===
/*++

Copyright (c) 1998-2002 Microsoft Corporation

Module Name:

    hash.c

Abstract:

    Contains the HTTP response cache hash table logic.

Author:

    Alex Chen (alexch)      28-Mar-2001

Revision History:

    George V. Reilly (GeorgeRe) 09-May-2001
        Cleaned up and tuned up

--*/

#include    "precomp.h"
#include    "hashp.h"


//
// Interlocked ops for pointer-sized data - used to update g_UlHashTablePages
//

#ifdef _WIN64
#define UlpInterlockedAddPointer InterlockedExchangeAdd64
#else
#define UlpInterlockedAddPointer InterlockedExchangeAdd
#endif // _WIN64

// Global Variables

ULONG   g_UlHashTableBits;
ULONG   g_UlHashTableSize;
ULONG   g_UlHashTableMask;
ULONG   g_UlHashIndexShift;

//
// Total Pages used by all cache entries in the hash table
//
LONG_PTR    g_UlHashTablePages;

//
// Optimization: Use the space of (g_UlCacheLineSize - sizeof (HASHBUCKET))
// to store a few records (Hash, pUriCacheEntry) such that we can scan the
// records first before jumping to the single list for searching.
//
// g_UlNumOfHashUriKeys: The number of stored records in the space.
//

ULONG   g_UlNumOfHashUriKeys;

#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, UlpGetHashTableSize )
#pragma alloc_text( PAGE, UlInitializeHashTable )
#pragma alloc_text( PAGE, UlpHashBucketIsCompact )
#pragma alloc_text( PAGE, UlTerminateHashTable )
#pragma alloc_text( PAGE, UlGetFromHashTable )
#pragma alloc_text( PAGE, UlDeleteFromHashTable )
#pragma alloc_text( PAGE, UlAddToHashTable )
#pragma alloc_text( PAGE, UlpFilterFlushHashBucket )
#pragma alloc_text( PAGE, UlFilterFlushHashTable )
#pragma alloc_text( PAGE, UlpClearHashBucket )
#pragma alloc_text( PAGE, UlClearHashTable )
#pragma alloc_text( PAGE, UlGetHashTablePages )
#endif  // ALLOC_PRAGMA

#if 0
NOT PAGEABLE -- 
#endif


/***************************************************************************++

Routine Description:

    This routine determine the hash table size according to
    (1) user-define value (reading from registry) or
    (2) system memory size estimation, if (1) is not defined

Arguments:

    HashTableBits   - The number of buckets is (1 << HashTableBits)

--***************************************************************************/
VOID
UlpGetHashTableSize(
    IN LONG     HashTableBits
    )
{

    // Each hashbucket is (1 << g_UlHashIndexShift) bytes long
    g_UlHashIndexShift = g_UlCacheLineBits;

    ASSERT(g_UlHashIndexShift < 10);

    //
    // HashTableBits is equal to DEFAULT_HASH_TABLE_BITS
    // if it is not defined in the registry
    //

    if (HashTableBits != DEFAULT_HASH_TABLE_BITS)
    {
        // Use the registry value

        // We must check for reasonable values, so that a
        // malicious or careless user doesn't cause us to eat up
        // all of (Non)PagedPool.

        if (HashTableBits < 3)
        {
            // Use a minimum of 8 buckets

            HashTableBits = 3;
        }
        else if ((ULONG) HashTableBits > 24 - g_UlHashIndexShift)
        {
            // Never use more than 16MB for the hash table.
            // Assuming g_UlHashIndexShift = 6 (CacheLine = 64 bytes),
            // that's 256K buckets.

            HashTableBits = 24 - g_UlHashIndexShift;
        }

        g_UlHashTableBits = HashTableBits;
    }
    else
    {
#if DBG
        //
        // Default to a relatively small number of buckets so that the
        // assertions don't consume an inordinate amount of time whenever
        // we flush the hash table.
        //

        g_UlHashTableBits = 9;

#else // !DBG
        
        //
        // Registry value REGISTRY_HASH_TABLE_BITS is not defined,
        // use system memory size estimation instead
        //

        if (g_UlTotalPhysicalMemMB <= 128)
        {
            // Small machine. Hash Table Size: 512 buckets

            g_UlHashTableBits = 9;
        }
        else if (g_UlTotalPhysicalMemMB <= 512)
        {
            // Medium machine. Hash Table Size: 8K buckets

            g_UlHashTableBits = 13;
        }
        else
        {
            // Large machine. Hash Table Size: 64K buckets

            g_UlHashTableBits = 16;
        }
#endif // !DBG
    }

#ifdef HASH_TEST
    g_UlHashTableBits = 3;
#endif

    ASSERT(3 <= g_UlHashTableBits  &&  g_UlHashTableBits <= 20);

    g_UlHashTableSize = (1 << g_UlHashTableBits);
    g_UlHashTableMask = g_UlHashTableSize - 1;
} // UlpGetHashTableSize



/***************************************************************************++

Routine Description:

    Validates that a locked HASHBUCKET is `compact'. If there are less than
    g_UlNumOfHashUriKeys entries in a bucket, they are clumped together at
    the beginning of the records array, and all the empty slots are at the
    end. All empty slots must have Hash == HASH_INVALID_SIGNATURE and
    pUriCacheEntry == NULL. Conversely, all the non-empty slots at the
    beginning of the array must have point to valid UL_URI_CACHE_ENTRYs
    and must have Hash == correct hash signature, which cannot be
    HASH_INVALID_SIGNATURE. If the single list pointer is non-NULL, then
    the records array must be full.

    If the HASHBUCKET is compact, then we can abort a search for a key as
    soon as we see HASH_INVALID_SIGNATURE. This invariant speeds up Find and
    Insert at the cost of making Delete and Flush a little more
    complex. Since we expect to do a lot more Finds than Deletes or Inserts,
    this is an acceptable tradeoff.

    Storing hash signatures means that we have a very fast test that
    eliminates almost all false positives. We very seldom find two keys
    that have matching hash signatures, but different strings.

Arguments:

    pBucket             - The hash bucket

--***************************************************************************/
BOOLEAN
UlpHashBucketIsCompact(
    IN const PHASHBUCKET pBucket)
{
#ifdef HASH_FULL_ASSERTS

    PUL_URI_CACHE_ENTRY pUriCacheEntry;
    PUL_URI_CACHE_ENTRY pPrevUriCacheEntry = NULL;
    PHASHURIKEY pHashUriKey = UlpHashTableUriKeyFromBucket(pBucket);
    ULONG i, j, Entries = 0;

    // First, validate the records array
    
    for (i = 0; i < g_UlNumOfHashUriKeys; i++)
    {
        ULONG Hash = pHashUriKey[i].Hash;
        
        if (HASH_INVALID_SIGNATURE == Hash)
        {
            // There are no more valid entries in the records array
            // and no singly linked list
            ASSERT(NULL == pBucket->pUriCacheEntry);
            pPrevUriCacheEntry = NULL;

            for (j = i; j < g_UlNumOfHashUriKeys; j++)
            {
                ASSERT(NULL == pHashUriKey[j].pUriCacheEntry);
                ASSERT(HASH_INVALID_SIGNATURE == pHashUriKey[j].Hash);
            }
        }
        else
        {
            // non-empty slot
            ++Entries;
            pUriCacheEntry = pHashUriKey[i].pUriCacheEntry;

            ASSERT(IS_VALID_URI_CACHE_ENTRY(pUriCacheEntry));
            ASSERT(pUriCacheEntry->Cached);
            ASSERT(Hash == pUriCacheEntry->UriKey.Hash);
            ASSERT(Hash == HashRandomizeBits(
                               HashStringNoCaseW(
                                   pUriCacheEntry->UriKey.pUri,
                                   0
                                   )));

            ASSERT(pPrevUriCacheEntry != pUriCacheEntry);
            pPrevUriCacheEntry = pUriCacheEntry;
        }
    }

    // Next, validate the singly linked list

    for (pUriCacheEntry = pBucket->pUriCacheEntry;
         NULL != pUriCacheEntry;
         pUriCacheEntry
             = (PUL_URI_CACHE_ENTRY) pUriCacheEntry->BucketEntry.Next)
    {
        ++Entries;

        ASSERT(IS_VALID_URI_CACHE_ENTRY(pUriCacheEntry));
        ASSERT(pUriCacheEntry->Cached);

        ASSERT(pUriCacheEntry->UriKey.Hash
                    == HashRandomizeBits(
                               HashStringNoCaseW(
                                   pUriCacheEntry->UriKey.pUri,
                                   0
                                   )));

        ASSERT(pPrevUriCacheEntry != pUriCacheEntry);
        pPrevUriCacheEntry = pUriCacheEntry;
    }

    ASSERT(Entries == pBucket->Entries);
    
#else  // !HASH_FULL_ASSERTS
    UNREFERENCED_PARAMETER(pBucket);
#endif // !HASH_FULL_ASSERTS

    return TRUE;
} // UlpHashBucketIsCompact



#ifdef HASH_TEST

NTSYSAPI
NTSTATUS
NTAPI
ZwYieldExecution (
    VOID
    );

/***************************************************************************++

Routine Description:

    Randomly delay for a long time. Exercises the yield logic in RWSPINLOCK

Arguments:

    None

Returns:

    Nothing
    
--***************************************************************************/
VOID
UlpRandomlyBlockHashTable()
{
    static LONG Count = 0;

    if ((++Count & 0x3F) == 0)
    {
        DbgPrint("UlpRandomlyBlockHashTable: starting delay\n");

#if 1
        LARGE_INTEGER Interval;

        Interval.QuadPart = - C_NS_TICKS_PER_SEC * 3;

        KeDelayExecutionThread(KernelMode, FALSE, &Interval);
#elif 0
        ZwYieldExecution();
#else
        // An effort to make sure the optimizer doesn't omit the inner loop
        
        volatile ULONG* pJunk = &g_UlHashTableBits;
        const ULONG Junk = *pJunk;
        LONG i;

        for (i = 0;  i < 10 * 1000 * 1000; ++i)
        {
            // Won't happen
            if (*pJunk != Junk)
                break;
        }
#endif

        DbgPrint("UlpRandomlyBlockHashTable: finishing delay\n");
    }
    
} // UlpRandomlyBlockHashTable

# define RANDOMLY_BLOCK_HASHTABLE() UlpRandomlyBlockHashTable()
#else  // !HASH_TEST
# define RANDOMLY_BLOCK_HASHTABLE() NOP_FUNCTION
#endif // !HASH_TEST



/***************************************************************************++

Routine Description:

    This routine initialize the hash table

Arguments:

    pHashTable      - The hash table
    PoolType        - Specifies the type of pool memory to allocate
    HashTableBits   - The number of buckets is (1 << HashTableBits)

Returns:
    NTSTATUS        - STATUS_SUCCESS or STATUS_NO_MEMORY
    
--***************************************************************************/
NTSTATUS
UlInitializeHashTable(
    IN OUT PHASHTABLE  pHashTable,
    IN     POOL_TYPE   PoolType,
    IN     LONG        HashTableBits
    )
{
    ULONG i;
    ULONG_PTR CacheLineMask, CacheLineSize = g_UlCacheLineSize;

    //
    // First, get the hash table size from the registry.
    // If not defined in the registry, determine the hash table
    // size by the system memory size
    //

    UlpGetHashTableSize(HashTableBits);

#ifdef HASH_TEST
    CacheLineSize = 64;
    g_UlHashIndexShift = 6;
#endif

    CacheLineMask = CacheLineSize - 1;

    ASSERT((CacheLineSize & CacheLineMask) == 0); // power of 2
    ASSERT(CacheLineSize == (1U << g_UlHashIndexShift));

    pHashTable->Signature = UL_HASH_TABLE_POOL_TAG;
    pHashTable->PoolType = PoolType;

    pHashTable->NumberOfBytes = g_UlHashTableSize * CacheLineSize;

    ASSERT(CacheLineSize > sizeof(HASHBUCKET));
    
    // number of keys stored in the initial clump
    g_UlNumOfHashUriKeys = (((ULONG) CacheLineSize - sizeof (HASHBUCKET))
                                / sizeof(HASHURIKEY));
    pHashTable->pBuckets = NULL;

#ifdef HASH_TEST
    g_UlNumOfHashUriKeys = 3;
#endif

    ASSERT((sizeof(HASHBUCKET)  +  g_UlNumOfHashUriKeys * sizeof(HASHURIKEY))
                <= (1U << g_UlHashIndexShift));

    // Allocate the memory

    pHashTable->pAllocMem
        = (PHASHBUCKET) UL_ALLOCATE_POOL(
                                PoolType,
                                pHashTable->NumberOfBytes + CacheLineMask,
                                UL_HASH_TABLE_POOL_TAG
                                );

    if (NULL == pHashTable->pAllocMem)
    {
        pHashTable->Signature = MAKE_FREE_TAG(UL_HASH_TABLE_POOL_TAG);
        return STATUS_NO_MEMORY;
    }

    // Initialize cache entry page count

    g_UlHashTablePages = 0;

    // Align the memory the cache line size boundary

    pHashTable->pBuckets
        = (PHASHBUCKET)((((ULONG_PTR)(pHashTable->pAllocMem)) + CacheLineMask)
                            & ~CacheLineMask);

    // Initialize each bucket and padding array elements

    for (i = 0;  i < g_UlHashTableSize;  i++)
    {
        PHASHBUCKET pBucket = UlpHashTableIndexedBucket(pHashTable, i);
        PHASHURIKEY pHashUriKey;
        ULONG       j;

        UlInitializeRWSpinLock(&pBucket->RWSpinLock);

        pBucket->pUriCacheEntry = NULL;

        pBucket->Entries = 0;

        pHashUriKey = UlpHashTableUriKeyFromBucket(pBucket);

        for (j = 0; j < g_UlNumOfHashUriKeys ;j++)
        {
            pHashUriKey[j].Hash           = HASH_INVALID_SIGNATURE;
            pHashUriKey[j].pUriCacheEntry = NULL;
        }

        ASSERT(UlpHashBucketIsCompact(pBucket));
    }

    return STATUS_SUCCESS;
} // UlInitializeHashTable



/***************************************************************************++

Routine Description:

    This routine terminates the hash table
    (flush all entries and free the table).

Arguments:

    pHashTable      - The hash table

--***************************************************************************/
VOID
UlTerminateHashTable(
    IN PHASHTABLE  pHashTable
    )
{
    if ( pHashTable->pAllocMem != NULL )
    {
        ASSERT(IS_VALID_HASHTABLE(pHashTable));

        // Clear the hash table (delete all entries)

        UlClearHashTable(pHashTable);

        // Free the hash table buckets

        UL_FREE_POOL(pHashTable->pAllocMem, UL_HASH_TABLE_POOL_TAG);

        pHashTable->Signature = MAKE_FREE_TAG(UL_HASH_TABLE_POOL_TAG);
        pHashTable->pAllocMem = pHashTable->pBuckets = NULL;

        ASSERT( g_UlHashTablePages == 0 );
    }
} // UlTerminateHashTable


/***************************************************************************++

Routine Description:

    This routine does a cache lookup on a hash table
    to see if there is a valid entry corresponding to the request key.
    Increment the reference counter of the entry by 1 inside the lock
    protection to ensure this entry will be still alive after returning
    this entry back.

Arguments:

    pHashTable          - The hash table
    pUriKey             - the search key

Returns:

    PUL_URI_CACHE_ENTRY - pointer to entry or NULL

--***************************************************************************/
PUL_URI_CACHE_ENTRY
UlGetFromHashTable(
    IN PHASHTABLE           pHashTable,
    IN PURI_SEARCH_KEY      pSearchKey  
    )
{
    PUL_URI_CACHE_ENTRY     pUriCacheEntry;
    PHASHBUCKET             pBucket;
    PHASHURIKEY             pHashUriKey;
    ULONG                   i;
    ULONG                   SearchKeyHash;
    PURI_KEY                pKey;
    PEX_URI_KEY             pExKey;   

    HASH_PAGED_CODE(pHashTable);
    ASSERT(IS_VALID_HASHTABLE(pHashTable));
    ASSERT(IS_VALID_URI_SEARCH_KEY(pSearchKey));

    // Identify what type of search key has been passed.
    
    if (pSearchKey->Type == UriKeyTypeExtended)
    {
        SearchKeyHash = pSearchKey->ExKey.Hash;
        pExKey        = &pSearchKey->ExKey;
        pKey          = NULL;
    }
    else
    {
        ASSERT(pSearchKey->Type == UriKeyTypeNormal);
        
        SearchKeyHash = pSearchKey->Key.Hash;
        pExKey        = NULL;
        pKey          = &pSearchKey->Key;
    }

    pBucket = UlpHashTableBucketFromUriKeyHash(pHashTable, SearchKeyHash);

    UlAcquireRWSpinLockShared(&pBucket->RWSpinLock);

    RANDOMLY_BLOCK_HASHTABLE();

    ASSERT(UlpHashBucketIsCompact(pBucket));

    pHashUriKey = UlpHashTableUriKeyFromBucket(pBucket);

    // Scan the records array first

    for (i = 0; i < g_UlNumOfHashUriKeys; i++)
    {
        ULONG Hash = pHashUriKey[i].Hash;
        
        if (HASH_INVALID_SIGNATURE == Hash)
        {
            // There are no more valid entries in the bucket
            ASSERT(NULL == pBucket->pUriCacheEntry);
            ASSERT(NULL == pHashUriKey[i].pUriCacheEntry);

            pUriCacheEntry = NULL;
            goto unlock;
        }

        if (Hash == SearchKeyHash)
        {            
            pUriCacheEntry = pHashUriKey[i].pUriCacheEntry;

            ASSERT(NULL != pUriCacheEntry);

            if (pExKey)
            {
                ASSERT(pKey == NULL);
                
                if(UlpEqualUriKeysEx(pExKey, &pUriCacheEntry->UriKey))
                {
                    goto addref;
                }
            }
            else
            {
                if(UlpEqualUriKeys(pKey, &pUriCacheEntry->UriKey))
                {
                    goto addref;
                }
            }
        }
    }

    ASSERT(i == g_UlNumOfHashUriKeys);

    // Jump to the single list for searching

    for (pUriCacheEntry = pBucket->pUriCacheEntry;
         NULL != pUriCacheEntry;
         pUriCacheEntry
             = (PUL_URI_CACHE_ENTRY) pUriCacheEntry->BucketEntry.Next)
    {
        if (pUriCacheEntry->UriKey.Hash == SearchKeyHash)            
        {
            if (pExKey)
            {
                ASSERT(pKey == NULL);
                
                if(UlpEqualUriKeysEx(pExKey, &pUriCacheEntry->UriKey))
                {
                    goto addref;
                }
            }
            else
            {
                if(UlpEqualUriKeys(pKey, &pUriCacheEntry->UriKey))
                {
                    goto addref;
                }
            }
        }        
    }

    // Not found

    ASSERT(NULL == pUriCacheEntry);

    goto unlock;

  addref:
    ASSERT(NULL != pUriCacheEntry);

    REFERENCE_URI_CACHE_ENTRY(pUriCacheEntry, CHECKOUT);

  unlock:
    ASSERT(UlpHashBucketIsCompact(pBucket));
    
    UlReleaseRWSpinLockShared(&pBucket->RWSpinLock);

    return pUriCacheEntry;

} // UlGetFromHashTable


/***************************************************************************++

Routine Description:

    This routine does a cache lookup on a hash table
    to see if there is a valid entry corresponding to the request URI,
    if found, delete this entry.  However, increment the reference counter
    of the entry by 1 insde the lock protection to ensure this entry will be
    still alive after returning this entry back.

Arguments:

    pHashTable          - The hash table
    pUriKey             - the search key
    pProcess            - The app pool process that is requesting the delete

Returns:

    PUL_URI_CACHE_ENTRY - pointer to entry removed from table or NULL

--***************************************************************************/
PUL_URI_CACHE_ENTRY
UlDeleteFromHashTable(
    IN PHASHTABLE           pHashTable,
    IN PURI_KEY             pUriKey,
    IN PUL_APP_POOL_PROCESS pProcess
    )
{
    PUL_URI_CACHE_ENTRY     pUriCacheEntry;
    PUL_URI_CACHE_ENTRY     PrevUriCacheEntry;
    PHASHBUCKET             pBucket;
    PHASHURIKEY             pHashUriKey;
    ULONG                   i;
    LONG_PTR                UriCacheEntryPages;

    HASH_PAGED_CODE(pHashTable);
    ASSERT(IS_VALID_HASHTABLE(pHashTable));

    pBucket = UlpHashTableBucketFromUriKeyHash(pHashTable, pUriKey->Hash);

    UlAcquireRWSpinLockExclusive(&pBucket->RWSpinLock);

    RANDOMLY_BLOCK_HASHTABLE();

    ASSERT(UlpHashBucketIsCompact(pBucket));

    pHashUriKey = UlpHashTableUriKeyFromBucket(pBucket);

    // Scan the records array first

    for (i = 0; i < g_UlNumOfHashUriKeys; i++)
    {
        ULONG Hash = pHashUriKey[i].Hash;

        if (HASH_INVALID_SIGNATURE == Hash)
        {
            ASSERT(NULL == pBucket->pUriCacheEntry);
            ASSERT(NULL == pHashUriKey[i].pUriCacheEntry);

            pUriCacheEntry = NULL;
            goto unlock;
        }

        if (Hash == pUriKey->Hash)
        {
            pUriCacheEntry = pHashUriKey[i].pUriCacheEntry;

            ASSERT(NULL != pUriCacheEntry);

            if (pUriCacheEntry->pProcess == pProcess && 
                UlpEqualUriKeys(&pUriCacheEntry->UriKey, pUriKey))
            {
                --pBucket->Entries;

                if (pBucket->pUriCacheEntry)
                {
                    // If there exists an entry in the single list,
                    // move it to the array

                    pHashUriKey[i].Hash
                        = pBucket->pUriCacheEntry->UriKey.Hash;

                    pHashUriKey[i].pUriCacheEntry = pBucket->pUriCacheEntry;

                    pBucket->pUriCacheEntry
                        = (PUL_URI_CACHE_ENTRY)
                                pBucket->pUriCacheEntry->BucketEntry.Next;
                }
                else
                {
                    // if this is not the last entry in the records array,
                    // move the last entry to this slot
                    ULONG j;

                    for (j = g_UlNumOfHashUriKeys; --j >= i; )
                    {
                        if (NULL != pHashUriKey[j].pUriCacheEntry)
                        {
                            ASSERT(HASH_INVALID_SIGNATURE
                                   != pHashUriKey[j].Hash);

                            ASSERT(j >= i);

                            pHashUriKey[i].Hash = pHashUriKey[j].Hash;
                            pHashUriKey[i].pUriCacheEntry
                                = pHashUriKey[j].pUriCacheEntry;

                            // Zap the last entry. Correct even if j == i
                            pHashUriKey[j].Hash = HASH_INVALID_SIGNATURE;
                            pHashUriKey[j].pUriCacheEntry = NULL;

                            goto unlock;
                        }
                        else
                        {
                            ASSERT(HASH_INVALID_SIGNATURE
                                   == pHashUriKey[j].Hash);
                        }
                    }

                    // We can't get here, since pHashUriKey[i] should
                    // have terminated the loop even if there wasn't
                    // any non-empty slot following it.
                    ASSERT(! "Overshot the deleted entry");
                }

                goto unlock;
            }
        }
    }

    ASSERT(i == g_UlNumOfHashUriKeys);
    
    // Jump to the single list for searching

    pUriCacheEntry = pBucket->pUriCacheEntry;

    PrevUriCacheEntry = NULL;

    while (NULL != pUriCacheEntry)
    {
        if (pUriCacheEntry->pProcess == pProcess &&
            pUriCacheEntry->UriKey.Hash == pUriKey->Hash &&  
            UlpEqualUriKeys(&pUriCacheEntry->UriKey, pUriKey))
        {
            if (PrevUriCacheEntry == NULL)
            {
                // Delete First Entry
                
                pBucket->pUriCacheEntry
                    = (PUL_URI_CACHE_ENTRY) pUriCacheEntry->BucketEntry.Next;
                
            }
            else
            {
                PrevUriCacheEntry->BucketEntry.Next
                    = pUriCacheEntry->BucketEntry.Next;
            }
            
            --pBucket->Entries;

            goto unlock;
        }
        
        PrevUriCacheEntry = pUriCacheEntry;
        pUriCacheEntry
            = (PUL_URI_CACHE_ENTRY) pUriCacheEntry->BucketEntry.Next;
    }

    // Not found

    ASSERT(NULL == pUriCacheEntry);

  unlock:
    ASSERT((LONG) pBucket->Entries >= 0);
    ASSERT(UlpHashBucketIsCompact(pBucket));

    UlReleaseRWSpinLockExclusive(&pBucket->RWSpinLock);

    if(pUriCacheEntry != NULL) {
        UriCacheEntryPages = pUriCacheEntry->NumPages;
        UlpInterlockedAddPointer( &g_UlHashTablePages, -UriCacheEntryPages );
    }

    return pUriCacheEntry;

} // UlDeleteFromHashTable



/***************************************************************************++

Routine Description:

    This routine does a cache lookup on a hash table
    to see if a given entry exists, if not found, add this entry to the
    hash table. Increment the reference counter of the entry by 1 insde the
    lock protection.

Arguments:

    pHashTable          - The hash table
    pUriCacheEntry      - the given entry

Returns

    NTSTATUS            - STATUS_SUCCESS or STATUS_DUPLICATE_NAME

--***************************************************************************/
NTSTATUS
UlAddToHashTable(
    IN PHASHTABLE           pHashTable,
    IN PUL_URI_CACHE_ENTRY  pUriCacheEntry
    )
{
    PUL_URI_CACHE_ENTRY     pTmpUriCacheEntry;
    PUL_URI_CACHE_ENTRY     pPrevUriCacheEntry;
    PUL_URI_CACHE_ENTRY     pDerefUriCacheEntry = NULL;
    PURI_KEY                pUriKey;
    PHASHBUCKET             pBucket;
    PHASHURIKEY             pHashUriKey;
    LONG                    EmptySlot = INVALID_SLOT_INDEX;
    NTSTATUS                Status = STATUS_SUCCESS;
    ULONG                   i;
    LONG_PTR                UriCacheEntryPages;

    HASH_PAGED_CODE(pHashTable);
    ASSERT(IS_VALID_HASHTABLE(pHashTable));

    ASSERT(IS_VALID_URI_CACHE_ENTRY(pUriCacheEntry));
    ASSERT(pUriCacheEntry->Cached);

    pUriKey = &pUriCacheEntry->UriKey;
    pBucket = UlpHashTableBucketFromUriKeyHash(pHashTable, pUriKey->Hash);

    UlAcquireRWSpinLockExclusive(&pBucket->RWSpinLock);

    RANDOMLY_BLOCK_HASHTABLE();

    ASSERT(UlpHashBucketIsCompact(pBucket));

    pHashUriKey = UlpHashTableUriKeyFromBucket(pBucket);

    // Scan the records array first

    for (i = 0; i < g_UlNumOfHashUriKeys; i++)
    {
        ULONG Hash = pHashUriKey[i].Hash;

        if (HASH_INVALID_SIGNATURE == Hash)
        {
            ASSERT(NULL == pBucket->pUriCacheEntry);
            ASSERT(NULL == pHashUriKey[i].pUriCacheEntry);

            EmptySlot = (LONG) i;
            goto insert;
        }

        if (Hash == pUriKey->Hash)
        {
            pTmpUriCacheEntry = pHashUriKey[i].pUriCacheEntry;

            ASSERT(NULL != pTmpUriCacheEntry);

            if (UlpEqualUriKeys(&pTmpUriCacheEntry->UriKey, pUriKey))
            {
                // Duplicate key exists. We will always overwrite the old entry
                // unless it was a response && the new entry is a fragment.

                if (IS_RESPONSE_CACHE_ENTRY(pUriCacheEntry) ||
                    IS_FRAGMENT_CACHE_ENTRY(pTmpUriCacheEntry))
                {
                    pHashUriKey[i].pUriCacheEntry = pUriCacheEntry;

                    UriCacheEntryPages = pUriCacheEntry->NumPages - pTmpUriCacheEntry->NumPages;
                    pDerefUriCacheEntry = pTmpUriCacheEntry;
                    REFERENCE_URI_CACHE_ENTRY(pUriCacheEntry, ADD);
                    UlpInterlockedAddPointer(&g_UlHashTablePages, UriCacheEntryPages );

                    Status = STATUS_SUCCESS;
                }
                else
                {
                    pUriCacheEntry->Cached = FALSE;
                    Status = STATUS_DUPLICATE_NAME;
                }

                goto unlock;
            }
        }
    }

    ASSERT(i == g_UlNumOfHashUriKeys);
    ASSERT(EmptySlot == INVALID_SLOT_INDEX);

    // Jump to the single list for searching

    pPrevUriCacheEntry = NULL;

    for (pTmpUriCacheEntry = pBucket->pUriCacheEntry;
         NULL != pTmpUriCacheEntry;
         pPrevUriCacheEntry = pTmpUriCacheEntry,
         pTmpUriCacheEntry
             = (PUL_URI_CACHE_ENTRY) pTmpUriCacheEntry->BucketEntry.Next)
    {
        if (pTmpUriCacheEntry->UriKey.Hash == pUriKey->Hash
            && UlpEqualUriKeys(&pTmpUriCacheEntry->UriKey, pUriKey))
        {
            // Duplicate key exists. We will always overwrite the old entry
            // unless it was a response && the new entry is a fragment.

            if (IS_RESPONSE_CACHE_ENTRY(pUriCacheEntry) ||
                IS_FRAGMENT_CACHE_ENTRY(pTmpUriCacheEntry))
            {
                pUriCacheEntry->BucketEntry.Next =
                    pTmpUriCacheEntry->BucketEntry.Next;

                if (NULL == pPrevUriCacheEntry)
                {
                    pBucket->pUriCacheEntry = pUriCacheEntry;
                }
                else
                {
                    pPrevUriCacheEntry->BucketEntry.Next =
                        (PSINGLE_LIST_ENTRY) pUriCacheEntry;
                }

                UriCacheEntryPages = pUriCacheEntry->NumPages - pTmpUriCacheEntry->NumPages;
                pDerefUriCacheEntry = pTmpUriCacheEntry;
                REFERENCE_URI_CACHE_ENTRY(pUriCacheEntry, ADD);
                UlpInterlockedAddPointer(&g_UlHashTablePages, UriCacheEntryPages );
                Status = STATUS_SUCCESS;
            }
            else
            {
                pUriCacheEntry->Cached = FALSE;
                Status = STATUS_DUPLICATE_NAME;
            }

            goto unlock;
        }
    }

  insert:
    //
    // Not found: no duplicate key in hash table
    //

    if (EmptySlot != INVALID_SLOT_INDEX)
    {
        ASSERT(0 <= EmptySlot  &&  EmptySlot < (LONG) g_UlNumOfHashUriKeys);

        // First, try to add this entry to the array if there is an empty slot.

        pHashUriKey[EmptySlot].Hash           = pUriKey->Hash;
        pHashUriKey[EmptySlot].pUriCacheEntry = pUriCacheEntry;
    }
    else
    {
        // Otherwise, add this entry to the head of the single list

        pUriCacheEntry->BucketEntry.Next
            = (PSINGLE_LIST_ENTRY) pBucket->pUriCacheEntry;

        pBucket->pUriCacheEntry = pUriCacheEntry;
    }

    REFERENCE_URI_CACHE_ENTRY(pUriCacheEntry, ADD);
    UlpInterlockedAddPointer( &g_UlHashTablePages,
                             pUriCacheEntry->NumPages );

    ASSERT((LONG) pBucket->Entries >= 0);

    ++pBucket->Entries;
    Status = STATUS_SUCCESS;

  unlock:
    ASSERT(UlpHashBucketIsCompact(pBucket));

    UlReleaseRWSpinLockExclusive(&pBucket->RWSpinLock);

    if (pDerefUriCacheEntry)
    {
        DEREFERENCE_URI_CACHE_ENTRY(pDerefUriCacheEntry, ADD);
    }

    return Status;

} // UlAddToHashTable



/***************************************************************************++

Routine Description:

    Removes entries based on a caller-specified filter. The caller
    provides a predicate function which takes a cache entry as a
    parameter. The function will be called for each item in the cache.
    If the function returns ULC_DELETE, the item will be removed.
    Otherwise the item will remain in the cache.

    All removals are done on a hash table bucket.
    Walk through all the entries under this bucket.

    Assume bucket exclusive lock is held.

Arguments:

    pBucket         - The hash table bucket
    pFilterRoutine  - A pointer to the filter function
    pContext        - A parameter to the filter function
    pDeletedCount   - A pointer to the number of deleted entries on this bucket
    bStop           - A pointer to a boolean variable returned to caller
                          (TRUE if the filter function asks for action stop)
--***************************************************************************/
BOOLEAN
UlpFilterFlushHashBucket(
    IN PHASHBUCKET          pBucket,
    IN PUL_URI_FILTER       pFilterRoutine,
    IN PVOID                pContext,
    OUT PULONG              pDeletedCount
    )
{
    PUL_URI_CACHE_ENTRY     pUriCacheEntry;
    PUL_URI_CACHE_ENTRY     pPrevUriCacheEntry;
    PUL_URI_CACHE_ENTRY     pTmpUriCacheEntry;
    UL_CACHE_PREDICATE      result;
    PHASHURIKEY             pHashUriKey;
    ULONG                   i;
    LONG                    LastSlot;
    BOOLEAN                 bStop = FALSE;
    LONG_PTR                UriCacheEntryPages;

    // Check if bucket exclusive lock is held

    ASSERT( UlRWSpinLockIsLockedExclusive(&pBucket->RWSpinLock) );
    ASSERT(UlpHashBucketIsCompact(pBucket));

    // Scan the single list first

    pUriCacheEntry = pBucket->pUriCacheEntry;
    pPrevUriCacheEntry = NULL;

    while (NULL != pUriCacheEntry)
    {
        BOOLEAN bDelete = FALSE;

        result = (*pFilterRoutine)(pUriCacheEntry, pContext);

        switch (result)
        {
            case ULC_ABORT:
                bStop = TRUE;
                goto end;

            case ULC_NO_ACTION:
                // nothing to do
                break;

            case ULC_DELETE:
            case ULC_DELETE_STOP:
            {
                 // Delete this entry
                bDelete = TRUE;

                ASSERT(pBucket->Entries > 0);
                --pBucket->Entries;

                pTmpUriCacheEntry = pUriCacheEntry;

                if (NULL == pPrevUriCacheEntry)
                {
                    // Delete First Entry

                    pBucket->pUriCacheEntry
                        = (PUL_URI_CACHE_ENTRY)
                                pUriCacheEntry->BucketEntry.Next;

                    pUriCacheEntry = pBucket->pUriCacheEntry;

                }
                else
                {
                    pPrevUriCacheEntry->BucketEntry.Next
                        = pUriCacheEntry->BucketEntry.Next;

                    pUriCacheEntry
                        = (PUL_URI_CACHE_ENTRY)
                                pPrevUriCacheEntry->BucketEntry.Next;
                }

                ASSERT(UlpHashBucketIsCompact(pBucket));

                UriCacheEntryPages = pTmpUriCacheEntry->NumPages;
                UlpInterlockedAddPointer( &g_UlHashTablePages, -UriCacheEntryPages );
                DEREFERENCE_URI_CACHE_ENTRY(pTmpUriCacheEntry, FILTER);

                ++(*pDeletedCount);

                if (result == ULC_DELETE_STOP)
                {
                    bStop = TRUE;
                    goto end;
                }

                break;
            }

            default:
                break;
        }

        if (!bDelete)
        {
            pPrevUriCacheEntry = pUriCacheEntry;

            pUriCacheEntry
                = (PUL_URI_CACHE_ENTRY) pUriCacheEntry->BucketEntry.Next;
        }
    }

    pHashUriKey = UlpHashTableUriKeyFromBucket(pBucket);

    //
    // Now, scan the records array.
    //
    // Because we keep the records array compact, we need to keep
    // track of the last valid slot, so that we can move its contents
    // to the slot that's being deleted.
    //

    LastSlot = INVALID_SLOT_INDEX;

    if (NULL == pBucket->pUriCacheEntry)
    {
        for (i = g_UlNumOfHashUriKeys; i-- > 0; )
        {
            if (NULL != pHashUriKey[i].pUriCacheEntry)
            {
                ASSERT(HASH_INVALID_SIGNATURE != pHashUriKey[i].Hash);
                LastSlot = (LONG) i;
                break;
            }
            else
            {
                ASSERT(HASH_INVALID_SIGNATURE == pHashUriKey[i].Hash);
            }
        }

        // Is records array completely empty?
        if (LastSlot == INVALID_SLOT_INDEX)
            goto end;
    }
    else
    {
        // final slot cannot be empty
        ASSERT(HASH_INVALID_SIGNATURE
               != pHashUriKey[g_UlNumOfHashUriKeys-1].Hash);
    }

    // Walk through the records array

    for (i = 0; i < g_UlNumOfHashUriKeys; i++)
    {
        pUriCacheEntry = pHashUriKey[i].pUriCacheEntry;

        if (NULL == pUriCacheEntry)
        {
            ASSERT(HASH_INVALID_SIGNATURE == pHashUriKey[i].Hash);
            goto end;
        }
        else
        {
            ASSERT(HASH_INVALID_SIGNATURE != pHashUriKey[i].Hash);
        }

        result = (*pFilterRoutine)(pUriCacheEntry, pContext);

        switch (result)
        {
            case ULC_ABORT:
                bStop = TRUE;
                goto end;

            case ULC_NO_ACTION:
                // nothing to do
                break;

            case ULC_DELETE:
            case ULC_DELETE_STOP:
            {
                // Delete this entry
                
                ASSERT(pBucket->Entries > 0);
                --pBucket->Entries;

                if (NULL != pBucket->pUriCacheEntry)
                {
                    // If there exists an entry in the single list,
                    // move it to the array

                    ASSERT(LastSlot == INVALID_SLOT_INDEX);

                    pHashUriKey[i].Hash
                        = pBucket->pUriCacheEntry->UriKey.Hash;

                    pHashUriKey[i].pUriCacheEntry = pBucket->pUriCacheEntry;

                    pBucket->pUriCacheEntry
                        = (PUL_URI_CACHE_ENTRY)
                                pBucket->pUriCacheEntry->BucketEntry.Next;

                    if (NULL == pBucket->pUriCacheEntry)
                    {
                        LastSlot = g_UlNumOfHashUriKeys - 1;

                        ASSERT(HASH_INVALID_SIGNATURE
                               != pHashUriKey[LastSlot].Hash);
                    }
                }
                else
                {
                    // Move the entry in the last slot to this position,
                    // zap the last slot, and move LastSlot backwards

                    if (LastSlot != INVALID_SLOT_INDEX
                        &&  (LONG) i < LastSlot)
                    {
                        ASSERT(HASH_INVALID_SIGNATURE
                               != pHashUriKey[LastSlot].Hash);

                        pHashUriKey[i].Hash = pHashUriKey[LastSlot].Hash;
                        pHashUriKey[i].pUriCacheEntry
                            = pHashUriKey[LastSlot].pUriCacheEntry;

                        pHashUriKey[LastSlot].Hash = HASH_INVALID_SIGNATURE;
                        pHashUriKey[LastSlot].pUriCacheEntry = NULL;

                        if (--LastSlot == (LONG) i)
                            LastSlot = INVALID_SLOT_INDEX;
                        else
                            ASSERT(HASH_INVALID_SIGNATURE
                                   != pHashUriKey[LastSlot].Hash);
                    }
                    else
                    {
                        // Just reset this array element

                        pHashUriKey[i].Hash           = HASH_INVALID_SIGNATURE;
                        pHashUriKey[i].pUriCacheEntry = NULL;
                        LastSlot                      = INVALID_SLOT_INDEX;
                    }
                }

                ASSERT(UlpHashBucketIsCompact(pBucket));

                UriCacheEntryPages = pUriCacheEntry->NumPages;
                UlpInterlockedAddPointer( &g_UlHashTablePages,
                                         -UriCacheEntryPages );
                DEREFERENCE_URI_CACHE_ENTRY(pUriCacheEntry, FILTER);

                ++(*pDeletedCount);

                if (result == ULC_DELETE_STOP)
                {
                    bStop = TRUE;
                    goto end;
                }

                break;
            }

            default:
                break;
        }
    }

  end:
    ASSERT(UlpHashBucketIsCompact(pBucket));

    return bStop;
} // UlpFilterFlushHashBucket



/***************************************************************************++

Routine Description:

    Removes entries based on a caller-specified filter. The caller
    provides a predicate function which takes a cache entry as a
    parameter. The function will be called with each item in the cache.
    If the function returns ULC_DELETE, the item will be removed.
    Otherwise the item will remain in the cache.

Arguments:

    pHashTable      - The hash table
    pFilterRoutine  - A pointer to the filter function
    pContext        - A parameter to the filter function

Returns:

    ULONG           - Number of entries flushed from the table

--***************************************************************************/
ULONG
UlFilterFlushHashTable(
    IN PHASHTABLE       pHashTable,
    IN PUL_URI_FILTER   pFilterRoutine,
    IN PVOID            pContext
    )
{
    ULONG   i;
    BOOLEAN bStop        = FALSE;
    ULONG   DeletedCount = 0;

    HASH_PAGED_CODE(pHashTable);
    ASSERT(IS_VALID_HASHTABLE(pHashTable));

    //
    // Scan and delete (if matching the filter) each bucket
    // of the cache table.
    //

    for (i = 0;  !bStop && i < g_UlHashTableSize;  i++)
    {
        PHASHBUCKET pBucket    = UlpHashTableIndexedBucket(pHashTable, i);

#ifdef HASH_FULL_ASSERTS
        BOOLEAN     TestBucket = TRUE;
#else
        // If the bucket has no entries, there's no point in locking it
        // and flushing it.
        BOOLEAN     TestBucket = (BOOLEAN) (pBucket->Entries > 0);
#endif
        
        if (TestBucket)
        {
            ULONG DeletedInBucket = 0;

            UlAcquireRWSpinLockExclusive(&pBucket->RWSpinLock);

            RANDOMLY_BLOCK_HASHTABLE();

            bStop = UlpFilterFlushHashBucket(
                        pBucket,
                        pFilterRoutine,
                        pContext,
                        &DeletedInBucket
                        );

            UlReleaseRWSpinLockExclusive(&pBucket->RWSpinLock);
            
            DeletedCount += DeletedInBucket;
        }
    }

    return DeletedCount;
} // UlFilterFlushHashTable



/***************************************************************************++

Routine Description:

    Removes all entries on a bucket.

    Assume bucket exclusive lock is held.

Arguments:

    pBucket     - The hash table bucket

--***************************************************************************/
VOID
UlpClearHashBucket(
    IN PHASHBUCKET          pBucket
    )
{
    PUL_URI_CACHE_ENTRY     pUriCacheEntry;
    PUL_URI_CACHE_ENTRY     pTmpUriCacheEntry;
    PHASHURIKEY             pHashUriKey;
    ULONG                   i;
    LONG_PTR                UriCacheEntryPages;

    // Check if bucket exclusive lock is held

    ASSERT( UlRWSpinLockIsLockedExclusive(&pBucket->RWSpinLock) );
    ASSERT(UlpHashBucketIsCompact(pBucket));

    // Scan the single list first

    pUriCacheEntry = pBucket->pUriCacheEntry;

    while (NULL != pUriCacheEntry)
    {
        pTmpUriCacheEntry = pUriCacheEntry;

        pBucket->pUriCacheEntry
            = (PUL_URI_CACHE_ENTRY) pUriCacheEntry->BucketEntry.Next;

        pUriCacheEntry = pBucket->pUriCacheEntry;

        UriCacheEntryPages = pTmpUriCacheEntry->NumPages;
        UlpInterlockedAddPointer( &g_UlHashTablePages,
                                 -UriCacheEntryPages );
        DEREFERENCE_URI_CACHE_ENTRY(pTmpUriCacheEntry, CLEAR);
    }

    ASSERT(NULL == pBucket->pUriCacheEntry);

    pHashUriKey = UlpHashTableUriKeyFromBucket(pBucket);

    // Scan the records array

    for (i = 0; i < g_UlNumOfHashUriKeys; i++)
    {
        pUriCacheEntry = pHashUriKey[i].pUriCacheEntry;

        if (NULL == pUriCacheEntry)
        {
            ASSERT(HASH_INVALID_SIGNATURE == pHashUriKey[i].Hash);
            break;
        }
        else
        {
            ASSERT(HASH_INVALID_SIGNATURE != pHashUriKey[i].Hash);
        }

        UriCacheEntryPages = pUriCacheEntry->NumPages;
        UlpInterlockedAddPointer( &g_UlHashTablePages,
                                 (-UriCacheEntryPages) );
        DEREFERENCE_URI_CACHE_ENTRY(pUriCacheEntry, CLEAR);
    }

    pBucket->Entries = 0;

    ASSERT(UlpHashBucketIsCompact(pBucket));
    
} // UlpClearHashBucket



/***************************************************************************++

Routine Description:

    Removes all entries of the hash table.

Arguments:

    pHashTable      - The hash table

--***************************************************************************/
VOID
UlClearHashTable(
    IN PHASHTABLE       pHashTable
    )
{
    ULONG               i;
    PHASHBUCKET         pBucket;

    HASH_PAGED_CODE(pHashTable);
    ASSERT(IS_VALID_HASHTABLE(pHashTable));

    for (i = 0; i < g_UlHashTableSize ;i++)
    {
        pBucket = UlpHashTableIndexedBucket(pHashTable, i);

        UlAcquireRWSpinLockExclusive(&pBucket->RWSpinLock);

        UlpClearHashBucket(pBucket);

        UlReleaseRWSpinLockExclusive(&pBucket->RWSpinLock);
    }
} // UlClearHashTable


/***************************************************************************++

Routine Description:

     Return the number of pages occupied by cache entries in the hash table

Arguments:

     NONE.

--***************************************************************************/
ULONG_PTR
UlGetHashTablePages()
{
    PAGED_CODE();
    return g_UlHashTablePages;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\hash.h ===
/*++

Copyright (c) 1998-2002 Microsoft Corporation

Module Name:

    hash.h

Abstract:

    The public definition of response cache hash table.

Author:

    Alex Chen (alexch)      28-Mar-2001

Revision History:

--*/


#ifndef _HASH_H_
#define _HASH_H_

#include "cachep.h"


//
// Hash Table definitions
//

typedef struct _HASH_BUCKET *PHASHBUCKET;

typedef struct _HASH_TABLE
{
    ULONG                   Signature; //UL_HASH_TABLE_POOL_TAG

    POOL_TYPE               PoolType;

    SIZE_T                  NumberOfBytes;

    PHASHBUCKET             pAllocMem;

    PHASHBUCKET             pBuckets;

} HASHTABLE, *PHASHTABLE;


#define IS_VALID_HASHTABLE(pHashTable)                          \
    (HAS_VALID_SIGNATURE(pHashTable, UL_HASH_TABLE_POOL_TAG)    \
     &&  NULL != (pHashTable)->pAllocMem)




/***************************************************************************++

Routine Description:

    Wrapper around RtlEqualUnicodeString

Return Value:

    TRUE    - Equal
    FALSE   - NOT Equal

--***************************************************************************/
__inline
BOOLEAN
UlEqualUnicodeString(
    IN PWSTR pString1,
    IN PWSTR pString2,
    IN ULONG StringLength,
    IN BOOLEAN CaseInSensitive 
    )
{
    UNICODE_STRING UnicodeString1, UnicodeString2;

    ASSERT(StringLength < UNICODE_STRING_MAX_BYTES);

    UnicodeString1.Length           = (USHORT) StringLength;
    UnicodeString2.Length           = (USHORT) StringLength;
    
    UnicodeString1.MaximumLength    = (USHORT) StringLength + sizeof(WCHAR);
    UnicodeString2.MaximumLength    = (USHORT) StringLength + sizeof(WCHAR);

    UnicodeString1.Buffer           = pString1;
    UnicodeString2.Buffer           = pString2;

    return RtlEqualUnicodeString(
                &UnicodeString1,
                &UnicodeString2,
                CaseInSensitive
                );
} // UlEqualUnicodeString

/***************************************************************************++

Routine Description:

    Similar to UlEqualUnicodeString but the source string is the concatenation
    of the two strings.    

Return Value:

    TRUE    - if s1 + s2 == s3
    
    FALSE   - NOT Equal

--***************************************************************************/
__inline
BOOLEAN
UlEqualUnicodeStringEx(
    IN PWSTR pString1,
    IN ULONG String1Length,
    IN PWSTR pString2,
    IN ULONG String2Length,
    IN PWSTR pString3,    
    IN BOOLEAN CaseInSensitive 
    )
{
    UNICODE_STRING UnicodeString1, UnicodeString2, UnicodeString3;

    ASSERT(String1Length < UNICODE_STRING_MAX_BYTES);
    ASSERT(String2Length < UNICODE_STRING_MAX_BYTES);
    ASSERT((String1Length + String2Length) < UNICODE_STRING_MAX_BYTES);    

    UnicodeString1.Length           = (USHORT) String1Length;
    UnicodeString2.Length           = (USHORT) String2Length;
    UnicodeString3.Length           = (USHORT) (String1Length + String2Length);
    
    UnicodeString1.MaximumLength    = UnicodeString1.Length + sizeof(WCHAR);
    UnicodeString2.MaximumLength    = UnicodeString2.Length + sizeof(WCHAR);
    UnicodeString3.MaximumLength    = UnicodeString3.Length + sizeof(WCHAR);

    UnicodeString1.Buffer           = pString1;
    UnicodeString2.Buffer           = pString2;
    UnicodeString3.Buffer           = pString3;

    if (RtlPrefixUnicodeString(
                &UnicodeString1,
                &UnicodeString3,
                CaseInSensitive
                ))
    {
        UNICODE_STRING UnicodeString;

        UnicodeString.Length        = (USHORT) String2Length;
        UnicodeString.MaximumLength = (USHORT) String2Length + sizeof(WCHAR);
        UnicodeString.Buffer        = (PWSTR) &pString3[String1Length/sizeof(WCHAR)];
            
        //
        // Prefix matched see if the rest matches too.
        //

        return RtlEqualUnicodeString(
                &UnicodeString2,
                &UnicodeString,
                CaseInSensitive
                );            
    }

    return FALSE;
    
} // UlEqualUnicodeStringEx

/***************************************************************************++

Routine Description:

    Wrapper around RtlPrefixUnicodeString

Return Value:

    TRUE    - s1 is Equal of prefix of s2
    FALSE   - s1 is NOT Equal of prefix of s2.

--***************************************************************************/
__inline
BOOLEAN
UlPrefixUnicodeString(
    IN PWSTR pString1,
    IN PWSTR pString2,
    IN ULONG StringLength,
    IN BOOLEAN CaseInSensitive 
    )
{
    UNICODE_STRING UnicodeString1, UnicodeString2;

    ASSERT(StringLength < UNICODE_STRING_MAX_BYTES);

    UnicodeString1.Length           = (USHORT) StringLength;
    UnicodeString2.Length           = (USHORT) StringLength;
    
    UnicodeString1.MaximumLength    = (USHORT) StringLength + sizeof(WCHAR);
    UnicodeString2.MaximumLength    = (USHORT) StringLength + sizeof(WCHAR);

    UnicodeString1.Buffer           = pString1;
    UnicodeString2.Buffer           = pString2;

    return RtlPrefixUnicodeString(
                &UnicodeString1,
                &UnicodeString2,
                CaseInSensitive
                );
} // UlPrefixUnicodeString

/***************************************************************************++

Routine Description:

    Compare two URI_KEYS that have identical URIs upto N character. But not
    necessarily have the identical hashes. (case-insensitively)

Arguments:

    pUriKey1 : The key that holds the > shortest < length. I.e. the virtual
               directory that holds the app.

    pUriKey2 : The key that holds the longer (or equal) length. I.e the app
               which is under the above virtual directory.

Return Value:

    BOOLEAN  - TRUE If Key2 is prefix of Key1, otherwise FALSE.

--***************************************************************************/
__inline
BOOLEAN
UlPrefixUriKeys(
    IN PURI_KEY pUriKey1,
    IN PURI_KEY pUriKey2
    )
{
    //
    // Hash field inside the UriKey is discarded.
    //
    
    return ( UlPrefixUnicodeString(
                pUriKey1->pUri,
                pUriKey2->pUri,
                pUriKey1->Length,
                TRUE
                )
            );
}
    
NTSTATUS
UlInitializeHashTable(
    IN OUT PHASHTABLE  pHashTable,
    IN     POOL_TYPE   PoolType,
    IN     LONG        HashTableBits
    );

VOID
UlTerminateHashTable(
    IN PHASHTABLE      pHashTable
    );

PUL_URI_CACHE_ENTRY
UlGetFromHashTable(
    IN PHASHTABLE           pHashTable,
    IN PVOID                pSearchKey
    );

PUL_URI_CACHE_ENTRY
UlDeleteFromHashTable(
    IN PHASHTABLE           pHashTable,
    IN PURI_KEY             pUriKey,
    IN PUL_APP_POOL_PROCESS pProcess
    );

NTSTATUS
UlAddToHashTable(
    IN PHASHTABLE           pHashTable,
    IN PUL_URI_CACHE_ENTRY  pUriCacheEntry
    );

ULONG
UlFilterFlushHashTable(
    IN PHASHTABLE           pHashTable,
    IN PUL_URI_FILTER       pFilterRoutine,
    IN PVOID                pContext
    );

VOID
UlClearHashTable(
    IN PHASHTABLE           pHashTable
    );

// For scavenger

ULONG_PTR
UlGetHashTablePages(
    VOID
    );

#endif // _HASH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\filter.c ===
/*++

Copyright (c) 2000-2002 Microsoft Corporation

Module Name:

    filter.c

Abstract:

    This module implements the filter channel.

Author:

    Michael Courage (mcourage)  17-Mar-2000

Revision History:

--*/


#include "precomp.h"
#include "filterp.h"
#include "ioctlp.h"


//
// Private globals.
//

BOOLEAN            g_InitFilterCalled = FALSE;
HANDLE             g_FilterWriteTrackerLookaside = NULL;
PUL_FILTER_CHANNEL g_pSslServerFilterChannel;
LIST_ENTRY     g_pSslClientFilterChannelTable[FILTER_CHANNEL_HASH_TABLE_SIZE];

//
// Flag to track whether we should filter everything, or only SSL endpoints.
// This is used for supporting IIS Raw Filters.
//
BOOLEAN  g_FilterOnlySsl = TRUE;

//
// Private macros.
//

#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, UlInitializeFilterChannel )
#pragma alloc_text( PAGE, UlTerminateFilterChannel )
#pragma alloc_text( PAGE, UlCloseFilterProcess )

#pragma alloc_text( PAGE, UlpCreateFilterChannel )
#pragma alloc_text( PAGE, UlpCreateFilterProcess )

#pragma alloc_text( PAGE, UlpAddSslClientCertToConnectionWorker )
#pragma alloc_text( PAGE, UlpFreeSslInformationWorker )
#pragma alloc_text( PAGE, UxpProcessRawReadQueueWorker )
#endif  // ALLOC_PRAGMA

#if 0
NOT PAGEABLE -- UxpInitializeFilterWriteQueue
NOT PAGEABLE -- UxInitializeFilterConnection
NOT PAGEABLE -- UlAttachFilterProcess
NOT PAGEABLE -- UlDetachFilterProcess
NOT PAGEABLE -- UlFilterAccept
NOT PAGEABLE -- UlFilterClose
NOT PAGEABLE -- UlFilterRawWriteAndAppRead
NOT PAGEABLE -- UlFilterAppWriteAndRawRead
NOT PAGEABLE -- UlFilterRawRead
NOT PAGEABLE -- UlFilterRawWrite
NOT PAGEABLE -- UlFilterAppRead
NOT PAGEABLE -- UlFilterAppWrite
NOT PAGEABLE -- UlReceiveClientCert
NOT PAGEABLE -- UlReferenceFilterChannel
NOT PAGEABLE -- UlDereferenceFilterChannel
NOT PAGEABLE -- UlFilterReceiveHandler
NOT PAGEABLE -- UlFilterSendHandler
NOT PAGEABLE -- UlFilterReadHandler
NOT PAGEABLE -- UlFilterCloseHandler
NOT PAGEABLE -- UlFilterDisconnectHandler
NOT PAGEABLE -- UlUnbindConnectionFromFilter
NOT PAGEABLE -- UlDestroyFilterConnection
NOT PAGEABLE -- UlGetSslInfo

NOT PAGEABLE -- UlpFindFilterChannel
NOT PAGEABLE -- UlpRestartFilterClose
NOT PAGEABLE -- UlpRestartFilterRawRead
NOT PAGEABLE -- UlpRestartFilterRawWrite
NOT PAGEABLE -- UlpRestartFilterAppWrite
NOT PAGEABLE -- UlpRestartFilterSendHandler
NOT PAGEABLE -- UlpCancelFilterAccept
NOT PAGEABLE -- UlpCancelFilterAcceptWorker
NOT PAGEABLE -- UlpCancelFilterRawRead
NOT PAGEABLE -- UlpCancelFilterAppRead
NOT PAGEABLE -- UlpCancelReceiveClientCert
NOT PAGEABLE -- UlDeliverConnectionToFilter
NOT PAGEABLE -- UlpFilterAppWriteStream
NOT PAGEABLE -- UlpEnqueueFilterAppWrite
NOT PAGEABLE -- UlpDequeueFilterAppWrite
NOT PAGEABLE -- UlpCaptureSslInfo
NOT PAGEABLE -- UlpCaptureSslClientCert
NOT PAGEABLE -- UlpAddSslInfoToConnection
NOT PAGEABLE -- UlpAddSslClientCertToConnection
NOT PAGEABLE -- UlpGetSslClientCert
NOT PAGEABLE -- UlpPopAcceptIrp
NOT PAGEABLE -- UlpPopAcceptIrpFromProcess
NOT PAGEABLE -- UlpCompleteAcceptIrp
NOT PAGEABLE -- UlpCompleteAppReadIrp
NOT PAGEABLE -- UlpDuplicateHandle

NOT PAGEABLE -- UxpQueueRawReadIrp
NOT PAGEABLE -- UxpDequeueRawReadIrp
NOT PAGEABLE -- UxpCancelAllQueuedRawReads
NOT PAGEABLE -- UxpSetBytesNotTaken
NOT PAGEABLE -- UxpProcessIndicatedData
NOT PAGEABLE -- UxpProcessRawReadQueue
NOT PAGEABLE -- UxpRestartProcessRawReadQueue

NOT PAGEABLE -- UlpQueueFilterIrp
NOT PAGEABLE -- UlpPopFilterIrp

NOT PAGEABLE -- UxpQueueFilterWrite
NOT PAGEABLE -- UxpRequeueFilterWrite
NOT PAGEABLE -- UxpDequeueFilterWrite
NOT PAGEABLE -- UxpCopyQueuedWriteData
NOT PAGEABLE -- UxpCompleteQueuedWrite
NOT PAGEABLE -- UxpCancelAllQueuedIo
NOT PAGEABLE -- UxpCreateFilterWriteTracker
NOT PAGEABLE -- UxpDeleteFilterWriteTracker
NOT PAGEABLE -- UxpAllocateFilterWriteTrackerPool
NOT PAGEABLE -- UxpFreeFilterWriteTrackerPool

#endif


//
// Public functions.
//


/***************************************************************************++

Routine Description:

    Initializes global data related to filter channels.

--***************************************************************************/
NTSTATUS
UlInitializeFilterChannel(
    PUL_CONFIG pConfig
    )
{
    ULONG    i;
    NTSTATUS Status = STATUS_SUCCESS;

    ASSERT(!g_InitFilterCalled);

    if (!g_InitFilterCalled)
    {
        for (i = 0; i < FILTER_CHANNEL_HASH_TABLE_SIZE; i++)
            InitializeListHead(&g_pSslClientFilterChannelTable[i]);

        UlInitializeSpinLock(
            &g_pUlNonpagedData->FilterSpinLock,
            "FilterSpinLock"
            );

        //
        // Initialize lookaside list for filter write tracker
        // objects.
        //

        g_FilterWriteTrackerLookaside =
            PplCreatePool(
                &UxpAllocateFilterWriteTrackerPool,         // Allocate
                &UxpFreeFilterWriteTrackerPool,             // Free
                0,                                          // Flags
                sizeof(UX_FILTER_WRITE_TRACKER),            // Size
                UX_FILTER_WRITE_TRACKER_POOL_TAG,           // Tag
                pConfig->FilterWriteTrackerLookasideDepth   // Depth
                );

        if (g_FilterWriteTrackerLookaside)
        {
            g_InitFilterCalled = TRUE;
        }
        else
        {
            Status = STATUS_NO_MEMORY;
        }

    }

    return Status;
}

/***************************************************************************++

Routine Description:

    Cleans up global data related to filter channels.

--***************************************************************************/
VOID
UlTerminateFilterChannel(
    VOID
    )
{
    //
    // Sanity check.
    //
    PAGED_CODE();

    if (g_InitFilterCalled)
    {
        PplDestroyPool(g_FilterWriteTrackerLookaside,
                       UX_FILTER_WRITE_TRACKER_POOL_TAG);

        g_InitFilterCalled = FALSE;
    }
}

/***************************************************************************++

Routine Description:

    Attaches a process to a filter channel. If the filter channel does
    not yet exist and the Create flag is set, this function will create
    a new one.

Arguments:

    pName - name of the filter channel
    NameLength - length of the name in bytes
    Create - set if non-existant channel should be created
    pAccessState - security parameter
    DesiredAccess - security parameter
    RequestorMode - kernel or user

    ppFilterProcess - returns the filter process object

--***************************************************************************/
NTSTATUS
UlAttachFilterProcess(
    IN PWCHAR pName,
    IN USHORT NameLength,
    IN BOOLEAN Create,
    IN PACCESS_STATE pAccessState,
    IN ACCESS_MASK DesiredAccess,
    IN KPROCESSOR_MODE RequestorMode,
    OUT PUL_FILTER_PROCESS *ppFilterProcess
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PUL_FILTER_CHANNEL pChannel = NULL;
    PUL_FILTER_PROCESS pProcess = NULL;
    KIRQL oldIrql;
    WCHAR SafeName[(UL_MAX_FILTER_NAME_LENGTH/sizeof(WCHAR)) + 1];


    //
    // Sanity check.
    //
    ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);
    ASSERT(pName);
    ASSERT(ppFilterProcess);

    if (NameLength > UL_MAX_FILTER_NAME_LENGTH)
        return STATUS_INVALID_PARAMETER;

    //
    // Copy the name into non-paged memory, since we are touching it after
    // acquiring the lock.
    //
    RtlCopyMemory(SafeName, pName, NameLength);
    SafeName[NameLength/sizeof(WCHAR)] = L'\0';
    pName = (PWCHAR) SafeName;


    //
    // Try to find a filter channel with the given name.
    //
    UlAcquireSpinLock(&g_pUlNonpagedData->FilterSpinLock, &oldIrql);

    pChannel = UlpFindFilterChannel(pName, NameLength, PsGetCurrentProcess());

    if (pChannel)
    {
        //
        // Ref for the new process object
        //
        REFERENCE_FILTER_CHANNEL(pChannel);
    }

    //
    // We're done with the list for now.
    //
    UlReleaseSpinLock(&g_pUlNonpagedData->FilterSpinLock, oldIrql);

    //
    // If we didn't find a filter channel, try to create one.
    //
    if (!pChannel)
    {
        if (Create)
        {
            PUL_FILTER_CHANNEL pNewChannel = NULL;


            if (NT_SUCCESS(Status))
            {
                //
                //  Create the specified filter channel
                //
                Status = UlpCreateFilterChannel(pName,
                                                NameLength,
                                                pAccessState,
                                                &pNewChannel);
            }

            //
            // OK. We've created a filter channel. Now insert it into
            // the list. Before we do that though, check to make sure
            // that no one else has created another channel with the
            // same name while we we're working on ours.
            //
            if (NT_SUCCESS(Status))
            {
                UlAcquireSpinLock(&g_pUlNonpagedData->FilterSpinLock, &oldIrql);

                pChannel = UlpFindFilterChannel(pName, NameLength,
                                                PsGetCurrentProcess());

                if (!pChannel)
                {
                    //
                    // Ours is unique. Add it to the list.
                    //
                    pChannel = pNewChannel;
                    UlpAddFilterChannel(pChannel);
                }
                else
                {
                    //
                    // A filter channel is already present, fail the create.
                    //
                    Status = STATUS_OBJECT_NAME_COLLISION;
                }

                UlReleaseSpinLock(&g_pUlNonpagedData->FilterSpinLock, oldIrql);

                //
                // Now that we're outside the spinlock, we can deref
                // our filter channel if it was a duplicate.
                //
                if (pChannel != pNewChannel)
                {
                    //
                    // The channel has been added already.
                    // Get rid of the one we just created
                    //
                    DEREFERENCE_FILTER_CHANNEL(pNewChannel);
                }
            }
        }
        else
        {
            //
            // Didn't find a channel and can't create one.
            //
            Status = STATUS_OBJECT_NAME_NOT_FOUND;
        }

    }
    else
    {
        //
        // Attach to the existing filter channel.
        //

        if (!Create)
        {
            //
            // If we pass the access check, we're all set.
            //
            Status = UlAccessCheck(
                            pChannel->pSecurityDescriptor,
                            pAccessState,
                            DesiredAccess,
                            RequestorMode,
                            pName
                            );
        }
        else
        {
            //
            // We were trying to create an object that already
            // exists..
            //
            Status = STATUS_OBJECT_NAME_COLLISION;
        }
    }

    if (NT_SUCCESS(Status))
    {
        //
        // We've got a filter channel, create the process object
        // and link it into the channel's list.
        //
        pProcess = UlpCreateFilterProcess(pChannel);

        if (pProcess)
        {
            //
            // Put it in the filter channel list.
            //

            UlAcquireSpinLock(&pChannel->SpinLock, &oldIrql);
            InsertHeadList(&pChannel->ProcessListHead, &pProcess->ListEntry);
            UlReleaseSpinLock(&pChannel->SpinLock, oldIrql);

            //
            // Return it to the caller.
            //

            *ppFilterProcess = pProcess;
        }
        else
        {
            Status = STATUS_NO_MEMORY;
        }
    }

    //
    // Done. Clean up if anything failed.
    //
    if (!NT_SUCCESS(Status))
    {
        if (pChannel != NULL)
        {
            DEREFERENCE_FILTER_CHANNEL(pChannel);
        }
        if (pProcess != NULL)
        {
            UL_FREE_POOL_WITH_SIG(pProcess, UL_FILTER_PROCESS_POOL_TAG);
        }
    }

    return Status;
}


/***************************************************************************++

Routine Description:

    Detaches a process from a filter channel.

    This is called by UlCleanup when the handle count goes to 0.  It removes
    the process object from the filter channel and cancels all i/o.

Arguments:

    pFilterProcess - the process object to detach

--***************************************************************************/
NTSTATUS
UlDetachFilterProcess(
    IN PUL_FILTER_PROCESS pFilterProcess
    )
{
    PUL_FILTER_CHANNEL pChannel;
    KIRQL oldIrql;
    //
    // Sanity check.
    //
    ASSERT(IS_VALID_FILTER_PROCESS(pFilterProcess));

    pChannel = pFilterProcess->pFilterChannel;
    ASSERT(IS_VALID_FILTER_CHANNEL(pChannel));

    //
    // Clean up I/O.
    //

    UlShutdownFilterProcess(
        pFilterProcess
        );

    //
    // Do final cleanup.
    //

    UlAcquireSpinLock(&pChannel->SpinLock, &oldIrql);

    //
    // Unlink from filter channel list.
    //
    RemoveEntryList(&pFilterProcess->ListEntry);

    UlReleaseSpinLock(&pChannel->SpinLock, oldIrql);

    return STATUS_SUCCESS;
}


/***************************************************************************++

Routine Description:

    Cleans up all outstanding I/O on a filter process.

Arguments:

    pFilterProcess - the process object to shut down

--***************************************************************************/
VOID
UlShutdownFilterProcess(
    IN PUL_FILTER_PROCESS pFilterProcess
    )
{
    PUL_FILTER_CHANNEL pChannel;
    KIRQL oldIrql;
    LIST_ENTRY ConnectionHead;

    //
    // Sanity check.
    //
    ASSERT(IS_VALID_FILTER_PROCESS(pFilterProcess));

    pChannel = pFilterProcess->pFilterChannel;
    ASSERT(IS_VALID_FILTER_CHANNEL(pChannel));

    UlAcquireSpinLock(&pChannel->SpinLock, &oldIrql);

    if (pFilterProcess->InCleanup)
    {
        //
        // Bail out if we've already been here.
        //

        UlReleaseSpinLock(&pChannel->SpinLock, oldIrql);

        return;
    }

    //
    // Mark the process as InCleanup so new I/O won't be attached
    //
    pFilterProcess->InCleanup = 1;


    //
    // Cancel outstanding I/O.
    //

    //
    // Cancel FilterAccept IRPs.
    //
    while (!IsListEmpty(&pFilterProcess->IrpHead))
    {
        PLIST_ENTRY pEntry;
        PIRP pIrp;

        //
        // Pop it off the list.
        //

        pEntry = RemoveHeadList(&pFilterProcess->IrpHead);
        pEntry->Blink = pEntry->Flink = NULL;

        pIrp = CONTAINING_RECORD(pEntry, IRP, Tail.Overlay.ListEntry);
        ASSERT(IS_VALID_IRP(pIrp));

        //
        // pop the cancel routine
        //

        if (IoSetCancelRoutine(pIrp, NULL) == NULL)
        {
            //
            // IoCancelIrp pop'd it first
            //
            // ok to just ignore this irp, it's been pop'd off the queue
            // and will be completed in the cancel routine.
            //
            // keep looping
            //

            pIrp = NULL;

        }
        else
        {
            PUL_FILTER_CHANNEL pFilterChannel;

            //
            // cancel it.  even if pIrp->Cancel == TRUE we are supposed to
            // complete it, our cancel routine will never run.
            //

            pFilterChannel = (PUL_FILTER_CHANNEL)(
                                    IoGetCurrentIrpStackLocation(pIrp)->
                                        Parameters.DeviceIoControl.Type3InputBuffer
                                    );

            ASSERT(pFilterChannel == pChannel);

            DEREFERENCE_FILTER_CHANNEL(pFilterChannel);

            IoGetCurrentIrpStackLocation(pIrp)->
                Parameters.DeviceIoControl.Type3InputBuffer = NULL;

            pIrp->IoStatus.Status = STATUS_CANCELLED;
            pIrp->IoStatus.Information = 0;

            UlCompleteRequest(pIrp, IO_NO_INCREMENT);
            pIrp = NULL;
        }
    }

    //
    // Close all connections attached to the process.
    // We need to move them to a private list, release
    // the channel spinlock, and then call close on
    // each connection.
    //
    InitializeListHead(&ConnectionHead);

    while (!IsListEmpty(&pFilterProcess->ConnectionHead))
    {
        PUX_FILTER_CONNECTION pConnection;
        PLIST_ENTRY pEntry;
        BOOLEAN Disconnect;

        pEntry = RemoveHeadList(&pFilterProcess->ConnectionHead);
        pConnection = CONTAINING_RECORD(
                            pEntry,
                            UX_FILTER_CONNECTION,
                            ChannelEntry
                            );

        ASSERT(IS_VALID_FILTER_CONNECTION(pConnection));

        UlAcquireSpinLockAtDpcLevel(&pConnection->FilterConnLock);

        ASSERT(pConnection->ConnState != UlFilterConnStateInactive);

        if (pConnection->ConnState == UlFilterConnStateQueued ||
            pConnection->ConnState == UlFilterConnStateConnected)
        {
            pConnection->ConnState = UlFilterConnStateWillDisconnect;
            Disconnect = TRUE;
        }
        else
        {
            Disconnect = FALSE;
        }

        UlReleaseSpinLockFromDpcLevel(&pConnection->FilterConnLock);

        if (Disconnect)
        {
            InsertHeadList(&ConnectionHead, &pConnection->ChannelEntry);
        }
        else
        {
            DEREFERENCE_FILTER_CONNECTION(pConnection);
        }
    }

    UlReleaseSpinLock(&pChannel->SpinLock, oldIrql);

    //
    // Now that we're outside the lock we can
    // close all the connections.
    //
    while (!IsListEmpty(&ConnectionHead))
    {
        PUX_FILTER_CONNECTION pConnection;
        PLIST_ENTRY           pEntry;

        pEntry = RemoveHeadList(&ConnectionHead);
        pConnection = CONTAINING_RECORD(
                            pEntry,
                            UX_FILTER_CONNECTION,
                            ChannelEntry
                            );

        ASSERT(IS_VALID_FILTER_CONNECTION(pConnection));


        pConnection->ChannelEntry.Flink = NULL;
        pConnection->ChannelEntry.Blink = NULL;

        (pConnection->pCloseConnectionHandler)(
            pConnection->pConnectionContext,
            TRUE,           // AbortiveDisconnect
            NULL,           // pCompletionRoutine
            NULL            // pCompletionContext
            );

        DEREFERENCE_FILTER_CONNECTION(pConnection);
    }
}


/***************************************************************************++

Routine Description:

    Frees the memory used by a UL_FILTER_PROCESS object.

Arguments:

    pFilterProcess - the process object to free

--***************************************************************************/
VOID
UlCloseFilterProcess(
    IN PUL_FILTER_PROCESS pFilterProcess
    )
{
    //
    // Sanity check.
    //
    PAGED_CODE();
    ASSERT( IS_VALID_FILTER_PROCESS(pFilterProcess) );
    ASSERT( IS_VALID_FILTER_CHANNEL(pFilterProcess->pFilterChannel) );

    //
    // Drop the reference on the filter channel.
    //
    DEREFERENCE_FILTER_CHANNEL(pFilterProcess->pFilterChannel);

    UL_FREE_POOL_WITH_SIG(pFilterProcess, UL_FILTER_PROCESS_POOL_TAG);
}


/***************************************************************************++

Routine Description:

    Accepts a raw connection that's been routed to the filter channel.

Arguments:

    pFilterProcess - the calling filter process
    pIrp - IRP from the caller

--***************************************************************************/
NTSTATUS
UlFilterAccept(
    IN PUL_FILTER_PROCESS pFilterProcess,
    IN PIRP pIrp
    )
{
    NTSTATUS Status;
    KIRQL oldIrql;
    PUL_FILTER_CHANNEL pChannel;
    PUX_FILTER_CONNECTION pConnection;

    //
    // Sanity check.
    //
    ASSERT( KeGetCurrentIrql() == PASSIVE_LEVEL );
    ASSERT( IS_VALID_FILTER_PROCESS(pFilterProcess) );
    ASSERT( pIrp );
    ASSERT( pIrp->MdlAddress );

    //
    // Always return pending unless we are going to fail
    // inline. In that case we have to remember to
    // remove the pending flag from the IRP.
    //

    IoMarkIrpPending(pIrp);

    Status = STATUS_PENDING;
    pConnection = NULL;

    pChannel = pFilterProcess->pFilterChannel;

    UlAcquireSpinLock(&pChannel->SpinLock, &oldIrql);

    //
    // Make sure we're not cleaning up the process
    //
    if (pFilterProcess->InCleanup)
    {
        Status = STATUS_INVALID_HANDLE;
        goto end;
    }

    //
    // Do we have a queued new connection?
    //
    if (!IsListEmpty(&pFilterProcess->pFilterChannel->ConnectionListHead))
    {
        PLIST_ENTRY pEntry;

        //
        // Accept a queued connection.
        //

        pEntry = RemoveHeadList(&pChannel->ConnectionListHead);
        pConnection = CONTAINING_RECORD(
                            pEntry,
                            UX_FILTER_CONNECTION,
                            ChannelEntry
                            );

        ASSERT(IS_VALID_FILTER_CONNECTION(pConnection));
        ASSERT(pConnection->ConnState == UlFilterConnStateQueued);

        pConnection->ChannelEntry.Flink = NULL;
        pConnection->ChannelEntry.Blink = NULL;

        UlAcquireSpinLockAtDpcLevel(&pConnection->FilterConnLock);

        pConnection->ConnState = UlFilterConnStateConnected;

        UlReleaseSpinLockFromDpcLevel(&pConnection->FilterConnLock);

        //
        // Transfer (referenced) connection to the calling process.
        //
        InsertTailList(
            &pFilterProcess->ConnectionHead,
            &pConnection->ChannelEntry
            );

        //
        // Deliver the data outside spinlocks.
        //

    }
    else
    {
        PIO_STACK_LOCATION pIrpSp;

        //
        // No connection available. Queue the IRP.
        //

        //
        // give the irp a pointer to the filter channel
        //

        pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
        pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer = pChannel;

        REFERENCE_FILTER_CHANNEL(pChannel);

        //
        // set to these to null just in case the cancel routine runs
        //

        pIrp->Tail.Overlay.ListEntry.Flink = NULL;
        pIrp->Tail.Overlay.ListEntry.Blink = NULL;

        IoSetCancelRoutine(pIrp, &UlpCancelFilterAccept);

        //
        // cancelled?
        //

        if (pIrp->Cancel)
        {
            //
            // darn it, need to make sure the irp get's completed
            //

            if (IoSetCancelRoutine( pIrp, NULL ) != NULL)
            {
                //
                // we are in charge of completion, IoCancelIrp didn't
                // see our cancel routine (and won't).  ioctl wrapper
                // will complete it
                //

                DEREFERENCE_FILTER_CHANNEL(pChannel);

                pIrp->IoStatus.Information = 0;

                Status = STATUS_CANCELLED;
                goto end;
            }

            //
            // our cancel routine will run and complete the irp,
            // don't touch it
            //

            //
            // STATUS_PENDING will cause the ioctl wrapper to
            // not complete (or touch in any way) the irp
            //

            Status = STATUS_PENDING;
            goto end;
        }

        //
        // now we are safe to queue it
        //

        InsertTailList(
            &pFilterProcess->IrpHead,
            &pIrp->Tail.Overlay.ListEntry
            );

        Status = STATUS_PENDING;
    }

end:
    UlReleaseSpinLock(&pChannel->SpinLock, oldIrql);

    //
    // Now that we're outside the spin lock, we can complete
    // the IRP if we have a connection. Don't bother to
    // try keep track of initial data. Let the filter process
    // request it.
    //
    if (pConnection)
    {
        UlpCompleteAcceptIrp(
            pIrp,
            pConnection,
            NULL,               // pBuffer
            0,                  // IndicatedLength
            NULL                // pTakenLength
            );

    }

    if (Status != STATUS_PENDING)
    {
        UlUnmarkIrpPending( pIrp );
    }

    RETURN(Status);
} // UlFilterAccept


/***************************************************************************++

Routine Description:

    Closes a raw connection.

Arguments:

    pFilterProcess - the calling filter process
    pConnection - the connection to close
    pIrp - IRP from the caller

--***************************************************************************/
NTSTATUS
UlFilterClose(
    IN PUL_FILTER_PROCESS pFilterProcess,
    IN PUX_FILTER_CONNECTION pConnection,
    IN PIRP pIrp
    )
{
    NTSTATUS Status;
    KIRQL oldIrql;
    BOOLEAN CloseConnection;

    //
    // Init locals so we know how to clean up.
    //
    CloseConnection = FALSE;

    //
    // Sanity check.
    //
    ASSERT( KeGetCurrentIrql() == PASSIVE_LEVEL );
    ASSERT( IS_VALID_FILTER_PROCESS(pFilterProcess) );
    ASSERT( IS_VALID_FILTER_CONNECTION(pConnection) );
    ASSERT( pIrp );

    UlAcquireSpinLock(&pFilterProcess->pFilterChannel->SpinLock, &oldIrql);

    UlAcquireSpinLockAtDpcLevel(&pConnection->FilterConnLock);

    Status = UlpValidateFilterCall(pFilterProcess, pConnection);


    if (!NT_SUCCESS(Status))
    {
        goto end;
    }

    //
    // Do the close outside the spin lock.
    // Go ahead and mark the IRP as pending, then
    // guarantee that we'll only return pending from
    // this point on.
    //

    IoMarkIrpPending( pIrp );
    Status = STATUS_PENDING;

    CloseConnection = TRUE;

end:
    UlReleaseSpinLockFromDpcLevel(&pConnection->FilterConnLock);
    UlReleaseSpinLock(&pFilterProcess->pFilterChannel->SpinLock, oldIrql);

    if (CloseConnection)
    {
        (pConnection->pCloseConnectionHandler)(
            pConnection->pConnectionContext,
            FALSE,                      // AbortiveDisconnect
            UlpRestartFilterClose,      // pCompletionRoutine
            pIrp                        // pCompletionContext
            );

    }

    UlTrace(FILTER, (
        "http!UlFilterClose pConn = %p returning %x\n",
        pConnection,
        Status
        ));

    RETURN(Status);

} // UlFilterClose


/***************************************************************************++

Routine Description:

    This routine performs an Raw Write followed by a App Read.

    Note: This is a METHOD_OUT_DIRECT IOCTL.

Arguments:

    pIrp - Supplies a pointer to the IO request packet.

    pIrpSp - Supplies a pointer to the IO stack location to use for this
        request.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlFilterRawWriteAndAppRead(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )
{
    NTSTATUS                 Status;
    PUX_FILTER_CONNECTION    pConnection = NULL;
    PUL_FILTER_PROCESS       pFilterProcess;
    PHTTP_FILTER_BUFFER_PLUS pFilterBufferPlus;
    BOOLEAN                  MarkedPending = FALSE;

    __try
    {
        VALIDATE_FILTER_PROCESS(pIrpSp, pFilterProcess);

        VALIDATE_INPUT_BUFFER(pIrp, pIrpSp,
            HTTP_FILTER_BUFFER_PLUS, pFilterBufferPlus);

        VALIDATE_OUTPUT_BUFFER_SIZE(pIrpSp, HTTP_FILTER_BUFFER);
        VALIDATE_OUTPUT_BUFFER_ADDRESS_FROM_MDL(pIrp, HTTP_FILTER_BUFFER);

        //
        // Map the incoming connection ID to the corresponding
        // UX_FILTER_CONNECTION object.
        //

        pConnection = UlGetRawConnectionFromId(pFilterBufferPlus->Reserved);

        if (!pConnection)
        {
            Status = STATUS_INVALID_PARAMETER;
            goto end;
        }

        ASSERT(IS_VALID_FILTER_CONNECTION(pConnection));

        IoMarkIrpPending(pIrp);
        MarkedPending = TRUE;

        //
        // If we were given a write buffer, then process it first.  Upon
        // completion, this function will be called again without a write
        // buffer.  Otherwise, simply do the App Read now.
        //
        if (pFilterBufferPlus->pWriteBuffer != NULL &&
            pFilterBufferPlus->WriteBufferSize > 0)
        {
            //
            // This will not completed inline, so the App Read operation will
            // be initiated at write completion.
            //
            Status = UlFilterRawWrite(
                pFilterProcess,
                pConnection,
                pIrpSp->Parameters.DeviceIoControl.OutputBufferLength,
                pIrp
                );
        }
        else
        {
            Status = UlFilterAppRead(pFilterProcess, pConnection, pIrp);
        }
    }
    __except( UL_EXCEPTION_FILTER() )
    {
        Status = UL_CONVERT_EXCEPTION_CODE(GetExceptionCode());

        UlTrace( FILTER, (
            "UlFilterRawWriteAndAppRead: Hit exception, status = 0x%08X\n",
            Status
            ));
    }

end:
    if (pConnection)
    {
        DEREFERENCE_FILTER_CONNECTION(pConnection);
    }

    //
    // Complete the IRP if we haven't queued it for later processing.
    //
    if (Status != STATUS_PENDING)
    {
        pIrp->IoStatus.Status = Status;
        UlCompleteRequest( pIrp, IO_NO_INCREMENT );

        if (MarkedPending)
        {
            //
            // Since we marked the IRP pending, we should return pending.
            //
            Status = STATUS_PENDING;
        }
    }
    else
    {
        //
        // If we're returning pending, the IRP better be marked pending.
        //
        ASSERT(MarkedPending);
    }

    RETURN( Status );

}   // UlFilterAppReadAndRawWrite


/***************************************************************************++

Routine Description:

    This routine performs an App Write followed by a Raw Read.

Arguments:

    pIrp - Supplies a pointer to the IO request packet.

    pIrpSp - Supplies a pointer to the IO stack location to use for this
        request.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlFilterAppWriteAndRawRead(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )
{
    NTSTATUS                 Status;
    PUX_FILTER_CONNECTION    pConnection = NULL;
    PUL_FILTER_PROCESS       pFilterProcess;
    PHTTP_FILTER_BUFFER_PLUS pFilterBufferPlus;
    BOOLEAN                  MarkedPending = FALSE;

    __try
    {
        VALIDATE_FILTER_PROCESS(pIrpSp, pFilterProcess);

        VALIDATE_INPUT_BUFFER(pIrp, pIrpSp, HTTP_FILTER_BUFFER_PLUS,
                              pFilterBufferPlus);

        VALIDATE_OUTPUT_BUFFER_SIZE(pIrpSp, HTTP_FILTER_BUFFER);
        VALIDATE_OUTPUT_BUFFER_ADDRESS_FROM_MDL(pIrp, HTTP_FILTER_BUFFER);

        //
        // Get the connection ID.
        //

        pConnection = UlGetRawConnectionFromId(pFilterBufferPlus->Reserved);

        if (!pConnection)
        {
            Status = STATUS_CONNECTION_INVALID;
            goto end;
        }

        ASSERT(IS_VALID_FILTER_CONNECTION(pConnection));

        IoMarkIrpPending(pIrp);
        MarkedPending = TRUE;

        //
        // Process the write buffer if one was given.  Otherwise, proceed
        // with the Raw Read.
        //
        if (pFilterBufferPlus->pWriteBuffer != NULL &&
            pFilterBufferPlus->WriteBufferSize > 0)
        {
            Status = UlFilterAppWrite(pFilterProcess, pConnection, pIrp);

            //
            // If the write operation was completed inline, initiate the read
            // now.  Otherwise, the read will be initiated on write completion.
            //
            if (NT_SUCCESS(Status) && Status != STATUS_PENDING)
            {
                Status = UlFilterRawRead(pFilterProcess, pConnection, pIrp);
            }
        }
        else
        {
            Status = UlFilterRawRead(pFilterProcess, pConnection, pIrp);
        }

    }
    __except( UL_EXCEPTION_FILTER() )
    {
        Status = UL_CONVERT_EXCEPTION_CODE(GetExceptionCode());

        UlTrace( FILTER, (
            "UlFilterAppWriteAndRawRead: Hit exception, status = 0x%08X\n",
            Status
            ));

    }

end:
    if (pConnection)
    {
        DEREFERENCE_FILTER_CONNECTION(pConnection);
    }

    //
    // Complete the IRP if we haven't queued it for later processing.
    //
    if (Status != STATUS_PENDING)
    {
        pIrp->IoStatus.Status = Status;
        UlCompleteRequest( pIrp, IO_NO_INCREMENT );

        if (MarkedPending)
        {
            //
            // Since we marked the IRP pending, we should return pending.
            //
            Status = STATUS_PENDING;
        }
    }
    else
    {
        //
        // If we're returning pending, the IRP better be marked pending.
        //
        ASSERT(MarkedPending);
    }

    RETURN( Status );

}   // UlFilterAppWriteAndRawRead


/***************************************************************************++

Routine Description:

    Reads data from a raw connection.

Arguments:

    pFilterProcess - the calling filter process
    pConnection - the connection from which to read
    pIrp - IRP from the caller

--***************************************************************************/
NTSTATUS
UlFilterRawRead(
    IN PUL_FILTER_PROCESS pFilterProcess,
    IN PUX_FILTER_CONNECTION pConnection,
    IN PIRP pIrp
    )
{
    NTSTATUS Status;
    KIRQL oldIrql;

    //
    // Sanity check.
    //

    //
    // This function can currently be called at DPC when called at write
    // completion.  This assertion should be reinstating if/when the
    // read post is moved to the combined read/write IOCTL.
    //
//    ASSERT( KeGetCurrentIrql() == PASSIVE_LEVEL );


    ASSERT( IS_VALID_FILTER_PROCESS(pFilterProcess) );
    ASSERT( IS_VALID_FILTER_CONNECTION(pConnection) );
    ASSERT( pIrp );

    UlAcquireSpinLock(&pFilterProcess->pFilterChannel->SpinLock, &oldIrql);

    UlAcquireSpinLockAtDpcLevel(&pConnection->FilterConnLock);

    Status = UlpValidateFilterCall(pFilterProcess, pConnection);


    if (NT_SUCCESS(Status))
    {
        UlTrace(FILTER, (
            "http!UlFilterRawRead(pConn = %p, pIrp = %p) size = %lu\n",
            pConnection,
            pIrp,
            IoGetCurrentIrpStackLocation(pIrp)->
                Parameters.DeviceIoControl.OutputBufferLength
            ));

        //
        // Always queue the IRP.
        //

        Status = UxpQueueRawReadIrp(pConnection, pIrp);
    }
    else
    {
        UlTrace(FILTER, (
            "http!UlFilterRawRead(pConn = %p, pIrp = %p) !NT_SUCCESS == Status %x\n",
            pConnection,
            pIrp,
            Status
            ));
    }

    UlReleaseSpinLockFromDpcLevel(&pConnection->FilterConnLock);
    UlReleaseSpinLock(&pFilterProcess->pFilterChannel->SpinLock, oldIrql);

    if (NT_SUCCESS(Status))
    {
        //
        // If we successfully queued the IRP, see if we need to grab some
        // data from TDI.
        //

        UxpProcessRawReadQueue(pConnection);
    }

    RETURN(Status);
}

/***************************************************************************++

Routine Description:

    Writes filtered data back to the network.

Arguments:

    pFilterProcess - the calling filter process
    pConnection - the connection from which the data originated
    BufferLength - the size of pBuffer
    pIrp - IRP from the caller

--***************************************************************************/
NTSTATUS
UlFilterRawWrite(
    IN PUL_FILTER_PROCESS pFilterProcess,
    IN PUX_FILTER_CONNECTION pConnection,
    IN ULONG BufferLength,
    IN PIRP pIrp
    )
{
    NTSTATUS Status;
    PUL_IRP_CONTEXT pIrpContext;
    KIRQL oldIrql;
    PHTTP_FILTER_BUFFER_PLUS pFiltBufferPlus;
    PMDL pMdl = NULL;
    PIO_STACK_LOCATION pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

    //
    // This function always returns STATUS_PENDING.
    //

    ASSERT(IS_VALID_IRP(pIrp));
    IoMarkIrpPending(pIrp);

    //
    // Setup locals so we know how to cleanup on failure.
    //

    pIrpContext = NULL;

    //
    // Sanity check.
    //
    ASSERT( KeGetCurrentIrql() == PASSIVE_LEVEL );
    ASSERT( IS_VALID_FILTER_PROCESS(pFilterProcess) );
    ASSERT( IS_VALID_FILTER_CONNECTION(pConnection) );

    UlAcquireSpinLock(&pFilterProcess->pFilterChannel->SpinLock, &oldIrql);

    UlAcquireSpinLockAtDpcLevel(&pConnection->FilterConnLock);

    Status = UlpValidateFilterCall(pFilterProcess, pConnection);

    UlReleaseSpinLockFromDpcLevel(&pConnection->FilterConnLock);

    UlReleaseSpinLock(&pFilterProcess->pFilterChannel->SpinLock, oldIrql);

    if (!NT_SUCCESS(Status))
    {
        goto fatal;
    }

    //
    // Allocate & initialize a context structure if necessary.
    //

    pIrpContext = UlPplAllocateIrpContext();

    if (pIrpContext == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto fatal;
    }

    ASSERT( IS_VALID_IRP_CONTEXT( pIrpContext ) );

    pIrpContext->pConnectionContext = (PVOID)pConnection->pConnectionContext;
    pIrpContext->pCompletionRoutine = &UlpRestartFilterRawWrite;
    pIrpContext->pCompletionContext = pIrp;
    pIrpContext->pOwnIrp            = NULL;
    pIrpContext->OwnIrpContext      = FALSE;

    //
    // Try to send the data, allocating an MDL if necessary.
    //
    if (pIrpSp->Parameters.DeviceIoControl.InputBufferLength
        == sizeof(HTTP_FILTER_BUFFER_PLUS))
    {
        pFiltBufferPlus =
            (PHTTP_FILTER_BUFFER_PLUS) pIrp->AssociatedIrp.SystemBuffer;

        pMdl = UlAllocateLockedMdl(
                    pFiltBufferPlus->pWriteBuffer,
                    pFiltBufferPlus->WriteBufferSize,
                    IoReadAccess
                    );

        if (pMdl == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto fatal;
        }

        //
        // Save the PMDL so we can deallocate it on IRP completion.
        //
        UL_MDL_FROM_IRP(pIrp) = pMdl;

        //
        // Send the data.
        //
        Status = (pConnection->pSendRawDataHandler)(
            pConnection->pConnectionContext,
            pMdl,
            pFiltBufferPlus->WriteBufferSize,
            pIrpContext,
            FALSE
            );

    }
    else
    {
        ASSERT(NULL != pIrp->MdlAddress);

        Status = (pConnection->pSendRawDataHandler)(
                    pConnection->pConnectionContext,
                    pIrp->MdlAddress,
                    BufferLength,
                    pIrpContext,
                    FALSE
                    );

    }

    if (!NT_SUCCESS(Status))
    {
        goto fatal;
    }

    return STATUS_PENDING;

fatal:
    ASSERT(!NT_SUCCESS(Status));

    //
    // Unlock the output buffer and free our MDL if necessary.
    //
    if (pMdl != NULL)
    {
        PHTTP_FILTER_BUFFER_PLUS pHttpBuffer;

        UlFreeLockedMdl(pMdl);
        pMdl = NULL;
        UL_MDL_FROM_IRP(pIrp) = NULL;
        pHttpBuffer =
            (PHTTP_FILTER_BUFFER_PLUS)pIrp->AssociatedIrp.SystemBuffer;
        pHttpBuffer->pWriteBuffer = NULL;
        pHttpBuffer->WriteBufferSize = 0;
    }

    if (pIrpContext != NULL)
    {
        UlPplFreeIrpContext( pIrpContext );
    }

    (pConnection->pCloseConnectionHandler)(
                pConnection->pConnectionContext,
                TRUE,           // AbortiveDisconnect
                NULL,           // pCompletionRoutine
                NULL            // pCompletionContext
                );

    //
    // Complete the IRP.
    //
    pIrp->IoStatus.Status = Status;
    pIrp->IoStatus.Information = 0;

    UlTrace(FILTER, (
        "http!UlFilterRawWrite sent %Id bytes from %p. Status = %x (fatal path)\n",
        pIrp->IoStatus.Information,
        pIrp,
        pIrp->IoStatus.Status
        ));

    UlCompleteRequest(pIrp, IO_NO_INCREMENT);

    //
    // STATUS_PENDING will cause the ioctl wrapper to
    // not complete (or touch in any way) the irp
    //

    Status = STATUS_PENDING;

    RETURN(Status);

}


/***************************************************************************++

Routine Description:

    Receives unfiltered data from the http application.

    First we'll try to grab some data by calling
    UxpCopyQueuedWriteData. If we get nothing we'll queue the
    read by calling UxpQueueFilterRead with the IRP.

Arguments:

    pFilterProcess - the calling filter process
    pConnection - the connection from which the data originated
    pIrp - IRP from the caller

--***************************************************************************/
NTSTATUS
UlFilterAppRead(
    IN PUL_FILTER_PROCESS pFilterProcess,
    IN PUX_FILTER_CONNECTION pConnection,
    IN PIRP pIrp
    )
{
    NTSTATUS Status;
    KIRQL oldIrql;
    HTTP_FILTER_BUFFER_TYPE BufferType;
    ULONG BytesCopied;
    PUCHAR pIrpBuffer;
    ULONG IrpBufferLength;
    PUCHAR pIrpDataBuffer;

    //
    // Sanity check.
    //

    //
    // This function can currently be called at DPC when called at write
    // completion.  This assertion should be reinstating if/when the
    // read post is moved to the combined read/write IOCTL.
    //
//    ASSERT( KeGetCurrentIrql() == PASSIVE_LEVEL );

    ASSERT( IS_VALID_FILTER_PROCESS(pFilterProcess) );
    ASSERT( IS_VALID_FILTER_CONNECTION(pConnection) );
    ASSERT( pIrp );
    ASSERT(NULL != pIrp->MdlAddress);

    UlAcquireSpinLock(&pFilterProcess->pFilterChannel->SpinLock, &oldIrql);

    UlAcquireSpinLockAtDpcLevel(&pConnection->FilterConnLock);

    Status = UlpValidateFilterCall(pFilterProcess, pConnection);

    if (!NT_SUCCESS(Status))
    {
        goto end;
    }

    //
    // See if we can copy some data immediately.
    //

    if (pConnection->AppToFiltQueue.PendingWriteCount > 0)
    {
        //
        // Get the output buffer from the IRP.
        //

        pIrpBuffer = (PUCHAR) MmGetSystemAddressForMdlSafe(
                                    pIrp->MdlAddress,
                                    NormalPagePriority
                                    );

        if (!pIrpBuffer)
        {
            //
            // Insufficient resources to map the IRP buffer.
            //

            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto end;
        }

        IrpBufferLength = MmGetMdlByteCount(pIrp->MdlAddress);

        if (IrpBufferLength <= sizeof(HTTP_FILTER_BUFFER))
        {
            //
            // Insufficient buffer space to copy any data.
            //

            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto end;
        }

        pIrpDataBuffer = pIrpBuffer + sizeof(HTTP_FILTER_BUFFER);

        Status = UxpCopyQueuedWriteData(
                        &pConnection->AppToFiltQueue,
                        &BufferType,
                        pIrpDataBuffer,
                        IrpBufferLength - sizeof(HTTP_FILTER_BUFFER),
                        NULL,
                        &BytesCopied
                        );

        if (NT_SUCCESS(Status))
        {
            PHTTP_FILTER_BUFFER pFilterBuffer;

            //
            // We got the data. Fill out the buffer structure.
            //

            pFilterBuffer = (PHTTP_FILTER_BUFFER)pIrpBuffer;
            pFilterBuffer->BufferType = BufferType;

            if (BufferType == HttpFilterBufferHttpStream)
            {
                pFilterBuffer->pBuffer = FIXUP_PTR(
                    PUCHAR,
                    MmGetMdlVirtualAddress(pIrp->MdlAddress),
                    pIrpBuffer,
                    pIrpDataBuffer,
                    IrpBufferLength
                    );
                pFilterBuffer->BufferSize = BytesCopied;
            }
            else
            {
                pFilterBuffer->pBuffer = NULL;
                pFilterBuffer->BufferSize = 0;
            }

            //
            // Set up all the IRP stuff and complete the IRP.
            //

            IoMarkIrpPending(pIrp);

            pIrp->IoStatus.Status = Status;
            pIrp->IoStatus.Information = sizeof(HTTP_FILTER_BUFFER) +
                                         pFilterBuffer->BufferSize;

            UlCompleteRequest(pIrp, IO_NO_INCREMENT);

            //
            // Return pending for consistency with the case where
            // we queue the IRP.
            //

            Status = STATUS_PENDING;
        }
    }
    else
    {
        //
        // We don't have any data to copy at the moment.
        // Queue the read.
        //

        Status = UxpQueueFilterRead(
                        pConnection,
                        &pConnection->AppToFiltQueue,
                        pIrp,
                        UlpCancelFilterAppRead
                        );

    }

end:
    UlReleaseSpinLockFromDpcLevel(&pConnection->FilterConnLock);

    UlReleaseSpinLock(&pFilterProcess->pFilterChannel->SpinLock, oldIrql);

    UlTrace(FILTER, (
        "UlFilterAppRead(pConn = %p, pIrp = %p) returning %x\n",
        pConnection,
        pIrp,
        Status
        ));

    RETURN(Status);

}


/***************************************************************************++

Routine Description:

    Writes filtered data back to a connection. That data will be parsed
    and routed to an application pool.

Arguments:

    pFilterProcess - the calling filter process
    pConnection - the connection from which the data originated
    pIrp - IRP from the caller

--***************************************************************************/
NTSTATUS
UlFilterAppWrite(
    IN PUL_FILTER_PROCESS pFilterProcess,
    IN PUX_FILTER_CONNECTION pConnection,
    IN PIRP pIrp
    )
{
    NTSTATUS Status;
    BOOLEAN QueuedIrp = FALSE;
    KIRQL oldIrql;
    PUL_SSL_INFORMATION pSslInformation = NULL;
    HTTP_SSL_SERVER_CERT_INFO ServerCertInfo;
    ULONG TakenLength = 0;
    PHTTP_FILTER_BUFFER pFiltBuffer;
    PUCHAR pDataBuffer;
    ULONG DataBufferSize;
    PIO_STACK_LOCATION pIrpSp;
    PMDL pMdl = NULL;
    PMDL pMdlData = NULL;

    //
    // Sanity check.
    //
    ASSERT( KeGetCurrentIrql() == PASSIVE_LEVEL );
    ASSERT( IS_VALID_FILTER_PROCESS(pFilterProcess) );
    ASSERT( IS_VALID_FILTER_CONNECTION(pConnection) );
    ASSERT( pIrp );

    UlAcquireSpinLock(&pFilterProcess->pFilterChannel->SpinLock, &oldIrql);

    UlAcquireSpinLockAtDpcLevel(&pConnection->FilterConnLock);

    Status = UlpValidateFilterCall(pFilterProcess, pConnection);

    UlReleaseSpinLockFromDpcLevel(&pConnection->FilterConnLock);

    UlReleaseSpinLock(&pFilterProcess->pFilterChannel->SpinLock, oldIrql);

    if (!NT_SUCCESS(Status))
    {
        goto end;
    }

    //
    // Get buffer info.
    //
    pIrpSp = IoGetCurrentIrpStackLocation( pIrp );

    if (pIrpSp->Parameters.DeviceIoControl.InputBufferLength
        == sizeof(HTTP_FILTER_BUFFER_PLUS))
    {
        PHTTP_FILTER_BUFFER_PLUS pFiltBufferPlus;

        //
        // First, check if MdlAddress is fine.
        //

        if (pIrp->MdlAddress == NULL)
        {
            Status = STATUS_INVALID_PARAMETER;
            goto end;
        }

        pFiltBufferPlus =
            (PHTTP_FILTER_BUFFER_PLUS) pIrp->AssociatedIrp.SystemBuffer;
        DataBufferSize = pFiltBufferPlus->WriteBufferSize;
        pFiltBuffer = (PHTTP_FILTER_BUFFER)pFiltBufferPlus;

        //
        // Allocate an MDL and map the write buffer.  We'll deallocate at
        // write completion.
        //
        pMdl = UlAllocateLockedMdl(
                    pFiltBufferPlus->pWriteBuffer,
                    pFiltBufferPlus->WriteBufferSize,
                    IoReadAccess);

        if (pMdl == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto end;
        }

        pMdlData = pMdl;
        pDataBuffer = (PUCHAR) MmGetSystemAddressForMdlSafe(
            pMdl,
            LowPagePriority
            );

        //
        // We need to save the MDL somewhere so the completion routine can
        // free it.
        //
        UL_MDL_FROM_IRP(pIrp) = pMdl;

    }
    else
    {
        pFiltBuffer = (PHTTP_FILTER_BUFFER) pIrp->AssociatedIrp.SystemBuffer;

        if (HttpFilterBufferNotifyDisconnect == pFiltBuffer->BufferType)
        {
            (pConnection->pDisconnectNotificationHandler)(
                pConnection->pConnectionContext
                );

            Status = STATUS_PENDING;
            pIrp->IoStatus.Status = STATUS_SUCCESS;
            pIrp->IoStatus.Information = 0;
            goto end;
        }

        pMdlData = pIrp->MdlAddress;
        if (pMdlData == NULL)
        {
            Status = STATUS_INVALID_PARAMETER;
            goto end;
        }

        pDataBuffer = (PUCHAR) MmGetSystemAddressForMdlSafe(
                        pMdlData,
                        LowPagePriority
                        );

        pIrpSp = IoGetCurrentIrpStackLocation( pIrp );
        DataBufferSize = pIrpSp->Parameters.DeviceIoControl.OutputBufferLength;
    }

    ASSERT(pIrp->MdlAddress != NULL);

    if (!pDataBuffer)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }
    else
    {
        //
        // Actually do something with the data.
        //

        switch (pFiltBuffer->BufferType)
        {
        case HttpFilterBufferHttpStream:
            //
            // Handle this case later inside the filter lock.
            //

            break;

        case HttpFilterBufferSslInitInfo:

            VALIDATE_BUFFER_ALIGNMENT(pDataBuffer, HTTP_SSL_INFO);

            //
            // Capture all the SSL info.
            //
            pSslInformation = (PUL_SSL_INFORMATION) UL_ALLOCATE_POOL(
                                    NonPagedPool,
                                    sizeof(*pSslInformation),
                                    UL_SSL_INFO_POOL_TAG
                                    );

            if (!pSslInformation)
            {
                Status = STATUS_NO_MEMORY;
                goto end;
            }

            RtlZeroMemory(pSslInformation, sizeof(*pSslInformation));

            Status = UlpCaptureSslInfo(
                            pIrp->RequestorMode,
                            (PHTTP_SSL_INFO)pDataBuffer,
                            DataBufferSize,
                            pSslInformation,
                            &TakenLength
                            );
            break;

        case HttpFilterBufferSslServerCert:

            VALIDATE_BUFFER_ALIGNMENT(pDataBuffer, HTTP_SSL_SERVER_CERT_INFO);

            //
            // HTTP Client does not use SslInformation for now
            //
            // RtlZeroMemory(&SslInformation, sizeof(SslInformation));

            //
            // Capture Server certificate
            //
            Status = UcCaptureSslServerCertInfo(
                            pConnection,
                            (PHTTP_SSL_SERVER_CERT_INFO)pDataBuffer,
                            DataBufferSize,
                            &ServerCertInfo,
                            &TakenLength
                            );
            break;

        case HttpFilterBufferSslClientCert:
        case HttpFilterBufferSslClientCertAndMap:

            VALIDATE_BUFFER_ALIGNMENT(pDataBuffer, HTTP_SSL_CLIENT_CERT_INFO);

            //
            // Capture the client certificate.
            //
            pSslInformation = (PUL_SSL_INFORMATION) UL_ALLOCATE_POOL(
                                    NonPagedPool,
                                    sizeof(*pSslInformation),
                                    UL_SSL_INFO_POOL_TAG
                                    );

            if (!pSslInformation)
            {
                Status = STATUS_NO_MEMORY;
                goto end;
            }

            RtlZeroMemory(pSslInformation, sizeof(*pSslInformation));

            Status = UlpCaptureSslClientCert(
                            pIrp->RequestorMode,
                            (PHTTP_SSL_CLIENT_CERT_INFO)pDataBuffer,
                            DataBufferSize,
                            pSslInformation,
                            &TakenLength
                            );

            Status = STATUS_SUCCESS;
            break;

        default:

            UlTrace(FILTER, (
                "http!UlFilterAppWrite invalid buffer type: %d\n",
                pFiltBuffer->BufferType
                ));

            Status = STATUS_INVALID_PARAMETER;
            break;
        }
    }

    if (!NT_SUCCESS(Status))
    {
        goto end;
    }

    //
    // Now acquire the lock and either pass data to the app
    // or update the connection with captured certificate information.
    //

    UlAcquireSpinLock(&pConnection->FilterConnLock, &oldIrql);

    if (pConnection->ConnState == UlFilterConnStateConnected)
    {
        switch (pFiltBuffer->BufferType)
        {
        case HttpFilterBufferHttpStream:

            Status = UlpFilterAppWriteStream(
                            pConnection,
                            pIrp,
                            pMdlData,
                            pDataBuffer,
                            DataBufferSize,
                            &TakenLength
                            );

            if (Status == STATUS_PENDING)
            {
                //
                // Remember we queued the IRP so we don't
                // complete it at the bottom of this function.
                //

                QueuedIrp = TRUE;
            }

            break;

        case HttpFilterBufferSslServerCert:

            Status = UcAddServerCertInfoToConnection(
                            pConnection,
                            &ServerCertInfo
                            );

            pConnection->SslInfoPresent = 1;
            break;

        case HttpFilterBufferSslInitInfo:

            //
            // Store the SSL info in the connection.
            //

            Status = UlpAddSslInfoToConnection(
                            pConnection,
                            pSslInformation
                            );
            break;

        case HttpFilterBufferSslClientCert:
        case HttpFilterBufferSslClientCertAndMap:

            //
            // Store the client certificate in the connection.
            //

            Status = UlpAddSslClientCertToConnection(
                            pConnection,
                            pSslInformation
                            );

            Status = STATUS_SUCCESS;
            break;

        default:
            ASSERT(!"Previous switch statement should have caught this!\n");

            UlTrace(FILTER, (
                "http!UlFilterAppWrite invalid buffer type: %d\n",
                pFiltBuffer->BufferType
                ));

            Status = STATUS_INVALID_PARAMETER;
            break;
        }

        //
        // On success we always complete the IRP ourselves and
        // return pending.
        //
        if (NT_SUCCESS(Status))
        {
            //
            // Set IRP status.
            //
            pIrp->IoStatus.Status = Status;
            pIrp->IoStatus.Information = TakenLength;

            Status = STATUS_PENDING;
        }
    }
    else
    {
        //
        // Connection is closed. Don't do a callback.
        //
        Status = STATUS_INVALID_PARAMETER;
    }

    UlReleaseSpinLock(&pConnection->FilterConnLock, oldIrql);

    //
    // See if the parent connection code is interested in knowing about when
    // the server certificate got installed.
    //

    if(pConnection->pServerCertIndicateHandler &&
       pFiltBuffer->BufferType == HttpFilterBufferSslServerCert)
    {
        (pConnection->pServerCertIndicateHandler)
            (pConnection->pConnectionContext, Status);
    }

end:

    if (!NT_SUCCESS(Status))
    {
        pIrp->IoStatus.Status = Status;
        pIrp->IoStatus.Information = 0;
    }

    //
    // Free SslInformation in g_UlSystemProcess if capture fails.
    //

    if (pSslInformation)
    {
        UlInitializeWorkItem(&pSslInformation->WorkItem);

        if (pSslInformation->Token)
        {
            UL_QUEUE_WORK_ITEM(
                &pSslInformation->WorkItem,
                &UlpFreeSslInformationWorker
                );
        }
        else
        {
            UlpFreeSslInformationWorker(
                &pSslInformation->WorkItem
                );
        }
    }

    //
    // Unlock the output buffer and free our MDL if we are done with it.
    // Otherwise, it will be freed upon write completion.
    //
    if ((!NT_SUCCESS(Status) || !QueuedIrp) && pMdl != NULL)
    {
        UlFreeLockedMdl(pMdl);
        pMdl = NULL;
        UL_MDL_FROM_IRP(pIrp) = NULL;
    }

    //
    // Complete the IRP if we we're successful. Otherwise
    // the ioctl wrapper will handle the completion.
    //
    UlTrace(FILTER, (
        "http!UlFilterAppWrite copied %Iu bytes from %p. Status = %x\n",
        pIrp->IoStatus.Information,
        pIrp,
        pIrp->IoStatus.Status
        ));

    if (NT_SUCCESS(Status) && !QueuedIrp)
    {
        //
        // We're done with the write operation.
        //
        pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

        if (pIrpSp->Parameters.DeviceIoControl.InputBufferLength
            == sizeof(HTTP_FILTER_BUFFER_PLUS))
        {
            //
            // We no longer need access to the write buffer.
            //
            PHTTP_FILTER_BUFFER_PLUS pHttpBuffer =
                (PHTTP_FILTER_BUFFER_PLUS) pIrp->AssociatedIrp.SystemBuffer;
            pHttpBuffer->pWriteBuffer = NULL;
            pHttpBuffer->WriteBufferSize = 0;

            //
            // Indicate that the write operation can be considered complete
            // and not pending.
            //
            Status = STATUS_SUCCESS;
        }
        else
        {
            UlCompleteRequest(pIrp, IO_NO_INCREMENT);
        }
    }
    else if (NT_SUCCESS(Status))
    {
        //
        // If we successfully queued the IRP, we must return a pending status.
        //
        ASSERT(Status == STATUS_PENDING);
    }

    RETURN(Status);

}


/***************************************************************************++

Routine Description:

    Requests a client certificate from the filter process. If a cert
    is present, this function returns it. Otherwise the IRP is queued
    on the connection until a cert arrives. Only one such IRP can
    be queued at a time. After the IRP is queued a request for the
    client cert is sent to the filter process.

Arguments:

    pProcess - the calling worker process
    pHttpConn - the connection on which to renegotiate
    Flags - e.g. UL_RECEIVE_CLIENT_CERT_FLAG_MAP
    pIrp - the IRP from the caller

--***************************************************************************/
NTSTATUS
UlReceiveClientCert(
    PUL_APP_POOL_PROCESS pProcess,
    PUX_FILTER_CONNECTION pConnection,
    ULONG Flags,
    PIRP pIrp
    )
{
    NTSTATUS Status = STATUS_UNSUCCESSFUL;
    KIRQL oldIrql;
    PIO_STACK_LOCATION pIrpSp;
    PUL_FILTER_CHANNEL pFilterChannel;
    BOOLEAN DoCertRequest;
    HTTP_FILTER_BUFFER_TYPE CertRequestType;
    BOOLEAN DoCompleteReceiveClientCertIrp;

    UNREFERENCED_PARAMETER(pProcess);

    //
    // Sanity check.
    //
    ASSERT( KeGetCurrentIrql() == PASSIVE_LEVEL );

    ASSERT( IS_VALID_FILTER_CONNECTION(pConnection) );

    ASSERT( IS_VALID_IRP(pIrp) );

    if (!pConnection->SecureConnection)
    {
        //
        // this is not a secure connection.
        //

        return STATUS_INVALID_PARAMETER;
    }

    pFilterChannel = pConnection->pFilterChannel;
    ASSERT( IS_VALID_FILTER_CHANNEL(pFilterChannel) );

    //
    // Set up cert request info.
    //
    DoCertRequest = FALSE;
    DoCompleteReceiveClientCertIrp = FALSE;

    if (Flags & HTTP_RECEIVE_CLIENT_CERT_FLAG_MAP)
    {
        CertRequestType = HttpFilterBufferSslRenegotiateAndMap;
    }
    else
    {
        CertRequestType = HttpFilterBufferSslRenegotiate;
    }

    //
    // Now we can try to retrieve the certificate.
    //

    UlAcquireSpinLock(&pFilterChannel->SpinLock, &oldIrql);
    UlAcquireSpinLockAtDpcLevel(&pConnection->FilterConnLock);

    if (pConnection->ConnState != UlFilterConnStateConnected)
    {
        Status = STATUS_INVALID_DEVICE_STATE;
        goto end;
    }

    if (pConnection->SslClientCertPresent)
    {
        //
        // We have the data. Copy it in. We need to do this outside the lock.
        //

        REFERENCE_FILTER_CONNECTION(pConnection);

        DoCompleteReceiveClientCertIrp = TRUE;

    }
    else
    {
        //
        // Queue the IRP.
        //

        if (pConnection->pReceiveCertIrp)
        {
            //
            // There is already an IRP here, we can't queue a second
            // one.
            //

            Status = STATUS_OBJECT_NAME_COLLISION;
            goto end;
        }

        //
        // Mark it pending.
        //

        IoMarkIrpPending(pIrp);

        //
        // Give the irp a pointer to the connection.
        //

        pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

        // Make sure we don't already have a reference to the UL_CONNECTION on this Irp.
        ASSERT( pConnection != pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer );

        pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer = pConnection;

        REFERENCE_FILTER_CONNECTION(pConnection);

        //
        // Save away a pointer to the process in the
        // IRP. We have to be sure that the DriverContext (PVOID [4])
        // in the IRP is big enough to hold both
        // the process pointer and a UL_WORK_ITEM for
        // this to work.
        //

        UL_PROCESS_FROM_IRP(pIrp) = PsGetCurrentProcess();

        //
        // Set to these to null just in case the cancel routine runs.
        //

        pIrp->Tail.Overlay.ListEntry.Flink = NULL;
        pIrp->Tail.Overlay.ListEntry.Blink = NULL;

        //
        // Set the cancel routine.
        //
        IoSetCancelRoutine(pIrp, &UlpCancelReceiveClientCert);

        //
        // cancelled?
        //

        if (pIrp->Cancel)
        {
            //
            // darn it, need to make sure the irp get's completed
            //

            if (IoSetCancelRoutine( pIrp, NULL ) != NULL)
            {
                //
                // we are in charge of completion, IoCancelIrp didn't
                // see our cancel routine (and won't).  ioctl wrapper
                // will complete it
                //
                DEREFERENCE_FILTER_CONNECTION(pConnection);

                pIrp->IoStatus.Information = 0;

                UlUnmarkIrpPending( pIrp );
                Status = STATUS_CANCELLED;
                goto end;
            }

            //
            // our cancel routine will run and complete the irp,
            // don't touch it
            //

            //
            // STATUS_PENDING will cause the ioctl wrapper to
            // not complete (or touch in any way) the IRP.
            //

            Status = STATUS_PENDING;
            goto end;
        }

        //
        // now we are safe to queue it
        //

        pConnection->pReceiveCertIrp = pIrp;

        //
        // We need a cert. Remember to request it after we
        // get outside the lock.
        //
        DoCertRequest = TRUE;
    }

end:
    UlReleaseSpinLockFromDpcLevel(&pConnection->FilterConnLock);
    UlReleaseSpinLock(&pFilterChannel->SpinLock, oldIrql);

    //
    // If we need a cert from the filter process then request it
    // now that we're outside the lock.
    //
    if (DoCertRequest)
    {
        //
        // Actually request the data by completing an app read IRP.
        // The completion routine will clean up on an async failure.
        //
        Status = UlpCompleteAppReadIrp(
                        pConnection,
                        CertRequestType,
                        NULL,
                        NULL
                        );

        if (NT_SUCCESS(Status))
        {
            Status = STATUS_PENDING;
        }
        else
        {
            //
            // Failed during UlpCompleteAppReadIrp; need to clean up.
            // We'll just abort the connection and let the normal
            // cleanup path dequeue and complete the IRP.
            //

            (pConnection->pCloseConnectionHandler)(
                        pConnection->pConnectionContext,
                        TRUE,           // AbortiveDisconnect
                        NULL,           // pCompletionRoutine
                        NULL            // pCompletionContext
                        );

            //
            // Return STATUS_PENDING so the wrapper will not
            // try to complete the IRP.
            //
            Status = STATUS_PENDING;
        }

    }
    else if(DoCompleteReceiveClientCertIrp)
    {
        Status = UlpCompleteReceiveClientCertIrp(
                        pConnection,
                        PsGetCurrentProcess(),
                        pIrp
                        );

        DEREFERENCE_FILTER_CONNECTION(pConnection);

    }

    RETURN(Status);

}



/***************************************************************************++

Routine Description:

    References a filter channel.

Arguments:

    pFilterChannel - the channel to ref

--***************************************************************************/
VOID
UlReferenceFilterChannel(
    IN PUL_FILTER_CHANNEL pFilterChannel
    REFERENCE_DEBUG_FORMAL_PARAMS
    )
{
    LONG refCount;

    //
    // Sanity check.
    //
    ASSERT( IS_VALID_FILTER_CHANNEL(pFilterChannel) );

    refCount = InterlockedIncrement(&pFilterChannel->RefCount);

    WRITE_REF_TRACE_LOG(
        g_pFilterTraceLog,
        REF_ACTION_REFERENCE_FILTER,
        refCount,
        pFilterChannel,
        pFileName,
        LineNumber
        );
}


/***************************************************************************++

Routine Description:

    Derferences a filter channel. If the reference count hits zero, the
    object is cleaned up.

Arguments:

    pFilterChannel - the channel to deref

--***************************************************************************/
VOID
UlDereferenceFilterChannel(
    IN PUL_FILTER_CHANNEL pFilterChannel
    REFERENCE_DEBUG_FORMAL_PARAMS
    )
{
    LONG refCount;
    KIRQL oldIrql;

    //
    // Sanity check.
    //
    ASSERT( IS_VALID_FILTER_CHANNEL(pFilterChannel) );

    //
    // Grab the lock on the global list to prevent the refcount
    // from bouncing back up from zero.
    //
    UlAcquireSpinLock(&g_pUlNonpagedData->FilterSpinLock, &oldIrql);

    refCount = InterlockedDecrement(&pFilterChannel->RefCount);

    //
    // If the counter hits zero remove from the list.
    // Do the rest of the cleanup later, outside the lock.
    //
    if (refCount == 0)
    {
        RemoveEntryList(&pFilterChannel->ListEntry);
        pFilterChannel->ListEntry.Flink = NULL;
        pFilterChannel->ListEntry.Blink = NULL;

        if(pFilterChannel == g_pSslServerFilterChannel)
        {
            g_pSslServerFilterChannel = NULL;
        }
    }

    UlReleaseSpinLock(&g_pUlNonpagedData->FilterSpinLock, oldIrql);

    WRITE_REF_TRACE_LOG(
        g_pFilterTraceLog,
        REF_ACTION_DEREFERENCE_FILTER,
        refCount,
        pFilterChannel,
        pFileName,
        LineNumber
        );

    //
    // Clean up the object if it has no more references.
    //
    if (refCount == 0)
    {
        //
        // Do some sanity checking.
        //
        ASSERT( UlDbgSpinLockUnowned(&pFilterChannel->SpinLock) );
        ASSERT( IsListEmpty(&pFilterChannel->ProcessListHead) );

        //
        // BUGBUG: clean up queued connections.
        //

        //
        // Cleanup any security descriptor on the object.
        //
        UlDeassignSecurity( &pFilterChannel->pSecurityDescriptor );

        //
        // Free the memory.
        //
        UL_FREE_POOL_WITH_SIG(pFilterChannel, UL_FILTER_CHANNEL_POOL_TAG);
    }
}


/***************************************************************************++

Routine Description:

    This function is called when data arrives on a filtered connection.
    It passes the data up to the filter process.

Arguments:

    pFilterChannel - pointer to the filter channel
    pConnection - the connection that just got some data
    pBuffer - the buffer containing the data
    IndicatedLength - amount of data in the buffer
    UnreceivedLength- Bytes that the transport has, but aren't in pBuffer
    pTakenLength - receives the amount of data we consumed

--***************************************************************************/
NTSTATUS
UlFilterReceiveHandler(
    IN PUX_FILTER_CONNECTION pConnection,
    IN PVOID pBuffer,
    IN ULONG IndicatedLength,
    IN ULONG UnreceivedLength,
    OUT PULONG pTakenLength
    )
{
    NTSTATUS Status;
    ULONG TransportBytesNotTaken;

    //
    // Sanity check.
    //
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);
    ASSERT(IS_VALID_FILTER_CONNECTION(pConnection));
    ASSERT(pBuffer);
    ASSERT(pTakenLength);

    //
    // Pass the data on to an accept IRP or a raw read IRP.
    //

    if (!pConnection->ConnectionDelivered)
    {
        //
        // Since this is the first receive on the connection,
        // we complete a FilterAccept call.
        //
        Status = UlDeliverConnectionToFilter(
                        pConnection,
                        pBuffer,
                        IndicatedLength,
                        pTakenLength
                        );
    }
    else
    {
        //
        // Filter the data.
        //
        Status = UxpProcessIndicatedData(
                        pConnection,
                        pBuffer,
                        IndicatedLength,
                        pTakenLength
                        );

    }

    //
    // Figure out how many bytes we didn't consume, including data
    // that TDI hasn't yet given us.
    //

    TransportBytesNotTaken = UnreceivedLength;

    if (NT_SUCCESS(Status))
    {
        TransportBytesNotTaken += (IndicatedLength - *pTakenLength);
    }

    //
    // If there is data we didn't take then TDI is going to stop
    // indications until we read that data with IRPs. If there
    // is some data we didn't take and we didn't encounter an
    // error, we should try to grab the data TDI stuck with.
    //

    if (NT_SUCCESS(Status) && TransportBytesNotTaken)
    {
        UxpSetBytesNotTaken(pConnection, TransportBytesNotTaken);
    }

    UlTrace(FILTER, (
                "http!UlpFilterReceiveHandler received %lu bytes on pconn = %p\n"
                "        Status = %x, TransportBytesNotTaken = %lu\n",
                IndicatedLength,
                pConnection,
                Status,
                TransportBytesNotTaken
                ));

    return Status;
}


/***************************************************************************++

Routine Description:

    This function is called whenever an app writes data to a filtered
    connection. It forwards all the data to the connections filter channel.

    First, we'll see if we can copy some data immediately
    by calling UxpCopyToQueuedRead. If not, or we could only
    copy part of the data, we'll queue the write by creating
    a filter write tracker with UxpCreateFilterWriteTracker,
    and then passing the tracker to UxpQueueFilterWrite.

Arguments:

    pConnection - the connection we're writing to
    pMdlChain - a chain of MDLs for the data
    Length - the total amount of data in the MDL chain
    pIrpContext - used to indicate completion to the caller

--***************************************************************************/
NTSTATUS
UlFilterSendHandler(
    IN PUX_FILTER_CONNECTION pConnection,
    IN PMDL pMdlChain,
    IN ULONG Length,
    IN PUL_IRP_CONTEXT pIrpContext
    )
{
    NTSTATUS Status;
    KIRQL oldIrql;
    ULONG BytesCopied;
    BOOLEAN OwnIrpContext;

    UlTrace(FILTER, (
                "http!UlFilterSendHandler processing %lu bytes on pconn = %p\n",
                Length,
                pConnection
                ));


    //
    // Sanity check.
    //
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);
    ASSERT(IS_VALID_FILTER_CONNECTION(pConnection));
    ASSERT(pMdlChain);
    ASSERT(pIrpContext);

    ASSERT(pConnection->ConnectionDelivered == TRUE);

    //
    // Get ready.
    //
    Status = STATUS_SUCCESS;
    BytesCopied = 0;
    OwnIrpContext = pIrpContext->OwnIrpContext;

    UlAcquireSpinLock(&pConnection->FilterConnLock, &oldIrql);

    if (pConnection->ConnState == UlFilterConnStateConnected)
    {
        PUX_FILTER_WRITE_TRACKER pTracker;
        PMDL pCurrentMdl;
        ULONG MdlOffset;

        //
        // Init locals to the beginning of the chain, in case
        // UxpCopyToQueuedRead doesn't set them.
        //

        pCurrentMdl = pMdlChain;
        MdlOffset = 0;

        //
        // try to write some data
        //

        Status = UxpCopyToQueuedRead(
                        &pConnection->AppToFiltQueue,
                        HttpFilterBufferHttpStream,
                        pMdlChain,
                        Length,
                        &pCurrentMdl,
                        &MdlOffset,
                        &BytesCopied
                        );

        //
        // if we're not done, pend a write tracker.
        //

        if (Status == STATUS_MORE_PROCESSING_REQUIRED)
        {
            pTracker = UxpCreateFilterWriteTracker(
                            HttpFilterBufferHttpStream,
                            pCurrentMdl,
                            MdlOffset,
                            Length,
                            BytesCopied,
                            UlpRestartFilterSendHandler,
                            pIrpContext
                            );

            if (!pTracker)
            {
                //
                // Doh! We couldn't create the tracker. Get out.
                //
                Status = STATUS_NO_MEMORY;
                goto end;
            }

            //
            // Now stick it on the queue.
            //

            Status = UxpQueueFilterWrite(
                            pConnection,
                            &pConnection->AppToFiltQueue,
                            pTracker
                            );

            if (NT_SUCCESS(Status))
            {
                //
                // return pending so the caller knows not to complete
                // the IRP.
                //
                Status = STATUS_PENDING;
            }
            else
            {
                //
                // Kill the tracker. The caller will take care of
                // completing the IRP with the status we return.
                //

                UxpDeleteFilterWriteTracker(pTracker);
            }

        }

    }
    else
    {
        //
        // We got disconnected, get out.
        //
        UlTrace(FILTER, (
            "http!UlFilterSendHandler connection aborted, quit writing!\n"
            ));

        Status = STATUS_CONNECTION_DISCONNECTED;
    }

end:
    UlReleaseSpinLock(&pConnection->FilterConnLock, oldIrql);


    if (Status != STATUS_PENDING)
    {
        //
        // Do a "completion".
        //
        (pIrpContext->pCompletionRoutine)(
            pIrpContext->pCompletionContext,
            Status,
            BytesCopied
            );

        if (!OwnIrpContext)
        {
            UlPplFreeIrpContext( pIrpContext );
        }
    }

    return STATUS_PENDING;

} // UlFilterSendHandler


/***************************************************************************++

Routine Description:

    This function is called when the App issues a read to grab bytes that
    were previously queued on the connection. Note that the app should
    only issue a read if there were bytes queued. Therefore these read
    operations are always completed immediately and never queued and
    there should always be queued writes available.

Arguments:

    pConnection - the connection we're writing to
    pBuffer - a buffer to receive the data
    BufferLength - the total amount of data in the MDL chain
    pCompletionRoutine - used to indicate completion to the caller
    pCompletionContext - passed to the completion routine

--***************************************************************************/
NTSTATUS
UlFilterReadHandler(
    IN PUX_FILTER_CONNECTION pConnection,
    OUT PUCHAR pBuffer,
    IN ULONG BufferLength,
    IN PUL_COMPLETION_ROUTINE pCompletionRoutine,
    IN PVOID pCompletionContext
    )
{
    NTSTATUS Status;
    KIRQL oldIrql;
    ULONG BytesCopied = 0;
    PUX_FILTER_WRITE_TRACKER pTracker = NULL;

    UlTrace(FILTER, (
                "http!UlFilterReadHandler reading %lu bytes on pconn = %p\n",
                BufferLength,
                pConnection
                ));


    //
    // Sanity check.
    //
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);
    ASSERT(IS_VALID_FILTER_CONNECTION(pConnection));
    ASSERT(pBuffer);
    ASSERT(BufferLength);
    ASSERT(pCompletionRoutine);

    //
    // Read the data.
    //

    UlAcquireSpinLock(&pConnection->FilterConnLock, &oldIrql);

    if (pConnection->ConnState == UlFilterConnStateConnected)
    {
        HTTP_FILTER_BUFFER_TYPE BufferType;

        ASSERT(pConnection->FiltToAppQueue.PendingWriteCount > 0);

        //
        // Grab data from the filter write queue.
        //

        Status = UxpCopyQueuedWriteData(
                            &pConnection->FiltToAppQueue,   // write queue
                            &BufferType,                    // buffer type
                            pBuffer,                        // output buffer
                            BufferLength,                   // output buffer len
                            &pTracker,                      // tracker
                            &BytesCopied                    // pBytesCopied
                            );

        ASSERT(!NT_SUCCESS(Status) || BytesCopied);
        ASSERT(!NT_SUCCESS(Status) ||
                (BufferType == HttpFilterBufferHttpStream));

    }
    else
    {
        //
        // We got disconnected, get out.
        //

        Status = STATUS_CONNECTION_DISCONNECTED;
    }

    UlReleaseSpinLock(&pConnection->FilterConnLock, oldIrql);

    //
    // Call the completion routine. This has to happen before
    // UxpCompleteQueuedWrite as otherwise the latter completes the AppWrite
    // IRP which can in turn sends down another AppWrite before the current
    // read is completed.
    //

    Status = UlInvokeCompletionRoutine(
                    Status,
                    BytesCopied,
                    pCompletionRoutine,
                    pCompletionContext
                    );

    //
    // Since FilterAppWrite can queue maximum one WriteTracker, it is safe
    // to complete the QueuedWrite this way by letting UxpCopyQueuedWriteData
    // pass back the WriteTracker.
    //

    if (pTracker)
    {
        UxpCompleteQueuedWrite(
            STATUS_SUCCESS,
            pTracker->pWriteQueue,
            pTracker
            );
    }

    return Status;

} // UlFilterReadHandler



/***************************************************************************++

Routine Description:

    Tells the filter channel to close an open connection.

Arguments:

    pConnection - Supplies a pointer to a connection as previously
        indicated to the PUX_FILTER_CONNECTION_REQUEST handler.

    pCompletionRoutine - Supplies a pointer to a completion routine to
        invoke after the connection is fully closed.

    pCompletionContext - Supplies an uninterpreted context value for the
        completion routine.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlFilterCloseHandler(
    IN PUX_FILTER_CONNECTION pConnection,
    IN PUL_COMPLETION_ROUTINE pCompletionRoutine,
    IN PVOID pCompletionContext
    )
{
    NTSTATUS Status;

    //
    // Sanity check.
    //
    ASSERT(IS_VALID_FILTER_CONNECTION(pConnection));

    Status = UlpCompleteAppReadIrp(
                    pConnection,
                    HttpFilterBufferCloseConnection,
                    pCompletionRoutine,
                    pCompletionContext
                    );

    return Status;

} // UlFilterCloseHandler


/***************************************************************************++

Routine Description:

    Tells the filter channel to gracefully disconnect an open connection.

Arguments:

    pConnection - Supplies a pointer to a connection as previously
        indicated to the PUX_FILTER_CONNECTION_REQUEST handler.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlFilterDisconnectHandler(
    IN PUX_FILTER_CONNECTION pConnection
    )
{
    NTSTATUS Status;
    PIRP pIrp;
    KIRQL OldIrql;

    //
    // Sanity check.
    //
    ASSERT(IS_VALID_FILTER_CONNECTION(pConnection));

    Status = STATUS_MORE_PROCESSING_REQUIRED;

    UlAcquireSpinLock(&pConnection->FilterConnLock, &OldIrql);

    ASSERT(!pConnection->DisconnectNotified);
    ASSERT(!pConnection->DisconnectDelivered);

    pConnection->DisconnectNotified = TRUE;

    //
    // Try to complete a RawRead with 0 length buffer to indicate disconnect
    // but only if we have consumed all the transport bytes.
    //
    // If the filter is not connected, call the DisconnectNotificationHandler
    // immediately because there will be no call back from the app for
    // HttpFilterBufferNotifyDisconnect.
    //
    if (UlFilterConnStateInactive == pConnection->ConnState)
    {
        pConnection->DisconnectDelivered = TRUE;

        (pConnection->pDisconnectNotificationHandler)(
            pConnection->pConnectionContext
            );
    }
    else
    if (!pConnection->TdiReadPending && !pConnection->TransportBytesNotTaken)
    {
        pIrp = UxpDequeueRawReadIrp(pConnection);

        if (pIrp)
        {
            pConnection->DisconnectDelivered = TRUE;
            Status = STATUS_SUCCESS;

            //
            // Complete the IRP.
            //
            pIrp->IoStatus.Status = Status;
            pIrp->IoStatus.Information = 0;
            UlCompleteRequest(pIrp, IO_NETWORK_INCREMENT);
        }
    }

    UlReleaseSpinLock(&pConnection->FilterConnLock, OldIrql);

    UlTrace(FILTER, (
        "http!UlFilterDisconnectHandler pConn = %p, Status = %x\n",
        pConnection,
        Status
        ));

    return Status;

} // UlFilterDisconnectHandler


/***************************************************************************++

Routine Description:

    Removes a connection from any filter channel lists it might be on.
    Cancels all IRPs attached to the connection.

Arguments:

    pConnection - the connection to unbind

--***************************************************************************/
VOID
UlUnbindConnectionFromFilter(
    IN PUX_FILTER_CONNECTION pConnection
    )
{
    KIRQL oldIrql;
    PUL_FILTER_CHANNEL pFilterChannel;
    BOOLEAN DerefConnection;

    //
    // Sanity check.
    //
    ASSERT(IS_VALID_FILTER_CONNECTION(pConnection));
    ASSERT(IS_VALID_FILTER_CHANNEL(pConnection->pFilterChannel));

    UlTrace(FILTER, (
        "UlUnbindConnectionFromFilter(pConn = %p)\n",
        pConnection
        ));

    //
    // Clean up filter channel related stuff.
    //
    pFilterChannel = pConnection->pFilterChannel;
    DerefConnection = FALSE;

    UlAcquireSpinLock(&pFilterChannel->SpinLock, &oldIrql);
    UlAcquireSpinLockAtDpcLevel(&pConnection->FilterConnLock);

    if (pConnection->ConnState != UlFilterConnStateInactive)
    {

        if ((pConnection->ConnState == UlFilterConnStateQueued) ||
            (pConnection->ConnState == UlFilterConnStateConnected))
        {
            //
            // Remove from filter channel queue.
            //
            ASSERT( pConnection->ChannelEntry.Flink );

            //
            // Remember to remove the list's ref at the end.
            //
            DerefConnection = TRUE;

            //
            // Get off the list.
            //
            RemoveEntryList(&pConnection->ChannelEntry);
            pConnection->ChannelEntry.Flink = NULL;
            pConnection->ChannelEntry.Blink = NULL;

            pConnection->ConnState = UlFilterConnStateWillDisconnect;
        }

        //
        // Cancel RetrieveClientCert request
        //
        if (pConnection->pReceiveCertIrp)
        {
            if (IoSetCancelRoutine( pConnection->pReceiveCertIrp, NULL ) != NULL)
            {
                PIRP pIrp;

                UlTrace(FILTER, (
                    "http!UlUnbindConnectionFromFilter: cleaning up pReceiveCertIrp\n  pConn = %p\n",
                    pConnection
                    ));

                pConnection->pReceiveCertIrp->Cancel = TRUE;

                IoGetCurrentIrpStackLocation(
                    pConnection->pReceiveCertIrp
                    )->Parameters.DeviceIoControl.Type3InputBuffer = NULL;

                DEREFERENCE_FILTER_CONNECTION(pConnection);

                pConnection->pReceiveCertIrp->IoStatus.Status = STATUS_CANCELLED;
                pConnection->pReceiveCertIrp->IoStatus.Information = 0;

                pIrp = pConnection->pReceiveCertIrp;
                pConnection->pReceiveCertIrp = NULL;

                UlCompleteRequest(pIrp, IO_NO_INCREMENT);
            }
#if DBG
            else
            {
                UlTrace(FILTER, (
                    "http!UlUnbindConnectionFromFilter: IoSetCancelRoutine already NULL while cleaning up pConn = %p\n",
                    pConnection
                    ));
            }
#endif // DBG
        }

        //
        // Cancel FilterRawRead IRPs.
        //

        UxpCancelAllQueuedRawReads(pConnection);

        //
        // Cancel all I/O on the AppToFilt write queue.
        //

        UxpCancelAllQueuedIo(&pConnection->AppToFiltQueue);

        //
        // Cancel all I/O on the FiltToApp write queue.
        //

        UxpCancelAllQueuedIo(&pConnection->FiltToAppQueue);

    }

    UlReleaseSpinLockFromDpcLevel(&pConnection->FilterConnLock);
    UlReleaseSpinLock(&pFilterChannel->SpinLock, oldIrql);

    if (DerefConnection)
    {
        DEREFERENCE_FILTER_CONNECTION(pConnection);
    }

}


/***************************************************************************++

Routine Description:

    Marks a filtered connection as closed so that we'll stop passing on
    data from UlFilterAppWrite to the upper layers. This guarantees that
    they won't receive any more data after we told them the connection
    was closed.

    Also removes the connection from any filter channel lists.

Arguments:

    pConnection - the connection that's going away.

--***************************************************************************/
VOID
UlDestroyFilterConnection(
    IN PUX_FILTER_CONNECTION pConnection
    )
{
    KIRQL oldIrql;
    BOOLEAN DerefConnection;

    //
    // Sanity check.
    //
    ASSERT(IS_VALID_FILTER_CONNECTION(pConnection));

    UlAcquireSpinLock(&pConnection->pFilterChannel->SpinLock, &oldIrql);
    UlAcquireSpinLockAtDpcLevel(&pConnection->FilterConnLock);

    //
    // Make sure we remove ourselves from the filter channel's
    // list.
    //

    if ((pConnection->ConnState == UlFilterConnStateQueued) ||
        (pConnection->ConnState == UlFilterConnStateConnected))
    {
        //
        // Remove from filter channel queue.
        //
        ASSERT( pConnection->ChannelEntry.Flink );

        //
        // Remember to remove the list's ref at the end.
        //
        DerefConnection = TRUE;

        //
        // Get off the list.
        //
        RemoveEntryList(&pConnection->ChannelEntry);
        pConnection->ChannelEntry.Flink = NULL;
        pConnection->ChannelEntry.Blink = NULL;

    }
    else
    {
        //
        // Connection has already been removed from the list.
        //
        DerefConnection = FALSE;
    }

    //
    // Set the new connection state.
    //

    pConnection->ConnState = UlFilterConnStateDisconnected;

    UlReleaseSpinLockFromDpcLevel(&pConnection->FilterConnLock);
    UlReleaseSpinLock(&pConnection->pFilterChannel->SpinLock, oldIrql);

    //
    // Deref if we were removed from a list.
    //

    if (DerefConnection)
    {
        DEREFERENCE_FILTER_CONNECTION(pConnection);
    }

}


/***************************************************************************++

Routine Description:

    Copies SSL info from the connection into a buffer supplied by the
    caller. Can also be called with a NULL buffer to get the required
    length. If the buffer is too small to hold all the data, none
    will be copied.

Arguments:

    pConnection - the connection to query
    BufferSize - size of pBuffer in bytes
    pUserBuffer - optional pointer to user mode buffer
    pBuffer - optional output buffer (mapped to user mode buffer)
    pBytesCopied - if pBuffer is non-NULL and the function returns
        success, pBytesCopied returns the number of bytes copied
        into the buffer. If pBuffer is NULL it returns the number
        of bytes required for all the information.

--***************************************************************************/
NTSTATUS
UlGetSslInfo(
    IN PUX_FILTER_CONNECTION pConnection,
    IN ULONG BufferSize,
    IN PUCHAR pUserBuffer OPTIONAL,
    IN PEPROCESS pProcess OPTIONAL,
    OUT PUCHAR pBuffer OPTIONAL,
    OUT PHANDLE pMappedToken OPTIONAL,
    OUT PULONG pBytesCopied OPTIONAL
    )
{
    NTSTATUS Status;
    ULONG BytesCopied;
    ULONG BytesNeeded;
    PHTTP_SSL_INFO pSslInfo;
    PUCHAR pKeBuffer;

    ULONG IssuerSize;
    ULONG SubjectSize;
    ULONG ClientCertSize;
    ULONG ClientCertBytesCopied;

    //
    // Sanity check.
    //
    ASSERT(IS_VALID_FILTER_CONNECTION(pConnection));

    // Need to fix UlComputeRequestBytesNeeded before we can add the macro
    // PAGED_CODE()

    //
    // Initialize locals.
    //
    Status = STATUS_SUCCESS;
    BytesCopied = 0;
    BytesNeeded = 0;
    ClientCertBytesCopied = 0;

    //
    // Figure out how big the buffer is
    // including client cert if it's there.
    //

    IssuerSize = ALIGN_UP(
                        pConnection->SslInfo.ServerCertIssuerSize + sizeof(CHAR),
                        PVOID
                        );

    SubjectSize = ALIGN_UP(
                        pConnection->SslInfo.ServerCertSubjectSize + sizeof(CHAR),
                        PVOID
                        );

    if (pConnection->SslInfoPresent)
    {
        BytesNeeded += sizeof(HTTP_SSL_INFO);
        BytesNeeded += IssuerSize;
        BytesNeeded += SubjectSize;

        if (pConnection->SslClientCertPresent)
        {
            Status = UlpGetSslClientCert(
                            pConnection,    // pConnection
                            NULL,           // pProcess
                            0,              // BufferLength
                            NULL,           // pUserBuffer
                            NULL,           // pBuffer
                            NULL,           // pMappedToken
                            &ClientCertSize // pClientCertBytesCopied
                            );

            if (NT_SUCCESS(Status))
            {
                BytesNeeded += ClientCertSize;
            }
            else
            {
                goto exit;
            }
        }
        else
        {
            ClientCertSize = 0;
        }
    }


    //
    // Construct the HTTP_SSL_INFO in the callers buffer.
    //

    if (pBuffer && BytesNeeded && (BufferSize >= BytesNeeded))
    {
        //
        // Buffer must be properly aligned
        //
        ASSERT(0 == (((SIZE_T)pBuffer) % sizeof(PVOID)));

        //
        // Copy the easy stuff.
        //
        ASSERT(NT_SUCCESS(Status));

        RtlZeroMemory(pBuffer, BytesNeeded);

        pSslInfo = (PHTTP_SSL_INFO) pBuffer;

        pSslInfo->ServerCertKeySize =
            pConnection->SslInfo.ServerCertKeySize;

        pSslInfo->ConnectionKeySize =
            pConnection->SslInfo.ConnectionKeySize;

        pSslInfo->ServerCertIssuerSize =
            pConnection->SslInfo.ServerCertIssuerSize;

        pSslInfo->ServerCertSubjectSize =
            pConnection->SslInfo.ServerCertSubjectSize;

        //
        // User mode will first receive pSslInfo
        // and then if client certificate is requested
        // it will call back to http.sys to retrieve client cert
        // info.
        // However there are cases when user mode needs to
        // know ahead of time if client certificate has been
        // negotiated already
        //

        pSslInfo->SslClientCertNegotiated =
            ( pConnection->SslInfo.SslRenegotiationFailed ||
              pConnection->SslClientCertPresent );

        BytesCopied += sizeof(HTTP_SSL_INFO);

        //
        // Copy the server cert issuer.
        //

        pKeBuffer = pBuffer + sizeof(HTTP_SSL_INFO);

        pSslInfo->pServerCertIssuer = FIXUP_PTR(
                                            PSTR,
                                            pUserBuffer,
                                            pBuffer,
                                            pKeBuffer,
                                            BufferSize
                                            );
        RtlCopyMemory(
            pKeBuffer,
            pConnection->SslInfo.pServerCertIssuer,
            pConnection->SslInfo.ServerCertIssuerSize
            );

        BytesCopied += IssuerSize;

        //
        // Copy the server cert subject.
        //

        pKeBuffer += IssuerSize;

        pSslInfo->pServerCertSubject = FIXUP_PTR(
                                            PSTR,
                                            pUserBuffer,
                                            pBuffer,
                                            pKeBuffer,
                                            BufferSize
                                            );
        RtlCopyMemory(
            pKeBuffer,
            pConnection->SslInfo.pServerCertSubject,
            pConnection->SslInfo.ServerCertSubjectSize
            );

        BytesCopied += SubjectSize;

        //
        // Copy client certificate info.
        //

        pKeBuffer += SubjectSize;

        if (pConnection->SslClientCertPresent)
        {
            Status = UlpGetSslClientCert(
                            pConnection,                // pConnection
                            pProcess,                   // pProcess
                            (BufferSize - BytesCopied), // BufferSize
                            FIXUP_PTR(                  // pUserBuffer
                                PUCHAR,
                                pUserBuffer,
                                pBuffer,
                                pKeBuffer,
                                BufferSize
                                ),
                            pKeBuffer,                  // pBuffer
                            pMappedToken,               // pMappedToken
                            &ClientCertBytesCopied      // pBytesCopied
                            );

            if (NT_SUCCESS(Status))
            {
                BytesCopied += ClientCertBytesCopied;
            }
            else
            {
                goto exit;
            }
        }
    }

    //
    // Tell the caller either how many bytes were copied, or
    // how many will be copied when they give us a buffer.
    //
    ASSERT(NT_SUCCESS(Status));

    if (pBytesCopied)
    {
        if (pBuffer)
        {
            //
            // We actually copied the data.
            //
            ASSERT(BytesCopied == BytesNeeded);
            *pBytesCopied = BytesCopied;
        }
        else
        {
            //
            // Just tell the caller how bug the buffer has to be.
            //
            *pBytesCopied = BytesNeeded;
        }
    }

exit:

    if (!NT_SUCCESS(Status))
    {
        //
        // Right now the only way for this function to fail
        // is if we are unable to duplicate a token associated
        // with the client certificate. If there were another
        // way to fail after duping the token, we would have
        // to close the handle here.
        //
        ASSERT(ClientCertBytesCopied == 0);
    }

    return Status;

} // UlGetSslInfo


/***************************************************************************++

Routine Description:

    Returns a referenced pointer to the UX_FILTER_CONNECTION referred to by
    ConnectionId.

Arguments:

    ConnectionId - Supplies the connection ID to retrieve.

Return Value:

    PUX_FILTER_CONNECTION - Returns the UX_FILTER_CONNECTION if successful,
        NULL otherwise.

--***************************************************************************/
PUX_FILTER_CONNECTION
UlGetRawConnectionFromId(
    IN HTTP_RAW_CONNECTION_ID ConnectionId
    )
{
    PUX_FILTER_CONNECTION pConn;

    pConn = (PUX_FILTER_CONNECTION) UlGetObjectFromOpaqueId(
                                  ConnectionId,
                                  UlOpaqueIdTypeRawConnection,
                                  UxReferenceConnection
                                  );

    ASSERT(pConn == NULL || IS_VALID_FILTER_CONNECTION(pConn));

    return pConn;
}

//
// Private functions.
//

/***************************************************************************++

Routine Description:

    Tries to find a UL_FILTER_CHANNEL object.

Arguments:

    pName - name of the filter channel
    NameLength - length of the name in bytes
    pProcess - the process that is trying to find

--***************************************************************************/
PUL_FILTER_CHANNEL
UlpFindFilterChannel(
    IN PWCHAR    pName,
    IN USHORT    NameLength,
    IN PEPROCESS pProcess
    )
{
    PLIST_ENTRY        pEntry;
    PUL_FILTER_CHANNEL pChannel;
    ULONG              i;

    ASSERT(pName && NameLength != 0);
    ASSERT(pProcess);
    ASSERT(UlDbgSpinLockOwned(&g_pUlNonpagedData->FilterSpinLock));

    //
    // searching for server channel?
    //
    if(IsServerFilterChannel(pName, NameLength))
    {
        return g_pSslServerFilterChannel;
    }

    //
    // must be searching for client channel
    //
    ASSERT(IsClientFilterChannel(pName, NameLength));

    pChannel = NULL;

    i = FILTER_CHANNEL_HASH_FUNCTION(pProcess);

    pEntry = g_pSslClientFilterChannelTable[i].Flink;

    while (pEntry != &g_pSslClientFilterChannelTable[i])
    {
        pChannel = CONTAINING_RECORD(
                        pEntry,
                        UL_FILTER_CHANNEL,
                        ListEntry
                        );

        if (pChannel->pProcess == pProcess)
        {
            // match!
            break;
        }
        else
        {
            pChannel = NULL;
        }

        pEntry = pEntry->Flink;
    }

    return pChannel;
}


/***************************************************************************++

Routine Description:

    Add a UL_FILTER_CHANNEL object to the global collection

Arguments:

    pChannel - channel that is being added

--***************************************************************************/
NTSTATUS
UlpAddFilterChannel(
    IN PUL_FILTER_CHANNEL pChannel
    )
{
    ULONG i;

    ASSERT(pChannel);
    ASSERT(UlDbgSpinLockOwned(&g_pUlNonpagedData->FilterSpinLock));

    //
    // adding a server channel?
    //
    if(IsServerFilterChannel(pChannel->pName, pChannel->NameLength))
    {
        ASSERT(g_pSslServerFilterChannel == NULL);
        g_pSslServerFilterChannel = pChannel;

        return STATUS_SUCCESS;
    }

    //
    // must be adding a client channel
    //
    ASSERT(IsClientFilterChannel(pChannel->pName, pChannel->NameLength));

    i = FILTER_CHANNEL_HASH_FUNCTION(pChannel->pProcess);

    InsertHeadList(&g_pSslClientFilterChannelTable[i],
                   &pChannel->ListEntry);

    return STATUS_SUCCESS;
}

/***************************************************************************++

Routine Description:

    Allocates and initializes a UL_FILTER_CHANNEL object.

Arguments:

    pName - name of the filter channel
    NameLength - length of the name in bytes
    pAccessState - security parameter

--***************************************************************************/
NTSTATUS
UlpCreateFilterChannel(
    IN PWCHAR pName,
    IN USHORT NameLength,
    IN PACCESS_STATE pAccessState,
    OUT PUL_FILTER_CHANNEL *ppFilterChannel
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PUL_FILTER_CHANNEL pChannel = NULL;

    //
    // Sanity check.
    //
    PAGED_CODE();
    ASSERT(pName);
    ASSERT(NameLength);
    ASSERT(pAccessState);

    pChannel = UL_ALLOCATE_STRUCT_WITH_SPACE(
                    NonPagedPool,
                    UL_FILTER_CHANNEL,
                    NameLength + sizeof(WCHAR),
                    UL_FILTER_CHANNEL_POOL_TAG
                    );

    if (pChannel)
    {
        //
        // Init the simple fields.
        //
        RtlZeroMemory(
            pChannel,
            NameLength + sizeof(WCHAR) +
                sizeof(UL_FILTER_CHANNEL)
            );

        pChannel->Signature = UL_FILTER_CHANNEL_POOL_TAG;
        pChannel->RefCount = 1;
        pChannel->pProcess = PsGetCurrentProcess();

        UlInitializeSpinLock(&pChannel->SpinLock, "FilterChannelSpinLock");
        InitializeListHead(&pChannel->ListEntry);
        InitializeListHead(&pChannel->ProcessListHead);
        InitializeListHead(&pChannel->ConnectionListHead);

        pChannel->NameLength = NameLength;
        RtlCopyMemory(
            pChannel->pName,
            pName,
            NameLength+sizeof(WCHAR)
            );

        //
        // Assign security.
        //
        Status = UlAssignSecurity(
                        &pChannel->pSecurityDescriptor,
                        pAccessState
                        );

    }
    else
    {
        //
        // Could not allocate the channel object.
        //
        Status = STATUS_NO_MEMORY;
    }


    if (NT_SUCCESS(Status))
    {
        //
        // Return the object.
        //
        *ppFilterChannel = pChannel;
    }
    else if (pChannel)
    {
        UL_FREE_POOL_WITH_SIG(pChannel, UL_FILTER_CHANNEL_POOL_TAG);
    }

    return Status;
}

/***************************************************************************++

Routine Description:

    Allocates and initializes a UL_FILTER_PROCESS object.

Arguments:

    pChannel - the filter channel to which this object belongs

--***************************************************************************/
PUL_FILTER_PROCESS
UlpCreateFilterProcess(
    IN PUL_FILTER_CHANNEL pChannel
    )
{
    PUL_FILTER_PROCESS pProcess;

    //
    // Sanity check.
    //
    PAGED_CODE();
    ASSERT( IS_VALID_FILTER_CHANNEL(pChannel) );

    pProcess = UL_ALLOCATE_STRUCT(
                    NonPagedPool,
                    UL_FILTER_PROCESS,
                    UL_FILTER_PROCESS_POOL_TAG
                    );

    if (pProcess)
    {
        RtlZeroMemory(pProcess, sizeof(UL_FILTER_PROCESS));

        pProcess->Signature = UL_FILTER_PROCESS_POOL_TAG;
        pProcess->pFilterChannel = pChannel;
        pProcess->pProcess = PsGetCurrentProcess();

        InitializeListHead(&pProcess->ConnectionHead);
        InitializeListHead(&pProcess->IrpHead);
    }

    return pProcess;
}


/***************************************************************************++

Routine Description:

    Checks a filtered connection and the associated filter channel process
    to make sure they are in a reasonable state to do filter reads and writes.

Arguments:

    pFilterProcess - the process attempting an operation
    pConnection - the connection specified in the call

--***************************************************************************/
NTSTATUS
UlpValidateFilterCall(
    IN PUL_FILTER_PROCESS pFilterProcess,
    IN PUX_FILTER_CONNECTION pConnection
    )
{
    //
    // Sanity check.
    //
    ASSERT( KeGetCurrentIrql() == DISPATCH_LEVEL );
    ASSERT( IS_VALID_FILTER_PROCESS(pFilterProcess) );
    ASSERT( IS_VALID_FILTER_CONNECTION(pConnection) );
    ASSERT( UlDbgSpinLockOwned(&pFilterProcess->pFilterChannel->SpinLock) );
    ASSERT( UlDbgSpinLockOwned(&pConnection->FilterConnLock) );

    //
    // Make sure we're not cleaning up the process or the connection.
    //
    if (pFilterProcess->InCleanup ||
        (pConnection->ConnState != UlFilterConnStateConnected))
    {
        return STATUS_INVALID_HANDLE;
    }

    //
    // Make sure this process is supposed to be filtering this connection.
    //
    if (pConnection->pFilterChannel != pFilterProcess->pFilterChannel)
    {
        return STATUS_INVALID_PARAMETER;
    }

    return STATUS_SUCCESS;
}

/***************************************************************************++

Routine Description:

    Called on a raw close completion. Just completes the IRP.

Arguments:

    pContext - pointer to the FilterClose IRP
    Status - Status from UlpCloseRawConnection
    Information - bytes transferred

--***************************************************************************/
VOID
UlpRestartFilterClose(
    IN PVOID pContext,
    IN NTSTATUS Status,
    IN ULONG_PTR Information
    )
{
    PIRP pIrp;

    //
    // Complete the IRP.
    //
    pIrp = (PIRP) pContext;

    pIrp->IoStatus.Status = Status;
    pIrp->IoStatus.Information = Information;

    UlTrace(FILTER, (
        "http!UlpRestartFilterClose read %Iu bytes from %p. Status = %x\n",
        pIrp->IoStatus.Information,
        pIrp,
        pIrp->IoStatus.Status
        ));

    UlCompleteRequest(pIrp, IO_NETWORK_INCREMENT);

} // UlpRestartFilterClose


/***************************************************************************++

Routine Description:

    Called on a raw read completion. Just completes the IRP.

Arguments:

    pContext - pointer to the FilterRawRead IRP
    Status - Status from UlpReceiveRawData
    Information - bytes transferred

--***************************************************************************/
VOID
UlpRestartFilterRawRead(
    IN PVOID pContext,
    IN NTSTATUS Status,
    IN ULONG_PTR Information
    )
{
    PIRP pIrp;

    //
    // Complete the IRP.
    //
    pIrp = (PIRP) pContext;

    pIrp->IoStatus.Status = Status;
    pIrp->IoStatus.Information = Information;

    UlTrace(FILTER, (
        "http!UlpRestartFilterRawRead read %Id bytes from %p. Status = %x\n"
        "        pIrp->UserEvent = %p\n",
        pIrp->IoStatus.Information,
        pIrp,
        pIrp->IoStatus.Status,
        pIrp->UserEvent
        ));

    UlCompleteRequest(pIrp, IO_NETWORK_INCREMENT);

}


/***************************************************************************++

Routine Description:

    Called on a raw write completion. Just completes the IRP.

Arguments:

    pContext - pointer to the FilterRawWrite IRP
    Status - Status from UlpSendRawData
    Information - bytes transferred

--***************************************************************************/
VOID
UlpRestartFilterRawWrite(
    IN PVOID pContext,
    IN NTSTATUS Status,
    IN ULONG_PTR Information
    )
{
    PIRP pIrp;
    PIO_STACK_LOCATION pIrpSp;
    BOOLEAN DoRead;

    pIrp = (PIRP) pContext;
    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    pIrp->IoStatus.Status = Status;
    pIrp->IoStatus.Information = Information;

    UlTrace(FILTER, (
        "http!UlpRestartFilterRawWrite sent %Id bytes from %p. Status = %x\n"
        "        pIrp->UserEvent = %p\n",
        pIrp->IoStatus.Information,
        pIrp,
        pIrp->IoStatus.Status,
        pIrp->UserEvent
        ));

    //
    // If a read buffer was given, then free the write buffer MDL and
    // initiate the App Read now.  The user-mode IRP will be completed
    // by the App Read operation.  Otherwise, complete the IRP now.
    //
    DoRead = (BOOLEAN) (pIrpSp->Parameters.DeviceIoControl.InputBufferLength
                            == sizeof(HTTP_FILTER_BUFFER_PLUS));

    if (DoRead)
    {
        PHTTP_FILTER_BUFFER_PLUS pHttpBuffer;

        //
        // Free the write buffer MDL.
        //
        PMDL pMdl = UL_MDL_FROM_IRP(pIrp);

        if (pMdl != NULL)
        {
            UlFreeLockedMdl(pMdl);
            pMdl = NULL;
            UL_MDL_FROM_IRP(pIrp) = NULL;
        }

        //
        // Indicate to the App Read code that it no longer needs to trigger
        // a Raw Write.
        //
        pHttpBuffer =
            (PHTTP_FILTER_BUFFER_PLUS)pIrp->AssociatedIrp.SystemBuffer;
        pHttpBuffer->pWriteBuffer = NULL;
        pHttpBuffer->WriteBufferSize = 0;
    }

    //
    // Complete the IRP now if we don't need to do a read or we failed the
    // write operation.  If we don't complete the IRP here, the read operation
    // will complete it.
    //
    if (NT_SUCCESS(Status) && DoRead)
    {
        UlFilterRawWriteAndAppRead(pIrp, pIrpSp);
    }
    else
    {
        UlCompleteRequest(pIrp, IO_NETWORK_INCREMENT);
    }
}


/***************************************************************************++

Routine Description:

    Called on a queued app write completion. Just completes the IRP.

Arguments:

    pContext - pointer to the FilterRawWrite IRP
    Status - Status from UlpSendRawData
    Information - bytes transferred

--***************************************************************************/
VOID
UlpRestartFilterAppWrite(
    IN PVOID pContext,
    IN NTSTATUS Status,
    IN ULONG_PTR Information
    )
{
    PIRP pIrp;
    PIO_STACK_LOCATION pIrpSp;
    BOOLEAN DoRead;

    pIrp = (PIRP) pContext;
    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    pIrp->IoStatus.Status = Status;
    pIrp->IoStatus.Information = Information;

    //
    // If a Read buffer was given, post it now.  Otherwise, simply complete
    // the IRP now.
    //

    DoRead = (BOOLEAN) (pIrpSp->Parameters.DeviceIoControl.InputBufferLength
                            == sizeof(HTTP_FILTER_BUFFER_PLUS));

    if (DoRead)
    {
        PHTTP_FILTER_BUFFER_PLUS pHttpBuffer;

        //
        // Free the MDL we used for the write.
        //
        PMDL pMdl = UL_MDL_FROM_IRP(pIrp);
        if (pMdl)
        {
            UlFreeLockedMdl(pMdl);
            pMdl = NULL;
            UL_MDL_FROM_IRP(pIrp) = NULL;
        }

        //
        // Indicate that we no longer need to do a write.
        //
        pHttpBuffer =
                (PHTTP_FILTER_BUFFER_PLUS)pIrp->AssociatedIrp.SystemBuffer;
        pHttpBuffer->pWriteBuffer = NULL;
        pHttpBuffer->WriteBufferSize = 0;
    }

    if (NT_SUCCESS(Status) && DoRead)
    {
        //
        // Initiate the read, which will complete the IRP.
        //
        UlFilterAppWriteAndRawRead(pIrp, pIrpSp);
    }
    else
    {
        UlCompleteRequest(pIrp, IO_NETWORK_INCREMENT);
    }

}



/***************************************************************************++

Routine Description:

    Called on a queued send handler completion. Calls the completion routine.

Arguments:

    pContext - pointer to a UL_IRP_CONTEXT
    Status - Status
    Information - bytes transferred

--***************************************************************************/
VOID
UlpRestartFilterSendHandler(
    IN PVOID pContext,
    IN NTSTATUS Status,
    IN ULONG_PTR Information
    )
{
    PUL_IRP_CONTEXT pIrpContext = (PUL_IRP_CONTEXT)pContext;
    BOOLEAN OwnIrpContext;

    ASSERT(IS_VALID_IRP_CONTEXT(pIrpContext));
    OwnIrpContext = pIrpContext->OwnIrpContext;

    //
    // Do a "completion".
    //

    if (pIrpContext->pCompletionRoutine)
    {
        (pIrpContext->pCompletionRoutine)(
            pIrpContext->pCompletionContext,
            Status,
            Information
            );
    }
    if (!OwnIrpContext)
    {
        UlPplFreeIrpContext(pIrpContext);
    }
}


/***************************************************************************++

Routine Description:

    cancels the pending user mode irp which was to accept a connection.
    this routine ALWAYS results in the irp being completed.

    note: we queue off to cancel in order to process the cancellation at lower
    irql.

    CODEWORK: do we still need to do this?

Arguments:

    pDeviceObject - the device object

    pIrp - the irp to cancel

--***************************************************************************/
VOID
UlpCancelFilterAccept(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    )
{
    UNREFERENCED_PARAMETER(pDeviceObject);

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    ASSERT(pIrp != NULL);

    //
    // release the cancel spinlock.  This means the cancel routine
    // must be the one completing the irp (to avoid the race of
    // completion + reuse prior to the cancel routine running).
    //

    IoReleaseCancelSpinLock(pIrp->CancelIrql);

    //
    // queue the cancel to a worker to ensure passive irql.
    //

    UL_CALL_PASSIVE(
        UL_WORK_ITEM_FROM_IRP( pIrp ),
        &UlpCancelFilterAcceptWorker
        );

}

/***************************************************************************++

Routine Description:

    Actually performs the cancel for the irp.

Arguments:

    pWorkItem - the work item to process.

--***************************************************************************/
VOID
UlpCancelFilterAcceptWorker(
    IN PUL_WORK_ITEM pWorkItem
    )
{
    PUL_FILTER_CHANNEL  pFilterChannel;
    PIRP                pIrp;
    KIRQL               oldIrql;

    //
    // Sanity check.
    //
    ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);
    ASSERT(pWorkItem != NULL);

    //
    // grab the irp off the work item
    //

    pIrp = UL_WORK_ITEM_TO_IRP( pWorkItem );

    ASSERT(IS_VALID_IRP(pIrp));

    //
    // grab the filter channel off the irp
    //

    pFilterChannel = (PUL_FILTER_CHANNEL)(
                        IoGetCurrentIrpStackLocation(pIrp)->Parameters.DeviceIoControl.Type3InputBuffer
                        );

    ASSERT(IS_VALID_FILTER_CHANNEL(pFilterChannel));

    //
    // grab the lock protecting the queue
    //

    UlAcquireSpinLock(&pFilterChannel->SpinLock, &oldIrql);

    //
    // does it need to be de-queue'd ?
    //

    if (pIrp->Tail.Overlay.ListEntry.Flink != NULL)
    {
        //
        // remove it
        //

        RemoveEntryList(&pIrp->Tail.Overlay.ListEntry);
        pIrp->Tail.Overlay.ListEntry.Flink = NULL;
        pIrp->Tail.Overlay.ListEntry.Blink = NULL;
    }

    //
    // let the lock go
    //

    UlReleaseSpinLock(&pFilterChannel->SpinLock, oldIrql);

    //
    // let our reference go
    //

    IoGetCurrentIrpStackLocation(pIrp)->Parameters.DeviceIoControl.Type3InputBuffer = NULL;

    DEREFERENCE_FILTER_CHANNEL(pFilterChannel);

    //
    // complete the irp
    //

    pIrp->IoStatus.Status = STATUS_CANCELLED;
    pIrp->IoStatus.Information = 0;

    UlCompleteRequest( pIrp, IO_NO_INCREMENT );

}   // UlpCancelFilterAccept


/***************************************************************************++

Routine Description:

    Cancels the pending user mode irp which was to read from a raw
    connection.

    This routine ALWAYS results in the IRP being completed.

Arguments:

    pDeviceObject - the device object

    pIrp - the irp to cancel

--***************************************************************************/
VOID
UlpCancelFilterRawRead(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    )
{
    PUX_FILTER_CONNECTION pConnection;
    PIO_STACK_LOCATION pIrpSp;
    KIRQL oldIrql;

    UNREFERENCED_PARAMETER(pDeviceObject);

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);
    ASSERT(pIrp != NULL);

    //
    // release the cancel spinlock.  This means the cancel routine
    // must be the one completing the irp (to avoid the race of
    // completion + reuse prior to the cancel routine running).
    //

    IoReleaseCancelSpinLock(pIrp->CancelIrql);

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

    //
    // Grab the connection off the IRP.
    //
    pConnection = (PUX_FILTER_CONNECTION)
        pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
    ASSERT(IS_VALID_FILTER_CONNECTION(pConnection));

    //
    // Lock the list.
    //
    UlAcquireSpinLock(&pConnection->FilterConnLock, &oldIrql);

    //
    // Remove ourselves.
    //
    if (pIrp->Tail.Overlay.ListEntry.Flink)
    {
        RemoveEntryList(&pIrp->Tail.Overlay.ListEntry);
        pIrp->Tail.Overlay.ListEntry.Flink = NULL;
        pIrp->Tail.Overlay.ListEntry.Blink = NULL;
    }

    //
    // Release the list.
    //
    UlReleaseSpinLock(&pConnection->FilterConnLock, oldIrql);

    //
    // Let go of our reference.
    //

    pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer = NULL;

    DEREFERENCE_FILTER_CONNECTION(pConnection);

    //
    // Complete the IRP.
    //

    pIrp->IoStatus.Status = STATUS_CANCELLED;
    pIrp->IoStatus.Information = 0;

    UlCompleteRequest( pIrp, IO_NO_INCREMENT );

}



/***************************************************************************++

Routine Description:

    Cancels the pending user mode irp which was to read from the
    application.

    This routine ALWAYS results in the IRP being completed.

Arguments:

    pDeviceObject - the device object

    pIrp - the irp to cancel

--***************************************************************************/
VOID
UlpCancelFilterAppRead(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    )
{
    PUX_FILTER_CONNECTION pConnection;
    PIO_STACK_LOCATION pIrpSp;
    KIRQL oldIrql;

    UNREFERENCED_PARAMETER(pDeviceObject);

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);
    ASSERT(pIrp != NULL);

    //
    // release the cancel spinlock.  This means the cancel routine
    // must be the one completing the irp (to avoid the race of
    // completion + reuse prior to the cancel routine running).
    //

    IoReleaseCancelSpinLock(pIrp->CancelIrql);

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

    //
    // Grab the connection off the IRP.
    //
    pConnection = (PUX_FILTER_CONNECTION)
        pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer;

    ASSERT(IS_VALID_FILTER_CONNECTION(pConnection));

    //
    // Lock the list.
    //
    UlAcquireSpinLock(&pConnection->FilterConnLock, &oldIrql);

    //
    // Remove ourselves.
    //
    if (pIrp->Tail.Overlay.ListEntry.Flink)
    {
        RemoveEntryList(&pIrp->Tail.Overlay.ListEntry);
        pIrp->Tail.Overlay.ListEntry.Flink = NULL;
        pIrp->Tail.Overlay.ListEntry.Blink = NULL;

        //
        // Update IRP counter.
        //

        ASSERT(pConnection->AppToFiltQueue.PendingReadCount > 0);
        pConnection->AppToFiltQueue.PendingReadCount--;
    }


    //
    // Release the list.
    //
    UlReleaseSpinLock(&pConnection->FilterConnLock, oldIrql);

    //
    // Let go of our reference.
    //

    pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer = NULL;

    DEREFERENCE_FILTER_CONNECTION(pConnection);

    //
    // Complete the IRP.
    //

    pIrp->IoStatus.Status = STATUS_CANCELLED;
    pIrp->IoStatus.Information = 0;

    UlCompleteRequest( pIrp, IO_NO_INCREMENT );

}


/***************************************************************************++

Routine Description:

    Cancels the pending user mode irp which was to write to the
    application.

    This routine ALWAYS results in the IRP being completed.

Arguments:

    pDeviceObject - the device object

    pIrp - the irp to cancel

--***************************************************************************/
VOID
UlpCancelFilterAppWrite(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    )
{
    PUX_FILTER_WRITE_TRACKER pTracker;
    PUX_FILTER_CONNECTION pConnection;
    PUX_FILTER_WRITE_QUEUE pWriteQueue;
    PIO_STACK_LOCATION pIrpSp;
    KIRQL oldIrql;

    UNREFERENCED_PARAMETER(pDeviceObject);

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);
    ASSERT(pIrp != NULL);

    //
    // release the cancel spinlock.  This means the cancel routine
    // must be the one completing the irp (to avoid the race of
    // completion + reuse prior to the cancel routine running).
    //

    IoReleaseCancelSpinLock(pIrp->CancelIrql);

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

    //
    // Grab the write tracker off the IRP.
    //
    pTracker = (PUX_FILTER_WRITE_TRACKER)
        pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer;

    ASSERT(IS_VALID_FILTER_WRITE_TRACKER(pTracker));

    pWriteQueue = pTracker->pWriteQueue;
    ASSERT(pWriteQueue);

    pConnection = pTracker->pConnection;
    ASSERT(IS_VALID_FILTER_CONNECTION(pConnection));

    //
    // Lock the list on which we might be queued.
    //
    UlAcquireSpinLock(&pConnection->FilterConnLock, &oldIrql);

    if (pTracker->ListEntry.Flink)
    {
        //
        // Remove ourselves.
        //

        RemoveEntryList(&pTracker->ListEntry);

        //
        // Decrement pending write counter.
        //

        ASSERT(pConnection->FiltToAppQueue.PendingWriteCount > 0);
        pConnection->FiltToAppQueue.PendingWriteCount--;
    }

    //
    // Release the list.
    //
    UlReleaseSpinLock(&pConnection->FilterConnLock, oldIrql);

    //
    // Let go of our reference to the connection.
    //

    pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer = NULL;
    DEREFERENCE_FILTER_CONNECTION(pConnection);

    //
    // Free the write buffer MDL if it was allocated in http.sys.
    //
    if (pIrpSp->Parameters.DeviceIoControl.InputBufferLength
        == sizeof(HTTP_FILTER_BUFFER_PLUS))
    {
        PMDL pMdl = UL_MDL_FROM_IRP(pIrp);
        if (pMdl != NULL)
        {
            PHTTP_FILTER_BUFFER_PLUS pHttpBuffer;

            UlFreeLockedMdl(pMdl);
            UL_MDL_FROM_IRP(pIrp) = NULL;
            pHttpBuffer =
                (PHTTP_FILTER_BUFFER_PLUS)pIrp->AssociatedIrp.SystemBuffer;
            pHttpBuffer->pWriteBuffer = NULL;
            pHttpBuffer->WriteBufferSize = 0;
        }
    }

    //
    // Complete through the normal path so the tracker gets cleaned up.
    //

    pTracker->BytesCopied = 0;

    UxpCompleteQueuedWrite(
        STATUS_CANCELLED,
        pWriteQueue,
        pTracker
        );

}

/***************************************************************************++

Routine Description:

    Cancels the pending user mode irp which was to read a client
    certificate from the connection.

    This routine ALWAYS results in the IRP being completed.

Arguments:

    pDeviceObject - the device object

    pIrp - the irp to cancel

--***************************************************************************/
VOID
UlpCancelReceiveClientCert(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    )
{
    PUX_FILTER_CONNECTION pConnection;
    PIO_STACK_LOCATION pIrpSp;
    KIRQL oldIrql;

    UNREFERENCED_PARAMETER(pDeviceObject);

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);
    ASSERT(pIrp != NULL);

    //
    // release the cancel spinlock.  This means the cancel routine
    // must be the one completing the irp (to avoid the race of
    // completion + reuse prior to the cancel routine running).
    //

    IoReleaseCancelSpinLock(pIrp->CancelIrql);

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

    //
    // Grab the connection off the IRP.
    //
    pConnection = (PUX_FILTER_CONNECTION)
        pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
    ASSERT(IS_VALID_FILTER_CONNECTION(pConnection));

    //
    // Lock the connection.
    //
    UlAcquireSpinLock(&pConnection->FilterConnLock, &oldIrql);

    //
    // Remove ourselves.
    //

    if (pConnection->pReceiveCertIrp)
    {
        ASSERT( pConnection->pReceiveCertIrp == pIrp );
        pConnection->pReceiveCertIrp = NULL;
    }

    //
    // Release the connection.
    //
    UlReleaseSpinLock(&pConnection->FilterConnLock, oldIrql);

    //
    // Let go of our reference.
    //

    pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer = NULL;

    DEREFERENCE_FILTER_CONNECTION(pConnection);

    //
    // Complete the IRP.
    //

    pIrp->IoStatus.Status = STATUS_CANCELLED;
    pIrp->IoStatus.Information = 0;

    UlCompleteRequest( pIrp, IO_NO_INCREMENT );

}

/***************************************************************************++

Routine Description:

    Delivers a new connection (and the first data on the connection) to
    a filter channel, which can now complete an accept IRP.

Arguments:

    pFilterChannel - the channel that gets the connection
    pConnection - the new connection object
    pBuffer - buffer containing initial data
    IndicatedLength - number of bytes in the buffer
    pTakenLength - number of bytes we copy into the buffer.

--***************************************************************************/
NTSTATUS
UlDeliverConnectionToFilter(
    IN PUX_FILTER_CONNECTION pConnection,
    IN PVOID pBuffer,
    IN ULONG IndicatedLength,
    OUT PULONG pTakenLength
    )
{
    KIRQL oldIrql;
    PIRP pIrp;
    PUL_FILTER_PROCESS pProcess;
    PUL_FILTER_CHANNEL pFilterChannel;


    //
    // Sanity check.
    //
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);
    ASSERT(IS_VALID_FILTER_CONNECTION(pConnection));
    pFilterChannel = pConnection->pFilterChannel;
    ASSERT(IS_VALID_FILTER_CHANNEL(pFilterChannel));
    // ASSERT(pBuffer);
    ASSERT(pTakenLength);

    UlTrace(FILTER, (
        "http!UlDeliverConnectionToFilter(pConnection = %p)\n",
        pConnection
        ));

    ASSERT(pConnection->ConnectionDelivered == FALSE);
    pConnection->ConnectionDelivered = TRUE;

    UlAcquireSpinLock(&pFilterChannel->SpinLock, &oldIrql);
    UlAcquireSpinLockAtDpcLevel(&pConnection->FilterConnLock);

    //
    // See if we have a pending accept IRP.
    //
    pIrp = UlpPopAcceptIrp(pFilterChannel, &pProcess);

    if (pIrp)
    {
        ASSERT( IS_VALID_FILTER_PROCESS(pProcess) );

        //
        // Attach the connection to the process, copy the data,
        // and complete the IRP.
        //

        ASSERT(pConnection->ConnState == UlFilterConnStateInactive);
        pConnection->ConnState = UlFilterConnStateConnected;

        InsertTailList(
            &pProcess->ConnectionHead,
            &pConnection->ChannelEntry
            );

        REFERENCE_FILTER_CONNECTION(pConnection);

        //
        // Do the irp completion stuff outside the spin lock.
        //

    }
    else
    {
        //
        // No IRPs available. Queue the connection on the filter
        // channel.
        //
        InsertTailList(
            &pFilterChannel->ConnectionListHead,
            &pConnection->ChannelEntry
            );

        ASSERT(pConnection->ConnState == UlFilterConnStateInactive);
        pConnection->ConnState = UlFilterConnStateQueued;

        REFERENCE_FILTER_CONNECTION(pConnection);

        *pTakenLength = 0;
    }

    UlReleaseSpinLockFromDpcLevel(&pConnection->FilterConnLock);
    UlReleaseSpinLock(&pFilterChannel->SpinLock, oldIrql);

    //
    // Now that we're outside the spin lock, we can complete
    // the IRP if we have one.
    //
    if (pIrp)
    {
        UlpCompleteAcceptIrp(
            pIrp,
            pConnection,
            pBuffer,
            IndicatedLength,
            pTakenLength
            );

    }

    UlTrace(FILTER, (
        "http!UlDeliverConnectionToFilter pConn = %p\n"
        "    consumed %lu of %lu bytes indicated\n",
        pConnection,
        *pTakenLength,
        IndicatedLength
        ));

    return STATUS_SUCCESS;

} // UlDeliverConnectionToFilter


/***************************************************************************++

Routine Description:

    A helper function for UlFilterAppWrite. This function takes care
    of the case where the data written is HTTP stream data to be passed
    to the app.

    If the app is not ready for the data this function will take care
    of queuing the write and will return STATUS_PENDING.

    Must be called with the FilterConnLock held.

Arguments:

    pConnection - the connection owning the data
    pIrp - the IRP that provides the data
    pMdlData - the MDL that provides the data
    pDataBuffer - output buffer from the IRP
    DataBufferSize - size of pDataBuffer in bytes
    pTakenLength - number of bytes we copied to the app.

Return Values:

    An NTSTATUS. STATUS_PENDING indicates that the IRP was queued and will
    be completed later. Any other status means that the caller should go
    ahead and complete the IRP.

--***************************************************************************/
NTSTATUS
UlpFilterAppWriteStream(
    IN PUX_FILTER_CONNECTION pConnection,
    IN PIRP pIrp,
    IN PMDL pMdlData,
    IN PUCHAR pDataBuffer,
    IN ULONG DataBufferSize,
    OUT PULONG pTakenLength
    )
{
    NTSTATUS Status;
    ULONG TakenLength = 0;
    PUX_FILTER_WRITE_TRACKER pTracker;

    ASSERT(NULL != pMdlData);
    ASSERT(NULL != pDataBuffer);

    //
    // If this is a secure connection, we must
    // have received the SslInitInfo already or
    // we cannot accept the data.
    //
    if (pConnection->SecureConnection &&
        !pConnection->SslInfoPresent)
    {
        Status = STATUS_INVALID_DEVICE_STATE;
        TakenLength = 0;
        goto end;
    }

    //
    // Make sure the connection can take the data. In
    // the Filter -> App case we just check to see if
    // any writes have been queued.
    //

    if (pConnection->FiltToAppQueue.PendingWriteCount == 0)
    {

        //
        // Pass the data to the application.
        //

        Status = (pConnection->pDummyTdiReceiveHandler)(
                    NULL,
                    pConnection->pConnectionContext,
                    pDataBuffer,
                    DataBufferSize,
                    0,
                    &TakenLength
                    );

        UlTrace(FILTER, (
            "http!UlpFilterAppWriteStream app took %lu of %lu bytes,"
            " pConnection = %p\n",
            TakenLength,
            DataBufferSize,
            pConnection
            ));

        ASSERT(TakenLength <= DataBufferSize);
    }
    else
    {
        //
        // There are queued writes, which means that the app
        // is not ready for our data. We have to queue it.
        //
        // CODEWORK:  Simulate TDI to indicate more data when having
        // multiple writes pended.  Fortunately the filter process doesn't
        // ever seem to issue multiple outstanding FilterAppWrites, so we
        // never actually hit this situation in practice.  However to be
        // safe we should disallow queuing of multiple FilterAppWrite IRPs.
        //

        Status = STATUS_NOT_SUPPORTED;
        TakenLength = 0;
    }

    //
    // Queue the write if necessary.
    //

    if (NT_SUCCESS(Status) && (TakenLength < DataBufferSize))
    {
        //
        // Since the app did not accept all of the data from
        // this IRP we have to queue it.
        //

        //
        // Allocate a generic write tracker object to put on the
        // queue and save a pointer to the IRP in there.
        //

        pTracker = UxpCreateFilterWriteTracker(
                        HttpFilterBufferHttpStream,     // BufferType
                        pMdlData,                       // pMdlChain
                        TakenLength,                    // MdlOffset
                        DataBufferSize,                 // Length of data
                        TakenLength,                    // BytesCopied so far
                        UlpRestartFilterAppWrite,       // pCompletionRoutine
                        pIrp                            // pContext
                        );

        if (!pTracker)
        {
            //
            // Doh! We couldn't create the tracker. Return to the
            // caller so they can complete the IRP.
            //
            Status = STATUS_NO_MEMORY;
            goto end;
        }


        //
        // Now stick it on the queue.
        //

        Status = UxpQueueFilterWrite(
                        pConnection,
                        &pConnection->FiltToAppQueue,
                        pTracker
                        );

        if (NT_SUCCESS(Status))
        {
            //
            // return pending so the caller knows not to complete
            // the IRP.
            //
            Status = STATUS_PENDING;
        }
        else
        {
            //
            // Kill the tracker. The caller will take care of
            // completing the IRP with the status we return.
            //

            UxpDeleteFilterWriteTracker(pTracker);
        }
    }

end:
    ASSERT(pTakenLength);
    *pTakenLength = TakenLength;

    return Status;
}

/***************************************************************************++

Routine Description:

    Does the magic incantation to queue an IRP on the filter connection.

Arguments:

    pTracker - the tracker we're queueing

--***************************************************************************/
NTSTATUS
UlpEnqueueFilterAppWrite(
    IN PUX_FILTER_WRITE_TRACKER pTracker
    )
{
    NTSTATUS Status;
    PIRP pIrp;
    PIO_STACK_LOCATION pIrpSp;

    //
    // Sanity check.
    //
    ASSERT(IS_VALID_FILTER_WRITE_TRACKER(pTracker));
    ASSERT(IS_VALID_FILTER_CONNECTION(pTracker->pConnection));
    ASSERT(pTracker->pCompletionContext);

    //
    // Get the IRP out of the tracker.
    //

    pIrp = (PIRP)pTracker->pCompletionContext;

    //
    // Save away a pointer to the tracker in the IRP so we can
    // clean up if the cancel routine runs.
    //

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer = pTracker;

    //
    // Set the Cancel routine.
    //
    IoSetCancelRoutine(pIrp, &UlpCancelFilterAppWrite);

    //
    // See if the IRP has been cancelled already.
    //
    if (pIrp->Cancel)
    {
        //
        // darn it, need to make sure the irp get's completed
        //

        if (IoSetCancelRoutine( pIrp, NULL ) != NULL)
        {
            //
            // We are in charge of completion. IoCancelIrp didn't
            // see our cancel routine (and won't). UlFilterAppWrite
            // will complete it.
            //

            pIrp->IoStatus.Information = 0;

            UlUnmarkIrpPending( pIrp );
            Status = STATUS_CANCELLED;
            goto end;
        }

        //
        // Our cancel routine will run and complete the irp.
        // Don't touch it.
        //

        //
        // STATUS_PENDING will cause the caller to
        // not complete (or touch in any way) the IRP.
        //

        Status = STATUS_PENDING;
        goto end;
    }

    //
    // All ready to queue!
    //

    Status = STATUS_SUCCESS;

end:

    return Status;
}

/***************************************************************************++

Routine Description:

    Removes the cancel routine from an IRP so we can use it.

Arguments:

    pTracker - the queued write that contains our IRP

    pConnection - the connection from which the tracker was removed

--***************************************************************************/
NTSTATUS
UlpDequeueFilterAppWrite(
    IN PUX_FILTER_WRITE_TRACKER pTracker
    )
{
    PIRP pIrp;
    PUX_FILTER_WRITE_QUEUE pWriteQueue;

    //
    // Sanity check.
    //
    ASSERT(IS_VALID_FILTER_WRITE_TRACKER(pTracker));
    ASSERT(pTracker->pCompletionContext);

    pIrp = (PIRP)pTracker->pCompletionContext;
    pWriteQueue = pTracker->pWriteQueue;

    //
    // In the FiltToApp case we are dequeuing an IRP, so
    // we have to do the cancel routine dance before we
    // try to use it.
    //

    //
    // pop the cancel routine
    //

    if (IoSetCancelRoutine(pIrp, NULL) == NULL)
    {
        //
        // IoCancelIrp pop'd it first
        //
        // ok to just ignore this irp, it's been pop'd off the queue
        // and will be completed in the cancel routine.
        //
        // keep looking for a irp to use
        //

        pIrp = NULL;

    }
    else if (pIrp->Cancel)
    {
        PUX_FILTER_WRITE_TRACKER pTrack;

        //
        // we pop'd it first. but the irp is being cancelled
        // and our cancel routine will never run. lets be
        // nice and complete the irp now (vs. using it
        // then completing it - which would also be legal).
        //
        pTrack = (PUX_FILTER_WRITE_TRACKER)(
                                IoGetCurrentIrpStackLocation(pIrp)->
                                    Parameters.DeviceIoControl.Type3InputBuffer
                                );

        ASSERT(pTrack == pTracker);
        ASSERT(IS_VALID_FILTER_CONNECTION(pTracker->pConnection));

        IoGetCurrentIrpStackLocation(pIrp)->
            Parameters.DeviceIoControl.Type3InputBuffer = NULL;

        //
        // Complete throught the normal path so the tracker can be
        // cleaned up.
        //

        pTracker->BytesCopied = 0;

        UxpCompleteQueuedWrite(
            STATUS_CANCELLED,
            pWriteQueue,
            pTracker
            );

        pIrp = NULL;
    }
    else
    {
        PUX_FILTER_WRITE_TRACKER pTrack;
        PUX_FILTER_CONNECTION pConn;

        //
        // we are free to use this irp !
        //

        pTrack = (PUX_FILTER_WRITE_TRACKER)(
                                IoGetCurrentIrpStackLocation(pIrp)->
                                    Parameters.DeviceIoControl.Type3InputBuffer
                                );

        ASSERT(pTrack == pTracker);
        ASSERT(pTrack->pWriteQueue == pWriteQueue);

        pConn = pTrack->pConnection;
        ASSERT(IS_VALID_FILTER_CONNECTION(pConn));

        IoGetCurrentIrpStackLocation(pIrp)->
            Parameters.DeviceIoControl.Type3InputBuffer = NULL;

    }

    //
    // If we didn't NULL out pIrp, it's ok to use it.
    //

    if (pIrp)
    {
        return STATUS_SUCCESS;
    }
    else
    {
        return STATUS_UNSUCCESSFUL;
    }
}

/***************************************************************************++

Routine Description:

    Captures SSL connection information passed down in a UlFilterAppWrite
    call with a UlFilterBufferSslInitInfo type.

Arguments:

    pHttpSslInfo - the data passed to us by the filter process
    HttpSslInfoSize - size of the passed data
    pUlSslInfo - this is where we store what we capture
    pTakenLength - gets the number of bytes we read

--***************************************************************************/
NTSTATUS
UlpCaptureSslInfo(
    IN KPROCESSOR_MODE PreviousMode,
    IN PHTTP_SSL_INFO pHttpSslInfo,
    IN ULONG HttpSslInfoSize,
    OUT PUL_SSL_INFORMATION pUlSslInfo,
    OUT PULONG pTakenLength
    )
{
    NTSTATUS Status;
    ULONG BytesCopied;
    ULONG BytesNeeded;
    HTTP_SSL_INFO LocalHttpSslInfo;

    //
    // Sanity check.
    //
    ASSERT(pHttpSslInfo);
    ASSERT(pUlSslInfo);
    ASSERT(pTakenLength);

    PAGED_CODE();

    //
    // Initialize locals.
    //

    Status = STATUS_SUCCESS;
    BytesCopied = 0;
    BytesNeeded = 0;

    //
    // See if it's ok to capture.
    //

    if (HttpSslInfoSize < sizeof(HTTP_SSL_INFO))
    {
        //
        // Buffer isn't big enough to pass the required data.
        //
        Status = STATUS_INVALID_PARAMETER;
        goto end;
    }

    //
    // Copy HTTP_SSL_INFO so its content won't change during the capture.
    //
    LocalHttpSslInfo = *pHttpSslInfo;

    //
    // Grab the easy stuff and figure out how much buffer
    // is required.
    //
    pUlSslInfo->ServerCertKeySize = LocalHttpSslInfo.ServerCertKeySize;
    pUlSslInfo->ConnectionKeySize = LocalHttpSslInfo.ConnectionKeySize;
    pUlSslInfo->ServerCertIssuerSize = LocalHttpSslInfo.ServerCertIssuerSize;
    pUlSslInfo->ServerCertSubjectSize = LocalHttpSslInfo.ServerCertSubjectSize;

    BytesNeeded += ALIGN_UP(LocalHttpSslInfo.ServerCertIssuerSize, PVOID);
    BytesNeeded += sizeof(CHAR);
    BytesNeeded += ALIGN_UP(LocalHttpSslInfo.ServerCertSubjectSize, PVOID);
    BytesNeeded += sizeof(CHAR);

    BytesCopied += HttpSslInfoSize;

    //
    // Allocate a buffer for the server cert info.
    // It might be nice to allocate the whole info structure dynamically.
    //
    pUlSslInfo->pServerCertData = (PUCHAR) UL_ALLOCATE_POOL(
                                                NonPagedPool,
                                                BytesNeeded,
                                                UL_SSL_CERT_DATA_POOL_TAG
                                                );

    if (pUlSslInfo->pServerCertData == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto end;
    }

    RtlZeroMemory(pUlSslInfo->pServerCertData, BytesNeeded);

    //
    // Capture the server cert info.
    //
    __try
    {
        PUCHAR pKeBuffer;

        //
        // Copy the Issuer.
        //
        pKeBuffer = pUlSslInfo->pServerCertData;

        UlProbeForRead(
            LocalHttpSslInfo.pServerCertIssuer,
            LocalHttpSslInfo.ServerCertIssuerSize,
            sizeof(PCSTR),
            PreviousMode
            );

        RtlCopyMemory(
            pKeBuffer,
            LocalHttpSslInfo.pServerCertIssuer,
            LocalHttpSslInfo.ServerCertIssuerSize
            );

        BytesCopied += LocalHttpSslInfo.ServerCertIssuerSize;

        pKeBuffer[LocalHttpSslInfo.ServerCertIssuerSize] = '\0';
        pUlSslInfo->pServerCertIssuer = pKeBuffer;

        //
        // Copy the subject.
        //
        pKeBuffer += LocalHttpSslInfo.ServerCertIssuerSize + 1;

        UlProbeForRead(
            LocalHttpSslInfo.pServerCertSubject,
            LocalHttpSslInfo.ServerCertSubjectSize,
            sizeof(PCSTR),
            PreviousMode
            );

        RtlCopyMemory(
            pKeBuffer,
            LocalHttpSslInfo.pServerCertSubject,
            LocalHttpSslInfo.ServerCertSubjectSize
            );

        BytesCopied += LocalHttpSslInfo.ServerCertSubjectSize;
        pKeBuffer[LocalHttpSslInfo.ServerCertSubjectSize] = '\0';

        pUlSslInfo->pServerCertSubject = pKeBuffer;

        //
        // Capture client cert info.
        //
        if (LocalHttpSslInfo.pClientCertInfo)
        {
            ULONG CertBytesCopied;

            UlProbeForRead(
                LocalHttpSslInfo.pClientCertInfo,
                sizeof(HTTP_SSL_CLIENT_CERT_INFO),
                sizeof(PVOID),
                PreviousMode
                );

            Status = UlpCaptureSslClientCert(
                        PreviousMode,
                        LocalHttpSslInfo.pClientCertInfo,
                        sizeof(HTTP_SSL_CLIENT_CERT_INFO),
                        pUlSslInfo,
                        &CertBytesCopied
                        );
        }
    }
    __except( UL_EXCEPTION_FILTER() )
    {
        Status = GetExceptionCode();
    }

end:
    if (!NT_SUCCESS(Status))
    {
        if (pUlSslInfo->pServerCertData)
        {
            UL_FREE_POOL(
                pUlSslInfo->pServerCertData,
                UL_SSL_CERT_DATA_POOL_TAG
                );

            pUlSslInfo->pServerCertData = NULL;
        }
    }

    //
    // Return the number of bytes read.
    //
    *pTakenLength = BytesCopied;

    return Status;
}


/***************************************************************************++

Routine Description:

    Captures SSL client certificate passed down in a UlFilterAppWrite
    call with a UlFilterBufferSslClientCert type.

Arguments:

    CertMapped - true if we have to capture a mapped token
    pCertInfo - the cert data to capture
    SslCertInfoSize - size of the buffer passed to us
    pUlSslInfo - this is where we stick the info we get
    pTakenLength - gets the number of bytes we read

--***************************************************************************/
NTSTATUS
UlpCaptureSslClientCert(
    IN KPROCESSOR_MODE PreviousMode,
    IN PHTTP_SSL_CLIENT_CERT_INFO pCertInfo,
    IN ULONG SslCertInfoSize,
    OUT PUL_SSL_INFORMATION pUlSslInfo,
    OUT PULONG pTakenLength
    )
{
    NTSTATUS Status;
    ULONG BytesCopied;
    ULONG BytesNeeded;
    HANDLE Token;
    HANDLE MappedToken;
    PUCHAR pKeBuffer;
    PUCHAR pCertEncoded;

    //
    // Sanity check.
    //
    ASSERT(pUlSslInfo);
    ASSERT(pCertInfo);
    ASSERT(pTakenLength);

    PAGED_CODE();

    //
    // Initialize locals.
    //

    Status = STATUS_SUCCESS;
    BytesCopied = 0;
    BytesNeeded = 0;
    MappedToken = NULL;

    //
    // See if it's ok to capture.
    //

    if (SslCertInfoSize < sizeof(HTTP_SSL_CLIENT_CERT_INFO))
    {
        //
        // Buffer isn't big enough to pass the required data.
        //
        Status = STATUS_INVALID_PARAMETER;
        goto end;
    }

    __try
    {
        //
        // Grab the easy stuff and figure out how much buffer
        // is required.
        //
        pUlSslInfo->CertEncodedSize = pCertInfo->CertEncodedSize;
        pUlSslInfo->pCertEncoded = NULL;
        pUlSslInfo->CertFlags = pCertInfo->CertFlags;
        pUlSslInfo->CertDeniedByMapper = pCertInfo->CertDeniedByMapper;

        //
        // Now grab the encoded certificate.
        //

        BytesNeeded += ALIGN_UP(pUlSslInfo->CertEncodedSize, PVOID);
        BytesNeeded += sizeof(CHAR);

        BytesCopied += SslCertInfoSize;

        if (pUlSslInfo->CertEncodedSize)
        {
            //
            // Allocate a buffer for the client cert info.
            // It might be nice to allocate the whole info structure
            // dynamically.
            //
            pUlSslInfo->pCertEncoded = (PUCHAR) UL_ALLOCATE_POOL(
                                            NonPagedPool,
                                            BytesNeeded,
                                            UL_SSL_CERT_DATA_POOL_TAG
                                            );

            if (pUlSslInfo->pCertEncoded == NULL)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto end;
            }

            RtlZeroMemory(pUlSslInfo->pCertEncoded, BytesNeeded);

            //
            // Capture the client cert info.
            //
            pCertEncoded = pCertInfo->pCertEncoded;

            UlProbeForRead(
                pCertEncoded,
                pUlSslInfo->CertEncodedSize,
                sizeof(PVOID),
                PreviousMode
                );

            //
            // Copy the Issuer.
            //
            pKeBuffer = (PUCHAR) pUlSslInfo->pCertEncoded;

            RtlCopyMemory(
                pKeBuffer,
                pCertEncoded,
                pUlSslInfo->CertEncodedSize
                );

            BytesCopied += pUlSslInfo->CertEncodedSize;

            pKeBuffer[pUlSslInfo->CertEncodedSize] = '\0';

        }
        else
        {
            //
            // The cert renegotiation must have failed so we remember
            // that we tried, but complete any requests for a cert
            // with an error status.
            //
            ASSERT(NT_SUCCESS(Status));

            pUlSslInfo->SslRenegotiationFailed = 1;
        }

        //
        // Capture the token last so if this fails we never need to close
        // the mapped token which requires us to attach to system process.
        //
        Token = pCertInfo->Token;

        if (Token)
        {
            //
            // Dup the token into the System process so that
            // we can dup it into the worker process later.
            //
            ASSERT(g_pUlSystemProcess);

            Status = UlpDuplicateHandle(
                            PsGetCurrentProcess(),          // SourceProcess
                            Token,                          // SourceHandle
                            (PEPROCESS)g_pUlSystemProcess,  // TargetProcess
                            &MappedToken,                   // TargetHandle
                            TOKEN_ALL_ACCESS,               // DesiredAccess
                            0,                              // HandleAttributes
                            0,                              // Options
                            PreviousMode                    // PreviousMode
                            );

            if (NT_SUCCESS(Status))
            {
                //
                // Save it away.
                //
                pUlSslInfo->Token = MappedToken;
            }
            else
            {
                //
                // Couldn't map the token into the system process, bail out.
                //
                goto end;
            }
        }
    }
    __except( UL_EXCEPTION_FILTER() )
    {
        Status = GetExceptionCode();
    }

end:
    if (!NT_SUCCESS(Status))
    {
        if (pUlSslInfo->pCertEncoded)
        {
            UL_FREE_POOL(
                pUlSslInfo->pCertEncoded,
                UL_SSL_CERT_DATA_POOL_TAG
                );

            pUlSslInfo->pCertEncoded = NULL;
        }

        ASSERT(MappedToken == NULL);
    }

    //
    // Return the number of bytes read.
    //
    *pTakenLength = BytesCopied;

    return Status;
}


/***************************************************************************++

Routine Description:

    Attaches captured SSL information to a connection.

    Called with the pConnection->FilterConnLock held. The connection is
    assumed to be in the connected state.

Arguments:

    pConnection - the connection that gets the info
    pSslInfo - the info to attach

--***************************************************************************/
NTSTATUS
UlpAddSslInfoToConnection(
    IN PUX_FILTER_CONNECTION pConnection,
    IN PUL_SSL_INFORMATION pSslInfo
    )
{
    NTSTATUS Status;
    PUL_SSL_INFORMATION pUlSslInfo;

    //
    // Sanity check.
    //

    ASSERT(IS_VALID_FILTER_CONNECTION(pConnection));
    ASSERT(pSslInfo);
    ASSERT(UlDbgSpinLockOwned(&pConnection->FilterConnLock));
    ASSERT(pConnection->ConnState == UlFilterConnStateConnected);

    //
    // See if it's ok to add the data.
    //

    if (!pConnection->SslInfoPresent)
    {
        //
        // Grab all the data. Note that we're taking ownership
        // of some buffers inside of the pSslInfo.
        //

        pUlSslInfo = &pConnection->SslInfo;

        pUlSslInfo->ServerCertKeySize = pSslInfo->ServerCertKeySize;
        pUlSslInfo->ConnectionKeySize = pSslInfo->ConnectionKeySize;
        pUlSslInfo->pServerCertIssuer = pSslInfo->pServerCertIssuer;
        pUlSslInfo->ServerCertIssuerSize = pSslInfo->ServerCertIssuerSize;
        pUlSslInfo->pServerCertSubject = pSslInfo->pServerCertSubject;
        pUlSslInfo->ServerCertSubjectSize = pSslInfo->ServerCertSubjectSize;
        pUlSslInfo->pServerCertData = pSslInfo->pServerCertData;

        pConnection->SslInfoPresent = 1;

        //
        // Take ownership of pSslInfo->pServerCertData.
        //

        pSslInfo->pServerCertData = NULL;

        Status = STATUS_SUCCESS;

        //
        // Don't forget to add the client certificate if it comes down with
        // the initial SSL information.
        //

        if (pSslInfo->pCertEncoded)
        {
            Status = UlpAddSslClientCertToConnection(
                            pConnection,
                            pSslInfo
                            );
        }
    }
    else
    {
        //
        // There is already stuff here. Don't capture more.
        //

        Status = STATUS_OBJECT_NAME_COLLISION;
    }

    return Status;
}


/***************************************************************************++

Routine Description:

    Frees UL_SSL_INFORMATION in g_UlSystemProcess.

Arguments:

    pWorkItem - a work item embedded in the UL_SSL_INFORMATION

--***************************************************************************/
VOID
UlpFreeSslInformationWorker(
    IN PUL_WORK_ITEM pWorkItem
    )
{
    PUL_SSL_INFORMATION pSslInformation;

    //
    // Sanity check.
    //

    PAGED_CODE();

    pSslInformation = CONTAINING_RECORD(
                            pWorkItem,
                            UL_SSL_INFORMATION,
                            WorkItem
                            );


    if (pSslInformation->pServerCertData)
    {
        UL_FREE_POOL(
            pSslInformation->pServerCertData,
            UL_SSL_CERT_DATA_POOL_TAG
            );
    }

    if (pSslInformation->pCertEncoded)
    {
        UL_FREE_POOL(
            pSslInformation->pCertEncoded,
            UL_SSL_CERT_DATA_POOL_TAG
            );
    }

    if (pSslInformation->Token)
    {
        ASSERT(g_pUlSystemProcess != (PKPROCESS)IoGetCurrentProcess());
        ZwClose(pSslInformation->Token);
    }

    UL_FREE_POOL(pSslInformation, UL_SSL_INFO_POOL_TAG);
}


/***************************************************************************++

Routine Description:

    Attaches captured SSL client cert information to a connection.

    Completes the ReceiveClientCert IRP if there is one.

    Called with the pConnection->FilterConnLock held.

Arguments:

    pConnection - the connection that gets the info
    pSslInfo - the info to attach

--***************************************************************************/
NTSTATUS
UlpAddSslClientCertToConnection(
    IN PUX_FILTER_CONNECTION pConnection,
    IN PUL_SSL_INFORMATION pSslInfo
    )
{
    NTSTATUS Status;
    PUL_SSL_INFORMATION pUlSslInfo;

    //
    // Sanity check.
    //
    ASSERT(IS_VALID_FILTER_CONNECTION(pConnection));
    ASSERT(pSslInfo);
    ASSERT(UlDbgSpinLockOwned(&pConnection->FilterConnLock));
    ASSERT(pConnection->ConnState == UlFilterConnStateConnected);

    //
    // See if it's ok to add the data.
    //

    if (!pConnection->SslClientCertPresent)
    {
        //
        // Grab all the data. Note that we're taking ownership
        // of some buffers inside of the pSslInfo.
        //

        pUlSslInfo = &pConnection->SslInfo;

        pUlSslInfo->CertEncodedSize = pSslInfo->CertEncodedSize;
        pUlSslInfo->pCertEncoded = pSslInfo->pCertEncoded;
        pUlSslInfo->CertFlags = pSslInfo->CertFlags;
        pUlSslInfo->Token = pSslInfo->Token;
        pUlSslInfo->SslRenegotiationFailed = pSslInfo->SslRenegotiationFailed;
        pUlSslInfo->CertDeniedByMapper = pSslInfo->CertDeniedByMapper;

        pConnection->SslClientCertPresent = 1;

        //
        // Take ownership of pSslInfo->pCertEncoded and pSslInfo->Token.
        //

        pSslInfo->pCertEncoded = NULL;
        pSslInfo->Token = NULL;

        Status = STATUS_SUCCESS;

    }
    else
    {
        //
        // There is already stuff here. Don't capture more.
        //

        Status = STATUS_OBJECT_NAME_COLLISION;
    }

    //
    // If we added successfully and there is a ReceiveClientCert
    // IRP, then we complete it.
    //

    if (NT_SUCCESS(Status) && pConnection->pReceiveCertIrp)
    {
        PIRP pIrp;

        if (IoSetCancelRoutine(pConnection->pReceiveCertIrp, NULL) == NULL)
        {
            //
            // IoCancelIrp pop'd it first
            //
            // ok to just ignore this irp, it's been pop'd off the queue
            // and will be completed in the cancel routine.
            //
            // no need to complete it
            //
        }
        else if (pConnection->pReceiveCertIrp->Cancel)
        {
            //
            // we pop'd it first. but the irp is being cancelled
            // and our cancel routine will never run.
            //

            IoGetCurrentIrpStackLocation(
                pConnection->pReceiveCertIrp
                )->Parameters.DeviceIoControl.Type3InputBuffer = NULL;


            DEREFERENCE_FILTER_CONNECTION(pConnection);

            pConnection->pReceiveCertIrp->IoStatus.Status = STATUS_CANCELLED;
            pConnection->pReceiveCertIrp->IoStatus.Information = 0;

            pIrp = pConnection->pReceiveCertIrp;
            pConnection->pReceiveCertIrp = NULL;

            UlCompleteRequest(pIrp, IO_NO_INCREMENT);
        }
        else
        {
            //
            // The IRP is all ours. Go ahead and use it.
            //

            pIrp = pConnection->pReceiveCertIrp;
            pConnection->pReceiveCertIrp = NULL;

            //
            // Queue off a work item to do it. We don't want
            // to do this stuff inside the spinlock we're
            // holding, because part of the completion may
            // duplicate a handle, which we should do at
            // passive level.
            //
            UL_CALL_PASSIVE(
                UL_WORK_ITEM_FROM_IRP( pIrp ),
                &UlpAddSslClientCertToConnectionWorker
                );


        }
    }

    return Status;
}


/***************************************************************************++

Routine Description:

    Completes the ReceiveClientCert IRP.

Arguments:

    pWorkItem - a work item embedded in the IRP

--***************************************************************************/
VOID
UlpAddSslClientCertToConnectionWorker(
    IN PUL_WORK_ITEM pWorkItem
    )
{
    PIRP                    pIrp;
    PIO_STACK_LOCATION      pIrpSp;
    PUX_FILTER_CONNECTION   pConnection;
    PEPROCESS               pProcess;

    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // grab the irp off the work item
    //

    pIrp = UL_WORK_ITEM_TO_IRP( pWorkItem );

    ASSERT(IS_VALID_IRP(pIrp));

    //
    // Pull out the filter connection.
    //

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

    pConnection = (PUX_FILTER_CONNECTION)
                        pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer;

    ASSERT(IS_VALID_FILTER_CONNECTION(pConnection));

    pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer = NULL;

    //
    // Pull out the original process.
    //

    pProcess = UL_PROCESS_FROM_IRP(pIrp);
    ASSERT(pProcess);

    //
    // Do the completion stuff.
    //
    UlpCompleteReceiveClientCertIrp(
        pConnection,
        pProcess,
        pIrp
        );

    DEREFERENCE_FILTER_CONNECTION(pConnection);
}


/***************************************************************************++

Routine Description:

    Copies SSL client certinfo from the connection into a buffer supplied
    by the caller. Can also be called with a NULL buffer to get the
    required length. If the buffer is too small to hold all the data, none
    will be copied.

Arguments:

    pConnection - the connection to query
    pProcess - the process into which client cert tokens should be duped
    BufferSize - size of pBuffer in bytes
    pUserBuffer - optional pointer to user mode buffer
    pBuffer - optional output buffer (mapped to user mode buffer)
    pBytesCopied - if pBuffer is not NULL, pBytesCopied returns
                    the number of bytes copied into the output buffer.
                    Otherwise it returns the number of bytes
                    required in the buffer.

--***************************************************************************/
NTSTATUS
UlpGetSslClientCert(
    IN PUX_FILTER_CONNECTION pConnection,
    IN PEPROCESS pProcess,
    IN ULONG BufferSize,
    IN PUCHAR pUserBuffer OPTIONAL,
    OUT PUCHAR pBuffer OPTIONAL,
    OUT PHANDLE pMappedToken OPTIONAL,
    OUT PULONG pBytesCopied OPTIONAL
    )
{
    NTSTATUS Status;
    ULONG BytesCopied;
    ULONG BytesNeeded;
    ULONG CertBufferSize;
    PHTTP_SSL_CLIENT_CERT_INFO pCertInfo;
    PUCHAR pKeBuffer;

    //
    // Sanity check.
    //
    ASSERT(IS_VALID_FILTER_CONNECTION(pConnection));
    ASSERT(pConnection->SslClientCertPresent);
    ASSERT(!BufferSize || pBuffer);
    ASSERT(!BufferSize || pProcess);

    // Need to fix UlComputeRequestBytesNeeded before we can add the macro
    // PAGED_CODE()

    //
    // Initialize locals.
    //
    Status = STATUS_SUCCESS;
    BytesCopied = 0;
    BytesNeeded = 0;

    //
    // Figure out how much space is required for the cert.
    //

    CertBufferSize = pConnection->SslInfo.CertEncodedSize;

    BytesNeeded += sizeof(HTTP_SSL_CLIENT_CERT_INFO);
    BytesNeeded += CertBufferSize;

    //
    // Construct the HTTP_SSL_CLIENT_CERT_INFO in the caller's buffer.
    //

    if (pBuffer)
    {
        ASSERT(BytesNeeded);

        //
        // Make sure there's enough buffer.
        //
        if (BufferSize < BytesNeeded)
        {
            Status = STATUS_BUFFER_OVERFLOW;
            goto exit;
        }

        if (pConnection->SslInfo.Token)
        {
            //
            // Try to dup the mapped token into the caller's process.
            //
            ASSERT(g_pUlSystemProcess);
            ASSERT(pProcess != (PEPROCESS)g_pUlSystemProcess);

            Status = UlpDuplicateHandle(
                            (PEPROCESS)g_pUlSystemProcess,
                            pConnection->SslInfo.Token,
                            pProcess,
                            pMappedToken,
                            TOKEN_ALL_ACCESS,
                            0,
                            0,
                            KernelMode
                            );

            if (!NT_SUCCESS(Status))
            {
                goto exit;
            }
        }

        //
        // Copy the easy stuff.
        //

        RtlZeroMemory(pBuffer, BytesNeeded);

        pCertInfo = (PHTTP_SSL_CLIENT_CERT_INFO) pBuffer;

        pCertInfo->CertEncodedSize = pConnection->SslInfo.CertEncodedSize;
        pCertInfo->CertFlags = pConnection->SslInfo.CertFlags;
        pCertInfo->CertDeniedByMapper = pConnection->SslInfo.CertDeniedByMapper;
        pCertInfo->Token = *pMappedToken;

        BytesCopied += sizeof(HTTP_SSL_CLIENT_CERT_INFO);

        //
        // Copy the certificate.
        //

        pKeBuffer = pBuffer + sizeof(HTTP_SSL_CLIENT_CERT_INFO);

        pCertInfo->pCertEncoded = (PUCHAR) FIXUP_PTR(
                                        PSTR,
                                        pUserBuffer,
                                        pBuffer,
                                        pKeBuffer,
                                        BufferSize
                                        );
        RtlCopyMemory(
            pKeBuffer,
            pConnection->SslInfo.pCertEncoded,
            pConnection->SslInfo.CertEncodedSize
            );

        BytesCopied += CertBufferSize;

    }

    //
    // Tell the caller how many bytes we copied (or the number
    // that we would if they gave an output buffer).
    //
    ASSERT(NT_SUCCESS(Status));

    if (pBytesCopied)
    {
        if (pBuffer)
        {
            ASSERT(BytesCopied == BytesNeeded);
            *pBytesCopied = BytesCopied;
        }
        else
        {
            *pBytesCopied = BytesNeeded;
        }
    }

exit:
    return Status;

} // UlpGetSslClientCert


/***************************************************************************++

Routine Description:

    Looks through the list of filter processes attached to a filter channel
    for an available FilterAccept IRP.

Arguments:

    pFilterChannel - the filter channel to search
    ppFilterProcess - receives the process whose IRP we found

Return values:

    pointer to an Accept IRP, or NULL.

--***************************************************************************/
PIRP
UlpPopAcceptIrp(
    IN PUL_FILTER_CHANNEL pFilterChannel,
    OUT PUL_FILTER_PROCESS * ppFilterProcess
    )
{
    PIRP pIrp;
    PUL_FILTER_PROCESS pProcess;
    PLIST_ENTRY pEntry;

    //
    // Sanity check.
    //
    ASSERT(IS_VALID_FILTER_CHANNEL(pFilterChannel));
    ASSERT(UlDbgSpinLockOwned(&pFilterChannel->SpinLock));
    ASSERT(ppFilterProcess);

    pIrp = NULL;

    pEntry = pFilterChannel->ProcessListHead.Flink;
    while (pEntry != &pFilterChannel->ProcessListHead)
    {
        pProcess = CONTAINING_RECORD(
                        pEntry,
                        UL_FILTER_PROCESS,
                        ListEntry
                        );

        ASSERT(IS_VALID_FILTER_PROCESS(pProcess));

        pIrp = UlpPopAcceptIrpFromProcess(pProcess);

        if (pIrp)
        {
            *ppFilterProcess = pProcess;
            break;
        }

        pEntry = pEntry->Flink;
    }

    return pIrp;

} // UlpPopAcceptIrp


/***************************************************************************++

Routine Description:

    Gets a queued accept IRP from a UL_FILTER_PROCESS.

Arguments:

    pProcess - the process from which to pop an IRP

Return values:

    pointer to an IRP or NULL if none are available

--***************************************************************************/
PIRP
UlpPopAcceptIrpFromProcess(
    IN PUL_FILTER_PROCESS pProcess
    )
{
    PIRP pIrp;

    //
    // Sanity check.
    //
    ASSERT(IS_VALID_FILTER_PROCESS(pProcess));

    pIrp = NULL;

    while (!IsListEmpty(&(pProcess->IrpHead)))
    {
        PUL_FILTER_CHANNEL pFilterChannel;
        PLIST_ENTRY        pEntry;

        //
        // Found a free irp !
        //

        pEntry = RemoveHeadList(&pProcess->IrpHead);
        pEntry->Blink = pEntry->Flink = NULL;

        pIrp = CONTAINING_RECORD(
                    pEntry,
                    IRP,
                    Tail.Overlay.ListEntry
                    );

        //
        // pop the cancel routine
        //

        if (IoSetCancelRoutine(pIrp, NULL) == NULL)
        {
            //
            // IoCancelIrp pop'd it first
            //
            // ok to just ignore this irp, it's been pop'd off the queue
            // and will be completed in the cancel routine.
            //
            // keep looking for a irp to use
            //

            pIrp = NULL;

        }
        else if (pIrp->Cancel)
        {

            //
            // we pop'd it first. but the irp is being cancelled
            // and our cancel routine will never run. lets be
            // nice and complete the irp now (vs. using it
            // then completing it - which would also be legal).
            //
            pFilterChannel = (PUL_FILTER_CHANNEL)(
                                    IoGetCurrentIrpStackLocation(pIrp)->
                                        Parameters.DeviceIoControl.Type3InputBuffer
                                    );

            ASSERT(pFilterChannel == pProcess->pFilterChannel);

            DEREFERENCE_FILTER_CHANNEL(pFilterChannel);

            IoGetCurrentIrpStackLocation(pIrp)->
                Parameters.DeviceIoControl.Type3InputBuffer = NULL;

            pIrp->IoStatus.Status = STATUS_CANCELLED;
            pIrp->IoStatus.Information = 0;

            UlCompleteRequest(pIrp, IO_NO_INCREMENT);

            pIrp = NULL;
        }
        else
        {

            //
            // we are free to use this irp !
            //

            pFilterChannel = (PUL_FILTER_CHANNEL)(
                                    IoGetCurrentIrpStackLocation(pIrp)->
                                        Parameters.DeviceIoControl.Type3InputBuffer
                                    );

            ASSERT(pFilterChannel == pProcess->pFilterChannel);

            DEREFERENCE_FILTER_CHANNEL(pFilterChannel);

            IoGetCurrentIrpStackLocation(pIrp)->
                Parameters.DeviceIoControl.Type3InputBuffer = NULL;

            break;
        }
    }

    return pIrp;
}


/***************************************************************************++

Routine Description:

    Completes a filter accept IRP, and copies data to it (if there is any).
    Filter accept is METHOD_OUT_DIRECT.

Arguments:

    pIrp - the accept IRP we're completing
    pConnection - the connection to accept
    pBuffer - optional initial data
    IndicatedLength - length of initial data
    pTakenLength - receives amount of data copied

--***************************************************************************/
VOID
UlpCompleteAcceptIrp(
    IN PIRP pIrp,
    IN PUX_FILTER_CONNECTION pConnection,
    IN PVOID pBuffer OPTIONAL,
    IN ULONG IndicatedLength,
    OUT PULONG pTakenLength OPTIONAL
    )
{
    PIO_STACK_LOCATION pIrpSp;
    ULONG BytesNeeded;
    ULONG InitialLength;
    ULONG BytesCopied;
    ULONG OutputBufferLength;
    PUCHAR pKernelBuffer;
    PVOID pUserBuffer;
    NTSTATUS Status;

    //
    // Sanity check.
    //
    ASSERT(pIrp);
    ASSERT(NULL != pIrp->MdlAddress);
    ASSERT(IS_VALID_FILTER_CONNECTION(pConnection));

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    BytesCopied = 0;
    OutputBufferLength = pIrpSp->Parameters.DeviceIoControl.OutputBufferLength;

    //
    // First, get the amount of bytes required to fill out a
    // HTTP_RAW_CONNECTION_INFO structure. This is different for client
    // & server.
    //

    BytesNeeded = (pConnection->pComputeRawConnectionLengthHandler)(
                        pConnection->pConnectionContext
                        );

    if (OutputBufferLength > BytesNeeded)
    {
        InitialLength = OutputBufferLength - BytesNeeded;
    }
    else
    {
        InitialLength = 0;
    }

    InitialLength = MIN(InitialLength, IndicatedLength);

    UlTrace(FILTER, (
        "http!UlpCompleteAcceptIrp\n"
        "    OutputBufferLength = %lu, BytesNeeded = %lu, InitialLength = %lu\n",
        pIrpSp->Parameters.DeviceIoControl.OutputBufferLength,
        BytesNeeded,
        InitialLength
        ));

    if (BytesNeeded <= OutputBufferLength)
    {
        //
        // Plenty of room. Copy in the info.
        //

        pKernelBuffer = (PUCHAR) MmGetSystemAddressForMdlSafe(
                            pIrp->MdlAddress,
                            NormalPagePriority
                            );

        if (!pKernelBuffer)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto end;
        }

        VALIDATE_BUFFER_ALIGNMENT(pKernelBuffer, PVOID);

        pUserBuffer = MmGetMdlVirtualAddress( pIrp->MdlAddress );
        ASSERT( pUserBuffer != NULL );

        //
        // Clean up the memory.
        //
        RtlZeroMemory(pKernelBuffer, BytesNeeded);

        BytesCopied = BytesNeeded;

        //
        // Get The local & remote addresss.
        //
        BytesCopied += (pConnection->pGenerateRawConnectionInfoHandler)(
            pConnection->pConnectionContext,
            pKernelBuffer,
            pUserBuffer,
            OutputBufferLength,
            (PUCHAR) pBuffer,
            InitialLength
            );

        ASSERT(BytesCopied <= OutputBufferLength);

        Status = STATUS_SUCCESS;
    }
    else
    {
        //
        // Doh! There is not enough space.
        //
        Status = STATUS_BUFFER_OVERFLOW;
    }

end:

    UlTrace(FILTER, (
        "http!UlpCompleteAcceptIrp copied %lu bytes to %p. Status = %x\n",
        BytesCopied,
        pIrp,
        pIrp->IoStatus.Status
        ));

    if (pTakenLength)
    {
        *pTakenLength = InitialLength;
    }

    pIrp->IoStatus.Status = Status;
    pIrp->IoStatus.Information = BytesCopied;

    UlCompleteRequest(pIrp, IO_NETWORK_INCREMENT);

} // UlpCompleteAcceptIrp


/***************************************************************************++

Routine Description:

    Completes AppRead IRPs that don't contain data beyond the buffer type.

    AppRead is METHOD_OUT_DIRECT.

Arguments:

    pConnection - the connection with queued AppRead IRPs
    BufferType - the buffer type to write in the IRP

--***************************************************************************/
NTSTATUS
UlpCompleteAppReadIrp(
    IN PUX_FILTER_CONNECTION pConnection,
    IN HTTP_FILTER_BUFFER_TYPE BufferType,
    IN PUL_COMPLETION_ROUTINE pCompletionRoutine,
    IN PVOID pCompletionContext
    )
{
    NTSTATUS Status;
    KIRQL oldIrql;

    //
    // Sanity check.
    //
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);
    ASSERT(IS_VALID_FILTER_CONNECTION(pConnection));

    ASSERT(pConnection->ConnectionDelivered == TRUE);

    //
    // First, we'll see if we can complete immediately
    // by calling UxpCopyToQueuedRead. If not we'll queue the write
    // by creating a filter write tracker with UxpCreateFilterWriteTracker,
    // and then passing the tracker to UxpQueueFilterWrite.
    //


    //
    // Get ready.
    //
    Status = STATUS_SUCCESS;

    UlAcquireSpinLock(&pConnection->FilterConnLock, &oldIrql);

    if (pConnection->ConnState == UlFilterConnStateConnected)
    {
        PUX_FILTER_WRITE_TRACKER pTracker;

        PMDL  pCurrentMdl;
        ULONG MdlOffset;
        ULONG BytesCopied;

        //
        // try to write our message
        //

        Status = UxpCopyToQueuedRead(
                        &pConnection->AppToFiltQueue,
                        BufferType,
                        NULL,               // pMdlChain
                        0,                  // Length
                        &pCurrentMdl,
                        &MdlOffset,
                        &BytesCopied
                        );

        //
        // if we're not done, pend a write tracker.
        //

        if (Status == STATUS_MORE_PROCESSING_REQUIRED)
        {
            ASSERT(BytesCopied == 0);

            pTracker = UxpCreateFilterWriteTracker(
                            BufferType,
                            NULL,           // pMdlChain
                            0,              // MdlOffset
                            0,              // TotalBytes
                            BytesCopied,
                            pCompletionRoutine,
                            pCompletionContext
                            );

            if (!pTracker)
            {
                //
                // Doh! We couldn't create the tracker. Get out.
                //
                Status = STATUS_NO_MEMORY;
                goto end;
            }

            //
            // Now stick it on the queue.
            //

            Status = UxpQueueFilterWrite(
                            pConnection,
                            &pConnection->AppToFiltQueue,
                            pTracker
                            );

            if (NT_SUCCESS(Status))
            {
                //
                // return pending so the caller knows not to complete
                // the IRP.
                //
                Status = STATUS_PENDING;
            }
            else
            {
                //
                // Kill the tracker. The caller will take care of
                // completing the IRP with the status we return.
                //

                UxpDeleteFilterWriteTracker(pTracker);
            }

        }

    }
    else
    {
        //
        // We got disconnected, get out.
        //
        UlTrace(FILTER, (
            "http!UlpCompleteAppReadIrp connection aborted, quit writing!\n"
            ));

        //
        // For our purpose, we are successful if the connection
        // is already closed.
        //
        Status = STATUS_SUCCESS;
    }

end:
    UlReleaseSpinLock(&pConnection->FilterConnLock, oldIrql);


    if (Status != STATUS_PENDING)
    {
        //
        // Do a "completion".
        //

        Status = UlInvokeCompletionRoutine(
                        Status,
                        0,
                        pCompletionRoutine,
                        pCompletionContext
                        );

    }

    return Status;

} // UlpCompleteAppReadIrp


/***************************************************************************++

Routine Description:

    Completes ReceiveClientCert IRPs.

    ReceiveClientCert is METHOD_OUT_DIRECT.

Arguments:

    pConnection - the connection with queued ReceiveClientCert IRPs
    pProcess - the original caller's process
    pIrp - the actual IRP to be completed

--***************************************************************************/
NTSTATUS
UlpCompleteReceiveClientCertIrp(
    IN PUX_FILTER_CONNECTION pConnection,
    IN PEPROCESS pProcess,
    IN PIRP pIrp
    )
{
    NTSTATUS Status;
    ULONG BytesCopied;
    ULONG BytesNeeded;
    PUCHAR pIrpBuffer;
    ULONG BytesInIrp;
    HANDLE MappedToken = NULL;
    PIO_STACK_LOCATION pIrpSp;

    //
    // Sanity check.
    //
    ASSERT(IS_VALID_FILTER_CONNECTION(pConnection));
    ASSERT(pIrp);
    ASSERT(pConnection->SslClientCertPresent);

    PAGED_CODE();

    Status = STATUS_SUCCESS;
    BytesCopied = 0;
    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    BytesInIrp = pIrpSp->Parameters.DeviceIoControl.OutputBufferLength;

    //
    // This routine is always going to complete the IRP
    // and return pending, even if there is an error.
    // Make sure that the IRP is marked.
    //

    IoMarkIrpPending(pIrp);

    //
    // See if there's enough space.
    //

    Status = UlpGetSslClientCert(
                    pConnection,
                    NULL,           // pProcess
                    0,              // BufferSize
                    NULL,           // pUserBuffer
                    NULL,           // pBuffer
                    NULL,           // pMappedToken
                    &BytesNeeded
                    );

    if (!NT_SUCCESS(Status))
    {
        goto exit;
    }

    ASSERT(NULL != pIrp->MdlAddress);

    pIrpBuffer = (PUCHAR) MmGetSystemAddressForMdlSafe(
                        pIrp->MdlAddress,
                        NormalPagePriority
                        );

    if (!pIrpBuffer)
    {
        //
        // Insufficient resources to map the IRP buffer.
        //
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }


    if (!pConnection->SslInfo.SslRenegotiationFailed)
    {
        //
        // We have a real cert. Try to complete the IRP.
        //

        if (BytesInIrp >= BytesNeeded)
        {
            Status = UlpGetSslClientCert(
                            pConnection,
                            pProcess,
                            BytesInIrp,
                            (PUCHAR) MmGetMdlVirtualAddress(pIrp->MdlAddress),
                            pIrpBuffer,
                            &MappedToken,
                            &BytesCopied
                            );

        }
        else
        {
            PHTTP_SSL_CLIENT_CERT_INFO pCertInfo;

            //
            // There's not enough room in the buffer for the cert.
            // Tell them how big it is. (The IOCTL wrapper ensures
            // that the buffer is at least as big as a
            // HTTP_SSL_CLIENT_CERT_INFO.
            //
            ASSERT(BytesInIrp >= sizeof(HTTP_SSL_CLIENT_CERT_INFO));

            pCertInfo = (PHTTP_SSL_CLIENT_CERT_INFO) pIrpBuffer;
            pCertInfo->CertEncodedSize = pConnection->SslInfo.CertEncodedSize;
            pCertInfo->pCertEncoded = NULL;
            pCertInfo->CertFlags = 0;
            pCertInfo->CertDeniedByMapper = FALSE;
            pCertInfo->Token = NULL;

            BytesCopied = sizeof(HTTP_SSL_CLIENT_CERT_INFO);
            Status = STATUS_BUFFER_OVERFLOW;
        }
    }
    else
    {
        //
        // We tried and failed to renegotiate a certificate.
        // Return an error status.
        //

        Status = STATUS_NOT_FOUND;
        BytesCopied = 0;
    }

exit:
    ASSERT(NT_SUCCESS(Status) || NULL == MappedToken);

    //
    // Complete the IRP.
    //

    pIrp->IoStatus.Status = Status;
    pIrp->IoStatus.Information = BytesCopied;
    UlCompleteRequest(pIrp, IO_NETWORK_INCREMENT);

    return STATUS_PENDING;
}


/***************************************************************************++

Routine Description:

    Given pointers to two processes and a handle, this function duplicates
    the handle from one process into the other.

Arguments:

    SourceProcess - the process where the original handle lives
    SourceHandle - the handle to dup
    TargetProcess - the process to dup the handle to
    pTargetHandle - receives the duped handle
    DesiredAccess - desired access to the duped handle
    HandleAttributes - attributes for the handle (eg inheritable)
    Options - duplication options (e.g. close source)

--***************************************************************************/
NTSTATUS
UlpDuplicateHandle(
    IN PEPROCESS SourceProcess,
    IN HANDLE SourceHandle,
    IN PEPROCESS TargetProcess,
    OUT PHANDLE pTargetHandle,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG HandleAttributes,
    IN ULONG Options,
    IN KPROCESSOR_MODE PreviousMode
    )
{
    NTSTATUS Status;
    HANDLE SourceProcessHandle;
    HANDLE TargetProcessHandle;

    UNREFERENCED_PARAMETER(PreviousMode);

    //
    // Sanity check.
    //
    ASSERT(SourceProcess);
    ASSERT(SourceHandle);
    ASSERT(TargetProcess);
    ASSERT(pTargetHandle);

    PAGED_CODE();

    //
    // Init locals.
    //

    SourceProcessHandle = NULL;
    TargetProcessHandle = NULL;

    //
    // Get handles for the processes.
    //
    Status = ObOpenObjectByPointer(
                    SourceProcess,
                    0,
                    NULL,
                    PROCESS_ALL_ACCESS,
                    *PsProcessType,
                    KernelMode,
                    &SourceProcessHandle
                    );

    if (!NT_SUCCESS(Status))
    {
        goto exit;
    }

    Status = ObOpenObjectByPointer(
                    TargetProcess,
                    0,
                    NULL,
                    PROCESS_ALL_ACCESS,
                    *PsProcessType,
                    KernelMode,
                    &TargetProcessHandle
                    );

    if (!NT_SUCCESS(Status))
    {
        goto exit;
    }

    //
    // Dup the handle.
    //
    Status = ZwDuplicateObject(
                    SourceProcessHandle,
                    SourceHandle,
                    TargetProcessHandle,
                    pTargetHandle,
                    DesiredAccess,
                    HandleAttributes,
                    Options
                    );

exit:
    //
    // Clean up the handles.
    //
    if (SourceProcessHandle)
    {
        ZwClose(SourceProcessHandle);
    }

    if (TargetProcessHandle)
    {
        ZwClose(TargetProcessHandle);
    }

    return Status;
}


/***************************************************************************++

Routine Description:

    Once a connection get disconnected gracefully and there's still unreceived
    data on it. We have to drain this extra bytes to expect the tdi disconnect
    indication.

Arguments:

    pConnection - stuck connection we have to drain out to complete the
                  gracefull disconnect.

--***************************************************************************/

VOID
UlFilterDrainIndicatedData(
    IN PUL_WORK_ITEM  pWorkItem
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PUX_FILTER_CONNECTION pConnection;
    PUL_FILTER_RECEIVE_BUFFER pReceiveBuffer = NULL;
    KIRQL    OldIrql;
    ULONG    BytesToRead = 0;

    //
    // Sanity check and init
    //

    ASSERT(pWorkItem != NULL);

    pConnection = CONTAINING_RECORD(
                    pWorkItem,
                    UX_FILTER_CONNECTION,
                    WorkItem
                    );
    ASSERT(IS_VALID_FILTER_CONNECTION(pConnection));

    //
    // Mark the drain state and restart receive if necessary.
    //

    UlAcquireSpinLock(&pConnection->FilterConnLock, &OldIrql);

    pConnection->DrainAfterDisconnect = TRUE;

    //
    // Even if ReadIrp is pending, it does not matter as we will just  discard
    // the indications from now on. We indicate this by marking the above flag.
    //

    if (pConnection->TdiReadPending ||
        pConnection->TransportBytesNotTaken == 0)
    {
        UlReleaseSpinLock(&pConnection->FilterConnLock, OldIrql);

        //
        // Release the refcount our caller put, before bailing out.
        //

        DEREFERENCE_FILTER_CONNECTION(pConnection);

        return;
    }

    //
    // We need to issue a receive to restart the flow of data again. Therefore
    // we can drain.
    //

    pConnection->TdiReadPending = TRUE;

    BytesToRead = pConnection->TransportBytesNotTaken;

    UlReleaseSpinLock(&pConnection->FilterConnLock, OldIrql);

    //
    // Do not try to drain more than g_UlMaxBufferedBytes. If necessary we will
    // issue another receive later.
    //

    BytesToRead = MIN(BytesToRead, g_UlMaxBufferedBytes);
    BytesToRead = ALIGN_UP(BytesToRead, PVOID);

    //
    // Issue the Read IRP outside the spinlock. Issue the receive.  Reference
    // the connection so it doesn't go away while we're waiting. The reference
    // will be removed after the completion.
    //

    pReceiveBuffer = UL_ALLOCATE_STRUCT_WITH_SPACE(
                        NonPagedPool,
                        UL_FILTER_RECEIVE_BUFFER,
                        BytesToRead,
                        UL_FILTER_RECEIVE_BUFFER_POOL_TAG
                        );

    if (pReceiveBuffer)
    {
        //
        // We won't use this buffer but simply discard it when
        // the completion happens.
        //

        pReceiveBuffer->Signature   = UL_FILTER_RECEIVE_BUFFER_POOL_TAG;
        pReceiveBuffer->pConnection = pConnection;

        //
        // Completion on the receive always happens. Therefore
        // it's safe to not to worry about cleaning up the receive
        // buffer here in case of error.
        //

        Status = (pConnection->pReceiveDataHandler)(
                        pConnection->pConnectionContext,
                        pReceiveBuffer->pBuffer,
                        BytesToRead,
                        &UlpRestartFilterDrainIndicatedData,
                        pReceiveBuffer
                        );
    }
    else
    {
        //
        // We're out of memory. Nothing we can do. Release the
        // reference that our caller put since the completion
        // function is not going to get called.
        //

        Status = STATUS_INSUFFICIENT_RESOURCES;
        DEREFERENCE_FILTER_CONNECTION(pConnection);
    }

    UlTrace(FILTER, (
        "UlFilterDrainIndicatedData(pConn = %p, pUlConn = %p)\n"
        "        Status = %x, BufferSize = %lu\n",
        pConnection,
        pConnection->pConnectionContext,
        Status,
        BytesToRead
        ));

    if (!NT_SUCCESS(Status))
    {
        //
        // Close the connection in case the failure was not
        // a network error.
        //

        (pConnection->pCloseConnectionHandler)(
                    pConnection->pConnectionContext,
                    TRUE,           // AbortiveDisconnect
                    NULL,           // pCompletionRoutine
                    NULL            // pCompletionContext
                    );
    }

}

/***************************************************************************++

Routine Description:

    Completion function for DrainIndicatedData. It decides on continuing
    the drain on the connection.

Arguments:

    pConnection - stuck connection we have to drain out to complete the
                  gracefull disconnect.

--***************************************************************************/

VOID
UlpRestartFilterDrainIndicatedData(
    IN PVOID pContext,
    IN NTSTATUS Status,
    IN ULONG_PTR Information
    )
{
    KIRQL oldIrql;
    PUX_FILTER_CONNECTION pConnection;
    PUL_FILTER_RECEIVE_BUFFER pReceiveBuffer;
    BOOLEAN IssueDrain = FALSE;

    //
    // Get the receive buffer and the connection out.
    //

    pReceiveBuffer = (PUL_FILTER_RECEIVE_BUFFER) pContext;
    ASSERT(IS_VALID_FILTER_RECEIVE_BUFFER(pReceiveBuffer));

    pConnection = pReceiveBuffer->pConnection;
    ASSERT(IS_VALID_FILTER_CONNECTION(pConnection));

    ASSERT(pConnection->DrainAfterDisconnect == 1);

    UlTrace(FILTER,(
        "UlpRestartDrainIndicatedData: pFilterConnection (%p)"
        "pReceiveBuffer (%p)\n",
         pConnection,
         pReceiveBuffer
         ));

    //
    // If we were successful, either start another read or stop
    // and abort the connection.
    //

    if (NT_SUCCESS(Status))
    {
        //
        // It worked! Update the accounting and see if there's more
        // reading to do.
        //
        UlAcquireSpinLock(&pConnection->FilterConnLock, &oldIrql);

        if (Information >= pConnection->TransportBytesNotTaken)
        {
            //
            // The read got everything. TDI will start indications again
            // after we return unless more bytes get posted.
            //

            pConnection->TransportBytesNotTaken = 0;
            pConnection->TdiReadPending = FALSE;
        }
        else
        {
            //
            // There are still more bytes to receive, keep receiving.
            //

            pConnection->TransportBytesNotTaken -= (ULONG)Information;
            pConnection->TdiReadPending = TRUE;
            IssueDrain = TRUE;
        }

        UlReleaseSpinLock(&pConnection->FilterConnLock, oldIrql);

    }
    else
    {
        (pConnection->pCloseConnectionHandler)(
                    pConnection->pConnectionContext,
                    TRUE,           // AbortiveDisconnect
                    NULL,           // pCompletionRoutine
                    NULL            // pCompletionContext
                    );
    }

    if (IssueDrain)
    {
        //
        // Put a reference on filter connection until the drain
        // is done.
        //
        REFERENCE_FILTER_CONNECTION(pConnection);

        UL_QUEUE_WORK_ITEM(
                &pConnection->WorkItem,
                &UlFilterDrainIndicatedData
                );
    }

    //
    // Release the reference we added for previous DrainIndicatedData
    //
    DEREFERENCE_FILTER_CONNECTION(pConnection);

    //
    // Free the receive buffer.
    //
    pReceiveBuffer->pConnection = NULL;
    UL_FREE_POOL_WITH_SIG(pReceiveBuffer, UL_FILTER_RECEIVE_BUFFER_POOL_TAG);

}

/***************************************************************************++

Routine Description:

    Queues a raw read IRP on a UX_FILTER_CONNECTION.

    Caller must hold the FilterConnLock.

Arguments:

    pConnection - the connection on which to queue an IRP
    pIrp - the IRP to queue

--***************************************************************************/
NTSTATUS
UxpQueueRawReadIrp(
    IN PUX_FILTER_CONNECTION pConnection,
    IN PIRP pIrp
    )
{
    NTSTATUS Status;
    PIO_STACK_LOCATION pIrpSp;

    //
    // Sanity check.
    //
    ASSERT(IS_VALID_FILTER_CONNECTION(pConnection));
    ASSERT(UlDbgSpinLockOwned(&pConnection->FilterConnLock));

    //
    // Queue the IRP.
    //

    IoMarkIrpPending(pIrp);

    //
    // Give the irp a pointer to the connection.
    //

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer = pConnection;

    REFERENCE_FILTER_CONNECTION(pConnection);

    //
    // Set to these to null just in case the cancel routine runs.
    //

    pIrp->Tail.Overlay.ListEntry.Flink = NULL;
    pIrp->Tail.Overlay.ListEntry.Blink = NULL;

    IoSetCancelRoutine(pIrp, &UlpCancelFilterRawRead);

    //
    // cancelled?
    //

    if (pIrp->Cancel)
    {
        //
        // darn it, need to make sure the irp get's completed
        //

        if (IoSetCancelRoutine( pIrp, NULL ) != NULL)
        {
            //
            // we are in charge of completion, IoCancelIrp didn't
            // see our cancel routine (and won't).  ioctl wrapper
            // will complete it
            //
            DEREFERENCE_FILTER_CONNECTION(pConnection);

            pIrp->IoStatus.Information = 0;

            UlUnmarkIrpPending( pIrp );
            Status = STATUS_CANCELLED;
            goto end;
        }

        //
        // our cancel routine will run and complete the irp,
        // don't touch it
        //

        //
        // STATUS_PENDING will cause the ioctl wrapper to
        // not complete (or touch in any way) the irp
        //

        Status = STATUS_PENDING;
        goto end;
    }

    //
    // now we are safe to queue it
    //

    InsertTailList(
        &pConnection->RawReadIrpHead,
        &pIrp->Tail.Overlay.ListEntry
        );

    Status = STATUS_PENDING;

end:
    return Status;
}

/***************************************************************************++

Routine Description:

    Gets a queued raw read IRP from a UX_FILTER_CONNECTION.

    Caller must hold the FilterConnLock.

Arguments:

    pConnection - the connection from which to pop an IRP

Return values:

    pointer to an IRP or NULL if none are available

--***************************************************************************/
PIRP
UxpDequeueRawReadIrp(
    IN PUX_FILTER_CONNECTION pConnection
    )
{
    PIRP pIrp;

    //
    // Sanity check.
    //
    ASSERT(IS_VALID_FILTER_CONNECTION(pConnection));
    ASSERT(UlDbgSpinLockOwned(&pConnection->FilterConnLock));

    pIrp = NULL;

    while (!IsListEmpty(&pConnection->RawReadIrpHead))
    {
        PUX_FILTER_CONNECTION     pConn;
        PLIST_ENTRY        pEntry;

        //
        // Found a free irp !
        //

        pEntry = RemoveHeadList(&pConnection->RawReadIrpHead);
        pEntry->Blink = pEntry->Flink = NULL;

        pIrp = CONTAINING_RECORD(
                    pEntry,
                    IRP,
                    Tail.Overlay.ListEntry
                    );

        //
        // pop the cancel routine
        //

        if (IoSetCancelRoutine(pIrp, NULL) == NULL)
        {
            //
            // IoCancelIrp pop'd it first
            //
            // ok to just ignore this irp, it's been pop'd off the queue
            // and will be completed in the cancel routine.
            //
            // keep looking for a irp to use
            //

            pIrp = NULL;

        }
        else if (pIrp->Cancel)
        {

            //
            // we pop'd it first. but the irp is being cancelled
            // and our cancel routine will never run. lets be
            // nice and complete the irp now (vs. using it
            // then completing it - which would also be legal).
            //
            pConn = (PUX_FILTER_CONNECTION)(
                        IoGetCurrentIrpStackLocation(pIrp)->
                            Parameters.DeviceIoControl.Type3InputBuffer
                        );

            ASSERT(pConn == pConnection);

            DEREFERENCE_FILTER_CONNECTION(pConnection);

            IoGetCurrentIrpStackLocation(pIrp)->
                Parameters.DeviceIoControl.Type3InputBuffer = NULL;

            pIrp->IoStatus.Status = STATUS_CANCELLED;
            pIrp->IoStatus.Information = 0;

            UlCompleteRequest(pIrp, IO_NO_INCREMENT);

            pIrp = NULL;
        }
        else
        {

            //
            // we are free to use this irp !
            //

            pConn = (PUX_FILTER_CONNECTION)(
                        IoGetCurrentIrpStackLocation(pIrp)->
                            Parameters.DeviceIoControl.Type3InputBuffer
                        );

            ASSERT(pConn == pConnection);

            DEREFERENCE_FILTER_CONNECTION(pConnection);

            IoGetCurrentIrpStackLocation(pIrp)->
                Parameters.DeviceIoControl.Type3InputBuffer = NULL;

            break;
        }
    }

    return pIrp;
}


/***************************************************************************++

Routine Description:

    Removes all the queued raw read irps from a connection an cancels them.

Arguments:

    pConnection - the connection to clean up

--***************************************************************************/
VOID
UxpCancelAllQueuedRawReads(
    IN PUX_FILTER_CONNECTION pConnection
    )
{
    PIRP pIrp;

    //
    // Sanity check.
    //
    ASSERT(IS_VALID_FILTER_CONNECTION(pConnection));

    while (NULL != (pIrp = UxpDequeueRawReadIrp(pConnection)))
    {
        pIrp->IoStatus.Status = STATUS_CANCELLED;
        pIrp->IoStatus.Information = 0;

        UlCompleteRequest(pIrp, IO_NO_INCREMENT);
    }
}

/***************************************************************************++

Routine Description:

    Sets the count of bytes that have been buffered for us by the
    transport. When this number is non-zero, TDI will not indicate data
    to us, so we have to read it with IRPs.

    This function will trigger IRP reads if we have raw reads around in
    our queue.

Arguments:

    pConnection - the connection with queued data
    TransportBytesNotTaken - number of bytes to add to the total

--***************************************************************************/
VOID
UxpSetBytesNotTaken(
    IN PUX_FILTER_CONNECTION pConnection,
    IN ULONG TransportBytesNotTaken
    )
{
    KIRQL oldIrql;
    BOOLEAN IssueDrain = FALSE;

    UlTrace(FILTER, (
        "http!UxpSetBytesNotTaken(pConnection = %p, TransportBytesNotTaken = %lu)\n",
        pConnection,
        TransportBytesNotTaken
        ));

    //
    // Sanity check.
    //
    ASSERT(IS_VALID_FILTER_CONNECTION(pConnection));

    if (TransportBytesNotTaken)
    {
        UlAcquireSpinLock(&pConnection->FilterConnLock, &oldIrql);
        ASSERT(pConnection->TransportBytesNotTaken == 0);

        pConnection->TransportBytesNotTaken = TransportBytesNotTaken;

        IssueDrain = (BOOLEAN) (pConnection->DrainAfterDisconnect != 0);

        UlReleaseSpinLock(&pConnection->FilterConnLock, oldIrql);

        if (IssueDrain)
        {
            //
            // Put a reference on filter connection until the drain
            // is done.
            //
            REFERENCE_FILTER_CONNECTION(pConnection);

            UL_QUEUE_WORK_ITEM(
                    &pConnection->WorkItem,
                    &UlFilterDrainIndicatedData
                    );
        }
        else
        {
            UxpProcessRawReadQueue(pConnection);
        }
    }
}


/***************************************************************************++

Routine Description:

    Completes RawRead IRPs, copying as much data in to them as possible.

    RawRead is METHOD_OUT_DIRECT.

Arguments:

    pConnection - the connection with queued AppRead IRPs
    pBuffer - the buffer containing the data
    IndicatedLength - amount of data in the buffer
    pTakenLength - receives the amount of data we consumed

--***************************************************************************/
NTSTATUS
UxpProcessIndicatedData(
    IN PUX_FILTER_CONNECTION pConnection,
    IN PVOID pBuffer,
    IN ULONG IndicatedLength,
    OUT PULONG pTakenLength
    )
{
    NTSTATUS Status;
    PIRP pIrp;
    PIO_STACK_LOCATION pIrpSp;
    ULONG BytesCopied;
    ULONG BytesToCopy;
    ULONG BytesInIrp;
    PUCHAR pSrcBuffer;
    PUCHAR pIrpBuffer;

    KIRQL oldIrql;

    //
    // Sanity check.
    //
    ASSERT(IS_VALID_FILTER_CONNECTION(pConnection));
    ASSERT(IndicatedLength);
    ASSERT(pTakenLength);

    Status = STATUS_SUCCESS;
    BytesCopied = 0;
    pSrcBuffer = (PUCHAR) pBuffer;

    UlAcquireSpinLock(&pConnection->FilterConnLock, &oldIrql);

    if (pConnection->DrainAfterDisconnect)
    {
        //
        // Regardless of the fact that there's an irp or not. We will
        // drain this data out and cancel the IRPs on cleanup. Because
        // we are trying to close the connection at this time.
        //
        pIrp = NULL;
    }
    else
    {
        pIrp = UxpDequeueRawReadIrp(pConnection);
    }

    UlReleaseSpinLock(&pConnection->FilterConnLock, oldIrql);

    while (pIrp && (BytesCopied < IndicatedLength))
    {
        UlTrace(FILTER, (
            "http!UxpProcessIndicatedData(pConn = %p)\n"
            "        dequeued IRP = %p, size %lu\n",
            pConnection,
            pIrp,
            IoGetCurrentIrpStackLocation(pIrp)->
                Parameters.DeviceIoControl.OutputBufferLength
            ));

        //
        // Copy some data.
        //
        pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
        BytesInIrp = pIrpSp->Parameters.DeviceIoControl.OutputBufferLength;

        BytesToCopy = MIN(BytesInIrp, (IndicatedLength - BytesCopied));

        ASSERT(NULL != pIrp->MdlAddress);

        pIrpBuffer = (PUCHAR) MmGetSystemAddressForMdlSafe(
                            pIrp->MdlAddress,
                            NormalPagePriority
                            );

        if (pIrpBuffer)
        {
            RtlCopyMemory(
                pIrpBuffer,
                pSrcBuffer + BytesCopied,
                BytesToCopy
                );

            BytesCopied += BytesToCopy;
            ASSERT(BytesCopied <= IndicatedLength);
        }
        else
        {
            //
            // Insufficient resources to map the IRP buffer.
            //
            Status = STATUS_INSUFFICIENT_RESOURCES;
            BytesToCopy = 0;
        }

        //
        // Complete the IRP.
        //
        pIrp->IoStatus.Status = Status;
        pIrp->IoStatus.Information = BytesToCopy;
        UlCompleteRequest(pIrp, IO_NETWORK_INCREMENT);

        pIrp = NULL;

        //
        // Get a new IRP if there's more to do.
        //
        if (NT_SUCCESS(Status) && (BytesCopied < IndicatedLength))
        {
            UlAcquireSpinLock(&pConnection->FilterConnLock, &oldIrql);

            pIrp = UxpDequeueRawReadIrp(pConnection);

            UlReleaseSpinLock(&pConnection->FilterConnLock, oldIrql);
        }
    }

    //
    // Return amount of copied data.
    //
    *pTakenLength = BytesCopied;

    UlTrace(FILTER, (
        "http!UxpProcessIndicatedData pConn = %p, Status = %x\n"
        "    consumed %lu of %lu bytes indicated\n",
        pConnection,
        Status,
        *pTakenLength,
        IndicatedLength
        ));


    return Status;
}

/***************************************************************************++

Routine Description:

    If there is data for this connection buffered in TDI, and we have
    available raw read IRPs, this function issues reads to TDI to retrieve
    that data.

Arguments:

    pConnection - the connection with queued data

--***************************************************************************/
VOID
UxpProcessRawReadQueue(
    IN PUX_FILTER_CONNECTION pConnection
    )
{
    KIRQL oldIrql;
    BOOLEAN IssueRead;

    PIRP pIrp;
    PIO_STACK_LOCATION pIrpSp;

    //
    // Sanity check.
    //
    ASSERT(IS_VALID_FILTER_CONNECTION(pConnection));

    UlAcquireSpinLock(&pConnection->FilterConnLock, &oldIrql);

    IssueRead = FALSE;
    pIrp = NULL;

    //
    // If there are bytes to read and no one is reading them already...
    //
    if ((pConnection->TransportBytesNotTaken > 0) &&
        !pConnection->TdiReadPending)
    {
        //
        // and we have an IRP...
        //
        pIrp = UxpDequeueRawReadIrp(pConnection);

        if (pIrp)
        {
            //
            // Remember that we've started a read.
            //
            pConnection->TdiReadPending = TRUE;

            //
            // Issue a read once we get out of the spinlock.
            //
            IssueRead = TRUE;
        }
    }
    else
    if (!pConnection->TdiReadPending &&
        !pConnection->TransportBytesNotTaken &&
        pConnection->DisconnectNotified &&
        !pConnection->DisconnectDelivered)
    {
        //
        // If we have taken everything, check if we need to notify a
        // graceful disconnect to the app.
        //
        pIrp = UxpDequeueRawReadIrp(pConnection);

        if (pIrp)
        {
            pConnection->DisconnectDelivered = TRUE;

            //
            // Complete the IRP.
            //
            pIrp->IoStatus.Status = STATUS_SUCCESS;
            pIrp->IoStatus.Information = 0;
            UlCompleteRequest(pIrp, IO_NETWORK_INCREMENT);
        }
    }

    UlReleaseSpinLock(&pConnection->FilterConnLock, oldIrql);

    UlTrace(FILTER, (
        "http!UxpProcessRawReadQueue(pConnection = %p)\n"
        "        TransportBytesNotTaken = %lu, TdiReadPending = %d, IssueRead = %d\n",
        pConnection,
        pConnection->TransportBytesNotTaken,
        pConnection->TdiReadPending,
        IssueRead
        ));

    if (IssueRead)
    {
        //
        // Stick a reference to the connection in the IRP.
        // This reference will get passed from IRP to IRP as we process
        // the queue. It will be released when we are through issuing
        // reads to TDI.
        //
        REFERENCE_FILTER_CONNECTION(pConnection);

        pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
        pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer = pConnection;

        //
        // Call TDI from the worker routine.
        //

        UL_QUEUE_WORK_ITEM(
            UL_WORK_ITEM_FROM_IRP( pIrp ),
            &UxpProcessRawReadQueueWorker
            );
    }
}


/***************************************************************************++

Routine Description:

    Worker routine for UxpProcessRawReadQueue. Issues a read to TDI.

Arguments:

    pWorkItem - work item embedded in a raw read IRP.

--***************************************************************************/
VOID
UxpProcessRawReadQueueWorker(
    IN PUL_WORK_ITEM pWorkItem
    )
{
    NTSTATUS Status;

    PIRP pIrp;
    PIO_STACK_LOCATION pIrpSp;
    ULONG BufferSize;
    PVOID pBuffer;

    PUX_FILTER_CONNECTION pConnection;

    PAGED_CODE();

    //
    // Get the IRP and the connection.
    //
    pIrp = UL_WORK_ITEM_TO_IRP( pWorkItem );

    ASSERT(IS_VALID_IRP(pIrp));

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

    pConnection = (PUX_FILTER_CONNECTION)
                        pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer;

    ASSERT(IS_VALID_FILTER_CONNECTION(pConnection));

    ASSERT(NULL != pIrp->MdlAddress);

    //
    // Map the buffer and figure out how big it is.
    //
    pBuffer = MmGetSystemAddressForMdlSafe(
                    pIrp->MdlAddress,
                    NormalPagePriority
                    );

    if (pBuffer)
    {
        BufferSize = pIrpSp->Parameters.DeviceIoControl.OutputBufferLength;

        //
        // Issue the read.
        //

        Status = (pConnection->pReceiveDataHandler)(
                        pConnection->pConnectionContext,
                        pBuffer,
                        BufferSize,
                        &UxpRestartProcessRawReadQueue,
                        pIrp
                        );
    }
    else
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        BufferSize = 0;
    }

    UlTrace(FILTER, (
        "UxpProcessRawReadQueueWorker(pConn = %p, pIrp = %p)\n"
        "        Status = %x, BufferSize = %lu\n",
        pConnection,
        pIrp,
        Status,
        BufferSize
        ));

    //
    // Clean up if it didn't work.
    //

    if (!NT_SUCCESS(Status))
    {
        //
        // Complete the IRP we dequeued.
        //
        pIrp->IoStatus.Status = Status;
        pIrp->IoStatus.Information = 0;

        UlCompleteRequest(pIrp, IO_NO_INCREMENT);

        //
        // Close the connection in case the failure was not
        // a network error.
        //

        (pConnection->pCloseConnectionHandler)(
                    pConnection->pConnectionContext,
                    TRUE,           // AbortiveDisconnect
                    NULL,           // pCompletionRoutine
                    NULL            // pCompletionContext
                    );

        //
        // Release the reference we added in UxpProcessRawReadQueue since
        // no more reads will be issued.
        //
        DEREFERENCE_FILTER_CONNECTION(pConnection);
    }

}

/***************************************************************************++

Routine Description:

    Completion routine for UxpProcessRawReadQueue.

Arguments:

    pContext - a raw read IRP
    Status - completion status
    Information - bytes read

--***************************************************************************/
VOID
UxpRestartProcessRawReadQueue(
    IN PVOID pContext,
    IN NTSTATUS Status,
    IN ULONG_PTR Information
    )
{
    KIRQL oldIrql;
    PIRP pIrp;
    PIO_STACK_LOCATION pIrpSp;

    PUX_FILTER_CONNECTION pConnection;

    BOOLEAN IssueRead;
    BOOLEAN IssueDrain;

    //
    // Get the IRP and the connection out.
    //
    pIrp = (PIRP)pContext;
    ASSERT(IS_VALID_IRP(pIrp));

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

    pConnection = (PUX_FILTER_CONNECTION)
                        pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer;

    ASSERT(IS_VALID_FILTER_CONNECTION(pConnection));

    UlTrace( FILTER, (
        "UxpRestartProcessRawReadQueue: Completing pIrp %p, pConnection %p, Status 0x%X\n",
        pIrp,
        pConnection,
        Status
        ));

    //
    // Complete the raw read IRP.
    //
    pIrp->IoStatus.Status = Status;
    pIrp->IoStatus.Information = Information;

    UlCompleteRequest(pIrp, IO_NETWORK_INCREMENT);

    //
    // Set up for the next round if there is one.
    //
    IssueRead = FALSE;
    IssueDrain= FALSE;

    pIrp = NULL;
    pIrpSp = NULL;

    //
    // If we were successful, either start another read or stop
    // issuing more reads.
    //
    if (NT_SUCCESS(Status))
    {
        //
        // It worked! Update the accounting and see if there's more
        // reading to do.
        //
        UlAcquireSpinLock(&pConnection->FilterConnLock, &oldIrql);

        if (Information >= pConnection->TransportBytesNotTaken)
        {
            //
            // The read got everything. TDI will start indications again
            // after we return.
            //

            pConnection->TransportBytesNotTaken = 0;
            pConnection->TdiReadPending = FALSE;

            //
            // Check if we have been gracefully disconnected.
            //

            if (pConnection->DisconnectNotified &&
                !pConnection->DisconnectDelivered)
            {
                pIrp = UxpDequeueRawReadIrp(pConnection);

                if (pIrp)
                {
                    pConnection->DisconnectDelivered = TRUE;

                    //
                    // Complete the IRP.
                    //

                    pIrp->IoStatus.Status = STATUS_SUCCESS;
                    pIrp->IoStatus.Information = 0;
                    UlCompleteRequest(pIrp, IO_NETWORK_INCREMENT);

                    pIrp = NULL;
                }
            }
        }
        else
        {
            //
            // There are still more bytes to read.
            //

            pConnection->TransportBytesNotTaken -= (ULONG)Information;

            //
            // Grab a new IRP.
            //

            pIrp = UxpDequeueRawReadIrp(pConnection);

            if (pIrp)
            {
                //
                // Issue a read once we get out here.
                //
                IssueRead = TRUE;
            }
            else
            {
                //
                // We want to keep reading, but we don't have
                // an IRP so we have to stop for now.
                //

                pConnection->TdiReadPending = FALSE;
                if (pConnection->DrainAfterDisconnect)
                {
                    //
                    // Start draining remaning parts once we
                    // get out here.
                    //
                    IssueDrain = TRUE;
                }
            }

        }

        UlReleaseSpinLock(&pConnection->FilterConnLock, oldIrql);
    }
    else
    {
        //
        // The connection must have died. Just let the normal cleanup
        // path happen by itself.
        //
    }

    if (IssueRead)
    {
        ASSERT(IS_VALID_IRP(pIrp));

        //
        // Issue the read. Note that we're calling UlQueueWorkItem
        // instead of UlCallPassive because otherwise we might get
        // into a recursive loop that blows the stack.
        //

        pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
        pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer = pConnection;

        UL_QUEUE_WORK_ITEM(
            UL_WORK_ITEM_FROM_IRP( pIrp ),
            &UxpProcessRawReadQueueWorker
            );
    }
    else
    {
        ASSERT(pIrp == NULL);

        //
        // See if we have to drain any remaining bytes on the
        // disconnected connection.
        //
        if (IssueDrain)
        {
            //
            // Put a reference until drain is done.
            //
            REFERENCE_FILTER_CONNECTION(pConnection);

            UL_QUEUE_WORK_ITEM(
                &pConnection->WorkItem,
                &UlFilterDrainIndicatedData
                );
        }

        //
        // Since we are not going to issue another read, we can
        // release the reference we added in UxpProcessRawReadQueue.
        //
        DEREFERENCE_FILTER_CONNECTION(pConnection);
    }
}


/***************************************************************************++

Routine Description:

    Increments the reference count on the specified connection.

Arguments:

    pConnection - Supplies the connection to reference.

    pFileName (REFERENCE_DEBUG only) - Supplies the name of the file
        containing the calling function.

    LineNumber (REFERENCE_DEBUG only) - Supplies the line number of
        the calling function.

--***************************************************************************/
VOID
UxReferenceConnection(
    IN PVOID pObject
    REFERENCE_DEBUG_FORMAL_PARAMS
    )
{
    PUX_FILTER_CONNECTION pConnection = (PUX_FILTER_CONNECTION) pObject;

#if REFERENCE_DEBUG
    UNREFERENCED_PARAMETER(pFileName);
    UNREFERENCED_PARAMETER(LineNumber);
#endif

    ASSERT( IS_VALID_FILTER_CONNECTION( pConnection ) );
    //
    // This filter connection object is owned by either the client or the
    // server connection objects. We have to propogate the ref to the right
    // context
    //

    REFERENCE_FILTER_CONNECTION(pConnection);

}

/***************************************************************************++

Routine Description:

    Initializes the UX_FILTER_CONNECTION structure

Arguments:

    pConnection            - Pointer to UX_FILTER_CONNECTION
    Secure                 - Secure connection
    pfnReferenceFunction   - Pointer to parent ReferenceFunction
                             (e.g. UlReferenceConnection)
    pfnDereferenceFunction - Pointer to parent DereferenceFunction
                             (e.g. UlDereferenceConnection)
    pfnConnectionClose     - Pointer to connection close handler

    pfnSendRawData         - Pointer to raw data send handler (UlpSendRawData)
    pfnReceiveData         - Pointer to data receive handler (UlpReceiveRawData)
    pfnDataReceiveHandler  - Pointer to client's data receive handler
                             (UlHttpReceive)
    pListenContext         - Pointer to endpoint context
    pConnectionContext     - Pointer to parent context (e.g. UL_CONNECTION)
    pAddressBuffer         - Address Buffer

--***************************************************************************/

NTSTATUS
UxInitializeFilterConnection(
    IN PUX_FILTER_CONNECTION                    pConnection,
    IN PUL_FILTER_CHANNEL                       pFilterChannel,
    IN BOOLEAN                                  Secure,
    IN PUL_OPAQUE_ID_OBJECT_REFERENCE           pfnReferenceFunction,
    IN PUL_OPAQUE_ID_OBJECT_REFERENCE           pfnDereferenceFunction,
    IN PUX_FILTER_CLOSE_CONNECTION              pfnConnectionClose,
    IN PUX_FILTER_SEND_RAW_DATA                 pfnSendRawData,
    IN PUX_FILTER_RECEIVE_RAW_DATA              pfnReceiveData,
    IN PUL_DATA_RECEIVE                         pfnDummyTdiReceiveHandler,
    IN PUX_FILTER_COMPUTE_RAW_CONNECTION_LENGTH pfnRawConnLength,
    IN PUX_FILTER_GENERATE_RAW_CONNECTION_INFO  pfnGenerateRawConnInfo,
    IN PUX_FILTER_SERVER_CERT_INDICATE          pfnServerCertIndicate,
    IN PUX_FILTER_DISCONNECT_NOTIFICATION       pfnDisconnectNotification,
    IN PVOID                                    pListenContext,
    IN PVOID                                    pConnectionContext
    )
{
    NTSTATUS status = STATUS_SUCCESS;

    UNREFERENCED_PARAMETER(pListenContext);

    pConnection->Signature               = UX_FILTER_CONNECTION_SIGNATURE;

    HTTP_SET_NULL_ID(&pConnection->ConnectionId);

    pConnection->pFilterChannel                     = pFilterChannel;
    pConnection->SecureConnection                   = Secure;
    pConnection->ChannelEntry.Flink                 = NULL;
    pConnection->ChannelEntry.Blink                 = NULL;
    pConnection->pReferenceHandler                  = pfnReferenceFunction;
    pConnection->pDereferenceHandler                = pfnDereferenceFunction;
    pConnection->pCloseConnectionHandler            = pfnConnectionClose;
    pConnection->pSendRawDataHandler                = pfnSendRawData;
    pConnection->pReceiveDataHandler                = pfnReceiveData;
    pConnection->pDummyTdiReceiveHandler            = pfnDummyTdiReceiveHandler;
    pConnection->pComputeRawConnectionLengthHandler = pfnRawConnLength;
    pConnection->pGenerateRawConnectionInfoHandler  = pfnGenerateRawConnInfo;
    pConnection->pServerCertIndicateHandler         = pfnServerCertIndicate;
    pConnection->pDisconnectNotificationHandler     = pfnDisconnectNotification;

    pConnection->ConnState               = UlFilterConnStateInactive;
    pConnection->TransportBytesNotTaken  = 0;
    pConnection->TdiReadPending          = FALSE;
    pConnection->ConnectionDelivered     = 0;
    pConnection->SslInfoPresent          = 0;
    pConnection->SslClientCertPresent    = 0;
    pConnection->pReceiveCertIrp         = NULL;

    pConnection->DrainAfterDisconnect    = 0;
    pConnection->DisconnectNotified      = 0;
    pConnection->DisconnectDelivered     = 0;
    UlInitializeWorkItem(&pConnection->WorkItem);

    //
    // Store the context's
    //
    pConnection->pConnectionContext      = pConnectionContext;


    InitializeListHead(&pConnection->RawReadIrpHead);
    UlInitializeSpinLock(&pConnection->FilterConnLock, "FilterConnLock");
    UxpInitializeFilterWriteQueue(
        &pConnection->AppToFiltQueue,
        NULL,
        NULL
        );
    UxpInitializeFilterWriteQueue(
        &pConnection->FiltToAppQueue,
        UlpEnqueueFilterAppWrite,
        UlpDequeueFilterAppWrite
        );

    RtlZeroMemory(&pConnection->SslInfo, sizeof(UL_SSL_INFORMATION));

    if (pConnection->pFilterChannel)
    {
        //
        // Get an opaque ID for the connection.
        //

        status = UlAllocateOpaqueId(
                        &pConnection->ConnectionId,
                        UlOpaqueIdTypeRawConnection,
                        pConnection);

        if(NT_SUCCESS(status))
        {
            REFERENCE_FILTER_CONNECTION(pConnection);
        }
    }

    return status;
}


/***************************************************************************++

Routine Description:

    Initializes a filter write queue. This is a producer/consumer queue
    for moving data between the filter and app.

Arguments:

    pWriteQueue - the queue to initialize.

    pWriteEnqueueRoutine - called to enqueue a write

    pWriteDequeueRoutine - called to dequeue a write

--***************************************************************************/
VOID
UxpInitializeFilterWriteQueue(
    IN PUX_FILTER_WRITE_QUEUE pWriteQueue,
    IN PUX_FILTER_WRITE_ENQUEUE pWriteEnqueueRoutine,
    IN PUX_FILTER_WRITE_DEQUEUE pWriteDequeueRoutine
    )
{
    //
    // Sanity check.
    //

    ASSERT(pWriteQueue);

    //
    // Set up the queue.
    //

    pWriteQueue->PendingWriteCount = 0;
    pWriteQueue->PendingReadCount = 0;

    InitializeListHead(&pWriteQueue->WriteTrackerListHead);
    InitializeListHead(&pWriteQueue->ReadIrpListHead);

    pWriteQueue->pWriteEnqueueRoutine = pWriteEnqueueRoutine;
    pWriteQueue->pWriteDequeueRoutine = pWriteDequeueRoutine;
}


/***************************************************************************++

Routine Description:

    Queues a filter write. As new read IRPs arrive data from the write will
    be placed in the read buffers. When all the data is copied (or an error
    occurs) then the write will be completed.

    Must be called with the FilterConnLock held.

Arguments:

    pConnection - the connection on which were queueing

    pWriteQueue - the queue to put the write on

    pTracker - the write tracker to queue

--***************************************************************************/
NTSTATUS
UxpQueueFilterWrite(
    IN PUX_FILTER_CONNECTION pConnection,
    IN PUX_FILTER_WRITE_QUEUE pWriteQueue,
    IN PUX_FILTER_WRITE_TRACKER pTracker
    )
{
    NTSTATUS Status;

    //
    // Sanity check.
    //

    ASSERT(pConnection);
    ASSERT(pWriteQueue);
    ASSERT(pTracker);

    //
    // Store a pointer to the write queue in the tracker.
    // Also store a pointer to the connection.
    // If the queued write contains an IRP, and the write
    // gets cancelled, it will need these pointers to
    // complete the write.
    //
    // We need a reference on the filter connection to keep
    // it around. We'll release the ref when the write is
    // completed.
    //

    REFERENCE_FILTER_CONNECTION(pConnection);

    pTracker->pConnection = pConnection;
    pTracker->pWriteQueue = pWriteQueue;

    //
    // If the write queue has an enqueue routine, call
    // it now.
    //

    if (pWriteQueue->pWriteEnqueueRoutine)
    {
        Status = (pWriteQueue->pWriteEnqueueRoutine)(
                        pTracker
                        );
    }
    else
    {
        Status = STATUS_SUCCESS;
    }

    if (NT_SUCCESS(Status))
    {
        //
        // Put the tracker in the queue.
        //

        InsertTailList(
            &pWriteQueue->WriteTrackerListHead,
            &pTracker->ListEntry
            );

        pWriteQueue->PendingWriteCount++;
    }
    else
    {
        //
        // If the write was not queued successfully, then
        // the completion won't run. Any tracker cleanup
        // that would have happened there must happen now.
        //

        //
        // Release our reference to the connection acquired
        // above.
        //

        DEREFERENCE_FILTER_CONNECTION(pTracker->pConnection);

        pTracker->pConnection = NULL;
        pTracker->pWriteQueue = NULL;
    }

    UlTrace(FILTER, (
        "http!UxpQueueFilterWrite status = %x, pTracker = %p, pContext = %p\n"
        "        BufferType = %d, Length = %lu\n",
        Status,
        pTracker,
        pTracker->pCompletionContext,
        pTracker->BufferType,
        pTracker->Length
        ));


    return Status;
}

/***************************************************************************++

Routine Description:

    Requeues a filter write. We do this when we dequeue a write, but cannot
    copy all the data into the receiver's buffer. Since this write's buffers
    should be copied next, we insert at the head of the list.

    Must be called with the FilterConnLock held.

Arguments:

    pWriteQueue - the queue to put the write on

    pTracker - the write to requeue

--***************************************************************************/
NTSTATUS
UxpRequeueFilterWrite(
    IN PUX_FILTER_WRITE_QUEUE pWriteQueue,
    IN PUX_FILTER_WRITE_TRACKER pTracker
    )
{
    NTSTATUS Status;

    //
    // Sanity check.
    //
    ASSERT(pWriteQueue);
    ASSERT(IS_VALID_FILTER_WRITE_TRACKER(pTracker));
    ASSERT(pTracker->pWriteQueue == pWriteQueue);

#if DBG
    //
    // Never requeue a stream tracker that has no space left in it!
    //

    if ( HttpFilterBufferHttpStream == pTracker->BufferType )
    {
        ASSERT( pTracker->Offset != pTracker->Length );
    }
    else
    {
        ASSERT( (0 == pTracker->Length) ||
                (pTracker->Offset != pTracker->Length)
                );
    }
#endif // DBG

    //
    // If the write queue has an enqueue routine, call
    // it now.
    //

    if (pWriteQueue->pWriteEnqueueRoutine)
    {
        Status = (pWriteQueue->pWriteEnqueueRoutine)(
                        pTracker
                        );
    }
    else
    {
        Status = STATUS_SUCCESS;
    }

    if (NT_SUCCESS(Status))
    {
        InsertHeadList(
            &pWriteQueue->WriteTrackerListHead,
            &pTracker->ListEntry
            );

        pWriteQueue->PendingWriteCount++;
    }

    UlTrace(FILTER, (
        "http!UxpRequeueFilterWrite status = %x, pTracker = %p, pContext = %p\n"
        "        BufferType = %d, Length = %lu, BytesCopied = %lu\n",
        Status,
        pTracker,
        pTracker->pCompletionContext,
        pTracker->BufferType,
        pTracker->Length,
        pTracker->BytesCopied
        ));

    return Status;
}

/***************************************************************************++

Routine Description:

    Removes a queued write from the head of the list.

    Must be called with the FilterConnLock held.

Arguments:

    pWriteQueue - the queue from which to get the write

Return Values:

    Returns the first queued write in the list or NULL of the queue is empty.

--***************************************************************************/
PUX_FILTER_WRITE_TRACKER
UxpDequeueFilterWrite(
    IN PUX_FILTER_WRITE_QUEUE pWriteQueue
    )
{
    PLIST_ENTRY pListEntry;
    PUX_FILTER_WRITE_TRACKER pTracker;
    NTSTATUS Status;

    //
    // Sanity check.
    //

    ASSERT(pWriteQueue);

    pTracker = NULL;

    //
    // Grab the first write off the queue.
    //

    while (!IsListEmpty(&pWriteQueue->WriteTrackerListHead))
    {
        //
        // Grab a tracker.
        //

        pListEntry = RemoveHeadList(&pWriteQueue->WriteTrackerListHead);

        pListEntry->Flink = NULL;
        pListEntry->Blink = NULL;

        pTracker = CONTAINING_RECORD(
                        pListEntry,
                        UX_FILTER_WRITE_TRACKER,
                        ListEntry
                        );

        ASSERT(IS_VALID_FILTER_WRITE_TRACKER(pTracker));

        ASSERT(pWriteQueue->PendingWriteCount > 0);
        pWriteQueue->PendingWriteCount--;

        //
        // See if we're allowed to use the tracker.
        //

        if (pWriteQueue->pWriteDequeueRoutine)
        {
            Status = (pWriteQueue->pWriteDequeueRoutine)(
                            pTracker
                            );

        }
        else
        {
            Status = STATUS_SUCCESS;
        }

        if (NT_SUCCESS(Status))
        {
            //
            // We got one.
            //

            UlTrace(FILTER, (
                "http!UxpDequeueFilterWrite pTracker = %p, pContext = %p\n"
                "        BufferType = %d, Length = %lu, BytesCopied = %lu\n",
                pTracker,
                pTracker->pCompletionContext,
                pTracker->BufferType,
                pTracker->Length,
                pTracker->BytesCopied
                ));

            break;
        }
        else
        {
            //
            // We didn't get one.
            //

            pTracker = NULL;

            UlTrace(FILTER, (
                "http!UxpDequeueFilterWrite: couldn't get tracker. pWriteQueue = %p Status = %X\n",
                pWriteQueue,
                Status
                ));

        }
    }


    return pTracker;
}


/***************************************************************************++

Routine Description:

    Copies data from a filter write queue into a memory buffer. As the
    queued writes are used up, this routine will complete them.

    Must be called with the FilterConnLock held.

Arguments:

    pWriteQueue - the queue from which to get the data

    pBufferType - returns the type of buffer we copied

    pBuffer - the buffer where we write the data

    BufferLength - length of pBuffer in bytes

    pBytesCopied - returns the number of bytes copied

Return values:

    Returns STATUS_SUCCESS unless a memory or queuing error occurs.
    This means that a success status may be returned even if no data
    was copied.

    The pBufferType and pBytesCopied OUT parameters are always set.
    If the function returns success, the caller should check these
    parameters to see what happened. If the *pBufferType is anything
    but stream, then the read should be completed with that buffer
    type because those types have no data. If *pBufferType is
    HttpStream and *pBytesCopied is zero, the read should be queued.

--***************************************************************************/
NTSTATUS
UxpCopyQueuedWriteData(
    IN PUX_FILTER_WRITE_QUEUE pWriteQueue,
    OUT PHTTP_FILTER_BUFFER_TYPE pBufferType,
    OUT PUCHAR pBuffer,
    IN ULONG BufferLength,
    OUT PUX_FILTER_WRITE_TRACKER * pWriteTracker,
    OUT PULONG pBytesCopied
    )
{
    PUX_FILTER_WRITE_TRACKER pTracker;
    ULONG BytesCopied;
    HTTP_FILTER_BUFFER_TYPE BufferType;
    NTSTATUS Status;

    PUCHAR pMdlBuffer;
    ULONG BytesInMdl;
    ULONG BytesInBuffer;
    ULONG BytesToCopy;

    //
    // Sanity check.
    //

    ASSERT(pWriteQueue);
    ASSERT(pBufferType);
    ASSERT(pBuffer);
    ASSERT(BufferLength);
    ASSERT(pBytesCopied);

    // CODEWORK: ASSERT that we have the FilterConn spin lock.

    //
    // Default type of data is HttpStream.
    //

    BufferType = HttpFilterBufferHttpStream;

    //
    // Initialize pWriteTracker if the caller has passed one in.
    //

    if (pWriteTracker)
    {
        *pWriteTracker = NULL;
    }

    //
    // Copy 'till you puke.
    //

    Status = STATUS_SUCCESS;
    BytesCopied = 0;
    BytesInBuffer = BufferLength;

    while (TRUE)
    {
        //
        // Grab a queued write.
        //

        pTracker = UxpDequeueFilterWrite(pWriteQueue);

        if (!pTracker)
        {
            //
            // We are all out of queued write data.
            // Bail out.
            //

            break;
        }

        ASSERT(IS_VALID_FILTER_CONNECTION(pTracker->pConnection));
        ASSERT(UlDbgSpinLockOwned(&pTracker->pConnection->FilterConnLock));

        //
        // If the write type is not stream, we return
        // immediately, because non-stream writes must
        // complete a whole read by themselves.
        //
        // If we haven't read any stream data yet, we
        // can complete the non-stream write. Otherwise,
        // we have to requeue that write, and complete
        // with the stream data we've already read.
        //

        if (pTracker->BufferType != HttpFilterBufferHttpStream)
        {
            ASSERT(Status == STATUS_SUCCESS);

            if (BytesCopied == 0)
            {
                //
                // No stream data has been read.
                // Capture the buffer type to be returned to
                // the caller.
                //
                BufferType = pTracker->BufferType;

                UxpCompleteQueuedWrite(
                    Status,
                    pWriteQueue,
                    pTracker
                    );

            }
            else
            {
                //
                // We already read some stream data into
                // the caller's buffer, so we can't
                // pass back the current write.
                // Requeue it and return.
                //

                Status = UxpRequeueFilterWrite(
                                pWriteQueue,
                                pTracker
                                );

                if (!NT_SUCCESS(Status))
                {
                    //
                    // Got an error putting the write back on the
                    // queue. Complete it and forget about any
                    // bytes we got out of it.
                    //

                    pTracker->BytesCopied = 0;
                    BytesCopied = 0;

                    UxpCompleteQueuedWrite(
                        Status,
                        pWriteQueue,
                        pTracker
                        );
                }
            }

            break;
        }

        //
        // We're copying data from an HttpStream write.
        // Make sure we can get at the MDL buffer.
        //

        ASSERT( HttpFilterBufferHttpStream == pTracker->BufferType );

        while (pTracker && NULL != pTracker->pMdl)
        {
            pMdlBuffer = (PUCHAR) MmGetSystemAddressForMdlSafe(
                                    pTracker->pMdl,
                                    NormalPagePriority
                                    );

            if (!pMdlBuffer)
            {
                //
                // Big trouble, we couldn't get an address for the buffer
                // which means we are out of memory. We need to get out
                // of here! Complete the tracker now so it can clean up.
                //

                Status = STATUS_INSUFFICIENT_RESOURCES;
                pTracker->BytesCopied = 0;

                UxpCompleteQueuedWrite(
                    Status,
                    pWriteQueue,
                    pTracker
                    );

                goto end;
            }

            //
            // Figure out how much data to copy.
            //

            BytesInMdl = MmGetMdlByteCount(pTracker->pMdl);
            BytesToCopy = MIN((BytesInMdl - pTracker->Offset), BytesInBuffer);

            ASSERT( 0 != BytesToCopy );

            //
            // Copy the data
            //

            RtlCopyMemory(
                pBuffer + BytesCopied,
                pMdlBuffer + pTracker->Offset,
                BytesToCopy
                );

            //
            // Update our local stats.
            //

            BytesCopied += BytesToCopy;
            BytesInBuffer -= BytesToCopy;

            //
            // Update the write tracker.
            //

            pTracker->Offset += BytesToCopy;
            ASSERT(pTracker->Offset <= BytesInMdl);

            pTracker->BytesCopied += BytesToCopy;
            ASSERT(pTracker->BytesCopied <= pTracker->Length);

            if ((pTracker->Offset == BytesInMdl) ||
                (pTracker->Offset == pTracker->Length))
            {
                //
                // We are done with this MDL. Move to the next one.
                //

                pTracker->pMdl = pTracker->pMdl->Next;
                pTracker->Offset = 0;

                // NOTE: Don't touch pTracker->BytesCopied, since it's
                // used by UxpCompleteQueuedWrite.

                if (pTracker->pMdl == NULL)
                {
                    ASSERT(pTracker->BytesCopied == pTracker->Length);

                    //
                    // We are done with the whole write tracker.
                    // Complete the queued write. Pass the write tracker
                    // back to the caller if the caller asks us so. This
                    // is needed since UlpRestartFilterAppWrite can start
                    // the raw read process which takes the lock we are
                    // holding now.
                    //

                    if (pWriteTracker)
                    {
                        *pWriteTracker = pTracker;
                    }
                    else
                    {
                        UxpCompleteQueuedWrite(
                            STATUS_SUCCESS,
                            pTracker->pWriteQueue,
                            pTracker
                            );
                    }

                    pTracker = NULL;
                }
            }

            //
            // If we're out of buffer space, requeue the tracker
            // and break out of the loop.
            //

            if (BytesInBuffer == 0)
            {
                if (pTracker)
                {
                    Status = UxpRequeueFilterWrite(
                                pWriteQueue,
                                pTracker
                                );

                    if (!NT_SUCCESS(Status))
                    {
                        //
                        // Got an error putting the write back on the
                        // queue. Complete it and forget about any
                        // bytes we got out of it.
                        //

                        pTracker->BytesCopied = 0;
                        BytesCopied = 0;

                        UxpCompleteQueuedWrite(
                            Status,
                            pWriteQueue,
                            pTracker
                            );
                    }
                }

                goto end;
            }
        }
    }

end:

    //
    // Done!
    //

    if (NT_SUCCESS(Status))
    {
        *pBufferType  = BufferType;
        *pBytesCopied = BytesCopied;
    }
    else
    {
        *pBytesCopied = 0;
    }

    return Status;
}


/***************************************************************************++

Routine Description:

    Completes a queued write operation. Calls the appropriate completion
    routine for this type of write, and frees the write tracker.

Arguments:

    Status - Status for the completion
    pWriteQueue - the write queue that the write was on
    pTracker - the queued write to be completed

--***************************************************************************/
VOID
UxpCompleteQueuedWrite(
    IN NTSTATUS Status,
    IN PUX_FILTER_WRITE_QUEUE pWriteQueue,
    IN PUX_FILTER_WRITE_TRACKER pTracker
    )
{
    //
    // Sanity check.
    //
    ASSERT(pWriteQueue);
    ASSERT(pTracker);

    UNREFERENCED_PARAMETER(pWriteQueue);

    ASSERT(!NT_SUCCESS(Status) || (pTracker->BytesCopied == pTracker->Length));

    UlTrace(FILTER, (
        "http!UxpCompleteQueuedWrite status = %x, pTracker = %p, pContext = %p\n",
        Status,
        pTracker,
        pTracker->pCompletionContext
        ));

    //
    // Call the completion routine.
    //

    if (pTracker->pCompletionRoutine)
    {
        (pTracker->pCompletionRoutine)(
            pTracker->pCompletionContext,
            Status,
            pTracker->BytesCopied
            );
    }

    //
    // Release our reference to the connection that we got
    // when the write was first queued.
    //

    DEREFERENCE_FILTER_CONNECTION(pTracker->pConnection);

    pTracker->pConnection = NULL;
    pTracker->pWriteQueue = NULL;

    //
    // Get rid of the tracker.
    //
    UxpDeleteFilterWriteTracker(pTracker);
}


/***************************************************************************++

Routine Description:

    Queues a read IRP on a UX_FILTER_WRITE_QUEUE in a connection.
    Once the IRP is queued, we update the queue state.

Arguments:

    pConnection - the connection on which to queue it
    pWriteQueue - the actual queue
    pIrp - the IRP we're queueing
    pCancelRoutine - cancel routine for the IRP

--***************************************************************************/
NTSTATUS
UxpQueueFilterRead(
    IN PUX_FILTER_CONNECTION pConnection,
    IN PUX_FILTER_WRITE_QUEUE pWriteQueue,
    IN PIRP pIrp,
    IN PDRIVER_CANCEL pCancelRoutine
    )
{
    NTSTATUS Status;
    PIO_STACK_LOCATION pIrpSp;

    //
    // Sanity check.
    //
    ASSERT(pIrp);
    ASSERT(IS_VALID_FILTER_CONNECTION(pConnection));
    ASSERT(UlDbgSpinLockOwned(&pConnection->FilterConnLock));
    ASSERT(pWriteQueue);
    ASSERT(pWriteQueue->PendingWriteCount == 0);

    //
    // Mark it pending.
    //

    IoMarkIrpPending(pIrp);

    //
    // Give the irp a pointer to the connection.
    //

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer = pConnection;

    REFERENCE_FILTER_CONNECTION(pConnection);

    //
    // Set to these to null just in case the cancel routine runs.
    //

    pIrp->Tail.Overlay.ListEntry.Flink = NULL;
    pIrp->Tail.Overlay.ListEntry.Blink = NULL;

    //
    // Set the cancel routine.
    //
    IoSetCancelRoutine(pIrp, pCancelRoutine);

    //
    // cancelled?
    //

    if (pIrp->Cancel)
    {
        //
        // darn it, need to make sure the irp get's completed
        //

        if (IoSetCancelRoutine( pIrp, NULL ) != NULL)
        {
            //
            // we are in charge of completion, IoCancelIrp didn't
            // see our cancel routine (and won't).  ioctl wrapper
            // will complete it
            //

            DEREFERENCE_FILTER_CONNECTION(pConnection);

            pIrp->IoStatus.Information = 0;

            UlUnmarkIrpPending( pIrp );
            Status = STATUS_CANCELLED;
            goto end;
        }

        //
        // our cancel routine will run and complete the irp,
        // don't touch it
        //

        //
        // STATUS_PENDING will cause the ioctl wrapper to
        // not complete (or touch in any way) the IRP.
        //

        Status = STATUS_PENDING;
        goto end;
    }

    //
    // now we are safe to queue it
    //

    InsertTailList(
        &pWriteQueue->ReadIrpListHead,
        &pIrp->Tail.Overlay.ListEntry
        );

    Status = STATUS_PENDING;

    //
    // Update the count of IRPs
    //
    pWriteQueue->PendingReadCount++;

 end:

    return Status;
}


/***************************************************************************++

Routine Description:

    Removes a queued read from the head of the list.

    Must be called with the FilterConnLock held.

Arguments:

    pWriteQueue - the queue from which to get the read

Return Values:

    Returns the first queued read in the list or NULL of the queue is empty.

--***************************************************************************/
PIRP
UxpDequeueFilterRead(
    IN PUX_FILTER_WRITE_QUEUE pWriteQueue
    )
{
    PIRP pIrp;
    PUX_FILTER_CONNECTION pConn;

    //
    // Sanity check.
    //

    ASSERT(pWriteQueue);
    ASSERT(pWriteQueue->PendingWriteCount == 0 ||
           pWriteQueue->PendingReadCount == 0);

    pIrp = NULL;

    while (!IsListEmpty(&pWriteQueue->ReadIrpListHead))
    {
        PLIST_ENTRY pListEntry;

        //
        // Grab an IRP.
        //

        pListEntry = RemoveHeadList(&pWriteQueue->ReadIrpListHead);

        pListEntry->Flink = NULL;
        pListEntry->Blink = NULL;

        pIrp = CONTAINING_RECORD(
                    pListEntry,
                    IRP,
                    Tail.Overlay.ListEntry
                    );

        ASSERT(IS_VALID_IRP(pIrp));

        ASSERT(pWriteQueue->PendingReadCount > 0);
        pWriteQueue->PendingReadCount--;

        //
        // See if we're allowed to use the IRP.
        //

        //
        // pop the cancel routine
        //

        if (IoSetCancelRoutine(pIrp, NULL) == NULL)
        {
            //
            // IoCancelIrp pop'd it first
            //
            // ok to just ignore this irp, it's been pop'd off the queue
            // and will be completed in the cancel routine.
            //
            // keep looking for a irp to use
            //

            pIrp = NULL;

        }
        else if (pIrp->Cancel)
        {
            //
            // we pop'd it first. but the irp is being cancelled
            // and our cancel routine will never run. lets be
            // nice and complete the irp now (vs. using it
            // then completing it - which would also be legal).
            //
            pConn = (PUX_FILTER_CONNECTION)(
                        IoGetCurrentIrpStackLocation(pIrp)->
                            Parameters.DeviceIoControl.Type3InputBuffer
                        );

            ASSERT(IS_VALID_FILTER_CONNECTION(pConn));

            DEREFERENCE_FILTER_CONNECTION(pConn);

            IoGetCurrentIrpStackLocation(pIrp)->
                Parameters.DeviceIoControl.Type3InputBuffer = NULL;

            pIrp->IoStatus.Status = STATUS_CANCELLED;
            pIrp->IoStatus.Information = 0;

            UlCompleteRequest(pIrp, IO_NO_INCREMENT);

            pIrp = NULL;
        }
        else
        {
            //
            // we are free to use this irp !
            //

            pConn = (PUX_FILTER_CONNECTION)(
                        IoGetCurrentIrpStackLocation(pIrp)->
                            Parameters.DeviceIoControl.Type3InputBuffer
                        );

            ASSERT(IS_VALID_FILTER_CONNECTION(pConn));

            DEREFERENCE_FILTER_CONNECTION(pConn);

            IoGetCurrentIrpStackLocation(pIrp)->
                Parameters.DeviceIoControl.Type3InputBuffer = NULL;

            //
            // We got one.
            //

            UlTrace(FILTER, (
                "http!UxpDequeueFilterRead pIrp = %p\n",
                pIrp
                ));

            break;
        }
    }

    return pIrp;
}


/***************************************************************************++

Routine Description:

    Copies the caller's data into queued read IRPs. As the queued
    reads are used up, this routine will complete them.

    N.B. UxpCopyToQueuedRead assumes that it's dealing with the
    AppToFilt queue, and therefore will copy an HTTP_FILTER_BUFFER
    header into the IRP. If we ever start using this routine
    for FiltToApp, we'd need a parameter that says which queue
    we're using.

    Must be called with the FilterConnLock held.

Arguments:

    pWriteQueue - the queue from which to get the data

    BufferType - the type of write we're doing

    pMdlChain - data to be copied

    Length - length of pMdlChain data in bytes

    ppCurrentMdl - returns a pointer to the first MDL in the chain
                    with uncopied data

    pMdlOffset - returns the offset into *ppCurrentMdl to the first byte
                    of uncopied data

    pBytesCopied - returns the number of bytes copied, NOT including
                    the filter buffer headers.

Return values:

    Returns STATUS_MORE_PROCESSING_REQUIRED if we ran out of IRPs
    before all the data was passed along.

--***************************************************************************/
NTSTATUS
UxpCopyToQueuedRead(
    IN PUX_FILTER_WRITE_QUEUE pWriteQueue,
    IN HTTP_FILTER_BUFFER_TYPE BufferType,
    IN PMDL pMdlChain,
    IN ULONG Length,
    OUT PMDL * ppCurrentMdl,
    OUT PULONG pMdlOffset,
    OUT PULONG pBytesCopied
    )
{
    NTSTATUS Status;
    ULONG MdlOffset;
    ULONG BytesCopied;
    PIRP pIrp;
    PIO_STACK_LOCATION pIrpSp;

    ASSERT(pWriteQueue);
    ASSERT(ppCurrentMdl);
    ASSERT(pMdlOffset);
    ASSERT(pBytesCopied);

    //
    // Set up for the loop.
    //

    Status = STATUS_SUCCESS;
    MdlOffset = 0;
    BytesCopied = 0;
    pIrp = NULL;

    do
    {
        PUCHAR pIrpBuffer;
        ULONG BytesInIrp;

        PHTTP_FILTER_BUFFER pFiltBuffer;

        //
        // Grab a queued read IRP.
        //

        ASSERT(pIrp == NULL);

        pIrp = UxpDequeueFilterRead(pWriteQueue);

        if (!pIrp)
        {
            ASSERT(pWriteQueue->PendingReadCount == 0);

            //
            // No more IRPs are available. Get out.
            // Return STATUS_MORE_PROCESSING_REQUIRED so the caller
            // knows we didn't get it all.
            //

            Status = STATUS_MORE_PROCESSING_REQUIRED;
            goto end;
        }

        //
        // Copy data into the IRP.
        //
        ASSERT(pIrp->MdlAddress);

        pIrpBuffer = (PUCHAR)MmGetSystemAddressForMdlSafe(
                                pIrp->MdlAddress,
                                NormalPagePriority
                                );


        if (!pIrpBuffer)
        {
            //
            // Big trouble, we couldn't get an address for the buffer
            // which means we are out of memory. We need to get out
            // of here!
            //

            Status = STATUS_INSUFFICIENT_RESOURCES;
            BytesCopied = 0;

            //
            // Complete the IRP we dequeued.
            //

            pIrp->IoStatus.Status = Status;
            pIrp->IoStatus.Information = 0;

            UlCompleteRequest(pIrp, IO_NETWORK_INCREMENT);
            pIrp = NULL;

            goto end;
        }

        //
        // How much space do we have?
        //

        pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
        BytesInIrp =
            pIrpSp->Parameters.DeviceIoControl.OutputBufferLength;

        ASSERT(BytesInIrp > sizeof(HTTP_FILTER_BUFFER));

        //
        // How much space do we have for data after making
        // room for the header.
        //
        // Note: AppToFilt assumption that we add the header at all.
        //

        BytesInIrp -= sizeof(HTTP_FILTER_BUFFER);
        BytesInIrp = MIN(BytesInIrp, Length);

        //
        // Fill in the header.
        //

        pFiltBuffer = (PHTTP_FILTER_BUFFER)pIrpBuffer;

        pFiltBuffer->BufferType = BufferType;
        pFiltBuffer->BufferSize = 0;

        if (BytesInIrp)
        {
            //
            // Figure out the user address where the data goes
            //

            pFiltBuffer->pBuffer =
                FIXUP_PTR(
                    PUCHAR,
                    MmGetMdlVirtualAddress(pIrp->MdlAddress),   // user addr
                    pFiltBuffer,                                // kernel addr
                    pFiltBuffer + 1,                            // offset ptr
                    BytesInIrp + sizeof(HTTP_FILTER_BUFFER)     // buffer size
                    );
        }
        else
        {
            //
            // No data to copy besides the header itself.
            //

            pFiltBuffer->pBuffer = NULL;
        }

        pIrp->IoStatus.Information = sizeof(HTTP_FILTER_BUFFER);
        pIrpBuffer = (PUCHAR)(pFiltBuffer + 1);

        //
        // Copy the data.
        //

        while (BytesInIrp)
        {
            PUCHAR pMdlBuffer;
            ULONG BytesInMdl;
            ULONG BytesToCopy;

            ASSERT(pIrpBuffer);
            ASSERT(pMdlChain);

            //
            // Get the MDL buffer.
            //

            pMdlBuffer = (PUCHAR) MmGetSystemAddressForMdlSafe(
                                        pMdlChain,
                                        NormalPagePriority
                                        );

            if (!pMdlBuffer)
            {
                //
                // Big trouble, we couldn't get an address for the buffer
                // which means we are out of memory. We need to get out
                // of here!
                //

                Status = STATUS_INSUFFICIENT_RESOURCES;
                BytesCopied = 0;

                //
                // Complete the IRP we dequeued.
                //

                pIrp->IoStatus.Status = Status;
                pIrp->IoStatus.Information = 0;

                UlCompleteRequest(pIrp, IO_NETWORK_INCREMENT);
                pIrp = NULL;

                goto end;
            }


            //
            // Figure out how much we can copy from the current
            // MDL in the chain.
            //

            BytesInMdl = MmGetMdlByteCount(pMdlChain);
            BytesInMdl -= MdlOffset;

            BytesToCopy = MIN(BytesInIrp, BytesInMdl);

            //
            // Copy the data.
            //

            RtlCopyMemory(
                pIrpBuffer,
                pMdlBuffer,
                BytesToCopy
                );

            //
            // Update stats.
            //

            BytesCopied += BytesToCopy;
            pFiltBuffer->BufferSize += BytesToCopy;

            //
            // Update MDL chain info.
            //

            BytesInMdl -= BytesToCopy;

            if (BytesInMdl)
            {
                //
                // We've still got more to copy.
                //
                MdlOffset += BytesToCopy;
            }
            else
            {
                //
                // We drained this MDL. Move to the next one.
                //

                pMdlChain = pMdlChain->Next;
                MdlOffset = 0;
            }

            //
            // Update IRP info.
            //

            pIrp->IoStatus.Information += BytesToCopy;
            BytesInIrp -= BytesToCopy;

            pIrpBuffer += BytesToCopy;

        }

        //
        // We filled up the IRP. Complete it.
        //

        UlTrace(FILTER, (
            "http!UxpCopyToQueuedRead completing pIrp = %p, "
            "%Id bytes, type = %d\n",
            pIrp,
            pIrp->IoStatus.Information,
            BufferType
            ));


        ASSERT(BytesInIrp == 0);
        pIrp->IoStatus.Status = STATUS_SUCCESS;

        UlCompleteRequest(pIrp, IO_NETWORK_INCREMENT);
        pIrp = NULL;

        //
        // If it's stream data, keep looping until we've
        // copied all the data. Otherwise exit now.
        //

    } while ((BufferType == HttpFilterBufferHttpStream) &&
                (BytesCopied < Length));

end:
    ASSERT(pIrp == NULL);

    if (NT_SUCCESS(Status) || Status == STATUS_MORE_PROCESSING_REQUIRED)
    {
        *ppCurrentMdl = pMdlChain;
        *pMdlOffset = MdlOffset;
        *pBytesCopied = BytesCopied;
    }

    UlTrace(FILTER, (
        "http!UxpCopyToQueuedRead returning %x, BytesCopied = %lu\n"
        "        BufferType = %d, Length = %lu\n",
        Status,
        BytesCopied,
        BufferType,
        Length
        ));

    return Status;
} // UxpCopyToQueuedRead



/***************************************************************************++

Routine Description:

    Cleans up a write queue by dequeuing all the queued reads and writes
    and completing them.

    Must be called with the FilterConnLock held.

Arguments:

    pWriteQueue - the write queue to clean

--***************************************************************************/
VOID
UxpCancelAllQueuedIo(
    IN PUX_FILTER_WRITE_QUEUE pWriteQueue
    )
{
    PUX_FILTER_WRITE_TRACKER pTracker;
    PIRP pIrp;

    //
    // Sanity check.
    //
    ASSERT(pWriteQueue);

    while (NULL != (pTracker = UxpDequeueFilterWrite(pWriteQueue)))
    {
        UxpCompleteQueuedWrite(STATUS_CANCELLED, pWriteQueue, pTracker);
    }

    while (NULL != (pIrp = UxpDequeueFilterRead(pWriteQueue)))
    {
        pIrp->IoStatus.Status = STATUS_CANCELLED;
        pIrp->IoStatus.Information = 0;

        UlCompleteRequest(pIrp, IO_NO_INCREMENT);
    }
}


/***************************************************************************++

Routine Description:

    Allocates and initializes a UX_FILTER_WRITE_TRACKER.

Arguments:

    BufferType - the type of buffer represented by this write.

    pMdlChain   - chain of MDLs to be copied starting with the first MDL that
        has not been completely copied to a reader.

    MdlOffset   - an offset to the first byte in the current MDL that has not
        been copied to a reader.

    TotalBytes  - the total number of bytes in the MDL chain including those
        that have already been copied.

    BytesCopied - the total number of bytes copied so far.

    pCompletionRoutine - called when the write completes.

    pContext    - a context pointer used when the write completes.

Return values:

    Returns a pointer to the tracker or NULL if it can't be allocated.

--***************************************************************************/
PUX_FILTER_WRITE_TRACKER
UxpCreateFilterWriteTracker(
    IN HTTP_FILTER_BUFFER_TYPE BufferType,
    IN PMDL pMdlChain,
    IN ULONG MdlOffset,
    IN ULONG TotalBytes,
    IN ULONG BytesCopied,
    IN PUL_COMPLETION_ROUTINE pCompletionRoutine,
    IN PVOID pContext
    )
{
    PUX_FILTER_WRITE_TRACKER pTracker;

    //
    // Allocate the tracker memory.
    //

    pTracker = (PUX_FILTER_WRITE_TRACKER)
                    PplAllocate(g_FilterWriteTrackerLookaside);

    //
    // Initialize the tracker data.
    //

    if (pTracker)
    {
        pTracker->Signature = UX_FILTER_WRITE_TRACKER_POOL_TAG;

        pTracker->ListEntry.Flink = NULL;
        pTracker->ListEntry.Blink = NULL;

        pTracker->pConnection = NULL;
        pTracker->pWriteQueue = NULL;

        pTracker->BufferType = BufferType;

        pTracker->pMdl = pMdlChain;
        pTracker->Offset = MdlOffset;

        pTracker->Length = TotalBytes;
        pTracker->BytesCopied = BytesCopied;

        pTracker->pCompletionRoutine = pCompletionRoutine;
        pTracker->pCompletionContext = pContext;

        UlInitializeWorkItem( &pTracker->WorkItem );

    }

    return pTracker;
}


/***************************************************************************++

Routine Description:

    Frees a UX_FILTER_WRITE_TRACKER structure.

Arguments:

    pTracker - Supplies the buffer to free.

--***************************************************************************/
VOID
UxpDeleteFilterWriteTracker(
    IN PUX_FILTER_WRITE_TRACKER pTracker
    )
{
    //
    // Sanity check.
    //

    ASSERT(pTracker);
    ASSERT(pTracker->Signature == UX_FILTER_WRITE_TRACKER_POOL_TAG);
    ASSERT(pTracker->pConnection == NULL);
    ASSERT(pTracker->pWriteQueue == NULL);

    pTracker->Signature = MAKE_FREE_SIGNATURE(
                                UX_FILTER_WRITE_TRACKER_POOL_TAG
                                );

    PplFree(g_FilterWriteTrackerLookaside, pTracker);
}

/***************************************************************************++

Routine Description:

    Allocates the pool necessary for a new UX_FILTER_WRITE_TRACKER
    structure and initializes the structure.

Arguments:

    PoolType - Supplies the type of pool to allocate. This must always
        be NonPagedPool.

    ByteLength - Supplies the byte length for the allocation request.
        This should be sizeof(UX_FILTER_WRITE_TRACKER) but is basically
        ignored.

    Tag - Supplies the tag to use for the pool. This should be
        UX_FILTER_WRITE_TRACKER_POOL_TAG, but is basically ignored.

    Note: These parameters are required so that this function has a
        signature identical to ExAllocatePoolWithTag.

Return Value:

    PVOID - Pointer to the newly allocated block if successful, FALSE
        otherwise.

--***************************************************************************/
PVOID
UxpAllocateFilterWriteTrackerPool(
    IN POOL_TYPE PoolType,
    IN SIZE_T ByteLength,
    IN ULONG Tag
    )
{
    PUX_FILTER_WRITE_TRACKER pTracker;

    //
    // Sanity check.
    //

    UNREFERENCED_PARAMETER(PoolType);
    UNREFERENCED_PARAMETER(ByteLength);
    UNREFERENCED_PARAMETER(Tag);

    ASSERT( PoolType == NonPagedPool );
    ASSERT( ByteLength == sizeof(UX_FILTER_WRITE_TRACKER) );
    ASSERT( Tag == UX_FILTER_WRITE_TRACKER_POOL_TAG );

    //
    // Allocate the tracker buffer.
    //

    pTracker = (PUX_FILTER_WRITE_TRACKER)UL_ALLOCATE_POOL(
                                                NonPagedPool,
                                                sizeof(UX_FILTER_WRITE_TRACKER),
                                                UX_FILTER_WRITE_TRACKER_POOL_TAG
                                                );

    if (pTracker != NULL)
    {
        //
        // Initialize with the free signature to avoid confusing this
        // object with one that's actually in use.
        //

        pTracker->Signature =
            MAKE_FREE_SIGNATURE(UX_FILTER_WRITE_TRACKER_POOL_TAG);
    }

    return pTracker;
}


/***************************************************************************++

Routine Description:

    Frees the pool allocated for a UX_FILTER_WRITE_TRACKER structure.

Arguments:

    pBuffer - Supplies the buffer to free.

--***************************************************************************/
VOID
UxpFreeFilterWriteTrackerPool(
    IN PVOID pBuffer
    )
{
    PUX_FILTER_WRITE_TRACKER pTracker = (PUX_FILTER_WRITE_TRACKER)pBuffer;

    //
    // Sanity check
    //
    ASSERT(pTracker);
    ASSERT(pTracker->Signature ==
                MAKE_FREE_SIGNATURE(UX_FILTER_WRITE_TRACKER_POOL_TAG));


    UL_FREE_POOL(pTracker, UX_FILTER_WRITE_TRACKER_POOL_TAG);
}


/***************************************************************************++

Routine Description:

    Retrieves the client filter Channel

Arguments:

    None

--***************************************************************************/
PUL_FILTER_CHANNEL
UxRetrieveClientFilterChannel(
    IN PEPROCESS pProcess
    )
{
    KIRQL              oldIrql;
    PUL_FILTER_CHANNEL pFilterChannel;

    UlAcquireSpinLock(&g_pUlNonpagedData->FilterSpinLock, &oldIrql);

    pFilterChannel = UlpFindFilterChannel(
                         HTTP_SSL_CLIENT_FILTER_CHANNEL_NAME,
                         HTTP_SSL_CLIENT_FILTER_CHANNEL_NAME_LENGTH,
                         pProcess);

    if (pFilterChannel)
    {
        REFERENCE_FILTER_CHANNEL(pFilterChannel);
    }

    UlReleaseSpinLock(&g_pUlNonpagedData->FilterSpinLock, oldIrql);

    return pFilterChannel;
}

/***************************************************************************++

Routine Description:

    Queries the filter channel information. Gives the caller a reference
    if the channel exists and the caller is supposed to be filtered.
    Secure (SSL) connections are always filtered. If g_FilterOnlySsl is
    FALSE then everything gets filtered.

Arguments:
    SecureConnection - tells us if the caller is on a secure endpoint.

Return values:

    A reference to the filter channel if the connection is filtered.
    NULL if it is not.


--***************************************************************************/
PUL_FILTER_CHANNEL
UxRetrieveServerFilterChannel(
    IN BOOLEAN SecureConnection
    )
{
    KIRQL              oldIrql;
    PUL_FILTER_CHANNEL pChannel;

    UlAcquireSpinLock(&g_pUlNonpagedData->FilterSpinLock, &oldIrql);

    if (g_pSslServerFilterChannel && (SecureConnection || !g_FilterOnlySsl))
    {
        REFERENCE_FILTER_CHANNEL(g_pSslServerFilterChannel);
        pChannel = g_pSslServerFilterChannel;
    }
    else
    {
        pChannel = NULL;
    }

    UlReleaseSpinLock(&g_pUlNonpagedData->FilterSpinLock, oldIrql);

    UlTrace(FILTER, (
        "http!UlQueryFilterChannel(secure = %s) returning %p\n",
        SecureConnection ? "TRUE" : "FALSE",
        pChannel
        ));

    return pChannel;
}

/***************************************************************************++

Routine Description:

    Sets the global flag that controls RAW ISAPI filtering.

Arguments:

    bFilterOnlySSL - TRUE  (enable only SSL filtering)
                   - FALSE (enable RAW ISAPI filtering)

Return values:

    None.

--***************************************************************************/
VOID
UxSetFilterOnlySsl(
    BOOLEAN bFilterOnlySsl
    )
{
    KIRQL oldIrql;

    UlAcquireSpinLock(&g_pUlNonpagedData->FilterSpinLock, &oldIrql);

    g_FilterOnlySsl = bFilterOnlySsl;

    UlReleaseSpinLock(&g_pUlNonpagedData->FilterSpinLock, oldIrql);
}


/***************************************************************************++

Routine Description:

    Checks to see if the callers filter channel matches the filter
    channel that would be returned by UlQueryFilterChannel.

    Note, this function intentionally does not acquire the config
    group read lock, because it doesn't really matter if we get
    a consistent view of the channel settings.

Arguments:

    pChannel - the callers current filter channel setting

    SecureConnection - tells us if the caller is on a secure endpoint.

Return values:

    Returns TRUE if the filter channel settings are up to date.

--***************************************************************************/
BOOLEAN
UlValidateFilterChannel(
    IN PUL_FILTER_CHANNEL pChannel,
    IN BOOLEAN SecureConnection
    )
{
    KIRQL oldIrql;
    BOOLEAN UpToDate;
    extern PUL_FILTER_CHANNEL   g_pFilterChannel;
    extern BOOLEAN              g_FilterOnlySsl;

    UlAcquireSpinLock(&g_pUlNonpagedData->FilterSpinLock, &oldIrql);

    //
    // Sanity check.
    //

    ASSERT(!pChannel || IS_VALID_FILTER_CHANNEL(pChannel));

    if (g_pSslServerFilterChannel && (SecureConnection || !g_FilterOnlySsl))
    {
        //
        // The connection should be filtered, so its channel
        // should match g_pFilterChannel.
        //

        UpToDate = (BOOLEAN)(pChannel == g_pSslServerFilterChannel);
    }
    else
    {
        //
        // The connection is not filtered, so its channel
        // should be NULL.
        //

        UpToDate = (BOOLEAN)(pChannel == NULL);
    }

    UlReleaseSpinLock(&g_pUlNonpagedData->FilterSpinLock, oldIrql);

    return UpToDate;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\hashfn.h ===
/*++

   Copyright    (c)    1998-2002    Microsoft Corporation

   Module  Name :
       hashfn.h

   Abstract:
       Declares and defines a collection of overloaded hash functions.
       It is strongly suggested that you use these functions with LKRhash.

   Author:
       George V. Reilly      (GeorgeRe)     06-Jan-1998

   Environment:
       Win32 - User Mode

   Project:
       Internet Information Server RunTime Library

   Revision History:

        Paul McDaniel (paulmcd)     Feb-05-1999     Trimmed for kernel mode
                                                    and C (not C++)

--*/

#ifndef __HASHFN_H__
#define __HASHFN_H__

#include <math.h>
#include <limits.h>

extern  WCHAR   FastUpcaseChars[256];

#define UPCASE_UNICODE_CHAR( wc )    \
    (wc < 256 ? FastUpcaseChars[(UCHAR)(wc)] : RtlUpcaseUnicodeChar(wc))


// Produce a scrambled, randomish number in the range 0 to RANDOM_PRIME-1.
// Applying this to the results of the other hash functions is likely to
// produce a much better distribution, especially for the identity hash
// functions such as Hash(char c), where records will tend to cluster at
// the low end of the hashtable otherwise.  LKRhash applies this internally
// to all hash signatures for exactly this reason.

// __inline ULONG
// HashScramble(ULONG dwHash)
// {
//     // Here are 10 primes slightly greater than 10^9
//     //  1000000007, 1000000009, 1000000021, 1000000033, 1000000087,
//     //  1000000093, 1000000097, 1000000103, 1000000123, 1000000181.
//
//     // default value for "scrambling constant"
//     const ULONG RANDOM_CONSTANT = 314159269UL;
//     // large prime number, also used for scrambling
//     const ULONG RANDOM_PRIME =   1000000007UL;
//
//     return (RANDOM_CONSTANT * dwHash) % RANDOM_PRIME ;
// }
//
// Given M = A % B, A and B unsigned 32-bit integers greater than zero,
// there are no values of A or B which yield M = 2^32-1.  Why?  Because
// M must be less than B.
// #define HASH_INVALID_SIGNATURE ULONG_MAX


// No number in 0..2^31-1 maps to this number after it has been
// scrambled by HashRandomizeBits
#define HASH_INVALID_SIGNATURE 31678523

// Faster scrambling function suggested by Eric Jacobsen

__inline ULONG
HashRandomizeBits(ULONG dw)
{
    const ULONG dwLo = ((dw * 1103515245 + 12345) >> 16);
    const ULONG dwHi = ((dw * 69069 + 1) & 0xffff0000);
    const ULONG dw2  = dwHi | dwLo;

    ASSERT(dw2 != HASH_INVALID_SIGNATURE);

    return dw2;
}

// Small prime number used as a multiplier in the supplied hash functions
#define HASH_MULTIPLIER 101

#undef HASH_SHIFT_MULTIPLY

#ifdef HASH_SHIFT_MULTIPLY
// 127 = 2^7 - 1 is prime
# define HASH_MULTIPLY(dw)   (((dw) << 7) - (dw))
#else
# define HASH_MULTIPLY(dw)   ((dw) * HASH_MULTIPLIER)
#endif


// Fast, simple hash function that tends to give a good distribution.
// Apply HashScramble to the result if you're using this for something
// other than LKHash.

__inline ULONG
HashStringA(
    const char* psz,
    ULONG       dwHash)
{
    // force compiler to use unsigned arithmetic
    const unsigned char* upsz = (const unsigned char*) psz;

    for (  ;  *upsz != '\0';  ++upsz)
        dwHash = HASH_MULTIPLY(dwHash)  +  *upsz;

    return dwHash;
}


// Unicode version of above

__inline ULONG
HashStringW(
    const wchar_t* pwsz,
    ULONG          dwHash)
{
    for (  ;  *pwsz != L'\0';  ++pwsz)
        dwHash = HASH_MULTIPLY(dwHash)  +  *pwsz;

    return dwHash;
}

__inline ULONG
HashCharW(
    WCHAR UnicodeChar,
    ULONG Hash
    )
{
    return HASH_MULTIPLY(Hash)  +  UnicodeChar;
}


// Quick-'n'-dirty case-insensitive string hash function.
// Make sure that you follow up with _stricmp or _mbsicmp.  You should
// also cache the length of strings and check those first.  Caching
// an uppercase version of a string can help too.
// Again, apply HashScramble to the result if using with something other
// than LKHash.
// Note: this is not really adequate for MBCS strings.

__inline ULONG
HashStringNoCaseA(
    const char* psz,
    ULONG       dwHash)
{
    const unsigned char* upsz = (const unsigned char*) psz;

    for (  ;  *upsz != '\0';  ++upsz)
        dwHash = HASH_MULTIPLY(dwHash)
                     +  (*upsz & 0xDF);  // strip off lowercase bit

    return dwHash;
}


// Unicode version of above

__inline ULONG
HashStringNoCaseW(
    const wchar_t* pwsz,
    ULONG          dwHash)
{
    for (  ;  *pwsz != L'\0';  ++pwsz)
        dwHash = HASH_MULTIPLY(dwHash)  +  UPCASE_UNICODE_CHAR(*pwsz);

    return dwHash;
}

__inline ULONG
HashStringsNoCaseW(
    const wchar_t* pwsz1,
    const wchar_t* pwsz2,
    ULONG          dwHash)
{
    for (  ;  *pwsz1 != L'\0';  ++pwsz1)
        dwHash = HASH_MULTIPLY(dwHash)  +  UPCASE_UNICODE_CHAR(*pwsz1);

    for (  ;  *pwsz2 != L'\0';  ++pwsz2)
        dwHash = HASH_MULTIPLY(dwHash)  +  UPCASE_UNICODE_CHAR(*pwsz2);

    return dwHash;
}


__inline ULONG
HashCharNoCaseW(
    WCHAR UnicodeChar,
    ULONG Hash
    )
{
    return HASH_MULTIPLY(Hash)  +  UPCASE_UNICODE_CHAR(UnicodeChar);
}


// HashBlob returns the hash of a blob of arbitrary binary data.
//
// Warning: HashBlob is generally not the right way to hash a class object.
// Consider:
//     class CFoo {
//     public:
//         char   m_ch;
//         double m_d;
//         char*  m_psz;
//     };
//
//     inline ULONG Hash(const CFoo& rFoo)
//     { return HashBlob(&rFoo, sizeof(CFoo)); }
//
// This is the wrong way to hash a CFoo for two reasons: (a) there will be
// a 7-byte gap between m_ch and m_d imposed by the alignment restrictions
// of doubles, which will be filled with random data (usually non-zero for
// stack variables), and (b) it hashes the address (rather than the
// contents) of the string m_psz.  Similarly,
//
//     bool operator==(const CFoo& rFoo1, const CFoo& rFoo2)
//     { return memcmp(&rFoo1, &rFoo2, sizeof(CFoo)) == 0; }
//
// does the wrong thing.  Much better to do this:
//
//     ULONG Hash(const CFoo& rFoo)
//     {
//         return HashString(rFoo.m_psz,
//                           37 * Hash(rFoo.m_ch)  +  Hash(rFoo.m_d));
//     }
//
// Again, apply HashScramble if using with something other than LKHash.

__inline ULONG
HashBlob(
    PUCHAR      pb,
    ULONG       cb,
    ULONG       dwHash)
{
    while (cb-- > 0)
        dwHash = HASH_MULTIPLY(dwHash)  +  *pb++;

    return dwHash;
}


// ======= <snip>
//
//  paulmcd: a bunch snipped due to use of overloading, not allowed in C
//
// ======= <snip>

__inline ULONG HashDouble(double dbl)
{
    int nExponent;
    double dblMantissa;
    if (dbl == 0.0)
        return 0;
    dblMantissa = frexp(dbl, &nExponent);
    // 0.5 <= |mantissa| < 1.0
    return (ULONG) ((2.0 * fabs(dblMantissa)  -  1.0)  *  UINT_MAX);
}

__inline ULONG HashFloat(float f)
{ return HashDouble((double) f); }

#endif // __HASHFN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\hashp.h ===
/*++

Copyright (c) 1998-2002 Microsoft Corporation

Module Name:

    hashp.h

Abstract:

    The private definition of response cache hash table.

Author:

    Alex Chen (alexch)      28-Mar-2001

Revision History:

--*/


#ifndef _HASHP_H_
#define _HASHP_H_

#include "hash.h"


// Global Variables

extern ULONG    g_UlHashTableBits;
extern ULONG    g_UlHashTableSize;
extern ULONG    g_UlHashTableMask;
extern ULONG    g_UlHashIndexShift;

extern ULONG    g_UlNumOfHashUriKeys;

// If we're using PagedPool for the hashtable, we must not access the
// hashtable at dispatch level.

#define HASH_PAGED_CODE(pHashTable)                 \
    do {                                            \
        if ((pHashTable)->PoolType == PagedPool) {  \
            PAGED_CODE();                           \
        }                                           \
    } while (0)


// Set some parameters to small values to ensure the single list code
// gets exercised

#undef HASH_TEST


// Turn HASH_FULL_ASSERTS on if you make any changes to hashtable internal
// data structures to get rigorous-but-time-consuming assertions

#undef HASH_FULL_ASSERTS


//
// Hash Table Bucket Stored UriKey definitions
//

#define INVALID_SLOT_INDEX     ((LONG) (-1))

typedef struct _HASH_URIKEY
{
    PUL_URI_CACHE_ENTRY     pUriCacheEntry;

    ULONG                   Hash;  // Hash signature

} HASHURIKEY, *PHASHURIKEY;


//
// Hash Table Bucket definitions
//

typedef struct _HASH_BUCKET
{
    RWSPINLOCK              RWSpinLock;

    PUL_URI_CACHE_ENTRY     pUriCacheEntry;

    ULONG_PTR               Entries;    // force alignment

    // followed immediately by HASHURIKEY HashUriKey[g_UlNumOfHashUriKeys];

} HASHBUCKET, *PHASHBUCKET;


/***************************************************************************++

Routine Description:

    Get the indexed bucket

Return Value:

--***************************************************************************/
__inline
PHASHBUCKET
UlpHashTableIndexedBucket(
    IN PHASHTABLE  pHashTable,
    IN ULONG       Index
    )
{
    PHASHBUCKET pBucket;

    ASSERT(Index < g_UlHashTableSize);
    ASSERT(NULL != pHashTable->pBuckets);

    pBucket = (PHASHBUCKET) (((PBYTE) pHashTable->pBuckets)
                                + (Index << g_UlHashIndexShift));

    ASSERT((PBYTE) pBucket
                < (PBYTE) pHashTable->pBuckets + pHashTable->NumberOfBytes);

    return pBucket;
} // UlpHashTableIndexedBucket


/***************************************************************************++

Routine Description:

    Retrieve the bucket associated with a URI_KEY hash

Return Value:

--***************************************************************************/
__inline
PHASHBUCKET
UlpHashTableBucketFromUriKeyHash(
    IN PHASHTABLE  pHashTable,
    IN ULONG       UriKeyHash
    )
{
    ASSERT(HASH_INVALID_SIGNATURE != UriKeyHash);

    return UlpHashTableIndexedBucket(
                pHashTable,
                UriKeyHash & g_UlHashTableMask
                );
    
} // UlpHashTableBucketFromUriKeyHash



/***************************************************************************++

Routine Description:

    Get the address of the inline array of HASHURIKEYs at the end of
    the HASHBUCKET

Return Value:

--***************************************************************************/
__inline
PHASHURIKEY
UlpHashTableUriKeyFromBucket(
    IN PHASHBUCKET pBucket
    )
{
    return (PHASHURIKEY) ((PBYTE) pBucket + sizeof(HASHBUCKET));
}


/***************************************************************************++

Routine Description:

    Compare two URI_KEYS that have identical hashes to see if the
    URIs also match (case-insensitively).
    (Hashes must have been computed with HashStringNoCaseW or
    HashCharNoCaseW.)

Return Value:

--***************************************************************************/
__inline
BOOLEAN
UlpEqualUriKeys(
    IN PURI_KEY pUriKey1,
    IN PURI_KEY pUriKey2
    )
{
    ASSERT(pUriKey1->Hash == pUriKey2->Hash);

    if (pUriKey1->Length == pUriKey2->Length
            &&  UlEqualUnicodeString(
                        pUriKey1->pUri,
                        pUriKey2->pUri,
                        pUriKey1->Length,
                        TRUE
                        ))
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

/***************************************************************************++

Routine Description:

    Compare an EXTENDED_URI_KEY against a URI_KEY that have identical hashes 
    to see if the URIs also match (case-insensitively).
    
    (Hashes must have been computed with HashStringNoCaseW or
    HashCharNoCaseW.)

--***************************************************************************/
__inline
BOOLEAN
UlpEqualUriKeysEx(
    IN PEX_URI_KEY pExtKey,
    IN PURI_KEY    pUriKey
    )
{
    ASSERT(pExtKey->Hash == pUriKey->Hash);

    if ((pExtKey->TokenLength + pExtKey->AbsPathLength) 
                    == pUriKey->Length
            &&  UlEqualUnicodeStringEx(
                        pExtKey->pToken,        // Routing token
                        pExtKey->TokenLength,   // Routing token length   
                        pExtKey->pAbsPath,      // AbsPath
                        pExtKey->AbsPathLength,// AbsPath length
                        pUriKey->pUri,          // Fully qualified url (in cache)
                        TRUE                    // Case sensitive comparison
                        ))
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

VOID
UlpGetHashTableSize(
    IN LONG     HashTableBits
    );

BOOLEAN
UlpHashBucketIsCompact(
    IN const PHASHBUCKET pBucket);

BOOLEAN
UlpFilterFlushHashBucket(
    IN PHASHBUCKET          pBucket,
    IN PUL_URI_FILTER       pFilterRoutine,
    IN PVOID                pContext,
    OUT PULONG              pDeletedCount
    );

VOID
UlpClearHashBucket(
    IN PHASHBUCKET          pBucket
    );


#endif // _HASHP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\httpconn.c ===
/*++

Copyright (c) 1998-2002 Microsoft Corporation

Module Name:

    httpconn.c

Abstract:

    This module implements the HTTP_CONNECTION object.

Author:

    Keith Moore (keithmo)       08-Jul-1998

Revision History:

--*/


#include "precomp.h"
#include "httpconnp.h"


//
// Private globals.
//

BOOLEAN g_HttpconnInitialized = FALSE;

UL_ZOMBIE_HTTP_CONNECTION_LIST  g_ZombieConnectionList;

//
// Global connection Limits stuff
//

ULONG   g_MaxConnections        = HTTP_LIMIT_INFINITE;
ULONG   g_CurrentConnections    = 0;
BOOLEAN g_InitGlobalConnections = FALSE;

#ifdef ALLOC_PRAGMA

#pragma alloc_text(INIT, UlInitializeHttpConnection)

#endif  // ALLOC_PRAGMA

#if 0
NOT PAGEABLE -- UlBindConnectionToProcess
NOT PAGEABLE -- UlQueryProcessBinding
NOT PAGEABLE -- UlpCreateProcBinding
NOT PAGEABLE -- UlpFreeProcBinding
NOT PAGEABLE -- UlpFindProcBinding

NOT PAGEABLE -- UlCreateHttpConnection
NOT PAGEABLE -- UlReferenceHttpConnection
NOT PAGEABLE -- UlDereferenceHttpConnection

NOT PAGEABLE -- UlReferenceHttpRequest
NOT PAGEABLE -- UlDereferenceHttpRequest
NOT PAGEABLE -- UlpCreateHttpRequest
NOT PAGEABLE -- UlpFreeHttpRequest

NOT PAGEABLE -- UlTerminateHttpConnection
NOT PAGEABLE -- UlPurgeZombieConnections
NOT PAGEABLE -- UlpZombifyHttpConnection
NOT PAGEABLE -- UlZombieTimerDpcRoutine
NOT PAGEABLE -- UlpZombieTimerWorker
NOT PAGEABLE -- UlpTerminateZombieList
NOT PAGEABLE -- UlLogZombieConnection

NOT PAGEABLE -- UlDisconnectHttpConnection

#endif

//
// Public functions.
//

/***************************************************************************++

Routine Description:

    Performs global initialization of this module.

--***************************************************************************/

NTSTATUS
UlInitializeHttpConnection(
    VOID
    )
{
    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(!g_HttpconnInitialized);

    if (g_HttpconnInitialized)
    {
        return STATUS_SUCCESS;
    }
    
    //
    // Initialize global data.
    //

    UlInitalizeLockedList(
        &g_ZombieConnectionList.LockList,
         "ZombieHttpConnectionList"
         );

    g_ZombieConnectionList.TimerRunning = 0;

#ifdef ENABLE_HTTP_CONN_STATS    
    g_ZombieConnectionList.TotalCount = 0;
    g_ZombieConnectionList.TotalZombieCount = 0;
    g_ZombieConnectionList.TotalZombieRefusal = 0;
    g_ZombieConnectionList.MaxZombieCount = 0;    
#endif

    //
    // Zombie Timer stuff
    //
    
    g_ZombieConnectionList.TimerInitialized = TRUE;

    UlInitializeSpinLock( 
        &g_ZombieConnectionList.TimerSpinLock, 
        "HttpZombieConnectionTimerSpinLock" 
        );    
    
    KeInitializeDpc(
        &g_ZombieConnectionList.DpcObject, // DPC object
        &UlZombieTimerDpcRoutine,           // DPC routine
        NULL                                   // context
        );

    UlInitializeWorkItem(&g_ZombieConnectionList.WorkItem);
    
    KeInitializeTimer(&g_ZombieConnectionList.Timer);

    UlpSetZombieTimer();

    //
    // Everything is initialized.
    //
    
    g_HttpconnInitialized = TRUE;

    return STATUS_SUCCESS;

}

/***************************************************************************++

Routine Description:

    Performs global termination of this module.

--***************************************************************************/

VOID
UlTerminateHttpConnection(
    VOID
    )
{
    KIRQL OldIrql;
    
    //
    // Sanity check.
    //

    if (g_HttpconnInitialized)
    {
        // Zombie timer 

        UlAcquireSpinLock(&g_ZombieConnectionList.TimerSpinLock, &OldIrql);

        g_ZombieConnectionList.TimerInitialized = FALSE;

        KeCancelTimer(&g_ZombieConnectionList.Timer);
        
        UlReleaseSpinLock(&g_ZombieConnectionList.TimerSpinLock, OldIrql);
    
        UlpTerminateZombieList();
        
#ifdef ENABLE_HTTP_CONN_STATS    
        UlTrace(HTTP_IO,
                ("UlTerminateHttpConnection, Stats:\n"
                 "\tTotalConnections        = %lu\n"
                 "\tMaxZombieCount          = %lu\n"
                 "\tTotalDisconnectedCount  = %lu\n"
                 "\tTotalRefusedCount       =%lu\n",
                 g_ZombieConnectionList.TotalCount,
                 g_ZombieConnectionList.MaxZombieCount,
                 g_ZombieConnectionList.TotalZombieCount,
                 g_ZombieConnectionList.TotalZombieRefusal
                 ));
#endif

        UlDestroyLockedList(&g_ZombieConnectionList.LockList);
         
        g_HttpconnInitialized = FALSE;
    }
} 

/***************************************************************************++

Routine Description:

    Creates a new HTTP_CONNECTION object.

Arguments:

    ppHttpConnection - Receives a pointer to the new HTTP_CONNECTION
        object if successful.

    pConnection - Supplies a pointer to the UL_CONNECTION to associate
        with the newly created HTTP_CONNECTION.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlCreateHttpConnection(
    OUT PUL_HTTP_CONNECTION *ppHttpConnection,
    IN PUL_CONNECTION pConnection
    )
{
    PUL_HTTP_CONNECTION pHttpConn;

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    pHttpConn = &pConnection->HttpConnection;
    RtlZeroMemory(pHttpConn, sizeof(*pHttpConn));

    REFERENCE_CONNECTION(pConnection);

    pHttpConn->Signature        = UL_HTTP_CONNECTION_POOL_TAG;
    pHttpConn->RefCount         = 1;
    pHttpConn->pConnection      = pConnection;
    pHttpConn->SecureConnection = pConnection->FilterInfo.SecureConnection;

    UlInitializeWorkItem(&pHttpConn->WorkItem);
    UlInitializeWorkItem(&pHttpConn->DisconnectWorkItem);
    UlInitializeWorkItem(&pHttpConn->DisconnectDrainWorkItem);
    UlInitializeWorkItem(&pHttpConn->ReceiveBufferWorkItem);

    UlInitializeExclusiveLock(&pHttpConn->ExLock);

    //
    // Initialize the disconnect management fields.
    //

    UlInitializeNotifyHead(&pHttpConn->WaitForDisconnectHead, NULL);

    //
    // Init our buffer list
    //

    InitializeListHead(&pHttpConn->BufferHead);

    //
    // Init pending receive buffer list
    //

    InitializeSListHead(&pHttpConn->ReceiveBufferSList);

    //
    // init app pool process binding list
    //

    InitializeListHead(&(pHttpConn->BindingHead));

    UlInitializePushLock(
        &(pHttpConn->PushLock),
        "UL_HTTP_CONNECTION[%p].PushLock",
        pHttpConn,
        UL_HTTP_CONNECTION_PUSHLOCK_TAG
        );

    //
    // Initialize BufferingInfo structure.
    //

    UlInitializeSpinLock(
        &pHttpConn->BufferingInfo.BufferingSpinLock,
        "BufferingSpinLock"
        );

    UlInitializeSpinLock(
        &pHttpConn->RequestIdSpinLock,
        "RequestIdSpinLock"
        );

    UlTrace(
        REFCOUNT, (
            "http!UlCreateHttpConnection conn=%p refcount=%d\n",
            pHttpConn,
            pHttpConn->RefCount)
        );

    *ppHttpConnection = pHttpConn;
    RETURN(STATUS_SUCCESS);

}   // UlCreateHttpConnection



NTSTATUS
UlCreateHttpConnectionId(
    IN PUL_HTTP_CONNECTION pHttpConnection
    )
{
    NTSTATUS Status;

    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // Create an opaque id for the connection
    //

    Status = UlAllocateOpaqueId(
                    &pHttpConnection->ConnectionId, // pOpaqueId
                    UlOpaqueIdTypeHttpConnection,   // OpaqueIdType
                    pHttpConnection                 // pContext
                    );

    if (NT_SUCCESS(Status))
    {
        UL_REFERENCE_HTTP_CONNECTION(pHttpConnection);

        TRACE_TIME(
            pHttpConnection->ConnectionId,
            0,
            TIME_ACTION_CREATE_CONNECTION
            );
    }

    RETURN(Status);

}   // UlCreateHttpConnectionId



/***************************************************************************++

Routine Description:

    In normal case it cleans up the connection and unlink the request.
    (if there is one). But if the last sendresponse hasn't been received on 
    the connection yet, it moves the connection to the zombie list w/o 
    releasing it's refcount.

Arguments:

    pWorkItem - workitem to get the http connection
    
--***************************************************************************/

VOID
UlConnectionDestroyedWorker(
    IN PUL_WORK_ITEM pWorkItem
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PUL_HTTP_CONNECTION pHttpConnection;
    BOOLEAN ZombieConnection = FALSE;
    PUL_INTERNAL_REQUEST pRequest;

    //
    // Sanity check.
    //

    PAGED_CODE();

    pHttpConnection = CONTAINING_RECORD(
                            pWorkItem,
                            UL_HTTP_CONNECTION,
                            WorkItem
                            );

    ASSERT(UL_IS_VALID_HTTP_CONNECTION(pHttpConnection));

    UlTrace(HTTP_IO, (
        "Http!UlConnectionDestroyedWorker: httpconn=%p\n",
        pHttpConnection
        ));

#ifdef ENABLE_HTTP_CONN_STATS
    InterlockedIncrement(
        (PLONG) &g_ZombieConnectionList.TotalCount);
#endif

    //
    // Don't let connection go away while we are working. If it becomes
    // zombie it may get destroyed as soon as we put it on the zombie
    // list and release the connection eresource.
    //
    
    UL_REFERENCE_HTTP_CONNECTION(pHttpConnection);
    
    UlAcquirePushLockExclusive(&pHttpConnection->PushLock);

    pRequest = pHttpConnection->pRequest;
    
    //
    // Kill the request if there is one. But only if we have done with 
    // the logging, otherwise we will keep it in the zombie list until last
    // the last sendresponse with logging data arrives or the request 
    // itself get scavenged out from the zombie list later.
    //

    if (pRequest) 
    {
        ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pRequest));

        //
        // Only if the last send did not happened yet.
        //

        if (0 == InterlockedCompareExchange(
                    (PLONG) &pRequest->ZombieCheck,
                    1,
                    0
                    ))
        {        
            //
            // Only if request got routed up to the worker process 
            // and logging enabled but not happened.
            //
            
            if (pRequest->ConfigInfo.pLoggingConfig != NULL &&
                UlCheckAppPoolState(pRequest))
            {
                ZombieConnection = TRUE;
            }
        }
        
        if (ZombieConnection)
        {
            ASSERT(pHttpConnection->Zombified == FALSE);
            ASSERT(pHttpConnection->pRequestIdContext != NULL);
            
            Status = UlpZombifyHttpConnection(pHttpConnection);
            if (!NT_SUCCESS(Status))
            {
                //
                // We didn't make it to the zombie list. The list
                // is probably full. Lets destroy this connection
                // completely.
                //

                ZombieConnection = FALSE;           
            }
        }

        if (!ZombieConnection)
        {
            //
            // If we got far enough to deliver the request then unlink it
            // from the app pool.  This needs to happen here because the
            // queue'd IRPs keep references to the UL_INTERNAL_REQUEST
            // objects.  This kicks their references off and allows them
            // to delete.
            //

            if (pRequest->ConfigInfo.pAppPool)
            {
                UlUnlinkRequestFromProcess(
                    pRequest->ConfigInfo.pAppPool,
                    pRequest
                    );
            }

            UlUnlinkHttpRequest(pRequest);

            //
            // If connection didn't go to the zombie list then
            // null out our request pointer since our refcount
            // has gone already.
            //

            pHttpConnection->pRequest = NULL;
        }        
        
    }

    //
    // Make sure no one adds a new request now that we're done
    //
    
    pHttpConnection->UlconnDestroyed = 1;
    
    if (!ZombieConnection)
    {
        //
        // If we don't need to keep the connection around
        // then remove its opaque id.
        //
        
        if (!HTTP_IS_NULL_ID(&pHttpConnection->ConnectionId))
        {
            UlFreeOpaqueId(
                pHttpConnection->ConnectionId,
                UlOpaqueIdTypeHttpConnection
                );

            HTTP_SET_NULL_ID(&pHttpConnection->ConnectionId);

            UL_DEREFERENCE_HTTP_CONNECTION(pHttpConnection);
        }        
    }    

    //
    // Complete all WaitForDisconnect IRPs
    //
    // Prevent new IRPs from getting attached to the connection,
    // by setting the DisconnectFlag.
    //

    ASSERT(!pHttpConnection->DisconnectFlag);
    pHttpConnection->DisconnectFlag = 1;

    if (pHttpConnection->WaitForDisconnectFlag)
    {
        UlCompleteAllWaitForDisconnect(pHttpConnection);
    }

    UlReleasePushLockExclusive(&pHttpConnection->PushLock);

    //
    // Release the temporary refcount.
    //
    
    UL_DEREFERENCE_HTTP_CONNECTION(pHttpConnection);

    //
    // Only remove the ULTDI reference from the HTTP_CONNECTION,
    // if connection didn't make it to the zombie list. Otherwise
    // the actual cleanup will happen later. Zombie list takes the
    // ownership of the TDI's original refcount now.
    //

    if (!ZombieConnection)
    {
        UL_DEREFERENCE_HTTP_CONNECTION(pHttpConnection);
    }

}   // UlConnectionDestroyedWorker


/***************************************************************************++

Routine Description:

    Tries to establish a binding between a connection and an app pool
    process. You can query these bindings with UlQueryProcessBinding.

Arguments:

    pHttpConnection - the connection to bind
    pAppPool        - the app pool that owns the process (key for lookups)
    pProcess        - the process to bind to

--***************************************************************************/
NTSTATUS
UlBindConnectionToProcess(
    IN PUL_HTTP_CONNECTION pHttpConnection,
    IN PUL_APP_POOL_OBJECT pAppPool,
    IN PUL_APP_POOL_PROCESS pProcess
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PUL_APOOL_PROC_BINDING pBinding = NULL;

    //
    // Sanity check
    //
    ASSERT( UL_IS_VALID_HTTP_CONNECTION( pHttpConnection ) );
    ASSERT( pAppPool->NumberActiveProcesses > 1 || pProcess == NULL );
    ASSERT( UlDbgSpinLockOwned( &pAppPool->SpinLock ) );

    //
    // see if there's already a binding object
    //
    pBinding = UlpFindProcBinding(pHttpConnection, pAppPool);
    if (pBinding) {
        if (pProcess) {
            //
            // modify the binding
            //
            pBinding->pProcess = pProcess;
        } else {
            //
            // we're supposed to kill this binding
            //
            RemoveEntryList(&pBinding->BindingEntry);
            UlpFreeProcBinding(pBinding);
        }
    } else {
        if (pProcess) {
            //
            // create a new entry
            //
            pBinding = UlpCreateProcBinding(pAppPool, pProcess);

            if (pBinding) {
                InsertHeadList(
                    &pHttpConnection->BindingHead,
                    &pBinding->BindingEntry
                    );
            } else {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
    }

    UlTrace(ROUTING, (
        "http!UlBindConnectionToProcess(\n"
        "        pHttpConnection = %p (%I64x)\n"
        "        pAppPool        = %p\n"
        "        pProcess        = %p )\n"
        "    Status = 0x%x\n",
        pHttpConnection,
        pHttpConnection->ConnectionId,
        pAppPool,
        pProcess,
        Status
        ));

    return Status;
}


/***************************************************************************++

Routine Description:

    Removes an HTTP request from all lists and cleans up it's opaque id.

Arguments:

    pRequest - the request to be unlinked

--***************************************************************************/
VOID
UlCleanupHttpConnection(
    IN PUL_HTTP_CONNECTION pHttpConnection
    )
{
    PLIST_ENTRY pEntry;
    PUL_INTERNAL_REQUEST pRequest;

    ASSERT( UL_IS_VALID_INTERNAL_REQUEST( pHttpConnection->pRequest ) );
    ASSERT( pHttpConnection->WaitingForResponse );
    ASSERT( UlDbgPushLockOwnedExclusive( &pHttpConnection->PushLock ) );

    pRequest = pHttpConnection->pRequest;

    if (pRequest->ContentLength > 0 || 1 == pRequest->Chunked)
    {
        //
        // Unlink the request from the process for POST.  The time to
        // unlink a GET request is when the last send completes.
        // However, similar logic can't be applied to POST because
        // we may still have to drain the entity body so we are not
        // fully done with the request on send completion.  So the
        // arrangement for POST is to 1) defer resuming parsing until send
        // completion, and 2) unlink the request from process when we
        // have drained the whole entity body unless server has issued
        // the disconnect.
        //

        if (pRequest->ConfigInfo.pAppPool)
        {
            UlUnlinkRequestFromProcess(
                pRequest->ConfigInfo.pAppPool,
                pRequest
                );
        }
    }

    UlUnlinkHttpRequest(pRequest);

    pHttpConnection->pRequest = NULL;
    pHttpConnection->WaitingForResponse = 0;

    UlTrace( PARSER, (
        "***1 pConnection %p->WaitingForResponse = 0\n",
        pHttpConnection
        ));

    //
    // Free the old request's buffers
    //

    ASSERT( UL_IS_VALID_REQUEST_BUFFER( pHttpConnection->pCurrentBuffer ) );

    pEntry = pHttpConnection->BufferHead.Flink;
    while (pEntry != &pHttpConnection->BufferHead)
    {
        PUL_REQUEST_BUFFER pBuffer;

        //
        // Get the object
        //

        pBuffer = CONTAINING_RECORD(
                        pEntry,
                        UL_REQUEST_BUFFER,
                        ListEntry
                        );

        //
        // did we reach the end?
        //

        if (pBuffer == pHttpConnection->pCurrentBuffer) {
            break;
        }

        //
        // remember the next one
        //

        pEntry = pEntry->Flink;

        //
        // unlink it
        //

        UlFreeRequestBuffer(pBuffer);
    }
} // UlCleanupHttpConnection


VOID
UlReferenceHttpConnection(
    IN PVOID pObject
    REFERENCE_DEBUG_FORMAL_PARAMS
    )
{
    LONG refCount;

    PUL_HTTP_CONNECTION pHttpConnection = (PUL_HTTP_CONNECTION) pObject;

    refCount = InterlockedIncrement( &pHttpConnection->RefCount );

    WRITE_REF_TRACE_LOG2(
        g_pHttpConnectionTraceLog,
        pHttpConnection->pConnection->pHttpTraceLog,
        REF_ACTION_REFERENCE_HTTP_CONNECTION,
        refCount,
        pHttpConnection,
        pFileName,
        LineNumber
        );

    UlTrace(
        REFCOUNT, (
            "http!UlReferenceHttpConnection conn=%p refcount=%d\n",
            pHttpConnection,
            refCount)
        );

}   // UlReferenceHttpConnection


VOID
UlDereferenceHttpConnection(
    IN PUL_HTTP_CONNECTION pHttpConnection
    REFERENCE_DEBUG_FORMAL_PARAMS
    )
{
    LONG refCount;

    ASSERT( pHttpConnection );
    ASSERT( pHttpConnection->RefCount > 0 );

    WRITE_REF_TRACE_LOG2(
        g_pHttpConnectionTraceLog,
        pHttpConnection->pConnection->pHttpTraceLog,
        REF_ACTION_DEREFERENCE_HTTP_CONNECTION,
        pHttpConnection->RefCount - 1,
        pHttpConnection,
        pFileName,
        LineNumber
        );

    refCount = InterlockedDecrement( &pHttpConnection->RefCount );

    UlTrace(
        REFCOUNT, (
            "http!UlDereferenceHttpConnection conn=%p refcount=%d\n",
            pHttpConnection,
            refCount)
        );

    if (refCount == 0)
    {
        //
        // now it's time to free the connection, we need to do
        // this at lower'd irql, let's check it out
        //

        UL_CALL_PASSIVE(
            &(pHttpConnection->WorkItem),
            &UlDeleteHttpConnection
            );
    }

}   // UlDereferenceHttpConnection


/***************************************************************************++

Routine Description:

    Frees all resources associated with the specified HTTP_CONNECTION.

Arguments:

    pWorkItem - Supplies the HTTP_CONNECTION to free.

--***************************************************************************/
VOID
UlDeleteHttpConnection(
    IN PUL_WORK_ITEM pWorkItem
    )
{
    PLIST_ENTRY         pEntry;
    PUL_HTTP_CONNECTION pHttpConnection;

    //
    // Sanity check.
    //

    PAGED_CODE();

    pHttpConnection = CONTAINING_RECORD(
                            pWorkItem,
                            UL_HTTP_CONNECTION,
                            WorkItem
                            );

    ASSERT( pHttpConnection != NULL &&
            pHttpConnection->Signature == UL_HTTP_CONNECTION_POOL_TAG );
    ASSERT(HTTP_IS_NULL_ID(&pHttpConnection->ConnectionId));
    ASSERT(pHttpConnection->TotalSendBytes == 0);

    WRITE_REF_TRACE_LOG2(
        g_pHttpConnectionTraceLog,
        pHttpConnection->pConnection->pHttpTraceLog,
        REF_ACTION_DESTROY_HTTP_CONNECTION,
        0,
        pHttpConnection,
        __FILE__,
        __LINE__
        );

    //
    // The request is gone by now
    //

    ASSERT(pHttpConnection->pRequest == NULL);

    //
    // remove from Timeout Timer Wheel(c)
    //

    UlTimeoutRemoveTimerWheelEntry(
        &pHttpConnection->TimeoutInfo
        );

    //
    // delete the buffer list
    //

    pEntry = pHttpConnection->BufferHead.Flink;
    while (pEntry != &pHttpConnection->BufferHead)
    {
        PUL_REQUEST_BUFFER pBuffer;

        //
        // Get the object
        //

        pBuffer = CONTAINING_RECORD(
                        pEntry,
                        UL_REQUEST_BUFFER,
                        ListEntry
                        );

        //
        // remember the next one
        //

        pEntry = pEntry->Flink;

        //
        // unlink it
        //

        UlFreeRequestBuffer(pBuffer);
    }

    ASSERT(IsListEmpty(&pHttpConnection->BufferHead));

    //
    // get rid of any bindings we're keeping
    //
    while (!IsListEmpty(&pHttpConnection->BindingHead))
    {
        PUL_APOOL_PROC_BINDING pBinding;

        //
        // Get the object
        //
        pEntry = RemoveHeadList(&pHttpConnection->BindingHead);

        pBinding = CONTAINING_RECORD(
                        pEntry,
                        UL_APOOL_PROC_BINDING,
                        BindingEntry
                        );

        ASSERT( IS_VALID_PROC_BINDING(pBinding) );

        //
        // free it
        //

        UlpFreeProcBinding(pBinding);
    }

    //
    // get rid of our resource
    //
    UlDeletePushLock(&pHttpConnection->PushLock);

    //
    // Attempt to remove any QoS filter on this connection,
    // if BWT is enabled.
    //

    if (pHttpConnection->BandwidthThrottlingEnabled)
    {
        UlTcDeleteFilter(pHttpConnection);
    }

    //
    // Decrement the global connection limit. Its safe to decrement for
    // global case because http object doesn't even allocated for global
    // rejection which happens as tcp refusal early when acepting the
    // connection request.
    //

    UlDecrementConnections( &g_CurrentConnections );

    //
    // Decrement the site connections and let our ref go away. If the
    // pConnectionCountEntry is not null, we have been accepted.
    //

    if (pHttpConnection->pConnectionCountEntry)
    {
        UlDecrementConnections(
            &pHttpConnection->pConnectionCountEntry->CurConnections );

        DEREFERENCE_CONNECTION_COUNT_ENTRY(pHttpConnection->pConnectionCountEntry);
        pHttpConnection->pConnectionCountEntry = NULL;
    }

    //
    // Remove final (previous) site counter entry reference 
    // (matches reference in UlSendCachedResponse/UlDeliverHttpRequest)
    // 
    if (pHttpConnection->pPrevSiteCounters)
    {
        UlDecSiteCounter(
            pHttpConnection->pPrevSiteCounters, 
            HttpSiteCounterCurrentConns
            );

        DEREFERENCE_SITE_COUNTER_ENTRY(pHttpConnection->pPrevSiteCounters);
        pHttpConnection->pPrevSiteCounters = NULL;
    }


    //
    // free the memory
    //

    pHttpConnection->Signature = MAKE_FREE_SIGNATURE(
                                        UL_HTTP_CONNECTION_POOL_TAG
                                        );

    //
    // let go the UL_CONNECTION
    //

    DEREFERENCE_CONNECTION( pHttpConnection->pConnection );

}   // UlDeleteHttpConnection


/***************************************************************************++

Routine Description:


Arguments:

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlpCreateHttpRequest(
    IN PUL_HTTP_CONNECTION pHttpConnection,
    OUT PUL_INTERNAL_REQUEST *ppRequest
    )
{
    PUL_INTERNAL_REQUEST pRequest = NULL;

    //
    // Sanity check.
    //

    PAGED_CODE();

    pRequest = UlPplAllocateInternalRequest();

    if (pRequest == NULL)
    {
        return STATUS_NO_MEMORY;
    }

    ASSERT( pRequest->Signature == UL_INTERNAL_REQUEST_POOL_TAG );

    //
    // Keep a reference to the connection.
    //

    UL_REFERENCE_HTTP_CONNECTION( pHttpConnection );

    pRequest->Signature     = UL_INTERNAL_REQUEST_POOL_TAG;
    pRequest->pHttpConn     = pHttpConnection;
    pRequest->ConnectionId  = pHttpConnection->ConnectionId;
    pRequest->Secure        = pHttpConnection->SecureConnection;

    //
    // Set first request flag, used to decide if we need to complete demand
    // start IRPs.
    //

    ASSERT( pHttpConnection->pCurrentBuffer );

    if (0 == pHttpConnection->pCurrentBuffer->BufferNumber &&
        0 == pHttpConnection->pCurrentBuffer->ParsedBytes)
    {
        pRequest->FirstRequest = TRUE;
    }
    else
    {
        pRequest->FirstRequest = FALSE;
    }

    //
    // Grab the raw connection id off the UL_CONNECTION.
    //

    pRequest->RawConnectionId = pHttpConnection->pConnection->FilterInfo.ConnectionId;


    CREATE_REF_TRACE_LOG( pRequest->pTraceLog,
                          32 - REF_TRACE_OVERHEAD,
                          0, TRACELOG_LOW_PRIORITY,
                          UL_INTERNAL_REQUEST_REF_TRACE_LOG_POOL_TAG );

    //
    // UL Handle the request received Event. Record the Connection Id
    // and the client IP address.
    //

    if (ETW_LOG_RESOURCE())
    {
        UlEtwTraceEvent(
            &UlTransGuid,
            ETW_TYPE_START, 
            (PVOID) &pRequest,
            sizeof(PVOID),
            (PVOID) &pHttpConnection->pConnection->AddressType,
            sizeof(USHORT),
            (PVOID) &pHttpConnection->pConnection->RemoteAddress,
            pHttpConnection->pConnection->AddressLength,
            NULL,
            0
            );
    }

    //
    // Increase the number of outstanding requests on this connection.
    //

    InterlockedIncrement((PLONG) &pHttpConnection->PipelinedRequests);

    //
    // return it
    //

    *ppRequest = pRequest;

    UlTrace(REFCOUNT, (
        "http!UlpCreateHttpRequest req=%p refcount=%d\n",
        pRequest,
        pRequest->RefCount
        ));

    return STATUS_SUCCESS;

}   // UlpCreateHttpRequest


VOID
UlReferenceHttpRequest(
    IN PVOID pObject
    REFERENCE_DEBUG_FORMAL_PARAMS
    )
{
    LONG refCount;

    PUL_INTERNAL_REQUEST pRequest = (PUL_INTERNAL_REQUEST) pObject;

    refCount = InterlockedIncrement( &pRequest->RefCount );

    WRITE_REF_TRACE_LOG2(
        g_pHttpRequestTraceLog,
        pRequest->pTraceLog,
        REF_ACTION_REFERENCE_HTTP_REQUEST,
        refCount,
        pRequest,
        pFileName,
        LineNumber
        );

    UlTrace(
        REFCOUNT, (
            "http!UlReferenceHttpRequest req=%p refcount=%d\n",
            pRequest,
            refCount)
        );

}   // UlReferenceHttpRequest

VOID
UlDereferenceHttpRequest(
    IN PUL_INTERNAL_REQUEST pRequest
    REFERENCE_DEBUG_FORMAL_PARAMS
    )
{
    LONG refCount;

    WRITE_REF_TRACE_LOG2(
        g_pHttpRequestTraceLog,
        pRequest->pTraceLog,
        REF_ACTION_DEREFERENCE_HTTP_REQUEST,
        pRequest->RefCount - 1,
        pRequest,
        pFileName,
        LineNumber
        );

    refCount = InterlockedDecrement( &pRequest->RefCount );

    UlTrace(
        REFCOUNT, (
            "http!UlDereferenceHttpRequest req=%p refcount=%d\n",
            pRequest,
            refCount)
        );

    if (refCount == 0)
    {
        UL_CALL_PASSIVE(
            &pRequest->WorkItem,
            &UlpFreeHttpRequest
            );
    }

}   // UlDereferenceHttpRequest

/***************************************************************************++

Routine Description:

    Cancels all pending http io.

Arguments:

    pRequest - Supplies the HTTP_REQUEST.

--***************************************************************************/
VOID
UlCancelRequestIo(
    IN PUL_INTERNAL_REQUEST pRequest
    )
{
    PLIST_ENTRY pEntry;
    PIRP pIrp;
    PUL_CHUNK_TRACKER pTracker;

    //
    // Sanity check.
    //

    PAGED_CODE();
    ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pRequest));
    ASSERT(UlDbgPushLockOwnedExclusive(&pRequest->pHttpConn->PushLock));

    //
    // Mark the request as InCleanup, so additional IRPs
    // on the request will not be queued.
    //

    pRequest->InCleanup = 1;

    //
    // tank all pending io on this request
    //

    while (IsListEmpty(&pRequest->ResponseHead) == FALSE)
    {
        //
        // Pop the SendHttpResponse/EntityBody IRP off the list.
        //

        pEntry = RemoveHeadList(&pRequest->ResponseHead);
        pTracker = CONTAINING_RECORD(pEntry, UL_CHUNK_TRACKER, ListEntry);
        ASSERT(IS_VALID_CHUNK_TRACKER(pTracker));

        //
        // Complete the send with STATUS_CONNECTION_RESET. This is better
        // than using STATUS_CANCELLED since we always reset the connection
        // upon hitting an error.
        //

        UlCompleteSendResponse(pTracker, STATUS_CONNECTION_RESET);
    }

    while (IsListEmpty(&pRequest->IrpHead) == FALSE)
    {
        //
        // Pop the ReceiveEntityBody IRP off the list.
        //

        pEntry = RemoveHeadList(&pRequest->IrpHead);
        pEntry->Blink = pEntry->Flink = NULL;

        pIrp = CONTAINING_RECORD(pEntry, IRP, Tail.Overlay.ListEntry);
        ASSERT(IS_VALID_IRP(pIrp));

        //
        // pop the cancel routine
        //

        if (IoSetCancelRoutine(pIrp, NULL) == NULL)
        {
            //
            // IoCancelIrp pop'd it first
            //
            // ok to just ignore this irp, it's been pop'd off the queue
            // and will be completed in the cancel routine.
            //
            // keep looping
            //

            pIrp = NULL;
        }
        else
        {
            PUL_INTERNAL_REQUEST pIrpRequest;

            //
            // cancel it.  even if pIrp->Cancel == TRUE we are supposed to
            // complete it, our cancel routine will never run.
            //

            pIrpRequest = (PUL_INTERNAL_REQUEST)(
                                IoGetCurrentIrpStackLocation(pIrp)->
                                    Parameters.DeviceIoControl.Type3InputBuffer
                                );

            ASSERT(pIrpRequest == pRequest);

            UL_DEREFERENCE_INTERNAL_REQUEST(pIrpRequest);

            IoGetCurrentIrpStackLocation(pIrp)->
                Parameters.DeviceIoControl.Type3InputBuffer = NULL;

            pIrp->IoStatus.Status = STATUS_CANCELLED;
            pIrp->IoStatus.Information = 0;

            UlCompleteRequest(pIrp, IO_NO_INCREMENT);
            pIrp = NULL;
        }

    }   // while (IsListEmpty(&pRequest->IrpHead) == FALSE)

}   // UlCancelRequestIo


/***************************************************************************++

Routine Description:

    Frees all resources associated with the specified UL_INTERNAL_REQUEST.

Arguments:

    pRequest - Supplies the UL_INTERNAL_REQUEST to free.

--***************************************************************************/
VOID
UlpFreeHttpRequest(
    IN PUL_WORK_ITEM pWorkItem
    )
{
    PUL_INTERNAL_REQUEST pRequest;
    PLIST_ENTRY pEntry;
    ULONG i;

    //
    // Sanity check.
    //

    PAGED_CODE();

    pRequest = CONTAINING_RECORD(
                    pWorkItem,
                    UL_INTERNAL_REQUEST,
                    WorkItem
                    );

    //
    // There should not be a LogData hanging around.
    //

    ASSERT(!pRequest->pLogData);

    //
    // our opaque id should already be free'd (UlDeleteOpaqueIds)
    //

    ASSERT(HTTP_IS_NULL_ID(&pRequest->RequestId));

    //
    // free any known header buffers allocated
    //

    if (pRequest->HeadersAppended)
    {
        for (i = 0; i < HttpHeaderRequestMaximum; i++)
        {
            HTTP_HEADER_ID HeaderId = (HTTP_HEADER_ID)pRequest->HeaderIndex[i];

            if (HeaderId == HttpHeaderRequestMaximum)
            {
                break;
            }

            ASSERT( pRequest->HeaderValid[HeaderId] );

            if (pRequest->Headers[HeaderId].OurBuffer == 1)
            {
                UL_FREE_POOL(
                    pRequest->Headers[HeaderId].pHeader,
                    HEADER_VALUE_POOL_TAG
                    );
            }
        }

        //
        // and any unknown header buffers allocated
        //

        while (IsListEmpty(&pRequest->UnknownHeaderList) == FALSE)
        {
            PUL_HTTP_UNKNOWN_HEADER pUnknownHeader;

            pEntry = RemoveHeadList(&pRequest->UnknownHeaderList);

            pUnknownHeader = CONTAINING_RECORD(
                                pEntry,
                                UL_HTTP_UNKNOWN_HEADER,
                                List
                                );

            if (pUnknownHeader->HeaderValue.OurBuffer == 1)
            {
                UL_FREE_POOL(
                    pUnknownHeader->HeaderValue.pHeader,
                    HEADER_VALUE_POOL_TAG
                    );
            }

            //
            // Free the header structure
            //

            if (pUnknownHeader->HeaderValue.ExternalAllocated == 1)
            {
                UL_FREE_POOL(
                    pUnknownHeader,
                    UL_HTTP_UNKNOWN_HEADER_POOL_TAG
                    );
            }
        }
    }

    //
    // there better not be any pending io, it would have been cancelled either
    // in UlDeleteHttpConnection or in UlDetachProcessFromAppPool .
    //

    ASSERT(IsListEmpty(&pRequest->IrpHead));
    ASSERT(pRequest->SendsPending == 0);

    //
    // dereferenc request buffers.
    //

    for (i = 0; i < pRequest->UsedRefBuffers; i++)
    {
        ASSERT( UL_IS_VALID_REQUEST_BUFFER(pRequest->pRefBuffers[i]) );
        UL_DEREFERENCE_REQUEST_BUFFER(pRequest->pRefBuffers[i]);
    }

    if (pRequest->AllocRefBuffers > 1)
    {
        UL_FREE_POOL(
            pRequest->pRefBuffers,
            UL_REF_REQUEST_BUFFER_POOL_TAG
            );
    }

    //
    // free any url that was allocated
    //

    if (pRequest->CookedUrl.pUrl != NULL)
    {
        if (pRequest->CookedUrl.pUrl != pRequest->pUrlBuffer)
        {
            UL_FREE_POOL(pRequest->CookedUrl.pUrl, URL_POOL_TAG);
        }
    }

    if (pRequest->CookedUrl.pRoutingToken != NULL)
    {
        if (pRequest->CookedUrl.pRoutingToken != pRequest->pDefaultRoutingTokenBuffer)
        {
            UL_FREE_POOL(pRequest->CookedUrl.pRoutingToken, URL_POOL_TAG);
        }
    }

    //
    // free any config group info
    //

    ASSERT( IS_VALID_URL_CONFIG_GROUP_INFO(&pRequest->ConfigInfo) );
    ASSERT( pRequest->pHttpConn );

    //
    // Perf counters
    // NOTE: Assumes cache & non-cache paths both go through here
    // NOTE: If connection is refused the pConnectionCountEntry will be NULL
    //
    if (pRequest->ConfigInfo.pSiteCounters &&
        pRequest->pHttpConn->pConnectionCountEntry)
    {
        PUL_SITE_COUNTER_ENTRY pCtr = pRequest->ConfigInfo.pSiteCounters;

        UlAddSiteCounter64(
                pCtr,
                HttpSiteCounterBytesSent,
                pRequest->BytesSent
                );

        UlAddSiteCounter64(
                pCtr,
                HttpSiteCounterBytesReceived,
                pRequest->BytesReceived
                );

        UlAddSiteCounter64(
                pCtr,
                HttpSiteCounterBytesTransfered,
                (pRequest->BytesSent + pRequest->BytesReceived)
                );

    }

    //
    // Release all the references from the UL_URL_CONFIG_GROUP_INFO.
    //
    if (pRequest->ConfigInfo.UrlInfoSet)
    {
        UlConfigGroupInfoRelease(&pRequest->ConfigInfo);
    }

    //
    // Decrease the number of outstanding requests on this connection.
    //
    InterlockedDecrement((PLONG) &pRequest->pHttpConn->PipelinedRequests);

    //
    // release our reference to the connection
    //
    UL_DEREFERENCE_HTTP_CONNECTION( pRequest->pHttpConn );
    pRequest->pHttpConn = NULL;

    //
    // release our reference to the process
    //
    if (pRequest->AppPool.pProcess)
    {
        DEREFERENCE_APP_POOL_PROCESS( pRequest->AppPool.pProcess );
        pRequest->AppPool.pProcess = NULL;
    }

    //
    // Free the object buffer
    //
    ASSERT( pRequest->Signature == UL_INTERNAL_REQUEST_POOL_TAG );

    DESTROY_REF_TRACE_LOG( pRequest->pTraceLog,
                           UL_INTERNAL_REQUEST_REF_TRACE_LOG_POOL_TAG );


    // 
    // Initialize the Request structure before putting it on the free list
    //
    
    INIT_HTTP_REQUEST( pRequest );

    UlPplFreeInternalRequest( pRequest );
}


/***************************************************************************++

Routine Description:

    Allocates and initializes a new UL_REQUEST_BUFFER.

Arguments:

    BufferSize - size of the new buffer in bytes

--***************************************************************************/
PUL_REQUEST_BUFFER
UlCreateRequestBuffer(
    ULONG BufferSize,
    ULONG BufferNumber,
    BOOLEAN UseLookaside
    )
{
    PUL_REQUEST_BUFFER pBuffer;
    BOOLEAN FromLookaside;

    if (UseLookaside && BufferSize <= DEFAULT_MAX_REQUEST_BUFFER_SIZE)
    {
        BufferSize = DEFAULT_MAX_REQUEST_BUFFER_SIZE;
        FromLookaside = TRUE;

        pBuffer = UlPplAllocateRequestBuffer();
    }
    else
    {
        FromLookaside = FALSE;

        pBuffer = UL_ALLOCATE_STRUCT_WITH_SPACE(
                        NonPagedPool,
                        UL_REQUEST_BUFFER,
                        BufferSize,
                        UL_REQUEST_BUFFER_POOL_TAG
                        );
    }

    if (pBuffer == NULL)
    {
        return NULL;
    }

    RtlZeroMemory((PCHAR)pBuffer, sizeof(UL_REQUEST_BUFFER));

    pBuffer->Signature = UL_REQUEST_BUFFER_POOL_TAG;
    UlInitializeWorkItem(&pBuffer->WorkItem);

    UlTrace(HTTP_IO, (
                "http!UlCreateRequestBuffer buff=%p num=#%d size=%d\n",
                pBuffer,
                BufferNumber,
                BufferSize
                ));

    pBuffer->RefCount       = 1;
    pBuffer->AllocBytes     = BufferSize;
    pBuffer->BufferNumber   = BufferNumber;
    pBuffer->FromLookaside  = FromLookaside;

    return pBuffer;
} // UlCreateRequestBuffer


/***************************************************************************++

Routine Description:

    Removes a request buffer from the buffer list and destroys it.

Arguments:

    pBuffer - the buffer to be deleted

--***************************************************************************/
VOID
UlFreeRequestBuffer(
    PUL_REQUEST_BUFFER pBuffer
    )
{
    ASSERT( UL_IS_VALID_REQUEST_BUFFER( pBuffer ) );

    UlTrace(HTTP_IO, (
        "http!UlFreeRequestBuffer(pBuffer = %p, Num = #%d)\n",
        pBuffer,
        pBuffer->BufferNumber
        ));

    if (pBuffer->ListEntry.Flink != NULL)
    {
        RemoveEntryList(&pBuffer->ListEntry);
        pBuffer->ListEntry.Blink = pBuffer->ListEntry.Flink = NULL;
    }

    UL_DEREFERENCE_REQUEST_BUFFER(pBuffer);
} // UlFreeRequestBuffer


//
// Private functions.
//

/***************************************************************************++

Routine Description:

    Retrieves a binding set with UlBindConnectionToProcess.

Arguments:

    pHttpConnection - the connection to query
    pAppPool        - the key to use for the lookup

Return Values:

    A pointer to the bound process if one was found. NULL otherwise.

--***************************************************************************/
PUL_APP_POOL_PROCESS
UlQueryProcessBinding(
    IN PUL_HTTP_CONNECTION pHttpConnection,
    IN PUL_APP_POOL_OBJECT pAppPool
    )
{
    PUL_APOOL_PROC_BINDING pBinding;
    PUL_APP_POOL_PROCESS pProcess = NULL;

    //
    // Sanity check
    //
    ASSERT( UL_IS_VALID_HTTP_CONNECTION( pHttpConnection ) );
    ASSERT( UlDbgSpinLockOwned( &pAppPool->SpinLock ) );

    pBinding = UlpFindProcBinding(pHttpConnection, pAppPool);

    if (pBinding) {
        pProcess = pBinding->pProcess;
    }

    return pProcess;
}


/***************************************************************************++

Routine Description:

    Allocates and builds a UL_APOOL_PROC_BINDING object.

Arguments:

    pAppPool - the lookup key
    pProcess - the binding

Return Values:

    a pointer to the allocated object, or NULL on failure

--***************************************************************************/
PUL_APOOL_PROC_BINDING
UlpCreateProcBinding(
    IN PUL_APP_POOL_OBJECT pAppPool,
    IN PUL_APP_POOL_PROCESS pProcess
    )
{
    PUL_APOOL_PROC_BINDING pBinding;

    ASSERT( UlDbgSpinLockOwned( &pAppPool->SpinLock ) );
    ASSERT( pAppPool->NumberActiveProcesses > 1 );

    //
    // CODEWORK: lookaside
    //

    pBinding = UL_ALLOCATE_STRUCT(
                    NonPagedPool,
                    UL_APOOL_PROC_BINDING,
                    UL_APOOL_PROC_BINDING_POOL_TAG
                    );

    if (pBinding) {
        pBinding->Signature = UL_APOOL_PROC_BINDING_POOL_TAG;
        pBinding->pAppPool = pAppPool;
        pBinding->pProcess = pProcess;

        UlTrace(ROUTING, (
            "http!UlpCreateProcBinding(\n"
            "        pAppPool = %p\n"
            "        pProcess = %p )\n"
            "    pBinding = %p\n",
            pAppPool,
            pProcess,
            pBinding
            ));
    }

    return pBinding;
}


/***************************************************************************++

Routine Description:

    Gets rid of a proc binding

Arguments:

    pBinding - the binding to get rid of

--***************************************************************************/
VOID
UlpFreeProcBinding(
    IN PUL_APOOL_PROC_BINDING pBinding
    )
{
    UL_FREE_POOL_WITH_SIG(pBinding, UL_APOOL_PROC_BINDING_POOL_TAG);
}


/***************************************************************************++

Routine Description:

    Searches a connection's list of bindings for one that has the right
    app pool key

Arguments:

    pHttpConnection - the connection to search
    pAppPool        - the key

Return Values:

    The binding if found or NULL if not found.

--***************************************************************************/
PUL_APOOL_PROC_BINDING
UlpFindProcBinding(
    IN PUL_HTTP_CONNECTION pHttpConnection,
    IN PUL_APP_POOL_OBJECT pAppPool
    )
{
    PLIST_ENTRY pEntry;
    PUL_APOOL_PROC_BINDING pBinding = NULL;

    //
    // Sanity check
    //
    ASSERT( UlDbgSpinLockOwned( &pAppPool->SpinLock ) );
    ASSERT( UL_IS_VALID_HTTP_CONNECTION(pHttpConnection) );

    pEntry = pHttpConnection->BindingHead.Flink;
    while (pEntry != &pHttpConnection->BindingHead) {

        pBinding = CONTAINING_RECORD(
                        pEntry,
                        UL_APOOL_PROC_BINDING,
                        BindingEntry
                        );

        ASSERT( IS_VALID_PROC_BINDING(pBinding) );

        if (pBinding->pAppPool == pAppPool) {
            //
            // got it!
            //
            break;
        }

        pEntry = pEntry->Flink;
    }

    return pBinding;
}


/***************************************************************************++

Routine Description:

    Removes an HTTP request from all lists and cleans up it's opaque id.

Arguments:

    pRequest - the request to be unlinked

--***************************************************************************/
VOID
UlUnlinkHttpRequest(
    IN PUL_INTERNAL_REQUEST pRequest
    )
{
    ASSERT(UlDbgPushLockOwnedExclusive(&pRequest->pHttpConn->PushLock));

    //
    // cancel i/o
    //

    UlCancelRequestIo(pRequest);

    //
    // delete its opaque id
    //

    if (HTTP_IS_NULL_ID(&pRequest->RequestId) == FALSE)
    {
        UlFreeRequestId(pRequest);

        HTTP_SET_NULL_ID(&pRequest->RequestId);

        //
        // it is still referenced by this connection
        //

        ASSERT(pRequest->RefCount > 1);

        UL_DEREFERENCE_INTERNAL_REQUEST(pRequest);
    }

    //
    // deref it
    //

    UL_DEREFERENCE_INTERNAL_REQUEST(pRequest);
}

/***************************************************************************++

Routine Description:

    If we need to keep the connection around (after disconnect/reset) to be 
    able to get the logging data from worker process, we put the connection 
    in zombie list until last sendresponse with the logging data arrives or
    until timeout code decides on purging this connection completely.

    Http Connection lock must be acquired exclusive before calling this 
    function.
    
Arguments:

    pHttpConnection - the http connection to be inserted to the zombie list.

Return Value:

    STATUS_INVALID_DEVICE_STATE - If the zombie list length is reached the
                                    allowed value.

    STATUS_SUCCESS - If the connection has been inserted to the zombie list
                     and marked as zombie.

--***************************************************************************/
NTSTATUS
UlpZombifyHttpConnection(
    IN PUL_HTTP_CONNECTION pHttpConnection
    )
{
    PUL_INTERNAL_REQUEST pRequest = pHttpConnection->pRequest;
    PLOCKED_LIST_HEAD pListHead = &g_ZombieConnectionList.LockList;
    KIRQL OldIrql;

    ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pRequest));
    ASSERT(UlDbgPushLockOwnedExclusive(&pHttpConnection->PushLock));

    //
    // Try to add the new zombie connection by paying attention to the
    // zombie list limit restriction.
    //

    UlAcquireSpinLock(&pListHead->SpinLock, &OldIrql);

    ASSERT(NULL == pHttpConnection->ZombieListEntry.Flink);

    if (HTTP_LIMIT_INFINITE != g_UlMaxZombieHttpConnectionCount &&
        (pListHead->Count + 1) >= g_UlMaxZombieHttpConnectionCount)
    {
        //
        // We are already at the maximum possible zombie list size.
        // Refuse the connection and let it get destroyed.
        //

#ifdef ENABLE_HTTP_CONN_STATS
        InterlockedIncrement(
            (PLONG) &g_ZombieConnectionList.TotalZombieRefusal
            );
#endif

        UlReleaseSpinLock(&pListHead->SpinLock, OldIrql);
        return STATUS_INVALID_DEVICE_STATE;
    }

    //
    // Double-check if the AppPool has been detached inside the lock for
    // g_ZombieConnectionList. Because we purge all zombie connections
    // related to the process after it is detached, we guarantee we never
    // have a dangling http connection in the zombie list when a process
    // is detached. Also check if the listening endpoint has been closed.
    //

    if (!UlCheckAppPoolState(pRequest) ||
        !UlCheckListeningEndpointState(pHttpConnection->pConnection))
    {
#ifdef ENABLE_HTTP_CONN_STATS
        InterlockedIncrement(
            (PLONG) &g_ZombieConnectionList.TotalZombieRefusal
            );
#endif

        UlReleaseSpinLock(&pListHead->SpinLock, OldIrql);
        return STATUS_INVALID_DEVICE_STATE;
    }

    pListHead->Count += 1;
    InsertTailList(
        &pListHead->ListHead,
        &pHttpConnection->ZombieListEntry
        );

    //
    // Remember the process that the connection was delivered so we can
    // force-purge later when the process is detached. This needs to be
    // done inside the lock to synchronize with UlPurgeZombieConnections.
    //

    ASSERT(IS_VALID_AP_PROCESS(pRequest->AppPool.pProcess));
    pHttpConnection->pAppPoolProcess = pRequest->AppPool.pProcess;

    UlReleaseSpinLock(&pListHead->SpinLock, OldIrql);

#ifdef ENABLE_HTTP_CONN_STATS
    {
        LONG ZombieCount;

        ZombieCount = (LONG) g_ZombieConnectionList.LockList.Count;
        if (ZombieCount > (LONG) g_ZombieConnectionList.MaxZombieCount)
        {        
            InterlockedExchange(
                (PLONG) &g_ZombieConnectionList.MaxZombieCount,
                ZombieCount
                );
        }

        InterlockedIncrement((PLONG) &g_ZombieConnectionList.TotalZombieCount);
    }
#endif

    UlTrace(HTTP_IO, (
       "Http!UlZombifyHttpRequest: httpconn=%p & request=%p \n",
        pHttpConnection, pRequest
        ));
    
    //
    // If we got far enough to deliver the request then unlink it from 
    // the app pool. So that queued Irps release their  references  on 
    // the request.
    //
    
    if (pRequest->ConfigInfo.pAppPool)
    {
        UlUnlinkRequestFromProcess(
            pRequest->ConfigInfo.pAppPool, 
            pRequest
            );
    }

    //
    // Cancel (Receive) I/O
    //
    
    UlCancelRequestIo(pRequest);

    //
    // Keep its opaque id while its  siting on the zombie list. But
    // owner is now the zombie list rather than the http connection.
    //

    ASSERT(pRequest->RefCount > 1);

    //
    // Mark that now we are in the zombie list.
    //

    InterlockedExchange((PLONG) &pHttpConnection->Zombified, 1);
    
    return STATUS_SUCCESS;
    
}

/***************************************************************************++

Routine Description:

    Removes the http connection from the zombie list.

    Caller should hold the zombie list spinlock prior to calling this 
    function.
    
Arguments:

    pHttpConnection - the http connection to be removed frm zombie list.

--***************************************************************************/

VOID
UlpRemoveZombieHttpConnection(
    IN PUL_HTTP_CONNECTION pHttpConn
    )
{
    LONG NewCount;
    
    ASSERT(UL_IS_VALID_HTTP_CONNECTION(pHttpConn));
    
    ASSERT(UlDbgSpinLockOwned( 
            &g_ZombieConnectionList.LockList.SpinLock));
        
    //
    // This connection should be in the zombie list.
    //
    
    ASSERT(pHttpConn->Zombified == TRUE);
    ASSERT(pHttpConn->ZombieListEntry.Flink != NULL);

    //
    // Remove this from the zombie list of http connections.
    //
    
    RemoveEntryList(&pHttpConn->ZombieListEntry);
    pHttpConn->ZombieListEntry.Flink = NULL;

    NewCount = InterlockedDecrement(
        (PLONG) &g_ZombieConnectionList.LockList.Count);
    ASSERT(NewCount >= 0);
    
}

/***************************************************************************++

Routine Description:

    Once the due SendResponse happens or timeout happens (whichever the 
    earliest) then we remove this connection from zombie list and cleanup
    it and it's request as well.

    You should hold the http connection lock exclusive before calling
    this function.

    You should also hold the zombie list lock prior to calling this function.
    
Arguments:

    pHttpConnection - the http connection to be removed frm zombie list.

--***************************************************************************/

VOID
UlpCleanupZombieHttpConnection(
    IN PUL_HTTP_CONNECTION pHttpConnection
    )
{
    PUL_INTERNAL_REQUEST pRequest;

    //
    // Both connection and request should be in the good shape.
    //

    pRequest = pHttpConnection->pRequest;
    
    ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pRequest));
    ASSERT(UL_IS_VALID_HTTP_CONNECTION(pHttpConnection));
    ASSERT(UlDbgPushLockOwnedExclusive(&pHttpConnection->PushLock));

    UlTrace(HTTP_IO, (
       "Http!UlCleanupZombieHttpConnection: httpconn=%p & request=%p \n",
        pHttpConnection, pRequest
        ));
    
    //
    // Release Request's opaque id and it's refcount.
    //

    if (!HTTP_IS_NULL_ID(&pRequest->RequestId))
    {
        UlFreeRequestId(pRequest);

        HTTP_SET_NULL_ID(&pRequest->RequestId);

        UL_DEREFERENCE_INTERNAL_REQUEST(pRequest);
    }    
    
    //
    // Release httpconn's refcount on request.
    //
    
    UL_DEREFERENCE_INTERNAL_REQUEST(pRequest);
    pHttpConnection->pRequest = NULL;
    
    //
    // Release httpconn's opaque id and its refcount.
    //

    if (!HTTP_IS_NULL_ID(&pHttpConnection->ConnectionId))
    {
        UlFreeOpaqueId(
            pHttpConnection->ConnectionId,
            UlOpaqueIdTypeHttpConnection
            );

        HTTP_SET_NULL_ID(&pHttpConnection->ConnectionId);

        UL_DEREFERENCE_HTTP_CONNECTION(pHttpConnection);
    }        

}

/***************************************************************************++

Routine Description:

    DPC routine get called every 30 seconds. (Default)
    
Arguments:

    Ignored

--***************************************************************************/

VOID
UlZombieTimerDpcRoutine(
    PKDPC Dpc,
    PVOID DeferredContext,
    PVOID SystemArgument1,
    PVOID SystemArgument2
    )
{
    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(DeferredContext);
    UNREFERENCED_PARAMETER(SystemArgument1);
    UNREFERENCED_PARAMETER(SystemArgument2);

    //
    // Queue a worker for terminating the timed out zombie entries.
    // Worker can acquire the individual http connection eresources. 
    // But do not queue a worker if there's already one running.
    //

    UlAcquireSpinLockAtDpcLevel(&g_ZombieConnectionList.TimerSpinLock);

    if (g_ZombieConnectionList.TimerInitialized == TRUE)
    {        
        if (FALSE == InterlockedExchange(
                        &g_ZombieConnectionList.TimerRunning, TRUE)) 
        {

            UL_QUEUE_WORK_ITEM(
                &g_ZombieConnectionList.WorkItem, 
                &UlpZombieTimerWorker
                );
        }
    }
    
    UlReleaseSpinLockFromDpcLevel(&g_ZombieConnectionList.TimerSpinLock);
    
}


/***************************************************************************++

Routine Description:

    Purge the zombie connections according to pPurgeRoutine or
    pHttpConn->ZombieExpired.

Arguments:

    pPurgeRoutine - purge routine to decide which connection to be purged.
    pPurgeContext - context passed to the purge routine.

--***************************************************************************/

VOID
UlPurgeZombieConnections(
    IN PUL_PURGE_ROUTINE pPurgeRoutine,
    IN PVOID pPurgeContext
    )
{
    KIRQL OldIrql;
    PLIST_ENTRY pLink;
    PUL_HTTP_CONNECTION pHttpConn;
    LIST_ENTRY TempZombieList;
    PLOCKED_LIST_HEAD pList;
    BOOLEAN ForceExpire;

    //
    // Init temp zombie list
    //
    
    InitializeListHead(&TempZombieList);

#ifdef ENABLE_HTTP_CONN_STATS    
    UlTraceVerbose(HTTP_IO,
            ("Http!UlPurgeZombieConnections, Stats:\n"
             "\tpPurgeRoutine           = %p\n"
             "\tpPurgeContext           = %p\n"
             "\tCurrentZombieCount      = %lu\n"
             "\tMaxZombieCount          = %lu\n"
             "\tTotalConnections        = %lu\n"
             "\tTotalZombieCount        = %lu\n"
             "\tTotalZombieRefusal      = %lu\n",
             pPurgeRoutine,
             pPurgeContext,
             g_ZombieConnectionList.LockList.Count,
             g_ZombieConnectionList.MaxZombieCount,
             g_ZombieConnectionList.TotalCount,
             g_ZombieConnectionList.TotalZombieCount,
             g_ZombieConnectionList.TotalZombieRefusal
             ));
#endif

    pList = &g_ZombieConnectionList.LockList;
    
    UlAcquireSpinLock(&pList->SpinLock, &OldIrql);

    pLink = pList->ListHead.Flink;        
    while (pLink != &pList->ListHead)
    {      
        pHttpConn = CONTAINING_RECORD(
                        pLink,
                        UL_HTTP_CONNECTION,
                        ZombieListEntry
                        );
        
        pLink = pLink->Flink;
        ForceExpire = FALSE;

        if (pPurgeRoutine)
        {
            ForceExpire = (*pPurgeRoutine)(pHttpConn, pPurgeContext);

            if (!ForceExpire)
            {
                continue;
            }
        }
        else
        if (pHttpConn->ZombieExpired)
        {
            ForceExpire = TRUE;
        }
        else
        {
            //
            // It will go away next time we wake up.
            //

            pHttpConn->ZombieExpired = TRUE;
        }

        if (ForceExpire)
        {
            //
            // Guard against multiple cleanups by looking at the below flag.
            // Final send may already be on the run and it will do the 
            // cleanup when it's done.
            //

            if (0 == InterlockedCompareExchange(
                        (PLONG) &pHttpConn->CleanedUp,
                        1,
                        0
                        ))
            {          
                //
                // Timed out already or we need to purge by force. Move to
                // the temp list and cleanup outside of the spinlock.
                //

                UlpRemoveZombieHttpConnection(pHttpConn);

                InsertTailList(&TempZombieList, &pHttpConn->ZombieListEntry);
            }
        }
    }

    UlReleaseSpinLock(&pList->SpinLock, OldIrql);

    //
    // Now cleanup the temp list.
    //

    pLink = TempZombieList.Flink;
    while (pLink != &TempZombieList)
    {            
        pHttpConn = CONTAINING_RECORD(
                        pLink,
                        UL_HTTP_CONNECTION,
                        ZombieListEntry
                        );

        pLink = pLink->Flink;

        UlAcquirePushLockExclusive(&pHttpConn->PushLock);

        //
        // Log the zombified connection before drop.
        //
        
        UlErrorLog(pHttpConn,
                    NULL,
                    ERROR_LOG_INFO_FOR_ZOMBIE_DROP,
                    ERROR_LOG_INFO_FOR_ZOMBIE_DROP_SIZE,
                    TRUE
                    );
            
        UlpCleanupZombieHttpConnection(pHttpConn);

        pHttpConn->ZombieListEntry.Flink = NULL;

        UlReleasePushLockExclusive(&pHttpConn->PushLock); 

        //
        // Release the zombie list's refcount on http connection.
        //
        
        UL_DEREFERENCE_HTTP_CONNECTION(pHttpConn);
        
    }        

}

/***************************************************************************++

Routine Description:

    Timer function walks through the zombie list and decides on terminating 
    the old zombie connections once and for all. 

Arguments:

    WorkItem - Ignored.

--***************************************************************************/

VOID
UlpZombieTimerWorker(
    IN PUL_WORK_ITEM pWorkItem
    )
{
    UNREFERENCED_PARAMETER(pWorkItem);

    ASSERT(g_ZombieConnectionList.TimerRunning == TRUE);
    
    //
    // Purge all zombie connections that have expired.
    //

    UlPurgeZombieConnections(NULL, NULL);

    //
    // Finally allow other instances of the timer to run.
    //

    InterlockedExchange(&g_ZombieConnectionList.TimerRunning, FALSE);

}

/***************************************************************************++

Routine Description:

    Purge the zombie list when we are shutting down.
    
Arguments:

    Ignored

--***************************************************************************/

VOID
UlpTerminateZombieList(
    VOID
    )
{
    KIRQL OldIrql;
    PLIST_ENTRY pLink;
    PUL_HTTP_CONNECTION pHttpConn;
    LIST_ENTRY TempZombieList;
    PLOCKED_LIST_HEAD pList;

    //
    // Init temp zombie list
    //

    InitializeListHead(&TempZombieList);

    pList = &g_ZombieConnectionList.LockList;
    
    UlTrace(HTTP_IO, (
       "Http!UlpTerminateZombieList: Terminating for ZombieCount =%d\n",
        pList->Count
        ));
    
    UlAcquireSpinLock(&pList->SpinLock, &OldIrql);

    //
    // Move the entire list to the temp zombie list and cleanup 
    // outside of the spinlock.
    //

    pLink = pList->ListHead.Flink;        
    while (pLink != &pList->ListHead)
    {      
    
        PLIST_ENTRY pNextLink = pLink->Flink;
        
        pHttpConn = CONTAINING_RECORD(
                        pLink,
                        UL_HTTP_CONNECTION,
                        ZombieListEntry
                        );
    
        UlpRemoveZombieHttpConnection(pHttpConn);
                 
        InsertTailList(&TempZombieList, &pHttpConn->ZombieListEntry);

        pLink = pNextLink;    
    }

    UlReleaseSpinLock(&pList->SpinLock, OldIrql);

    //
    // Now cleanup everything.
    //
    
    pLink = TempZombieList.Flink;
    while (pLink != &TempZombieList)
    {    
        pHttpConn = CONTAINING_RECORD(
                        pLink,
                        UL_HTTP_CONNECTION,
                        ZombieListEntry
                        );
        
        pLink = pLink->Flink;

        UlAcquirePushLockExclusive(&pHttpConn->PushLock);

        //
        // Log the zombified connection before dropping it.
        //

        UlErrorLog(pHttpConn,
                    NULL,
                    ERROR_LOG_INFO_FOR_ZOMBIE_DROP,
                    ERROR_LOG_INFO_FOR_ZOMBIE_DROP_SIZE,
                    TRUE
                    );
        
        UlpCleanupZombieHttpConnection(pHttpConn);

        pHttpConn->ZombieListEntry.Flink = NULL;

        UlReleasePushLockExclusive(&pHttpConn->PushLock); 

        //
        // Release the zombie list's refcount on http connection.
        //
        UL_DEREFERENCE_HTTP_CONNECTION(pHttpConn);
        
    }
    
}

/***************************************************************************++

Routine Description:

    Timer for the zombie http connection list wakes up every 30 seconds and
    in the max case it terminates the zombie connection no later than 60 
    seconds.
    
--***************************************************************************/

VOID
UlpSetZombieTimer(
    VOID
    )
{
    LONGLONG        PeriodTime100Ns;
    LONG            PeriodTimeMs;
    LARGE_INTEGER   PeriodTime;

    PeriodTimeMs = DEFAULT_ZOMBIE_HTTP_CONNECTION_TIMER_PERIOD_IN_SECONDS * 1000;
    PeriodTime100Ns = (LONGLONG) PeriodTimeMs * 10 * 1000;

    UlTrace(HTTP_IO,("http!UlpSetZombieTimer: period of %d seconds.\n",
             DEFAULT_ZOMBIE_HTTP_CONNECTION_TIMER_PERIOD_IN_SECONDS
             ));

    PeriodTime.QuadPart = -PeriodTime100Ns; // Relative time

    KeSetTimerEx(
        &g_ZombieConnectionList.Timer,
        PeriodTime,      // In nanosec
        PeriodTimeMs,    // In millisec
        &g_ZombieConnectionList.DpcObject
        );
    
}

/***************************************************************************++

Routine Description:

    Probes and prepares the user provided log buffers and completes the
    logging for this zombie connection. After that it triggers the cleanup
    of the zombie connection.

    If any error happens, it cleans up the zombie connection But returns 
    success regardless.

    You should hold the http connection lock exclusive before calling this
    function.

Arguments:

    pRequest - The request for the zombie connection.
    pHttpConnection - Supplies the HTTP_CONNECTION to send the response on.

Return Value:

    Always STATUS_CONNECTION_INVALID. Handling the zombie connection is a 
    best effort to write a log record for the connection. If something fails 
    we terminate the zombie connection and do not allow a second chance.

--***************************************************************************/
NTSTATUS
UlLogZombieConnection(
    IN PUL_INTERNAL_REQUEST  pRequest,
    IN PUL_HTTP_CONNECTION   pHttpConn,
    IN PHTTP_LOG_FIELDS_DATA pCapturedUserLogData,
    IN KPROCESSOR_MODE       RequestorMode
    )
{
    PUL_LOG_DATA_BUFFER pLogData = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    KIRQL OldIrql;

    //
    // Sanity check.
    //
    
    Status = STATUS_SUCCESS;

    ASSERT(UL_IS_VALID_HTTP_CONNECTION(pHttpConn));
    ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pRequest));

    ASSERT(pHttpConn->Zombified == TRUE);
    ASSERT(pHttpConn->ZombieListEntry.Flink != NULL);

    UlTrace(HTTP_IO, (
       "Http!UlLogZombieConnection: Logging for pRequest=%p pHttpConn=%p\n",
        pRequest, pHttpConn
        ));

    //
    // No user logging data, bail out and cleanup the zombie connection.
    //

    if (!pCapturedUserLogData)
    {
        goto cleanup;
    }
    
    //
    // Probe the log data. If something fails, then cleanup
    // the zombie connection.
    //

    __try
    {
        //
        // The pCapturedUserLogData is already probed and captured. However
        // we need to probe the individual log fields (pointers) inside the 
        // structure.
        //
    
        UlProbeLogData(pCapturedUserLogData, RequestorMode);

    } __except(UL_EXCEPTION_FILTER())
    {
        Status = UL_CONVERT_EXCEPTION_CODE(GetExceptionCode());
        goto cleanup;
    }
        
    //
    // Now we will allocate a kernel pLogData and built and format it
    // from the provided user log fields. However if logging is not
    // enabled for the pRequest's cgroup then capture will simply 
    // return success w/o setting the pLogData. Therefore we need to 
    // make sure we only log if the pLogData is set.
    //
    
    Status = UlCaptureUserLogData(
                pCapturedUserLogData,
                pRequest,
               &pLogData
                );            
    
    if (NT_SUCCESS(Status) && pLogData) 
    {
        ASSERT(IS_VALID_LOG_DATA_BUFFER(pLogData));
        
        //
        // The actual logging takes place inline.
        //
        
        LOG_SET_WIN32STATUS(pLogData, STATUS_CONNECTION_RESET);
               
        //
        // Pick the right logging type.
        //
        
        if (pLogData->Flags.Binary)
        {
            UlRawLogHttpHit(pLogData);
        }
        else
        {
            UlLogHttpHit(pLogData);
        }
    }

cleanup:

    //
    // Cleanup the pLogData & the zombie connection before
    // completing the Ioctl.
    //

    if (pLogData)
    {
        UlDestroyLogDataBuffer(pLogData);
    }                

    UlAcquireSpinLock(
        &g_ZombieConnectionList.LockList.SpinLock, &OldIrql);
  
    UlpRemoveZombieHttpConnection(pHttpConn);

    UlReleaseSpinLock(
        &g_ZombieConnectionList.LockList.SpinLock, OldIrql);

    UlpCleanupZombieHttpConnection(pHttpConn);

    //
    // Release Zombie List's refcount on the http connection.
    //

    UL_DEREFERENCE_HTTP_CONNECTION(pHttpConn);    
    
    return STATUS_CONNECTION_INVALID;
} 


//
// Following code has been implemented for Global & Site specific connection
// limits feature. If enforced, incoming  connections get refused  when they
// exceed the existing limit. Control  channel & config group  (re)sets this
// values whereas httprcv and sendresponse  updates the limits  for incoming
// requests & connections. A seperate connection_count_entry structure keeps
// track  of the  limits per site. Global limits  are tracked by the  global
// variables g_MaxConnections & g_CurrentConnections same API has been used
// for both purposes.
//

/***************************************************************************++

Routine Description:

    Allocates a connection count entry which will hold the site specific
    connection count info. Get called by cgroup when Config group is
    attempting to allocate a connection count entry.

Arguments:

    pConfigGroup - To receive the newly allocated count entry
    MaxConnections - The maximum allowed connections

--***************************************************************************/

NTSTATUS
UlCreateConnectionCountEntry(
      IN OUT PUL_CONFIG_GROUP_OBJECT pConfigGroup,
      IN     ULONG                   MaxConnections
    )
{
    PUL_CONNECTION_COUNT_ENTRY       pEntry;

    // Sanity check.

    PAGED_CODE();
    ASSERT(IS_VALID_CONFIG_GROUP(pConfigGroup));

    // Alloc new struct from Paged Pool

    pEntry = UL_ALLOCATE_STRUCT(
                PagedPool,
                UL_CONNECTION_COUNT_ENTRY,
                UL_CONNECTION_COUNT_ENTRY_POOL_TAG
                );
    if (!pEntry)
    {
        UlTrace(LIMITS,
          ("Http!UlCreateConnectionCountEntry: OutOfMemory pConfigGroup %p\n",
            pConfigGroup
            ));

        return STATUS_NO_MEMORY;
    }

    pEntry->Signature       = UL_CONNECTION_COUNT_ENTRY_POOL_TAG;
    pEntry->RefCount        = 1;
    pEntry->MaxConnections  = MaxConnections;
    pEntry->CurConnections  = 0;

    // Update cgroup pointer

    ASSERT( pConfigGroup->pConnectionCountEntry == NULL );
    pConfigGroup->pConnectionCountEntry = pEntry;

    UlTrace(LIMITS,
          ("Http!UlCreateConnectionCountEntry: "
           "pNewEntry %p, pConfigGroup %p, Max %d\n",
            pEntry,
            pConfigGroup,
            MaxConnections
            ));

    return STATUS_SUCCESS;

} // UlCreateConnectionCountEntry

/***************************************************************************++

Routine Description:

    increments the refcount for ConnectionCountEntry.

Arguments:

    pEntry - the object to increment.

--***************************************************************************/
VOID
UlReferenceConnectionCountEntry(
    IN PUL_CONNECTION_COUNT_ENTRY pEntry
    REFERENCE_DEBUG_FORMAL_PARAMS
    )
{
    LONG refCount;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT( IS_VALID_CONNECTION_COUNT_ENTRY(pEntry) );

    refCount = InterlockedIncrement( &pEntry->RefCount );

    //
    // Tracing.
    //

    WRITE_REF_TRACE_LOG(
        g_pConnectionCountTraceLog,
        REF_ACTION_REFERENCE_CONNECTION_COUNT_ENTRY,
        refCount,
        pEntry,
        pFileName,
        LineNumber
        );

    UlTrace(
        REFCOUNT,
        ("Http!UlReferenceConnectionCountEntry pEntry=%p refcount=%d\n",
         pEntry,
         refCount
         ));

}   // UlReferenceConnectionCountEntry

/***************************************************************************++

Routine Description:

    decrements the refcount.  if it hits 0, destruct's ConnectionCountEntry

Arguments:

    pEntry - the object to decrement.

--***************************************************************************/
VOID
UlDereferenceConnectionCountEntry(
    IN PUL_CONNECTION_COUNT_ENTRY pEntry
    REFERENCE_DEBUG_FORMAL_PARAMS
    )
{
    LONG refCount;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT( IS_VALID_CONNECTION_COUNT_ENTRY(pEntry) );

    refCount = InterlockedDecrement( &pEntry->RefCount );

    //
    // Tracing.
    //
    WRITE_REF_TRACE_LOG(
        g_pConnectionCountTraceLog,
        REF_ACTION_DEREFERENCE_CONNECTION_COUNT_ENTRY,
        refCount,
        pEntry,
        pFileName,
        LineNumber
        );

    UlTrace(
        REFCOUNT,
        ("Http!UlDereferenceConnectionCountEntry pEntry=%p refcount=%d\n",
         pEntry,
         refCount
         ));

    //
    // Cleanup the memory and do few checks !
    //

    if ( refCount == 0 )
    {
        // Make sure no connection on the site
        ASSERT( 0 == pEntry->CurConnections );

        UlTrace(
            LIMITS,
            ("Http!UlDereferenceConnectionCountEntry: Removing pEntry=%p\n",
             pEntry
             ));

        // Release memory
        UL_FREE_POOL_WITH_SIG(pEntry,UL_CONNECTION_COUNT_ENTRY_POOL_TAG);
    }

} // UlDereferenceConnectionCountEntry

/***************************************************************************++

Routine Description:

    This
    function set the maximum limit. Maximum allowed number of  connections
    at any time by the active control channel.

Arguments:

    MaxConnections - Maximum allowed number of connections

Return Value:

    Old Max Connection count

--***************************************************************************/

ULONG
UlSetMaxConnections(
    IN OUT PULONG  pCurMaxConnection,
    IN     ULONG   NewMaxConnection
    )
{
    ULONG  OldMaxConnection;

    UlTrace(LIMITS,
      ("Http!UlSetMaxConnections pCurMaxConnection=%p NewMaxConnection=%d\n",
        pCurMaxConnection,
        NewMaxConnection
        ));

    //
    // By setting this we are not forcing the existing connections  to
    // termination but this number will be effective for all newcoming
    // connections, as soon as the atomic operation completed.
    //

    OldMaxConnection = (ULONG) InterlockedExchange((LONG *) pCurMaxConnection,
                                                   (LONG)   NewMaxConnection
                                                            );
    return OldMaxConnection;

} // UlSetMaxConnections

/***************************************************************************++

Routine Description:

    Control channel uses this function to set or reset the global connection
    limits.

--***************************************************************************/

ULONG 
UlGetGlobalConnectionLimit(
    VOID
    )
{
    return g_MaxConnections;
}


/***************************************************************************++

Routine Description:

    Control channel uses this function to initialize the global connection
    limits. Assuming the existince of one and only one active control channel
    this globals get set only once during init. But could be set again later
    because of a reconfig.

--***************************************************************************/

NTSTATUS
UlInitGlobalConnectionLimits(
    VOID
    )
{
    ULONG       PerConnectionEstimate;
    SIZE_T      HttpMaxConnections;
    SIZE_T      AvailablePages;
    NTSTATUS    Status = STATUS_SUCCESS;

    ASSERT(!g_InitGlobalConnections);

    if (!g_InitGlobalConnections)
    {
        g_CurrentConnections    = 0;
    
        //
        // Set global max connection limit
        //
        
        // Heuristic Calculation to estmiate the size 
        // needed per connection

        // First, there's the UL_CONNECTION
        PerConnectionEstimate = sizeof(UL_CONNECTION);

        // Second, assume one UL_INTERNAL_REQUEST+Full Tracker per Connection
        PerConnectionEstimate += (sizeof(UL_INTERNAL_REQUEST) + 
            MAX(g_UlFullTrackerSize, g_UlChunkTrackerSize) + 
            g_UlMaxInternalUrlLength +
            DEFAULT_MAX_ROUTING_TOKEN_LENGTH + 
            sizeof(WCHAR) // for the null on the InternalUrl
            ); 

        // Third, add one UL_REQUEST_BUFFER
        PerConnectionEstimate += (sizeof(UL_REQUEST_BUFFER) +
            DEFAULT_MAX_REQUEST_BUFFER_SIZE);

        // Fourth, add the size of a response
        PerConnectionEstimate += g_UlResponseBufferSize;
        
        // Finally, round up to the next page size & convert to pages
        PerConnectionEstimate = 
            (ULONG)ROUND_TO_PAGES(PerConnectionEstimate);

        PerConnectionEstimate /= PAGE_SIZE;

        ASSERT(0 != PerConnectionEstimate);

        AvailablePages = BYTES_TO_PAGES(g_UlTotalNonPagedPoolBytes);

        // Assume only 50% of NPP available to HTTP.SYS
        AvailablePages /= 2;

        // Assume 20% set aside for HttpDataChunkFromFileHandle send buffers.
        // (this works out to roughly 3% to 5% of the connections)
        AvailablePages -= (AvailablePages/5);

        if ( AvailablePages < PerConnectionEstimate )
        {
            // this machine has so little NPP, that it can't even support one 
            // measely little connection!
            AvailablePages = PerConnectionEstimate;
        }

        // Okay, how many fit?
        HttpMaxConnections = (AvailablePages / PerConnectionEstimate);

        ASSERT(0 != HttpMaxConnections);

        // And set it (if it wasn't overridden in UlpReadRegistry)
        if (HTTP_LIMIT_INFINITE == g_MaxConnections)
        {
            g_MaxConnections = (ULONG)MIN(HttpMaxConnections, LONG_MAX);
        }
        else
        {
            UlTrace(LIMITS,
                ("Http!UlInitGlobalConnectionLimits: User has overridden "
                "g_MaxConnections: %d\n",
                g_MaxConnections
                ));
        }
            
        g_InitGlobalConnections = TRUE;

        UlTrace2Either(LIMITS, TDI_STATS,
            ("Http!UlInitGlobalConnectionLimits: Init g_MaxConnections %d,"
            "g_CurrentConnections %d, HttpMaxConnections %d\n",
            g_MaxConnections,
            g_CurrentConnections,
            HttpMaxConnections
            ));

        if (DEFAULT_MAX_REQUESTS_QUEUED == g_UlMaxRequestsQueued)
        {
            //
            // If it's been left at the default, set it equal to 
            // the number of Max Connections; this assumes a 1:1 ratio
            // of requests per connection.
            //
            
            g_UlMaxRequestsQueued = (ULONG) g_MaxConnections;
        }

        UlTrace2Either(LIMITS, TDI_STATS,
            ("Http!UlInitGlobalConnectionLimits: Init g_UlMaxRequestsQueued %d\n",
            g_UlMaxRequestsQueued
            ));          
    }

    return Status;

} // UlInitGlobalConnectionLimits

/***************************************************************************++

Routine Description:

    Wrapper around the Accept Connection for global connections

--***************************************************************************/
BOOLEAN
UlAcceptGlobalConnection(
    VOID
    )
{
    return UlAcceptConnection( &g_MaxConnections, &g_CurrentConnections );

} // UlAcceptGlobalConnection

/***************************************************************************++

Routine Description:

    This function checks if we are allowed to accept the incoming connection
    based on the number enforced by the control channel.

Return value:

    Decision for the newcoming connection either ACCEPT or REJECT as boolean

--***************************************************************************/

BOOLEAN
UlAcceptConnection(
    IN     PULONG   pMaxConnection,
    IN OUT PULONG   pCurConnection
    )
{
    ULONG    LocalCur;
    ULONG    LocalCurPlusOne;
    ULONG    LocalMax;

    do
    {
        //
        // Capture the Max & Cur. Do  the comparison. If in the  limit
        // attempt to increment the connection count by ensuring nobody
        // else did it before us.
        //

        LocalMax = *((volatile ULONG *) pMaxConnection);
        LocalCur = *((volatile ULONG *) pCurConnection);

        //
        // Its greater than or equal because Max may get updated  to
        // a smaller number on-the-fly and we end up having  current
        // connections greater than the maximum allowed.
        // NOTE: HTTP_LIMIT_INFINITE has been picked as (ULONG)-1 so
        // following comparison won't reject for the infinite case.
        //

        if ( LocalCur >= LocalMax )
        {
            //
            // We are already at the limit refuse it.
            //

            UlTrace(LIMITS,
                ("Http!UlAcceptConnection REFUSE pCurConnection=%p[%d]"
                 "pMaxConnection=%p[%d]\n",
                  pCurConnection, LocalCur,
                  pMaxConnection, LocalMax
                  ));

            return FALSE;
        }

        //
        // Either the limit was infinite or conn count was not exceeding
        // the limit. Lets attempt to increment the count and accept the
        // connection in the while statement.
        //

        LocalCurPlusOne  = LocalCur + 1;

    }
    while ( LocalCur != (ULONG) InterlockedCompareExchange(
                                        (LONG *) pCurConnection,
                                        (LONG) LocalCurPlusOne,
                                        (LONG) LocalCur
                                        ) );

    //
    // Successfully incremented the counter. Let it go with success.
    //

    UlTrace(LIMITS,
        ("Http!UlAcceptConnection ACCEPT pCurConnection=%p[%d]"
         "pMaxConnection=%p[%d]\n",
          pCurConnection, LocalCur,
          pMaxConnection, LocalMax
          ));

    return TRUE;

} // UlAcceptConnection


/***************************************************************************++

Routine Description:

    Everytime a disconnection happens we will decrement the count here.

Return Value:

    The newly decremented value

--***************************************************************************/

LONG
UlDecrementConnections(
    IN OUT PULONG pCurConnection
    )
{
    LONG NewConnectionCount;

    NewConnectionCount = InterlockedDecrement( (LONG *) pCurConnection );

    ASSERT( NewConnectionCount >= 0 );

    return NewConnectionCount;

} // UlDecrementConnections


/***************************************************************************++

Routine Description:

    For cache & non-cache hits this function get called. Connection  resource
    has assumed to be acquired at this time. The function decide to accept or
    reject the request by looking at the corresponding count entries.

Arguments:

    pConnection - For getting the previous site's connection count entry
    pConfigInfo - Holds a pointer to newly received request's site's
                  connection count entry.
Return Value:

    Shows reject or accept

--***************************************************************************/

BOOLEAN
UlCheckSiteConnectionLimit(
    IN OUT PUL_HTTP_CONNECTION pConnection,
    IN OUT PUL_URL_CONFIG_GROUP_INFO pConfigInfo
    )
{
    BOOLEAN Accept;
    PUL_CONNECTION_COUNT_ENTRY pConEntry;
    PUL_CONNECTION_COUNT_ENTRY pCIEntry;

    if (pConfigInfo->pMaxConnections == NULL || pConfigInfo->pConnectionCountEntry == NULL)
    {
        //
        // No connection count entry for the new request perhaps WAS never
        // set this before otherwise its a problem.
        //

        UlTrace(LIMITS,
          ("Http!UlCheckSiteConnectionLimit: NO LIMIT pConnection=%p pConfigInfo=%p\n",
            pConnection,
            pConfigInfo
            ));

        return TRUE;
    }

    ASSERT(IS_VALID_CONNECTION_COUNT_ENTRY(pConfigInfo->pConnectionCountEntry));

    pCIEntry  = pConfigInfo->pConnectionCountEntry;
    pConEntry = pConnection->pConnectionCountEntry;
    Accept    = FALSE;

    //
    // Make a check on the connection  limit of the site. Refuse the request
    // if the limit is exceded.
    //
    if (pConEntry)
    {
        ASSERT(IS_VALID_CONNECTION_COUNT_ENTRY(pConEntry));

        //
        // For consecutive requests we decrement the previous site's  connection count
        // before proceeding to the decision on the newcoming request,if the two sides
        // are not same.That means we assume this connection on site x until (if ever)
        // a request changes this to site y. Naturally until the first request arrives
        // and successfully parsed, the connection does not count to any specific site
        //

        if (pConEntry != pCIEntry)
        {
            UlDecrementConnections(&pConEntry->CurConnections);
            DEREFERENCE_CONNECTION_COUNT_ENTRY(pConEntry);

            //
            // We do not increment the connection here yet, since the AcceptConnection
            // will decide and do that.
            //

            REFERENCE_CONNECTION_COUNT_ENTRY(pCIEntry);
            pConnection->pConnectionCountEntry = pCIEntry;
        }
        else
        {
            //
            // There was an old entry, that means this connection already got through.
            // And the entry hasn't been changed with this new request.
            // No need to check again, our design is not forcing existing connections
            // to disconnect.
            //

            return TRUE;
        }
    }
    else
    {
        REFERENCE_CONNECTION_COUNT_ENTRY(pCIEntry);
        pConnection->pConnectionCountEntry = pCIEntry;
    }

    Accept = UlAcceptConnection(
                &pConnection->pConnectionCountEntry->MaxConnections,
                &pConnection->pConnectionCountEntry->CurConnections
                );

    if (Accept == FALSE)
    {
        // We are going to refuse. Let our ref & refcount go  away
        // on the connection entry to prevent the possible incorrect
        // decrement in the UlConnectionDestroyedWorker. If refused
        // current connection hasn't been incremented in the accept
        // connection. Perf counters also depends on the fact  that
        // pConnectionCountEntry will be Null when con got  refused

        DEREFERENCE_CONNECTION_COUNT_ENTRY(pConnection->pConnectionCountEntry);
        pConnection->pConnectionCountEntry = NULL;
    }

    return Accept;

} // UlCheckSiteConnectionLimit


/***************************************************************************++

Routine Description:

    Allocate a request opaque ID.

Return Value:

    NT_SUCCESS

--***************************************************************************/

NTSTATUS
UlAllocateRequestId(
    IN PUL_INTERNAL_REQUEST pRequest
    )
{
    PUL_HTTP_CONNECTION pConnection;
    KIRQL OldIrql;

    PAGED_CODE();

    pConnection = pRequest->pHttpConn;

    UlAcquireSpinLock(&pConnection->RequestIdSpinLock, &OldIrql);
    pConnection->pRequestIdContext = pRequest;
    UlReleaseSpinLock(&pConnection->RequestIdSpinLock, OldIrql);

    pRequest->RequestId = pConnection->ConnectionId;

    UL_REFERENCE_INTERNAL_REQUEST(pRequest);
    pRequest->RequestIdCopy = pRequest->RequestId;

    return STATUS_SUCCESS;
}


/***************************************************************************++

Routine Description:

    Free a request opaque ID.

Return Value:

    VOID

--***************************************************************************/

VOID
UlFreeRequestId(
    IN PUL_INTERNAL_REQUEST pRequest
    )
{
    PUL_HTTP_CONNECTION pConnection;
    KIRQL OldIrql;

    pConnection = pRequest->pHttpConn;

    UlAcquireSpinLock(&pConnection->RequestIdSpinLock, &OldIrql);
    pConnection->pRequestIdContext = NULL;
    UlReleaseSpinLock(&pConnection->RequestIdSpinLock, OldIrql);

    return;
}


/***************************************************************************++

Routine Description:

    Get a request from the connection opaque ID.

Return Value:

    PUL_INTERNAL_REQUEST

--***************************************************************************/

PUL_INTERNAL_REQUEST
UlGetRequestFromId(
    IN HTTP_REQUEST_ID RequestId,
    IN PUL_APP_POOL_PROCESS pProcess
    )
{
    PUL_HTTP_CONNECTION pConnection;
    PUL_INTERNAL_REQUEST pRequest;
    KIRQL OldIrql;

    pConnection = UlGetConnectionFromId(RequestId);

    if (pConnection != NULL)
    {
        UlAcquireSpinLock(&pConnection->RequestIdSpinLock, &OldIrql);

        pRequest = pConnection->pRequestIdContext;

        if (pRequest != NULL)
        {
            //
            // Check to make sure the user that is asking for the request
            // comes from the same process we have delivered the request.
            //

            if (pRequest->AppPool.pProcess == pProcess)
            {
                UL_REFERENCE_INTERNAL_REQUEST(pRequest);
            }
            else
            {
                pRequest = NULL;
            }
        }

        UlReleaseSpinLock(&pConnection->RequestIdSpinLock, OldIrql);

        //
        // Release the reference added by UlGetConnectionFromId.
        //

        UL_DEREFERENCE_HTTP_CONNECTION(pConnection);

        return pRequest;
    }

    return NULL;
}


/***************************************************************************++

Routine Description:

    Check if the pHttpConnection is associated with pListeningContext.

Return value:

    TRUE if match or FALSE

--***************************************************************************/

BOOLEAN
UlPurgeListeningEndpoint(
    IN PUL_HTTP_CONNECTION  pHttpConnection,
    IN PVOID                pListeningContext
    )
{
    ASSERT(pHttpConnection->pConnection->pListeningContext);

    if (pListeningContext == pHttpConnection->pConnection->pListeningContext)
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


/***************************************************************************++

Routine Description:

    Check if the pHttpConnection is associated with pProcessContext.

Return value:

    TRUE if match or FALSE

--***************************************************************************/

BOOLEAN
UlPurgeAppPoolProcess(
    IN PUL_HTTP_CONNECTION  pHttpConnection,
    IN PVOID                pProcessContext
    )
{
    ASSERT(pHttpConnection->pAppPoolProcess);

    if (pProcessContext == pHttpConnection->pAppPoolProcess)
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


/***************************************************************************++

Routine Description:

    Gracefully close a connection.

Return value:

    None

--***************************************************************************/

NTSTATUS
UlDisconnectHttpConnection(
    IN PUL_HTTP_CONNECTION      pHttpConnection,
    IN PUL_COMPLETION_ROUTINE   pCompletionRoutine,
    IN PVOID                    pCompletionContext
    )
{
    PUL_TIMEOUT_INFO_ENTRY  pTimeoutInfo;
    KIRQL                   OldIrql;

    //
    // Start the Idle timer (do not wait forever for FIN).
    //

    ASSERT(UL_IS_VALID_HTTP_CONNECTION(pHttpConnection));

    pTimeoutInfo = &pHttpConnection->TimeoutInfo;

    UlAcquireSpinLock(&pTimeoutInfo->Lock, &OldIrql);

    if (UlIsConnectionTimerOff(pTimeoutInfo, TimerConnectionIdle))
    {
        UlSetConnectionTimer(pTimeoutInfo, TimerConnectionIdle);
    }

    UlReleaseSpinLock(&pTimeoutInfo->Lock, OldIrql);

    UlEvaluateTimerState(pTimeoutInfo);

    return UlCloseConnection(
                pHttpConnection->pConnection,
                FALSE,
                pCompletionRoutine,
                pCompletionContext
                );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\httprcv.h ===
/*++

Copyright (c) 1998-2002 Microsoft Corporation

Module Name:

    httprcv.h

Abstract:

    Contains public http receive declarations.

Author:

    Henry Sanders (henrysa)       10-Jun-1998

Revision History:

--*/

#ifndef _HTTPRCV_H_
#define _HTTPRCV_H_


BOOLEAN
UlConnectionRequest(
    IN PVOID pListeningContext,
    IN PUL_CONNECTION pConnection,
    IN PTRANSPORT_ADDRESS pRemoteAddress,
    IN ULONG RemoteAddressLength,
    OUT PVOID *ppConnectionContext
    );

VOID
UlConnectionComplete(
    IN PVOID pListeningContext,
    IN PVOID pConnectionContext,
    IN NTSTATUS Status
    );

VOID
UlConnectionDisconnect(
    IN PVOID pListeningContext,
    IN PVOID pConnectionContext
    );

VOID
UlConnectionDisconnectComplete(
    IN PVOID pListeningContext,
    IN PVOID pConnectionContext
    );

VOID
UlConnectionDestroyed(
    IN PVOID pListeningContext,
    IN PVOID pConnectionContext
    );

NTSTATUS
UlHttpReceive(
    IN PVOID pListeningContext,
    IN PVOID pConnectionContext,
    IN PVOID pVoidBuffer,
    IN ULONG BufferLength,
    IN ULONG UnreceivedLength,
    OUT PULONG pBytesTaken
    );

NTSTATUS
UlReceiveEntityBody(
    IN PUL_APP_POOL_PROCESS pProcess,
    IN PUL_INTERNAL_REQUEST pRequest,
    IN PIRP pIrp
    );

VOID
UlProcessBufferQueue(
    IN PUL_INTERNAL_REQUEST pRequest,
    IN PUCHAR pEntityBody OPTIONAL,
    IN ULONG EntityBodyLength OPTIONAL
    );

VOID
UlResumeParsing(
    IN PUL_HTTP_CONNECTION pConnection,
    IN BOOLEAN FromCache,
    IN BOOLEAN InDisconnect
    );

NTSTATUS
UlCheckProtocolCompliance(
    IN PUL_INTERNAL_REQUEST pRequest
    );

NTSTATUS
UlGetCGroupForRequest(
    IN PUL_INTERNAL_REQUEST pRequest
    );

VOID
UlSendErrorResponse(
    IN PUL_HTTP_CONNECTION pConnection
    );

ULONG
UlSendSimpleStatus(
    PUL_INTERNAL_REQUEST pRequest,
    UL_HTTP_SIMPLE_STATUS Response
    );

ULONG
UlSendSimpleStatusEx(
    PUL_INTERNAL_REQUEST pRequest,
    UL_HTTP_SIMPLE_STATUS Response,
    PUL_URI_CACHE_ENTRY pUriCacheEntry OPTIONAL,
    BOOLEAN ResumeParsing
    );

VOID
UlSetErrorCodeFileLine(
    IN OUT  PUL_INTERNAL_REQUEST pRequest,
    IN      UL_HTTP_ERROR        ErrorCode,
    IN      PUL_APP_POOL_OBJECT  pAppPool,
    IN      PCSTR                pFileName,
    IN      USHORT               LineNumber
    );

#define UlSetErrorCode(pRequest, ErrorCode, pAppPool)               \
    UlSetErrorCodeFileLine((pRequest), (ErrorCode), (pAppPool),     \
                           (PCSTR) __FILE__, (USHORT) __LINE__)

VOID
UlErrorLog(
    IN     PUL_HTTP_CONNECTION     pHttpConn,
    IN     PUL_INTERNAL_REQUEST    pRequest,        // OPTIONAL   
    IN     PCHAR                   pInfo,
    IN     USHORT                  InfoSize,
    IN     BOOLEAN                 CheckIfDropped
    );

#endif // _HTTPRCV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\httptdi.c ===
/*++

Copyright (c) 2000-2002 Microsoft Corporation

Module Name:

    httptdi.c

Abstract:

    This module implements the TDI/MUX/SSL component that is common between
    ultdi and uctdi

Author:

    Rajesh Sundaram (rajeshsu)

Revision History:

--*/


#include "precomp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, UxInitializeTdi )
#pragma alloc_text( PAGE, UxTerminateTdi )
#pragma alloc_text( PAGE, UxOpenTdiAddressObject )
#pragma alloc_text( PAGE, UxOpenTdiConnectionObject )
#pragma alloc_text( PAGE, UxpOpenTdiObjectHelper )
#pragma alloc_text( PAGE, UxSetEventHandler )

#endif

#if 0

NOT PAGEABLE - UxCreateDisconnectIrp
NOT PAGEABLE - UxInitializeDisconnectIrp

#endif

//
// Timeout for disconnects. This cannot be a stack-based local,
// so we make it a global.
//
BOOLEAN         g_UxTdiInitialized;

UNICODE_STRING  g_TCPDeviceName;  // global transport device name (IP)
UNICODE_STRING  g_TCP6DeviceName;  // global transport device name (IPv6)

LARGE_INTEGER   g_TdiDisconnectTimeout;

/***************************************************************************++

Routine Description:

    Performs global initialization of this module.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UxInitializeTdi(
    VOID
    )
{
    NTSTATUS status = STATUS_SUCCESS;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT( !g_UxTdiInitialized );

    status = UlInitUnicodeStringEx(&g_TCPDeviceName, DD_TCP_DEVICE_NAME);

    if (NT_SUCCESS(status))
    {
        status = UlInitUnicodeStringEx(&g_TCP6DeviceName, DD_TCPV6_DEVICE_NAME);
    }

    if (NT_SUCCESS(status))
    {    
        g_TdiDisconnectTimeout = RtlConvertLongToLargeInteger( -1 );

        g_UxTdiInitialized = TRUE;
    }

    return status;

}

/***************************************************************************++

Routine Description:

    Performs global termination of this module.

--***************************************************************************/
VOID
UxTerminateTdi(
    VOID
    )
{
    //
    // Sanity check.
    //

    PAGED_CODE();

    if (g_UxTdiInitialized)
    {
    }

}   // UxTerminateTdi


/***************************************************************************++

Routine Description:

    Opens a TDI address object.

Arguments:

    pTransportDeviceName - Supplies the device name of the TDI transport
        to open.

    pLocalAddress - Supplies the local address to bind to.

    LocalAddressLength - Supplies the length of pLocalAddress.

    pTdiObject - Receives the file handle, referenced FILE_OBJECT
        pointer, and corresponding DEVICE_OBJECT pointer.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UxOpenTdiAddressObject(
    IN PTRANSPORT_ADDRESS pLocalAddress,
    IN ULONG LocalAddressLength,
    OUT PUX_TDI_OBJECT pTdiObject
    )
{
    NTSTATUS status;
    PFILE_FULL_EA_INFORMATION pEaInfo;
    ULONG eaLength;
    UCHAR eaBuffer[MAX_ADDRESS_EA_BUFFER_LENGTH];
    PUNICODE_STRING pTransportDeviceName;

    //
    // Sanity check.
    //

    PAGED_CODE();

    eaLength = sizeof(FILE_FULL_EA_INFORMATION) - 1 +
        TDI_TRANSPORT_ADDRESS_LENGTH + 1 +
        LocalAddressLength;

    ASSERT( eaLength <= sizeof(eaBuffer) );

    ASSERT( LocalAddressLength == sizeof(TA_IP_ADDRESS) ||
            LocalAddressLength == sizeof(TA_IP6_ADDRESS));

    ASSERT( pLocalAddress->TAAddressCount == 1 );

    ASSERT( pLocalAddress->Address[0].AddressLength == sizeof(TDI_ADDRESS_IP)
        || pLocalAddress->Address[0].AddressLength == sizeof(TDI_ADDRESS_IP6));

    ASSERT( pLocalAddress->Address[0].AddressType == TDI_ADDRESS_TYPE_IP 
        ||  pLocalAddress->Address[0].AddressType == TDI_ADDRESS_TYPE_IP6);

    //
    // Initialize the EA buffer. See UxpOpenTdiObjectHelper() for the
    // gory details.
    //

    pEaInfo = (PFILE_FULL_EA_INFORMATION)eaBuffer;

    pEaInfo->NextEntryOffset = 0;
    pEaInfo->Flags = 0;
    pEaInfo->EaNameLength = TDI_TRANSPORT_ADDRESS_LENGTH;
    pEaInfo->EaValueLength = (USHORT)LocalAddressLength;

    RtlMoveMemory(
        pEaInfo->EaName,
        TdiTransportAddress,
        pEaInfo->EaNameLength + 1
        );

    RtlMoveMemory(
        &pEaInfo->EaName[pEaInfo->EaNameLength + 1],
        pLocalAddress,
        LocalAddressLength
        );

    //
    // Initialize pTransportDeviceName
    //
    pTransportDeviceName = 
        (pLocalAddress->Address[0].AddressType == TDI_ADDRESS_TYPE_IP)?
        &g_TCPDeviceName : &g_TCP6DeviceName;

    //
    // Let the helper do the dirty work.
    //

    status = UxpOpenTdiObjectHelper(
                    pTransportDeviceName,
                    eaBuffer,
                    eaLength,
                    pTdiObject
                    );

    if (NT_SUCCESS(status))
    {
        //
        // Enable Optimize for Interrupt Moderation if needed
        //

        if ( DEFAULT_OPT_FOR_INTR_MOD != g_UlOptForIntrMod )
        {
            status = UlpOptimizeForInterruptModeration( pTdiObject, g_UlOptForIntrMod );

            if (!NT_SUCCESS(status))
            {
                UxCloseTdiObject( pTdiObject );
            }
        }
    }

    return status;

}   // UxpOpenTdiAddressObject


/***************************************************************************++

Routine Description:

    Opens a TDI connection object.

Arguments:

    pTransportDeviceName - Supplies the device name of the TDI transport
        to open.

    pConnectionContext - Supplies the context to associate with the
        new connection.

    pTdiObject - Receives the file handle, referenced FILE_OBJECT
        pointer, and corresponding DEVICE_OBJECT pointer.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UxOpenTdiConnectionObject(
    IN USHORT AddressType,
    IN CONNECTION_CONTEXT pConnectionContext,
    OUT PUX_TDI_OBJECT pTdiObject
    )
{
    NTSTATUS status;
    PFILE_FULL_EA_INFORMATION pEaInfo;
    ULONG eaLength;
    UCHAR eaBuffer[MAX_CONNECTION_EA_BUFFER_LENGTH];
    PUNICODE_STRING pTransportDeviceName;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(AddressType == TDI_ADDRESS_TYPE_IP ||
           AddressType == TDI_ADDRESS_TYPE_IP6);

    pTransportDeviceName = (AddressType == TDI_ADDRESS_TYPE_IP)?
                               &g_TCPDeviceName : &g_TCP6DeviceName;


    eaLength = sizeof(FILE_FULL_EA_INFORMATION) - 1 +
        TDI_CONNECTION_CONTEXT_LENGTH + 1 +
        sizeof(pConnectionContext);

    ASSERT( eaLength <= sizeof(eaBuffer) );
    ASSERT( pConnectionContext != NULL );

    //
    // Initialize the EA buffer. See UxpOpenTdiObjectHelper() for the
    // gory details.
    //

    pEaInfo = (PFILE_FULL_EA_INFORMATION)eaBuffer;

    pEaInfo->NextEntryOffset = 0;
    pEaInfo->Flags = 0;
    pEaInfo->EaNameLength = TDI_CONNECTION_CONTEXT_LENGTH;
    pEaInfo->EaValueLength = (USHORT)sizeof(CONNECTION_CONTEXT);

    RtlMoveMemory(
        pEaInfo->EaName,
        TdiConnectionContext,
        pEaInfo->EaNameLength + 1
        );

    RtlMoveMemory(
        &pEaInfo->EaName[pEaInfo->EaNameLength + 1],
        &pConnectionContext,
        sizeof(pConnectionContext)
        );

    //
    // Let the helper do the dirty work.
    //

    status = UxpOpenTdiObjectHelper(
                    pTransportDeviceName,
                    eaBuffer,
                    eaLength,
                    pTdiObject
                    );

    if (NT_SUCCESS(status))
    {
        //
        // Enable/disable Nagle's Algorithm as appropriate.
        //

        status = UlpSetNagling( pTdiObject, g_UlEnableNagling );

        if (!NT_SUCCESS(status))
        {
            UxCloseTdiObject( pTdiObject );
        }
    }

    return status;

}   // UxpOpenTdiConnectionObject


/***************************************************************************++

Routine Description:

    Helper routine for UxpOpenTdiAddressObject and
    UxpOpenTdiConnectionObject.

Arguments:

    pTransportDeviceName - Supplies the device name of the TDI transport
        to open.

    pEaBuffer - Supplies a pointer to the EA to use when opening
        the object. This buffer consists of a FILE_FULL_EA_INFORMATION
        structure, followed by the EA Name, followed by the EA Value.
        The EA Name and Value are use as follows:

            Address Object:
                Ea Name  = TdiTransportAddress ("TransportAddress")
                Ea Value = The local TRANSPORT_ADDRESS to bind to

            Connection Object:
                Ea Name  = TdiConnectionContext ("ConnectionContext")
                Ea Value = The connection context (basically a PVOID)

    EaLength - Supplies the length of pEaBuffer.

    pTdiObject - Receives the file handle, referenced FILE_OBJECT
        pointer, and corresponding DEVICE_OBJECT pointer.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UxpOpenTdiObjectHelper(
    IN PUNICODE_STRING pTransportDeviceName,
    IN PVOID pEaBuffer,
    IN ULONG EaLength,
    OUT PUX_TDI_OBJECT pTdiObject
    )
{
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatusBlock;
    OBJECT_ATTRIBUTES objectAttributes;

    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // Open the TDI object.
    //

    InitializeObjectAttributes(
        &objectAttributes,                      // ObjectAttributes
        pTransportDeviceName,                   // ObjectName
        OBJ_CASE_INSENSITIVE |                  // Attributes
            OBJ_KERNEL_HANDLE,
        NULL,                                   // RootHandle
        NULL                                    // SecurityDescriptor
        );

    status = IoCreateFile(
                 &pTdiObject->Handle,           // FileHandle
                 GENERIC_READ |                 // DesiredAccess
                    GENERIC_WRITE |
                    SYNCHRONIZE,
                 &objectAttributes,             // ObjectAttributes
                 &ioStatusBlock,                // IoStatusBlock
                 NULL,                          // AllocationSize
                 0,                             // FileAttributes
                 0,                             // ShareAccess
                 0,                             // Disposition
                 0,                             // CreateOptions
                 pEaBuffer,                     // EaBuffer
                 EaLength,                      // EaLength
                 CreateFileTypeNone,            // CreateFileType
                 NULL,                          // ExtraCreateParameters
                 IO_NO_PARAMETER_CHECKING       // Options
                 );

    if (NT_SUCCESS(status))
    {
        //
        // Now that we have an open handle to the transport,
        // reference it so we can get the file & device object
        // pointers.
        //

        status = ObReferenceObjectByHandle(
                     pTdiObject->Handle,                // Handle
                     FILE_READ_ACCESS,                  // DesiredAccess
                     *IoFileObjectType,                 // ObjectType
                     KernelMode,                        // AccessMode
                     (PVOID *)&pTdiObject->pFileObject, // Object
                     NULL                               // HandleInformation
                     );

        if (NT_SUCCESS(status))
        {
            //
            // Chase down the appropriate device object for the file
            // object.
            //

            pTdiObject->pDeviceObject =
                IoGetRelatedDeviceObject( pTdiObject->pFileObject );

            return status;
        }

        //
        // The ObReferenceObjectByHandle() failed, so close the handle
        // we managed to open & fail the call.
        //

        ZwClose( pTdiObject->Handle );
    }

    RtlZeroMemory(
        pTdiObject,
        sizeof(*pTdiObject)
        );

    return status;

}   // UxpOpenTdiObjectHelper

/***************************************************************************++

Routine Description:

    Establishes a TDI event handler for the specified endpoint.

Arguments:

    pEndpoint - Supplies the endpoint for which to set the event handler.

    EventType - Supplies the type of event to set. This should be one
        of the TDI_EVENT_* values.

    pEventHandler - Supplies a pointer to the indication handler function
        to be invoked for the specified event type.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UxSetEventHandler(
    IN PUX_TDI_OBJECT  pUlTdiObject,
    IN ULONG           EventType,
    IN ULONG_PTR       pEventHandler,
    IN PVOID           pEventContext

    )
{
    NTSTATUS                     status;
    TDI_REQUEST_KERNEL_SET_EVENT eventParams;

    //
    // Sanity check.
    //
    PAGED_CODE();

    //
    // Build the parameter block.
    //

    eventParams.EventType    = EventType;
    eventParams.EventHandler = (PVOID) pEventHandler;
    eventParams.EventContext = pEventContext;

    //
    // Make the call.
    //

    status = UlIssueDeviceControl(
                    pUlTdiObject,               // pTdiObject
                    &eventParams,               // pIrpParameters
                    sizeof(eventParams),        // IrpParamtersLength
                    NULL,                       // pMdlBuffer
                    0,                          // MdlBufferLength
                    TDI_SET_EVENT_HANDLER       // MinorFunction
                    );

    return status;

}   // UxSetEventHandler

/***************************************************************************++

Routine Description:

    Allocates & initializes a new disconnect IRP.

Arguments:

    pConnection - Supplies the UC_CONNECTION to be disconnected.

    Flags - Supplies the TDI_DISCONNECT_* flags for the IRP.

    pCompletionRoutine - Supplies the completion routine for the IRP.

    pCompletionContext - Supplies an uninterpreted context for the
        completion routine.

Return Value:

    PIRP - Pointer to the IRP if successful, NULL otherwise.

--***************************************************************************/
PIRP
UxCreateDisconnectIrp(
    IN PUX_TDI_OBJECT         pTdiObject,
    IN ULONG_PTR              Flags,
    IN PIO_COMPLETION_ROUTINE pCompletionRoutine,
    IN PVOID                  pCompletionContext
    )
{
    PIRP pIrp;

    ASSERT( IS_VALID_TDI_OBJECT( pTdiObject ) );

    //
    // Allocate an IRP for the disconnect.
    //

    pIrp = UlAllocateIrp(
                pTdiObject->pDeviceObject->StackSize,   // StackSize
                FALSE                                   // ChargeQuota
                );

    if (pIrp != NULL)
    {
        UxInitializeDisconnectIrp(
            pIrp,
            pTdiObject,
            Flags,
            pCompletionRoutine,
            pCompletionContext
            );
    }

    return pIrp;

}   // UxCreateDisconnectIrp

/***************************************************************************++

Routine Description:

    Initializes a disconnect IRP.

Arguments:

    pIrp - Supplies the disconnect IRP.

    pConnection - Supplies the UC_CONNECTION to be disconnected.

    Flags - Supplies the TDI_DISCONNECT_* flags for the IRP.

    pCompletionRoutine - Supplies the completion routine for the IRP.

    pCompletionContext - Supplies an uninterpreted context for the
        completion routine.

Return Value:

    None

--***************************************************************************/
VOID
UxInitializeDisconnectIrp(
    IN PIRP                   pIrp,
    IN PUX_TDI_OBJECT         pTdiObject,
    IN ULONG_PTR              Flags,
    IN PIO_COMPLETION_ROUTINE pCompletionRoutine,
    IN PVOID                  pCompletionContext
    )
{
    ASSERT( IS_VALID_TDI_OBJECT( pTdiObject ) );
    ASSERT( pIrp != NULL );

    //
    // Initialize the IRP. Note that IRPs are always zero-initialized
    // when allocated. Therefore, we don't need to explicitly set
    // the zeroed fields.
    //

    pIrp->RequestorMode = KernelMode;

    pIrp->Tail.Overlay.Thread = PsGetCurrentThread();
    pIrp->Tail.Overlay.OriginalFileObject = pTdiObject->pFileObject;

    TdiBuildDisconnect(
        pIrp,                               // Irp
        pTdiObject->pDeviceObject,          // DeviceObject
        pTdiObject->pFileObject,            // FileObject
        pCompletionRoutine,                 // CompletionRoutine
        pCompletionContext,                 // CompletionContext
        &g_TdiDisconnectTimeout,            // Timeout
        Flags,                              // Flags
        NULL,                               // RequestConnectionInfo
        NULL                                // ReturnConnectionInfo
        );

}   // UxInitializeDisconnectIrp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\httprcvp.h ===
/*++

Copyright (c) 2000-2002 Microsoft Corporation

Module Name:

    httprcvp.h

Abstract:

    Contains private http receive declarations.

Author:

    Henry Sanders (henrysa)       10-Jun-1998

Revision History:

--*/

#ifndef _HTTPRCVP_H_
#define _HTTPRCVP_H_


VOID
UlpHandleRequest(
    IN PUL_WORK_ITEM pWorkItem
    );

VOID
UlpFreeReceiveBufferList(
    IN PSLIST_ENTRY pBufferList
    );

NTSTATUS
UlpParseNextRequest(
    IN PUL_HTTP_CONNECTION pConnection,
    IN BOOLEAN MoreRequestBuffer,
    OUT PIRP *pIrpToComplete
    );

NTSTATUS
UlpDeliverHttpRequest(
    IN PUL_HTTP_CONNECTION pConnection,
    OUT PBOOLEAN pResumeParsing,
    OUT PIRP *pIrpToComplete
    );

VOID
UlpInsertBuffer(
    IN PUL_HTTP_CONNECTION pConnection,
    IN PUL_REQUEST_BUFFER pRequestBuffer
    );

VOID
UlpMergeBuffers(
    IN PUL_REQUEST_BUFFER pDest,
    IN PUL_REQUEST_BUFFER pSrc
    );

NTSTATUS
UlpAdjustBuffers(
    IN PUL_HTTP_CONNECTION pConnection
    );

VOID
UlpCancelEntityBody(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    );

VOID
UlpCancelEntityBodyWorker(
    IN PUL_WORK_ITEM pWorkItem
    );

NTSTATUS
UlpHandle503Response(
    IN PUL_INTERNAL_REQUEST pRequest,
    IN PHTTP_RESPONSE       pResponse
    );

VOID
UlpCompleteSendErrorResponse(
    IN PVOID pCompletionContext,
    IN NTSTATUS Status,
    IN ULONG_PTR Information
    );

VOID
UlpRestartSendSimpleStatus(
    IN PVOID pCompletionContext,
    IN NTSTATUS Status,
    IN ULONG_PTR Information
    );

VOID
UlpSendSimpleCleanupWorker(
    IN PUL_WORK_ITEM pWorkItem
    );

VOID
UlpConsumeBytesFromConnection(
    IN PUL_HTTP_CONNECTION pConnection,
    IN ULONG ByteCount
    );

VOID
UlpRestartHttpReceive(
    IN PVOID pContext,
    IN NTSTATUS Status,
    IN ULONG_PTR Information
    );

VOID
UlpDiscardBytesFromConnection(
    IN PUL_HTTP_CONNECTION pConnection
    );

VOID
UlpConnectionDisconnectWorker(
    IN PUL_WORK_ITEM pWorkItem
    );

VOID
UlpCloseConnectionWorker(
    IN PUL_WORK_ITEM pWorkItem
    );

VOID
UlpCloseDisconnectedConnection(
    IN PUL_HTTP_CONNECTION pConnection
    );

VOID
UlpConnectionDisconnectCompleteWorker(
    IN PUL_WORK_ITEM pWorkItem
    );

VOID
UlpDoConnectionDisconnect(
    IN PUL_HTTP_CONNECTION pConnection
    );

#if DBG
BOOLEAN
UlpIsValidRequestBufferList(
    IN PUL_HTTP_CONNECTION pHttpConn
    );
#endif // DBG

#define ALLOC_REQUEST_BUFFER_INCREMENT  5

BOOLEAN
UlpReferenceBuffers(
    IN PUL_INTERNAL_REQUEST pRequest,
    IN PUL_REQUEST_BUFFER pRequestBuffer
    );

VOID
UlpInitErrorLogInfo(
    IN OUT PUL_ERROR_LOG_INFO      pErrorLogInfo,
    IN     PUL_HTTP_CONNECTION     pHttpConn,
    IN     PUL_INTERNAL_REQUEST    pRequest,
    IN     PCHAR                   pInfo,
    IN     USHORT                  InfoSize    
    );

#endif // _HTTPRCVP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\httptdi.h ===
/*++

Copyright (c) 2001-2002 Microsoft Corporation

Module Name:

    httptdi.h

Abstract:

    Declarations for the TDI/MUX/SSL component that is common between
    ultdi and uctdi

Author:

    Rajesh Sundaram (rajeshsu)

Revision History:

--*/

#ifndef _HTTPTDI_H
#define _HTTPTDI_H


#define IS_VALID_TDI_OBJECT( pobj )                                         \
    ( ( (pobj)->Handle != NULL ) &&                                         \
      ( (pobj)->pFileObject != NULL ) &&                                    \
      ( (pobj)->pDeviceObject != NULL ) )

#define UxCloseTdiObject( pTdiObject )                                     \
    do                                                                      \
    {                                                                       \
        if ((pTdiObject)->pFileObject != NULL)                              \
        {                                                                   \
            ObDereferenceObject( (pTdiObject)->pFileObject );               \
            (pTdiObject)->pFileObject = NULL;                               \
        }                                                                   \
                                                                            \
        if ((pTdiObject)->Handle != NULL)                                   \
        {                                                                   \
            ZwClose( (pTdiObject)->Handle );                    \
            (pTdiObject)->Handle = NULL;                                    \
        }                                                                   \
    } while (0, 0)


//
// A wrapper around a TDI object handle, with a pre-referenced
// FILE_OBJECT pointer and the corresponding DEVICE_OBJECT pointer.
//

typedef struct _UX_TDI_OBJECT
{
    HANDLE Handle;
    PFILE_OBJECT pFileObject;
    PDEVICE_OBJECT pDeviceObject;

} UX_TDI_OBJECT, *PUX_TDI_OBJECT;

NTSTATUS
UxInitializeTdi(
    VOID
    );

VOID
UxTerminateTdi(
    VOID
    );

NTSTATUS
UxOpenTdiAddressObject(
    IN PTRANSPORT_ADDRESS pLocalAddress,
    IN ULONG LocalAddressLength,
    OUT PUX_TDI_OBJECT pTdiObject
    );

NTSTATUS
UxOpenTdiConnectionObject(
    IN USHORT AddressType,
    IN CONNECTION_CONTEXT pConnectionContext,
    OUT PUX_TDI_OBJECT pTdiObject
    );

NTSTATUS
UxpOpenTdiObjectHelper(
    IN PUNICODE_STRING pTransportDeviceName,
    IN PVOID pEaBuffer,
    IN ULONG EaLength,
    OUT PUX_TDI_OBJECT pTdiObject
    );


NTSTATUS
UxSetEventHandler(
    IN PUX_TDI_OBJECT  pUlTdiObject,
    IN ULONG           EventType,
    IN ULONG_PTR       pEventHandler,
    IN PVOID           pEventContext
    );

PIRP
UxCreateDisconnectIrp(
    IN PUX_TDI_OBJECT pTdiObject,
    IN ULONG_PTR Flags,
    IN PIO_COMPLETION_ROUTINE pCompletionRoutine,
    IN PVOID pCompletionContext
    );

VOID
UxInitializeDisconnectIrp(
    IN PIRP pIrp,
    IN PUX_TDI_OBJECT pTdiObject,
    IN ULONG_PTR Flags,
    IN PIO_COMPLETION_ROUTINE pCompletionRoutine,
    IN PVOID pCompletionContext
    );


#endif // _HTTPTDI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\httpconnp.h ===
/*++

Copyright (c) 2000-2002 Microsoft Corporation

Module Name:

    httpconnp.h

Abstract:

    This module contains private declarations for manipulation of
    HTTP_CONNECTION objects.

Author:

    Eric Stenson (ericsten)       01-Nov-2000

Revision History:

--*/

#ifndef __HTTPCONNP_H__
#define __HTTPCONNP_H__

//
// private types
//

#define ERROR_LOG_INFO_FOR_ZOMBIE_DROP       "Connection_Dropped"
#define ERROR_LOG_INFO_FOR_ZOMBIE_DROP_SIZE  \
            (sizeof(ERROR_LOG_INFO_FOR_ZOMBIE_DROP) - sizeof(CHAR))

//
// for binding connections to app pool processes
//

#define IS_VALID_PROC_BINDING(pObject) \
    HAS_VALID_SIGNATURE(pObject, UL_APOOL_PROC_BINDING_POOL_TAG)

typedef struct _UL_APOOL_PROC_BINDING
{
    ULONG                   Signature;      // UL_APOOL_PROC_BINDING_POOL_TAG
    LIST_ENTRY              BindingEntry;

    PUL_APP_POOL_OBJECT     pAppPool;
    PUL_APP_POOL_PROCESS    pProcess;
} UL_APOOL_PROC_BINDING, *PUL_APOOL_PROC_BINDING;


//
// Private prototypes.
//

VOID
UlpSetZombieTimer(
    VOID
    );

VOID
UlpTerminateZombieList(
    VOID
    );

NTSTATUS
UlpZombifyHttpConnection(
    IN PUL_HTTP_CONNECTION pHttpConnection
    );

VOID
UlpZombieTimerWorker(
    IN PUL_WORK_ITEM pWorkItem
    );

VOID
UlpRemoveZombieHttpConnection(
    IN PUL_HTTP_CONNECTION pHttpConnection
    );

VOID
UlpCleanupZombieHttpConnection(
    IN PUL_HTTP_CONNECTION pHttpConnection
    );


PUL_APOOL_PROC_BINDING
UlpCreateProcBinding(
    IN PUL_APP_POOL_OBJECT pAppPool,
    IN PUL_APP_POOL_PROCESS pProcess
    );

VOID
UlpFreeProcBinding(
    IN PUL_APOOL_PROC_BINDING pBinding
    );

PUL_APOOL_PROC_BINDING
UlpFindProcBinding(
    IN PUL_HTTP_CONNECTION pHttpConnection,
    IN PUL_APP_POOL_OBJECT pAppPool
    );


#endif // __HTTPCONNP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\httpconn.h ===
/*++

Copyright (c) 1998-2002 Microsoft Corporation

Module Name:

    httpconn.h

Abstract:

    This module contains declarations for manipulation HTTP_CONNECTION
    objects.

Author:

    Keith Moore (keithmo)       08-Jul-1998

Revision History:

--*/

/*

there is a bit of refcount madness going on.  basically, these are the
object we have.

OPAQUE_ID_TABLE

    |
    |-->    UL_INTERNAL_REQUEST
    |
    |           o
    |           |
    |-->    UL_HTTP_CONNECTION
                    |
                    o
                o
                |
            UL_CONNECTION


there is a circular reference from UL_CONNECTION to UL_HTTP_CONNECTION.

the chain that brings down a connection starts with UlConnectionDestroyed
notifcation which releases the reference from the UL_CONNECTION.

at this time the opaque id's are also deleted, releasing their references.

when the http_connection refcount hits 0, it releases the reference on the
UL_CONNECTION and the HTTP_REQUEST's.

poof.  everyone is gone now.


CODEWORK:  think about making hardref's everywhere and adding "letgo"
terminate methods


*/

#ifndef _HTTPCONN_H_
#define _HTTPCONN_H_


//
// Zombie connection timer period in seconds. A zombie connection
// may live; 30 < T < 60 seconds.
//

#define DEFAULT_ZOMBIE_HTTP_CONNECTION_TIMER_PERIOD_IN_SECONDS   (30)

typedef struct _UL_ZOMBIE_HTTP_CONNECTION_LIST 
{
    LOCKED_LIST_HEAD    LockList; 
        
    //
    // Private timer stuff.
    //
    
    KTIMER              Timer;
    KDPC                DpcObject;
    UL_SPIN_LOCK        TimerSpinLock;
    BOOLEAN             TimerInitialized; 
    UL_WORK_ITEM        WorkItem;
    LONG                TimerRunning;    
    
    #ifdef ENABLE_HTTP_CONN_STATS
    //
    // Http connection statistics.
    //
    ULONG   MaxZombieCount;
    ULONG   TotalCount;
    ULONG   TotalZombieCount;
    ULONG   TotalZombieRefusal;
    #endif
 
} UL_ZOMBIE_HTTP_CONNECTION_LIST, *PUL_ZOMBIE_HTTP_CONNECTION_LIST;

//
// Refcounted structure to hold the number of conn for each Site.
// Multiple connections may try to reach to the same entry thru the
// the corresponding ( means the last request's happening on the connection )
// cgroup. This entry get allocated when cgroup created with connection
// limit is enabled.
//

typedef struct _UL_CONNECTION_COUNT_ENTRY {

    //
    // Signature is UL_CONNECTION_COUNT_ENTRY_POOL_TAG
    //

    ULONG               Signature;

    //
    // Ref count for this Site Counter Entry
    //
    LONG                RefCount;

    //
    // Current number of connections
    //

    ULONG               CurConnections;

    //
    // Maximum allowed connections
    //

    ULONG               MaxConnections;

} UL_CONNECTION_COUNT_ENTRY, *PUL_CONNECTION_COUNT_ENTRY;

#define IS_VALID_CONNECTION_COUNT_ENTRY( entry )                            \
    HAS_VALID_SIGNATURE(entry, UL_CONNECTION_COUNT_ENTRY_POOL_TAG)

VOID
UlDereferenceConnectionCountEntry(
    IN PUL_CONNECTION_COUNT_ENTRY pEntry
    REFERENCE_DEBUG_FORMAL_PARAMS
    );

#define DEREFERENCE_CONNECTION_COUNT_ENTRY( pEntry )                        \
    UlDereferenceConnectionCountEntry(                                      \
    (pEntry)                                                                \
    REFERENCE_DEBUG_ACTUAL_PARAMS                                           \
    )

VOID
UlReferenceConnectionCountEntry(
    IN PUL_CONNECTION_COUNT_ENTRY pEntry
    REFERENCE_DEBUG_FORMAL_PARAMS
    );

#define REFERENCE_CONNECTION_COUNT_ENTRY( pEntry )                          \
    UlReferenceConnectionCountEntry(                                        \
    (pEntry)                                                                \
    REFERENCE_DEBUG_ACTUAL_PARAMS                                           \
    )

NTSTATUS
UlCreateConnectionCountEntry(
      IN OUT PUL_CONFIG_GROUP_OBJECT pConfigGroup,
      IN     ULONG                   MaxConnections
    );

ULONG
UlSetMaxConnections(
    IN OUT PULONG  pCurMaxConnection,
    IN     ULONG   NewMaxConnection
    );

ULONG 
UlGetGlobalConnectionLimit(
    VOID
    );

NTSTATUS
UlInitGlobalConnectionLimits(
    VOID
    );

BOOLEAN
UlAcceptConnection(
    IN     PULONG   pMaxConnection,
    IN OUT PULONG   pCurConnection
    );

LONG
UlDecrementConnections(
    IN OUT PULONG pCurConnection
    );

BOOLEAN
UlCheckSiteConnectionLimit(
    IN OUT PUL_HTTP_CONNECTION pConnection,
    IN OUT PUL_URL_CONFIG_GROUP_INFO pConfigInfo
    );

BOOLEAN
UlAcceptGlobalConnection(
    VOID
    );


//
// function prototypes
//

NTSTATUS
UlCreateHttpConnection(
    OUT PUL_HTTP_CONNECTION *ppHttpConnection,
    IN PUL_CONNECTION pConnection
    );

NTSTATUS
UlCreateHttpConnectionId(
    IN PUL_HTTP_CONNECTION pHttpConnection
    );

VOID
UlConnectionDestroyedWorker(
    IN PUL_WORK_ITEM pWorkItem
    );

NTSTATUS
UlBindConnectionToProcess(
    IN PUL_HTTP_CONNECTION pHttpConnection,
    IN PUL_APP_POOL_OBJECT pAppPool,
    IN PUL_APP_POOL_PROCESS pProcess
    );

PUL_APP_POOL_PROCESS
UlQueryProcessBinding(
    IN PUL_HTTP_CONNECTION pHttpConnection,
    IN PUL_APP_POOL_OBJECT pAppPool
    );

VOID
UlUnlinkHttpRequest(
    IN PUL_INTERNAL_REQUEST pRequest
    );

VOID
UlCleanupHttpConnection(
    IN PUL_HTTP_CONNECTION pHttpConnection
    );

VOID
UlDeleteHttpConnection(
    IN PUL_WORK_ITEM pWorkItem
    );

VOID
UlReferenceHttpConnection(
    IN PVOID pObject
    REFERENCE_DEBUG_FORMAL_PARAMS
    );

VOID
UlDereferenceHttpConnection(
    IN PUL_HTTP_CONNECTION pHttpConnection
    REFERENCE_DEBUG_FORMAL_PARAMS
    );

#if REFERENCE_DEBUG

#define UL_REFERENCE_HTTP_CONNECTION( pconn )                               \
    UlReferenceHttpConnection(                                              \
        (pconn)                                                             \
        REFERENCE_DEBUG_ACTUAL_PARAMS                                       \
        )

#define UL_DEREFERENCE_HTTP_CONNECTION( pconn )                             \
    UlDereferenceHttpConnection(                                            \
        (pconn)                                                             \
        REFERENCE_DEBUG_ACTUAL_PARAMS                                       \
        )

#else // !REFERENCE_DEBUG

#define UL_REFERENCE_HTTP_CONNECTION( pconn )                               \
    InterlockedIncrement( &( pconn )->RefCount )

#define UL_DEREFERENCE_HTTP_CONNECTION( pconn )                             \
    if ( InterlockedDecrement( &( pconn )->RefCount ) == 0 )                \
    {                                                                       \
        UL_CALL_PASSIVE(                                                    \
            &( ( pconn )->WorkItem ),                                       \
            &UlDeleteHttpConnection                                         \
        );                                                                  \
    } else

#endif // !REFERENCE_DEBUG


#define INIT_HTTP_REQUEST(pRequest)                                         \
do {                                                                        \
    pRequest->RefCount      = 1;                                            \
                                                                            \
    pRequest->ParseState    = ParseVerbState;                               \
                                                                            \
    InitializeListHead(   &pRequest->UnknownHeaderList );                   \
    InitializeListHead(   &pRequest->IrpHead );                             \
    InitializeListHead(   &pRequest->ResponseHead );                        \
    UlInitializeWorkItem( &pRequest->WorkItem );                            \
                                                                            \
    pRequest->HeadersAppended        = FALSE;                               \
                                                                            \
    pRequest->NextUnknownHeaderIndex = 0;                                   \
    pRequest->UnknownHeaderCount     = 0;                                   \
                                                                            \
    HTTP_SET_NULL_ID(&pRequest->RequestId);                                 \
                                                                            \
    pRequest->RequestIdCopy   = pRequest->RequestId;                        \
                                                                            \
    pRequest->HeaderIndex[0]  = HttpHeaderRequestMaximum;                   \
                                                                            \
    pRequest->AllocRefBuffers = 1;                                          \
    pRequest->UsedRefBuffers  = 0;                                          \
    pRequest->pRefBuffers     = pRequest->pInlineRefBuffers;                \
                                                                            \
    UlInitializeSpinLock(                                                   \
        &pRequest->SpinLock,                                                \
        "RequestSpinLock"                                                   \
        );                                                                  \
                                                                            \
    pRequest->SendsPending    = 0;                                          \
    pRequest->pLogData        = NULL;                                       \
    pRequest->pLogDataCopy    = NULL;                                       \
    pRequest->LogStatus       = STATUS_SUCCESS;                             \
                                                                            \
    UlInitializeUrlInfo(&pRequest->ConfigInfo);                             \
                                                                            \
    RtlZeroMemory(                                                          \
        (PUCHAR)pRequest + FIELD_OFFSET(UL_INTERNAL_REQUEST, HeaderValid),  \
        sizeof(*pRequest) - FIELD_OFFSET(UL_INTERNAL_REQUEST, HeaderValid)  \
        );                                                                  \
                                                                            \
    pRequest->LoadBalancerCapability                                        \
        = HttpLoadBalancerSophisticatedCapability;                          \
} while (0, 0)


NTSTATUS
UlpCreateHttpRequest(
    IN PUL_HTTP_CONNECTION pHttpConnection,
    OUT PUL_INTERNAL_REQUEST *ppRequest
    );

VOID
UlpFreeHttpRequest(
    IN PUL_WORK_ITEM pWorkItem
    );

VOID
UlReferenceHttpRequest(
    IN PVOID pObject
    REFERENCE_DEBUG_FORMAL_PARAMS
    );

VOID
UlDereferenceHttpRequest(
    IN PUL_INTERNAL_REQUEST pRequest
    REFERENCE_DEBUG_FORMAL_PARAMS
    );


#if REFERENCE_DEBUG

#define UL_REFERENCE_INTERNAL_REQUEST( preq )                               \
    UlReferenceHttpRequest(                                                 \
        (preq)                                                              \
        REFERENCE_DEBUG_ACTUAL_PARAMS                                       \
        )

#define UL_DEREFERENCE_INTERNAL_REQUEST( preq )                             \
    UlDereferenceHttpRequest(                                               \
        (preq)                                                              \
        REFERENCE_DEBUG_ACTUAL_PARAMS                                       \
        )

#else // !REFERENCE_DEBUG

#define UL_REFERENCE_INTERNAL_REQUEST( preq )                               \
    InterlockedIncrement( &( preq )->RefCount )

#define UL_DEREFERENCE_INTERNAL_REQUEST( preq )                             \
    if ( InterlockedDecrement( &( preq )->RefCount ) == 0 )                 \
    {                                                                       \
        UL_CALL_PASSIVE(                                                    \
            &( ( preq )->WorkItem ),                                        \
            &UlpFreeHttpRequest                                             \
        );                                                                  \
    } else

#endif // !REFERENCE_DEBUG


VOID
UlCancelRequestIo(
    IN PUL_INTERNAL_REQUEST pRequest
    );

PUL_REQUEST_BUFFER
UlCreateRequestBuffer(
    ULONG BufferSize,
    ULONG BufferNumber,
    BOOLEAN UseLookaside
    );

VOID
UlFreeRequestBuffer(
    PUL_REQUEST_BUFFER pBuffer
    );

#define UL_REFERENCE_REQUEST_BUFFER( pbuf )                                 \
    InterlockedIncrement( &( pbuf )->RefCount )

#define UL_DEREFERENCE_REQUEST_BUFFER( pbuf )                               \
    if ( InterlockedDecrement( &( pbuf )->RefCount ) == 0 )                 \
    {                                                                       \
        if ((pbuf)->FromLookaside)                                          \
        {                                                                   \
            UlPplFreeRequestBuffer( ( pbuf ) );                             \
        }                                                                   \
        else                                                                \
        {                                                                   \
            UL_FREE_POOL_WITH_SIG( ( pbuf ), UL_REQUEST_BUFFER_POOL_TAG );  \
        }                                                                   \
    }

__inline
PUL_HTTP_CONNECTION
UlGetConnectionFromId(
    IN HTTP_CONNECTION_ID ConnectionId
    )
{
    return (PUL_HTTP_CONNECTION) UlGetObjectFromOpaqueId(
                                        ConnectionId,
                                        UlOpaqueIdTypeHttpConnection,
                                        UlReferenceHttpConnection
                                        );
}

NTSTATUS
UlAllocateRequestId(
    IN PUL_INTERNAL_REQUEST pRequest
    );

VOID
UlFreeRequestId(
    IN PUL_INTERNAL_REQUEST pRequest
    );

PUL_INTERNAL_REQUEST
UlGetRequestFromId(
    IN HTTP_REQUEST_ID RequestId,
    IN PUL_APP_POOL_PROCESS pProcess
    );

//
// Zombie connection list stuff
//

NTSTATUS
UlInitializeHttpConnection(
    VOID
    );

VOID
UlTerminateHttpConnection(
    VOID
    );

typedef
BOOLEAN
(*PUL_PURGE_ROUTINE)(
    IN PUL_HTTP_CONNECTION  pHttpConnection,
    IN PVOID                pPurgeContext
    );

VOID
UlPurgeZombieConnections(
    IN PUL_PURGE_ROUTINE pPurgeRoutine,
    IN PVOID pPurgeContext
    );

BOOLEAN
UlPurgeListeningEndpoint(
    IN PUL_HTTP_CONNECTION  pHttpConnection,
    IN PVOID                pListeningContext
    );

BOOLEAN
UlPurgeAppPoolProcess(
    IN PUL_HTTP_CONNECTION  pHttpConnection,
    IN PVOID                pProcessContext
    );

VOID
UlZombieTimerDpcRoutine(
    PKDPC Dpc,
    PVOID DeferredContext,
    PVOID SystemArgument1,
    PVOID SystemArgument2
    );

NTSTATUS
UlLogZombieConnection(
    IN PUL_INTERNAL_REQUEST  pRequest,
    IN PUL_HTTP_CONNECTION   pHttpConn,
    IN PHTTP_LOG_FIELDS_DATA pUserLogData,
    IN KPROCESSOR_MODE       RequestorMode
    );

NTSTATUS
UlDisconnectHttpConnection(
    IN PUL_HTTP_CONNECTION      pHttpConnection,
    IN PUL_COMPLETION_ROUTINE   pCompletionRoutine,
    IN PVOID                    pCompletionContext
    );


#endif  // _HTTPCONN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\httprcv.c ===
/*++

Copyright (c) 1998-2002 Microsoft Corporation

Module Name:

    httprcv.c

Abstract:

    Contains core HTTP receive code.

Author:

    Henry Sanders (henrysa)       10-Jun-1998

Revision History:

    Paul McDaniel (paulmcd)       01-Mar-1999

        massively rewrote it to handle request spanning tdi packets.
        moved all http parsing to PASSIVE irql (from DISPATCH).
        also merged tditest into this module.

    Eric Stenson (EricSten)       11-Sep-2000

        Added support for sending "100 Continue" responses to PUT
        and POST requests.  Added #pragma's for PAGED -vs- Non-PAGED
        functions.

--*/

#include    "precomp.h"
#include    "httprcvp.h"


//
// Declare pageable and non-pageable functions
//

#ifdef ALLOC_PRAGMA

// Public
#pragma alloc_text( PAGE, UlCheckProtocolCompliance )
#pragma alloc_text( PAGE, UlGetCGroupForRequest )
#pragma alloc_text( PAGE, UlSendSimpleStatus )
#pragma alloc_text( PAGE, UlSendSimpleStatusEx )
#pragma alloc_text( PAGE, UlProcessBufferQueue )
#pragma alloc_text( PAGE, UlErrorLog )

// Private
#pragma alloc_text( PAGE, UlpDeliverHttpRequest )
#pragma alloc_text( PAGE, UlpCancelEntityBodyWorker )
#pragma alloc_text( PAGE, UlpConnectionDisconnectWorker )
#pragma alloc_text( PAGE, UlpInitErrorLogInfo )

#if DBG
#pragma alloc_text( PAGE, UlpIsValidRequestBufferList )
#endif // DBG

#endif // ALLOC_PRAGMA

#if 0   // Non-Pageable Functions
// Public
NOT PAGEABLE -- UlHttpReceive
NOT PAGEABLE -- UlResumeParsing
NOT PAGEABLE -- UlConnectionRequest
NOT PAGEABLE -- UlConnectionComplete
NOT PAGEABLE -- UlConnectionDisconnect
NOT PAGEABLE -- UlConnectionDisconnectComplete
NOT PAGEABLE -- UlConnectionDestroyed
NOT PAGEABLE -- UlReceiveEntityBody
NOT PAGEABLE -- UlSetErrorCodeFileLine
NOT PAGEABLE -- UlSendErrorResponse

// Private
NOT PAGEABLE -- UlpHandleRequest
NOT PAGEABLE -- UlpFreeReceiveBufferList
NOT PAGEABLE -- UlpParseNextRequest
NOT PAGEABLE -- UlpInsertBuffer
NOT PAGEABLE -- UlpMergeBuffers
NOT PAGEABLE -- UlpAdjustBuffers
NOT PAGEABLE -- UlpConsumeBytesFromConnection
NOT PAGEABLE -- UlpCancelEntityBody
NOT PAGEABLE -- UlpCompleteSendErrorResponse
NOT PAGEABLE -- UlpRestartSendSimpleResponse
NOT PAGEABLE -- UlpSendSimpleCleanupWorker
NOT PAGEABLE -- UlpDoConnectionDisconnect

#endif  // Non-Pageable Functions

//
// Private globals.
//

#if DBG
BOOLEAN g_CheckRequestBufferList = FALSE;
#endif


/*++

    Paul McDaniel (paulmcd)         26-May-1999

here is a brief description of the data structures used by this module:

the connection keeps track of all buffers received by TDI into a list anchored
by HTTP_CONNECTION::BufferHead.  this list is sequenced and sorted.  the
buffers are refcounted.

HTTP_REQUEST(s) keep pointers into these buffers for the parts they consume.
HTTP_REQUEST::pHeaderBuffer and HTTP_REQUEST::pChunkBuffer.

the buffers fall off the list as they are no longer needed.  the connection
only keeps a reference at HTTP_CONNECTION::pCurrentBuffer.  so as it completes
the processing of a buffer, if no other objects kept that buffer, it will be
released.

here is a brief description of the functions in this module, and how they
are used:


UlHttpReceive - the TDI data indication handler.  copies buffers and queues to
    UlpHandleRequest.

UlpHandleRequest - the main processing function for connections.

    UlCreateHttpConnectionId - creates the connections opaque id.

    UlpInsertBuffer - inserts the buffer into pConnection->BufferHead - sorted.

    UlpAdjustBuffers - determines where in BufferHead the current connection
        should be parsing.  handle buffer merging and copying if a protocol
        token spans buffers

    UlParseHttp - the main http parser. expects that no protocol tokens span
        a buffer.  will return a status code if it does.

    UlProcessBufferQueue - handles entity body buffer processing.
        synchronizes access to pRequest->IrpHead at pRequest->pChunkBuffer
        with UlReceiveEntityBody.

UlConnectionRequest - called when a new connection comes in.  allocates a new
    HTTP_CONNECTION.  does not create the opaque id.

UlConnectionComplete - called if the client is happy with our accept.
    closes the connection if error status.

UlConnectionDisconnect - called when the client disconnects.  it calls tdi to
    close the server end.  always a graceful close.

UlConnectionDestroyed - called when the connection is dropped. both sides have
    closed it.  deletes all opaque ids .  removes the tdi reference on the
    HTTP_CONNECTION (and hopefully vice versa) .

UlReceiveEntityBody - called by user mode to read entity body.  pends the irp
    to pRequest->IrpHead and calls UlProcessBufferQueue .


--*/


/*++

Routine Description:

    The main http receive routine, called by TDI.

Arguments:

    pHttpConn       - Pointer to HTTP connection on which data was received.
    pVoidBuffer     - Pointer to data received.
    BufferLength    - Length of data pointed to by pVoidBuffer.
    UnreceivedLength- Bytes that the transport has, but aren't in pBuffer
    pBytesTaken     - Pointer to where to return bytes taken.

Return Value:

    Status of receive.

--*/
NTSTATUS
UlHttpReceive(
    IN PVOID pListeningContext,
    IN PVOID pConnectionContext,
    IN PVOID pVoidBuffer,
    IN ULONG BufferLength,
    IN ULONG UnreceivedLength,
    OUT PULONG pBytesTaken
    )
{
    PUL_REQUEST_BUFFER  pRequestBuffer;
    PUL_HTTP_CONNECTION pConnection;
    BOOLEAN             DrainAfterDisconnect = FALSE;
    BOOLEAN             CopyRequest = FALSE;
    ULONG               NextBufferNumber = ULONG_MAX;
    KIRQL               OldIrql;
    BOOLEAN             UseLookaside = FALSE;

    UNREFERENCED_PARAMETER(pListeningContext);

    ASSERT(BufferLength != 0);
    ASSERT(pConnectionContext != NULL);

    pConnection = (PUL_HTTP_CONNECTION)pConnectionContext;
    ASSERT(UL_IS_VALID_HTTP_CONNECTION(pConnection));

    //
    // Make sure we are not buffering too much data.
    // Need to adjust the BufferLength to be no more
    // than the number of bytes we can accept at this time.
    //

    //
    // PerfBug: need to get rid of this lock
    //

    UlAcquireSpinLock(&pConnection->BufferingInfo.BufferingSpinLock, &OldIrql);

    DrainAfterDisconnect = pConnection->BufferingInfo.DrainAfterDisconnect;

    //
    // For filtered connections, a receive indication may happen while
    // there is a pending read. Therefore we need to increment up here.
    //

    pConnection->BufferingInfo.TransportBytesNotTaken += UnreceivedLength;

    if (!DrainAfterDisconnect)
    {
        //
        // Use the RequestBuffer lookaside list if we haven't previously
        // buffered any request buffers.
        //

        if (0 == pConnection->BufferingInfo.BytesBuffered)
        {
            UseLookaside = TRUE;
        }

        if ((pConnection->BufferingInfo.BytesBuffered + BufferLength)
                > g_UlMaxBufferedBytes)
        {
            ULONG SpaceAvailable = g_UlMaxBufferedBytes
                                - pConnection->BufferingInfo.BytesBuffered;
            pConnection->BufferingInfo.TransportBytesNotTaken
                += (BufferLength - SpaceAvailable);

            BufferLength = SpaceAvailable;
        }

        pConnection->BufferingInfo.BytesBuffered += BufferLength;

        UlTraceVerbose(HTTP_IO,
                       ("UlHttpReceive(conn=%p): BytesBuffered %lu->%lu, "
                        "TransportBytesNotTaken %lu->%lu\n",
                        pConnection,
                        pConnection->BufferingInfo.BytesBuffered
                            - BufferLength,
                        pConnection->BufferingInfo.BytesBuffered,
                        pConnection->BufferingInfo.TransportBytesNotTaken
                            - UnreceivedLength,
                        pConnection->BufferingInfo.TransportBytesNotTaken
                        ));
    }

    if (BufferLength && DrainAfterDisconnect == FALSE)
    {
        CopyRequest = TRUE;

        NextBufferNumber = pConnection->NextBufferNumber;
        pConnection->NextBufferNumber++;
    }

    UlReleaseSpinLock(&pConnection->BufferingInfo.BufferingSpinLock, OldIrql);

    if (CopyRequest)
    {
        //
        // get a new request buffer
        //

        pRequestBuffer = UlCreateRequestBuffer(
                                BufferLength,
                                NextBufferNumber,
                                UseLookaside
                                );

        if (pRequestBuffer == NULL)
        {
            return STATUS_NO_MEMORY;
        }

        //
        // copy the tdi buffer
        //

        RtlCopyMemory(pRequestBuffer->pBuffer, pVoidBuffer, BufferLength);

        pRequestBuffer->UsedBytes = BufferLength;

        //
        // Add backpointer to connection.
        //

        pRequestBuffer->pConnection = pConnection;

        UlTrace( PARSER, (
            "*** Request Buffer %p (#%d) has connection %p\n",
            pRequestBuffer,
            pRequestBuffer->BufferNumber,
            pConnection
            ));

        IF_DEBUG2BOTH(HTTP_IO, VERBOSE)
        {
            UlTraceVerbose( HTTP_IO, (
                "<<<< Request(%p), "
                "RequestBuffer %p(#%d), %lu bytes, "
                "Conn %p.\n",
                pConnection->pRequest,
                pRequestBuffer, pRequestBuffer->BufferNumber, BufferLength,
                pConnection
                ));

            UlDbgPrettyPrintBuffer(pRequestBuffer->pBuffer, BufferLength);

            UlTraceVerbose( HTTP_IO, (">>>>\n"));
        }

        //
        // Queue a work item to handle the data.
        //
        // Reference the connection so it doesn't go
        // away while we're waiting for our work item
        // to run. UlpHandleRequest will release the ref.
        //
        // If ReceiveBufferSList is empty, then queue a UlpHandleRequest
        // workitem to handle any request buffers that have accumulated
        // by the time that UlpHandleRequest is finally invoked.
        //

        if (NULL == InterlockedPushEntrySList(
                        &pConnection->ReceiveBufferSList,
                        &pRequestBuffer->SListEntry
                        ))
        {
            UL_REFERENCE_HTTP_CONNECTION(pConnection);

            UL_QUEUE_WORK_ITEM(
                &pConnection->ReceiveBufferWorkItem,
                &UlpHandleRequest
                );
        }
    }
    else if ( DrainAfterDisconnect && UnreceivedLength != 0 )
    {
        // Handle the case where we are in drain state and there's
        // unreceived data indicated but not available by the tdi.

        UlpDiscardBytesFromConnection( pConnection );
    }

    //
    // Tell the caller how many bytes we consumed.
    //

    *pBytesTaken = BufferLength;

    return STATUS_SUCCESS;

}   // UlHttpReceive


/***************************************************************************++

Routine Description:

    links a set of request buffers into the connection and processes the list.

    starts http request parsing.

Arguments:

    pWorkItem - embedded in an UL_HTTP_CONNECTION

--***************************************************************************/
VOID
UlpHandleRequest(
    IN PUL_WORK_ITEM pWorkItem
    )
{
    NTSTATUS            Status = STATUS_SUCCESS;
    PUL_REQUEST_BUFFER  pRequestBuffer;
    PUL_HTTP_CONNECTION pConnection;
    SLIST_ENTRY         BufferSList;
    PSLIST_ENTRY        pListEntry, pNext;
    PIRP                pIrp, pIrpToComplete = NULL;

    //
    // Sanity check.
    //

    PAGED_CODE();

    pConnection = CONTAINING_RECORD(
                        pWorkItem,
                        UL_HTTP_CONNECTION,
                        ReceiveBufferWorkItem
                        );

    ASSERT(UL_IS_VALID_HTTP_CONNECTION(pConnection));

    //
    // Yank the receive buffers accumulated so far into a local list.
    //

    pListEntry = InterlockedFlushSList(&pConnection->ReceiveBufferSList);

    ASSERT( NULL != pListEntry );

    //
    // Reverse-order of what we received.
    //

    BufferSList.Next = NULL;

    while (pListEntry != NULL)
    {
        pNext = pListEntry->Next;
        pListEntry->Next = BufferSList.Next;
        BufferSList.Next = pListEntry;
        pListEntry = pNext;
    }

    //
    // grab the lock
    //

    UlAcquirePushLockExclusive(&pConnection->PushLock);

    //
    // if the connection is going down, just bail out.
    //

    if (pConnection->UlconnDestroyed)
    {
        UlpFreeReceiveBufferList(&BufferSList);
        Status = STATUS_SUCCESS;
        goto end;
    }

    while (NT_SUCCESS(Status) && NULL != BufferSList.Next)
    {
        pListEntry = BufferSList.Next;
        BufferSList.Next = pListEntry->Next;

        pRequestBuffer = CONTAINING_RECORD(
                            pListEntry,
                            UL_REQUEST_BUFFER,
                            ListEntry
                            );

        ASSERT( UL_IS_VALID_REQUEST_BUFFER(pRequestBuffer) );

        pRequestBuffer->ListEntry.Blink = NULL;
        pRequestBuffer->ListEntry.Flink = NULL;

        //
        // insert it into the list
        //

        ASSERT( 0 != pRequestBuffer->UsedBytes );

        UlTraceVerbose( PARSER, (
            "http!UlpHandleRequest: conn = %p, Req = %p: "
            "about to insert buffer %p\n",
            pConnection,
            pConnection->pRequest,
            pRequestBuffer
            ));

        UlpInsertBuffer(pConnection, pRequestBuffer);

        //
        // Kick off the parser
        //

        UlTraceVerbose( PARSER, (
            "http!UlpHandleRequest: conn = %p, Req = %p: "
            "about to parse next request (MoreRequestBuffers=%d)\n",
            pConnection,
            pConnection->pRequest,
            BufferSList.Next != NULL
            ));

        pIrp = NULL;

        Status = UlpParseNextRequest(
                    pConnection,
                    (BOOLEAN) (BufferSList.Next != NULL),
                    &pIrp
                    );

        if (pIrp)
        {
            //
            // There shall be only one IRP to complete since we handle
            // cache-miss request one at a time.
            //

            ASSERT(pIrpToComplete == NULL);
            pIrpToComplete = pIrp;
        }
    }

    if (!NT_SUCCESS(Status))
    {
        UlpFreeReceiveBufferList(&BufferSList);
    }

end:

    UlTraceVerbose( PARSER, (
        "http!UlpHandleRequest: %s, pConnection %p, pRequest %p\n",
        HttpStatusToString(Status),
        pConnection,
        pConnection->pRequest
        ));

    if (!NT_SUCCESS(Status) && pConnection->pRequest != NULL)
    {
        UlTraceError( PARSER, (
            "*** %s, pConnection %p, pRequest %p\n",
            HttpStatusToString(Status),
            pConnection,
            pConnection->pRequest
            ));

        //
        // An error happened, most propably during parsing.
        // Send an error back if user hasn't send one yet.
        // E.g. We have received a request, then delivered
        // it to the WP, therefore WaitingForResponse is
        // set. And then encountered an error when dealing
        // with entity body.
        //
        // Not all error paths explicitly set pRequest->ErrorCode, so
        // we may have to fall back on the most generic error, UlError.
        //
        
        if (UlErrorNone == pConnection->pRequest->ErrorCode)
            UlSetErrorCode(pConnection->pRequest, UlError, NULL);

        UlSendErrorResponse( pConnection );
    }

    //
    // done with the lock
    //

    UlReleasePushLockExclusive(&pConnection->PushLock);

    //
    // and release the connection added in UlHttpReceive
    //

    UL_DEREFERENCE_HTTP_CONNECTION(pConnection);

    //
    // Complete the IRP outside the connection resource to reduce chance
    // of contentions. This is because the delivered request can cause
    // a response being sent on another thread than the current one,
    // which calls UlResumeParsing after done with the send. Completing the
    // receive IRP inside the connection resource can make UlResumeParsing
    // block because we may not have released the resource by then (this
    // is the case because IoCompleteRequest can cause a thread switch).
    //

    if (pIrpToComplete)
    {
        //
        // Use IO_NO_INCREMENT to avoid the work thread being rescheduled.
        //

        UlCompleteRequest(pIrpToComplete, IO_NO_INCREMENT);
    }

    CHECK_STATUS(Status);

}   // UlpHandleRequest


/***************************************************************************++

Routine Description:

    When we finish sending a response we call into this function to
    kick the parser back into action.

Arguments:

    pHttpConn - the connection on which to resume

    FromCache - True if we are called from send cache completion.

    InDisconnect - if a disconnect is in progress

--***************************************************************************/
VOID
UlResumeParsing(
    IN PUL_HTTP_CONNECTION  pHttpConn,
    IN BOOLEAN              FromCache,
    IN BOOLEAN              InDisconnect
    )
{
    NTSTATUS                Status = STATUS_SUCCESS;
    PUL_INTERNAL_REQUEST    pRequest;
    KIRQL                   OldIrql;
    PIRP                    pIrpToComplete = NULL;

    //
    // Sanity check.
    //

    PAGED_CODE();
    ASSERT(UL_IS_VALID_HTTP_CONNECTION(pHttpConn));

    //
    // If the connection is going down, just bail out.
    //

    if (!pHttpConn->UlconnDestroyed)
    {
        UlAcquirePushLockExclusive(&pHttpConn->PushLock);

        if (!pHttpConn->UlconnDestroyed)
        {
            pRequest = pHttpConn->pRequest;
            ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pRequest));
            
            if (FromCache)
            {
                //
                // For cache case, cleanup the last request and try to 
                // resume parse right away.
                //

                UlCleanupHttpConnection(pHttpConn);
                
            }
            else if (!pRequest->ContentLength && !pRequest->Chunked)
            {
                //
                // For cache-miss, cleanup the last request only if a graceful 
                // disconnect is in progress, or if this request does not have
                // any entity body.
                //

                ASSERT(1 == pRequest->SentLast);

                UlCleanupHttpConnection(pHttpConn); 
                
            }
            else
            {      
                //
                // This is a cache-miss case however we may still have entity 
                // body to drain before we can continue parsing the next request.
                // 

                pRequest->InDrain = 1;
                UlProcessBufferQueue(pRequest, NULL, 0);

                //
                // We are done with the request if we have parsed all the data.
                // Clean up the request from the connection so we can start
                // parsing a new request.
                //

                if (ParseDoneState == pRequest->ParseState)
                {
                    ASSERT(0 == pRequest->ChunkBytesToRead);
                    UlCleanupHttpConnection(pHttpConn);
                }
                else
                {
                    PUL_TIMEOUT_INFO_ENTRY pTimeoutInfo;
                    
                    //
                    // Waiting for more data to parse/drain.  Put the
                    // connection back to idle timer to avoid waiting forever
                    // under DOS attack.
                    //

                    pTimeoutInfo = &pHttpConn->TimeoutInfo;
                    
                    UlLockTimeoutInfo(
                        pTimeoutInfo,
                        &OldIrql
                        );


                    if (UlIsConnectionTimerOff(pTimeoutInfo, 
                            TimerConnectionIdle))
                    {
                        UlSetConnectionTimer(
                            pTimeoutInfo, 
                            TimerConnectionIdle
                            );
                    }

                    UlUnlockTimeoutInfo(
                        pTimeoutInfo,
                        OldIrql
                        );

                    UlEvaluateTimerState(
                        pTimeoutInfo
                        );
                }
            }

            //
            // Kick off the parser if no disconnect is in progress.
            //

            if (!InDisconnect)
            {
                Status = UlpParseNextRequest(pHttpConn, FALSE, &pIrpToComplete);

                if (!NT_SUCCESS(Status) && pHttpConn->pRequest != NULL)
                {
                    //
                    // Uh oh, something bad happened: send back an error (which
                    // should have been set by UlpParseNextRequest).
                    //

                    ASSERT(UlErrorNone != pHttpConn->pRequest->ErrorCode);

                    UlSendErrorResponse(pHttpConn);
                }
            }
        }

        UlReleasePushLockExclusive(&pHttpConn->PushLock);
    }

    //
    // Complete the IRP outside the connection resource. See comment
    // in UlpHandleRequest for detailed reasons.
    //

    if (pIrpToComplete)
    {
        //
        // Use IO_NO_INCREMENT to avoid the work thread being rescheduled.
        //

        UlCompleteRequest(pIrpToComplete, IO_NO_INCREMENT);
    }

    CHECK_STATUS(Status);
} // UlResumeParsing


/***************************************************************************++

Routine Description:

    Validates certain requirements about verbs and versions.
    If not met, will set the error code and return STATUS_INVALID_PARAMETER

Arguments:

    pRequest - the request to validate. Must be cooked.

--***************************************************************************/
NTSTATUS
UlCheckProtocolCompliance(
    IN PUL_INTERNAL_REQUEST pRequest
    )
{
    HTTP_VERB Verb = pRequest->Verb;

    //
    // Sanity check
    //
    PAGED_CODE();
    ASSERT( UL_IS_VALID_INTERNAL_REQUEST(pRequest) );
    ASSERT(pRequest->ParseState > ParseCookState);

    //
    // If the major version is greater than 1, fail.
    //

    if (HTTP_GREATER_EQUAL_VERSION(pRequest->Version, 2, 0))
    {
        UlTraceError(PARSER,
                    ("UlCheckProtocolCompliance: HTTP/%hu.%hu is invalid\n",
                    pRequest->Version.MajorVersion,
                    pRequest->Version.MinorVersion
                    ));

        UlSetErrorCode(pRequest, UlErrorVersion, NULL);
        return STATUS_INVALID_PARAMETER;
    }

    if (HTTP_GREATER_EQUAL_VERSION(pRequest->Version, 1, 1))
    {
        //
        // 1.1 requests MUST have a host header
        //
        if (!pRequest->HeaderValid[HttpHeaderHost])
        {
            UlTraceError(PARSER,
                        ("UlCheckProtocolCompliance: "
                        "HTTP/1.%hu must have Host header\n",
                        pRequest->Version.MinorVersion
                        ));

            UlSetErrorCode(pRequest, UlErrorHost, NULL);
            return STATUS_INVALID_PARAMETER;
        }
    }
    else if (HTTP_LESS_VERSION(pRequest->Version, 1, 0))
    {
        // Anything other than HTTP/0.9 should have been rejected earlier
        ASSERT(HTTP_EQUAL_VERSION(pRequest->Version, 0, 9));

        // HTTP/0.9 only supports GET
        if (Verb != HttpVerbGET)
        {
            UlTraceError(PARSER,
                        ("UlCheckProtocolCompliance: "
                         "'%s' invalid on HTTP/0.9\n",
                        UlVerbToString(Verb)
                        ));

            UlSetErrorCode(pRequest, UlErrorVerb, NULL);
            return STATUS_INVALID_PARAMETER;
        }

        return STATUS_SUCCESS;
    }

    //
    // Make sure that POSTs and PUTs have a message body.
    // Requests must either be chunked or have a content length.
    //
    if ((Verb == HttpVerbPOST || Verb == HttpVerbPUT)
            && (!pRequest->Chunked)
            && (!pRequest->HeaderValid[HttpHeaderContentLength]))
    {
        UlTraceError(PARSER,
                    ("UlCheckProtocolCompliance: "
                    "HTTP/1.%hu '%s' must have entity body\n",
                    pRequest->Version.MinorVersion,
                    UlVerbToString(Verb)
                    ));

        UlSetErrorCode(pRequest, UlErrorContentLength, NULL);
        return STATUS_INVALID_PARAMETER;
    }

    //
    // TRACE and TRACK are not allowed to have an entity body.
    // If an entity body is expected, we will be in ParseEntityBodyState.
    //
    if ((pRequest->ParseState != ParseDoneState)
        && (Verb == HttpVerbTRACE || Verb == HttpVerbTRACK))
    {
        UlTraceError(PARSER,
                    ("UlCheckProtocolCompliance: "
                    "HTTP/1.%hu '%s' must not have entity body\n",
                    pRequest->Version.MinorVersion,
                    UlVerbToString(Verb)
                    ));

        UlSetErrorCode(pRequest, UlError, NULL);
        return STATUS_INVALID_PARAMETER;
    }

    return STATUS_SUCCESS;

} // UlCheckProtocolCompliance



/***************************************************************************++

Routine Description:

    Tries to parse data attached to the connection into a request. If
    a complete request header is parsed, the request will be dispatched
    to an Application Pool.

    This function assumes the caller is holding the connection resource!

Arguments:

    pConnection - the HTTP_CONNECTION with data to parse.

    MoreRequestBuffers - if TRUE, this is not the last request buffer
        currently attached to the connection

--***************************************************************************/
NTSTATUS
UlpParseNextRequest(
    IN PUL_HTTP_CONNECTION  pConnection,
    IN BOOLEAN              MoreRequestBuffers,
    OUT PIRP                *pIrpToComplete
    )
{
    NTSTATUS                    Status;
    PUL_INTERNAL_REQUEST        pRequest = NULL;
    ULONG                       BytesTaken;
    ULONG                       BufferLength;
    BOOLEAN                     ResumeParsing;
    KIRQL                       OldIrql;
    PARSE_STATE                 OldState;

    //
    // Sanity check.
    //

    PAGED_CODE();
    ASSERT( UL_IS_VALID_HTTP_CONNECTION( pConnection ) );
    ASSERT( NULL == pIrpToComplete || NULL == *pIrpToComplete );

    ASSERT(UlDbgPushLockOwnedExclusive(&pConnection->PushLock));

    Status = STATUS_SUCCESS;

    UlTrace(HTTP_IO, ("http!UlpParseNextRequest(httpconn = %p)\n", pConnection));

    //
    // Only parse the next request if
    //
    //  We haven't dispatched the current request yet
    //      OR
    //  The current request has unparsed entity body or trailers.
    //

    if ((pConnection->pRequest == NULL)
        || (!pConnection->WaitingForResponse)
        || (pConnection->pRequest->ParseState == ParseEntityBodyState)
        || (pConnection->pRequest->ParseState == ParseTrailerState))
    {
        //
        // loop consuming the buffer, we will make multiple iterations
        // if a single request spans multiple buffers.
        //

        for (;;)
        {
            ASSERT( UlpIsValidRequestBufferList( pConnection ) );
            Status = UlpAdjustBuffers(pConnection);

            if (!NT_SUCCESS(Status))
            {
                if (Status == STATUS_MORE_PROCESSING_REQUIRED)
                {
                    Status = STATUS_SUCCESS;
                }

                break;
            }

            //
            // Since BufferLength is a ULONG, it can never be negative.
            // So, if UsedBytes is less than ParsedBytes, BufferLength
            // will be very large, and non-zero.
            //

            ASSERT( pConnection->pCurrentBuffer->UsedBytes >
                    pConnection->pCurrentBuffer->ParsedBytes );

            BufferLength = pConnection->pCurrentBuffer->UsedBytes -
                           pConnection->pCurrentBuffer->ParsedBytes;

            //
            // do we need to create a request object?
            //

            if (pConnection->pRequest == NULL)
            {
                //
                // First shot at reading a request, allocate a request object
                //

                Status = UlpCreateHttpRequest(
                                pConnection,
                                &pConnection->pRequest
                                );

                if (NT_SUCCESS(Status) == FALSE)
                    goto end;

                ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pConnection->pRequest));

                UlTrace(HTTP_IO, (
                            "http!UlpParseNextRequest created "
                            "pRequest = %p for httpconn = %p\n",
                            pConnection->pRequest,
                            pConnection
                            ));

                //
                // To be exact precise about the life-time of this
                // request, copy the starting TIMESTAMP from connection
                // pointer. But that won't work since we may get hit by
                // multiple requests to the same connection. So we won't
                // be that much precise.
                //

                KeQuerySystemTime( &(pConnection->pRequest->TimeStamp) );

                TRACE_TIME(
                    pConnection->ConnectionId,
                    pConnection->pRequest->RequestId,
                    TIME_ACTION_CREATE_REQUEST
                    );

                WRITE_REF_TRACE_LOG2(
                    g_pHttpConnectionTraceLog,
                    pConnection->pConnection->pHttpTraceLog,
                    REF_ACTION_INSERT_REQUEST,
                    pConnection->RefCount,
                    pConnection->pRequest,
                    __FILE__,
                    __LINE__
                    );

                //
                // stop the Connection Timeout timer
                // and start the Header Wait timer
                //

                UlLockTimeoutInfo(
                    &pConnection->TimeoutInfo,
                    &OldIrql
                    );

                UlResetConnectionTimer(
                    &pConnection->TimeoutInfo,
                    TimerConnectionIdle
                    );

                UlSetConnectionTimer(
                    &pConnection->TimeoutInfo,
                    TimerHeaderWait
                    );

                UlUnlockTimeoutInfo(
                    &pConnection->TimeoutInfo,
                    OldIrql
                    );

                UlEvaluateTimerState(
                    &pConnection->TimeoutInfo
                    );

            }

            OldState = pConnection->pRequest->ParseState;

            UlTrace( PARSER, (
                "*** pConn %p, pReq %p, ParseState %d (%s), curbuf=%d\n",
                pConnection,
                pConnection->pRequest,
                OldState,
                UlParseStateToString(OldState),
                pConnection->pCurrentBuffer->BufferNumber
                ));

            switch (pConnection->pRequest->ParseState)
            {

            case ParseVerbState:
            case ParseUrlState:
            case ParseVersionState:
            case ParseHeadersState:
            case ParseCookState:

                pRequest = pConnection->pRequest;
                ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pRequest));

                //
                // parse it !
                //

                Status = UlParseHttp(
                                pRequest,
                                GET_REQUEST_BUFFER_POS(pConnection->pCurrentBuffer),
                                BufferLength,
                                &BytesTaken
                                );

                ASSERT(BytesTaken <= BufferLength);

                UlTraceVerbose(PARSER, (
                    "UlpParseNextRequest(pRequest = %p) "
                    "UlParseHttp: states "
                    "%d (%s) -> %d (%s), %lu bytes taken; "
                    "%s\n",
                    pRequest,
                    OldState,
                    UlParseStateToString(OldState),
                    pConnection->pRequest->ParseState,
                    UlParseStateToString(pConnection->pRequest->ParseState),
                    BytesTaken,
                    HttpStatusToString(Status)
                    ));

                pConnection->pCurrentBuffer->ParsedBytes += BytesTaken;
                BufferLength -= BytesTaken;

                //
                // Need some accounting for Logging
                //
                pRequest->BytesReceived += BytesTaken;

                //
                // did we consume any of the data?  if so, give the request
                // a pointer to the buffer
                //

                if (BytesTaken > 0)
                {
                    if (pRequest->pHeaderBuffer == NULL)
                    {
                        //
                        // store its location, for later release
                        //
                        pRequest->pHeaderBuffer = pConnection->pCurrentBuffer;
                    }

                    pRequest->pLastHeaderBuffer = pConnection->pCurrentBuffer;

                    if (!UlpReferenceBuffers(
                            pRequest,
                            pConnection->pCurrentBuffer
                            ))
                    {
                        Status = STATUS_NO_MEMORY;
                        goto end;
                    }
                }

                //
                // We may still need to receive some transport bytes not taken
                // even if UlParseHttp calls returns zero. Especially if some
                // large header value is spanning over multiple request buffers
                // and some part of it is available in tdi but not received yet.
                //

                UlpConsumeBytesFromConnection(pConnection, BytesTaken);

                //
                // did everything work out ok?
                //

                if (!NT_SUCCESS(Status))
                {
                    if (Status == STATUS_MORE_PROCESSING_REQUIRED)
                    {
                        ULONG FullBytesReceived;

                        FullBytesReceived = (ULONG)(
                            (pRequest->BytesReceived + BufferLength));

                        if (FullBytesReceived < g_UlMaxRequestBytes)
                        {
                            //
                            // we need more transport data
                            //

                            pConnection->NeedMoreData = 1;

                            Status = STATUS_SUCCESS;
                        }
                        else
                        {
                            //
                            // The request has grown too large. Send back
                            // an error.
                            //

                            if (pRequest->ParseState == ParseUrlState)
                            {
                                UlTraceError(PARSER, (
                                    "UlpParseNextRequest(pRequest = %p)"
                                    " ERROR: URL is too big\n",
                                    pRequest
                                    ));

                                UlSetErrorCode(
                                        pRequest,
                                        UlErrorUrlLength,
                                        NULL
                                        );
                            }
                            else
                            {
                                UlTraceError(PARSER, (
                                    "UlpParseNextRequest(pRequest = %p)"
                                    " ERROR: request is too big\n",
                                    pRequest
                                    ));

                                UlSetErrorCode(
                                        pRequest,
                                        UlErrorRequestLength,
                                        NULL
                                        );
                            }

                            Status = STATUS_SECTION_TOO_BIG;

                            goto end;
                        }
                    }
                    else
                    {
                        //
                        // some other bad error!
                        //

                        goto end;
                    }
                }

                //
                // if we're not done parsing the request, we need more data.
                // it's not bad enough to set NeedMoreData as nothing important
                // spanned buffer boundaries (header values, etc..) .  it was
                // a clean split.  no buffer merging is necessary.  simply skip
                // to the next buffer.
                //

                if (pRequest->ParseState <= ParseCookState)
                {
                    continue;
                }

                //
                // all done, mark the sequence number on this request
                //

                pRequest->RecvNumber = pConnection->NextRecvNumber;
                pConnection->NextRecvNumber += 1;

                UlTrace(HTTP_IO, (
                    "http!UlpParseNextRequest(httpconn = %p) built request %p\n",
                    pConnection,
                    pRequest
                    ));

                //
                // Stop the Header Wait timer
                //

                UlLockTimeoutInfo(
                    &pConnection->TimeoutInfo,
                    &OldIrql
                    );

                UlResetConnectionTimer(
                    &pConnection->TimeoutInfo,
                    TimerHeaderWait
                    );

                UlUnlockTimeoutInfo(
                    &pConnection->TimeoutInfo,
                    OldIrql
                    );

                UlEvaluateTimerState(
                    &pConnection->TimeoutInfo
                    );
                
                //
                // check protocol compliance
                //

                Status = UlCheckProtocolCompliance(pRequest);

                if (!NT_SUCCESS(Status))
                {
                    //
                    // This request is bad. Send a 400.
                    //

                    ASSERT(pRequest->ParseState == ParseErrorState);

                    goto end;

                }

                //
                // Record the Request Details.
                // This should be the only place where the URL is logged.
                //

                if (ETW_LOG_RESOURCE())
                {
                    UlEtwTraceEvent(
                        &UlTransGuid,
                        ETW_TYPE_ULPARSE_REQ,
                        (PVOID) &pRequest,
                        sizeof(PVOID),
                        &pRequest->Verb,
                        sizeof(HTTP_VERB),
                        pRequest->CookedUrl.pUrl ,
                        pRequest->CookedUrl.Length,
                        NULL,
                        0
                        );
                }

                Status = UlpDeliverHttpRequest(
                            pConnection,
                            &ResumeParsing,
                            pIrpToComplete
                            );

                if (!NT_SUCCESS(Status)) {
                    goto end;
                }

                if (ResumeParsing)
                {
                    //
                    // We have hit the cache entry and sent the response.
                    // There is no more use for the request anymore so
                    // unlink it from the connection and try parsing the
                    // next request immediately. However if we have reached to
                    // max allowed pipelined requests, we will resume parse at
                    // cache send completion. In which case UlpDeliverHttpRequest
                    // returns False too.
                    //

                    UlCleanupHttpConnection(pConnection);
                    continue;
                }

                //
                // if we're done parsing the request break out
                // of the loop. Otherwise keep going around
                // so we can pick up the entity body.
                //

                if (pRequest->ParseState == ParseDoneState)
                {
                    goto end;
                }

                //
                // done with protocol parsing.  keep looping.
                //

                break;

            case ParseEntityBodyState:
            case ParseTrailerState:

                pRequest = pConnection->pRequest;
                ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pRequest));

                //
                // is there anything for us to parse?
                //

                UlTraceVerbose(PARSER, (
                    "UlpParseNextRequest(pRequest=%p, httpconn=%p): "
                    "ChunkBytesToParse = %I64u, ParseState = %d (%s).\n",
                    pRequest, pConnection, pRequest->ChunkBytesToParse,
                    pConnection->pRequest->ParseState,
                    UlParseStateToString(pConnection->pRequest->ParseState)
                    ));

                if (pRequest->ChunkBytesToParse > 0  ||  pRequest->Chunked)
                {
                    //
                    // Set/bump the Entity Body Receive timer
                    //

                    UlLockTimeoutInfo(
                        &pConnection->TimeoutInfo,
                        &OldIrql
                        );

                    UlSetConnectionTimer(
                        &pConnection->TimeoutInfo,
                        TimerEntityBody
                        );

                    UlUnlockTimeoutInfo(
                        &pConnection->TimeoutInfo,
                        OldIrql
                        );

                    UlEvaluateTimerState(
                        &pConnection->TimeoutInfo
                        );
                }

                if (pRequest->ChunkBytesToParse > 0)
                {
                    ULONG BytesToSkip;

                    //
                    // is this the first chunk we've parsed?
                    //

                    ASSERT(pConnection->pCurrentBuffer);

                    if (pRequest->pChunkBuffer == NULL)
                    {
                        //
                        // store its location, this is where to start reading
                        //

                        pRequest->pChunkBuffer = pConnection->pCurrentBuffer;
                        pRequest->pChunkLocation = GET_REQUEST_BUFFER_POS(
                                                        pConnection->pCurrentBuffer
                                                        );
                    }

                    //
                    // how much should we parse?
                    //

                    BytesToSkip = (ULONG)(
                                        MIN(
                                            pRequest->ChunkBytesToParse,
                                            BufferLength
                                            )
                                        );

                    //
                    // update that we parsed this piece
                    //

                    pRequest->ChunkBytesToParse -= BytesToSkip;
                    pRequest->ChunkBytesParsed += BytesToSkip;

                    pConnection->pCurrentBuffer->ParsedBytes += BytesToSkip;
                    BufferLength -= BytesToSkip;

                    //
                    // Need some accounting info for Logging
                    //
                    pRequest->BytesReceived += BytesToSkip;
                }

                //
                // process any irp's waiting for entity body
                //

                UlTraceVerbose(PARSER, (
                    "UlpParseNextRequest(pRequest=%p, httpconn=%p): "
                    "%sabout to process buffer queue\n",
                    pRequest, pConnection,
                    MoreRequestBuffers ? "not " : ""
                    ));

                if (!MoreRequestBuffers)
                {
                    UlProcessBufferQueue(pRequest, NULL, 0);
                }

                //
                // check to see there is another chunk
                //

                UlTraceVerbose(PARSER, (
                    "UlpParseNextRequest(pRequest=%p, httpconn=%p, "
                    "curbuf=%p(#%d)): checking to see if another chunk.\n",
                    pRequest, pConnection,
                    pConnection->pCurrentBuffer,
                    pConnection->pCurrentBuffer->BufferNumber
                    ));

                Status = UlParseHttp(
                                pRequest,
                                GET_REQUEST_BUFFER_POS(pConnection->pCurrentBuffer),
                                BufferLength,
                                &BytesTaken
                                );

                UlTraceVerbose(PARSER, (
                    "UlpParseNextRequest(pRequest = %p) "
                    "UlParseHttp: states (EB/T) %d (%s) -> %d (%s), "
                    "%lu bytes taken\n",
                    pRequest,
                    OldState,
                    UlParseStateToString(OldState),
                    pConnection->pRequest->ParseState,
                    UlParseStateToString(pConnection->pRequest->ParseState),
                    BytesTaken
                    ));

                pConnection->pCurrentBuffer->ParsedBytes += BytesTaken;
                BufferLength -= BytesTaken;

                //
                // Need some accounting info for Logging
                //
                pRequest->BytesReceived += BytesTaken;

                //
                // was there enough in the buffer to please?
                //

                if (NT_SUCCESS(Status) == FALSE)
                {
                    if (Status == STATUS_MORE_PROCESSING_REQUIRED)
                    {
                        //
                        // we need more transport data
                        //

                        pConnection->NeedMoreData = 1;

                        Status = STATUS_SUCCESS;

                        continue;
                    }
                    else
                    {
                        //
                        // some other bad error !
                        //

                        goto end;
                    }
                }

                //
                // are we all done parsing it ?
                //

                if (pRequest->ParseState == ParseDoneState)
                {
                    UlTraceVerbose(PARSER, (
                        "UlpParseNextRequest(pRequest = %p) all done\n",
                        pRequest
                        ));

                    //
                    // Once more, with feeling. Check to see if there
                    // are any remaining buffers to be processed or irps
                    // to be completed (e.g., catch a solo zero-length
                    // chunk)
                    //

                    UlProcessBufferQueue(pRequest, NULL, 0);

                    //
                    // Stop all timers (including entity body)
                    //

                    UlLockTimeoutInfo(
                        &pConnection->TimeoutInfo,
                        &OldIrql
                        );

                    UlResetConnectionTimer(
                        &pConnection->TimeoutInfo,
                        TimerEntityBody
                        );

                    UlUnlockTimeoutInfo(
                        &pConnection->TimeoutInfo,
                        OldIrql
                        );

                    if (pRequest->InDrain)
                    {
                        //
                        // If we enter the parser in drain mode, clean up the
                        // request from the connection so we can start parsing
                        // a new request.
                        //

                        ASSERT(0 == pRequest->ChunkBytesToRead);
                        UlCleanupHttpConnection(pConnection);
                    }
                    else
                    {
                        //
                        // Exit the parser and wait for the ReceiveEntityBody
                        // IRPs to pick up the data.  Make sure we don't
                        // disconnect a half-closed connection in this case.
                        //

                        goto end;
                    }
                }

                //
                // keep looping.
                //

                break;

            case ParseErrorState:

                //
                // ignore this buffer
                //

                Status = STATUS_SUCCESS;
                goto end;

            case ParseDoneState:
            default:
                //
                // this should never happen
                //
                ASSERT(! "invalid parse state");
                Status = STATUS_INVALID_DEVICE_STATE;
                goto end;

            }   // switch (pConnection->pRequest->ParseState)

        }   // for(;;)
    }

    //
    // Handle a graceful close by the client.
    //

    if (pConnection->LastBufferNumber > 0 &&
        pConnection->NextBufferToParse == pConnection->LastBufferNumber)
    {
        ASSERT(pConnection->LastBufferNumber > 0);

#if 0
        if (pConnection->pRequest)
        {
            // can't drain from a gracefully disconnected connection
            pConnection->pRequest->InDrain = 0;
        }
#endif // 0

        UlpCloseDisconnectedConnection(pConnection);
    }

end:
    if (!NT_SUCCESS(Status))
    {
        if (NULL != pConnection->pRequest
            &&  UlErrorNone == pConnection->pRequest->ErrorCode)
        {
            UlTraceError(PARSER, (
                        "UlpParseNextRequest(pRequest = %p): "
                        "generic failure for %s\n",
                        pRequest, HttpStatusToString(Status)
                        ));

            UlSetErrorCode( pConnection->pRequest, UlError, NULL);
        }
    }
    
    UlTrace(PARSER, (
        "UlpParseNextRequest(pRequest = %p): returning %s. "
        "NeedMoreData=%d\n",
        pRequest, HttpStatusToString(Status),
        pConnection->NeedMoreData
        ));

    return Status;
} // UlpParseNextRequest



/***************************************************************************++

Routine Description:

   DeliverHttpRequest may want to get the cgroup info for the request if it's
   not a cache hit. Similarly sendresponse may want to get this info - later-
   even if it's cache hit, when logging is enabled on the hit. Therefore we
   have created a new function for this to easily maintain the functionality.

Arguments:

   pConnection - The connection whose request we are to deliver.

--***************************************************************************/

NTSTATUS
UlGetCGroupForRequest(
    IN PUL_INTERNAL_REQUEST pRequest
    )
{
    NTSTATUS            Status;
    BOOLEAN             OptionsStar;

    //
    // Sanity check
    //

    PAGED_CODE();
    Status = STATUS_SUCCESS;
    ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pRequest));

    //
    // Lookup the config group information for this url .
    //
    // don't include the query string in the lookup.
    // route OPTIONS * as though it were OPTIONS /
    //

    if (pRequest->CookedUrl.pQueryString != NULL)
    {
        pRequest->CookedUrl.pQueryString[0] = UNICODE_NULL;
    }

    if ((pRequest->Verb == HttpVerbOPTIONS)
        && (pRequest->CookedUrl.pAbsPath[0] == '*')
        && (pRequest->CookedUrl.pAbsPath[1] == UNICODE_NULL))
    {
        pRequest->CookedUrl.pAbsPath[0] = '/';
        OptionsStar = TRUE;
    } else {
        OptionsStar = FALSE;
    }

    //
    // Get the Url Config Info
    //
    Status = UlGetConfigGroupInfoForUrl(
                    pRequest->CookedUrl.pUrl,
                    pRequest,
                    &pRequest->ConfigInfo
                    );

    if (pRequest->CookedUrl.pQueryString != NULL)
    {
        pRequest->CookedUrl.pQueryString[0] = L'?';
    }

    //
    // restore the * in the path
    //
    if (OptionsStar) {
        pRequest->CookedUrl.pAbsPath[0] = '*';
    }

    return Status;
} // UlGetCGroupForRequest



/***************************************************************************++

Routine Description:

    Takes a parsed http request and tries to deliver it to something
    that can send a response.

    First we try the cache. If there is no cache entry we try to route
    to an app pool.

    We send back an auto response if the control channel
    or config group is inactive. If we can't do any of those things we
    set an error code in the HTTP_REQUEST and return a failure status.
    The caller will take care of sending the error.

Arguments:

    pConnection - The connection whose request we are to deliver.

--***************************************************************************/
NTSTATUS
UlpDeliverHttpRequest(
    IN PUL_HTTP_CONNECTION pConnection,
    OUT PBOOLEAN pResumeParsing,
    OUT PIRP *pIrpToComplete
    )
{
    NTSTATUS Status;
    PUL_INTERNAL_REQUEST pRequest;
    UL_SEND_CACHE_RESULT SendCacheResult;
    HTTP_ENABLED_STATE CurrentState;
    ULONG Connections;
    PUL_SITE_COUNTER_ENTRY pCtr;

    //
    // Sanity check
    //

    PAGED_CODE();
    ASSERT(UL_IS_VALID_HTTP_CONNECTION(pConnection));
    ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pConnection->pRequest));

    pRequest = pConnection->pRequest;

    *pResumeParsing = FALSE;
    SendCacheResult = UlSendCacheResultNotSet;
    Status = STATUS_SUCCESS;

    //
    // Do we have a cache hit?
    // Set WaitingForResponse to 1 before calling UlSendCachedResponse
    // because the send may be completed before we return.
    //

    pConnection->WaitingForResponse = 1;

    UlTrace( PARSER, (
        "***3 pConnection %p->WaitingForResponse = 1\n",
        pConnection
        ));

    pRequest->CachePreconditions = UlCheckCachePreconditions(
                                        pRequest,
                                        pConnection
                                        );

    if (pRequest->CachePreconditions)
    {
        Status = UlSendCachedResponse(
                    pConnection,
                    &SendCacheResult,
                    pResumeParsing
                    );

        switch (SendCacheResult)
        {
            case UlSendCacheResultNotSet:
                ASSERT(!"CacheSendResult should be specified !");
                break;

            case UlSendCacheMiss:
                g_UriCacheStats.MissTableCount++;
                UlIncCounter(HttpGlobalCounterUriCacheMisses);

                // Bounce back to user mode.
                break;

            case UlSendCacheServedFromCache:
                ASSERT(NT_SUCCESS(Status));

                //
                // All done with this request. It's served from cache.
                //

                g_UriCacheStats.HitCount++;
                UlIncCounter(HttpGlobalCounterUriCacheHits);
                goto end;

            case UlSendCachePreconditionFailed:
                ASSERT(UlErrorPreconditionFailed == pRequest->ErrorCode); // Fall down
                
            case UlSendCacheConnectionRefused:
                ASSERT(STATUS_INVALID_DEVICE_STATE == Status);            // Fall down

            case UlSendCacheFailed:
                {
                    //
                    // If a cache precondition failed during SendCacheResponse,
                    // Or connection is refused, or any other failure then bail
                    // out.
                    //
                    
                    ASSERT(!NT_SUCCESS(Status));

                    pConnection->WaitingForResponse = 0;

                    UlTrace( PARSER, (
                        "***3 pConnection %p->WaitingForResponse = 0\n",
                        pConnection
                        ));
                        
                    goto end;                
                }
                break;

            default:
                ASSERT(! "Invalid UL_SEND_CACHE_RESULT !");
                break;            
        }
    }
    else
    {
        //
        // Update the cache-miss counters.
        //

        g_UriCacheStats.MissTableCount++;
        UlIncCounter(HttpGlobalCounterUriCacheMisses);
    }

    //
    // We didn't do a send from the cache, so we are not
    // yet WaitingForResponse.
    //

    pConnection->WaitingForResponse = 0;

    UlTrace( PARSER, (
        "***3 pConnection %p->WaitingForResponse = 0\n",
        pConnection
        ));

    //
    // Allocate connection ID here since the request is going to be delivered
    // to user.
    //

    if (HTTP_IS_NULL_ID(&(pConnection->ConnectionId)))
    {
        Status = UlCreateHttpConnectionId(pConnection);

        if (!NT_SUCCESS(Status))
        {
            UlTraceError(PARSER, (
                        "UlpDeliverHttpRequest(pRequest = %p): "
                        "Failed to create conn ID\n",
                        pRequest
                        ));

            UlSetErrorCode(pRequest, UlErrorInternalServer, NULL);
            goto end;
        }

        pRequest->ConnectionId = pConnection->ConnectionId;
    }

    //
    // Allocate request ID here since we didn't do it in UlCreateHttpRequest.
    //

    Status = UlAllocateRequestId(pRequest);

    if (!NT_SUCCESS(Status))
    {
        UlTraceError(PARSER, (
                    "UlpDeliverHttpRequest(pRequest = %p): "
                    "Failed to allocate request ID\n",
                    pRequest
                    ));

        UlSetErrorCode(pRequest, UlErrorInternalServer, NULL);
        goto end;
    }

    //
    // Get the cgroup for this request.
    //

    Status = UlGetCGroupForRequest( pRequest );

    //
    // CODEWORK+BUGBUG: need to check the port's actually matched
    //

    //
    // check that the config group tree lookup matched
    //

    if (!NT_SUCCESS(Status) || pRequest->ConfigInfo.pAppPool == NULL)
    {
        //
        // Could not route to a listening url, send
        // back an http error. Always return error 400
        // to show that host not found. This will also
        // make us to be compliant with HTTP1.1 / 5.2
        //

        // REVIEW: What do we do about the site counter(s)
        // REVIEW: when we can't route to a site? i.e., Connection Attempts?

        UlTraceError(PARSER, (
                    "UlpDeliverHttpRequest(pRequest = %p): "
                    "no config group (%s) or AppPool(%p)\n",
                    pRequest,
                    HttpStatusToString(Status),
                    pRequest->ConfigInfo.pAppPool
                    ));

        UlSetErrorCode(pRequest, UlErrorHost, NULL);

        Status = STATUS_INVALID_DEVICE_STATE;
        goto end;
    }

    //
    // Check to see if there's a connection timeout value override
    //

    if (0L != pRequest->ConfigInfo.ConnectionTimeout)
    {
        UlSetPerSiteConnectionTimeoutValue(
            &pRequest->pHttpConn->TimeoutInfo,
            pRequest->ConfigInfo.ConnectionTimeout
            );
    }

    //
    // Check the connection limit of the site.
    //
    if (UlCheckSiteConnectionLimit(pConnection, &pRequest->ConfigInfo) == FALSE)
    {
        // If exceeding the site limit, send back 503 error and disconnect.
        // NOTE: This code depends on the fact that UlSendErrorResponse always
        // NOTE: disconnects. Otherwise we need a force disconnect here.

        UlTraceError(PARSER, (
                    "UlpDeliverHttpRequest(pRequest = %p): "
                    "exceeded site connection limit\n",
                    pRequest
                    ));

        UlSetErrorCode( pRequest,
                          UlErrorConnectionLimit,
                          pRequest->ConfigInfo.pAppPool
                          );

        Status = STATUS_INVALID_DEVICE_STATE;
        goto end;
    }

    //
    // Perf Counters (non-cached)
    //
    pCtr = pRequest->ConfigInfo.pSiteCounters;
    if (pCtr)
    {
        // NOTE: pCtr may be NULL if the SiteId was never set on the root-level
        // NOTE: Config Group for the site.  BVTs may need to be updated.

        ASSERT(IS_VALID_SITE_COUNTER_ENTRY(pCtr));

        UlIncSiteNonCriticalCounterUlong(pCtr, HttpSiteCounterAllReqs);

        if (pCtr != pConnection->pPrevSiteCounters)
        {
            if (pConnection->pPrevSiteCounters)
            {
                // Decrement old site's counters & release ref count 
                
                UlDecSiteCounter(
                    pConnection->pPrevSiteCounters, 
                    HttpSiteCounterCurrentConns
                    );
                DEREFERENCE_SITE_COUNTER_ENTRY(pConnection->pPrevSiteCounters);
            }

            UlIncSiteNonCriticalCounterUlong(pCtr, HttpSiteCounterConnAttempts);
            
            Connections = (ULONG) UlIncSiteCounter(pCtr, HttpSiteCounterCurrentConns);
            UlMaxSiteCounter(
                    pCtr,
                    HttpSiteCounterMaxConnections,
                    Connections
                    );

            // add ref for new site counters
            REFERENCE_SITE_COUNTER_ENTRY(pCtr);
            pConnection->pPrevSiteCounters = pCtr;
            
        }
    }

    ASSERT(NT_SUCCESS(Status));
    
    //
    // Install a filter if BWT is enabled for this request's site.
    // or for the control channel that owns the site. If fails 
    // refuse the connection back. (503)
    //

    Status = UlTcAddFilterForConnection(
                pConnection,
                &pRequest->ConfigInfo
                );
    
    if (!NT_SUCCESS(Status))
    {
        UlTraceError(PARSER, (
                    "UlpDeliverHttpRequest(pRequest = %p): "
                    "Bandwidth throttling failed: %s\n",
                    pRequest,
                    HttpStatusToString(Status)
                    ));

        UlSetErrorCode( pRequest,
                          UlErrorUnavailable,
                          pRequest->ConfigInfo.pAppPool
                          );
        goto end;
    }    
    
    //
    // the routing matched, let's check and see if we are active.
    // first check the control channel.
    //

    if (pRequest->ConfigInfo.pControlChannel->State != HttpEnabledStateActive)
    {
        UlTraceError(HTTP_IO,
                ("http!UlpDeliverHttpRequest Control Channel is inactive\n"
               ));

        CurrentState = HttpEnabledStateInactive;
    }
    // now check the cgroup
    else if (pRequest->ConfigInfo.CurrentState != HttpEnabledStateActive)
    {
        UlTraceError(HTTP_IO,
                ("http!UlpDeliverHttpRequest Config Group is inactive\n"
               ));

        CurrentState = HttpEnabledStateInactive;
    }
    else
    {
        CurrentState = HttpEnabledStateActive;
    }

    //
    // well, are we active?
    //
    if (CurrentState == HttpEnabledStateActive)
    {

        //
        // it's a normal request. Deliver to
        // app pool (aka client)
        //
        Status = UlDeliverRequestToProcess(
                        pRequest->ConfigInfo.pAppPool,
                        pRequest,
                        pIrpToComplete
                        );

        if (NT_SUCCESS(Status))
        {

            //
            // All done with this request. Wait for response
            // before going on.
            //

            pConnection->WaitingForResponse = 1;

            // CODEWORK: Start the "Processing" Connection Timeout Timer.

            UlTrace( PARSER, (
                "***4 pConnection %p->WaitingForResponse = 1\n",
                pConnection
                ));
        }
    }
    else
    {
        //
        // we are not active. Send a 503 response
        //

        UlTraceError(PARSER, (
                    "UlpDeliverHttpRequest(pRequest = %p): inactive\n",
                    pRequest
                    ));

        UlSetErrorCode( pRequest,
                        UlErrorUnavailable,
                        pRequest->ConfigInfo.pAppPool
                        );

        Status = STATUS_INVALID_DEVICE_STATE;
    }

end:
    return Status;
} // UlpDeliverHttpRequest



/***************************************************************************++

Routine Description:

    links the buffer into the sorted connection list.

Arguments:

    pConnection - the connection to insert into

    pRequestBuffer - the buffer to link in

--***************************************************************************/
VOID
UlpInsertBuffer(
    PUL_HTTP_CONNECTION pConnection,
    PUL_REQUEST_BUFFER pRequestBuffer
    )
{
    PLIST_ENTRY         pEntry;
    PUL_REQUEST_BUFFER  pListBuffer = NULL;

    ASSERT( UL_IS_VALID_HTTP_CONNECTION(pConnection) );
    ASSERT( UlDbgPushLockOwnedExclusive( &pConnection->PushLock ) );
    ASSERT( UL_IS_VALID_REQUEST_BUFFER(pRequestBuffer) );
    ASSERT( pRequestBuffer->UsedBytes != 0 );

    //
    // figure out where to insert the buffer into our
    // sorted queue (we need to enforce FIFO by number -
    // head is the first in).  optimize for ordered inserts by
    // searching tail to head.
    //

    pEntry = pConnection->BufferHead.Blink;

    while (pEntry != &(pConnection->BufferHead))
    {
        pListBuffer = CONTAINING_RECORD(
                            pEntry,
                            UL_REQUEST_BUFFER,
                            ListEntry
                            );

        ASSERT( UL_IS_VALID_REQUEST_BUFFER(pListBuffer) );

        //
        // if the number is less than, put it here, we are
        // searching in reverse sort order
        //

        if (pListBuffer->BufferNumber < pRequestBuffer->BufferNumber)
        {
            break;
        }

        //
        // go on to the preceding one
        //

        pEntry = pEntry->Blink;
    }

    ASSERT(pEntry == &pConnection->BufferHead  ||  NULL != pListBuffer);

    UlTrace(
        HTTP_IO, (
            "http!UlpInsertBuffer(conn=%p): inserting %p(#%d) after %p(#%d)\n",
            pConnection,
            pRequestBuffer,
            pRequestBuffer->BufferNumber,
            pListBuffer,
            (pEntry == &(pConnection->BufferHead)) ?
                -1 : pListBuffer->BufferNumber
            )
        );

    //
    // and insert it
    //

    ASSERT(UL_IS_VALID_HTTP_CONNECTION(pConnection));

    InsertHeadList(
        pEntry,
        &(pRequestBuffer->ListEntry)
        );

    WRITE_REF_TRACE_LOG2(
        g_pHttpConnectionTraceLog,
        pConnection->pConnection->pHttpTraceLog,
        REF_ACTION_INSERT_BUFFER,
        pConnection->RefCount,
        pRequestBuffer,
        __FILE__,
        __LINE__
        );

    ASSERT(UL_IS_VALID_HTTP_CONNECTION(pConnection));

}   // UlpInsertBuffer




/***************************************************************************++

Routine Description:

    Merges the unparsed bytes on a source buffer to a destination buffer.
    Assumes that there is space in the buffer.

Arguments:

    pDest - the buffer that gets the bytes
    pSrc  - the buffer that gives the bytes

--***************************************************************************/
VOID
UlpMergeBuffers(
    PUL_REQUEST_BUFFER pDest,
    PUL_REQUEST_BUFFER pSrc
    )
{
    ASSERT( UL_IS_VALID_REQUEST_BUFFER( pDest ) );
    ASSERT( UL_IS_VALID_REQUEST_BUFFER( pSrc ) );
    ASSERT( pDest->AllocBytes - pDest->UsedBytes >= UNPARSED_BUFFER_BYTES( pSrc ) );
    ASSERT( UlpIsValidRequestBufferList( pSrc->pConnection ) );

    UlTrace(HTTP_IO, (
        "http!UlpMergeBuffers(pDest = %p(#%d), pSrc = %p(#%d))\n"
        "   Copying %lu bytes from pSrc.\n"
        "   pDest->AllocBytes (%lu) - pDest->UsedBytes(%lu) = %lu available\n",
        pDest,
        pDest->BufferNumber,
        pSrc,
        pSrc->BufferNumber,
        UNPARSED_BUFFER_BYTES( pSrc ),
        pDest->AllocBytes,
        pDest->UsedBytes,
        pDest->AllocBytes - pDest->UsedBytes
        ));

    //
    // copy the unparsed bytes
    //
    RtlCopyMemory(
        pDest->pBuffer + pDest->UsedBytes,
        GET_REQUEST_BUFFER_POS( pSrc ),
        UNPARSED_BUFFER_BYTES( pSrc )
        );

    //
    // adjust buffer byte counters to match the transfer
    //
    pDest->UsedBytes += UNPARSED_BUFFER_BYTES( pSrc );
    pSrc->UsedBytes = pSrc->ParsedBytes;

    ASSERT( pDest->UsedBytes != 0 );
    ASSERT( pDest->UsedBytes <= pDest->AllocBytes );
} // UlpMergeBuffers



/***************************************************************************++

Routine Description:

    sets up pCurrentBuffer to the proper location, merging any blocks
    as needed.

Arguments:

    pConnection - the connection to adjust buffers for

--***************************************************************************/
NTSTATUS
UlpAdjustBuffers(
    PUL_HTTP_CONNECTION pConnection
    )
{
    ASSERT(UL_IS_VALID_HTTP_CONNECTION(pConnection));
    ASSERT(UlDbgPushLockOwnedExclusive(&pConnection->PushLock));

    //
    // do we have a starting buffer?
    //

    if (pConnection->pCurrentBuffer == NULL)
    {
        //
        // the list can't be empty, this is the FIRST time in
        // pCurrentBuffer is NULL
        //

        ASSERT(IsListEmpty(&(pConnection->BufferHead)) == FALSE);
        ASSERT(pConnection->NextBufferToParse == 0);

        //
        // pop from the head
        //

        pConnection->pCurrentBuffer = CONTAINING_RECORD(
                                            pConnection->BufferHead.Flink,
                                            UL_REQUEST_BUFFER,
                                            ListEntry
                                            );

        ASSERT( UL_IS_VALID_REQUEST_BUFFER(pConnection->pCurrentBuffer) );

        //
        // is this the right number?
        //

        if (pConnection->pCurrentBuffer->BufferNumber !=
            pConnection->NextBufferToParse)
        {
            pConnection->pCurrentBuffer = NULL;
            return STATUS_MORE_PROCESSING_REQUIRED;
        }

        pConnection->NextBufferToParse += 1;

        pConnection->NeedMoreData = 0;
    }

    //
    // did we need more transport data?
    //

    if (pConnection->NeedMoreData == 1)
    {
        PUL_REQUEST_BUFFER pNextBuffer;

        //
        // is it there?
        //

        if (pConnection->pCurrentBuffer->ListEntry.Flink ==
            &(pConnection->BufferHead))
        {
            //
            // need to wait for more
            //

            UlTrace(HTTP_IO, (
                "http!UlpAdjustBuffers(pHttpConn %p) NeedMoreData == 1\n"
                "    No new request buffer available yet\n",
                pConnection
                ));

            return STATUS_MORE_PROCESSING_REQUIRED;
        }

        pNextBuffer = CONTAINING_RECORD(
                            pConnection->pCurrentBuffer->ListEntry.Flink,
                            UL_REQUEST_BUFFER,
                            ListEntry
                            );

        ASSERT( UL_IS_VALID_REQUEST_BUFFER(pNextBuffer) );

        //
        // is the next buffer really the 'next' buffer?
        //

        if (pNextBuffer->BufferNumber != pConnection->NextBufferToParse)
        {
            UlTrace(HTTP_IO, (
                "http!UlpAdjustBuffers(pHttpConn %p) NeedMoreData == 1\n"
                "    Buffer %d available, but we're waiting for %d\n",
                pConnection,
                pNextBuffer->BufferNumber,
                pConnection->NextBufferToParse
                ));

            return STATUS_MORE_PROCESSING_REQUIRED;
        }

        UlTrace(HTTP_IO, (
            "http!UlpAdjustBuffers(pHttpConn %p) NeedMoreData == 1\n",
            pConnection
            ));

        //
        // is there space to merge the blocks?
        //

        if (pNextBuffer->UsedBytes <
            (pConnection->pCurrentBuffer->AllocBytes -
                pConnection->pCurrentBuffer->UsedBytes))
        {
            //
            // merge 'em .. copy the next buffer into this buffer
            //

            UlpMergeBuffers(
                pConnection->pCurrentBuffer,    // dest
                pNextBuffer                     // src
                );

            //
            // remove the next (now empty) buffer
            //

            ASSERT( pNextBuffer->UsedBytes == 0 );
            UlFreeRequestBuffer(pNextBuffer);

            ASSERT( UlpIsValidRequestBufferList( pConnection ) );

            //
            // skip the buffer sequence number as we deleted that next buffer
            // placing the data in the current buffer.  the "new" next buffer
            // will have a 1 higher sequence number.
            //

            pConnection->NextBufferToParse += 1;

            //
            // reset the signal for more data needed
            //

            pConnection->NeedMoreData = 0;

        }
        else
        {
            PUL_REQUEST_BUFFER pNewBuffer;

            //
            // allocate a new buffer with space for the remaining stuff
            // from the old buffer, and everything in the new buffer.
            //
            // this new buffer is replacing pNextBuffer so gets its
            // BufferNumber.
            //

            pNewBuffer = UlCreateRequestBuffer(
                                (pConnection->pCurrentBuffer->UsedBytes -
                                    pConnection->pCurrentBuffer->ParsedBytes) +
                                    pNextBuffer->UsedBytes,
                                pNextBuffer->BufferNumber,
                                FALSE
                                );

            if (pNewBuffer == NULL)
            {
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            pNewBuffer->pConnection = pConnection;

            UlTrace( PARSER, (
                "*** Request Buffer %p (#%d) has connection %p\n",
                pNewBuffer,
                pNewBuffer->BufferNumber,
                pConnection
                ));

            //
            // copy the unused portion into the start of this buffer
            //

            UlpMergeBuffers(
                pNewBuffer,                     // dest
                pConnection->pCurrentBuffer     // src
                );

            if ( 0 == pConnection->pCurrentBuffer->UsedBytes )
            {
                //
                // Whoops!  Accidently ate everything...zap this buffer!
                // This happens when we're ahead of the parser and there
                // are 0 ParsedBytes.
                //

                ASSERT( 0 == pConnection->pCurrentBuffer->ParsedBytes );

                UlTrace(HTTP_IO, (
                        "http!UlpAdjustBuffers: "
                        "Zapping pConnection->pCurrentBuffer %p(#%d)\n",
                        pConnection->pCurrentBuffer,
                        pConnection->pCurrentBuffer->BufferNumber
                        ));

                UlFreeRequestBuffer( pConnection->pCurrentBuffer );
                pConnection->pCurrentBuffer = NULL;
            }

            //
            // merge the next block into this one
            //

            UlpMergeBuffers(
                pNewBuffer,     // dest
                pNextBuffer     // src
                );


            //
            // Dispose of the now empty next buffer
            //

            ASSERT(pNextBuffer->UsedBytes == 0);
            UlFreeRequestBuffer(pNextBuffer);
            pNextBuffer = NULL;

            //
            // link in the new buffer
            //

            ASSERT(pNewBuffer->UsedBytes != 0 );
            UlpInsertBuffer(pConnection, pNewBuffer);

            ASSERT( UlpIsValidRequestBufferList( pConnection ) );

            //
            // this newly created (larger) buffer is still the next
            // buffer to parse
            //

            ASSERT(pNewBuffer->BufferNumber == pConnection->NextBufferToParse);

            //
            // so make it the current buffer now
            //

            pConnection->pCurrentBuffer = pNewBuffer;

            //
            // and advance the sequence checker
            //

            pConnection->NextBufferToParse += 1;

            //
            // now reset the signal for more data needed
            //

            pConnection->NeedMoreData = 0;
        }
    }
    else
    {
        //
        // is this buffer drained?
        //

        if (pConnection->pCurrentBuffer->UsedBytes ==
            pConnection->pCurrentBuffer->ParsedBytes)
        {
            PUL_REQUEST_BUFFER pOldBuffer;

            //
            // are there any more buffers?
            //

            if (pConnection->pCurrentBuffer->ListEntry.Flink ==
                &(pConnection->BufferHead))
            {

                //
                // need to wait for more.
                //
                // we leave this empty buffer around refcount'd
                // in pCurrentBuffer until a new buffer shows up,
                // or the connection is dropped.
                //
                // this is so we don't lose our place
                // and have to search the sorted queue
                //

                UlTrace(HTTP_IO, (
                    "http!UlpAdjustBuffers(pHttpConn = %p) NeedMoreData == 0\n"
                    "    buffer %p(#%d) is drained, more required\n",
                    pConnection,
                    pConnection->pCurrentBuffer,
                    pConnection->pCurrentBuffer->BufferNumber
                    ));


                return STATUS_MORE_PROCESSING_REQUIRED;
            }

            // else

            //
            // grab the next buffer
            //

            pOldBuffer = pConnection->pCurrentBuffer;

            pConnection->
                pCurrentBuffer = CONTAINING_RECORD(
                                        pConnection->
                                            pCurrentBuffer->ListEntry.Flink,
                                        UL_REQUEST_BUFFER,
                                        ListEntry
                                        );

            ASSERT( UL_IS_VALID_REQUEST_BUFFER(pConnection->pCurrentBuffer) );

            //
            // is it the 'next' buffer?
            //

            if (pConnection->pCurrentBuffer->BufferNumber !=
                pConnection->NextBufferToParse)
            {

                UlTrace(HTTP_IO, (
                    "http!UlpAdjustBuffers(pHttpConn = %p) NeedMoreData == 0\n"
                    "    Buffer %p(#%d) available, but we're waiting for buffer %d\n",
                    pConnection,
                    pConnection->pCurrentBuffer,
                    pConnection->pCurrentBuffer->BufferNumber,
                    pConnection->NextBufferToParse
                    ));

                pConnection->pCurrentBuffer = pOldBuffer;

                return STATUS_MORE_PROCESSING_REQUIRED;

            }

            //
            // bump up the buffer number
            //

            pConnection->NextBufferToParse += 1;

            pConnection->NeedMoreData = 0;
        }
    }

    return STATUS_SUCCESS;

}   // UlpAdjustBuffers



/***************************************************************************++

Routine Description:

    Routine invoked after an incoming TCP/MUX connection has been
    received (but not yet accepted).

Arguments:

    pListeningContext - Supplies an uninterpreted context value as
        passed to the UlCreateListeningEndpoint() API.

    pConnection - Supplies the connection being established.

    pRemoteAddress - Supplies the remote (client-side) address
        requesting the connection.

    RemoteAddressLength - Supplies the total byte length of the
        pRemoteAddress structure.

    ppConnectionContext - Receives a pointer to an uninterpreted
        context value to be associated with the new connection if
        accepted. If the new connection is not accepted, this
        parameter is ignored.

Return Value:

    BOOLEAN - TRUE if the connection was accepted, FALSE if not.

--***************************************************************************/
BOOLEAN
UlConnectionRequest(
    IN PVOID pListeningContext,
    IN PUL_CONNECTION pConnection,
    IN PTRANSPORT_ADDRESS pRemoteAddress,
    IN ULONG RemoteAddressLength,
    OUT PVOID *ppConnectionContext
    )
{
    PUL_HTTP_CONNECTION pHttpConnection;
    NTSTATUS status;

    UNREFERENCED_PARAMETER(pListeningContext);
    UNREFERENCED_PARAMETER(pRemoteAddress);
    UNREFERENCED_PARAMETER(RemoteAddressLength);

    //
    // Sanity check.
    //

    ASSERT( IS_VALID_CONNECTION( pConnection ) );

    UlTrace(HTTP_IO,("UlConnectionRequest: conn %p\n",pConnection));

    //
    // Check the global connection limit. If it's reached then
    // enforce it by refusing the connection request. The TDI will
    // return STATUS_CONNECTION_REFUSED when we return FALSE here
    //

    if (UlAcceptGlobalConnection() == FALSE)
    {
        UL_INC_CONNECTION_STATS( GlobalLimit );

        UlTraceError(LIMITS,
            ("UlConnectionRequest: conn %p refused global limit is reached.\n",
              pConnection
              ));

        return FALSE;
    }

    //
    // Create a new HTTP connection.
    //

    status = UlCreateHttpConnection( &pHttpConnection, pConnection );
    ASSERT( NT_SUCCESS(status) );

    //
    // We the HTTP_CONNECTION pointer as our connection context,
    // ULTDI now owns a reference (from the create).
    //

    *ppConnectionContext = pHttpConnection;

    return TRUE;

}   // UlConnectionRequest


/***************************************************************************++

Routine Description:

    Routine invoked after an incoming TCP/MUX connection has been
    fully accepted.

    This routine is also invoked if an incoming connection was not
    accepted *after* PUL_CONNECTION_REQUEST returned TRUE. In other
    words, if PUL_CONNECTION_REQUEST indicated that the connection
    should be accepted but a fatal error occurred later, then
    PUL_CONNECTION_COMPLETE is invoked.

Arguments:

    pListeningContext - Supplies an uninterpreted context value
        as passed to the UlCreateListeningEndpoint() API.

    pConnectionContext - Supplies the uninterpreted context value
        as returned by PUL_CONNECTION_REQUEST.

    Status - Supplies the completion status. If this value is
        STATUS_SUCCESS, then the connection is now fully accepted.
        Otherwise, the connection has been aborted.

--***************************************************************************/
VOID
UlConnectionComplete(
    IN PVOID pListeningContext,
    IN PVOID pConnectionContext,
    IN NTSTATUS Status
    )
{
    PUL_CONNECTION pConnection;
    PUL_HTTP_CONNECTION pHttpConnection;

    UNREFERENCED_PARAMETER(pListeningContext);

    //
    // Sanity check.
    //

    pHttpConnection = (PUL_HTTP_CONNECTION)pConnectionContext;
    ASSERT( UL_IS_VALID_HTTP_CONNECTION(pHttpConnection) );
    pConnection = pHttpConnection->pConnection;
    ASSERT( IS_VALID_CONNECTION( pConnection ) );

    UlTrace(HTTP_IO,("UlConnectionComplete: http %p conn %p status %s\n",
            pHttpConnection,
            pConnection,
            HttpStatusToString(Status)
            ));

    //
    // Blow away our HTTP connection if the connect failed.
    //

    if (!NT_SUCCESS(Status))
    {
        UL_DEREFERENCE_HTTP_CONNECTION( pHttpConnection );
    }
    else
    {
        //
        // Init connection timeout info block; implicitly starts
        // ConnectionIdle timer. We can't start the timer in
        // UlCreateHttpConnection because if the timer expires before
        // the connection is fully accepted, the connection won't have
        // an initial idle timer running. This is because abort has no
        // effect on a connection being accepted.
        //

        UlInitializeConnectionTimerInfo( &pHttpConnection->TimeoutInfo );
    }

}   // UlConnectionComplete


/***************************************************************************++

Routine Description:

    Routine invoked after an established TCP/MUX connection has been
    disconnected by the remote (client) side.

    This routine flags a UL_HTTP_CONNECTION that has been gracefully
    closed by the client. When the connection is idle, we'll close
    our half of it.

Arguments:

    pListeningContext - Supplies an uninterpreted context value
        as passed to the UlCreateListeningEndpoint() API.

    pConnectionContext - Supplies the uninterpreted context value
        as returned by PUL_CONNECTION_REQUEST.

--***************************************************************************/
VOID
UlConnectionDisconnect(
    IN PVOID pListeningContext,
    IN PVOID pConnectionContext
    )
{
    PUL_CONNECTION pConnection;
    PUL_HTTP_CONNECTION pHttpConnection;

    UNREFERENCED_PARAMETER(pListeningContext);

    //
    // Sanity check.
    //

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    pHttpConnection = (PUL_HTTP_CONNECTION)pConnectionContext;
    ASSERT(UL_IS_VALID_HTTP_CONNECTION(pHttpConnection));

    pConnection = pHttpConnection->pConnection;
    ASSERT(IS_VALID_CONNECTION(pConnection));

    UlTrace(HTTP_IO,("UlConnectionDisconnect: http %p conn %p NextBufferNumber %d\n",
            pHttpConnection,
            pConnection,
            pHttpConnection->NextBufferNumber
            ));

    UlAcquireSpinLockAtDpcLevel(
        &pHttpConnection->BufferingInfo.BufferingSpinLock
        );

    if (pHttpConnection->BufferingInfo.ReadIrpPending)
    {
        //
        // Read IRP is pending, defer setting pHttpConnection->LastBufferNumber
        // in read completion.
        //

        pHttpConnection->BufferingInfo.ConnectionDisconnect = TRUE;
    }
    else
    {
        //
        // Do it now.
        //

        UlpDoConnectionDisconnect(pHttpConnection);
    }

    UlReleaseSpinLockFromDpcLevel(
        &pHttpConnection->BufferingInfo.BufferingSpinLock
        );

}   // UlConnectionDisconnect


/***************************************************************************++

Routine Description:

    Routine invoked after an established TCP/MUX connection has been
    disconnected by the remote (client) side.

    This routine flags a UL_HTTP_CONNECTION that has been gracefully
    closed by the client. When the connection is idle, we'll close
    our half of it.

Arguments:

    pConnection - Supplies the UL_HTTP_CONNECTION.

--***************************************************************************/
VOID
UlpDoConnectionDisconnect(
    IN PUL_HTTP_CONNECTION pConnection
    )
{
    //
    // Sanity check.
    //

    ASSERT(UL_IS_VALID_HTTP_CONNECTION(pConnection));
    ASSERT(UlDbgSpinLockOwned(&pConnection->BufferingInfo.BufferingSpinLock));

    UlTrace(HTTP_IO,("UlpDoConnectionDisconnect: http %p NextBufferNumber %d\n",
            pConnection,
            pConnection->NextBufferNumber
            ));

    if (pConnection->NextBufferNumber > 0)
    {
        //
        // Mark the connection as having been disconnected gracefully
        // by the client. We do this by remembering the current
        // buffer number. This lets the parser figure out when it
        // has received the last buffer.
        //

        pConnection->LastBufferNumber = pConnection->NextBufferNumber;

        //
        // Client disconnected gracefully. If the connection is idle
        // we should clean up now. Otherwise we wait until the
        // connection is idle, and then close our half.
        //
        UL_REFERENCE_HTTP_CONNECTION(pConnection);

        UL_QUEUE_WORK_ITEM(
            &pConnection->DisconnectWorkItem,
            &UlpConnectionDisconnectWorker
            );
    }
    else
    {
        //
        // We have not received any data on this connection
        // before the disconnect. Close the connection now.
        //
        // We have to handle this as a special case, because
        // the parser takes (LastBufferNumber == 0) to
        // mean that we haven't yet received a disconnect.
        //

        UL_REFERENCE_HTTP_CONNECTION(pConnection);

        UL_QUEUE_WORK_ITEM(
            &pConnection->DisconnectWorkItem,
            &UlpCloseConnectionWorker
            );
    }

}   // UlpDoConnectionDisconnect


/***************************************************************************++

Routine Description:

    Closes the connection after a graceful client disconnect, if the
    connection is idle or if the client sent only part of a request
    before disconnecting.

Arguments:

    pWorkItem -- a pointer to a UL_WORK_ITEM DisconnectWorkItem

--***************************************************************************/
VOID
UlpConnectionDisconnectWorker(
    IN PUL_WORK_ITEM pWorkItem
    )
{
    PUL_HTTP_CONNECTION pConnection;

    PAGED_CODE();
    ASSERT(pWorkItem);

    pConnection = CONTAINING_RECORD(
                        pWorkItem,
                        UL_HTTP_CONNECTION,
                        DisconnectWorkItem
                        );

    UlTrace(HTTP_IO, (
        "http!UlpConnectionDisconnectWorker (%p) pConnection (%p)\n",
         pWorkItem,
         pConnection
         ));

    ASSERT(UL_IS_VALID_HTTP_CONNECTION(pConnection));
    ASSERT(pConnection->LastBufferNumber > 0);

    //
    // grab the lock
    //

    UlAcquirePushLockExclusive(&pConnection->PushLock);

    //
    // If the parser has handled all the data, call
    // UlpCloseDisconnectedConnection, which will close the
    // connection if appropriate.
    //

    UlTrace(HTTP_IO, (
        "http!UlpConnectionDisconnectWorker\n"
        "        NextBufferNumber %d, NextBufferToParse %d, LastBufferNumber %d\n"
        "        pRequest %p, ParseState %d (%s)",
        pConnection->NextBufferNumber,
        pConnection->NextBufferToParse,
        pConnection->LastBufferNumber,
        pConnection->pRequest,
        pConnection->pRequest ? pConnection->pRequest->ParseState : 0,
        pConnection->pRequest
            ? UlParseStateToString(pConnection->pRequest->ParseState)
            : "<None>"
        ));

    if (!pConnection->UlconnDestroyed &&
        pConnection->NextBufferToParse == pConnection->LastBufferNumber)
    {
        UlpCloseDisconnectedConnection(pConnection);
    }

    //
    // done with the lock
    //

    UlReleasePushLockExclusive(&pConnection->PushLock);

    //
    // release the reference added in UlConnectionDisconnect
    //

    UL_DEREFERENCE_HTTP_CONNECTION(pConnection);

} // UlpConnectionDisconnectWorker


/***************************************************************************++

Routine Description:

    Closes the connection after a graceful client disconnect, if the
    connection is idle.

Arguments:

    pWorkItem -- a pointer to a UL_WORK_ITEM DisconnectWorkItem

--***************************************************************************/
VOID
UlpCloseConnectionWorker(
    IN PUL_WORK_ITEM pWorkItem
    )
{
    PUL_HTTP_CONNECTION pConnection;

    PAGED_CODE();
    ASSERT(pWorkItem);

    pConnection = CONTAINING_RECORD(
                        pWorkItem,
                        UL_HTTP_CONNECTION,
                        DisconnectWorkItem
                        );

    UlTrace(HTTP_IO, (
        "http!UlpCloseConnectionWorker (%p) pConnection (%p)\n",
         pWorkItem,
         pConnection
         ));

    ASSERT(UL_IS_VALID_HTTP_CONNECTION(pConnection));
    ASSERT(0 == pConnection->LastBufferNumber);

    UlCloseConnection(
            pConnection->pConnection,
            TRUE,           // AbortiveDisconnect
            NULL,           // pCompletionRoutine
            NULL            // pCompletionContext
            );

    //
    // release the reference added in UlConnectionDisconnect
    //

    UL_DEREFERENCE_HTTP_CONNECTION(pConnection);

}   // UlpCloseConnectionWorker


/***************************************************************************++

Routine Description:

    Closes the connection after a graceful client disconnect, if the
    connection is idle or if the client sent only part of a request
    before disconnecting.

Arguments:

    pConnection - the connection to be disconnected

--***************************************************************************/
VOID
UlpCloseDisconnectedConnection(
    IN PUL_HTTP_CONNECTION pConnection
    )
{
    //
    // Sanity check.
    //

    PAGED_CODE();
    ASSERT(UL_IS_VALID_HTTP_CONNECTION(pConnection));
    ASSERT(UlDbgPushLockOwnedExclusive(&pConnection->PushLock));
    ASSERT(pConnection->NextBufferNumber == pConnection->LastBufferNumber);

    //
    // The parser has parsed all the available data.
    //

    if (pConnection->pRequest == NULL || pConnection->pRequest->InDrain)
    {
        //
        // We can't be ParseDone if we are in drain because if so pRequest
        // should have been cleaned up already.
        //

        ASSERT(pConnection->pRequest == NULL ||
               pConnection->pRequest->ParseState != ParseDoneState);

        //
        // We're completely idle. Close the connection.
        //

        UlTrace(HTTP_IO, (
            "http!UlpCloseDisconnectedConnection closing idle conn %p\n",
            pConnection
            ));

        UlDisconnectHttpConnection(
            pConnection,
            NULL,   // pCompletionRoutine
            NULL    // pCompletionContext
            );
        
    }
    else if (pConnection->pRequest->ParseState != ParseDoneState)
    {
        //
        // The connection was closed before a full request
        // was sent out so send a 400 error.
        //
        // UlSendErrorResponse will close the connection.
        //

        UlTraceError(HTTP_IO, (
            "http!UlpCloseDisconnectedConnection sending 400 on %p\n",
            pConnection
            ));

        UlSetErrorCode( pConnection->pRequest, UlError, NULL);

        UlSendErrorResponse(pConnection);
    }
    else
    {
        //
        // Connection isn't ready to close yet.
        //
    
        UlTrace(HTTP_IO, (
            "http!UlpCloseDisconnectedConnection NOT ready to close conn %p\n",
            pConnection
            ));
    }

} // UlpCloseDisconnectedConnection


/***************************************************************************++

Routine Description:

    Routine invoked after an established TCP/MUX connection has been
    disconnected by us (server side) we make a final check here to see
    if we have to drain the connection or not.

Arguments:

    pListeningContext - Supplies an uninterpreted context value
        as passed to the UlCreateListeningEndpoint() API.

    pConnectionContext - Supplies the uninterpreted context value
        as returned by PUL_CONNECTION_REQUEST.

--***************************************************************************/
VOID
UlConnectionDisconnectComplete(
    IN PVOID pListeningContext,
    IN PVOID pConnectionContext
    )
{
    PUL_HTTP_CONNECTION pConnection;
    KIRQL OldIrql;
    BOOLEAN Drained;

    UNREFERENCED_PARAMETER(pListeningContext);

    //
    // Sanity check.
    //

    pConnection = (PUL_HTTP_CONNECTION)pConnectionContext;
    ASSERT(UL_IS_VALID_HTTP_CONNECTION(pConnection));

    UlTrace( HTTP_IO, ("UlConnectionDisconnectComplete: pConnection %p \n",
             pConnection
             ));

    UlAcquireSpinLock(
        &pConnection->BufferingInfo.BufferingSpinLock,
        &OldIrql
        );

    pConnection->BufferingInfo.DrainAfterDisconnect = TRUE;

    Drained = (BOOLEAN) (pConnection->BufferingInfo.ReadIrpPending
                        || (pConnection->BufferingInfo.TransportBytesNotTaken == 0));

    UlReleaseSpinLock(
        &pConnection->BufferingInfo.BufferingSpinLock,
        OldIrql
        );

    // Avoid adding this connection to the workitem queue, if possible

    if (Drained)
    {
        WRITE_REF_TRACE_LOG2(
            g_pTdiTraceLog,
            pConnection->pConnection->pTraceLog,
            REF_ACTION_DRAIN_UL_CONN_DISCONNECT_COMPLETE,
            pConnection->pConnection->ReferenceCount,
            pConnection->pConnection,
            __FILE__,
            __LINE__
            );
    }
    else
    {
        UL_REFERENCE_HTTP_CONNECTION( pConnection );

        UL_QUEUE_WORK_ITEM(
                &pConnection->DisconnectDrainWorkItem,
                &UlpConnectionDisconnectCompleteWorker
                );
    }

}   // UlConnectionDisconnectComplete


/***************************************************************************++

Routine Description:

    Worker function to do cleanup work that shouldn't happen above DPC level.

Arguments:

    pWorkItem -- a pointer to a UL_WORK_ITEM DisconnectDrainWorkItem

--***************************************************************************/
VOID
UlpConnectionDisconnectCompleteWorker(
    IN PUL_WORK_ITEM pWorkItem
    )
{
    PUL_HTTP_CONNECTION pConnection;

    PAGED_CODE();

    ASSERT(pWorkItem);

    pConnection = CONTAINING_RECORD(
                        pWorkItem,
                        UL_HTTP_CONNECTION,
                        DisconnectDrainWorkItem
                        );

    UlTrace(HTTP_IO, (
        "http!UlpConnectionDisconnectCompleteWorker (%p) pConnection (%p)\n",
         pWorkItem,
         pConnection
         ));

    ASSERT(UL_IS_VALID_HTTP_CONNECTION(pConnection));

    //
    // If connection is already get destroyed just bail out !
    //

    WRITE_REF_TRACE_LOG2(
        g_pTdiTraceLog,
        pConnection->pConnection->pTraceLog,
        REF_ACTION_DRAIN_UL_CONN_DISCONNECT_COMPLETE,
        pConnection->pConnection->ReferenceCount,
        pConnection->pConnection,
        __FILE__,
        __LINE__
        );

    //
    // Check to see if we have to drain out or not.
    //

    UlpDiscardBytesFromConnection( pConnection );

    //
    // Deref the http connection added in UlConnectionDisconnectComplete.
    //

    UL_DEREFERENCE_HTTP_CONNECTION( pConnection );

} // UlpConnectionDisconnectCompleteWorker



/***************************************************************************++

Routine Description:

    Routine invoked after an established TCP/MUX connection has been
    destroyed.

Arguments:

    pListeningContext - Supplies an uninterpreted context value
        as passed to the UlCreateListeningEndpoint() API.

    pConnectionContext - Supplies the uninterpreted context value
        as returned by PUL_CONNECTION_REQUEST.

--***************************************************************************/
VOID
UlConnectionDestroyed(
    IN PVOID pListeningContext,
    IN PVOID pConnectionContext
    )
{
    PUL_CONNECTION pConnection;
    PUL_HTTP_CONNECTION pHttpConnection;

    UNREFERENCED_PARAMETER(pListeningContext);

    //
    // Sanity check.
    //

    pHttpConnection = (PUL_HTTP_CONNECTION)pConnectionContext;
    pConnection = pHttpConnection->pConnection;
    ASSERT( IS_VALID_CONNECTION( pConnection ) );

    UlTrace(
        HTTP_IO, (
            "http!UlConnectionDestroyed: httpconn %p ulconn %p\n",
            pHttpConnection,
            pConnection
            )
        );

    //
    // Remove the CONNECTION and REQUEST opaque id entries and the ULTDI
    // reference
    //

    UL_QUEUE_WORK_ITEM(
        &pHttpConnection->WorkItem,
        UlConnectionDestroyedWorker
        );

}   // UlConnectionDestroyed


/***************************************************************************++

Routine Description:

    handles retrieving entity body from the http request and placing into
    user mode buffers.

Arguments:

    pRequest - the request to receive from.

    pIrp - the user irp to copy it into.  this will be pended, always.

--***************************************************************************/
NTSTATUS
UlReceiveEntityBody(
    IN PUL_APP_POOL_PROCESS pProcess,
    IN PUL_INTERNAL_REQUEST pRequest,
    IN PIRP pIrp
    )
{
    NTSTATUS            Status;
    PIO_STACK_LOCATION  pIrpSp;

    UNREFERENCED_PARAMETER(pProcess);

    ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pRequest));
    ASSERT(UL_IS_VALID_HTTP_CONNECTION(pRequest->pHttpConn));

    //
    // get the current stack location (a macro)
    //

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

    UlTraceVerbose(HTTP_IO, (
        "http!UlReceiveEntityBody: process=%p, req=%p, irp=%p, irpsp=%p\n",
        pProcess, pRequest, pIrp, pIrpSp
        ));

    //
    // is there any recv buffer?
    //

    if (pIrpSp->Parameters.DeviceIoControl.OutputBufferLength == 0)
    {
        //
        // nope, shortcircuit this
        //

        Status = STATUS_PENDING;
        pIrp->IoStatus.Information = 0;
        goto end;
    }

    //
    // grab our lock
    //

    UlAcquirePushLockExclusive(&pRequest->pHttpConn->PushLock);

    //
    // Make sure we're not cleaning up the request before queuing an
    // IRP on it.
    //

    if (pRequest->InCleanup)
    {
        Status = STATUS_CONNECTION_DISCONNECTED;

        UlReleasePushLockExclusive(&pRequest->pHttpConn->PushLock);

        UlTraceVerbose(HTTP_IO, (
            "http!UlReceiveEntityBody(req=%p, irp=%p): "
            "Cleaning up request, %s\n",
            pRequest,
            pIrp,
            HttpStatusToString(Status)
            ));

        goto end;
    }

    //
    // is there any data to read? either
    //
    //      1) there were no entity chunks OR
    //
    //      2) there were and :
    //
    //          2b) we've are done parsing all of them AND
    //
    //          2c) we've read all we parsed
    //
    //      3) we have encountered an error when parsing
    //         the entity body. Therefore parser was in the
    //         error state.
    //

    if ((pRequest->ContentLength == 0 && pRequest->Chunked == 0) ||
        (pRequest->ParseState > ParseEntityBodyState &&
            pRequest->ChunkBytesRead == pRequest->ChunkBytesParsed) ||
        (pRequest->ParseState == ParseErrorState)
        )
    {
        if ( pRequest->ParseState == ParseErrorState )
        {
            //
            // Do not route up the entity body if we have
            // encountered an error when parsing it.
            //

            Status = STATUS_INVALID_DEVICE_REQUEST;
        }
        else
        {
            //
            // nope, complete right away
            //

            Status = STATUS_END_OF_FILE;
        }

        UlReleasePushLockExclusive(&pRequest->pHttpConn->PushLock);

        UlTraceVerbose(HTTP_IO, (
            "http!UlReceiveEntityBody(req=%p, irp=%p): "
            "No data to read, %s\n",
            pRequest,
            pIrp,
            HttpStatusToString(Status)
            ));

        goto end;
    }

    //
    // queue the irp
    //

    IoMarkIrpPending(pIrp);

    //
    // handle 100 continue message reponses
    //

    if ( HTTP_GREATER_EQUAL_VERSION(pRequest->Version, 1, 1) )
    {
        //
        // if this is a HTTP/1.1 PUT or POST request,
        // send "100 Continue" response.
        //

        if ( (HttpVerbPUT  == pRequest->Verb) ||
             (HttpVerbPOST == pRequest->Verb) )
        {
            //
            // Only send continue once...
            //

            if ( (0 == pRequest->SentContinue) &&
                 (0 == pRequest->SentResponse) &&
                 // 
                 // The following two conditions ensure we have NOT yet
                 // received any  of the entity body for this request.
                 //
                 ((pRequest->Chunked && (0 == pRequest->ParsedFirstChunk))  
                 || (!pRequest->Chunked && (0 == pRequest->ChunkBytesParsed))))
            {
                ULONG BytesSent;

                BytesSent = UlSendSimpleStatus(pRequest, UlStatusContinue);
                pRequest->SentContinue = 1;

                // Update the server to client bytes sent.
                // The logging & perf counters will use it.

                pRequest->BytesSent += BytesSent;

                UlTraceVerbose(HTTP_IO, (
                    "http!UlReceiveEntityBody(req=%p, irp=%p): "
                    "sent \"100 Continue\", bytes sent = %I64u\n",
                    pRequest, pIrp, pRequest->BytesSent
                    ));
            }
        }
    }

    //
    // give it a pointer to the request object
    //

    pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer = pRequest;

    UL_REFERENCE_INTERNAL_REQUEST(pRequest);

    //
    // set to these to null just in case the cancel routine runs
    //

    pIrp->Tail.Overlay.ListEntry.Flink = NULL;
    pIrp->Tail.Overlay.ListEntry.Blink = NULL;

    IoSetCancelRoutine(pIrp, &UlpCancelEntityBody);

    //
    // cancelled?
    //

    if (pIrp->Cancel)
    {
        //
        // darn it, need to make sure the irp get's completed
        //

        if (IoSetCancelRoutine( pIrp, NULL ) != NULL)
        {
            //
            // we are in charge of completion, IoCancelIrp didn't
            // see our cancel routine (and won't).  ioctl wrapper
            // will complete it
            //

            UlReleasePushLockExclusive(&pRequest->pHttpConn->PushLock);

            //
            // let go of the request reference
            //

            UL_DEREFERENCE_INTERNAL_REQUEST(
                (PUL_INTERNAL_REQUEST)(pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer)
                );

            pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer = NULL;

            pIrp->IoStatus.Information = 0;

            UlUnmarkIrpPending( pIrp );
            Status = STATUS_CANCELLED;
            goto end;
        }

        //
        // our cancel routine will run and complete the irp,
        // don't touch it
        //

        //
        // STATUS_PENDING will cause the ioctl wrapper to
        // not complete (or touch in any way) the irp
        //

        Status = STATUS_PENDING;

        UlReleasePushLockExclusive(&pRequest->pHttpConn->PushLock);
        goto end;
    }

    //
    // now we are safe to queue it
    //

    //
    // queue the irp on the request
    //

    InsertHeadList(&(pRequest->IrpHead), &(pIrp->Tail.Overlay.ListEntry));

    //
    // all done
    //

    Status = STATUS_PENDING;

    //
    // Process the buffer queue (which might process the irp we just queued)
    //

    ASSERT( UlpIsValidRequestBufferList( pRequest->pHttpConn ) );

    UlProcessBufferQueue(pRequest, NULL, 0);

    UlReleasePushLockExclusive(&pRequest->pHttpConn->PushLock);

    //
    // all done
    //

end:
    UlTraceVerbose(HTTP_IO, (
        "http!UlReceiveEntityBody(req=%p, irp=%p): returning %s\n",
        pRequest,
        pIrp,
        HttpStatusToString(Status)
        ));

    RETURN(Status);

}   // UlReceiveEntityBody


/***************************************************************************++

Routine Description:

    processes the pending irp queue and buffered body. copying data from the
    buffers into the irps, releasing the buffers and completing the irps

    you must already have the resource locked exclusive on the request prior
    to calling this procedure.

Arguments:

    pRequest - the request which we should process.

    pEntityBody - optionally provides a buffer to copy entity body

    EntityBody - the length of the optional buffer to copy entity body

--***************************************************************************/
VOID
UlProcessBufferQueue(
    IN PUL_INTERNAL_REQUEST pRequest,
    IN PUCHAR pEntityBody OPTIONAL,
    IN ULONG EntityBodyLength OPTIONAL
    )
{
    ULONG                   OutputBufferLength = 0;
    PUCHAR                  pOutputBuffer = NULL;
    PIRP                    pIrp;
    PIO_STACK_LOCATION      pIrpSp = NULL;
    PLIST_ENTRY             pEntry;
    ULONG                   BytesToCopy;
    ULONG                   BufferLength;
    ULONG                   TotalBytesConsumed;
    PUL_REQUEST_BUFFER      pNewBuffer;
    BOOLEAN                 InDrain;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pRequest));

    ASSERT(UlDbgPushLockOwnedExclusive(&pRequest->pHttpConn->PushLock));

    //
    // now let's pop some buffers off the list
    //

    TotalBytesConsumed = 0;
    pIrp = NULL;
    InDrain = (BOOLEAN) pRequest->InDrain;

    if (InDrain)
    {
        //
        // pseudo buffer has unlimited space in drain mode
        //

        OutputBufferLength = ULONG_MAX;
    }
    else
    if (pEntityBody)
    {
        OutputBufferLength = EntityBodyLength;
        pOutputBuffer = pEntityBody;
    }

    while (TRUE)
    {
        //
        // is there any more entity body to read?
        //

        UlTraceVerbose(HTTP_IO, (
            "http!UlProcessBufferQueue(req=%p): "
            "ParseState=%d (%s), ChunkBytesRead=%I64u, ChunkBytesParsed=%I64u, "
            "pChunkBuffer=%p\n",
            pRequest,
            pRequest->ParseState,
            UlParseStateToString(pRequest->ParseState),
            pRequest->ChunkBytesRead, pRequest->ChunkBytesParsed,
            pRequest->pChunkBuffer
            ));

        if (pRequest->ParseState > ParseEntityBodyState &&
            pRequest->ChunkBytesRead == pRequest->ChunkBytesParsed)
        {
            //
            // nope, let's loop through all of the irp's, completing 'em
            //

            UlTraceVerbose(HTTP_IO, (
                "http!UlProcessBufferQueue(req=%p): no more EntityBody\n",
                pRequest
                ));

            BufferLength = 0;
        }

        //
        // Do we have data ready to be read ?
        //
        // we have not received the first chunk from the parser? OR
        // the parser has not parsed any more data, we've read it all so far
        //

        else if (pRequest->pChunkBuffer == NULL ||
                 pRequest->ChunkBytesRead == pRequest->ChunkBytesParsed)
        {
            //
            // Wait for the parser .... UlpParseNextRequest will call
            // this function when it has seen more.
            //

            UlTraceVerbose(HTTP_IO, (
                "http!UlProcessBufferQueue(req=%p): pChunkBuffer=%p, "
                "ChunkBytesRead=%I64u, ChunkBytesParsed=%I64u; breaking.\n",
                pRequest, pRequest->pChunkBuffer,
                pRequest->ChunkBytesRead, pRequest->ChunkBytesParsed
                ));

            break;
        }

        //
        // We are ready to process !
        //

        else
        {
            BufferLength = pRequest->pChunkBuffer->UsedBytes -
                            DIFF(pRequest->pChunkLocation -
                                pRequest->pChunkBuffer->pBuffer);

            UlTraceVerbose(HTTP_IO, (
                "http!UlProcessBufferQueue(req=%p): BufferLength=0x%x\n",
                pRequest, BufferLength
                ));

            //
            // Do we really have parsed bytes to process ?
            //

            if (0 == BufferLength)
            {
                if (pRequest->pChunkBuffer->ListEntry.Flink !=
                    &(pRequest->pHttpConn->BufferHead))
                {
                    pNewBuffer = CONTAINING_RECORD(
                                    pRequest->pChunkBuffer->ListEntry.Flink,
                                    UL_REQUEST_BUFFER,
                                    ListEntry
                                    );

                    ASSERT( UL_IS_VALID_REQUEST_BUFFER(pNewBuffer) );

                    //
                    // There had better be some bytes in this buffer
                    //

                    ASSERT( 0 != pNewBuffer->UsedBytes );
                }
                else
                {
                    pNewBuffer = NULL;
                }

                if (NULL == pNewBuffer || 0 == pNewBuffer->ParsedBytes)
                {
                    //
                    // Still waiting for the parser, so break the loop.
                    // We will get stuck if this check is not done (477936).
                    //

                    break;
                }
            }
        }

        //
        // do we need a fresh irp?
        //

        if (OutputBufferLength == 0)
        {
            if (pEntityBody || InDrain)
            {
                //
                // break the loop if we drained all data
                //

                break;
            }

            //
            // need to complete the current in-use irp first
            //

            if (pIrp != NULL)
            {
                //
                // let go of the request reference
                //

                UL_DEREFERENCE_INTERNAL_REQUEST(
                    (PUL_INTERNAL_REQUEST)pIrpSp->Parameters.
                                        DeviceIoControl.Type3InputBuffer
                    );

                pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer = NULL;

                //
                // complete the used irp
                //

                UlTraceVerbose(HTTP_IO, (
                    "http!UlProcessBufferQueue(req=%p): "
                    "completing Irp %p, %s\n",
                    pRequest,
                    pIrp,
                    HttpStatusToString(pIrp->IoStatus.Status)
                ));

                //
                // Use IO_NO_INCREMENT to avoid the work thread being
                // rescheduled.
                //

                UlCompleteRequest(pIrp, IO_NO_INCREMENT);
                pIrp = NULL;

            }

            //
            // dequeue an irp from the request
            //

            while (IsListEmpty(&(pRequest->IrpHead)) == FALSE)
            {
                pEntry = RemoveTailList(&(pRequest->IrpHead));
                pEntry->Blink = pEntry->Flink = NULL;

                pIrp = CONTAINING_RECORD(pEntry, IRP, Tail.Overlay.ListEntry);
                pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

                //
                // pop the cancel routine
                //

                if (IoSetCancelRoutine(pIrp, NULL) == NULL)
                {
                    //
                    // IoCancelIrp pop'd it first
                    //
                    // ok to just ignore this irp, it's been pop'd off the
                    // queue and will be completed in the cancel routine.
                    //
                    // keep looking for a irp to use
                    //

                    pIrp = NULL;
                }
                else if (pIrp->Cancel)
                {
                    //
                    // we pop'd it first. but the irp is being cancelled
                    // and our cancel routine will never run. lets be
                    // nice and complete the irp now (vs. using it
                    // then completing it - which would also be legal).
                    //

                    //
                    // let go of the request reference
                    //

                    UL_DEREFERENCE_INTERNAL_REQUEST(
                        (PUL_INTERNAL_REQUEST)pIrpSp->Parameters.
                                        DeviceIoControl.Type3InputBuffer
                        );

                    pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer = NULL;

                    //
                    // complete the irp
                    //

                    pIrp->IoStatus.Status = STATUS_CANCELLED;
                    pIrp->IoStatus.Information = 0;

                    UlTraceVerbose(HTTP_IO, (
                        "http!UlProcessBufferQueue(req=%p): "
                        "completing cancelled Irp %p, %s\n",
                        pRequest,
                        pIrp,
                        HttpStatusToString(pIrp->IoStatus.Status)
                        ));

                    UlCompleteRequest(pIrp, IO_NO_INCREMENT);

                    pIrp = NULL;
                }
                else
                {

                    //
                    // we are free to use this irp !
                    //

                    break;
                }

            }   // while (IsListEmpty(&(pRequest->IrpHead)) == FALSE)

            //
            // did we get an irp?

            //

            if (pIrp == NULL)
            {
                //
                // stop looping
                //

                break;
            }

            UlTraceVerbose(HTTP_IO, (
                "http!UlProcessBufferQueue(req=%p): found Irp %p\n",
                pRequest, pIrp
                ));

            //
            // CODEWORK: we could release the request now.
            //

            OutputBufferLength =
                pIrpSp->Parameters.DeviceIoControl.OutputBufferLength;

            ASSERT(NULL != pIrp->MdlAddress);
    
            pOutputBuffer = (PUCHAR) MmGetSystemAddressForMdlSafe(
                                pIrp->MdlAddress,
                                NormalPagePriority
                                );

            if ( pOutputBuffer == NULL )
            {
                pIrp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
                pIrp->IoStatus.Information = 0;

                break;
            }

            //
            // fill in the IO_STATUS_BLOCK
            //

            pIrp->IoStatus.Status = STATUS_SUCCESS;
            pIrp->IoStatus.Information = 0;

        } // if (OutputBufferLength == 0)


        UlTrace(
            HTTP_IO, (
                "http!UlProcessBufferQueue(req=%p): pChunkBuffer=%p(#%d)\n",
                pRequest,
                pRequest->pChunkBuffer,
                pRequest->pChunkBuffer == NULL ?
                    -1 :
                    pRequest->pChunkBuffer->BufferNumber

                )
            );

        //
        // how much of it can we copy?  min of both buffer sizes
        // and the chunk size
        //

        BytesToCopy = MIN(BufferLength, OutputBufferLength);
        BytesToCopy = (ULONG)(MIN(
                            (ULONGLONG)(BytesToCopy),
                            pRequest->ChunkBytesToRead
                            ));

        if (BytesToCopy > 0)
        {
            ASSERT(pRequest->pChunkBuffer != NULL) ;

            if (!InDrain)
            {
                //
                // copy the buffer
                //

                RtlCopyMemory(
                    pOutputBuffer,
                    pRequest->pChunkLocation,
                    BytesToCopy
                    );

                if (pIrp)
                {
                    pIrp->IoStatus.Information += BytesToCopy;
                }

                IF_DEBUG2BOTH(HTTP_IO, VERBOSE)
                {
                    UlTraceVerbose( HTTP_IO, (
                        ">>>> http!UlProcessBufferQueue(req=%p): %lu bytes\n",
                        pRequest, BytesToCopy
                    ));

                    UlDbgPrettyPrintBuffer(pRequest->pChunkLocation, BytesToCopy);

                    UlTraceVerbose( HTTP_IO, ("<<<<\n"));
                }
            }
            else
            {
                // 
                // Since we're draining, we need to account for the 
                // bytes received here, rather than up in UlpParseNextRequest.
                //
                pRequest->BytesReceived += BytesToCopy;

                UlTrace(HTTP_IO, (
                    "http!UlProcessBufferQueue(req=%p): "
                    "InDrain: draining %lu bytes\n",
                    pRequest,
                    BytesToCopy
                    ));
            }

            pRequest->pChunkLocation += BytesToCopy;
            BufferLength -= BytesToCopy;

            pRequest->ChunkBytesToRead -= BytesToCopy;
            pRequest->ChunkBytesRead += BytesToCopy;

            pOutputBuffer += BytesToCopy;
            OutputBufferLength -= BytesToCopy;

            TotalBytesConsumed += BytesToCopy;
        }
        else
        {
            UlTraceVerbose(HTTP_IO, (
                "http!UlProcessBufferQueue(req=%p): BytesToCopy=0\n",
                pRequest
                ));
        }


        //
        // are we all done with body?

        //
        // when the parser is all done, and we caught up with the parser
        // we are all done.
        //

        UlTraceVerbose(HTTP_IO, (
            "http!UlProcessBufferQueue(req=%p): "
            "ParseState=%d (%s), Chunk: BytesRead=%I64u, BytesParsed=%I64u, "
            "BytesToRead=%I64u, BytesToParse=%I64u, BufferLength=%lu\n",
            pRequest,
            pRequest->ParseState, UlParseStateToString(pRequest->ParseState),
            pRequest->ChunkBytesRead, pRequest->ChunkBytesParsed,
            pRequest->ChunkBytesToRead,
            pRequest->ChunkBytesToParse, BufferLength
            ));

        if (pRequest->ParseState > ParseEntityBodyState &&
            pRequest->ChunkBytesRead == pRequest->ChunkBytesParsed)
        {
            //
            // we are done buffering, mark this irp's return status
            // if we didn't copy any data into it
            //

            if (!InDrain && pIrp && pIrp->IoStatus.Information == 0)
            {
                pIrp->IoStatus.Status = STATUS_END_OF_FILE;
            }

            //
            // force it to complete at the top of the loop
            //

            OutputBufferLength = 0;

            UlTraceVerbose(HTTP_IO, (
                "http!UlProcessBufferQueue(req=%p): "
                "set Irp %p status to EOF\n",
                pRequest, pIrp
                ));
        }

        //
        // need to do buffer management? three cases to worry about:
        //
        //  1) consumed the buffer, but more chunk bytes exist
        //
        //  2) consumed the buffer, and no more chunk bytes exist
        //
        //  3) did not consume the buffer, but no more chunk bytes exist
        //

        else if (BufferLength == 0)
        {
            //
            // consumed the buffer, has the parser already seen another?
            //

            //
            // end of the list?
            //

            if (pRequest->pChunkBuffer->ListEntry.Flink !=
                &(pRequest->pHttpConn->BufferHead))
            {
                pNewBuffer = CONTAINING_RECORD(
                                    pRequest->pChunkBuffer->ListEntry.Flink,
                                    UL_REQUEST_BUFFER,
                                    ListEntry
                                    );

                ASSERT( UL_IS_VALID_REQUEST_BUFFER(pNewBuffer) );

                //
                // There had better be some bytes in this buffer
                //
                ASSERT( 0 != pNewBuffer->UsedBytes );

            }
            else
            {
                pNewBuffer = NULL;
            }

            UlTraceVerbose(HTTP_IO, (
                "http!UlProcessBufferQueue(req=%p): "
                "pNewBuffer = %p, %lu parsed bytes\n",
                pRequest, pNewBuffer, (pNewBuffer ? pNewBuffer->ParsedBytes : 0)
                ));

            //
            // the flink buffer is a "next buffer" (the list is circular)
            // AND that buffer has been consumed by the parser,
            //
            // then we too can move on to it and start consuming.
            //

            if (pNewBuffer != NULL && pNewBuffer->ParsedBytes > 0)
            {
                PUL_REQUEST_BUFFER pOldBuffer;

                //
                // remember the old buffer
                //

                pOldBuffer = pRequest->pChunkBuffer;

                ASSERT(pNewBuffer->BufferNumber > pOldBuffer->BufferNumber);

                //
                // use it the new one
                //

                pRequest->pChunkBuffer = pNewBuffer;
                ASSERT( UL_IS_VALID_REQUEST_BUFFER(pRequest->pChunkBuffer) );

                //
                // update our current location in the buffer and record
                // its length
                //

                pRequest->pChunkLocation = pRequest->pChunkBuffer->pBuffer;

                BufferLength = pRequest->pChunkBuffer->UsedBytes;

                //
                // did the chunk end on that buffer boundary and there are
                // more chunks ?
                //

                if (pRequest->ChunkBytesToRead == 0)
                {
                    NTSTATUS    Status;
                    ULONG       BytesTaken = 0L;

                    //
                    // we know there are more chunk buffers,
                    // thus we must be chunk encoded
                    //

                    ASSERT(pRequest->Chunked == 1);

                    //
                    // the chunk length is not allowed to span buffers,
                    // let's parse it
                    //

                    Status = ParseChunkLength(
                                    pRequest->ParsedFirstChunk,
                                    pRequest->pChunkLocation,
                                    BufferLength,
                                    &BytesTaken,
                                    &(pRequest->ChunkBytesToRead)
                                    );

                    UlTraceVerbose(HTTP_IO, (
                        "http!UlProcessBufferQueue(pReq=%p): %s. "
                        "Chunk length (a): %lu bytes taken, "
                        "%I64u bytes to read.\n",
                        pRequest,
                        HttpStatusToString(Status),
                        BytesTaken,
                        pRequest->ChunkBytesToRead
                        ));

                    //
                    // this can't fail, the only failure case from
                    // ParseChunkLength spanning buffers, which the parser
                    // would have fixed in HandleRequest
                    //

                    ASSERT(NT_SUCCESS(Status) && BytesTaken > 0);
                    ASSERT(pRequest->ChunkBytesToRead > 0);

                    ASSERT(BytesTaken <= BufferLength);

                    pRequest->pChunkLocation += BytesTaken;
                    BufferLength -= BytesTaken;

                    //
                    // Keep track of the chunk encoding overhead. If we don't,
                    // then we'll slowly "leak" a few bytes in the BufferingInfo
                    // for every chunk processed.
                    //
                    
                    TotalBytesConsumed += BytesTaken;
                    
                }   // if (pRequest->ChunkBytesToRead == 0)

                UlTrace(HTTP_IO, (
                    "http!UlProcessBufferQueue(pRequest = %p)\n"
                    "    finished with pOldBuffer = %p(#%d)\n"
                    "    moved on to pChunkBuffer = %p(#%d)\n"
                    "    pConn(%p)->pCurrentBuffer = %p(#%d)\n"
                    "    pRequest->pLastHeaderBuffer = %p(#%d)\n",
                    pRequest,
                    pOldBuffer,
                    pOldBuffer->BufferNumber,
                    pRequest->pChunkBuffer,
                    pRequest->pChunkBuffer ? pRequest->pChunkBuffer->BufferNumber : -1,
                    pRequest->pHttpConn,
                    pRequest->pHttpConn->pCurrentBuffer,
                    pRequest->pHttpConn->pCurrentBuffer->BufferNumber,
                    pRequest->pLastHeaderBuffer,
                    pRequest->pLastHeaderBuffer->BufferNumber
                    ));

                //
                // let the old buffer go if it doesn't contain any header
                // data. We're done with it.
                //

                if (pOldBuffer != pRequest->pLastHeaderBuffer)
                {
                    //
                    // the connection should be all done using this, the only
                    // way we get here is if the parser has seen this buffer
                    // thus pCurrentBuffer points at least to pNewBuffer.
                    //

                    ASSERT(pRequest->pHttpConn->pCurrentBuffer != pOldBuffer);

                    UlFreeRequestBuffer(pOldBuffer);
                    pOldBuffer = NULL;
                }

            } // if (pNewBuffer != NULL && pNewBuffer->ParsedBytes > 0)

        }   // else if (BufferLength == 0)

        //
        // ok, there's more bytes in the buffer, but how about the chunk?
        //

        //
        // Have we taken all of the current chunk?
        //

        else if (pRequest->ChunkBytesToRead == 0)
        {

            //
            // Are we are still behind the parser?
            //

            if (pRequest->ChunkBytesRead < pRequest->ChunkBytesParsed)
            {
                NTSTATUS    Status;
                ULONG       BytesTaken;

                ASSERT(pRequest->Chunked == 1);

                //
                // the chunk length is not allowed to span buffers,
                // let's parse it
                //

                Status = ParseChunkLength(
                                pRequest->ParsedFirstChunk,
                                pRequest->pChunkLocation,
                                BufferLength,
                                &BytesTaken,
                                &(pRequest->ChunkBytesToRead)
                                );

                UlTraceVerbose(HTTP_IO, (
                    "http!UlProcessBufferQueue(pRequest=%p): %s. "
                    "chunk length (b): %lu bytes taken, "
                    "%I64u bytes to read.\n",
                    pRequest,
                    HttpStatusToString(Status),
                    BytesTaken,
                    pRequest->ChunkBytesToRead
                    ));

                //
                // this can't fail, the only failure case from
                // ParseChunkLength spanning buffers, which the parser
                // would have fixed in HandleRequest
                //

                ASSERT(NT_SUCCESS(Status) && BytesTaken > 0);
                ASSERT(pRequest->ChunkBytesToRead > 0);

                ASSERT(BytesTaken <= BufferLength);

                pRequest->pChunkLocation += BytesTaken;
                BufferLength -= BytesTaken;

                //
                // Keep track of the chunk encoding overhead. If we don't,
                // then we'll slowly "leak" a few bytes in the BufferingInfo
                // for every chunk processed.
                //
                
                TotalBytesConsumed += BytesTaken;
            }
            else
            {
                //
                // Need to wait for the parser to parse more
                //

                UlTraceVerbose(HTTP_IO, (
                    "http!UlProcessBufferQueue(pRequest = %p): "
                    "need to parse more\n",
                    pRequest
                    ));

                break;
            }
        } // else if (pRequest->ChunkBytesToRead == 0)


        //
        // next irp or buffer
        //

    }   // while (TRUE)

    //
    // complete the irp we put partial data in
    //

    if (pIrp != NULL)
    {

        //
        // let go of the request reference
        //

        UL_DEREFERENCE_INTERNAL_REQUEST(
            (PUL_INTERNAL_REQUEST)pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer
            );

        pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer = NULL;

        //
        // complete the used irp
        //

        UlTraceVerbose(HTTP_IO, (
            "http!UlProcessBufferQueue(req=%p): "
            "completing partially used Irp %p, %s\n",
            pRequest,
            pIrp,
            HttpStatusToString(pIrp->IoStatus.Status)
            ));

        //
        // Use IO_NO_INCREMENT to avoid the work thread being rescheduled.
        //

        UlCompleteRequest(pIrp, IO_NO_INCREMENT);

        pIrp = NULL;
    }
    else
    {
        UlTraceVerbose(HTTP_IO, (
            "http!UlProcessBufferQueue(req=%p): no irp with partial data\n",
            pRequest
            ));
    }

    //
    // Tell the connection how many bytes we consumed. This
    // may allow us to restart receive indications.
    //

    UlTraceVerbose(HTTP_IO, (
        "http!UlProcessBufferQueue(req=%p, httpconn=%p): "
        "%lu bytes consumed\n",
        pRequest, pRequest->pHttpConn, TotalBytesConsumed
        ));

    if (TotalBytesConsumed != 0)
    {
        UlpConsumeBytesFromConnection(pRequest->pHttpConn, TotalBytesConsumed);
    }

    //
    // all done
    //

}   // UlProcessBufferQueue


/***************************************************************************++

Routine Description:

    This function subtracts from the total number of bytes currently buffered
    on the UL_HTTP_CONNECTION object. If there are bytes from the transport
    that we previously refused, this function may issue a receive to restart
    the flow of data from TCP.

Arguments:

    pConnection - the connection on which the bytes came in
    BytesCount - the number of bytes consumed

--***************************************************************************/

VOID
UlpConsumeBytesFromConnection(
    IN PUL_HTTP_CONNECTION pConnection,
    IN ULONG ByteCount
    )
{
    KIRQL OldIrql;
    ULONG SpaceAvailable;
    ULONG BytesToRead;
    BOOLEAN IssueReadIrp;

    //
    // Sanity check.
    //

    ASSERT(UL_IS_VALID_HTTP_CONNECTION(pConnection));

    //
    // Set up locals.
    //

    BytesToRead = 0;
    IssueReadIrp = FALSE;

    //
    // Consume the bytes.
    //

    UlAcquireSpinLock(
        &pConnection->BufferingInfo.BufferingSpinLock,
        &OldIrql
        );

    //
    // Tell the connection how many bytes we consumed.
    // HTTP header bytes are "consumed" as soon as we
    // parse them.
    //

    if (ByteCount)
    {
        UlTrace(HTTP_IO, (
            "UlpConsumeBytesFromConnection(pconn = %p, bytes = %lu)"
            " ZeroBytes consumed !"
            ));
    
        ASSERT(ByteCount <= pConnection->BufferingInfo.BytesBuffered);

        if (ByteCount > pConnection->BufferingInfo.BytesBuffered)
        {
            //
            // This should never happen, but if it does then make sure
            // we don't subtract more BufferedBytes than we have.
            //
            ByteCount = pConnection->BufferingInfo.BytesBuffered;
        }

        //
        // Compute the new number of buffered bytes.
        //

        pConnection->BufferingInfo.BytesBuffered -= ByteCount;    
    }
    
    //
    // Enforce the 16K Buffer Limit.
    //

    if (g_UlMaxBufferedBytes > pConnection->BufferingInfo.BytesBuffered)
    {
        SpaceAvailable = g_UlMaxBufferedBytes
                            - pConnection->BufferingInfo.BytesBuffered;
    }
    else
    {
        SpaceAvailable = 0;
    }

    UlTrace(HTTP_IO, (
        "UlpConsumeBytesFromConnection(pconn = %p, bytes = %lu)\n"
        "        SpaceAvailable = %lu, BytesBuffered %lu->%lu, not taken = %lu\n",
        pConnection,
        ByteCount,
        SpaceAvailable,
        pConnection->BufferingInfo.BytesBuffered + ByteCount,
        pConnection->BufferingInfo.BytesBuffered,
        pConnection->BufferingInfo.TransportBytesNotTaken
        ));

    //
    // See if we need to issue a receive to restart the flow of data.
    //

    if ((SpaceAvailable > 0) &&
        (pConnection->BufferingInfo.TransportBytesNotTaken > 0) &&
        (!pConnection->BufferingInfo.ReadIrpPending))
    {
        //
        // Remember that we issued an IRP.
        //

        pConnection->BufferingInfo.ReadIrpPending = TRUE;

        //
        // Issue the Read IRP outside the spinlock.
        //

        IssueReadIrp = TRUE;
        BytesToRead = pConnection->BufferingInfo.TransportBytesNotTaken;

        //
        // Don't read more bytes than we want to buffer.
        //

        BytesToRead = MIN(BytesToRead, SpaceAvailable);
    }

    UlReleaseSpinLock(
        &pConnection->BufferingInfo.BufferingSpinLock,
        OldIrql
        );

    if (IssueReadIrp)
    {
        NTSTATUS Status;
        PUL_REQUEST_BUFFER pRequestBuffer;

        //
        // get a new request buffer, but initialize it
        // with a bogus number. We have to allocate it now,
        // but we want to set the number when the data
        // arrives in the completion routine (like UlHttpReceive
        // does) to avoid synchronization trouble.
        //

        ASSERT(BytesToRead > 0);

        pRequestBuffer = UlCreateRequestBuffer(
                                BytesToRead,
                                (ULONG)-1,      // BufferNumber
                                FALSE
                                );

        if (pRequestBuffer)
        {

            //
            // Add a backpointer to the connection.
            //

            pRequestBuffer->pConnection = pConnection;

            UlTrace(HTTP_IO, (
                "UlpConsumeBytesFromConnection(pconn=%p). About to read %lu bytes.\n",
                pConnection, BytesToRead
                ));

            //
            // We've got the buffer. Issue the receive.
            // Reference the connection so it doesn't
            // go away while we're waiting. The reference
            // will be removed after the completion.
            //

            UL_REFERENCE_HTTP_CONNECTION( pConnection );

            Status = UlReceiveData(
                            pConnection->pConnection,
                            pRequestBuffer->pBuffer,
                            BytesToRead,
                           &UlpRestartHttpReceive,
                            pRequestBuffer
                            );
        }
        else
        {
            //
            // We're out of memory. Nothing we can do.
            //
            Status = STATUS_NO_MEMORY;
        }

        if (!NT_SUCCESS(Status))
        {
            //
            // Couldn't issue the read. Close the connection.
            //

            UlCloseConnection(
                pConnection->pConnection,
                TRUE,                       // AbortiveDisconnect
                NULL,                       // pCompletionRoutine
                NULL                        // pCompletionContext
                );
        }
    }
    else
    {
        UlTrace(HTTP_IO, (
            "UlpConsumeBytesFromConnection(pconn=%p). Not reading.\n",
            pConnection, BytesToRead
            ));
    }

} // UlpConsumeBytesFromConnection



/***************************************************************************++

Routine Description:

    Once a connection get disconnected gracefully and there's still unreceived
    data on it. We have to drain this extra bytes to expect the tdi disconnect
    indication. We have to drain this data because we need the disconnect indi
    cation to clean up the connection. And we cannot simply abort it. If we do
    not do this we will leak this connection object  and finally it will cause
    shutdown failures.

Arguments:

    pConnection - stuck connection we have to drain out to complete the
                  gracefull disconnect.

--***************************************************************************/

VOID
UlpDiscardBytesFromConnection(
    IN PUL_HTTP_CONNECTION pConnection
    )
{
    NTSTATUS Status;
    PUL_REQUEST_BUFFER pRequestBuffer;
    KIRQL OldIrql;
    ULONG BytesToRead;

    //
    // Sanity check and init
    //

    ASSERT(UL_IS_VALID_HTTP_CONNECTION(pConnection));

    Status         = STATUS_SUCCESS;
    BytesToRead    = 0;
    pRequestBuffer = NULL;

    //
    // Mark the drain state and restart receive if necessary.
    //

    UlAcquireSpinLock(
        &pConnection->BufferingInfo.BufferingSpinLock,
        &OldIrql
        );

    pConnection->BufferingInfo.DrainAfterDisconnect = TRUE;

    //
    // Even if ReadIrp is pending, it does not matter as we will just  discard
    // the indications from now on. We indicate this by marking the above flag
    //

    if ( pConnection->BufferingInfo.ReadIrpPending ||
         pConnection->BufferingInfo.TransportBytesNotTaken == 0
         )
    {
        UlReleaseSpinLock(
            &pConnection->BufferingInfo.BufferingSpinLock,
            OldIrql
            );

        return;
    }

    //
    // As soon as we enter this "DrainAfterDisconnect" state we will not be
    // processing and inserting request buffers anymore. For any new receive
    // indications, we will just mark the whole available data as taken and
    // don't do nothing about it.
    //

    WRITE_REF_TRACE_LOG2(
        g_pTdiTraceLog,
        pConnection->pConnection->pTraceLog,
        REF_ACTION_DRAIN_UL_CONN_START,
        pConnection->pConnection->ReferenceCount,
        pConnection->pConnection,
        __FILE__,
        __LINE__
        );

    //
    // We need to issue a receive to restart the flow of data again. Therefore
    // we can drain.
    //

    pConnection->BufferingInfo.ReadIrpPending = TRUE;

    BytesToRead = pConnection->BufferingInfo.TransportBytesNotTaken;

    UlReleaseSpinLock(
        &pConnection->BufferingInfo.BufferingSpinLock,
        OldIrql
        );

    //
    // Do not try to drain more than g_UlMaxBufferedBytes. If necessary we will
    // issue another receive later.
    //

    BytesToRead = MIN( BytesToRead, g_UlMaxBufferedBytes );

    UlTrace(HTTP_IO,(
        "UlpDiscardBytesFromConnection: pConnection (%p) consuming %lu bytes\n",
         pConnection,
         BytesToRead
         ));

    //
    // Issue the Read IRP outside the spinlock. Issue the receive.  Reference
    // the connection so it doesn't go away while we're waiting. The reference
    // will be removed after the completion.
    //

    pRequestBuffer = UlCreateRequestBuffer( BytesToRead, (ULONG)-1, FALSE );

    if (pRequestBuffer)
    {
        //
        // We won't use this buffer but simply discard it when completion happens.
        // Let's still set the pConnection so that completion function doesn't
        // complain
        //

        pRequestBuffer->pConnection = pConnection;

        UL_REFERENCE_HTTP_CONNECTION( pConnection );

        Status = UlReceiveData(pConnection->pConnection,
                               pRequestBuffer->pBuffer,
                               BytesToRead,
                              &UlpRestartHttpReceive,
                               pRequestBuffer
                               );
    }
    else
    {
        //
        // We're out of memory. Nothing we can do.
        //

        Status = STATUS_NO_MEMORY;
    }

    if ( !NT_SUCCESS(Status) )
    {
        //
        // Couldn't issue the receive. ABORT the connection.
        //
        // CODEWORK: We need a real abort here. If connection is
        // previously gracefully disconnected and a fatal failure
        // happened during drain after disconnect. This abort will
        // be discarded by the Close handler. We have to provide a
        // way to do a forceful abort here.
        //

        UlCloseConnection(
                pConnection->pConnection,
                TRUE,                       // Abortive
                NULL,                       // pCompletionRoutine
                NULL                        // pCompletionContext
                );
    }

} // UlpDiscardBytesFromConnection


/***************************************************************************++

Routine Description:

    Called on a read completion. This happens when we had stopped
    data indications for some reason and then restarted them. This
    function mirrors UlHttpReceive.

Arguments:

    pContext - pointer to the UL_REQUEST_BUFFER
    Status - Status from UlReceiveData
    Information - bytes transferred

--***************************************************************************/
VOID
UlpRestartHttpReceive(
    IN PVOID        pContext,
    IN NTSTATUS     Status,
    IN ULONG_PTR    Information
    )
{
    PUL_HTTP_CONNECTION pConnection;
    PUL_REQUEST_BUFFER pRequestBuffer;
    KIRQL OldIrql;
    ULONG TransportBytesNotTaken;

    pRequestBuffer = (PUL_REQUEST_BUFFER)pContext;
    ASSERT(UL_IS_VALID_REQUEST_BUFFER(pRequestBuffer));

    pConnection = pRequestBuffer->pConnection;
    ASSERT(UL_IS_VALID_HTTP_CONNECTION(pConnection));

    ASSERT(!NT_SUCCESS(Status) || 0 != Information);

    if (NT_SUCCESS(Status))
    {
        //
        // update our stats
        //
        UlAcquireSpinLock(
            &pConnection->BufferingInfo.BufferingSpinLock,
            &OldIrql
            );

        ASSERT(Information <= pConnection->BufferingInfo.TransportBytesNotTaken);

        //
        // We've now read the bytes from the transport and
        // buffered them.
        //
        pConnection->BufferingInfo.TransportBytesNotTaken -= (ULONG) Information;
        pConnection->BufferingInfo.BytesBuffered += (ULONG) Information;

        UlTraceVerbose(HTTP_IO,
                       ("UlpRestartHttpReceive(conn=%p): "
                        "BytesBuffered %lu->%lu, "
                        "TransportBytesNotTaken %lu->%lu\n",
                        pConnection,
                        pConnection->BufferingInfo.BytesBuffered
                            - (ULONG) Information,
                        pConnection->BufferingInfo.BytesBuffered,
                        pConnection->BufferingInfo.TransportBytesNotTaken
                            + (ULONG) Information,
                        pConnection->BufferingInfo.TransportBytesNotTaken
                        ));

        pConnection->BufferingInfo.ReadIrpPending = FALSE;

        if ( pConnection->BufferingInfo.DrainAfterDisconnect )
        {
            //
            // Just free the memory and restart the receive if necessary.
            //

            TransportBytesNotTaken = pConnection->BufferingInfo.TransportBytesNotTaken;

            UlReleaseSpinLock(
                &pConnection->BufferingInfo.BufferingSpinLock,
                OldIrql
                );

            WRITE_REF_TRACE_LOG2(
                g_pTdiTraceLog,
                pConnection->pConnection->pTraceLog,
                REF_ACTION_DRAIN_UL_CONN_RESTART,
                pConnection->pConnection->ReferenceCount,
                pConnection->pConnection,
                __FILE__,
                __LINE__
                );

            if ( TransportBytesNotTaken )
            {
                //
                // Keep draining ...
                //

                UlpDiscardBytesFromConnection( pConnection );
            }

            UlTrace(HTTP_IO,(
               "UlpRestartHttpReceive(d): "
               "pConnection (%p) drained %Iu remaining %lu\n",
                pConnection,
                Information,
                TransportBytesNotTaken
                ));

            //
            // Free the request buffer. And release our reference.
            //

            pRequestBuffer->pConnection = NULL;
            UlFreeRequestBuffer( pRequestBuffer );
            UL_DEREFERENCE_HTTP_CONNECTION( pConnection );

            return;
        }

        //
        // Get the request buffer ready to be inserted.
        //

        pRequestBuffer->UsedBytes = (ULONG) Information;
        ASSERT( 0 != pRequestBuffer->UsedBytes );

        pRequestBuffer->BufferNumber = pConnection->NextBufferNumber;
        pConnection->NextBufferNumber++;

        //
        // Do connection disconnect logic here if we got deferred previously.
        //

        if (pConnection->BufferingInfo.ConnectionDisconnect)
        {
            pConnection->BufferingInfo.ConnectionDisconnect = FALSE;
            UlpDoConnectionDisconnect(pConnection);
        }

        UlReleaseSpinLock(
            &pConnection->BufferingInfo.BufferingSpinLock,
            OldIrql
            );

        UlTrace(HTTP_IO, (
            "UlpRestartHttpReceive(pconn = %p, %s, bytes rec'd=%Iu)\n"
            "        BytesBuffered = %lu, not taken = %lu\n",
            pConnection,
            HttpStatusToString(Status),
            Information,
            pConnection->BufferingInfo.BytesBuffered,
            pConnection->BufferingInfo.TransportBytesNotTaken
            ));

        //
        // queue it off
        //

        UlTrace( PARSER, (
            "*** Request Buffer %p(#%d) has connection %p\n",
            pRequestBuffer,
            pRequestBuffer->BufferNumber,
            pConnection
            ));

        if (NULL == InterlockedPushEntrySList(
                        &pConnection->ReceiveBufferSList,
                        &pRequestBuffer->SListEntry
                        ))
        {
            UL_QUEUE_WORK_ITEM(
                &pConnection->ReceiveBufferWorkItem,
                &UlpHandleRequest
                );

            UlTraceVerbose( HTTP_IO, (
                "Request Buffer %p(#%d) + UlpHandleRequest workitem "
                "queued to connection %p\n",
                pRequestBuffer,
                pRequestBuffer->BufferNumber,
                pConnection
                ));
        }
        else
        {
            UL_DEREFERENCE_HTTP_CONNECTION(pConnection);
        }
    }
    else //  !NT_SUCCESS(Status)
    {
        UlCloseConnection(
            pConnection->pConnection,
            TRUE,
            NULL,
            NULL
            );

        //
        // Release the reference we added to the connection
        // before issuing the read. Normally this ref would
        // be released in UlpHandleRequest.
        //
        UL_DEREFERENCE_HTTP_CONNECTION(pConnection);

        //
        // free the request buffer.
        //

        UlFreeRequestBuffer(pRequestBuffer);
    }
} // UlpRestartHttpReceive



/***************************************************************************++

Routine Description:

    cancels the pending user mode irp which was to receive entity body.  this
    routine ALWAYS results in the irp being completed.

    note: we queue off to cancel in order to process the cancellation at lower
    irql.

Arguments:

    pDeviceObject - the device object

    pIrp - the irp to cancel

--***************************************************************************/
VOID
UlpCancelEntityBody(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    )
{
    UNREFERENCED_PARAMETER(pDeviceObject);

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    ASSERT(pIrp != NULL);

    //
    // release the cancel spinlock.  This means the cancel routine
    // must be the one completing the irp (to avoid the race of
    // completion + reuse prior to the cancel routine running).
    //

    IoReleaseCancelSpinLock(pIrp->CancelIrql);

    //
    // queue the cancel to a worker to ensure passive irql.
    //

    UL_CALL_PASSIVE(
        UL_WORK_ITEM_FROM_IRP( pIrp ),
        &UlpCancelEntityBodyWorker
        );

} // UlpCancelEntityBody



/***************************************************************************++

Routine Description:

    Actually performs the cancel for the irp.

Arguments:

    pWorkItem - the work item to process.

--***************************************************************************/
VOID
UlpCancelEntityBodyWorker(
    IN PUL_WORK_ITEM pWorkItem
    )
{
    PIRP                    pIrp;
    PUL_INTERNAL_REQUEST    pRequest;

    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // grab the irp off the work item
    //

    pIrp = UL_WORK_ITEM_TO_IRP( pWorkItem );

    ASSERT(IS_VALID_IRP(pIrp));

    //
    // grab the request off the irp
    //

    pRequest = (PUL_INTERNAL_REQUEST)(
                    IoGetCurrentIrpStackLocation(pIrp)->
                        Parameters.DeviceIoControl.Type3InputBuffer
                    );

    ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pRequest));

    //
    // grab the lock protecting the queue'd irp
    //

    UlAcquirePushLockExclusive(&pRequest->pHttpConn->PushLock);

    //
    // does it need to be dequeue'd ?
    //

    if (pIrp->Tail.Overlay.ListEntry.Flink != NULL)
    {
        //
        // remove it
        //

        RemoveEntryList(&(pIrp->Tail.Overlay.ListEntry));

        pIrp->Tail.Overlay.ListEntry.Flink = NULL;
        pIrp->Tail.Overlay.ListEntry.Blink = NULL;

    }

    //
    // let the lock go
    //

    UlReleasePushLockExclusive(&pRequest->pHttpConn->PushLock);

    //
    // let our reference go
    //

    IoGetCurrentIrpStackLocation(pIrp)->
        Parameters.DeviceIoControl.Type3InputBuffer = NULL;

    UL_DEREFERENCE_INTERNAL_REQUEST(pRequest);

    //
    // complete the irp
    //

    pIrp->IoStatus.Status = STATUS_CANCELLED;
    pIrp->IoStatus.Information = 0;

    UlTrace(HTTP_IO, (
        "UlpCancelEntityBodyWorker(pIrp=%p): %s.\n",
        pIrp,
        HttpStatusToString(pIrp->IoStatus.Status)
        ));

    UlCompleteRequest( pIrp, IO_NO_INCREMENT );

} // UlpCancelEntityBodyWorker


//
// types and functions for sending error responses
//

typedef struct _UL_HTTP_ERROR_ENTRY
{
    UL_HTTP_ERROR   ErrorCode;
    USHORT          StatusCode;
    USHORT          ReasonLength;
    USHORT          BodyLength;
    USHORT          LogLength;
    PCSTR           ErrorCodeString;
    PCSTR           pReasonPhrase;
    PCSTR           pBody;
    PCSTR           pLog;                   // Goes to error log file
    
} UL_HTTP_ERROR_ENTRY, PUL_HTTP_ERROR_ENTRY;

#define HTTP_ERROR_ENTRY(ErrorCode, StatusCode, pReasonPhrase, pBody, pLog)    \
    {                                                   \
        (ErrorCode),                                    \
        (StatusCode),                                   \
        sizeof((pReasonPhrase))-sizeof(CHAR),           \
        sizeof((pBody))-sizeof(CHAR),                   \
        sizeof((pLog))-sizeof(CHAR),                    \
        #ErrorCode,                                     \
        (pReasonPhrase),                                \
        (pBody),                                        \
        (pLog)                                          \
    }

//
// ErrorTable[] must match the order of the UL_HTTP_ERROR enum
// in httptypes.h. The Reason Phrases are generally taken from
// RFC 2616, section 10.4 "Client Error 4xx" and
// section 10.5 "Server Error 5xx".
//

const
UL_HTTP_ERROR_ENTRY ErrorTable[] =
{
    HTTP_ERROR_ENTRY(UlErrorNone, 0, "", "", ""),   // not a valid error

    //
    // 4xx Client Errors
    //
    
    HTTP_ERROR_ENTRY(UlError, 
                       400, 
                       "Bad Request",
                       "<h1>Bad Request</h1>",
                       "BadRequest"
                       ),
    HTTP_ERROR_ENTRY(UlErrorVerb, 
                       400, 
                       "Bad Request",
                       "<h1>Bad Request (Invalid Verb)</h1>",
                       "Verb"
                       ),
    HTTP_ERROR_ENTRY(UlErrorUrl, 
                       400, 
                       "Bad Request",
                       "<h1>Bad Request (Invalid URL)</h1>",
                       "URL"
                       ),
    HTTP_ERROR_ENTRY(UlErrorHeader, 
                       400, 
                       "Bad Request",
                       "<h1>Bad Request (Invalid Header Name)</h1>",
                       "Header"
                       ),
    HTTP_ERROR_ENTRY(UlErrorHost, 
                       400, 
                       "Bad Request",
                       "<h1>Bad Request (Invalid Hostname)</h1>",
                       "Hostname"
                       ),
    HTTP_ERROR_ENTRY(UlErrorCRLF, 
                       400, 
                       "Bad Request",
                       "<h1>Bad Request (Invalid CR or LF)</h1>",
                       "Invalid_CR/LF"
                       ),
    HTTP_ERROR_ENTRY(UlErrorNum, 
                       400, 
                       "Bad Request",
                       "<h1>Bad Request (Invalid Number)</h1>",
                       "Number"
                       ),
    HTTP_ERROR_ENTRY(UlErrorFieldLength, 
                       400, 
                       "Bad Request",
                       "<h1>Bad Request (Header Field Too Long)</h1>",
                       "FieldLength"
                       ),
    HTTP_ERROR_ENTRY(UlErrorRequestLength, 
                       400, 
                       "Bad Request",
                       "<h1>Bad Request (Request Header Too Long)</h1>",
                       "RequestLength"
                       ),

    HTTP_ERROR_ENTRY(UlErrorForbiddenUrl, 
                       403, 
                       "Forbidden",
                       "<h1>Forbidden (Invalid URL)</h1>",
                       "Forbidden"
                       ),
    HTTP_ERROR_ENTRY(UlErrorContentLength, 
                       411, 
                       "Length Required",
                       "<h1>Length Required</h1>",
                       "LengthRequired"
                       ),
    HTTP_ERROR_ENTRY(UlErrorPreconditionFailed, 
                       412, 
                       "Precondition Failed",
                       "<h1>Precondition Failed</h1>",
                       "Precondition"
                       ),
    HTTP_ERROR_ENTRY(UlErrorEntityTooLarge, 
                       413, 
                       "Request Entity Too Large",
                       "<h1>Request Entity Too Large</h1>",
                       "EntityTooLarge"
                       ),
    HTTP_ERROR_ENTRY(UlErrorUrlLength, 
                       414, 
                       "Request-URI Too Long",
                       "<h1>Url Too Long</h1>",
                       "URL_Length"
                       ),

    //
    // 5xx Server Errors
    //
    
    HTTP_ERROR_ENTRY(UlErrorInternalServer, 
                       500, 
                       "Internal Server Error",
                       "<h1>Internal Server Error</h1>",
                       "Internal"
                       ),
    HTTP_ERROR_ENTRY(UlErrorNotImplemented, 
                       501, 
                       "Not Implemented",
                       "<h1>Not Implemented</h1>",
                       "N/I"
                       ),

    HTTP_ERROR_ENTRY(UlErrorUnavailable, 
                       503, 
                       "Service Unavailable",
                       "<h1>Service Unavailable</h1>",
                       "N/A"
                       ),

    //
    // We used to return extended AppPool state in HTTP 503 Error messages. 
    // We decided to replace these with a generic 503 error, to reduce
    // information disclosure.  However, we'll still keep the state,
    // as we might change this in the future. We still report the detailed
    // reason in the error log file.
    //
    // The comments represent the old error code.
    //
    
    // "Forbidden - Too Many Users", 
    // "<h1>Forbidden - Too Many Users</h1>"
    
    HTTP_ERROR_ENTRY(UlErrorConnectionLimit, 
                     503, 
                     "Service Unavailable",
                     "<h1>Service Unavailable</h1>",
                     "ConnLimit"
                     ),

    // "Multiple Application Errors - Application Taken Offline",
    // "<h1>Multiple Application Errors - Application Taken Offline</h1>"
    
    HTTP_ERROR_ENTRY(UlErrorRapidFailProtection, 
                     503, 
                     "Service Unavailable",
                     "<h1>Service Unavailable</h1>",
                     "AppOffline"
                     ),

    // "Application Request Queue Full",
    // "<h1>Application Request Queue Full</h1>"
    
    HTTP_ERROR_ENTRY(UlErrorAppPoolQueueFull, 
                     503,
                     "Service Unavailable",
                     "<h1>Service Unavailable</h1>",
                     "QueueFull"
                     ),

    // "Administrator Has Taken Application Offline",
    // "<h1>Administrator Has Taken Application Offline</h1>"
    
    HTTP_ERROR_ENTRY(UlErrorDisabledByAdmin, 
                     503,
                     "Service Unavailable",
                     "<h1>Service Unavailable</h1>",
                     "Disabled"
                     ),

    // "Application Automatically Shutdown Due to Administrator Policy",
    // "<h1>Application Automatically Shutdown Due to Administrator Policy</h1>"
    
    HTTP_ERROR_ENTRY(UlErrorJobObjectFired, 
                     503,
                     "Service Unavailable",
                     "<h1>Service Unavailable</h1>",
                     "AppShutdown"
                     ),

    // Appool process is too busy to handle the request. The connection is
    // timed out because of TimerAppPool.

    HTTP_ERROR_ENTRY(UlErrorAppPoolBusy, 
                       503, 
                       "Service Unavailable",
                       "<h1>Service Unavailable</h1>",
                       "AppPoolTimer"
                       ),
    
    HTTP_ERROR_ENTRY(UlErrorVersion, 
                       505, 
                       "HTTP Version Not Supported",
                       "<h1>HTTP Version Not Supported</h1>",
                       "Version_N/S"
                       ),
}; // ErrorTable[]



/***************************************************************************++

Routine Description:

    Set the pRequest->ErrorCode. Makes breakpointing easier to have
    a special function.

Arguments:

    self explanatory

--***************************************************************************/
VOID
UlSetErrorCodeFileLine(
    IN OUT  PUL_INTERNAL_REQUEST pRequest,
    IN      UL_HTTP_ERROR        ErrorCode,
    IN      PUL_APP_POOL_OBJECT  pAppPool,
    IN      PCSTR                pFileName,
    IN      USHORT               LineNumber
    )
{
    ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pRequest));
    ASSERT(UlErrorNone < ErrorCode  &&  ErrorCode < UlErrorMax);

    pRequest->ParseState = ParseErrorState;
    pRequest->ErrorCode  = ErrorCode;

    /* If pAppPool is not null then try to set the LB Capacity as well */
    /* It is required if the error code is 503 related */

    if (pAppPool) 
    {
        ASSERT(IS_VALID_AP_OBJECT(pAppPool));

        pRequest->LoadBalancerCapability = pAppPool->LoadBalancerCapability;
    }
    else
    {
        ASSERT(503 != ErrorTable[ErrorCode].StatusCode);
    }

    UlTraceError(PARSER,
            ("http!UlSetErrorCode(Req=%p, Err=%d %s, Status=%hu, \"%s\") "
             "@ %s:%hu\n",
             pRequest, ErrorCode,
             ErrorTable[ErrorCode].ErrorCodeString,
             ErrorTable[ErrorCode].StatusCode,
             ErrorTable[ErrorCode].pBody,
             UlDbgFindFilePart(pFileName),
             LineNumber
            ));

#if DBG
    if (g_UlBreakOnError)
        DbgBreakPoint();
#else // !DBG
    UNREFERENCED_PARAMETER(pFileName);
    UNREFERENCED_PARAMETER(LineNumber);
#endif // !DBG

} // UlSetErrorCodeFileLine

/***************************************************************************++

Routine Description:

    Logs an error record.

    Caller must own the httpconn pushlock.

    The main reason that this function is here because, we use the above 
    error table. I din't want to duplicate the table.

Arguments:

    pHttpConn       - Connection and its request.
    pInfo           - Extra info (ANSI)
    InfoSize        - Size of the info in bytes, excluding the terminating
                      null.

    CheckIfDropped  - Caller must set this to TRUE, if it is going to abort
                      the conenction after calling this function.
                      This is to prevent double logging.
    
--***************************************************************************/

VOID
UlErrorLog(
    IN     PUL_HTTP_CONNECTION     pHttpConn,
    IN     PUL_INTERNAL_REQUEST    pRequest,    
    IN     PCHAR                   pInfo,
    IN     USHORT                  InfoSize,
    IN     BOOLEAN                 CheckIfDropped
    )
{
    NTSTATUS          LogStatus;
    UL_ERROR_LOG_INFO ErrorLogInfo;    

    //
    // Sanity check
    //

    PAGED_CODE();
    
    ASSERT(UlDbgPushLockOwnedExclusive( &pHttpConn->PushLock ));
    ASSERT(UL_IS_VALID_HTTP_CONNECTION( pHttpConn ));

    if ( CheckIfDropped )
    {
        if ( pHttpConn->Dropped )
        {
            return;
        }

        pHttpConn->Dropped = TRUE;
    }
  
    UlpInitErrorLogInfo( &ErrorLogInfo,
                          pHttpConn,
                          pRequest,
                          pInfo,
                          InfoSize
                          );

    LogStatus = UlLogHttpError( &ErrorLogInfo );
    
    if (!NT_SUCCESS( LogStatus ))
    {
        UlTraceError( ERROR_LOGGING, (
                "UlErrorLog(pHttpConn=%p)"
                " Unable to log an entry to the error log file Failure: %08lx\n",
                pHttpConn,
                LogStatus
                ));
    }    
}

/***************************************************************************++

Routine Description:

    Inits a error log info structure.

    Caller must own the httpconn pushlock.

Arguments:

    pErrorLogInfo   - Will be initialized
    pHttpConn       - Connection and its request.
    pRequest        - optional
    pInfo           - Extra info (ANSI)
    InfoSize        - Size of the info in bytes, excluding the terminating
                      null.
    
--***************************************************************************/

VOID
UlpInitErrorLogInfo(
    IN OUT PUL_ERROR_LOG_INFO      pErrorLogInfo,
    IN     PUL_HTTP_CONNECTION     pHttpConn,
    IN     PUL_INTERNAL_REQUEST    pRequest,
    IN     PCHAR                   pInfo,
    IN     USHORT                  InfoSize    
    )
{    
    //
    // Sanity check.
    //

    PAGED_CODE();
    
    ASSERT(pInfo);
    ASSERT(InfoSize);
    ASSERT(pErrorLogInfo);    
    ASSERT(UlDbgPushLockOwnedExclusive(&pHttpConn->PushLock));
    ASSERT(UL_IS_VALID_HTTP_CONNECTION(pHttpConn));
    
    RtlZeroMemory(pErrorLogInfo, sizeof(UL_ERROR_LOG_INFO));

    pErrorLogInfo->pHttpConn  = pHttpConn;

    //
    // See if pRequest is already provided if not try to grab
    // it from the http connection.
    //

    if (!pRequest)
    {
        pRequest = pHttpConn->pRequest;
    }
        
    //
    // Request may not be there.
    //
    
    if (pRequest)
    {
        ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pRequest));    
        pErrorLogInfo->pRequest = pRequest;

        pErrorLogInfo->ProtocolStatus = 
            ErrorTable[pRequest->ErrorCode].StatusCode;
    }

    //
    // Point to the callers buffer.
    //
    
    pErrorLogInfo->pInfo = pInfo;
    pErrorLogInfo->InfoSize  = InfoSize;
}

/***************************************************************************++

Routine Description:

    You should hold the connection Resource before calling this function.

Arguments:

    self explanatory

--***************************************************************************/

VOID
UlSendErrorResponse(
    PUL_HTTP_CONNECTION pConnection
    )
{
    UL_HTTP_ERROR               ErrorCode;
    NTSTATUS                    Status = STATUS_SUCCESS;
    PUL_INTERNAL_REQUEST        pRequest;
    HTTP_RESPONSE               Response;
    HTTP_DATA_CHUNK             DataChunk;
    PUL_INTERNAL_RESPONSE       pKeResponse = NULL;
    const CHAR                  ContentType[] = "text/html";
    USHORT                      ContentTypeLength = STRLEN_LIT("text/html");
    UCHAR                       contentLength[MAX_ULONG_STR];
    PHTTP_DATA_CHUNK            pResponseBody;
    USHORT                      DataChunkCount;
    ULONG                       Flags = HTTP_SEND_RESPONSE_FLAG_DISCONNECT;

    //
    // This function should not be marked as PAGEable, because it's
    // useful to set breakpoints on it, and that interacts badly
    // with the driver verifier's IRQL checking
    //
    PAGED_CODE();

    //
    // Sanity check.
    //

    ASSERT(UL_IS_VALID_HTTP_CONNECTION(pConnection));
    ASSERT(UlDbgPushLockOwnedExclusive(&pConnection->PushLock));
    ASSERT(!pConnection->UlconnDestroyed);

    pRequest = pConnection->pRequest;
    ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pRequest));

    //
    // To prevent sending back double responses. We will
    // check if user (WP) has already sent one.
    //

    pConnection->WaitingForResponse = 1;

    UlTrace( PARSER, (
            "*** pConnection %p->WaitingForResponse = 1\n",
            pConnection
            ));

    //
    // We will send a response back. won't we ?
    // An error response.
    //

    if (!NT_SUCCESS(UlCheckSendHttpResponseFlags(pRequest, Flags)))
    {
        UlTraceError( PARSER, (
            "*** pConnection %p, pRequest %p, skipping SendError.\n",
            pConnection,
            pRequest
            ));

        goto end;
    }

    //
    // Proceed with constructing and sending the error
    // back to the client
    //

    RtlZeroMemory(&Response, sizeof(Response));

    //
    // Mark as a driver-generated response
    //
    
    Response.Flags = HTTP_RESPONSE_FLAG_DRIVER;

    if (pRequest->ErrorCode <= UlErrorNone
        ||  pRequest->ErrorCode >= UlErrorMax)
    {
        ASSERT(! "Invalid Request ErrorCode");
        pRequest->ErrorCode = UlError;
    }
    
    ErrorCode = pRequest->ErrorCode;

    //
    // ErrorTable[] must be kept in sync with the UL_HTTP_ERROR enum
    //

    ASSERT(ErrorTable[ErrorCode].ErrorCode == ErrorCode);

    Response.StatusCode = ErrorTable[ErrorCode].StatusCode;
    Response.ReasonLength = ErrorTable[ErrorCode].ReasonLength;
    Response.pReason = ErrorTable[ErrorCode].pReasonPhrase;

    UlTraceError( PARSER, (
            "UlSendErrorResponse(pReq=%p), Error=%d %s, %hu, \"%s\"\n",
            pRequest,
            ErrorCode,
            ErrorTable[ErrorCode].ErrorCodeString,
            Response.StatusCode,
            ErrorTable[ErrorCode].pBody
            ));

    //
    // Log an entry to the error log file.
    //
    
    UlErrorLog( pConnection,
                 pRequest,
                 (PCHAR) ErrorTable[ErrorCode].pLog,
                 ErrorTable[ErrorCode].LogLength,
                 FALSE
                 );
        
    //
    // Special-case handling for 503s and load balancers
    //

    if (Response.StatusCode == 503)
    {
        //
        // For dumb L3/L4 load balancers, UlpHandle503Response will return an
        // error, which will cause us to abort the connection
        //
        
        Status = UlpHandle503Response(pRequest, &Response);

        if (!NT_SUCCESS(Status))
        {
            goto end;
        }
    }


    Response.Headers.KnownHeaders[HttpHeaderContentType].RawValueLength =
        ContentTypeLength;
    Response.Headers.KnownHeaders[HttpHeaderContentType].pRawValue =
        ContentType;

    if (pConnection->pRequest->Verb != HttpVerbHEAD)
    {
        //
        // generate a body
        //
        DataChunk.DataChunkType = HttpDataChunkFromMemory;
        DataChunk.FromMemory.pBuffer = (PVOID) ErrorTable[ErrorCode].pBody;
        DataChunk.FromMemory.BufferLength = ErrorTable[ErrorCode].BodyLength;

        DataChunkCount = 1;
        pResponseBody = &DataChunk;
    }
    else
    {
        PCHAR pEnd;
        USHORT contentLengthStringLength;
    
        //
        // HEAD requests MUST NOT have a body, so we don't include
        // the data chunk. However we do have to manually generate a content
        // length header, which would have been generated automatically
        // had we specified the entity body.
        //

        pEnd = UlStrPrintUlong(
                   (PCHAR) contentLength,
                   ErrorTable[ErrorCode].BodyLength,
                   '\0');
                   
        contentLengthStringLength = DIFF_USHORT(pEnd - (PCHAR) contentLength);

        Response.Headers.KnownHeaders[HttpHeaderContentLength].RawValueLength =
            contentLengthStringLength;
        Response.Headers.KnownHeaders[HttpHeaderContentLength].pRawValue =
            (PSTR) contentLength;


        //
        // Set the empty entity body.
        //
        
        DataChunkCount = 0;
        pResponseBody = NULL;
    }

    Status = UlCaptureHttpResponse(
                    NULL,
                    &Response,
                    pRequest,
                    DataChunkCount,
                    pResponseBody,
                    UlCaptureCopyDataInKernelMode,
                    Flags,
                    FALSE,
                    NULL,
                    NULL,
                    &pKeResponse
                    );

    if (NT_SUCCESS(Status) == FALSE)
        goto end;

    Status = UlPrepareHttpResponse(
                    pRequest->Version,
                    &Response,
                    pKeResponse,
                    KernelMode
                    );

    if (NT_SUCCESS(Status) == FALSE)
        goto end;

    Status = UlSendHttpResponse(
                    pRequest,
                    pKeResponse,
                    &UlpCompleteSendErrorResponse,
                    pKeResponse
                    );

    if (NT_SUCCESS(Status) == FALSE)
        goto end;

    ASSERT(Status == STATUS_PENDING);

end:
    if (NT_SUCCESS(Status) == FALSE)
    {
        if (pKeResponse != NULL)
        {
            UL_DEREFERENCE_INTERNAL_RESPONSE(pKeResponse);
        }

        //
        // Abort the connection
        //

        UlTraceError(HTTP_IO, (
            "http!UlSendErrorResponse(%p): "
            "Failed to send error response, %s\n",
            pConnection,
            HttpStatusToString(Status)
            ));

        //
        // cancel any pending io
        //
        UlCancelRequestIo(pRequest);

        //
        // We are about to drop this conenction, set the flag.
        // So that we don't error log twice.
        //

        pConnection->Dropped = TRUE;

        //
        // abort the connection this request is associated with
        //

        UlCloseConnection(
            pConnection->pConnection,
            TRUE,
            NULL,
            NULL
            );
    }

} // UlSendErrorResponse


const CHAR g_RetryAfter10Seconds[] = "10";
const CHAR g_RetryAfter5Minutes[] = "300";  // 5 * 60 == 300 seconds


/***************************************************************************++

Routine Description:

    Special-case handling for 503s and load balancers.

Arguments:

    pConnection - connection that's being 503'd

Returns:
    Error NTSTATUS - caller should abort the connection
    STATUS_SUCCESS => caller should send the 503 response

--***************************************************************************/

NTSTATUS
UlpHandle503Response(
    IN PUL_INTERNAL_REQUEST pRequest,
    IN PHTTP_RESPONSE       pResponse
    )
{
    HTTP_LOAD_BALANCER_CAPABILITIES LBCapability
        = pRequest->LoadBalancerCapability;
    PCSTR  RetryAfterString = NULL;
    USHORT RetryAfterLength = 0;

    UNREFERENCED_PARAMETER(pResponse);

    //
    // If this is an L3/L4 load balancer, we just want to send a TCP RST.
    // We should not send a 503 response. Returning an error code to
    // UlSendErrorResponse will cause it to abort the connection.
    //
    if (HttpLoadBalancerBasicCapability == LBCapability)
    {
        return STATUS_UNSUCCESSFUL;
    }

    //
    // The only other load balancer we know how to deal with currently
    // is an L7 
    //

    ASSERT(HttpLoadBalancerSophisticatedCapability == LBCapability);

    switch (pRequest->ErrorCode)
    {
    case UlErrorUnavailable:
    case UlErrorAppPoolQueueFull:
    case UlErrorConnectionLimit:
    case UlErrorAppPoolBusy:
        RetryAfterString = g_RetryAfter10Seconds;
        RetryAfterLength = sizeof(g_RetryAfter10Seconds) - sizeof(CHAR);
        break;

    case UlErrorRapidFailProtection:
    case UlErrorDisabledByAdmin:
    case UlErrorJobObjectFired:
        RetryAfterString = g_RetryAfter5Minutes;
        RetryAfterLength = sizeof(g_RetryAfter5Minutes) - sizeof(CHAR);
        break;

    default:
        ASSERT(! "Invalid UL_HTTP_ERROR");
        break;
    }

    // We don't want to disclose too much information in our error messages,
    // so, we'll not add the HttpHeaderRetryAfter. We might change this in 
    // the future, for now, we just don't use the 
    // RetryAfterString & RetryAfterLength.
    //
    
    return STATUS_SUCCESS;

} // UlpHandle503Response



/***************************************************************************++

Routine Description:

    Completion function for UlSendErrorResponse

Arguments:

    pCompletionContext - a UL_INTERNAL_RESPONSE

--***************************************************************************/

VOID
UlpCompleteSendErrorResponse(
    IN PVOID pCompletionContext,
    IN NTSTATUS Status,
    IN ULONG_PTR Information
    )
{
    UNREFERENCED_PARAMETER(Status);
    UNREFERENCED_PARAMETER(Information);

    //
    // release the response
    //

    if (pCompletionContext != NULL)
    {
        PUL_INTERNAL_RESPONSE pResponse
            = (PUL_INTERNAL_RESPONSE)(pCompletionContext);

        ASSERT(UL_IS_VALID_INTERNAL_RESPONSE(pResponse));

        UL_DEREFERENCE_INTERNAL_RESPONSE(pResponse);
    }
} // UlpCompleteSendErrorResponse


//
// Types and functions for sending simple status responses
//
// REVIEW: Does this status code need to be localized?
// REVIEW: Do we need to load this as a localized resource?
//

typedef struct _UL_SIMPLE_STATUS_ITEM
{
    UL_WORK_ITEM WorkItem;

    UL_HTTP_SIMPLE_STATUS  Status;
    ULONG                  Length;
    PCHAR                  pMessage;
    PMDL                   pMdl;

    PUL_HTTP_CONNECTION    pHttpConn;

    BOOLEAN                ResumeParsing;

} UL_SIMPLE_STATUS_ITEM, *PUL_SIMPLE_STATUS_ITEM;

typedef struct _UL_HTTP_SIMPLE_STATUS_ENTRY
{
    USHORT StatusCode;      // HTTP Status
    ULONG  Length;          // size (bytes) of response in pResponse, minus trailing NULL
    PSTR   pResponse;       // header line only with trailing <CRLF><CRLF>

} UL_HTTP_SIMPLE_STATUS_ENTRY, *PUL_HTTP_SIMPLE_STATUS_ENTRY;


#define HTTP_SIMPLE_STATUS_ENTRY(StatusCode, pResp)   \
    {                                                 \
        (StatusCode),                                 \
        sizeof((pResp))-sizeof(CHAR),                 \
        (pResp)                                       \
    }

//
// This must match the order of UL_HTTP_SIMPLE_STATUS in httptypes.h
//
UL_HTTP_SIMPLE_STATUS_ENTRY g_SimpleStatusTable[] =
{
    //
    // UlStatusContinue
    //
    HTTP_SIMPLE_STATUS_ENTRY( 100, "HTTP/1.1 100 Continue\r\n\r\n" ),

    //
    // UlStatusNoContent
    //
    HTTP_SIMPLE_STATUS_ENTRY( 204, "HTTP/1.1 204 No Content\r\n\r\n" ),

    //
    // UlStatusNotModified (must add Date:)
    //
    HTTP_SIMPLE_STATUS_ENTRY( 304, "HTTP/1.1 304 Not Modified\r\nDate:" ),

};



/***************************************************************************++

Routine Description:

    Sends a "Simple" status response: one which does not have a body and is
    terminated by the first empty line after the header field(s).
    See RFC 2616, Section 4.4 for more info.

Notes:

    According to RFC 2616, Section 8.2.3 [Use of the 100 (Continue)
    Status], "An origin server that sends a 100 (Continue) response
    MUST ultimately send a final status code, once the request body is
    received and processed, unless it terminates the transport
    connection prematurely."

    The connection will not be closed after the response is sent.  Caller
    is responsible for cleanup.

Arguments:

    pRequest        a valid pointer to an internal request object

    Response        the status code for the simple response to send

Return

    ULONG           the number of bytes sent for this simple response
                    if not successfull returns zero

--***************************************************************************/

#define ETAG_HDR "Etag:"
#define ETAG_HDR_LENGTH (sizeof(ETAG_HDR) - sizeof(CHAR))

ULONG
UlSendSimpleStatusEx(
    PUL_INTERNAL_REQUEST pRequest,
    UL_HTTP_SIMPLE_STATUS Response,
    PUL_URI_CACHE_ENTRY pUriCacheEntry OPTIONAL,
    BOOLEAN ResumeParsing
    )
{
    NTSTATUS                Status;
    ULONG                   BytesSent = 0;
    PUL_SIMPLE_STATUS_ITEM  pItem = NULL;
    
    //
    // Sanity check.
    //

    PAGED_CODE();
    ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pRequest));
    ASSERT(UL_IS_VALID_HTTP_CONNECTION(pRequest->pHttpConn));

    ASSERT( (Response >= 0) && (Response < UlStatusMaxStatus) );

    switch( Response )
    {
    case UlStatusNotModified:
        {
        ULONG                   Length;
        PCHAR                   pTemp;
        CHAR                    DateBuffer[DATE_HDR_LENGTH + 1];
        LARGE_INTEGER           liNow;

        IS_VALID_URI_CACHE_ENTRY(pUriCacheEntry);

        // 304 MUST include a "Date:" header, which is
        // present on the cached item.

        // Add the ETag as well.

        // Calc size of buffer to send
        Length = g_SimpleStatusTable[Response].Length + // Pre-formed message
                    1 +                 // space
                    DATE_HDR_LENGTH +   // size of date field
                    (2 * CRLF_SIZE) +   // size of two <CRLF> sequences
                    1 ;                 // trailing NULL (for nifty debug printing)

        if (pUriCacheEntry && pUriCacheEntry->ETagLength )
        {
            Length += (pUriCacheEntry->ETagLength - 1) + // Etag (without NULL)
                           ETAG_HDR_LENGTH +       // Etag: prefix
                           1 +                     // space
                           CRLF_SIZE;
        }

        // Alloc some non-page buffer for the response
        pItem = UL_ALLOCATE_STRUCT_WITH_SPACE(
                        NonPagedPool,
                        UL_SIMPLE_STATUS_ITEM,
                        Length,
                        UL_SIMPLE_STATUS_ITEM_POOL_TAG
                        );
        if (!pItem)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto end;
        }

        
        UlInitializeWorkItem(&pItem->WorkItem);

        pItem->pHttpConn = pRequest->pHttpConn;
        pItem->Length    = (Length - 1); // Don't include the NULL in the outbound message
        pItem->pMessage  = (PCHAR) (pItem + 1);
        pItem->Status    = Response;

        // Get date buffer
        UlGenerateDateHeader(
            (PUCHAR) DateBuffer,
            &liNow
            );

        // Copy the chunks into the Message buffer
        pTemp = UlStrPrintStr(
                    pItem->pMessage,
                    g_SimpleStatusTable[Response].pResponse,
                    ' '
                    );

        pTemp = UlStrPrintStr(
                    pTemp,
                    DateBuffer,
                    '\r'       
                    );

        // If we have an Etag, copy that in too.
        if (pUriCacheEntry && pUriCacheEntry->ETagLength )
        {
            ASSERT( pUriCacheEntry->pETag );
            
            *pTemp = '\n';
            pTemp++;

            pTemp = UlStrPrintStr(
                        pTemp,
                        ETAG_HDR,
                        ' '
                        );

            pTemp = UlStrPrintStr(
                        pTemp,
                        (PCHAR)pUriCacheEntry->pETag,
                        '\r'
                        );
        }

        // Trailing *LF-CRLF
        pTemp = UlStrPrintStr(
                    pTemp,
                    "\n\r\n",
                    '\0'
                    );

        // pTemp should point at the trailing NULL; 
        // pItem->Length should not include trailing NULL.
        ASSERT( DIFF((pTemp) - pItem->pMessage) == pItem->Length );

        UlTraceVerbose(HTTP_IO, (
            "http!UlSendSimpleStatusEx: %s\n",
            pItem->pMessage
            ));

        // Construct MDL for buffer
        pItem->pMdl = UlAllocateMdl(
                        pItem->pMessage,
                        pItem->Length,
                        FALSE,
                        FALSE,
                        NULL
                        );

        if (!pItem->pMdl)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto end;
        }

        MmBuildMdlForNonPagedPool(pItem->pMdl);

        BytesSent = pItem->Length;

        }
        break;

    case UlStatusContinue:
    case UlStatusNoContent:
        {
        // 
        // Alloc non-page buffer for the simple send tracker 
        // NOTE: no need to alloc extra space for the static message
        //
        
        pItem = UL_ALLOCATE_STRUCT(
                        NonPagedPool,
                        UL_SIMPLE_STATUS_ITEM,
                        UL_SIMPLE_STATUS_ITEM_POOL_TAG
                        );
        if (!pItem)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto end;
        }

        UlInitializeWorkItem(&pItem->WorkItem);

        pItem->pHttpConn = pRequest->pHttpConn;
        pItem->pMessage  = g_SimpleStatusTable[Response].pResponse;
        pItem->Length    = g_SimpleStatusTable[Response].Length;
        pItem->Status    = Response;


        UlTraceVerbose(HTTP_IO, (
            "http!UlSendSimpleStatusEx: %s\n",
            pItem->pMessage
            ));

        // Construct MDL for buffer
        pItem->pMdl = UlAllocateMdl(
                        pItem->pMessage,
                        pItem->Length,
                        FALSE,
                        FALSE,
                        NULL
                        );

        if (!pItem->pMdl)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto end;
        }

        MmBuildMdlForNonPagedPool(pItem->pMdl);

        BytesSent = g_SimpleStatusTable[Response].Length;
        
        }
        break;
    
    default:
        {
        UlTraceError(HTTP_IO, (
            "http!UlSendSimpleStatusEx: Invalid simple status (%d)\n",
            Response
            ));

        ASSERT(!"UlSendSimpleStatusEx: Invalid status!");
        
        Status    = STATUS_SUCCESS; // quietly ignore
        BytesSent = 0;
        goto end;
        }
        
    }

    //
    // We need to hold a ref to the connection while we send.
    //
    
    UL_REFERENCE_HTTP_CONNECTION(pRequest->pHttpConn);

    //
    // Turn on the min bytes per sec timer
    //
    
    UlSetMinBytesPerSecondTimer(
        &pRequest->pHttpConn->TimeoutInfo,
        BytesSent
        );
    
    //
    // We will only resume parse, if the response type is UlStatusNotModified
    // (cache response). Otherwise this must have been a cache-miss call.
    //

    pItem->ResumeParsing = ResumeParsing;

    ASSERT((ResumeParsing == FALSE
            || Response == UlStatusNotModified));        
        
    Status = UlSendData(
                pRequest->pHttpConn->pConnection,
                pItem->pMdl,
                pItem->Length,
                UlpRestartSendSimpleStatus,
                pItem,
                NULL,
                NULL,
                FALSE,
                (BOOLEAN)(pRequest->ParseState >= ParseDoneState)
                );

    //
    // In an error case the completion routine will always 
    // get called.
    //
    
    return BytesSent;

    
 end:

    if (NT_SUCCESS(Status) == FALSE)
    {
        //
        // Clean up simple send item since completion routine 
        // won't get called
        //
        if (pItem)
        {
            if (pItem->pMdl)
            {
                UlFreeMdl( pItem->pMdl );
            }

            UL_FREE_POOL( pItem, UL_SIMPLE_STATUS_ITEM_POOL_TAG );
        }
        
        
        //
        // Abort the connection
        //

        UlTraceError(HTTP_IO, (
            "http!UlSendSimpleStatusEx(%p, %d): aborting request\n",
            pRequest,
            Response
            ));

        //
        // cancel any pending io
        //

        UlCancelRequestIo(pRequest);

        //
        // abort the connection this request is associated with
        //

        UlCloseConnection(
            pRequest->pHttpConn->pConnection,
            TRUE,
            NULL,
            NULL
            );

        return 0;
    }
    else
    {
        return BytesSent;
    }
} // UlSendSimpleStatusEx


/***************************************************************************++

Routine Description:

    Shim for UlSendSimpleStatusEx

Arguments:

    pRequest - Request associated with simple response to send

    Response - Simple Response type to send

--***************************************************************************/

ULONG
UlSendSimpleStatus(
    PUL_INTERNAL_REQUEST pRequest,
    UL_HTTP_SIMPLE_STATUS Response
    )
{
    return UlSendSimpleStatusEx( pRequest, Response, NULL, FALSE );
} // UlSendSimpleStatus



/***************************************************************************++

Routine Description:

    Callback for when UlSendData completes sending a UL_SIMPLE_STATUS message

Arguments:

    pCompletionContext (OPTIONAL) -- If non-NULL, a pointer to a
       UL_SIMPLE_STATUS_ITEM.

   Status -- Ignored.

   Information -- Ignored.

--***************************************************************************/

VOID
UlpRestartSendSimpleStatus(
    IN PVOID pCompletionContext,
    IN NTSTATUS Status,
    IN ULONG_PTR Information
    )
{
    PUL_SIMPLE_STATUS_ITEM  pItem;

    UNREFERENCED_PARAMETER(Status);
    UNREFERENCED_PARAMETER(Information);

    UlTrace(HTTP_IO, (
            "http!UlpRestartSendSimpleStatus: \n"
            "    pCompletionContext: %p\n"
            "    %s\n"
            "    Information: %Iu\n",
            pCompletionContext,
            HttpStatusToString(Status),
            Information
            ));

    if ( pCompletionContext )
    {
        pItem = (PUL_SIMPLE_STATUS_ITEM) pCompletionContext;

        // Queue up work item for passive level
        UL_QUEUE_WORK_ITEM(
            &pItem->WorkItem,
            &UlpSendSimpleCleanupWorker
            );

    }

} // UlpRestartSendSimpleStatus



/***************************************************************************++

Routine Description:

    Worker function to do cleanup work that shouldn't happen above DPC level.

Arguments:

    pWorkItem -- If non-NULL, a pointer to a UL_WORK_ITEM
         contained within a UL_SIMPLE_STATUS_ITEM.

--***************************************************************************/

VOID
UlpSendSimpleCleanupWorker(
    IN PUL_WORK_ITEM pWorkItem
    )
{
    KIRQL OldIrql;
    PUL_SIMPLE_STATUS_ITEM pItem;

    PAGED_CODE();
    ASSERT(pWorkItem);

    pItem = CONTAINING_RECORD(
                pWorkItem,
                UL_SIMPLE_STATUS_ITEM,
                WorkItem
                );

    UlTrace(HTTP_IO, (
        "http!UlpSendSimpleCleanupWorker (%p) \n",
        pWorkItem
        ));

    ASSERT(UL_IS_VALID_HTTP_CONNECTION(pItem->pHttpConn));

    //
    // start the Connection Timeout timer
    //

    UlLockTimeoutInfo(
        &(pItem->pHttpConn->TimeoutInfo),
        &OldIrql
        );

    UlResetConnectionTimer(
        &(pItem->pHttpConn->TimeoutInfo),
        TimerMinBytesPerSecond
        );
   
    if ( UlStatusContinue != pItem->Status )
    {
        UlSetConnectionTimer(
            &(pItem->pHttpConn->TimeoutInfo),
            TimerConnectionIdle
            );
    }

    UlUnlockTimeoutInfo(
        &(pItem->pHttpConn->TimeoutInfo),
        OldIrql
        );

    UlEvaluateTimerState(
        &(pItem->pHttpConn->TimeoutInfo)
        );

    if ( pItem->ResumeParsing )
    {
        //
        // Only possible path which will invoke the simple send path
        // with a requirement of resume parsing on send completion is
        // the 304 (not-modifed) cache sends.
        //
        UlResumeParsing(
            pItem->pHttpConn,
            TRUE,
            FALSE
            );
    }
    
    //
    // deref http connection
    //

    UL_DEREFERENCE_HTTP_CONNECTION( pItem->pHttpConn );
    
    //
    // free alloc'd mdl and tracker struct
    //
    
    ASSERT( pItem->pMdl );
    UlFreeMdl( pItem->pMdl );
    UL_FREE_POOL( pItem, UL_SIMPLE_STATUS_ITEM_POOL_TAG );

} // UlpSendSimpleCleanupWorker


#if DBG

/***************************************************************************++

Routine Description:

   Invasive assert predicate.  DEBUG ONLY!!!  Use this only inside an
   ASSERT() macro.

--***************************************************************************/

BOOLEAN
UlpIsValidRequestBufferList(
    PUL_HTTP_CONNECTION pHttpConn
    )
{
    PLIST_ENTRY         pEntry;
    PUL_REQUEST_BUFFER  pReqBuf;
    ULONG               LastSeqNum = 0;
    BOOLEAN             fRet = TRUE;

    if (!g_CheckRequestBufferList)
        return TRUE;

    PAGED_CODE();
    ASSERT( pHttpConn );

    //
    // pop from the head
    //

    pEntry = pHttpConn->BufferHead.Flink;
    while ( pEntry != &(pHttpConn->BufferHead) )
    {
        pReqBuf = CONTAINING_RECORD( pEntry,
                                     UL_REQUEST_BUFFER,
                                     ListEntry
                                     );

        ASSERT( UL_IS_VALID_REQUEST_BUFFER(pReqBuf) );
        ASSERT( pReqBuf->UsedBytes != 0 );

        if ( 0 == pReqBuf->UsedBytes )
        {
            fRet = FALSE;
        }

        //
        // ignore case when BufferNumber is zero (0).
        //
        if ( pReqBuf->BufferNumber && (LastSeqNum >= pReqBuf->BufferNumber) )
        {
            fRet = FALSE;
        }

        LastSeqNum = pReqBuf->BufferNumber;
        pEntry = pEntry->Flink;

    }

    return fRet;

} // UlpIsValidRequestBufferList

#endif // DBG


/***************************************************************************++

Routine Description:

   Add a request buffer to the end of the array of request buffers in
   a request. Reallocate that array if necessary. Increase the reqbuff's
   reference count, to indicate that a header is holding a reference on it.

--***************************************************************************/

BOOLEAN
UlpReferenceBuffers(
    IN PUL_INTERNAL_REQUEST pRequest,
    IN PUL_REQUEST_BUFFER pRequestBuffer
    )
{
    PUL_REQUEST_BUFFER * pNewRefBuffers;

    if (pRequest->UsedRefBuffers >= pRequest->AllocRefBuffers)
    {
        ASSERT( pRequest->UsedRefBuffers == pRequest->AllocRefBuffers );

        pNewRefBuffers = UL_ALLOCATE_ARRAY(
                            NonPagedPool,
                            PUL_REQUEST_BUFFER,
                            pRequest->AllocRefBuffers + ALLOC_REQUEST_BUFFER_INCREMENT,
                            UL_REF_REQUEST_BUFFER_POOL_TAG
                            );

        if (!pNewRefBuffers)
        {
            return FALSE;
        }

        RtlCopyMemory(
            pNewRefBuffers,
            pRequest->pRefBuffers, 
            pRequest->UsedRefBuffers * sizeof(PUL_REQUEST_BUFFER)
            );

        if (pRequest->AllocRefBuffers > 1)
        {
            UL_FREE_POOL(
                pRequest->pRefBuffers,
                UL_REF_REQUEST_BUFFER_POOL_TAG
                );
        }

        pRequest->AllocRefBuffers += ALLOC_REQUEST_BUFFER_INCREMENT;
        pRequest->pRefBuffers = pNewRefBuffers;
    }

    pRequest->pRefBuffers[pRequest->UsedRefBuffers] = pRequestBuffer;
    pRequest->UsedRefBuffers++;
    UL_REFERENCE_REQUEST_BUFFER(pRequestBuffer);

    return TRUE;

}   // UlpReferenceBuffers


/***************************************************************************++

Routine Description:

    Frees all pending request buffers on this connection.

Arguments:

    pConnection - points to a UL_HTTP_CONNECTION

--***************************************************************************/
VOID
UlpFreeReceiveBufferList(
    IN PSLIST_ENTRY pBufferSList
    )
{
    PUL_REQUEST_BUFFER pBuffer;
    PSLIST_ENTRY pEntry;

    while (NULL != pBufferSList->Next)
    {
        pEntry = pBufferSList->Next;
        pBufferSList->Next = pEntry->Next;

        pBuffer = CONTAINING_RECORD(
                        pEntry,
                        UL_REQUEST_BUFFER,
                        ListEntry
                        );

        pBuffer->ListEntry.Flink = NULL;
        pBuffer->ListEntry.Blink = NULL;

        UL_DEREFERENCE_REQUEST_BUFFER(pBuffer);
    }

}   // UlpFreeReceiveBufferList
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\ioctl.h ===
/*++

Copyright (c) 1998-2002 Microsoft Corporation

Module Name:

    ioctl.h

Abstract:

    This module contains declarations for various IOCTL handlers.

Author:

    Keith Moore (keithmo)       10-Jun-1998

Revision History:

--*/


#ifndef _IOCTL_H_
#define _IOCTL_H_


NTSTATUS
UlQueryControlChannelIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

NTSTATUS
UlSetControlChannelIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

NTSTATUS
UlCreateConfigGroupIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

NTSTATUS
UlDeleteConfigGroupIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

NTSTATUS
UlQueryConfigGroupIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

NTSTATUS
UlSetConfigGroupIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

NTSTATUS
UlAddUrlToConfigGroupIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

NTSTATUS
UlRemoveUrlFromConfigGroupIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

NTSTATUS
UlRemoveAllUrlsFromConfigGroupIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

NTSTATUS
UlQueryAppPoolInformationIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

NTSTATUS
UlSetAppPoolInformationIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

NTSTATUS
UlShutdownAppPoolIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

NTSTATUS
UlReceiveHttpRequestIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

NTSTATUS
UlReceiveEntityBodyIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

NTSTATUS
UlSendHttpResponseIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

NTSTATUS
UlSendEntityBodyIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

NTSTATUS
UlFlushResponseCacheIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

NTSTATUS
UlWaitForDemandStartIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

NTSTATUS
UlWaitForDisconnectIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

NTSTATUS
UlShutdownFilterIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

NTSTATUS
UlFilterAcceptIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

NTSTATUS
UlFilterCloseIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

NTSTATUS
UlFilterRawReadIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

NTSTATUS
UlFilterRawWriteIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

NTSTATUS
UlFilterAppReadIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

NTSTATUS
UlFilterAppWriteIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

NTSTATUS
UlReceiveClientCertIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

NTSTATUS
UlGetCountersIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

NTSTATUS
UlAddFragmentToCacheIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

NTSTATUS
UlReadFragmentFromCacheIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

// Maximum number of chunks that we'll allow in a response, to prevent
// carefully crafted arithmetic overflow errors fooling us into passing 0
// as the buffer length to ProbeForRead.

#define UL_MAX_CHUNKS   10000

C_ASSERT(UL_MAX_CHUNKS < (LONG_MAX / sizeof(HTTP_DATA_CHUNK)));

// Number of chunks to keep on the stack
#define UL_LOCAL_CHUNKS 10


NTSTATUS
UcSendRequestIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

NTSTATUS
UcSendEntityBodyIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

NTSTATUS
UcReceiveResponseIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

NTSTATUS
UcSetServerContextInformationIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

NTSTATUS
UcQueryServerContextInformationIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

NTSTATUS
UcCancelRequestIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION IrpSp
    );


#endif  // _IOCTL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\httptypes.h ===
/*++

Copyright (c) 1998-2002 Microsoft Corporation

Module Name:

    httptypes.h

Abstract:

    The definition of HTTP specific types

Author:

    Henry Sanders (henrysa)     July-1998 started

Revision History:

    Paul McDaniel (paulmcd)     3-March-1999 massive updates / rewrite

--*/


#ifndef _HTTPTYPES_H_
#define _HTTPTYPES_H_


//
// Forwarders.
//

typedef struct _UL_CONNECTION *PUL_CONNECTION;
typedef struct _UL_URI_CACHE_ENTRY *PUL_URI_CACHE_ENTRY;
typedef struct _UL_FULL_TRACKER *PUL_FULL_TRACKER;


//
// the largest name that can fit as an knownheader (3 ULONGLONG's)
//
#define MAX_KNOWN_HEADER_SIZE   24

#define CRLF_SIZE   2
#define CRLF        0x0A0D          // Reversed for endian switch
#define LFLF        0x0A0A

#define LAST_CHUNK      0x0A0D30    // Reversed for endian switch
#define LAST_CHUNK_SIZE 3

#define DATE_HDR_LENGTH  STRLEN_LIT("Thu, 14 Jul 1994 15:26:05 GMT")

//
// Response constants
//

//
// Parser error codes; these need to match the order of
// UL_HTTP_ERROR_ENTRY ErrorTable[] in httprcv.c.
// Always use UlSetErrorCode() to set pRequest->ErrorCode;
// never set it directly.
//

typedef enum _UL_HTTP_ERROR
{
    UlErrorNone = 0,

    UlError,                    // 400 Bad Request
    UlErrorVerb,                // 400 Bad Request (Invalid Verb)
    UlErrorUrl,                 // 400 Bad Request (Invalid URL)
    UlErrorHeader,              // 400 Bad Request (Invalid Header Name)
    UlErrorHost,                // 400 Bad Request (Invalid Hostname)
    UlErrorCRLF,                // 400 Bad Request (Invalid CR or LF)
    UlErrorNum,                 // 400 Bad Request (Invalid Number)
    UlErrorFieldLength,         // 400 Bad Request (Header Field Too Long)
    UlErrorRequestLength,       // 400 Bad Request (Request Header Too Long)

    UlErrorForbiddenUrl,        // 403 Forbidden
    UlErrorContentLength,       // 411 Length Required
    UlErrorPreconditionFailed,  // 412 Precondition Failed
    UlErrorEntityTooLarge,      // 413 Request Entity Too Large
    UlErrorUrlLength,           // 414 Request-URI Too Long

    UlErrorInternalServer,      // 500 Internal Server Error
    UlErrorNotImplemented,      // 501 Not Implemented

    //
    // Do not forget to update the UlpHandle503Response for
    // any additional 503 error types.
    //
    
    UlErrorUnavailable,         // 503 Service Unavailable
    UlErrorConnectionLimit,     // 503 Forbidden - Too Many Users
    UlErrorRapidFailProtection, // 503 Multiple Application Errors - Application Taken Offline
    UlErrorAppPoolQueueFull,    // 503 Application Request Queue Full
    UlErrorDisabledByAdmin,     // 503 Administrator Has Taken Application Offline
    UlErrorJobObjectFired,      // 503 Application Automatically Shutdown Due to Administrator Policy
    UlErrorAppPoolBusy,         // 503 Request timed out in App Pool Queue

    UlErrorVersion,             // 505 HTTP Version Not Supported

    UlErrorMax
} UL_HTTP_ERROR;



//
// HTTP responses which do not have a Content-Length and are
// terminated by the first empty line after the header fields.
// [RFC 2616, sec 4.4]
// NOTE: these need to match the order of
// UL_HTTP_SIMPLE_STATUS_ENTRY StatusTable[] in httprcv.c
//

typedef enum _UL_HTTP_SIMPLE_STATUS
{
    UlStatusContinue = 0,   // 100 Continue
    UlStatusNoContent,      // 204 No Content
    UlStatusNotModified,    // 304 Not Modified

    UlStatusMaxStatus

} UL_HTTP_SIMPLE_STATUS;


//
// The enum type for our parse state.
//
// note:  the order of the enum values are important as code
// uses < and > operators for comparison. keep the order the exact
// order the parse moves through.
//

typedef enum _PARSE_STATE
{
    ParseVerbState = 1,
    ParseUrlState = 2,
    ParseVersionState = 3,
    ParseHeadersState = 4,
    ParseCookState = 5,
    ParseEntityBodyState = 6,
    ParseTrailerState = 7,

    ParseDoneState = 8,
    ParseErrorState = 9

} PARSE_STATE, *PPARSE_STATE;

//
// An enum type for tracking the app pool queue state of requests
//
typedef enum _QUEUE_STATE
{
    QueueUnroutedState,     // request has not yet been routed to an app pool
    QueueDeliveredState,    // request is waiting at app pool for an IRP
    QueueCopiedState,       // request has been copied to user mode
    QueueUnlinkedState      // request has been unlinked from app pool

} QUEUE_STATE, *PQUEUE_STATE;

//
// The enum type of connection timers in a UL_TIMEOUT_INFO_ENTRY.
//
// NOTE: must be kept in sync with g_aTimeoutTimerNames
// NOTE: must be kept in sync with TimeoutInfoTable;
//
typedef enum _CONNECTION_TIMEOUT_TIMER
{
    TimerConnectionIdle = 0,    // Server Listen timeout
    TimerHeaderWait,            // Header Wait timeout
    TimerMinBytesPerSecond,    // Minimum Bandwidth not met (as timer value)
    TimerEntityBody,            // Entity Body receive
    TimerResponse,              // Response processing (user-mode)
    TimerAppPool,               // Queue to app pool, waitin for App

    TimerMaximumTimer

} CONNECTION_TIMEOUT_TIMER;

#define IS_VALID_TIMEOUT_TIMER(a) \
    (((a) >= TimerConnectionIdle) && ((a) < TimerMaximumTimer))

//
// Contained structure.  Not allocated on its own; therefore does not have
// a Signature or ref count.  No allocation or freeing functions provided,
// however, there is an UlInitalizeTimeoutInfo() function.
//

typedef struct _UL_TIMEOUT_INFO_ENTRY
{
    UL_SPIN_LOCK    Lock;

    // Wheel state

    //
    // Linkage to TimerWheel slot list
    //
    LIST_ENTRY      QueueEntry;

    //
    // Linkage to Zombie list; used when connection is expired
    //
    LIST_ENTRY      ZombieEntry;

    //
    // Timer Wheel Slot
    //
    ULONG           SlotEntry;


    // Timer state

    //
    // Block of timers; timers are in Timer Wheel Ticks
    //
    ULONG           Timers[ TimerMaximumTimer ];

    //
    // Index to timer that is closest to expiring
    //
    CONNECTION_TIMEOUT_TIMER  CurrentTimer;

    // 
    // Time (in Timer Wheel Ticks) at which this entry will expire;
    // matches the CurrentTimer's value in Timers[] array
    //
    ULONG           CurrentExpiry;

    //
    // SystemTime of when MinBytesPerSecond timer will expire;
    // more granularity is needed when dealing with this timer
    //
    LONGLONG        MinBytesPerSecondSystemTime;

    //
    // Flag indicating if this entry has been expired or not 
    //
    BOOLEAN         Expired;

    //
    // Per-site ConnectionTimeout value
    //
    LONGLONG        ConnectionTimeoutValue;

    //
    // Captured at init time from g_TM_MinBytesPerSecondDivisor
    //
    ULONG           BytesPerSecondDivisor;

    //
    // Count of sends currently in-flight
    //
    ULONG           SendCount;

} UL_TIMEOUT_INFO_ENTRY, *PUL_TIMEOUT_INFO_ENTRY;

//
// An enum type for tracking routing token type in the request.
//

typedef enum _UL_ROUTING_TOKEN_TYPE
{
    RoutingTokenNotExists = 0,   // should be zero
    RoutingTokenIP,
    RoutingTokenHostPlusIP,
    RoutingTokenMax
        
} UL_ROUTING_TOKEN_TYPE, *PUL_ROUTING_TOKEN_TYPE;

#define IS_VALID_ROUTING_TOKEN(a) \
    (((a) >= RoutingTokenNotExists) && ((a) < RoutingTokenMax))

//
// Structure we use for tracking headers from incoming requests. The pointer
// points into a buffer we received from the transport, unless the OurBuffer
// flag is set, which indicates we had to allocate a buffer and copy the header
// due to multiple occurences of the header or a continuation line.
//
typedef struct _UL_HTTP_HEADER
{
    PUCHAR      pHeader;

    USHORT      HeaderLength;

    USHORT      OurBuffer:1;
    USHORT      ExternalAllocated:1;

} UL_HTTP_HEADER, *PUL_HTTP_HEADER;

//
// Structure we use for tracking unknown headers. These structures are
// dynamically allocated when we see an unknown header.
//
typedef struct _UL_HTTP_UNKNOWN_HEADER
{
    LIST_ENTRY      List;
    USHORT          HeaderNameLength;
    PUCHAR          pHeaderName;
    UL_HTTP_HEADER  HeaderValue;

} UL_HTTP_UNKNOWN_HEADER, *PUL_HTTP_UNKNOWN_HEADER;

//
// forward declarations
//

typedef struct _UL_INTERNAL_REQUEST *PUL_INTERNAL_REQUEST;
typedef struct _UL_HTTP_CONNECTION *PUL_HTTP_CONNECTION;
typedef struct _UL_CONNECTION_COUNT_ENTRY *PUL_CONNECTION_COUNT_ENTRY;
typedef struct _UL_APP_POOL_PROCESS *PUL_APP_POOL_PROCESS;

typedef struct _UL_TCI_FLOW *PUL_TCI_FLOW;
typedef struct _UL_TCI_FILTER *PUL_TCI_FILTER;

//
// Structure we use for a copy of the data from the transport's buffer.
//

#define UL_IS_VALID_REQUEST_BUFFER(pObject)                     \
    HAS_VALID_SIGNATURE(pObject, UL_REQUEST_BUFFER_POOL_TAG)


typedef struct _UL_REQUEST_BUFFER
{
    //
    // NonPagedPool
    //

    //
    // This MUST be the first field in the structure. This is the linkage
    // used by the lookaside package for storing entries in the lookaside
    // list.
    //

    SLIST_ENTRY         LookasideEntry;

    //
    // UL_REQUEST_BUFFER_POOL_TAG
    //
    ULONG               Signature;

    //
    // References of the request buffer, mainly used for logging purpose.
    //
    LONG                RefCount;

    //
    // for linking on the pConnection->BufferHead
    //
    union {
        LIST_ENTRY      ListEntry;
        SLIST_ENTRY     SListEntry;
    };

    //
    // the connection
    //
    PUL_HTTP_CONNECTION pConnection;

    //
    // for queue'ing
    //
    UL_WORK_ITEM        WorkItem;

    //
    // how many bytes are stored
    //
    ULONG               UsedBytes;

    //
    // how many bytes are allocated from the pool
    //
    ULONG               AllocBytes;

    //
    // how many bytes have been consumed by the parser
    //
    ULONG               ParsedBytes;

    //
    // the sequence number
    //
    ULONG               BufferNumber;

    //
    // whether or not this was allocated from lookaside
    //
    ULONG               FromLookaside : 1;

    //
    // the actual buffer space (inline)
    //
    UCHAR               pBuffer[0];

} UL_REQUEST_BUFFER, *PUL_REQUEST_BUFFER;

// 
// Macro to find the next byte to parse in the Request Buffer
//
#define GET_REQUEST_BUFFER_POS(pRequestBuffer) \
    (pRequestBuffer->pBuffer + pRequestBuffer->ParsedBytes)

//
// Macro to get the count of remaining unparsed bytes in the 
// Request Buffer.  If this evaluates to zero, then there is no
// valid data to parse beyond GET_REQUEST_BUFFER_POS(pRequestBuffer)
//
#define UNPARSED_BUFFER_BYTES(pRequestBuffer) \
    (pRequestBuffer->UsedBytes - pRequestBuffer->ParsedBytes)


//
// Structure used for tracking an HTTP connection, which may represent
// either a real TCP connection or a virtual MUX connection.
//

#define UL_IS_VALID_HTTP_CONNECTION(pObject)                    \
    (HAS_VALID_SIGNATURE(pObject, UL_HTTP_CONNECTION_POOL_TAG)  \
     &&  ((pObject)->RefCount > 0))

typedef struct _UL_HTTP_CONNECTION
{
    //
    // NonPagedPool
    //

    //
    // UL_HTTP_CONNECTION_POOL_TAG
    //
    ULONG               Signature;

    //
    // Reference count of this connection.
    //
    LONG                RefCount;

    //
    // Opaque ID for this connection.
    //
    HTTP_CONNECTION_ID  ConnectionId;

    //
    // to perform the destructor at lower irql
    //
    UL_WORK_ITEM        WorkItem;

    //
    // A work item, used to process disconnect notification
    //
    UL_WORK_ITEM        DisconnectWorkItem;

    //
    // A work item, used to drain received data after we
    // gracefully close a connection.
    //
    UL_WORK_ITEM        DisconnectDrainWorkItem;

    //
    // used to pend incoming request buffers
    //
    UL_WORK_ITEM        ReceiveBufferWorkItem;

    //
    // links all pending transport packets
    //
    SLIST_HEADER        ReceiveBufferSList;

    //
    // Total send bytes added by each send on this connection. This includes
    // both overhead such as UL_INTERNAL_RESPONSE, UL_CHUNK_TRACKER, or
    // UL_FULL_TRACKER plus the size of the actual data.
    //
    ULONGLONG           TotalSendBytes;

    //
    // A simple exclusive lock that protects the above field. 
    //
    UL_EXCLUSIVE_LOCK   ExLock;

    //
    // Number of outstanding requests on the connection to control how many
    // concurrent requests we allow for pipelining.
    //
    ULONG               PipelinedRequests;

    //
    // sequence number for the next UL_INTERNAL_REQUEST that comes in.
    //
    ULONG               NextRecvNumber;

    //
    // sequence number for the next buffer received from TDI
    //
    ULONG               NextBufferNumber;

    //
    // sequence number for the next buffer to parse
    //
    ULONG               NextBufferToParse;

    //
    // sequence number for the end of the stream
    //
    ULONG               LastBufferNumber;

    //
    // Associated TDI connection
    //
    PUL_CONNECTION      pConnection;

    //
    // Secure connection flag.
    //
    BOOLEAN             SecureConnection;

    //
    // If this connection get aborted by our timeout code or by 
    // appool code. The following flag is set to distunguish that 
    // this connection has been abondened by us. Currently used 
    // only by the error logging code to prevent double logs.
    // Must not be accessed w/o acquiring the conn lock.
    //

    BOOLEAN             Dropped;
    
    //
    // Determines when the zombie connection get
    // terminated.
    //
    BOOLEAN             ZombieExpired;

    //
    // Shows whether this connection has been put to the zombie list
    // and waiting for the last sendresponse for the logging info.
    //
    ULONG               Zombified;

    //
    // The process the connection was delivered when it got zombified.
    //
    PVOID               pAppPoolProcess;

    //
    // Links all the zombie connections together.
    //
    LIST_ENTRY          ZombieListEntry;

    //
    // Has the (zombie) connection been cleanedup. To guard against
    // multiple cleanups.
    //
    ULONG               CleanedUp;

    //
    // The current request being parsed
    //
    PUL_INTERNAL_REQUEST    pRequest;

    //
    // to synchro UlpHandleRequest
    //
    UL_PUSH_LOCK        PushLock;

    //
    // links all buffered transport packets
    //
    LIST_ENTRY          BufferHead;

    //
    // links to app pool process binding structures, protected by the
    // AppPool lock
    //
    LIST_ENTRY          BindingHead;

    //
    // Connection Timeout Information block
    //
    UL_TIMEOUT_INFO_ENTRY TimeoutInfo;

    //
    // the current buffer (from BufferHead) that we are parsing
    //
    PUL_REQUEST_BUFFER  pCurrentBuffer;

    //
    // Connection remembers the last visited site's connection count
    // using this pointer.
    //
    PUL_CONNECTION_COUNT_ENTRY pConnectionCountEntry;

    //
    // previous Site Counter block (ref counted); so we can detect
    // when we transition across sites & set the active connection
    // count apropriately
    //
    PUL_SITE_COUNTER_ENTRY pPrevSiteCounters;

    //
    // If BWT is enabled on site that we receive a request
    // we will keep pointers to corresponding flow & filters
    // as well as a bit field to show that. Once the BWT is
    // enabled we will keep this state until connection drops
    //
    PUL_TCI_FLOW        pFlow;

    PUL_TCI_FILTER      pFilter;

    // First time we install a flow we set this
    //
    ULONG               BandwidthThrottlingEnabled : 1;

    //
    // set if a protocol token span buffers
    //
    ULONG               NeedMoreData : 1;

    //
    // set if the ul connection has been destroyed
    //
    ULONG               UlconnDestroyed : 1;

    //
    // set if we have dispatched a request and
    // are now waiting for the response
    //
    ULONG               WaitingForResponse : 1;

    //
    // set after the underlying network connection has been
    // disconnected.
    //
    ULONG               DisconnectFlag : 1;

    //
    // set after a WaitForDisconnect IRP has been pended on
    // this connection.
    //
    ULONG               WaitForDisconnectFlag : 1;

    //
    // List of pending "wait for disconnect" IRPs.
    // Note: This list and the DisconnectFlag are synchronized by
    // g_pUlNonpagedData->DisconnectResource.
    //
    UL_NOTIFY_HEAD WaitForDisconnectHead;

    //
    // Data for tracking buffered entity data which we use to
    // decide when to stop and restart TDI indications.
    //
    struct {

        //
        // Synchronizes the structure which is accessed from UlHttpReceive
        // at DPC and when we copy some entity to user mode.
        //

        UL_SPIN_LOCK    BufferingSpinLock;

        //
        // Count of bytes we have buffered on the connection.
        //

        ULONG           BytesBuffered;

        //
        // Count of bytes indicated to us by TDI but not buffered on
        // the connection.
        //

        ULONG           TransportBytesNotTaken;

        //
        // Flag indicating that we have a Read IRP pending which may
        // restart the flow of transport data.
        //

        BOOLEAN         ReadIrpPending;

        //
        // Once a connection get disconnected gracefuly and if there is
        // still unreceived data on it. We mark this state and start
        // draining the unreceived data. Otherwise transport won't give us
        // the disconnect indication which we depend on for cleaning up the
        // connection.
        //

        BOOLEAN         DrainAfterDisconnect;

        //
        // Record a graceful connection disconnect that is deferred to read
        // completion.
        //

        BOOLEAN         ConnectionDisconnect;

    } BufferingInfo;

    //
    // The request ID context and the lock that protects the context.
    //

    PUL_INTERNAL_REQUEST    pRequestIdContext;
    UL_SPIN_LOCK            RequestIdSpinLock;

} UL_HTTP_CONNECTION, *PUL_HTTP_CONNECTION;


//
// forward decl for cgroup.h which is not included yet
//

#define UL_IS_VALID_INTERNAL_REQUEST(pObject)                   \
    (HAS_VALID_SIGNATURE(pObject, UL_INTERNAL_REQUEST_POOL_TAG) \
     && ((pObject)->RefCount > 0))

//
// WARNING!  All fields of this structure must be explicitly initialized.
//
// Certain fields are placed next to each other so that they can be on
// the same cache line. Please make sure your add/remove fields carefully.
//

typedef struct _UL_INTERNAL_REQUEST
{
    //
    // NonPagedPool
    //

    //
    // This MUST be the first field in the structure. This is the linkage
    // used by the lookaside package for storing entries in the lookaside
    // list.
    //
    SLIST_ENTRY         LookasideEntry;

    //
    // UL_INTERNAL_REQUEST_POOL_TAG
    //
    ULONG               Signature;

    //
    // The connection
    //
    PUL_HTTP_CONNECTION pHttpConn;

    //
    // Opaque ID for the connection.
    // No reference.
    //
    HTTP_CONNECTION_ID  ConnectionId;

    //
    // Secure connection flag
    //
    BOOLEAN             Secure;

    //
    // Very first request flag, used to decide completing demand start IRPs.
    //
    BOOLEAN             FirstRequest;

    //
    // Copy of opaque id for the raw connection. May be UL_NULL_ID.
    // No reference.
    //
    HTTP_RAW_CONNECTION_ID  RawConnectionId;

    //
    // Reference count
    //
    LONG                RefCount;

    //
    // Copy of opaque id for the request.
    // No reference.
    //
    HTTP_REQUEST_ID     RequestIdCopy;

    //
    // Opaque ID for this object.
    // Has a reference.
    //
    HTTP_REQUEST_ID     RequestId;

    //
    // Result of call to UlCheckCachePreconditions.
    //
    BOOLEAN             CachePreconditions;

    //
    // Headers appended flag.  Set if AppendHeaderValue called.
    //
    BOOLEAN             HeadersAppended;

    //
    // Local copy of unknown headers buffer.
    //
    UCHAR                   NextUnknownHeaderIndex;
    UL_HTTP_UNKNOWN_HEADER  UnknownHeaders[DEFAULT_MAX_UNKNOWN_HEADERS];

    //
    // Current state of our parsing effort.
    //
    PARSE_STATE         ParseState;

    //
    // a list of pending send response IRP(s)
    //
    LIST_ENTRY          ResponseHead;

    //
    // a list of IRP(s) trying to read entity body
    //
    LIST_ENTRY          IrpHead;

    //
    // List of headers we don't know about.
    //
    LIST_ENTRY          UnknownHeaderList;

    //
    // Local copy of Url buffer for raw URL.  Allocated inline.
    //
    PWSTR               pUrlBuffer;

    //
    // Local copy of Routing Token buffer.  Allocated inline.
    //
    PWSTR               pDefaultRoutingTokenBuffer;

    //
    // The pre-allocated cache/fast tracker for a single full response.
    //
    PUL_FULL_TRACKER    pTracker;

    //
    // Array of indexes of valid known headers.
    //
    UCHAR               HeaderIndex[HttpHeaderRequestMaximum];

    //
    // Array of known headers.
    //
    UL_HTTP_HEADER      Headers[HttpHeaderRequestMaximum];

    //
    // A work item, used to queue processing.
    //
    UL_WORK_ITEM        WorkItem;

    //
    // Points to the cgroup info.
    //
    UL_URL_CONFIG_GROUP_INFO    ConfigInfo;

    //
    // Number of allocated referenced request buffers (default is 1).
    //
    USHORT              AllocRefBuffers;

    //
    // Number of used referenced request buffers.
    //
    USHORT              UsedRefBuffers;

    //
    // An array of referenced request buffers.
    //
    PUL_REQUEST_BUFFER  *pRefBuffers;

    //
    // A default array of referenced request buffers.
    //
    PUL_REQUEST_BUFFER  pInlineRefBuffers[1];

    //
    // The lock that protects SendsPending, pLogData and ResumeParsing fields.
    //
    UL_SPIN_LOCK        SpinLock;

    //
    // Total sends pending and not yet completed on the request.
    //
    ULONG               SendsPending;

    //
    // Dynamically allocated log data buffer. pLogDataCopy if for debugging
    // purpose only.
    //
    PUL_LOG_DATA_BUFFER  pLogData;
    PUL_LOG_DATA_BUFFER  pLogDataCopy;

    //
    // STATUS_SUCCESS or the last error status recorded for all sends
    // happening on this request.
    //
    NTSTATUS            LogStatus;

    //
    // WARNING: RtlZeroMemory is only called for fields below this line.
    // All fields above should be explicitly initialized in CreateHttpRequest.
    //

    //
    // Array of valid bit for known headers.
    //
    BOOLEAN             HeaderValid[HttpHeaderRequestMaximum];

    //
    // See if we need to resume parsing when SendsPending drops to 0.
    //
    BOOLEAN             ResumeParsing;

    //
    // Application pool queuing information.
    // These members should only be accessed by apool code.
    //
    struct {
        //
        // Shows where this request lives in the app pool queues.
        //
        QUEUE_STATE             QueueState;

        //
        // the process on which this request is queued. null
        // if the request is not on the process request list.
        //
        PUL_APP_POOL_PROCESS    pProcess;

        //
        // to queue it on the app pool
        //
        LIST_ENTRY              AppPoolEntry;

        //
        // to queue it on the process in UlShutdownAppPoolProcess
        //
        LIST_ENTRY              ProcessEntry;
    } AppPool;

    //
    // this request's sequence number on the connection
    //
    ULONG               RecvNumber;

    //
    // If there was an error parsing, the error code is put here.
    // ParseState is set to ParseErrorState.
    // Always use UlSetErrorCode(); never set this directly.
    //
    UL_HTTP_ERROR       ErrorCode;

    //
    // If there's a 503 error, we also need to know what kind of
    // load balancer we're dealing with.
    //
    HTTP_LOAD_BALANCER_CAPABILITIES LoadBalancerCapability;

    //
    // Total bytes needed for this request, includes string terminators
    //
    ULONG               TotalRequestSize;

    //
    // Number of 'unknown' headers we have.
    //
    USHORT              UnknownHeaderCount;

    //
    // byte length of pRawVerb.
    //
    UCHAR               RawVerbLength;

    //
    // Verb of this request.
    //
    HTTP_VERB           Verb;

    //
    // Pointer to raw verb, valid if Verb == UnknownVerb.
    //
    PUCHAR              pRawVerb;

    struct
    {

        //
        // The raw URL.
        //
        PUCHAR          pUrl;

        //
        // the below 2 pointers point into RawUrl.pUrl
        //

        //
        // host part (OPTIONAL)
        //
        PUCHAR          pHost;
        //
        // points to the abs_path part
        //
        PUCHAR          pAbsPath;

        //
        // The byte length of the RawUrl.pUrl.
        //
        ULONG           Length;

    } RawUrl;

    struct
    {

        //
        // The canonicalized, fully qualified URL,
        // http://hostname:port/abs/path/file?query=string.
        //
        PWSTR           pUrl;

        //
        // the below 3 pointers point into CookedUrl.pUrl
        //

        //
        // points to the host part, "hostname"
        //
        PWSTR           pHost;
        //
        // points to the abs_path part, "/abs/path/file"
        //
        PWSTR           pAbsPath;
        //
        // points to the query string (OPTIONAL), "?query=string"
        // CODEWORK: Change this to PSTR here and in HTTP_COOKED_URL in http.w
        //
        PWSTR           pQueryString;

        //
        // the byte length of CookedUrl.pUrl
        //
        ULONG           Length;
        //
        // the hash of CookedUrl.pUrl
        //
        ULONG           Hash;

        //
        // Which type was the RawUrl successfully decoded from:
        // Ansi, Dbcs, or Utf8?
        // CODEWORK: Add this field to HTTP_COOKED_URL in http.w
        //
        URL_ENCODING_TYPE UrlEncoding;

        //
        // Points to a separate buffer which holds the
        // modified form of the host part. The IP string
        // is augmented to the end. Used for IP bind site
        // routing. Initially this pointer is Null. As soon
        // as the token get generated it stays valid.
        //
        
        PWSTR           pRoutingToken;

        //
        // Length of the above string (in bytes) which may resides 
        // in a bigger buffer.Not including the terminating NULL.
        //

        USHORT          RoutingTokenLength;

        //
        // Allocation size (in bytes) of the above buffer.
        //
        
        USHORT          RoutingTokenBufferSize;
        
        //
        // The hash of the pRoutingToken + pAbsPath.
        //
        
        ULONG           RoutingHash;

        //
        // True if last generated token is Host Plus IP Based.
        //

        UL_ROUTING_TOKEN_TYPE RoutingTokenType;        

        //
        // If cgroup tree match happened with the above routing token.
        // rather than the original cooked url following is set.
        // In that case if the response for this request makes it to 
        // the uri cache, cache entry will include the token.
        //
        // CookedUrl's SiteUrlType is set accordingly.
        //
        
    } CookedUrl;

    //
    // HTTP Version of current request.
    //
    HTTP_VERSION        Version;

    //
    // Number of known headers.
    //
    ULONG               HeaderCount;

    //
    // the content length (OPTIONAL)
    //
    ULONGLONG           ContentLength;

    //
    // How many bytes are left to parse in the current chunk
    // (probably in pCurrentBuffer)
    //
    ULONGLONG           ChunkBytesToParse;

    //
    // How many bytes TOTAL were parsed
    //
    ULONGLONG           ChunkBytesParsed;

    //
    // How many bytes are left in pChunkBuffer (the current chunk)
    // for reading by user mode
    //
    ULONGLONG           ChunkBytesToRead;

    //
    // How many TOTAL bytes have been read by user mode
    //
    ULONGLONG           ChunkBytesRead;

    //
    // Statistical information for Logging and
    // possibly perfcounters. BytesReceived get updated
    // by Parser, whereas BytesSend is updated by sendresponse.
    //
    ULONGLONG           BytesSent;

    ULONGLONG           BytesReceived;

    //
    // To calculate the response time for this request
    //
    LARGE_INTEGER       TimeStamp;

    //
    // does the accept header of the this request has */* wild card?
    //

    ULONG               AcceptWildcard:1;

    //
    // is this chunk-encoded?
    //
    ULONG               Chunked:1;

    //
    // parsed the first chunk?
    //
    ULONG               ParsedFirstChunk:1;

    //
    // Is the request in "drain mode"?
    //
    ULONG               InDrain:1;

    //
    // Has a "100 continue" been sent?
    //
    ULONG               SentContinue:1;

    //
    // Are we cleaning up the request?
    //
    ULONG               InCleanup:1;

    //
    // Are we building a response but haven't flushed it to TDI yet?
    //
    ULONG               SendInProgress:1;

    //
    // Is the RawUrl Clean?
    //
    BOOLEAN             RawUrlClean;

    //
    // has a response has been sent
    //
    ULONG               SentResponse;

    //
    // has the last send call been made
    //
    ULONG               SentLast;

    //
    // To scynchronize against zombifying the connection while
    // last send is on the fly. This however cannot be set on the
    // HttpConnection as the last response for the first request
    // will always set this flag, which means we will take a perf-hit
    // for keep-alive connections.
    //
    ULONG               ZombieCheck;

    //
    // points to the buffer where protocol header data started.
    //
    PUL_REQUEST_BUFFER  pHeaderBuffer;

    //
    // the last buffer containing header data
    //
    PUL_REQUEST_BUFFER  pLastHeaderBuffer;

    //
    // points to the buffer where we are reading/parsing body chunk(s)
    //
    PUL_REQUEST_BUFFER  pChunkBuffer;

    //
    // the current location we are reading body chunk from, points into
    // pChunkBuffer
    //
    PUCHAR              pChunkLocation;

#if REFERENCE_DEBUG
    //
    // Reference trace log.
    //

    PTRACE_LOG          pTraceLog;
#endif

} UL_INTERNAL_REQUEST, *PUL_INTERNAL_REQUEST;


#endif // _HTTPTYPES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\ioctlp.h ===
/*++

Copyright (c) 1998-2002 Microsoft Corporation

Module Name:

    ioctlp.h

Abstract:

    Validation macros for IOCTL handlers

Author:

    George V. Reilly (GeorgeRe) May 2001        Hardened the IOCTLs

Revision History:


--*/

#ifndef _IOCTLP_H_
#define _IOCTLP_H_

/*++

IOCTL buffering methods

InputBuffer |METHOD_BUFFERED|METHOD_IN_DIRECT|METHOD_OUT_DIRECT|METHOD_NEITHER
------------+---------------+----------------+-----------------+--------------
Uses        | Buffered I/O  |  Buffered I/O  |  Buffered I/O   | Requestor's
            |               |                |                 | virtual addr
------------+---------------+----------------+-----------------+--------------
located     | Kernel virtual address in                        | Parameters.
(if present)| Irp->AssociatedIrp.SystemBuffer                  | DeviceIoContr
            |                                                  | ol.Type3Input
            |                                                  | Buffer
------------+--------------------------------------------------+--------------
length      | Parameters.DeviceIoControlInputBufferLength
------------+-----------------------------------------------------------------
OutBuffer 
------------+---------------+----------------+-----------------+--------------
Uses        | Buffered I/O  |   Direct I/O   |   Direct I/O    | Requestor's
            |               |                |                 | virtual addr
------------+---------------+----------------------------------+--------------
located     |Kernel virtual | MDL pointed to by                | Irp->
(if present)|addr Irp->Assoc| Irp->MdlAddress                  | UserBuffer
            |iatedIrp.System|                                  |
            |Buffer         |                                  |
------------+---------------+----------------------------------+--------------
length      | Length in bytes at Parameters.DeviceIoControl.OutputBufferLength
------------+-----------------------------------------------------------------

--*/


// METHOD_BUFFERED, METHOD_IN_DIRECT, METHOD_OUT_DIRECT, or METHOD_NEITHER
#define METHOD_FROM_CTL_CODE(ctlcode)   ((ctlcode) & 3)

// Used in each ioctl handler to document the kind of parameter probing
// that needs to be done.
#define ASSERT_IOCTL_METHOD(method, ioctl)                                  \
    C_ASSERT(METHOD_##method == METHOD_FROM_CTL_CODE(IOCTL_HTTP_##ioctl))


#define VALIDATE_INFORMATION_CLASS( pInfo, Class, Type, Max )               \
    Class = pInfo->InformationClass;                                        \
    if ( (Class < 0) || (Class >= Max) )                                   \
    {                                                                       \
        Status = STATUS_INVALID_PARAMETER;                                  \
        goto end;                                                           \
    }


#define OUTPUT_BUFFER_TOO_SMALL(pIrpSp, Type)                               \
    ((pIrpSp->Parameters.DeviceIoControl.OutputBufferLength) < sizeof(Type))


#define VALIDATE_OUTPUT_BUFFER_SIZE(pIrpSp, Type)                           \
    /* Ensure the output buffer is large enough. */                         \
    if ( OUTPUT_BUFFER_TOO_SMALL(pIrpSp,Type) )                             \
    {                                                                       \
        /* output buffer too small. */                                      \
        Status = STATUS_BUFFER_TOO_SMALL;                                   \
        goto end;                                                           \
    }


//
// We check for alignment problems as well as obtain a virtual address
// for the MdlAddress
//

#define VALIDATE_BUFFER_ALIGNMENT(pInfo, Type)                              \
    if ( ((ULONG_PTR) pInfo) & (TYPE_ALIGNMENT(Type)-1) )                   \
    {                                                                       \
        Status = STATUS_DATATYPE_MISALIGNMENT_ERROR;                        \
        pInfo = NULL;                                                       \
        goto end;                                                           \
    }


#define GET_OUTPUT_BUFFER_ADDRESS_FROM_MDL(pIrp, pInfo)                     \
    /* Ensure MdlAddress is non-null */                                     \
    if (NULL == pIrp->MdlAddress)                                           \
    {                                                                       \
        Status = STATUS_INVALID_PARAMETER;                                  \
        goto end;                                                           \
    }                                                                       \
                                                                            \
    /* Try to obtain virtual address */                                     \
    pInfo = MmGetSystemAddressForMdlSafe(                                   \
                        pIrp->MdlAddress,                                   \
                        LowPagePriority                                     \
                        );                                                  \
                                                                            \
    if (NULL == pInfo)                                                      \
    {                                                                       \
        Status = STATUS_INSUFFICIENT_RESOURCES;                             \
        goto end;                                                           \
    }


#define VALIDATE_OUTPUT_BUFFER_ADDRESS_FROM_MDL(pIrp, Type)                 \
    /* Ensure MdlAddress is non-null */                                     \
    if (NULL == pIrp->MdlAddress)                                           \
    {                                                                       \
        Status = STATUS_INVALID_PARAMETER;                                  \
        goto end;                                                           \
    }                                                                       \
                                                                            \
    /* Check alignment using of MdlAddress's virtual address */             \
    if (((ULONG_PTR) MmGetMdlVirtualAddress(pIrp->MdlAddress)) &            \
        (TYPE_ALIGNMENT(Type) - 1))                                         \
    {                                                                       \
        Status = STATUS_DATATYPE_MISALIGNMENT_ERROR;                        \
        goto end;                                                           \
    }


//
// Because we are using pIrp->AssociatedIrp.SystemBuffer below to check for a
// valid output buffer, this macro only works properly with METHOD_BUFFERED
// ioctl's.
//

#define VALIDATE_OUTPUT_BUFFER(pIrp, pIrpSp, Type, pInfo)                   \
    /* Ensure the output buffer is large enough. */                         \
    VALIDATE_OUTPUT_BUFFER_SIZE(pIrpSp, Type);                              \
                                                                            \
    /* Fetch out the output buffer */                                       \
    pInfo = (Type*) pIrp->AssociatedIrp.SystemBuffer;                       \
                                                                            \
    if (NULL == pInfo)                                                      \
    {                                                                       \
        Status = STATUS_INVALID_PARAMETER;                                  \
        goto end;                                                           \
    }


//
// Because we are using Irp->MdlAddress below to check for a valid output
// buffer, this macro does *not* work for METHOD_BUFFERED ioctl's.  For 
// METHOD_BUFFERED ioctl's use VALIDATE_OUTPUT_BUFFER above.
//

#define VALIDATE_OUTPUT_MDL(pIrp, pIrpSp, Type, pInfo)                      \
    /* Ensure the output buffer is large enough. */                         \
    VALIDATE_OUTPUT_BUFFER_SIZE(pIrpSp, Type);                              \
                                                                            \
    /* Obtain virtual address from Mdl */                                   \
    GET_OUTPUT_BUFFER_ADDRESS_FROM_MDL(pIrp, pInfo);                        \
                                                                            \
    /* Check alignment */                                                   \
    VALIDATE_BUFFER_ALIGNMENT(pInfo, Type);


#define VALIDATE_OUTPUT_BUFFER_FROM_MDL(pIrpSp, pInfo, Type)                \
    /* Ensure the output buffer is large enough. */                         \
    VALIDATE_OUTPUT_BUFFER_SIZE(pIrpSp, Type);                              \
                                                                            \
    /* Check alignment */                                                   \
    VALIDATE_BUFFER_ALIGNMENT(pInfo, Type);


#define HANDLE_BUFFER_LENGTH_REQUEST(pIrp, pIrpSp, Type)                    \
    if ( (NULL == pIrp->MdlAddress) ||                                      \
          OUTPUT_BUFFER_TOO_SMALL(pIrpSp, Type) )                           \
    {                                                                       \
        pIrp->IoStatus.Information = sizeof(Type);                        \
        Status = STATUS_BUFFER_OVERFLOW;                                    \
        goto end;                                                           \
    }


#define VALIDATE_INPUT_BUFFER(pIrp, pIrpSp, INFO_TYPE, pInfo)           \
    /* Ensure the input buffer looks good */                                \
    if (pIrpSp->Parameters.DeviceIoControl.InputBufferLength                \
            < sizeof(INFO_TYPE))                                            \
    {                                                                       \
        /* input buffer too small. */                                       \
        Status = STATUS_BUFFER_TOO_SMALL;                                   \
        goto end;                                                           \
    }                                                                       \
                                                                            \
    /* Fetch out the input buffer */                                        \
    pInfo = (INFO_TYPE*) pIrp->AssociatedIrp.SystemBuffer;                  \
                                                                            \
    if (NULL == pInfo)                                                      \
    {                                                                       \
        Status = STATUS_INVALID_PARAMETER;                                  \
        goto end;                                                           \
    }


#define VALIDATE_SEND_INFO(                                                 \
    pIrp,                                                                   \
    pIrpSp,                                                                 \
    pSendInfo,                                                              \
    LocalSendInfo,                                                          \
    pEntityChunk,                                                           \
    pLocalEntityChunks,                                                     \
    LocalEntityChunks                                                       \
    )                                                                       \
    /* Ensure the input buffer looks good */                                \
    if (pIrpSp->Parameters.DeviceIoControl.InputBufferLength                \
            < sizeof(HTTP_SEND_HTTP_RESPONSE_INFO))                         \
    {                                                                       \
        /* input buffer too small. */                                       \
        Status = STATUS_BUFFER_TOO_SMALL;                                   \
        goto end;                                                           \
    }                                                                       \
                                                                            \
    pSendInfo = (PHTTP_SEND_HTTP_RESPONSE_INFO)                             \
                    pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer;    \
                                                                            \
    if (NULL == pSendInfo)                                                  \
    {                                                                       \
        Status = STATUS_INVALID_PARAMETER;                                  \
        goto end;                                                           \
    }                                                                       \
                                                                            \
    /* Probe the input buffer before copying it, to check address range */  \
    UlProbeForRead(                                                         \
        pSendInfo,                                                          \
        sizeof(HTTP_SEND_HTTP_RESPONSE_INFO),                               \
        sizeof(PVOID),                                                      \
        pIrp->RequestorMode                                                 \
        );                                                                  \
                                                                            \
    /* Copy the input buffer into a local variable, to prevent user */      \
    /* remapping it after we've probed it. */                               \
    LocalSendInfo = *pSendInfo;                                             \
                                                                            \
    /* Prevent arithmetic overflows in the multiplication below */          \
    if (LocalSendInfo.EntityChunkCount >= UL_MAX_CHUNKS)                    \
    {                                                                       \
        Status = STATUS_INVALID_PARAMETER;                                  \
        goto end;                                                           \
    }                                                                       \
                                                                            \
    /* Third parameter should be TYPE_ALIGNMENT(HTTP_DATA_CHUNK) */         \
    UlProbeForRead(                                                         \
        LocalSendInfo.pEntityChunks,                                        \
        sizeof(HTTP_DATA_CHUNK) * LocalSendInfo.EntityChunkCount,           \
        sizeof(PVOID),                                                      \
        pIrp->RequestorMode                                                 \
        );                                                                  \
                                                                            \
    /* Copy the data chunks to a local chunk arrary. */                     \
    if (UserMode == pIrp->RequestorMode)                                    \
    {                                                                       \
        if (LocalSendInfo.EntityChunkCount > UL_LOCAL_CHUNKS)               \
        {                                                                   \
            pLocalEntityChunks = (PHTTP_DATA_CHUNK)                         \
                UL_ALLOCATE_POOL(                                           \
                    PagedPool,                                              \
                    sizeof(HTTP_DATA_CHUNK) * LocalSendInfo.EntityChunkCount,\
                    UL_DATA_CHUNK_POOL_TAG                                  \
                    );                                                      \
                                                                            \
            if (NULL == pLocalEntityChunks)                                 \
            {                                                               \
                Status = STATUS_NO_MEMORY;                                  \
                goto end;                                                   \
            }                                                               \
                                                                            \
            pEntityChunks = pLocalEntityChunks;                             \
        }                                                                   \
        else                                                                \
        {                                                                   \
            pEntityChunks = LocalEntityChunks;                              \
        }                                                                   \
                                                                            \
        RtlCopyMemory(                                                      \
            pEntityChunks,                                                  \
            LocalSendInfo.pEntityChunks,                                    \
            sizeof(HTTP_DATA_CHUNK) * LocalSendInfo.EntityChunkCount        \
            );                                                              \
    }                                                                       \
    else                                                                    \
    {                                                                       \
        pEntityChunks = LocalSendInfo.pEntityChunks;                        \
    }


#define VALIDATE_LOG_DATA(pIrp,LocalSendInfo, LocalLogData)                 \
    /* Capture and make a local copy of LogData. */                         \
    /* pSendInfo is already captured and LocalSendInfo.pLogData is */       \
    /* pointing to user's pLogData at the beginning */                      \
    if (LocalSendInfo.pLogData && UserMode == pIrp->RequestorMode)          \
    {                                                                       \
        UlProbeForRead(                                                     \
            LocalSendInfo.pLogData,                                         \
            sizeof(HTTP_LOG_FIELDS_DATA),                                   \
            sizeof(USHORT),                                                 \
            pIrp->RequestorMode                                             \
            );                                                              \
                                                                            \
        LocalLogData = *(LocalSendInfo.pLogData);                           \
        LocalSendInfo.pLogData = &LocalLogData;                             \
    } else

// better be an application pool
#define VALIDATE_APP_POOL_FO(pFileObject, pProcess, CheckWorkerProcess)     \
    if (!IS_APP_POOL_FO(pFileObject))                                       \
    {                                                                       \
        Status = STATUS_INVALID_DEVICE_REQUEST;                             \
        goto end;                                                           \
    }                                                                       \
                                                                            \
    pProcess = GET_APP_POOL_PROCESS(pFileObject);                           \
                                                                            \
    if (!IS_VALID_AP_PROCESS(pProcess)                                      \
        || !IS_VALID_AP_OBJECT(pProcess->pAppPool))                         \
    {                                                                       \
        Status = STATUS_INVALID_PARAMETER;                                  \
        goto end;                                                           \
    }                                                                       \
                                                                            \
    if (CheckWorkerProcess && pProcess->Controller)                         \
    {                                                                       \
        Status = STATUS_NOT_SUPPORTED;                                      \
        goto end;                                                           \
    } else


#define VALIDATE_APP_POOL(pIrpSp, pProcess, CheckWorkerProcess)             \
    VALIDATE_APP_POOL_FO(pIrpSp->FileObject, pProcess, CheckWorkerProcess)
        
// better be a control channel
#define VALIDATE_CONTROL_CHANNEL(pIrpSp, pControlChannel)                   \
    if (!IS_CONTROL_CHANNEL(pIrpSp->FileObject))                            \
    {                                                                       \
        Status = STATUS_INVALID_DEVICE_REQUEST;                             \
        goto end;                                                           \
    }                                                                       \
    else                                                                    \
    {                                                                       \
        pControlChannel = GET_CONTROL_CHANNEL(pIrpSp->FileObject);          \
                                                                            \
        if (!IS_ACTIVE_CONTROL_CHANNEL(pControlChannel))                    \
        {                                                                   \
            Status = STATUS_INVALID_PARAMETER;                              \
            goto end;                                                       \
        }                                                                   \
    }
        
// better be a filter channel
#define VALIDATE_FILTER_PROCESS(pIrpSp, pFilterProcess)                     \
    if (!IS_FILTER_PROCESS_FO(pIrpSp->FileObject))                          \
    {                                                                       \
        Status = STATUS_INVALID_DEVICE_REQUEST;                             \
        goto end;                                                           \
    }                                                                       \
                                                                            \
    pFilterProcess = GET_FILTER_PROCESS(pIrpSp->FileObject);                \
                                                                            \
    if (!IS_VALID_FILTER_PROCESS(pFilterProcess))                           \
    {                                                                       \
        Status = STATUS_INVALID_PARAMETER;                                  \
        goto end;                                                           \
    } else


// Complete the request and return Status
#define COMPLETE_REQUEST_AND_RETURN(pIrp, Status)                           \
    if (Status != STATUS_PENDING)                                           \
    {                                                                       \
        pIrp->IoStatus.Status = Status;                                     \
        UlCompleteRequest( pIrp, IO_NO_INCREMENT );                         \
    }                                                                       \
                                                                            \
    RETURN( Status );


/***************************************************************************++

Routine Description:

    Check to see if the connection is a zombie. If that's the case
    proceed with logging only handling of the connection. Basically
    if this is the last sendresponse with the logging data, do the
    logging otherwise reject. But this zombie connection may already
    been terminated by the timeout code, guard against that by 
    looking at the ZombieCheck flag.

Arguments:

    pRequest     - Request which reeceives the ioctl
    pHttpConn    - Check connection for zombie state
    Falgs        - To understant whether this is final send or not
    pUserLogData - The user logging data
    
--***************************************************************************/

__inline
NTSTATUS
UlCheckForZombieConnection(
    IN  PUL_INTERNAL_REQUEST pRequest,
    IN   PUL_HTTP_CONNECTION pHttpConn,
    IN                 ULONG Flags,
    IN PHTTP_LOG_FIELDS_DATA pUserLogData,
    IN       KPROCESSOR_MODE RequestorMode
    )
{
    NTSTATUS Status;
    BOOLEAN LastSend;

    ASSERT(UL_IS_VALID_HTTP_CONNECTION(pHttpConn));
    ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pRequest));

    LastSend = (BOOLEAN)(((Flags) & HTTP_SEND_RESPONSE_FLAG_MORE_DATA) == 0);
    Status   = STATUS_SUCCESS;
    
    if (!LastSend)
    {        
        if (pHttpConn->Zombified)
        {
            //
            // Reject any send ioctl other than the last one 
            // if the connection is in zombie state.
            //
            
            Status = STATUS_CONNECTION_INVALID;
        }
        else
        {
            //
            // Proceed with the normal send path.
            //
        }
    }
    else
    {
        //
        // Only if the destroy-connection raced before us, then 
        // acquire the eresource and do the zombie check. 
        //
        if (1 == InterlockedCompareExchange(
                    (PLONG) &pRequest->ZombieCheck,
                    1,
                    0
                    ))
        {            
            UlAcquirePushLockExclusive(&pHttpConn->PushLock);
            
            if (pHttpConn->Zombified)
            {        
                //
                // Avoid the logging path if the zombie connection is 
                // already timed out.
                //

                if (1 == InterlockedCompareExchange(
                            (PLONG) &pHttpConn->CleanedUp,
                            1,
                            0
                            ))
                {
                    Status = STATUS_CONNECTION_INVALID; 
                }
                else
                {
                    Status = UlLogZombieConnection(
                                pRequest,
                                pHttpConn,
                                pUserLogData,
                                RequestorMode
                                );
                }
                    
            }
            else
            {
                //
                // Not a zombie connection proceed with the normal 
                // last send path. 
                //   
            }
        
            UlReleasePushLockExclusive(&pHttpConn->PushLock);
        }

    }

    return Status;
} // UlCheckForZombieConnection
    

// Forward declarations

VOID
UlpRestartSendHttpResponse(
    IN PVOID pCompletionContext,
    IN NTSTATUS Status,
    IN ULONG_PTR Information
    );


#endif  // _IOCTLP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\ioctl.c ===
/*++

Copyright (c) 1998-2002 Microsoft Corporation

Module Name:

    ioctl.c

Abstract:

    This module implements various IOCTL handlers.

Author:

    Keith Moore (keithmo)       10-Jun-1998

Revision History:

    Paul McDaniel (paulmcd)     15-Mar-1999     Modified SendResponse
    George V. Reilly (GeorgeRe) May 2001        Hardened the IOCTLs

--*/

// Paranoia is the name of the game here. We don't trust anything we get from
// user mode. All data has to be probed inside of a try/except handler.
// Furthermore, we assume that malicious or incompetent users will
// asynchronously change the data at any time, so we attempt to capture as
// much as possible of it in stack variables. If we need to walk through a
// list more than once, we cannot assume that it's the same data the second
// time around. Failure to observe these rules could result in a bugcheck or
// in the usermode code gaining access to kernel data structures.

#include "precomp.h"
#include "ioctlp.h"


#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, UlQueryControlChannelIoctl )
#pragma alloc_text( PAGE, UlSetControlChannelIoctl )
#pragma alloc_text( PAGE, UlCreateConfigGroupIoctl )
#pragma alloc_text( PAGE, UlDeleteConfigGroupIoctl )
#pragma alloc_text( PAGE, UlQueryConfigGroupIoctl )
#pragma alloc_text( PAGE, UlSetConfigGroupIoctl )
#pragma alloc_text( PAGE, UlAddUrlToConfigGroupIoctl )
#pragma alloc_text( PAGE, UlRemoveUrlFromConfigGroupIoctl )
#pragma alloc_text( PAGE, UlRemoveAllUrlsFromConfigGroupIoctl )
#pragma alloc_text( PAGE, UlQueryAppPoolInformationIoctl )
#pragma alloc_text( PAGE, UlSetAppPoolInformationIoctl )
#pragma alloc_text( PAGE, UlReceiveHttpRequestIoctl )
#pragma alloc_text( PAGE, UlReceiveEntityBodyIoctl )
#pragma alloc_text( PAGE, UlSendHttpResponseIoctl )
#pragma alloc_text( PAGE, UlSendEntityBodyIoctl )
#pragma alloc_text( PAGE, UlFlushResponseCacheIoctl )
#pragma alloc_text( PAGE, UlWaitForDemandStartIoctl )
#pragma alloc_text( PAGE, UlWaitForDisconnectIoctl )
#pragma alloc_text( PAGE, UlFilterAcceptIoctl )
#pragma alloc_text( PAGE, UlFilterCloseIoctl )
#pragma alloc_text( PAGE, UlFilterRawReadIoctl )
#pragma alloc_text( PAGE, UlFilterRawWriteIoctl )
#pragma alloc_text( PAGE, UlFilterAppReadIoctl )
#pragma alloc_text( PAGE, UlFilterAppWriteIoctl )
#pragma alloc_text( PAGE, UlReceiveClientCertIoctl )
#pragma alloc_text( PAGE, UlGetCountersIoctl )
#pragma alloc_text( PAGE, UlAddFragmentToCacheIoctl )
#pragma alloc_text( PAGE, UlReadFragmentFromCacheIoctl )
#pragma alloc_text( PAGE, UcSetServerContextInformationIoctl )
#pragma alloc_text( PAGE, UcQueryServerContextInformationIoctl )
#pragma alloc_text( PAGE, UcReceiveResponseIoctl )

#pragma alloc_text( PAGEUC, UcSendEntityBodyIoctl )
#pragma alloc_text( PAGEUC, UcSendRequestIoctl )
#pragma alloc_text( PAGEUC, UcCancelRequestIoctl )

#endif  // ALLOC_PRAGMA

#if 0

NOT PAGEABLE --  UlShutdownAppPoolIoctl 
NOT PAGEABLE --  UlpRestartSendHttpResponse 
NOT PAGEABLE --  UlShutdownFilterIoctl 

#endif


//
// Public functions.
//

/***************************************************************************++

Routine Description:

    This routine queries information associated with a control channel.

    Note: This is a METHOD_OUT_DIRECT IOCTL.

Arguments:

    pIrp - Supplies a pointer to the IO request packet.

    pIrpSp - Supplies a pointer to the IO stack location to use for this
        request.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlQueryControlChannelIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )
{
    NTSTATUS                    Status = STATUS_SUCCESS;
    PHTTP_CONTROL_CHANNEL_INFO  pInfo;
    PUL_CONTROL_CHANNEL         pControlChannel;
    PVOID                       pMdlBuffer = NULL;
    ULONG                       Length = 0;
    ULONG                       OutputBufferLength;

    //
    // sanity check.
    //

    ASSERT_IOCTL_METHOD(OUT_DIRECT, QUERY_CONTROL_CHANNEL);

    PAGED_CODE();

    VALIDATE_CONTROL_CHANNEL(pIrpSp, pControlChannel);

    VALIDATE_INPUT_BUFFER(pIrp, pIrpSp, HTTP_CONTROL_CHANNEL_INFO, pInfo);

    //
    // Validate input buffer
    // A NULL MdlAddress inidicates a request for buffer length
    //

    if ( NULL != pIrp->MdlAddress )
    {
        GET_OUTPUT_BUFFER_ADDRESS_FROM_MDL(pIrp, pMdlBuffer);
    }


    // Also make sure that user buffer was aligned properly

    switch (pInfo->InformationClass)
    {
    case HttpControlChannelStateInformation:
        HANDLE_BUFFER_LENGTH_REQUEST(pIrp, pIrpSp, HTTP_ENABLED_STATE);

        VALIDATE_BUFFER_ALIGNMENT(pMdlBuffer, HTTP_ENABLED_STATE);
        break;

    case HttpControlChannelBandwidthInformation:
        HANDLE_BUFFER_LENGTH_REQUEST(pIrp, pIrpSp, HTTP_BANDWIDTH_LIMIT);

        VALIDATE_BUFFER_ALIGNMENT(pMdlBuffer, HTTP_BANDWIDTH_LIMIT);
        break;

    case HttpControlChannelConnectionInformation:
        HANDLE_BUFFER_LENGTH_REQUEST(pIrp, pIrpSp, HTTP_CONNECTION_LIMIT);

        VALIDATE_BUFFER_ALIGNMENT(pMdlBuffer, HTTP_CONNECTION_LIMIT);
        break;

    default:
        Status = STATUS_INVALID_PARAMETER;
        goto end;
        break;
    }

    OutputBufferLength = pIrpSp->Parameters.DeviceIoControl.OutputBufferLength;

    Status = UlGetControlChannelInformation(
                        pIrp->RequestorMode,
                        pControlChannel,
                        pInfo->InformationClass,
                        pMdlBuffer,
                        OutputBufferLength,
                        &Length
                        );

    if (NT_SUCCESS(Status))
    {
        pIrp->IoStatus.Information = (ULONG_PTR)Length;
    }

end:
    COMPLETE_REQUEST_AND_RETURN( pIrp, Status );

}   // UlQueryControlChannelIoctl


/***************************************************************************++

Routine Description:

    This routine sets information associated with a control channel.

    Note: This is a METHOD_IN_DIRECT IOCTL.

Arguments:

    pIrp - Supplies a pointer to the IO request packet.

    pIrpSp - Supplies a pointer to the IO stack location to use for this
        request.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlSetControlChannelIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )
{
    NTSTATUS                                Status = STATUS_SUCCESS;
    PHTTP_CONTROL_CHANNEL_INFO              pInfo;
    PUL_CONTROL_CHANNEL                     pControlChannel;
    HTTP_CONTROL_CHANNEL_INFORMATION_CLASS  Class;
    PVOID                                   pMdlBuffer = NULL;
    ULONG                                   OutputBufferLength;
    
    //
    // sanity check.
    //

    ASSERT_IOCTL_METHOD(IN_DIRECT, SET_CONTROL_CHANNEL);

    PAGED_CODE();

    VALIDATE_CONTROL_CHANNEL(pIrpSp, pControlChannel);

    VALIDATE_INPUT_BUFFER(pIrp, pIrpSp, HTTP_CONTROL_CHANNEL_INFO, pInfo);

    VALIDATE_INFORMATION_CLASS( 
            pInfo, 
            Class, 
            HTTP_CONTROL_CHANNEL_INFORMATION_CLASS,
            HttpControlChannelMaximumInformation);

    //
    // Validate input buffer
    //

    GET_OUTPUT_BUFFER_ADDRESS_FROM_MDL(pIrp, pMdlBuffer);

    switch ( Class )
    {
    case HttpControlChannelStateInformation:
        VALIDATE_OUTPUT_BUFFER_FROM_MDL(
                pIrpSp, 
                pMdlBuffer, 
                HTTP_ENABLED_STATE);
        break;
    
    case HttpControlChannelBandwidthInformation:
        VALIDATE_OUTPUT_BUFFER_FROM_MDL(
                pIrpSp, 
                pMdlBuffer, 
                HTTP_BANDWIDTH_LIMIT);
        break;

    case HttpControlChannelFilterInformation:
        VALIDATE_OUTPUT_BUFFER_FROM_MDL(
                pIrpSp, 
                pMdlBuffer, 
                HTTP_CONTROL_CHANNEL_FILTER);
        break;
        
    case HttpControlChannelTimeoutInformation:
        VALIDATE_OUTPUT_BUFFER_FROM_MDL(
                pIrpSp, 
                pMdlBuffer, 
                HTTP_CONTROL_CHANNEL_TIMEOUT_LIMIT);
        break;
        
    case HttpControlChannelUTF8Logging:
        VALIDATE_OUTPUT_BUFFER_FROM_MDL(
                pIrpSp, 
                pMdlBuffer, 
                HTTP_CONTROL_CHANNEL_UTF8_LOGGING);
        break;
        
    case HttpControlChannelBinaryLogging:
        VALIDATE_OUTPUT_BUFFER_FROM_MDL(
                pIrpSp, 
                pMdlBuffer, 
                HTTP_CONTROL_CHANNEL_BINARY_LOGGING);
        break;

    case HttpControlChannelDemandStartThreshold:
        VALIDATE_OUTPUT_BUFFER_FROM_MDL(
                pIrpSp, 
                pMdlBuffer, 
                HTTP_CONTROL_CHANNEL_DEMAND_START_THRESHOLD);
        break;

    default:
        Status = STATUS_INVALID_PARAMETER;
        goto end;
        break;
    }        

    //
    // call the function
    //

    OutputBufferLength = pIrpSp->Parameters.DeviceIoControl.OutputBufferLength;

    Status = UlSetControlChannelInformation(
                pControlChannel,
                pInfo->InformationClass,
                pMdlBuffer,
                OutputBufferLength,
                pIrp->RequestorMode
                );
    
end:
    COMPLETE_REQUEST_AND_RETURN( pIrp, Status );

}   // UlSetControlChannelIoctl


/***************************************************************************++

Routine Description:

    This routine creates a new configuration group.

    Note: This is a METHOD_BUFFERED IOCTL.

Arguments:

    pIrp - Supplies a pointer to the IO request packet.

    pIrpSp - Supplies a pointer to the IO stack location to use for this
        request.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlCreateConfigGroupIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )
{
    NTSTATUS                    Status;
    PHTTP_CONFIG_GROUP_INFO     pInfo;
    PUL_CONTROL_CHANNEL         pControlChannel;
    HTTP_CONFIG_GROUP_ID        LocalConfigGroupId;

    //
    // sanity check.
    //

    ASSERT_IOCTL_METHOD(BUFFERED, CREATE_CONFIG_GROUP);

    PAGED_CODE();

    HTTP_SET_NULL_ID(&LocalConfigGroupId);

    VALIDATE_CONTROL_CHANNEL(pIrpSp, pControlChannel);

    VALIDATE_OUTPUT_BUFFER(pIrp, pIrpSp,
                           HTTP_CONFIG_GROUP_INFO, pInfo);

    // it's pure output, wipe it to be sure
    RtlZeroMemory(pInfo, sizeof(HTTP_CONFIG_GROUP_INFO));

    // Call the internal worker func
    //
    Status = UlCreateConfigGroup(
                    pControlChannel,
                    &LocalConfigGroupId
                    );

    if (NT_SUCCESS(Status))
        pInfo->ConfigGroupId = LocalConfigGroupId;

end:
    if (Status != STATUS_PENDING)
    {
        //  how much output should we return?
        pIrp->IoStatus.Information = sizeof(HTTP_CONFIG_GROUP_INFO);
    }

    COMPLETE_REQUEST_AND_RETURN( pIrp, Status );

}   // UlCreateConfigGroupIoctl


/***************************************************************************++

Routine Description:

    This routine deletes an existing configuration group.

    Note: This is a METHOD_BUFFERED IOCTL.

Arguments:

    pIrp - Supplies a pointer to the IO request packet.

    pIrpSp - Supplies a pointer to the IO stack location to use for this
        request.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlDeleteConfigGroupIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )
{
    NTSTATUS                    Status;
    PHTTP_CONFIG_GROUP_INFO     pInfo;
    PUL_CONTROL_CHANNEL         pControlChannel;

    //
    // sanity check.
    //

    ASSERT_IOCTL_METHOD(BUFFERED, DELETE_CONFIG_GROUP);

    PAGED_CODE();

    VALIDATE_CONTROL_CHANNEL(pIrpSp, pControlChannel);

    VALIDATE_INPUT_BUFFER(pIrp, pIrpSp, HTTP_CONFIG_GROUP_INFO, pInfo);

    Status = UlDeleteConfigGroup(pInfo->ConfigGroupId);

end:
    COMPLETE_REQUEST_AND_RETURN( pIrp, Status );

}   // UlDeleteConfigGroupIoctl


/***************************************************************************++

Routine Description:

    This routine queries information associated with a configuration group.

    Note: This is a METHOD_OUT_DIRECT IOCTL.

Arguments:

    pIrp - Supplies a pointer to the IO request packet.

    pIrpSp - Supplies a pointer to the IO stack location to use for this
        request.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlQueryConfigGroupIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )
{
    NTSTATUS                             Status = STATUS_SUCCESS;
    PHTTP_CONFIG_GROUP_INFO              pInfo;
    PVOID                                pMdlBuffer = NULL;
    ULONG                                Length = 0L;
    ULONG                                OutputLength;
    PUL_CONTROL_CHANNEL                  pControlChannel;
    HTTP_CONFIG_GROUP_INFORMATION_CLASS  Class;

    //
    // sanity check.
    //

    ASSERT_IOCTL_METHOD(OUT_DIRECT, QUERY_CONFIG_GROUP);

    PAGED_CODE();

    //
    // Going to access the url string from user mode memory
    //

    VALIDATE_CONTROL_CHANNEL(pIrpSp, pControlChannel);

    VALIDATE_INPUT_BUFFER(pIrp, pIrpSp, HTTP_CONFIG_GROUP_INFO, pInfo);

    VALIDATE_INFORMATION_CLASS( 
            pInfo, 
            Class, 
            HTTP_CONFIG_GROUP_INFORMATION_CLASS,
            HttpConfigGroupMaximumInformation);

    //
    // Validate input buffer
    // A NULL MdlAddress inidicates a request for buffer length
    //

    if ( NULL != pIrp->MdlAddress )
    {
        GET_OUTPUT_BUFFER_ADDRESS_FROM_MDL(pIrp, pMdlBuffer);
    }

    switch ( Class )
    {
    case HttpConfigGroupBandwidthInformation:
        HANDLE_BUFFER_LENGTH_REQUEST(
                pIrp, 
                pIrpSp, 
                HTTP_CONFIG_GROUP_MAX_BANDWIDTH);
                
        VALIDATE_BUFFER_ALIGNMENT(
                pMdlBuffer, 
                HTTP_CONFIG_GROUP_MAX_BANDWIDTH);
        break;

    case HttpConfigGroupConnectionInformation:
        HANDLE_BUFFER_LENGTH_REQUEST(
                pIrp, 
                pIrpSp, 
                HTTP_CONFIG_GROUP_MAX_CONNECTIONS);
                
        VALIDATE_BUFFER_ALIGNMENT(
                pMdlBuffer, 
                HTTP_CONFIG_GROUP_MAX_CONNECTIONS);
        break;
        
    case HttpConfigGroupStateInformation:
        HANDLE_BUFFER_LENGTH_REQUEST(
                pIrp, 
                pIrpSp, 
                HTTP_CONFIG_GROUP_STATE);

        VALIDATE_BUFFER_ALIGNMENT(
                pMdlBuffer, 
                HTTP_CONFIG_GROUP_STATE);
        break;
        
    case HttpConfigGroupConnectionTimeoutInformation:
        HANDLE_BUFFER_LENGTH_REQUEST(pIrp, pIrpSp, ULONG);

        VALIDATE_BUFFER_ALIGNMENT(pMdlBuffer, ULONG);
        break;

    case HttpConfigGroupAppPoolInformation:

    default:
        Status = STATUS_INVALID_PARAMETER;
        goto end;
        break;
    }

    //
    // call the function
    //

    OutputLength = pIrpSp->Parameters.DeviceIoControl.OutputBufferLength;

    Status = UlQueryConfigGroupInformation(
                    pInfo->ConfigGroupId,
                    pInfo->InformationClass,
                    pMdlBuffer,
                    OutputLength,
                    &Length
                    );

    pIrp->IoStatus.Information = (NT_SUCCESS(Status)) ? 

            (ULONG_PTR)Length : (ULONG_PTR)0;

end:
    COMPLETE_REQUEST_AND_RETURN( pIrp, Status );

}   // UlQueryConfigGroupIoctl


/***************************************************************************++

Routine Description:

    This routine sets information associated with a configuration group.

    Note: This is a METHOD_IN_DIRECT IOCTL.

Arguments:

    pIrp - Supplies a pointer to the IO request packet.

    pIrpSp - Supplies a pointer to the IO stack location to use for this
        request.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlSetConfigGroupIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )
{
    NTSTATUS                             Status;
    PHTTP_CONFIG_GROUP_INFO              pInfo;
    PVOID                                pMdlBuffer;
    ULONG                                OutputLength;
    PUL_CONTROL_CHANNEL                  pControlChannel;
    HTTP_CONFIG_GROUP_INFORMATION_CLASS  Class;

    //
    // sanity check.
    //

    ASSERT_IOCTL_METHOD(IN_DIRECT, SET_CONFIG_GROUP);

    PAGED_CODE();

    VALIDATE_CONTROL_CHANNEL(pIrpSp, pControlChannel);

    VALIDATE_INPUT_BUFFER(pIrp, pIrpSp, HTTP_CONFIG_GROUP_INFO, pInfo);

    VALIDATE_INFORMATION_CLASS( 
            pInfo, 
            Class, 
            HTTP_CONFIG_GROUP_INFORMATION_CLASS,
            HttpConfigGroupMaximumInformation);

    //
    // Validate input buffer
    //

    GET_OUTPUT_BUFFER_ADDRESS_FROM_MDL(pIrp, pMdlBuffer);

    switch ( Class )
    {        
    case HttpConfigGroupLogInformation:
        VALIDATE_OUTPUT_BUFFER_FROM_MDL(
                pIrpSp, 
                pMdlBuffer, 
                HTTP_CONFIG_GROUP_LOGGING);
        break;

    case HttpConfigGroupAppPoolInformation:
        VALIDATE_OUTPUT_BUFFER_FROM_MDL(
                pIrpSp, 
                pMdlBuffer, 
                HTTP_CONFIG_GROUP_APP_POOL);
        break;

    case HttpConfigGroupBandwidthInformation:
        VALIDATE_OUTPUT_BUFFER_FROM_MDL(
                pIrpSp, 
                pMdlBuffer, 
                HTTP_CONFIG_GROUP_MAX_BANDWIDTH);
        break;

    case HttpConfigGroupConnectionInformation:
        VALIDATE_OUTPUT_BUFFER_FROM_MDL(
                pIrpSp, 
                pMdlBuffer, 
                HTTP_CONFIG_GROUP_MAX_CONNECTIONS);
        break;

    case HttpConfigGroupStateInformation:
        VALIDATE_OUTPUT_BUFFER_FROM_MDL(
                pIrpSp, 
                pMdlBuffer, 
                HTTP_CONFIG_GROUP_STATE);
        break;

    case HttpConfigGroupSiteInformation:
        VALIDATE_OUTPUT_BUFFER_FROM_MDL(
                pIrpSp, 
                pMdlBuffer, 
                HTTP_CONFIG_GROUP_SITE);
        break;

    case HttpConfigGroupConnectionTimeoutInformation:
        VALIDATE_OUTPUT_BUFFER_FROM_MDL(
                pIrpSp, 
                pMdlBuffer, 
                ULONG);
        break;

    default:
        Status = STATUS_INVALID_PARAMETER;
        goto end;
        break;

    }

    //
    // call the function
    //

    OutputLength = pIrpSp->Parameters.DeviceIoControl.OutputBufferLength;

    UlTrace(IOCTL,
            ("UlSetConfigGroupIoctl: CGroupId=%I64x, "
             "InfoClass=%d, pMdlBuffer=%p, length=%d\n",
             pInfo->ConfigGroupId,
             pInfo->InformationClass,
             pMdlBuffer,
             OutputLength
             ));

    Status = UlSetConfigGroupInformation(
                    pInfo->ConfigGroupId,
                    pInfo->InformationClass,
                    pMdlBuffer,
                    OutputLength,
                    pIrp->RequestorMode
                    );

end:
    COMPLETE_REQUEST_AND_RETURN( pIrp, Status );

}  // UlSetConfigGroupIoctl


/***************************************************************************++

Routine Description:

    This routine adds a new URL prefix to a configuration group.

    Note: This is a METHOD_BUFFERED IOCTL.

Arguments:

    pIrp - Supplies a pointer to the IO request packet.

    pIrpSp - Supplies a pointer to the IO stack location to use for this
        request.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlAddUrlToConfigGroupIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )
{
    NTSTATUS                    Status;
    PHTTP_CONFIG_GROUP_URL_INFO pInfo;
    PUL_CONTROL_CHANNEL         pControlChannel;
    UNICODE_STRING              FullyQualifiedUrl;
    ACCESS_STATE                AccessState;
    AUX_ACCESS_DATA             AuxData;
    ACCESS_MASK                 AccessMask;

    //
    // sanity check.
    //

    ASSERT_IOCTL_METHOD(BUFFERED, ADD_URL_TO_CONFIG_GROUP);

    PAGED_CODE();

    RtlInitEmptyUnicodeString(&FullyQualifiedUrl, NULL, 0);
        
    VALIDATE_CONTROL_CHANNEL(pIrpSp, pControlChannel);

    VALIDATE_INPUT_BUFFER(pIrp, pIrpSp, HTTP_CONFIG_GROUP_URL_INFO, pInfo);

    __try
    {
        Status = 
            UlProbeAndCaptureUnicodeString(
                &pInfo->FullyQualifiedUrl,
                pIrp->RequestorMode,
                &FullyQualifiedUrl,
                UNICODE_STRING_MAX_WCHAR_LEN
                );
    }
    __except( UL_EXCEPTION_FILTER() )
    {
        Status = UL_CONVERT_EXCEPTION_CODE(GetExceptionCode());
    }

    if (NT_SUCCESS(Status))
    {
        //
        // Validate type of operation being performed.
        //

        if (pInfo->UrlType != HttpUrlOperatorTypeRegistration &&
            pInfo->UrlType != HttpUrlOperatorTypeReservation)
        {
            Status = STATUS_INVALID_PARAMETER;
            goto end;
        }

        //
        // Set Access mask.
        //

        AccessMask = (pInfo->UrlType == HttpUrlOperatorTypeRegistration)?
                         HTTP_ALLOW_REGISTER_URL : HTTP_ALLOW_DELEGATE_URL;

        //
        // Capture the thread's access state.  Adding a reservation is 
        // delegation.
        //

        Status = SeCreateAccessState(
                    &AccessState,
                    &AuxData,
                    AccessMask,
                    &g_UrlAccessGenericMapping
                    );

        if (NT_SUCCESS(Status))
        {
            Status = UlAddUrlToConfigGroup(
                         pInfo,
                         &FullyQualifiedUrl,
                         &AccessState,
                         AccessMask,
                         pIrp->RequestorMode
                         );

            //
            // Delete the access state created above.
            //

            SeDeleteAccessState(&AccessState);
        }
    }

end:

    UlFreeCapturedUnicodeString(&FullyQualifiedUrl);
    
    COMPLETE_REQUEST_AND_RETURN( pIrp, Status );

} 



/***************************************************************************++

Routine Description:

    This routine removes a URL prefix from a configuration group.

    Note: This is a METHOD_BUFFERED IOCTL.

Arguments:

    pIrp - Supplies a pointer to the IO request packet.

    pIrpSp - Supplies a pointer to the IO stack location to use for this
        request.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlRemoveUrlFromConfigGroupIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )
{
    NTSTATUS                    Status;
    PHTTP_CONFIG_GROUP_URL_INFO pInfo;
    PUL_CONTROL_CHANNEL         pControlChannel;
    UNICODE_STRING              FullyQualifiedUrl;
    ACCESS_STATE                AccessState;
    AUX_ACCESS_DATA             AuxData;

    //
    // sanity check.
    //

    ASSERT_IOCTL_METHOD(BUFFERED, REMOVE_URL_FROM_CONFIG_GROUP);

    PAGED_CODE();

    RtlInitEmptyUnicodeString(&FullyQualifiedUrl, NULL, 0);
        
    VALIDATE_CONTROL_CHANNEL(pIrpSp, pControlChannel);

    VALIDATE_INPUT_BUFFER(pIrp, pIrpSp, HTTP_CONFIG_GROUP_URL_INFO, pInfo);

    __try
    {
        Status =
            UlProbeAndCaptureUnicodeString(
                &pInfo->FullyQualifiedUrl,
                pIrp->RequestorMode,
                &FullyQualifiedUrl,
                UNICODE_STRING_MAX_WCHAR_LEN
                );
    }
    __except( UL_EXCEPTION_FILTER() )
    {
        Status = UL_CONVERT_EXCEPTION_CODE(GetExceptionCode());
    }

    if(NT_SUCCESS(Status))
    {
        //
        // Validate type of operation being performed.
        //

        if (pInfo->UrlType != HttpUrlOperatorTypeRegistration &&
            pInfo->UrlType != HttpUrlOperatorTypeReservation)
        {
            Status = STATUS_INVALID_PARAMETER;
            goto end;
        }

        //
        // Capture the thread's access state.  Removing a reservation is
        // same as delegation.
        //

        Status = SeCreateAccessState(
                    &AccessState,
                    &AuxData,
                    HTTP_ALLOW_DELEGATE_URL,
                    &g_UrlAccessGenericMapping
                    );

        if (NT_SUCCESS(Status))
        {
            //
            // Further sanitization and stronger checks will happen in cgroup.
            //

            Status = UlRemoveUrlFromConfigGroup(
                         pInfo,
                         &FullyQualifiedUrl,
                         &AccessState,
                         HTTP_ALLOW_DELEGATE_URL,
                         pIrp->RequestorMode
                         );

            //
            // Delete the above captured state.
            //

            SeDeleteAccessState(&AccessState);
        }
    }

end:

    UlFreeCapturedUnicodeString(&FullyQualifiedUrl);
        
    COMPLETE_REQUEST_AND_RETURN(pIrp, Status);

}   


/***************************************************************************++

Routine Description:

    This routine removes all URLs from a configuration group.

    Note: This is a METHOD_BUFFERED IOCTL.

Arguments:

    pIrp - Supplies a pointer to the IO request packet.

    pIrpSp - Supplies a pointer to the IO stack location to use for this
        request.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlRemoveAllUrlsFromConfigGroupIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )
{
    NTSTATUS                    Status;
    PHTTP_REMOVE_ALL_URLS_INFO  pInfo;
    PUL_CONTROL_CHANNEL         pControlChannel;

    //
    // Sanity check.
    //

    ASSERT_IOCTL_METHOD(BUFFERED, REMOVE_ALL_URLS_FROM_CONFIG_GROUP);

    PAGED_CODE();

    VALIDATE_CONTROL_CHANNEL(pIrpSp, pControlChannel);

    VALIDATE_INPUT_BUFFER(pIrp, pIrpSp, HTTP_REMOVE_ALL_URLS_INFO, pInfo);

    //
    // Call the internal worker function.
    //

    Status = UlRemoveAllUrlsFromConfigGroup( pInfo->ConfigGroupId );

end:

    COMPLETE_REQUEST_AND_RETURN( pIrp, Status );

}


/***************************************************************************++

Routine Description:

    This routine queries information associated with an application pool.

    Note: This is a METHOD_OUT_DIRECT IOCTL.

Arguments:

    pIrp - Supplies a pointer to the IO request packet.

    pIrpSp - Supplies a pointer to the IO stack location to use for this
        request.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlQueryAppPoolInformationIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )
{
    NTSTATUS                         Status = STATUS_SUCCESS;
    PHTTP_APP_POOL_INFO              pInfo;
    PVOID                            pMdlBuffer = NULL;
    ULONG                            OutputBufferLength;
    ULONG                            Length = 0;
    PUL_APP_POOL_PROCESS             pProcess;
    HTTP_APP_POOL_INFORMATION_CLASS  Class;

    //
    // sanity check.
    //

    ASSERT_IOCTL_METHOD(OUT_DIRECT, QUERY_APP_POOL_INFORMATION);

    PAGED_CODE();

    // pProcess is an aligned address because it is allocated
    // by the I/O Manager.

    VALIDATE_APP_POOL(pIrpSp, pProcess, FALSE);

    VALIDATE_INPUT_BUFFER(pIrp, pIrpSp, HTTP_APP_POOL_INFO, pInfo);

    VALIDATE_INFORMATION_CLASS( 
            pInfo, 
            Class, 
            HTTP_APP_POOL_INFORMATION_CLASS,
            HttpConfigGroupMaximumInformation);


    // if no outbut buffer passed down in the Irp
    // that means app is asking for the required
    // field length

    if ( NULL != pIrp->MdlAddress )
    {
        GET_OUTPUT_BUFFER_ADDRESS_FROM_MDL(pIrp, pMdlBuffer);
    }

    // Verify input data in output buffer

    switch ( Class )
    {
    case HttpAppPoolQueueLengthInformation:
        HANDLE_BUFFER_LENGTH_REQUEST(
                pIrp, 
                pIrpSp, 
                LONG);
                
        VALIDATE_BUFFER_ALIGNMENT(
                pMdlBuffer, 
                LONG);
        break;

    case HttpAppPoolStateInformation:
        HANDLE_BUFFER_LENGTH_REQUEST(
                pIrp, 
                pIrpSp, 
                HTTP_APP_POOL_ENABLED_STATE);
                
        VALIDATE_BUFFER_ALIGNMENT(
                pMdlBuffer, 
                HTTP_APP_POOL_ENABLED_STATE);
        break;

    case HttpAppPoolLoadBalancerInformation:
        HANDLE_BUFFER_LENGTH_REQUEST(
                pIrp, 
                pIrpSp, 
                HTTP_LOAD_BALANCER_CAPABILITIES);
                
        VALIDATE_BUFFER_ALIGNMENT(
                pMdlBuffer, 
                HTTP_LOAD_BALANCER_CAPABILITIES);
        break;

    default:
        Status = STATUS_INVALID_PARAMETER;
        goto end;
        break;
    }

    OutputBufferLength = pIrpSp->Parameters.DeviceIoControl.OutputBufferLength;

    Status = UlQueryAppPoolInformation(
                    pProcess,
                    pInfo->InformationClass,
                    pMdlBuffer,
                    OutputBufferLength,
                    &Length
                    );

    pIrp->IoStatus.Information = (NT_SUCCESS(Status)) ? 

            (ULONG_PTR)Length : (ULONG_PTR)0;

end:

    COMPLETE_REQUEST_AND_RETURN( pIrp, Status );

}   // UlQueryAppPoolInformationIoctl



/***************************************************************************++

Routine Description:

    This routine sets information associated with an application pool.

    Note: This is a METHOD_IN_DIRECT IOCTL.

Arguments:

    pIrp - Supplies a pointer to the IO request packet.

    pIrpSp - Supplies a pointer to the IO stack location to use for this
        request.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlSetAppPoolInformationIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )
{
    NTSTATUS                         Status = STATUS_SUCCESS;
    PHTTP_APP_POOL_INFO              pInfo;
    PVOID                            pMdlBuffer = NULL;
    PUL_APP_POOL_PROCESS             pProcess = NULL;
    ULONG                            OutputBufferLength;
    HTTP_APP_POOL_INFORMATION_CLASS  Class;

    //
    // Sanity check
    //

    ASSERT_IOCTL_METHOD(IN_DIRECT, SET_APP_POOL_INFORMATION);

    PAGED_CODE();

    VALIDATE_APP_POOL(pIrpSp, pProcess, FALSE);

    VALIDATE_INPUT_BUFFER(pIrp, pIrpSp, HTTP_APP_POOL_INFO, pInfo);

    VALIDATE_INFORMATION_CLASS( 
            pInfo, 
            Class, 
            HTTP_APP_POOL_INFORMATION_CLASS,
            HttpConfigGroupMaximumInformation);
            
    //
    // Validate input buffer
    //

    GET_OUTPUT_BUFFER_ADDRESS_FROM_MDL(pIrp, pMdlBuffer);

    //
    // Also make sure that user buffer was aligned properly
    //

    switch (pInfo->InformationClass)
    {
    case HttpAppPoolQueueLengthInformation:
        VALIDATE_OUTPUT_BUFFER_FROM_MDL(
                pIrpSp, 
                pMdlBuffer, 
                LONG);
        break;

    case HttpAppPoolStateInformation:
        VALIDATE_OUTPUT_BUFFER_FROM_MDL(
                pIrpSp, 
                pMdlBuffer, 
                HTTP_APP_POOL_ENABLED_STATE);
        break;

    case HttpAppPoolLoadBalancerInformation:
        VALIDATE_OUTPUT_BUFFER_FROM_MDL(
                pIrpSp, 
                pMdlBuffer, 
                HTTP_LOAD_BALANCER_CAPABILITIES);
        break;

    case HttpAppPoolControlChannelInformation:
        VALIDATE_OUTPUT_BUFFER_FROM_MDL(
                pIrpSp,
                pMdlBuffer,
                HTTP_APP_POOL_CONTROL_CHANNEL);
        break;

    default:
        Status = STATUS_INVALID_PARAMETER;
        goto end;
        break;
    }

    OutputBufferLength = pIrpSp->Parameters.DeviceIoControl.OutputBufferLength;

    Status = UlSetAppPoolInformation(
                    pProcess,
                    pInfo->InformationClass,
                    pMdlBuffer,
                    OutputBufferLength
                    );

end:
    COMPLETE_REQUEST_AND_RETURN( pIrp, Status );

}   // UlSetAppPoolInformationIoctl


/***************************************************************************++

Routine Description:

    This routine stops request processing on the app pool and cancels
    outstanding I/O.

    Note: This is a METHOD_BUFFERED IOCTL.

Arguments:

    pIrp - Supplies a pointer to the IO request packet.

    pIrpSp - Supplies a pointer to the IO stack location to use for this
        request.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlShutdownAppPoolIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )
{
    NTSTATUS                Status = STATUS_SUCCESS;
    PUL_APP_POOL_PROCESS    pProcess;

    //
    // sanity check.
    //

    ASSERT_IOCTL_METHOD(BUFFERED, SHUTDOWN_APP_POOL);

    PAGED_CODE();

    VALIDATE_APP_POOL(pIrpSp, pProcess, FALSE);

    //
    // make the call
    //

    UlTrace(IOCTL,
            ("UlShutdownAppPoolIoctl: pAppPoolProcess=%p, pIrp=%p\n",
             pProcess,
             pIrp
             ));

    UlShutdownAppPoolProcess(
        pProcess
        );

    Status = STATUS_SUCCESS;

end:

    COMPLETE_REQUEST_AND_RETURN( pIrp, Status );

} // UlShutdownAppPoolIoctl


/***************************************************************************++

Routine Description:

    This routine receives an HTTP request.

    Note: This is a METHOD_OUT_DIRECT IOCTL.

Arguments:

    pIrp - Supplies a pointer to the IO request packet.

    pIrpSp - Supplies a pointer to the IO stack location to use for this
        request.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlReceiveHttpRequestIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )
{
    NTSTATUS                    Status;
    PHTTP_RECEIVE_REQUEST_INFO  pInfo;
    PUL_APP_POOL_PROCESS        pProcess = NULL;

    //
    // Sanity check.
    //

    ASSERT_IOCTL_METHOD(OUT_DIRECT, RECEIVE_HTTP_REQUEST);

    PAGED_CODE();

    VALIDATE_APP_POOL(pIrpSp, pProcess, TRUE);
    VALIDATE_INPUT_BUFFER(pIrp, pIrpSp, HTTP_RECEIVE_REQUEST_INFO, pInfo);
    VALIDATE_OUTPUT_BUFFER_ADDRESS_FROM_MDL(pIrp, PVOID);

    //
    // First make sure the output buffer is at least
    // minimum size.  This is important as we require
    // at least this much space later.
    //

    UlTrace(ROUTING, (
        "UlReceiveHttpRequestIoctl(outbuf=%d, inbuf=%d)\n",
        pIrpSp->Parameters.DeviceIoControl.OutputBufferLength,
        pIrpSp->Parameters.DeviceIoControl.InputBufferLength
        ));

    if ((pIrpSp->Parameters.DeviceIoControl.OutputBufferLength >=
            sizeof(HTTP_REQUEST)) &&
        (pIrpSp->Parameters.DeviceIoControl.InputBufferLength ==
            sizeof(HTTP_RECEIVE_REQUEST_INFO)))
    {
        if (pInfo->Flags & (~HTTP_RECEIVE_REQUEST_FLAG_VALID))
        {
            Status = STATUS_INVALID_PARAMETER;
            goto end;
        }

        Status = UlReceiveHttpRequest(
                        pInfo->RequestId,
                        pInfo->Flags,
                        pProcess,
                        pIrp
                        );
    }
    else
    {
        Status = STATUS_BUFFER_TOO_SMALL;
    }

    UlTrace(ROUTING, (
        "UlReceiveHttpRequestIoctl: BytesNeeded=%Iu, status=0x%x\n",
        pIrp->IoStatus.Information, Status
        ));

end:
    COMPLETE_REQUEST_AND_RETURN( pIrp, Status );

}   // UlReceiveHttpRequestIoctl


/***************************************************************************++

Routine Description:

    This routine receives entity body data from an HTTP request.

    Note: This is a METHOD_OUT_DIRECT IOCTL.

Arguments:

    pIrp - Supplies a pointer to the IO request packet.

    pIrpSp - Supplies a pointer to the IO stack location to use for this
        request.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlReceiveEntityBodyIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )
{
    NTSTATUS                    Status = STATUS_SUCCESS;
    PHTTP_RECEIVE_REQUEST_INFO  pInfo;
    PUL_APP_POOL_PROCESS        pProcess;
    PUL_INTERNAL_REQUEST        pRequest = NULL;

    //
    // Sanity check.
    //

    ASSERT_IOCTL_METHOD(OUT_DIRECT, RECEIVE_ENTITY_BODY);

    PAGED_CODE();

    VALIDATE_APP_POOL(pIrpSp, pProcess, TRUE);
    VALIDATE_INPUT_BUFFER(pIrp, pIrpSp, HTTP_RECEIVE_REQUEST_INFO, pInfo);

    //
    // Validate output buffer for METHOD_OUT_DIRECT.
    //

    if (NULL == pIrp->MdlAddress)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto end;
    }

    //
    // Now get the request from the request id.
    // This gets us a reference to the request.
    //

    pRequest = UlGetRequestFromId(pInfo->RequestId, pProcess);

    if (!pRequest)
    {
        Status = STATUS_CONNECTION_INVALID;
        goto end;
    }

    ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pRequest));

    //
    // OK, now call the function.
    //

    Status = UlReceiveEntityBody(pProcess, pRequest, pIrp);

end:
    if (pRequest != NULL)
    {
        UL_DEREFERENCE_INTERNAL_REQUEST(pRequest);
        pRequest = NULL;
    }

    COMPLETE_REQUEST_AND_RETURN( pIrp, Status );

}   // UlReceiveEntityBodyIoctl


/***************************************************************************++

Routine Description:

    This routine sends an HTTP response.

    Note: This is a METHOD_NEITHER IOCTL.

Arguments:

    pIrp - Supplies a pointer to the IO request packet.

    pIrpSp - Supplies a pointer to the IO stack location to use for this
        request.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlSendHttpResponseIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )
{
    NTSTATUS                        Status = STATUS_SUCCESS;
    PHTTP_SEND_HTTP_RESPONSE_INFO   pSendInfo;
    HTTP_SEND_HTTP_RESPONSE_INFO    LocalSendInfo;
    PUL_INTERNAL_RESPONSE           pResponse = NULL;
    PUL_INTERNAL_RESPONSE           pResponseCopy;
    PHTTP_RESPONSE                  pHttpResponse = NULL;
    PUL_INTERNAL_REQUEST            pRequest = NULL;
    BOOLEAN                         ServedFromCache = FALSE;
    BOOLEAN                         CaptureCache;
    PUL_APP_POOL_PROCESS            pAppPoolProcess = NULL;
    ULONG                           BufferLength = 0;
    BOOLEAN                         FastSend = FALSE;
    BOOLEAN                         CopySend = FALSE;
    BOOLEAN                         CloseConnection = FALSE;
    BOOLEAN                         LastResponse = FALSE;
    HTTP_REQUEST_ID                 RequestId = HTTP_NULL_ID;
    HTTP_DATA_CHUNK                 LocalEntityChunks[UL_LOCAL_CHUNKS];
    PHTTP_DATA_CHUNK                pLocalEntityChunks = NULL;
    PHTTP_DATA_CHUNK                pEntityChunks;
    HTTP_LOG_FIELDS_DATA            LocalLogData;
    USHORT                          StatusCode = 0;
    ULONGLONG                       SendBytes = 0;
    ULONGLONG                       ConnectionSendBytes = 0;
    ULONGLONG                       GlobalSendBytes = 0;

    //
    // Sanity check.
    //

    ASSERT_IOCTL_METHOD(NEITHER, SEND_HTTP_RESPONSE);

    PAGED_CODE();

    __try
    {
        //
        // Ensure that this is really an app pool, not a control channel.
        // And it's going until we are done with the sendresponse.
        //

        VALIDATE_APP_POOL(pIrpSp, pAppPoolProcess, TRUE);
        
        VALIDATE_SEND_INFO(
            pIrp,
            pIrpSp,
            pSendInfo,
            LocalSendInfo,
            pEntityChunks,
            pLocalEntityChunks,
            LocalEntityChunks
            );

        VALIDATE_LOG_DATA(pIrp, LocalSendInfo, LocalLogData);

        LastResponse = (BOOLEAN)
            (0 == (LocalSendInfo.Flags & HTTP_SEND_RESPONSE_FLAG_MORE_DATA));

        if (ETW_LOG_MIN() && LastResponse)
        {
            RequestId = LocalSendInfo.RequestId;

            UlEtwTraceEvent(
                &UlTransGuid,
                ETW_TYPE_ULRECV_RESP,
                (PVOID) &RequestId,
                sizeof(HTTP_REQUEST_ID),
                NULL,
                0
                );
        }

        UlTrace(SEND_RESPONSE, (
            "http!UlSendHttpResponseIoctl - Flags = %X\n",
            LocalSendInfo.Flags
            ));

        //
        // UlSendHttpResponse() *must* take a PHTTP_RESPONSE. This will
        // protect us from those whackos that attempt to build their own
        // raw response headers.
        //

        pHttpResponse = LocalSendInfo.pHttpResponse;

        if (pHttpResponse == NULL)
        {
            Status = STATUS_INVALID_PARAMETER;
            goto end;
        }

        //
        // Now get the request from the request id.
        // This gives us a reference to the request.
        //

        pRequest = UlGetRequestFromId(LocalSendInfo.RequestId, pAppPoolProcess);

        if (pRequest == NULL)
        {
            //
            // Couldn't map the HTTP_REQUEST_ID.
            //
            Status = STATUS_CONNECTION_INVALID;
            goto end;
        }

        ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pRequest));
        ASSERT(UL_IS_VALID_HTTP_CONNECTION(pRequest->pHttpConn));

        //
        // OK, we have the connection. Now capture the incoming
        // HTTP_RESPONSE structure and map it to our internal
        // format.
        //

        if (LocalSendInfo.CachePolicy.Policy != HttpCachePolicyNocache)
        {
            CaptureCache = pRequest->CachePreconditions;
        }
        else
        {
            CaptureCache = FALSE;
        }

        //
        // Check if we need to perform a CopySend if this IRP is
        // non-overlapped and this is not LastResponse.
        //

        if (g_UlEnableCopySend &&
            !LastResponse &&
            !pIrp->Overlay.AsynchronousParameters.UserApcRoutine &&
            !pIrp->Overlay.AsynchronousParameters.UserApcContext)
        {
            CopySend = TRUE;
        }

        //
        // Take the fast path if this is a single memory chunk that needs no
        // retransmission (<= 64k).
        //

        if (!CaptureCache && !pRequest->SendInProgress && !CopySend
            && LocalSendInfo.EntityChunkCount == 1
            && pEntityChunks->DataChunkType == HttpDataChunkFromMemory
            && pEntityChunks->FromMemory.BufferLength <= g_UlMaxBytesPerSend)
        {
            BufferLength = pEntityChunks->FromMemory.BufferLength;
            FastSend = (BOOLEAN) (BufferLength > 0);
        }

        if (!FastSend)
        {
            Status = UlCaptureHttpResponse(
                        pAppPoolProcess,
                        LocalSendInfo.pHttpResponse,
                        pRequest,
                        LocalSendInfo.EntityChunkCount,
                        pEntityChunks,
                        UlCaptureNothing,
                        LocalSendInfo.Flags,
                        CaptureCache,
                        LocalSendInfo.pLogData,
                        &StatusCode,
                        &pResponse
                        );

            if (!NT_SUCCESS(Status))
            {
                goto end;
            }
        }

        //
        // Apply ConnectionSendLimit and GlobalSendLimit. Only FromMemory
        // chunks are taken into account plus the overhead. Do this before
        // checking response flags because the check alters request's state.
        //

        if (FastSend)
        {
            SendBytes = BufferLength + g_UlFullTrackerSize;
        }
        else
        {
            ASSERT(UL_IS_VALID_INTERNAL_RESPONSE(pResponse));

            SendBytes = pResponse->FromMemoryLength +
                        g_UlResponseBufferSize +
                        g_UlChunkTrackerSize;
        }

        Status = UlCheckSendLimit(
                        pRequest->pHttpConn,
                        SendBytes,
                        &ConnectionSendBytes,
                        &GlobalSendBytes
                        );

        if (!NT_SUCCESS(Status))
        {
            goto end;
        }

        //
        // Check pRequest->SentResponse and pRequest->SentLast flags.
        //

        Status = UlCheckSendHttpResponseFlags(
                        pRequest,
                        LocalSendInfo.Flags
                        );

        if (!NT_SUCCESS(Status))
        {
            goto end;
        }

        //
        // If this is for a zombie connection and not the last sendresponse
        // then we will reject. Otherwise if the logging data is provided
        // we will only do the logging and bail out.
        //

        Status = UlCheckForZombieConnection(
                        pRequest,
                        pRequest->pHttpConn,
                        LocalSendInfo.Flags,
                        LocalSendInfo.pLogData,
                        pIrp->RequestorMode
                        );

        if (!NT_SUCCESS(Status))
        {
            goto end;
        }

        //
        // Capture the user log data if we have a response captured.
        //

        if (pResponse && LocalSendInfo.pLogData && pRequest->SentLast == 1)
        {        
            Status = UlCaptureUserLogData(
                        LocalSendInfo.pLogData,
                        pRequest,
                       &pResponse->pLogData
                        );

            if (!NT_SUCCESS(Status))
            {
                goto end;
            }
        }
    }
    __except( UL_EXCEPTION_FILTER() )
    {
        Status = UL_CONVERT_EXCEPTION_CODE(GetExceptionCode());
        goto end;
    }

    ASSERT(NT_SUCCESS(Status));

    if (FastSend)
    {
        Status = UlFastSendHttpResponse(
                    LocalSendInfo.pHttpResponse,
                    LocalSendInfo.pLogData,
                    pEntityChunks,
                    1,
                    BufferLength,
                    NULL,
                    LocalSendInfo.Flags,
                    pRequest,
                    pIrp,
                    pIrp->RequestorMode,
                    ConnectionSendBytes,
                    GlobalSendBytes,
                    NULL
                    );

        goto end;
    }

    //
    // At this point, we'll definitely be initiating the
    // send. Go ahead and mark the IRP as pending, then
    // guarantee that we'll only return pending from
    // this point on.
    //

    IoMarkIrpPending( pIrp );

    //
    // Remember ConnectionSendBytes and GlobalSendBytes. These are needed
    // to uncheck send limit when the IRP is completed.
    //

    ASSERT(UL_IS_VALID_INTERNAL_RESPONSE(pResponse));

    pResponse->ConnectionSendBytes = ConnectionSendBytes;
    pResponse->GlobalSendBytes = GlobalSendBytes;

    //
    // Set CopySend flag on the response.
    //

    pResponse->CopySend = CopySend;

    //
    // Save the captured response in the IRP so we can dereference it
    // after the IRP completes. The ownership of pResponse is transferred
    // to the IRP beyond this point so we zap pResponse to avoid
    // double-derefrence in the cleanup.
    //

    pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer = pResponse;
    pResponseCopy = pResponse;
    pResponse = NULL;

    //
    // Prepare the response (open files, etc).
    //

    Status = UlPrepareHttpResponse(
                    pRequest->Version,
                    pHttpResponse,
                    pResponseCopy,
                    UserMode
                    );

    if (NT_SUCCESS(Status))
    {
        //
        // Try capture to cache and send
        //

        if (CaptureCache)
        {
            Status = UlCacheAndSendResponse(
                            pRequest,
                            pResponseCopy,
                            pAppPoolProcess,
                            LocalSendInfo.CachePolicy,
                            &UlpRestartSendHttpResponse,
                            pIrp,
                            &ServedFromCache
                            );

            if (NT_SUCCESS(Status) && !ServedFromCache)
            {
                //
                // Send the non-cached response
                //

                Status = UlSendHttpResponse(
                                pRequest,
                                pResponseCopy,
                                &UlpRestartSendHttpResponse,
                                pIrp
                                );
            }
        }
        else
        {
            //
            // Non-cacheable request/response, send response directly.
            //

            Status = UlSendHttpResponse(
                            pRequest,
                            pResponseCopy,
                            &UlpRestartSendHttpResponse,
                            pIrp
                            );
        }
    }

    if (Status != STATUS_PENDING)
    {
        ASSERT(Status != STATUS_SUCCESS);

        //
        // UlSendHttpResponse either completed in-line
        // (extremely unlikely) or failed (much more
        // likely). Fake a completion to the completion
        // routine so that the IRP will get completed
        // properly, then map the return code to
        // STATUS_PENDING, since we've already marked
        // the IRP as such.
        //

        UlpRestartSendHttpResponse(
            pIrp,
            Status,
            0
            );

        CloseConnection = TRUE;

        Status = STATUS_PENDING;
    }

end:

    //
    // Free the local chunk array if we have allocated one.
    //

    if (pLocalEntityChunks)
    {
        UL_FREE_POOL(pLocalEntityChunks, UL_DATA_CHUNK_POOL_TAG);
    }

    //
    // Close the connection if we hit an error.
    //

    if (pRequest)
    {
        //
        // STATUS_OBJECT_PATH_NOT_FOUND means no cache chunk is found for the
        // response to send, in which case we should not close the connection
        // but rather let the user retry.
        //

        if ((NT_ERROR(Status) && STATUS_OBJECT_PATH_NOT_FOUND != Status) ||
            CloseConnection)
        {
            UlCloseConnection(
                pRequest->pHttpConn->pConnection,
                TRUE,
                NULL,
                NULL
                );
        }

        //
        // Uncheck either ConnectionSendBytes or GlobalSendBytes while we
        // still have a reference on the HttpConnection.
        //

        if (Status != STATUS_PENDING)
        {
            UlUncheckSendLimit(
                pRequest->pHttpConn,
                ConnectionSendBytes,
                GlobalSendBytes
                );
        }

        UL_DEREFERENCE_INTERNAL_REQUEST(pRequest);
    }

    if (pResponse)
    {
        ASSERT(UL_IS_VALID_INTERNAL_RESPONSE(pResponse));
        UL_DEREFERENCE_INTERNAL_RESPONSE(pResponse);
    }

    //
    // If the last response was an error case, log an error event here
    //

    if (ETW_LOG_MIN() && LastResponse && 
        (NT_ERROR(Status) && Status != STATUS_OBJECT_PATH_NOT_FOUND))
    {
        UlEtwTraceEvent(
            &UlTransGuid,
            ETW_TYPE_SEND_ERROR,
            (PVOID) &RequestId,
            sizeof(HTTP_REQUEST_ID),
            (PVOID) &StatusCode,
            sizeof(USHORT),
            NULL,
            0
            );
    }

    if (Status != STATUS_PENDING)
    {
        pIrp->IoStatus.Status = Status;
        UlCompleteRequest(pIrp, IO_NO_INCREMENT);
    }

    RETURN(Status);

}   // UlSendHttpResponseIoctl


/***************************************************************************++

Routine Description:

    This routine sends an HTTP entity body.

    Note: This is a METHOD_NEITHER IOCTL.

Arguments:

    pIrp - Supplies a pointer to the IO request packet.

    pIrpSp - Supplies a pointer to the IO stack location to use for this
        request.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlSendEntityBodyIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )
{
    NTSTATUS                        Status;
    PHTTP_SEND_HTTP_RESPONSE_INFO   pSendInfo;
    HTTP_SEND_HTTP_RESPONSE_INFO    LocalSendInfo;
    PUL_INTERNAL_RESPONSE           pResponse = NULL;
    PUL_INTERNAL_RESPONSE           pResponseCopy;
    PUL_INTERNAL_REQUEST            pRequest = NULL;
    PUL_APP_POOL_PROCESS            pAppPoolProcess = NULL;
    ULONG                           BufferLength = 0;
    BOOLEAN                         FastSend = FALSE;
    BOOLEAN                         CopySend = FALSE;
    BOOLEAN                         CloseConnection = FALSE;
    BOOLEAN                         LastResponse = FALSE;
    HTTP_REQUEST_ID                 RequestId = HTTP_NULL_ID;
    HTTP_DATA_CHUNK                 LocalEntityChunks[UL_LOCAL_CHUNKS];
    PHTTP_DATA_CHUNK                pLocalEntityChunks = NULL;
    PHTTP_DATA_CHUNK                pEntityChunks;
    HTTP_LOG_FIELDS_DATA            LocalLogData;
    USHORT                          StatusCode = 0;
    ULONGLONG                       SendBytes = 0;
    ULONGLONG                       ConnectionSendBytes = 0;
    ULONGLONG                       GlobalSendBytes = 0;

    //
    // Sanity check.
    //

    ASSERT_IOCTL_METHOD(NEITHER, SEND_ENTITY_BODY);

    PAGED_CODE();

    __try
    {
        VALIDATE_APP_POOL(pIrpSp, pAppPoolProcess, TRUE);
        
        VALIDATE_SEND_INFO(
            pIrp,
            pIrpSp,
            pSendInfo,
            LocalSendInfo,
            pEntityChunks,
            pLocalEntityChunks,
            LocalEntityChunks
            );

        VALIDATE_LOG_DATA(pIrp, LocalSendInfo, LocalLogData);

        LastResponse = (BOOLEAN)
            (0 == (LocalSendInfo.Flags & HTTP_SEND_RESPONSE_FLAG_MORE_DATA));

        if (ETW_LOG_MIN() && LastResponse)
        {
            RequestId = LocalSendInfo.RequestId;

            UlEtwTraceEvent(
                &UlTransGuid,
                ETW_TYPE_ULRECV_RESPBODY,
                (PVOID) &RequestId,
                sizeof(HTTP_REQUEST_ID),
                NULL,
                0
                );
        }

        UlTrace(SEND_RESPONSE, (
            "http!UlSendEntityBodyIoctl - Flags = %X\n",
            LocalSendInfo.Flags
            ));

        //
        // Now get the request from the request id.
        // This gives us a reference to the request.
        //

        pRequest = UlGetRequestFromId(LocalSendInfo.RequestId, pAppPoolProcess);

        if (pRequest == NULL)
        {
            //
            // Couldn't map the HTTP_REQUEST_ID.
            //
            Status = STATUS_CONNECTION_INVALID;
            goto end;
        }

        ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pRequest));
        ASSERT(UL_IS_VALID_HTTP_CONNECTION(pRequest->pHttpConn));

        //
        // Check if we need to perform a CopySend if this IRP is
        // non-overlapped and this is not LastResponse.
        //

        if (g_UlEnableCopySend &&
            !LastResponse &&
            !pIrp->Overlay.AsynchronousParameters.UserApcRoutine &&
            !pIrp->Overlay.AsynchronousParameters.UserApcContext)
        {
            CopySend = TRUE;
        }

        //
        // Take the fast path if this is a single memory chunk that needs no
        // retransmission (<= 64k).
        //

        if (!pRequest->SendInProgress && !CopySend
            && LocalSendInfo.EntityChunkCount == 1
            && pEntityChunks->DataChunkType == HttpDataChunkFromMemory
            && pEntityChunks->FromMemory.BufferLength <= g_UlMaxBytesPerSend)
        {
            BufferLength = pEntityChunks->FromMemory.BufferLength;
            FastSend = (BOOLEAN) (BufferLength > 0);
        }

        //
        // OK, we have the connection. Now capture the incoming
        // HTTP_RESPONSE structure and map it to our internal
        // format if this is not a FastSend.
        //

        if (!FastSend)
        {
            Status = UlCaptureHttpResponse(
                        pAppPoolProcess,
                        NULL,
                        pRequest,
                        LocalSendInfo.EntityChunkCount,
                        pEntityChunks,
                        UlCaptureNothing,
                        LocalSendInfo.Flags,
                        FALSE,
                        LocalSendInfo.pLogData,
                        &StatusCode,
                        &pResponse
                        );

            if (!NT_SUCCESS(Status))
            {
                goto end;
            }
        }

        //
        // Apply ConnectionSendLimit and GlobalSendLimit. Only FromMemory
        // chunks are taken into account plus the overhead. Do this before
        // checking response flags because the check alters request's state.
        //

        if (FastSend)
        {
            SendBytes = BufferLength + g_UlFullTrackerSize;
        }
        else
        {
            ASSERT(UL_IS_VALID_INTERNAL_RESPONSE(pResponse));

            SendBytes = pResponse->FromMemoryLength +
                        g_UlResponseBufferSize +
                        g_UlChunkTrackerSize;
        }

        Status = UlCheckSendLimit(
                        pRequest->pHttpConn,
                        SendBytes,
                        &ConnectionSendBytes,
                        &GlobalSendBytes
                        );

        if (!NT_SUCCESS(Status))
        {
            goto end;
        }

        //
        // Check pRequest->SentResponse and pRequest->SentLast flags.
        //

        Status = UlCheckSendEntityBodyFlags(
                        pRequest,
                        LocalSendInfo.Flags
                        );

        if (!NT_SUCCESS(Status))
        {
            goto end;
        }

        //
        // If this is for a zombie connection and not the last sendresponse
        // then we will reject. Otherwise if the logging data is provided
        // we will only do the logging and bail out.
        //

        Status = UlCheckForZombieConnection(
                        pRequest,
                        pRequest->pHttpConn,
                        LocalSendInfo.Flags,
                        LocalSendInfo.pLogData,
                        pIrp->RequestorMode
                        );

        if (!NT_SUCCESS(Status))
        {
            goto end;
        }

        //
        // Capture the user log data if we have a response captured.
        //

        if (pResponse && LocalSendInfo.pLogData && pRequest->SentLast == 1)
        {        
            Status = UlCaptureUserLogData(
                        LocalSendInfo.pLogData,
                        pRequest,
                       &pResponse->pLogData
                        );

            if (!NT_SUCCESS(Status))
            {
                goto end;
            }
        }
    }
    __except( UL_EXCEPTION_FILTER() )
    {
        Status = UL_CONVERT_EXCEPTION_CODE(GetExceptionCode());
        goto end;
    }

    ASSERT(NT_SUCCESS(Status));
    ASSERT(LocalSendInfo.pHttpResponse == NULL);

    if (FastSend)
    {
        Status = UlFastSendHttpResponse(
                    NULL,
                    LocalSendInfo.pLogData,
                    pEntityChunks,
                    1,
                    BufferLength,
                    NULL,
                    LocalSendInfo.Flags,
                    pRequest,
                    pIrp,
                    pIrp->RequestorMode,
                    ConnectionSendBytes,
                    GlobalSendBytes,
                    NULL
                    );

        goto end;
    }

    //
    // At this point, we'll definitely be initiating the
    // send. Go ahead and mark the IRP as pending, then
    // guarantee that we'll only return pending from
    // this point on.
    //

    IoMarkIrpPending( pIrp );

    // Remember ConnectionSendBytes and GlobalSendBytes. These are needed
    // to uncheck send limit when the IRP is completed.
    //

    ASSERT(UL_IS_VALID_INTERNAL_RESPONSE(pResponse));

    pResponse->ConnectionSendBytes = ConnectionSendBytes;
    pResponse->GlobalSendBytes = GlobalSendBytes;

    //
    // Set CopySend flag on the response.
    //

    pResponse->CopySend = CopySend;

    //
    // Save the captured response in the IRP so we can dereference it
    // after the IRP completes. The ownership of pResponse is transferred
    // to the IRP beyond this point so we zap pResponse to avoid
    // double-derefrence in the cleanup.
    //

    pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer = pResponse;
    pResponseCopy = pResponse;
    pResponse = NULL;

    //
    // Prepare the response (open files, etc).
    //

    Status = UlPrepareHttpResponse(
                    pRequest->Version,
                    NULL,
                    pResponseCopy,
                    UserMode
                    );

    if (NT_SUCCESS(Status))
    {
        //
        // Send the response
        //

        Status = UlSendHttpResponse(
                        pRequest,
                        pResponseCopy,
                        &UlpRestartSendHttpResponse,
                        pIrp
                        );
    }

    if (Status != STATUS_PENDING)
    {
        ASSERT(Status != STATUS_SUCCESS);

        //
        // UlSendHttpResponse either completed in-line
        // (extremely unlikely) or failed (much more
        // likely). Fake a completion to the completion
        // routine so that the IRP will get completed
        // properly, then map the return code to
        // STATUS_PENDING, since we've already marked
        // the IRP as such.
        //

        UlpRestartSendHttpResponse(
            pIrp,
            Status,
            0
            );

        CloseConnection = TRUE;

        Status = STATUS_PENDING;
    }

end:

    //
    // Free the local chunk array if we have allocated one.
    //

    if (pLocalEntityChunks)
    {
        UL_FREE_POOL(pLocalEntityChunks, UL_DATA_CHUNK_POOL_TAG);
    }

    //
    // Close the connection if we hit an error.
    //

    if (pRequest)
    {
        //
        // STATUS_OBJECT_PATH_NOT_FOUND means no cache chunk is found for the
        // response to send, in which case we should not close the connection
        // but rather let the user retry.
        //

        if ((NT_ERROR(Status) && STATUS_OBJECT_PATH_NOT_FOUND != Status) ||
            CloseConnection)
        {
            UlCloseConnection(
                pRequest->pHttpConn->pConnection,
                TRUE,
                NULL,
                NULL
                );
        }

        //
        // Uncheck either ConnectionSendBytes or GlobalSendBytes while we
        // still have a reference on the HttpConnection.
        //

        if (Status != STATUS_PENDING)
        {
            UlUncheckSendLimit(
                pRequest->pHttpConn,
                ConnectionSendBytes,
                GlobalSendBytes
                );
        }

        UL_DEREFERENCE_INTERNAL_REQUEST(pRequest);
    }

    if (pResponse)
    {
        ASSERT(UL_IS_VALID_INTERNAL_RESPONSE(pResponse));
        UL_DEREFERENCE_INTERNAL_RESPONSE(pResponse);
    }

    //
    // If the last response was an error case, log an error event here
    //
    if (ETW_LOG_MIN() && LastResponse &&
        (NT_ERROR(Status) && Status != STATUS_OBJECT_PATH_NOT_FOUND))
    {
        UlEtwTraceEvent(
            &UlTransGuid,
            ETW_TYPE_SEND_ERROR,
            (PVOID) &RequestId,
            sizeof(HTTP_REQUEST_ID),
            (PVOID) &StatusCode,
            sizeof(USHORT),
            NULL,
            0
            );
    }

    if (Status != STATUS_PENDING)
    {
        pIrp->IoStatus.Status = Status;
        UlCompleteRequest(pIrp, IO_NO_INCREMENT);
    }

    RETURN(Status);

}   // UlSendEntityBodyIoctl


/***************************************************************************++

Routine Description:

    This routine flushes a URL or URL tree from the response cache.

    Note: This is a METHOD_BUFFERED IOCTL.

Arguments:

    pIrp - Supplies a pointer to the IO request packet.

    pIrpSp - Supplies a pointer to the IO stack location to use for this
        request.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlFlushResponseCacheIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )
{
    NTSTATUS                        Status = STATUS_SUCCESS;
    PHTTP_FLUSH_RESPONSE_CACHE_INFO pInfo = NULL;
    PUL_APP_POOL_PROCESS            pProcess;
    UNICODE_STRING                  FullyQualifiedUrl;

    //
    // sanity check.
    //

    ASSERT_IOCTL_METHOD(BUFFERED, FLUSH_RESPONSE_CACHE);

    PAGED_CODE();

    RtlInitEmptyUnicodeString(&FullyQualifiedUrl, NULL, 0);
        
    VALIDATE_APP_POOL(pIrpSp, pProcess, TRUE);

    VALIDATE_INPUT_BUFFER(pIrp, pIrpSp,
                        HTTP_FLUSH_RESPONSE_CACHE_INFO, pInfo);

    //
    // Check the flag.
    //
    
    if (pInfo->Flags != (pInfo->Flags & HTTP_FLUSH_RESPONSE_FLAG_VALID))
    {
        Status = STATUS_INVALID_PARAMETER;
        goto end;
    }

    Status = 
        UlProbeAndCaptureUnicodeString(
            &pInfo->FullyQualifiedUrl,
            pIrp->RequestorMode,
            &FullyQualifiedUrl,
            UNICODE_STRING_MAX_WCHAR_LEN
            );

    if (NT_SUCCESS(Status))
    {
        UlFlushCacheByUri(
            FullyQualifiedUrl.Buffer,
            FullyQualifiedUrl.Length,
            pInfo->Flags,
            pProcess
            );
    }
    
end:

    UlFreeCapturedUnicodeString(&FullyQualifiedUrl);
        
    COMPLETE_REQUEST_AND_RETURN( pIrp, Status );

}   // UlFlushResponseCacheIoctl


/***************************************************************************++

Routine Description:

    This routine waits for demand start notifications.

    Note: This is a METHOD_BUFFERED IOCTL.

Arguments:

    pIrp - Supplies a pointer to the IO request packet.

    pIrpSp - Supplies a pointer to the IO stack location to use for this
        request.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlWaitForDemandStartIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )
{
    NTSTATUS                Status = STATUS_SUCCESS;
    PUL_APP_POOL_PROCESS    pProcess;

    //
    // sanity check.
    //

    ASSERT_IOCTL_METHOD(BUFFERED, WAIT_FOR_DEMAND_START);

    PAGED_CODE();

    VALIDATE_APP_POOL(pIrpSp, pProcess, FALSE);

    //
    // make the call
    //

    UlTrace(IOCTL,
            ("UlWaitForDemandStartIoctl: pAppPoolProcess=%p, pIrp=%p\n",
             pProcess,
             pIrp
             ));

    Status = UlWaitForDemandStart(pProcess, pIrp);

end:
    COMPLETE_REQUEST_AND_RETURN( pIrp, Status );

}   // UlWaitForDemandStartIoctl


/***************************************************************************++

Routine Description:

    This routine waits for the client to initiate a disconnect.

    Note: This is a METHOD_BUFFERED IOCTL.

Arguments:

    pIrp - Supplies a pointer to the IO request packet.

    pIrpSp - Supplies a pointer to the IO stack location to use for this
        request.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlWaitForDisconnectIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )
{
    NTSTATUS                        Status;
    PHTTP_WAIT_FOR_DISCONNECT_INFO  pInfo;
    PUL_HTTP_CONNECTION             pHttpConn = NULL;
    PUL_APP_POOL_PROCESS            pProcess;

    //
    // Sanity check.
    //

    ASSERT_IOCTL_METHOD(BUFFERED, WAIT_FOR_DISCONNECT);

    PAGED_CODE();

    VALIDATE_APP_POOL(pIrpSp, pProcess, TRUE);

    VALIDATE_INPUT_BUFFER(pIrp, pIrpSp,
                          HTTP_WAIT_FOR_DISCONNECT_INFO, pInfo);

    //
    // Chase down the connection.
    //

    pHttpConn = UlGetConnectionFromId( pInfo->ConnectionId );

    if (!pHttpConn)
    {
        Status = STATUS_CONNECTION_INVALID;
        goto end;
    }

    ASSERT(UL_IS_VALID_HTTP_CONNECTION(pHttpConn));

    //
    // Do it.
    //

    Status = UlWaitForDisconnect(pProcess, pHttpConn, pIrp);

end:
    if (pHttpConn)
    {
        UL_DEREFERENCE_HTTP_CONNECTION(pHttpConn);
    }

    COMPLETE_REQUEST_AND_RETURN( pIrp, Status );

}   // UlWaitForDisconnectIoctl


//
// Private functions.
//

/***************************************************************************++

Routine Description:

    Completion routine for UlSendHttpResponse().

Arguments:

    pCompletionContext - Supplies an uninterpreted context value
        as passed to the asynchronous API. In this case, it's
        actually a pointer to the user's IRP.

    Status - Supplies the final completion status of the
        asynchronous API.

    Information - Optionally supplies additional information about
        the completed operation, such as the number of bytes
        transferred.

--***************************************************************************/
VOID
UlpRestartSendHttpResponse(
    IN PVOID pCompletionContext,
    IN NTSTATUS Status,
    IN ULONG_PTR Information
    )
{
    PIRP pIrp;
    PIO_STACK_LOCATION pIrpSp;
    PUL_INTERNAL_RESPONSE pResponse;

    //
    // Snag the IRP from the completion context, fill in the completion
    // status, then complete the IRP.
    //

    pIrp = (PIRP)pCompletionContext;
    pIrpSp = IoGetCurrentIrpStackLocation( pIrp );

    pResponse = (PUL_INTERNAL_RESPONSE)(
                    pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer
                    );

    ASSERT( UL_IS_VALID_INTERNAL_RESPONSE( pResponse ) );

    //
    // Set pResponse->pIrp and pResponse->IoStatus so we can complete the
    // IRP when the reference of the response drops to 0.
    //

    pResponse->pIrp = pIrp;
    pResponse->IoStatus.Status = Status;
    pResponse->IoStatus.Information = Information;

    //
    // Drop the initial/last reference of the response.
    //

    UL_DEREFERENCE_INTERNAL_RESPONSE( pResponse );

}   // UlpRestartSendHttpResponse


/***************************************************************************++

Routine Description:

    This routine stops request processing on the filter channel and cancels
    outstanding I/O.

    Note: This is a METHOD_BUFFERED IOCTL.

Arguments:

    pIrp - Supplies a pointer to the IO request packet.

    pIrpSp - Supplies a pointer to the IO stack location to use for this
        request.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlShutdownFilterIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )
{
    NTSTATUS                Status = STATUS_SUCCESS;
    PUL_FILTER_PROCESS      pProcess;

    //
    // sanity check.
    //

    ASSERT_IOCTL_METHOD(BUFFERED, SHUTDOWN_FILTER_CHANNEL);

    PAGED_CODE();

    VALIDATE_FILTER_PROCESS(pIrpSp, pProcess);

    //
    // make the call
    //

    UlTrace(IOCTL,
            ("UlShutdownFilterIoctl: pFilterProcess=%p, pIrp=%p\n",
             pProcess,
             pIrp
             ));

    UlShutdownFilterProcess(
        pProcess
        );

    Status = STATUS_SUCCESS;

end:

    COMPLETE_REQUEST_AND_RETURN( pIrp, Status );

}


/***************************************************************************++

Routine Description:

    This routine accepts a raw connection.

    Note: This is a METHOD_OUT_DIRECT IOCTL.

Arguments:

    pIrp - Supplies a pointer to the IO request packet.

    pIrpSp - Supplies a pointer to the IO stack location to use for this
        request.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlFilterAcceptIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )
{
    NTSTATUS            Status;
    PUL_FILTER_PROCESS  pFilterProcess;

    //
    // Sanity check.
    //

    ASSERT_IOCTL_METHOD(OUT_DIRECT, FILTER_ACCEPT);

    PAGED_CODE();

    VALIDATE_FILTER_PROCESS(pIrpSp, pFilterProcess);
    VALIDATE_OUTPUT_BUFFER_SIZE(pIrpSp, HTTP_RAW_CONNECTION_INFO);
    VALIDATE_OUTPUT_BUFFER_ADDRESS_FROM_MDL(pIrp, HTTP_RAW_CONNECTION_INFO);

    //
    // make the call
    //

    Status = UlFilterAccept(pFilterProcess, pIrp);

end:
    COMPLETE_REQUEST_AND_RETURN( pIrp, Status );

}   // UlFilterAcceptIoctl


/***************************************************************************++

Routine Description:

    This routine closes a raw connection.

    Note: This is a METHOD_BUFFERED IOCTL.

Arguments:

    pIrp - Supplies a pointer to the IO request packet.

    pIrpSp - Supplies a pointer to the IO stack location to use for this
        request.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlFilterCloseIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )
{
    NTSTATUS                Status;
    PHTTP_RAW_CONNECTION_ID pConnectionId;
    PUX_FILTER_CONNECTION   pConnection = NULL;
    PUL_FILTER_PROCESS      pFilterProcess;

    //
    // Sanity check.
    //

    ASSERT_IOCTL_METHOD(BUFFERED, FILTER_CLOSE);

    PAGED_CODE();

    VALIDATE_FILTER_PROCESS(pIrpSp, pFilterProcess);

    VALIDATE_INPUT_BUFFER(pIrp, pIrpSp, HTTP_RAW_CONNECTION_ID,
                          pConnectionId);

    pConnection = UlGetRawConnectionFromId(*pConnectionId);

    if (!pConnection)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto end;
    }


    ASSERT(IS_VALID_FILTER_CONNECTION(pConnection));

    //
    // make the call
    //

    Status = UlFilterClose(pFilterProcess, pConnection, pIrp);

end:

    if (pConnection)
    {
        DEREFERENCE_FILTER_CONNECTION(pConnection);
    }

    COMPLETE_REQUEST_AND_RETURN( pIrp, Status );

}   // UlFilterCloseIoctl


/***************************************************************************++

Routine Description:

    This routine reads data from a raw connection.

    Note: This is a METHOD_OUT_DIRECT IOCTL.

Arguments:

    pIrp - Supplies a pointer to the IO request packet.

    pIrpSp - Supplies a pointer to the IO stack location to use for this
        request.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlFilterRawReadIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )
{
    NTSTATUS                Status;
    PHTTP_RAW_CONNECTION_ID pConnectionId;
    PUX_FILTER_CONNECTION   pConnection = NULL;
    PUL_FILTER_PROCESS      pFilterProcess;

    //
    // Sanity check.
    //

    ASSERT_IOCTL_METHOD(OUT_DIRECT, FILTER_RAW_READ);

    PAGED_CODE();

    VALIDATE_FILTER_PROCESS(pIrpSp, pFilterProcess);
    VALIDATE_OUTPUT_BUFFER_SIZE(pIrpSp, UCHAR);
    VALIDATE_OUTPUT_BUFFER_ADDRESS_FROM_MDL(pIrp, UCHAR);

    //
    // Immediately fork to the appropriate code if we're doing a combined
    // read and write.
    //
    if (pIrpSp->Parameters.DeviceIoControl.InputBufferLength ==
        sizeof(HTTP_FILTER_BUFFER_PLUS))
    {
        return UlFilterAppWriteAndRawRead(pIrp, pIrpSp);
    }

    __try
    {
        //
        // Get the connection ID.
        //
        VALIDATE_INPUT_BUFFER(pIrp, pIrpSp, HTTP_RAW_CONNECTION_ID,
                              pConnectionId);

        pConnection = UlGetRawConnectionFromId(*pConnectionId);

        if (!pConnection)
        {
            Status = STATUS_INVALID_PARAMETER;
            goto end;
        }


        ASSERT(IS_VALID_FILTER_CONNECTION(pConnection));

        Status = UlFilterRawRead(pFilterProcess, pConnection, pIrp);

    }
    __except( UL_EXCEPTION_FILTER() )
    {
        Status = UL_CONVERT_EXCEPTION_CODE(GetExceptionCode());
        UlTrace( FILTER, (
            "UlFilterRawReadIoctl: Exception hit! 0x%08X\n",
            Status
            ));
    }

end:
    if (pConnection)
    {
        DEREFERENCE_FILTER_CONNECTION(pConnection);
    }

    COMPLETE_REQUEST_AND_RETURN( pIrp, Status );

}   // UlFilterRawReadIoctl

/***************************************************************************++

Routine Description:

    This routine writes data to a raw connection.

    Note: This is a METHOD_IN_DIRECT IOCTL.

Arguments:

    pIrp - Supplies a pointer to the IO request packet.

    pIrpSp - Supplies a pointer to the IO stack location to use for this
        request.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlFilterRawWriteIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )
{
    NTSTATUS                Status;
    PHTTP_RAW_CONNECTION_ID pConnectionId;
    PUX_FILTER_CONNECTION   pConnection = NULL;
    PUL_FILTER_PROCESS      pFilterProcess;
    BOOLEAN                 MarkedPending = FALSE;

    //
    // Sanity check.
    //

    ASSERT_IOCTL_METHOD(IN_DIRECT, FILTER_RAW_WRITE);

    PAGED_CODE();

    __try
    {
        VALIDATE_FILTER_PROCESS(pIrpSp, pFilterProcess);

        VALIDATE_INPUT_BUFFER(pIrp, pIrpSp, HTTP_RAW_CONNECTION_ID,
                              pConnectionId);

        if (!pIrp->MdlAddress)
        {
            Status = STATUS_INVALID_PARAMETER;
            goto end;
        }

        pConnection = UlGetRawConnectionFromId(*pConnectionId);

        if (!pConnection)
        {
            Status = STATUS_INVALID_PARAMETER;
            goto end;
        }

        ASSERT(IS_VALID_FILTER_CONNECTION(pConnection));

        //
        // make the call
        //
        IoMarkIrpPending(pIrp);
        MarkedPending = TRUE;

        Status = UlFilterRawWrite(
                        pFilterProcess,
                        pConnection,
                        pIrpSp->Parameters.DeviceIoControl.OutputBufferLength,
                        pIrp
                        );
    }
    __except( UL_EXCEPTION_FILTER() )
    {
        Status = UL_CONVERT_EXCEPTION_CODE(GetExceptionCode());
        UlTrace( FILTER, (
            "UlFilterRawWriteIoctl: Exception hit! 0x%08X\n",
            Status
            ));

    }

end:
    if (pConnection)
    {
        DEREFERENCE_FILTER_CONNECTION(pConnection);
    }

    //
    // complete the request?
    //
    if (Status != STATUS_PENDING)
    {
        pIrp->IoStatus.Status = Status;
        UlCompleteRequest( pIrp, IO_NO_INCREMENT );

        if (MarkedPending)
        {
            //
            // Since we marked the IRP pending, we should return pending.
            //
            Status = STATUS_PENDING;
        }

    }
    else
    {
        //
        // If we're returning pending, the IRP better be marked pending.
        //
        ASSERT(MarkedPending);
    }

    RETURN( Status );

}   // UlFilterRawWriteIoctl


/***************************************************************************++

Routine Description:

    This routine reads data from an http application.

    Note: This is a METHOD_OUT_DIRECT IOCTL.

Arguments:

    pIrp - Supplies a pointer to the IO request packet.

    pIrpSp - Supplies a pointer to the IO stack location to use for this
        request.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlFilterAppReadIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )
{
    NTSTATUS                Status;
    PUX_FILTER_CONNECTION   pConnection = NULL;
    PHTTP_FILTER_BUFFER     pFiltBuffer;
    PUL_FILTER_PROCESS      pFilterProcess;

    //
    // Sanity check.
    //

    ASSERT_IOCTL_METHOD(OUT_DIRECT, FILTER_APP_READ);

    PAGED_CODE();

    //
    // Immediately fork to the appropriate code if we're doing a combined
    // read and write.
    //
    if (pIrpSp->Parameters.DeviceIoControl.InputBufferLength ==
        sizeof(HTTP_FILTER_BUFFER_PLUS))
    {
        return UlFilterRawWriteAndAppRead(pIrp, pIrpSp);
    }

    __try
    {

        VALIDATE_FILTER_PROCESS(pIrpSp, pFilterProcess);

        VALIDATE_INPUT_BUFFER(pIrp, pIrpSp, HTTP_FILTER_BUFFER, pFiltBuffer);

        VALIDATE_OUTPUT_BUFFER_SIZE(pIrpSp, HTTP_FILTER_BUFFER);
        VALIDATE_OUTPUT_BUFFER_ADDRESS_FROM_MDL(pIrp, HTTP_FILTER_BUFFER);

        //
        // Map the incoming connection ID to the corresponding
        // UX_FILTER_CONNECTION object.
        //

        pConnection = UlGetRawConnectionFromId(pFiltBuffer->Reserved);

        if (!pConnection)
        {
            Status = STATUS_INVALID_PARAMETER;
            goto end;
        }

        ASSERT(IS_VALID_FILTER_CONNECTION(pConnection));

        Status = UlFilterAppRead(pFilterProcess, pConnection, pIrp);

    }
    __except( UL_EXCEPTION_FILTER() )
    {
        Status = UL_CONVERT_EXCEPTION_CODE(GetExceptionCode());
        UlTrace( FILTER, (
            "UlFilterAppReadIoctl: Exception hit! 0x%08X\n",
            Status
            ));

    }

end:
    if (pConnection)
    {
        DEREFERENCE_FILTER_CONNECTION(pConnection);
    }

    COMPLETE_REQUEST_AND_RETURN( pIrp, Status );

}   // UlFilterAppReadIoctl



/***************************************************************************++

Routine Description:

    This routine writes data to an http application.

    Note: This is a METHOD_IN_DIRECT IOCTL.

Arguments:

    pIrp - Supplies a pointer to the IO request packet.

    pIrpSp - Supplies a pointer to the IO stack location to use for this
        request.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlFilterAppWriteIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )
{
    NTSTATUS                Status;
    PUX_FILTER_CONNECTION   pConnection = NULL;
    BOOLEAN                 MarkedPending = FALSE;
    PHTTP_FILTER_BUFFER     pFiltBuffer;
    PUL_FILTER_PROCESS      pFilterProcess;

    //
    // Sanity check.
    //

    ASSERT_IOCTL_METHOD(IN_DIRECT, FILTER_APP_WRITE);

    PAGED_CODE();

    __try
    {
        VALIDATE_FILTER_PROCESS(pIrpSp, pFilterProcess);
        VALIDATE_INPUT_BUFFER(pIrp, pIrpSp, HTTP_FILTER_BUFFER, pFiltBuffer);

        //
        // Map the incoming connection ID to the corresponding
        // UX_FILTER_CONNECTION object.
        //

        pConnection = UlGetRawConnectionFromId(pFiltBuffer->Reserved);

        if (!pConnection)
        {
            Status = STATUS_INVALID_PARAMETER;
            goto end;
        }


        ASSERT(IS_VALID_FILTER_CONNECTION(pConnection));

        //
        // make the call
        //
        IoMarkIrpPending(pIrp);
        MarkedPending = TRUE;

        Status = UlFilterAppWrite(pFilterProcess, pConnection, pIrp);
    }
    __except( UL_EXCEPTION_FILTER() )
    {
        Status = UL_CONVERT_EXCEPTION_CODE(GetExceptionCode());
        UlTrace( FILTER, (
            "UlFilterAppWriteIoctl: Exception hit! 0x%08X\n",
            Status
            ));

    }

end:
    if (pConnection)
    {
        DEREFERENCE_FILTER_CONNECTION(pConnection);
    }

    //
    // complete the request?
    //
    if (Status != STATUS_PENDING)
    {
        pIrp->IoStatus.Status = Status;
        UlCompleteRequest( pIrp, IO_NO_INCREMENT );

        if (MarkedPending)
        {
            //
            // Since we marked the IRP pending, we should return pending.
            //
            Status = STATUS_PENDING;
        }

    }
    else
    {
        //
        // If we're returning pending, the IRP better be marked pending.
        //
        ASSERT(MarkedPending);
    }

    RETURN( Status );

}   // UlFilterAppWriteIoctl


/***************************************************************************++

Routine Description:

    This routine asks the SSL helper for a client certificate.

    Note: This is a METHOD_OUT_DIRECT IOCTL.

Arguments:

    pIrp - Supplies a pointer to the IO request packet.

    pIrpSp - Supplies a pointer to the IO stack location to use for this
        request.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlReceiveClientCertIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )
{
    NTSTATUS                                Status;
    PHTTP_FILTER_RECEIVE_CLIENT_CERT_INFO   pReceiveCertInfo;
    PUL_HTTP_CONNECTION                     pHttpConn = NULL;
    PUL_APP_POOL_PROCESS                    pProcess;

    //
    // Sanity check.
    //

    ASSERT_IOCTL_METHOD(OUT_DIRECT, FILTER_RECEIVE_CLIENT_CERT);

    PAGED_CODE();

    __try
    {
        VALIDATE_APP_POOL(pIrpSp, pProcess, TRUE);

        VALIDATE_INPUT_BUFFER(pIrp, pIrpSp,
                              HTTP_FILTER_RECEIVE_CLIENT_CERT_INFO,
                              pReceiveCertInfo);

        VALIDATE_OUTPUT_BUFFER_SIZE(pIrpSp, HTTP_SSL_CLIENT_CERT_INFO);
        VALIDATE_OUTPUT_BUFFER_ADDRESS_FROM_MDL(pIrp, PVOID);

        //
        // Map the incoming connection ID to the corresponding
        // HTTP_CONNECTION object.
        //

        pHttpConn = UlGetConnectionFromId(pReceiveCertInfo->ConnectionId);

        if (!pHttpConn)
        {
            Status = STATUS_CONNECTION_INVALID;
            goto end;
        }

        ASSERT(UL_IS_VALID_HTTP_CONNECTION(pHttpConn));

        //
        // make the call
        //

        Status = UlReceiveClientCert(
                        pProcess,
                        &pHttpConn->pConnection->FilterInfo,
                        pReceiveCertInfo->Flags,
                        pIrp
                        );
    }
    __except( UL_EXCEPTION_FILTER() )
    {
        Status = UL_CONVERT_EXCEPTION_CODE(GetExceptionCode());
    }

end:
    if (pHttpConn)
    {
        UL_DEREFERENCE_HTTP_CONNECTION(pHttpConn);
    }

    COMPLETE_REQUEST_AND_RETURN( pIrp, Status );

}   // UlFilterReceiveClientCertIoctl


/***************************************************************************++

Routine Description:

    This routine returns the perfmon counter data for this driver

    Note: This is a METHOD_OUT_DIRECT IOCTL.

Arguments:

    pIrp - Supplies a pointer to the IO request packet.

    pIrpSp - Supplies a pointer to the IO stack location to use for this
        request.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlGetCountersIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )
{
    NTSTATUS                Status = STATUS_SUCCESS;
    PUL_CONTROL_CHANNEL     pControlChannel;
    PVOID                   pMdlBuffer = NULL;
    PHTTP_COUNTER_GROUP     pCounterGroup = NULL;
    ULONG                   Blocks;
    ULONG                   Length = 
                    pIrpSp->Parameters.DeviceIoControl.OutputBufferLength;
    //
    // Sanity check.
    //

    ASSERT_IOCTL_METHOD(OUT_DIRECT, GET_COUNTERS);

    PAGED_CODE();

    //
    // If not returning STATUS_SUCCESS,
    // IoStatus.Information *must* be 0.
    //

    pIrp->IoStatus.Information = 0;

    //
    // Validate Parameters
    //

    VALIDATE_CONTROL_CHANNEL(pIrpSp, pControlChannel);

    VALIDATE_INPUT_BUFFER(pIrp, pIrpSp, HTTP_COUNTER_GROUP, pCounterGroup);

    // Crack IRP and get MDL containing user's buffer
    // Crack MDL to get user's buffer

    // if no outbut buffer pass down in the Irp
    // that means app is asking for the required
    // field length

    if ( NULL != pIrp->MdlAddress )
    {
        GET_OUTPUT_BUFFER_ADDRESS_FROM_MDL(pIrp, pMdlBuffer);
    }

    //
    // Call support function to gather appropriate counter blocks
    // and place in user's buffer.
    //

    if (HttpCounterGroupGlobal == *pCounterGroup)
    {
        VALIDATE_BUFFER_ALIGNMENT(pMdlBuffer, HTTP_GLOBAL_COUNTERS);

        Status = UlGetGlobalCounters(
                    pMdlBuffer,
                    Length,
                    &Length
                    );
    }
    else
    if (HttpCounterGroupSite == *pCounterGroup)
    {
        VALIDATE_BUFFER_ALIGNMENT(pMdlBuffer, HTTP_SITE_COUNTERS);

        Status = UlGetSiteCounters(
                    pControlChannel,
                    pMdlBuffer,
                    Length,
                    &Length,
                    &Blocks
                    );
    }
    else
    {
        Status = STATUS_NOT_IMPLEMENTED;
    }

    if ( NT_SUCCESS(Status) || NT_INFORMATION(Status) )
    {
        pIrp->IoStatus.Information = (ULONG_PTR)Length;
    }

 end:

    COMPLETE_REQUEST_AND_RETURN( pIrp, Status );

} // UlGetCountersIoctl


/***************************************************************************++

Routine Description:

    This routine adds a fragment cache entry.

    Note: This is a METHOD_BUFFERED IOCTL.

Arguments:

    pIrp - Supplies a pointer to the IO request packet.

    pIrpSp - Supplies a pointer to the IO stack location to use for this
        request.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlAddFragmentToCacheIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )
{
    NTSTATUS                    Status;
    PHTTP_ADD_FRAGMENT_INFO     pInfo = NULL;
    PUL_APP_POOL_PROCESS        pProcess;

    //
    // Sanity check.
    //

    ASSERT_IOCTL_METHOD(BUFFERED, ADD_FRAGMENT_TO_CACHE);

    PAGED_CODE();

    VALIDATE_APP_POOL(pIrpSp, pProcess, TRUE);

    VALIDATE_INPUT_BUFFER(pIrp, pIrpSp, HTTP_ADD_FRAGMENT_INFO, pInfo);

    //
    // Add a new fragment cache entry.
    //

    Status = UlAddFragmentToCache(
                pProcess,
                &pInfo->FragmentName,
                &pInfo->DataChunk,
                &pInfo->CachePolicy,
                pIrp->RequestorMode
                );

end:

    COMPLETE_REQUEST_AND_RETURN( pIrp, Status );

} // UlAddFragmentToCacheIoctl


/***************************************************************************++

Routine Description:

    This routine reads the data back from the fragment cache entry.

    Note: This is a METHOD_OUT_DIRECT IOCTL.

Arguments:

    pIrp - Supplies a pointer to the IO request packet.

    pIrpSp - Supplies a pointer to the IO stack location to use for this
        request.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlReadFragmentFromCacheIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )
{
    NTSTATUS                    Status = STATUS_SUCCESS;
    PUL_APP_POOL_PROCESS        pProcess;
    ULONG                       BytesRead = 0;

    //
    // Sanity check.
    //

    ASSERT_IOCTL_METHOD(NEITHER, READ_FRAGMENT_FROM_CACHE);

    PAGED_CODE();

    //
    // Initialize total bytes read.
    //

    pIrp->IoStatus.Information = 0;

    VALIDATE_APP_POOL(pIrpSp, pProcess, TRUE);

    Status = UlReadFragmentFromCache(
                pProcess,
                pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                pIrpSp->Parameters.DeviceIoControl.InputBufferLength,
                pIrp->UserBuffer,
                pIrpSp->Parameters.DeviceIoControl.OutputBufferLength,
                pIrp->RequestorMode,
                &BytesRead
                );

    pIrp->IoStatus.Information = BytesRead;

end:

    COMPLETE_REQUEST_AND_RETURN( pIrp, Status );

} // UlReadFragmentFromCacheIoctl


/***************************************************************************++

Routine Description:

    This routine sends Entity body on a request.

Arguments:

    pIrp - Supplies a pointer to the IO request packet.

    pIrpSp - Supplies a pointer to the IO stack location to use for this
        request.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UcSendEntityBodyIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )
{
    NTSTATUS                              Status;
    PHTTP_SEND_REQUEST_ENTITY_BODY_INFO   pSendInfo;
    PUC_HTTP_REQUEST                      pRequest  = 0;
    PUC_HTTP_SEND_ENTITY_BODY             pKeEntity = 0;
    KIRQL                                 OldIrql;
    BOOLEAN                               bDontFail = FALSE;
    BOOLEAN                               bLast;

    //
    // Sanity check.
    //

    ASSERT_IOCTL_METHOD(IN_DIRECT, SEND_REQUEST_ENTITY_BODY);

    PAGED_CODE();

    do
    {
        //
        // Ensure this is really an app pool, not a control channel.
        //

        if (IS_SERVER(pIrpSp->FileObject) == FALSE)
        {
            //
            // Not an server
            //
            Status = STATUS_INVALID_HANDLE;

            UC_WRITE_TRACE_LOG(
                g_pUcTraceLog,
                UC_ACTION_ENTITY_NEW,
                NULL,
                NULL,
                NULL,
                UlongToPtr(Status)
                );

            break;
        }

        //
        // Ensure the input buffer is large enough.
        //

        if (pIrpSp->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(*pSendInfo))
        {
            //
            // Input buffer too small.
            //

            Status = STATUS_BUFFER_TOO_SMALL;

            UC_WRITE_TRACE_LOG(
                g_pUcTraceLog,
                UC_ACTION_ENTITY_NEW,
                NULL,
                NULL,
                NULL,
                UlongToPtr(Status)
                );

            break;
        }

        pSendInfo =
        (PHTTP_SEND_REQUEST_ENTITY_BODY_INFO)pIrp->AssociatedIrp.SystemBuffer;

        //
        // Now get the request from the request id.
        // This gives us a reference to the request.
        // 
        // NOTE: We don't have to worry about the RequestID being changed, 
        // since it's not a pointer.
        //

        pRequest = (PUC_HTTP_REQUEST)
                    UlGetObjectFromOpaqueId(pSendInfo->RequestID,
                                            UlOpaqueIdTypeHttpRequest,
                                            UcReferenceRequest);

        if (UC_IS_VALID_HTTP_REQUEST(pRequest) == FALSE)
        {
            //
            // Couldn't map the UL_HTTP_REQUEST_ID.
            //

            Status = STATUS_INVALID_PARAMETER;

            UC_WRITE_TRACE_LOG(
                g_pUcTraceLog,
                UC_ACTION_ENTITY_NEW,
                pRequest,
                NULL,
                NULL,
                UlongToPtr(Status)
                );

            break;
        }

        if(pRequest->pFileObject != pIrpSp->FileObject)
        {
            //
            // Cant allow the app to use someone else's RequestID
            //

            Status = STATUS_INVALID_PARAMETER;

            UC_WRITE_TRACE_LOG(
                g_pUcTraceLog,
                UC_ACTION_ENTITY_NEW,
                pRequest,
                NULL,
                NULL,
                UlongToPtr(Status)
                );

            break;
        }

        if(pSendInfo->Flags & (~HTTP_SEND_REQUEST_FLAG_VALID))
        {
            Status = STATUS_INVALID_PARAMETER;

            UC_WRITE_TRACE_LOG(
                g_pUcTraceLog,
                UC_ACTION_ENTITY_NEW,
                pRequest,
                NULL,
                NULL,
                UlongToPtr(Status)
                );

            break;
        }


        bLast = FALSE;

        if(!(pSendInfo->Flags & HTTP_SEND_REQUEST_FLAG_MORE_DATA))
        {
            //
            // Remember that this was the last send. We shouldn't
            // get any more data after this.
            //
            bLast = TRUE;

        }

        ExAcquireFastMutex(&pRequest->Mutex);

        Status = UcCaptureEntityBody(
                        pSendInfo,
                        pIrp,
                        pRequest,
                        &pKeEntity,
                        bLast
                        );

        ExReleaseFastMutex(&pRequest->Mutex);

        if(!NT_SUCCESS(Status))
        {
            //
            // NOTE: If the SendEntity IRP fails for some reason or the other,
            // we will be failing the entire request.  This simplifies the code
            // somewhat (For e.g. When we get a entity, we record some state
            // in UC_HTTP_REQUEST. If we were not failing the entire request,
            // we would have to unwind the state if an entity failed). It's a
            // lot simpler to just fail the entire request and get the app to
            // post another one.
            //

            UC_WRITE_TRACE_LOG(
                g_pUcTraceLog,
                UC_ACTION_ENTITY_NEW,
                NULL,
                NULL,
                NULL,
                UlongToPtr(Status)
                );


            break;
        }

        pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer = pKeEntity;

        UC_WRITE_TRACE_LOG(
            g_pUcTraceLog,
            UC_ACTION_ENTITY_NEW,
            pRequest,
            pKeEntity,
            pIrp,
            UlongToPtr(Status)
            );

        Status = UcSendEntityBody(pRequest,
                                  pKeEntity,
                                  pIrp,
                                  pIrpSp,
                                  &bDontFail,
                                  bLast
                                  );

    } while(FALSE);

    if(Status == STATUS_SUCCESS)
    {
        pIrp->IoStatus.Status = Status;
        UlCompleteRequest(pIrp, IO_NO_INCREMENT);
    }
    else if(Status != STATUS_PENDING)
    {
        if(pKeEntity)
        {
            ASSERT(pRequest);

            UcFreeSendMdls(pKeEntity->pMdlHead);

            UL_FREE_POOL_WITH_QUOTA(
                pKeEntity,
                UC_ENTITY_POOL_TAG,
                NonPagedPool,
                pKeEntity->BytesAllocated,
                pRequest->pServerInfo->pProcess
                );
        }

        if(pRequest)
        {

            if(!bDontFail)
            {
                UlAcquireSpinLock(&pRequest->pConnection->SpinLock, &OldIrql);

                UcFailRequest(pRequest, Status, OldIrql);
            }

            //
            // Deref for the ref that we took above.
            //

            UC_DEREFERENCE_REQUEST(pRequest);
        }

        pIrp->IoStatus.Status = Status;

        UlCompleteRequest(pIrp, IO_NO_INCREMENT);
    }

    return Status;
} // UcSendEntityBodyIoctl 



/***************************************************************************++

Routine Description:

    This routine receives a HTTP response

Arguments:

    pIrp - Supplies a pointer to the IO request packet.

    pIrpSp - Supplies a pointer to the IO stack location to use for this
        request.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UcReceiveResponseIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )
{
    PHTTP_RECEIVE_RESPONSE_INFO pInfo = NULL;
    NTSTATUS                    Status = STATUS_SUCCESS;
    PUC_HTTP_REQUEST            pRequest = NULL;
    ULONG                       BytesTaken = 0;

    ASSERT_IOCTL_METHOD(OUT_DIRECT, RECEIVE_RESPONSE);

    do
    {
        if(!IS_SERVER(pIrpSp->FileObject))
        {
            Status = STATUS_INVALID_HANDLE;

            UC_WRITE_TRACE_LOG(
                g_pUcTraceLog,
                UC_ACTION_NEW_RESPONSE,
                NULL,
                NULL,
                NULL,
                UlongToPtr(Status)
                );

                break;
        }

        //
        // Grab the input buffer
        //

        pInfo = (PHTTP_RECEIVE_RESPONSE_INFO) pIrp->AssociatedIrp.SystemBuffer;

        //
        // See if the input buffer is large enough.
        //

        if(
            (pIrpSp->Parameters.DeviceIoControl.OutputBufferLength <
             sizeof(HTTP_RESPONSE)) ||
            (pIrpSp->Parameters.DeviceIoControl.InputBufferLength !=
            sizeof(*pInfo))
          )
        {
            Status = STATUS_BUFFER_TOO_SMALL;

            UC_WRITE_TRACE_LOG(
                g_pUcTraceLog,
                UC_ACTION_NEW_RESPONSE,
                NULL,
                NULL,
                NULL,
                UlongToPtr(Status)
                );

            break;
        }

        //
        // NOTE: We don't have to worry about the RequestID being changed, 
        // since it's not a pointer.
        //

        if(HTTP_IS_NULL_ID(&pInfo->RequestID) ||
           pInfo->Flags != 0)
        {
            Status = STATUS_INVALID_PARAMETER;

            UC_WRITE_TRACE_LOG(
                g_pUcTraceLog,
                UC_ACTION_NEW_RESPONSE,
                NULL,
                NULL,
                NULL,
                UlongToPtr(Status)
                );

            break;
        }

        pRequest = (PUC_HTTP_REQUEST) UlGetObjectFromOpaqueId(
                                            pInfo->RequestID,
                                            UlOpaqueIdTypeHttpRequest,
                                            UcReferenceRequest
                                      );

        if (UC_IS_VALID_HTTP_REQUEST(pRequest) == FALSE)
        {
            Status = STATUS_INVALID_PARAMETER;

            UC_WRITE_TRACE_LOG(
                g_pUcTraceLog,
                UC_ACTION_NEW_RESPONSE,
                NULL,
                NULL,
                NULL,
                UlongToPtr(Status)
                );

            break;
        }

        if(pRequest->pFileObject != pIrpSp->FileObject)
        {
            //
            // Cant allow the app to use someone else's RequestID
            //

            Status = STATUS_INVALID_PARAMETER;

            UC_WRITE_TRACE_LOG(
                g_pUcTraceLog,
                UC_ACTION_NEW_RESPONSE,
                NULL,
                NULL,
                NULL,
                UlongToPtr(Status)
                );


            break;
        }

        BytesTaken = 0;
        Status = UcReceiveHttpResponse(
                    pRequest,
                    pIrp,
                    &BytesTaken
                 );

        UC_WRITE_TRACE_LOG(
            g_pUcTraceLog,
            UC_ACTION_NEW_RESPONSE,
            NULL,
            pRequest,
            pIrp,
            UlongToPtr(Status)
            );


    } while(FALSE);

    if(Status == STATUS_SUCCESS)
    {
        pIrp->IoStatus.Status      = Status;
        pIrp->IoStatus.Information = (ULONG_PTR) BytesTaken;
        UlCompleteRequest(pIrp, IO_NO_INCREMENT);

    }
    else if(Status != STATUS_PENDING)
    {
        if(pRequest)
        {
            UC_DEREFERENCE_REQUEST(pRequest);
        }

        pIrp->IoStatus.Status      = Status;
        pIrp->IoStatus.Information = (ULONG_PTR) BytesTaken;

        //
        // If we are not completing the IRP with STATUS_SUCCESS, the IO 
        // manager eats the pIrp->IoStatus.Information. But, the user wants
        // to see this information (e.g. when we complete the IRP with 
        // STATUS_BUFFER_OVERFLOW, we want to tell the app how much to write.
        //
        // So, we convey this information using the app's pointer. Note that 
        // this can be done only if we are completing the IRP synchronously.
        //

        __try 
        {
            // This is METHOD_OUT_DIRECT, so the input buffer comes from
            // the IO manager. So, we don't have to worry about the app
            // changing pInfo->pBytesTaken after we've probed it.
            //
            // We still have to probe & access it in a try except block,
            // since this is a user mode pointer.
    
            if(pInfo && pInfo->pBytesTaken)
            {
                UlProbeForWrite(
                    pInfo->pBytesTaken,
                    sizeof(ULONG),
                    sizeof(ULONG),
                    pIrp->RequestorMode
                    );

                *pInfo->pBytesTaken = BytesTaken;
            }
        } __except( UL_EXCEPTION_FILTER())
        {
        }

        UlCompleteRequest(pIrp, IO_NO_INCREMENT);
    }

    return Status;
} // UcReceiveResponseIoctl



/***************************************************************************++

Routine Description:

    This routine sets per server configuration information

Arguments:

    pIrp - Supplies a pointer to the IO request packet.

    pIrpSp - Supplies a pointer to the IO stack location to use for this
        request.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UcSetServerContextInformationIoctl(
    IN PIRP               pIrp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    NTSTATUS                         Status = STATUS_SUCCESS;
    PUC_PROCESS_SERVER_INFORMATION   pServerInfo;
    PHTTP_SERVER_CONTEXT_INFORMATION pInfo;

    ASSERT_IOCTL_METHOD(IN_DIRECT, SET_SERVER_CONTEXT_INFORMATION);

    do 
    {
        if(!IS_SERVER(IrpSp->FileObject))
        {
            Status = STATUS_INVALID_HANDLE;
            break;
        }

        //
        // Pull out the connection information from the Irp, make sure it is
        // valid.
        //

        pServerInfo = (PUC_PROCESS_SERVER_INFORMATION)
                            IrpSp->FileObject->FsContext;

        ASSERT( IS_VALID_SERVER_INFORMATION(pServerInfo) );

        //
        // See if the input buffer is large enough.
        //

        if( IrpSp->Parameters.DeviceIoControl.InputBufferLength <
            sizeof(*pInfo))
        {
            Status = STATUS_BUFFER_TOO_SMALL;
            break;
        }

        pInfo = (PHTTP_SERVER_CONTEXT_INFORMATION)
                    pIrp->AssociatedIrp.SystemBuffer;

        Status = UcSetServerContextInformation(
                        pServerInfo,
                        pInfo->ConfigID,
                        pInfo->pInputBuffer,
                        pInfo->InputBufferLength,
                        pIrp
                        );

    } while(FALSE);

    ASSERT(STATUS_PENDING != Status);

    pIrp->IoStatus.Status = Status;

    UlCompleteRequest(pIrp, IO_NO_INCREMENT);

    return Status;
} // UcSetServerContextInformationIoctl 



/***************************************************************************++

Routine Description:

    This routine queries per server configuration information

Arguments:

    pIrp - Supplies a pointer to the IO request packet.

    pIrpSp - Supplies a pointer to the IO stack location to use for this
        request.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UcQueryServerContextInformationIoctl(
    IN PIRP               pIrp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    NTSTATUS                         Status = STATUS_SUCCESS;
    PUC_PROCESS_SERVER_INFORMATION   pServerInfo;
    PHTTP_SERVER_CONTEXT_INFORMATION pInfo = NULL;
    PVOID                            pAppBase, pMdlBuffer;
    ULONG                            Length = 0;

    ASSERT_IOCTL_METHOD(OUT_DIRECT, QUERY_SERVER_CONTEXT_INFORMATION);

    do 
    {
        if(!IS_SERVER(IrpSp->FileObject))
        {
            Status = STATUS_INVALID_HANDLE;
            break;
        }

        //
        // Pull out the connection information from the Irp, make sure it is
        // valid.
        //

        pServerInfo = (PUC_PROCESS_SERVER_INFORMATION)
                            IrpSp->FileObject->FsContext;

        ASSERT( IS_VALID_SERVER_INFORMATION(pServerInfo) );

        //
        // See if the input buffer is large enough.
        //

        if( IrpSp->Parameters.DeviceIoControl.InputBufferLength <
            sizeof(*pInfo))
        {
            Status = STATUS_BUFFER_TOO_SMALL;
            break;
        }

        //
        // Ensure that the output buffer looks good.
        //
        if(!pIrp->MdlAddress)
        {
            Status = STATUS_INVALID_PARAMETER;
            break;
        }

        pInfo = (PHTTP_SERVER_CONTEXT_INFORMATION)
                    pIrp->AssociatedIrp.SystemBuffer;

        pMdlBuffer = MmGetSystemAddressForMdlSafe(
                        pIrp->MdlAddress,
                        LowPagePriority
                        );

        if (pMdlBuffer == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        //
        // Make sure that the output buffer is ULONG aligned.
        //

        if(pMdlBuffer != ALIGN_UP_POINTER(pMdlBuffer, ULONG))
        {   
            Status = STATUS_DATATYPE_MISALIGNMENT_ERROR;
            break;
        }

        pAppBase = (PSTR) MmGetMdlVirtualAddress(pIrp->MdlAddress);

        Length = 0;

        Status = UcQueryServerContextInformation(
                        pServerInfo,
                        pInfo->ConfigID,
                        pMdlBuffer,
                        IrpSp->Parameters.DeviceIoControl.OutputBufferLength,
                        &Length,
                        pAppBase
                        );

    } while(FALSE);

    ASSERT(STATUS_PENDING != Status);

    if(Status != STATUS_SUCCESS)
    {
        //
        // If we are not completing the IRP with STATUS_SUCCESS, the IO 
        // manager eats the pIrp->IoStatus.Information. But, the user wants
        // to see this information (e.g. when we complete the IRP with 
        // STATUS_BUFFER_OVERFLOW, we want to tell the app how much to write.
        //
        // So, we convey this information using the app's pointer. Note that 
        // this can be done only if we are completing the IRP synchronously.
        //

        __try 
        {
            // This is METHOD_OUT_DIRECT, so the input buffer comes from
            // the IO manager. So, we don't have to worry about the app
            // changing pInfo->pBytesTaken after we've probed it.
            //
            // We still have to probe & access it in a try except block,
            // since this is a user mode pointer.
    
            if(pInfo && pInfo->pBytesTaken)
            {
                UlProbeForWrite(
                    pInfo->pBytesTaken,
                    sizeof(ULONG),
                    sizeof(ULONG),
                    pIrp->RequestorMode
                    );

                *pInfo->pBytesTaken = Length;
            }
        } __except( UL_EXCEPTION_FILTER())
        {
        }
    }

    pIrp->IoStatus.Status      = Status;
    pIrp->IoStatus.Information = (ULONG_PTR) Length;

    UlCompleteRequest(pIrp, IO_NO_INCREMENT);

    return Status;
} // UcQueryServerContextInformationIoctl 



/***************************************************************************++

Routine Description:

    This routine sends a HTTP request

Arguments:

    pIrp - Supplies a pointer to the IO request packet.

    pIrpSp - Supplies a pointer to the IO stack location to use for this
        request.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UcSendRequestIoctl(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    NTSTATUS                       Status = STATUS_SUCCESS;
    PHTTP_SEND_REQUEST_INPUT_INFO  pHttpSendRequest = NULL;
    PUC_HTTP_REQUEST               pHttpInternalRequest = 0;
    PUC_PROCESS_SERVER_INFORMATION pServerInfo;
    ULONG                          BytesTaken = 0;

    ASSERT_IOCTL_METHOD(OUT_DIRECT, SEND_REQUEST);

    do 
    {
        if(!IS_SERVER(IrpSp->FileObject))
        {
            Status = STATUS_INVALID_HANDLE;

            UC_WRITE_TRACE_LOG(
                g_pUcTraceLog,
                UC_ACTION_REQUEST_NEW,
                NULL,
                NULL,
                pIrp,
                UlongToPtr(Status)
                );

                break;
        }

        //
        // Pull out the connection information from the Irp, make sure it is
        // valid.
        //
        // IrpSp->FileObject->FsContext;
        //

        pServerInfo = (PUC_PROCESS_SERVER_INFORMATION)
                            IrpSp->FileObject->FsContext;

        ASSERT( IS_VALID_SERVER_INFORMATION(pServerInfo) );

        //
        // See if the input buffer is large enough.
        //

        if( IrpSp->Parameters.DeviceIoControl.InputBufferLength <
            sizeof(*pHttpSendRequest))
        {
            Status = STATUS_BUFFER_TOO_SMALL;
            UC_WRITE_TRACE_LOG(
                g_pUcTraceLog,
                UC_ACTION_REQUEST_NEW,
                NULL,
                NULL,
                pIrp,
                UlongToPtr(Status)
                );

            break;
        }

        pHttpSendRequest = (PHTTP_SEND_REQUEST_INPUT_INFO)
            pIrp->AssociatedIrp.SystemBuffer;

        if(NULL == pHttpSendRequest->pHttpRequest)
        {
            Status = STATUS_INVALID_PARAMETER;

            UC_WRITE_TRACE_LOG(
                g_pUcTraceLog,
                UC_ACTION_REQUEST_NEW,
                NULL,
                NULL,
                pIrp,
                UlongToPtr(Status)
                );

            break;
        }


        //
        // Make sure that the SEND_REQUEST_FLAGS are valid.
        //

        if(pHttpSendRequest->HttpRequestFlags & (~HTTP_SEND_REQUEST_FLAG_VALID))
        {
            Status = STATUS_INVALID_PARAMETER;

            UC_WRITE_TRACE_LOG(
                g_pUcTraceLog,
                UC_ACTION_REQUEST_NEW,
                NULL,
                NULL,
                pIrp,
                UlongToPtr(Status)
                );

            break;
        }

        BytesTaken = 0;

        Status = UcCaptureHttpRequest(pServerInfo,
                                      pHttpSendRequest,
                                      pIrp,
                                      IrpSp,
                                      &pHttpInternalRequest,
                                      &BytesTaken
                                      );


        if(!NT_SUCCESS(Status))
        {
            UC_WRITE_TRACE_LOG(
                g_pUcTraceLog,
                UC_ACTION_REQUEST_NEW,
                NULL,
                NULL,
                pIrp,
                UlongToPtr(Status)
                );

            break;
        }

        //
        // Save the captured request in the IRP.
        //
        IrpSp->Parameters.DeviceIoControl.Type3InputBuffer =
                pHttpInternalRequest;

        UC_WRITE_TRACE_LOG(
            g_pUcTraceLog,
            UC_ACTION_REQUEST_NEW,
            NULL,
            pHttpInternalRequest,
            pIrp,
            UlongToPtr(Status)
            );

        //
        // We have to pin the request down to a connection regardless of
        // whether we are going to send it or not. We need to do this to
        // maintain the order in which the user passes requests to the driver.
        //

        Status = UcSendRequest(pServerInfo, pHttpInternalRequest);


    } while(FALSE);

    if (Status == STATUS_SUCCESS)
    {
        ASSERT(pHttpInternalRequest);

        pIrp->IoStatus.Status = Status;

        // For the IRP.
        UC_DEREFERENCE_REQUEST(pHttpInternalRequest);

        UlCompleteRequest(pIrp, IO_NO_INCREMENT);
    }
    else if (Status != STATUS_PENDING)
    {
        if(pHttpInternalRequest)
        {
            // For the IRP.
            UC_DEREFERENCE_REQUEST(pHttpInternalRequest);

            UcFreeSendMdls(pHttpInternalRequest->pMdlHead);

            //
            // We don't need the Request ID
            //

            if(!HTTP_IS_NULL_ID(&pHttpInternalRequest->RequestId))
            {
                UlFreeOpaqueId(
                        pHttpInternalRequest->RequestId,
                        UlOpaqueIdTypeHttpRequest
                        );

                HTTP_SET_NULL_ID(&pHttpInternalRequest->RequestId);

                UC_DEREFERENCE_REQUEST(pHttpInternalRequest);
            }

            UC_DEREFERENCE_REQUEST(pHttpInternalRequest);
        }

        pIrp->IoStatus.Status      = Status;
        pIrp->IoStatus.Information = (ULONG_PTR) BytesTaken;

        //
        // If we are not completing the IRP with STATUS_SUCCESS, the IO 
        // manager eats the pIrp->IoStatus.Information. But, the user wants
        // to see this information (e.g. when we complete the IRP with 
        // STATUS_BUFFER_OVERFLOW, we want to tell the app how much to write.
        //
        // So, we convey this information using the app's pointer. Note that 
        // this can be done only if we are completing the IRP synchronously.
        //
        __try 
        {
            // This is METHOD_OUT_DIRECT, so the input buffer comes from
            // the IO manager. So, we don't have to worry about the app
            // changing pHttpSendRequest->pBytesTaken after we've probed it.
            //
            // We still have to probe & access it in a try except block,
            // since this is a user mode pointer.
    
            if(pHttpSendRequest && pHttpSendRequest->pBytesTaken)
            {
                UlProbeForWrite(
                    pHttpSendRequest->pBytesTaken,
                    sizeof(ULONG),
                    sizeof(ULONG),
                    pIrp->RequestorMode
                    );

                *pHttpSendRequest->pBytesTaken = BytesTaken;
            }
        } __except( UL_EXCEPTION_FILTER())
        {
        }

        UlCompleteRequest(pIrp, IO_NO_INCREMENT);
    }

    return Status;
} // UcSendRequestIoctl 



/***************************************************************************++

Routine Description:

    This routine cancels a HTTP request

Arguments:

    pIrp - Supplies a pointer to the IO request packet.

    pIrpSp - Supplies a pointer to the IO stack location to use for this
        request.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UcCancelRequestIoctl(
    IN PIRP               pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )
{
    NTSTATUS                       Status = STATUS_SUCCESS;
    PHTTP_RECEIVE_RESPONSE_INFO    pInfo;
    PUC_HTTP_REQUEST               pRequest = NULL;
    PUC_PROCESS_SERVER_INFORMATION pServerInfo;
    KIRQL                          OldIrql;

    ASSERT_IOCTL_METHOD(BUFFERED, CANCEL_REQUEST);

    do 
    {
        if(!IS_SERVER(pIrpSp->FileObject))
        {
            Status = STATUS_INVALID_HANDLE;

            UC_WRITE_TRACE_LOG(
                g_pUcTraceLog,
                UC_ACTION_REQUEST_CANCELLED,
                NULL,
                NULL,
                pIrp,
                UlongToPtr(Status)
                );

                break;
        }

        //
        // Pull out the connection information from the Irp, make sure it is
        // valid.
        //
        // IrpSp->FileObject->FsContext;
        //

        pServerInfo = (PUC_PROCESS_SERVER_INFORMATION)
                            pIrpSp->FileObject->FsContext;

        ASSERT( IS_VALID_SERVER_INFORMATION(pServerInfo) );

        //
        // Grab the input buffer
        //

        pInfo = (PHTTP_RECEIVE_RESPONSE_INFO) pIrp->AssociatedIrp.SystemBuffer;

        //
        // See if the input buffer is large enough.
        //

        if(
            (pIrpSp->Parameters.DeviceIoControl.InputBufferLength !=
            sizeof(*pInfo))
          )
        {
            Status = STATUS_BUFFER_TOO_SMALL;

            UC_WRITE_TRACE_LOG(
                g_pUcTraceLog,
                UC_ACTION_REQUEST_CANCELLED,
                NULL,
                NULL,
                NULL,
                UlongToPtr(Status)
                );

            break;
        }

        if(HTTP_IS_NULL_ID(&pInfo->RequestID) ||
           pInfo->Flags != 0)
        {
            Status = STATUS_INVALID_PARAMETER;

            UC_WRITE_TRACE_LOG(
                g_pUcTraceLog,
                UC_ACTION_REQUEST_CANCELLED,
                NULL,
                NULL,
                NULL,
                UlongToPtr(Status)
                );

            break;
        }

        pRequest = (PUC_HTTP_REQUEST) UlGetObjectFromOpaqueId(
                                            pInfo->RequestID,
                                            UlOpaqueIdTypeHttpRequest,
                                            UcReferenceRequest
                                      );

        if (UC_IS_VALID_HTTP_REQUEST(pRequest) == FALSE)
        {
            Status = STATUS_INVALID_PARAMETER;

            UC_WRITE_TRACE_LOG(
                g_pUcTraceLog,
                UC_ACTION_REQUEST_CANCELLED,
                NULL,
                NULL,
                NULL,
                UlongToPtr(Status)
                );

            break;
        }

        if(pRequest->pFileObject != pIrpSp->FileObject)
        {
            //
            // Cant allow the app to use someone else's RequestID
            //

            Status = STATUS_INVALID_PARAMETER;

            UC_WRITE_TRACE_LOG(
                g_pUcTraceLog,
                UC_ACTION_ENTITY_NEW,
                pRequest,
                NULL,
                NULL,
                UlongToPtr(Status)
                );

            break;
        }


        UlAcquireSpinLock(&pRequest->pConnection->SpinLock, &OldIrql);

        UcFailRequest(pRequest, STATUS_CANCELLED, OldIrql);

        Status = STATUS_SUCCESS;

    } while(FALSE);

    if (Status == STATUS_SUCCESS)
    {
        UC_DEREFERENCE_REQUEST(pRequest);

        pIrp->IoStatus.Status = Status;

        UlCompleteRequest(pIrp, IO_NO_INCREMENT);
    }
    else
    {
        ASSERT(Status != STATUS_PENDING);

        if(pRequest)
        {
            UC_DEREFERENCE_REQUEST(pRequest);
        }

        pIrp->IoStatus.Status = Status;

        UlCompleteRequest(pIrp, IO_NO_INCREMENT);
    }

    return Status;
} // UcCancelRequestIoctl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\init.c ===
/*++

Copyright (c) 1998-2002 Microsoft Corporation

Module Name:

    init.c

Abstract:

    This module performs initialization for the UL device driver.

Author:

    Keith Moore (keithmo)       10-Jun-1998

Revision History:

--*/


#include "precomp.h"


PDRIVER_OBJECT  g_UlDriverObject = NULL;

//
// Private constants.
//

#define DEFAULT_THREAD_AFFINITY_MASK ((1ui64 << KeNumberProcessors) - 1)



//
// Private types.
//


//
// Private prototypes.
//


NTSTATUS
UlpApplySecurityToDeviceObjects(
    VOID
    );

NTSTATUS
UlpSetDeviceObjectSecurity(
    IN PDEVICE_OBJECT pDeviceObject,
    IN SECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
    );

ULONG
UlpReadUrlC14nConfig(
    HANDLE parametersHandle
    );

VOID
UlpReadErrorLogConfig(
    HANDLE parametersHandle
    );

VOID
UlpReadRegistry (
    IN PUL_CONFIG pConfig
    );

VOID
UlpTerminateModules(
    VOID
    );

VOID
UlpUnload (
    IN PDRIVER_OBJECT DriverObject
    );


//
// Private globals.
//

#if DBG
ULONG g_UlpForceInitFailure = 0;
#endif  // DBG


#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, DriverEntry )
#pragma alloc_text( INIT, UlpApplySecurityToDeviceObjects )
#pragma alloc_text( INIT, UlpSetDeviceObjectSecurity )
#pragma alloc_text( INIT, UlpReadUrlC14nConfig )
#pragma alloc_text( INIT, UlpReadRegistry )
#pragma alloc_text( INIT, UlpReadErrorLogConfig )
#pragma alloc_text( PAGE, UlpUnload )
#pragma alloc_text( PAGE, UlpTerminateModules )

//
// Note that UlpTerminateModules() must be "page" if driver unloading
// is enabled (it's called from UlpUnload), but can be "init" otherwise
// (it's only called after initialization failure).
//
#pragma alloc_text( PAGE, UlpTerminateModules )
#endif  // ALLOC_PRAGMA


//
// Public functions.
//

/***************************************************************************++

Routine Description:

    This is the initialization routine for the UL device driver.

Arguments:

    DriverObject - Supplies a pointer to driver object created by the
        system.

    RegistryPath - Supplies the name of the driver's configuration
        registry tree.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
{
    NTSTATUS                    status;
    UNICODE_STRING              deviceName;
    OBJECT_ATTRIBUTES           objectAttributes;
    UL_CONFIG                   config;
    SYSTEM_BASIC_INFORMATION    sbi;

    UNREFERENCED_PARAMETER(RegistryPath);

    //
    // Sanity check.
    //

    PAGED_CODE();

    g_UlDriverObject = DriverObject;

    //
    // Grab the number of processors in the system.
    //

    g_UlNumberOfProcessors = KeNumberProcessors;
    g_UlThreadAffinityMask = DEFAULT_THREAD_AFFINITY_MASK;

    //
    // Grab the largest cache line size in the system
    //

    g_UlCacheLineSize = KeGetRecommendedSharedDataAlignment();

    for (g_UlCacheLineBits = 0;
         (1U << g_UlCacheLineBits) < g_UlCacheLineSize;
         ++g_UlCacheLineBits)
    {}

    ASSERT(g_UlCacheLineSize <= (1U << g_UlCacheLineBits));

    status = NtQuerySystemInformation(
                    SystemBasicInformation,
                    &sbi,
                    sizeof(sbi),
                    NULL);
    ASSERT(NT_SUCCESS(status));

    //
    // Capture total physical memory, in terms of megabytes.
    //

    g_UlTotalPhysicalMemMB = PAGES_TO_MEGABYTES(sbi.NumberOfPhysicalPages);

    //
    // Estimate the total number of NPP available in bytes since Landy
    // doesn't want to export MmSizeOfNonPagedPoolInBytes.
    //
    // CODEWORK: Whenever we have a mechanism for discovering the
    // NonPagedPool size, use that instead of the total physical
    // RAM on the system.
    //

#if defined(_WIN64)
    //
    // On IA64, assume NPP can be 50% of total physical memory.
    //

    g_UlTotalNonPagedPoolBytes = MEGABYTES_TO_BYTES(g_UlTotalPhysicalMemMB/2);
#else
    //
    // On X86, assume NPP is either 50% of total physical memory or 256MB,
    // whichever is less.
    //

    g_UlTotalNonPagedPoolBytes = MEGABYTES_TO_BYTES(
                                    MIN(256, g_UlTotalPhysicalMemMB/2)
                                    );
#endif

    //
    // Snag a pointer to the system process.
    //

    g_pUlSystemProcess = (PKPROCESS)IoGetCurrentProcess();

    //
    // Temporarily initialize the IS_HTTP_*() macros.
    // Will be initialized properly by InitializeHttpUtil() later.
    //

    HttpCmnInitializeHttpCharsTable(FALSE);

    //
    // Read registry information.
    //

    UlpReadRegistry( &config );

#if DBG
    //
    // Give anyone using the kernel debugger a chance to abort
    // initialization.
    //

    if (g_UlpForceInitFailure != 0)
    {
        status = STATUS_UNSUCCESSFUL;
        goto fatal;
    }
#endif  // DBG

    //
    // Initialize the global trace logs.
    //

    CREATE_REF_TRACE_LOG( g_pMondoGlobalTraceLog,
                          16384 - REF_TRACE_OVERHEAD,
                          0, TRACELOG_HIGH_PRIORITY,
                          UL_REF_TRACE_LOG_POOL_TAG );

    CREATE_REF_TRACE_LOG( g_pPoolAllocTraceLog,
                          16384 - REF_TRACE_OVERHEAD,
                          0, TRACELOG_HIGH_PRIORITY,
                          UL_REF_TRACE_LOG_POOL_TAG );

    CREATE_REF_TRACE_LOG( g_pUriTraceLog,
                          2048 - REF_TRACE_OVERHEAD,
                          0, TRACELOG_HIGH_PRIORITY,
                          UL_REF_TRACE_LOG_POOL_TAG );

    CREATE_REF_TRACE_LOG( g_pTdiTraceLog,
                          32768 - REF_TRACE_OVERHEAD,
                          0, TRACELOG_HIGH_PRIORITY,
                          UL_REF_TRACE_LOG_POOL_TAG );

    CREATE_REF_TRACE_LOG( g_pHttpRequestTraceLog,
                          2048 - REF_TRACE_OVERHEAD,
                          0, TRACELOG_HIGH_PRIORITY,
                          UL_REF_TRACE_LOG_POOL_TAG );

    CREATE_REF_TRACE_LOG( g_pHttpConnectionTraceLog,
                          2048 - REF_TRACE_OVERHEAD,
                          0, TRACELOG_HIGH_PRIORITY,
                          UL_REF_TRACE_LOG_POOL_TAG );

    CREATE_REF_TRACE_LOG( g_pHttpResponseTraceLog,
                          2048 - REF_TRACE_OVERHEAD,
                          0, TRACELOG_HIGH_PRIORITY,
                          UL_REF_TRACE_LOG_POOL_TAG );

    CREATE_REF_TRACE_LOG( g_pAppPoolTraceLog,
                          2048 - REF_TRACE_OVERHEAD,
                          0, TRACELOG_HIGH_PRIORITY,
                          UL_REF_TRACE_LOG_POOL_TAG );

    CREATE_REF_TRACE_LOG( g_pAppPoolProcessTraceLog,
                          2048 - REF_TRACE_OVERHEAD, 
                          0, TRACELOG_HIGH_PRIORITY,
                          UL_REF_TRACE_LOG_POOL_TAG );

    CREATE_REF_TRACE_LOG( g_pConfigGroupTraceLog,
                          2048 - REF_TRACE_OVERHEAD,
                          0, TRACELOG_HIGH_PRIORITY,
                          UL_REF_TRACE_LOG_POOL_TAG );

    CREATE_REF_TRACE_LOG( g_pControlChannelTraceLog,
                          2048 - REF_TRACE_OVERHEAD,
                          0, TRACELOG_HIGH_PRIORITY,
                          UL_REF_TRACE_LOG_POOL_TAG );

    CREATE_REF_TRACE_LOG( g_pThreadTraceLog,
                          16384 - REF_TRACE_OVERHEAD,
                          0, TRACELOG_HIGH_PRIORITY,
                          UL_REF_TRACE_LOG_POOL_TAG );

    CREATE_REF_TRACE_LOG( g_pMdlTraceLog,
                          2048 - REF_TRACE_OVERHEAD,
                          0, TRACELOG_HIGH_PRIORITY,
                          UL_REF_TRACE_LOG_POOL_TAG );

    CREATE_REF_TRACE_LOG( g_pFilterTraceLog,
                          2048 - REF_TRACE_OVERHEAD,
                          0, TRACELOG_HIGH_PRIORITY,
                          UL_REF_TRACE_LOG_POOL_TAG );

    CREATE_REF_TRACE_LOG( g_pSiteCounterTraceLog,
                          2048 - REF_TRACE_OVERHEAD,
                          0, TRACELOG_HIGH_PRIORITY,
                          UL_REF_TRACE_LOG_POOL_TAG );

    CREATE_REF_TRACE_LOG( g_pConnectionCountTraceLog,
                          2048 - REF_TRACE_OVERHEAD,
                          0, TRACELOG_HIGH_PRIORITY,
                          UL_REF_TRACE_LOG_POOL_TAG );

    CREATE_REF_TRACE_LOG( g_pConfigGroupInfoTraceLog,
                          2048 - REF_TRACE_OVERHEAD,
                          0, TRACELOG_HIGH_PRIORITY,
                          UL_REF_TRACE_LOG_POOL_TAG );

    CREATE_REF_TRACE_LOG( g_pChunkTrackerTraceLog,
                          2048 - REF_TRACE_OVERHEAD,
                          0, TRACELOG_HIGH_PRIORITY,
                          UL_REF_TRACE_LOG_POOL_TAG );

    CREATE_REF_TRACE_LOG( g_pWorkItemTraceLog,
                          32768 - REF_TRACE_OVERHEAD,
                          0, TRACELOG_HIGH_PRIORITY,
                          UL_REF_TRACE_LOG_POOL_TAG );

    CREATE_REF_TRACE_LOG( g_pEndpointUsageTraceLog,
                          16384 - REF_TRACE_OVERHEAD,
                          0, TRACELOG_HIGH_PRIORITY,
                          UL_REF_TRACE_LOG_POOL_TAG );

    CREATE_IRP_TRACE_LOG( g_pIrpTraceLog,
                          32768 - REF_TRACE_OVERHEAD, 0 );
    CREATE_TIME_TRACE_LOG( g_pTimeTraceLog,
                           32768 - REF_TRACE_OVERHEAD, 0 );
    CREATE_APP_POOL_TIME_TRACE_LOG( g_pAppPoolTimeTraceLog,
                                    32768 - REF_TRACE_OVERHEAD, 0 );
    
    CREATE_STRING_LOG( g_pGlobalStringLog, 5 * 1024 * 1024, 0, FALSE );

    CREATE_UC_TRACE_LOG( g_pUcTraceLog,
                         16384 - REF_TRACE_OVERHEAD, 0 );

    //
    // Create an object directory to contain our device objects.
    //

    status = UlInitUnicodeStringEx( &deviceName, HTTP_DIRECTORY_NAME );

    if (!NT_SUCCESS(status))
    {
        goto fatal;
    }

    InitializeObjectAttributes(
        &objectAttributes,                      // ObjectAttributes
        &deviceName,                            // ObjectName
        OBJ_CASE_INSENSITIVE |                  // Attributes
            OBJ_KERNEL_HANDLE,
        NULL,                                   // RootDirectory
        NULL                                    // SecurityDescriptor
        );

    status = ZwCreateDirectoryObject(
                    &g_UlDirectoryObject,       // DirectoryHandle
                    DIRECTORY_ALL_ACCESS,       // AccessMask
                    &objectAttributes           // ObjectAttributes
                    );

    if (!NT_SUCCESS(status))
    {
        goto fatal;
    }

    //
    // Create the control channel device object.
    //

    status = UlInitUnicodeStringEx( &deviceName, HTTP_CONTROL_DEVICE_NAME );

    if (!NT_SUCCESS(status))
    {
        goto fatal;
    }

    status = IoCreateDevice(
                    DriverObject,               // DriverObject
                    0,                          // DeviceExtension
                    &deviceName,                // DeviceName
                    FILE_DEVICE_NETWORK,        // DeviceType
                    0,                          // DeviceCharacteristics
                    FALSE,                      // Exclusive
                    &g_pUlControlDeviceObject   // DeviceObject
                    );

    if (!NT_SUCCESS(status))
    {
        goto fatal;
    }

    //
    // Create the filter device object.
    //

    status = UlInitUnicodeStringEx( &deviceName, HTTP_FILTER_DEVICE_NAME );

    if (!NT_SUCCESS(status))
    {
        goto fatal;
    }

    status = IoCreateDevice(
                    DriverObject,               // DriverObject
                    0,                          // DeviceExtension
                    &deviceName,                // DeviceName
                    FILE_DEVICE_NETWORK,        // DeviceType
                    0,                          // DeviceCharacteristics
                    FALSE,                      // Exclusive
                    &g_pUlFilterDeviceObject    // DeviceObject
                    );

    if (!NT_SUCCESS(status))
    {
        goto fatal;
    }

    g_pUlFilterDeviceObject->StackSize = DEFAULT_IRP_STACK_SIZE;

    //
    // Create the app pool device object.
    //

    status = UlInitUnicodeStringEx( &deviceName, HTTP_APP_POOL_DEVICE_NAME );

    if (!NT_SUCCESS(status))
    {
        goto fatal;
    }

    status = IoCreateDevice(
                    DriverObject,               // DriverObject
                    0,                          // DeviceExtension
                    &deviceName,                // DeviceName
                    FILE_DEVICE_NETWORK,        // DeviceType
                    0,                          // DeviceCharacteristics
                    FALSE,                      // Exclusive
                    &g_pUlAppPoolDeviceObject   // DeviceObject
                    );

    if (!NT_SUCCESS(status))
    {
        goto fatal;
    }

    g_pUlAppPoolDeviceObject->StackSize = DEFAULT_IRP_STACK_SIZE;


    //
    // Initialize the driver object with this driver's entrypoints.
    //

    DriverObject->MajorFunction[IRP_MJ_CREATE] = &UlCreate;
    DriverObject->MajorFunction[IRP_MJ_CLOSE] = &UlClose;
    DriverObject->MajorFunction[IRP_MJ_CLEANUP] = &UlCleanup;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = &UlDeviceControl;
    DriverObject->MajorFunction[IRP_MJ_QUERY_SECURITY] = &UlQuerySecurityDispatch;
    DriverObject->MajorFunction[IRP_MJ_SET_SECURITY] = &UlSetSecurityDispatch;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = &UlEtwDispatch;
    DriverObject->FastIoDispatch = &UlFastIoDispatch;
    DriverObject->DriverUnload = NULL;

    //
    // Initialize global data.
    //

    status = UlInitializeData(&config);

    if (!NT_SUCCESS(status))
    {
        goto fatal;
    }

    //
    // Create the thread pool.
    //

    status = UlInitializeThreadPool(config.ThreadsPerCpu);

    if (!NT_SUCCESS(status))
    {
        goto fatal;
    }

    //
    // Initialize common TDI code.
    //
    
    status = UxInitializeTdi();

    if (!NT_SUCCESS(status))
    {
        goto fatal;
    }

    //
    // Initialize server connection code.
    //

    status = UlInitializeTdi();

    if (!NT_SUCCESS(status))
    {
        goto fatal;
    }

    //
    // Initialize George.
    //

    status = UlLargeMemInitialize();
    if (!NT_SUCCESS(status))
    {
        goto fatal;
    }

    //
    // Initialize Keith.
    //

    status = UlInitializeControlChannel();
    if (!NT_SUCCESS(status))
    {
        goto fatal;
    }

    //
    // Initialize Henry.
    //

    status = InitializeHttpUtil();
    if (!NT_SUCCESS(status))
    {
        goto fatal;
    }

    status = InitializeParser();
    if (!NT_SUCCESS(status))
    {
        goto fatal;
    }

    status = UlInitializeOpaqueIdTable();
    if (!NT_SUCCESS(status))
    {
        goto fatal;
    }

    status = InitializeFileCache();
    if (!NT_SUCCESS(status))
    {
        goto fatal;
    }

    //
    // Initialize Michael.
    //
    status = UlInitializeFilterChannel(&config);
    if (!NT_SUCCESS(status))
    {
        goto fatal;
    }

    //
    // Initialize Alex.
    //
    status = UlInitializeUriCache(&config);
    if (!NT_SUCCESS(status))
    {
        goto fatal;
    }

    status = UlInitializeDateCache();
    if (!NT_SUCCESS(status))
    {
        goto fatal;
    }

    //
    // Initialize Paul.
    //

    status = UlInitializeCG();
    if (!NT_SUCCESS(status))
    {
        goto fatal;
    }

    status = UlInitializeAP();
    if (!NT_SUCCESS(status))
    {
        goto fatal;
    }

    //
    // Initialize Ali
    //
    status = UlInitializeLogUtil();
    if (!NT_SUCCESS(status))
    {
        goto fatal;
    }

    status = UlInitializeLogs();
    if (!NT_SUCCESS(status))
    {
        goto fatal;
    }

    status = UlInitializeBinaryLog();
    if (!NT_SUCCESS(status))
    {
        goto fatal;
    }

    status = UlInitializeErrorLog();
    if (!NT_SUCCESS(status))
    {
        goto fatal;
    }
    
    status = UlTcInitialize();
    if (!NT_SUCCESS(status))
    {
        goto fatal;
    }

    status = UlInitGlobalConnectionLimits();
    if (!NT_SUCCESS(status))
    {
        goto fatal;
    }

    status = UlInitializeHttpConnection();
    if (!NT_SUCCESS(status))
    {
        goto fatal;
    }
    
    //
    // Initialize Eric.
    //

    status = UlInitializeCounters();
    if (!NT_SUCCESS(status))
    {
        goto fatal;
    }

    UlInitializeTimeoutMonitor();
    //
    // Initialize ETW Tracing
    //
    UlEtwInitLog( g_pUlControlDeviceObject );

    //
    // Initialize HTTP client
    //

    if(config.EnableHttpClient)
    {
        //
        // All of the client code live under a "section" called PAGEUC. This
        // section is paged by default & gets locked down when there is an app 
        // that uses the client APIs (specifically, opens a handle to a server).
        //
        // There are two ways of demand locking this section. We can either use 
        // MmLockPagableCodeSection or MmLockPagableSectionByHandle. It's a lot
        // cheaper to use MmLockPagableSectionByHandle. 
        //
        // So, during our DriverEntry, we first lock the entire PAGEUC section
        // to obtain the handle. We then immediately unlock it, but remember
        // the handle. This allows us to use MmLockPagableSectionByHandle for
        // subsequent locks, which is much faster.
        //
        // In order to use MmLockPagableCodeSection, we'll pick one function
        // that lives under this section --> UcpTdiReceiveHandler
        //

        g_ClientImageHandle =
            MmLockPagableCodeSection((PVOID)((ULONG_PTR)UcpTdiReceiveHandler));
        MmUnlockPagableImageSection(g_ClientImageHandle);


        //
        // Create the server device object
        //
        status = UlInitUnicodeStringEx(&deviceName, HTTP_SERVER_DEVICE_NAME);

        if(!NT_SUCCESS(status))
        {
            goto fatal;
        }
    
        status = IoCreateDevice(DriverObject,
                                0,
                                &deviceName,
                                FILE_DEVICE_NETWORK,
                                0,
                                FALSE,
                                &g_pUcServerDeviceObject
                                );
    
        if(!NT_SUCCESS(status))
        {
            goto fatal;
        }
        g_pUcServerDeviceObject->StackSize ++;

        //
        // Initialize the client connection code.
        //
    
        status = UcInitializeServerInformation();
        if(!NT_SUCCESS(status))
        {
            goto fatal;
        }
    
        status = UcInitializeClientConnections();
        if(!NT_SUCCESS(status))
        {
            goto fatal;
        }
    
        status = UcInitializeSSPI();
        if(!NT_SUCCESS(status))
        {
            goto fatal;
        }
    
        status = UcInitializeHttpRequests();
        if (!NT_SUCCESS(status))
        {
            goto fatal;
        }

    }
    else
    {
        // Disable all the client IOCTLs.
        
        UlSetDummyIoctls();
    }

    //
    // Apply security to the device objects.
    //

    status = UlpApplySecurityToDeviceObjects();

    if (!NT_SUCCESS(status))
    {
        goto fatal;
    }

    //
    // Initialize Namespace.
    // Note: This initialization must be done after 
    //       UlpApplySecurityToDeviceObjects() has been called.
    //       Otherwise, g_pAdminAllSystemAll will not be initialzied.
    //       UlInitializeNamespace() uses that global security descriptor.
    //

    status = UlInitializeNamespace();

    if (!NT_SUCCESS(status))
    {
        goto fatal;
    }

#if DBG
    //
    // Give anyone using the kernel debugger one final chance to abort
    // initialization.
    //

    if (g_UlpForceInitFailure != 0)
    {
        status = STATUS_UNSUCCESSFUL;
        goto fatal;
    }
#endif  // DBG

    //
    // Set DriverUnload only after everything has succeeded to synchronize
    // DriverEntry and DriverUnload. In theory however, the DriverUnload
    // routine can still be called once we set it, but that can't be fixed
    // by the drivers, it needs to be fixed by IO or SCM.
    //

    DriverObject->DriverUnload = &UlpUnload;

    return STATUS_SUCCESS;

    //
    // Fatal error handlers.
    //

fatal:

    ASSERT( !NT_SUCCESS(status) );

    UlpTerminateModules();

     return status;

}   // DriverEntry


//
// Private functions.
//

/***************************************************************************++

Routine Description:

    Applies the appropriate security descriptors to the global device
    objects created at initialization time.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlpApplySecurityToDeviceObjects(
    VOID
    )
{
    NTSTATUS            status;
    SECURITY_DESCRIPTOR securityDescriptor;
    PGENERIC_MAPPING    pFileObjectGenericMapping;
    ACCESS_MASK         fileReadWrite;
    ACCESS_MASK         fileAll;
    SID_MASK_PAIR       sidMaskPairs[4];

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT( IS_VALID_DEVICE_OBJECT( g_pUlControlDeviceObject ) );
    ASSERT( IS_VALID_DEVICE_OBJECT( g_pUlFilterDeviceObject ) );
    ASSERT( IS_VALID_DEVICE_OBJECT( g_pUlAppPoolDeviceObject ) );

    //
    // Gain access to the predefined SIDs and other security-related
    // goodies exported by the kernel.
    //

    //SeEnableAccessToExports();

    //
    // Map a couple of generic file access types to their corresponding
    // object-specific rights.
    //


    pFileObjectGenericMapping = IoGetFileObjectGenericMapping();
    ASSERT( pFileObjectGenericMapping != NULL );

    //
    // FILE_READ & FILE_WRITE
    //

    fileReadWrite = GENERIC_READ | GENERIC_WRITE;

    RtlMapGenericMask(
        &fileReadWrite,
        pFileObjectGenericMapping
        );

    //
    // FILE_ALL
    //

    fileAll = GENERIC_ALL;

    RtlMapGenericMask(
        &fileAll,
        pFileObjectGenericMapping
        );

    //
    // Build a restrictive security descriptor for the filter device
    // object:
    //
    //      Full access for NT AUTHORITY\SYSTEM
    //      Full access for BUILTIN\Administrators
    //

    sidMaskPairs[0].pSid = SeExports->SeLocalSystemSid;
    sidMaskPairs[0].AccessMask = fileAll;
    sidMaskPairs[0].AceFlags = 0;    

    sidMaskPairs[1].pSid = SeExports->SeAliasAdminsSid;
    sidMaskPairs[1].AccessMask = fileAll;
    sidMaskPairs[1].AceFlags = 0;    

    status = UlCreateSecurityDescriptor(
                    &securityDescriptor,    // pSecurityDescriptor
                    &sidMaskPairs[0],       // pSidMaskPairs
                    2                       // NumSidMaskPairs
                    );

    if (!NT_SUCCESS(status))
    {
        return status;
    }

    //
    // Filter object
    //

    status = UlpSetDeviceObjectSecurity(
                    g_pUlFilterDeviceObject,
                    DACL_SECURITY_INFORMATION,
                    &securityDescriptor
                    );

    UlCleanupSecurityDescriptor(&securityDescriptor);

    if (!NT_SUCCESS(status))
    {
        return status;
    }

    //
    // We want a global security descriptor that allows fileAll to 
    // System and Administrators and nothing else for world. Incidently,
    // the filter device object provides this exact feature. We'll save 
    // a pointer to this security descriptor.
    // 
    // WARNING: If we ever change the ACL on the Filter Device Object, we'll
    // have to create a new security descriptor for this.
    //
    //

    g_pAdminAllSystemAll = g_pUlFilterDeviceObject->SecurityDescriptor;

    //
    // Build a slightly less restrictive security descriptor for the
    // other device objects.
    //
    //      Full       access for NT AUTHORITY\SYSTEM
    //      Full       access for BUILTIN\Administrators
    //      Read/Write access for Authenticated users
    //      Read/Write access for Guest.
    //

    sidMaskPairs[2].pSid       = SeExports->SeAuthenticatedUsersSid;
    sidMaskPairs[2].AccessMask = fileReadWrite;
    sidMaskPairs[2].AceFlags   = 0;    


    sidMaskPairs[3].pSid       = SeExports->SeAliasGuestsSid;
    sidMaskPairs[3].AccessMask = fileReadWrite;
    sidMaskPairs[3].AceFlags   = 0;    


    status = UlCreateSecurityDescriptor(
                    &securityDescriptor, 
                    &sidMaskPairs[0],               // pSidMaskPairs
                    4                               // NumSidMaskPairs
                    );

    if (!NT_SUCCESS(status))
    {
        return status;
    }

    for(;;)
    {

        //
        // App Pool
        //
        status = UlpSetDeviceObjectSecurity(
                        g_pUlAppPoolDeviceObject,
                        DACL_SECURITY_INFORMATION,
                        &securityDescriptor
                        );

        if (!NT_SUCCESS(status))
        {
            break;
        }

        //
        // Control Channel
        //
        status = UlpSetDeviceObjectSecurity(
                        g_pUlControlDeviceObject,
                        DACL_SECURITY_INFORMATION,
                        &securityDescriptor
                        );

        if (!NT_SUCCESS(status))
        {
            break;
        }

        //
        // Server
        //

        if(g_pUcServerDeviceObject)
        {
            status = UlpSetDeviceObjectSecurity(
                            g_pUcServerDeviceObject,
                            DACL_SECURITY_INFORMATION,
                            &securityDescriptor
                            );
        }

        break;
    }

    UlCleanupSecurityDescriptor(&securityDescriptor);

    return status;

}   // UlpApplySecurityToDeviceObjects

/***************************************************************************++

Routine Description:

    Applies the specified security descriptor to the specified device
    object.

Arguments:

    pDeviceObject - Supplies the device object to manipulate.

    SecurityInformation - Supplies the level of information to change.

    pSecurityDescriptor - Supplies the new security descriptor for the
        device object.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlpSetDeviceObjectSecurity(
    IN PDEVICE_OBJECT pDeviceObject,
    IN SECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
    )
{
    NTSTATUS status;
    HANDLE handle;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT( IS_VALID_DEVICE_OBJECT( pDeviceObject ) );
    ASSERT( RtlValidSecurityDescriptor( pSecurityDescriptor ) );

    //
    // Open a handle to the device object.
    //

    status = ObOpenObjectByPointer(
                    pDeviceObject,                  // Object
                    OBJ_CASE_INSENSITIVE |          // HandleAttributes
                        OBJ_KERNEL_HANDLE,
                    NULL,                           // PassedAccessState
                    MAXIMUM_ALLOWED,                // DesiredAccess
                    NULL,                           // ObjectType
                    KernelMode,                     // AccessMode
                    &handle                         // Handle
                    );

    if (NT_SUCCESS(status))
    {
        status = NtSetSecurityObject(
                        handle,                     // Handle
                        SecurityInformation,        // SecurityInformation
                        pSecurityDescriptor         // SecurityDescriptor
                        );

        ZwClose( handle );
    }

    return status;

}   // UlpSetDeviceObjectSecurity


//
// Read URL processing parameters.
//

ULONG
UlpReadUrlC14nConfig(
    HANDLE parametersHandle
    )
{
    LONG tmp;
    LONG DefaultBoolRegValue = -123; // sane values are 0 and 1
    LONG EnableDbcs;
    LONG FavorUtf8;
    LONG EnableNonUtf8 ;
    LONG PercentUAllowed ;
    LONG AllowRestrictedChars ;
    LONG UrlSegmentMaxLength;
    LONG UrlSegmentMaxCount;
    NTSTATUS status;
    UNICODE_STRING registryPathNLS;
    HANDLE codePageHandle;
    UNICODE_STRING ACPCodeString;
    ULONG ACPCode = 0;
    PKEY_VALUE_PARTIAL_INFORMATION pInfo;

    //
    // Tune defaults based on whether we are running on a DBCS system.
    // Since we do not have a convenient API to do so, use this algorithm:
    //
    //  1- Get ACP from the registry at: 
    //      HKLM\System\CurrentControlSet\Control\NLS\CodePage
    //  2- check against the list of DBCS in:
    //      http://www.microsoft.com/globaldev/reference/WinCP.asp
    //
    // TODO - use kernel mode API when provided.
    //

    EnableDbcs = FALSE;

    status = UlInitUnicodeStringEx(&registryPathNLS, REGISTRY_NLS_PATH);

    if(NT_SUCCESS(status))
    {
        status = UlOpenRegistry( 
                    &registryPathNLS, 
                    &codePageHandle,
                    REGISTRY_NLS_CODEPAGE_KEY
                    );

        if (NT_SUCCESS(status))
        {
            pInfo = NULL;

            status = UlReadGenericParameter(
                        codePageHandle,
                        REGISTRY_ACP_NAME,
                        &pInfo
                        );

            if (NT_SUCCESS(status))
            {
                ASSERT(pInfo);
        
                if (pInfo->Type == REG_SZ)
                {
                    status = UlInitUnicodeStringEx(
                                    &ACPCodeString, 
                                    (PWSTR)pInfo->Data
                                    );

                    if (NT_SUCCESS(status))
                    {
                        status = HttpWideStringToULong(
                                        ACPCodeString.Buffer, 
                                        ACPCodeString.Length / sizeof(WCHAR), 
                                        FALSE,
                                        10, 
                                        NULL,
                                        &ACPCode
                                        );

                        if (NT_SUCCESS(status))
                        {
                            //
                            // Check if this is one of the known DBCS codes:
                            //
                            if ((ACPCode == CP_JAPANESE_SHIFT_JIS) ||
                                (ACPCode == CP_SIMPLIFIED_CHINESE_GBK) ||
                                (ACPCode == CP_KOREAN) ||
                                (ACPCode == CP_TRADITIONAL_CHINESE_BIG5))
                            {
                                EnableDbcs = TRUE;
                            }
                            else
                            {
                                EnableDbcs = FALSE;
                            }
                        }
                    }
                }

            //
            // Free up the returned value.
            //
            UL_FREE_POOL( pInfo, UL_REGISTRY_DATA_POOL_TAG );
            }

            ZwClose( codePageHandle );
        }
    }

    //
    // Now check if we have registry overrides for each of these.
    //
    EnableNonUtf8 = UlReadLongParameter(
                        parametersHandle,
                        REGISTRY_ENABLE_NON_UTF8_URL,
                        DefaultBoolRegValue);

    if (EnableNonUtf8 != DefaultBoolRegValue)
    {
        //
        // A registry setting is present; use it.
        //
        EnableNonUtf8 = (BOOLEAN) (EnableNonUtf8 != 0);
    }
    else
    {
        EnableNonUtf8 = DEFAULT_ENABLE_NON_UTF8_URL;
    }

    if (EnableNonUtf8)
    {
        FavorUtf8 = UlReadLongParameter(
                            parametersHandle,
                            REGISTRY_FAVOR_UTF8_URL,
                            DefaultBoolRegValue
                            );

        if (FavorUtf8 != DefaultBoolRegValue)
        {
            //
            // A registry setting is present; use it.
            //
            FavorUtf8 = (BOOLEAN) (FavorUtf8 != 0);
        }
        else
        {
            FavorUtf8 = DEFAULT_FAVOR_UTF8_URL;
        }

    }
    else
    {
        //
        // We can't do DBCS or favor UTF-8 if we accept UTF-8 only.
        //
        EnableDbcs = FALSE;
        FavorUtf8  = FALSE;
    }

    PercentUAllowed = UlReadLongParameter(
                        parametersHandle,
                        REGISTRY_PERCENT_U_ALLOWED,
                        DefaultBoolRegValue);

    if (PercentUAllowed != DefaultBoolRegValue)
    {
        //
        // A registry setting is present; use it.
        //
        PercentUAllowed = (BOOLEAN) (PercentUAllowed != 0);
    }
    else
    {
        PercentUAllowed = DEFAULT_PERCENT_U_ALLOWED;
    }

    AllowRestrictedChars = UlReadLongParameter(
                                parametersHandle,
                                REGISTRY_ALLOW_RESTRICTED_CHARS,
                                DefaultBoolRegValue);

    if (AllowRestrictedChars != DefaultBoolRegValue)
    {
        //
        // A registry setting is present; use it.
        //
        AllowRestrictedChars = (BOOLEAN) (AllowRestrictedChars != 0);
    }
    else
    {
        AllowRestrictedChars = DEFAULT_ALLOW_RESTRICTED_CHARS;
    }

    tmp = UlReadLongParameter(
                parametersHandle,
                REGISTRY_URL_SEGMENT_MAX_LENGTH,
                DEFAULT_URL_SEGMENT_MAX_LENGTH
                );

    if (tmp == 0)
    {
        // 0 in the registry turns this feature off
        UrlSegmentMaxLength = C14N_URL_SEGMENT_UNLIMITED_LENGTH;
    }
    else if (tmp < WCSLEN_LIT(L"/x") || tmp > UNICODE_STRING_MAX_WCHAR_LEN)
    {
        UrlSegmentMaxLength = DEFAULT_URL_SEGMENT_MAX_LENGTH;
    }
    else
    {
        UrlSegmentMaxLength = tmp;
    }

    tmp = UlReadLongParameter(
                parametersHandle,
                REGISTRY_URL_SEGMENT_MAX_COUNT,
                DEFAULT_URL_SEGMENT_MAX_COUNT
                );

    if (tmp == 0)
    {
        // 0 in the registry turns this feature off
        UrlSegmentMaxCount = C14N_URL_SEGMENT_UNLIMITED_COUNT;
    }
    else if (tmp < 2 || tmp > UNICODE_STRING_MAX_WCHAR_LEN / WCSLEN_LIT(L"/x"))
    {
        UrlSegmentMaxCount = DEFAULT_URL_SEGMENT_MAX_COUNT;
    }
    else
    {
        UrlSegmentMaxCount = tmp;
    }

    //
    // Initialize the default Url Canonicalization settings
    //

    HttpInitializeDefaultUrlC14nConfigEncoding(
            &g_UrlC14nConfig,
            (BOOLEAN) EnableNonUtf8,
            (BOOLEAN) FavorUtf8,
            (BOOLEAN) EnableDbcs
            );

    g_UrlC14nConfig.PercentUAllowed         = (BOOLEAN) PercentUAllowed;
    g_UrlC14nConfig.AllowRestrictedChars    = (BOOLEAN) AllowRestrictedChars;
    g_UrlC14nConfig.CodePage                = ACPCode;
    g_UrlC14nConfig.UrlSegmentMaxLength     = UrlSegmentMaxLength;
    g_UrlC14nConfig.UrlSegmentMaxCount      = UrlSegmentMaxCount;

    return ACPCode;

} // UlpReadUrlC14nConfig

/***************************************************************************++

Routine Description:

    Reads the error logging config from registry and initializes the 
    global config structure.

Arguments:

    parametersHandle - Supplies the reg handle to the http param folder.

--***************************************************************************/

VOID
UlpReadErrorLogConfig(
    HANDLE parametersHandle
    )
{
    LONG tmp;
    NTSTATUS Status;
    PKEY_VALUE_PARTIAL_INFORMATION pInfo;

    PAGED_CODE();

    //
    // First see whether it's enabled or not.
    //
    
    tmp = UlReadLongParameter(
                 parametersHandle,
                 REGISTRY_ERROR_LOGGING_ENABLED,
                 DEFAULT_ENABLE_ERROR_LOGGING
                 );
    if (tmp == 0)
    {
        g_UlErrLoggingConfig.Enabled = FALSE;
    }
    else if (tmp == 1)
    {
        g_UlErrLoggingConfig.Enabled = TRUE;
    }
    else
    {
        g_UlErrLoggingConfig.Enabled = DEFAULT_ENABLE_ERROR_LOGGING;
    }

    //
    // Now try to read the whole config if it is enabled.
    //
    
    if (g_UlErrLoggingConfig.Enabled == TRUE)
    {     
        //
        // Rollover size.
        //
        
        tmp = UlReadLongParameter(
                    parametersHandle,
                    REGISTRY_ERROR_LOGGING_TRUNCATION_SIZE,
                    0
                    );
        if (tmp < 0)   
        {
            //
            // Interpret the neg values as infinite.
            //
            
            g_UlErrLoggingConfig.TruncateSize = HTTP_LIMIT_INFINITE;
            
        }
        else if (tmp < DEFAULT_MIN_ERROR_FILE_TRUNCATION_SIZE)
        {
            //
            // If the it is invalid, set it to default.
            //        
            
            g_UlErrLoggingConfig.TruncateSize = DEFAULT_ERROR_FILE_TRUNCATION_SIZE;
            
        }
        else
        {
            g_UlErrLoggingConfig.TruncateSize = (ULONG) tmp;
        }
            
        //
        // Error logging directory.
        //

        g_UlErrLoggingConfig.Dir.Buffer = g_UlErrLoggingConfig._DirBuffer;
        g_UlErrLoggingConfig.Dir.Length = 0;
        g_UlErrLoggingConfig.Dir.MaximumLength = 
                (USHORT) sizeof(g_UlErrLoggingConfig._DirBuffer);        

        //
        // Lets make sure the buffer is big enough to hold.
        //
        
        ASSERT(sizeof(g_UlErrLoggingConfig._DirBuffer) 
                >= ((  MAX_PATH                       // From reg 
                     + UL_ERROR_LOG_SUB_DIR_LENGTH    // SubDir
                     + 1                              // UnicodeNull
                     ) * sizeof(WCHAR))
                );
        
        pInfo  = NULL;        
        Status = UlReadGenericParameter(
                    parametersHandle,
                    REGISTRY_ERROR_LOGGING_DIRECTORY,
                    &pInfo
                    );

        if (NT_SUCCESS(Status))
        {            
            ASSERT(pInfo);
            
            if (pInfo->Type == REG_EXPAND_SZ || pInfo->Type == REG_SZ)
            {
                USHORT RegDirLength = (USHORT) wcslen((PWCHAR) pInfo->Data);

                if (RegDirLength <= MAX_PATH)
                {
                    //
                    // Copy the beginning portion from the registry.
                    //

                    Status = UlBuildErrorLoggingDirStr(
                                    (PCWSTR) pInfo->Data,
                                    &g_UlErrLoggingConfig.Dir
                                    );
                    
                    ASSERT(NT_SUCCESS(Status));
                    
                    //
                    // Check the user's directory.
                    // 
                    
                    Status = UlCheckErrorLogConfig(&g_UlErrLoggingConfig);
                    if (NT_SUCCESS(Status))
                    {
                        //
                        // Good to go.
                        //
                        
                        UL_FREE_POOL( pInfo, UL_REGISTRY_DATA_POOL_TAG );
                        return;
                    }                    
                }                
            }

            //
            // Free up the returned value.
            //
            
            UL_FREE_POOL( pInfo, UL_REGISTRY_DATA_POOL_TAG );
        }

        //
        // Fall back to the default directory.
        //

        ASSERT(wcslen(DEFAULT_ERROR_LOGGING_DIR) <= MAX_PATH);

        Status = UlBuildErrorLoggingDirStr(
                        DEFAULT_ERROR_LOGGING_DIR,
                       &g_UlErrLoggingConfig.Dir
                        );
        
        ASSERT(NT_SUCCESS(Status));
                
        Status = UlCheckErrorLogConfig(&g_UlErrLoggingConfig);
        if (!NT_SUCCESS(Status))
        {
            //
            // This call should not fail.
            //

            ASSERT(!"Invalid default error logging config !");
            g_UlErrLoggingConfig.Enabled = FALSE;
        }            
    }

    return;    
}

/***************************************************************************++

Routine Description:

    Reads the UL section of the registry. Any values contained in the
    registry override defaults.

    BUGBUG: the limits on many of these settings seem particularly arbitrary,
    not to mention undocumented.

Arguments:

    pConfig - Supplies a pointer to a UL_CONFIG structure that receives
        init-time configuration parameters. These are basically
        parameters that do not need to persist in the driver once
        initialization is complete.

--***************************************************************************/
VOID
UlpReadRegistry(
    IN PUL_CONFIG pConfig
    )
{
    HANDLE parametersHandle;
    NTSTATUS status;
    LONG tmp;
    LONGLONG tmp64;
    UNICODE_STRING registryPath;
    UNICODE_STRING registryPathComputerName;
    PKEY_VALUE_PARTIAL_INFORMATION pInfo;
    PKEY_VALUE_PARTIAL_INFORMATION pValue;
    HANDLE computerNameHandle;
    ULONG ACPCode;


    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // Establish defaults.
    //

    pConfig->ThreadsPerCpu = DEFAULT_THREADS_PER_CPU;
    pConfig->IrpContextLookasideDepth = DEFAULT_IRP_CONTEXT_LOOKASIDE_DEPTH;
    pConfig->ReceiveBufferLookasideDepth = DEFAULT_RCV_BUFFER_LOOKASIDE_DEPTH;
    pConfig->ResourceLookasideDepth = DEFAULT_RESOURCE_LOOKASIDE_DEPTH;
    pConfig->RequestBufferLookasideDepth = DEFAULT_REQ_BUFFER_LOOKASIDE_DEPTH;
    pConfig->InternalRequestLookasideDepth = DEFAULT_INT_REQUEST_LOOKASIDE_DEPTH;
    pConfig->ResponseBufferLookasideDepth = DEFAULT_RESP_BUFFER_LOOKASIDE_DEPTH;
    pConfig->SendTrackerLookasideDepth = DEFAULT_SEND_TRACKER_LOOKASIDE_DEPTH;
    pConfig->LogFileBufferLookasideDepth = DEFAULT_LOG_BUFFER_LOOKASIDE_DEPTH;
    pConfig->LogDataBufferLookasideDepth = DEFAULT_LOG_DATA_BUFFER_LOOKASIDE_DEPTH;
    pConfig->ErrorLogBufferLookasideDepth = DEFAULT_ERROR_LOG_BUFFER_LOOKASIDE_DEPTH;
    pConfig->FilterWriteTrackerLookasideDepth = DEFAULT_LOOKASIDE_DEPTH;

    pConfig->UriConfig.EnableCache = DEFAULT_CACHE_ENABLED;
    pConfig->UriConfig.MaxCacheUriCount = DEFAULT_MAX_CACHE_URI_COUNT;
    pConfig->UriConfig.MaxCacheMegabyteCount = DEFAULT_MAX_CACHE_MEGABYTE_COUNT;
    pConfig->UriConfig.MaxUriBytes = DEFAULT_MAX_URI_BYTES;
    pConfig->UriConfig.ScavengerPeriod = DEFAULT_CACHE_SCAVENGER_PERIOD;
    pConfig->EnableHttpClient = DEFAULT_HTTP_CLIENT_ENABLED;

    //
    // Open the registry.
    //

    status = UlInitUnicodeStringEx( &registryPath, REGISTRY_UL_INFORMATION );

    if(!NT_SUCCESS(status))
    {
        return;
    }

    status = UlOpenRegistry( &registryPath, &parametersHandle, NULL );

    if(!NT_SUCCESS(status))
    {
        return;
    }

#if DBG
    //
    // Read the debug flags.
    //

    g_UlDebug = (ULONGLONG)
        UlReadLongLongParameter(
                parametersHandle,
                REGISTRY_DEBUG_FLAGS,
                (LONGLONG)g_UlDebug
                );

    //
    // Force a breakpoint if so requested.
    //

    if (UlReadLongParameter(
            parametersHandle,
            REGISTRY_BREAK_ON_STARTUP,
            DEFAULT_BREAK_ON_STARTUP) != 0 )
    {
        DbgBreakPoint();
    }

    //
    // Read the break-on-error flags.
    //

    g_UlBreakOnError = (BOOLEAN) UlReadLongParameter(
                                    parametersHandle,
                                    REGISTRY_BREAK_ON_ERROR,
                                    g_UlBreakOnError
                                    ) != 0;

    g_UlVerboseErrors = (BOOLEAN) UlReadLongParameter(
                                    parametersHandle,
                                    REGISTRY_VERBOSE_ERRORS,
                                    g_UlVerboseErrors
                                    ) != 0;

    //
    // Break-on-error implies verbose-errors.
    //

    if (g_UlBreakOnError)
    {
        g_UlVerboseErrors = TRUE;
    }
#endif  // DBG

    //
    // Read the thread pool parameters.
    //

    tmp = UlReadLongParameter(
            parametersHandle,
            REGISTRY_THREADS_PER_CPU,
            (LONG)pConfig->ThreadsPerCpu
            );

    if (tmp > MAX_THREADS_PER_CPU || tmp <= 0)
    {
        tmp = DEFAULT_THREADS_PER_CPU;
    }

    pConfig->ThreadsPerCpu = (USHORT)tmp;

    //
    // Other configuration parameters. (Lookaside depths are USHORTs)
    //

    tmp = UlReadLongParameter(
                parametersHandle,
                REGISTRY_IDLE_CONNECTIONS_LOW_MARK,
                (LONG)g_UlIdleConnectionsLowMark
                );

    if (tmp > UL_MAX_SLIST_DEPTH || tmp < 1)
    {
        //
        // If the low mark is bad, don't even try to read the high mark.
        //
        g_UlIdleConnectionsLowMark      = DEFAULT_IDLE_CONNECTIONS_LOW_MARK;
        g_UlIdleConnectionsHighMark     = DEFAULT_IDLE_CONNECTIONS_HIGH_MARK;
    }
    else
    {
        g_UlIdleConnectionsLowMark    = (USHORT)tmp;

        //
        // Now read the high mark, again if it is bad, discard the low mark
        // as well.
        //
        tmp = UlReadLongParameter(
                    parametersHandle,
                    REGISTRY_IDLE_CONNECTIONS_HIGH_MARK,
                    (LONG)g_UlIdleConnectionsHighMark
                    );

        if (tmp < g_UlIdleConnectionsLowMark || 
            tmp > UL_MAX_SLIST_DEPTH
            )
        {
            g_UlIdleConnectionsLowMark      = DEFAULT_IDLE_CONNECTIONS_LOW_MARK;
            g_UlIdleConnectionsHighMark     = DEFAULT_IDLE_CONNECTIONS_HIGH_MARK;
        }
        else
        {
            g_UlIdleConnectionsHighMark = (USHORT)tmp;        
        }        
    }

    tmp = UlReadLongParameter(
                parametersHandle,
                REGISTRY_IDLE_LIST_TRIMMER_PERIOD,
                (LONG)g_UlIdleListTrimmerPeriod
                );

    if (tmp > (24 * 60 * 60) || tmp < 5)
    {
        tmp = DEFAULT_IDLE_LIST_TRIMMER_PERIOD;
    }

    g_UlIdleListTrimmerPeriod = (ULONG)tmp;

    tmp = UlReadLongParameter(
                parametersHandle,
                REGISTRY_MAX_ENDPOINTS,
                (LONG)g_UlMaxEndpoints
                );

    if (tmp > 1024 || tmp < 0)
    {
        tmp = DEFAULT_MAX_ENDPOINTS;
    }

    g_UlMaxEndpoints = (USHORT)tmp;

    tmp = UlReadLongParameter(
                parametersHandle,
                REGISTRY_IRP_CONTEXT_LOOKASIDE_DEPTH,
                (LONG)pConfig->IrpContextLookasideDepth
                );

    if (tmp > UL_MAX_SLIST_DEPTH || tmp < 0)
    {
        tmp = DEFAULT_IRP_CONTEXT_LOOKASIDE_DEPTH;
    }

    pConfig->IrpContextLookasideDepth = (USHORT)tmp;

    tmp = UlReadLongParameter(
                parametersHandle,
                REGISTRY_RCV_BUFFER_LOOKASIDE_DEPTH,
                (LONG)pConfig->ReceiveBufferLookasideDepth
                );

    if (tmp > UL_MAX_SLIST_DEPTH || tmp < 0)
    {
        tmp = DEFAULT_RCV_BUFFER_LOOKASIDE_DEPTH;
    }

    pConfig->ReceiveBufferLookasideDepth = (USHORT)tmp;

    tmp = UlReadLongParameter(
                parametersHandle,
                REGISTRY_REQ_BUFFER_LOOKASIDE_DEPTH,
                (LONG)pConfig->RequestBufferLookasideDepth
                );

    if (tmp > UL_MAX_SLIST_DEPTH || tmp < 0)
    {
        tmp = DEFAULT_REQ_BUFFER_LOOKASIDE_DEPTH;
    }

    pConfig->RequestBufferLookasideDepth = (USHORT)tmp;

    tmp = UlReadLongParameter(
                parametersHandle,
                REGISTRY_INT_REQUEST_LOOKASIDE_DEPTH,
                (LONG)pConfig->InternalRequestLookasideDepth
                );

    if (tmp > UL_MAX_SLIST_DEPTH || tmp < 0)
    {
        tmp = DEFAULT_INT_REQUEST_LOOKASIDE_DEPTH;
    }

    pConfig->InternalRequestLookasideDepth = (USHORT)tmp;

    tmp = UlReadLongParameter(
                parametersHandle,
                REGISTRY_RESP_BUFFER_LOOKASIDE_DEPTH,
                (LONG)pConfig->ResponseBufferLookasideDepth
                );

    if (tmp > UL_MAX_SLIST_DEPTH || tmp < 0)
    {
        tmp = DEFAULT_RESP_BUFFER_LOOKASIDE_DEPTH;
    }

    pConfig->ResponseBufferLookasideDepth = (USHORT)tmp;

    tmp = UlReadLongParameter(
                parametersHandle,
                REGISTRY_SEND_TRACKER_LOOKASIDE_DEPTH,
                (LONG)pConfig->SendTrackerLookasideDepth
                );

    if (tmp > UL_MAX_SLIST_DEPTH || tmp < 0)
    {
        tmp = DEFAULT_SEND_TRACKER_LOOKASIDE_DEPTH;
    }

    pConfig->SendTrackerLookasideDepth = (USHORT)tmp;

    tmp = UlReadLongParameter(
                parametersHandle,
                REGISTRY_LOG_BUFFER_LOOKASIDE_DEPTH,
                (LONG)pConfig->LogFileBufferLookasideDepth
                );

    if (tmp > UL_MAX_SLIST_DEPTH || tmp < 0)
    {
        tmp = DEFAULT_LOG_BUFFER_LOOKASIDE_DEPTH;
    }

    pConfig->LogFileBufferLookasideDepth = (USHORT)tmp;

    tmp = UlReadLongParameter(
                parametersHandle,
                REGISTRY_LOG_DATA_BUFFER_LOOKASIDE_DEPTH,
                (LONG)pConfig->LogDataBufferLookasideDepth
                );

    if (tmp > UL_MAX_SLIST_DEPTH || tmp < 0)
    {
        tmp = DEFAULT_LOG_DATA_BUFFER_LOOKASIDE_DEPTH;
    }

    pConfig->LogDataBufferLookasideDepth = (USHORT)tmp;

    g_UlOptForIntrMod = (BOOLEAN) UlReadLongParameter(
                            parametersHandle,
                            REGISTRY_OPT_FOR_INTR_MOD,
                            (LONG)g_UlOptForIntrMod
                            ) != 0;

    g_UlEnableNagling = (BOOLEAN) UlReadLongParameter(
                            parametersHandle,
                            REGISTRY_ENABLE_NAGLING,
                            (LONG)g_UlEnableNagling
                            ) != 0;

    g_UlEnableThreadAffinity = (BOOLEAN) UlReadLongParameter(
                                    parametersHandle,
                                    REGISTRY_ENABLE_THREAD_AFFINITY,
                                    (LONG)g_UlEnableThreadAffinity
                                    ) != 0;

    tmp64 = UlReadLongLongParameter(
                parametersHandle,
                REGISTRY_THREAD_AFFINITY_MASK,
                g_UlThreadAffinityMask
                );

    if ((ULONGLONG)tmp64 > DEFAULT_THREAD_AFFINITY_MASK
        || (ULONGLONG)tmp64 == 0)
    {
        tmp64 = DEFAULT_THREAD_AFFINITY_MASK;
    }

    g_UlThreadAffinityMask = (ULONGLONG)tmp64;

    tmp = UlReadLongParameter(
                parametersHandle,
                REGISTRY_MAX_WORK_QUEUE_DEPTH,
                (LONG)g_UlMaxWorkQueueDepth
                );

    if (tmp > UL_MAX_SLIST_DEPTH || tmp < 0)
    {
        tmp = DEFAULT_MAX_WORK_QUEUE_DEPTH;
    }

    g_UlMaxWorkQueueDepth = (USHORT)tmp;

    tmp = UlReadLongParameter(
                parametersHandle,
                REGISTRY_MIN_WORK_DEQUEUE_DEPTH,
                (LONG)g_UlMinWorkDequeueDepth
                );

    if (tmp > UL_MAX_SLIST_DEPTH || tmp < 0)
    {
        tmp = DEFAULT_MIN_WORK_DEQUEUE_DEPTH;
    }

    g_UlMinWorkDequeueDepth = (USHORT)tmp;

    tmp = UlReadLongParameter(
                parametersHandle,
                REGISTRY_MAX_COPY_THRESHOLD,
                (LONG)g_UlMaxCopyThreshold
                );

    if (tmp > (128 * 1024) || tmp < 0)
    {
        tmp = DEFAULT_MAX_COPY_THRESHOLD;
    }

    g_UlMaxCopyThreshold = tmp;

    tmp = UlReadLongParameter(
                parametersHandle,
                REGISTRY_MAX_BUFFERED_SENDS,
                (LONG)g_UlMaxBufferedSends
                );

    if (tmp > 64 || tmp < 0)
    {
        tmp = DEFAULT_MAX_BUFFERED_SENDS;
    }

    g_UlMaxBufferedSends = tmp;

    tmp = UlReadLongParameter(
                parametersHandle,
                REGISTRY_MAX_BYTES_PER_SEND,
                (LONG)g_UlMaxBytesPerSend
                );

    if (tmp > 0xFFFFF || tmp < 0)
    {
        tmp = DEFAULT_MAX_BYTES_PER_SEND;
    }

    g_UlMaxBytesPerSend = tmp;

    tmp = UlReadLongParameter(
                parametersHandle,
                REGISTRY_MAX_BYTES_PER_READ,
                (LONG)g_UlMaxBytesPerRead
                );

    if (tmp > 0xFFFFF || tmp < 0)
    {
        tmp = DEFAULT_MAX_BYTES_PER_READ;
    }

    g_UlMaxBytesPerRead = tmp;

    tmp = UlReadLongParameter(
                parametersHandle,
                REGISTRY_MAX_PIPELINED_REQUESTS,
                (LONG)g_UlMaxPipelinedRequests
                );

    if (tmp > 1024 || tmp < 0)
    {
        tmp = DEFAULT_MAX_PIPELINED_REQUESTS;
    }

    g_UlMaxPipelinedRequests = tmp;

    g_UlEnableCopySend = (BOOLEAN) UlReadLongParameter(
                                        parametersHandle,
                                        REGISTRY_ENABLE_COPY_SEND,
                                        DEFAULT_ENABLE_COPY_SEND
                                        ) != 0;

    tmp = UlReadLongParameter(
                parametersHandle,
                REGISTRY_CONNECTION_SEND_LIMIT,
                (LONG)g_UlConnectionSendLimit
                );

    if (tmp > (1024 * 1024) || tmp < 0)
    {
        tmp = DEFAULT_CONNECTION_SEND_LIMIT;
    }

    g_UlConnectionSendLimit = tmp;

    tmp64 = UlReadLongLongParameter(
                parametersHandle,
                REGISTRY_GLOBAL_SEND_LIMIT,
                g_UlGlobalSendLimit
                );

    if (tmp64 > (LONGLONG)g_UlTotalNonPagedPoolBytes / 2 ||
        tmp64 < (LONGLONG)g_UlConnectionSendLimit)
    {
        tmp64 = DEFAULT_GLOBAL_SEND_LIMIT;
    }

    g_UlGlobalSendLimit = tmp64;

    tmp = UlReadLongParameter(
                parametersHandle,
                REGISTRY_OPAQUE_ID_TABLE_SIZE,
                (LONG)g_UlOpaqueIdTableSize
                );

    if (tmp > 0xFFFF || tmp <= 0)
    {
        tmp = DEFAULT_OPAQUE_ID_TABLE_SIZE;
    }

    g_UlOpaqueIdTableSize = tmp;

     //
    // MaxInternalUrlLength is a hint for allocating the inline buffer
    // of WCHARs to hold the URL at the end of a UL_INTERNAL_REQUEST.
    // Note: This is not the maximum possible length of a URL received off
    // the wire; that's MaxFieldLength.
    //

    tmp = UlReadLongParameter(
                parametersHandle,
                REGISTRY_MAX_INTERNAL_URL_LENGTH,
                g_UlMaxInternalUrlLength
                );

    //
    // Round up to an even number, as it measures the size in bytes
    // of a WCHAR array
    //
    tmp = (tmp + 1) & ~1;

#define MIN_MAX_INTERNAL_URL_LENGTH (64 * sizeof(WCHAR))
#define MAX_MAX_INTERNAL_URL_LENGTH (MAX_PATH * sizeof(WCHAR))

    tmp = min(tmp, MAX_MAX_INTERNAL_URL_LENGTH);
    tmp = max(tmp, MIN_MAX_INTERNAL_URL_LENGTH);

    ASSERT(MIN_MAX_INTERNAL_URL_LENGTH <= tmp
                &&  tmp <= MAX_MAX_INTERNAL_URL_LENGTH);

    g_UlMaxInternalUrlLength = tmp;

    //
    // MAX allowed field length in HTTP requests, in bytes
    //

    tmp = UlReadLongParameter(
                parametersHandle,
                REGISTRY_MAX_FIELD_LENGTH,
                (LONG)g_UlMaxFieldLength
                );

    // Set a 64KB-2 hard upper limit for each individual header.
    // Note: the length fields in HTTP_KNOWN_HEADER and HTTP_UNKNOWN_HEADER
    // are USHORTs. We have to allow a terminating '\0' in the data
    // we pass up, hence -2.

    tmp = min(tmp, ANSI_STRING_MAX_CHAR_LEN);
    tmp = max(tmp, 64);

    ASSERT(64 <= tmp  &&  tmp <= ANSI_STRING_MAX_CHAR_LEN);

    g_UlMaxFieldLength = tmp;

    //
    // MaxRequestBytes is the total size of all the headers, including
    // the initial verb/URL/version line.
    //

    tmp = UlReadLongParameter(
                parametersHandle,
                REGISTRY_MAX_REQUEST_BYTES,
                g_UlMaxRequestBytes
                );

    // Set a 16MB hard upper limit for all the headers. Don't want to
    // set it bigger than this to minimize Denial of Service attacks.
    // If you really want to send a lot of data, send it in the entity body.

    tmp = min(tmp, (16 * 1024 * 1024));
    tmp = max(tmp, 256);

    ASSERT(256 <= tmp  &&  tmp <= (16 * 1024 * 1024));

    g_UlMaxRequestBytes = tmp;

    // An individual field can't be bigger than the aggregated fields

    if (g_UlMaxRequestBytes < g_UlMaxFieldLength)
    {
        g_UlMaxFieldLength = g_UlMaxRequestBytes;
    }

    tmp = UlReadLongParameter(
                parametersHandle,
                REGISTRY_DISABLE_LOG_BUFFERING,
                (LONG)g_UlDisableLogBuffering
                );

    g_UlDisableLogBuffering = (BOOLEAN) (tmp != 0);
        
    tmp = UlReadLongParameter(
                parametersHandle,
                REGISTRY_LOG_BUFFER_SIZE,
                (LONG)g_UlLogBufferSize
                );

    if (tmp >  MAXIMUM_ALLOWED_LOG_BUFFER_SIZE
        || tmp <  MINIMUM_ALLOWED_LOG_BUFFER_SIZE )
    {
        // Basically this value will be discarted by the logging code
        // instead systems granularity size (64K) will be used.
        tmp = DEFAULT_LOG_BUFFER_SIZE;
    }

    tmp -= tmp % 4096;  // Align down to 4k

    g_UlLogBufferSize = (ULONG) tmp;

    //
    // read the resource lookaside config
    //

    tmp = UlReadLongParameter(
                parametersHandle,
                REGISTRY_RESOURCE_LOOKASIDE_DEPTH,
                (LONG)pConfig->ResourceLookasideDepth
                );

    if (tmp > UL_MAX_SLIST_DEPTH || tmp < 0)
    {
        tmp = DEFAULT_RESOURCE_LOOKASIDE_DEPTH;
    }

    pConfig->ResourceLookasideDepth = (USHORT)tmp;


    tmp = UlReadLongParameter(
                parametersHandle,
                REGISTRY_MAX_REQUESTS_QUEUED,
                g_UlMaxRequestsQueued
                );

    if (tmp > UL_MAX_REQUESTS_QUEUED || tmp < UL_MIN_REQUESTS_QUEUED)
    {
        tmp = DEFAULT_MAX_REQUESTS_QUEUED;
    }

    g_UlMaxRequestsQueued = tmp;

    tmp = UlReadLongParameter(
                parametersHandle,
                REGISTRY_MAX_ZOMBIE_HTTP_CONN_COUNT,
                g_UlMaxZombieHttpConnectionCount
                );

    if (tmp > 0xFFFF || tmp < 0)
    {
        tmp = DEFAULT_MAX_ZOMBIE_HTTP_CONN_COUNT;
    }

    g_UlMaxZombieHttpConnectionCount = tmp;

    //
    // Max UL_CONNECTION override 
    //
    
    tmp = UlReadLongParameter(
                parametersHandle,
                REGISTRY_MAX_CONNECTIONS,
                g_MaxConnections
                );
    
    // Restrict from 1K min to 2M max 
    if (tmp > 0x1F0000 || tmp < 0x400 )
    {
        tmp = HTTP_LIMIT_INFINITE;
    }

    g_MaxConnections = tmp;
    
    tmp = UlReadLongParameter(
                parametersHandle,
                REGISTRY_RCV_BUFFER_SIZE,
                g_UlReceiveBufferSize
                );

    if (tmp > 0xFFFF || tmp < 128)
    {
        tmp = DEFAULT_RCV_BUFFER_SIZE;
    }

    g_UlReceiveBufferSize = ALIGN_UP( tmp, PVOID );

    tmp = UlReadLongParameter(
                parametersHandle,
                REGISTRY_RESP_BUFFER_SIZE,
                g_UlResponseBufferSize
                );

    if (tmp > 0xFFFF || tmp < 128)
    {
        tmp = DEFAULT_RESP_BUFFER_SIZE;
    }

    g_UlResponseBufferSize = tmp;

    ACPCode = UlpReadUrlC14nConfig(parametersHandle);

    //
    // Should we disable the Server: response header?
    //
    
    tmp = UlReadLongParameter(
            parametersHandle,
            REGISTRY_DISABLE_SERVER_HEADER,
            (LONG)g_UlDisableServerHeader
            );

    if (tmp >= 0 && tmp <= 2)
    {
        g_UlDisableServerHeader = (ULONG) tmp;
    }
    

    //
    // Read error logging config.
    //

    UlpReadErrorLogConfig(parametersHandle);
    
    //
    // Read the ComputerName from the Registry.
    //

    wcsncpy(g_UlComputerName, L"<server>", MAX_COMPUTER_NAME_LEN);
    
    status = UlInitUnicodeStringEx( &registryPathComputerName, 
                                    REGISTRY_COMPUTER_NAME_PATH );

    if (NT_SUCCESS(status))
    {
        status = UlOpenRegistry( 
                    &registryPathComputerName, 
                    &computerNameHandle,
                    REGISTRY_COMPUTER_NAME
                    );

        if (NT_SUCCESS(status))
        {
            pInfo = NULL;
            
            status = UlReadGenericParameter(
                        computerNameHandle,
                        REGISTRY_COMPUTER_NAME,
                        &pInfo
                        );

            if (NT_SUCCESS(status))
            {
                ASSERT(pInfo);
                
                if (pInfo->Type == REG_SZ)
                {
                    wcsncpy(g_UlComputerName, 
                            (PWCHAR)pInfo->Data, 
                            MAX_COMPUTER_NAME_LEN
                            );
                    //
                    // Make sure we're NULL terminated.  This will truncate
                    // the name from the registry.
                    //

                    g_UlComputerName[MAX_COMPUTER_NAME_LEN] = L'\0';
                }

                //
                // Free up the returned value.
                //
                
                UL_FREE_POOL( pInfo, UL_REGISTRY_DATA_POOL_TAG );
            }

            ZwClose( computerNameHandle );
        }
    }

    //
    // Read URI Cache parameters
    //

    pConfig->UriConfig.EnableCache = (BOOLEAN) UlReadLongParameter(
                                            parametersHandle,
                                            REGISTRY_CACHE_ENABLED,
                                            DEFAULT_CACHE_ENABLED
                                            ) != 0;

    pConfig->UriConfig.MaxCacheUriCount = UlReadLongParameter(
                                                parametersHandle,
                                                REGISTRY_MAX_CACHE_URI_COUNT,
                                                DEFAULT_MAX_CACHE_URI_COUNT
                                                );

    pConfig->UriConfig.MaxCacheMegabyteCount = UlReadLongParameter(
                                                parametersHandle,
                                                REGISTRY_MAX_CACHE_MEGABYTE_COUNT,
                                                DEFAULT_MAX_CACHE_MEGABYTE_COUNT
                                                );

    tmp = UlReadLongParameter(
            parametersHandle,
            REGISTRY_MAX_URI_BYTES,
            DEFAULT_MAX_URI_BYTES
            );

    if (tmp < (4 * 1024) || tmp > (16 * 1024 * 1024))
    {
        tmp = DEFAULT_MAX_URI_BYTES;
    }

    pConfig->UriConfig.MaxUriBytes = tmp;

    pConfig->UriConfig.ScavengerPeriod = UlReadLongParameter(
                                            parametersHandle,
                                            REGISTRY_CACHE_SCAVENGER_PERIOD,
                                            DEFAULT_CACHE_SCAVENGER_PERIOD
                                            );

    pConfig->UriConfig.HashTableBits = UlReadLongParameter(
                                            parametersHandle,
                                            REGISTRY_HASH_TABLE_BITS,
                                            DEFAULT_HASH_TABLE_BITS
                                            );

#if 0
    pConfig->EnableHttpClient = (BOOLEAN) UlReadLongParameter(
                                            parametersHandle,
                                            REGISTRY_HTTP_CLIENT_ENABLED,
                                            DEFAULT_HTTP_CLIENT_ENABLED
                                            ) != 0;
#endif

    g_HttpClientEnabled = pConfig->EnableHttpClient;

    // 
    // Read list of IP addresses for ListenOnlyList
    //
    pValue = NULL;
    status = UlReadGenericParameter(
                parametersHandle,
                REGISTRY_LISTEN_ONLY_LIST,
                &pValue
                );

    if (NT_SUCCESS(status) && REG_MULTI_SZ == pValue->Type)
    {
        // If UlRegMultiSzToUlAddrArray fails then we simply use
        // the default.
    
        status = UlRegMultiSzToUlAddrArray(
                    (PWSTR)pValue->Data,
                    &g_pTdiListenAddresses,
                    &g_TdiListenAddrCount
                    );

        if ( STATUS_INVALID_PARAMETER == status )
        {
            //
            // Write event log message that ListenOnlyList was found, but 
            // no entries could be converted.
            //
            
            UlWriteEventLogEntry(
                EVENT_HTTP_LISTEN_ONLY_ALL_CONVERT_FAILED,
                0,
                0,
                NULL,
                0,
                NULL
                );
        }
    }

    if ( pValue )
    {
        UL_FREE_POOL( pValue, UL_REGISTRY_DATA_POOL_TAG );
        pValue = NULL;
    }
    
    //
    // Make sure we can always buffer enough bytes for an entire request
    // header.
    //

    g_UlMaxBufferedBytes = MAX(g_UlMaxBufferedBytes, g_UlMaxRequestBytes);

    //
    // Scavenger Config - MB to reclaim each time
    //

    g_UlScavengerTrimMB = UlReadLongParameter(
        parametersHandle,
        REGISTRY_SCAVENGER_TRIM_MB,
        DEFAULT_SCAVENGER_TRIM_MB
        );

    //
    // Dump configuration on checked builds.
    //

#if DBG
    DbgPrint( "Http.sys Configuration:\n" );

    // These settings are only present on checked builds
    DbgPrint( "    g_UlDebug                    = 0x%016I64x\n", g_UlDebug );
    DbgPrint( "    g_UlBreakOnError             = %lu\n", g_UlBreakOnError );
    DbgPrint( "    g_UlVerboseErrors            = %lu\n", g_UlVerboseErrors );

    // These settings are present on all builds
    DbgPrint( "    g_UlComputerName             = %ls\n", g_UlComputerName );
    DbgPrint( "    g_UlIdleConnectionsHighMark  = %lu\n", g_UlIdleConnectionsHighMark );
    DbgPrint( "    g_UlIdleConnectionsLowMark   = %lu\n", g_UlIdleConnectionsLowMark );
    DbgPrint( "    g_UlIdleListTrimmerPeriod    = %lu\n", g_UlIdleListTrimmerPeriod );
    DbgPrint( "    g_UlMaxEndpoints             = %lu\n", g_UlMaxEndpoints );
    DbgPrint( "    g_UlOptForIntrMod            = %lu\n", g_UlOptForIntrMod );
    DbgPrint( "    g_UlEnableNagling            = %lu\n", g_UlEnableNagling );
    DbgPrint( "    g_UlEnableThreadAffinity     = %lu\n", g_UlEnableThreadAffinity );
    DbgPrint( "    g_UlThreadAffinityMask       = 0x%I64x\n", g_UlThreadAffinityMask );
    DbgPrint( "    g_UlMaxCopyThreshold         = %lu\n", g_UlMaxCopyThreshold );
    DbgPrint( "    g_UlMaxBufferedSends         = %lu\n", g_UlMaxBufferedSends );
    DbgPrint( "    g_UlMaxBytesPerSend          = %lu\n", g_UlMaxBytesPerSend );
    DbgPrint( "    g_UlMaxBytesPerRead          = %lu\n", g_UlMaxBytesPerRead );
    DbgPrint( "    g_UlMaxPipelinedRequests     = %lu\n", g_UlMaxPipelinedRequests );
    DbgPrint( "    g_UlEnableCopySend           = %lu\n", g_UlEnableCopySend );
    DbgPrint( "    g_UlConnectionSendLimit      = %lu\n", g_UlConnectionSendLimit );
    DbgPrint( "    g_UlGlobalSendLimit          = %I64u\n", g_UlGlobalSendLimit );
    DbgPrint( "    g_UlOpaqueIdTableSize        = %lu\n", g_UlOpaqueIdTableSize );
    DbgPrint( "    g_UlMaxRequestsQueued        = %lu\n", g_UlMaxRequestsQueued );
    DbgPrint( "    g_UlMaxRequestBytes          = %lu\n", g_UlMaxRequestBytes );
    DbgPrint( "    g_UlReceiveBufferSize        = %lu\n", g_UlReceiveBufferSize );
    DbgPrint( "    g_UlResponseBufferSize       = %lu\n", g_UlResponseBufferSize );
    DbgPrint( "    g_UlMaxFieldLength           = %lu\n", g_UlMaxFieldLength );
    DbgPrint( "    g_MaxConnections             = 0x%lx\n", g_MaxConnections );
    DbgPrint( "    g_UlDisableLogBuffering      = %lu\n", g_UlDisableLogBuffering );
    DbgPrint( "    g_UlLogBufferSize            = %lu\n", g_UlLogBufferSize );

    DbgPrint( "    CodePage                     = %lu\n", ACPCode );
    DbgPrint( "    EnableNonUtf8                = %lu\n", g_UrlC14nConfig.EnableNonUtf8 );
    DbgPrint( "    FavorUtf8                    = %lu\n", g_UrlC14nConfig.FavorUtf8 );
    DbgPrint( "    EnableDbcs                   = %lu\n", g_UrlC14nConfig.EnableDbcs );
    DbgPrint( "    PercentUAllowed              = %lu\n", g_UrlC14nConfig.PercentUAllowed );
    DbgPrint( "    AllowRestrictedChars         = %lu\n", g_UrlC14nConfig.AllowRestrictedChars );
    DbgPrint( "    HostnameDecodeOrder          = 0x%lx\n", g_UrlC14nConfig.HostnameDecodeOrder );
    DbgPrint( "    AbsPathDecodeOrder           = 0x%lx\n", g_UrlC14nConfig.AbsPathDecodeOrder );
    DbgPrint( "    UrlSegmentMaxLength          = %lu\n", g_UrlC14nConfig.UrlSegmentMaxLength );
    DbgPrint( "    UrlSegmentMaxCount           = %lu\n", g_UrlC14nConfig.UrlSegmentMaxCount );

    DbgPrint( "    g_UlMaxInternalUrlLength     = %lu\n", g_UlMaxInternalUrlLength );
    DbgPrint( "    g_UlMaxZombieHttpConnCount   = %lu\n", g_UlMaxZombieHttpConnectionCount );
    DbgPrint( "    g_UlDisableServerHeader      = %lu\n", g_UlDisableServerHeader );

    DbgPrint( "    ThreadsPerCpu                = %lu\n", pConfig->ThreadsPerCpu );
    DbgPrint( "    IrpContextLookasideDepth     = %lu\n", pConfig->IrpContextLookasideDepth );
    DbgPrint( "    ReceiveBufferLookasideDepth  = %lu\n", pConfig->ReceiveBufferLookasideDepth );
    DbgPrint( "    ResourceLookasideDepth       = %lu\n", pConfig->ResourceLookasideDepth );
    DbgPrint( "    RequestBufferLookasideDepth  = %lu\n", pConfig->RequestBufferLookasideDepth );
    DbgPrint( "    IntlRequestLookasideDepth    = %lu\n", pConfig->InternalRequestLookasideDepth );
    DbgPrint( "    ResponseBufferLookasideDepth = %lu\n", pConfig->ResponseBufferLookasideDepth );
    DbgPrint( "    SendTrackerLookasideDepth    = %lu\n", pConfig->SendTrackerLookasideDepth );
    DbgPrint( "    LogFileBufferLookasideDepth  = %lu\n", pConfig->LogFileBufferLookasideDepth );
    DbgPrint( "    LogDataBufferLookasideDepth  = %lu\n", pConfig->LogDataBufferLookasideDepth );
    DbgPrint( "    WriteTrackerLookasideDepth   = %lu\n", pConfig->FilterWriteTrackerLookasideDepth );
    DbgPrint( "    EnableCache                  = %lu\n", pConfig->UriConfig.EnableCache );
    DbgPrint( "    MaxCacheUriCount             = %lu\n", pConfig->UriConfig.MaxCacheUriCount );
    DbgPrint( "    MaxCacheMegabyteCount        = %lu\n", pConfig->UriConfig.MaxCacheMegabyteCount );
    DbgPrint( "    ScavengerPeriod              = %lu\n", pConfig->UriConfig.ScavengerPeriod );
    DbgPrint( "    HashTableBits                = %ld\n", pConfig->UriConfig.HashTableBits);
    DbgPrint( "    MaxUriBytes                  = %lu\n", pConfig->UriConfig.MaxUriBytes );
    DbgPrint( "    ScavengerTrimMB              = %ld\n", g_UlScavengerTrimMB);
#endif  // DBG

    //
    // Cleanup.
    //

    ZwClose( parametersHandle );

}   // UlpReadRegistry


/***************************************************************************++

Routine Description:

    Unload routine called by the IO subsystem when UL is getting
    unloaded.

--***************************************************************************/
VOID
UlpUnload(
    IN PDRIVER_OBJECT DriverObject
    )
{
    UNREFERENCED_PARAMETER(DriverObject);

    //
    // Sanity check.
    //

    PAGED_CODE();
    UL_ENTER_DRIVER("http!UlpUnload", NULL);

#if DBG
    KdPrint(( "UlpUnload called.\n" ));
#endif // DBG

    //
    // Terminate the UL modules.
    //

    UlpTerminateModules();

    //
    // Flush all kernel DPCs to ensure our periodic timer DPCs cannot
    // get called after we unload.
    //

    KeFlushQueuedDpcs();    
    
    UL_LEAVE_DRIVER("UlpUnload");

#if DBG
    //
    // Terminate any debug-specific data after UL_LEAVE_DRIVER
    //

    UlDbgTerminateDebugData( );
#endif  // DBG

#if DBG
    KdPrint(( "\n"
              "------\n"
              "http!UlpUnload finished.\n"
              "------\n" ));
#endif // DBG

}   // UlpUnload


/***************************************************************************++

Routine Description:

    Terminates the various UL modules in the correct order.

--***************************************************************************/
VOID
UlpTerminateModules(
    VOID
    )
{
    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // Wait for endpoints to go away, so we're sure all I/O is done.
    //

    UlWaitForEndpointDrain();

    //
    // Kill Michael.
    //

    UlTerminateDateCache();
    UlTerminateUriCache();
    UlTerminateFilterChannel();

    //
    // Kill Henry.
    //

    TerminateFileCache();

    //
    // Kill Paul.
    //

    UlTerminateCG();
    UlTerminateAP();

    //
    // Kill Keith.
    //

    UlTerminateControlChannel();

    //
    // TerminateLogs Blocks until all Io To Be Complete
    //
    // Note:CG should be terminated before Logs.
    //      Otherwise we won't stop issuing the buffer writes.
    //      ThreadPool should be terminated after Logs.
    //      Otherwise our Completion APCs won't be completed back.
    //

    //
    // Kill ETW Logging
    //
    UlEtwUnRegisterLog( g_pUlControlDeviceObject );

    //
    // Kill Ali
    //

    UlTerminateLogs();
    UlTerminateBinaryLog();
    UlTerminateErrorLog();
    UlTerminateLogUtil();    
    UlTcTerminate();
    UlTerminateHttpConnection();

    //
    // Kill Eric.
    //

    UlTerminateCounters();
    UlTerminateTimeoutMonitor();

    //
    // Kill George.
    //

    UlLargeMemTerminate();

    //
    // Kill TDI.
    //

    UxTerminateTdi();
    UlTerminateTdi();

    //
    // Kill the thread pool.
    //

    UlTerminateThreadPool();


    //
    // Kill the opaque Ids
    //

    UlTerminateOpaqueIdTable();


    //
    // Kill any global data.
    //

    UlTerminateData();

    // 
    // Kill Listen-Only address list
    //
    
    if ( g_pTdiListenAddresses )
    {
        ASSERT( 0 != g_TdiListenAddrCount );
        UlFreeUlAddr( g_pTdiListenAddresses );
    }

    //
    // Kill namespace.
    //

    UlTerminateNamespace();

    //
    // Kill Client.
    //

    if (g_ClientImageHandle)
    {
        //
        // g_ClientImageHandle != NULL  <=> client code was initialized.
        // Call client terminate functions now.
        //

        g_ClientImageHandle = NULL;

        UcTerminateServerInformation();
        UcTerminateClientConnections();

        UcTerminateHttpRequests();
    }
 
    //
    // Delete our device objects.
    //

    if (g_pUlAppPoolDeviceObject != NULL)
    {
        IoDeleteDevice( g_pUlAppPoolDeviceObject );
    }

    if (g_pUlFilterDeviceObject != NULL)
    {
        IoDeleteDevice( g_pUlFilterDeviceObject );
    }

    if (g_pUlControlDeviceObject != NULL)
    {
        IoDeleteDevice( g_pUlControlDeviceObject );
    }

    if (g_pUcServerDeviceObject != NULL)
    {
        IoDeleteDevice( g_pUcServerDeviceObject );
    }

    //
    // Delete the directory container.
    //

    if (g_UlDirectoryObject != NULL)
    {
        ZwClose( g_UlDirectoryObject );
    }

    //
    // Delete the global trace logs.
    //

    DESTROY_REF_TRACE_LOG( g_pEndpointUsageTraceLog, UL_REF_TRACE_LOG_POOL_TAG );
    DESTROY_REF_TRACE_LOG( g_pTdiTraceLog, UL_REF_TRACE_LOG_POOL_TAG );
    DESTROY_REF_TRACE_LOG( g_pHttpRequestTraceLog, UL_REF_TRACE_LOG_POOL_TAG );
    DESTROY_REF_TRACE_LOG( g_pHttpConnectionTraceLog, UL_REF_TRACE_LOG_POOL_TAG );
    DESTROY_REF_TRACE_LOG( g_pHttpResponseTraceLog, UL_REF_TRACE_LOG_POOL_TAG );
    DESTROY_REF_TRACE_LOG( g_pAppPoolTraceLog, UL_REF_TRACE_LOG_POOL_TAG );
    DESTROY_REF_TRACE_LOG( g_pAppPoolProcessTraceLog, UL_REF_TRACE_LOG_POOL_TAG );
    DESTROY_REF_TRACE_LOG( g_pConfigGroupTraceLog, UL_REF_TRACE_LOG_POOL_TAG );
    DESTROY_REF_TRACE_LOG( g_pControlChannelTraceLog, UL_REF_TRACE_LOG_POOL_TAG );    
    DESTROY_REF_TRACE_LOG( g_pThreadTraceLog, UL_REF_TRACE_LOG_POOL_TAG );
    DESTROY_REF_TRACE_LOG( g_pMdlTraceLog, UL_REF_TRACE_LOG_POOL_TAG );
    DESTROY_REF_TRACE_LOG( g_pFilterTraceLog, UL_REF_TRACE_LOG_POOL_TAG );
    DESTROY_REF_TRACE_LOG( g_pUriTraceLog, UL_REF_TRACE_LOG_POOL_TAG );
    DESTROY_IRP_TRACE_LOG( g_pIrpTraceLog );
    DESTROY_TIME_TRACE_LOG( g_pTimeTraceLog );
    DESTROY_APP_POOL_TIME_TRACE_LOG( g_pAppPoolTimeTraceLog );
    DESTROY_REF_TRACE_LOG( g_pSiteCounterTraceLog, UL_REF_TRACE_LOG_POOL_TAG );
    DESTROY_REF_TRACE_LOG( g_pConnectionCountTraceLog, UL_REF_TRACE_LOG_POOL_TAG );
    DESTROY_REF_TRACE_LOG( g_pConfigGroupInfoTraceLog, UL_REF_TRACE_LOG_POOL_TAG );
    DESTROY_REF_TRACE_LOG( g_pChunkTrackerTraceLog, UL_REF_TRACE_LOG_POOL_TAG );
    DESTROY_REF_TRACE_LOG( g_pWorkItemTraceLog, UL_REF_TRACE_LOG_POOL_TAG );
    DESTROY_REF_TRACE_LOG( g_pPoolAllocTraceLog, UL_REF_TRACE_LOG_POOL_TAG );
    DESTROY_REF_TRACE_LOG( g_pMondoGlobalTraceLog, UL_REF_TRACE_LOG_POOL_TAG );

    DESTROY_STRING_LOG( g_pGlobalStringLog );

    DESTROY_UC_TRACE_LOG( g_pUcTraceLog);

}   // UlpTerminateModules
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\irptrace.h ===
/*++

Copyright (c) 1999-2002 Microsoft Corporation

Module Name:

    irptrace.h

Abstract:

    This module contains public declarations and definitions for tracing
    and debugging IRP problems. This module uses the generic TRACE_LOG
    facility in tracelog.h.

Author:

    Keith Moore (keithmo)       10-Aug-1999

Revision History:

--*/


#ifndef _IRPTRACE_H_
#define _IRPTRACE_H_


//
// This defines the entry written to the trace log.
//

#define ENABLE_IRP_CAPTURE  1

#define MAX_CAPTURED_IRP_SIZE                                           \
    (sizeof(IRP) + (DEFAULT_IRP_STACK_SIZE * sizeof(IO_STACK_LOCATION)))

typedef struct _IRP_TRACE_LOG_ENTRY
{
    PIRP pIrp;
    PCSTR pFileName;
    PEPROCESS pProcess;
    PETHREAD pThread;
    PVOID pCaller;
    PVOID pCallersCaller;
    USHORT LineNumber;
    UCHAR Action;
    UCHAR Processor;
#if ENABLE_IRP_CAPTURE
    ULONG CapturedIrp[MAX_CAPTURED_IRP_SIZE / sizeof(ULONG)];
#endif

} IRP_TRACE_LOG_ENTRY, *PIRP_TRACE_LOG_ENTRY;


//
// Action codes.
//
// N.B. These codes must be contiguous, starting at zero. If you update
//      this list, you must also update the corresponding array in
//      ul\ulkd\irp.c.
//

#define IRP_ACTION_INCOMING_IRP                     0
#define IRP_ACTION_ALLOCATE_IRP                     1
#define IRP_ACTION_FREE_IRP                         2
#define IRP_ACTION_CALL_DRIVER                      3
#define IRP_ACTION_COMPLETE_IRP                     4

#define IRP_ACTION_COUNT                            5

#define IRP_TRACE_LOG_SIGNATURE   MAKE_SIGNATURE('IrLg')

//
// Manipulators.
//

PTRACE_LOG
CreateIrpTraceLog(
    IN LONG LogSize,
    IN LONG ExtraBytesInHeader
    );

VOID
DestroyIrpTraceLog(
    IN PTRACE_LOG pLog
    );

VOID
WriteIrpTraceLog(
    IN PTRACE_LOG pLog,
    IN UCHAR Action,
    IN PIRP pIrp,
    IN PCSTR pFileName,
    IN USHORT LineNumber
    );


#if ENABLE_IRP_TRACE

#define CREATE_IRP_TRACE_LOG( ptr, size, extra )                            \
    (ptr) = CreateIrpTraceLog( (size), (extra) )

#define DESTROY_IRP_TRACE_LOG( ptr )                                        \
    do                                                                      \
    {                                                                       \
        DestroyIrpTraceLog( ptr );                                          \
        (ptr) = NULL;                                                       \
    } while (FALSE, FALSE)

#define WRITE_IRP_TRACE_LOG( plog, act, pirp, pfile, line )                 \
    WriteIrpTraceLog(                                                       \
        (plog),                                                             \
        (act),                                                              \
        (pirp),                                                             \
        (pfile),                                                            \
        (line)                                                              \
        )

#else   // !ENABLE_IRP_TRACE

#define CREATE_IRP_TRACE_LOG( ptr, size, extra )            NOP_FUNCTION
#define DESTROY_IRP_TRACE_LOG( ptr )                        NOP_FUNCTION
#define WRITE_IRP_TRACE_LOG( plog, act, ref, pfile, line )  NOP_FUNCTION

#endif  // ENABLE_IRP_TRACE

#define TRACE_IRP( act, pirp )                                              \
    WRITE_IRP_TRACE_LOG(                                                    \
        g_pIrpTraceLog,                                                     \
        (act),                                                              \
        (pirp),                                                             \
        (PVOID)__FILE__,                                                    \
        (USHORT)__LINE__                                                    \
        )


#endif  // _IRPTRACE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\irptrace.c ===
/*++

Copyright (c) 1999-2002 Microsoft Corporation

Module Name:

    irptrace.c

Abstract:

    This module implements an IRP tracing facility.

Author:

    Keith Moore (keithmo)       10-Aug-1999

Revision History:

--*/


#include "precomp.h"


#if !ENABLE_IRP_TRACE

static int g_IrpTraceDummyDeclarationToKeepW4WarningsQuiet;

#else


/***************************************************************************++

Routine Description:

    Creates a new (empty) IRP trace log buffer.

Arguments:

    LogSize - Supplies the number of entries in the log.

    ExtraBytesInHeader - Supplies the number of extra bytes to include
        in the log header. This is useful for adding application-
        specific data to the log.

Return Value:

    PTRACE_LOG - Pointer to the newly created log if successful,
        NULL otherwise.

--***************************************************************************/
PTRACE_LOG
CreateIrpTraceLog(
    IN LONG LogSize,
    IN LONG ExtraBytesInHeader
    )
{
    return CreateTraceLog(
               IRP_TRACE_LOG_SIGNATURE,
               LogSize,
               ExtraBytesInHeader,
               sizeof(IRP_TRACE_LOG_ENTRY),
               TRACELOG_HIGH_PRIORITY,
               UL_REF_TRACE_LOG_POOL_TAG
               );

}   // CreateIrpTraceLog


/***************************************************************************++

Routine Description:

    Destroys an IRP trace log buffer created with CreateIrpTraceLog().

Arguments:

    pLog - Supplies the IRP trace log buffer to destroy.

--***************************************************************************/
VOID
DestroyIrpTraceLog(
    IN PTRACE_LOG pLog
    )
{
    DestroyTraceLog( pLog, UL_REF_TRACE_LOG_POOL_TAG );

}   // DestroyIrpTraceLog


/***************************************************************************++

Routine Description:

    Writes a new entry to the specified IRP trace log.

Arguments:

    pLog - Supplies the log to write to.

    Action - Supplies an action code for the new log entry.

    pIrp - Supplies the IRP for the log entry.

    pFileName - Supplies the filename of the routine writing the log entry.

    LineNumber - Supplies the line number of the routine writing the log
        entry.

--***************************************************************************/
VOID
WriteIrpTraceLog(
    IN PTRACE_LOG pLog,
    IN UCHAR Action,
    IN PIRP pIrp,
    IN PCSTR pFileName,
    IN USHORT LineNumber
    )
{
    IRP_TRACE_LOG_ENTRY entry;
    USHORT irpSize;

    //
    // Initialize the entry.
    //

    RtlGetCallersAddress( &entry.pCaller, &entry.pCallersCaller );

    entry.Action = Action;
    entry.pIrp = pIrp;

    entry.pFileName = pFileName;
    entry.LineNumber = LineNumber;
    entry.Processor = (UCHAR)KeGetCurrentProcessorNumber();
    entry.pProcess = PsGetCurrentProcess();
    entry.pThread = PsGetCurrentThread();

#if ENABLE_IRP_CAPTURE
    irpSize = pIrp->Size;
    if (irpSize > sizeof(entry.CapturedIrp))
    {
        irpSize = sizeof(entry.CapturedIrp);
    }

    RtlCopyMemory( entry.CapturedIrp, pIrp, irpSize );
#endif

    //
    // Write it to the logs.
    //

    WriteTraceLog( pLog, &entry );

}   // WriteIrpTraceLog


#endif  // ENABLE_IRP_TRACE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\largemem.h ===
/*++

Copyright (c) 2000-2002 Microsoft Corporation

Module Name:

    largemem.h

Abstract:

    The public definition of large memory allocator interfaces.

Author:

    George V. Reilly (GeorgeRe)    10-Nov-2000

Revision History:

--*/

#ifndef _LARGEMEM_H_
#define _LARGEMEM_H_


NTSTATUS
UlLargeMemInitialize(
    );

VOID
UlLargeMemTerminate(
    VOID
    );

ULONG
UlLargeMemUsagePercentage(
    VOID
    );

PMDL
UlLargeMemAllocate(
    IN ULONG Length
    );

VOID
UlLargeMemFree(
    IN PMDL pMdl
    );

BOOLEAN
UlLargeMemSetData(
    IN PMDL pMdl,
    IN PUCHAR pBuffer,
    IN ULONG Length,
    IN ULONG Offset
    );


// 2^20 = 1MB
#define MEGABYTE_SHIFT 20
C_ASSERT(PAGE_SHIFT < MEGABYTE_SHIFT);

#define PAGES_TO_MEGABYTES(P)  ((P) >> (MEGABYTE_SHIFT - PAGE_SHIFT))
#define MEGABYTES_TO_PAGES(M)  ((M) << (MEGABYTE_SHIFT - PAGE_SHIFT))
#define MEGABYTES_TO_BYTES(M)  ((M) << (MEGABYTE_SHIFT))


#endif // _LARGEMEM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\mdlutil.h ===
/*++

Copyright (c) 1998-2002 Microsoft Corporation

Module Name:

    mdlutil.h

Abstract:

    This module contains general MDL utilities.

Author:

    Keith Moore (keithmo)       25-Aug-1998

Revision History:

--*/


#ifndef _MDLUTIL_H_
#define _MDLUTIL_H_


ULONG
UlGetMdlChainByteCount(
    IN PMDL pMdlChain
    );

PMDL
UlCloneMdl(
    IN PMDL pMdl,
    IN ULONG MdlLength
    );

PMDL
UlFindLastMdlInChain(
    IN PMDL pMdlChain
    );


#endif  // _MDLUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\largemem.c ===
/*++

Copyright (c) 2000-2002 Microsoft Corporation

Module Name:

    largemem.c

Abstract:

    The implementation of large memory allocator interfaces.

Author:

    George V. Reilly (GeorgeRe)    10-Nov-2000

Revision History:

--*/

#include "precomp.h"
#include "largemem.h"

// Magic constant for use with MmAllocatePagesForMdl
#define LOWEST_USABLE_PHYSICAL_ADDRESS    (16 * 1024 * 1024)

//
// Globals
//

LONG            g_LargeMemInitialized;
volatile SIZE_T g_LargeMemPagesMaxLimit;     //  "   "  pages   "   "    "
volatile ULONG  g_LargeMemPagesCurrent;      // #pages currently used
volatile ULONG  g_LargeMemPagesMaxEverUsed;  // max #pages ever used

#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, UlLargeMemInitialize )
#endif  // ALLOC_PRAGMA

#if 0
NOT PAGEABLE -- UlLargeMemTerminate
#endif


/***************************************************************************++

Routine Description:

    Initialize global state for LargeMem

Arguments:

--***************************************************************************/
NTSTATUS
UlLargeMemInitialize(
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    g_LargeMemPagesCurrent     = 0;
    g_LargeMemPagesMaxEverUsed = 0;

    // Set the upper bound on the amount of memory that we'll ever use

    // Set it to size of physical memory. We wont actually use this much 
    // because the scavenger thread will get a low memory notification and 
    // trim the cache

    g_LargeMemPagesMaxLimit = MEGABYTES_TO_PAGES(g_UlTotalPhysicalMemMB);

    UlTraceVerbose(LARGE_MEM,
            ("Http!UlLargeMemInitialize: "
             "g_UlTotalPhysicalMemMB=%dMB, "
             "\t g_LargeMemPagesMaxLimit=%I64u.\n",
             g_UlTotalPhysicalMemMB,
             g_LargeMemPagesMaxLimit));

    g_LargeMemInitialized = TRUE;

    return Status;

} // UlLargeMemInitialize

/***************************************************************************++

Routine Description:

    Cleanup global state for LargeMem

--***************************************************************************/
VOID
UlLargeMemTerminate(
    VOID
    )
{
    PAGED_CODE();

    ASSERT(0 == g_LargeMemPagesCurrent);

    if (g_LargeMemInitialized)
    {
        //
        // Clear the "initialized" flag. If the memory tuner runs soon,
        // it will see this flag, set the termination event, and exit
        // quickly.
        //

        g_LargeMemInitialized = FALSE;
    }

    UlTraceVerbose(LARGE_MEM,
            ("Http!UlLargeMemTerminate: Memory used: "
             "Current = %d pages = %dMB; MaxEver = %d pages = %dMB.\n",
             g_LargeMemPagesCurrent,
             PAGES_TO_MEGABYTES(g_LargeMemPagesCurrent),
             g_LargeMemPagesMaxEverUsed,
             PAGES_TO_MEGABYTES(g_LargeMemPagesMaxEverUsed)
             ));
} // UlLargeMemTerminate

/***************************************************************************++

Routine Description:

    Allocate a MDL from PAE memory

--***************************************************************************/
PMDL
UlLargeMemAllocate(
    IN ULONG Length
    )
{
    PMDL pMdl;
    PHYSICAL_ADDRESS LowAddress, HighAddress, SkipBytes;
    LONG PrevPagesUsed;
    LONG NewMaxUsed;

    LONG RoundUpBytes = (LONG) ROUND_TO_PAGES(Length);
    LONG NewPages = RoundUpBytes >> PAGE_SHIFT;

    PrevPagesUsed =
        InterlockedExchangeAdd((PLONG) &g_LargeMemPagesCurrent, NewPages);
    
    if (PrevPagesUsed + NewPages > (LONG)g_LargeMemPagesMaxLimit) {

        // overshot g_LargeMemPagesMaxLimit
        UlTrace(LARGE_MEM,
                ("http!UlLargeMemAllocate: "
                 "overshot g_LargeMemPagesMaxLimit=%I64u pages. "
                 "Releasing %d pages\n",
                 g_LargeMemPagesMaxLimit, NewPages
                 ));

        // CODEWORK: This implies that the MRU entries in the cache will
        // be not be cached, which probably leads to poor cache locality.
        // Really ought to free up some LRU cache entries instead.

        //
        // Start the scavenger
        //
        UlSetScavengerLimitEvent();

        // Fail the allocation. The cache miss path will be taken

        InterlockedExchangeAdd((PLONG) &g_LargeMemPagesCurrent, -NewPages);
        return NULL;
    }

    LowAddress.QuadPart  = LOWEST_USABLE_PHYSICAL_ADDRESS;
    HighAddress.QuadPart = 0xfffffffff; // 64GB
    SkipBytes.QuadPart   = 0;

    pMdl = MmAllocatePagesForMdl(
                LowAddress,
                HighAddress,
                SkipBytes,
                RoundUpBytes
                );

    // Completely failed to allocate memory
    if (pMdl == NULL)
    {
        UlTrace(LARGE_MEM,
                ("http!UlLargeMemAllocate: "
                 "Completely failed to allocate %d bytes.\n",
                 RoundUpBytes
                ));

        InterlockedExchangeAdd((PLONG) &g_LargeMemPagesCurrent, -NewPages);
        return NULL;
    }

    // Couldn't allocate all the memory we asked for. We need all the pages
    // we asked for, so we have to set the state of `this' to invalid.
    // Memory is probably really tight.
    if (MmGetMdlByteCount(pMdl) < Length)
    {
        UlTrace(LARGE_MEM,
                ("http!UlLargeMemAllocate: Failed to allocate %d bytes. "
                 "Got %d instead.\n",
                 RoundUpBytes, MmGetMdlByteCount(pMdl)
                ));

        // Free MDL but don't adjust g_LargeMemPagesCurrent downwards
        MmFreePagesFromMdl(pMdl);
        ExFreePool(pMdl);

        InterlockedExchangeAdd((PLONG) &g_LargeMemPagesCurrent, -NewPages);
        return NULL;
    }

    UlTrace(LARGE_MEM,
            ("http!UlLargeMemAllocate: %u->%u, mdl=%p, %d pages.\n",
             Length, pMdl->ByteCount, pMdl, NewPages
            ));

    ASSERT(pMdl->MdlFlags & MDL_PAGES_LOCKED);

    // Hurrah! a successful allocation
    //
    // update g_LargeMemPagesMaxEverUsed in a threadsafe manner
    // using interlocked instructions

    do
    {
        volatile LONG CurrentPages = g_LargeMemPagesCurrent;
        volatile LONG MaxEver      = g_LargeMemPagesMaxEverUsed;

        NewMaxUsed = max(MaxEver, CurrentPages);

        if (NewMaxUsed > MaxEver)
        {
            InterlockedCompareExchange(
                (PLONG) &g_LargeMemPagesMaxEverUsed,
                NewMaxUsed,
                MaxEver
                );
        }

        PAUSE_PROCESSOR;
    } while (NewMaxUsed < (LONG)g_LargeMemPagesCurrent);

    UlTrace(LARGE_MEM,
            ("http!UlLargeMemAllocate: "
             "g_LargeMemPagesCurrent=%d pages. "
             "g_LargeMemPagesMaxEverUsed=%d pages.\n",
             g_LargeMemPagesCurrent, NewMaxUsed
             ));

    WRITE_REF_TRACE_LOG(
        g_pMdlTraceLog,
            REF_ACTION_ALLOCATE_MDL,
        PtrToLong(pMdl->Next),      // bugbug64
        pMdl,
        __FILE__,
        __LINE__
        );

    return pMdl;
} // UlLargeMemAllocate



/***************************************************************************++

Routine Description:

    Free a MDL to PAE memory

--***************************************************************************/
VOID
UlLargeMemFree(
    IN PMDL pMdl
    )
{
    LONG Pages;
    LONG PrevPagesUsed;

    ASSERT(ROUND_TO_PAGES(pMdl->ByteCount) == pMdl->ByteCount);

    Pages = pMdl->ByteCount >> PAGE_SHIFT;

    MmFreePagesFromMdl(pMdl);
    ExFreePool(pMdl);

    PrevPagesUsed
        = InterlockedExchangeAdd(
                    (PLONG) &g_LargeMemPagesCurrent,
                    - Pages);

    ASSERT(PrevPagesUsed >= Pages);
} // UlLargeMemFree

/***************************************************************************++

Routine Description:

    Copy a buffer to the specified MDL starting from Offset.

--***************************************************************************/
BOOLEAN
UlLargeMemSetData(
    IN PMDL pMdl,
    IN PUCHAR pBuffer,
    IN ULONG Length,
    IN ULONG Offset
    )
{
    PUCHAR pSysAddr;

    ASSERT(Offset <= pMdl->ByteCount);
    ASSERT(Length <= (pMdl->ByteCount - Offset));
    ASSERT(pMdl->MdlFlags & MDL_PAGES_LOCKED);

    pSysAddr = (PUCHAR) MmMapLockedPagesSpecifyCache (
                            pMdl,               // MemoryDescriptorList,
                            KernelMode,         // AccessMode,
                            MmCached,           // CacheType,
                            NULL,               // BaseAddress,
                            FALSE,              // BugCheckOnFailure,
                            NormalPagePriority  // Priority
                            );

    if (pSysAddr != NULL)
    {
        __try
        {
            RtlCopyMemory (
                pSysAddr + Offset,
                pBuffer,
                Length
                );
        }
         __except(UL_EXCEPTION_FILTER())
        {
            MmUnmapLockedPages (pSysAddr, pMdl);
            return FALSE;
        }

        MmUnmapLockedPages (pSysAddr, pMdl);
        return TRUE;
    }

    return FALSE;
} // UlLargeMemSetData
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\mdlutil.c ===
/*++

Copyright (c) 1998-2002 Microsoft Corporation

Module Name:

    mdlutil.c

Abstract:

    This module implements general MDL utilities.

Author:

    Keith Moore (keithmo)       25-Aug-1998

Revision History:

--*/


#include "precomp.h"


#ifdef ALLOC_PRAGMA
#endif  // ALLOC_PRAGMA
#if 0
NOT PAGEABLE -- UlGetMdlChainByteCount
NOT PAGEABLE -- UlCloneMdl
NOT PAGEABLE -- UlFindLastMdlInChain
#endif


//
// Public functions.
//

/***************************************************************************++

Routine Description:

    Calculates the total byte length of the specified MDL chain.

Arguments:

    pMdlChain - Supplies the head of the MDL chain to scan.

Return Value:

    ULONG_PTR - The total byte length of the chain.

--***************************************************************************/
ULONG
UlGetMdlChainByteCount(
    IN PMDL pMdlChain
    )
{
    ULONG totalLength;

    //
    // Simply scan through the MDL chain and sum the lengths.
    //

    totalLength = 0;

    do
    {
        totalLength += (ULONG)MmGetMdlByteCount( pMdlChain );
        pMdlChain = pMdlChain->Next;

    } while (pMdlChain != NULL);

    return totalLength;

}   // UlGetMdlChainByteCount


/***************************************************************************++

Routine Description:

    Clones the specified MDL, resulting in a new MDL that describes
    the exact same memory (pages, etc) as the original MDL.

Arguments:

    pMdl - Supplies the MDL to clone.

    MdlLength - Supplies the length of the MDL to clone.

Return Value:

    PMDL - The newly cloned MDL if successful, NULL otherwise.

--***************************************************************************/
PMDL
UlCloneMdl(
    IN PMDL pMdl,
    IN ULONG MdlLength
    )
{
    PMDL pMdlClone;
    PVOID pMdlAddress;

    //
    // Ensure the incoming MDL is of the type we expect (either nonpaged
    // or locked).  For a response that doesn't need to goto the cache entry,
    // there is no need to map the buffer as either the lower layer will map
    // it or some miniport can handle it unmapped.
    //

    ASSERT( pMdl->MdlFlags & (MDL_PAGES_LOCKED | MDL_SOURCE_IS_NONPAGED_POOL) );
    ASSERT( MdlLength > 0 );

    //
    // Snag the virtual address from the MDL. Note a MDL returned from
    // MmAllocatePagesForMdl doesn't have the virtual address set.
    //

    pMdlAddress = MmGetMdlVirtualAddress( pMdl );
    ASSERT( pMdlAddress != NULL || (pMdl->MdlFlags & MDL_PAGES_LOCKED) );

    //
    // Allocate a new MDL, then initialize it with the incoming MDL.
    //

    pMdlClone = UlAllocateMdl(
                    pMdlAddress,            // VirtualAddress
                    MdlLength,              // Length
                    FALSE,                  // SecondaryBuffer
                    FALSE,                  // ChargeQuota
                    NULL                    // Irp
                    );

    if (pMdlClone != NULL)
    {
        IoBuildPartialMdl(
            pMdl,                           // SourceMdl
            pMdlClone,                      // TargetMdl
            pMdlAddress,                    // VirtualAddress
            MdlLength                       // Length
            );
    }

    return pMdlClone;

}   // UlCloneMdl


/***************************************************************************++

Routine Description:

    Finds the last MDL in the specified MDL chain.

Arguments:

    pMdlChain - Supplies the MDL chain to scan.

Return Value:

    PMDL - Pointer to the last MDL in the MDL chain.

--***************************************************************************/
PMDL
UlFindLastMdlInChain(
    IN PMDL pMdlChain
    )
{
    while (pMdlChain->Next != NULL)
    {
        pMdlChain = pMdlChain->Next;
    }

    return pMdlChain;

}   // UlFindLastMdlInChain


//
// Private functions.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\logutil.h ===
/*++

Copyright (c) 2000-2002 Microsoft Corporation

Module Name:

    logutil.h 

Abstract:

    Various utilities for both raw & normal logging.
    
Author:

    Ali E. Turkoglu (aliTu)       05-Oct-2001

Revision History:

    ---
    
--*/

#ifndef _LOGUTIL_H_
#define _LOGUTIL_H_

//
// Forwarders.
//

typedef struct _UL_INTERNAL_REQUEST *PUL_INTERNAL_REQUEST;
typedef struct _UL_URI_CACHE_ENTRY *PUL_URI_CACHE_ENTRY;
typedef struct _HTTP_RAWLOGID *PHTTP_RAWLOGID;

///////////////////////////////////////////////////////////////////////////////
//
// Definitions for the HTTP Logging Modules
//
///////////////////////////////////////////////////////////////////////////////

//
// Some directory name related Macros.
//

#define UL_LOCAL_PATH_PREFIX         (L"\\??\\")
#define UL_LOCAL_PATH_PREFIX_LENGTH  (WCSLEN_LIT(UL_LOCAL_PATH_PREFIX))
#define UL_UNC_PATH_PREFIX           (L"\\dosdevices\\UNC")
#define UL_UNC_PATH_PREFIX_LENGTH    (WCSLEN_LIT(UL_UNC_PATH_PREFIX))

#define UL_SYSTEM_ROOT_PREFIX        (L"\\SystemRoot")
#define UL_SYSTEM_ROOT_PREFIX_LENGTH (WCSLEN_LIT(UL_SYSTEM_ROOT_PREFIX))

#define UL_MAX_PATH_PREFIX_LENGTH    (UL_UNC_PATH_PREFIX_LENGTH)

__inline
ULONG
UlpGetDirNameOffset(
    IN PWSTR  pFullName
    )
{
    if (wcsncmp(pFullName,
                UL_LOCAL_PATH_PREFIX,
                UL_LOCAL_PATH_PREFIX_LENGTH
                ) == 0 )
    {
        return UL_LOCAL_PATH_PREFIX_LENGTH;
    }
    else 
    if(wcsncmp(pFullName,
               UL_UNC_PATH_PREFIX,
               UL_UNC_PATH_PREFIX_LENGTH
               ) == 0 )
    {        
        return UL_UNC_PATH_PREFIX_LENGTH;        
    }
    else
    {
        //
        // Must be an error log file directory, 
        // use the whole string.
        //

        return 0;
    }
}


__inline
PWSTR
UlpGetLastDirOrFile(
    IN PUNICODE_STRING pFullName
    )
{
    PWCHAR pw;

    ASSERT(pFullName != NULL);
    ASSERT(pFullName->Length != 0);
    ASSERT(pFullName->Buffer != NULL);
        
    pw = &pFullName->Buffer[(pFullName->Length/sizeof(WCHAR)) - 1];
        
    while( *pw != UNICODE_NULL && *pw != L'\\' )
    {
        pw--;
    }

    ASSERT(*pw != UNICODE_NULL);
    return pw;
}

//
// Maximum possible log file name length depends on the sequence number.
// Only the size based recycling will produce filenames as long as this.
// u_extend is the biggest one among ansi, binary and error logging file
// names;
//      
//      i.e. "\u_extend1234567890.log"
//

#define UL_MAX_FILE_NAME_SUFFIX_LENGTH      (32)
#define UL_MAX_FILE_NAME_SUFFIX_SIZE        \
            (UL_MAX_FILE_NAME_SUFFIX_LENGTH * sizeof(WCHAR))

C_ASSERT(UL_MAX_FILE_NAME_SUFFIX_LENGTH >                       \
               (                                                \
                    WCSLEN_LIT(L"\\u_extend")                   \
                    +                                           \
                    MAX_ULONG_STR                               \
                    +                                           \
                    WCSLEN_LIT(L".log")                         \
                 ));

//
// Upper limit for the log file directory name will be enforced when WAS
// does the logging configuration for the site. 212 has been picked to 
// give the maximum space to the directoy name w/o violating the MAX_PATH
// after we add the prefix & suffix. Any number higher than this will cause
// the compile time assert to raise.
//

#define UL_MAX_FULL_PATH_DIR_NAME_LENGTH    (212)
#define UL_MAX_FULL_PATH_DIR_NAME_SIZE      (UL_MAX_FULL_PATH_DIR_NAME_LENGTH * sizeof(WCHAR))

C_ASSERT(UL_MAX_FULL_PATH_DIR_NAME_LENGTH <= 
    (MAX_PATH - UL_MAX_PATH_PREFIX_LENGTH - UL_MAX_FILE_NAME_SUFFIX_LENGTH));

//
// The amount of buffer allocated for directory search  query during
// initialization. Pick this big enough to avoid too  many  querries
// 4K provides enough size for 40 something filenames.  Increase  it
// for faster startups with too many sites and/or too many log files
//

#define UL_DIRECTORY_SEARCH_BUFFER_SIZE     (4*1024)

C_ASSERT(UL_DIRECTORY_SEARCH_BUFFER_SIZE >=
          (sizeof(FILE_DIRECTORY_INFORMATION) + UL_MAX_FILE_NAME_SUFFIX_SIZE + sizeof(WCHAR)));

//
// Some macros regarding log field limits.
//
#define MAX_LOG_EXTEND_FIELD_LEN              (4096) 

//
// Method field has its own field limitation.
//
#define MAX_LOG_METHOD_FIELD_LEN              (100)

//
// UserName field has its own field limitation.
//
#define MAX_LOG_USERNAME_FIELD_LEN            (256)

//
// Simple macros to check log format type validity
//

#define IS_VALID_ANSI_LOGGING_TYPE(lt)              \
    ((lt) == HttpLoggingTypeW3C ||                  \
     (lt) == HttpLoggingTypeIIS ||                  \
     (lt) == HttpLoggingTypeNCSA )

#define IS_VALID_BINARY_LOGGING_TYPE(lt)            \
    ((lt) == HttpLoggingTypeRaw)

#define IS_VALID_SELECTIVE_LOGGING_TYPE(lt)         \
    ((lt) == HttpLogAllRequests ||                  \
     (lt) == HttpLogSuccessfulRequests ||           \
     (lt) == HttpLogErrorRequests )

#define IS_VALID_LOGGING_PERIOD(lp)                 \
    ((lp) < HttpLoggingPeriodMaximum)

//
// Even if LocalRollTimeRollover is set there will be one log
// recycle timer which will be aligned properly for the beginning
// of each hour, both for GMT and Local timezones.
//

typedef enum _UL_LOG_TIMER_PERIOD_TYPE
{
    UlLogTimerPeriodNone = 0,
    UlLogTimerPeriodGMT,        
    UlLogTimerPeriodLocal,
    UlLogTimerPeriodBoth,   // When and where GMT & Local are the same
    
    UlLogTimerPeriodMaximum

} UL_LOG_TIMER_PERIOD_TYPE, *PUL_LOG_TIMER_PERIOD_TYPE;

//
// For Log File ReCycling based on Local and/or GMT time.
//

typedef struct _UL_LOG_TIMER
{
    //
    // Timer itself and the corresponding Dpc object.    
    //
    
    KTIMER       Timer;
    KDPC         DpcObject;
    UL_SPIN_LOCK SpinLock;

    //
    // Initially a negative value i.e. -15, 15 minutes to first wakeup
    // once the first wakeup happens then it becomes positive i.e. 4, 
    // that means 4 periods of "DEFAULT_LOG_TIMER_GRANULARITY" until 
    // the next wakeup. 
    //

    UL_LOG_TIMER_PERIOD_TYPE PeriodType;           
    SHORT Period;          

    //
    // Spinlock to protect the following state parameters
    //
    

    BOOLEAN Initialized;
    BOOLEAN Started;
        
} UL_LOG_TIMER, *PUL_LOG_TIMER;

//
// Structure to hold a log file buffer
//

typedef struct _UL_LOG_FILE_BUFFER
{
    //
    // PagedPool
    //

    //
    // This MUST be the first field in the structure. This is the linkage
    // used by the lookaside package for storing entries in the lookaside
    // list.
    //

    SLIST_ENTRY         LookasideEntry;

    //
    // Signature is UL_LOG_FILE_BUFFER_POOL_TAG.
    //

    ULONG               Signature;
    
    //
    // I/O status block for UlpBufferFlushAPC.
    //

    IO_STATUS_BLOCK     IoStatusBlock;

    //
    // Bytes used in the allocated buffered space.
    //

    LONG                BufferUsed;

    //
    // The real buffered space for log records.
    //

    PUCHAR              Buffer;

} UL_LOG_FILE_BUFFER, *PUL_LOG_FILE_BUFFER;

#define IS_VALID_LOG_FILE_BUFFER( entry )                             \
    HAS_VALID_SIGNATURE(entry, UL_LOG_FILE_BUFFER_POOL_TAG)

//
// Following structure is used for two reasons;
// 1. To be able to close the handle on threadpool to avoid
//    attach/detach (to system process) bugchecks.
// 2. To be able to do the defered log file creation. When a
//    a request comes in file entry will allocate a file handle 
//    structure and create/open a file.
//

typedef struct _UL_LOG_FILE_HANDLE
{
    //
    // Signature is UL_LOG_FILE_HANDLE_POOL_TAG.
    //

    ULONG           Signature;

    //
    // To be able to close the file handle on threadpool.
    //

    UL_WORK_ITEM    WorkItem;

    //
    // The open file handle. Note that this handle is only valid
    // in the context of the system process. Therefore we open it
    // with kernel flag set and we close it on our threadpool.
    //

    HANDLE          hFile;
        
} UL_LOG_FILE_HANDLE, *PUL_LOG_FILE_HANDLE;

#define IS_VALID_LOG_FILE_HANDLE( entry )                             \
    HAS_VALID_SIGNATURE(entry, UL_LOG_FILE_HANDLE_POOL_TAG)

//
// Temp Log buffer holds the captured data from user until logging 
// for the request is done. Both Binary & Normal logging uses this
// structure. Sizes are in bytes.
//

#define UL_ANSI_LOG_LINE_BUFFER_SIZE         (4096)

#define UL_BINARY_LOG_LINE_BUFFER_SIZE       (512)

#define UL_ERROR_LOG_BUFFER_SIZE             (768)

typedef struct _UL_BINARY_LOG_DATA
{
    //
    // If the field is captured, its respective pointer points to  its
    // beginning in the external buffer. If field is cached, its id is
    // provided in the same log line buffer.
    //
    
    PUCHAR pUriStem;   
    PHTTP_RAWLOGID pUriStemID;    

    PUCHAR pUriQuery;
    PUCHAR pUserName;

    USHORT UriStemSize;
    USHORT UriQuerySize;
    USHORT UserNameSize;

    UCHAR  Method;
    UCHAR  Version;

} UL_BINARY_LOG_DATA, *PUL_BINARY_LOG_DATA;

typedef struct _UL_STR_LOG_DATA
{
    //
    // Format & Flags for normal (ansi) logging.
    //
    
    HTTP_LOGGING_TYPE Format;

    ULONG  Flags;
    
    //
    // This fields are used to track the format of the partially 
    // stored log line in the below buffer.
    //
    
    USHORT Offset1;
    USHORT Offset2;
    USHORT Offset3;

} UL_STR_LOG_DATA, *PUL_STR_LOG_DATA;

typedef struct _UL_LOG_DATA_BUFFER
{
    //
    // This MUST be the first field in the structure. This is the linkage
    // used by the lookaside package for storing entries in the lookaside
    // list.
    //

    SLIST_ENTRY             LookasideEntry;

    //
    // Signature is UL_BINARY_LOG_DATA_BUFFER_POOL_TAG
    // or UL_ANSI_LOG_DATA_BUFFER_POOL_TAG.
    //

    ULONG                   Signature;


    //
    // A work item, used for queuing to a worker thread.
    //

    UL_WORK_ITEM            WorkItem;

    //
    // Our private pointer to the Internal Request structure to ensure
    // the request will be around around until we are done. Upon send
    // completion we may need to read few fields from request.
    //

    PUL_INTERNAL_REQUEST    pRequest;

    //
    // The total amount of send_response bytes.
    //

    ULONGLONG               BytesTransferred;

    //
    // Status fields captured from user data. They can be overwritten
    // according to the send completion results.
    //

    ULONG                   Win32Status;
    
    USHORT                  ProtocolStatus;

    USHORT                  SubStatus;

    USHORT                  ServerPort;

    union
    {        
        USHORT     Value;
        struct
        {
            USHORT CacheAndSendResponse:1;    // Do not restore back from cache
            USHORT Binary:1;                  // Logging type binary
            USHORT IsFromLookaside:1;         // Destroy carefully
        };
    } Flags;
    
    //
    // Logging Type specific fields, either binary or normal logging.
    //
    
    union 
    {
        UL_STR_LOG_DATA     Str;
        UL_BINARY_LOG_DATA  Binary;
        
    } Data;

    //
    // Length of the buffer. It gets allocated from a lookaside list and
    // could be 512 byte (Binary Log) or 4k (Normal Log) by default.
    // It is allocated at the end of this structure.
    //

    USHORT                  Used;
    USHORT                  Size;    
    PUCHAR                  Line;

} UL_LOG_DATA_BUFFER, *PUL_LOG_DATA_BUFFER;

#define IS_VALID_LOG_DATA_BUFFER( entry )                             \
    ( (entry != NULL) &&                                              \
      ((entry)->Signature == UL_BINARY_LOG_DATA_BUFFER_POOL_TAG) ||   \
      ((entry)->Signature == UL_ANSI_LOG_DATA_BUFFER_POOL_TAG))


#define LOG_UPDATE_WIN32STATUS(pLogData,Status)       \
    do {                                              \
        if (STATUS_SUCCESS != (Status))               \
        {                                             \
            ASSERT((pLogData) != NULL);               \
                                                      \
            (pLogData)->Win32Status = HttpNtStatusToWin32Status(Status); \
        }                                             \
    } while (FALSE, FALSE)

#define LOG_SET_WIN32STATUS(pLogData,Status)      \
    if (pLogData)                                 \
    {                                             \
       (pLogData)->Win32Status = HttpNtStatusToWin32Status(Status); \
    }                                             \
    else                                          \
    {                                             \
        ASSERT(!"Null LogData Pointer !");        \
    }

//
// 64K Default log file buffer.
//

#define DEFAULT_MAX_LOG_BUFFER_SIZE  (0x00010000)

//
// Buffer flush out period in minutes.
//

#define DEFAULT_BUFFER_TIMER_PERIOD_MINUTES  (1)

//
// Maximum allowed idle time for a log entry. After this time 
// its file will automatically be closed. In buffer periods.
//

#define DEFAULT_MAX_FILE_IDLE_TIME           (15)

//
// Maximum allowed sequence number for an existing log file in the 
// log directory.
//

#define MAX_ALLOWED_SEQUENCE_NUMBER          (0xFFFFFF)
 
//
// Ellipsis are used to show that a long event log message was truncated.
// Ellipsis and its size (in bytes including UNICODE_NULL.)
//

#define UL_ELLIPSIS_WSTR L"..."
#define UL_ELLIPSIS_SIZE (sizeof(UL_ELLIPSIS_WSTR))

//
// UlCopyHttpVersion doesn't convert version lengths
// bigger than this.
//

#define UL_HTTP_VERSION_LENGTH  (8)

//
// Cached Date header string.
//

#define DATE_LOG_FIELD_LENGTH   (15)
#define TIME_LOG_FIELD_LENGTH   (8)

typedef struct _UL_LOG_DATE_AND_TIME_CACHE
{

    CHAR           Date[DATE_LOG_FIELD_LENGTH+1];
    ULONG          DateLength;
    CHAR           Time[TIME_LOG_FIELD_LENGTH+1];
    ULONG          TimeLength;

    LARGE_INTEGER  LastSystemTime;

} UL_LOG_DATE_AND_TIME_CACHE, *PUL_LOG_DATE_AND_TIME_CACHE;


///////////////////////////////////////////////////////////////////////////////
//
// Exported function calls
//
///////////////////////////////////////////////////////////////////////////////

NTSTATUS
UlInitializeLogUtil(
    VOID
    );

VOID
UlTerminateLogUtil(
    VOID
    );

NTSTATUS
UlBuildLogDirectory(
    IN      PUNICODE_STRING pSrcDirName,
    IN OUT  PUNICODE_STRING pDstDirName
    );

NTSTATUS
UlRefreshFileName(
    IN  PUNICODE_STRING pDirectory,
    OUT PUNICODE_STRING pFileName,
    OUT PWSTR          *ppShortName
    );

VOID
UlConstructFileName(
    IN      HTTP_LOGGING_PERIOD period,
    IN      PCWSTR              prefix,
    IN      PCWSTR              extension,
    OUT     PUNICODE_STRING     filename,
    IN      PTIME_FIELDS        fields,
    IN      BOOLEAN             Utf8Enabled,
    IN OUT  PULONG              sequenceNu // OPTIONAL
    );

NTSTATUS
UlCreateSafeDirectory(
    IN  PUNICODE_STRING  pDirectoryName,
    OUT PBOOLEAN         pUncShare,
    OUT PBOOLEAN         pACLSupport    
    );

NTSTATUS
UlFlushLogFileBuffer(
    IN OUT PUL_LOG_FILE_BUFFER *ppLogBuffer,
    IN     PUL_LOG_FILE_HANDLE  pLogFile,
    IN     BOOLEAN              WaitForComplete,
       OUT PULONGLONG           pTotalWritten    
    );

VOID
UlpWaitForIoCompletion(
    VOID
    );

VOID
UlpCloseLogFileWorker(
    IN PUL_WORK_ITEM    pWorkItem
    );

VOID
UlCloseLogFile(
    IN OUT PUL_LOG_FILE_HANDLE *ppLogFile
    );

NTSTATUS
UlQueryDirectory(
    IN OUT PUNICODE_STRING pFileName,
    IN OUT PWSTR           pShortName,
    IN     PCWSTR          Prefix,
    IN     PCWSTR          ExtensionPlusDot,
    OUT    PULONG          pSequenceNumber,
    OUT    PULONGLONG      pTotalWritten
    );

ULONGLONG
UlGetLogFileLength(
   IN HANDLE hFile
   );

/***************************************************************************++

Routine Description:

    UlGetMonthDays :

    Shamelessly stolen from IIS 5.1 Logging code and adapted here.

Arguments:

    PTIME_FIELDS        - Current Time Fields

Return Value:

    ULONG  -  Number of days in the month.

--***************************************************************************/

__inline
ULONG
UlGetMonthDays(
    IN  PTIME_FIELDS    pDueTime
    )
{
    ULONG   NumDays = 31;

    if ( (4  == pDueTime->Month) ||     // April
         (6  == pDueTime->Month) ||     // June
         (9  == pDueTime->Month) ||     // September
         (11 == pDueTime->Month)        // November
       )
    {
        NumDays = 30;
    }

    if (2 == pDueTime->Month)           // February
    {
        if ((pDueTime->Year % 4 == 0 &&
             pDueTime->Year % 100 != 0) ||
             pDueTime->Year % 400 == 0 )
        {
            //
            // Leap year
            //
            NumDays = 29;
        }
        else
        {
            NumDays = 28;
        }
    }
    return NumDays;
}

VOID
UlSetLogTimer(
    IN PUL_LOG_TIMER pTimer
    );

VOID
UlSetBufferTimer(
    IN PUL_LOG_TIMER pTimer
    );

NTSTATUS
UlCalculateTimeToExpire(
     PTIME_FIELDS           pDueTime,
     HTTP_LOGGING_PERIOD    LogPeriod,
     PULONG                 pTimeRemaining
     );

__inline
PUL_LOG_DATA_BUFFER
UlReallocLogDataBuffer(
    IN ULONG    LogLineSize,
    IN BOOLEAN  IsBinary
    )
{
    PUL_LOG_DATA_BUFFER pLogDataBuffer = NULL;
    ULONG Tag = UL_ANSI_LOG_DATA_BUFFER_POOL_TAG;
    USHORT BytesNeeded = (USHORT) ALIGN_UP(LogLineSize, PVOID);

    //
    // It should be bigger than the default size for each buffer
    // logging type.
    //

    if (IsBinary)
    {
        Tag = UL_BINARY_LOG_DATA_BUFFER_POOL_TAG;
        ASSERT(LogLineSize > UL_BINARY_LOG_LINE_BUFFER_SIZE);
    }
    else
    {
        ASSERT(LogLineSize > UL_ANSI_LOG_LINE_BUFFER_SIZE);
    }
        
    pLogDataBuffer = 
        UL_ALLOCATE_STRUCT_WITH_SPACE(
            PagedPool,
            UL_LOG_DATA_BUFFER,
            BytesNeeded, 
            Tag
            );

    if (pLogDataBuffer)
    {
        pLogDataBuffer->Signature   = Tag;
        pLogDataBuffer->Used        = 0;
        pLogDataBuffer->Size        = BytesNeeded;
        pLogDataBuffer->Line        = (PUCHAR) (pLogDataBuffer + 1);
        pLogDataBuffer->Flags.Value = 0;
            
        pLogDataBuffer->Flags.IsFromLookaside = 0;

        if (IsBinary)
        {
            pLogDataBuffer->Flags.Binary = 1;                
        }
        
        UlInitializeWorkItem(&pLogDataBuffer->WorkItem);
    }

    return pLogDataBuffer;    
}

VOID
UlDestroyLogDataBufferWorker(
    IN PUL_WORK_ITEM    pWorkItem
    );

/***************************************************************************++

Routine Description:

    Wrapper function to ensure we are not touching to paged-pool allocated
    large log buffer on elevated IRQL. It's important that this function has
    been written with the assumption of Request doesn't go away until we
    properly execute the possible passive worker. This is indeed the case
    because request(with the embedded logdata) has been refcounted up by the
    logdata.

Arguments:

    pLogData   -   The buffer to be destroyed

--***************************************************************************/

__inline
VOID
UlDestroyLogDataBuffer(
    IN PUL_LOG_DATA_BUFFER  pLogData
    )
{
    //
    // Sanity check
    //

    ASSERT(pLogData);

    //
    // If we are running on elevated IRQL and large log line allocated
    // then queue a passive worker otherwise complete inline.
    //

    if (!pLogData->Flags.IsFromLookaside)
    {
        UL_CALL_PASSIVE( &pLogData->WorkItem,
                           &UlDestroyLogDataBufferWorker );
    }
    else
    {
        UlDestroyLogDataBufferWorker( &pLogData->WorkItem );
    }
}

VOID
UlProbeLogData(
    IN PHTTP_LOG_FIELDS_DATA pLogData,
    IN KPROCESSOR_MODE       RequestorMode
    );

__inline
NTSTATUS
UlCopyLogFileDir(
    IN OUT PUNICODE_STRING  pOldDir,
    IN     PUNICODE_STRING  pNewDir
    )
{
    PWSTR pNewBuffer = NULL;
    
    ASSERT(pOldDir);
    ASSERT(pNewDir);

    pNewBuffer = 
        (PWSTR) UL_ALLOCATE_ARRAY(
                    PagedPool,
                    UCHAR,
                    pNewDir->MaximumLength,
                    UL_CG_LOGDIR_POOL_TAG
                    );
    if(pNewBuffer == NULL)
    {
        return STATUS_NO_MEMORY;
    }

    if (pOldDir->Buffer != NULL)
    {
        UL_FREE_POOL(pOldDir->Buffer,UL_CG_LOGDIR_POOL_TAG);
    }

    pOldDir->Buffer = pNewBuffer;
        
    RtlCopyMemory(
        pOldDir->Buffer,
        pNewDir->Buffer,
        pNewDir->MaximumLength
        );

    pOldDir->Length  = pNewDir->Length;
    pOldDir->MaximumLength = pNewDir->MaximumLength;

    return STATUS_SUCCESS;    
}

NTSTATUS
UlCheckLogDirectory(
    IN  PUNICODE_STRING pDirName
    );

NTSTATUS
UlpCheckLogDirectory(
    IN PVOID   pContext
    );

BOOLEAN
UlUpdateLogTruncateSize(
    IN     ULONG          NewTruncateSize,
    IN OUT PULONG         pCurrentTruncateSize,  
    IN OUT PULONG         pEntryTruncateSize,
    IN     ULARGE_INTEGER EntryTotalWritten
    );

ULONG
UlpInitializeLogBufferGranularity();

#define HTTP_MAX_EVENT_LOG_DATA_SIZE \
   ((ERROR_LOG_MAXIMUM_SIZE - sizeof(IO_ERROR_LOG_PACKET) + sizeof(ULONG)) & ~3)

NTSTATUS
UlWriteEventLogEntry(
    IN  NTSTATUS                EventCode,
    IN  ULONG                   UniqueEventValue,
    IN  USHORT                  NumStrings,
    IN  PWSTR *                 pStringArray    OPTIONAL,
    IN  ULONG                   DataSize,
    IN  PVOID                   Data            OPTIONAL
    );

//
// Sanity check.  An event log entry must be able to hold the ellipsis string
// and NTSTATUS error code.  UlEventLogOneString() depends on this condition.
//

C_ASSERT(HTTP_MAX_EVENT_LOG_DATA_SIZE >= UL_ELLIPSIS_SIZE + sizeof(NTSTATUS));

NTSTATUS
UlEventLogOneStringEntry(
    IN NTSTATUS EventCode,
    IN PWSTR    pMessage,
    IN BOOLEAN  WriteErrorCode,
    IN NTSTATUS ErrorCode       OPTIONAL
    );

//
// Following structure is used for distinguishing the event log entry
// based on the type of logging issuing the create failure.
//

typedef enum _UL_LOG_EVENT_LOG_TYPE
{
    UlEventLogNormal,
    UlEventLogBinary,        
    UlEventLogError,
    
    UlEventLogMaximum

} UL_LOG_EVENT_LOG_TYPE, *PUL_LOG_EVENT_LOG_TYPE;

NTSTATUS
UlEventLogCreateFailure(
    IN NTSTATUS                Failure,
    IN UL_LOG_EVENT_LOG_TYPE   LoggingType,
    IN PUNICODE_STRING         pFullName,
    IN ULONG                   SiteId
    );

NTSTATUS
UlBuildSecurityToLogFile(
    OUT PSECURITY_DESCRIPTOR  pSecurityDescriptor,
    IN  PSID                  pSid        
    );

NTSTATUS
UlQueryLogFileSecurity(
    IN HANDLE            hFile,
    IN BOOLEAN           UncShare,
    IN BOOLEAN           Opened
    );

//
// Normally when the log file is created by  http.sys the  owner
// will be the admin alias "SeAliasAdminsSid". However when  the
// log files is created on a UNC share following macro will fail
// even though it is created by http.sys on a different  machine
// in that case the owner will be DOMAIN\ServerName. 
//

#define IS_VALID_OWNER(Owner)                       \
        (RtlEqualSid((Owner),                       \
                    SeExports->SeLocalSystemSid     \
                    ) ||                            \
         RtlEqualSid((Owner),                       \
                    SeExports->SeAliasAdminsSid     \
                    ))

//
// Used for queueing buffer flushes. Passed into 
// to the worker below as a context.
//

typedef struct _LOG_IO_FLUSH_OBJ
{
    PUL_LOG_FILE_HANDLE  pLogFile;
    PUL_LOG_FILE_BUFFER  pLogBuffer;

} LOG_IO_FLUSH_OBJ, *PLOG_IO_FLUSH_OBJ;

NTSTATUS
UlpFlushLogFileBufferWorker(
    IN PVOID pContext
    );

//
// Types and API for queueing logging I/O for 
// passive execution under threadpool.
//

typedef
NTSTATUS
(*PUL_LOG_IO_ROUTINE)(
    IN PVOID pContext
    );

typedef struct _LOG_IO_SYNC_OBJ 
{
    //
    // Pointer to log file entry or directory name
    //

    PVOID               pContext;

    //
    // Handler for the above context.
    //

    PUL_LOG_IO_ROUTINE  pHandler;
    
    //
    // For queueing to the high priority.
    //
    
    UL_WORK_ITEM        WorkItem;

    //
    // Used for wait until handler is done.
    //
    
    KEVENT              Event;

    //
    // Result of the handler's work.
    //

    NTSTATUS            Status;
    
} LOG_IO_SYNC_OBJ, *PLOG_IO_SYNC_OBJ;

NTSTATUS
UlQueueLoggingRoutine(
    IN PVOID              pContext, 
    IN PUL_LOG_IO_ROUTINE pHandler 
    );

VOID
UlpQueueLoggingRoutineWorker(
    IN PUL_WORK_ITEM   pWorkItem
    );

VOID
UlpInitializeLogCache(
    VOID
    );

VOID
UlpGenerateDateAndTimeFields(
    IN  HTTP_LOGGING_TYPE   LogType,
    IN  LARGE_INTEGER       CurrentTime,
    OUT PCHAR               pDate,
    OUT PULONG              pDateLength,
    OUT PCHAR               pTime,
    OUT PULONG              pTimeLength
    );

VOID
UlGetDateTimeFields(
    IN  HTTP_LOGGING_TYPE LogType,
    OUT PCHAR  pDate,
    OUT PULONG pDateLength,
    OUT PCHAR  pTime,
    OUT PULONG pTimeLength
    );

/***************************************************************************++

Routine Description:

    For a given HTTP_VERSION this function will build a version string in 
    the provided log data buffer, at exactly UL_HTTP_VERSION_LENGTH.
    
Arguments:

    psz: Pointer to log data buffer. Enough space is assumed to be allocated.
    version: To be converted to string.
    chSeparator
    
Returns:

    the pointer to the log data buffer after the separator.
    
--***************************************************************************/

__inline
PCHAR
UlCopyHttpVersion(
    IN OUT PCHAR psz,
    IN HTTP_VERSION version,
    IN CHAR chSeparator    
    )
{
    //
    // Do the fast lookup first
    //
    
    if (HTTP_EQUAL_VERSION(version, 1, 1))
    {
        psz = UlStrPrintStr(psz, "HTTP/1.1", chSeparator);    
    }
    else if (HTTP_EQUAL_VERSION(version, 1, 0))
    {
        psz = UlStrPrintStr(psz, "HTTP/1.0", chSeparator);    
    }
    else if (HTTP_EQUAL_VERSION(version, 0, 9))
    {
        psz = UlStrPrintStr(psz, "HTTP/0.9", chSeparator);    
    }
    else
    {    
        //
        // Otherwise string convert but do not exceed the deafult size of
        // UL_HTTP_VERSION_LENGTH.
        //

        if (version.MajorVersion < 10 &&
            version.MinorVersion < 10)
        {
            psz = UlStrPrintStr(
                        psz, 
                        "HTTP/", 
                (CHAR) (version.MajorVersion + '0')
                        );

            *psz++ = '.';
            *psz++ = (CHAR) (version.MinorVersion + '0');
            *psz++ = chSeparator;
        }
        else
        {
            psz = UlStrPrintStr(psz, "HTTP/?.?", chSeparator);
        }
    }

    return psz;
}

#if DBG

NTSTATUS
UlValidateLogFileOwner(
    IN HANDLE hFile
    );

__inline
VOID
UlpTraceOwnerDetails(
    PSID    Owner,
    BOOLEAN OwnerDefaulted
    )
{
    NTSTATUS Status;
    UNICODE_STRING OwnerSID;

    ASSERT(RtlValidSid(Owner));

    Status = 
        RtlConvertSidToUnicodeString(
            &OwnerSID,
            Owner,
            TRUE
            );

    if (NT_SUCCESS(Status))
    {    
        UlTrace2Either(BINARY_LOGGING, LOGGING,
            ("Http!UlpTraceOwnerDetails: "
             "handle owned by <%s> OwnerDefaulted <%s>\n"
             "SID -> <%S>\n\n",
             
              RtlEqualSid(
                Owner,
                SeExports->SeLocalSystemSid) ? "System" :
              RtlEqualSid(
                Owner,
                SeExports->SeAliasAdminsSid) ? "Admin"  : "Other",
                                                
              OwnerDefaulted == TRUE         ? "Yes"    : "No",
              
              OwnerSID.Buffer
              ));

        RtlFreeUnicodeString(&OwnerSID);    
    }    
}

#define TRACE_LOG_FILE_OWNER(Owner,OwnerDefaulted)           \
    IF_DEBUG2EITHER(LOGGING,BINARY_LOGGING)                  \
    {                                                        \
        UlpTraceOwnerDetails((Owner),(OwnerDefaulted));      \
    }

#else 

#define TRACE_LOG_FILE_OWNER(Owner,OwnerDefaulted)          NOP_FUNCTION

#endif // DBG

USHORT
UlComputeCachedLogDataLength(
    IN PUL_LOG_DATA_BUFFER  pLogData
    );

VOID
UlCopyCachedLogData(
    IN PUL_LOG_DATA_BUFFER  pLogData,
    IN USHORT               LogDataLength,
    IN PUL_URI_CACHE_ENTRY  pEntry
    );

NTSTATUS
UlQueryAttributeInfo(
    IN  HANDLE   hFile,
    OUT PBOOLEAN pSupportsPersistentACL
    );

NTSTATUS
UlCreateLogFile(
    IN  PUNICODE_STRING   pFileName,
    IN  BOOLEAN           UncShare,
    IN  BOOLEAN           ACLSupport,
    OUT PHANDLE           pFileHandle
    );

BOOLEAN
UlIsValidLogDirectory(
    IN PUNICODE_STRING    pDir,
    IN BOOLEAN            UncSupported,
    IN BOOLEAN            SystemRootSupported
    );

NTSTATUS
UlCheckLoggingConfig(
    IN PHTTP_CONTROL_CHANNEL_BINARY_LOGGING pBinaryConfig,
    IN PHTTP_CONFIG_GROUP_LOGGING           pAnsiConfig
    );

#endif  // _LOGUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\misc.c ===
/*++

Copyright (c) 1998-2002 Microsoft Corporation

Module Name:

    misc.c

Abstract:

    This module contains the miscellaneous UL routines.

Author:

    Keith Moore (keithmo)       10-Jun-1998

Revision History:

--*/


#include "precomp.h"
#include "miscp.h"


//
// Binary <--> Base64 Conversion Tables.
//

DECLSPEC_ALIGN(UL_CACHE_LINE) UCHAR   BinaryToBase64Table[64] =
{
//  0    1    2    3    4    5    6    7
   'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H',
   'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
   'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
   'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',
   'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',
   'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
   'w', 'x', 'y', 'z', '0', '1', '2', '3',
   '4', '5', '6', '7', '8', '9', '+', '/'
};

DECLSPEC_ALIGN(UL_CACHE_LINE) UCHAR   Base64ToBinaryTable[256];


const static char hexArray[] = "0123456789ABCDEF";


#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, UlOpenRegistry )
#pragma alloc_text( PAGE, UlReadLongParameter )
#pragma alloc_text( PAGE, UlReadLongLongParameter )
#pragma alloc_text( PAGE, UlReadGenericParameter )
#pragma alloc_text( PAGE, UlIssueDeviceControl )
#endif  // ALLOC_PRAGMA

#if 0
NOT PAGEABLE -- UlBuildDeviceControlIrp
NOT PAGEABLE -- UlULongLongToAscii
NOT PAGEABLE -- UlpRestartDeviceControl
NOT PAGEABLE -- UlAllocateReceiveBuffer
NOT PAGEABLE -- UlAllocateReceiveBufferPool
NOT PAGEABLE -- UlFreeReceiveBufferPool
NOT PAGEABLE -- UlAllocateIrpContextPool
NOT PAGEABLE -- UlFreeIrpContextPool
NOT PAGEABLE -- UlAllocateRequestBufferPool
NOT PAGEABLE -- UlFreeRequestBufferPool
NOT PAGEABLE -- UlAllocateInternalRequestPool
NOT PAGEABLE -- UlFreeInternalRequestPool
NOT PAGEABLE -- UlAllocateChunkTrackerPool
NOT PAGEABLE -- UlFreeChunkTrackerPool
NOT PAGEABLE -- UlAllocateFullTrackerPool
NOT PAGEABLE -- UlFreeFullTrackerPool
NOT PAGEABLE -- UlAllocateResponseBufferPool
NOT PAGEABLE -- UlFreeResponseBufferPool
NOT PAGEABLE -- UlAllocateLogFileBufferPool
NOT PAGEABLE -- UlFreeLogFileBufferPool
NOT PAGEABLE -- UlAllocateLogDataBufferPool
NOT PAGEABLE -- UlFreeLogDataBufferPool
NOT PAGEABLE -- UlAllocateErrorLogBufferPool
NOT PAGEABLE -- UlFreeErrorLogBufferPool

NOT PAGEABLE -- UlUlInterlockedIncrement64
NOT PAGEABLE -- UlUlInterlockedDecrement64
NOT PAGEABLE -- UlUlInterlockedAdd64
NOT PAGEABLE -- UlUlInterlockedExchange64

NOT PAGEABLE -- TwoDigitsToUnicode
NOT PAGEABLE -- TimeFieldsToHttpDate
NOT PAGEABLE -- AsciiToShort
NOT PAGEABLE -- TwoAsciisToShort
NOT PAGEABLE -- NumericToAsciiMonth
NOT PAGEABLE -- StringTimeToSystemTime
#endif


//
// Public functions.
//

/***************************************************************************++

Routine Description:

    Opens a handle to the UL's Parameters registry key.

Arguments:

    BaseName - Supplies the name of the parent registry key containing
        the Parameters key.

    ParametersHandle - Returns a handle to the Parameters key.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlOpenRegistry(
    IN PUNICODE_STRING BaseName,
    OUT PHANDLE ParametersHandle,
    IN PWSTR OptionalParameterString    
    )
{
    HANDLE configHandle;
    NTSTATUS status;
    PWSTR parametersString = REGISTRY_PARAMETERS;
    UNICODE_STRING parametersKeyName;
    OBJECT_ATTRIBUTES objectAttributes;

    //
    // Sanity check.
    //

    PAGED_CODE();

    if (OptionalParameterString)
    {
        parametersString = OptionalParameterString;
    }

    //
    // Open the registry for the initial string.
    //

    InitializeObjectAttributes(
        &objectAttributes,                      // ObjectAttributes
        BaseName,                               // ObjectName
        OBJ_CASE_INSENSITIVE |                  // Attributes
            OBJ_KERNEL_HANDLE,
        NULL,                                   // RootDirectory
        NULL                                    // SecurityDescriptor
        );

    status = ZwOpenKey( &configHandle, KEY_READ, &objectAttributes );

    if (!NT_SUCCESS(status))
    {
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Now open the parameters key.
    //

    status = UlInitUnicodeStringEx( &parametersKeyName, parametersString );

    if ( NT_SUCCESS(status) )
    {
        InitializeObjectAttributes(
            &objectAttributes,                      // ObjectAttributes
            &parametersKeyName,                     // ObjectName
            OBJ_CASE_INSENSITIVE,                   // Attributes
            configHandle,                           // RootDirectory
            NULL                                    // SecurityDescriptor
            );

        status = ZwOpenKey( ParametersHandle, KEY_READ, &objectAttributes );
    }

    ZwClose( configHandle );

    return status;

}   // UlOpenRegistry


/***************************************************************************++

Routine Description:

    Reads a single (LONG/ULONG) value from the registry.

Arguments:

    ParametersHandle - Supplies an open registry handle.

    ValueName - Supplies the name of the value to read.

    DefaultValue - Supplies the default value.

Return Value:

    LONG - The value read from the registry or the default if the
        registry data was unavailable or incorrect.

--***************************************************************************/
LONG
UlReadLongParameter(
    IN HANDLE ParametersHandle,
    IN PWCHAR ValueName,
    IN LONG DefaultValue
    )
{
    PKEY_VALUE_PARTIAL_INFORMATION information = { 0 };
    UNICODE_STRING valueKeyName;
    ULONG informationLength;
    LONG returnValue;
    NTSTATUS status;
    UCHAR buffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(LONG)];

    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // Build the value name, read it from the registry.
    //

    status = UlInitUnicodeStringEx(
                &valueKeyName,
                ValueName
                );

    if ( NT_SUCCESS(status) )
    {
        information = (PKEY_VALUE_PARTIAL_INFORMATION)buffer;

        status = ZwQueryValueKey(
                     ParametersHandle,
                     &valueKeyName,
                     KeyValuePartialInformation,
                     (PVOID)information,
                     sizeof(buffer),
                     &informationLength
                     );
    }

    //
    // If the read succeeded, the type is DWORD and the length is
    // sane, use it. Otherwise, use the default.
    //

    if (status == STATUS_SUCCESS &&
        information->Type == REG_DWORD &&
        information->DataLength == sizeof(returnValue))
    {
        RtlMoveMemory( &returnValue, information->Data, sizeof(returnValue) );
    } 
    else 
    {
        returnValue = DefaultValue;
    }

    return returnValue;

}   // UlReadLongParameter


/***************************************************************************++

Routine Description:

    Reads a single (LONGLONG/ULONGLONG) value from the registry.

Arguments:

    ParametersHandle - Supplies an open registry handle.

    ValueName - Supplies the name of the value to read.

    DefaultValue - Supplies the default value.

Return Value:

    LONGLONG - The value read from the registry or the default if the
        registry data was unavailable or incorrect.

--***************************************************************************/
LONGLONG
UlReadLongLongParameter(
    IN HANDLE ParametersHandle,
    IN PWCHAR ValueName,
    IN LONGLONG DefaultValue
    )
{
    PKEY_VALUE_PARTIAL_INFORMATION information = { 0 };
    UNICODE_STRING valueKeyName;
    ULONG informationLength;
    LONGLONG returnValue;
    NTSTATUS status;
    UCHAR buffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(LONGLONG)];

    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // Build the value name, read it from the registry.
    //

    status = UlInitUnicodeStringEx(
                &valueKeyName,
                ValueName
                );

    if ( NT_SUCCESS(status) )
    {
        information = (PKEY_VALUE_PARTIAL_INFORMATION)buffer;

        status = ZwQueryValueKey(
                     ParametersHandle,
                     &valueKeyName,
                     KeyValuePartialInformation,
                     (PVOID)information,
                     sizeof(buffer),
                     &informationLength
                     );
    }

    //
    // If the read succeeded, the type is DWORD and the length is
    // sane, use it. Otherwise, use the default.
    //

    if (status == STATUS_SUCCESS &&
        information->Type == REG_QWORD &&
        information->DataLength == sizeof(returnValue))
    {
        RtlMoveMemory( &returnValue, information->Data, sizeof(returnValue) );
    } 
    else 
    {
        returnValue = DefaultValue;
    }

    return returnValue;

}   // UlReadLongLongParameter


/***************************************************************************++

Routine Description:

    Reads a single free-form value from the registry.

Arguments:

    ParametersHandle - Supplies an open registry handle.

    ValueName - Supplies the name of the value to read.

    Value - Receives the value read from the registry.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlReadGenericParameter(
    IN HANDLE ParametersHandle,
    IN PWCHAR ValueName,
    OUT PKEY_VALUE_PARTIAL_INFORMATION * Value
    )
{

    KEY_VALUE_PARTIAL_INFORMATION partialInfo;
    UNICODE_STRING valueKeyName;
    ULONG informationLength;
    NTSTATUS status;
    PKEY_VALUE_PARTIAL_INFORMATION newValue;
    ULONG dataLength;

    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // Build the value name, then perform an initial read. The read
    // should fail with buffer overflow, but that's OK. We just want
    // to get the length of the data.
    //

    status = UlInitUnicodeStringEx( &valueKeyName, ValueName );

    if ( NT_ERROR(status) )
    {
        return status;
    }
    
    status = ZwQueryValueKey(
                 ParametersHandle,
                 &valueKeyName,
                 KeyValuePartialInformation,
                 (PVOID)&partialInfo,
                 sizeof(partialInfo),
                 &informationLength
                 );

    if (NT_ERROR(status))
    {
        return status;
    }

    //
    // Determine the data length. Ensure that strings and multi-sz get
    // properly terminated.
    //

    dataLength = partialInfo.DataLength - 1;

    if (partialInfo.Type == REG_SZ || partialInfo.Type == REG_EXPAND_SZ)
    {
        dataLength += 1;
    }

    if (partialInfo.Type == REG_MULTI_SZ)
    {
        dataLength += 2;
    }

    //
    // Allocate the buffer.
    //

    newValue = UL_ALLOCATE_STRUCT_WITH_SPACE(
                    PagedPool,
                    KEY_VALUE_PARTIAL_INFORMATION,
                    dataLength,
                    UL_REGISTRY_DATA_POOL_TAG
                   );

    if (newValue == NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // update the actually allocated length for later use
    //

    dataLength += sizeof(KEY_VALUE_PARTIAL_INFORMATION);

    RtlZeroMemory( newValue, dataLength );

    //
    // Perform the actual read.
    //

    status = ZwQueryValueKey(
                 ParametersHandle,
                 &valueKeyName,
                 KeyValuePartialInformation,
                 (PVOID)(newValue),
                 dataLength,
                 &informationLength
                 );

    if (NT_SUCCESS(status))
    {
        *Value = newValue;
    }
    else
    {
        UL_FREE_POOL( newValue, UL_REGISTRY_DATA_POOL_TAG );
    }

    return status;

}   // UlReadGenericParameter


/***************************************************************************++

Routine Description:

    Builds a properly formatted device control IRP.

Arguments:

    Irp - Supplies the IRP to format.

    IoControlCode - Supplies the device IO control code.

    InputBuffer - Supplies the input buffer.

    InputBufferLength - Supplies the length of InputBuffer.

    OutputBuffer - Supplies the output buffer.

    OutputBufferLength - Supplies the length of OutputBuffer.

    MdlAddress - Supplies a MDL to attach to the IRP. This is assumed to
        be a non-paged MDL.

    FileObject - Supplies the file object for the target driver.

    DeviceObject - Supplies the correct device object for the target
        driver.

    IoStatusBlock - Receives the final completion status of the request.

    CompletionRoutine - Supplies a pointer to a completion routine to
        call after the request completes. This will only be called if
        this routine returns STATUS_PENDING.

    CompletionContext - Supplies an uninterpreted context value passed
        to the completion routine.

    TargetThread - Optionally supplies a target thread for the IRP. If
        this value is NULL, then the current thread is used.

--***************************************************************************/
VOID
UlBuildDeviceControlIrp(
    IN OUT PIRP Irp,
    IN ULONG IoControlCode,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    IN PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN PMDL MdlAddress,
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIO_STATUS_BLOCK IoStatusBlock,
    IN PIO_COMPLETION_ROUTINE CompletionRoutine,
    IN PVOID CompletionContext,
    IN PETHREAD TargetThread OPTIONAL
    )
{
    PIO_STACK_LOCATION irpSp;

    //
    // Sanity check.
    //

    ASSERT( Irp != NULL );
    ASSERT( FileObject != NULL );
    ASSERT( DeviceObject != NULL );

    //
    // Fill in the service independent parameters in the IRP.
    //

    Irp->Flags = 0;
    Irp->RequestorMode = KernelMode;
    Irp->PendingReturned = FALSE;

    Irp->UserIosb = IoStatusBlock;
    Irp->UserEvent = NULL;

    Irp->AssociatedIrp.SystemBuffer = InputBuffer ? InputBuffer : OutputBuffer;
    Irp->UserBuffer = OutputBuffer;
    Irp->MdlAddress = MdlAddress;

    Irp->Overlay.AsynchronousParameters.UserApcRoutine = NULL;

    Irp->Tail.Overlay.Thread = TargetThread ? TargetThread : PsGetCurrentThread();
    Irp->Tail.Overlay.OriginalFileObject = FileObject;
    Irp->Tail.Overlay.AuxiliaryBuffer = NULL;

    //
    // Put the file object pointer in the stack location.
    //

    irpSp = IoGetNextIrpStackLocation( Irp );
    irpSp->FileObject = FileObject;
    irpSp->DeviceObject = DeviceObject;

    //
    // Fill in the service dependent parameters in the IRP stack.
    //

    irpSp->Parameters.DeviceIoControl.IoControlCode = IoControlCode;
    irpSp->Parameters.DeviceIoControl.InputBufferLength = InputBufferLength;
    irpSp->Parameters.DeviceIoControl.OutputBufferLength = OutputBufferLength;
    irpSp->Parameters.DeviceIoControl.Type3InputBuffer = InputBuffer;

    irpSp->MajorFunction = IRP_MJ_DEVICE_CONTROL;
    irpSp->MinorFunction = 0;

    //
    // Set the completion routine appropriately.
    //

    if (CompletionRoutine == NULL)
    {
        IoSetCompletionRoutine(
            Irp,
            NULL,
            NULL,
            FALSE,
            FALSE,
            FALSE
            );
    }
    else
    {
        IoSetCompletionRoutine(
            Irp,
            CompletionRoutine,
            CompletionContext,
            TRUE,
            TRUE,
            TRUE
            );
    }

}   // UlBuildDeviceControlIrp


/***************************************************************************++

Routine Description:

    Converts the given ULONGLLONG to an ASCII representation and stores it
    in the given string.

Arguments:

    String - Receives the ASCII representation of the ULONGLONG.

    Value - Supplies the ULONGLONG to convert.

Return Value:

    PSTR - Pointer to the next character in String *after* the converted
        ULONGLONG.

--***************************************************************************/
PSTR
UlULongLongToAscii(
    IN PSTR String,
    IN ULONGLONG Value
    )
{
    PSTR p1;
    PSTR p2;
    CHAR ch;
    ULONG digit;

    //
    // Special case 0 to make the rest of the routine simpler.
    //

    if (Value == 0)
    {
        *String++ = '0';
    }
    else
    {
        //
        // Convert the ULONG. Note that this will result in the string
        // being backwards in memory.
        //

        p1 = String;
        p2 = String;

        while (Value != 0)
        {
            digit = (ULONG)( Value % 10 );
            Value = Value / 10;
            *p1++ = '0' + (CHAR)digit;
        }

        //
        // Reverse the string.
        //

        String = p1;
        p1--;

        while (p1 > p2)
        {
            ch = *p1;
            *p1 = *p2;
            *p2 = ch;

            p2++;
            p1--;
        }
    }

    *String = '\0';
    return String;

}   // UlULongLongToAscii



NTSTATUS
_RtlIntegerToUnicode(
    IN ULONG Value,
    IN ULONG Base OPTIONAL,
    IN LONG BufferLength,
    OUT PWSTR String
    )
{
    PWSTR p1;
    PWSTR p2;
    WCHAR ch;
    ULONG digit;

    UNREFERENCED_PARAMETER(Base);
    UNREFERENCED_PARAMETER(BufferLength);

    //
    // Special case 0 to make the rest of the routine simpler.
    //

    if (Value == 0)
    {
        *String++ = L'0';
    }
    else
    {
        //
        // Convert the ULONG. Note that this will result in the string
        // being backwards in memory.
        //

        p1 = String;
        p2 = String;

        while (Value != 0)
        {
            digit = (ULONG)( Value % 10 );
            Value = Value / 10;
            *p1++ = L'0' + (WCHAR)digit;
        }

        //
        // Reverse the string.
        //

        String = p1;
        p1--;

        while (p1 > p2)
        {
            ch = *p1;
            *p1 = *p2;
            *p2 = ch;

            p2++;
            p1--;
        }
    }

    *String = L'\0';

    return STATUS_SUCCESS;

}   // _RtlIntegerToUnicode



/***************************************************************************++

Routine Description:

    Synchronously issues a device control request to the TDI provider.

Arguments:

    pTdiObject - Supplies a pointer to the TDI object.

    pIrpParameters - Supplies a pointer to the IRP parameters.

    IrpParametersLength - Supplies the length of pIrpParameters.

    pMdlBuffer - Optionally supplies a pointer to a buffer to be mapped
        into a MDL and placed in the MdlAddress field of the IRP.

    MdlBufferLength - Optionally supplies the length of pMdlBuffer.

    MinorFunction - Supplies the minor function code of the request.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlIssueDeviceControl(
    IN PUX_TDI_OBJECT pTdiObject,
    IN PVOID pIrpParameters,
    IN ULONG IrpParametersLength,
    IN PVOID pMdlBuffer OPTIONAL,
    IN ULONG MdlBufferLength OPTIONAL,
    IN UCHAR MinorFunction
    )
{
    NTSTATUS status;
    PIRP pIrp;
    PIO_STACK_LOCATION pIrpSp;
    UL_STATUS_BLOCK ulStatus;
    IO_STATUS_BLOCK UserIosb;
    PMDL pMdl;

    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // Initialize the event that will signal I/O completion.
    //

    UlInitializeStatusBlock( &ulStatus );

    //
    // Set the file object event to the non-signaled state.
    //

    KeResetEvent( &pTdiObject->pFileObject->Event );

    //
    // Allocate an IRP for the request.
    //

    pIrp = UlAllocateIrp(
                pTdiObject->pDeviceObject->StackSize,   // StackSize
                FALSE                                   // ChargeQuota
                );

    if (pIrp == NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Initialize the User IO_STATUS_BLOCK
    //

    UserIosb.Information = 0;
    UserIosb.Status = STATUS_SUCCESS;
    
    //
    // Establish the service independent parameters.
    //

    pIrp->Flags = IRP_SYNCHRONOUS_API;
    pIrp->RequestorMode = KernelMode;
    pIrp->PendingReturned = FALSE;
    pIrp->UserIosb = &UserIosb;

    pIrp->Tail.Overlay.Thread = PsGetCurrentThread();
    pIrp->Tail.Overlay.OriginalFileObject = pTdiObject->pFileObject;

    //
    // If we have a MDL buffer, allocate a new MDL and map the
    // buffer into it.
    //

    if (pMdlBuffer != NULL)
    {
        pMdl = UlAllocateMdl(
                    pMdlBuffer,                 // VirtualAddress
                    MdlBufferLength,            // Length
                    FALSE,                      // SecondaryBuffer
                    FALSE,                      // ChargeQuota
                    pIrp                        // Irp
                    );

        if (pMdl == NULL)
        {
            UlFreeIrp( pIrp );
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        MmBuildMdlForNonPagedPool( pMdl );
    }
    else
    {
        pIrp->MdlAddress = NULL;
    }

    //
    // Initialize the IRP stack location.
    //

    pIrpSp = IoGetNextIrpStackLocation( pIrp );

    pIrpSp->FileObject = pTdiObject->pFileObject;
    pIrpSp->DeviceObject = pTdiObject->pDeviceObject;

    ASSERT( IrpParametersLength <= sizeof(pIrpSp->Parameters) );
    RtlCopyMemory(
        &pIrpSp->Parameters,
        pIrpParameters,
        IrpParametersLength
        );

    pIrpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    pIrpSp->MinorFunction = MinorFunction;

    //
    // Reference the file object.
    //

    ObReferenceObject( pTdiObject->pFileObject );

    //
    // Establish a completion routine to free the MDL and dereference
    // the FILE_OBJECT.
    //

    IoSetCompletionRoutine(
        pIrp,                                   // Irp
        &UlpRestartDeviceControl,               // CompletionRoutine
        &ulStatus,                              // Context
        TRUE,                                   // InvokeOnSuccess
        TRUE,                                   // InvokeOnError
        TRUE                                    // InvokeOnCancel
        );

    //
    // Issue the request.
    //

    status = UlCallDriver( pTdiObject->pDeviceObject, pIrp );

    //
    // If necessary, wait for the request to complete and snag the
    // final completion status.
    //

    if (status == STATUS_PENDING)
    {
        UlWaitForStatusBlockEvent( &ulStatus );
        status = ulStatus.IoStatus.Status;
    }

    return status;

}   // UlIssueDeviceControl



/***************************************************************************++

Routine Description:

    Allocates the pool necessary for a new UL_RECEIVE_BUFFER structure and
    initializes the structure.

Arguments:

    IrpStackSize - Supplies the IrpStackSize.

Return Value:

    PVOID - Pointer to the newly allocated block if successful, FALSE
        otherwise.

--***************************************************************************/
PVOID
UlAllocateReceiveBuffer(
    IN CCHAR IrpStackSize
    )
{
    PUL_RECEIVE_BUFFER pBuffer;
    SIZE_T irpLength;
    SIZE_T mdlLength;
    SIZE_T ExtraLength;

    //
    // Calculate the required length of the buffer & allocate it.
    //

    irpLength = IoSizeOfIrp( IrpStackSize );
    irpLength = ALIGN_UP( irpLength, PVOID );

    mdlLength = MmSizeOfMdl( (PVOID)(PAGE_SIZE - 1), g_UlReceiveBufferSize );
    mdlLength = ALIGN_UP( mdlLength, PVOID );

    ExtraLength = irpLength + (mdlLength*2) + g_UlReceiveBufferSize;

    ASSERT( ( ExtraLength & (sizeof(PVOID) - 1) ) == 0 );

    pBuffer = UL_ALLOCATE_STRUCT_WITH_SPACE(
                    NonPagedPool,
                    UL_RECEIVE_BUFFER,
                    ExtraLength,
                    UL_RCV_BUFFER_POOL_TAG
                    );

    if (pBuffer != NULL)
    {
        PUCHAR pRawBuffer = (PUCHAR)(pBuffer);

        //
        // Initialize the IRP, MDL, and data pointers within the buffer.
        //

        pBuffer->Signature = UL_RECEIVE_BUFFER_SIGNATURE_X;
        pRawBuffer += ALIGN_UP( sizeof(UL_RECEIVE_BUFFER), PVOID );
        pBuffer->pIrp = (PIRP)pRawBuffer;
        pRawBuffer += irpLength;
        pBuffer->pMdl = (PMDL)pRawBuffer;
        pRawBuffer += mdlLength;
        pBuffer->pPartialMdl = (PMDL)pRawBuffer;
        pRawBuffer += mdlLength;
        pBuffer->pDataArea = (PVOID)pRawBuffer;
        pBuffer->UnreadDataLength = 0;

        //
        // Initialize the IRP.
        //

        IoInitializeIrp(
            pBuffer->pIrp,                      // Irp
            (USHORT)irpLength,                  // PacketSize
            IrpStackSize                        // StackSize
            );

        //
        // Initialize the primary MDL.
        //

        MmInitializeMdl(
            pBuffer->pMdl,                      // MemoryDescriptorList
            pBuffer->pDataArea,                 // BaseVa
            g_UlReceiveBufferSize               // Length
            );

        MmBuildMdlForNonPagedPool( pBuffer->pMdl );
    }

    return (PVOID)pBuffer;

}   // UlAllocateReceiveBuffer



/***************************************************************************++

Routine Description:

    Allocates the pool necessary for a new UL_RECEIVE_BUFFER structure and
    initializes the structure.

Arguments:

    PoolType - Supplies the type of pool to allocate. This must always
        be NonPagedPool.

    ByteLength - Supplies the byte length for the allocation request.
        This should be sizeof(UL_RECEIVE_BUFFER), but is basically ignored.

    Tag - Supplies the tag to use for the pool. This should be
        UL_RCV_BUFFER_POOL_TAG, but is basically ignored.

    Note: These parameters are required so that this function has a
        signature identical to ExAllocatePoolWithTag.

Return Value:

    PVOID - Pointer to the newly allocated block if successful, FALSE
        otherwise.

--***************************************************************************/
PVOID
UlAllocateReceiveBufferPool(
    IN POOL_TYPE PoolType,
    IN SIZE_T ByteLength,
    IN ULONG Tag
    )
{
    UNREFERENCED_PARAMETER(PoolType);
    UNREFERENCED_PARAMETER(ByteLength);
    UNREFERENCED_PARAMETER(Tag);

    //
    // Sanity check.
    //

    ASSERT( PoolType == NonPagedPool );
    ASSERT( ByteLength == sizeof(UL_RECEIVE_BUFFER) );
    ASSERT( Tag == UL_RCV_BUFFER_POOL_TAG );

    return UlAllocateReceiveBuffer( DEFAULT_IRP_STACK_SIZE );

}   // UlAllocateReceiveBufferPool



/***************************************************************************++

Routine Description:

    Frees the pool allocated for a UL_RECEIVE_BUFFER structure.

Arguments:

    pBuffer - Supplies the buffer to free.

--***************************************************************************/
VOID
UlFreeReceiveBufferPool(
    IN PVOID pBuffer
    )
{
    PUL_RECEIVE_BUFFER pReceiveBuffer;

    pReceiveBuffer = (PUL_RECEIVE_BUFFER)pBuffer;

    ASSERT(pReceiveBuffer->Signature == UL_RECEIVE_BUFFER_SIGNATURE_X);

    UL_FREE_POOL( pReceiveBuffer, UL_RCV_BUFFER_POOL_TAG );

}   // UlFreeReceiveBufferPool



/***************************************************************************++

Routine Description:

    Allocates the pool necessary for a new UL_IRP_CONTEXT structure and
    initializes the structure.

Arguments:

    PoolType - Supplies the type of pool to allocate. This must always
        be NonPagedPool.

    ByteLength - Supplies the byte length for the allocation request.
        This should be sizeof(UL_IRP_CONTEXT), but is basically ignored.

    Tag - Supplies the tag to use for the pool. This should be
        UL_IRP_CONTEXT_POOL_TAG, but is basically ignored.

    Note: These parameters are required so that this function has a
        signature identical to ExAllocatePoolWithTag.

Return Value:

    PVOID - Pointer to the newly allocated block if successful, FALSE
        otherwise.

--***************************************************************************/
PVOID
UlAllocateIrpContextPool(
    IN POOL_TYPE PoolType,
    IN SIZE_T ByteLength,
    IN ULONG Tag
    )
{
    PUL_IRP_CONTEXT pIrpContext;

    UNREFERENCED_PARAMETER(PoolType);
    UNREFERENCED_PARAMETER(ByteLength);
    UNREFERENCED_PARAMETER(Tag);

    //
    // Sanity check.
    //

    ASSERT( PoolType == NonPagedPool );
    ASSERT( ByteLength == sizeof(UL_IRP_CONTEXT) );
    ASSERT( Tag == UL_IRP_CONTEXT_POOL_TAG );

    //
    // Allocate the IRP context.
    //

    pIrpContext = UL_ALLOCATE_STRUCT(
                        NonPagedPool,
                        UL_IRP_CONTEXT,
                        UL_IRP_CONTEXT_POOL_TAG
                        );

    if (pIrpContext != NULL)
    {
        //
        // Initialize it.
        //

        pIrpContext->Signature = UL_IRP_CONTEXT_SIGNATURE_X;
#if DBG
        pIrpContext->pCompletionRoutine = &UlDbgInvalidCompletionRoutine;
#endif
    }

    return (PVOID)pIrpContext;

}   // UlAllocateIrpContextPool



/***************************************************************************++

Routine Description:

    Frees the pool allocated for a UL_IRP_CONTEXT structure.

Arguments:

    pBuffer - Supplies the buffer to free.

--***************************************************************************/
VOID
UlFreeIrpContextPool(
    IN PVOID pBuffer
    )
{
    PUL_IRP_CONTEXT pIrpContext;

    pIrpContext = (PUL_IRP_CONTEXT)pBuffer;

    ASSERT(pIrpContext->Signature == UL_IRP_CONTEXT_SIGNATURE_X);

    UL_FREE_POOL( pIrpContext, UL_IRP_CONTEXT_POOL_TAG );

}   // UlFreeIrpContextPool



/***************************************************************************++

Routine Description:

    Allocates the pool necessary for a new UL_REQUEST_BUFFER structure and
    initializes the structure.

Arguments:

    PoolType - Supplies the type of pool to allocate. This must always
        be NonPagedPool.

    ByteLength - Supplies the byte length for the allocation request.
        This should be DEFAULT_MAX_REQUEST_BUFFER_SIZE but is basically
        ignored.

    Tag - Supplies the tag to use for the pool. This should be
        UL_REQUEST_BUFFER_POOL_TAG, but is basically ignored.

    Note: These parameters are required so that this function has a
        signature identical to ExAllocatePoolWithTag.

Return Value:

    PVOID - Pointer to the newly allocated block if successful, FALSE
        otherwise.

--***************************************************************************/
PVOID
UlAllocateRequestBufferPool(
    IN POOL_TYPE PoolType,
    IN SIZE_T ByteLength,
    IN ULONG Tag
    )
{
    PUL_REQUEST_BUFFER pRequestBuffer;

    UNREFERENCED_PARAMETER(PoolType);
    UNREFERENCED_PARAMETER(ByteLength);
    UNREFERENCED_PARAMETER(Tag);

    //
    // Sanity check.
    //

    ASSERT( PoolType == NonPagedPool );
    ASSERT( ByteLength == DEFAULT_MAX_REQUEST_BUFFER_SIZE );
    ASSERT( Tag == UL_REQUEST_BUFFER_POOL_TAG );

    //
    // Allocate the request buffer.
    //

    pRequestBuffer = UL_ALLOCATE_STRUCT_WITH_SPACE(
                        NonPagedPool,
                        UL_REQUEST_BUFFER,
                        DEFAULT_MAX_REQUEST_BUFFER_SIZE,
                        UL_REQUEST_BUFFER_POOL_TAG
                        );

    if (pRequestBuffer != NULL)
    {
        //
        // Initialize it.
        //

        pRequestBuffer->Signature = MAKE_FREE_TAG(UL_REQUEST_BUFFER_POOL_TAG);
    }

    return (PVOID)pRequestBuffer;

}   // UlAllocateRequestBufferPool



/***************************************************************************++

Routine Description:

    Frees the pool allocated for a UL_REQUEST_BUFFER structure.

Arguments:

    pBuffer - Supplies the buffer to free.

--***************************************************************************/
VOID
UlFreeRequestBufferPool(
    IN PVOID pBuffer
    )
{
    PUL_REQUEST_BUFFER pRequestBuffer;

    pRequestBuffer = (PUL_REQUEST_BUFFER)pBuffer;

    ASSERT(pRequestBuffer->Signature == MAKE_FREE_TAG(UL_REQUEST_BUFFER_POOL_TAG));

    UL_FREE_POOL_WITH_SIG(pRequestBuffer, UL_REQUEST_BUFFER_POOL_TAG);

}   // UlFreeRequestBufferPool



/***************************************************************************++

Routine Description:

    Allocates the pool necessary for a new UL_INTERNAL_REQUEST structure and
    initializes the structure.

Arguments:

    PoolType - Supplies the type of pool to allocate. This must always
        be NonPagedPool.

    ByteLength - Supplies the byte length for the allocation request.
        This should be sizeof(UL_INTERNAL_REQUEST) but is basically ignored.

    Tag - Supplies the tag to use for the pool. This should be
        UL_INTERNAL_REQUEST_POOL_TAG, but is basically ignored.

    Note: These parameters are required so that this function has a
        signature identical to ExAllocatePoolWithTag.

Return Value:

    PVOID - Pointer to the newly allocated block if successful, FALSE
        otherwise.

--***************************************************************************/
PVOID
UlAllocateInternalRequestPool(
    IN POOL_TYPE PoolType,
    IN SIZE_T ByteLength,
    IN ULONG Tag
    )
{
    PUL_INTERNAL_REQUEST pRequest;
    PUL_FULL_TRACKER pTracker;
    ULONG SpaceLength;
    ULONG UrlBufferSize;

    UNREFERENCED_PARAMETER(PoolType);
    UNREFERENCED_PARAMETER(ByteLength);
    UNREFERENCED_PARAMETER(Tag);

    //
    // Sanity check.
    //

    ASSERT( PoolType == NonPagedPool );
    ASSERT( ByteLength == sizeof(UL_INTERNAL_REQUEST) );
    ASSERT( Tag == UL_INTERNAL_REQUEST_POOL_TAG );

    //
    // Allocate the request buffer plus the default cooked URL buffer and
    // the full tracker plus the auxiliary buffer.
    //

    ASSERT( (g_UlMaxInternalUrlLength & (sizeof(WCHAR) - 1)) == 0);

    UrlBufferSize = g_UlMaxInternalUrlLength + sizeof(WCHAR);

    SpaceLength = g_UlFullTrackerSize + UrlBufferSize +
                  DEFAULT_MAX_ROUTING_TOKEN_LENGTH;

    pRequest = UL_ALLOCATE_STRUCT_WITH_SPACE(
                        NonPagedPool,
                        UL_INTERNAL_REQUEST,
                        SpaceLength,
                        UL_INTERNAL_REQUEST_POOL_TAG
                        );

    if (pRequest != NULL)
    {
        pRequest->pTracker =
            (PUL_FULL_TRACKER)((PCHAR)pRequest +
                ALIGN_UP(sizeof(UL_INTERNAL_REQUEST), PVOID));

        pRequest->pUrlBuffer =
            (PWSTR)((PCHAR)pRequest->pTracker + g_UlFullTrackerSize);

        pRequest->pDefaultRoutingTokenBuffer = 
            (PWSTR)((PCHAR)pRequest->pUrlBuffer + UrlBufferSize);
        
        // 
        // Initialize the Request structure 
        //


        INIT_HTTP_REQUEST( pRequest );

        pRequest->Signature = MAKE_FREE_TAG(UL_INTERNAL_REQUEST_POOL_TAG);

        //
        // Initialize the fast/cache tracker.
        //

        pTracker = pRequest->pTracker;

        pTracker->Signature = UL_FULL_TRACKER_POOL_TAG;
        pTracker->IrpContext.Signature = UL_IRP_CONTEXT_SIGNATURE;
        pTracker->FromLookaside = FALSE;
        pTracker->FromRequest = TRUE;
        pTracker->ResponseStatusCode = 0;
        pTracker->AuxilaryBufferLength =
            g_UlMaxFixedHeaderSize +
            g_UlMaxVariableHeaderSize +
            g_UlMaxCopyThreshold;

        UlInitializeFullTrackerPool( pTracker, DEFAULT_MAX_IRP_STACK_SIZE );
    }

    return (PVOID)pRequest;

}   // UlAllocateInternalRequestPool



/***************************************************************************++

Routine Description:

    Frees the pool allocated for a UL_INTERNAL_REQUEST structure.

Arguments:

    pBuffer - Supplies the buffer to free.

--***************************************************************************/
VOID
UlFreeInternalRequestPool(
    IN PVOID pBuffer
    )
{
    PUL_INTERNAL_REQUEST pRequest;

    pRequest = (PUL_INTERNAL_REQUEST)pBuffer;

    ASSERT(pRequest->Signature == MAKE_FREE_TAG(UL_INTERNAL_REQUEST_POOL_TAG));

    UL_FREE_POOL_WITH_SIG( pRequest, UL_INTERNAL_REQUEST_POOL_TAG );

}   // UlFreeInternalRequestPool



/***************************************************************************++

Routine Description:

    Allocates the pool necessary for a new UL_CHUNK_TRACKER structure and
    initializes the structure.

Arguments:

    PoolType - Supplies the type of pool to allocate. This must always
        be NonPagedPool.

    ByteLength - Supplies the byte length for the allocation request.
        This should be g_UlChunkTrackerSize but is basically ignored.

    Tag - Supplies the tag to use for the pool. This should be
        UL_CHUNK_TRACKER_POOL_TAG, but is basically ignored.

    Note: These parameters are required so that this function has a
        signature identical to ExAllocatePoolWithTag.

Return Value:

    PVOID - Pointer to the newly allocated block if successful, FALSE
        otherwise.

--***************************************************************************/
PVOID
UlAllocateChunkTrackerPool(
    IN POOL_TYPE PoolType,
    IN SIZE_T ByteLength,
    IN ULONG Tag
    )
{
    PUL_CHUNK_TRACKER pTracker;

    UNREFERENCED_PARAMETER(PoolType);
    UNREFERENCED_PARAMETER(ByteLength);
    UNREFERENCED_PARAMETER(Tag);

    //
    // Sanity check.
    //

    ASSERT( PoolType == NonPagedPool );
    ASSERT( ByteLength == g_UlChunkTrackerSize );
    ASSERT( Tag == UL_CHUNK_TRACKER_POOL_TAG );

    //
    // Allocate the tracker buffer.
    //

    pTracker = (PUL_CHUNK_TRACKER)UL_ALLOCATE_POOL(
                                    NonPagedPool,
                                    g_UlChunkTrackerSize,
                                    UL_CHUNK_TRACKER_POOL_TAG
                                    );

    if (pTracker != NULL)
    {
        pTracker->Signature = MAKE_FREE_TAG(UL_CHUNK_TRACKER_POOL_TAG);
        pTracker->IrpContext.Signature = UL_IRP_CONTEXT_SIGNATURE;
        pTracker->FromLookaside = TRUE;

        //
        // Set up the IRP.
        //

        pTracker->pIrp =
            (PIRP)((PCHAR)pTracker +
                ALIGN_UP(sizeof(UL_CHUNK_TRACKER), PVOID));

        IoInitializeIrp(
            pTracker->pIrp,
            IoSizeOfIrp(DEFAULT_MAX_IRP_STACK_SIZE),
            DEFAULT_MAX_IRP_STACK_SIZE
            );
    }

    return pTracker;

}   // UlAllocateChunkTrackerPool



/***************************************************************************++

Routine Description:

    Frees the pool allocated for a UL_CHUNK_TRACKER structure.

Arguments:

    pBuffer - Supplies the buffer to free.

--***************************************************************************/
VOID
UlFreeChunkTrackerPool(
    IN PVOID pBuffer
    )
{
    PUL_CHUNK_TRACKER pTracker = (PUL_CHUNK_TRACKER)pBuffer;

    ASSERT(pTracker->Signature == MAKE_FREE_TAG(UL_CHUNK_TRACKER_POOL_TAG));

    UL_FREE_POOL_WITH_SIG( pTracker, UL_CHUNK_TRACKER_POOL_TAG );

}   // UlFreeChunkTrackerPool



/***************************************************************************++

Routine Description:

    Allocates the pool necessary for a new UL_FULL_TRACKER structure and
    initializes the structure.

Arguments:

    PoolType - Supplies the type of pool to allocate. This must always
        be NonPagedPool.

    ByteLength - Supplies the byte length for the allocation request.
        This should be g_UlFullTrackerSize but is basically ignored.

    Tag - Supplies the tag to use for the pool. This should be
        UL_FULL_TRACKER_POOL_TAG, but is basically ignored.

    Note: These parameters are required so that this function has a
        signature identical to ExAllocatePoolWithTag.

Return Value:

    PVOID - Pointer to the newly allocated block if successful, FALSE
        otherwise.

--***************************************************************************/
PVOID
UlAllocateFullTrackerPool(
    IN POOL_TYPE PoolType,
    IN SIZE_T ByteLength,
    IN ULONG Tag
    )
{
    PUL_FULL_TRACKER pTracker;

    UNREFERENCED_PARAMETER(PoolType);
    UNREFERENCED_PARAMETER(ByteLength);
    UNREFERENCED_PARAMETER(Tag);

    //
    // Sanity check.
    //

    ASSERT( PoolType == NonPagedPool );
    ASSERT( ByteLength == g_UlFullTrackerSize );
    ASSERT( Tag == UL_FULL_TRACKER_POOL_TAG );

    //
    // Allocate the tracker buffer.
    //

    pTracker = (PUL_FULL_TRACKER)UL_ALLOCATE_POOL(
                                    NonPagedPool,
                                    g_UlFullTrackerSize,
                                    UL_FULL_TRACKER_POOL_TAG
                                    );

    if (pTracker != NULL)
    {
        pTracker->Signature = MAKE_FREE_TAG(UL_FULL_TRACKER_POOL_TAG);
        pTracker->IrpContext.Signature = UL_IRP_CONTEXT_SIGNATURE;
        pTracker->FromLookaside = TRUE;
        pTracker->FromRequest = FALSE;
        pTracker->AuxilaryBufferLength =
            g_UlMaxFixedHeaderSize +
            g_UlMaxVariableHeaderSize +
            g_UlMaxCopyThreshold;

        UlInitializeFullTrackerPool( pTracker, DEFAULT_MAX_IRP_STACK_SIZE );
    }

    return pTracker;

}   // UlAllocateFullTrackerPool



/***************************************************************************++

Routine Description:

    Frees the pool allocated for a UL_FULL_TRACKER structure.

Arguments:

    pBuffer - Supplies the buffer to free.

--***************************************************************************/
VOID
UlFreeFullTrackerPool(
    IN PVOID pBuffer
    )
{
    PUL_FULL_TRACKER pTracker = (PUL_FULL_TRACKER)pBuffer;

    ASSERT(pTracker->Signature == MAKE_FREE_TAG(UL_FULL_TRACKER_POOL_TAG));

    UL_FREE_POOL_WITH_SIG( pTracker, UL_FULL_TRACKER_POOL_TAG );

}   // UlFreeFullTrackerPool



/***************************************************************************++

Routine Description:

    Allocates the pool necessary for a new UL_INTERNAL_RESPONSE structure and
    initializes the structure.

Arguments:

    PoolType - Supplies the type of pool to allocate. This must always
        be NonPagedPool.

    ByteLength - Supplies the byte length for the allocation request.
        This should be g_UlResponseBufferSize but is basically ignored.

    Tag - Supplies the tag to use for the pool. This should be
        UL_INTERNAL_RESPONSE_POOL_TAG, but is basically ignored.

    Note: These parameters are required so that this function has a
        signature identical to ExAllocatePoolWithTag.

Return Value:

    PVOID - Pointer to the newly allocated block if successful, FALSE
        otherwise.

--***************************************************************************/
PVOID
UlAllocateResponseBufferPool(
    IN POOL_TYPE PoolType,
    IN SIZE_T ByteLength,
    IN ULONG Tag
    )
{
    PUL_INTERNAL_RESPONSE pResponseBuffer;

    UNREFERENCED_PARAMETER(PoolType);
    UNREFERENCED_PARAMETER(ByteLength);
    UNREFERENCED_PARAMETER(Tag);

    //
    // Sanity check.
    //

    ASSERT( PoolType == NonPagedPool );
    ASSERT( ByteLength == g_UlResponseBufferSize );
    ASSERT( Tag == UL_INTERNAL_RESPONSE_POOL_TAG );

    //
    // Allocate the default internal response buffer.
    //

    pResponseBuffer = (PUL_INTERNAL_RESPONSE)UL_ALLOCATE_POOL(
                                                NonPagedPool,
                                                g_UlResponseBufferSize,
                                                UL_INTERNAL_RESPONSE_POOL_TAG
                                                );

    if (pResponseBuffer != NULL)
    {
        //
        // Initialize it.
        //

        pResponseBuffer->Signature = MAKE_FREE_TAG(UL_INTERNAL_RESPONSE_POOL_TAG);
    }

    return (PVOID)pResponseBuffer;

}   // UlAllocateResponseBufferPool



/***************************************************************************++

Routine Description:

    Frees the pool allocated for a UL_INTERNAL_RESPONSE structure.

Arguments:

    pBuffer - Supplies the buffer to free.

--***************************************************************************/
VOID
UlFreeResponseBufferPool(
    IN PVOID pBuffer
    )
{
    PUL_INTERNAL_RESPONSE pResponseBuffer;

    pResponseBuffer = (PUL_INTERNAL_RESPONSE)pBuffer;

    UL_FREE_POOL_WITH_SIG( pResponseBuffer, UL_INTERNAL_RESPONSE_POOL_TAG );

}   // UlFreeResponseBufferPool



/***************************************************************************++

Routine Description:

    Allocates the pool necessary for a new UL_FILE_LOG_BUFFER structure and
    initializes the structure.

Arguments:

    PoolType - Supplies the type of pool to allocate. This must always
        be PagedPool.

    ByteLength - Supplies the byte length for the allocation request.
        This should be sizeof(UL_LOG_FILE_BUFFER) but is basically ignored.

    Tag - Supplies the tag to use for the pool. This should be
        UL_LOG_FILE_BUFFER_POOL_TAG, but is basically ignored.

    Note: These parameters are required so that this function has a
        signature identical to ExAllocatePoolWithTag.

Return Value:

    PVOID - Pointer to the newly allocated block if successful, FALSE
        otherwise.

--***************************************************************************/
PVOID
UlAllocateLogFileBufferPool(
    IN POOL_TYPE PoolType,
    IN SIZE_T ByteLength,
    IN ULONG Tag
    )
{
    PUL_LOG_FILE_BUFFER pLogBuffer;

    UNREFERENCED_PARAMETER(PoolType);
    UNREFERENCED_PARAMETER(ByteLength);
    UNREFERENCED_PARAMETER(Tag);

    //
    // Sanity check.
    //

    ASSERT( PoolType == NonPagedPool );
    ASSERT( ByteLength == sizeof(UL_LOG_FILE_BUFFER) );
    ASSERT( Tag == UL_LOG_FILE_BUFFER_POOL_TAG );

    //
    // Allocate the default log buffer.
    //

    pLogBuffer = UL_ALLOCATE_STRUCT_WITH_SPACE(
                    PagedPool,
                    UL_LOG_FILE_BUFFER,
                    g_UlLogBufferSize,
                    UL_LOG_FILE_BUFFER_POOL_TAG
                    );

    if ( pLogBuffer != NULL )
    {
        pLogBuffer->Signature = MAKE_FREE_TAG(UL_LOG_FILE_BUFFER_POOL_TAG);
        pLogBuffer->BufferUsed = 0;
        pLogBuffer->Buffer = (PUCHAR) (pLogBuffer + 1);
    }

    return pLogBuffer;

}   // UlAllocateLogFileBufferPool



/***************************************************************************++

Routine Description:

    Frees the pool allocated for a UL_LOG_FILE_BUFFER structure.

Arguments:

    pBuffer - Supplies the buffer to free.

--***************************************************************************/
VOID
UlFreeLogFileBufferPool(
    IN PVOID pBuffer
    )
{
    PUL_LOG_FILE_BUFFER pLogBuffer;

    pLogBuffer = (PUL_LOG_FILE_BUFFER) pBuffer;

    ASSERT(pLogBuffer->Signature == MAKE_FREE_TAG(UL_LOG_FILE_BUFFER_POOL_TAG));

    UL_FREE_POOL_WITH_SIG( pLogBuffer, UL_LOG_FILE_BUFFER_POOL_TAG );

}   // UlFreeLogFileBufferPool



/***************************************************************************++

Routine Description:

    Allocates the pool necessary for a new UL_FILE_LOG_BUFFER structure and
    initializes the structure.

Return Value:

    PVOID - Pointer to the newly allocated block if successful, FALSE
        otherwise.

--***************************************************************************/

PVOID
UlAllocateLogDataBufferPool(
    IN POOL_TYPE PoolType,
    IN SIZE_T ByteLength,
    IN ULONG Tag
    )
{    
    PUL_LOG_DATA_BUFFER pLogDataBuffer = NULL;
    USHORT Size = UL_ANSI_LOG_LINE_BUFFER_SIZE;
    BOOLEAN Binary = FALSE;

    UNREFERENCED_PARAMETER(PoolType);
    UNREFERENCED_PARAMETER(ByteLength);

    //
    // We understand what type of buffer is asked, by looking at the tag.
    //

    ASSERT(ByteLength == 
        (sizeof(UL_LOG_DATA_BUFFER) + UL_ANSI_LOG_LINE_BUFFER_SIZE) ||
           ByteLength ==
        (sizeof(UL_LOG_DATA_BUFFER) + UL_BINARY_LOG_LINE_BUFFER_SIZE)
            );
    
    ASSERT(PoolType == NonPagedPool );
    
    ASSERT(Tag == UL_BINARY_LOG_DATA_BUFFER_POOL_TAG ||
           Tag == UL_ANSI_LOG_DATA_BUFFER_POOL_TAG );

    if (Tag == UL_BINARY_LOG_DATA_BUFFER_POOL_TAG)
    {
        Binary = TRUE;
        Size   = UL_BINARY_LOG_LINE_BUFFER_SIZE;       
    }
        
    pLogDataBuffer = 
        UL_ALLOCATE_STRUCT_WITH_SPACE(
            NonPagedPool,
            UL_LOG_DATA_BUFFER,
            Size, 
            Tag
            );

    if ( pLogDataBuffer != NULL )
    {
        pLogDataBuffer->Signature   = MAKE_FREE_TAG(Tag);
        pLogDataBuffer->Used        = 0;
        pLogDataBuffer->Size        = Size;
        pLogDataBuffer->Line        = (PUCHAR) (pLogDataBuffer + 1);
        pLogDataBuffer->Flags.Value = 0;
            
        pLogDataBuffer->Flags.IsFromLookaside = 1;

        if (Binary)
        {
            pLogDataBuffer->Flags.Binary = 1;                
        }
    }

    return pLogDataBuffer;
    
} // UlAllocateBinaryLogDataBufferPool



/***************************************************************************++

Routine Description:

    Frees the pool allocated for a UL_LOG_DATA_BUFFER structure.

Arguments:

    pBuffer - Supplies the buffer to free.

--***************************************************************************/
VOID
UlFreeLogDataBufferPool(
    IN PVOID pBuffer
    )
{
    ULONG Tag;
    PUL_LOG_DATA_BUFFER pLogDataBuffer;    

    pLogDataBuffer = (PUL_LOG_DATA_BUFFER) pBuffer;

    if (pLogDataBuffer->Flags.Binary)
    {
        Tag = UL_BINARY_LOG_DATA_BUFFER_POOL_TAG;
    }
    else
    {
        Tag = UL_ANSI_LOG_DATA_BUFFER_POOL_TAG;
    }

    ASSERT(pLogDataBuffer->Signature == MAKE_FREE_TAG(Tag));

    UL_FREE_POOL_WITH_SIG( 
        pLogDataBuffer, 
        Tag 
        );

}   // UlFreeLogDataBufferPool

/***************************************************************************++

Routine Description:

    Allocates the pool necessary for a new UL_ERROR_LOG_BUFFER structure and
    initializes the structure.

Return Value:

    PVOID - Pointer to the newly allocated block if successful, FALSE
        otherwise.

--***************************************************************************/

PVOID
UlAllocateErrorLogBufferPool(
    IN POOL_TYPE PoolType,
    IN SIZE_T ByteLength,
    IN ULONG Tag
    )
{    
    PUL_ERROR_LOG_BUFFER pErrorLogBuffer = NULL;

    UNREFERENCED_PARAMETER(PoolType);
    UNREFERENCED_PARAMETER(ByteLength);

    //
    // We understand what type of buffer is asked, by looking at the tag.
    //

    ASSERT(ByteLength == UL_ERROR_LOG_BUFFER_SIZE);    
    ASSERT(PoolType     == NonPagedPool );    
    ASSERT(Tag          == UL_ERROR_LOG_BUFFER_POOL_TAG);
        
    pErrorLogBuffer = 
        UL_ALLOCATE_STRUCT_WITH_SPACE(
            NonPagedPool,
            UL_ERROR_LOG_BUFFER,
            UL_ERROR_LOG_BUFFER_SIZE, 
            Tag
            );

    if ( pErrorLogBuffer != NULL )
    {
        pErrorLogBuffer->Signature   = MAKE_FREE_TAG(Tag);
        pErrorLogBuffer->Used        = 0;
        pErrorLogBuffer->pBuffer     = (PUCHAR) (pErrorLogBuffer + 1);
            
        pErrorLogBuffer->IsFromLookaside = TRUE;
    }

    return pErrorLogBuffer;
    
} // UlAllocateErrorLogBufferPool

/***************************************************************************++

Routine Description:

    Frees the pool allocated for a UL_ERROR_LOG_BUFFER structure.

Arguments:

    pBuffer - Supplies the buffer to free.

--***************************************************************************/
VOID
UlFreeErrorLogBufferPool(
    IN PVOID pBuffer
    )
{
    PUL_ERROR_LOG_BUFFER pErrorLogBuffer = (PUL_ERROR_LOG_BUFFER) pBuffer;

    ASSERT(pErrorLogBuffer->Signature == 
                MAKE_FREE_TAG(UL_ERROR_LOG_BUFFER_POOL_TAG));

    UL_FREE_POOL_WITH_SIG(
        pErrorLogBuffer, 
        UL_ERROR_LOG_BUFFER_POOL_TAG 
        );

}   // UlFreeErrorLogBufferPool


//
// Private routines.
//

/***************************************************************************++

Routine Description:

    Completion handler for device control IRPs.

Arguments:

    pDeviceObject - Supplies the device object for the IRP being
        completed.

    pIrp - Supplies the IRP being completed.

    pContext - Supplies the context associated with this request. In
        this case, it's a pointer to a UL_STATUS_BLOCK structure.

Return Value:

    NTSTATUS - STATUS_SUCCESS if IO should continue processing this
        IRP, STATUS_MORE_PROCESSING_REQUIRED if IO should stop processing
        this IRP.

--***************************************************************************/
NTSTATUS
UlpRestartDeviceControl(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    IN PVOID pContext
    )
{
    PUL_STATUS_BLOCK pStatus;

    UNREFERENCED_PARAMETER(pDeviceObject);

    //
    // If we attached an MDL to the IRP, then free it here and reset
    // the MDL pointer to NULL. IO can't handle a nonpaged MDL in an
    // IRP, so we do it here.
    //

    if (pIrp->MdlAddress != NULL)
    {
        UlFreeMdl( pIrp->MdlAddress );
        pIrp->MdlAddress = NULL;
    }

    //
    // Complete the request.
    //

    pStatus = (PUL_STATUS_BLOCK)pContext;

    UlSignalStatusBlock(
        pStatus,
        pIrp->IoStatus.Status,
        pIrp->IoStatus.Information
        );

    //
    // Tell IO to continue processing this IRP.
    //

    return STATUS_SUCCESS;

}   // UlpRestartDeviceControl


/*++

Routine Description:

    Routine to initialize the utilitu code.

Arguments:


Return Value:


--*/
NTSTATUS
InitializeHttpUtil(
    VOID
    )
{
    ULONG i;

    HttpCmnInitializeHttpCharsTable(g_UrlC14nConfig.EnableDbcs);

    //
    // Initialize base64 <--> binary conversion tables.
    // N.B. - This initialization must be done at run-time and not
    //        compile-time.
    //

    for (i = 0; i < 256; i++)
    {
        Base64ToBinaryTable[i] = INVALID_BASE64_TO_BINARY_TABLE_ENTRY;
    }

    for (i = 0; i < 64; i++)
    {
        ASSERT(BinaryToBase64Table[i] < 256);
        Base64ToBinaryTable[BinaryToBase64Table[i]] = (UCHAR)i;
    }

    return STATUS_SUCCESS;

} // InitializeHttpUtil


//
// constants used by the date formatter
//

const PCWSTR pDays[] =
{
   L"Sun", L"Mon", L"Tue", L"Wed", L"Thu", L"Fri", L"Sat"
};

const PCWSTR pMonths[] =
{
    L"Jan", L"Feb", L"Mar", L"Apr", L"May", L"Jun", L"Jul",
    L"Aug", L"Sep", L"Oct", L"Nov", L"Dec"
};

__inline
VOID
TwoDigitsToUnicode(
    PWSTR pBuffer,
    ULONG Number
    )
{
    ASSERT(Number < 100);

    pBuffer[0] = L'0' + (WCHAR)(Number / 10);
    pBuffer[1] = L'0' + (WCHAR)(Number % 10);
}


/***************************************************************************++

Routine Description:

    Converts the given system time to string representation containing
    GMT Formatted String.

Arguments:

    pTime - System time that needs to be converted.

    pBuffer - pointer to string which will contain the GMT time on
        successful return.

    BufferLength - size of pszBuff in bytes

Return Value:

    NTSTATUS

History:

     MuraliK        3-Jan-1995
     paulmcd        4-Mar-1999  copied to ul

--***************************************************************************/

NTSTATUS
TimeFieldsToHttpDate(
    IN  PTIME_FIELDS pTime,
    OUT PWSTR pBuffer,
    IN  ULONG BufferLength
    )
{
    NTSTATUS Status;

    ASSERT(pBuffer != NULL);

    if (BufferLength < (DATE_HDR_LENGTH + 1) * sizeof(WCHAR))
    {
        return STATUS_BUFFER_TOO_SMALL;
    }

    //                          0         1         2
    //                          01234567890123456789012345678
    //  Formats a string like: "Thu, 14 Jul 1994 15:26:05 GMT"
    //

    //
    // write the constants
    //

    pBuffer[3] = L',';
    pBuffer[4] = pBuffer[7] = pBuffer[11] = L' ';
    pBuffer[19] = pBuffer[22] = L':';

    //
    // now the variants
    //

    //
    // 0-based Weekday
    //

    RtlCopyMemory(&(pBuffer[0]), pDays[pTime->Weekday], 3*sizeof(WCHAR));

    TwoDigitsToUnicode(&(pBuffer[5]), pTime->Day);

    //
    // 1-based Month
    //

    RtlCopyMemory(&(pBuffer[8]), pMonths[pTime->Month - 1], 3*sizeof(WCHAR)); // 1-based

    Status = _RtlIntegerToUnicode(pTime->Year, 10, 5, &(pBuffer[12]));
    ASSERT(NT_SUCCESS(Status));

    pBuffer[16] = L' ';

    TwoDigitsToUnicode(&(pBuffer[17]), pTime->Hour);
    TwoDigitsToUnicode(&(pBuffer[20]), pTime->Minute);
    TwoDigitsToUnicode(&(pBuffer[23]), pTime->Second);

    RtlCopyMemory(&(pBuffer[25]), L" GMT", sizeof(L" GMT"));

    return STATUS_SUCCESS;

}   // TimeFieldsToHttpDate


__inline
SHORT
AsciiToShort(
    PCHAR pString
    )
{
    return (SHORT)atoi(pString);
}


__inline
SHORT
TwoAsciisToShort(
    PCHAR pString
    )
{
    SHORT Value;
    SHORT Number;

    Number = pString[1] - '0';

    if (Number <= 9)
    {
        Value = Number;
        Number = pString[0] - '0';

        if (Number <= 9)
        {
            Value += Number * 10;
            return Value;
        }
    }

    return 0;
}


/***************************************************************************++
  DateTime function ported from user mode W3SVC
--***************************************************************************/

/************************************************************
 *   Data
 ************************************************************/

static const PSTR s_rgchMonths[] = {
    "Jan", "Feb", "Mar", "Apr",
    "May", "Jun", "Jul", "Aug",
    "Sep", "Oct", "Nov", "Dec"
};

// Custom hash table for NumericToAsciiMonth() for mapping "Apr" to 4
static const CHAR MonthIndexTable[64] = {
   -1,'A',  2, 12, -1, -1, -1,  8, // A to G
   -1, -1, -1, -1,  7, -1,'N', -1, // F to O
    9, -1,'R', -1, 10, -1, 11, -1, // P to W
   -1,  5, -1, -1, -1, -1, -1, -1, // X to Z
   -1,'A',  2, 12, -1, -1, -1,  8, // a to g
   -1, -1, -1, -1,  7, -1,'N', -1, // f to o
    9, -1,'R', -1, 10, -1, 11, -1, // p to w
   -1,  5, -1, -1, -1, -1, -1, -1  // x to z
};

/************************************************************
 *   Functions
 ************************************************************/

/***************************************************************************++

    Converts three letters of a month to numeric month

    Arguments:
        s   String to convert

    Returns:
        numeric equivalent, 0 on failure.

--***************************************************************************/
__inline
SHORT
NumericToAsciiMonth(
    PCHAR s
    )
{
    UCHAR monthIndex;
    UCHAR c;
    PSTR monthString;

    //
    // use the third character as the index
    //

    c = (s[2] - 0x40) & 0x3F;

    monthIndex = MonthIndexTable[c];

    if ( monthIndex < 13 ) {
        goto verify;
    }

    //
    // ok, we need to look at the second character
    //

    if ( monthIndex == 'N' ) {

        //
        // we got an N which we need to resolve further
        //

        //
        // if s[1] is 'u' then Jun, if 'a' then Jan
        //

        if ( MonthIndexTable[(s[1]-0x40) & 0x3f] == 'A' ) {
            monthIndex = 1;
        } else {
            monthIndex = 6;
        }

    } else if ( monthIndex == 'R' ) {

        //
        // if s[1] is 'a' then March, if 'p' then April
        //

        if ( MonthIndexTable[(s[1]-0x40) & 0x3f] == 'A' ) {
            monthIndex = 3;
        } else {
            monthIndex = 4;
        }
    } else {
        goto error_exit;
    }

verify:

    monthString = (PSTR) s_rgchMonths[monthIndex-1];

    if ( (s[0] == monthString[0]) &&
         (s[1] == monthString[1]) &&
         (s[2] == monthString[2]) ) {

        return(monthIndex);

    } else if ( (toupper(s[0]) == monthString[0]) &&
                (tolower(s[1]) == monthString[1]) &&
                (tolower(s[2]) == monthString[2]) ) {

        return monthIndex;
    }

error_exit:
    return(0);

} // NumericToAsciiMonth


/***************************************************************************++

  Converts a string representation of a GMT time (three different
  varieties) to an NT representation of a file time.

  We handle the following variations:

    Sun, 06 Nov 1994 08:49:37 GMT   (RFC 822 updated by RFC 1123)
    Sunday, 06-Nov-94 08:49:37 GMT  (RFC 850)
    Sun Nov  6 08:49:37 1994        (ANSI C's asctime() format)

  Arguments:
    pTimeString         String representation of time field
    TimeStringLength    Length of the string representation of time field
    pTime               Large integer containing the time in NT format

  Returns:
    TRUE on success and FALSE on failure.

  History:

    Johnl       24-Jan-1995     Modified from WWW library
    ericsten    30-Nov-2000     Ported from user-mode W3SVC

--***************************************************************************/
BOOLEAN
StringTimeToSystemTime(
    IN  PCSTR pTimeString,
    IN  USHORT TimeStringLength,
    OUT LARGE_INTEGER *pTime
    )
{
    PSTR pString;
    TIME_FIELDS Fields;
    USHORT Length;

    if (NULL == pTimeString)
    {
        return FALSE;
    }

    Fields.Milliseconds = 0;
    Length = 0;
    
    while (Length < TimeStringLength && ',' != pTimeString[Length])
    {
        Length++;
    }

    if (Length < TimeStringLength)
    {
        //
        // Thursday, 10-Jun-93 01:29:59 GMT
        // or: Thu, 10 Jan 1993 01:29:59 GMT
        //

        Length++;
        pString = (PSTR) &pTimeString[Length];

        while (Length < TimeStringLength && ' ' == *pString)
        {
            Length++;
            pString++;
        }

        if ((TimeStringLength - Length) < 18)
        {
            return FALSE;
        }

        if ('-' == *(pString + 2))
        {
            //
            // First format: Thursday, 10-Jun-93 01:29:59 GMT
            //

            if ('-' == *(pString + 6) &&
                ' ' == *(pString + 9) &&
                ':' == *(pString + 12) &&
                ':' == *(pString + 15))
            {
                Fields.Day      = AsciiToShort(pString);
                Fields.Month    = NumericToAsciiMonth(pString + 3);
                Fields.Year     = AsciiToShort(pString + 7);
                Fields.Hour     = AsciiToShort(pString + 10);
                Fields.Minute   = AsciiToShort(pString + 13);
                Fields.Second   = AsciiToShort(pString + 16);
            }
            else
            {
                return FALSE;
            }
        }
        else
        {
            //
            // Second format: Thu, 10 Jan 1993 01:29:59 GMT
            //

            if ((TimeStringLength - Length) < 20)
            {
                return FALSE;
            }

            if (' ' == *(pString + 2) &&
                ' ' == *(pString + 6) &&
                ' ' == *(pString + 11) &&
                ':' == *(pString + 14) &&
                ':' == *(pString + 17))
            {
                Fields.Day      = TwoAsciisToShort(pString);
                Fields.Month    = NumericToAsciiMonth(pString + 3);
                Fields.Year     = TwoAsciisToShort(pString + 7) * 100 +
                                  TwoAsciisToShort(pString + 9);
                Fields.Hour     = TwoAsciisToShort(pString + 12);
                Fields.Minute   = TwoAsciisToShort(pString + 15);
                Fields.Second   = TwoAsciisToShort(pString + 18);
            }
            else
            {
                return FALSE;
            }
        }
    }
    else
    {
        //
        // Thu Jun  9 01:29:59 1993 GMT
        //

        Length = 0;
        pString = (PSTR) pTimeString;

        while (Length < TimeStringLength && ' ' == *pString)
        {
            Length++;
            pString++;
        }

        if ((TimeStringLength - Length) < 24)
        {
            return FALSE;
        }

        if (' ' != *(pString + 3) ||
            ' ' != *(pString + 7) ||
            ' ' != *(pString + 10) ||
            ':' != *(pString + 13) ||
            ':' != *(pString + 16))
        {
            return FALSE;
        }

        if (isdigit(*(pString + 8)))
        {
            Fields.Day  = AsciiToShort(pString + 8);
        }
        else
        {
            if (' ' != *(pString + 8))
            {
                return FALSE;
            }
            Fields.Day  = AsciiToShort(pString + 9);
        }
        Fields.Month    = NumericToAsciiMonth(pString + 4);
        Fields.Year     = AsciiToShort(pString + 20);
        Fields.Hour     = AsciiToShort(pString + 11);
        Fields.Minute   = AsciiToShort(pString + 14);
        Fields.Second   = AsciiToShort(pString + 17);
    }

    //
    //  Adjust for dates with only two digits
    //

    if (Fields.Year < 1000)
    {
        if (Fields.Year < 50)
        {
            Fields.Year += 2000;
        }
        else
        {
            Fields.Year += 1900;
        }
    }

    return RtlTimeFieldsToTime(&Fields, pTime);
}

/***************************************************************************++
  End of DateTime function ported from user mode W3SVC
--***************************************************************************/


/*++

Routine Description:
    Search input list of ETags for one that matches our local ETag.
    All strings must be NULL terminated (ANSI C strings).

Arguments:
    pLocalETag   - The local ETag we're using.
    pETagList    - The ETag list we've received from the client.
    bWeakCompare - Whether using Weak Comparison is ok

Returns:

    FIND_ETAG_STATUS value:
      ETAG_FOUND       - pLocalETag was found on the list
      ETAG_NOT_FOUND   - pLocalETag was NOT found on the list
      ETAG_PARSE_ERROR - one (or more) elements on the list were invalid

Author:
     Anil Ruia (AnilR)            3-Apr-2000

History:
     Eric Stenson (EricSten)      6-Dec-2000    ported from user-mode


--*/
FIND_ETAG_STATUS
FindInETagList(
    IN PUCHAR    pLocalETag,
    IN PUCHAR    pETagList,
    IN BOOLEAN   fWeakCompare
    )
{
    ULONG     QuoteCount;
    PUCHAR    pFileETag;
    BOOLEAN   Matched;

    // We'll loop through the ETag string, looking for ETag to
    // compare, as long as we have an ETag to look at.

    do
    {
        while (IS_HTTP_LWS(*pETagList))
        {
            pETagList++;
        }

        if (!*pETagList)
        {
            // Ran out of ETag.
            return ETAG_NOT_FOUND;
        }

        // If this ETag is *, it's a match.
        if (*pETagList == '*')
        {
            return ETAG_FOUND;
        }

        // See if this ETag is weak.
        if (pETagList[0] == 'W' && pETagList[1] == '/')
        {
            // This is a weak validator. If we're not doing the weak
            // comparison, fail.

            if (!fWeakCompare)
            {
                return ETAG_NOT_FOUND;
            }

            // Skip over the 'W/', and any intervening whitespace.
            pETagList += 2;

            while (IS_HTTP_LWS(*pETagList))
            {
                pETagList++;
            }

            if (!*pETagList)
            {
                // Ran out of ETag.
                return ETAG_PARSE_ERROR;
            }
        }

        if (*pETagList != '"')
        {
            // This isn't a quoted string, so fail.
            return ETAG_PARSE_ERROR;
        }

        // OK, right now we should be at the start of a quoted string that
        // we can compare against our current ETag.

        QuoteCount = 0;

        Matched = TRUE;
        pFileETag = pLocalETag;

        // Do the actual compare. We do this by scanning the current ETag,
        // which is a quoted string. We look for two quotation marks, the
        // the delimiters of the quoted string. If after we find two quotes
        // in the ETag everything has matched, then we've matched this ETag.
        // Otherwise we'll try the next one.

        do
        {
            UCHAR Temp;

            Temp = *pETagList;

            if (IS_HTTP_CTL(Temp))
            {
                return ETAG_PARSE_ERROR;
            }

            if (Temp == '"')
            {
                QuoteCount++;
            }

            if (*pFileETag != Temp)
            {
                Matched = FALSE;
                
                // at this point, we can skip the current 
                // ETag on the list.
                break;
            }

            pETagList++;

            if (*pFileETag == '\0')
            {
                break;
            }

            pFileETag++;


        }
        while (QuoteCount != 2);

        if (Matched)
        {
            return ETAG_FOUND;
        }

        // Otherwise, at this point we need to look at the next ETag.

        while (QuoteCount != 2)
        {
            if (*pETagList == '"')
            {
                QuoteCount++;
            }
            else
            {
                if (IS_HTTP_CTL(*pETagList))
                {
                    return ETAG_PARSE_ERROR;
                }
            }

            pETagList++;
        }

        while (IS_HTTP_LWS(*pETagList))
        {
            pETagList++;
        }

        if (*pETagList == ',')
        {
            pETagList++;
        }
        else
        {
            return ETAG_NOT_FOUND;
        }

    } while ( *pETagList );

    return ETAG_NOT_FOUND;

} // FindInETagList



/*++

Routine Description:
    Build a NULL-terminated ANSI string from the IP address

Arguments:
    IpAddressString     - String buffer to place the ANSI string
                          (caller allocated)
    TdiAddress          - TDI address to be converted
    TdiAddressType      - type of address at TdiAddress

Returns:

    Count of bytes written into IpAddressString.
    Not including the terminating null.

--*/

USHORT
HostAddressAndPortToString(
    OUT PUCHAR IpAddressString,
    IN  PVOID  TdiAddress,
    IN  USHORT TdiAddressType
    )
{
    PCHAR psz = (PCHAR) IpAddressString;

    if (TdiAddressType == TDI_ADDRESS_TYPE_IP)
    {
        PTDI_ADDRESS_IP pIPv4Address = ((PTDI_ADDRESS_IP) TdiAddress);
        struct in_addr IPv4Addr
            = * (struct in_addr UNALIGNED*) &pIPv4Address->in_addr;
        USHORT IpPortNum = SWAP_SHORT(pIPv4Address->sin_port);
    
        psz = RtlIpv4AddressToStringA(&IPv4Addr, psz);
        *psz++ = ':';
        psz = UlStrPrintUlong(psz, IpPortNum, '\0');
    }
    else if (TdiAddressType == TDI_ADDRESS_TYPE_IP6)
    {
        PTDI_ADDRESS_IP6 pIPv6Address = ((PTDI_ADDRESS_IP6) TdiAddress);
        struct in6_addr IPv6Addr
            = * (struct in6_addr UNALIGNED*) &pIPv6Address->sin6_addr[0];
        USHORT IpPortNum = SWAP_SHORT(pIPv6Address->sin6_port);

        *psz++ = '[';
        psz = RtlIpv6AddressToStringA(&IPv6Addr, psz);
        *psz++ = ']';
        *psz++ = ':';
        psz = UlStrPrintUlong(psz, IpPortNum, '\0');
    }
    else
    {
        ASSERT(! "Unexpected TdiAddressType");
        *psz = '\0';
    }

    return DIFF_USHORT(psz - (PCHAR) IpAddressString);

} // HostAddressAndPortToString

/****************************************************************************++

Routine Description:
    Build a NULL terminated UNICODE string from the IP address & port.

Arguments:
    IpAddressStringW    - String buffer to place the UNICODE string
                          (caller allocated)
    TdiAddress          - TDI address to be converted
    TdiAddressType      - type of address at TdiAddress

Returns:

    Count of bytes written into IpAddressStringW.
    Not including the terminating null.

--****************************************************************************/
USHORT
HostAddressAndPortToStringW(
    PWCHAR  IpAddressStringW,
    PVOID   TdiAddress,
    USHORT  TdiAddressType
    )
{
    PWCHAR pszW = IpAddressStringW;

    if (TdiAddressType == TDI_ADDRESS_TYPE_IP)
    {
        PTDI_ADDRESS_IP pIPv4Address = ((PTDI_ADDRESS_IP) TdiAddress);
        struct in_addr IPv4Addr
            = * (struct in_addr UNALIGNED*) &pIPv4Address->in_addr;
        USHORT IpPortNum = SWAP_SHORT(pIPv4Address->sin_port);
    
        pszW = RtlIpv4AddressToStringW(&IPv4Addr, pszW);
        *pszW++ = L':';
        pszW = UlStrPrintUlongW(pszW, IpPortNum, 0, L'\0');        
    }
    else if (TdiAddressType == TDI_ADDRESS_TYPE_IP6)
    {
        PTDI_ADDRESS_IP6 pIPv6Address = ((PTDI_ADDRESS_IP6) TdiAddress);
        struct in6_addr IPv6Addr
            = * (struct in6_addr UNALIGNED*) &pIPv6Address->sin6_addr[0];
        USHORT IpPortNum = SWAP_SHORT(pIPv6Address->sin6_port);

        *pszW++ = L'[';
        pszW = RtlIpv6AddressToStringW(&IPv6Addr, pszW);
        *pszW++ = L']';
        *pszW++ = L':';
        pszW = UlStrPrintUlongW(pszW, IpPortNum, 0, L'\0');
    }
    else
    {
        ASSERT(! "Unexpected TdiAddressType");
        *pszW = L'\0';
    }

    return (DIFF_USHORT(pszW - IpAddressStringW) * sizeof(WCHAR));

} // HostAddressAndPortToString



/*++

Routine Description:
    Build a NULL terminated UNICODE string from the IP address

Arguments:
    IpAddressStringW    - String buffer to place the UNICODE string
                          (caller allocated)
    TdiAddress          - TDI address to be converted
    TdiAddressType      - type of address at TdiAddress

Returns:

    Count of bytes written into IpAddressStringW.
    Not including the terminating null.

--*/

USHORT
HostAddressToStringW(
    OUT PWCHAR   IpAddressStringW,
    IN  PVOID    TdiAddress,
    IN  USHORT   TdiAddressType
    )
{
    PWCHAR pszW = IpAddressStringW;

    if (TdiAddressType == TDI_ADDRESS_TYPE_IP)
    {
        PTDI_ADDRESS_IP pIPv4Address = ((PTDI_ADDRESS_IP) TdiAddress);
        struct in_addr IPv4Addr
            = * (struct in_addr UNALIGNED*) &pIPv4Address->in_addr;
    
        pszW = RtlIpv4AddressToStringW(&IPv4Addr, pszW);
        *pszW = L'\0';
    }
    else if (TdiAddressType == TDI_ADDRESS_TYPE_IP6)
    {
        PTDI_ADDRESS_IP6 pIPv6Address = ((PTDI_ADDRESS_IP6) TdiAddress);
        struct in6_addr IPv6Addr
            = * (struct in6_addr UNALIGNED*) &pIPv6Address->sin6_addr[0];

        *pszW++ = L'[';
        pszW = RtlIpv6AddressToStringW(&IPv6Addr, pszW);
        *pszW++ = L']';
        *pszW = L'\0';
    }
    else
    {
        ASSERT(! "Unexpected TdiAddressType");
        *pszW = L'\0';
    }

    return (DIFF_USHORT(pszW - IpAddressStringW) * sizeof(WCHAR));
    
} // HostAddressToStringW



/*++

Routine Description:
    Build a NULL terminated routing token UNICODE string from 
    the IP address and port.
    e.g
        1.1.1.1:80:1.1.1.1

Arguments:
    IpAddressStringW    - String buffer to place the UNICODE string
                          (caller allocated)
    TdiAddress          - TDI address to be converted
    TdiAddressType      - type of address at TdiAddress

Returns:

    Count of bytes written into IpAddressStringW.
    Not including the terminating null.

--*/

USHORT
HostAddressAndPortToRoutingTokenW(
    OUT PWCHAR   IpAddressStringW,
    IN  PVOID    TdiAddress,
    IN  USHORT   TdiAddressType
    )
{
    PWCHAR pszW = IpAddressStringW;

    //
    // WARNING:
    // Provided buffer should be at least as big as
    // MAX_IP_BASED_ROUTING_TOKEN_LENGTH.
    //

    if (TdiAddressType == TDI_ADDRESS_TYPE_IP)
    {
        PTDI_ADDRESS_IP pIPv4Address = ((PTDI_ADDRESS_IP) TdiAddress);
        struct in_addr IPv4Addr
            = * (struct in_addr UNALIGNED*) &pIPv4Address->in_addr;
        USHORT IpPortNum = SWAP_SHORT(pIPv4Address->sin_port);
    
        pszW = RtlIpv4AddressToStringW(&IPv4Addr, pszW);
        *pszW++ = L':';
        pszW = UlStrPrintUlongW(pszW, IpPortNum, 0, L':');        
        pszW = RtlIpv4AddressToStringW(&IPv4Addr, pszW);
        *pszW = L'\0';        
    }
    else if (TdiAddressType == TDI_ADDRESS_TYPE_IP6)
    {
        PTDI_ADDRESS_IP6 pIPv6Address = ((PTDI_ADDRESS_IP6) TdiAddress);
        struct in6_addr IPv6Addr
            = * (struct in6_addr UNALIGNED*) &pIPv6Address->sin6_addr[0];
        USHORT IpPortNum = SWAP_SHORT(pIPv6Address->sin6_port);

        *pszW++ = L'[';
        pszW = RtlIpv6AddressToStringW(&IPv6Addr, pszW);
        *pszW++ = L']';
        *pszW++ = L':';
        pszW = UlStrPrintUlongW(pszW, IpPortNum, 0, L':');
        *pszW++ = L'[';
        pszW = RtlIpv6AddressToStringW(&IPv6Addr, pszW);
        *pszW++ = L']';
        *pszW = L'\0';   
    }
    else
    {
        ASSERT(! "Unexpected TdiAddressType");
        *pszW = L'\0';
    }

    return DIFF_USHORT(pszW - IpAddressStringW) * sizeof(WCHAR);
    
} // HostAddressAndPortToRoutingTokenW


/*++

Routine Description:

    Calculates current bias (daylight time aware) and time zone ID.    

    Captured from base\client\datetime.c

    Until this two functions are exposed in the kernel we have to 
    keep them here.
    
Arguments:

    IN CONST TIME_ZONE_INFORMATION *ptzi - time zone for which to calculate bias
    OUT KSYSTEM_TIME *pBias - current bias

Return Value:

    TIME_ZONE_ID_UNKNOWN - daylight saving time is not used in the 
        current time zone.

    TIME_ZONE_ID_STANDARD - The system is operating in the range covered
        by StandardDate.

    TIME_ZONE_ID_DAYLIGHT - The system is operating in the range covered
        by DaylightDate.

    TIME_ZONE_ID_INVALID - The operation failed.

--*/

ULONG 
UlCalcTimeZoneIdAndBias(
     IN  RTL_TIME_ZONE_INFORMATION *ptzi,
     OUT PLONG pBias
     )
{
    LARGE_INTEGER TimeZoneBias;
    LARGE_INTEGER NewTimeZoneBias;
    LARGE_INTEGER LocalCustomBias;
    LARGE_INTEGER UtcStandardTime;
    LARGE_INTEGER UtcDaylightTime;
    LARGE_INTEGER StandardTime;
    LARGE_INTEGER DaylightTime;
    LARGE_INTEGER CurrentUniversalTime;
    ULONG CurrentTimeZoneId = UL_TIME_ZONE_ID_INVALID;
    
    NewTimeZoneBias.QuadPart = Int32x32To64(ptzi->Bias * 60, C_NS_TICKS_PER_SEC);

    //
    // Now see if we have stored cutover times
    //
    
    if (ptzi->StandardStart.Month && ptzi->DaylightStart.Month) 
    {       
        KeQuerySystemTime(&CurrentUniversalTime);

        //
        // We have timezone cutover information. Compute the
        // cutover dates and compute what our current bias
        // is
        //

        if((!UlpCutoverTimeToSystemTime(
                    &ptzi->StandardStart,
                    &StandardTime,
                    &CurrentUniversalTime)
                    ) || 
           (!UlpCutoverTimeToSystemTime(
                    &ptzi->DaylightStart,
                    &DaylightTime,
                    &CurrentUniversalTime)
                    )
           ) 
        {
            return UL_TIME_ZONE_ID_INVALID;
        }

        //
        // Convert standard time and daylight time to utc
        //

        LocalCustomBias.QuadPart = Int32x32To64(ptzi->StandardBias*60, C_NS_TICKS_PER_SEC);
        TimeZoneBias.QuadPart = NewTimeZoneBias.QuadPart + LocalCustomBias.QuadPart;
        UtcDaylightTime.QuadPart = DaylightTime.QuadPart + TimeZoneBias.QuadPart;

        LocalCustomBias.QuadPart = Int32x32To64(ptzi->DaylightBias*60, C_NS_TICKS_PER_SEC);
        TimeZoneBias.QuadPart = NewTimeZoneBias.QuadPart + LocalCustomBias.QuadPart;
        UtcStandardTime.QuadPart = StandardTime.QuadPart + TimeZoneBias.QuadPart;

        //
        // If daylight < standard, then time >= daylight and
        // less than standard is daylight
        //

        if (UtcDaylightTime.QuadPart < UtcStandardTime.QuadPart) 
        {
            //
            // If today is >= DaylightTime and < StandardTime, then
            // We are in daylight savings time
            //

            if ((CurrentUniversalTime.QuadPart >= UtcDaylightTime.QuadPart) &&
                (CurrentUniversalTime.QuadPart < UtcStandardTime.QuadPart)) 
            {
                CurrentTimeZoneId = UL_TIME_ZONE_ID_DAYLIGHT;
            } 
            else 
            {
                CurrentTimeZoneId = UL_TIME_ZONE_ID_STANDARD;
            }
        } 
        else 
        {
            //
            // If today is >= StandardTime and < DaylightTime, then
            // We are in standard time
            //

            if ((CurrentUniversalTime.QuadPart >= UtcStandardTime.QuadPart) &&
                (CurrentUniversalTime.QuadPart < UtcDaylightTime.QuadPart)) 
            {
                CurrentTimeZoneId = UL_TIME_ZONE_ID_STANDARD;

            } 
            else 
            {
                CurrentTimeZoneId = UL_TIME_ZONE_ID_DAYLIGHT;
            }
        }

        // Bias in minutes
        
        *pBias = ptzi->Bias + (CurrentTimeZoneId == UL_TIME_ZONE_ID_DAYLIGHT ?
                                ptzi->DaylightBias : ptzi->StandardBias
                                );
        
    } 
    else 
    {
        *pBias = ptzi->Bias;
        CurrentTimeZoneId = UL_TIME_ZONE_ID_UNKNOWN;
    }

    return CurrentTimeZoneId;
} // UlCalcTimeZoneIdAndBias



BOOLEAN
UlpCutoverTimeToSystemTime(
    PTIME_FIELDS    CutoverTime,
    PLARGE_INTEGER  SystemTime,
    PLARGE_INTEGER  CurrentSystemTime
    )
{
    TIME_FIELDS     CurrentTimeFields;

    //
    // Get the current system time
    //

    RtlTimeToTimeFields(CurrentSystemTime,&CurrentTimeFields);

    //
    // check for absolute time field. If the year is specified,
    // the the time is an abosulte time
    //

    if ( CutoverTime->Year ) 
    {
        return FALSE;
    }
    else 
    {
        TIME_FIELDS WorkingTimeField;
        TIME_FIELDS ScratchTimeField;
        LARGE_INTEGER ScratchTime;
        CSHORT BestWeekdayDate;
        CSHORT WorkingWeekdayNumber;
        CSHORT TargetWeekdayNumber;
        CSHORT TargetYear;
        CSHORT TargetMonth;
        CSHORT TargetWeekday;     // range [0..6] == [Sunday..Saturday]
        BOOLEAN MonthMatches;
        //
        // The time is an day in the month style time
        //
        // the convention is the Day is 1-5 specifying 1st, 2nd... Last
        // day within the month. The day is WeekDay.
        //

        //
        // Compute the target month and year
        //

        TargetWeekdayNumber = CutoverTime->Day;
        if ( TargetWeekdayNumber > 5 || TargetWeekdayNumber == 0 ) {
            return FALSE;
            }
        TargetWeekday = CutoverTime->Weekday;
        TargetMonth = CutoverTime->Month;
        MonthMatches = FALSE;
        
        TargetYear = CurrentTimeFields.Year;
        
        try_next_year:
            
        BestWeekdayDate = 0;

        WorkingTimeField.Year = TargetYear;
        WorkingTimeField.Month = TargetMonth;
        WorkingTimeField.Day = 1;
        WorkingTimeField.Hour = CutoverTime->Hour;
        WorkingTimeField.Minute = CutoverTime->Minute;
        WorkingTimeField.Second = CutoverTime->Second;
        WorkingTimeField.Milliseconds = CutoverTime->Milliseconds;
        WorkingTimeField.Weekday = 0;

        //
        // Convert to time and then back to time fields so we can determine
        // the weekday of day 1 on the month
        //

        if ( !RtlTimeFieldsToTime(&WorkingTimeField,&ScratchTime) ) {
            return FALSE;
            }
        RtlTimeToTimeFields(&ScratchTime,&ScratchTimeField);

        //
        // Compute bias to target weekday
        //
        if ( ScratchTimeField.Weekday > TargetWeekday ) {
            WorkingTimeField.Day += (7-(ScratchTimeField.Weekday - TargetWeekday));
            }
        else if ( ScratchTimeField.Weekday < TargetWeekday ) {
            WorkingTimeField.Day += (TargetWeekday - ScratchTimeField.Weekday);
            }

        //
        // We are now at the first weekday that matches our target weekday
        //

        BestWeekdayDate = WorkingTimeField.Day;
        WorkingWeekdayNumber = 1;

        //
        // Keep going one week at a time until we either pass the
        // target weekday, or we match exactly
        //

        while ( WorkingWeekdayNumber < TargetWeekdayNumber ) {
            WorkingTimeField.Day += 7;
            if ( !RtlTimeFieldsToTime(&WorkingTimeField,&ScratchTime) ) {
                break;
                }
            RtlTimeToTimeFields(&ScratchTime,&ScratchTimeField);
            WorkingWeekdayNumber++;
            BestWeekdayDate = ScratchTimeField.Day;
            }
        WorkingTimeField.Day = BestWeekdayDate;

        //
        // If the months match, and the date is less than the current
        // date, then be have to go to next year.
        //

        if ( !RtlTimeFieldsToTime(&WorkingTimeField,&ScratchTime) ) {
            return FALSE;
            }
        if ( MonthMatches ) {
            if ( WorkingTimeField.Day < CurrentTimeFields.Day ) {
                MonthMatches = FALSE;
                TargetYear++;
                goto try_next_year;
                }
            if ( WorkingTimeField.Day == CurrentTimeFields.Day ) {

                if (ScratchTime.QuadPart < CurrentSystemTime->QuadPart) {
                    MonthMatches = FALSE;
                    TargetYear++;
                    goto try_next_year;
                    }
                }
            }
        *SystemTime = ScratchTime;

        return TRUE;
        }
} // UlpCutoverTimeToSystemTime



/*++

Routine Description:
    Predicate for testing if system is close to being out of Non-Paged 
    Pool memory

Notes:
    The Right Thing(tm) would be to query the value of
    MmMaximumNonPagedPoolInBytes (%SDXROOT%\base\ntos\mm\miglobal.c).
    However, this value is not exposed outside of the memory manager.
    
    (from LandyW) "A crude workaround for now would be for your driver
    to periodically allocate a big chunk of pool and if it fails, you
    know you are low.  If it works, then just return it." (27-Jul-2001)

    We check to see if there is 3MB of NPP available.  To avoid frag-
    mentation issue, we do this in small chunks, tallying up to 3MB.

Returns:

    TRUE - System is low on non-paged pool
    FALSE - System is NOT low on non-paged pool

--*/

//
// NOTE: (NPP_CHUNK_COUNT * NPP_CHUNK_SIZE) == 3MB
//
#define NPP_CHUNK_SIZE  (128 * 1024)
#define NPP_CHUNK_COUNT ((3 * 1024 * 1024) / NPP_CHUNK_SIZE)


BOOLEAN
UlIsLowNPPCondition( VOID )
{
    BOOLEAN  bRet;
    PVOID    aPtrs[NPP_CHUNK_COUNT];
    int      i;

    //
    // Optimisim is a good thing.
    //
    bRet = FALSE;

    RtlZeroMemory( aPtrs, sizeof(aPtrs) );

    //
    // To avoid failing an allocation on a fragmentation issue, we
    // allocate multiple smaller chunks, which brings us to 3MB of
    // NonPagedPool.  If we fail on any of the allocs, we know we're
    // nearly out of NPP, and are in a Low NPP Condition.
    //

    for (i = 0 ; i < NPP_CHUNK_COUNT ; i++ )
    {
        aPtrs[i] = UL_ALLOCATE_POOL(
                        NonPagedPool,
                        NPP_CHUNK_SIZE, // 128K
                        UL_AUXILIARY_BUFFER_POOL_TAG
                        );
        
        if ( !aPtrs[i] )
        {
            // Alloc failed!  We're in a low-NPP condition!
            bRet = TRUE;
            goto End;
        }
        
    }
    
End:

    //
    // Clean up memory
    //
    
    for ( i = 0; i < NPP_CHUNK_COUNT; i++ )
    {
        if ( aPtrs[i] )
        {
            UL_FREE_POOL(
                aPtrs[i],
                UL_AUXILIARY_BUFFER_POOL_TAG
                );
        }
    }

    return bRet;
} // UlIsLowNPPCondition



/***************************************************************************++

Routine Description:

    Generates a hex string from a ULONG. The incoming buffer must be big enough
    to hold "12345678" plus the nul terminator.

Arguments:

    n      - input ULONG

Return Value:

    a pointer to the end of the string
    
--***************************************************************************/

PSTR
UlUlongToHexString(
    ULONG n, 
    PSTR wszHexDword
    )
{
    const int ULONGHEXDIGITS = sizeof(ULONG) * 2;
    PSTR p = wszHexDword;

    unsigned shift = (sizeof(ULONG) * 8) - 4;
    ULONG mask = 0xFu << shift;
    int i;

    for (i = 0; i < ULONGHEXDIGITS; ++i, mask >>= 4, shift -= 4)
    {
        unsigned digit = (unsigned) ((n & mask) >> shift);
        p[i] = hexArray[digit];
    }

    return p+i;

} // UlUlongToHexString


/***************************************************************************++

Routine Description:

    This function does what strstr does, but assumes that str1 is not NULL
    terminated. str2 is NULL terminated.

Arguments:
    str1 - the input string
    str2 - the substring
    length - length of input string

Return Value:
    offset of the substring, NULL if none found.

--***************************************************************************/
char *
UxStrStr(
    const char *str1, 
    const char *str2,
    ULONG length
   )
{
    char *cp = (char *) str1;
    char *s1, *s2;
    ULONG l1;

    if ( !*str2 )
        return((char *)str1);

    while (length)
    {       
        l1 = length;
        s1 = cp;
        s2 = (char *) str2;

        while ( l1 && *s2 && !(*s1-*s2) )
            l1--, s1++, s2++;

        if (!*s2)
            return(cp);

        cp++;
        length --;
    }

    return(NULL);
}

/***************************************************************************++

Routine Description:

    This function does what strstr does, but assumes that str1 is not NULL
    terminated. str2 is NULL terminated.

Arguments:
    str1 - the input string
    str2 - the substring
    length - length of input string

Return Value:
    offset of the substring, NULL if none found.

--***************************************************************************/
char *
UxStriStr(
    const char *str1, 
    const char *str2,
    ULONG length1
   )
{
    ULONG length2;

    length2 = (ULONG) strlen(str2);

    while (length1 >= length2 )
    {       
        if(_strnicmp(str1, str2, length2) == 0)
            return ((char *)str1);

        str1 ++;
        length1 --;
    }

    return(NULL);
}


/**************************************************************************++

Routine Description:

    This routine encodes binary data in base64 format.  It does not spilt
    encoded base64 data across lines.

Arguments:

    pBinaryData - Supplied pointer to binary data to encode.
    BinaryDataLen - Supplies length of binary data in bytes.
    pBase64Data - Supplies output buffer where base64 data will be written.
    Base64DataLen - Supplies length of output buffer in bytes.
    BytesWritten - Returns the number of bytes written in the output buffer.

Return Value:

    NTSTATUS.

--**************************************************************************/
NTSTATUS
BinaryToBase64(
    IN  PUCHAR pBinaryData,
    IN  ULONG  BinaryDataLen,
    IN  PUCHAR pBase64Data,
    IN  ULONG  Base64DataLen,
    OUT PULONG BytesWritten
    )
{
    NTSTATUS Status;
    ULONG    RequiredBase64Len;
    ULONG    i;
    UCHAR    o0, o1, o2, o3;
    UCHAR    end24bits[3];
    PUCHAR   p, pOrig;

//
// N.B. The following macros only work with UCHAR's (because of >> operator.)
//

#define UPPER_6_BITS(c) (((c) & 0xfc) >> 2)
#define UPPER_4_BITS(c) (((c) & 0xf0) >> 4)
#define UPPER_2_BITS(c) (((c) & 0xc0) >> 6)

#define LOWER_2_BITS(c) ((c) & 0x03)
#define LOWER_4_BITS(c) ((c) & 0x0f)
#define LOWER_6_BITS(c) ((c) & 0x3f)

    // Sanity Check.
    ASSERT(pBinaryData && BinaryDataLen);
    ASSERT(pBase64Data && Base64DataLen);
    ASSERT(BytesWritten);

    // Initialize output argument.
    *BytesWritten = 0;

    //
    // Check if the output buffer can contain base64 encoded data.
    //

    Status = BinaryToBase64Length(BinaryDataLen, &RequiredBase64Len);

    if (!NT_SUCCESS(Status))
    {
        return Status;
    }

    if (RequiredBase64Len > Base64DataLen)
    {
        return STATUS_BUFFER_TOO_SMALL;
    }

    // Return the number of bytes written.
    *BytesWritten = RequiredBase64Len;

    p     = pBinaryData;
    pOrig = pBase64Data;

    for (i = 0; i + 3 <= BinaryDataLen; i += 3)
    {
        //
        // Encode 3 bytes at indices i, i+1, i+2.
        //

        o0 = UPPER_6_BITS(p[i]);
        o1 = (LOWER_2_BITS(p[i]) << 4) | UPPER_4_BITS(p[i+1]);
        o2 = (LOWER_4_BITS(p[i+1]) << 2) | UPPER_2_BITS(p[i+2]);
        o3 = LOWER_6_BITS(p[i+2]);

        ASSERT(o0 < 64 && o1 < 64 && o2 < 64 && o3 < 64);

        //
        // Encode binary bytes and write out the base64 bytes.
        //

        *pBase64Data++ = BinaryToBase64Table[o0];
        *pBase64Data++ = BinaryToBase64Table[o1];
        *pBase64Data++ = BinaryToBase64Table[o2];
        *pBase64Data++ = BinaryToBase64Table[o3];
    }

    if (i < BinaryDataLen)
    {
        //
        // Zero pad the remaining bits to get 24 bits.
        //

        end24bits[0] = p[i];
        end24bits[1] = (BinaryDataLen > i+1) ? p[i+1] : '\0';
        end24bits[2] = '\0';

        o0 = UPPER_6_BITS(end24bits[0]);
        o1 = (LOWER_2_BITS(end24bits[0]) << 4) | UPPER_4_BITS(end24bits[1]);
        o2 = (LOWER_4_BITS(end24bits[1]) << 2) | UPPER_2_BITS(end24bits[2]);

        pBase64Data[0] = BinaryToBase64Table[o0];
        pBase64Data[1] = BinaryToBase64Table[o1];
        pBase64Data[2] = BinaryToBase64Table[o2];

        pBase64Data[3] = '=';
        pBase64Data[2] = (BinaryDataLen > i+1) ? pBase64Data[2] : '=';

        ASSERT(pBase64Data + 4 == pOrig + RequiredBase64Len);
    }
    else
    {
        ASSERT(pBase64Data == pOrig + RequiredBase64Len);
    }

    return STATUS_SUCCESS;
}


/**************************************************************************++

Routine Description:

    This routine decodes Base64 encoded data to binary format.

Arguments:

    pBase64Data - Supplies pointer to base64 encoded data.
    Base64DataLen - Length of base64 data in bytes.
    pBinaryData - Supplies pointer to a buffer where decoded data will
                  be written.
    BinaryDataLen - Supplied the length of output buffer in bytes.
    BytesWritten  - Returns the number of bytes written in the output buffer.

Return Value:

    NTSTATUS.

--**************************************************************************/
NTSTATUS
Base64ToBinary(
    IN  PUCHAR pBase64Data,
    IN  ULONG  Base64DataLen,
    IN  PUCHAR pBinaryData,
    IN  ULONG  BinaryDataLen,
    OUT PULONG BytesWritten
    )
{
    ULONG    i;
    UCHAR    b;
    NTSTATUS Status;
    ULONG    RequiredBinaryLen;
    ULONG    BitsAvail, NumBitsAvail;
    PUCHAR   pCurr = pBinaryData;

    // Sanity check.
    ASSERT(pBase64Data && Base64DataLen);
    ASSERT(pBinaryData && BinaryDataLen);
    ASSERT(BytesWritten);

    // Initialize output argument.
    *BytesWritten = 0;

    //
    // Check if output buffer is big enough to hold the data.
    //

    Status = Base64ToBinaryLength(Base64DataLen, &RequiredBinaryLen);

    if (!NT_SUCCESS(Status))
    {
        return Status;
    }

    if (RequiredBinaryLen > BinaryDataLen)
    {
        return STATUS_BUFFER_TOO_SMALL;
    }

    ASSERT(Base64DataLen % 4 == 0);

    BitsAvail = 0;
    NumBitsAvail = 0;

    for (i = 0; i < Base64DataLen; i ++)
    {
        //
        // See if base64 char is valid.  All valid base64 chars are mapped
        // to n where 0 <= n <= 63.  In adition, '=' is also a valid 
        // base64 char.
        //

        b = Base64ToBinaryTable[pBase64Data[i]];

        if (b == INVALID_BASE64_TO_BINARY_TABLE_ENTRY)
        {
            if (pBase64Data[i] != '=')
            {
                return STATUS_INVALID_PARAMETER;
            }
            // Handle '=' outside the for loop.
            break;
        }

        ASSERT(NumBitsAvail < 8);
        ASSERT(0 <= b && b <= 63);

        BitsAvail = (BitsAvail << 6) | b;
        NumBitsAvail += 6;

        if (NumBitsAvail >= 8)
        {
            NumBitsAvail -= 8;
            *pCurr++ = (UCHAR)(BitsAvail >> NumBitsAvail);
        }

        ASSERT(NumBitsAvail < 8);
    }

    if (i < Base64DataLen)
    {
        ASSERT(pBase64Data[i] == '=');

        //
        // There can be at most two '=' chars and they must appear at the end
        // of the encoded data.  A char, if any, that follows '=' char, must
        // be a '='.
        //

        if (i + 2 < Base64DataLen ||
            (i + 1 < Base64DataLen && pBase64Data[i+1] != '='))
        {
            return STATUS_INVALID_PARAMETER;
        }

        //
        // All the remaining bits at this point must be zeros.
        //

        ASSERT(NumBitsAvail > 0 && NumBitsAvail < 8);

        if (BitsAvail & ((1<<NumBitsAvail)-1))
        {
            return STATUS_INVALID_PARAMETER;
        }
    }

    *BytesWritten = (ULONG)(pCurr - pBinaryData);
    ASSERT(*BytesWritten <= BinaryDataLen);

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\miscp.h ===
/*++

Copyright (c) 1998-2002 Microsoft Corporation

Module Name:

    miscp.h

Abstract:

    The private definition of response cache interfaces.

Author:

    George V. Reilly (GeorgeRe)  17-Apr-2002

Revision History:

--*/


#ifndef _MISCP_H_
#define _MISCP_H_


// Invalid base64 chars will be mapped to this value.
#define INVALID_BASE64_TO_BINARY_TABLE_ENTRY 64

//
// Private prototypes.
//

NTSTATUS
UlpRestartDeviceControl(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    IN PVOID pContext
    );

BOOLEAN
UlpCutoverTimeToSystemTime(
    PTIME_FIELDS    CutoverTime,
    PLARGE_INTEGER  SystemTime,
    PLARGE_INTEGER  CurrentSystemTime
    );

#endif // _MISCP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\logutil.c ===
/*++

Copyright (c) 2000-2002 Microsoft Corporation

Module Name:

    logutil.c 

Abstract:

    This module provide various functions which are common to
    the centralized raw logging and the conventional logging
    components.

    It also provides log buffering mechanism.

Author:

    Ali E. Turkoglu (aliTu)       05-Oct-2001

Revision History:

    --- 

--*/

#include "precomp.h"
#include "logutil.h"

//
// Generic Private globals.
//

BOOLEAN         g_InitLogUtilCalled = FALSE;

//
// Used to wait for the logging i/o to exhaust during shutdown.
//

UL_SPIN_LOCK    g_BufferIoSpinLock;
BOOLEAN         g_BufferWaitingForIoComplete = FALSE;
KEVENT          g_BufferIoCompleteEvent;
ULONG           g_BufferIoCount = 0;

//
// For Logging Date & Time caching
//

#define         ONE_SECOND       (10000000)

UL_LOG_DATE_AND_TIME_CACHE
                g_UlDateTimeCache[HttpLoggingTypeMaximum];
LARGE_INTEGER   g_UlLogSystemTime;
FAST_MUTEX      g_LogCacheFastMutex;

//
// This little utility makes life easier.
//

const PSTR _Months[] =
{
    "Jan", "Feb", "Mar", "Apr", "May", "Jun",
    "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
};

#define UL_GET_MONTH_AS_STR(m)                                     \
    ( ((m)>=1) && ((m)<=12) ? _Months[(m)-1] : "Unk" )


#ifdef ALLOC_PRAGMA

//#pragma alloc_text( INIT, UlInitialize... )

#pragma alloc_text( PAGE, UlBuildLogDirectory )
#pragma alloc_text( PAGE, UlRefreshFileName )
#pragma alloc_text( PAGE, UlConstructFileName )
#pragma alloc_text( PAGE, UlCreateSafeDirectory )
#pragma alloc_text( PAGE, UlFlushLogFileBuffer)
#pragma alloc_text( PAGE, UlCloseLogFile)
#pragma alloc_text( PAGE, UlQueryDirectory)
#pragma alloc_text( PAGE, UlGetLogFileLength )
#pragma alloc_text( PAGE, UlCalculateTimeToExpire )
#pragma alloc_text( PAGE, UlProbeLogData )
#pragma alloc_text( PAGE, UlCheckLogDirectory )
#pragma alloc_text( PAGE, UlUpdateLogTruncateSize )
#pragma alloc_text( PAGE, UlComputeCachedLogDataLength )
#pragma alloc_text( PAGE, UlCopyCachedLogData )
#pragma alloc_text( PAGE, UlpInitializeLogBufferGranularity )
#pragma alloc_text( PAGE, UlWriteEventLogEntry )
#pragma alloc_text( PAGE, UlEventLogCreateFailure )
#pragma alloc_text( PAGE, UlQueryLogFileSecurity )
#pragma alloc_text( PAGE, UlQueueLoggingRoutine )
#pragma alloc_text( PAGE, UlpQueueLoggingRoutineWorker )
#pragma alloc_text( PAGE, UlpGenerateDateAndTimeFields )
#pragma alloc_text( PAGE, UlGetDateTimeFields )
#pragma alloc_text( PAGE, UlpFlushLogFileBufferWorker )

#endif // ALLOC_PRAGMA

#if 0
NOT PAGEABLE -- UlpWaitForIoCompletion
NOT PAGEABLE -- UlpBufferFlushAPC
NOT PAGEABLE -- UlSetLogTimer
NOT PAGEABLE -- UlSetBufferTimer

#endif


//
// Public functions.
//

/***************************************************************************++

Routine Description:

    UlInitializeLogUtil :

        Initialize the spinlock for buffer IO

--***************************************************************************/

NTSTATUS
UlInitializeLogUtil (
    VOID
    )
{
    PAGED_CODE();

    ASSERT(!g_InitLogUtilCalled);

    UlTrace(LOG_UTIL,("Http!UlInitializeLogUtil.\n"));

    if (!g_InitLogUtilCalled)
    {
        ULONG AllocationGranularity = 0;
        
        UlInitializeSpinLock(&g_BufferIoSpinLock, "g_BufferIoSpinLock");

        //
        // Get the allocation granularity from the system. It will be used as 
        // log buffer size if there's no registry overwrites.
        //

        AllocationGranularity = UlpInitializeLogBufferGranularity();
        
        //
        // Overwrite the log buffer size with the above value,
        // only if a registry parameter doesn't exist.
        //

        if (g_UlLogBufferSize == 0)
        {
            g_UlLogBufferSize = AllocationGranularity;
        }
        else
        {
            //
            // Proceed with using the registry provided log buffer size
            //
            
            UlTrace(LOG_UTIL,
              ("Http!UlInitializeLogUtil: Log buffer size %d from registry!\n",
                g_UlLogBufferSize
                ));
        }

        UlpInitializeLogCache();
        
        g_InitLogUtilCalled = TRUE;
    }

    return STATUS_SUCCESS;
}

/***************************************************************************++

Routine Description:

    UlTerminateLogUtil :

        Waits for all the buffer IO completes

--***************************************************************************/

VOID
UlTerminateLogUtil(
    VOID
    )
{
    PAGED_CODE();

    if (g_InitLogUtilCalled)
    {
        UlpWaitForIoCompletion();
        g_InitLogUtilCalled = FALSE;
    }
}

/***************************************************************************++

Routine Description:

    Waits for Io Completions to complete on Log Buffers before shutdown.

Arguments:

    None.

--***************************************************************************/
VOID
UlpWaitForIoCompletion(
    VOID
    )
{
    KIRQL   OldIrql;
    BOOLEAN Wait = FALSE;

    ASSERT( g_InitLogUtilCalled );

    UlAcquireSpinLock( &g_BufferIoSpinLock, &OldIrql );

    if ( !g_BufferWaitingForIoComplete )
    {
        g_BufferWaitingForIoComplete = TRUE;

        KeInitializeEvent(
            &g_BufferIoCompleteEvent,
            NotificationEvent,
            FALSE
            );
    }

    //
    // If no more i/o operations are happening we are not going to
    // wait for them. It is not possible for global i/o counter to
    // increment at this time because the log file entry list is empty.
    // If there were outstanding i/o then we have to wait them to be
    // complete.
    //

    if ( g_BufferIoCount > 0 )
    {
        Wait = TRUE;
    }

    UlReleaseSpinLock( &g_BufferIoSpinLock, OldIrql );

    if (Wait)
    {
        KeWaitForSingleObject(
            (PVOID)&g_BufferIoCompleteEvent,
            UserRequest,
            KernelMode,
            FALSE,
            NULL
            );
    }
}

/***************************************************************************++

Routine Description:

    Everytime Aynsc Write Io happens on Log Buffer This APC get called when
    completion happens and decrement the global Io Count. If shutting down
    we set the event.

    This is basically to prevent against shutting down before the Io Complete.

Arguments:

    None.

--***************************************************************************/

VOID
UlpBufferFlushAPC(
    IN PVOID            ApcContext,
    IN PIO_STATUS_BLOCK pIoStatusBlock,
    IN ULONG            Reserved
    )
{
    PUL_LOG_FILE_BUFFER pLogBuffer;
    ULONG               IoCount;
    KIRQL               OldIrql;

    UNREFERENCED_PARAMETER(pIoStatusBlock);
    UNREFERENCED_PARAMETER(Reserved);
    
    //
    // Free the LogBuffer allocated for this write I/o.
    //

    pLogBuffer = (PUL_LOG_FILE_BUFFER) ApcContext;

    ASSERT(IS_VALID_LOG_FILE_BUFFER(pLogBuffer));
    ASSERT(pIoStatusBlock == &pLogBuffer->IoStatusBlock );
    
    UlTrace(LOG_UTIL,
       ("Http!UlpBufferFlushAPC: FileBuffer %p Used %d Status %08lx Count %d\n",
         ApcContext,
         pLogBuffer->BufferUsed,
         pIoStatusBlock->Status,
         (g_BufferIoCount - 1)
         ));

    UlPplFreeLogFileBuffer( pLogBuffer ); 

    //
    // Decrement the global outstanding i/o count.
    //

    IoCount = InterlockedDecrement((PLONG) &g_BufferIoCount);

    if ( IoCount == 0 )
    {
        UlAcquireSpinLock( &g_BufferIoSpinLock, &OldIrql );

        //
        // Set the event if we hit to zero and waiting for drain.
        //

        if ( g_BufferWaitingForIoComplete )
        {
            KeSetEvent( &g_BufferIoCompleteEvent, 0, FALSE );
        }

        UlReleaseSpinLock( &g_BufferIoSpinLock,  OldIrql );
    }
}



/***************************************************************************++

Routine Description:

    Will allocate/fill up a new UNICODE_STRING to hold the directory name info
    based on the LocalDrive/UNC.

    It's caller's responsibility to cleanup the unicode buffer. If return code
    is SUCCESS otherwise no buffer get allocated at all.

    * Source string should be null terminated *
    * Destination string will be null terminated. *

Arguments:

    pSrc - the directory name as it's received from the user.

    pDst - the fuly qualified directory name.

--***************************************************************************/

NTSTATUS
UlBuildLogDirectory(
    IN      PUNICODE_STRING pSrc,
    IN OUT  PUNICODE_STRING pDst
    )
{
    UNICODE_STRING  PathPrefix;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(pDst);
    ASSERT(IS_WELL_FORMED_UNICODE_STRING(pSrc));

    UlTrace(LOG_UTIL,(
         "Http!UlBuildLogDirectory: Directory %S,Length %d,MaxLength %d\n",
          pSrc->Buffer,
          pSrc->Length,
          pSrc->MaximumLength
          ));

    // Allocate a buffer including the terminating NULL and the prefix.

    pDst->Length = 0;
    pDst->MaximumLength =
        pSrc->Length + (UL_MAX_PATH_PREFIX_LENGTH + 1) * sizeof(WCHAR);

    pDst->Buffer =
        (PWSTR) UL_ALLOCATE_ARRAY(
            PagedPool,
            UCHAR,
            pDst->MaximumLength,
            UL_CG_LOGDIR_POOL_TAG
            );
    if (pDst->Buffer == NULL)
    {
        return  STATUS_NO_MEMORY;
    }

    ASSERT(pSrc->Length > sizeof(WCHAR));
    

    // We store the dir name to cgroup as it is. But when we are constructing
    // the filename we skip the second backslash for the UNC shares and for
    // local dirs w/o the drive names.

    if (pSrc->Buffer[0] == L'\\')
    {
        if (pSrc->Buffer[1] == L'\\')
        {
            // UNC share: "\\alitudev\temp"
            // We do *not* use UlInitUnicodeStringEx on purpose here
            // We know the constant string is null terminated and short
            RtlInitUnicodeString( &PathPrefix, UL_UNC_PATH_PREFIX );

            RtlCopyUnicodeString( pDst, &PathPrefix );
            RtlCopyMemory(
               &pDst->Buffer[pDst->Length/sizeof(WCHAR)],
               &pSrc->Buffer[1],
                pSrc->Length - sizeof(WCHAR)
            );
            pDst->Length += (pSrc->Length - sizeof(WCHAR));
            pDst->Buffer[pDst->Length/sizeof(WCHAR)] = UNICODE_NULL;            
        }
        else
        {
            // Local Directory name is missing the device i.e "\temp"
            // It should be fully qualified name.  

            if ((pSrc->Length/sizeof(WCHAR)) < UL_SYSTEM_ROOT_PREFIX_LENGTH ||
                0 != _wcsnicmp (pSrc->Buffer, 
                                UL_SYSTEM_ROOT_PREFIX, 
                                UL_SYSTEM_ROOT_PREFIX_LENGTH
                                ))
            {
                UL_FREE_POOL(pDst->Buffer, UL_CG_LOGDIR_POOL_TAG);
                pDst->Buffer = NULL;
                
                return STATUS_NOT_SUPPORTED;
            }
            else
            {
                // However SystemRoot is allowed

                RtlCopyUnicodeString( pDst, pSrc );
                pDst->Buffer[pDst->Length/sizeof(WCHAR)] = UNICODE_NULL;
            }             
        }
    }
    else
    {
        // We do *not* use UlInitUnicodeStringEx on purpose here
        // We know the constant string is null terminated and short
        RtlInitUnicodeString( &PathPrefix, UL_LOCAL_PATH_PREFIX );
        RtlCopyUnicodeString( pDst, &PathPrefix );
        RtlAppendUnicodeStringToString( pDst, pSrc );
    }

    // Append adds the terminating null if there is a space.
    // and there should be.

    ASSERT(IS_WELL_FORMED_UNICODE_STRING(pDst));
    
    return STATUS_SUCCESS;
}

/***************************************************************************++

Routine Description:

   Regenerates the fully qualified filename in the entry according to the
   newly received directory path.
   
Arguments:

    PUNICODE_STRING : The log file directory as it's received from user.
                      "C:\Whistler\System32\LogFiles\W3SVC1"
    
    PUNICODE_STRING : The unicode buffer which will receive the new name.
                      "\??\C:\Whistler\System32\LogFiles\W3SVC1\extend1.log"

    PWSTR           : The short name points to the file name portion of the
                      above unicode string.
                      pShortName -> "extend1.log"
    
--***************************************************************************/

NTSTATUS
UlRefreshFileName(
    IN  PUNICODE_STRING pDirectory,
    OUT PUNICODE_STRING pFileName,
    OUT PWSTR          *ppShortName
    )
{
    NTSTATUS        Status;
    USHORT          FullPathFileNameLength;
    UNICODE_STRING  DirectoryCooked;
    UNICODE_STRING  JunkName;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(pFileName);
    ASSERT(ppShortName);    
    ASSERT(IS_WELL_FORMED_UNICODE_STRING(pDirectory));

    Status = STATUS_SUCCESS;
    
    // We do *not* use UlInitUnicodeStringEx on purpose here
    // We know the constant string is null terminated and short
    RtlInitUnicodeString(&JunkName, L"\\none.log");

    //
    // Get the fully qualified cooked directory string.
    //
    
    Status = UlBuildLogDirectory(pDirectory,&DirectoryCooked);
    if (!NT_SUCCESS(Status))
    {
        return Status;
    }

    ASSERT(IS_WELL_FORMED_UNICODE_STRING(&DirectoryCooked));

    //
    // Worst case estimate for the max fully qualified file name length.
    //
    
    FullPathFileNameLength = DirectoryCooked.Length +
                             UL_MAX_FILE_NAME_SUFFIX_SIZE;
    
    //
    // Force reallocate the memory if the existing buffer is not
    // sufficient. Otherwise overwrite the existing buffer.
    //
    
    if (pFileName->Buffer)
    {
        if (pFileName->MaximumLength < FullPathFileNameLength)
        {
            UL_FREE_POOL(pFileName->Buffer,UL_CG_LOGDIR_POOL_TAG);
            pFileName->Buffer = NULL;
            *ppShortName = NULL;
        }
    }

    if (pFileName->Buffer == NULL)
    {
        pFileName->Buffer =
            (PWSTR) UL_ALLOCATE_ARRAY(
                NonPagedPool,
                UCHAR,
                FullPathFileNameLength,
                UL_CG_LOGDIR_POOL_TAG
                );
        if (pFileName->Buffer == NULL)
        {
            Status = STATUS_NO_MEMORY;
            goto end;
        }
        pFileName->Length        = 0;
        pFileName->MaximumLength = FullPathFileNameLength;        
    }

    //
    // Write the directory and the filename. Don't worry about the L"none.log", 
    // it will be overwritten by the recycler later on, as long as there's 
    // MAX_LOG_FILE_NAME_SIZE space for the time/type dependent part of the file
    // name (aka short file name), it's all right.
    //
    
    RtlCopyUnicodeString(pFileName, &DirectoryCooked);

    *ppShortName = (PWSTR) 
        &pFileName->Buffer[DirectoryCooked.Length/sizeof(WCHAR)];

    Status = RtlAppendUnicodeStringToString(pFileName,&JunkName);
    ASSERT(NT_SUCCESS(Status));

    pFileName->Buffer[DirectoryCooked.Length/sizeof(WCHAR)] 
        = UNICODE_NULL;

    ASSERT(IS_WELL_FORMED_UNICODE_STRING(pFileName));

end:
    //
    // Get rid of the temp directory buffer.
    //
    
    if (DirectoryCooked.Buffer)
    {
        UL_FREE_POOL(DirectoryCooked.Buffer, UL_CG_LOGDIR_POOL_TAG);
    }

    UlTrace(LOG_UTIL,
        ("Http!UlpRefreshFileName: resulted %S \n", 
          pFileName->Buffer 
          ));

    return Status;    
}

/***************************************************************************++

Routine Description:

  UlpWeekOfMonth :  Ordinal Number of the week of the current month

  Stolen from IIS 5.1 code base.

  Example

  July 2000 ... :

     S   M   T   W   T   F   S      WeekOfMonth
                             1          1
     2   3   4   5   6   7   8          2
     9  10  11  12  13  14  15          3
    16  17  18  19  20  21  22          4
    23  24  25  26  27  28  29          5
    30  31                              6

  Finds the ordinal number of the week of current month.
  The numbering of weeks starts from 1 and run through 6 per month (max).
  The week number changes only on sundays.

  The calculation to be use is:

     1 + (dayOfMonth - 1)/7  + ((dayOfMonth - 1) % 7 > dayOfWeek);
     (a)     (b)                       (c)                (d)

     (a) to set the week numbers to begin from week numbered "1"
     (b) used to calculate the rough number of the week on which a given
        day falls based on the date.
     (c) calculates what is the offset from the start of week for a given
        day based on the fact that a week had 7 days.
     (d) is the raw day of week given to us.
     (c) > (d) indicates that the week is rolling forward and hence
        the week count should be offset by 1 more.

Arguments:

   PTIME_FIELDS    -   system time fields

Return Value:

   ULONG           -   This func magically returns the week of the month


--***************************************************************************/

__inline
ULONG UlpWeekOfMonth(
    IN  PTIME_FIELDS    fields
    )
{
    ULONG Tmp;

    Tmp = (fields->Day - 1);
    Tmp = ( 1 + Tmp/7 + (((Tmp % 7) > ((ULONG) fields->Weekday)) ? 1 : 0));

    return Tmp;
}

/***************************************************************************++

Routine Description:

    A bunch of current_time TO file_name conversions comes here ...

Arguments:

    period      - period type of the log
    prefix      - any prefix to be added to the file name
    filename    - result file name
    fields      - time fields

Return Value:

    VOID - No return value.

--***************************************************************************/

VOID
UlConstructFileName(
    IN      HTTP_LOGGING_PERIOD period,
    IN      PCWSTR              prefix,
    IN      PCWSTR              extension,
    OUT     PUNICODE_STRING     filename,
    IN      PTIME_FIELDS        fields,
    IN      BOOLEAN             Utf8Enabled,
    IN OUT  PULONG              sequenceNu  //OPTIONAL
    )
{
    WCHAR           _tmp[UL_MAX_FILE_NAME_SUFFIX_LENGTH + 1];
    UNICODE_STRING  tmp;
    CSHORT          Year;
    LONG            WcharsCopied = 0L;

    PAGED_CODE();

    ASSERT(NULL != fields);
        
    //
    // Retain just last 2 digits of the Year
    //

    tmp.Buffer        = _tmp;
    tmp.Length        = 0;
    tmp.MaximumLength = sizeof(_tmp);

    Year = fields->Year % 100;

    switch ( period )
    {
        case HttpLoggingPeriodHourly:
        {
            WcharsCopied =
                _snwprintf( _tmp,
                    UL_MAX_FILE_NAME_SUFFIX_LENGTH,
                    (Utf8Enabled ?
                        L"%.5s%02.2d%02d%02d%02d.%s" :
                        L"%.3s%02.2d%02d%02d%02d.%s"),
                    prefix,
                    Year,
                    fields->Month,
                    fields->Day,
                    fields->Hour,
                    extension
                    );
        }
        break;

        case HttpLoggingPeriodDaily:
        {
            WcharsCopied =
                _snwprintf( _tmp,
                    UL_MAX_FILE_NAME_SUFFIX_LENGTH,
                    (Utf8Enabled ?
                        L"%.5s%02.2d%02d%02d.%s" :
                        L"%.3s%02.2d%02d%02d.%s"),
                    prefix,
                    Year,
                    fields->Month,
                    fields->Day,
                    extension
                    );
        }
        break;

        case HttpLoggingPeriodWeekly:
        {
            WcharsCopied =
                _snwprintf( _tmp,
                    UL_MAX_FILE_NAME_SUFFIX_LENGTH,
                    (Utf8Enabled ?
                        L"%.5s%02.2d%02d%02d.%s" :
                        L"%.3s%02.2d%02d%02d.%s"),
                    prefix,
                    Year,
                    fields->Month,
                    UlpWeekOfMonth(fields),
                    extension
                    );
        }
        break;

        case HttpLoggingPeriodMonthly:
        {
            WcharsCopied =
                _snwprintf( _tmp,
                    UL_MAX_FILE_NAME_SUFFIX_LENGTH,
                    (Utf8Enabled ?
                        L"%.5s%02.2d%02d.%s" :
                        L"%.3s%02.2d%02d.%s"),
                    prefix,
                    Year,
                    fields->Month,
                    extension
                    );
        }
        break;

        case HttpLoggingPeriodMaxSize:
        {
            if ( sequenceNu != NULL )
            {
                WcharsCopied =
                 _snwprintf( _tmp,
                    UL_MAX_FILE_NAME_SUFFIX_LENGTH,
                    (Utf8Enabled ?
                        L"%.10s%u.%s" :
                        L"%.8s%u.%s"),
                    prefix,
                    (*sequenceNu),
                    extension
                    );

               (*sequenceNu) += 1;
            }
            else
            {
                ASSERT(!"Improper sequence number !");
            }
        }
        break;

        default:
        {
            //
            // This should never happen ...
            //

            ASSERT(!"Unknown Log Period !");

            WcharsCopied =
                _snwprintf( _tmp,
                    UL_MAX_FILE_NAME_SUFFIX_LENGTH,
                    L"%.7s?.%s",
                    prefix,
                    extension
                    );
        }
    }

    //
    // As long as we allocate an enough space for a possible
    // log filename we should never hit to this assert here.
    //

    ASSERT(WcharsCopied >0 );

    if ( WcharsCopied < 0 )
    {
        //
        // This should never happen but lets cover it
        // anyway.
        //

        WcharsCopied = UL_MAX_FILE_NAME_SUFFIX_SIZE;
        tmp.Buffer[UL_MAX_FILE_NAME_SUFFIX_LENGTH] = UNICODE_NULL;
    }

    tmp.Length = (USHORT) WcharsCopied * sizeof(WCHAR);

    RtlCopyUnicodeString( filename, &tmp );
}

/***************************************************************************++

Routine Description:

    Create a log file and returns the handle on success.

Arguments:

    pFileName  - Must be pointing to a fully qualified file name.

    UncShare   - Must be set to TRUE, if the path refers to a UNC share.

    ACLSupport - Must be set to TRUE, if the file system supports 
                 persistent ACLs.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/

NTSTATUS
UlCreateLogFile(
    IN  PUNICODE_STRING   pFileName,
    IN  BOOLEAN           UncShare,
    IN  BOOLEAN           ACLSupport,
    OUT PHANDLE           pFileHandle
    )    
{
    NTSTATUS              Status;
    HANDLE                FileHandle;
    OBJECT_ATTRIBUTES     ObjectAttributes;
    IO_STATUS_BLOCK       IoStatusBlock;    
    ACCESS_MASK           RequiredAccess;
    
    //
    // Sanity check.
    //
    
    PAGED_CODE();

    ASSERT(pFileName);
    ASSERT(pFileHandle);

    FileHandle = NULL;
    RtlZeroMemory(&IoStatusBlock, sizeof(IoStatusBlock));

    RequiredAccess = FILE_GENERIC_WRITE;
    
    //
    // Make the ownership check only if the persistent ACLs are 
    // supported.
    //

    if (ACLSupport)
    {
        RequiredAccess |= READ_CONTROL;        
    }

    //
    // Do not pass a security descriptor. Individual log files will
    // inherit the DACLs from the parent sub-folder.
    //
    
    InitializeObjectAttributes(
            &ObjectAttributes,
            pFileName,
            OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
            NULL,
            NULL
            );

    //
    // Make the created file Aysnc by not picking the sync flag.
    //

    Status = ZwCreateFile(
                &FileHandle,
                RequiredAccess,
                &ObjectAttributes,
                &IoStatusBlock,
                NULL,
                FILE_ATTRIBUTE_NORMAL,
                FILE_SHARE_READ,
                FILE_OPEN_IF,
                FILE_NON_DIRECTORY_FILE,
                NULL,
                0
                );

    if (!NT_SUCCESS(Status))
    {
        goto end;
    }

    //
    // If we've opened an existing file on a local share which 
    // supports the ACLs, then we need to verify the owner. 
    //

    if (ACLSupport  == TRUE     && 
        UncShare    == FALSE    && 
        IoStatusBlock.Information == FILE_OPENED
        )
    {
        Status = UlQueryLogFileSecurity(
                    FileHandle, 
                    FALSE,
                    TRUE
                    );
        
        if (!NT_SUCCESS(Status))
        {
            ZwClose(FileHandle);            
            goto end;
        }        
    }

    //
    // Success. Set the caller's handle.
    //

    *pFileHandle = FileHandle;
    
end:
    UlTrace(LOG_UTIL,
        ("\nHttp!UlCreateLogFile: \n"
         "\tFile %S, Status %08lx\n"
         "\tIoStatusBlock: S %08lx I %p \n",
          pFileName->Buffer,
          Status,
          IoStatusBlock.Status,
          IoStatusBlock.Information
          ));    

    return Status;
}


/***************************************************************************++

Routine Description:

    UlCreateSafeDirectory :

        Creates all of the necessary directories in a given UNICODE directory
        pathname.

            E.g.  For given \??\C:\temp\w3svc1

                -> Directories "C:\temp" & "C:\temp\w3svc1" will be created.

        This function assumes that directory string starts with "\\??\\"

Arguments:

    pDirectoryName  - directroy path name string, WARNING this function makes
                      some inplace modification to the passed directory string
                      but it restores the original before returning.

    pUncShare       - Will be set to TRUE, if the path refers to a UNC share.

    pACLSupport     - Will be set to TRUE, if the file system supports 
                      persistent ACLs.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/

NTSTATUS
UlCreateSafeDirectory(
    IN  PUNICODE_STRING  pDirectoryName,
    OUT PBOOLEAN         pUncShare,
    OUT PBOOLEAN         pACLSupport    
    )
{
    OBJECT_ATTRIBUTES   ObjectAttributes;
    IO_STATUS_BLOCK     IoStatusBlock;
    NTSTATUS            Status;
    HANDLE              hDirectory;
    BOOLEAN             FileSystemDetected;
    PWCHAR              pw;
    USHORT              i;

    //
    // Sanity check
    //

    PAGED_CODE();

    Status = STATUS_SUCCESS;
    hDirectory = NULL;    
    *pACLSupport  = FALSE;
    FileSystemDetected = FALSE;

    ASSERT( pUncShare );
    ASSERT( pACLSupport );
    ASSERT( pDirectoryName );
    ASSERT( pDirectoryName->Buffer );
    ASSERT( pDirectoryName->Length );
    ASSERT( pDirectoryName->MaximumLength > pDirectoryName->Length );

    // We must be running under system process, when creating the directories
    ASSERT(g_pUlSystemProcess == (PKPROCESS)IoGetCurrentProcess());

    pw = pDirectoryName->Buffer;
    pw[pDirectoryName->Length/sizeof(WCHAR)]=UNICODE_NULL;

    // TODO: Handle network mapped drives. Redirector.

    if (0 == wcsncmp(pw, UL_UNC_PATH_PREFIX, UL_UNC_PATH_PREFIX_LENGTH))
    {
        *pUncShare = TRUE;
        
        // UNC share
        pw += UL_UNC_PATH_PREFIX_LENGTH;

        // Bypass "\\machine\share"

        i = 0; // Skip two backslashes before reaching to share name

        while( *pw != UNICODE_NULL )
        {
            if ( *pw == L'\\' ) i++;
            if ( i == 2 ) break;
            pw++;
        }
    }
    else if (0 == wcsncmp(pw, UL_LOCAL_PATH_PREFIX, UL_LOCAL_PATH_PREFIX_LENGTH))
    {
        *pUncShare = FALSE;
        
        // Local Drive
        pw += UL_LOCAL_PATH_PREFIX_LENGTH;

        // Bypass "C:"

        while( *pw != L'\\' && *pw != UNICODE_NULL )
        {
            pw++;
        }
    }
    else if (0 == _wcsnicmp(pw, UL_SYSTEM_ROOT_PREFIX, UL_SYSTEM_ROOT_PREFIX_LENGTH))
    {
        *pUncShare = FALSE;

        pw += UL_SYSTEM_ROOT_PREFIX_LENGTH;

        while( *pw != L'\\' && *pw != UNICODE_NULL )
        {
            pw++;
        }        
    }    
    else
    {
        ASSERT(!"Incorrect logging directory name or type !");
        return STATUS_INVALID_PARAMETER;
    }

    if ( *pw == UNICODE_NULL )
    {
        // Dir. Name cannot be only "\??\C:" or "\dosdevices\UNC\machine
        // It should at least be pointing to the root directory.

        ASSERT(!"Incomplete logging directory name !");
        return STATUS_INVALID_PARAMETER;
    }

    //
    //            \??\C:\temp\w3svc1 OR \\dosdevices\UNC\machine\share\w3svc1
    //                  ^                                       ^
    // pw now points to |            OR                         |
    //
    //

    ASSERT( *pw == L'\\' );

    do
    {
        SECURITY_DESCRIPTOR   SecurityDescriptor;
        PSECURITY_DESCRIPTOR  pSecurityDescriptor;
    
        pw++;

        if ( *pw == L'\\' || *pw == UNICODE_NULL )
        {
            ACCESS_MASK RequiredAccess = FILE_LIST_DIRECTORY | FILE_TRAVERSE;
                
            //
            // Remember the original character
            //

            WCHAR  wcOriginal = *pw;
            UNICODE_STRING DirectoryName;

            //
            // Time to create the directory with the string we have build so far.
            //

            *pw = UNICODE_NULL;

            Status = UlInitUnicodeStringEx( 
                        &DirectoryName, 
                        pDirectoryName->Buffer );

            ASSERT(NT_SUCCESS(Status));

            if (wcOriginal == UNICODE_NULL && *pACLSupport == TRUE)
            {
                //
                // Aply the correct security descriptor to the last subdirectory. 
                //

                Status = UlBuildSecurityToLogFile(
                            &SecurityDescriptor,
                            NULL
                            );
                if (!NT_SUCCESS(Status))
                {
                    break;
                }

                pSecurityDescriptor = &SecurityDescriptor;
                
                ASSERT(RtlValidSecurityDescriptor(pSecurityDescriptor));

                RequiredAccess |= READ_CONTROL | WRITE_DAC | WRITE_OWNER;
            }
            else
            {
                pSecurityDescriptor = NULL;
            }

            InitializeObjectAttributes(
                &ObjectAttributes,
                &DirectoryName,
                OBJ_CASE_INSENSITIVE|OBJ_KERNEL_HANDLE,
                NULL,
                pSecurityDescriptor
                );

            Status = ZwCreateFile(
                &hDirectory,
                RequiredAccess,
                &ObjectAttributes,
                &IoStatusBlock,
                NULL,
                FILE_ATTRIBUTE_NORMAL,
                FILE_SHARE_READ,
                FILE_OPEN_IF,
                FILE_DIRECTORY_FILE,
                NULL,
                0
                );

            UlTrace(LOG_UTIL,
                ("\nHttp!UlCreateSafeDirectory: \n"
                 "\tDir %S, Status %08lx\n"
                 "\tIoStatusBlock: S %08lx I %p \n",
                  pDirectoryName->Buffer,
                  Status,
                  IoStatusBlock.Status,
                  IoStatusBlock.Information
                  ));

            if (pSecurityDescriptor)
            {                
                UlCleanupSecurityDescriptor(pSecurityDescriptor); 
                pSecurityDescriptor = NULL;
            }

            //
            // Restore the original character. And break the loop
            // if necessary.
            //

            *pw = wcOriginal;

            if (!NT_SUCCESS(Status))
            {
                break;
            }

            if (!NT_SUCCESS(IoStatusBlock.Status))
            {
                Status = IoStatusBlock.Status;
                break;
            }

            //
            // For the very first time query the underlying file system
            // to see if it supports persistent ACLs.
            //
            if (!FileSystemDetected)
            {
                FileSystemDetected = TRUE;            
                Status = UlQueryAttributeInfo(
                            hDirectory, 
                            pACLSupport
                            );
            }            
    
            //
            // If we have happened to open an existing directory for
            // the very last iteration, we need to verify the  owner.
            // Also if this was an UncShare we need to include owner
            // sid "DOMAIN\webserver" to the DACL list, let's use query
            // for the same purpose.
            //

            if ( NT_SUCCESS(Status) && 
                 wcOriginal == UNICODE_NULL &&
                 *pACLSupport == TRUE &&
                (IoStatusBlock.Information == FILE_OPENED ||
                 *pUncShare == TRUE)
                 )
            {
                Status = UlQueryLogFileSecurity(
                            hDirectory, 
                            *pUncShare,
                            (BOOLEAN)(IoStatusBlock.Information == FILE_OPENED)
                            );
            }

            ZwClose(hDirectory);

            if (!NT_SUCCESS(Status))
            {
                break;
            }
        }
    }
    while( *pw != UNICODE_NULL );
    
    if (!NT_SUCCESS(Status))
    {
        UlTrace(LOG_UTIL,
            ("Http!UlCreateSafeDirectory: directory %S, failure %08lx\n",
              pDirectoryName->Buffer,
              Status
              ));
    }

    return Status;
}

/***************************************************************************++

Routine Description:

    Just to ensure ZwWriteFile get executed under the system process.

    The ZwWrite calls with APC Completions must happen under the system 
    process. Otherwise there's a chance that the user mode process under 
    which the ZwWrite call happens may go away and actual APC never get 
    queued,this would block our termination and cause a shutdown hang.

    This worker get queued to the high priority queue, as a rule of thumb
    we should not acquire a global lock which would cause a deadlock. 

Arguments:

    pContext - Pointer to LOG_IO_FLUSH_OBJ structure. It is a helper 
               structure which holds the pointers to buffer and file handle.

--***************************************************************************/

NTSTATUS
UlpFlushLogFileBufferWorker(
    IN PVOID pContext
    )
{
    NTSTATUS          Status;
    LARGE_INTEGER     EndOfFile;
    PLOG_IO_FLUSH_OBJ pFlush;

    PAGED_CODE();

    ASSERT(pContext);

    pFlush = (PLOG_IO_FLUSH_OBJ) pContext;

    ASSERT(IS_VALID_LOG_FILE_BUFFER(pFlush->pLogBuffer));
    ASSERT(IS_VALID_LOG_FILE_HANDLE(pFlush->pLogFile));

    EndOfFile.HighPart  = -1;
    EndOfFile.LowPart   = FILE_WRITE_TO_END_OF_FILE;

    Status = ZwWriteFile(
                  pFlush->pLogFile->hFile,
                  NULL,
                 &UlpBufferFlushAPC,
                  pFlush->pLogBuffer,
                 &pFlush->pLogBuffer->IoStatusBlock,
                  pFlush->pLogBuffer->Buffer,
                  pFlush->pLogBuffer->BufferUsed,
                 &EndOfFile,
                  NULL
                  );

    UlTrace(LOG_UTIL,
        ("Http!UlpFlushLogFileBufferWorker:"
         " For pLogFile %p and pLogBuffer %p\n",
          pFlush->pLogFile,
          pFlush->pLogBuffer
          ));

    return Status;
}

/***************************************************************************++

Routine Description:

    Generic buffer flusher for binary & normal log files.

    - If it is called async - completion happens with UlpBufferFlushAPC
    - For sync, waits until buffer flush is complete. 
        i.e. caller wants to make sure title (w3c) is written successfully.

Arguments:

    pEntry - The log file entry to be flushed.

--***************************************************************************/

NTSTATUS
UlFlushLogFileBuffer(
    IN OUT PUL_LOG_FILE_BUFFER *ppLogBuffer,
    IN     PUL_LOG_FILE_HANDLE  pLogFile,
    IN     BOOLEAN              WaitForComplete,
       OUT PULONGLONG           pTotalWritten    
    )
{
    NTSTATUS                Status;
    LARGE_INTEGER           EndOfFile;
    PUL_LOG_FILE_BUFFER     pLogBuffer;
    ULONG                   BufferUsed;
    LOG_IO_FLUSH_OBJ        Flush;

    PAGED_CODE();

    ASSERT(ppLogBuffer);
    ASSERT(IS_VALID_LOG_FILE_HANDLE(pLogFile));
    
    pLogBuffer = *ppLogBuffer;
        
    if (pLogBuffer == NULL || 
        pLogBuffer->BufferUsed == 0 ||
        pLogFile == NULL ||
        pLogFile->hFile == NULL 
        )
    {
        return STATUS_SUCCESS;
    }

    ASSERT(IS_VALID_LOG_FILE_BUFFER(pLogBuffer));
    
    UlTrace(LOG_UTIL,
        ("Http!UlFlushLogFileBuffer: pLogBuffer %p pLogFile %p\n", 
          pLogBuffer,
          pLogFile
          ));

    //
    // Flush & forget the current buffer. Null the buffer
    // pointer of the caller; (binary or normal) log entry.
    //
    
    *ppLogBuffer = NULL;

    BufferUsed = pLogBuffer->BufferUsed;

    EndOfFile.HighPart = -1;
    EndOfFile.LowPart = FILE_WRITE_TO_END_OF_FILE;

    //
    // Wait on event for flush to complete if this is a sync call.
    //
    
    if ( WaitForComplete )
    {         
        // Sync call
        
        HANDLE  EventHandle;
            
        Status = ZwCreateEvent(
                    &EventHandle,
                    EVENT_ALL_ACCESS,
                    NULL,
                    NotificationEvent,
                    FALSE
                    );
        
        if (NT_SUCCESS(Status))
        {
            Status = ZwWriteFile(
                      pLogFile->hFile,
                      EventHandle,
                      NULL,
                      NULL,
                      &pLogBuffer->IoStatusBlock,
                      pLogBuffer->Buffer,
                      pLogBuffer->BufferUsed,
                      &EndOfFile,
                      NULL
                      );

            if (Status == STATUS_PENDING)
            {
                Status = NtWaitForSingleObject( 
                            EventHandle,
                            FALSE,
                            NULL 
                            );
                
                ASSERT( Status == STATUS_SUCCESS );
                        
                Status = pLogBuffer->IoStatusBlock.Status;
            }  

            ZwClose(EventHandle);
        }

        UlTrace(LOG_UTIL,
            ("Http!UlFlushLogFileBuffer: Sync flush complete: Status %08lx \n",
              Status
              )); 

        UlPplFreeLogFileBuffer(pLogBuffer);
    }
    else
    {        
        // Async call

        Flush.pLogBuffer = pLogBuffer;
        Flush.pLogFile   = pLogFile;

        Status = UlQueueLoggingRoutine(
                    (PVOID) &Flush,
                    &UlpFlushLogFileBufferWorker
                    );

         if (NT_SUCCESS(Status))
         {
             //
             // Properly keep the number of outstanding Io.
             // LogFileBuffer will get freed up along in Apc 
             // completion.
             //

             InterlockedIncrement((PLONG) &g_BufferIoCount);         
         }
         else
         {
            //
            // Status maybe STATUS_DISK_FULL,in that case Logging
            // will be ceased. Hence log hits stored in this buffer
            // are lost.
            //       

            UlTrace(LOG_UTIL,
                ("Http!UlFlushLogFileBuffer: ZwWriteFile Failure %08lx \n",
                  Status
                  ));

            UlPplFreeLogFileBuffer(pLogBuffer);
         }
    }
    
     //
     // If we have successfully flushed the log buffer, 
     // increment the total bytes written on callers address.
     //

     if (NT_SUCCESS(Status))
     {
        UlInterlockedAdd64((PLONGLONG)pTotalWritten, (LONGLONG) BufferUsed);
     }
    
     return Status;
}


/***************************************************************************++

Routine Description:

    Simple utility to close the log file handle on a system thread.

Arguments:

    pLogFile  -  Acquired from passed-in pWorkItem

--***************************************************************************/

VOID
UlpCloseLogFileWorker(
    IN PUL_WORK_ITEM    pWorkItem
    )
{
    PUL_LOG_FILE_HANDLE pLogFile;

    // Sanity check
    
    PAGED_CODE();

    pLogFile = CONTAINING_RECORD(
                pWorkItem,
                UL_LOG_FILE_HANDLE,
                WorkItem
                );
    
    ASSERT(IS_VALID_LOG_FILE_HANDLE(pLogFile));
    ASSERT(pLogFile->hFile);

    UlTrace(LOG_UTIL,
        ("Http!UlpCloseLogFileWorker: pLogFile %p hFile %p\n",
          pLogFile, pLogFile->hFile ));

    // Close the handle and free up the memory
    
    ZwClose(pLogFile->hFile);
    pLogFile->hFile = NULL;

    UL_FREE_POOL_WITH_SIG(pLogFile,UL_LOG_FILE_HANDLE_POOL_TAG);
}


/***************************************************************************++

Routine Description:

    Simple utility to close the log file handle on a system thread and set the
    event to notify the caller that it's done.

    Normally caller of this function will attempt to flush the corresponding 
    buffer prior to closing the log file.

    But a flush will cause an APC to be queued to the user thread,therefore we 
    have to close the handle on one of our system threads to avoid the possible 
    bugcheck INVALID_PROCESS_ DETACH or ATTACH _ATTEMPT condition.    

Arguments:

    ppLogFile -  Callers address (In Binary/Normal log entry) of the log file 
                 pointer.

--***************************************************************************/

VOID
UlCloseLogFile(
    IN OUT PUL_LOG_FILE_HANDLE *ppLogFile
    )
{
    PUL_LOG_FILE_HANDLE pLogFile;

    //
    // Sanity check
    //

    PAGED_CODE();
    ASSERT(ppLogFile);
    
    pLogFile = *ppLogFile;    
    ASSERT(IS_VALID_LOG_FILE_HANDLE(pLogFile));

    ASSERT(pLogFile->hFile);    
    ASSERT(g_pUlSystemProcess);

    //
    // Set the log file null for the caller
    //
    
    *ppLogFile = NULL;       

    UlTrace(LOG_UTIL,
        ("Http!UlCloseLogFile: pLogFile %p\n",pLogFile));

    //
    // Try to close the handle on the system thread.
    //
    
    if (g_pUlSystemProcess == (PKPROCESS)PsGetCurrentProcess())
    {
        ZwClose(pLogFile->hFile);
        
        pLogFile->hFile = NULL;

        UL_FREE_POOL_WITH_SIG(pLogFile,UL_LOG_FILE_HANDLE_POOL_TAG);
    }
    else
    {        
        // Otherwise queue a passive worker to do the work for us
        
        UL_QUEUE_WORK_ITEM(
            &pLogFile->WorkItem,
            &UlpCloseLogFileWorker
            );
    }
}

/***************************************************************************++

Routine Description:

    UlQueryDirectory:

  * What file should IIS write to when logging type is daily/weekly/monthly/
    hourly if there is already a log file there for that day?

      IIS should write to the current day/week/month/hour's log file.  For
      example, let's say there's an extended log file in my log directory
      called ex000727.log.  IIS should append new log entries to this log,
      as it is for today.

  * What file should IIS write to when logging type is MAXSIZE when there are
    already log files there for maxsize (like extend0.log, extend1.log, etc.)?

      IIS should write to the max extend#.log file, where max(extend#.log)
      is has the largest # in the #field for extend#.log. This is provided,
      of course, that the MAXSIZE in that file hasn't been exceeded.

  * This function quite similar to the implementation of the FindFirstFile
    Win32 API. Except that it has been shaped to our purposes.

  * Modified to bypass the directories matching with the log file name.

Arguments:

    pEntry - The log file entry which freshly created.

--***************************************************************************/

NTSTATUS
UlQueryDirectory(
    IN OUT PUNICODE_STRING pFileName,
    IN OUT PWSTR           pShortName,
    IN     PCWSTR          Prefix,
    IN     PCWSTR          ExtensionPlusDot,
    OUT    PULONG          pSequenceNumber,
    OUT    PULONGLONG      pTotalWritten
    )
{
#define GET_NEXT_FILE(pv, cb)   \
       (FILE_DIRECTORY_INFORMATION *) ((VOID *) (((UCHAR *) (pv)) + (cb)))

    NTSTATUS                    Status;
    OBJECT_ATTRIBUTES           ObjectAttributes;
    IO_STATUS_BLOCK             IoStatusBlock;
    LONG                        WcharsCopied;
    HANDLE                      hDirectory;
    ULONG                       Sequence;
    ULONGLONG                   LastSequence;
    PWCHAR                      pTemp;
    UNICODE_STRING              FileName;
    WCHAR                      _FileName[UL_MAX_FILE_NAME_SUFFIX_LENGTH + 1];

    FILE_DIRECTORY_INFORMATION *pFdi;
    PUCHAR                      FileInfoBuffer;
    ULARGE_INTEGER              FileSize;
    WCHAR                       OriginalWChar;
    WCHAR                       SavedWChar;
    BOOLEAN                     SequenceForDir;

    PAGED_CODE();

    Status = STATUS_SUCCESS;
    hDirectory = NULL;
    FileInfoBuffer = NULL;
    SequenceForDir = FALSE;

    UlTrace(LOG_UTIL,
            ("Http!UlQueryDirectory: %S\n",pFileName->Buffer));

    //
    // Open the directory for the list access again. Use the filename in
    // pEntry. Where pShortName points to the "\inetsv1.log" portion  of
    // the  whole "\??\c:\whistler\system32\logfiles\w3svc1\inetsv1.log"
    // Overwrite the pShortName to get the  directory name. Once we  are
    // done with finding the last sequence we will restore it back later
    // on.
    //

    OriginalWChar = *((PWCHAR)pShortName);
    *((PWCHAR)pShortName) = UNICODE_NULL;
    pFileName->Length =
        (USHORT) wcslen(pFileName->Buffer) * sizeof(WCHAR);

    InitializeObjectAttributes(
        &ObjectAttributes,
         pFileName,
         OBJ_CASE_INSENSITIVE|OBJ_KERNEL_HANDLE,
         NULL,
         NULL
         );

    Status = ZwCreateFile(
                &hDirectory,
                SYNCHRONIZE|FILE_LIST_DIRECTORY,
                &ObjectAttributes,
                &IoStatusBlock,
                NULL,
                FILE_ATTRIBUTE_NORMAL,
                FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,
                FILE_OPEN,
                FILE_SYNCHRONOUS_IO_NONALERT|FILE_DIRECTORY_FILE,
                NULL,
                0
                );

    if (!NT_SUCCESS(Status))
    {
        //
        // This call should never fail since CreateLog   already created
        // the directory for us.
        //

        ASSERT(!"Directory Invalid!\n");
        goto end;
    }

    //
    // Before querrying we need to provide additional DOS-like  wildcard
    // matching semantics. In our case, only * to DOS_STAR conversion is
    // enough though. The following is the pattern we will use for query
    // Skipping the first slash character.
    //

    FileName.Buffer = &_FileName[1];
    WcharsCopied    =  _snwprintf( _FileName,
                        UL_MAX_FILE_NAME_SUFFIX_LENGTH + 1,
                        L"%s%c.%s",
                        Prefix,
                        DOS_STAR,
                        (PCWSTR)&ExtensionPlusDot[1]
                        );
    ASSERT(WcharsCopied > 0);

    FileName.Length = (USHORT) wcslen(FileName.Buffer) * sizeof(WCHAR);
    FileName.MaximumLength = FileName.Length;

    //
    // This non-paged buffer should be allocated to be  used for storing
    // query results.
    //

    FileInfoBuffer =
        UL_ALLOCATE_ARRAY(
                    NonPagedPool,
                    UCHAR,
                    UL_DIRECTORY_SEARCH_BUFFER_SIZE + sizeof(WCHAR),
                    UL_LOG_GENERIC_POOL_TAG
                    );
    if (FileInfoBuffer == NULL)
    {
        Status = STATUS_NO_MEMORY;
        goto end;
    }
    
    //
    // The  very first call may also fail if there is no log file in the
    // current directory. We subtract off a WCHAR so that we can append a 
    // terminating null as needed.
    //
        
    Status = ZwQueryDirectoryFile (
        hDirectory,
        NULL,
        NULL,
        NULL,
       &IoStatusBlock,
        FileInfoBuffer,
        UL_DIRECTORY_SEARCH_BUFFER_SIZE - sizeof(WCHAR),
        FileDirectoryInformation,
        FALSE,
       &FileName,
        TRUE
        );

    if(!NT_SUCCESS(Status))
    {
        //
        // This should never fail with STATUS_BUFFER_OVERFLOW unless the
        // buffer size is ridiculously small  i.e. 50 bytes or something
        //

        UlTrace(LOG_UTIL,
            ("Http!UlQueryDirectory: Status %08lx for %S & %S\n",
              Status,
              pFileName->Buffer,
              FileName.Buffer
              ));

        if (Status == STATUS_NO_SUCH_FILE)
        {
            Status = STATUS_SUCCESS;
        }        
        
        goto end;
    }

    //
    // Look into the buffer and get the sequence number from filename.
    //

    pFdi = (FILE_DIRECTORY_INFORMATION *) FileInfoBuffer;
    Sequence = 1;
    LastSequence = 1;
    FileSize.QuadPart = 0;

    while (TRUE)
    {
        //
        // Temporarily terminate the dir name. We allocated an extra WCHAR to
        // make sure we could safely do this.
        //

        SavedWChar = pFdi->FileName[pFdi->FileNameLength / sizeof(WCHAR)];
        pFdi->FileName[pFdi->FileNameLength / sizeof(WCHAR)] = UNICODE_NULL;
            
        //
        // Get the latest Sequence Number from the dirname (null terminated)
        //        
        
        pTemp = wcsstr(pFdi->FileName, ExtensionPlusDot);
        
        if (pTemp)
        {
            PCWSTR pEnd = pTemp;
           *pTemp = UNICODE_NULL;
            pTemp = pFdi->FileName;

            while ( *pTemp != UNICODE_NULL )
            {
                if ( isdigit((CHAR) (*pTemp)) )
                {
                    NTSTATUS ConversionStatus;

                    ConversionStatus = 
                        HttpWideStringToULongLong(
                                pTemp,
                                pEnd - pTemp,
                                FALSE,
                                10,
                                NULL,
                                &LastSequence
                                );

                    //
                    // Do not let conversion to overflow, and also enforce an 
                    // upper limit.
                    //
                    
                    if (!NT_SUCCESS(ConversionStatus) 
                         || LastSequence > MAX_ALLOWED_SEQUENCE_NUMBER)
                    {
                        LastSequence = 0;
                    }
                                        
                    break;
                }
                pTemp++;
            }
        }
        else
        {
            //
            // Since we asked for expression match and query returned success
            // we should never come here.
            //
            ASSERT(FALSE);
        }

        //
        // Carefully put the Saved Wchar back, we might have overwritten the
        // NextEntryOffset field of the next record in the buffer.
        //
        
        pFdi->FileName[pFdi->FileNameLength / sizeof(WCHAR)] = SavedWChar;

        //
        // Its greater than or equal because we want to initialize the FileSize 
        // properly even if there's only one match.
        //
        
        if (LastSequence >= (ULONGLONG) Sequence)
        {
            //
            // To be able to skip the matching <directories>.
            //

            SequenceForDir = 
              (pFdi->FileAttributes & FILE_ATTRIBUTE_DIRECTORY) ? TRUE : FALSE;
            
            //
            // Bingo ! We have two things to remember though; the file  size
            // and the sequence number. Cryptic it's that we are getting the
            // file size from EOF. 
            //

            Sequence = (ULONG) LastSequence;

            FileSize.QuadPart = (ULONGLONG) pFdi->EndOfFile.QuadPart;
        }

        //
        // Keep going until we see no more files
        //

        if (pFdi->NextEntryOffset != 0)
        {
            //
            // Search through the buffer as long as there is  still something
            // in there.
            //

            pFdi = GET_NEXT_FILE(pFdi, pFdi->NextEntryOffset);
        }
        else
        {
            //
            // Otherwise query again for any other possible log file(s)
            //

            Status = ZwQueryDirectoryFile (
                hDirectory,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                FileInfoBuffer,
                UL_DIRECTORY_SEARCH_BUFFER_SIZE,
                FileDirectoryInformation,
                FALSE,
                NULL,
                FALSE
                );

            if (Status == STATUS_NO_MORE_FILES)
            {
                Status  = STATUS_SUCCESS;
                break;
            }

            if (!NT_SUCCESS(Status))
            {
                goto end;
            }

            pFdi = (FILE_DIRECTORY_INFORMATION *) FileInfoBuffer;
        }
    }

    //
    // If the highest number was from a directory then skip it and
    // mark that the file size is zero. 
    //
    
    if (SequenceForDir)
    {
       Sequence++;
       FileSize.QuadPart = 0;
    }    
    
    //
    // Construct the log file name properly from the sequence number so  that
    // our caller can create the log file later on.
    //

    WcharsCopied = _snwprintf( pShortName,
                    UL_MAX_FILE_NAME_SUFFIX_LENGTH,
                    L"%s%d.%s",
                    Prefix,
                    Sequence,
                    (PCWSTR)&ExtensionPlusDot[1]
                    );
    ASSERT(WcharsCopied > 0);

    pFileName->Length =
        (USHORT) wcslen(pFileName->Buffer) * sizeof(WCHAR);

    //
    // Set the next sequence number according to last log file
    //

    *pSequenceNumber = Sequence + 1;

    //
    // Update the log file size accordingly in the entry.Otherwise truncation
    // will not work properly.
    //

    *pTotalWritten = FileSize.QuadPart;

    UlTrace(LOG_UTIL,
        ("Http!UlQueryDirectory: %S has been found with size %d.\n",
          pFileName->Buffer,
          *pTotalWritten
          ));

end:
    if (*((PWCHAR)pShortName) == UNICODE_NULL )
    {
        //
        // We have failed for some reason before reconstructing the filename
        // Perhaps because the directory was empty. Do not forget to restore
        // the pShortName in the pEntry then.
        //

        *((PWCHAR)pShortName) = OriginalWChar;
        pFileName->Length =
            (USHORT) wcslen(pFileName->Buffer) * sizeof(WCHAR);
    }

    if (FileInfoBuffer)
    {
        UL_FREE_POOL( FileInfoBuffer, UL_LOG_GENERIC_POOL_TAG );
    }

    if (!NT_SUCCESS(Status))
    {
        UlTrace(LOG_UTIL,
            ("Http!UlQueryDirectory: failure %08lx for %S\n",
              Status,
              pFileName->Buffer
              ));
    }

    if (hDirectory != NULL)
    {
        ZwClose(hDirectory);
    }

    return Status;
}


/***************************************************************************++

Routine Description:

    A utility to get the log file length, for a possible size check.

Arguments:

    hFile - handle to file.

Return Value:

    ULONG - the length of the file.

--***************************************************************************/

ULONGLONG
UlGetLogFileLength(
   IN HANDLE                 hFile
   )
{
   NTSTATUS                  Status;
   FILE_STANDARD_INFORMATION StandardInformation;
   IO_STATUS_BLOCK           IoStatusBlock;
   LARGE_INTEGER             Length;

   PAGED_CODE();

   Status = ZwQueryInformationFile(
                     hFile,
                     &IoStatusBlock,
                     &StandardInformation,
                     sizeof(StandardInformation),
                     FileStandardInformation
                     );

   if (NT_SUCCESS(Status))
   {
      Length = StandardInformation.EndOfFile;
   }
   else
   {
      Length.QuadPart = 0;
   }

   return Length.QuadPart;
   
}

/***************************************************************************++

Routine Description:

    UlpCalculateTimeToExpire :

        Shamelessly stolen from IIS 5.1 Logging code and adapted here.
        This routine returns the time-to-expire in hours. 1 means the log
        will expire in the next timer-fire and so ...

Arguments:

    PTIME_FIELDS        - Current Time Fields
    HTTP_LOGGING_PERIOD - Logging Period
    PULONG              - Pointer to a buffer to receive result

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/

NTSTATUS
UlCalculateTimeToExpire(
     PTIME_FIELDS           pDueTime,
     HTTP_LOGGING_PERIOD    LogPeriod,
     PULONG                 pTimeRemaining
     )
{
    NTSTATUS    Status;
    ULONG       NumDays;

    PAGED_CODE();

    ASSERT(pDueTime!=NULL);
    ASSERT(pTimeRemaining!=NULL);

    Status = STATUS_SUCCESS;

    switch (LogPeriod)
    {
        case HttpLoggingPeriodMaxSize:
             return Status;

        case HttpLoggingPeriodHourly:
             *pTimeRemaining = 1;
             break;

        case HttpLoggingPeriodDaily:
             *pTimeRemaining = 24 - pDueTime->Hour;
             break;

        case HttpLoggingPeriodWeekly:
        {
            ULONG TimeRemainingInTheMonth;
            NumDays = UlGetMonthDays(pDueTime);

            TimeRemainingInTheMonth =
                NumDays*24 - ((pDueTime->Day-1)*24 + pDueTime->Hour);

            // Time Remaining in the week
            // Sunday = 0, Monday = 1 ... Saturday = 6

            *pTimeRemaining =
                7*24 - (pDueTime->Weekday*24 + pDueTime->Hour);

             //
             // If the time remaining in the month less than time remaining in
             // the week then we have to recycle at the end of the month.
             // Otherwise we have to recycle at the end of the week. (next sunday)
             //

             if (TimeRemainingInTheMonth < *pTimeRemaining)
             {
                *pTimeRemaining = TimeRemainingInTheMonth;
             }
        }
            break;

        case HttpLoggingPeriodMonthly:
        {
            NumDays = UlGetMonthDays(pDueTime);

            //
            // Lets not forget that the day starts from 1 .. 31
            // Therefore we have to subtract one from the day value.
            //

            *pTimeRemaining =
                NumDays*24 - ((pDueTime->Day-1)*24 + pDueTime->Hour);
        }
            break;

        default:
            ASSERT(!"Invalid Log file period !");
            return STATUS_INVALID_PARAMETER;
    }

    return Status;
}

/***************************************************************************++

Routine Description:

    This routine provides the initial due time for the upcoming
    periodic hourly timer. We have to align the timer so that it
    get signaled at the beginning of each hour.

    We keep ONLY one timer for all log periods. A DPC routine will
    get called every hour, and it will traverse the log list and
    do the recycling properly.

    Additionally this timer also handles the local time rollover.
    It queries the system time, calculates the remaining time to
    the hour beginning for both GMT & Local timezones then picks 
    the earliest one and reset it back again.
    
    This goes on until it get canceled.

--***************************************************************************/

VOID
UlSetLogTimer(
    IN PUL_LOG_TIMER pTimer
    )
{
    TIME_FIELDS   TimeFieldsGMT;
    TIME_FIELDS   TimeFieldsLocal;
    LARGE_INTEGER TimeStampGMT;
    LARGE_INTEGER TimeStampLocal;
    
    LONGLONG      DueTime100NsGMT;
    LONGLONG      DueTime100NsLocal;
    
    LARGE_INTEGER DueTime100Ns;
    BOOLEAN       IsTimerAlreadyInTheQueue = FALSE;
    
    //
    // This value is computed for the GMT time zone.
    //

    KeQuerySystemTime(&TimeStampGMT);
    ExSystemTimeToLocalTime(&TimeStampGMT, &TimeStampLocal);
    
    RtlTimeToTimeFields(&TimeStampGMT, &TimeFieldsGMT);
    RtlTimeToTimeFields(&TimeStampLocal, &TimeFieldsLocal);
        
    //
    // Calculate remaining time to the next hour tick for both timezones.
    //

    /* GMT */
    DueTime100NsGMT = 
        1*60*60 - (TimeFieldsGMT.Minute*60 + TimeFieldsGMT.Second);

    DueTime100NsGMT =  // Convert to 100Ns
        (DueTime100NsGMT*1000 - TimeFieldsGMT.Milliseconds ) * 1000 * 10;

    /* Local */
    DueTime100NsLocal = 
        1*60*60 - (TimeFieldsLocal.Minute*60 + TimeFieldsLocal.Second);

    DueTime100NsLocal =  // Convert to 100Ns
        (DueTime100NsLocal*1000 - TimeFieldsLocal.Milliseconds ) * 1000 * 10;

    //
    // Pick the earliest and proceed and set the timer accordingly.
    //

    if (DueTime100NsLocal < DueTime100NsGMT)
    {
        DueTime100Ns.QuadPart   = -DueTime100NsLocal;        
        pTimer->PeriodType = UlLogTimerPeriodLocal;
    }
    else if (DueTime100NsLocal > DueTime100NsGMT)
    {
        DueTime100Ns.QuadPart   = -DueTime100NsGMT;        
        pTimer->PeriodType = UlLogTimerPeriodGMT;        
    }
    else
    {
        //
        // When and where the GMT & Local times are same or
        // aligned hourly.
        //
        
        DueTime100Ns.QuadPart   = -DueTime100NsGMT;        
        pTimer->PeriodType = UlLogTimerPeriodBoth;      
    }

    //
    // As a debugging aid remember the remaining period in minutes.
    //
    
    pTimer->Period = 
        (SHORT) ( -1 * DueTime100Ns.QuadPart / C_NS_TICKS_PER_MIN );

    IsTimerAlreadyInTheQueue = 
        KeSetTimer(
            &pTimer->Timer,
            DueTime100Ns,
            &pTimer->DpcObject
            );
    ASSERT(IsTimerAlreadyInTheQueue == FALSE);

    UlTrace(LOG_UTIL,
        ("Http!UlSetLogTimer: pTimer %p will wake up after %d minutes\n",
             pTimer,
             pTimer->Period
             ));
}

/***************************************************************************++

Routine Description:

    We have to introduce a new timer for the log buffering mechanism.
    Each log file keeps a system default (64K) buffer do not flush this
    out unless it's full or this timer get fired every MINUTE.

    The hourly timer get aligned for the beginning of each hour. Therefore
    using that existing timer would introduce a lot of complexity.

--***************************************************************************/

VOID
UlSetBufferTimer(
    IN PUL_LOG_TIMER pTimer
    )
{
    LONGLONG        BufferPeriodTime100Ns;
    LONG            BufferPeriodTimeMs;
    LARGE_INTEGER   BufferPeriodTime;

    //
    // Remaining time to next tick.
    //

    BufferPeriodTimeMs    = DEFAULT_BUFFER_TIMER_PERIOD_MINUTES * 60 * 1000;
    BufferPeriodTime100Ns = (LONGLONG) BufferPeriodTimeMs * 10 * 1000;

    UlTrace(LOG_UTIL,
        ("Http!UlSetBufferTimer: period of %d seconds.\n",
          BufferPeriodTimeMs / 1000
          ));

    //
    // Negative time for relative value.
    //

    BufferPeriodTime.QuadPart = -BufferPeriodTime100Ns;

    KeSetTimerEx(
        &pTimer->Timer,
        BufferPeriodTime,           // Must be in nanosec
        BufferPeriodTimeMs,         // Must be in millisec
        &pTimer->DpcObject
        );
}

/***************************************************************************++

Routine Description:

    Probes the content of the user buffer of Log Data

    Note: pUserLogData holds untrusted data sent down from user mode.
    The caller MUST have a __try/__except block to catch any exceptions
    or access violations that occur while probing this data.

Arguments:

    PHTTP_LOG_FIELDS_DATA - The captured log data to be probed and verified.

--***************************************************************************/

VOID
UlProbeLogData(
    IN PHTTP_LOG_FIELDS_DATA pCapturedLogData,
    IN KPROCESSOR_MODE       RequestorMode
    )
{
    PAGED_CODE();

#define PROBE_LOG_STRING(pField,ByteLength,RequestorMode)           \
    if ( NULL != pField  &&  0 != ByteLength )                      \
    {                                                               \
        UlProbeAnsiString( pField, ByteLength, RequestorMode);      \
    }

#define PROBE_LOG_STRING_W(pField,ByteLength,RequestorMode)         \
    if ( NULL != pField  &&  0 != ByteLength )                      \
    {                                                               \
        UlProbeWideString( pField, ByteLength, RequestorMode);      \
    }

    //
    // Probe each string pointer in the log data.
    //
    
    if (pCapturedLogData)
    {
        UlTrace(LOG_UTIL,
            ("Http!UlProbeLogData: pCapturedLogData %p\n",
              pCapturedLogData 
              ));

        //
        // Now check for the individual strings
        //

        PROBE_LOG_STRING(
                pCapturedLogData->ClientIp,
                pCapturedLogData->ClientIpLength,
                RequestorMode
                );

        PROBE_LOG_STRING(
                pCapturedLogData->ServiceName,
                pCapturedLogData->ServiceNameLength,
                RequestorMode
                );

        PROBE_LOG_STRING(
                pCapturedLogData->ServerName,
                pCapturedLogData->ServerNameLength,
                RequestorMode
                );

        PROBE_LOG_STRING(
                pCapturedLogData->ServerIp,
                pCapturedLogData->ServerIpLength,
                RequestorMode
                );

        PROBE_LOG_STRING(
                pCapturedLogData->UriQuery,
                pCapturedLogData->UriQueryLength,
                RequestorMode
                );

        PROBE_LOG_STRING(
                pCapturedLogData->Host,
                pCapturedLogData->HostLength,
                RequestorMode
                );

        PROBE_LOG_STRING(
                pCapturedLogData->UserAgent,
                pCapturedLogData->UserAgentLength,
                RequestorMode
                );

        PROBE_LOG_STRING(
                pCapturedLogData->Cookie,
                pCapturedLogData->CookieLength,
                RequestorMode
                );

        PROBE_LOG_STRING(
                pCapturedLogData->Referrer,
                pCapturedLogData->ReferrerLength,
                RequestorMode
                );

        PROBE_LOG_STRING(
                pCapturedLogData->Method,
                pCapturedLogData->MethodLength,
                RequestorMode
                );

        PROBE_LOG_STRING_W(
                pCapturedLogData->UserName,
                pCapturedLogData->UserNameLength,
                RequestorMode
                );

        PROBE_LOG_STRING_W(
                pCapturedLogData->UriStem,
                pCapturedLogData->UriStemLength,
                RequestorMode
                );
    }
}

/***************************************************************************++

Routine Description:

    After we are done with writing this record we have to clean up
    the internal log buffer here.

Arguments:

    pWorkItem - WorkItem field of the buffer to be destroyed.

--***************************************************************************/

VOID
UlDestroyLogDataBufferWorker(
    IN PUL_WORK_ITEM    pWorkItem
    )
{
    PUL_LOG_DATA_BUFFER pLogData;
    ULONG Tag;

    //
    // Sanity check
    //

    ASSERT(pWorkItem);

    pLogData = CONTAINING_RECORD(
                    pWorkItem,
                    UL_LOG_DATA_BUFFER,
                    WorkItem
                    );

    if (pLogData->pRequest)
    {
        PUL_INTERNAL_REQUEST pRequest = pLogData->pRequest;

        ASSERT(!pRequest->pLogData);

        pLogData->pRequest = NULL;
        UL_DEREFERENCE_INTERNAL_REQUEST(pRequest);
    }

    UlTrace(LOG_UTIL,
        ("Http!UlDestroyLogDataBufferWorker: pLogData %p \n",
                       pLogData
                       ));

    //
    // Now release the possibly allocated large log line buffer
    //

    if (!pLogData->Flags.IsFromLookaside)
    {
        //
        // Large log line get allocated from paged pool
        // we better be running on lowered IRQL for this case.
        //
        
        PAGED_CODE();

        if (pLogData->Flags.Binary)
        {
            Tag = UL_BINARY_LOG_DATA_BUFFER_POOL_TAG;
        }
        else
        {
            Tag = UL_ANSI_LOG_DATA_BUFFER_POOL_TAG;
        }
        pLogData->Signature = MAKE_FREE_TAG(Tag);

        UlFreeLogDataBufferPool(pLogData);
    }
    else
    {
        UlPplFreeLogDataBuffer(pLogData);
    }
}

/***************************************************************************++

Routine Description:

    Common function to execute various logging functions "create dirs/files"
    under system porocess. * if necessary *

Arguments:

    pContext - To be passed to the handler function.
    pHandler - Handler function which will be queued if necessary.

--***************************************************************************/

NTSTATUS
UlQueueLoggingRoutine(
    IN PVOID              pContext, 
    IN PUL_LOG_IO_ROUTINE pHandler 
    )
{
    NTSTATUS Status;
    
    PAGED_CODE();  

    ASSERT(pContext);
    ASSERT(pHandler);

    //
    // Queue a worker if we are not under system process,
    // to ensure the directories/files get created under the
    // system process.
    //

    if (g_pUlSystemProcess != (PKPROCESS)IoGetCurrentProcess())
    {
        LOG_IO_SYNC_OBJ Sync;

        KeInitializeEvent( &Sync.Event,
                           NotificationEvent,
                           FALSE
                           );

        UlInitializeWorkItem( &Sync.WorkItem );

        Sync.pContext = pContext;
        Sync.pHandler = pHandler;
        
        Sync.Status   = STATUS_SUCCESS;
            
        //
        // Queue as high priority to prevent deadlock. 
        // Typically our caller will be holding the logging lock.
        // This call is very rare anyway.
        //
        
        UL_QUEUE_HIGH_PRIORITY_ITEM(
            &Sync.WorkItem,
            &UlpQueueLoggingRoutineWorker
            );

        //
        // Block until worker is done.
        //
        
        KeWaitForSingleObject( (PVOID)&Sync.Event,
                                UserRequest,
                                KernelMode,
                                FALSE,
                                NULL
                                );   

        Status = Sync.Status;
    }
    else
    {
        Status = pHandler( pContext );
    }        

    return Status;
}

/***************************************************************************++

Routine Description:

    Corresponding worker function. Above function will be blocked until we
    are done.
    
Arguments:

    pWorkItem  - Embedded inside the sync obj.

--***************************************************************************/

VOID
UlpQueueLoggingRoutineWorker(
    IN PUL_WORK_ITEM   pWorkItem
    )
{
    NTSTATUS           Status;
    PUL_LOG_IO_ROUTINE pHandler;
    PVOID              pContext;
    PLOG_IO_SYNC_OBJ   pSync;

    PAGED_CODE(); 
        
    pSync = CONTAINING_RECORD( pWorkItem,
                               LOG_IO_SYNC_OBJ,
                               WorkItem
                               );
    
    pHandler = pSync->pHandler;
    pContext = pSync->pContext;

    ASSERT(pHandler);
    ASSERT(pContext);

    Status = pHandler( pContext );

    pSync->Status = Status;
    
    KeSetEvent( &pSync->Event, 0, FALSE );   

    UlTrace(LOG_UTIL, 
        ("Http!UlQueueLoggingRoutineWorker: pContext %p Status %08lx\n",
          pContext, 
          Status 
          ));      
}


/***************************************************************************++

Routine Description:

    A utility to check to see if the directory is correct or not.

Arguments:

    pDirName - The unicode directory string.

--***************************************************************************/

NTSTATUS
UlCheckLogDirectory(
    IN PUNICODE_STRING  pDirName
    )
{
    NTSTATUS Status;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(pDirName);
    
    Status = UlQueueLoggingRoutine(
                (PVOID) pDirName,
                &UlpCheckLogDirectory
                );
                
    return Status;
}

/***************************************************************************++

Routine Description:

    Actual handler which will always run under system process.

Arguments:

    pContext - The original pointer to the unicode directory string

--***************************************************************************/

NTSTATUS
UlpCheckLogDirectory(
    IN PVOID        pContext
    )
{
    NTSTATUS        Status;
    PUNICODE_STRING pDirName;
    UNICODE_STRING  DirectoryName;
    BOOLEAN         UncShare;
    BOOLEAN         ACLSupport;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(pContext);
    pDirName = (PUNICODE_STRING) pContext;

    // Always create the directories when running under system process.    
    ASSERT(g_pUlSystemProcess == (PKPROCESS)IoGetCurrentProcess());

    Status = UlBuildLogDirectory(pDirName, &DirectoryName);
    if (!NT_SUCCESS(Status))
    {
        goto end;
    }

    //
    // Create/Open the director(ies) to see whether it's correct or not.
    //

    Status = UlCreateSafeDirectory( 
                &DirectoryName, 
                &UncShare,
                &ACLSupport
                );

end:
    UlTrace(LOG_UTIL,
        ("Http!UlpCheckLogDirectory: [%S] -> [%S], Status %08lx\n",
             pDirName->Buffer,
             DirectoryName.Buffer,
             Status
             ));

    if (DirectoryName.Buffer)
    {
        UL_FREE_POOL( DirectoryName.Buffer, UL_CG_LOGDIR_POOL_TAG );
    }

    return Status;
}

/***************************************************************************++

Routine Description:

    Updates the truncate size of the entry and decides on recycle.

    Changes to the LogPeriod is handled elsewhere in the reconfig before
    this function get called.
    
    We will discard the changes to the truncate size if the current
    LogPeriod is not MaxSize.

    This function must be called if LogPeriod is HttpLoggingPeriodMaxSize.
    
Arguments:

    pEntryTruncateSize  - The log file entry's truncate size.
    pCurrentTruncateSize  - current configuration' truncate size
    NewTruncateSize  - new configuration as it's passed down by the user

Returns
    
    BOOLEAN - Make it TRUE if we need to recyle after this.
         Usage of this parameter is on need to do bases. We should
         not set this to FALSE if we do not need a recyle. Since
         some other changes may require it and already updated it to
         TRUE.         

--***************************************************************************/

BOOLEAN
UlUpdateLogTruncateSize(
    IN     ULONG          NewTruncateSize,
    IN OUT PULONG         pCurrentTruncateSize,  
    IN OUT PULONG         pEntryTruncateSize,
    IN     ULARGE_INTEGER EntryTotalWritten
    )
{
    BOOLEAN HaveToReCycle = FALSE;
    
    //
    // Sanity checks
    //
    
    PAGED_CODE();
    
    ASSERT(pCurrentTruncateSize);
    ASSERT(pEntryTruncateSize);

    ASSERT(*pCurrentTruncateSize == *pEntryTruncateSize);
    ASSERT(NewTruncateSize != *pCurrentTruncateSize);
        
    //
    // For MAX_SIZE period type we should check if
    //  limited => unlimited:
    //      we can still use the last log file
    //  unlimited => limited:
    //      we should open a new one if old size is larger than
    //      the new limitation
    //  limited => limited
    //      we should recycle if necessary
    //

    if (NewTruncateSize == HTTP_LIMIT_INFINITE)
    {
        //
        // For changes to unlimited, there's nothing special to do.
        //
    }
    else
    {
        //
        // Limited/Unlimited to Limited truncate size change
        // we need the check the truncate size against the
        // current file size.
        //

        if (EntryTotalWritten.QuadPart > (ULONGLONG)NewTruncateSize)
        {
            HaveToReCycle = TRUE;
        }
    }
    
    *pEntryTruncateSize   = NewTruncateSize;
    *pCurrentTruncateSize = NewTruncateSize;

    return HaveToReCycle;    
}

/***************************************************************************++

Routine Description:

    Determines the MAX size of the file buffer : PUL_LOG_FILE_BUFFER.

--***************************************************************************/

ULONG
UlpInitializeLogBufferGranularity()
{
    SYSTEM_BASIC_INFORMATION sbi;
    NTSTATUS Status = STATUS_SUCCESS;

    //
    // Get the granularity from the system
    //

    Status = ZwQuerySystemInformation(
                SystemBasicInformation,
                (PVOID)&sbi,
                sizeof(sbi),
                NULL
                );

    if (!NT_SUCCESS(Status))
    {
        UlTrace(LOG_UTIL,
            ("Http!UlpInitializeLogBufferGranularity: failure %08lx\n",
              Status) );

        return DEFAULT_MAX_LOG_BUFFER_SIZE;
    }

    UlTrace(LOG_UTIL,
            ("Http!UlpInitializeLogBufferGranularity: %d\n",
                sbi.AllocationGranularity
                ) );

    return sbi.AllocationGranularity;
}


/***************************************************************************++

Routine Description:

    This function allocates an I/O error log record, fills it in and writes it
    to the I/O error log.


Arguments:

    EventCode           - Identifies the error message.

    UniqueEventValue    - Identifies this instance of a given error message.

    NumStrings          - Number of unicode strings in strings list.

    DataSize            - Number of bytes of data.

    Strings             - Array of pointers to unicode strings.

    Data                - Binary dump data for this message, each piece being
                          aligned on word boundaries.

Return Value:

    STATUS_SUCCESS                If successful.

    STATUS_INSUFFICIENT_RESOURCES If unable to allocate the IO error log packet.

    STATUS_BUFFER_OVERFLOW        If passed in string + data is bigger than 
                                  HTTP_MAX_EVENT_LOG_DATA_SIZE.

Notes:

    This code is paged and may not be called at raised IRQL.

--***************************************************************************/

NTSTATUS
UlWriteEventLogEntry(
    IN  NTSTATUS                EventCode,
    IN  ULONG                   UniqueEventValue,
    IN  USHORT                  NumStrings,
    IN  PWSTR *                 pStringArray    OPTIONAL,
    IN  ULONG                   DataSize,
    IN  PVOID                   Data            OPTIONAL
    )
{
    PIO_ERROR_LOG_PACKET    pErrorLogEntry;
    ULONG                   PaddedDataSize;
    ULONG                   PacketSize;
    ULONG                   TotalStringSize;
    PWCHAR                  pString;
    PWCHAR                  pDestStr;
    USHORT                  i;
    NTSTATUS                Status;

    PAGED_CODE();
    
    Status = STATUS_SUCCESS;

    do
    {
        //
        // Sum up the length of the strings
        //
        TotalStringSize = 0;
        for (i = 0; i < NumStrings; i++)
        {
            ULONG  StringSize;

            StringSize = sizeof(UNICODE_NULL);
            pString = pStringArray[i];

            while (*pString++ != UNICODE_NULL)
            {
                StringSize += sizeof(WCHAR);
            }

            TotalStringSize += StringSize;
        }

        PaddedDataSize = ALIGN_UP(DataSize, ULONG);

        PacketSize = TotalStringSize + PaddedDataSize;

        //
        // Now add in the size of the log packet, but subtract 4 from the data
        // since the packet struct contains a ULONG for data.
        //
        if (PacketSize > sizeof(ULONG))
        {
            PacketSize += sizeof(IO_ERROR_LOG_PACKET) - sizeof(ULONG);
        }
        else
        {
            PacketSize += sizeof(IO_ERROR_LOG_PACKET);
        }

        if (PacketSize > ERROR_LOG_MAXIMUM_SIZE)
        {        
            Status = STATUS_BUFFER_OVERFLOW;
            break;
        }

        pErrorLogEntry = (PIO_ERROR_LOG_PACKET) IoAllocateErrorLogEntry(g_UlDriverObject,
                                                                        (UCHAR) PacketSize);

        if (pErrorLogEntry == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        //
        // Fill in the necessary log packet fields.
        //
        pErrorLogEntry->UniqueErrorValue = UniqueEventValue;
        pErrorLogEntry->ErrorCode = EventCode;
        pErrorLogEntry->NumberOfStrings = NumStrings;
        pErrorLogEntry->StringOffset = (USHORT) (sizeof(IO_ERROR_LOG_PACKET) + PaddedDataSize - sizeof(ULONG));
        pErrorLogEntry->DumpDataSize = (USHORT) PaddedDataSize;

        //
        // Copy the Dump Data to the packet
        //
        if (DataSize > 0)
        {
            RtlMoveMemory((PVOID)pErrorLogEntry->DumpData,
                          Data,
                          DataSize);
        }

        //
        // Copy the strings to the packet.
        //
        pDestStr = (PWCHAR)((PUCHAR)pErrorLogEntry + pErrorLogEntry->StringOffset);

        for (i = 0; i < NumStrings; i++)
        {
            pString = pStringArray[i];

            while ((*pDestStr++ = *pString++) != UNICODE_NULL)
                NOTHING;
        }

        IoWriteErrorLogEntry(pErrorLogEntry);

        ASSERT(NT_SUCCESS(Status) == TRUE);

    }
    while (FALSE);
    
    return (Status);
}


/**************************************************************************++

Routine Description:

Arguments:

    EventCode - Supplies the event log message code.

    pMessage - Supplies the message to write to the event log.

    WriteErrorCode - Supplies a boolean to choose whether or not ErrorCode
        gets written to the event log.

    ErrorCode - Supplies the error code to write to the event log.  It is
        ignored if WriteErrorCode is FALSE.

Return Value:

    NTSTATUS.

--**************************************************************************/
NTSTATUS
UlEventLogOneStringEntry(
    IN NTSTATUS EventCode,
    IN PWSTR    pMessage,
    IN BOOLEAN  WriteErrorCode,
    IN NTSTATUS ErrorCode       OPTIONAL
    )
{
    // Sanity check.
    C_ASSERT(UL_ELLIPSIS_SIZE % sizeof(WCHAR) == 0);

    NTSTATUS Status;
    WCHAR    MessageChars[UL_ELLIPSIS_SIZE / sizeof(WCHAR)];
    ULONG    MessageSize;
    ULONG    DataSize;
    PVOID    Data;
    ULONG    i = 0;
    BOOLEAN  Truncated = FALSE;

    //
    // Sanity check.
    //

    PAGED_CODE();
    ASSERT(pMessage != NULL);

    //
    // Is the error code to be written?
    //

    if (WriteErrorCode)
    {
        DataSize = (ULONG)sizeof(ErrorCode);
        Data = &ErrorCode;
    }
    else
    {
        DataSize = 0;
        Data = NULL;
    }

    //
    // Calculate message size in bytes (including terminating UNICODE_NULL.)
    //

    MessageSize = (ULONG)((wcslen(pMessage) + 1) * sizeof(WCHAR));

    if (MessageSize + DataSize > HTTP_MAX_EVENT_LOG_DATA_SIZE)
    {
        //
        // Message is too big to fit in an event log entry.
        // Truncate it at the end.  For instance,
        //   http://site:80/This/is/a/very/long/url/hence/it/will/be/truncated/
        // will become,
        //   http://site:80/This/is/a/very/long/url/hence/it/wi...
        //
        // To truncate, overwrite "ll/b" with "...\0".
        //

        Truncated = TRUE;

        //
        // Find the index of char where ellipsis will be inserted.
        //

        ASSERT(HTTP_MAX_EVENT_LOG_DATA_SIZE >= UL_ELLIPSIS_SIZE + DataSize);

        i = (HTTP_MAX_EVENT_LOG_DATA_SIZE - UL_ELLIPSIS_SIZE - DataSize);

        //
        // MessageSize + DataSize > HTTP_MAX_EVENT_LOG_DATA_SIZE
        //
        // Therefore,
        //    MessageSize - UL_ELLIPSIS_SIZE > 
        //       HTTP_MAX_EVENT_LOG_DATA_SIZE - DataSize - UL_ELLIPSIS_SIZE.
        //

        ASSERT(i < MessageSize - UL_ELLIPSIS_SIZE);

        i /= sizeof(WCHAR);

        //
        // Remember the old characters.
        //

        RtlCopyMemory(&MessageChars[0], &pMessage[i], UL_ELLIPSIS_SIZE);

        //
        // Copy ellipsis (including a UNICODE_NULL.)
        //

        RtlCopyMemory(&pMessage[i], UL_ELLIPSIS_WSTR, UL_ELLIPSIS_SIZE);
    }

    ASSERT((wcslen(pMessage) + 1) * sizeof(WCHAR) + DataSize
           <= HTTP_MAX_EVENT_LOG_DATA_SIZE);
    //
    // Write an event log entry.
    //

    Status = UlWriteEventLogEntry(
                 EventCode, // EventCode
                 0,         // UniqueEventValue
                 1,         // NumStrings
                 &pMessage, // pStringArray
                 DataSize,  // DataSize
                 Data       // Data
                 );

    //
    // Log entry should not be too big to cause an overflow.
    //

    ASSERT(Status != STATUS_BUFFER_OVERFLOW);

    //
    // Restore message characters if necessary.
    //

    if (Truncated)
    {
        RtlCopyMemory(&pMessage[i], &MessageChars[0], UL_ELLIPSIS_SIZE);
    }

    return Status;
}


/***************************************************************************++

Routine Description:

    Common routine for event logging the create file or directory failure.
    
Arguments:

    Failure         - The failure at create time.
    LoggingType     - Distinguishes the type of the caller 
    pFullName       - Fully qualified file name.
    SiteId          - used only if the caller is UlEventLogNormal

--***************************************************************************/

NTSTATUS
UlEventLogCreateFailure(
    IN NTSTATUS                Failure,
    IN UL_LOG_EVENT_LOG_TYPE   LoggingType,
    IN PUNICODE_STRING         pFullName,
    IN ULONG                   SiteId
    )
{
    NTSTATUS Status;
    NTSTATUS EventCode;
    PWSTR    StringList[1];
    PWSTR   *pStrings;
    USHORT   NumOfStrings;

    PAGED_CODE();
    
    //
    // Dispatch the failure type.
    //
    
    if (Failure == STATUS_INVALID_OWNER)
    {       
        EventCode = (NTSTATUS) EVENT_HTTP_LOGGING_INVALID_FILE_OWNER;
    }
    else
    {
        switch(LoggingType)
        {
            case UlEventLogNormal:
                EventCode = (NTSTATUS) EVENT_HTTP_LOGGING_CREATE_FILE_FAILED;
                break;
        
            case UlEventLogBinary:
                EventCode = (NTSTATUS) EVENT_HTTP_LOGGING_CREATE_BINARY_FILE_FAILED;
                break;
        
            case UlEventLogError:
                EventCode = (NTSTATUS) EVENT_HTTP_LOGGING_CREATE_ERROR_FILE_FAILED;
                break;
                
            default:
                ASSERT(!"Invalid event log caller !");
                return STATUS_INVALID_PARAMETER;
                break;                    
        }        
    }

    //
    // Init the informational strings.
    //
    
    switch(EventCode)
    {
        case EVENT_HTTP_LOGGING_INVALID_FILE_OWNER:
        case EVENT_HTTP_LOGGING_CREATE_FILE_FAILED:
        {
            ULONG DirOffset = UlpGetDirNameOffset(pFullName->Buffer);
            StringList[0]    = (PWSTR) &pFullName->Buffer[DirOffset]; 

            pStrings     = StringList;
            NumOfStrings = 1;                        
        }
        break;
        
        case EVENT_HTTP_LOGGING_CREATE_BINARY_FILE_FAILED:
        case EVENT_HTTP_LOGGING_CREATE_ERROR_FILE_FAILED:
        {
            pStrings     = NULL;
            NumOfStrings = 0;            
        }        
        break;
        
        default:
            ASSERT(!"Invalid event code !");
            return STATUS_INVALID_PARAMETER;
        break;
    }
    
    //
    // Now event log.
    //
    
    Status = UlWriteEventLogEntry(
                   EventCode,
                   0,
                   NumOfStrings,
                   pStrings,
                   sizeof(NTSTATUS),
                   (PVOID) &Failure
                   );

    ASSERT(NumOfStrings != 0 || Status != STATUS_BUFFER_OVERFLOW);

    //
    // Report the site name if we couldn't pass the fully qualified 
    // logging directoy/file name.
    //
    
    if (Status == STATUS_BUFFER_OVERFLOW)
    {
        WCHAR SiteName[MAX_ULONG_STR + 1];
                
        //
        // Revert back to the less detailed warning.
        //
        
        if(EventCode == EVENT_HTTP_LOGGING_INVALID_FILE_OWNER)
        {
            StringList[0] = UlpGetLastDirOrFile(pFullName);            
            
            // Event code stays the same
        }
        else
        {
            ASSERT(EventCode == EVENT_HTTP_LOGGING_CREATE_FILE_FAILED);

            UlStrPrintUlongW(SiteName, SiteId, 0, L'\0');
            StringList[0] = (PWSTR) SiteName;

            EventCode = (NTSTATUS) EVENT_HTTP_LOGGING_CREATE_FILE_FAILED_FOR_SITE;
        }        

        Status = UlWriteEventLogEntry(
                       EventCode,
                       0,
                       1,
                       StringList,
                       sizeof(NTSTATUS),
                       (PVOID) &Failure
                       );
        
        ASSERT(Status != STATUS_BUFFER_OVERFLOW);
    }

    return Status;
}

/***************************************************************************++

Routine Description:

    Builds a security descriptor for a log file or directory.

        - Full access for NT AUTHORITY\SYSTEM       (SeLocalSystemSid)

        - Full access for BUILTIN\Administrators    (SeAliasAdminsSid)

        If passed in

        - Full access for pSid

        Typically the pSid is SeCreatorOwnerSid (and used for a unc share)

Arguments:

    pSecurityDescriptor  Get allocated

    pSid                 Optional sid

--***************************************************************************/

NTSTATUS
UlBuildSecurityToLogFile(
    OUT PSECURITY_DESCRIPTOR  pSecurityDescriptor,
    IN  PSID                  pSid
    )
{
    NTSTATUS            Status;
    PGENERIC_MAPPING    pFileObjectGenericMapping;
    ACCESS_MASK         FileAll;
    SID_MASK_PAIR       SidMaskPairs[3];

    //
    // Sanity check.
    //

    PAGED_CODE();

    pFileObjectGenericMapping = IoGetFileObjectGenericMapping();
    ASSERT(pFileObjectGenericMapping != NULL);

    FileAll = GENERIC_ALL;

    RtlMapGenericMask(
        &FileAll,
        pFileObjectGenericMapping
        );

    //
    // Build a restrictive security descriptor for the log file
    // object. ACEs for log sub-folders must be inheritable.
    //

    ASSERT(RtlValidSid(SeExports->SeLocalSystemSid));
    ASSERT(RtlValidSid(SeExports->SeAliasAdminsSid));

    SidMaskPairs[0].pSid       = SeExports->SeLocalSystemSid;
    SidMaskPairs[0].AccessMask = FileAll;
    SidMaskPairs[0].AceFlags   = CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE;

    SidMaskPairs[1].pSid       = SeExports->SeAliasAdminsSid;
    SidMaskPairs[1].AccessMask = FileAll;
    SidMaskPairs[1].AceFlags   = CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE;

    if (pSid != NULL)
    {
        ASSERT(RtlValidSid(pSid));

        SidMaskPairs[2].pSid       = pSid;
        SidMaskPairs[2].AccessMask = FileAll;
        SidMaskPairs[2].AceFlags   = CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE;
    }

    Status = UlCreateSecurityDescriptor(
                    pSecurityDescriptor,    // pSecurityDescriptor
                    &SidMaskPairs[0],       // pSidMaskPairs
                    pSid != NULL ? 3 : 2    // NumSidMaskPairs
                    );

    return Status;
}

/***************************************************************************++

Routine Description:

    Used to query the owner of an existing logging sub-directory
    or a log file.

    If the owner is valid, this function resets the DACLs on the file only
    on a UNC share when the file is newly created.

Arguments:

    hFile               Handle to the log directory OR to the log file.

    UncShare            Shows whether file is opened on a unc share or not.

    Opened              Shows whether file is opened or created.

Returns

    STATUS_INSUFFICIENT_RESOURCES      If unable to allocate the required
                                       security descriptor.


    STATUS_SUCCESS                     Caller can use the output values.


    STATUS_INVALID_OWNER               Owner is INVALID.

    Any other failure returned by SE APIs.

--***************************************************************************/

NTSTATUS
UlQueryLogFileSecurity(
    IN HANDLE            hFile,
    IN BOOLEAN           UncShare,
    IN BOOLEAN           Opened
    )
{
    NTSTATUS             Status             = STATUS_SUCCESS;
    ULONG                SecurityLength     = 0;
    PSECURITY_DESCRIPTOR pSecurity          = NULL;
    PSID                 Owner              = NULL;
    BOOLEAN              OwnerDefaulted     = FALSE;

    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // First get the owner's sid back from the newly created
    // log file.
    //

    Status = ZwQuerySecurityObject(
                hFile,
                OWNER_SECURITY_INFORMATION,
                NULL,
                0,
                &SecurityLength
                );

    if (Status == STATUS_BUFFER_TOO_SMALL)
    {
        //
        // File objects must have an owner.
        //

        ASSERT(SecurityLength);

        //
        // Allocate enough space for the Sec Info.
        //

        pSecurity =
            (PSECURITY_DESCRIPTOR)
                UL_ALLOCATE_POOL(
                    PagedPool,
                    SecurityLength,
                    UL_SECURITY_DATA_POOL_TAG
                    );

        if (pSecurity)
        {
            Status = ZwQuerySecurityObject(
                       hFile,
                       OWNER_SECURITY_INFORMATION,
                       pSecurity,
                       SecurityLength,
                      &SecurityLength
                       );

            if (NT_SUCCESS(Status))
            {
                Status = RtlGetOwnerSecurityDescriptor(
                            pSecurity,
                            &Owner,
                            &OwnerDefaulted
                            );

                if (NT_SUCCESS(Status))
                {
                    ASSERT(RtlValidSid(Owner));

                    TRACE_LOG_FILE_OWNER(Owner,OwnerDefaulted);

                    if (UncShare == TRUE)
                    {
                        //
                        // Reset the DACLs on a new file to give
                        // ourselves a full access.
                        //

                        if (Opened == FALSE)
                        {
                            SECURITY_DESCRIPTOR  SecurityDescriptor;

                            //
                            // Since it's us who created the file, the 
                            // owner SID must be our machine account.
                            //
                            
                            Status = UlBuildSecurityToLogFile(
                                        &SecurityDescriptor,
                                        Owner
                                        );

                            if (NT_SUCCESS(Status))
                            {
                               ASSERT(RtlValidSecurityDescriptor(
                                            &SecurityDescriptor
                                            ));

                               Status = ZwSetSecurityObject(
                                            hFile,
                                            DACL_SECURITY_INFORMATION,
                                            &SecurityDescriptor
                                            );

                               UlCleanupSecurityDescriptor(&SecurityDescriptor);
                            }                            
                        }                        
                        
                    }
                    else
                    {
                        //
                        // For local machine the only thing we have to do is
                        // to make an ownership check.
                        //
                        
                        if (!IS_VALID_OWNER(Owner))
                        {
                            //
                            // Ouch, somebody  hijacked  the directory. Stop right
                            // here. Update the status so that caller can eventlog
                            // properly.
                            //

                            Status = STATUS_INVALID_OWNER;                            
                        }
                    }
                    
                }
            }

            UL_FREE_POOL(
                pSecurity,
                UL_SECURITY_DATA_POOL_TAG
                );
        }
        else
        {
            return  STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    UlTrace(LOG_UTIL,
        ("Http!UlQueryLogFileSecurity: Status 0x%08lx\n",
          Status
          ));

    return Status;
}

/***************************************************************************++

Routine Description:

    Will query the file system to figure out the File System Attributes for 
    a file handle passed in.    
        
Arguments:

    hFile  Handle to the log directory OR to the log file. (Could be UNC file)

    pSupportsPersistentACL : Will be set to TRUE for file systems supoorts the
                             persistent ACLing. I.e TRUE for NTFS, FALSE for
                             FAT32.

                             It is not going to be set if the Query fails.
Returns

    STATUS_INSUFFICIENT_RESOURCES      If unable to allocate the required
                                       security descriptor.


    STATUS_SUCCESS                     Caller can use the BOOLEAN set.


--***************************************************************************/

NTSTATUS
UlQueryAttributeInfo(
    IN  HANDLE   hFile,
    OUT PBOOLEAN pSupportsPersistentACL
    )
{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    PFILE_FS_ATTRIBUTE_INFORMATION pAttributeInfo;
    ULONG AttributeInfoSize;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(pSupportsPersistentACL);
    
    //
    // According to the implementation of the GetVolumeInformation API,
    // MAX_PATH should be sufficient to hold file system name. Notice
    // there's a one WCHAR in the structure so that we have space for 
    // the terminating null.
    //
    
    AttributeInfoSize = 
        sizeof(FILE_FS_ATTRIBUTE_INFORMATION) 
        + (MAX_PATH * sizeof(WCHAR));
            
    pAttributeInfo =
        (PFILE_FS_ATTRIBUTE_INFORMATION)
            UL_ALLOCATE_POOL(
                PagedPool,
                AttributeInfoSize,
                UL_LOG_VOLUME_QUERY_POOL_TAG
                );

    if (!pAttributeInfo)
    {
        return  STATUS_INSUFFICIENT_RESOURCES;            
    }
        
    RtlZeroMemory(pAttributeInfo, AttributeInfoSize);
        
    Status = 
        NtQueryVolumeInformationFile(
            hFile,
            &IoStatusBlock,
            (PVOID) pAttributeInfo,
            AttributeInfoSize,
            FileFsAttributeInformation
            );

    if (NT_SUCCESS(Status))
    {
        if (FILE_PERSISTENT_ACLS & pAttributeInfo->FileSystemAttributes)
        {
            *pSupportsPersistentACL = TRUE;
        }
        else
        {
            *pSupportsPersistentACL = FALSE;
        }        
    
        UlTrace(LOG_UTIL,
            ("Http!UlQueryAttributeInfo:\n"
             "\tFileSystemAttributes :0x%08lX\n"
             "\tPersistent ACL       :%s\n"
             "\tMaxCompNameLength    :%d\n"
             "\tName                 :%S\n",
              pAttributeInfo->FileSystemAttributes,
              *pSupportsPersistentACL == TRUE ? "TRUE" : "FALSE",
              pAttributeInfo->MaximumComponentNameLength,
              pAttributeInfo->FileSystemName
              ));
    }
    else
    {
        UlTrace(LOG_UTIL,
            ("Http!UlQueryAttributeInfo: Status 0x%08lX"
             " IoStatusBlock.Status 0x%08lX\n",
              Status,
              IoStatusBlock.Status
              ));
    }
    
    UL_FREE_POOL(
        pAttributeInfo,
        UL_LOG_VOLUME_QUERY_POOL_TAG
        );
    
    return Status;
}


/***************************************************************************++

Routine Description:

    Compute the space needed for LogData stored in a cache entry.

Arguments:

    pLogData    Supplies a UL_LOG_DATA_BUFFER to compute the space.

Returns

    Length for the LogData.

--***************************************************************************/

USHORT
UlComputeCachedLogDataLength(
    IN PUL_LOG_DATA_BUFFER  pLogData
    )
{
    USHORT LogDataLength = 0;

    ASSERT(IS_VALID_LOG_DATA_BUFFER(pLogData));

    if (pLogData->Flags.Binary)
    {
        //
        // Nothing to store other than the RawId for the UriStem
        // If no logging data is provided while we are  building
        // the cache entry,no logging will happen for this cache
        // entry for the future cache hits.
        //

        LogDataLength = sizeof(HTTP_RAWLOGID);
    }
    else
    {
        switch(pLogData->Data.Str.Format)
        {
        case HttpLoggingTypeW3C:
            //
            // Store the fields from SiteName to ServerPort.
            // Reserved space for date & time will not be copied.
            //
            LogDataLength = pLogData->Data.Str.Offset2
                            - pLogData->Data.Str.Offset1;
            break;

        case HttpLoggingTypeNCSA:
            //
            // Store the fields from Method to UriQuery.
            //
            LogDataLength = pLogData->Data.Str.Offset2
                            - pLogData->Data.Str.Offset1
                            - NCSA_FIX_DATE_AND_TIME_FIELD_SIZE;
            break;

        case HttpLoggingTypeIIS:
            //
            // Store the 2nd and 3rd fragments to the cache.
            //
            LogDataLength = pLogData->Used // Sizeof 3rd
                            + pLogData->Data.Str.Offset2; // Sizeof 2nd
            break;

        default:
            ASSERT(!"Invalid Log Format.\n");
            break;
        }
    }

    return LogDataLength;
}

/***************************************************************************++

Routine Description:

    Copy the LogData to the cache entry.

Arguments:

    pLogData        Supplies a UL_LOG_DATA_BUFFER to compute the space.

    LogDataLength   Length of pLogData supplied.

    pEntry          Supplies the cache entry to copy.

Returns

    None.

--***************************************************************************/

VOID
UlCopyCachedLogData(
    IN PUL_LOG_DATA_BUFFER  pLogData,
    IN USHORT               LogDataLength, 
    IN PUL_URI_CACHE_ENTRY  pEntry
    )
{
    HTTP_RAWLOGID           CacheId = { 0, 0 };

    //
    // Copy over the partially complete log line excluding the date and
    // time fields to the cache entry. Also remember the length of the
    // data.
    //

    if (LogDataLength)
    {
        if (pLogData->Flags.Binary)
        {
            ULARGE_INTEGER Address;

            Address.QuadPart = (ULONGLONG) pEntry;

            CacheId.AddressLowPart  = Address.LowPart;
            CacheId.AddressHighPart = Address.HighPart;

            ASSERT(LogDataLength == sizeof(CacheId));

            RtlCopyMemory(
                    pEntry->pLogData,
                   &CacheId,
                    LogDataLength
                    );

            pEntry->BinaryLogged = TRUE;
        }
        else
        {
            switch( pLogData->Data.Str.Format )
            {
                case HttpLoggingTypeW3C:
                {
                    pEntry->UsedOffset1 = pLogData->Data.Str.Offset1;
                    pEntry->UsedOffset2 = pLogData->Data.Str.Offset2;

                    // Copy the middle fragment

                    RtlCopyMemory(
                            pEntry->pLogData,
                           &pLogData->Line[pEntry->UsedOffset1],
                            LogDataLength
                            );
                }
                break;

                case HttpLoggingTypeNCSA:
                {
                    // Calculate the start of the middle fragment.

                    pEntry->UsedOffset1 = pLogData->Data.Str.Offset1
                                          + NCSA_FIX_DATE_AND_TIME_FIELD_SIZE;
                    pEntry->UsedOffset2 = 0;

                    // Copy the middle fragment

                    RtlCopyMemory(
                            pEntry->pLogData,
                           &pLogData->Line[pEntry->UsedOffset1],
                            LogDataLength
                            );
                }
                break;

                case HttpLoggingTypeIIS:
                {
                    // UsedOffset1 specifies the second fragment's size.
                    // UsedOffset2 specifies the third's size.

                    pEntry->UsedOffset1 = pLogData->Data.Str.Offset2;
                    pEntry->UsedOffset2 = LogDataLength - pEntry->UsedOffset1;

                    // Copy over the fragments two and three

                    RtlCopyMemory(
                            pEntry->pLogData,
                           &pLogData->Line[IIS_LOG_LINE_SECOND_FRAGMENT_OFFSET],
                            pEntry->UsedOffset1
                            );
                    RtlCopyMemory(
                           &pEntry->pLogData[pEntry->UsedOffset1],
                           &pLogData->Line[IIS_LOG_LINE_THIRD_FRAGMENT_OFFSET],
                            pEntry->UsedOffset2
                            );
                }
                break;

                default:
                ASSERT(!"Unknown Log Format.\n");
            }
        }
    }
    else
    {
        //
        // Only W3C log line may not have something to cache
        // but it still may require the date & time fields
        // to be logged, albeit not stored in the cache entry.
        //

        ASSERT( pLogData->Flags.Binary == 0);
        ASSERT( pLogData->Data.Str.Format == HttpLoggingTypeW3C );

        pEntry->LogDataLength = 0;
        pEntry->pLogData      = NULL;

        //
        // Carry over the Offsets so that cache hit worker can
        // calculate reserved space for date & time.
        //

        pEntry->UsedOffset1   = pLogData->Data.Str.Offset1;
        pEntry->UsedOffset2   = pLogData->Data.Str.Offset2;
    }
}

/***************************************************************************++

Routine Description:

    Initializes the Log Date & Time Cache

--***************************************************************************/
VOID
UlpInitializeLogCache(
    VOID
    )
{
    LARGE_INTEGER SystemTime;
    ULONG         LogType;

    ExInitializeFastMutex( &g_LogCacheFastMutex);

    KeQuerySystemTime(&SystemTime);

    for ( LogType=0; LogType<HttpLoggingTypeMaximum; LogType++ )
    {
        UlpGenerateDateAndTimeFields( (HTTP_LOGGING_TYPE) LogType,
                                      SystemTime,
                                      g_UlDateTimeCache[LogType].Date,
                                     &g_UlDateTimeCache[LogType].DateLength,
                                      g_UlDateTimeCache[LogType].Time,
                                     &g_UlDateTimeCache[LogType].TimeLength
                                      );

        g_UlDateTimeCache[LogType].LastSystemTime.QuadPart = SystemTime.QuadPart;
    }
}

/***************************************************************************++

Routine Description:

    Generates all possible types of date/time fields from a LARGE_INTEGER.

Arguments:

    CurrentTime: A 64 bit Time value to be converted.

--***************************************************************************/

VOID
UlpGenerateDateAndTimeFields(
    IN  HTTP_LOGGING_TYPE   LogType,
    IN  LARGE_INTEGER       CurrentTime,
    OUT PCHAR               pDate,
    OUT PULONG              pDateLength,
    OUT PCHAR               pTime,
    OUT PULONG              pTimeLength
    )
{
    TIME_FIELDS   CurrentTimeFields;
    LARGE_INTEGER CurrentTimeLoc;
    TIME_FIELDS   CurrentTimeFieldsLoc;
    PCHAR         psz;

    // This routine does touch to pageable memory if the default log buffer
    // wasn't sufficent enough to hold log fields and get reallocated from
    // paged pool. For this reason the date&time cache can not use SpinLocks.

    PAGED_CODE();

    ASSERT(LogType < HttpLoggingTypeMaximum);

    RtlTimeToTimeFields( &CurrentTime, &CurrentTimeFields );

    switch(LogType)
    {
    case HttpLoggingTypeW3C:
        //
        // Uses GMT with format as follows;
        //
        // 2000-01-31 00:12:23
        //

        if (pDate)
        {
            psz = pDate;
            psz = UlStrPrintUlongPad(psz, CurrentTimeFields.Year, 4, '-' );
            psz = UlStrPrintUlongPad(psz, CurrentTimeFields.Month,2, '-' );
            psz = UlStrPrintUlongPad(psz, CurrentTimeFields.Day,  2, '\0');
            *pDateLength = DIFF(psz - pDate);
        }

        if (pTime)
        {
            psz = pTime;
            psz = UlStrPrintUlongPad(psz, CurrentTimeFields.Hour,  2, ':' );
            psz = UlStrPrintUlongPad(psz, CurrentTimeFields.Minute,2, ':' );
            psz = UlStrPrintUlongPad(psz, CurrentTimeFields.Second,2, '\0');
            *pTimeLength = DIFF(psz - pTime);
        }
    break;

    case HttpLoggingTypeNCSA:
        //
        // Uses GMT Time with format as follows;
        //
        // 07/Jan/2000 00:02:23
        //

        ExSystemTimeToLocalTime( &CurrentTime, &CurrentTimeLoc );
        RtlTimeToTimeFields( &CurrentTimeLoc, &CurrentTimeFieldsLoc );

        if(pDate)
        {
            psz = pDate;
            psz = UlStrPrintUlongPad(psz, CurrentTimeFieldsLoc.Day, 2, '/' );
            psz = UlStrPrintStr(psz, UL_GET_MONTH_AS_STR(CurrentTimeFieldsLoc.Month),'/');
            psz = UlStrPrintUlongPad(psz, CurrentTimeFieldsLoc.Year,4, '\0');
            *pDateLength = DIFF(psz - pDate);
        }

        if(pTime)
        {
            psz = pTime;
            psz = UlStrPrintUlongPad(psz, CurrentTimeFieldsLoc.Hour,  2, ':' );
            psz = UlStrPrintUlongPad(psz, CurrentTimeFieldsLoc.Minute,2, ':' );
            psz = UlStrPrintUlongPad(psz, CurrentTimeFieldsLoc.Second,2, '\0');
            *pTimeLength = DIFF(psz - pTime);
        }
    break;

    case HttpLoggingTypeIIS:
        //
        // Uses LOCAL Time with format as follows;
        // This should be localised if we can solve the problem.
        //
        // 1/31/2000 0:02:03
        //

        ExSystemTimeToLocalTime( &CurrentTime, &CurrentTimeLoc );
        RtlTimeToTimeFields( &CurrentTimeLoc, &CurrentTimeFieldsLoc );

        if (pDate)
        {
            psz = pDate;
            psz = UlStrPrintUlongPad(psz, CurrentTimeFieldsLoc.Month, 0, '/' );
            psz = UlStrPrintUlongPad(psz, CurrentTimeFieldsLoc.Day,   0, '/' );
            psz = UlStrPrintUlongPad(psz, CurrentTimeFieldsLoc.Year,  0, '\0');
            *pDateLength = DIFF(psz - pDate);
        }

        if(pTime)
        {
            psz = pTime;
            psz = UlStrPrintUlongPad(psz, CurrentTimeFieldsLoc.Hour,  0, ':' );
            psz = UlStrPrintUlongPad(psz, CurrentTimeFieldsLoc.Minute,2, ':' );
            psz = UlStrPrintUlongPad(psz, CurrentTimeFieldsLoc.Second,2, '\0');
            *pTimeLength = DIFF(psz - pTime);
        }
    break;

    case HttpLoggingTypeRaw:
        /* Binary logging does not use the date and time cache */
        break;
        
    default:
        ASSERT(!"Invalid Logging Type !");
        break;
    }

    return;
}

/***************************************************************************++

Routine Description:

    Generates a date header and updates cached value if required.

    Caller should overwrite the terminating null by a space or comma.

Arguments:

    Date and Time are optional. But one of them should be provided.

--***************************************************************************/

VOID
UlGetDateTimeFields(
    IN  HTTP_LOGGING_TYPE   LogType,
    OUT PCHAR               pDate,
    OUT PULONG              pDateLength,
    OUT PCHAR               pTime,
    OUT PULONG              pTimeLength
    )
{
    LARGE_INTEGER SystemTime;
    LARGE_INTEGER CacheTime;
    LONGLONG      Timediff;

    PAGED_CODE();

    ASSERT(LogType < HttpLoggingTypeMaximum);
    ASSERT(pDate || pTime);

    //
    // Get the current time.
    //
    KeQuerySystemTime( &SystemTime );

    CacheTime.QuadPart =
        g_UlDateTimeCache[LogType].LastSystemTime.QuadPart;

    //
    // Check the difference between the current time, and
    // the cached time.
    //
    Timediff = SystemTime.QuadPart - CacheTime.QuadPart;

    if (Timediff < ONE_SECOND)
    {
        //
        // The cached date&time hasn't gone stale yet.We can copy.
        // Force a barrier around reading the string into memory.
        //

        UL_READMOSTLY_READ_BARRIER();
        if (pDate)
        {
            RtlCopyMemory( pDate,
                           g_UlDateTimeCache[LogType].Date,
                           g_UlDateTimeCache[LogType].DateLength
                           );
            *pDateLength = g_UlDateTimeCache[LogType].DateLength;
        }
        if (pTime)
        {
            RtlCopyMemory( pTime,
                           g_UlDateTimeCache[LogType].Time,
                           g_UlDateTimeCache[LogType].TimeLength
                           );
            *pTimeLength = g_UlDateTimeCache[LogType].TimeLength;
        }
        UL_READMOSTLY_READ_BARRIER();

        //
        // Get grab the cached time value again in case it has been changed.
        // As you notice we do not have a lock around this part of the code.
        //

        if (CacheTime.QuadPart ==
                g_UlDateTimeCache[LogType].LastSystemTime.QuadPart)
        {
            //
            // Value hasn't changed. We are all set.
            //
            return;
        }
        //
        // Otherwise fall down and flush the cache, and then recopy.
        //

    }

    //
    // The cached date & time is stale. We need to update it.
    //

    ExAcquireFastMutex( &g_LogCacheFastMutex );

    //
    // Has someone else updated the time while we were blocked?
    //

    CacheTime.QuadPart =
        g_UlDateTimeCache[LogType].LastSystemTime.QuadPart;

    Timediff = SystemTime.QuadPart - CacheTime.QuadPart;

    if (Timediff >= ONE_SECOND)
    {
        g_UlDateTimeCache[LogType].LastSystemTime.QuadPart = 0;
        KeQuerySystemTime( &SystemTime );

        UL_READMOSTLY_WRITE_BARRIER();
        UlpGenerateDateAndTimeFields(
                  LogType,
                  SystemTime,
                  g_UlDateTimeCache[LogType].Date,
                 &g_UlDateTimeCache[LogType].DateLength,
                  g_UlDateTimeCache[LogType].Time,
                 &g_UlDateTimeCache[LogType].TimeLength
                 );
        UL_READMOSTLY_WRITE_BARRIER();

        g_UlDateTimeCache[LogType].LastSystemTime.QuadPart =
            SystemTime.QuadPart;
    }

    //
    // The time has been updated. Copy the new string into
    // the caller's buffer.
    //
    if (pDate)
    {
        RtlCopyMemory( pDate,
                       g_UlDateTimeCache[LogType].Date,
                       g_UlDateTimeCache[LogType].DateLength
                       );
        *pDateLength = g_UlDateTimeCache[LogType].DateLength;
    }

    if (pTime)
    {
        RtlCopyMemory( pTime,
                       g_UlDateTimeCache[LogType].Time,
                       g_UlDateTimeCache[LogType].TimeLength
                       );
        *pTimeLength = g_UlDateTimeCache[LogType].TimeLength;
    }

    ExReleaseFastMutex( &g_LogCacheFastMutex );

    return;
}

/***************************************************************************++

Routine Description:

    This is a simple utility which will test the sanity of a passed in
    logging directory.

Arguments:

    pDir            - Pointer to logging directory string.

    UncSupported    - Whether or not UNC type directories are supported.

    SystemRootSupported - Whether or not "\SystemRoot" types of directories
                          are supported.
    
--***************************************************************************/


BOOLEAN
UlIsValidLogDirectory(
    IN PUNICODE_STRING  pDir,
    IN BOOLEAN          UncSupported,
    IN BOOLEAN          SystemRootSupported
    )
{
    USHORT DirLength;

    //
    // Sanity check
    //
    
    ASSERT(pDir);
    ASSERT(pDir->Buffer);
    ASSERT(pDir->Length);

    DirLength = pDir->Length / sizeof(WCHAR);
    
    // Too short for a fully qualified directory name.
    // The shortest possible is "C:\" (for Unc "\\a\b")

    if (DirLength < 3)
    {        
        return FALSE;
    }

    if (pDir->Buffer[0] == L'\\')
    {
        if (pDir->Buffer[1] == L'\\')
        {            
            // Reject Unc Path if not supported.
            
            if (!UncSupported)
            {                
                return FALSE;               
            }  
            
        }
        else
        {
            // This could either be a SystemRoot or a non-qualified
            // directory. 

            if (!SystemRootSupported)
            {
                return FALSE;
            }

            // The "\SystemRoot" represents the default system partition. 
            // Comparison is case insensitive.

            if (DirLength < UL_SYSTEM_ROOT_PREFIX_LENGTH ||
                0 != _wcsnicmp (pDir->Buffer, 
                                UL_SYSTEM_ROOT_PREFIX, 
                                UL_SYSTEM_ROOT_PREFIX_LENGTH
                                ))
            {
                // Log file directory is missing the device i.e "\temp" 
                // instead of "c:\temp". Log file directory should be 
                // fully qualified and must include the device letter.

                return FALSE;
            }
        }
    }
    else
    {
        // It should at least be pointing to the root directory
        // of the drive.
        
        if (pDir->Buffer[1] != L':' || pDir->Buffer[2] != L'\\')
        {
            return FALSE;
        }        
    }

    return TRUE;
}

/***************************************************************************++

Routine Description:

    This is a simple utility which will test the sanity of a passed in
    logging configuration. Typically used at control channel or config 
    group set IOCTLs.

Arguments:

    pBinaryConfig - Control channel logging configuration.
    pNormalConfig - Config group logging configuration.
    
--***************************************************************************/

NTSTATUS
UlCheckLoggingConfig(
    IN PHTTP_CONTROL_CHANNEL_BINARY_LOGGING pBinaryConfig,
    IN PHTTP_CONFIG_GROUP_LOGGING           pAnsiConfig
    )
{
    BOOLEAN LoggingEnabled;     
    BOOLEAN LocaltimeRollover; 
    ULONG   LogPeriod;
    ULONG   LogFileTruncateSize;
    ULONG   DirSize;
 
    if (pBinaryConfig)
    {
        ASSERT(NULL == pAnsiConfig);
        
        LoggingEnabled      = pBinaryConfig->LoggingEnabled;
        LocaltimeRollover   = pBinaryConfig->LocaltimeRollover;
        LogPeriod           = pBinaryConfig->LogPeriod;
        LogFileTruncateSize = pBinaryConfig->LogFileTruncateSize;
        DirSize             = pBinaryConfig->LogFileDir.Length;
    }
    else
    {
        ASSERT(NULL != pAnsiConfig);

        LoggingEnabled      = pAnsiConfig->LoggingEnabled;
        LocaltimeRollover   = pAnsiConfig->LocaltimeRollover;
        LogPeriod           = pAnsiConfig->LogPeriod;
        LogFileTruncateSize = pAnsiConfig->LogFileTruncateSize;        
        DirSize             = pAnsiConfig->LogFileDir.Length;        
    }

    UlTrace(LOG_UTIL,
        ("Http!UlCheckLoggingConfig: %s Logging;\n"
         "\tLoggingEnabled      : %d\n"
         "\tLocaltimeRollover   : %d\n"
         "\tLogPeriod           : %d\n"
         "\tLogFileTruncateSize : %d\n",
         NULL != pAnsiConfig ? "Ansi" : "Binary",
         LoggingEnabled,LocaltimeRollover,LogPeriod,
         LogFileTruncateSize
         ));
    
    // Do the range checking for Enabled Flag first.
        
    if (!VALID_BOOLEAN_VALUE(LoggingEnabled))
    {
        return STATUS_INVALID_PARAMETER;
    }

    // If the logging's disabled we will discard the remaining params in the 
    // configuration.

    if (LoggingEnabled == FALSE)
    {
        return STATUS_SUCCESS;
    }
    
    // More range checking for the remaining params.
    
    if (!VALID_BOOLEAN_VALUE(LocaltimeRollover) ||
        !IS_VALID_LOGGING_PERIOD(LogPeriod)
        )
    {
        return STATUS_INVALID_PARAMETER;
    }
        
    // If the passed down DirectoryName is long enough to cause full path to 
    // exceed MAX_PATH then reject it.

    if (DirSize > UL_MAX_FULL_PATH_DIR_NAME_SIZE)
    {        
        return STATUS_INVALID_PARAMETER;
    }

    // An important check to ensure that no infinite loop occurs  because of
    // of a ridiculusly small truncatesize. Which means smaller than maximum
    // allowed log record line (10*1024)
    
    if (LogPeriod           ==  HttpLoggingPeriodMaxSize  &&
        LogFileTruncateSize !=  HTTP_LIMIT_INFINITE       &&
        LogFileTruncateSize  <  HTTP_MIN_ALLOWED_TRUNCATE_SIZE_FOR_LOG_FILE
        )
    {
        return STATUS_INVALID_PARAMETER;
    }

    // Extra check apply only to the normal logging config.

    if (pAnsiConfig)
    {
        if (!IS_VALID_ANSI_LOGGING_TYPE(pAnsiConfig->LogFormat))
        {
            return STATUS_INVALID_PARAMETER;
        }

#ifdef IMPLEMENT_SELECTIVE_LOGGING
        if(!IS_VALID_SELECTIVE_LOGGING_TYPE(pAnsiConfig->SelectiveLogging))
        {
            return STATUS_INVALID_PARAMETER;
        }        
#endif

    }    

    UlTrace(LOG_UTIL,("Http!UlCheckLoggingConfig: Accepted.\n"));
    
    return STATUS_SUCCESS;    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\misc.h ===
/*++

Copyright (c) 1998-2002 Microsoft Corporation

Module Name:

    misc.h

Abstract:

    This module contains miscellaneous constants & declarations.

Author:

    Keith Moore (keithmo)       10-Jun-1998
    Henry Sanders (henrysa)     17-Jun-1998 Merge with old httputil.h
    Paul McDaniel (paulmcd)     30-Mar-1999 added refcounted eresource

Revision History:

--*/



#ifndef _MISC_H_
#define _MISC_H_



#define UL_MAX_HTTP_STATUS_CODE         999
#define UL_MAX_HTTP_STATUS_CODE_LENGTH  3

#define HTTP_PREFIX_ANSI             "http://"
#define HTTP_PREFIX_ANSI_LENGTH      (sizeof(HTTP_PREFIX_ANSI)-sizeof(CHAR))
#define HTTPS_PREFIX_ANSI            "https://"
#define HTTPS_PREFIX_ANSI_LENGTH     (sizeof(HTTPS_PREFIX_ANSI)-sizeof(CHAR))

#define HTTP_PREFIX_COLON_INDEX     4   // the colon location for http: (+4)
#define HTTPS_PREFIX_COLON_INDEX    5   // the colon location for https: (+5)

//
// Note that the length of the strong wildcard prefix is the same as 
// that of the (weak) wildcard prefix.
//

#define HTTPS_WILD_PREFIX           L"https://*:"
#define HTTPS_WILD_PREFIX_LENGTH    (sizeof(HTTPS_WILD_PREFIX)-sizeof(WCHAR))
#define HTTP_WILD_PREFIX            L"http://*:"
#define HTTP_WILD_PREFIX_LENGTH     (sizeof(HTTP_WILD_PREFIX)-sizeof(WCHAR))
#define HTTPS_STRONG_WILD_PREFIX    L"https://+:"
#define HTTP_STRONG_WILD_PREFIX     L"http://+:"

#define HTTP_IP_PREFIX              L"http://"
#define HTTP_IP_PREFIX_LENGTH       (sizeof(HTTP_IP_PREFIX)-sizeof(WCHAR))
#define HTTPS_IP_PREFIX             L"https://"
#define HTTPS_IP_PREFIX_LENGTH      (sizeof(HTTPS_IP_PREFIX)-sizeof(WCHAR))

NTSTATUS
InitializeHttpUtil(
    VOID
    );


//
// Our presumed cache-line size.
//

#define CACHE_LINE_SIZE UL_CACHE_LINE


//
// # of 100ns ticks per second ( 1ns = (1 / (10^9))s )
//

#define C_NS_TICKS_PER_SEC  ((LONGLONG) (10 * 1000 * 1000))

//
// # of 100ns ticks per minute ( 1ns = (1 / ((10^9) * 60)) min )
//

#define C_NS_TICKS_PER_MIN  ((LONGLONG) (C_NS_TICKS_PER_SEC * 60))

//
// # of millisecs per hour ( 1 ms = (1 / ((10^3) * 60 * 60)) hour )
//

#define C_MS_TICKS_PER_HOUR ((LONGLONG) (1000 * 60 * 60))

//
// # of 100ns ticks per milli second ( 1ns = (1 / (10^4)) milli sec )
//

#define C_NS_TICKS_PER_MSEC  ((LONGLONG) (10 * 1000))

//
// # of seconds per year (aprox) 
// 1 year = (60 sec/min * 60 min/hr * 24 hr/day * 365 day/year)
// 

#define C_SECS_PER_YEAR ((ULONG) (60 * 60 * 24 * 365))

//
// Alignment macros.
//

#define ROUND_UP( val, pow2 )                                               \
    ( ( (ULONG_PTR)(val) + (pow2) - 1 ) & ~( (pow2) - 1 ) )


//
// Macros for swapping the bytes in a long and a short.
//

#define SWAP_LONG   RtlUlongByteSwap
#define SWAP_SHORT  RtlUshortByteSwap


#define VALID_BOOLEAN_VALUE(x)    ((x) == TRUE || (x) == FALSE)


//
// Context values stored in PFILE_OBJECT->FsContext2 to identify a handle
// as a control channel, filter channel or an app pool.
//
// BUGBUG: Can these be spoofed?
//

#define UL_CONTROL_CHANNEL_CONTEXT      ((PVOID) MAKE_SIGNATURE('CTRL'))
#define UL_CONTROL_CHANNEL_CONTEXT_X    ((PVOID) MAKE_SIGNATURE('Xctr'))
#define UL_FILTER_CHANNEL_CONTEXT       ((PVOID) MAKE_SIGNATURE('FLTR'))
#define UL_FILTER_CHANNEL_CONTEXT_X     ((PVOID) MAKE_SIGNATURE('Xflt'))
#define UL_APP_POOL_CONTEXT             ((PVOID) MAKE_SIGNATURE('APPP'))
#define UL_APP_POOL_CONTEXT_X           ((PVOID) MAKE_SIGNATURE('Xapp'))
#define UC_SERVER_CONTEXT               ((PVOID) MAKE_SIGNATURE('SERV'))
#define UC_SERVER_CONTEXT_X             ((PVOID) MAKE_SIGNATURE('Xerv'))

#define IS_SERVER( pFileObject )                                            \
    ( (pFileObject)->FsContext2 == UC_SERVER_CONTEXT )

#define IS_EX_SERVER( pFileObject )                                         \
    ( (pFileObject)->FsContext2 == UC_SERVER_CONTEXT_X )

#define MARK_VALID_SERVER( pFileObject )                                    \
    ( (pFileObject)->FsContext2 = UC_SERVER_CONTEXT )

#define MARK_INVALID_SERVER( pFileObject )                                  \
    ( (pFileObject)->FsContext2 = UC_SERVER_CONTEXT_X )

#define IS_CONTROL_CHANNEL( pFileObject )                                   \
    ( (pFileObject)->FsContext2 == UL_CONTROL_CHANNEL_CONTEXT )

#define IS_EX_CONTROL_CHANNEL( pFileObject )                                \
    ( (pFileObject)->FsContext2 == UL_CONTROL_CHANNEL_CONTEXT_X )

#define MARK_VALID_CONTROL_CHANNEL( pFileObject )                           \
    ( (pFileObject)->FsContext2 = UL_CONTROL_CHANNEL_CONTEXT )

#define MARK_INVALID_CONTROL_CHANNEL( pFileObject )                         \
    ( (pFileObject)->FsContext2 = UL_CONTROL_CHANNEL_CONTEXT_X )

#define GET_CONTROL_CHANNEL( pFileObject )                                  \
    ((PUL_CONTROL_CHANNEL)((pFileObject)->FsContext))

#define GET_PP_CONTROL_CHANNEL( pFileObject )                               \
    ((PUL_CONTROL_CHANNEL *)&((pFileObject)->FsContext))

#define IS_FILTER_PROCESS( pFileObject )                                    \
    ( (pFileObject)->FsContext2 == UL_FILTER_CHANNEL_CONTEXT )

#define IS_EX_FILTER_PROCESS( pFileObject )                                 \
    ( (pFileObject)->FsContext2 == UL_FILTER_CHANNEL_CONTEXT_X )

#define MARK_VALID_FILTER_CHANNEL( pFileObject )                            \
    ( (pFileObject)->FsContext2 = UL_FILTER_CHANNEL_CONTEXT )

#define MARK_INVALID_FILTER_CHANNEL( pFileObject )                          \
    ( (pFileObject)->FsContext2 = UL_FILTER_CHANNEL_CONTEXT_X )

#define GET_FILTER_PROCESS( pFileObject )                                   \
    ((PUL_FILTER_PROCESS)((pFileObject)->FsContext))

#define GET_PP_FILTER_PROCESS( pFileObject )                                \
    ((PUL_FILTER_PROCESS *)&((pFileObject)->FsContext))

#define IS_APP_POOL( pFileObject )                                          \
    ( (pFileObject)->FsContext2 == UL_APP_POOL_CONTEXT )

#define IS_EX_APP_POOL( pFileObject )                                       \
    ( (pFileObject)->FsContext2 == UL_APP_POOL_CONTEXT_X )

#define MARK_VALID_APP_POOL( pFileObject )                                  \
    ( (pFileObject)->FsContext2 = UL_APP_POOL_CONTEXT )

#define MARK_INVALID_APP_POOL( pFileObject )                                \
    ( (pFileObject)->FsContext2 = UL_APP_POOL_CONTEXT_X )

#define GET_APP_POOL_PROCESS( pFileObject )                                 \
    ((PUL_APP_POOL_PROCESS)((pFileObject)->FsContext))

#define GET_PP_APP_POOL_PROCESS( pFileObject )                              \
    ((PUL_APP_POOL_PROCESS *)&((pFileObject)->FsContext))

#define IS_APP_POOL_FO( pFileObject )                                       \
    ((pFileObject->DeviceObject->DriverObject == g_UlDriverObject) &&       \
     (IS_APP_POOL(pFileObject)))

#define IS_FILTER_PROCESS_FO(pFileObject)                                   \
    ((pFileObject->DeviceObject->DriverObject == g_UlDriverObject) &&       \
     (IS_FILTER_PROCESS(pFileObject)))

//
// A locked doubly-linked list
//

typedef struct DECLSPEC_ALIGN(UL_CACHE_LINE) _LOCKED_LIST_HEAD
{
    UL_SPIN_LOCK    SpinLock;
    ULONG           Count;
    LIST_ENTRY      ListHead;

} LOCKED_LIST_HEAD, *PLOCKED_LIST_HEAD;

//
// Manipulators for LOCKED_LIST_HEADs
//

__inline
VOID
UlInitalizeLockedList(
    IN PLOCKED_LIST_HEAD pListHead,
    IN PSTR              pListName
    )
{
    UNREFERENCED_PARAMETER(pListName);
    InitializeListHead(&pListHead->ListHead);
    pListHead->Count = 0;
    UlInitializeSpinLock(&pListHead->SpinLock, pListName);

} // UlInitalizeLockedList

__inline
VOID
UlDestroyLockedList(
    IN PLOCKED_LIST_HEAD pListHead
    )
{
    UNREFERENCED_PARAMETER(pListHead);
    ASSERT(IsListEmpty(&pListHead->ListHead));
    ASSERT(pListHead->Count == 0);
    ASSERT(UlDbgSpinLockUnowned(&pListHead->SpinLock));

} // UlDestroyLockedList

__inline
BOOLEAN
UlLockedListInsertHead(
    IN PLOCKED_LIST_HEAD pListHead,
    IN PLIST_ENTRY       pListEntry,
    IN ULONG             ListLimit
    )
{
    KIRQL OldIrql;

    UlAcquireSpinLock(&pListHead->SpinLock, &OldIrql);

    ASSERT(NULL == pListEntry->Flink);

    if (HTTP_LIMIT_INFINITE != ListLimit && (pListHead->Count + 1) >= ListLimit)
    {
        UlReleaseSpinLock(&pListHead->SpinLock, OldIrql);
        return FALSE;
    }

    pListHead->Count += 1;
    InsertHeadList(
        &pListHead->ListHead,
        pListEntry
        );

    UlReleaseSpinLock(&pListHead->SpinLock, OldIrql);

    return TRUE;

} // UlLockedListInsertHead

__inline
BOOLEAN
UlLockedListInsertTail(
    IN PLOCKED_LIST_HEAD pListHead,
    IN PLIST_ENTRY       pListEntry,
    IN ULONG             ListLimit
    )
{
    KIRQL OldIrql;

    UlAcquireSpinLock(&pListHead->SpinLock, &OldIrql);

    ASSERT(NULL == pListEntry->Flink);

    if (HTTP_LIMIT_INFINITE != ListLimit && (pListHead->Count + 1) >= ListLimit)
    {
        UlReleaseSpinLock(&pListHead->SpinLock, OldIrql);
        return FALSE;
    }

    pListHead->Count += 1;
    InsertTailList(
        &pListHead->ListHead,
        pListEntry
        );

    UlReleaseSpinLock(&pListHead->SpinLock, OldIrql);

    return TRUE;
    
} // UlLockedListInsertTail

__inline
PLIST_ENTRY
UlLockedListRemoveHead(
    IN PLOCKED_LIST_HEAD pListHead
    )
{
    KIRQL OldIrql;
    PLIST_ENTRY pEntry = NULL;

    UlAcquireSpinLock(&pListHead->SpinLock, &OldIrql);

    if (!IsListEmpty(&pListHead->ListHead))
    {
        pEntry = RemoveHeadList(&pListHead->ListHead);
        ASSERT(NULL != pEntry);
        pEntry->Flink = NULL;

        pListHead->Count -= 1;
        ASSERT(HTTP_LIMIT_INFINITE != pListHead->Count);
    }

    UlReleaseSpinLock(&pListHead->SpinLock, OldIrql);

    return pEntry;

} // UlLockedListRemoveHead

__inline
BOOLEAN
UlLockedListRemoveEntry(
    IN PLOCKED_LIST_HEAD pListHead,
    IN PLIST_ENTRY       pListEntry
    )
{
    KIRQL OldIrql;

    UlAcquireSpinLock(&pListHead->SpinLock, &OldIrql);

    if (NULL == pListEntry->Flink)
    {
        UlReleaseSpinLock(&pListHead->SpinLock, OldIrql);
        return FALSE;
    }

    RemoveEntryList(pListEntry);
    pListEntry->Flink = NULL;

    pListHead->Count -= 1;
    ASSERT(HTTP_LIMIT_INFINITE != pListHead->Count);

    UlReleaseSpinLock(&pListHead->SpinLock, OldIrql);

    return TRUE;

} // UlLockedListRemoveEntry

//
// Miscellaneous validators, etc.
//

#define IS_VALID_DEVICE_OBJECT( pDeviceObject )                             \
    ( ((pDeviceObject) != NULL) &&                                          \
      ((pDeviceObject)->Type == IO_TYPE_DEVICE) &&                          \
      ((pDeviceObject)->Size == sizeof(DEVICE_OBJECT)) )

#define IS_VALID_FILE_OBJECT( pFileObject )                                 \
    ( ((pFileObject) != NULL) &&                                            \
      ((pFileObject)->Type == IO_TYPE_FILE) &&                              \
      ((pFileObject)->Size == sizeof(FILE_OBJECT)) )

#define IS_VALID_IRP( pIrp )                                                \
    ( ((pIrp) != NULL) &&                                                   \
      ((pIrp)->Type == IO_TYPE_IRP) &&                                      \
      ((pIrp)->Size >= IoSizeOfIrp((pIrp)->StackCount)) )

//
// IP Based routing token looks like L"https://1.1.1.1:80:1.1.1.1".
// Space is calculated including the terminated null and the second
// column. It is in bytes.
//

#define MAX_IP_BASED_ROUTING_TOKEN_LENGTH                                   \
    (HTTPS_IP_PREFIX_LENGTH                                                 \
     + MAX_IP_ADDR_AND_PORT_STRING_LEN * sizeof(WCHAR)                      \
     + sizeof(WCHAR) + MAX_IP_ADDR_PLUS_BRACKETS_STRING_LEN * sizeof(WCHAR) \
     + sizeof(WCHAR))

//
// Make sure that the maximum possible IP Based Routing token can fit to the 
// default provided routing token space in the request structure. This is 
// necessary to avoid the memory allocation per hit, when there is an IP bound 
// site in the cgroup tree.
//

C_ASSERT(DEFAULT_MAX_ROUTING_TOKEN_LENGTH >= MAX_IP_BASED_ROUTING_TOKEN_LENGTH);
NTSTATUS
TimeFieldsToHttpDate(
    IN  PTIME_FIELDS pTime,
    OUT PWSTR pBuffer,
    IN  ULONG BufferLength
    );

BOOLEAN
StringTimeToSystemTime(
    IN  PCSTR pTimeString,
    IN  USHORT TimeStringLength,
    OUT LARGE_INTEGER *pTime
    );

ULONG
HttpUnicodeToUTF8(
    IN  PCWSTR  lpSrcStr,
    IN  LONG    cchSrc,
    OUT LPSTR   lpDestStr,
    IN  LONG    cchDest
    );

NTSTATUS
HttpUTF8ToUnicode(
    IN     LPCSTR lpSrcStr,
    IN     LONG   cchSrc,
       OUT LPWSTR lpDestStr,
    IN OUT PLONG  pcchDest,
    IN     ULONG  dwFlags
    );

typedef enum _FIND_ETAG_STATUS
{
    ETAG_FOUND,
    ETAG_NOT_FOUND,        
    ETAG_PARSE_ERROR,
} FIND_ETAG_STATUS;

FIND_ETAG_STATUS
FindInETagList(
    IN PUCHAR    pLocalETag,
    IN PUCHAR    pETagList,
    IN BOOLEAN   fWeakCompare
    );

USHORT
HostAddressAndPortToString(
    OUT PUCHAR IpAddressString,
    IN  PVOID  TdiAddress,
    IN  USHORT TdiAddressType
    );

USHORT
HostAddressAndPortToStringW(
    PWCHAR  IpAddressString,
    PVOID   TdiAddress,
    USHORT  TdiAddressType
    );

USHORT
HostAddressToStringW(
    OUT PWCHAR   IpAddressStringW,
    IN  PVOID    TdiAddress,
    IN  USHORT   TdiAddressType
    );

USHORT
HostAddressAndPortToRoutingTokenW(
    OUT PWCHAR   IpAddressStringW,
    IN  PVOID    TdiAddress,
    IN  USHORT   TdiAddressType
    );

/***************************************************************************++

Routine Description:

    Stores the decimal representation of an unsigned 32-bit
    number in a character buffer, followed by a terminator
    character. Returns a pointer to the next position in the
    output buffer, to make appending strings easy; i.e., you
    can use the result of UlStrPrintUlong as the argument to the
    next call to UlStrPrintUlong. Note: the string is >not<
    zero-terminated unless you passed in '\0' as chTerminator

Arguments:

    psz - output buffer; assumed to be large enough to hold the number.

    n - the number to print into psz, a 32-bit unsigned integer

    chTerminator - character to append after the decimal representation of n

Return Value:

    pointer to end of string

History:

     GeorgeRe       19-Sep-2000

--***************************************************************************/
__inline
PCHAR
UlStrPrintUlong(
    OUT PCHAR psz,
    IN  ULONG n,
    IN  CHAR  chTerminator)
{
    CHAR digits[MAX_ULONG_STR];
    int i = 0;

    ASSERT(psz != NULL);

    digits[i++] = chTerminator;

    // Build the string in reverse
    do
    {
        digits[i++] = (CHAR) (n % 10) + '0';
        n /= 10;
    } while (n != 0);

    while (--i >= 0)
        *psz++ = digits[i];

    // Back up to the nul terminator, if present
    if (chTerminator == '\0')
    {
        --psz;
        ASSERT(*psz == '\0');
    }

    return psz;
} // UlStrPrintUlong

/***************************************************************************++

Routine Description:

    Identical to the above function except it writes to a WCHAR buffer and
    it pads zeros to the beginning of the number.

--***************************************************************************/
__inline
PWCHAR
UlStrPrintUlongW(
    OUT PWCHAR pwsz,
    IN  ULONG  n,
    IN  LONG   padding,
    IN  WCHAR  wchTerminator)
{
    WCHAR digits[MAX_ULONG_STR];
    int i = 0;

    ASSERT(pwsz != NULL);

    digits[i++] = wchTerminator;

    // Build the string in reverse
    do
    {
        digits[i++] = (WCHAR) (n % 10) + L'0';
        n /= 10;
    } while (n != 0);

    // Padd Zeros to the beginning
    while( padding && --padding >= (i-1))
        *pwsz++ = L'0';

    // Reverse back
    while (--i >= 0)
        *pwsz++ = digits[i];

    // Back up to the nul terminator, if present
    if (wchTerminator == L'\0')
    {
        --pwsz;
        ASSERT(*pwsz == L'\0');
    }

    return pwsz;
} // UlStrPrintUlongW

__inline
PCHAR
UlStrPrintUlongPad(
    OUT PCHAR  psz,
    IN  ULONG  n,
    IN  LONG   padding,
    IN  CHAR   chTerminator)
{
    CHAR digits[MAX_ULONG_STR];
    int  i = 0;

    ASSERT(psz != NULL);

    digits[i++] = chTerminator;

    // Build the string in reverse
    do
    {
        digits[i++] = (CHAR) (n % 10) + '0';
        n /= 10;
    } while (n != 0);

    // Padd Zeros to the beginning
    while( padding && --padding >= (i-1))
        *psz++ = '0';

    // Reverse back
    while (--i >= 0)
        *psz++ = digits[i];

    // Back up to the nul terminator, if present
    if (chTerminator == '\0')
    {
        --psz;
        ASSERT(*psz == '\0');
    }

    return psz;
} // UlStrPrintUlongPad

/***************************************************************************++

Routine Description:

    Stores the decimal representation of an unsigned 64-bit
    number in a character buffer, followed by a terminator
    character. Returns a pointer to the next position in the
    output buffer, to make appending strings easy; i.e., you
    can use the result of UlStrPrintUlonglong as the argument to the
    next call to UlStrPrintUlonglong. Note: the string is >not<
    zero-terminated unless you passed in '\0' as chTerminator

Arguments:

    psz - output buffer; assumed to be large enough to hold the number.

    n - the number to print into psz, a 64-bit unsigned integer

    chTerminator - character to append after the decimal representation of n

Return Value:

    pointer to end of string

History:

     GeorgeRe       19-Sep-2000

--***************************************************************************/
__inline
PCHAR
UlStrPrintUlonglong(
    OUT PCHAR       psz,
    IN  ULONGLONG   n,
    IN  CHAR        chTerminator)
{
    CHAR digits[MAX_ULONGLONG_STR];
    int i;

    if (n <= ULONG_MAX)
    {
        // If this is a 32-bit integer, it's faster to use the
        // 32-bit routine.
        return UlStrPrintUlong(psz, (ULONG)n, chTerminator);
    }

    ASSERT(psz != NULL);

    i = 0;
    digits[i++] = chTerminator;

    // Build the string in reverse
    do
    {
        digits[i++] = (CHAR) (n % 10) + '0';
        n /= 10;
    } while (n != 0);

    while (--i >= 0)
        *psz++ = digits[i];

    // Back up to the nul terminator, if present
    if (chTerminator == '\0')
    {
        --psz;
        ASSERT(*psz == '\0');
    }

    return psz;
} // UlStrPrintUlonglong

/***************************************************************************++

Routine Description:

    Stores a string in a character buffer, followed by a
    terminator character. Returns a pointer to the next position
    in the output buffer, to make appending strings easy; i.e.,
    you can use the result of UlStrPrintStr as the argument to the
    next call to UlStrPrintStr. Note: the string is >not<
    zero-terminated unless you passed in '\0' as chTerminator

Arguments:

    pszOutput - output buffer; assumed to be large enough to hold the number.

    pszInput - input string

    chTerminator - character to append after the input string

Return Value:

    pointer to end of string

History:

     GeorgeRe       19-Sep-2000

--***************************************************************************/
__inline
PCHAR
UlStrPrintStr(
    OUT PCHAR       pszOutput,
    IN  const CHAR* pszInput,
    IN  CHAR        chTerminator)
{
    ASSERT(pszOutput != NULL);
    ASSERT(pszInput != NULL);

    // copy the input string
    while (*pszInput != '\0')
        *pszOutput++ = *pszInput++;

    *pszOutput = chTerminator;

    // Move past the terminator character unless it's a nul
    if (chTerminator != '\0')
        ++pszOutput;

    return pszOutput;
} // UlStrPrintStr

/***************************************************************************++

Routine Description:

    Converts an V4 Ip address to string in the provided buffer.

Arguments:

    psz             - Pointer to the buffer
    RawAddress      - IP address structure from TDI / UL_CONNECTION
    chTerminator    - The terminator char will be appended to the end

Return:

    The number of bytes copied to destination buffer.
    
--***************************************************************************/

__inline
PCHAR
UlStrPrintIP(
    OUT PCHAR       psz,
    IN  const VOID* pTdiAddress,
    IN  USHORT      TdiAddressType,
    IN  CHAR        chTerminator
    )
{
    if (TdiAddressType == TDI_ADDRESS_TYPE_IP)
    {
        PTDI_ADDRESS_IP pIPv4Address = ((PTDI_ADDRESS_IP) pTdiAddress);
        struct in_addr IPv4Addr
            = * (struct in_addr UNALIGNED*) &pIPv4Address->in_addr;
    
        psz = RtlIpv4AddressToStringA(&IPv4Addr, psz);
    }
    else if (TdiAddressType == TDI_ADDRESS_TYPE_IP6)
    {
        PTDI_ADDRESS_IP6 pIPv6Address = ((PTDI_ADDRESS_IP6) pTdiAddress);
        struct in6_addr IPv6Addr
            = * (struct in6_addr UNALIGNED*) &pIPv6Address->sin6_addr[0];

        psz = RtlIpv6AddressToStringA(&IPv6Addr, psz);

        // Write Scope ID
        *psz++ = '%';
        psz = UlStrPrintUlong(psz, pIPv6Address->sin6_scope_id, '\0');
    }
    else
    {
        ASSERT(! "Unexpected TdiAddressType");
        *psz++ = '?';
    }

    *psz = chTerminator;

    // Move past the terminator character unless it's a nul
    if (chTerminator != '\0')
        ++psz;

    return psz;
} // UlStrPrintIP

/***************************************************************************++

Routine Description:

    Converts an V4 or V6 Ip address to string in the provided buffer.
    Provided seperator is inserted between Ip and Port and also 
    appended after the port. 

    String is * NOT * going to be null terminated.
    
Arguments:

    psz             - Pointer to the buffer
    RawAddress      - IP address structure from TDI / UL_CONNECTION
    chSeperator     - the seperator character
    
Return:

    The char pointer pointing after the last written seperator.
    
--***************************************************************************/

__inline
PCHAR
UlStrPrintIPAndPort(
    OUT PCHAR       psz,
    IN  const VOID* pTdiAddress,
    IN  USHORT      TdiAddressType,
    IN  CHAR        chSeperator
    )
{
    if (TdiAddressType == TDI_ADDRESS_TYPE_IP)
    {
        PTDI_ADDRESS_IP pIPv4Address = ((PTDI_ADDRESS_IP) pTdiAddress);
        struct in_addr IPv4Addr
            = * (struct in_addr UNALIGNED*) &pIPv4Address->in_addr;
        USHORT IpPortNum = SWAP_SHORT(pIPv4Address->sin_port);
    
        psz = RtlIpv4AddressToStringA(&IPv4Addr, psz);
        *psz++ = chSeperator;
        psz = UlStrPrintUlong(psz, IpPortNum, '\0');        
    }
    else if (TdiAddressType == TDI_ADDRESS_TYPE_IP6)
    {
        PTDI_ADDRESS_IP6 pIPv6Address = ((PTDI_ADDRESS_IP6) pTdiAddress);
        struct in6_addr IPv6Addr
            = * (struct in6_addr UNALIGNED*) &pIPv6Address->sin6_addr[0];
        USHORT IpPortNum = SWAP_SHORT(pIPv6Address->sin6_port);        

        psz = RtlIpv6AddressToStringA(&IPv6Addr, psz);

        // Write Scope ID
        *psz++ = '%';
        psz = UlStrPrintUlong(psz, pIPv6Address->sin6_scope_id, '\0');

        *psz++ = chSeperator;
        psz = UlStrPrintUlong(psz, IpPortNum, '\0');        
    }
    else
    {
        ASSERT(! "Unexpected TdiAddressType");
        *psz++ = '?';
    }

    *psz++ = chSeperator;

    return psz;
    
} // UlStrPrintIPAndPort

__inline
VOID
CopyTdiAddrToSockAddr(
    IN  USHORT              TdiAddressType,
    IN  const VOID*         pTdiAddress,
    OUT struct sockaddr*    pSockAddress
    )
{
    if (TdiAddressType == TDI_ADDRESS_TYPE_IP)
    {
        const PTDI_ADDRESS_IP pIPv4Address
            = (const PTDI_ADDRESS_IP) pTdiAddress;
        struct sockaddr_in *pSockAddrIPv4
            = (struct sockaddr_in*) pSockAddress;

        pSockAddrIPv4->sin_family = TdiAddressType;
        pSockAddrIPv4->sin_port   = pIPv4Address->sin_port;
        pSockAddrIPv4->sin_addr.s_addr
            = (UNALIGNED ULONG) pIPv4Address->in_addr;
        RtlCopyMemory(
            &pSockAddrIPv4->sin_zero[0],
            &pIPv4Address->sin_zero[0],
            8 * sizeof(UCHAR)
            );
    }
    else if (TdiAddressType == TDI_ADDRESS_TYPE_IP6)
    {
        const PTDI_ADDRESS_IP6 pIPv6Address
            = (const PTDI_ADDRESS_IP6) pTdiAddress;
        struct sockaddr_in6 *pSockAddrIPv6
            = (struct sockaddr_in6*) pSockAddress;

        pSockAddrIPv6->sin6_family = TdiAddressType;
        pSockAddrIPv6->sin6_port  = pIPv6Address->sin6_port;
        pSockAddrIPv6->sin6_flowinfo
            = (UNALIGNED ULONG) pIPv6Address->sin6_flowinfo;
        RtlCopyMemory(
            &pSockAddrIPv6->sin6_addr,
            &pIPv6Address->sin6_addr[0],
            8 * sizeof(USHORT)
            );
        pSockAddrIPv6->sin6_scope_id
            = (UNALIGNED ULONG) pIPv6Address->sin6_scope_id;
    }
    else
    {
        ASSERT(! "Unexpected TdiAddressType");
    }
} // CopyTdiAddrToSockAddr


__inline
PCHAR
UlStrPrintProtocolStatus(
    OUT PCHAR  psz,
    IN  USHORT HttpStatusCode,
    IN  CHAR   chTerminator
    )
{
    ASSERT(HttpStatusCode <= UL_MAX_HTTP_STATUS_CODE);
        
    //
    // Build ASCII representation of 3-digit status code
    // in reverse order: units, tens, hundreds
    //

    psz[2] = '0' + (CHAR)(HttpStatusCode % 10);
    HttpStatusCode /= 10;

    psz[1] = '0' + (CHAR)(HttpStatusCode % 10);
    HttpStatusCode /= 10;

    psz[0] = '0' + (CHAR)(HttpStatusCode % 10);

    psz[3] = chTerminator;

    return psz + 4;
} // UlStrPrintProtocolStatus



__inline
VOID
UlProbeForRead(
    IN const VOID*      Address,
    IN SIZE_T           Length,
    IN ULONG            Alignment,
    IN KPROCESSOR_MODE  RequestorMode
    )
{
    ASSERT((Alignment == 1) || (Alignment == 2) ||
           (Alignment == 4) || (Alignment == 8) ||
           (Alignment == 16));

    UlTraceVerbose(IOCTL,
            ("http!UlProbeForRead: "
             "%Id bytes @ %p, Align = %lu, Mode = '%c'.\n",
             Length, Address, Alignment,
             (RequestorMode != KernelMode) ? 'U' : 'K'
            ));

    if (RequestorMode != KernelMode)
    {
        // ASSERT(Length == 0  ||  (LONG_PTR) Address > 0);

        // ProbeForRead will throw an exception if we probe kernel-mode data
        ProbeForRead(Address, Length, Alignment);
    }
    else if (Length != 0)
    {
        // Check alignment
        if ( ( ((ULONG_PTR) Address) & (Alignment - 1)) != 0 )
            ExRaiseDatatypeMisalignment();
    }   
} // UlProbeForRead



__inline
VOID
UlProbeForWrite(
    IN PVOID            Address,
    IN SIZE_T           Length,
    IN ULONG            Alignment,
    IN KPROCESSOR_MODE  RequestorMode
    )
{
    ASSERT((Alignment == 1) || (Alignment == 2) ||
           (Alignment == 4) || (Alignment == 8) ||
           (Alignment == 16));

    UlTraceVerbose(IOCTL,
            ("http!UlProbeForWrite: "
             "%Id bytes @ %p, Align = %lu, Mode = '%c'.\n",
             Length, Address, Alignment,
             (RequestorMode != KernelMode) ? 'U' : 'K'
            ));

    if (RequestorMode != KernelMode)
    {
        // ASSERT(Length == 0  ||  (LONG_PTR) Address > 0);

        // ProbeForWrite will throw an exception if we probe kernel-mode data
        ProbeForWrite(Address, Length, Alignment);
    }
    else if (Length != 0)
    {
        // Check alignment
        if ( ( ((ULONG_PTR) Address) & (Alignment - 1)) != 0 )
            ExRaiseDatatypeMisalignment();
    }   
} // UlProbeForWrite



/***************************************************************************++

Routine Description:

    Probes an ANSI string and validates its length and accessibility.
    This MUST be called from within an exception handler, as it
    will throw exceptions if the data is invalid.

Arguments:

    pStr            - Pointer to the ANSI string to be validated.
    ByteLength      - Length in bytes of pStr, excluding the trailing '\0'.
    RequestorMode   - UserMode or KernelMode
    
--***************************************************************************/

__inline
VOID
UlProbeAnsiString(
    IN PCSTR            pStr,
    IN USHORT           ByteLength,
    IN KPROCESSOR_MODE  RequestorMode
    )
{
    UlTraceVerbose(IOCTL,
            ("http!UlProbeAnsiString: "
             "%hu bytes @ %p, "
             "Mode='%c'.\n",
             ByteLength, pStr,
             ((RequestorMode != KernelMode) ? 'U' : 'K')
            ));

    // String cannot be empty or NULL.
    if (0 == ByteLength  ||  NULL == pStr)
    {
        ExRaiseStatus(STATUS_INVALID_PARAMETER);
    }
        
    UlProbeForRead(
        pStr,
        (SIZE_T) ByteLength,
        sizeof(CHAR),
        RequestorMode
        );

} // UlProbeAnsiString



/***************************************************************************++

Routine Description:

    Probes a WCHAR string and validates its length and accessibility.
    This MUST be called from within an exception handler, as it
    will throw exceptions if the data is invalid.

Arguments:

    pStr            - Pointer to the WCHAR string to be validated.
    ByteLength      - Length in bytes of pStr, excluding the trailing L'\0'.
    RequestorMode   - UserMode or KernelMode
    
--***************************************************************************/

__inline
VOID
UlProbeWideString(
    IN PCWSTR           pStr,
    IN USHORT           ByteLength,
    IN KPROCESSOR_MODE  RequestorMode
    )
{
    UlTraceVerbose(IOCTL,
            ("http!UlProbeWideString: "
             "%hu bytes (%hu) WCHARs @ %p,"
             "Mode = '%c'.\n",
             ByteLength, 
             ByteLength / sizeof(WCHAR),
             pStr,
             ((RequestorMode != KernelMode) ? 'U' : 'K')
            ));

    // String cannot be empty or NULL.
    // ByteLength must be even.
    // Data must be WCHAR-aligned.
    if (0 == ByteLength  ||  NULL == pStr
        || (ByteLength & (sizeof(WCHAR) - 1)) != 0
        || (((ULONG_PTR) pStr) & (sizeof(WCHAR) - 1)) != 0)
    {
        ExRaiseStatus(STATUS_INVALID_PARAMETER);
    }
        
    UlProbeForRead(
        pStr,
        (SIZE_T) ByteLength,
        sizeof(WCHAR),
        RequestorMode
        );

} // UlProbeWideString



/***************************************************************************++

Routine Description:

    Probes a UNICODE_STRING and validates its members. And captures down 
    to a kernel buffer.

    If this function returns success, caller should clean up the allocated
    Unicode buffer by calling UlFreeCapturedUnicodeString(), once it's done 
    with it.
    
Arguments:

    pSrc            - Pointer to the UNICODE_STRING to be validated.
                      The UNICODE_STRING struct should live in kernel mode
                      (local stack copy), but the Buffer should be in user
                      mode address space, unless RequestorMode == KernelMode.

    pDst            - Pointer to the UNICODE_STRING to hold the captured user 
                      buffer. Caller must have initialized this before passing
                      in.
                      
    AllocationLimit - User string will be refused if it is exceeding this limit.
                      Expressed in WCHARs. If zero, no size check is done.
    
    RequestorMode   - UserMode or KernelMode.
    
--***************************************************************************/

__inline
NTSTATUS
UlProbeAndCaptureUnicodeString(
    IN  PCUNICODE_STRING pSrc,
    IN  KPROCESSOR_MODE  RequestorMode,
    OUT PUNICODE_STRING  pDst,
    IN  const USHORT     AllocationLimit      // In WCHARS, optional   
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PWSTR pKernelBuffer = NULL;

    ASSERT(NULL != pSrc);
    ASSERT(NULL != pDst);
    ASSERT(pSrc != pDst);
    ASSERT(AllocationLimit <= UNICODE_STRING_MAX_WCHAR_LEN);

    // Ensure that pDst is properly initialized
    RtlInitEmptyUnicodeString(pDst, NULL, 0);
        
    UlTraceVerbose(IOCTL,
        ("http!UlProbeAndCaptureUnicodeString: struct @ %p, "
         "Length = %hu bytes (%hu) WCHARs, "
         "MaxLen = %hu bytes,"
         "Mode = '%c'.\n",
         pSrc,
         pSrc->Length,
         pSrc->Length / sizeof(WCHAR),
         pSrc->MaximumLength,
         (RequestorMode != KernelMode) ? 'U' : 'K'
        ));

    // Do not allocate/copy more than the limit being enforced.
    // if limit is non-zero, otherwise it is not being enforced

    if (0 != AllocationLimit && 
        (AllocationLimit * sizeof(WCHAR)) < pSrc->Length)
    {
        return STATUS_INVALID_PARAMETER;
    }

    if ((pSrc->MaximumLength < pSrc->Length) || (pSrc->Length == 0))
    {
        return STATUS_INVALID_PARAMETER;
    }

    __try
    {
        // Probe the user's buffer first.

        UlProbeWideString(
            pSrc->Buffer,
            pSrc->Length,
            RequestorMode
            );

        // Allocate a kernel buffer and capture the user's buffer.
        // The ULONG cast prevents USHORT arithmetic overflow.

        pKernelBuffer = (PWSTR) UL_ALLOCATE_ARRAY(
                                    PagedPool,
                                    WCHAR,
                                    ((ULONG) pSrc->Length + sizeof(WCHAR))
                                        / sizeof(WCHAR),
                                    UL_UNICODE_STRING_POOL_TAG
                                    );
        if (pKernelBuffer == NULL)
        {
            Status = STATUS_NO_MEMORY;
            __leave;        
        }    

        // Copy and null-terminate the unicode string.
        
        RtlCopyMemory(pKernelBuffer, pSrc->Buffer, pSrc->Length);        
        pKernelBuffer[pSrc->Length/sizeof(WCHAR)] = UNICODE_NULL;

        pDst->Buffer = pKernelBuffer;
        pDst->Length = pSrc->Length;
        pDst->MaximumLength = pDst->Length + sizeof(WCHAR);
    }    
    __except( UL_EXCEPTION_FILTER() )
    {
        Status = UL_CONVERT_EXCEPTION_CODE(GetExceptionCode());
    }    

    if (!NT_SUCCESS(Status))
    {
        if (pKernelBuffer != NULL)
        {
            UL_FREE_POOL(pKernelBuffer, UL_UNICODE_STRING_POOL_TAG );        
        }           
    }

    return Status;
    
} // UlProbeAndCaptureUnicodeString



// Cleans up a UNICODE_STRING initialized by UlProbeAndCaptureUnicodeString()
__inline
VOID
UlFreeCapturedUnicodeString(
    IN  PUNICODE_STRING  pCapturedUnicodeString
    )
{
    ASSERT(pCapturedUnicodeString);

    if (pCapturedUnicodeString->Buffer != NULL)
    {
        UL_FREE_POOL(
            pCapturedUnicodeString->Buffer, 
            UL_UNICODE_STRING_POOL_TAG 
            );        
    }

    RtlInitEmptyUnicodeString(pCapturedUnicodeString, NULL, 0);
}

//
// Small macro to test the sanity of an unicode string
// also tests whether it is null terminated or not.
//

#define IS_WELL_FORMED_UNICODE_STRING(pUStr)                   \
            ((pUStr)                                    &&     \
             (pUStr)->Buffer                            &&     \
             (pUStr)->Length                            &&     \
             (!((pUStr)->Length & 1))                   &&     \
             (pUStr)->Length < (pUStr)->MaximumLength   &&     \
             (!((pUStr)->MaximumLength & 1))            &&     \
             (pUStr)->Buffer[                                  \
                (pUStr)->Length/sizeof(WCHAR)]                 \
                    == UNICODE_NULL                            \
            )

//
// 64-bit interlocked routines
//

#ifdef _WIN64

#define UlInterlockedIncrement64    InterlockedIncrement64
#define UlInterlockedDecrement64    InterlockedDecrement64
#define UlInterlockedAdd64          InterlockedAdd64
#define UlInterlockedExchange64     InterlockedExchange64

#else // !_WIN64

__inline
LONGLONG
UlInterlockedIncrement64 (
    IN OUT PLONGLONG Addend
    )
{
    LONGLONG localAddend;
    LONGLONG addendPlusOne;
    LONGLONG originalAddend;

    do {
        localAddend = *((volatile LONGLONG *) Addend);
        addendPlusOne = localAddend + 1;

        originalAddend = InterlockedCompareExchange64( Addend,
                                                       addendPlusOne,
                                                       localAddend );
        PAUSE_PROCESSOR;
    } while (originalAddend != localAddend);

    return addendPlusOne;
} // UlInterlockedIncrement64 

__inline
LONGLONG
UlInterlockedDecrement64 (
    IN OUT PLONGLONG Addend
    )
{
    LONGLONG localAddend;
    LONGLONG addendMinusOne;
    LONGLONG originalAddend;

    do {
        localAddend = *((volatile LONGLONG *) Addend);
        addendMinusOne = localAddend - 1;

        originalAddend = InterlockedCompareExchange64( Addend,
                                                       addendMinusOne,
                                                       localAddend );
        PAUSE_PROCESSOR;
    } while (originalAddend != localAddend);

    return addendMinusOne;
} // UlInterlockedDecrement64 

__inline
LONGLONG
UlInterlockedAdd64 (
    IN OUT PLONGLONG Addend,
    IN     LONGLONG  Value
    )
{
    LONGLONG localAddend;
    LONGLONG addendPlusValue;
    LONGLONG originalAddend;

    do {
        localAddend = *((volatile LONGLONG *) Addend);
        addendPlusValue = localAddend + Value;

        originalAddend = InterlockedCompareExchange64( Addend,
                                                       addendPlusValue,
                                                       localAddend );
        PAUSE_PROCESSOR;
    } while (originalAddend != localAddend);

    return originalAddend;
} // UlInterlockedAdd64 

__inline
LONGLONG
UlInterlockedExchange64 (
    IN OUT PLONGLONG Addend,
    IN     LONGLONG  newValue
    )
{
    LONGLONG localAddend;
    LONGLONG originalAddend;

    do {

        localAddend = *((volatile LONGLONG *) Addend);

        originalAddend = InterlockedCompareExchange64( Addend,
                                                       newValue,
                                                       localAddend );
        PAUSE_PROCESSOR;

    } while (originalAddend != localAddend);

    return originalAddend;
} // UlInterlockedExchange64 

#endif // !_WIN64

//
// Barrier support for read-mostly operations
// Note that the AMD64 and IA32 barrier relies on program ordering
// and does not generate a hardware barrier
//

#if defined(_M_IA64)
    #define UL_READMOSTLY_READ_BARRIER()   __mf()
    #define UL_READMOSTLY_WRITE_BARRIER()  __mf()
    #define UL_READMOSTLY_MEMORY_BARRIER() __mf()
#elif defined(_AMD64_) || defined(_X86_)
    extern VOID _ReadWriteBarrier();
    extern VOID _WriteBarrier();
    #pragma intrinsic(_ReadWriteBarrier)
    #pragma intrinsic(_WriteBarrier)
    #define UL_READMOSTLY_READ_BARRIER()   _ReadWriteBarrier()
    #define UL_READMOSTLY_WRITE_BARRIER()  _WriteBarrier()
    #define UL_READMOSTLY_MEMORY_BARRIER() _ReadWriteBarrier()
#else
    #error Cannot generate memory barriers for this architecture
#endif

__inline
PVOID
UlpFixup(
    IN PUCHAR pUserPtr,
    IN PUCHAR pKernelPtr,
    IN PUCHAR pOffsetPtr,
    IN ULONG  BufferLength
    )
{
    ASSERT( pOffsetPtr >= pKernelPtr );
    ASSERT( DIFF(pOffsetPtr - pKernelPtr) <= BufferLength );
    UNREFERENCED_PARAMETER(BufferLength);

    return pUserPtr + DIFF(pOffsetPtr - pKernelPtr);

}   // UlpFixup

#define FIXUP_PTR( Type, pUserPtr, pKernelPtr, pOffsetPtr, BufferLength )   \
    (Type)UlpFixup(                                                         \
                (PUCHAR)(pUserPtr),                                         \
                (PUCHAR)(pKernelPtr),                                       \
                (PUCHAR)(pOffsetPtr),                                       \
                (BufferLength)                                              \
                )

//
// Time utility to calculate the TimeZone Bias Daylight/standart 
// and returns one of the following values. 
// It's taken from base\client\timedate.c.
// Once this two functions are exposed in the kernel we can get rid of
// this two functions.
//

#define UL_TIME_ZONE_ID_INVALID    0xFFFFFFFF
#define UL_TIME_ZONE_ID_UNKNOWN    0
#define UL_TIME_ZONE_ID_STANDARD   1
#define UL_TIME_ZONE_ID_DAYLIGHT   2

BOOLEAN
UlpCutoverTimeToSystemTime(
    PTIME_FIELDS    CutoverTime,
    PLARGE_INTEGER  SystemTime,
    PLARGE_INTEGER  CurrentSystemTime
    );

ULONG 
UlCalcTimeZoneIdAndBias(
     IN  RTL_TIME_ZONE_INFORMATION *ptzi,
     OUT PLONG pBias
     );

BOOLEAN
UlIsLowNPPCondition( VOID );

//
// Converts from NtStatus to Win32Status
//

#define HttpNtStatusToWin32Status( Status )     \
    ( ( (Status) == STATUS_SUCCESS )            \
          ? NO_ERROR                            \
          : RtlNtStatusToDosErrorNoTeb( Status ) )

ULONG
HttpUnicodeToUTF8Count(
    IN LPCWSTR pwszIn,
    IN ULONG dwInLen,
    IN BOOLEAN bEncode
    );

NTSTATUS
HttpUnicodeToUTF8Encode(
    IN  LPCWSTR pwszIn,
    IN  ULONG   dwInLen,
    OUT PUCHAR  pszOut,
    IN  ULONG   dwOutLen,
    OUT ULONG   *pdwOutLen,
    IN  BOOLEAN bEncode
    );

PSTR
UlUlongToHexString(
    ULONG  n,
    PSTR   pBuffer
    );

PCHAR
UxStriStr(
    const char *str1, 
    const char *str2,
    ULONG length
    );

PCHAR
UxStrStr(
    const char *str1, 
    const char *str2,
    ULONG length
    );


/**************************************************************************++

Routine Description:

    This routine tries to convert a SECURITY_STATUS to an NTSTATUS.  It calls
    MapSecurityError to perform the conversion.  If the conversion fails,
    it returns STATUS_UNSUCCESSFUL.

    This routine always returns a valid NTSTATUS.

Arguments:

    SecStatus - SECURITY_STATUS to be converted into NTSTATUS.

Return Value:

    NTSTATUS.

--**************************************************************************/
__forceinline
NTSTATUS
SecStatusToNtStatus(
    SECURITY_STATUS SecStatus
    )
{
    NTSTATUS Status;

    //
    // Try to convert SECURITY_STATUS to NTSTATUS.  If a corresponding
    // NTSTATUS is not found, then return STATUS_UNSUCCESSFUL.
    //

    Status = MapSecurityError(SecStatus);

    //
    // The following is temporarily disabled because, the tests will fail.
    // Enable this when MapSecurityError is fixed. 
    //

#if 0
    if (!NT_SUCCESS(Status) && Status == (NTSTATUS)SecStatus)
    {
        Status = STATUS_UNSUCCESSFUL;
    }
#endif

    return Status;
}


/**************************************************************************++

Routine Description:

    This routine returns the number of bytes required to encode n byte 
    binary data in base64.

Arguments:

    BinaryLength  - Length of binary data (in bytes)
    pBase64Length - Pointer to length of Base64 data (in bytes)

Return Value:

    NTSTATUS.

--**************************************************************************/
__forceinline
NTSTATUS
BinaryToBase64Length(
    IN  ULONG  BinaryLength,
    OUT PULONG pBase64Length
    )
{
    NTSTATUS Status;

    //
    // Every 6 bits in binary will be encoded by 8 bits in base64.
    // Hence the output is roughly 33.33% larger than input.
    // First round up (BinaryLength / 3).  Now. each 3 bytes
    // in binary data will yield 4 bytes of base64 encoded data.
    //
    // N.B. The order of arithmetic operation is important.
    //      Actual formula of conversion is:
    //          Base64Length = ceil(BinaryLength/3) * 4.
    //

    *pBase64Length = ((BinaryLength + 2) / 3) * 4;

    Status = STATUS_SUCCESS;

    // Was there an arithmetic overflow in the above computation?
    if (*pBase64Length < BinaryLength)
    {
        Status = STATUS_INTEGER_OVERFLOW;
    }

    return Status;
}


/**************************************************************************++

Routine Description:

    This routine returns the number of bytes required to decode base64
    encoded data of length n back to binary format.

Arguments:

    Base64Length  - Length of base64 data (in bytes).
    pBinaryLength - Length of binary data (in bytes).

Return Value:

    NTSTATUS.

--**************************************************************************/
__forceinline
NTSTATUS
Base64ToBinaryLength(
    IN  ULONG  Base64Length,
    OUT PULONG pBinaryLength
    )
{
    NTSTATUS Status;

    *pBinaryLength = (Base64Length / 4) * 3;

    Status = STATUS_SUCCESS;

    // Base64Length must be a multiple of 4.
    if (Base64Length % 4 != 0)
    {
        Status = STATUS_INVALID_PARAMETER;
    }

    return Status;
}

/**************************************************************************++

    Safer version of UlInitUnicodeString, using the private function until
    the Rtl one is exposed.
    
--**************************************************************************/

__inline
NTSTATUS
UlInitUnicodeStringEx(
    OUT PUNICODE_STRING DestinationString,
    IN PCWSTR SourceString OPTIONAL
    )
{
    if (SourceString != NULL) 
    {
        SIZE_T Length = wcslen(SourceString);

        //
        // We are actually limited to 32765 characters since we want 
        // to store a meaningful MaximumLength also.
        //
        
        if (Length > (UNICODE_STRING_MAX_CHARS - 1)) 
        {
            return STATUS_NAME_TOO_LONG;
        }

        Length *= sizeof(WCHAR);

        DestinationString->Length = (USHORT) Length;
        DestinationString->MaximumLength = (USHORT) (Length + sizeof(WCHAR));
        DestinationString->Buffer = (PWSTR) SourceString;
    } 
    else 
    {
        DestinationString->Length = 0;
        DestinationString->MaximumLength = 0;
        DestinationString->Buffer = NULL;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
BinaryToBase64(
    IN  PUCHAR pBinaryData,
    IN  ULONG  BinaryDataLen,
    IN  PUCHAR pBase64Data,
    IN  ULONG  Base64DataLen,
    OUT PULONG BytesWritten
    );

NTSTATUS
Base64ToBinary(
    IN  PUCHAR pBase64Data,
    IN  ULONG  Base64DataLen,
    IN  PUCHAR pBinaryData,
    IN  ULONG  BinaryDataLen,
    OUT PULONG BytesWritten
    );

//
// A simple exclusive spinlock at passive level that doesn't raise IRQLs.
//

#define UL_EX_LOCK_FREE     0
#define UL_EX_LOCK_LOCKED   1

typedef LONG UL_EXCLUSIVE_LOCK, *PUL_EXCLUSIVE_LOCK;

__inline
VOID
UlInitializeExclusiveLock(
    PUL_EXCLUSIVE_LOCK pExLock
    )
{
    *pExLock = UL_EX_LOCK_FREE;
}

__inline
VOID
UlAcquireExclusiveLock(
    PUL_EXCLUSIVE_LOCK pExLock
    )
{
    while (TRUE)
    {
        if (UL_EX_LOCK_FREE == *((volatile LONG *) pExLock))
        {
            if (UL_EX_LOCK_FREE == InterlockedCompareExchange(
                                        pExLock,
                                        UL_EX_LOCK_LOCKED,
                                        UL_EX_LOCK_FREE
                                        ))
            {
                break;
            }
        }

        PAUSE_PROCESSOR;
    }
}

__inline
VOID
UlReleaseExclusiveLock(
    PUL_EXCLUSIVE_LOCK pExLock
    )
{
    ASSERT( UL_EX_LOCK_LOCKED == *pExLock );
    InterlockedExchange( pExLock, UL_EX_LOCK_FREE );
}

#endif  // _MISC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\notify.h ===
/*++

Copyright (c) 2000-2002 Microsoft Corporation

Module Name:

    notify.h

Abstract:

    This module contains the notification list utilities.
    A notification list is optionally synchronized with
    a user specified UL_ERESOURCE, and provides an iterator
    called UlNotifyAllEntries.

Author:

    Michael Courage (mcourage)  25-Jan-2000

Revision History:

--*/

#ifndef _NOTIFY_H_
#define _NOTIFY_H_


//
// forwards
//
typedef struct _UL_NOTIFY_ENTRY *PUL_NOTIFY_ENTRY;

//
// Notification function prototype.
// Invoked on a list notification.
//
// Arguments:
//      pEntry - the entry that is being notified
//      pv     - "anything" parameter from UlNotifyEntries caller
//
// Return Value:
//      Function returns TRUE to continue iterating through the list
//      or FALSE to stop iterating.
//
typedef
BOOLEAN
(*PUL_NOTIFY_FUNC)(
    IN PUL_NOTIFY_ENTRY pEntry,
    IN PVOID            pHost,
    IN PVOID            pv
    );


//
// The head of a notification list
//
typedef struct _UL_NOTIFY_HEAD
{
    //
    // A list of UL_NOTIFY_ENTRYs
    //
    LIST_ENTRY      ListHead;
    PUL_ERESOURCE   pResource;


} UL_NOTIFY_HEAD, *PUL_NOTIFY_HEAD;

//
// An entry in the notification list.
//
typedef struct _UL_NOTIFY_ENTRY
{
    //
    // List information.
    //
    LIST_ENTRY      ListEntry;
    PUL_NOTIFY_HEAD pHead;

    //
    // A pointer to the object containting this entry
    //
    PVOID           pHost;

} UL_NOTIFY_ENTRY, *PUL_NOTIFY_ENTRY;

//
// Notification List functions
//

VOID
UlInitializeNotifyHead(
    IN PUL_NOTIFY_HEAD pHead,
    IN PUL_ERESOURCE pResource OPTIONAL
    );

VOID
UlInitializeNotifyEntry(
    IN PUL_NOTIFY_ENTRY pEntry,
    IN PVOID pHost
    );

VOID
UlAddNotifyEntry(
    IN PUL_NOTIFY_HEAD pHead,
    IN PUL_NOTIFY_ENTRY pEntry
    );

VOID
UlRemoveNotifyEntry(
    IN PUL_NOTIFY_ENTRY pEntry
    );

VOID
UlNotifyAllEntries(
    IN PUL_NOTIFY_FUNC pFunction,
    IN PUL_NOTIFY_HEAD pHead,
    IN PVOID pv OPTIONAL
    );


#endif  // _NOTIFY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\opaqueid.c ===
/*++

Copyright (c) 1998-2002 Microsoft Corporation

Module Name:

    opaqueid.c

Abstract:

    This module implements the opaque ID table. The ID table is
    implemented as a two-level array.

    The first level is an array of pointers to the second-level arrays.
    This first-level array is not growable, but its size is controlled
    by a registry key.

    The second level is an array of ID_TABLE_ENTRY structures. These
    structures contain a cyclic (to detect stale IDs) and caller-supplied
    context value.

    The data structures may be diagrammed as follows:

        g_FirstLevelTable[i]
               |
               |   +-----+
               |   |     |      +-----+-----+-----+----+...--+-----+-----+
               |   |     |      | ID_       | ID_      |     | ID_       |
               +-->|  *-------->| TABLE_    | TABLE_   |     | TABLE_    |
                   |     |      | ENTRY     | ENTRY    |     | ENTRY     |
                   |     |      +-----+-----+-----+----+--...+-----+-----+
                   +-----+
                   |     |      +-----+-----+-----+----+...--+-----+-----+
                   |     |      | ID_       | ID_      |     | ID_       |
                   |  *-------->| TABLE_    | TABLE_   |     | TABLE_    |
                   |     |      | ENTRY     | ENTRY    |     | ENTRY     |
                   |     |      +-----+-----+-----+----+--...+-----+-----+
                   +-----+
                   |     .
                   |     .
                   .     .
                   .     |
                   .     |
                   +-----+
                   |     |
                   |     |
                   |  /  |
                   |     |
                   |     |
                   +-----+
                   |     |
                   |     |
                   |  /  |
                   |     |
                   |     |
                   +-----+

    Because the lock protecting the single, global table of opaque IDs
    turned out to be a major scalability bottleneck on SMP machines, we
    now maintain per-processor subtables of opaque IDs. In addition, each
    ID_TABLE_ENTRY itself has a small lock that protects the fields inside
    it. This means we usually don't need to take the per-table spinlock.
    The per-table lock is only used when we grow the second-level table,
    in which case we have to protect the first-level table index and its
    pointer to the new second-level table.

    Note that all free ID_TABLE_ENTRY structures are kept on a single
    (global) free list. Whenever a new ID needs to be allocated, the free
    list is consulted. If it's not empty, an item is popped from the list
    and used. If the list is empty, then new space must be allocated. This
    will involve the allocation of a new second-level array.

    A HTTP_OPAQUE_ID is opaque at user-mode. Internally, it consists of 5
    fields:

        1) A processor number the ID was allocated on. This tells which
           per-processor table to free the ID.
        2) An index into the first-level array.
        3) An index into the second-level array referenced by the
           first-level index.
        4) A cyclic for the ID, used to detect stale IDs.
        5) An opaque ID type, used to guard against misuse of opaque IDs.

    See the OPAQUE_ID_INTERNAL structure definition (opaqueidp.h) for details.

    Note that most of the routines in this module assume they are called
    at PASSIVE_LEVEL.

Author:

    Keith Moore (keithmo)       05-Aug-1998

Revision History:

--*/


#include "precomp.h"


//
// Private globals.
//

DECLSPEC_ALIGN(UL_CACHE_LINE)
UL_ALIGNED_OPAQUE_ID_TABLE g_UlOpaqueIdTable[MAXIMUM_PROCESSORS];


#ifdef OPAQUE_ID_INSTRUMENTATION
LONGLONG g_NumberOfTotalGets = 0;
LONGLONG g_NumberOfSuccessfulGets = 0;
#endif


#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, UlInitializeOpaqueIdTable )
#pragma alloc_text( PAGE, UlTerminateOpaqueIdTable )
#endif  // ALLOC_PRAGMA
#if 0
NOT PAGEABLE -- UlAllocateOpaqueId
NOT PAGEABLE -- UlFreeOpaqueId
NOT PAGEABLE -- UlGetObjectFromOpaqueId
#endif


//
// Public functions.
//

/***************************************************************************++

Routine Description:

    Performs global initialization of the opaque ID package.

Arguments:

    None

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlInitializeOpaqueIdTable(
    VOID
    )
{
    PUL_OPAQUE_ID_TABLE pOpaqueIdTable;
    LONG i;

    //
    // Allocate the first-level opaque ID table arrry.
    //

    for (i = 0; i < (LONG)g_UlNumberOfProcessors; i++)
    {
        pOpaqueIdTable = &g_UlOpaqueIdTable[i].OpaqueIdTable;

        RtlZeroMemory(
            pOpaqueIdTable,
            sizeof(UL_OPAQUE_ID_TABLE)
            );

        pOpaqueIdTable->FirstLevelTable = UL_ALLOCATE_ARRAY(
                                                NonPagedPool,
                                                PUL_OPAQUE_ID_TABLE_ENTRY,
                                                g_UlOpaqueIdTableSize,
                                                UL_OPAQUE_ID_TABLE_POOL_TAG
                                                );

        if (pOpaqueIdTable->FirstLevelTable != NULL)
        {
            //
            // Initialization.
            //

            InitializeSListHead( &pOpaqueIdTable->FreeOpaqueIdSListHead );

            UlInitializeSpinLock( &pOpaqueIdTable->Lock, "OpaqueIdTableLock" );

            pOpaqueIdTable->FirstLevelTableSize = g_UlOpaqueIdTableSize;
            pOpaqueIdTable->FirstLevelTableInUse = 0;
            pOpaqueIdTable->Processor = (UCHAR)i;

            //
            // Zero out the first-level table.
            //

            RtlZeroMemory(
                pOpaqueIdTable->FirstLevelTable,
                g_UlOpaqueIdTableSize * sizeof(PUL_OPAQUE_ID_TABLE_ENTRY)
                );
        }
        else
        {
            while (--i >= 0)
            {
                pOpaqueIdTable = &g_UlOpaqueIdTable[i].OpaqueIdTable;

                UL_FREE_POOL(
                    pOpaqueIdTable->FirstLevelTable,
                    UL_OPAQUE_ID_TABLE_POOL_TAG
                    );

                pOpaqueIdTable->FirstLevelTable = NULL;
            }

            return STATUS_NO_MEMORY;
        }
    }

    return STATUS_SUCCESS;
}


/***************************************************************************++

Routine Description:

    Performs global termination of the opaque ID package.

Arguments:

    None

Return Value:

    None

--***************************************************************************/
VOID
UlTerminateOpaqueIdTable(
    VOID
    )
{
    PUL_OPAQUE_ID_TABLE pOpaqueIdTable;
    ULONG i, j;

    for (i = 0; i < g_UlNumberOfProcessors; i++)
    {
        pOpaqueIdTable = &g_UlOpaqueIdTable[i].OpaqueIdTable;

#ifdef OPAQUE_ID_INSTRUMENTATION
        ASSERT( pOpaqueIdTable->NumberOfAllocations ==
                pOpaqueIdTable->NumberOfFrees );
#endif

        //
        // Free all allocated second-level tables.
        //

        for (j = 0; j < pOpaqueIdTable->FirstLevelTableInUse; j++)
        {
            ASSERT( pOpaqueIdTable->FirstLevelTable[j] != NULL );

            UL_FREE_POOL(
                pOpaqueIdTable->FirstLevelTable[j],
                UL_OPAQUE_ID_TABLE_POOL_TAG
                );
        }

        //
        // Free the first-level table.
        //

        if (pOpaqueIdTable->FirstLevelTable != NULL)
        {
            UL_FREE_POOL(
                pOpaqueIdTable->FirstLevelTable,
                UL_OPAQUE_ID_TABLE_POOL_TAG
                );
        }
    }
}


/***************************************************************************++

Routine Description:

    Allocates a new opaque ID and associates it with the specified
    context. A new opaque ID takes a new slot in the opaque ID table.

Arguments:

    pOpaqueId - Receives the newly allocated opaque ID if successful.

    OpaqueIdType - Supplies the opaque ID type to be associated with
        the opaque ID and associated object.

    pContext - Supplies the context to associate with the new opaque ID.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlAllocateOpaqueId(
    OUT PHTTP_OPAQUE_ID pOpaqueId,
    IN UL_OPAQUE_ID_TYPE OpaqueIdType,
    IN PVOID pContext
    )
{
    PUL_OPAQUE_ID_TABLE pOpaqueIdTable;
    PUL_OPAQUE_ID_TABLE_ENTRY pEntry;
    PSLIST_ENTRY pListEntry;
    PUL_OPAQUE_ID_INTERNAL pInternalId;
    ULONG CurrentProcessor;
    ULONG CapturedFirstTableInUse;
    NTSTATUS Status = STATUS_SUCCESS;
    KIRQL OldIrql;

    //
    // Allocate a new opaque ID from the current processor table.  We need
    // a new entry for each ID.
    //

    CurrentProcessor = KeGetCurrentProcessorNumber();
    pOpaqueIdTable = &g_UlOpaqueIdTable[CurrentProcessor].OpaqueIdTable;

    //
    // Loop, trying to allocate an item from the table.
    //

    do
    {
        //
        // Remember the first-level table index if we need to expand later.
        //

        CapturedFirstTableInUse =
            *((volatile LONG *) &pOpaqueIdTable->FirstLevelTableInUse);

        pListEntry = InterlockedPopEntrySList(
                        &pOpaqueIdTable->FreeOpaqueIdSListHead
                        );

        if (pListEntry != NULL)
        {
            //
            // The free list isn't empty, so we can just use this
            // entry. We'll calculate the indices for this entry
            // and initialize the entry.
            //

            pEntry = CONTAINING_RECORD(
                        pListEntry,
                        UL_OPAQUE_ID_TABLE_ENTRY,
                        FreeListEntry
                        );

            //
            // If the entry popped up is not ready, loop and try again.
            // This can happen if we get thread switched right after we
            // obtained the current processor number, and the remaining
            // of the code got executed on another processor.  This would
            // mean we can't assume UlpExpandOpaqueIdTable will be completed
            // first before we issue the pop so we could end up having
            // entries that are not yet fully initialized.
            //

            if (pEntry->FirstIndex >= CapturedFirstTableInUse)
            {
                InterlockedPushEntrySList(
                    &pOpaqueIdTable->FreeOpaqueIdSListHead,
                    &pEntry->FreeListEntry
                );

                continue;
            }

            pInternalId = (PUL_OPAQUE_ID_INTERNAL) pOpaqueId;

            UlpAcquireOpaqueIdLock( &pEntry->Lock, &OldIrql );

            //
            // Processor and FirstIndex are ready to use.
            //

            pInternalId->Index = pEntry->Index;

            //
            // Re-compute SecondIndex because its corresponding field has
            // been overwritten by Cyclic and OpaqueIdType when the entry
            // is in use.
            //

            pInternalId->SecondIndex
                = (UCHAR) (pEntry - pOpaqueIdTable->FirstLevelTable[pEntry->FirstIndex]);

            //
            // Set the context associated with this entry.
            //

            pEntry->pContext = pContext;

            //
            // Update the cyclic and ID type of the entry.
            //

            pEntry->OpaqueIdCyclic = ++pEntry->EntryOpaqueIdCyclic;
            pEntry->OpaqueIdType = OpaqueIdType;

            pInternalId->Cyclic = pEntry->Cyclic;

            UlpReleaseOpaqueIdLock( &pEntry->Lock, OldIrql );

#ifdef OPAQUE_ID_INSTRUMENTATION
            UlInterlockedIncrement64( &pOpaqueIdTable->NumberOfAllocations );
#endif

            Status = STATUS_SUCCESS;
            break;
        }

        //
        // We only make it to this point if the free list is empty,
        // meaning we need to do some memory allocations before
        // we can continue. We'll put this off into a separate routine
        // to keep this one small (to avoid cache thrash). The realloc
        // routine returns STATUS_SUCCESS if it (or another thread)
        // managed to successfully reallocate the tables. Otherwise, it
        // returns a failure code.
        //

        Status = UlpExpandOpaqueIdTable(
                    pOpaqueIdTable,
                    CapturedFirstTableInUse
                    );

    } while ( Status == STATUS_SUCCESS );

    return Status;
}


/***************************************************************************++

Routine Description:

    Frees the specified opaque ID. This frees up the slot in the ID
    table as well.

Arguments:

    OpaqueId - Supplies the opaque ID to free.

    OpaqueIdType - Supplies the opaque ID type associated with the opaque ID.

Return Value:

    None

--***************************************************************************/
VOID
UlFreeOpaqueId(
    IN HTTP_OPAQUE_ID OpaqueId,
    IN UL_OPAQUE_ID_TYPE OpaqueIdType
    )
{
    PUL_OPAQUE_ID_TABLE pOpaqueIdTable;
    PUL_OPAQUE_ID_TABLE_ENTRY pEntry;
    ULONG Processor;
    ULONG FirstIndex = ULONG_MAX;
    ULONG SecondIndex;
    BOOLEAN Result;
    KIRQL OldIrql;

#if !DBG
    UNREFERENCED_PARAMETER( OpaqueIdType );
#endif

    //
    // Obtain the global opaque ID table and the entry associated with the
    // opaque ID passed in.
    //

    Result = UlpExtractIndexFromOpaqueId(
                OpaqueId,
                &Processor,
                &FirstIndex,
                &SecondIndex
                );

    ASSERT( Result );

    pOpaqueIdTable = &g_UlOpaqueIdTable[Processor].OpaqueIdTable;
    pEntry = pOpaqueIdTable->FirstLevelTable[FirstIndex] + SecondIndex;

    UlpAcquireOpaqueIdLock( &pEntry->Lock, &OldIrql );

    ASSERT( pEntry->OpaqueIdType != UlOpaqueIdTypeInvalid );
    ASSERT( (UL_OPAQUE_ID_TYPE) pEntry->OpaqueIdType == OpaqueIdType );
    ASSERT( pEntry->pContext != NULL );
    ASSERT( pEntry->OpaqueIdCyclic ==
            ((PUL_OPAQUE_ID_INTERNAL)&OpaqueId)->OpaqueIdCyclic );

    //
    // Restore the processor and first-level index but set the ID type
    // to invalid. This ensures subsequent mapping attempts on the stale
    // opaque ID entry will fail.
    //

    pEntry->Processor = Processor;
    pEntry->FirstIndex = FirstIndex;

    //
    // Setting OpaqueIdType to UlOpaqueIdTypeInvalid means the entry is freed.
    //

    pEntry->OpaqueIdType = UlOpaqueIdTypeInvalid;

    UlpReleaseOpaqueIdLock( &pEntry->Lock, OldIrql );

    InterlockedPushEntrySList(
        &pOpaqueIdTable->FreeOpaqueIdSListHead,
        &pEntry->FreeListEntry
        );

#ifdef OPAQUE_ID_INSTRUMENTATION
    UlInterlockedIncrement64( &pOpaqueIdTable->NumberOfFrees );
#endif
}


/***************************************************************************++

Routine Description:

    Maps the specified opaque ID to the corresponding context value.

Arguments:

    OpaqueId - Supplies the opaque ID to map.

    OpaqueIdType - Supplies the opaque ID type associated with the opaque ID.

    pReferenceRoutine - Supplies the reference routine to call on the mapped
        context if there is a match.

Return Value:

    PVOID - Returns the original context associated with the opaqued ID.

--***************************************************************************/
PVOID
UlGetObjectFromOpaqueId(
    IN HTTP_OPAQUE_ID OpaqueId,
    IN UL_OPAQUE_ID_TYPE OpaqueIdType,
    IN PUL_OPAQUE_ID_OBJECT_REFERENCE pReferenceRoutine
    )
{
    PUL_OPAQUE_ID_TABLE pOpaqueIdTable = NULL;
    PUL_OPAQUE_ID_TABLE_ENTRY pEntry;
    UL_OPAQUE_ID_INTERNAL InternalId;
    ULONG Processor;
    ULONG FirstIndex;
    ULONG SecondIndex;
    PVOID pContext = NULL;
    BOOLEAN Result;
    KIRQL OldIrql;

    //
    // Sanity check.
    //

    ASSERT( OpaqueIdType != UlOpaqueIdTypeInvalid );
    ASSERT( pReferenceRoutine != NULL );

#ifdef OPAQUE_ID_INSTRUMENTATION
    UlInterlockedIncrement64( &g_NumberOfTotalGets );
#endif

    InternalId.OpaqueId = OpaqueId;

    //
    // Preliminary checking.
    //

    if ((UL_OPAQUE_ID_TYPE) InternalId.OpaqueIdType != OpaqueIdType)
    {
        return pContext;
    }

    //
    // Obtain a matching ID table entry. If we get one, this means the
    // processor, first-level table index and second-level table index of
    // the ID passed in are valid.
    //

    Result = UlpExtractIndexFromOpaqueId(
                OpaqueId,
                &Processor,
                &FirstIndex,
                &SecondIndex
                );

    if (Result)
    {
        pOpaqueIdTable = &g_UlOpaqueIdTable[Processor].OpaqueIdTable;
        pEntry = pOpaqueIdTable->FirstLevelTable[FirstIndex] + SecondIndex;
    }
    else
    {
        pEntry = NULL;
    }

    if (pEntry != NULL)
    {
#ifdef OPAQUE_ID_INSTRUMENTATION
        ASSERT( pOpaqueIdTable );
        UlInterlockedIncrement64( &pOpaqueIdTable->NumberOfTotalGets );
#endif

        //
        // Check other things inside the lock.
        //

        UlpAcquireOpaqueIdLock( &pEntry->Lock, &OldIrql );

        if ((UL_OPAQUE_ID_TYPE) pEntry->OpaqueIdType == OpaqueIdType &&
            pEntry->OpaqueIdCyclic == InternalId.OpaqueIdCyclic)
        {
            ASSERT( pEntry->pContext != NULL );

            //
            // All matched so we set pContext.
            //

            pContext = pEntry->pContext;

            //
            // Invoke the caller's reference routine with the lock held.
            //

            (pReferenceRoutine)(
                pContext
                REFERENCE_DEBUG_ACTUAL_PARAMS
                );

#ifdef OPAQUE_ID_INSTRUMENTATION
            UlInterlockedIncrement64( &pOpaqueIdTable->NumberOfSuccessfulGets );
            UlInterlockedIncrement64( &g_NumberOfSuccessfulGets );
#endif
        }

        UlpReleaseOpaqueIdLock( &pEntry->Lock, OldIrql );
    }

    return pContext;
}


//
// Private functions.
//

/***************************************************************************++

Routine Description:

    Allocates a new second-level table.

Arguments:

    pOpaqueIdTable - Supplies the per-processor opaque ID table that we need
        to grow the second-level table.

    CapturedFirstTableInUse - Supplies the size of the first-level table as
        captured before InterlockedPopEntrySList. If this changes, it
        would mean another thread has allocated a new second-level table
        already and we return success right away in that case.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlpExpandOpaqueIdTable(
    IN PUL_OPAQUE_ID_TABLE pOpaqueIdTable,
    IN LONG CapturedFirstTableInUse
    )
{
    PUL_OPAQUE_ID_TABLE_ENTRY pNewTable;
    PUL_OPAQUE_ID_TABLE_ENTRY pEntry;
    LONG FirstIndex;
    LONG Processor;
    NTSTATUS Status;
    KIRQL OldIrql;
    LONG i;

    //
    // Acquire the lock when expanding the table.  This protects the
    // FirstLevelTableInUse and its associated first-level table.
    //

    UlAcquireSpinLock( &pOpaqueIdTable->Lock, &OldIrql );

    //
    // Bail out if FirstLevelTableInUse has changed.  This means, though
    // unlikely, another thread has expanded the table for us.
    //

    if (CapturedFirstTableInUse < (LONG)(pOpaqueIdTable->FirstLevelTableInUse))
    {
        Status = STATUS_SUCCESS;
        goto end;
    }

    //
    // Fail the expansion if we reach the limit.
    //

    if (pOpaqueIdTable->FirstLevelTableInUse >=
        pOpaqueIdTable->FirstLevelTableSize)
    {
        Status = STATUS_ALLOTTED_SPACE_EXCEEDED;
        goto end;
    }

    //
    // Allocate a new second-level table.
    //

    pNewTable = UL_ALLOCATE_ARRAY(
                    NonPagedPool,
                    UL_OPAQUE_ID_TABLE_ENTRY,
                    SECOND_LEVEL_TABLE_SIZE,
                    UL_OPAQUE_ID_TABLE_POOL_TAG
                    );

    if (pNewTable == NULL)
    {
        Status = STATUS_NO_MEMORY;
        goto end;
    }

    //
    // Initialize each table entry and push them to the global table's
    // free list.
    //

    RtlZeroMemory(
        pNewTable,
        sizeof(UL_OPAQUE_ID_TABLE_ENTRY) * SECOND_LEVEL_TABLE_SIZE
        );

    Processor = pOpaqueIdTable->Processor;
    FirstIndex = pOpaqueIdTable->FirstLevelTableInUse;

    for (i = 0, pEntry = pNewTable; i < SECOND_LEVEL_TABLE_SIZE; i++, pEntry++)
    {
        pEntry->Processor = Processor;
        pEntry->FirstIndex = FirstIndex;

        UlpInitializeOpaqueIdLock( &pEntry->Lock );

        InterlockedPushEntrySList(
            &pOpaqueIdTable->FreeOpaqueIdSListHead,
            &pEntry->FreeListEntry
            );
    }

    //
    // Adjust the first-level index forward.  Do this only after all entries
    // have been pushed to the global list so the IDs only become valid when
    // they indeed exist.  Because we have raised IRQL to DISPATCH level by
    // acquiring a spinlock, it is impossible for another thread to get in
    // and allocate an opaque ID from the current processor and its assoicated
    // global ID table.  All the map attempts on the IDs being pushed will
    // duely fail because we haven't moved first-level index forward during
    // the push.
    //

    ASSERT( pOpaqueIdTable->FirstLevelTable[FirstIndex] == NULL );

    pOpaqueIdTable->FirstLevelTable[FirstIndex] = pNewTable;
    pOpaqueIdTable->FirstLevelTableInUse++;

    Status = STATUS_SUCCESS;

end:

    UlReleaseSpinLock( &pOpaqueIdTable->Lock, OldIrql );

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\opaqueid.h ===
/*++

Copyright (c) 1998-2002 Microsoft Corporation

Module Name:

    opaqueid.h

Abstract:

    This module contains declarations for manipulating opaque IDs to
    kernel-mode objects.

Author:

    Keith Moore (keithmo)       05-Aug-1998

Revision History:

--*/


#ifndef _OPAQUEID_H_
#define _OPAQUEID_H_


//
// Types to set opaque IDs to for tag-like free checking.
//

typedef enum _UL_OPAQUE_ID_TYPE
{
    UlOpaqueIdTypeInvalid = 0,
    UlOpaqueIdTypeConfigGroup,
    UlOpaqueIdTypeHttpConnection,
    UlOpaqueIdTypeHttpRequest,
    UlOpaqueIdTypeRawConnection,

    UlOpaqueIdTypeMaximum

} UL_OPAQUE_ID_TYPE, *PUL_OPAQUE_ID_TYPE;


//
// Routines invoked to manipulate the reference count of an object.
//

typedef
VOID
(*PUL_OPAQUE_ID_OBJECT_REFERENCE)(
    IN PVOID pObject
    REFERENCE_DEBUG_FORMAL_PARAMS
    );


//
// Public functions.
//

NTSTATUS
UlInitializeOpaqueIdTable(
    VOID
    );

VOID
UlTerminateOpaqueIdTable(
    VOID
    );

NTSTATUS
UlAllocateOpaqueId(
    OUT PHTTP_OPAQUE_ID pOpaqueId,
    IN UL_OPAQUE_ID_TYPE OpaqueIdType,
    IN PVOID pContext
    );

VOID
UlFreeOpaqueId(
    IN HTTP_OPAQUE_ID OpaqueId,
    IN UL_OPAQUE_ID_TYPE OpaqueIdType
    );

PVOID
UlGetObjectFromOpaqueId(
    IN HTTP_OPAQUE_ID OpaqueId,
    IN UL_OPAQUE_ID_TYPE OpaqueIdType,
    IN PUL_OPAQUE_ID_OBJECT_REFERENCE pReferenceRoutine
    );


#endif  // _OPAQUEID_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\opaqueidp.h ===
/*++

Copyright (c) 1999-2002 Microsoft Corporation

Module Name:

    opaqueidp.h

Abstract:

    This module contains declarations private to the opaque ID table. These
    declarations are placed in a separate .H file to make it easier to access
    them from within the kernel debugger extension DLL.

Author:

    Keith Moore (keithmo)       10-Sep-1999

Revision History:

--*/


#ifndef _OPAQUEIDP_H_
#define _OPAQUEIDP_H_


//
// The internal structure of an HTTP_OPAQUE_ID.
//
// N.B. This structure must be EXACTLY the same size as an HTTP_OPAQUE_ID!
//

#define PROCESSOR_BIT_WIDTH             6
#define FIRST_INDEX_BIT_WIDTH           18
#define SECOND_INDEX_BIT_WIDTH          8
#define OPAQUE_ID_CYCLIC_BIT_WIDTH      29
#define OPAQUE_ID_TYPE_BIT_WIDTH        3

//
// The maximum size of the first-level table.  Out of 32 bits, we use 6 bits
// for the processor (64) and 8 bits for the second-level table (256).  So
// we have 18 = (32 - 6 - 8) bits left, or 262,144 first-level tables per
// processor, for a total of 67,108,864 opaque IDs per processor.
//

#define MAX_OPAQUE_ID_TABLE_SIZE    \
    (1 << (32 - PROCESSOR_BIT_WIDTH - SECOND_INDEX_BIT_WIDTH))

typedef union _UL_OPAQUE_ID_INTERNAL
{
    HTTP_OPAQUE_ID OpaqueId;

    struct
    {
        union
        {
            ULONG Index;

            struct
            {
                ULONG Processor :       PROCESSOR_BIT_WIDTH;
                ULONG FirstIndex :      FIRST_INDEX_BIT_WIDTH;
                ULONG SecondIndex :     SECOND_INDEX_BIT_WIDTH;
            };
        };

        union
        {
            ULONG Cyclic;

            struct
            {
                ULONG OpaqueIdCyclic :  OPAQUE_ID_CYCLIC_BIT_WIDTH;
                ULONG OpaqueIdType :    OPAQUE_ID_TYPE_BIT_WIDTH;
            };
        };
    };

} UL_OPAQUE_ID_INTERNAL, *PUL_OPAQUE_ID_INTERNAL;

C_ASSERT( sizeof(HTTP_OPAQUE_ID) == sizeof(UL_OPAQUE_ID_INTERNAL) );
C_ASSERT( 8 * sizeof(HTTP_OPAQUE_ID) == (PROCESSOR_BIT_WIDTH +          \
                                        FIRST_INDEX_BIT_WIDTH +         \
                                        SECOND_INDEX_BIT_WIDTH +        \
                                        OPAQUE_ID_CYCLIC_BIT_WIDTH +    \
                                        OPAQUE_ID_TYPE_BIT_WIDTH        \
                                        ));
C_ASSERT( (1 << PROCESSOR_BIT_WIDTH) >= MAXIMUM_PROCESSORS );
C_ASSERT( (1 << OPAQUE_ID_TYPE_BIT_WIDTH) >= UlOpaqueIdTypeMaximum );
C_ASSERT( (8 * sizeof(UCHAR)) >= SECOND_INDEX_BIT_WIDTH );


//
// A per-entry opaque ID lock.
//

#define OPAQUE_ID_DPC

#ifdef OPAQUE_ID_DPC
typedef KSPIN_LOCK UL_OPAQUE_ID_LOCK, *PUL_OPAQUE_ID_LOCK;

__inline
VOID
UlpInitializeOpaqueIdLock(
    IN PUL_OPAQUE_ID_LOCK pLock
    )
{
    KeInitializeSpinLock( pLock );
}

__inline
VOID
UlpAcquireOpaqueIdLock(
    IN PUL_OPAQUE_ID_LOCK pLock,
    OUT PKIRQL pOldIrql
    )
{
    KeAcquireSpinLock( pLock, pOldIrql );
}

__inline
VOID
UlpReleaseOpaqueIdLock(
    IN PUL_OPAQUE_ID_LOCK pLock,
    IN KIRQL OldIrql
    )
{
    KeReleaseSpinLock( pLock, OldIrql );
}

#else // !OPAQUE_ID_DPC

typedef volatile LONG UL_OPAQUE_ID_LOCK, *PUL_OPAQUE_ID_LOCK;

__inline
VOID
UlpInitializeOpaqueIdLock(
    IN PUL_OPAQUE_ID_LOCK pLock
    )
{
    *pLock = 0;
}

__inline
VOID
UlpAcquireOpaqueIdLock(
    IN PUL_OPAQUE_ID_LOCK pLock,
    OUT PKIRQL pOldIrql
    )
{
    while (TRUE)
    {
        while (*pLock == 1)
        {
            PAUSE_PROCESSOR
        }

        if (0 == InterlockedCompareExchange( pLock, 1, 0 ))
        {
            break;
        }
    }
}

__inline
VOID
UlpReleaseOpaqueIdLock(
    IN PUL_OPAQUE_ID_LOCK pLock,
    IN KIRQL OldIrql
    )
{
    ASSERT( *pLock == 1 );

    InterlockedExchange( pLock, 0 );
}

#endif // !OPAQUE_ID_DPC


//
// A second-level table entry.
//
// Note that FreeListEntry and pContext are in an anonymous
// union to save space; an entry is either on the free list or in use,
// so only one of these fields will be used at a time.
//
// Also note that Cyclic is in a second anonymous union. It's overlayed
// with FirstLevelIndex (which is basically the second-level table's
// index in the first-level table) and ID type (used to distinguish
// free entries from in-use entries).
//

#define SECOND_LEVEL_TABLE_SIZE 256

C_ASSERT( SECOND_LEVEL_TABLE_SIZE == 1 << SECOND_INDEX_BIT_WIDTH );

typedef struct _UL_OPAQUE_ID_TABLE_ENTRY
{
    //
    // NonPagedPool
    //

    union
    {
        //
        // To ensure FreeListEntry is aligned on the right boundary.
        //

        DECLSPEC_ALIGN(MEMORY_ALLOCATION_ALIGNMENT) ULONGLONG Alignment;

        struct
        {
            union
            {
                //
                // An entry to the global ID table's free ID list.
                //

                SLIST_ENTRY FreeListEntry;

                //
                // Context associated with the opaque ID.
                //

                PVOID       pContext;
            };

            //
            // A per-entry ID cyclic that guarantees we can generate
            // 2 ^ OPAQUE_ID_CYCLIC_BIT_WIDTH of opaque IDs from the
            // current entry without repeating. This gives us extra
            // protection than using a global ID cyclic.
            //

            ULONG EntryOpaqueIdCyclic;
        };
    };

    //
    // A per-entry lock that protects the entry.
    //

    UL_OPAQUE_ID_LOCK Lock;

    //
    // The ID index for the opaque ID when the entry is free or the cyclic
    // when the entry is in use.
    //

    union
    {
        union
        {
            ULONG Index;

            struct
            {
                ULONG Processor :       PROCESSOR_BIT_WIDTH;
                ULONG FirstIndex :      FIRST_INDEX_BIT_WIDTH;
                ULONG Reserved :        SECOND_INDEX_BIT_WIDTH;
            };
        };

        union
        {
            ULONG Cyclic;

            struct
            {
                ULONG OpaqueIdCyclic :  OPAQUE_ID_CYCLIC_BIT_WIDTH;
                ULONG OpaqueIdType :    OPAQUE_ID_TYPE_BIT_WIDTH;
            };
        };
    };

} UL_OPAQUE_ID_TABLE_ENTRY, *PUL_OPAQUE_ID_TABLE_ENTRY;


//
// We keep per-processor first-level ID tables. A single table is a
// major scalability bottleneck on SMP machines. The size of the first-level
// table is controlled by a registry setting.
//

#if DBG
#define OPAQUE_ID_INSTRUMENTATION
#endif

typedef struct _UL_OPAQUE_ID_TABLE
{
    //
    // A list of free IDs available on this table.
    //

    SLIST_HEADER FreeOpaqueIdSListHead;

    //
    // An arrary of second-level ID table entries.
    //

    PUL_OPAQUE_ID_TABLE_ENTRY *FirstLevelTable;

    //
    // The corresponding CPU this table represents.
    //

    UCHAR Processor;

    //
    // The lock really only protects FirstLevelTableInUse.
    //

    UL_SPIN_LOCK Lock;

    //
    // The current number of first-level tables allocated.
    //

    ULONG FirstLevelTableInUse;

    //
    // The maximum size we can grow for the first-level tables.
    //

    ULONG FirstLevelTableSize;

#ifdef OPAQUE_ID_INSTRUMENTATION
    LONGLONG NumberOfAllocations;
    LONGLONG NumberOfFrees;
    LONGLONG NumberOfTotalGets;
    LONGLONG NumberOfSuccessfulGets;
#endif
} UL_OPAQUE_ID_TABLE, *PUL_OPAQUE_ID_TABLE;


//
// Necessary to ensure our array of UL_OPAQUE_ID_TABLE structures is
// cache aligned.
//

typedef union _UL_ALIGNED_OPAQUE_ID_TABLE
{
    UL_OPAQUE_ID_TABLE OpaqueIdTable;

    UCHAR CacheAlignment[(sizeof(UL_OPAQUE_ID_TABLE) + UL_CACHE_LINE - 1) & ~(UL_CACHE_LINE - 1)];

} UL_ALIGNED_OPAQUE_ID_TABLE, *PUL_ALIGNED_OPAQUE_ID_TABLE;


//
// An inline function that maps a specified HTTP_OPAQUE_ID to the
// corresponding ID table entry.
//

extern UL_ALIGNED_OPAQUE_ID_TABLE g_UlOpaqueIdTable[];

__inline
BOOLEAN
UlpExtractIndexFromOpaqueId(
    IN HTTP_OPAQUE_ID OpaqueId,
    OUT PULONG pProcessor,
    OUT PULONG pFirstIndex,
    OUT PULONG pSecondIndex
    )
{
    UL_OPAQUE_ID_INTERNAL InternalId;
    PUL_OPAQUE_ID_TABLE pOpaqueIdTable;

    InternalId.OpaqueId = OpaqueId;

    //
    // Verify the processor portion of the index.
    //

    *pProcessor = InternalId.Processor;

    if (*pProcessor >= g_UlNumberOfProcessors)
    {
        return FALSE;
    }

    //
    // Verify the first-level index.
    //

    pOpaqueIdTable = &g_UlOpaqueIdTable[*pProcessor].OpaqueIdTable;
    *pFirstIndex = InternalId.FirstIndex;

    if (*pFirstIndex >= pOpaqueIdTable->FirstLevelTableInUse)
    {
        return FALSE;
    }

    //
    // Second-level index is always valid since we only allocated 8-bits.
    //

    ASSERT( InternalId.SecondIndex < SECOND_LEVEL_TABLE_SIZE );

    *pSecondIndex = InternalId.SecondIndex;

    return TRUE;

}

__inline
PUL_OPAQUE_ID_TABLE_ENTRY
UlpMapOpaqueIdToTableEntry(
    IN HTTP_OPAQUE_ID OpaqueId
    )
{
    PUL_OPAQUE_ID_TABLE pOpaqueIdTable;
    ULONG Processor;
    ULONG FirstIndex;
    ULONG SecondIndex;

    if (UlpExtractIndexFromOpaqueId(
            OpaqueId,
            &Processor,
            &FirstIndex,
            &SecondIndex
            ))
    {
        pOpaqueIdTable = &g_UlOpaqueIdTable[Processor].OpaqueIdTable;
        return pOpaqueIdTable->FirstLevelTable[FirstIndex] + SecondIndex;
    }
    else
    {
        return NULL;
    }

}


//
// Private prototypes.
//

NTSTATUS
UlpExpandOpaqueIdTable(
    IN PUL_OPAQUE_ID_TABLE pOpaqueIdTable,
    IN LONG CapturedFirstTableInUse
    );


#endif  // _OPAQUEIDP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\notify.c ===
/*++

Copyright (c) 2000-2002 Microsoft Corporation

Module Name:

    notify.c

Abstract:

    This module implements notification lists.

Author:

    Michael Courage (mcourage)  25-Jan-2000

Revision History:

--*/


#include "precomp.h"


#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, UlAddNotifyEntry )
#pragma alloc_text( PAGE, UlRemoveNotifyEntry )
#pragma alloc_text( PAGE, UlNotifyAllEntries )
#endif  // ALLOC_PRAGMA
#if 0
NOT PAGEABLE -- UlInitializeNotifyHead
NOT PAGEABLE -- UlInitializeNotifyEntry
#endif


//
// Public functions.
//

/***************************************************************************++

Routine Description:

    Initializes the head of the list.

Arguments:

    pHead - pointer to the head of list structure
    pResource - an optional pointer to a resource to synchronize access

--***************************************************************************/
VOID
UlInitializeNotifyHead(
    IN PUL_NOTIFY_HEAD pHead,
    IN PUL_ERESOURCE pResource
    )
{
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);
    ASSERT(pHead);

    InitializeListHead(&pHead->ListHead);
    pHead->pResource = pResource;
}

/***************************************************************************++

Routine Description:

    Initializes an entry in a notify list.

Arguments:

    pEntry - the entry to be initialized
    pHost - A void context pointer assumed to be the containing object

--***************************************************************************/
VOID
UlInitializeNotifyEntry(
    IN PUL_NOTIFY_ENTRY pEntry,
    IN PVOID pHost
    )
{
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);
    ASSERT(pEntry);
    ASSERT(pHost);

    pEntry->ListEntry.Flink = pEntry->ListEntry.Blink = NULL;
    pEntry->pHead = NULL;
    pEntry->pHost = pHost;
}

/***************************************************************************++

Routine Description:

    Adds an entry to the tail of the list.

Arguments:

    pHead - Head of the target list
    pEntry - the entry to be added to the list

--***************************************************************************/
VOID
UlAddNotifyEntry(
    IN PUL_NOTIFY_HEAD pHead,
    IN PUL_NOTIFY_ENTRY pEntry
    )
{
    PAGED_CODE();
    ASSERT(pEntry);
    ASSERT(pHead);
    ASSERT(pEntry->pHead == NULL);
    ASSERT(pEntry->ListEntry.Flink == NULL);

    if (pHead->pResource) {
        UlAcquireResourceExclusive(pHead->pResource, TRUE);
    }

    pEntry->pHead = pHead;
    InsertTailList(&pHead->ListHead, &pEntry->ListEntry);

    if (pHead->pResource) {
        UlReleaseResource(pHead->pResource);
    }
}

/***************************************************************************++

Routine Description:

    Removes an entry from the notify list it is on.

Arguments:

    pEntry - the entry to be removed

--***************************************************************************/
VOID
UlRemoveNotifyEntry(
    IN PUL_NOTIFY_ENTRY pEntry
    )
{
    PUL_NOTIFY_HEAD pHead;

    PAGED_CODE();
    ASSERT(pEntry);

    pHead = pEntry->pHead;

    if (pHead) {

        ASSERT(pEntry->ListEntry.Flink);


        if (pHead->pResource) {
            UlAcquireResourceExclusive(pHead->pResource, TRUE);
        }

        pEntry->pHead = NULL;
        RemoveEntryList(&pEntry->ListEntry);
        pEntry->ListEntry.Flink = pEntry->ListEntry.Blink = NULL;

        if (pHead->pResource) {
            UlReleaseResource(pHead->pResource);
        }
    }
}

/***************************************************************************++

Routine Description:

    An internal iterator that applies pFunction to every element in the
    list.

    We start at the head of the list, and keep iterating until we get to
    the end OR pFunction returns FALSE.

Arguments:

    pFunction - the function to call for each member of the list
    pHead - the head of the list over which we'll iterate
    pv - an arbitrary context pointer that will be passed to pFunction

--***************************************************************************/
VOID
UlNotifyAllEntries(
    IN PUL_NOTIFY_FUNC pFunction,
    IN PUL_NOTIFY_HEAD pHead,
    IN PVOID pv
    )
{
    PLIST_ENTRY pEntry;
    PUL_NOTIFY_ENTRY pNotifyEntry;
    BOOLEAN Continue;

    PAGED_CODE();
    ASSERT(pHead);

    // grab the resource
    if (pHead->pResource) {
        UlAcquireResourceExclusive(pHead->pResource, TRUE);
    }


    //
    // Iterate through the list
    //
    pEntry = pHead->ListHead.Flink;
    Continue = TRUE;

    while (Continue && (pEntry != &pHead->ListHead)) {
        ASSERT(pEntry);

        pNotifyEntry = CONTAINING_RECORD(
                            pEntry,
                            UL_NOTIFY_ENTRY,
                            ListEntry
                            );

        pEntry = pEntry->Flink;

        //
        // Call the notification function
        //
        Continue = pFunction(
                        pNotifyEntry,
                        pNotifyEntry->pHost,
                        pv
                        );
    }

    // let go of the resource
    if (pHead->pResource) {
        UlReleaseResource(pHead->pResource);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\parse.c ===
/*++

Copyright (c) 1998-2002 Microsoft Corporation

Module Name:

    parse.c

Abstract:

    Contains all of the kernel mode HTTP parsing code.

Author:

    Henry Sanders (henrysa)       27-Apr-1998

Revision History:

    Paul McDaniel   (paulmcd)       3-Mar-1998  finished up
    Rajesh Sundaram (rajeshsu)     10-Oct-2000  Implemented client parser

--*/


#include "precomp.h"


//  Internal (private) status codes
//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag - 0
//
//      R - is a reserved bit - 0
//
//      Facility - is the facility code - 0x16
//
//      Code - is the facility's status code

#define STATUS_QDSTRING_TERMINATED_BY_CRLF      0xC0160001

//

//
// The request header map table. These entries don't need to be in strict
// alphabetical order, but they do need to be grouped by the first character
// of the header - all A's together, all C's together, etc. They also need
// to be entered in uppercase, since we upcase incoming verbs before we do
// the compare.
//
// for nice perf, group unused headers low in the sub-sort order
//
// it's important that the header name is <= 24 characters (3 ULONGLONG's).
//

HEADER_MAP_ENTRY g_RequestHeaderMapTable[] =
{
    CREATE_HEADER_MAP_ENTRY(Accept:,
                            HttpHeaderAccept,
                            FALSE,
                            UlAcceptHeaderHandler,
                            NULL,
                            0),

    CREATE_HEADER_MAP_ENTRY(Accept-Language:,
                            HttpHeaderAcceptLanguage,
                            FALSE,
                            UlMultipleHeaderHandler,
                            NULL,
                            2),

    CREATE_HEADER_MAP_ENTRY(Accept-Encoding:,
                            HttpHeaderAcceptEncoding,
                            FALSE,
                            UlMultipleHeaderHandler,
                            NULL,
                            3),

    CREATE_HEADER_MAP_ENTRY(Accept-Charset:,
                            HttpHeaderAcceptCharset,
                            FALSE,
                            UlMultipleHeaderHandler,
                            NULL,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Authorization:,
                            HttpHeaderAuthorization,
                            FALSE,
                            UlSingleHeaderHandler,
                            NULL,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Allow:,
                            HttpHeaderAllow,
                            FALSE,
                            UlMultipleHeaderHandler,
                            NULL,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Connection:,
                            HttpHeaderConnection,
                            FALSE,
                            UlMultipleHeaderHandler,
                            NULL,
                            8),

    CREATE_HEADER_MAP_ENTRY(Cache-Control:,
                            HttpHeaderCacheControl,
                            FALSE,
                            UlMultipleHeaderHandler,
                            NULL,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Cookie:,
                            HttpHeaderCookie,
                            FALSE,
                            UlMultipleHeaderHandler,
                            NULL,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Content-Length:,
                            HttpHeaderContentLength,
                            TRUE,
                            UlSingleHeaderHandler,
                            NULL,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Content-Type:,
                            HttpHeaderContentType,
                            FALSE,
                            UlSingleHeaderHandler,
                            NULL,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Content-Encoding:,
                            HttpHeaderContentEncoding,
                            FALSE,
                            UlMultipleHeaderHandler,
                            NULL,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Content-Language:,
                            HttpHeaderContentLanguage,
                            FALSE,
                            UlMultipleHeaderHandler,
                            NULL,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Content-Location:,
                            HttpHeaderContentLocation,
                            FALSE,
                            UlSingleHeaderHandler,
                            NULL,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Content-MD5:,
                            HttpHeaderContentMd5,
                            FALSE,
                            UlSingleHeaderHandler,
                            NULL,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Content-Range:,
                            HttpHeaderContentRange,
                            FALSE,
                            UlSingleHeaderHandler,
                            NULL,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Date:,
                            HttpHeaderDate,
                            FALSE,
                            UlSingleHeaderHandler,
                            NULL,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Expect:,
                            HttpHeaderExpect,
                            FALSE,
                            UlMultipleHeaderHandler,
                            NULL,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Expires:,
                            HttpHeaderExpires,
                            FALSE,
                            UlSingleHeaderHandler,
                            NULL,
                            -1),

    CREATE_HEADER_MAP_ENTRY(From:,
                            HttpHeaderFrom,
                            FALSE,
                            UlSingleHeaderHandler,
                            NULL,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Host:,
                            HttpHeaderHost,
                            TRUE,
                            UlHostHeaderHandler,
                            NULL,
                            7),

    CREATE_HEADER_MAP_ENTRY(If-Modified-Since:,
                            HttpHeaderIfModifiedSince,
                            FALSE,
                            UlSingleHeaderHandler,
                            NULL,
                            4),

    CREATE_HEADER_MAP_ENTRY(If-None-Match:,
                            HttpHeaderIfNoneMatch,
                            FALSE,
                            UlMultipleHeaderHandler,
                            NULL,
                            5),

    CREATE_HEADER_MAP_ENTRY(If-Match:,
                            HttpHeaderIfMatch,
                            FALSE,
                            UlMultipleHeaderHandler,
                            NULL,
                            -1),

    CREATE_HEADER_MAP_ENTRY(If-Unmodified-Since:,
                            HttpHeaderIfUnmodifiedSince,
                            FALSE,
                            UlSingleHeaderHandler,
                            NULL,
                            -1),

    CREATE_HEADER_MAP_ENTRY(If-Range:,
                            HttpHeaderIfRange,
                            FALSE,
                            UlSingleHeaderHandler,
                            NULL,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Keep-Alive:,
                            HttpHeaderKeepAlive,
                            FALSE,
                            UlSingleHeaderHandler,
                            NULL,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Last-Modified:,
                            HttpHeaderLastModified,
                            FALSE,
                            UlSingleHeaderHandler,
                            NULL,
                            -1),


    CREATE_HEADER_MAP_ENTRY(Max-Forwards:,
                            HttpHeaderMaxForwards,
                            FALSE,
                            UlSingleHeaderHandler,
                            NULL,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Pragma:,
                            HttpHeaderPragma,
                            FALSE,
                            UlMultipleHeaderHandler,
                            NULL,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Proxy-Authorization:,
                            HttpHeaderProxyAuthorization,
                            FALSE,
                            UlSingleHeaderHandler,
                            NULL,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Referer:,
                            HttpHeaderReferer,
                            FALSE,
                            UlSingleHeaderHandler,
                            NULL,
                            1),

    CREATE_HEADER_MAP_ENTRY(Range:,
                            HttpHeaderRange,
                            FALSE,
                            UlSingleHeaderHandler,
                            NULL,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Trailer:,
                            HttpHeaderTrailer,
                            FALSE,
                            UlMultipleHeaderHandler,
                            NULL,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Transfer-Encoding:,
                            HttpHeaderTransferEncoding,
                            FALSE,
                            UlMultipleHeaderHandler,
                            NULL,
                            -1),

    CREATE_HEADER_MAP_ENTRY(TE:,
                            HttpHeaderTe,
                            FALSE,
                            UlMultipleHeaderHandler,
                            NULL,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Translate:,
                            HttpHeaderTranslate,
                            FALSE,
                            UlSingleHeaderHandler,
                            NULL,
                            -1),

    CREATE_HEADER_MAP_ENTRY(User-Agent:,
                            HttpHeaderUserAgent,
                            FALSE,
                            UlSingleHeaderHandler,
                            NULL,
                            6),

    CREATE_HEADER_MAP_ENTRY(Upgrade:,
                            HttpHeaderUpgrade,
                            FALSE,
                            UlMultipleHeaderHandler,
                            NULL,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Via:,
                            HttpHeaderVia,
                            FALSE,
                            UlMultipleHeaderHandler,
                            NULL,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Warning:,
                            HttpHeaderWarning,
                            FALSE,
                            UlMultipleHeaderHandler,
                            NULL,
                            -1),
};

// The response header map table. These entries don't need to be in strict
// alphabetical order, but they do need to be grouped by the first character
// of the header - all A's together, all C's together, etc. They also need
// to be entered in uppercase, since we upcase incoming verbs before we do
// the compare.
//
// for nice perf, group unused headers low in the sub-sort order
//
// it's important that the header name is <= 24 characters (3 ULONGLONG's).
//

HEADER_MAP_ENTRY g_ResponseHeaderMapTable[] =
{
    CREATE_HEADER_MAP_ENTRY(Accept-Ranges:,
                            HttpHeaderAcceptRanges,
                            FALSE,
                            NULL,
                            UcMultipleHeaderHandler,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Age:,
                            HttpHeaderAge,
                            FALSE,
                            NULL,
                            UcSingleHeaderHandler,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Allow:,
                            HttpHeaderAllow,
                            FALSE,
                            NULL,
                            UcMultipleHeaderHandler,
                            -1),


    CREATE_HEADER_MAP_ENTRY(Cache-Control:,
                            HttpHeaderCacheControl,
                            FALSE,
                            NULL,
                            UcMultipleHeaderHandler,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Connection:,
                            HttpHeaderConnection,
                            FALSE,
                            NULL,
                            UcConnectionHeaderHandler,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Content-Encoding:,
                            HttpHeaderContentEncoding,
                            FALSE,
                            NULL,
                            UcMultipleHeaderHandler,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Content-Language:,
                            HttpHeaderContentLanguage,
                            FALSE,
                            NULL,
                            UcMultipleHeaderHandler,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Content-Length:,
                            HttpHeaderContentLength,
                            FALSE,
                            NULL,
                            UcContentLengthHeaderHandler,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Content-Location:,
                            HttpHeaderContentLocation,
                            FALSE,
                            NULL,
                            UcSingleHeaderHandler,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Content-MD5:,
                            HttpHeaderContentMd5,
                            FALSE,
                            NULL,
                            UcSingleHeaderHandler,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Content-Range:,
                            HttpHeaderContentRange,
                            FALSE,
                            NULL,
                            UcSingleHeaderHandler,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Content-Type:,
                            HttpHeaderContentType,
                            FALSE,
                            NULL,
                            UcContentTypeHeaderHandler,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Date:,
                            HttpHeaderDate,
                            FALSE,
                            NULL,
                            UcSingleHeaderHandler,
                            -1),

    CREATE_HEADER_MAP_ENTRY(ETag:,
                            HttpHeaderEtag,
                            FALSE,
                            NULL,
                            UcSingleHeaderHandler,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Expires:,
                            HttpHeaderExpires,
                            FALSE,
                            NULL,
                            UcSingleHeaderHandler,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Keep-Alive:,
                            HttpHeaderKeepAlive,
                            FALSE,
                            NULL,
                            UcSingleHeaderHandler,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Last-Modified:,
                            HttpHeaderLastModified,
                            FALSE,
                            NULL,
                            UcSingleHeaderHandler,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Location:,
                            HttpHeaderLocation,
                            FALSE,
                            NULL,
                            UcSingleHeaderHandler,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Pragma:,
                            HttpHeaderPragma,
                            FALSE,
                            NULL,
                            UcMultipleHeaderHandler,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Proxy-Authenticate:,
                            HttpHeaderProxyAuthenticate,
                            FALSE,
                            NULL,
                            UcAuthenticateHeaderHandler,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Retry-After:,
                            HttpHeaderRetryAfter,
                            FALSE,
                            NULL,
                            UcSingleHeaderHandler,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Server:,
                            HttpHeaderServer,
                            FALSE,
                            NULL,
                            UcSingleHeaderHandler,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Set-Cookie:,
                            HttpHeaderSetCookie,
                            FALSE,
                            NULL,
                            UcMultipleHeaderHandler,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Trailer:,
                            HttpHeaderTrailer,
                            FALSE,
                            NULL,
                            UcMultipleHeaderHandler,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Transfer-Encoding:,
                            HttpHeaderTransferEncoding,
                            FALSE,
                            NULL,
                            UcTransferEncodingHeaderHandler,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Upgrade:,
                            HttpHeaderUpgrade,
                            FALSE,
                            NULL,
                            UcMultipleHeaderHandler,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Vary:,
                            HttpHeaderVary,
                            FALSE,
                            NULL,
                            UcMultipleHeaderHandler,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Via:,
                            HttpHeaderVia,
                            FALSE,
                            NULL,
                            UcMultipleHeaderHandler,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Warning:,
                            HttpHeaderWarning,
                            FALSE,
                            NULL,
                            UcMultipleHeaderHandler,
                            -1),

    CREATE_HEADER_MAP_ENTRY(WWW-Authenticate:,
                            HttpHeaderWwwAuthenticate,
                            FALSE,
                            NULL,
                            UcAuthenticateHeaderHandler,
                            -1)
};

ULONG g_RequestHeaderMap[HttpHeaderMaximum];
ULONG g_ResponseHeaderMap[HttpHeaderMaximum];


//
// The header index table. This is initialized by the init code.
//

HEADER_INDEX_ENTRY  g_RequestHeaderIndexTable[NUMBER_HEADER_INDICES];
HEADER_INDEX_ENTRY  g_ResponseHeaderIndexTable[NUMBER_HEADER_INDICES];

HEADER_HINT_INDEX_ENTRY g_RequestHeaderHintIndexTable[NUMBER_HEADER_HINT_INDICES];

#define NUMBER_REQUEST_HEADER_MAP_ENTRIES  \
              (sizeof(g_RequestHeaderMapTable)/sizeof(HEADER_MAP_ENTRY))
#define NUMBER_RESPONSE_HEADER_MAP_ENTRIES \
              (sizeof(g_ResponseHeaderMapTable)/sizeof(HEADER_MAP_ENTRY))


/*++

Routine Description:

    A utility routine to find a hex value token. We take an input pointer,
    skip any preceding LWS, then scan the token until we find a non-hex char,
    LWS or a CRLF pair.

Arguments:

    pBuffer         - Buffer to search for token.
    BufferLength    - Length of data pointed to by pBuffer.
    TokenLength     - Where to return the length of the token.

Return Value:

    A pointer to the token we found, as well as the length, or NULL if we
    don't find a delimited token.

--*/
PUCHAR
FindHexToken(
    IN  PUCHAR pBuffer,
    IN  ULONG  BufferLength,
    OUT ULONG  *pTokenLength
    )
{
    PUCHAR  pTokenStart;

    //
    // First, skip any preceding LWS.
    //

    while (BufferLength > 0 && IS_HTTP_LWS(*pBuffer))
    {
        pBuffer++;
        BufferLength--;
    }

    // If we stopped because we ran out of buffer, fail.
    if (BufferLength == 0)
    {
        return NULL;
    }

    pTokenStart = pBuffer;

    // Now skip over the token, until we see either LWS or a CR or LF.
    while (
            ( BufferLength != 0 ) && 
            ( IS_HTTP_HEX(*pBuffer) )
          )
    {
        pBuffer++;
        BufferLength--;
    }

    // See why we stopped.
    if (BufferLength == 0)
    {
        // Ran out of buffer before end of token.
        return NULL;
    }

    // Success. Set the token length and return the start of the token.
    *pTokenLength = DIFF(pBuffer - pTokenStart);
    return pTokenStart;

}   // FindHexToken


/*++

Routine Description:

    Routine to initialize the parse code.

Arguments:


Return Value:


--*/
NTSTATUS
InitializeParser(
    VOID
    )
{
    ULONG               i;
    ULONG               j;
    PHEADER_MAP_ENTRY   pHeaderMap;
    PHEADER_INDEX_ENTRY pHeaderIndex;
    UCHAR               c;

    //
    // Make sure the entire table starts life as zero
    //

    RtlZeroMemory(
            &g_RequestHeaderIndexTable,
            sizeof(g_RequestHeaderIndexTable)
            );
            
    RtlZeroMemory(
            &g_ResponseHeaderIndexTable,
            sizeof(g_ResponseHeaderIndexTable)
            );

    RtlZeroMemory(
            &g_RequestHeaderHintIndexTable,
            sizeof(g_RequestHeaderHintIndexTable)
            );

#if DBG
    //
    // Initialize g_RequestHeaderMap & g_ResponseHeaderMap to 0xFFFFFFFF
    // so that we can catch un-initialized entries.
    //

    RtlFillMemory(
            &g_RequestHeaderMap,
            sizeof(g_RequestHeaderMap),
            0xFF);

    RtlFillMemory(
            &g_ResponseHeaderMap,
            sizeof(g_ResponseHeaderMap),
            0xFF);
#endif

    for (i = 0; i < NUMBER_REQUEST_HEADER_MAP_ENTRIES;i++)
    {
        pHeaderMap = &g_RequestHeaderMapTable[i];

        //
        // Map the header to upper-case.
        //

        for (j = 0 ; j < pHeaderMap->HeaderLength ; j++)
        {
            c = pHeaderMap->Header.HeaderChar[j];

            if ((c >= 'a') && (c <= 'z'))
            {
                pHeaderMap->Header.HeaderChar[j] = c - ('a' - 'A');
            }
        }

        ASSERT(pHeaderMap->pServerHandler != NULL);

        c = pHeaderMap->Header.HeaderChar[0];

        pHeaderIndex = &g_RequestHeaderIndexTable[c - 'A'];

        if (pHeaderIndex->pHeaderMap == NULL)
        {
            pHeaderIndex->pHeaderMap = pHeaderMap;
            pHeaderIndex->Count = 1;
        }
        else
        {
            pHeaderIndex->Count++;
        }

        // Now go through the mask fields for this header map structure and
        // initialize them. We set them to default values first, and then
        // go through the header itself and convert the mask for any
        // non-alphabetic characters.

        for (j = 0; j < MAX_HEADER_LONG_COUNT; j++)
        {
            pHeaderMap->HeaderMask[j] = CREATE_HEADER_MASK(
                                            pHeaderMap->HeaderLength,
                                            sizeof(ULONGLONG) * (j+1)
                                            );
        }

        for (j = 0; j < pHeaderMap->HeaderLength; j++)
        {
            c = pHeaderMap->Header.HeaderChar[j];
            if (c < 'A' || c > 'Z')
            {
                pHeaderMap->HeaderMask[j/sizeof(ULONGLONG)] |=
                    (ULONGLONG)0xff << ((j % sizeof(ULONGLONG)) * (ULONGLONG)8);
            }
        }

        //
        // setup the mapping from header id to map table index
        //

        g_RequestHeaderMap[pHeaderMap->HeaderID] = i;

        //
        // Save the Header Map and first char in the hint table if the entry
        // is part of the hints
        //

        if ((pHeaderMap->HintIndex >= 0)
                && (pHeaderMap->HintIndex < NUMBER_HEADER_HINT_INDICES))
        {

            g_RequestHeaderHintIndexTable[pHeaderMap->HintIndex].pHeaderMap
                = pHeaderMap;
            g_RequestHeaderHintIndexTable[pHeaderMap->HintIndex].c
                = pHeaderMap->Header.HeaderChar[0];

        }
    }

    for (i = 0; i < NUMBER_RESPONSE_HEADER_MAP_ENTRIES;i++)
    {
        pHeaderMap = &g_ResponseHeaderMapTable[i];

        //
        // Map the header to upper-case.
        //

        for (j = 0 ; j < pHeaderMap->HeaderLength ; j++)
        {
            c = pHeaderMap->Header.HeaderChar[j];

            if ((c >= 'a') && (c <= 'z'))
            {
                pHeaderMap->Header.HeaderChar[j] = c - ('a' - 'A');
            }
        }

        ASSERT(pHeaderMap->pClientHandler != NULL);

        c = pHeaderMap->Header.HeaderChar[0];
        pHeaderIndex = &g_ResponseHeaderIndexTable[c - 'A'];

        if (pHeaderIndex->pHeaderMap == NULL)
        {
            pHeaderIndex->pHeaderMap = pHeaderMap;
            pHeaderIndex->Count = 1;
        }
        else
        {
            pHeaderIndex->Count++;
        }

        // Now go through the mask fields for this header map structure and
        // initialize them. We set them to default values first, and then
        // go through the header itself and convert the mask for any
        // non-alphabetic characters.

        for (j = 0; j < MAX_HEADER_LONG_COUNT; j++)
        {
            pHeaderMap->HeaderMask[j] = CREATE_HEADER_MASK(
                                            pHeaderMap->HeaderLength,
                                            sizeof(ULONGLONG) * (j+1)
                                            );
        }

        for (j = 0; j < pHeaderMap->HeaderLength; j++)
        {
            c = pHeaderMap->Header.HeaderChar[j];
            if (c < 'A' || c > 'Z')
            {
                pHeaderMap->HeaderMask[j/sizeof(ULONGLONG)] |=
                    (ULONGLONG)0xff << ((j % sizeof(ULONGLONG)) * (ULONGLONG)8);
            }
        }

        //
        // setup the mapping from header id to map table index
        //

        g_ResponseHeaderMap[pHeaderMap->HeaderID] = i;

    }

#if DBG
    for(i=0; i<HttpHeaderRequestMaximum; i++)
    {
        ASSERT(g_RequestHeaderMap[i] != 0xFFFFFFFF);
    }

    for(i=0; i<HttpHeaderResponseMaximum; i++)
    {
        ASSERT(g_ResponseHeaderMap[i] != 0xFFFFFFFF);
    }
#endif

    return STATUS_SUCCESS;

}   // InitializeParser



/***************************************************************************++

Routine Description:

    Parses the http version from a string. Assumes string begins with "HTTP/".
    Eats leading zeros. Puts resulting version in HTTP_VERSION structure
    passed into function.

Arguments:

    pString         array of chars to parse

    StringLength    number of bytes in pString

    pVersion        where to put parsed version.

Returns:

    Number of bytes parsed out of string. Zero indicates parse failure,
    and no version information was found.  Number of bytes does not include
    trailing linear white space nor CRLF line terminator.

--***************************************************************************/
ULONG
UlpParseHttpVersion(
    PUCHAR pString,
    ULONG  StringLength,
    PHTTP_VERSION pVersion
    )
{
    ULONG   BytesRemaining = StringLength;
    ULONG   NumberLength;
    USHORT  VersionNumber;
C_ASSERT(sizeof(VersionNumber) == sizeof(pVersion->MajorVersion));
C_ASSERT(sizeof(VersionNumber) == sizeof(pVersion->MinorVersion));
    BOOLEAN Done = FALSE;

    ASSERT( pString );
    ASSERT( StringLength > HTTP_PREFIX_SIZE + 1 );
    ASSERT( pVersion );

    pVersion->MajorVersion = 0;
    pVersion->MinorVersion = 0;

    //
    // compare 'HTTP' away
    //
    if ( *(UNALIGNED64 ULONG *)pString == (ULONG) HTTP_PREFIX )
    {
        BytesRemaining -= HTTP_PREFIX_SIZE;
        pString += HTTP_PREFIX_SIZE;
    }
    else
    {
        goto End;
    }

    if ( '/' == *pString )
    {
        BytesRemaining--;
        pString++;
    }
    else
    {
        goto End;
    }

    //
    // Parse major version
    //

    //
    // Skip leading zeros.
    //
    NumberLength = 0;
    while ( (0 != BytesRemaining) && (*pString == ZERO) )
    {
        BytesRemaining--;
        pString++;
        NumberLength++;
    }

    while ( (0 != BytesRemaining) && IS_HTTP_DIGIT(*pString) )
    {
        VersionNumber = pVersion->MajorVersion;

        pVersion->MajorVersion *= 10;
        pVersion->MajorVersion += (*pString - '0');

        // Guard against wrapping around.
        if ( VersionNumber > pVersion->MajorVersion )
        {
            goto End;
        }

        BytesRemaining--;
        pString++;
        NumberLength++;
    }

    // Must disallow version numbers less than 1.0
    if ((0 == pVersion->MajorVersion) ||
        (0 == BytesRemaining) || 
        (0 == NumberLength) )
    {
        goto End;
    }

    //
    // find '.'
    //
    if ( '.' != *pString )
    {
        // Error: No decimal place; bail out.
        goto End;
    }
    else
    {
        BytesRemaining--;
        pString++;
    }

    if ( 0 == BytesRemaining || !IS_HTTP_DIGIT(*pString) )
    {
        goto End;
    }

    //
    // Parse minor version
    //

    //
    // Skip leading zeros.
    //
    NumberLength = 0;
    while ( (0 != BytesRemaining) && (*pString == ZERO) )
    {
        BytesRemaining--;
        pString++;
        NumberLength++;
    }

    while ( (0 != BytesRemaining) && IS_HTTP_DIGIT(*pString) )
    {
        VersionNumber = pVersion->MinorVersion;

        pVersion->MinorVersion *= 10;
        pVersion->MinorVersion += (*pString - '0');

        // Guard against wrapping around.
        if ( VersionNumber > pVersion->MinorVersion )
        {
            goto End;
        }

        BytesRemaining--;
        pString++;
        NumberLength++;
    }

    if ( 0 == NumberLength )
    {
        goto End;
    }

    Done = TRUE;


 End:
    if (!Done)
    {
        return 0;
    }
    else
    {
        UlTrace(PARSER, (
            "http!UlpParseHttpVersion: found version HTTP/%hu.%hu\n",
            pVersion->MajorVersion,
            pVersion->MinorVersion
            ));

        return (StringLength - BytesRemaining);
    }

} // UlpParseHttpVersion
 
/****************************************************************************++

Routine Description:

    A utility routine, to find the terminating CRLF or LFLF of a header's
    field content, if present. This routine does not perform line folding 
    (hence read-only) but returns an error if it realizes that it has to do
    so. 

    The user is supposed to allocate memory & call FindHeaderEnd to do the real
    folding.

    NOTE: NOTE: If this function is fixed, the corresponding FindHeaderEnd
                also needs to be fixed.
    
Arguments:

    pHeader         - Header whose end is to be found.
    HeaderLength    - Length of data pointed to by pHeader.
    pBytesTaken     - Where to return the total number of bytes traversed.
                      We return 0 if we couldn't locate the end of the header

Return Value:

    STATUS_SUCCESS                  - if no parsing errors were encountered 
                                      (including not being able to locate the 
                                       end of the header)
    STATUS_INVALID_DEVICE_REQUEST   - Illegal response
    STATUS_MORE_PROCESSING_REQUIRED - Need to do header folding

--****************************************************************************/
NTSTATUS
FindHeaderEndReadOnly(
    IN  PUCHAR                  pHeader,
    IN  ULONG                   HeaderLength,
    OUT PULONG                  pBytesTaken
    )
{
    NTSTATUS            Status;
    UCHAR               CurrentChar;
    ULONG               CurrentOffset;
    HFC_PARSER_STATE    ParserState, OldState;
    ULONG               QuotedStringLen;

    ParserState = HFCStart;
    CurrentOffset = 0;

    //
    // The field-content of a header contains *TEXT or combinations
    // token, separators and quoted-string. It is terminated by a CRLF.
    //
    // Folding - if one or more LWS follows a CRLF, replace the entire
    //   sequence with a single SP, and treat this as a continuation of
    //   header field content.
    //
    for (/* NOTHING */; CurrentOffset < HeaderLength; CurrentOffset++)
    {
        CurrentChar = *(pHeader + CurrentOffset);
        OldState = ParserState;
        switch (ParserState)
        {
            case HFCStart:
                if (CurrentChar == CR)
                {
                    ParserState = HFCSeenCR;
                }
                else if (CurrentChar == LF)
                {
                    ParserState = HFCSeenLF;
                }
                else if (CurrentChar == DOUBLE_QUOTE)
                {
                    ParserState = HFCInQuotedString;
                }
                else if (!IS_HTTP_CTL(CurrentChar) || 
                          IS_HTTP_WS_TOKEN(CurrentChar))
                {
                    ;
                }
                else
                {
                    UlTraceError(PARSER, (
                            "FindHeaderEndReadOnly: ERROR parsing char (%x) at "
                            "Offset %d in state %d\n",
                            CurrentChar,
                            CurrentOffset,
                            OldState
                            ));

                    return STATUS_INVALID_DEVICE_REQUEST;
                }
                break;
            
            case HFCSeenCR:
                if (CurrentChar == LF)
                {
                    ParserState = HFCSeenCRLF;
                }
                else
                {
                    UlTraceError(PARSER, (
                            "FindHeaderEndReadOnly: ERROR parsing char (%x) at "
                            "Offset %d in state %d\n",
                            CurrentChar,
                            CurrentOffset,
                            OldState
                            ));

                    return STATUS_INVALID_DEVICE_REQUEST;
                }
                break;
            
            case HFCSeenLF:
                if (CurrentChar == LF)
                {
                    ParserState = HFCSeenCRLF; // LFLF considered = CRLF
                }
                else
                {
                    UlTraceError(PARSER, (
                            "FindHeaderEndReadOnly: ERROR parsing char (%x) at "
                            "Offset %d in state %d\n",
                            CurrentChar,
                            CurrentOffset,
                            OldState
                            ));

                    return STATUS_INVALID_DEVICE_REQUEST;
                }
                break;

            case HFCSeenCRLF:
                if (IS_HTTP_LWS(CurrentChar))
                {
                    // We have to fold the header value. We can't use the 
                    // TDI indicated buffers for this, because we'll have
                    // to change the indicated data.

                    return STATUS_MORE_PROCESSING_REQUIRED;
                }
                else
                {
                    // Found a non-continuation char immediately
                    // following CRLF; must be end of header content.

                    //
                    // All done!
                    //
            
                    *pBytesTaken = CurrentOffset;
                    return STATUS_SUCCESS;
                }
            
                break;
                        
            case HFCInQuotedString:

                Status = ParseQuotedString(pHeader + CurrentOffset,
                                           HeaderLength - CurrentOffset,
                                           NULL,
                                           &QuotedStringLen);

                if (Status == STATUS_SUCCESS)
                {
                    if (QuotedStringLen == 0)
                    {
                        //
                        // Ran out of header buffer while parsing quotes 
                        // string.  Setting QuotedStringLen to whatever
                        // available will get us out of the for loop.
                        //

                        QuotedStringLen = HeaderLength - CurrentOffset;
                    }
                    else
                    {
                        // Found a quoted string.  Change the parser state.
                        ParserState = HFCStart;
                    }

                    //
                    // Increment the offset by the length of quoted string-1.
                    // One less because the for loop will increment it by 1.
                    //

                    CurrentOffset += (QuotedStringLen - 1);
                }
                else if (Status == STATUS_QDSTRING_TERMINATED_BY_CRLF)
                {
                    //
                    // Reparse the current character as an HTTP Char
                    //

                    ParserState = HFCStart;
                    
                    //
                    // Decrement the offset because the for loop will 
                    // increment it by 1.
                    //

                    CurrentOffset--;
                }
                else if (Status == STATUS_MORE_PROCESSING_REQUIRED)
                {
                    //
                    // The quoted string is folded.  Let the caller know.
                    //

                    return Status;
                }
                else
                {
                    UlTraceError(PARSER, (
                            "FindHeaderEndReadOnly: ERROR parsing char (%x) at "
                            "Offset %d in state %d\n",
                            CurrentChar,
                            CurrentOffset,
                            OldState
                            ));

                    return STATUS_INVALID_DEVICE_REQUEST;
                }

                break;
            
            default:
                ASSERT(!"Invalid ParserState value!");
                break;
        }

    }

    //
    // Did not find the end of a header, let's get more buffer.
    //

    *pBytesTaken = 0;
    return STATUS_SUCCESS;

} // FindHeaderEndReadOnly

/****************************************************************************++

Routine Description:

    A utility routine, to find the terminating CRLF or LFLF of a header's
    field content, if present. This routine also performs line folding,
    which may "compress" the content. We don't actually shrink the length
    of the buffer, but simply move the content up, and fill up extra bytes
    at the end with spaces.

    Example: "<CR><LF><SP><TAB><SP>Field<CR><LF><SP>Content<SP><CR><LF>" becomes
             "<SP>Field<SP>Content<SP><SP><SP><SP><SP><SP><SP><CR><LF>"
    
    NOTE: NOTE: If this function is fixed, the corresponding 
                FindHeaderEndReadOnly also needs to be fixed.

Arguments:

    pHeader         - Header whose end is to be found.
    HeaderLength    - Length of data pointed to by pHeader.
    pBytesTaken     - Where to return the total number of bytes traversed.
                      We return 0 if we couldn't locate the end of the header

Return Value:

    STATUS_SUCCESS if no parsing errors were encountered (including not
    being able to locate the end of the header),
    STATUS_INVALID_DATA_REQUEST otherwise.

--****************************************************************************/
NTSTATUS
FindHeaderEnd(
    IN  PUCHAR                  pHeader,
    IN  ULONG                   HeaderLength,
    OUT PULONG                  pBytesTaken
    )
{
    UCHAR               CurrentChar;
    PUCHAR              pDest;
    ULONG               CurrentOffset;
    HFC_PARSER_STATE    ParserState, OldState;
    ULONG               QuotedStringLen;
    NTSTATUS            Status;

    ParserState = HFCStart;
    CurrentOffset = 0;
    pDest = pHeader + CurrentOffset;

    //
    // The field-content of a header contains *TEXT or combinations
    // token, separators and quoted-string. It is terminated by a CRLF.
    //
    // Folding - if one or more LWS follows a CRLF, replace the entire
    //   sequence with a single SP, and treat this as a continuation of
    //   header field content.
    //
    for (/* NOTHING */; CurrentOffset < HeaderLength; CurrentOffset++)
    {
        CurrentChar = *(pHeader + CurrentOffset);
        OldState = ParserState;
        switch (ParserState)
        {
            case HFCFolding:
                if (IS_HTTP_LWS(CurrentChar))
                {
                    // Do nothing - eat this char.
                    break;
                }

                // Else fall through.

                ParserState = HFCStart;

            case HFCStart:
                if (CurrentChar == CR)
                {
                    ParserState = HFCSeenCR;
                }
                else if (CurrentChar == LF)
                {
                    ParserState = HFCSeenLF;
                }
                else if (CurrentChar == DOUBLE_QUOTE)
                {
                    *pDest++ = CurrentChar;
                    ParserState = HFCInQuotedString;
                }
                else if (!IS_HTTP_CTL(CurrentChar) || 
                          IS_HTTP_WS_TOKEN(CurrentChar))
                {
                    *pDest++ = CurrentChar;
                }
                else
                {
                    UlTraceError(PARSER, (
                            "FindHeaderEnd: ERROR parsing char (%x) at "
                            "Offset %d in state %d\n",
                            CurrentChar,
                            CurrentOffset,
                            OldState
                            ));

                    return STATUS_INVALID_DEVICE_REQUEST;
                }
                break;
            
            case HFCSeenCR:
                if (CurrentChar == LF)
                {
                    ParserState = HFCSeenCRLF;
                }
                else
                {
                    UlTraceError(PARSER, (
                            "FindHeaderEnd: ERROR parsing char (%x) at "
                            "Offset %d in state %d\n",
                            CurrentChar,
                            CurrentOffset,
                            OldState
                            ));

                    return STATUS_INVALID_DEVICE_REQUEST;
                }
                break;
            
            case HFCSeenLF:
                if (CurrentChar == LF)
                {
                    ParserState = HFCSeenCRLF; // LFLF considered = CRLF
                }
                else
                {
                    UlTraceError(PARSER, (
                            "FindHeaderEnd: ERROR parsing char (%x) at "
                            "Offset %d in state %d\n",
                            CurrentChar,
                            CurrentOffset,
                            OldState
                            ));

                    return STATUS_INVALID_DEVICE_REQUEST;
                }
                break;

            case HFCSeenCRLF:
                if (IS_HTTP_LWS(CurrentChar))
                {
                    //
                    // Replace one or more LWS following CRLF
                    // with a single SP.
                    //
                    *pDest++ = SP;
                    ParserState = HFCFolding;
                }
                else
                {
                    // Found a non-continuation char immediately
                    // following CRLF; must be end of header content.

                    //
                    // Fill up any trailing bytes with spaces. This is to 
                    // account for any compression occurring due to folding.
                    //

                    ASSERT(CurrentOffset >= CRLF_SIZE);

                    while (pDest < (pHeader + CurrentOffset - CRLF_SIZE))
                    {
                        *pDest++ = SP;
                    }

                    //
                    // Calling routines expect to find
                    // one terminating CRLF for the header.
                    // Attach it back.
                    //
                    *pDest++ = CR;
                    *pDest++ = LF;

                    //
                    // All done!
                    //

                    *pBytesTaken = CurrentOffset;
                    return STATUS_SUCCESS;
                }
                break;

            case HFCInQuotedString:

                Status = ParseQuotedString(pHeader + CurrentOffset,
                                           HeaderLength - CurrentOffset,
                                           pDest,
                                           &QuotedStringLen);

                if (Status == STATUS_SUCCESS)
                {
                    if (QuotedStringLen == 0)
                    {
                        //
                        // Ran out of header buffer while parsing quoted 
                        // string.  Setting QuotedStringLen to whatever
                        // available will get us out of the for loop.
                        //

                        QuotedStringLen = HeaderLength - CurrentOffset;
                    }
                    else
                    {
                        // Found a quoted string.  Change the parser state.
                        ParserState = HFCStart;
                    }

                    //
                    // Skip the destination pointer by the length of quoted
                    // string.
                    //

                    pDest += QuotedStringLen;

                    //
                    // Increment the offset by the length of quoted string-1.
                    // One less because the for loop will increment it by 1.
                    //

                    CurrentOffset += (QuotedStringLen - 1);
                }
                else if (Status == STATUS_QDSTRING_TERMINATED_BY_CRLF)
                {
                    //
                    // Reparse the current character as an HTTP Char
                    //

                    ParserState = HFCStart;

                    //
                    // Decrement the offset because the for loop will 
                    // increment it by 1.
                    //

                    CurrentOffset--;
                }
                else
                {
                    UlTraceError(PARSER, (
                            "FindHeaderEnd: ERROR parsing char (%x) at "
                            "Offset %d in state %d\n",
                            CurrentChar,
                            CurrentOffset,
                            OldState
                            ));

                    return STATUS_INVALID_DEVICE_REQUEST;
                }

                break;

            default:
                ASSERT(!"Invalid ParserState value!");
                break;
        }

    }

    //
    // Did not find the end of a header, let's get more buffer.
    //

    *pBytesTaken = 0;
    return STATUS_SUCCESS;

} // FindHeaderEnd



/*++

Routine Description:

    A wrapper around FindHeaderEnd that enforces a maximum length
    for request headers.

Arguments:

    pRequest        - The request object
    pHeader         - Header whose end is to be found.
    HeaderLength    - Length of data pointed to by pHeader.
    pBytesTaken     - Where to return the total number of bytes traversed.
                      We return 0 if we couldn't locate the end of the header

Return Value:

    As FindHeaderEnd. Returns STATUS_INVALID_DEVICE_REQUEST if too long.

--*/
NTSTATUS
FindRequestHeaderEnd(
    IN  PUL_INTERNAL_REQUEST    pRequest,
    IN  PUCHAR                  pHeader,
    IN  ULONG                   HeaderLength,
    OUT PULONG                  pBytesTaken
    )
{
    NTSTATUS Status = FindHeaderEnd(pHeader, HeaderLength, pBytesTaken);

    if (NT_SUCCESS(Status))
    {
        if (*pBytesTaken > ANSI_STRING_MAX_CHAR_LEN)
        {
            UlTraceError(PARSER, (
                        "FindRequestHeaderEnd(pRequest = %p) "
                        "Header too long: %lu\n",
                        pRequest,
                        *pBytesTaken
                        ));

            UlSetErrorCode(pRequest, UlErrorHeader, NULL);
            Status = STATUS_INVALID_DEVICE_REQUEST;
        }
    }

    return Status;

} // FindHeaderEndMax


/*++

Routine Description:

    A utility routine, to find the terminating CRLF or LFLF of a
    chunk header.

    NOTE: This skips any chunk-extension fields, if present. It is
    OK to ignore any chunk-extension extensions that we don't understand,
    and the current code understands none.

    TODO: modify the API to pass up chunk-extension fields to the user.

Arguments:

    pHeader         - Header whose end is to be found.
    HeaderLength    - Length of data pointed to by pHeader.
    TokenLength     - Where to return the length of the token.

Return Value:

    Length of the header, or 0 if we couldn't find the end.

--*/
NTSTATUS
FindChunkHeaderEnd(
    IN  PUCHAR                  pHeader,
    IN  ULONG                   HeaderLength,
    OUT PULONG                  pBytesTaken
    )
{
    UCHAR           CurrentChar;
    ULONG           CurrentOffset;
    ULONG           ChunkExtNameLength = 0;
    ULONG           ChunkExtValLength = 0;
    BOOLEAN         SeenSingleCharQuote;
    CH_PARSER_STATE ParserState;
    ULONG           QuotedStringLen;
    NTSTATUS        Status;

    CurrentOffset = 0;
    ParserState = CHStart;
    SeenSingleCharQuote = FALSE;

    //
    // While we still have data, loop through looking for the end of
    // the chunk header.
    //
    // The following loop implements parsing for:
    // chunk-extension= *( ";" chunk-ext-name [ "=" chunk-ext-val ] )
    //

    for (; CurrentOffset < HeaderLength; CurrentOffset++)
    {
        CurrentChar = *(pHeader + CurrentOffset);
        switch (ParserState)
        {
            case CHStart:
                if (CurrentChar == CR || CurrentChar == LF)
                {
                    ParserState = CHSeenCR;
                }
                else if (CurrentChar == SEMI_COLON)
                {
                    ParserState = CHInChunkExtName;
                    ChunkExtNameLength = 0;
                }
                else if (IS_HTTP_LWS(CurrentChar))
                {
                    // Ignore leading linear white spaces.
                    ;
                }
                else
                {
                    ParserState = CHError;
                }
                break;
            case CHSeenCR:
                if (CurrentChar == LF)
                {
                    ParserState = CHSuccess;
                }
                else
                {
                    ParserState = CHError;
                }
                break;
            case CHInChunkExtName:
                if (CurrentChar == EQUALS)
                {
                    ParserState = CHSeenChunkExtNameAndEquals;
                }
                else if (CurrentChar == SEMI_COLON)
                {
                    ChunkExtNameLength = 0;
                    ParserState = CHInChunkExtName;
                }
                else if (CurrentChar == CR ||
                         CurrentChar == LF)
                {
                    ParserState = CHSeenCR;
                }
                else if (IS_HTTP_TOKEN(CurrentChar))
                {
                    ChunkExtNameLength++;
                }
                else
                {
                    ParserState = CHError;
                }
                break;
            case CHSeenChunkExtNameAndEquals:
                if (CurrentChar == DOUBLE_QUOTE)
                {
                    ChunkExtValLength = 0;
                    ParserState = CHInChunkExtValQuotedString;
                }
                else if (IS_HTTP_TOKEN(CurrentChar))
                {
                    ChunkExtValLength = 1; // including this one
                    ParserState = CHInChunkExtValToken;
                }
                else
                {
                    ParserState = CHError;
                }
                break;
            case CHInChunkExtValToken:
                if (IS_HTTP_TOKEN(CurrentChar))
                {
                    ChunkExtValLength++;
                }
                else if (CurrentChar == SEMI_COLON)
                {
                    ParserState = CHInChunkExtName;
                    ChunkExtNameLength = 0;
                }
                else if (CurrentChar == CR)
                {
                    ParserState = CHSeenCR;
                }
                else
                {
                    ParserState = CHError;
                }
                break;
            case CHInChunkExtValQuotedString:
                Status = ParseQuotedString(pHeader + CurrentOffset,
                                           HeaderLength - CurrentOffset,
                                           NULL,
                                           &QuotedStringLen);

                if (Status == STATUS_SUCCESS ||
                    Status == STATUS_MORE_PROCESSING_REQUIRED)
                {
                    if (QuotedStringLen == 0)
                    {
                        //
                        // Ran out of header buffer while parsing quotes 
                        // string.  Setting QuotedStringLen to whatever
                        // available will get us out of the for loop.
                        //

                        QuotedStringLen = HeaderLength - CurrentOffset;
                    }
                    else
                    {
                        // Found a quoted string.  Change the parser state.
                        ParserState = CHSeenChunkExtValQuotedStringTerminator;
                    }

                    // Do not count the closing <">.
                    ChunkExtValLength = QuotedStringLen - 1;

                    // One less because the for loop will increment it by 1.
                    CurrentOffset += (QuotedStringLen - 1);
                }
                else
                {
                    ParserState = CHError;
                }
                break;

            case CHSeenChunkExtValQuotedStringTerminator:
                if (CurrentChar == SEMI_COLON)
                {
                    ParserState = CHInChunkExtName;
                }
                else if (CurrentChar == CR)
                {
                    ParserState = CHSeenCR;
                }
                else
                {
                    ParserState = CHError;
                }
                break;
            case CHSuccess:
                break;
            case CHError:
                break;
            default:
                ASSERT(!"Invalid CH parser state!");
                break;
        }

        if ((ParserState == CHError) ||
            (ParserState == CHSuccess))
        {
            break;
        }
    }

    if (ParserState == CHSuccess)
    {
        ASSERT(CurrentOffset < HeaderLength);

        //
        // All done!
        //

        *pBytesTaken = CurrentOffset + 1;
        return STATUS_SUCCESS;
    }
    else if (ParserState == CHError)
    {
        *pBytesTaken = 0;
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    // Else, more data is required to find the end.
    //

    *pBytesTaken = 0;
    return STATUS_SUCCESS;
}

/****************************************************************************++

Routine Description:

    A utility routine, to parse the chunk length of a chunked response.

Arguments:

    FirstChunkParsed - Whether we are in the first chunk or a subsequent chunk
    pBuffer          - pointer to the indicated data
    BufferLength     - Length of data pointed to by pBuffer.
    pBytesTaken      - Bytes consumed by this routine.
    pChunkLength     - Parsed Chunk length

Return Value:

    Length of the header, or 0 if we couldn't find the end.

--****************************************************************************/
NTSTATUS
ParseChunkLength(
    IN  ULONG       FirstChunkParsed,
    IN  PUCHAR      pBuffer,
    IN  ULONG       BufferLength,
    OUT PULONG      pBytesTaken,
    OUT PULONGLONG  pChunkLength
    )
{
    NTSTATUS Status;
    PUCHAR  pToken;
    ULONG   TokenLength;
    ULONG   BytesTaken;
    ULONG   TotalBytesTaken = 0;
    ULONG   HeaderLength;

    ASSERT(pBytesTaken != NULL);
    ASSERT(pChunkLength != NULL);

    *pBytesTaken = 0;

    //
    // 2 cases:
    //
    //  1) the first chunk where the length follows the headers
    //  2) subsequent chunks where the length follows a previous chunk
    //
    // in case 1 pBuffer will point straight to the chunk length.
    //
    // in case 2 pBuffer will point to the CRLF that terminated the previous
    // chunk, this needs to be consumed, skipped, and then the chunk length
    // read.

    //
    // if we are case 2 (see above)
    //

    if (FirstChunkParsed == 1)
    {
        //
        // make sure there is enough space first
        //

        if (BufferLength < CRLF_SIZE)
        {
            Status = STATUS_MORE_PROCESSING_REQUIRED;
            goto end;
        }

        //
        // now it better be a terminator
        //

        if (*(UNALIGNED64 USHORT *)pBuffer != CRLF &&
            *(UNALIGNED64 USHORT *)pBuffer != LFLF)
        {
            UlTraceError(PARSER, (
                "http!ParseChunkLength ERROR: No CRLF at the end of "
                "chunk-data\n"));

            Status = STATUS_INVALID_DEVICE_REQUEST;
            goto end;
        }

        //
        // update our book-keeping
        //

        pBuffer += CRLF_SIZE;
        TotalBytesTaken += CRLF_SIZE;
        BufferLength -= CRLF_SIZE;
    }

    pToken = FindHexToken(pBuffer, BufferLength, &TokenLength);

    if (pToken == NULL ||
        ((BufferLength - TokenLength) < CRLF_SIZE))
    {
        //
        // not enough buffer
        //

        Status = STATUS_MORE_PROCESSING_REQUIRED;
        goto end;

    }

    //
    // Was there any token ?
    //

    if (TokenLength == 0)
    {
        UlTraceError(PARSER, ("[ParseChunkLength]: No length!\n"));

        Status = STATUS_INVALID_DEVICE_REQUEST;
        goto end;
    }

    //
    // Add the bytes consumed by FindHexToken
    // (the token bytes plus preceding bytes)
    //

    TotalBytesTaken += DIFF((pToken + TokenLength) - pBuffer);

    //
    // and find the end
    //

    HeaderLength = BufferLength - DIFF((pToken + TokenLength) - pBuffer);

    Status = FindChunkHeaderEnd(
                    pToken + TokenLength,
                    HeaderLength,
                    &BytesTaken
                    );

    if (NT_SUCCESS(Status) == FALSE)
    {
        UlTraceError(PARSER, ("[ParseChunkLength]: FindChunkHeaderEnd failed!\n"));
        goto end;
    }

    if (BytesTaken == 0)
    {
        Status = STATUS_MORE_PROCESSING_REQUIRED;
        goto end;
    }

    TotalBytesTaken += BytesTaken;

    //
    // now update the HTTP_REQUEST
    //

    Status = UlAnsiToULongLong(
                    pToken,
                    (USHORT) TokenLength,
                    16,                             // Base
                    pChunkLength
                    );

    //
    // Did the number conversion fail ?
    //

    if (NT_SUCCESS(Status) == FALSE)
    {
        UlTraceError(PARSER, ("[ParseChunkLength]: Failed number conversion \n"));
        goto end;
    }

    //
    // all done, return the bytes consumed
    //
    *pBytesTaken = TotalBytesTaken;

end:

    RETURN(Status);

}   // ParseChunkLength


/*++

Routine Description:

    This routine parses a quoted string.  The grammar of quoted string is

    quoted-string  = ( <"> *(qdtext | quoted-pair ) <"> )
    qdtext         = <any TEXT except <">>
    quoted-pair    = "\" CHAR

    TEXT           = <any OCTET except CTLs, but including LWS>
    CHAR           = <any US-ASCII character (octets 0 - 127)>
    LWS            = [CRLF] 1*( SP | HT )

    Upon seeing a header folding, this routine overwrites the folding CRLF
    with SPSP and does not replace LWS with a single SP.  (This is done 
    to handle read only buffer cases.)

    STATUS_QDSTRING_TERMINATED_BY_CRLF is *not* a success code!  It is up
    to the caller to handle the input buffer.

Arguments:

    pInput       - Supplies pointer to input buffer.  pInput must point to
                   the first char after the opening <"> char.
    pInputLength - Supplies the length of the input buffer in bytes.
    pOutput      - Supplied pointer where output will be written.
                   (Can be same as pInput.)
    pBytesTaken  - Returns the length of the quoted string in bytes.
                   (It includs the closing double quote char.)

Return Value:

    STATUS_INVALID_PARAMETER           - Input is malformed.
    STATUS_MORE_PROCESSING_REQUIRED    - Same as STATUS_SUCCESS except it is 
                                         returned when pOutput is NULL.
    STATUS_QDSTRING_TERMINATED_BY_CRLF - Indicates that the buffer contained
                                         an unmatched quote and was terminated
                                         by a CRLF
    STATUS_SUCCESS                     - Either parsed a quoted string 
                                         successfully (when *pBytesTaken != 0)
                                         or more data is required to proceed
                                         (when *pBytesTaken == 0).
--*/
NTSTATUS
ParseQuotedString(
    IN  PUCHAR   pInput,
    IN  ULONG    InputLength,
    IN  PUCHAR   pOutput,       OPTIONAL
    OUT PULONG   pBytesTaken
    )
{
    ULONG           CurrentOffset;
    UCHAR           CurrentChar;
    QS_PARSER_STATE ParserState;
    BOOLEAN         bFolded;

    // Sanity check.
    ASSERT(pInput && InputLength);
    ASSERT(pBytesTaken);

    UlTrace(PARSER, (
        "ParseQuotedString %.*s\n",
        InputLength,
        pInput
        ));

    // Initialize output argument.
    *pBytesTaken = 0;

    // Initially, there is no folding.
    bFolded = FALSE;

    // Initialize parser state.
    ParserState = QSInString;

    //
    // Loop through all input chars.
    //

    for (CurrentOffset = 0; CurrentOffset < InputLength; CurrentOffset++)
    {
        static PCHAR StateName[] =
        {
            "QSInString",
            "QSSeenBackSlash",
            "QSSeenCR",
            "QSSeenLF",
            "QSSeenCRLF",
            "QSFolding",
            "Default"
        };
    
        CurrentChar = pInput[CurrentOffset];

        if (ARGUMENT_PRESENT(pOutput))
        {
            pOutput[CurrentOffset] = CurrentChar;
        }

        UlTraceVerbose(PARSER, (
            "\t%-15.15s [0x%02X] '%c'\n",
            StateName[ParserState],
            CurrentChar,
            ((IS_HTTP_PRINT(CurrentChar)) ? CurrentChar : '?')
            ));
            
        switch(ParserState)
        {
        case QSFolding:
            if (IS_HTTP_LWS(CurrentChar))
            {
                // Skip LWS.
                break;
            }

            // Fall through.
            ParserState = QSInString;

        case QSInString:
            if (CurrentChar == DOUBLE_QUOTE)
            {
                //
                // We are done parsing!  Update the bytes consumed.
                //

                *pBytesTaken = CurrentOffset + 1;

                ASSERT(*pBytesTaken <= InputLength);

                //
                // If the string was folded and the input was readonly,
                // let the caller know that the string was folded.
                //

                if (ARGUMENT_PRESENT(pOutput) == FALSE && bFolded == TRUE)
                {
                    return STATUS_MORE_PROCESSING_REQUIRED;
                }

                return STATUS_SUCCESS;
            }
            else if (CurrentChar == BACK_SLASH)
            {
                ParserState = QSSeenBackSlash;
            }
            else if (CurrentChar == CR)
            {
                ParserState = QSSeenCR;
            }
            else if (CurrentChar == LF)
            {
                ParserState = QSSeenLF;
            }
            else if (!IS_HTTP_CTL(CurrentChar) || IS_HTTP_LWS(CurrentChar))
            {
                ;
            }
            else
            {
                return STATUS_INVALID_PARAMETER;
            }
            break;

        case QSSeenCR:
            if (CurrentChar == LF)
            {
                ParserState = QSSeenCRLF;
            }
            else
            {
                return STATUS_INVALID_PARAMETER;
            }
            break;

        case QSSeenLF:
            if (CurrentChar == LF)
            {
                ParserState = QSSeenCRLF;
                break;
            }
            
            if (!IS_HTTP_LWS(CurrentChar) &&
                (CurrentOffset >= 2) &&
                ((pInput[CurrentOffset-2] == CR) ||
                    (pInput[CurrentOffset-2] == LF)))
            {
                // The only way to enter this block is if the
                // first character of a CRLF or LFLF pair is
                // preceded by a '\' effectively escape encoding
                // the first character.
            
                UlTraceVerbose(PARSER, (
                    "ParseQuotedString: Unmatched Quote 0x%02X 0x%02X 0x%02X\n",
                    pInput[CurrentOffset-2],
                    pInput[CurrentOffset-1],
                    pInput[CurrentOffset]
                    ));

                // Allow single double quote in field value.
                // Field value now ends immediately prior to CRLF.

                *pBytesTaken = CurrentOffset - 2;

                ASSERT(*pBytesTaken <= InputLength);
                ASSERT(pInput[CurrentOffset-1] == LF);
                ASSERT(CurrentOffset > 2);
                ASSERT(pInput[CurrentOffset-3] == BACK_SLASH);

                return STATUS_QDSTRING_TERMINATED_BY_CRLF;
            }

            return STATUS_INVALID_PARAMETER;
            break;

        case QSSeenCRLF:
            if (IS_HTTP_LWS(CurrentChar))
            {
                bFolded = TRUE;
                ParserState = QSFolding;

                if (ARGUMENT_PRESENT(pOutput))
                {
                    //
                    // Overwrite prior CRLF with SPSP.
                    //

                    ASSERT(CurrentOffset >= 2);
                    ASSERT((pOutput[CurrentOffset-2] == CR) ||
                           (pOutput[CurrentOffset-2] == LF));
                    ASSERT(pOutput[CurrentOffset-1] == LF);

                    pOutput[CurrentOffset-2] = SP;
                    pOutput[CurrentOffset-1] = SP;
                }
            }
            else
            {
                UlTraceVerbose(PARSER, (
                    "ParseQuotedString: Unmatched Quote 0x%02X 0x%02X 0x%02X\n",
                    pInput[CurrentOffset-2],
                    pInput[CurrentOffset-1],
                    pInput[CurrentOffset]
                    ));

                // Allow single double quote in field value.
                // Field value now ends immediately prior to CRLF.  
                
                *pBytesTaken = CurrentOffset - 2;

                ASSERT(*pBytesTaken <= InputLength);
                ASSERT(CurrentOffset >= 2);
                ASSERT(pInput[CurrentOffset-1] == LF);

                return STATUS_QDSTRING_TERMINATED_BY_CRLF;
            }
            break;

        case QSSeenBackSlash:
            // Accept any CHAR in this state.
            if (IS_HTTP_CHAR(CurrentChar))
            {
                ParserState = QSInString;
            }
            else
            {
                return STATUS_INVALID_PARAMETER;
            }
            break;

        default:
            ASSERT(!"ParseQuotedString: Invalid parser state!");
            break;
        }
    }

    // We ran out of data to parse, get more.
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\pplasl.c ===
/*++

Copyright (c) 1999-2002 Microsoft Corporation

Module Name:

    pplasl.c

Abstract:

    This file contains the implementation of a per-processor lookaside
    list manager.

Author:

    Shaun Cox (shaunco) 25-Oct-1999

--*/

#include "precomp.h"

HANDLE
PplCreatePool(
    IN PALLOCATE_FUNCTION Allocate,
    IN PFREE_FUNCTION Free,
    IN ULONG Flags,
    IN SIZE_T Size,
    IN ULONG Tag,
    IN USHORT Depth
    )
{
    HANDLE                      PoolHandle;
    SIZE_T                      PoolSize;
    CLONG                       NumberLookasideLists;
    CLONG                       i;
    PUL_NPAGED_LOOKASIDE_LIST   Lookaside;

    // Allocate room for 1 lookaside list per processor plus 1 extra
    // lookaside list for overflow.  Only allocate 1 lookaside list if
    // we're on a single processor machine.
    //
    NumberLookasideLists = g_UlNumberOfProcessors;
    if (g_UlNumberOfProcessors > 1)
    {
        NumberLookasideLists++;
    }

    PoolSize = sizeof(UL_NPAGED_LOOKASIDE_LIST) * NumberLookasideLists;

    PoolHandle = UL_ALLOCATE_POOL(NonPagedPool, PoolSize, Tag);

    if (PoolHandle)
    {
        for (i = 0, Lookaside = (PUL_NPAGED_LOOKASIDE_LIST)PoolHandle;
             i < NumberLookasideLists;
             i++, Lookaside++)
        {
            ExInitializeNPagedLookasideList(
                &Lookaside->List,
                Allocate,
                Free,
                Flags,
                Size,
                Tag,
                Depth);

            // ExInitializeNPagedLookasideList doesn't really set the
            // maximum depth to Depth, so we'll do it here.
            //
            if (Depth != 0)
            {
                Lookaside->List.L.MaximumDepth = Depth;
            }
        }
    }

    return PoolHandle;
}

VOID
PplDestroyPool(
    IN HANDLE   PoolHandle,
    IN ULONG    Tag
    )
{
    CLONG                       NumberLookasideLists;
    CLONG                       i;
    PUL_NPAGED_LOOKASIDE_LIST   Lookaside;

#if !DBG
    UNREFERENCED_PARAMETER(Tag);
#endif

    if (!PoolHandle)
    {
        return;
    }

    NumberLookasideLists = g_UlNumberOfProcessors;
    if (g_UlNumberOfProcessors > 1)
    {
        NumberLookasideLists++;
    }

    for (i = 0, Lookaside = (PUL_NPAGED_LOOKASIDE_LIST)PoolHandle;
         i < NumberLookasideLists;
         i++, Lookaside++)
    {
        ExDeleteNPagedLookasideList(&Lookaside->List);
    }

    UL_FREE_POOL(PoolHandle, Tag);
}

HANDLE
PpslCreatePool(
    IN ULONG  Tag,
    IN USHORT MaxDepth,
    IN USHORT MinDepth
    )
{
    PPER_PROC_SLISTS    pPPSList;
    HANDLE              PoolHandle;
    SIZE_T              PoolSize;
    CLONG               NumberSLists;
    CLONG               i;

    NumberSLists = g_UlNumberOfProcessors + 1;
    PoolSize = sizeof(PER_PROC_SLISTS) * NumberSLists;
    PoolHandle = UL_ALLOCATE_POOL(NonPagedPool, PoolSize, Tag);

    if (PoolHandle)
    {
        for (i = 0; i < NumberSLists; i++)
        {
            pPPSList = PER_PROC_SLIST(PoolHandle, i);
            ExInitializeSListHead(&(pPPSList->SL));

            pPPSList->MaxDepth          = MaxDepth;
            pPPSList->MinDepth          = MinDepth;
            pPPSList->Delta             = 0;
            pPPSList->EntriesServed     = 0;
            pPPSList->PrevEntriesServed = 0;

            #if DBG
            pPPSList->TotalServed       = 0;
            #endif            
        }        
    }

    return PoolHandle;
}

VOID
PpslDestroyPool(
    IN HANDLE   PoolHandle,
    IN ULONG    Tag
    )
{
#if !DBG
    UNREFERENCED_PARAMETER(Tag);
#endif

    if (!PoolHandle)
    {
        return;
    }

    UL_FREE_POOL(PoolHandle, Tag);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\pplasl.h ===
/*++

Copyright (c) 1999-2002 Microsoft Corporation

Module Name:

    pplasl.h

Abstract:

    This file contains definitions and function prototypes of a per-processor
    lookaside list manager.

Author:

    Shaun Cox (shaunco) 25-Oct-1999

--*/

#ifndef _PPLASL_H_
#define _PPLASL_H_


typedef struct DECLSPEC_ALIGN(UL_CACHE_LINE) _UL_NPAGED_LOOKASIDE_LIST
{
    NPAGED_LOOKASIDE_LIST List;

} UL_NPAGED_LOOKASIDE_LIST, *PUL_NPAGED_LOOKASIDE_LIST;

C_ASSERT(sizeof(UL_NPAGED_LOOKASIDE_LIST) % UL_CACHE_LINE == 0);

typedef struct DECLSPEC_ALIGN(UL_CACHE_LINE) _PER_PROC_SLISTS
{
    SLIST_HEADER    SL;
    USHORT          MaxDepth;            // High water mark   
    USHORT          MinDepth;            // Low water mark 
    
    LONG            Delta;               // Delta between the entry serv rate of last two intervals  
    ULONG           EntriesServed;       // Entries served (frm this list) so far this interval   
    ULONG           PrevEntriesServed;   // Entries served during last interval

#if DBG
    ULONG           TotalServed;         // Used for tracking backing list serv rate by the tracing code
#endif

} PER_PROC_SLISTS, *PPER_PROC_SLISTS;

C_ASSERT(sizeof(PER_PROC_SLISTS) % UL_CACHE_LINE == 0);
C_ASSERT(TYPE_ALIGNMENT(PER_PROC_SLISTS) == UL_CACHE_LINE);

#define UL_MAX_SLIST_DEPTH  (0xfffe)

#define PER_PROC_SLIST(PoolHandle, Index)   ((PPER_PROC_SLISTS) (PoolHandle) + Index)
#define BACKING_SLIST(PoolHandle)           PER_PROC_SLIST((PoolHandle), g_UlNumberOfProcessors)

HANDLE
PplCreatePool(
    IN PALLOCATE_FUNCTION   Allocate,
    IN PFREE_FUNCTION       Free,
    IN ULONG                Flags,
    IN SIZE_T               Size,
    IN ULONG                Tag,
    IN USHORT               Depth
    );

VOID
PplDestroyPool(
    IN HANDLE   PoolHandle,
    IN ULONG    Tag
    );

__inline
PVOID
PplAllocate(
    IN HANDLE PoolHandle
    )
{
    PUL_NPAGED_LOOKASIDE_LIST   Lookaside;
    PVOID                       Entry;

    if (1 == g_UlNumberOfProcessors)
    {
        goto SingleProcessorCaseOrMissedPerProcessor;
    }

    // Try first for the per-processor lookaside list.
    //
    Lookaside = (PUL_NPAGED_LOOKASIDE_LIST)PoolHandle +
                    KeGetCurrentProcessorNumber() + 1;

    Lookaside->List.L.TotalAllocates += 1;
    Entry = InterlockedPopEntrySList(&Lookaside->List.L.ListHead);
    if (!Entry)
    {
        Lookaside->List.L.AllocateMisses += 1;

SingleProcessorCaseOrMissedPerProcessor:
        // We missed on the per-processor lookaside list, (or we're
        // running on a single processor machine) so try for
        // the overflow lookaside list.
        //
        Lookaside = (PUL_NPAGED_LOOKASIDE_LIST)PoolHandle;

        Lookaside->List.L.TotalAllocates += 1;
        Entry = InterlockedPopEntrySList(&Lookaside->List.L.ListHead);
        if (!Entry)
        {
            Lookaside->List.L.AllocateMisses += 1;
            Entry = (Lookaside->List.L.Allocate)(
                        Lookaside->List.L.Type,
                        Lookaside->List.L.Size,
                        Lookaside->List.L.Tag);
        }
    }
    return Entry;
}

__inline
VOID
PplFree(
    IN HANDLE PoolHandle,
    IN PVOID Entry
    )
{
    PUL_NPAGED_LOOKASIDE_LIST   Lookaside;

    if (1 == g_UlNumberOfProcessors)
    {
        goto SingleProcessorCaseOrMissedPerProcessor;
    }

    // Try first for the per-processor lookaside list.
    //
    Lookaside = (PUL_NPAGED_LOOKASIDE_LIST)PoolHandle +
                    KeGetCurrentProcessorNumber() + 1;

    Lookaside->List.L.TotalFrees += 1;
    if (ExQueryDepthSList(&Lookaside->List.L.ListHead) >=
        Lookaside->List.L.Depth)
    {
        Lookaside->List.L.FreeMisses += 1;

SingleProcessorCaseOrMissedPerProcessor:
        // We missed on the per-processor lookaside list, (or we're
        // running on a single processor machine) so try for
        // the overflow lookaside list.
        //
        Lookaside = (PUL_NPAGED_LOOKASIDE_LIST)PoolHandle;

        Lookaside->List.L.TotalFrees += 1;
        if (ExQueryDepthSList(&Lookaside->List.L.ListHead) >=
            Lookaside->List.L.Depth)
        {
            Lookaside->List.L.FreeMisses += 1;
            (Lookaside->List.L.Free)(Entry);
        }
        else
        {
            InterlockedPushEntrySList(
                &Lookaside->List.L.ListHead,
                (PSLIST_ENTRY)Entry);
        }
    }
    else
    {
        InterlockedPushEntrySList(
            &Lookaside->List.L.ListHead,
            (PSLIST_ENTRY)Entry);
    }
}


HANDLE
PpslCreatePool(
    IN ULONG  Tag,
    IN USHORT MaxDepth,
    IN USHORT MinDepth
    );

VOID
PpslDestroyPool(
    IN HANDLE   PoolHandle,
    IN ULONG    Tag
    );

__inline
PSLIST_ENTRY
PpslAllocate(
    IN HANDLE    PoolHandle
    )
{
    PSLIST_ENTRY        Entry;
    PPER_PROC_SLISTS    PPSList;
 
    PPSList = PER_PROC_SLIST(PoolHandle, KeGetCurrentProcessorNumber());

    Entry = InterlockedPopEntrySList(&(PPSList->SL));
 
    if (!Entry)
    {

        PPSList = BACKING_SLIST(PoolHandle);

        Entry = InterlockedPopEntrySList(&(PPSList->SL));        
    }

    if (Entry)
    {
        InterlockedIncrement((PLONG) &PPSList->EntriesServed);  

        #if DBG
        InterlockedIncrement((PLONG) &PPSList->TotalServed);        
        #endif
    }
   
    return Entry;
}

__inline
PSLIST_ENTRY
PpslAllocateToTrim(
    IN HANDLE PoolHandle,
    IN ULONG  Processor
    )
{
    PSLIST_ENTRY        Entry;
    PPER_PROC_SLISTS    PPSList;
 
    ASSERT(Processor <= (ULONG)g_UlNumberOfProcessors);
    
    PPSList = PER_PROC_SLIST(PoolHandle, Processor);    
    
    if (ExQueryDepthSList(&(PPSList->SL)) > PPSList->MinDepth)
    {
        Entry = InterlockedPopEntrySList(&(PPSList->SL));
    }
    else
    {
        Entry = NULL;        
    }

    return Entry;
}

__inline
PSLIST_ENTRY
PpslAllocateToDrain(
    IN HANDLE PoolHandle
    )
{
    PSLIST_ENTRY        Entry = NULL;
    PPER_PROC_SLISTS    PPSList;
    CLONG               NumberSLists;
    CLONG               i;


    NumberSLists = g_UlNumberOfProcessors + 1;

    for (i = 0; i < NumberSLists; i++)
    {
        PPSList = PER_PROC_SLIST(PoolHandle, i);

        Entry = InterlockedPopEntrySList(&(PPSList->SL));

        if (Entry) {

            break;
        }
    }

    return Entry;
}

__inline
BOOLEAN
PpslFree(
    IN HANDLE   PoolHandle,
    IN PVOID    Entry
    )
{
    PPER_PROC_SLISTS    PPSList;
    BOOLEAN             Freed = TRUE;

    PPSList = PER_PROC_SLIST(PoolHandle, KeGetCurrentProcessorNumber());

    if (ExQueryDepthSList(&(PPSList->SL)) < PPSList->MaxDepth &&
        PPSList->Delta >= 0)
    {
        InterlockedPushEntrySList(&(PPSList->SL), (PSLIST_ENTRY)Entry);
    }
    else
    {
        PPSList = BACKING_SLIST(PoolHandle);

        if (ExQueryDepthSList(&(PPSList->SL)) < PPSList->MaxDepth &&
            PPSList->Delta >= 0)
        {
            InterlockedPushEntrySList(&(PPSList->SL), (PSLIST_ENTRY)Entry);
        }
        else
        {
            Freed = FALSE;
        }
    }

    return Freed;
}

__inline
BOOLEAN
PpslFreeSpecifyList(
    IN HANDLE   PoolHandle,
    IN PVOID    Entry,
    IN ULONG    Processor
    )
{
    PPER_PROC_SLISTS    PPSList;
    BOOLEAN             Freed = TRUE;    

    ASSERT(Processor   <= (ULONG)g_UlNumberOfProcessors);
    
    PPSList = PER_PROC_SLIST(PoolHandle, Processor);

    if (ExQueryDepthSList(&(PPSList->SL)) < PPSList->MaxDepth)
    {
        InterlockedPushEntrySList(&(PPSList->SL), (PSLIST_ENTRY)Entry);
    }
    else
    {
        PPSList = BACKING_SLIST(PoolHandle);

        if (ExQueryDepthSList(&(PPSList->SL)) < PPSList->MaxDepth)
        {
            InterlockedPushEntrySList(&(PPSList->SL), (PSLIST_ENTRY)Entry);                
        }
        else
        {
            Freed = FALSE;        
        }
    }

    return Freed;
}

__inline
USHORT
PpslQueryBackingListDepth(
    IN HANDLE PoolHandle
    )
{
    USHORT              Depth;
    PPER_PROC_SLISTS    PPSList;

    PPSList = BACKING_SLIST(PoolHandle);

    Depth = ExQueryDepthSList(&(PPSList->SL));

    return (Depth);
}

__inline
USHORT
PpslQueryDepth(
    IN HANDLE   PoolHandle,
    IN ULONG    Processor
    )
{
    USHORT              Depth;
    PPER_PROC_SLISTS    PPSList;

    ASSERT(Processor <= (ULONG)g_UlNumberOfProcessors);

    PPSList = PER_PROC_SLIST(PoolHandle, Processor);

    Depth = ExQueryDepthSList(&(PPSList->SL));

    return (Depth);
}

__inline
USHORT
PpslQueryMinDepth(
    IN HANDLE   PoolHandle,
    IN ULONG    Processor
    )
{
    PPER_PROC_SLISTS    PPSList;

    ASSERT(Processor <= (ULONG)g_UlNumberOfProcessors);
    
    PPSList = PER_PROC_SLIST(PoolHandle, Processor);

    return PPSList->MinDepth;
}

__inline
USHORT
PpslQueryBackingListMinDepth(
    IN HANDLE PoolHandle
    )
{
    PPER_PROC_SLISTS    PPSList;

    PPSList = BACKING_SLIST(PoolHandle);

    return PPSList->MinDepth;
}

__inline
LONG
PpslAdjustActivityStats(
    IN HANDLE   PoolHandle,
    IN ULONG    Processor
    )
{
    PPER_PROC_SLISTS PPSList;
    ULONG EntriesServed;

    ASSERT(Processor <= (ULONG)g_UlNumberOfProcessors);
    
    PPSList = PER_PROC_SLIST(PoolHandle, Processor);

    EntriesServed = 
        InterlockedExchange((PLONG) &PPSList->EntriesServed, 0);

    InterlockedExchange(
        &PPSList->Delta,
        EntriesServed - PPSList->PrevEntriesServed
        );
    
    PPSList->PrevEntriesServed = EntriesServed;

    return PPSList->Delta;
}

__inline
ULONG
PpslQueryPrevServed(
    IN HANDLE PoolHandle,
    IN ULONG  Processor    
    )
{
    PPER_PROC_SLISTS    PPSList;

    ASSERT(Processor <= (ULONG)g_UlNumberOfProcessors);
    
    PPSList = PER_PROC_SLIST(PoolHandle, Processor);

    return PPSList->PrevEntriesServed;
}

#if DBG

__inline
LONG
PpslQueryDelta(
    IN HANDLE   PoolHandle,
    IN ULONG    Processor
    )
{
    PPER_PROC_SLISTS    PPSList;

    ASSERT(Processor <= (ULONG)g_UlNumberOfProcessors);
    
    PPSList = PER_PROC_SLIST(PoolHandle, Processor);

    return PPSList->Delta;
}

__inline
ULONG
PpslQueryTotalServed(
    IN HANDLE   PoolHandle
    )
{
    PPER_PROC_SLISTS    PPSList;
    
    PPSList = BACKING_SLIST(PoolHandle);

    return PPSList->TotalServed;
}

__inline
ULONG
PpslQueryServed(
    IN HANDLE PoolHandle,
    IN ULONG  Processor    
    )
{
    PPER_PROC_SLISTS    PPSList;

    ASSERT(Processor <= (ULONG)g_UlNumberOfProcessors);
    
    PPSList = PER_PROC_SLIST(PoolHandle, Processor);

    return PPSList->EntriesServed;
}

#endif // DBG


#endif  // _PPLASL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\parse.h ===
/*++

Copyright (c) 1998-2002 Microsoft Corporation

Module Name:

    parse.h

Abstract:

    Contains all of the public definitions for the HTTP parsing code.

Author:

    Henry Sanders (henrysa)         04-May-1998

Revision History:

    Paul McDaniel (paulmcd)         14-Apr-1999

--*/

#ifndef _PARSE_H_
#define _PARSE_H_

//
// Constants
//

#define WILDCARD_SIZE       (STRLEN_LIT("*/*") + sizeof(CHAR))
#define WILDCARD_SPACE      '*/* '
#define WILDCARD_COMMA      '*/*,'


//
// Size of Connection: header values
//

#define CONN_CLOSE_HDR              "close"
#define CONN_CLOSE_HDR_LENGTH       STRLEN_LIT(CONN_CLOSE_HDR)

#define CONN_KEEPALIVE_HDR          "keep-alive"
#define CONN_KEEPALIVE_HDR_LENGTH   STRLEN_LIT(CONN_KEEPALIVE_HDR)

#define CHUNKED_HDR                 "chunked"
#define CHUNKED_HDR_LENGTH          STRLEN_LIT(CHUNKED_HDR)


#define MIN_VERSION_SIZE        STRLEN_LIT("HTTP/1.1")
#define STATUS_CODE_LENGTH      3

#define HTTP_VERSION_11         "HTTP/1.1"
#define HTTP_VERSION_10         "HTTP/1.0"
#define HTTP_VERSION_OTHER      "HTTP/"
#define VERSION_SIZE            STRLEN_LIT(HTTP_VERSION_11)
#define VERSION_OTHER_SIZE      STRLEN_LIT(HTTP_VERSION_OTHER)

#define MAX_KNOWN_VERB_LENGTH   STRLEN_LIT("PROPPATCH") + sizeof(CHAR)

#define MAX_VERB_LENGTH         255


// "HTTP/1.x" backward