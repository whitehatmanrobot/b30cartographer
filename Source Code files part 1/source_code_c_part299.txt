t );
        SetConstant( IsConstant() && GetRight()->IsConstant() );

        // check here for div by zero ( could be var / 0 )
        if ( !RightCtxt.AnyUpFlags( EX_VALUE_INVALID ) &&
             ( GetOperator() == OP_SLASH ) &&
             ( RightCtxt.Value() == 0 ) )
            {
            SemError( pExprCtxt->GetNode(),
                      *(pExprCtxt->GetCtxt()),
                      EXPR_DIV_BY_ZERO,
                      NULL );
            pExprCtxt->SetUpFlags( EX_VALUE_INVALID );
            }
        }
    else
        pExprCtxt->SetUpFlags( EX_VALUE_INVALID );


    ////////////////////////////////////////////////////////////////////////
    // do type compatibility stuff

    switch ( GetOperator() )
        {
        case OP_PLUS:
        case OP_MINUS:
        case OP_STAR:
        case OP_MOD:
        // gaj - we implicitly assume signed types
        case OP_LEFT_SHIFT:
        case OP_RIGHT_SHIFT:
        case OP_AND:
        case OP_OR:
        case OP_XOR:
        case OP_SLASH:
            {
            // tbd - for now, just grab the bigger of the types
            if ( !RightCtxt.pType ||
                 (LeftCtxt.pType &&
                        (LeftCtxt.pType->GetSize() >= RightCtxt.pType->GetSize() ) ) )
                {
                pExprCtxt->pType = LeftCtxt.pType;
                pExprCtxt->TypeInfo = LeftCtxt.TypeInfo;
                pExprCtxt->fIntegral = LeftCtxt.fIntegral;
                SetType( pExprCtxt->pType );
                }
            else if ( RightCtxt.pType )
                {
                pExprCtxt->pType = RightCtxt.pType;
                pExprCtxt->TypeInfo = RightCtxt.TypeInfo;
                pExprCtxt->fIntegral = RightCtxt.fIntegral;
                SetType( pExprCtxt->pType );
                }

            break;
            }
        case OP_LOGICAL_AND:
        case OP_LOGICAL_OR:
        // gaj - we implicitly assume signed types
        case OP_LESS:
        case OP_LESS_EQUAL:
        case OP_GREATER_EQUAL:
        case OP_GREATER:
        case OP_EQUAL:
        case OP_NOT_EQUAL:
            {
            pExprCtxt->TypeInfo.TypeSize = SIZE_UNDEF;
            pExprCtxt->TypeInfo.BaseType = TYPE_BOOLEAN;
            pExprCtxt->TypeInfo.TypeSign = SIGN_UNDEF;
            GetBaseTypeNode( &(pExprCtxt->pType ), pExprCtxt->TypeInfo );

            pExprCtxt->fIntegral = TRUE;
            SetType( pExprCtxt->pType );
            break;
            }
        default:
            {
            break;
            }
        }


    ////////////////////////////////////////////////////////////////////////
    // compute the value

    if ( !pExprCtxt->AnyUpFlags( EX_VALUE_INVALID ) )
        {
        // update value directly from LeftCtxt and RightCtxt
        EXPR_VALUE  &       LeftValue   = LeftCtxt.Value();
        EXPR_VALUE  &       RightValue  = RightCtxt.Value();
        EXPR_VALUE  &       Result      = pExprCtxt->Value();

        switch ( GetOperator() )
            {
            case OP_PLUS:
                {
                Result = LeftValue + RightValue;
                break;
                }
            case OP_MINUS:
                {
                Result = LeftValue - RightValue;
                break;
                }
            case OP_STAR:
                {
                Result = LeftValue * RightValue;
                break;
                }
            case OP_SLASH:
                {
                if (RightValue == 0)
                    Result = 0;
                else
                    Result = LeftValue / RightValue;
                break;
                }
            case OP_MOD:
                {
                Result = LeftValue % RightValue;
                break;
                }
            case OP_LOGICAL_AND:
                {
                Result = LeftValue && RightValue;
                break;
                }
            case OP_LOGICAL_OR:
                {
                Result = LeftValue || RightValue;
                break;
                }
            // gaj - we implicitly assume signed types
            case OP_LESS:
                {
                Result = LeftValue < RightValue;
                break;
                }
            case OP_LESS_EQUAL:
                {
                Result = LeftValue <= RightValue;
                break;
                }
            case OP_GREATER_EQUAL:
                {
                Result = LeftValue >= RightValue;
                break;
                }
            case OP_GREATER:
                {
                Result = LeftValue > RightValue;
                break;
                }
            case OP_EQUAL:
                {
                Result = LeftValue == RightValue;
                break;
                }
            case OP_NOT_EQUAL:
                {
                Result = LeftValue != RightValue;
                break;
                }
            // gaj - we implicitly assume signed types
            case OP_LEFT_SHIFT:
                {
                Result = LeftValue << RightValue;
                break;
                }
            case OP_RIGHT_SHIFT:
                {
                Result = LeftValue >> RightValue;
                break;
                }
            case OP_AND:
                {
                Result = LeftValue & RightValue;
                break;
                }
            case OP_OR:
                {
                Result = LeftValue | RightValue;
                break;
                }
            case OP_XOR:
                {
                Result = LeftValue ^ RightValue;
                break;
                }
            default:
                {
                Result = 0;
                break;
                }
            }

        }

    }

//
// determine the type of the expression
//

void
expr_ternary::DetermineType()
{
    node_skl    *   pLeftType   = NULL;
    node_skl    *   pRightType  = NULL;


    if ( GetLeft() )
        pLeftType   = GetLeft()->AlwaysGetType();
    if ( GetRight() )
        pRightType  = GetRight()->AlwaysGetType();

    SetConstant( GetRight()->IsConstant() && GetLeft()->IsConstant() );

    if ( pLeftType )
        SetType( pLeftType );
    else if ( pRightType )
        SetType( pRightType );

}

void
expr_ternary::ExprAnalyze( EXPR_CTXT * pExprCtxt )
    {
    EXPR_CTXT           LeftCtxt( pExprCtxt );
    EXPR_CTXT           RightCtxt( pExprCtxt );
    EXPR_CTXT           RelCtxt( pExprCtxt );

    if ( GetLeft() )
        {
        GetLeft()->ExprAnalyze( &LeftCtxt );
        pExprCtxt->MergeUpFlags( &LeftCtxt );
        SetConstant( IsConstant() && GetLeft()->IsConstant() );
        }
    else
        pExprCtxt->SetUpFlags( EX_VALUE_INVALID );

    if ( GetRight() )
        {
        GetRight()->ExprAnalyze( &RightCtxt );
        pExprCtxt->MergeUpFlags( &RightCtxt );
        SetConstant( IsConstant() && GetRight()->IsConstant() );
        }
    else
        pExprCtxt->SetUpFlags( EX_VALUE_INVALID );

    if ( GetRelational() )
        {
        GetRelational()->ExprAnalyze( &RelCtxt );
        pExprCtxt->MergeUpFlags( &RelCtxt );
        SetConstant( IsConstant() && GetRelational()->IsConstant() );
        }
    else
        pExprCtxt->SetUpFlags( EX_VALUE_INVALID );


    // tbd - get the type from the left or right of the ':'
    if ( LeftCtxt.pType )
        {
        pExprCtxt->pType = LeftCtxt.pType;
        pExprCtxt->TypeInfo = LeftCtxt.TypeInfo;
        pExprCtxt->fIntegral = LeftCtxt.fIntegral;
        SetType( pExprCtxt->pType );
        }
    else if ( RightCtxt.pType )
        {
        pExprCtxt->pType = RightCtxt.pType;
        pExprCtxt->TypeInfo = RightCtxt.TypeInfo;
        pExprCtxt->fIntegral = RightCtxt.fIntegral;
        SetType( pExprCtxt->pType );
        }
    else
        SetType( NULL );

    ////////////////////////////////////////////////////////////////////////
    // compute the value

    if ( !pExprCtxt->AnyUpFlags( EX_VALUE_INVALID ) )
        {
        // update value directly from LeftCtxt and RightCtxt
        EXPR_VALUE  &       LeftValue   = LeftCtxt.Value();
        EXPR_VALUE  &       RightValue  = RightCtxt.Value();
        EXPR_VALUE  &       RelValue    = RelCtxt.Value();
        EXPR_VALUE  &       Result      = pExprCtxt->Value();

        Result = (RelValue) ? LeftValue : RightValue;

        }

    }

//
// determine the type of the expression
//

void
expr_variable::DetermineType()
{
    if ( pType->NodeKind() == NODE_FORWARD )
        {
        node_forward *  pFwd = (node_forward *) pType;
        // (permanently) resolve the forward
        pType = pFwd->ResolveFDecl();

        // This appears to be a better fix for the problem of unresolved
        // variables in async size expressions than the NULL type pointer check
        // in Fixup[Begin|Finish]ProcExpr in front\copyto.cxx.  However, at this
        // time we don't fully understand the implications of this change while
        // the other is localized to the async_uuid interfaces only.
        // e.g. ([in] long size, [in, size_is(huh)] long *p)
        // 03-May-99 MikeW
/*
        // if it couldn't be resolved, put back the forward
        if ( !pType )
            {
            pType = pFwd;
            }
*/
        }
}

void
expr_variable::ExprAnalyze( EXPR_CTXT * pExprCtxt )
    {
    pExprCtxt->SetUpFlags( EX_VALUE_INVALID );
    pExprCtxt->SetUpFlags( EX_NON_NUMERIC );

    if ( !pType )
        {
        pExprCtxt->SetUpFlags( EX_UNSAT_FWD );
        return;
        }

    if ( pType->NodeKind() == NODE_FORWARD )
        {
        node_forward *  pFwd = (node_forward *) pType;
        // (permanently) resolve the forward
        pType = pFwd->ResolveFDecl();
        // if it couldn't be resolved, put back the forward
        if ( !pType )
            {
            pExprCtxt->SetUpFlags( EX_UNSAT_FWD );
            pExprCtxt->TypeInfo.TypeSize = SIZE_UNDEF;
            pExprCtxt->TypeInfo.BaseType = TYPE_INT;
            pExprCtxt->TypeInfo.TypeSign = SIGN_SIGNED;
            GetBaseTypeNode( &pType, pExprCtxt->TypeInfo);
            pExprCtxt->pType = pType;
            return;
            }
        }

    // do type compatibility stuff
    pExprCtxt->pType = pType;
    pExprCtxt->TypeInfo.TypeSize = SIZE_UNDEF;
    pExprCtxt->TypeInfo.BaseType = TYPE_UNDEF;
    pExprCtxt->TypeInfo.TypeSign = SIGN_UNDEF;
    pExprCtxt->fIntegral = FALSE; // for now...

    if ( ( pType->NodeKind() == NODE_PARAM ) &&
          pType->FInSummary( ATTR_OUT ) &&
         !pType->FInSummary( ATTR_IN ) )
        pExprCtxt->SetUpFlags( EX_OUT_ONLY_PARAM );

    }

//
// determine the type of the expression
//

void
expr_named_constant::DetermineType()
{
    // do type compatibility stuff
    if ( !GetType() )
        {
        SetType( GetExpr()->AlwaysGetType() );
        }

}

void
expr_named_constant::ExprAnalyze( EXPR_CTXT * pExprCtxt )
    {
    // named constants shouldn't be folded away
    pExprCtxt->SetUpFlags( EX_NON_NUMERIC );

    // update value
    pExprCtxt->Value() = GetValue();

    // do type compatibility stuff
    if ( GetType() )
        {
        pExprCtxt->pType = GetType();
        pExprCtxt->TypeInfo.TypeSize = SIZE_UNDEF;
        pExprCtxt->TypeInfo.BaseType = TYPE_UNDEF;
        pExprCtxt->TypeInfo.TypeSign = SIGN_UNDEF;
        pExprCtxt->fIntegral = FALSE; // for now...
        }
    else
        {
        EXPR_CTXT       LeftCtxt( pExprCtxt );
        expr_node   *   pExpr   = GetExpr();

        pExpr->ExprAnalyze( &LeftCtxt );

        pExprCtxt->pType = LeftCtxt.pType;
        pExprCtxt->TypeInfo = LeftCtxt.TypeInfo;
        pExprCtxt->fIntegral = LeftCtxt.fIntegral;
        SetType( pExprCtxt->pType );
        }


    }

//
// determine the type of the expression
//

void
expr_constant::DetermineType()
{
    node_skl* pNewType = 0;

    // do type compatibility stuff
    if ( GetType() )
        return;

    // do type compatibility stuff
    switch (Format)
        {
        case VALUE_TYPE_STRING:
            {
            node_skl    *   pBottomType;
            GetBaseTypeNode( &pBottomType,
                             SIGN_SIGNED,
                             SIZE_CHAR,
                             TYPE_INT );
            pNewType = new node_pointer;
            pNewType->SetChild( pBottomType );
            break;
            }
        case VALUE_TYPE_WSTRING:
            {
            node_skl    *   pBottomType;
            SymKey  SKey( "wchar_t", NAME_DEF );

            pBottomType = pBaseSymTbl->SymSearch( SKey );
            pNewType = new node_pointer;
            pNewType->SetChild( pBottomType );
            break;
            }
        case VALUE_TYPE_CHAR:
            {
            GetBaseTypeNode( &pNewType,
                             SIGN_SIGNED,
                             SIZE_CHAR,
                             TYPE_INT );
            break;
            }
        case VALUE_TYPE_WCHAR:
            {
            SymKey  SKey( "wchar_t", NAME_DEF );

            pNewType    = pBaseSymTbl->SymSearch( SKey );
            break;
            }
        case VALUE_TYPE_NUMERIC:
        case VALUE_TYPE_HEX:
        case VALUE_TYPE_OCTAL:
            {
            GetBaseTypeNode( &pNewType,
                             SIGN_SIGNED,
                             SIZE_UNDEF,
                             TYPE_INT );
            break;
            }
        case VALUE_TYPE_NUMERIC_U:
        case VALUE_TYPE_HEX_U:
        case VALUE_TYPE_OCTAL_U:
            {
            GetBaseTypeNode( &pNewType,
                             SIGN_UNSIGNED,
                             SIZE_SHORT,
                             TYPE_INT );
            break;
            }

        case VALUE_TYPE_NUMERIC_LONG:
        case VALUE_TYPE_HEX_LONG:
        case VALUE_TYPE_OCTAL_LONG:
            {
            GetBaseTypeNode( &pNewType,
                             SIGN_SIGNED,
                             SIZE_LONG,
                             TYPE_INT );
            break;
            }

        case VALUE_TYPE_NUMERIC_ULONG:
        case VALUE_TYPE_HEX_ULONG:
        case VALUE_TYPE_OCTAL_ULONG:
            {
            GetBaseTypeNode( &pNewType,
                             SIGN_UNSIGNED,
                             SIZE_LONG,
                             TYPE_INT );
            break;
            }

        case VALUE_TYPE_BOOL:
            {
            GetBaseTypeNode( &pNewType,
                             SIGN_UNDEF,
                             SIZE_UNDEF,
                             TYPE_BOOLEAN );
            break;
            }

        case VALUE_TYPE_FLOAT:
            {
            GetBaseTypeNode( &pNewType,
                             SIGN_UNDEF,
                             SIZE_UNDEF,
                             TYPE_FLOAT );
            break;
            }
        case VALUE_TYPE_DOUBLE:
            {
            GetBaseTypeNode( &pNewType,
                             SIGN_UNDEF,
                             SIZE_UNDEF,
                             TYPE_DOUBLE );
            break;
            }

        default:
            break;
        }
    SetType( pNewType );
}

void
expr_constant::ExprAnalyze( EXPR_CTXT * pExprCtxt )
    {

    // update value
    pExprCtxt->Value() = GetValue();

    if ( GetType() )
        {
        pExprCtxt->pType = GetType();
        pExprCtxt->TypeInfo.TypeSize = SIZE_UNDEF;
        pExprCtxt->TypeInfo.BaseType = TYPE_UNDEF;
        pExprCtxt->TypeInfo.TypeSign = SIGN_UNDEF;
        pExprCtxt->fIntegral = FALSE; // for now...
        return;
        }

    // do type compatibility stuff
    switch (Format)
        {
        case VALUE_TYPE_STRING:
            {
            node_skl    *   pBottomType;
            GetBaseTypeNode( &pBottomType,
                             SIGN_SIGNED,
                             SIZE_CHAR,
                             TYPE_INT );
            pExprCtxt->pType = new node_pointer;
            pExprCtxt->pType->SetChild( pBottomType );
            break;
            }
        case VALUE_TYPE_WSTRING:
            {
            node_skl    *   pBottomType;
            SymKey  SKey( "wchar_t", NAME_DEF );

            pBottomType = pBaseSymTbl->SymSearch( SKey );
            pExprCtxt->pType = new node_pointer;
            pExprCtxt->pType->SetChild( pBottomType );
            break;
            }
        case VALUE_TYPE_CHAR:
            {
            GetBaseTypeNode( &pExprCtxt->pType,
                             SIGN_SIGNED,
                             SIZE_CHAR,
                             TYPE_INT );
            break;
            }
        case VALUE_TYPE_WCHAR:
            {
            SymKey  SKey( "wchar_t", NAME_DEF );

            pExprCtxt->pType    = pBaseSymTbl->SymSearch( SKey );
            break;
            }
        case VALUE_TYPE_NUMERIC:
        case VALUE_TYPE_HEX:
        case VALUE_TYPE_OCTAL:
            {
            short   RealSize    = SIZE_HYPER;
            __int64 val         = GetValue();

            if ( (val <= 127) && (val >= -128 ) )
                RealSize = SIZE_CHAR;
            else if ( (val <= _I16_MAX) && (val >= _I16_MIN ) )
                RealSize = SIZE_SHORT;
            else if ( (val <= _I32_MAX) && (val >= _I32_MIN ) )
                RealSize = SIZE_LONG;

            GetBaseTypeNode( &pExprCtxt->pType,
                             SIGN_SIGNED,
                             RealSize,
                             TYPE_INT );
            break;
            }
        case VALUE_TYPE_NUMERIC_U:
        case VALUE_TYPE_HEX_U:
        case VALUE_TYPE_OCTAL_U:
            {
            short RealSize      = SIZE_LONG;
            unsigned long  val  = (unsigned long) GetValue();

            if ( val <= 255 )
                RealSize = SIZE_CHAR;
            else if ( val <= 65536 )
                RealSize = SIZE_SHORT;

            GetBaseTypeNode( &pExprCtxt->pType,
                             SIGN_UNSIGNED,
                             RealSize,
                             TYPE_INT );
            break;
            }

        case VALUE_TYPE_NUMERIC_LONG:
        case VALUE_TYPE_HEX_LONG:
        case VALUE_TYPE_OCTAL_LONG:
            {
            GetBaseTypeNode( &pExprCtxt->pType,
                             SIGN_SIGNED,
                             SIZE_LONG,
                             TYPE_INT );
            break;
            }

        case VALUE_TYPE_NUMERIC_ULONG:
        case VALUE_TYPE_HEX_ULONG:
        case VALUE_TYPE_OCTAL_ULONG:
            {
            GetBaseTypeNode( &pExprCtxt->pType,
                             SIGN_UNSIGNED,
                             SIZE_LONG,
                             TYPE_INT );
            break;
            }

        case VALUE_TYPE_BOOL:
            {
            GetBaseTypeNode( &pExprCtxt->pType,
                             SIGN_UNDEF,
                             SIZE_UNDEF,
                             TYPE_BOOLEAN );
            break;
            }

        case VALUE_TYPE_FLOAT:
            {
            GetBaseTypeNode( &pExprCtxt->pType,
                             SIGN_UNDEF,
                             SIZE_UNDEF,
                             TYPE_FLOAT );
            break;
            }
        case VALUE_TYPE_DOUBLE:
            {
            GetBaseTypeNode( &pExprCtxt->pType,
                             SIGN_UNDEF,
                             SIZE_UNDEF,
                             TYPE_DOUBLE );
            break;
            }

        default:
            break;
        }
    SetType( pExprCtxt->pType );
    }

//
// determine the type of the expression
//

void
expr_init_list::DetermineType()
{
    SetType( pExpr->AlwaysGetType() );
}

void
expr_init_list::ExprAnalyze( EXPR_CTXT * pExprCtxt )
    {

    // tbd - for now only process first element
    pExpr->ExprAnalyze( pExprCtxt );
    SetConstant( pExpr->IsConstant() );
    SetType( pExpr->GetType() );

    }

short
expr_op_binary::MakeListOfDerefedVars( ITERATOR& List )
    {
    if( GetLeft() )
        GetLeft()->MakeListOfDerefedVars( List );

    if( GetRight() )
        GetRight()->MakeListOfDerefedVars( List );
    return (short) ITERATOR_GETCOUNT( List );
    }

short
expr_u_deref::MakeListOfDerefedVars( ITERATOR& List )
    {
    expr_node * pLeft = GetLeft();

    if( !pLeft ) return 0;

    if( pLeft->IsAVariable() )
        ITERATOR_INSERT( List, pLeft );
    else if( pLeft->GetOperator() == OP_UNARY_INDIRECTION )
        pLeft->MakeListOfDerefedVars( List );

    return ITERATOR_GETCOUNT( List );
    }

BOOL
expr_b_arithmetic::GetExprValue( SExprValue& v )
    {
    SExprValue  LeftValue  = {VALUE_TYPE_UNDEFINED, 0};
    SExprValue  RightValue = {VALUE_TYPE_UNDEFINED, 0};
    BOOL        fSuccess;

    fSuccess =  GetLeft()->GetExprValue( LeftValue ) &&
                GetRight()->GetExprValue( RightValue ) &&
                (LeftValue.format == VALUE_TYPE_DOUBLE || LeftValue.format == VALUE_TYPE_DOUBLE) && 
                (RightValue.format == VALUE_TYPE_DOUBLE || RightValue.format == VALUE_TYPE_DOUBLE);

    if (fSuccess)
        {
        v.format = LeftValue.format == VALUE_TYPE_DOUBLE || RightValue.format == VALUE_TYPE_DOUBLE ?
                    VALUE_TYPE_DOUBLE : VALUE_TYPE_FLOAT ;
        double l = LeftValue.format == VALUE_TYPE_DOUBLE ? LeftValue.d : LeftValue.f ;
        double r = RightValue.format == VALUE_TYPE_DOUBLE ? RightValue.d : RightValue.f ;
    
        switch ( GetOperator() )
            {
            case OP_PLUS:
                l += r;
                break;
            case OP_MINUS:
                l -= r;
                break;
            case OP_STAR:
                l *= r;
                break;
            case OP_SLASH:
                __try 
                    {
                    l /= r;
                    }
                __except (EXCEPTION_EXECUTE_HANDLER)
                    {
                    fSuccess = FALSE;
                    }
                break;
            }
        if (v.format == VALUE_TYPE_FLOAT)
            {
            v.f = (float) l;
            }
        else if (v.format == VALUE_TYPE_DOUBLE)
            {
            v.d = l;
            }
        }
    return fSuccess;
    }

BOOL
expr_u_arithmetic::GetExprValue( SExprValue& v )
{
    SExprValue  LeftValue = {VALUE_TYPE_UNDEFINED, 0};
    BOOL        fSuccess  = GetLeft()->GetExprValue( LeftValue );

    if (fSuccess)
        {
        v = LeftValue;
        if (GetOperator() == OP_UNARY_MINUS)
            {
            switch ( v.format )
                {
                case VALUE_TYPE_FLOAT:
                    v.f = -LeftValue.f;
                    break;
                case VALUE_TYPE_DOUBLE:
                    v.d = -LeftValue.d;
                    break;
                default:
                    fSuccess = FALSE;
                    break;
                }
            }
        }
    return fSuccess;
}

void
expr_node::CopyTo( expr_node* lhs )
    {
    DetermineType();
    lhs->pType       = pType;
    lhs->fFloatExpr  = fFloatExpr;
    lhs->fConstant   = fConstant;
    }

void
expr_constant::CopyTo( expr_node* pExpr )
    {
    expr_constant* lhs = (expr_constant*) pExpr;
    expr_node::CopyTo( lhs );
    lhs->Format = Format;
    lhs->Value  = Value;
    }

void
expr_init_list::CopyTo( expr_node* pExpr )
    {
    expr_init_list* lhs = (expr_init_list*) pExpr;
    expr_node::CopyTo( lhs );
    lhs->pSibling = (expr_init_list*)pSibling->Clone();
    pSibling->CopyTo(lhs->pSibling);
    lhs->pExpr = pExpr->Clone();
    pExpr->CopyTo(lhs->pExpr);
    }

void
expr_operator::CopyTo( expr_node* pExpr )
    {
    expr_operator* lhs = (expr_operator*) pExpr;
    expr_node::CopyTo( lhs );
    lhs->Operator = Operator;
    }

void
expr_op_binary::CopyTo( expr_node* pExpr )
    {
    expr_op_binary* lhs = (expr_op_binary*) pExpr;
    expr_operator::CopyTo( lhs );
    lhs->pLeft = pLeft->Clone();
    pLeft->CopyTo(lhs->pLeft);
    lhs->pRight = pRight->Clone();
    pRight->CopyTo(lhs->pRight);
    }

void
expr_param::CopyTo( expr_node* pExpr )
    {
    expr_param* lhs = (expr_param*) pExpr;
    expr_op_binary::CopyTo( lhs );
    _STRDUP( lhs->pName, pName );
    }

void
expr_op_unary::CopyTo( expr_node* pExpr )
    {
    expr_op_unary* lhs = (expr_op_unary*) pExpr;
    expr_operator::CopyTo( lhs );
    lhs->pLeft = pLeft->Clone();
    pLeft->CopyTo(lhs->pLeft);
    }

void
expr_cast::CopyTo( expr_node* pExpr )
    {
    expr_cast* lhs = (expr_cast*) pExpr;
    expr_op_unary::CopyTo( lhs );
    lhs->fEmitModifiers  = fEmitModifiers;
    lhs->pCastType       = pCastType;
    }

void
expr_proc_call::CopyTo( expr_node* pExpr )
    {
    expr_proc_call* lhs = (expr_proc_call*) pExpr;
    expr_op_unary::CopyTo( lhs );
    _STRDUP( lhs->pName, pName );
    lhs->NoOfParams = NoOfParams;
    }

void
expr_sizeof::CopyTo( expr_node* pExpr )
    {
    expr_sizeof* lhs = (expr_sizeof*) pExpr;
    expr_op_unary::CopyTo( lhs );
    lhs->pType = pType;
    }

void
expr_alignof::CopyTo( expr_node* pExpr )
    {
    expr_alignof* lhs = (expr_alignof*) pExpr;
    expr_op_unary::CopyTo( lhs );
    lhs->pType = pType;
    }

void
expr_ternary::CopyTo( expr_node* pExpr )
    {
    expr_ternary* lhs = (expr_ternary*) pExpr;
    expr_operator::CopyTo( lhs );
    lhs->pLeft = pLeft->Clone();
    pLeft->CopyTo(lhs->pLeft);
    lhs->pRight = pRight->Clone();
    pRight->CopyTo(lhs->pRight);
    lhs->pRelational = pRelational->Clone();
    pRelational->CopyTo(lhs->pRelational);
    }

void
expr_variable::CopyTo( expr_node* pExpr )
    {
    expr_variable* lhs = (expr_variable*) pExpr;
    expr_node::CopyTo( lhs );
    _STRDUP( lhs->pIDName, pIDName );
    _STRDUP( lhs->pPrefix, pPrefix );
    }

expr_node*
expr_ternary::Clone()
    {
    return new expr_ternary(OP_ILLEGAL,0,0,0);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\front\acfattr.cxx ===
/*****************************************************************************/
/**						Microsoft LAN Manager								**/
/**				Copyright(c) Microsoft Corp., 1987-1999						**/
/*****************************************************************************/
/*****************************************************************************
File				: acfattr.cxx
Title				: the acf attribute handler
Description			: this file handles all the code connected to the acf
					: attribute handling
History				:
	02-Jan-1990	VibhasC	Create - Happy New Year !!
*****************************************************************************/

/*****************************************************************************
 * include files
 *****************************************************************************/

#pragma warning ( disable : 4514 )

#include "nulldefs.h"
extern "C"	{
	#include <stdio.h>
	#include <stdlib.h>
	#include <string.h>
}
#include "allnodes.hxx"
#include "cmdana.hxx"

/*****************************************************************************
 * local defines
 *****************************************************************************/

/*****************************************************************************
 * local data 
 *****************************************************************************/

/*****************************************************************************
 * extern data
 *****************************************************************************/

extern ATTR_VECTOR					AcfConflicts[ ][ ATTR_VECTOR_SIZE ];
extern CMD_ARG					*	pCommand;

/*****************************************************************************
 * local procs
 *****************************************************************************/

/*****************************************************************************
 * extern procs
 *****************************************************************************/
 extern void						ParseError( STATUS_T, char * );
 


node_implicit::node_implicit(
	node_skl	*	pType,
	node_id		*	pID ) : acf_attr( ATTR_IMPLICIT )
	{
	pHandleID	= pID;
	pID->SetEdgeType( EDGE_USE );
	pID->SetChild( pType );
	pHandleType	= pType;
	}

void
node_implicit::ImplicitHandleDetails(
	node_skl	**	ppType,
	node_id		**	ppID )
	{
	(*ppID)		= pHandleID;
	(*ppType)	= pHandleType;
	}

BOOL
node_implicit::IsHandleTypeDefined()
	{
	return ( pHandleType && 
			 ( pHandleType->NodeKind() != NODE_FORWARD) );
	}


OPT_LEVEL_ENUM
ParseAcfOptimizationAttr(
    char *              pOptString,
    unsigned short *    pOptFlags )
/*
    Before the /target switch was introduced, we had the following
    optimization switches (up to beta2 for NT40):
        -Os   size                        from NT 3.5 (always available)
        -Oi   old interpreter             from NT 3.5 (always available)
        -Oi1  -Oi w/stubless obj client   from NT 3.51
        -Oi2  new interpreter             from NT 4.0
*/
{
    unsigned short  OptFlags = pCommand->GetOptimizationFlags(); 
    OPT_LEVEL_ENUM  OptLevel = pCommand->GetOptimizationLevel();

    if ( strcmp( pOptString, "i" ) == 0 )
        {
        OptLevel = OPT_LEVEL_OI;
        }
    else if ( strcmp( pOptString, "ic" ) == 0 )
        {
        OptLevel = OPT_LEVEL_OIC;
        }
    else if ( strcmp( pOptString, "i1" ) == 0 )
        {
        ParseError( OI1_PHASED_OUT, "i1");
        OptLevel = OPT_LEVEL_OIC;
        }
    else if ( strcmp( pOptString, "icf" ) == 0  ||
              strcmp( pOptString, "if" ) == 0  )
        {
        OptLevel = OPT_LEVEL_OICF;
        }
    else if ( strcmp( pOptString, "i2" ) == 0 )
        {
        ParseError( OI2_OBSOLETE, "i2");
        OptLevel = OPT_LEVEL_OICF;
        }
    else if ( strcmp( pOptString, "s" ) == 0 )
        {
        if ( pCommand->NeedsNDR64Run() )
            ParseError( OS_IN_NDR64, "" );

        OptLevel = OPT_LEVEL_OS;
        }
    else
        ParseError( ILLEGAL_ARG_VALUE, pOptString );

    switch ( OptLevel )
        {
        case OPT_LEVEL_OS:
            OptFlags = OPTIMIZE_SIZE;
            break;

    // Force Oi and Oic to mean Oicf for 64b platforms.

        case OPT_LEVEL_OI:
            if ( pCommand->Is64BitEnv() )
                { 
                ParseError( WIN64_INTERPRETED, "-Oicf for -Oi" );
                OptFlags = OPTIMIZE_ALL_I2_FLAGS;
                }
            else
                OptFlags = OPTIMIZE_INTERPRETER;
            break;

        case OPT_LEVEL_OIC:
            if ( pCommand->Is64BitEnv() )
                { 
                ParseError( WIN64_INTERPRETED, "-Oicf for -Oic" );
                OptFlags = OPTIMIZE_ALL_I2_FLAGS;
                }
            else
                OptFlags = OPTIMIZE_ALL_I1_FLAGS;

            break;

        case OPT_LEVEL_OICF:
            OptFlags = OPTIMIZE_ALL_I2_FLAGS;
            break;
        }

    *pOptFlags = OptFlags;

    return OptLevel;
}

/*****************************************************************************
 * utility routines
 *****************************************************************************/
short
CheckValidAllocate(
	char	*	pAllocID )
	{
static char *ValidAllocates[] = {
	 "single_node"
	,"all_nodes"
	,"dont_free"
	,"free"
	,"all_nodes_aligned"
	,(char *)0
};
static short AllocateValues[] = {
	 ALLOCATE_SINGLE_NODE
	,ALLOCATE_ALL_NODES
	,ALLOCATE_DONT_FREE
	,ALLOCATE_FREE
	,ALLOCATE_ALL_NODES_ALIGNED
};
	char	*	pSearch;
	int			i		= 0;

	while( ( pSearch = ValidAllocates[i] ) != 0 )
		{
		if( !strcmp( pSearch, pAllocID ) )
			return AllocateValues[ i ];
		++i;
		}

	ParseError( INVALID_ALLOCATE_MODE, pAllocID );
	return 0;
	}

/*****************************************************************************
 * clone routines
 *****************************************************************************/

node_base_attr *	node_optimize::Clone()
							{
							node_optimize	*	pNew = new node_optimize( this );
							return pNew;
							}
node_base_attr *	node_ptr_size::Clone()
							{
							node_ptr_size	*	pNew = new node_ptr_size( this );
							return pNew;
							}

node_base_attr *	node_implicit::Clone()
							{
							node_implicit	*	pNew = new node_implicit( this );
							return pNew;
							}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\expr\makexpr.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-1999 Microsoft Corporation

 Module Name:
	
	makexpr.cxx

 Abstract:

	This file contains specialized routines for creating complex expressions
	from the basic expressions.

 Notes:


 History:

 ----------------------------------------------------------------------------*/

#pragma warning ( disable : 4514 )

/****************************************************************************
 *	include files
 ***************************************************************************/

#include "nulldefs.h"
extern "C"
	{
	#include <stdio.h>
	
	}
#include "makexpr.hxx"
#include "gramutil.hxx"

/****************************************************************************
 *	local definitions
 ***************************************************************************/
/****************************************************************************
 *	local data
 ***************************************************************************/

/****************************************************************************
 *	externs
 ***************************************************************************/
/****************************************************************************/

expr_node *
MakeReferentExpressionIfNecessary(
	expr_node * pExpr )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Create a reference expression out of this expression.

 Arguments:
	
	pExpr	- The input expression for making another reference expr.

 Return Value:

 	The final generated expression.
	
 Notes:

 	If the input expression is a simple variable, make a &(variable) expression
 	out of it. If it is already a pointer, return the same expression.

	The method is implemented for this situation: I have an expression with me,
	I dont really want to know if it is a pointer or not. I just know that this
	expression represents the final data location for me to unmarshall into or
	marshall from. Given that , generate an expression that will effectively
	point to this piece of data. So if it is already a pointer, just return the
	same expression, if it is a variable, return the address of this variable,
	if it is already a pointer, just dont do anything.
----------------------------------------------------------------------------*/
{
	node_skl	*	pNode = pExpr->GetType();
	NODE_T	NT			  = pExpr->GetType()->NodeKind();

	if( (NT == NODE_PARAM) || (NT == NODE_ID) || (NT == NODE_FIELD) )
		{
		pNode = pNode->GetBasicType();
		NT	  = pNode->NodeKind();
		}

	if( IS_BASE_TYPE_NODE( NT )  )
		{
		return MakeAddressExpressionNoMatterWhat( pExpr );
		}

	switch( NT )
		{
		default:
			MIDL_ASSERT( FALSE );

		case NODE_POINTER:
			return pExpr;
		}
}
expr_node *
MakeDereferentExpressionIfNecessary(
	expr_node * pExpr )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Create a de-reference expression out of this expression.

 Arguments:
	
	pExpr	- The input expression for making another de-reference expr.

 Return Value:

 	The final generated expression.
	
 Notes:

 	If the input expression is a simple variable, return just that.
 	If it is already a pointer, return a deref expression.

	The method is implemented for this situation: I have an expression with me,
	I dont really want to know if it is a variable or not. I just know that this
	expression represents the final data address for me to unmarshall into or
	marshall from. Given that , generate an expression that will effectively
	be a dereference of this piece of data. So if it is already a variable,
	just return the same expression, if it is a pointer, return the deref of
	this expression.
----------------------------------------------------------------------------*/
{
	expr_node	*	pENew;
	node_skl	*	pNode	= pExpr->GetType();
	NODE_T			NT		= pNode->NodeKind();

	if( (NT == NODE_PARAM) || (NT == NODE_FIELD) || (NT == NODE_ID) )
		{
		pNode	= pNode->GetBasicType();
		NT		= pNode->NodeKind();
		}

	if( IS_BASE_TYPE_NODE( NT ) )
		{
		return pExpr;
		}

	switch( NT )
		{
		default:
	//		MIDL_ASSERT( FALSE );
		case NODE_POINTER:
			pENew = new expr_u_deref( pExpr );
			pENew->SetType( pNode->GetBasicType() );
			return pENew;
		}
}

expr_node *
MakeAddressExpressionNoMatterWhat(
	expr_node	*	pExpr )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

	Make an address expression out of this one, ie generate &(expr).

 Arguments:
	
	pExpr	- A pointer to the expression to manipulate.

 Return Value:
	
 	The final expression.

 Notes:

----------------------------------------------------------------------------*/
{
	expr_node	*	pENew	= (expr_node *) new expr_u_address( pExpr );
	node_skl	*	pNode	= new node_pointer();
	pNode->SetBasicType( pExpr->GetType() );
	pNode->SetEdgeType( EDGE_USE );
	pENew->SetType( pNode );
	return pENew;
}

expr_node *
MakeDerefExpressionOfCastPtrToType(
	node_skl	*	pType,
	expr_node	*	pExpr )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

	Make an deref expression of a pointer cast to the type.

 Arguments:
	
	pType	- The type to cast to.
	pExpr	- A pointer to the expression to manipulate.

 Return Value:
	
 	The final expression.

 Notes:

----------------------------------------------------------------------------*/
{
	node_skl	*	pPtr	= new node_pointer();

	pPtr->SetBasicType( pType );
	pPtr->SetEdgeType( EDGE_USE );

	pExpr	= new expr_cast( pPtr, pExpr );
	pExpr	= new expr_u_deref( pExpr );
	pExpr->SetType( pType );

	return pExpr;
}
expr_node *
MakeExpressionOfCastPtrToType(
	node_skl	*	pType,
	expr_node	*	pExpr )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

	Make an expression of a pointer cast to the type.
      (type *) expr

 Arguments:
	
	pType	- The type to cast to.
	pExpr	- A pointer to the expression to manipulate.

 Return Value:
	
 	The final expression.

 Notes:

----------------------------------------------------------------------------*/
{
	node_skl	*	pPtr	= new node_pointer();

	pPtr->SetBasicType( pType );
	pPtr->SetEdgeType( EDGE_USE );

	pExpr	= new expr_cast( pPtr, pExpr );

	return pExpr;
}
expr_node *
MakeExpressionOfCastToTypeName(
	PNAME			pName,
	expr_node	*	pExpr )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

	Make an expression of a cast to the type whose name is specified.
      (name) expr

 Arguments:
	
	pName	- The type name to cast to.
	pExpr	- A pointer to the expression to manipulate.

 Return Value:
	
 	The final expression.

 Notes:

----------------------------------------------------------------------------*/
{
	node_skl	*	pDef	= new node_def( (char *)pName );

	pDef->SetBasicType( 0 );
	pDef->SetEdgeType( EDGE_USE );

	pExpr	= new expr_cast( pDef, pExpr );

	return pExpr;
}

expr_proc_call *
MakeProcCallOutOfParamExprList(
	PNAME			pName,
	node_skl	*	pType,
	ITERATOR&		ParamExprList )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Make a procedure call expression given a list of param expressions.

 Arguments:

 	pName			- The name of the procedure.
 	pType			- The return type of the procedure.
	ParamExprList	- The list of expressions (sans the expr_param nodes)
	
 Return Value:
	
 Notes:

----------------------------------------------------------------------------*/
{
	expr_node		*	pExpr = 0;
	expr_proc_call	*	pProc	= new expr_proc_call( pName );

	pProc->SetType( pType );

	if( ITERATOR_GETCOUNT( ParamExprList ) )
		{
		while( ITERATOR_GETNEXT( ParamExprList, pExpr ) )
			{
			pProc->SetParam( new expr_param( pExpr ) );
			}
		}

	return pProc;
}
expr_node *
MakeRefExprOutOfDeref(
	expr_node * pExpr )
	{

	if( pExpr->GetOperator() == OP_UNARY_INDIRECTION )
		{
		return pExpr->GetLeft();
		}
	return pExpr;
	}
expr_node *
MakeAddressOfPointer(
	expr_node * pExpr )
	{
	if( pExpr->GetOperator() == OP_UNARY_INDIRECTION )
		{
		return pExpr->GetLeft();
		}
	else
		{
		return MakeAddressExpressionNoMatterWhat( pExpr );
		}
	}
expr_node *
MakeCastExprPtrToUChar(
	expr_node	*	pExpr )
	{
	node_skl	*	pType;
	node_skl	*	pP;

	GetBaseTypeNode( &pType, SIGN_UNSIGNED, SIZE_CHAR, TYPE_INT );
	pP	= new node_pointer();
	pP->SetBasicType( pType );
	pP->SetEdgeType( EDGE_USE );
	return new expr_cast( pP, pExpr );
	}
expr_node *
MakeCastExprPtrToPtrToUChar(
	expr_node	*	pExpr )
	{
	node_skl	*	pType;
	node_skl	*	pP;
	node_skl	*	pP1;

	GetBaseTypeNode( &pType, SIGN_UNSIGNED, SIZE_CHAR, TYPE_INT );
	pP	= new node_pointer();
	pP->SetBasicType( pType );
	pP->SetEdgeType( EDGE_USE );
	pP1	= new node_pointer();
	pP1->SetBasicType( pP );
	pP1->SetEdgeType( EDGE_USE );
	return new expr_cast( pP1, pExpr );
	}
expr_node *
MakeCastExprPtrToVoid(
	expr_node	*	pExpr )
	{
	node_skl	*	pType;
	node_skl	*	pP;

	GetBaseTypeNode( &pType, SIGN_UNDEF, SIZE_UNDEF, TYPE_VOID );
	pP	= new node_pointer();
	pP->SetBasicType( pType );
	pP->SetEdgeType( EDGE_USE );
	return new expr_cast( pP, pExpr );
	}
void
SetPrefixes(
	ITERATOR&	VarList,
	char * pPrefix,
	expr_node * pTarget )
	{
	short Count;

	ITERATOR_INIT(VarList);

	for( Count =  pTarget->MakeListOfVars( VarList),
		 ITERATOR_INIT( VarList) ;
		 Count > 0 ;
		 Count-- )
		{
		expr_variable * pE = 0;

		if ( !ITERATOR_GETNEXT( VarList, pE ) )
		        MIDL_ASSERT(0);
		pE->SetPrefix( pPrefix );

		}
	}
void
ResetPrefixes(
	ITERATOR&	VarList,
	expr_node * pTarget )
	{
	short Count;

	ITERATOR_INIT(VarList);

	for( Count =  pTarget->MakeListOfVars( VarList),
		 ITERATOR_INIT( VarList) ;
		 Count > 0 ;
		 Count-- )
		{
		expr_variable * pE = 0;

		ITERATOR_GETNEXT( VarList, pE );
		pE->SetPrefix( 0 );

		}
	}

expr_node *
Make_1_ArrayExpressionFromVarName(
    PNAME   pName,
    int     Dimension )
    {
    expr_variable * pEV = new expr_variable( pName, 0 );
    expr_index    * pIV = new expr_index( pEV,
                                           new expr_constant( (long) Dimension)
                                         ); 
    return pIV;
    }



// This method combines all expressions in the list wiht logical ANDs. There is
// guaranteed to be at least 1 member in the list.

expr_node *
CombineIntoLogicalAndExpr(
    ITERATOR&   List )
    {
    expr_node   *   pExpr = 0;
    expr_node   *   pExpr1 = 0;

    ITERATOR_INIT( List );

    ITERATOR_GETNEXT( List, pExpr );

    while( ITERATOR_GETNEXT( List, pExpr1 ) )
        {
        pExpr = new expr_op_binary( OP_LOGICAL_AND, pExpr, pExpr1 );
        }

    return pExpr;
    }

/*******************************************************************
    We need to generate an expression to check that any pointers that
    are used in the expression are non-null, otherwise we will end
    up generating a deref of those pointers and GP fault. 

    For example, a length_is expression of *pLengthIs should generate
    code like so:
    _StubMsg.ActualCount = (pLengthIs) ? *pLengthIs : 0;

    Return the same expression if there is no pointer deref in the expr.
*******************************************************************/
expr_node *
MakeAttrExprWithNullPtrChecks(
    expr_node * pAttrExpr )
    {
    ITERATOR        List;
        
    if( pAttrExpr->MakeListOfDerefedVars( List ) )
        {
        expr_node   *   pExpr;

        // There is at least 1 deref expression here.

        pExpr = CombineIntoLogicalAndExpr( List );
        pAttrExpr = new expr_ternary( OP_QM,
                                      pExpr,
                                      pAttrExpr,
                                      new expr_constant( 0L ) );
        }
    return pAttrExpr;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\front\copyto.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-1999 Microsoft Corporation

 Module Name:

    CopyTo.cxx

 Abstract:

    cloning routines

 Notes:


 Author:

    NishadM Sep-29-1997     Created.

 Notes:


 ----------------------------------------------------------------------------*/

// unreferenced inline/local function has been removed
#pragma warning ( disable : 4514 )

// includes
#include "nodeskl.hxx"
#include "attrnode.hxx"
#include "acfattr.hxx"
#include "idict.hxx"

// externs
extern SymTable*    pBaseSymTbl;

// constants
const char* const szAsyncIntfPrefix     = "Async";
const unsigned int uAsyncIntfPrefixLen  = 5;
const char* const szFinishProcPrefix    = "Finish_";
const unsigned int uFinishProcPrefixLen = 7;
const char* const szBeginProcPrefix     = "Begin_";
const unsigned int uBeginProcPrefixLen  = 6;

// forwards
extern IDICT* pInterfaceDict;

void
FixupCallAs (
            node_call_as*,
            ITERATOR&
            );
node_interface*
DuplicateNodeInterface  (
                        node_interface*     pIntfSrc,
                        const char* const   szPrefix,
                        unsigned short      uPrefixLen
                        );
node_proc*
DuplicateNodeProc   (
                    node_proc*          pProcSrc,
                    const char* const   szPrefix,
                    unsigned            uPrefixLen,
                    unsigned long       uInterfaceKey,
                    ITERATOR&           Itr
                    );
node_param*
DuplicateNodeParam  (
                    node_param*     pParamSrc,
                    node_proc*      pProc
                    );
node_skl*
FindInOnlyParamInExpr   (
                        expr_node*  pExpr
                        );
node_skl*
GetInOnlyParamPairedWithOut (
                            MEM_ITER&    MemParamList
                            );
void
FixupBeginProcExpr  (
                    expr_node*  pExpr
                    );

void
FixupFinishProcExpr (
                    expr_node*  pExpr
                    );
void
TraverseParamsAndExprs  (
                        MEM_ITER&    MemParamList,
                        void (*CallFunc)( expr_node* )
                        );

// routines

/****************************************************************************
 CloneIFAndSplitMethods:
    Given an interface, copy it and split the methods for async.  e.g.
    method IFoo::Foo becomes AsyncIFoo::Begin_Bar and AsyncIFoo::Finish_Bar.
 ****************************************************************************/
node_interface*
CloneIFAndSplitMethods  (
                        node_interface* pSrc
                        )
    {
    node_interface* pAsyncIntf = DuplicateNodeInterface (
                                                        pSrc,
                                                        szAsyncIntfPrefix,
                                                        uAsyncIntfPrefixLen
                                                        ) ;

    if ( pAsyncIntf )
        {
        // for [call_as] fixups
        ITERATOR BeginProcList;
        ITERATOR FinishProcList;

        // each IFoo::Bar() becomes,
        named_node* pNodeProcItr = 0;
        named_node* pPrevSibling = 0;
        MEM_ITER    MemList( pSrc );
        while ( ( pNodeProcItr = MemList.GetNext() ) != 0 )
            {
            if ( pNodeProcItr->NodeKind() == NODE_PROC )
                {
                // AsyncIFoo::Begin_Bar()
                node_proc* pProcBegin = DuplicateNodeProc   (
                                                            (node_proc*)pNodeProcItr,
                                                            szBeginProcPrefix,
                                                            uBeginProcPrefixLen,
                                                            CurrentIntfKey,
                                                            BeginProcList
                                                            );
                pProcBegin->SetIsBeginProc();
                if ( pPrevSibling )
                    {
                    pPrevSibling->SetSibling( pProcBegin );
                    }
                else
                    {
                    pAsyncIntf->SetFirstMember( pProcBegin );
                    }

                // AsyncIFoo::Finish_Bar()
                node_proc* pProcFinish = DuplicateNodeProc  (
                                                            (node_proc*)pNodeProcItr,
                                                            szFinishProcPrefix,
                                                            uFinishProcPrefixLen,
                                                            CurrentIntfKey,
                                                            FinishProcList
                                                            );
                pProcFinish->SetIsFinishProc();
                pProcFinish->SetBeginProc( pProcBegin );
                pProcBegin->SetSibling( pProcFinish );
                pPrevSibling = pProcFinish;

                // AsyncIFoo::Begin_Bar() gets all [in] params of IFoo::Bar() &
                // AsyncIFoo::Finish_Bar() gets all [out] params IFoo::Bar().
                MEM_ITER    MemParamList( (node_proc*)pNodeProcItr );
                named_node* pNodeParamItr = 0;
                MemParamList.Init();
                while ( ( pNodeParamItr = (node_param *) MemParamList.GetNext() ) != 0 )
                    {
                    // if parameter has [in] or, does not have either [in] or [out] attributes
                    // assume [in] by default
                    if ( pNodeParamItr->FInSummary( ATTR_IN ) || 
                            !( pNodeParamItr->FInSummary( ATTR_IN ) || pNodeParamItr->FInSummary( ATTR_OUT ) ) )
                        {
                        ( (node_param*) pNodeParamItr )->SetAsyncBeginSibling   (
                                        DuplicateNodeParam( (node_param*)pNodeParamItr, pProcBegin )
                                                                                );
                        }
                    if ( pNodeParamItr->FInSummary( ATTR_OUT )
                         // || ( (node_param *) pNodeParamItr )->IsTaggedForAsyncFinishParamList()
                         )
                        {
                        ( (node_param*) pNodeParamItr )->SetAsyncFinishSibling  (
                                        DuplicateNodeParam( (node_param*)pNodeParamItr, pProcFinish )
                                                                                );
                        }
                    }
                // fix up expr in Begin_* and Finish_*
                MEM_ITER    BeginProcParamList( pProcBegin );
                TraverseParamsAndExprs( BeginProcParamList, FixupBeginProcExpr );

                MEM_ITER    FinishProcParamList( pProcFinish );
                TraverseParamsAndExprs( FinishProcParamList, FixupFinishProcExpr );
                }
            }
        // [call_as] fixups
        // [call_as(Baz)] IFoo::Bar() becomes,
        // [call_as(Begin_Baz)] AsyncIFoo::Begin_Bar()
        // [call_as(Finish_Baz)] AsyncIFoo::Finish_Bar()
        MEM_ITER    AsyncMemList( pAsyncIntf );
        AsyncMemList.Init();
        while ( ( pNodeProcItr = AsyncMemList.GetNext() ) != 0 )
            {
            node_call_as* pCallAs = ( node_call_as* )pNodeProcItr->GetAttribute( ATTR_CALL_AS );

            if ( pCallAs )
                {
                FixupCallAs( pCallAs, BeginProcList );
                pNodeProcItr = AsyncMemList.GetNext();
                // if Begin_* has [call_as] Finish_* has it too.
                pCallAs = ( node_call_as* )pNodeProcItr->GetAttribute( ATTR_CALL_AS );
                FixupCallAs( pCallAs, FinishProcList );
                }
            }
        }
    return pAsyncIntf;
    }


/****************************************************************************
 DuplicateNodeInterface:
    Duplicate an interface changing it's name from IFoo to AsyncIFoo and
    changing the [async_uuid] attribute to [uuid]
 ****************************************************************************/
node_interface*
DuplicateNodeInterface  (
                        node_interface*     pIntfSrc,
                        const char* const   szPrefix,
                        unsigned short      uPrefixLen
                        )
    {
    node_interface* pIntfDup = new node_interface;
    if ( pIntfDup ) 
        {
        *pIntfDup = *pIntfSrc;
        // new named_node get a new copy of the attributes
        pIntfDup->CopyAttributes( pIntfSrc );
        // members will be added later
        pIntfDup->SetFirstMember( 0 );

        // async interface inherits from base interface's async clone
        node_interface* pSrcBase = pIntfSrc->GetMyBaseInterface();
        if ( pSrcBase && pSrcBase->GetAsyncInterface() )
            {
            pIntfDup->SetMyBaseInterfaceReference   (
                                                    new node_interface_reference(
                                                        pSrcBase->GetAsyncInterface()
                                                                                )
                                                    );
            }

        // [async_uuid] becomes [uuid]
        node_guid* pAsyncGuid = (node_guid*) pIntfSrc->GetAttribute( ATTR_ASYNCUUID );
        char* szGuid = new char[strlen(pAsyncGuid->GetGuidString())+1];
        strcpy( szGuid, pAsyncGuid->GetGuidString() );
        pIntfDup->RemoveAttribute( ATTR_GUID );
        pIntfDup->RemoveAttribute( ATTR_ASYNCUUID );
        pIntfDup->SetAttribute( new node_guid( szGuid, ATTR_GUID ) );

        // IFoo becomes AsyncIFoo
        char* szName = new char[strlen(pIntfSrc->GetSymName())+uPrefixLen+1];
        strcpy( szName, szPrefix );
        strcat( szName, pIntfSrc->GetSymName() );
        pIntfDup->SetSymName( szName );

        // AsyncIFoo added to the list of interfaces
        pIntfDup->SetSibling( pIntfSrc->GetSibling() );
        pIntfSrc->SetSibling( pIntfDup );

        CurrentIntfKey = (unsigned short) pInterfaceDict->AddElement( pIntfDup );

        SymKey  SKey( pIntfDup->GetSymName(), NAME_DEF );
        named_node* pFound = pBaseSymTbl->SymSearch( SKey );
        if ( pFound )
            {
            pFound->SetChild( pIntfDup );
            }
        }
    return pIntfDup;
    }

/****************************************************************************
 DuplicateNodeProc
    Duplicate a node_proc and prefix it's name with the given string.
    Only the procedure node is duplicated, parameters are not set.
 ****************************************************************************/
node_proc*
DuplicateNodeProc   (
                    node_proc*          pProcSrc,
                    const char* const   szPrefix,
                    unsigned            uPrefixLen,
                    unsigned long       uInterfaceKey,
                    ITERATOR&           Itr
                    )
    {
    node_proc*  pProcDup = new node_proc( short( 0 ), true );
    // pProcSrc->CopyTo( pProcDup );
    *pProcDup = *pProcSrc;
    pProcDup->SetSibling( 0 );
    pProcDup->SetClientCorrelationCount();
    pProcDup->SetServerCorrelationCount();
    // new named_node get a new copy of the attributes
    pProcDup->CopyAttributes( pProcSrc );
    // members will be added later
    pProcDup->SetFirstMember( 0 );
    pProcDup->SetInterfaceKey( uInterfaceKey );
    char* szName = new char[strlen(pProcSrc->GetSymName())+uPrefixLen+1];
    strcpy( szName, szPrefix );
    strcat( szName, pProcSrc->GetSymName() );
    pProcDup->SetSymName( szName );
    ITERATOR_INSERT( Itr, pProcDup );
    return pProcDup;
    }

/****************************************************************************
 DuplicateNodeParam:
    Duplicate the given parameter and attach it to the given procedure.
 ****************************************************************************/
node_param*
DuplicateNodeParam  (
                    node_param*     pParamSrc,
                    node_proc*      pProc
                    )
    {
    node_param* pParamDup = new node_param;
    // pParamSrc->CopyTo( pParamDup );
    *pParamDup = *pParamSrc;
    pParamDup->SetSibling( 0 );
    // new named_node get a new copy of the attributes
    pParamDup->CopyAttributes( pParamSrc );
    pProc->AddLastMember( pParamDup );
    return pParamDup;
    }

/****************************************************************************
 FixupCallAs:
    When an async interface is created from a sync one the duplicated
    interface still points to stuff in the original interface.  Fix up [call_as]
    procs to point to the split procedures instead.
 ****************************************************************************/
void
FixupCallAs( node_call_as* pCallAs, ITERATOR& ProcList )
    {
    char*       szProcName = pCallAs->GetCallAsName();
    node_proc*  pProcItr = 0;

    ITERATOR_INIT( ProcList );
    while ( ITERATOR_GETNEXT( ProcList, pProcItr ) )
        {
        // advance past Begin_ or Finish_
        char*   szProcItrName = pProcItr->GetSymName();
        szProcItrName = strchr( szProcItrName, '_' );
        szProcItrName++;
        // semantic errors will be caught in node_proc::SemanticAnalysis()
        if ( !strcmp( szProcItrName, szProcName ) )
            {
            pCallAs->SetCallAsName( pProcItr->GetSymName() );
            pCallAs->SetCallAsType( pProcItr );
            break;
            }
        }
    }

/****************************************************************************
 FindInOnlyParamInExpr:
    Search an expression for an in-only parameter.
 ****************************************************************************/
node_skl*
FindInOnlyParamInExpr   (
                        expr_node*  pExpr
                        )
    {
    node_skl* pRet = 0;
    if ( pExpr )
        {
         if ( pExpr->IsAVariable() )
            {
            if ( !pExpr->GetType()->FInSummary( ATTR_OUT ) )
                pRet = pExpr->GetType();
            }
        else
            {
            pRet = FindInOnlyParamInExpr( pExpr->GetLeft() );
            if ( !pRet )
                {
                pRet = FindInOnlyParamInExpr( pExpr->GetRight() );
                }
            }        
        }
    return pRet;
    }

/****************************************************************************
 GetUnknownExpression:
    Determine if a given expression is a non-simple with in parameters.
    An expression is simple if it is NULL, a constant, or a single variable.
    An expression is also simple if it is of the form "var+1", "var-1", 
    "var*2", "var/2", or "*var" (these are simple because they can be
    expressed by directly in the correlation descriptor).

    If the expression is non-simple with in parameters, non-0 is returned,
    else 0 is returned.
 ****************************************************************************/
bool
IsSimpleExpression(
                expr_node*  pExpr
                )
    {
    if ( ! pExpr || pExpr->IsAVariable() || pExpr->IsConstant() )
        {
        return true;
        }

    expr_node*  pExprLHS = pExpr->GetLeft();
    expr_node*  pExprRHS = pExpr->GetRight();

    switch ( pExpr->GetOperator() )
        {
        case OP_SLASH:
        case OP_STAR:
            if ( pExprLHS->IsAVariable() &&
                     pExprRHS->IsConstant() &&
                     ((expr_constant *)pExprRHS)->GetValue() == 2 )
                {
                return true;
                }
            break;

        case OP_PLUS :
        case OP_MINUS :
            if ( pExprLHS->IsAVariable() &&
                     pExprRHS->IsConstant() &&
                     ((expr_constant *)pExprRHS)->GetValue() == 1 )
                {
                return true;
                }
            break;

        case OP_UNARY_INDIRECTION :
            if ( pExprLHS->IsAVariable() )
                {
                return true;
                }
            break;

       default:
            break;
        }

    return false;
    }

/****************************************************************************
 GetInOnlyParamPairedWithOut:
    Determine if any of the expression in the given parameter list mixes
    in and out parameters in non-simple ways.  Return non-0 if the do and 0
    if they don't.
 ****************************************************************************/
node_skl*
GetInOnlyParamPairedWithOut (
                            MEM_ITER&    MemParamList
                            )
    {
    named_node* pNodeParamItr = 0;
    node_skl* pNode  = 0;
    MemParamList.Init();
    while ( ( pNodeParamItr = (node_param *) MemParamList.GetNext() ) != 0 )
        {
        if ( !pNodeParamItr->GetAttribute( ATTR_OUT ) )
            {
            continue;
            }
        node_base_attr* pAttr;
        ATTRLIST        AList = pNodeParamItr->GetAttributeList(AList);
        ATTR_T          lastAttrID = ATTR_NONE;
        int             nAttrInstance = 0;
        bool            bFirstInstanceWasNull = false;
        bool            bHasInParam = false;

        for ( pAttr = AList.GetFirst(); NULL != pAttr && 0 == pNode; pAttr = pAttr->GetNext() )
            {
            ATTR_T  thisAttrID = pAttr->GetAttrID();

            if ( thisAttrID == lastAttrID )
                ++nAttrInstance;
            else
                nAttrInstance = 1;

            lastAttrID = thisAttrID;

            switch ( thisAttrID )
                {
                case ATTR_SIZE:
                case ATTR_LENGTH:
                case ATTR_SWITCH_IS:
                case ATTR_IID_IS:
                case ATTR_FIRST:
                case ATTR_LAST:
                case ATTR_MAX:
                case ATTR_MIN:
                    {
                    if ( 1 == nAttrInstance )
                        {
                        bFirstInstanceWasNull = ( NULL == pAttr->GetExpr() );
                        bHasInParam = false;
                        }

                    // Don't allow any dimensions after one with an in param
                    if ( bHasInParam )
                        {
                        pNode = (node_skl *) -1;
                        break;
                        }
                        
                    if ( FindInOnlyParamInExpr( pAttr->GetExpr() ) )
                        {
                        if ( ! IsSimpleExpression( pAttr->GetExpr() )
                             || ( nAttrInstance > 2 )
                             || ( nAttrInstance == 2 && ! bFirstInstanceWasNull ) )
                            {
                            pNode = (node_skl *) -1;
                            break;
                            }

                        bHasInParam = true;
                        }

                    break;
                    }
                   
                case ATTR_BYTE_COUNT:
                    {
                    pNode = ( ( node_byte_count* ) pAttr )->GetByteCountParam();
                    if ( pNode->FInSummary( ATTR_OUT ) )
                        {
                        pNode = 0;
                        }
                    break;
                    }

                default:
                    // Only need to worry about attributes with parameter
                    // expressions
                    break;
                }
            }

        if ( pNode )
            {
            // Do this to have an error message context.
            pNode = pNodeParamItr;
            break;
            }
        }

    return pNode;
    }

/****************************************************************************
 FixupFinishProcExpr:
    When an async interface is created from a sync one the duplicated
    interface still points to stuff in the original interface.  Fix up 
    parameters in a Finish method to point to the duplicated parameters
    in the async interface instead of the original sync interface.
 ****************************************************************************/
void
FixupFinishProcExpr (
                    expr_node*  pExpr
                    )
    {
    if ( pExpr )
        {
        // If we don't have a type then that means we have a reference to a
        // variable that doesn't exist.  The dangling reference will be caught
        // and reported in FIELD_ATTR_INFO::Validate

        if ( NULL == pExpr->GetType() )
            {
            return;
            }

        if ( pExpr->GetType()->NodeKind() == NODE_PARAM )
            {
            node_param* pParam = (node_param*)pExpr->GetType();
            if ( pParam->GetAsyncFinishSibling() )
                {
                pExpr->SetType( pParam->GetAsyncFinishSibling() );
                }
            else
                {
                pExpr->SetType( pParam->GetAsyncBeginSibling() );
                pParam->GetAsyncBeginSibling()->SaveForAsyncFinish();
                }
            }
        FixupFinishProcExpr( pExpr->GetLeft() );
        FixupFinishProcExpr( pExpr->GetRight() );
        // FixupFinishProcExpr( pExpr->GetRelational() );
        }
    }

/****************************************************************************
 FixupFinishProcExpr:
    When an async interface is created from a sync one the duplicated
    interface still points to stuff in the original interface.  Fix up 
    parameters in a Begin method to point to the duplicated parameters
    in the async interface instead of the original sync interface.
 ****************************************************************************/
void
FixupBeginProcExpr  (
                    expr_node*  pExpr
                    )
    {
    if ( pExpr )
        {
        // If we don't have a type then that means we have a reference to a
        // variable that doesn't exist.  The dangling reference will be caught
        // and reported in FIELD_ATTR_INFO::Validate

        if ( NULL == pExpr->GetType() )
            {
            return;
            }

        if ( pExpr->GetType()->NodeKind() == NODE_PARAM )
            {
            node_param* pParam = (node_param*)pExpr->GetType();
            pExpr->SetType( pParam->GetAsyncBeginSibling() );
            }
        FixupBeginProcExpr( pExpr->GetLeft() );
        FixupBeginProcExpr( pExpr->GetRight() );
        // FixupExpr( pExpr->GetRelational() );
        }
    }

/****************************************************************************
 FixupFinishProcExpr:
    When an async interface is created from a sync one the duplicated
    interface still points to stuff in the original interface.  This routine
    traverses the parameters and fixes up the pointers to point to the 
    proper stuff in the duplicated interface instead.

    This routine is quite specific to the needs of async and is not meant as
    a general purpose parameter traversing function.
 ****************************************************************************/
void
TraverseParamsAndExprs  (
                        MEM_ITER&    MemParamList,
                        void (*CallFunc)( expr_node* )
                        )
    {
    node_param* pNodeParamItr = 0;

    MemParamList.Init();
    while ( ( pNodeParamItr = ( node_param *) MemParamList.GetNext() ) != 0 )
        {
        node_base_attr* pAttr;
        ATTRLIST        AList = pNodeParamItr->GetAttributeList(AList);

        for ( pAttr = AList.GetFirst(); NULL != pAttr; pAttr = pAttr->GetNext() )
            {
            switch ( pAttr->GetAttrID() )
                {
                case ATTR_SIZE:
                case ATTR_LENGTH:
                case ATTR_SWITCH_IS:
                case ATTR_IID_IS:
                case ATTR_FIRST:
                case ATTR_LAST:
                case ATTR_MAX:
                case ATTR_MIN:
                    {
                    CallFunc( pAttr->GetExpr() );
                    break;
                    }
                    
                case ATTR_BYTE_COUNT:
                    {
                    node_param* pParam = ( ( node_byte_count* ) pAttr )->GetByteCountParam();
                    if ( FixupBeginProcExpr == CallFunc )
                        {
                        ( ( node_byte_count* ) pAttr )->SetByteCountParam( pParam->GetAsyncBeginSibling() );
                        }
                    else
                        {
                        if ( pParam->GetAsyncFinishSibling() )
                            {
                            ( ( node_byte_count* ) pAttr )->SetByteCountParam( pParam->GetAsyncFinishSibling() );
                            }
                        else
                            {
                            ( ( node_byte_count* ) pAttr )->SetByteCountParam( pParam->GetAsyncBeginSibling() );
                            pParam->GetAsyncBeginSibling()->SaveForAsyncFinish();
                            }
                        }
                    }

                default:
                    // Only need to worry about attributes with parameter
                    // expressions
                    break;
                }
            }
        }
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\expr\exprpr.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-1999 Microsoft Corporation

 Module Name:
	
	exprpr.cxx

 Abstract:

	expression evaluator print routines implementation.

 Notes:


 History:

 	VibhasC		Aug-05-1993		Created

 ----------------------------------------------------------------------------*/

#pragma warning ( disable : 4514 )

/****************************************************************************
 *	include files
 ***************************************************************************/
#include "nulldefs.h"

extern "C"
	{
	#include <stdio.h>
	
	#include <string.h>
	}

#include "expr.hxx"
#include "nodeskl.hxx"

/****************************************************************************
 *	extern definitions
 ***************************************************************************/

extern char * OperatorToString( OPERATOR Op );

/***************************************************************************/

void
expr_node::PrintWithPrefix(
    ISTREAM *   pStream,
    char *      pPrefix )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    This routine prints an expression adding a prefix to each of the varaibles
    within the expression.

 Arguments:

 	pStream		- A pointer to the stream to output to.
    pPrefix     - the prefix to be prepended to each variable
	
 Return Value:
	
 Notes:

----------------------------------------------------------------------------*/
{
    ITERATOR  VarList;
    expr_variable * pVarNode = 0;

    short VarCount = MakeListOfVars( VarList );
    if ( VarCount )
        {

        VarList.Init();
        while ( ITERATOR_GETNEXT( VarList, pVarNode ) )
            pVarNode->SetPrefix( pPrefix );
        }

    Print( pStream );

    if ( VarCount )
        {
        VarList.Init();
        while ( ITERATOR_GETNEXT( VarList, pVarNode ) )
            pVarNode->SetPrefix( NULL );
        }
}



/*
//  table of precedences ( lower number => lower precedence )
 200	[] () . -> ()++ ()--
 190	++() --() sizeof() & *(deref) +() -() ~() !()
 180	(cast)
 170	* / %
 160	+ -
 150	<< >>
 140	< > <= >=
 130	== !=
 120	& (bitwise)
 110	^
 100	|
 90		&&
 80		||
 70		?:
 60		= *= /= %= += -= <<= >>= &= |= ^=
 50		, (seqential eval)
 0		all other operators (should be none)
 */

const short Prec[] =
	{
	0	// OP_ILLEGAL = OP_START

	// OP_UNARY_START

	// OP_UNARY_ARITHMETIC_START	= OP_UNARY_START
	,190	// OP_UNARY_PLUS 				= OP_UNARY_ARITHMETIC_START
	,190	// OP_UNARY_MINUS
	// OP_UNARY_ARITHMETIC_END

	// OP_UNARY_LOGICAL_START		= OP_UNARY_ARITHMETIC_END
	,190	// OP_UNARY_NOT				= OP_UNARY_LOGICAL_START
	,190	// OP_UNARY_COMPLEMENT
	// OP_UNARY_LOGICAL_END

	,190	// OP_UNARY_INDIRECTION		= OP_UNARY_LOGICAL_END
	,180	// OP_UNARY_CAST
	,190	// OP_UNARY_AND
	,190	// OP_UNARY_SIZEOF
        ,190    // OP_UNARY_ALIGNOF
	,190	// OP_PRE_INCR
	,190	// OP_PRE_DECR
	,200	// OP_POST_INCR
	,200	// OP_POST_DECR

	// OP_UNARY_END

	// OP_BINARY_START			= OP_UNARY_END

	// OP_BINARY_ARITHMETIC_START	= OP_BINARY_START
	,160	// OP_PLUS					= OP_BINARY_ARITHMETIC_START
	,160	// OP_MINUS
	,170	// OP_STAR
	,170	// OP_SLASH
	,170	// OP_MOD
	// OP_BINARY_ARITHMETIC_END

	// OP_BINARY_SHIFT_START		= OP_BINARY_ARITHMETIC_END
	,150	// OP_LEFT_SHIFT				= OP_BINARY_SHIFT_START
	,150	// OP_RIGHT_SHIFT
	// OP_BINARY_SHIFT_END

	// OP_BINARY_RELATIONAL_START	= OP_BINARY_SHIFT_END
	,140	// OP_LESS					= OP_BINARY_RELATIONAL_START
	,140	// OP_LESS_EQUAL
	,140	// OP_GREATER_EQUAL
	,140	// OP_GREATER
	,130	// OP_EQUAL
	,130	// OP_NOT_EQUAL
	// OP_BINARY_RELATIONAL_END

	// OP_BINARY_BITWISE_START	= OP_BINARY_RELATIONAL_END
	,120	// OP_AND						= OP_BINARY_BITWISE_START
	,100	// OP_OR
	,110	// OP_XOR
	// OP_BINARY_BITWISE_END

	// OP_BINARY_LOGICAL_START	= OP_BINARY_BITWISE_END
	,90		// OP_LOGICAL_AND				= OP_BINARY_LOGICAL_START
	,80		// OP_LOGICAL_OR
	// OP_BINARY_LOGICAL_END

	// OP_BINARY_TERNARY_START	= OP_BINARY_LOGICAL_END
	,70		// OP_QM						= OP_BINARY_TERNARY_START
	,70		// OP_COLON
	// OP_BINARY_TERNARY_END

	// OP_BINARY_END				= OP_BINARY_TERNARY_END

	,0		// OP_INTERNAL_START			= OP_BINARY_END
	,200	// OP_FUNCTION
	,0		// OP_PARAM

	,200	// OP_POINTSTO
	,200	// OP_DOT
	,200	// OP_INDEX
	,50		// OP_COMMA
	,0		// OP_STMT
	,60		// OP_ASSIGN
	
	,0		// OP_END
	};


/*
//  table of associativity ( -1 => L to R, 1 => R to L )
 -1	[] () . -> ()++ ()--
 1	++() --() sizeof() & *(deref) +() -() ~() !()
 1	(cast)
 -1	* / %
 -1	+ -
 -1	<< >>
 -1	< > <= >=
 -1	== !=
 -1	& (bitwise)
 -1	^
 -1	|
 -1		&&
 -1		||
 1		?:
 1		= *= /= %= += -= <<= >>= &= |= ^=
 -1		, (seqential eval)
 0		all other operators (should be none)
 */

const short AssocTbl[] =
	{
	0	// OP_ILLEGAL = OP_START

	// OP_UNARY_START

	// OP_UNARY_ARITHMETIC_START	= OP_UNARY_START
	,-1	// OP_UNARY_PLUS 				= OP_UNARY_ARITHMETIC_START
	,-1	// OP_UNARY_MINUS
	// OP_UNARY_ARITHMETIC_END

	// OP_UNARY_LOGICAL_START		= OP_UNARY_ARITHMETIC_END
	,1	// OP_UNARY_NOT				= OP_UNARY_LOGICAL_START
	,1	// OP_UNARY_COMPLEMENT
	// OP_UNARY_LOGICAL_END

	,1	// OP_UNARY_INDIRECTION		= OP_UNARY_LOGICAL_END
	,1	// OP_UNARY_CAST
	,1	// OP_UNARY_AND
	,1	// OP_UNARY_SIZEOF
        ,1      // OP_UNARY_ALIGNOF
	,1	// OP_PRE_INCR
	,1	// OP_PRE_DECR
	,-1	// OP_POST_INCR
	,-1	// OP_POST_DECR

	// OP_UNARY_END

	// OP_BINARY_START			= OP_UNARY_END

	// OP_BINARY_ARITHMETIC_START	= OP_BINARY_START
	,-1	// OP_PLUS					= OP_BINARY_ARITHMETIC_START
	,-1	// OP_MINUS
	,-1	// OP_STAR
	,-1	// OP_SLASH
	,-1	// OP_MOD
	// OP_BINARY_ARITHMETIC_END

	// OP_BINARY_SHIFT_START		= OP_BINARY_ARITHMETIC_END
	,-1	// OP_LEFT_SHIFT				= OP_BINARY_SHIFT_START
	,-1	// OP_RIGHT_SHIFT
	// OP_BINARY_SHIFT_END

	// OP_BINARY_RELATIONAL_START	= OP_BINARY_SHIFT_END
	,-1	// OP_LESS					= OP_BINARY_RELATIONAL_START
	,-1	// OP_LESS_EQUAL
	,-1	// OP_GREATER_EQUAL
	,-1	// OP_GREATER
	,-1	// OP_EQUAL
	,-1	// OP_NOT_EQUAL
	// OP_BINARY_RELATIONAL_END

	// OP_BINARY_BITWISE_START	= OP_BINARY_RELATIONAL_END
	,-1	// OP_AND						= OP_BINARY_BITWISE_START
	,-1	// OP_OR
	,-1	// OP_XOR
	// OP_BINARY_BITWISE_END

	// OP_BINARY_LOGICAL_START	= OP_BINARY_BITWISE_END
	,-1		// OP_LOGICAL_AND				= OP_BINARY_LOGICAL_START
	,-1		// OP_LOGICAL_OR
	// OP_BINARY_LOGICAL_END

	// OP_BINARY_TERNARY_START	= OP_BINARY_LOGICAL_END
	,1		// OP_QM						= OP_BINARY_TERNARY_START
	,1		// OP_COLON
	// OP_BINARY_TERNARY_END

	// OP_BINARY_END				= OP_BINARY_TERNARY_END

	,0		// OP_INTERNAL_START			= OP_BINARY_END
	,0		// OP_FUNCTION
	,0		// OP_PARAM

	,-1	// OP_POINTSTO
	,-1	// OP_DOT
	,-1	// OP_INDEX
	,-1		// OP_COMMA
	,0		// OP_STMT
	,1		// OP_ASSIGN
	
	,0		// OP_END
	};

void
expr_operator::PrintSubExpr(
	expr_node	* pExpr,
	ISTREAM	*	pStream )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Print a subexpression, optionally adding parens.

 Arguments:

	pExpr		- the expression to print
 	pStream		- A pointer to the stream to output to.
	
 Return Value:
	
 Notes:

----------------------------------------------------------------------------*/
{
	short	PrecMe		= Prec[ GetOperator() ];
	short	PrecChild;
	BOOL	fAddParens	= FALSE;
	
	if ( pExpr->IsOperator() )
		{
		PrecChild = Prec[ pExpr->GetOperator() ];
		// account for associativity
		if ( pExpr != GetLeft() )
			PrecChild = short( PrecChild + AssocTbl[ pExpr->GetOperator() ] );

		fAddParens = PrecChild < PrecMe;
		}
		
	if ( fAddParens )
		pStream->Write('(');

	pExpr->Print( pStream );

	if ( fAddParens )
		pStream->Write(')');

}


void
expr_variable::Print(
	ISTREAM	*	pStream )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Print a variable name expression.

 Arguments:

 	pStream		- A pointer to the stream to output to.
	
 Return Value:
	
 Notes:

----------------------------------------------------------------------------*/
{
    if ( GetPrefix() )
    	pStream->Write( GetPrefix() );
	pStream->Write( GetName() );
}

char	*	ConstFormats[]	=
	{
	"\"%s\"",		// string
	"L\"%Ls\"",		// wstring
	"0x%x",			// char
	"L'%Lc'",		// wchar

	"%d",			// numeric
	"%uU",			// numeric unsigned
	"%ldL",			// numeric long
	"%luUL",		// numeric unsigned long

	"%#x",			// hex
	"%#xU",			// hex unsigned
	"%#lxL",		// hex long
	"%#lxUL",		// hex unsigned long

	"%#o",			// octal
	"%#oU",			// octal unsigned 
	"%#loL",		// octal long
	"%#loUL",		// octal unsigned long

	"%s",			// BOOL ( not used )

	"%g",			// float
	"%lg",			// double

// RKK64
// value types for int64

	};

void
expr_constant::Print(
	ISTREAM	*	pStream )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

	Emit a constant expression to the stream.

 Arguments:
	
	pStream	- A pointer to the stream.

 Return Value:
	
 Notes:

----------------------------------------------------------------------------*/
{
	char Array[ 256 ];

    Array[0] = 0;
	if (Format == VALUE_TYPE_BOOL)
        {
		strcpy( Array,  (Value.L) ? "TRUE" : "FALSE" );
        }
    else if ( Format == VALUE_TYPE_FLOAT )
        {
		sprintf( Array, ConstFormats[ Format] , Value.F );
        }
    else if ( Format == VALUE_TYPE_DOUBLE )
        {
		sprintf( Array, ConstFormats[ Format] , Value.D );
        }
    else if ( Format == VALUE_TYPE_CHAR )
        {
        if ( Value.C )
            {
            Array[0] = '0';
            Array[1] = 'x';
            char ch = ( char ) ( ( Value.C >> 4 ) & 0xF );
            Array[2] = ( char ) ( ( ch >= 0 && ch <= 9 ) ? ch + '0' : ch + 'A' - 0xA );
            ch = ( char ) ( Value.C & 0xF );
            Array[3] = ( char ) ( ( ch >= 0 && ch <= 9 ) ? ch + '0' : ch + 'A' - 0xA );
            Array[4] = 0;
            }
        else
            {
            Array[0] = '0';
            Array[1] = 0;
            }
        }
    else if ( Format == VALUE_TYPE_STRING )
        {
        if (Value.pC) 
            {
	        pStream->Write( "\"" );
	        pStream->Write( ( char* ) Value.pC );
	        pStream->Write( "\"" );
            }
        else
            {
	        pStream->Write( "0" );
            }
        }
    else if ( Format == VALUE_TYPE_WSTRING )
        {
        if (Value.pWC) 
            {
	        pStream->Write( "L\"" );
	        pStream->Write( ( char* ) Value.pWC );
	        pStream->Write( "\"" );
            }
        else
            {
	        pStream->Write( "0" );
            }
        }
	else
        {
		sprintf( Array, ConstFormats[ Format] , Value.I64 );
        }
	pStream->Write( (char *)Array );
}

void
expr_op_unary::Print(
	ISTREAM	*	pStream )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

	Emit a unary expression to the stream.

 Arguments:
	
	pStream	- A pointer to the stream.

 Return Value:
	
 Notes:

----------------------------------------------------------------------------*/
{
	OPERATOR	Op	= GetOperator();
	char		ch;

	switch( Op )
		{
		case OP_UNARY_PLUS:			ch = '+'; break;
		case OP_UNARY_MINUS:		ch = '-'; break;
		case OP_UNARY_NOT:			ch = '!'; break;
		case OP_UNARY_COMPLEMENT:	ch = '~'; break;
		case OP_UNARY_INDIRECTION:	ch = '*'; break;
		case OP_UNARY_AND:			ch = '&'; break;
		default:					ch = 'X'; break;
		}

	pStream->Write( ch );
	PrintSubExpr( GetLeft(), pStream );
}

void
expr_cast::Print(
	ISTREAM * pStream )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Emit a cast expression.

 Arguments:
 	
 	pStream	- A pointer to the stream.
	
 Return Value:

 	None.
	
 Notes:

 	Not implemented for now.

----------------------------------------------------------------------------*/
{
    if ( GetEmitModifiers() == true )
        {
	    GetType()->PrintType( (PRT_CAST),
					       pStream,
					       (node_skl *)0
					    );
        }
    else
        {
	    GetType()->PrintType( (PRT_CAST) | PRT_SUPPRESS_MODIFIERS,
					       pStream,
					       (node_skl *)0
					    );
        }
	PrintSubExpr( GetLeft(), pStream );

}

void
expr_sizeof::Print(
	ISTREAM * pStream )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Emit a sizeof expression.

 Arguments:
 	
 	pStream	- A pointer to the stream.
	
 Return Value:

 	None.
	
 Notes:

 	Not implemented for now.

----------------------------------------------------------------------------*/
{
	pStream->Write( "sizeof" );
	pType->PrintType( (PRT_CAST | PRT_ARRAY_SIZE_ONE),
					   pStream,
					   (node_skl *)0
					);
}

void
expr_alignof::Print(
	ISTREAM * pStream )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Emit a sizeof expression.

 Arguments:
 	
 	pStream	- A pointer to the stream.
	
 Return Value:

 	None.
	
 Notes:

 	Not implemented for now.

----------------------------------------------------------------------------*/
{
	pStream->Write( "__alignof" );
	pType->PrintType( (PRT_CAST | PRT_ARRAY_SIZE_ONE),
					   pStream,
					   (node_skl *)0
					);
}


void
expr_pre_incr::Print(
	ISTREAM * pStream )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Emit a pre-incr expression.

 Arguments:
 	
 	pStream	- A pointer to the stream.
	
 Return Value:

 	None.
	
 Notes:

 	Not implemented for now.

----------------------------------------------------------------------------*/
{
	pStream->Write("++");
	PrintSubExpr( GetLeft(), pStream );
}

void
expr_pre_decr::Print(
	ISTREAM * pStream )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Emit a pre-decrement expression.

 Arguments:
 	
 	pStream	- A pointer to the stream.
	
 Return Value:

 	None.
	
 Notes:

 	Not implemented for now.

----------------------------------------------------------------------------*/
{
	pStream->Write("--");
	PrintSubExpr( GetLeft(), pStream );
}

void
expr_post_incr::Print(
	ISTREAM * pStream )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Emit a post-increment expression.

 Arguments:
 	
 	pStream	- A pointer to the stream.
	
 Return Value:

 	None.
	
 Notes:

 	Not implemented for now.

----------------------------------------------------------------------------*/
{
	PrintSubExpr( GetLeft(), pStream );
	pStream->Write("++");
}

void
expr_post_decr::Print(
	ISTREAM * pStream )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Emit a post-decrement expression.

 Arguments:
 	
 	pStream	- A pointer to the stream.
	
 Return Value:

 	None.
	
 Notes:

 	Not implemented for now.

----------------------------------------------------------------------------*/
{
	PrintSubExpr( GetLeft(), pStream );
	pStream->Write("--");
}

void
expr_op_binary::Print(
	ISTREAM * pStream )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Emit a binary arithmetic expression.

 Arguments:
 	
 	pStream	- A pointer to the stream.
	
 Return Value:

 	None.
	
 Notes:

 	Not implemented for now.

----------------------------------------------------------------------------*/
{
	PrintSubExpr( GetLeft(), pStream );

	pStream->Write( OperatorToString( GetOperator() ) );

	PrintSubExpr( GetRight(), pStream );

}
void
expr_op_binary::PrintCall(
	ISTREAM	*	pStream,
	short		LeftMargin,
	BOOL		fInProc )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

	Emit expression as part of a procedure call.

 Arguments:

 	pStream	- A pointer to the stream.
 	LeftMargin	- The start margin for the procedure call.
 	fInProc	- Is it in a proc context already ?
	
 Return Value:
	
 	None.

 Notes:

	The left margin is 0 if the call is the only thing on the line. If the
	call is in an assignment, the start of param indent must take that into
	account.
----------------------------------------------------------------------------*/
{
	expr_node	*	pN;
	if ( ( pN = GetLeft() ) != 0 )
		pN->PrintCall( pStream, LeftMargin, fInProc );

	pStream->Write( OperatorToString( GetOperator() ) );

	if ( ( pN = GetRight() ) != 0 )
		pN->PrintCall( pStream, LeftMargin, fInProc );
}
void
expr_assign::PrintCall(
	ISTREAM	*	pStream,
	short		LeftMargin,
	BOOL		fInProc )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

	Emit expression as part of a procedure call.

 Arguments:

 	pStream	- A pointer to the stream.
 	LeftMargin	- The start margin for the procedure call.
 	fInProc	- Is it in a proc context already ?
	
 Return Value:
	
 	None.

 Notes:

	The left margin is 0 if the call is the only thing on the line. If the
	call is in an assignment, the start of param indent must take that into
	account.
----------------------------------------------------------------------------*/
{
	expr_node	*	pN;
	if ( ( pN = GetLeft() ) != 0 )
		pN->PrintCall( pStream, LeftMargin, fInProc );

	pStream->Write( " = " );

	if ( ( pN = GetRight() ) != 0 )
		pN->PrintCall( pStream, LeftMargin, fInProc );
}

void
expr_index::Print(
	ISTREAM	*	pStream )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

	Emit expression for the array index operator.

 Arguments:

 	pStream	- A pointer to the stream.
	
 Return Value:
	
 	None.

 Notes:

----------------------------------------------------------------------------*/
{

	PrintSubExpr( GetLeft(), pStream );
	pStream->Write( '[' );
	GetRight()->Print( pStream );
	pStream->Write( ']' );
}
void
expr_index::PrintCall(
	ISTREAM	*	pStream,
	short		LeftMargin,
	BOOL		fInProc )
	{
	GetLeft()->PrintCall( pStream, LeftMargin, fInProc );
	pStream->Write( '[' );
	GetRight()->PrintCall( pStream, LeftMargin, fInProc );
	pStream->Write( ']' );
	}

void
expr_proc_call::PrintCall(
	ISTREAM	*	pStream,
	short		LeftMargin,
	BOOL		fInProc )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

	Emit expression for a procedure call.

 Arguments:

 	pStream	- A pointer to the stream.
 	LeftMargin	- The start margin for the procedure call.
 	fInProc	- Is it in a proc context already ?
	
 Return Value:
	
 	None.

 Notes:

	The left margin is 0 if the call is the only thing on the line. If the
	call is in an assignment, the start of param indent must take that into
	account.
----------------------------------------------------------------------------*/
{
	PNAME	pName = GetName();
	unsigned short CurPref	= pStream->GetPreferredIndent();
	unsigned short CurIndent= pStream->GetIndent();

	//
	// Print fancy only if more than 2 params.
	//

	if( GetNoOfParams() < 3 )
		{
		Print( pStream );
		if( !fInProc )
			pStream->Write(';');
		return;
		}

	pStream->Write( GetName() );

	pStream->Write( '(' );
	pStream->SetPreferredIndent( short( LeftMargin + CurPref + strlen( pName ) - CurIndent ) );
	pStream->IndentInc();
	pStream->NewLine();
	if( GetFirstParam())
		{
		GetFirstParam()->PrintCall( pStream,
								    LeftMargin,
								    TRUE // now in proc context
								  );
		}

	pStream->Write( ')' );
	if( !fInProc )
		pStream->Write( ';' );
	pStream->IndentDec();
	pStream->SetPreferredIndent( CurPref );
}

void
expr_proc_call::Print(
	ISTREAM	*	pStream )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

	Emit expression for a procedure call.

 Arguments:

 	pStream	- A pointer to the stream.
	
 Return Value:
	
 	None.

 Notes:

----------------------------------------------------------------------------*/
{
	pStream->Write( GetName() );
	pStream->Write( '(' );
	if( GetFirstParam())
		GetFirstParam()->Print( pStream );
	pStream->Write( ')' );
}

void
expr_param::Print(
	ISTREAM	*	pStream )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

	Emit expression for a parameter.

 Arguments:

 	pStream	- A pointer to the stream.
	
 Return Value:
	
 	None.

 Notes:

----------------------------------------------------------------------------*/
{
	expr_node * pNextParam;

	GetLeft()->Print( pStream );

	if ( ( pNextParam = GetNextParam() ) != 0 )
		{
		pStream->Write( ',' );
//		pStream->NewLine();
		pNextParam->Print( pStream );
		}
}

void
expr_param::PrintCall(
	ISTREAM	*	pStream,
	short		LeftMargin,
	BOOL		fInProc )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

	Emit expression as part of a procedure call.

 Arguments:

 	pStream	- A pointer to the stream.
 	LeftMargin	- The start margin for the procedure call.
 	fInProc	- Is it in a proc context already ?
 	pStream	- A pointer to the stream.
	
 Return Value:
	
 	None.

 Notes:

----------------------------------------------------------------------------*/
{
	expr_node * pNextParam;

	GetLeft()->PrintCall( pStream, LeftMargin, fInProc );

	if ( ( pNextParam = GetNextParam() ) != 0 )
		{
		pStream->Write( ',' );
		pStream->NewLine();
		pNextParam->PrintCall( pStream, LeftMargin, fInProc );
		}
}

void
expr_ternary::Print(
	ISTREAM * pStream )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Emit a ternary expression.

 Arguments:
 	
 	pStream	- A pointer to the stream.
	
 Return Value:

 	None.
	
 Notes:

 	Not implemented for now.

----------------------------------------------------------------------------*/
{
	PrintSubExpr( GetRelational(), pStream );
	pStream->Write( " ? " );
	PrintSubExpr( GetLeft(), pStream );
	pStream->Write( " : " );
	PrintSubExpr( GetRight(), pStream );
}
/****************************************************************************
 	utilities
 ****************************************************************************/
char *
OperatorToString(
	OPERATOR	Op )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Translate the operator to its string.

 Arguments:
	
	Op	- The operator value.

 Return Value:
	
 Notes:

----------------------------------------------------------------------------*/
{
    char *p;

    switch( Op )
        {
        case OP_PLUS:           p = " + ";  break;
        case OP_MINUS:          p = " - ";  break;
        case OP_STAR:           p = " * ";  break;
        case OP_SLASH:          p = " / ";  break;
        case OP_MOD:            p = " % ";  break;
        case OP_LEFT_SHIFT:     p = " << "; break;
        case OP_RIGHT_SHIFT:    p = " >> "; break;
        case OP_LESS:           p = " < ";  break;
        case OP_LESS_EQUAL:     p = " <= "; break;
        case OP_GREATER_EQUAL:  p = " >= "; break;
        case OP_GREATER:        p = " > ";  break;
        case OP_EQUAL:          p = " == "; break;
        case OP_NOT_EQUAL:      p = " != "; break;
        case OP_AND:            p = " & ";  break;
        case OP_OR:             p = " | ";  break;
        case OP_XOR:            p = " ^ ";  break;
        case OP_LOGICAL_AND:    p = " && "; break;
        case OP_LOGICAL_OR:     p = " || "; break;
        case OP_QM:             p = " ? ";  break;
        case OP_COLON:          p = " : ";  break;
        case OP_ASSIGN:         p = " = ";  break;
        case OP_DOT:            p = " . ";  break;
        case OP_POINTSTO:       p = " -> "; break;
        case OP_COMMA:          p = " , ";  break;
        case OP_UNARY_NOT:      p = " ! ";  break;
        default:                p = " X ";  break;
        }

    return p;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\front\data.cxx ===
/*****************************************************************************
/**						Microsoft LAN Manager								**/
/**				Copyright(c) Microsoft Corp., 1987-1999						**/
/*****************************************************************************/
/*****************************************************************************
File				: listhndl.cxx
Title				: general purpose list handler
					:
Description			: this file handles the general purpose list routines
History				:
	05-Aug-1991	VibhasC	Created

*****************************************************************************/
#if 0
							Notes
							-----

The MIDL compilers DGROUP is larger than 64K (remember, 10k of stack space
is allocated). To get around the link errors of DGROUP more than 64k, we 
allocate all data in a single file, and compile that file such that the
data segement is a different named data segment. This way, we need not
specify /Gt1 for every source file which has reasonably big data segments


NOTE: In order to search easily I enter the data items in sorted order of names

	  Please maintain this order

#endif // 0


#pragma warning ( disable : 4514 )

/****************************************************************************
	include files
 ****************************************************************************/


#include "nulldefs.h"
extern	"C"
	{
	#include <stdio.h>
	#include <stdlib.h>
	}
#include "allnodes.hxx"
#include "cmdana.hxx"
#include "filehndl.hxx"
#include "lextable.hxx"
#include "symtable.hxx"
#include "gramutil.hxx"
#include "control.hxx"
#include "treg.hxx"


/****************************************************************************
	general data declarations
 ****************************************************************************/

unsigned short 				CurrentIntfKey;
unsigned short				CurrentZp			= 0;
ATTR_SUMMARY				DisallowedAttrs[INTERNAL_NODE_END];
ATTR_SUMMARY				FieldAttrs;
BOOL						fPragmaImportOn	= FALSE;

BOOL						fNoLogo			= FALSE;
short						GrammarAct;
short						ImportLevel = 0;
TREGISTRY				*	pCallAsTable;
CMD_ARG					*	pCommand;
CCONTROL				*	pCompiler;
SymTable				*	pCurSymTbl;
SymTable				*	pBaseSymTbl;
node_error				*	pErrorTypeNode;
node_e_attr				*	pErrorAttrNode;
node_e_status_t			*	pError_status_t;
NFA_INFO				*	pImportCntrl;
LexTable				*	pMidlLexTable;
IDICT					*	pInterfaceDict;
node_pragma_pack		*	pPackStack;
PASS_1					*	pPass1;
PASS_2					*	pPass2;
PASS_3					*	pPass3;
pre_type_db				*	pPreAllocTypes;
node_source				*	pSourceNode;
nsa						*	pSymTblMgr;
SymTable				*	pUUIDTable;
ISTACK					*	pZpStack;
ATTR_SUMMARY				RedundantsOk;
char					*	Skl_bufstart		= 0;
char					*	Skl_bufend			= 0;
unsigned long				Skl_Allocations		= 0;
unsigned long				Skl_Bytes			= 0;
unsigned long				Skl_Deletions		= 0;
short						yysavestate;
IINFODICT				*	pInterfaceInfoDict;
BOOL						fRedundantImport = FALSE;
node_skl				*	pBaseImplicitHandle = 0;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\front\attrnode.cxx ===
/*****************************************************************************/
/**                         Microsoft LAN Manager                           **/
/**                 Copyright(c) Microsoft Corp., 1987-1999                 **/
/*****************************************************************************/
/*****************************************************************************
File        : attrnode.cxx
Title       : attribute node routines
History     :
              04-Aug-1991     VibhasC Created

*****************************************************************************/

#pragma warning ( disable : 4514 4710 )

/****************************************************************************
 local defines and includes
 ****************************************************************************/

#include "nulldefs.h"
extern  "C"
    {
    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>
    #include <ctype.h>
    
    }

#include "allnodes.hxx"
#include "cmdana.hxx"
#include "buffer.hxx"
#include "mbcs.hxx"

#define W_CHAR_T_STRLEN_NAME    ("MIDL_wchar_strlen")
#define CHAR_STRLEN_NAME        ("MIDL_ascii_strlen")


/****************************************************************************
                           external data
 ****************************************************************************/

extern  CMD_ARG     *   pCommand;
extern  SymTable    *   pBaseSymTbl;

/****************************************************************************
                        external procedures
 ****************************************************************************/

extern void         ParseError( STATUS_T, char *);
extern  int         HexCheck(char *);
extern node_skl *   pBaseImplicitHandle;
/****************************************************************************/


/****************************************************************************
 node_base_attr:
 ****************************************************************************/
const char  *   const AttrNodeNameArray[ ACF_ATTR_END ] =
    {
    "[none]"
    ,"[first_is]"
    ,"[last_is]"
    ,"[length_is]"
    ,"[min_is]"
    ,"[max_is]"
    ,"[size_is]"
    ,"[range]"
    ,"[case]"
    ,"[funcdescattr]"
    ,"[idldescattr]"
    ,"[typedescattr]"
    ,"[vardescattr]"
    ,"[type attribute]"
    ,"[member attribute]"
    ,"[id]"
    ,"[helpcontext]"
    ,"[helpstringcontext]"
    ,"[lcid]"   // ATTR_LCID - applied to libraries - associated with an LCID constant
    ,"[dllname]"
    ,"[helpstring]"
    ,"[helpfile]"
    ,"[helpstringdll]"
    ,"[entry]"
    ,"[uuid]"
    ,"[async_uuid]"
    ,"[version]"
    ,"[switch_is]"
    ,"[iid_is]"
    ,"[defaultvalue]"
    ,"[transmit_as]"
    ,"[wire_marshal]"
    ,"[represent_as]"
    ,"[call_as]"        // last attribute that may not appear more than once
    ,"[custom]" 
    ,"[switch_type]"
    ,"[handle]"
    ,"[user_marshal]"
    ,"[ms_union]"
    ,"[ms_conf_struct]"
    ,"[v1_enum]"
    ,"[lcid]"   // ATTR_FLCID - applied to parameters - bit attribute
    ,"[hidden]"
    ,"[ptr kind]"
    ,"[string]"
    ,"[bstring]"
    ,"[endpoint]"
    ,"[local]"
    ,"[object]"
    ,"[ignore]"
    ,"[opaque]"
    ,"[idempotent]"
    ,"[broadcast]"
    ,"[maybe]"
    ,"[async]"
    ,"[input_sync]"
    ,"[byte_count]"
    ,"[callback]"
    ,"[message]"
    ,"[in]"
    ,"[out]"
    ,"[partial_ignore]"
    ,"[default]"
    ,"[context_handle]"
    ,"[code]"
    ,"[nocode]"
    ,"[optimize]"
    ,"[comm_status]"
    ,"[fault_status]"
    ,"[allocate]"
    ,"[heap]"
    ,"[implicit_handle]"
    ,"[explicit_handle]"
    ,"[auto_handle]"
    ,"[ptrsize]"
    ,"[notify]"
    ,"[notify_flag]"
    ,"[enable_allocate]"
    ,"[encode]"
    ,"[decode]"
    ,"[strict_context_handle]"
    ,"[context_handle_noserialize]"
    ,"[context_handle_serialize]"
    ,"[force_allocate]"
    ,"[cs_drtag]"
    ,"[cs_rtag]"
    ,"[cs_stag]"
    ,"[cs_char]"
    ,"[cs_tag_rtn]"
    };

const char * PtrKindArray[] =
    {
    "",
    "[ref]",
    "[unique]",
    "[full]"
    };

const char * TypeAttrArray[] =
    {
    "[public]",
    "[appobject]",
    "[control]",
    "[dual]",
    "[licensed]",
    "[nonextensible]",
    "[oleautomation]",
    "[noncreatable]",
    "[aggregatable]",
    "[proxy]"
    };

const char * MemberAttrArray[] =
    {
    "[readonly]",
    "[source]",
    "[bindable]",
    "[displaybind]",
    "[defaultbind]",
    "[requestedit]",
    "[propget]",
    "[propput]",
    "[propputref]",
    "[restricted]",
    "[optional]",
    "[retval]",
    "[vararg]",
    "[predeclid]",
    "[uidefault]",
    "[nonbrowsable]",
    "[defaultcollelem]",
    "[defaultvtable]",
    "[immediatebind]",
    "[usesgetlasterror]",
    "[replaceable]"
    };

char    *
node_base_attr::GetNodeNameString()
    {
    int At  = (int) GetAttrID();

    MIDL_ASSERT ( At < sizeof(AttrNodeNameArray)/sizeof(char *) );

    if ( At == ATTR_PTR_KIND )
        return (char *) PtrKindArray[ ((node_ptr_attr *)this)->GetPtrKind() ];
    if ( At == ATTR_TYPE )
        return (char *) TypeAttrArray[ ((node_type_attr *)this)->GetAttr() - TATTR_BEGIN];
    if ( At == ATTR_MEMBER )
        return (char *) MemberAttrArray[ ((node_member_attr *)this)->GetAttr() - MATTR_BEGIN];
    return (char *) AttrNodeNameArray[ (int) At ];
    }

/****************************************************************************
 ATTRLIST::Merge
    Merge two ATTRLISTs -- singly linked linear lists - insert at head
 ****************************************************************************/
void
ATTRLIST::Merge(ATTRLIST & MoreAttrs )
    {
    node_base_attr * pCur = MoreAttrs.pHead;

    if (pCur == NULL)
        {
        return;
        }

    while (pCur->pNext)
        {
        pCur = pCur->pNext;
        }

    pCur->pNext = pHead;
    pHead = MoreAttrs.pHead;

    };
/****************************************************************************
 ATTRLIST::Reverse
    Reverse an ATTRLIST -- singly linked linear list
 ****************************************************************************/
void
ATTRLIST::Reverse()
    {
    node_base_attr * pCur   = pHead;
    node_base_attr * pNext;
    node_base_attr * pPrev  = NULL;

    while (pCur)
        {
        pNext = pCur->pNext;
        pCur->pNext = pPrev;

        // advance to the next node
        pPrev = pCur;
        pCur = pNext;
        }

    pHead = pPrev;

    };
/****************************************************************************
 ATTRLIST::FInSummary
    Search for matching attribute -- singly linked linear lists
 ****************************************************************************/
BOOL
ATTRLIST::FInSummary(ATTR_T flag )
    {
    node_base_attr * pCur = pHead;

    while (pCur)
        {
        if ( pCur->AttrID == flag )
            {
            return TRUE;
            };
        pCur = pCur->pNext;
        }
    return FALSE;
    };

/****************************************************************************
 ATTRLIST::FMATTRInSummary
    Search for matching MEMEBER attribute -- singly linked linear lists
 ****************************************************************************/
BOOL
ATTRLIST::FMATTRInSummary(MATTR_T flag)
    {
    node_base_attr * pCur = pHead;

    while (pCur)
        {
        if ( pCur->AttrID == ATTR_MEMBER)
            {
            if (((node_member_attr *)pCur)->GetAttr() == flag)
                return TRUE;
            };
        pCur = pCur->pNext;
        }
    return FALSE;
    };

/****************************************************************************
 ATTRLIST::FTATTRInSummary
    Search for matching MEMEBER attribute -- singly linked linear lists
 ****************************************************************************/
BOOL
ATTRLIST::FTATTRInSummary(TATTR_T flag)
    {
    node_base_attr * pCur = pHead;

    while (pCur)
        {
        if ( pCur->AttrID == ATTR_TYPE)
            {
            if (((node_member_attr *)pCur)->GetAttr() == flag)
                return TRUE;
            };
        pCur = pCur->pNext;
        }
    return FALSE;
    };

/****************************************************************************
 ATTRLIST::GetAttribute
    Search for matching attribute -- singly linked linear lists
 ****************************************************************************/
node_base_attr  *
ATTRLIST::GetAttribute(ATTR_T flag )
    {
    node_base_attr * pCur = pHead;

    while (pCur)
        {
        if ( pCur->AttrID == flag )
            {
            return pCur;
            }
        pCur = pCur->pNext;
        }
    return NULL;
    };

/****************************************************************************
 ATTRLIST::Remove
 ****************************************************************************/
void
ATTRLIST::Remove( ATTR_T flag )
    {
    node_base_attr* pCur = pHead;
    node_base_attr* pPrev = 0;

    while (pCur)
        {
        if ( pCur->AttrID == flag )
            {
            if ( pPrev )
                {
                pPrev->pNext = pCur->pNext;
                }
            else
                {
                pHead = pHead->pNext;
                }
            delete pCur;
            }
        pPrev = pCur;
        pCur = pCur->pNext;
        }
    }

    /****************************************************************************
 ATTRLIST::GetAttributeList
    Return entire attribute list
 ****************************************************************************/
STATUS_T
ATTRLIST::GetAttributeList(type_node_list * pTNList )
    {
    node_base_attr * pCur = pHead;

    while (pCur)
        {
        pTNList->SetPeer( (node_skl *)pCur );
        pCur = pCur->pNext;
        }
    return (pHead) ? STATUS_OK: I_ERR_NO_MEMBER;
    };

/****************************************************************************
 ATTRLIST::Clone
    Return an attribute list with all new attribute nodes
 ****************************************************************************/
ATTRLIST
ATTRLIST::Clone()
    {
    node_base_attr * pCur = pHead;
    ATTRLIST    NewList;

    NewList.MakeAttrList();
    while (pCur)
        {
        // gaj - does this reverse the list ?? and if so is it OK?
        NewList.Add( pCur->Clone() );
        pCur = pCur->pNext;
        }
    return NewList;
    };

/****************************************************************************
 ATTRLIST::Dump
    Dump all attributes on list
 ****************************************************************************/
void
ATTRLIST::Dump( ISTREAM* pStream)
    {
    node_base_attr * pCur = pHead;

    while (pCur)
        {
        int At  = (int) pCur->GetAttrID();

        if ( At == ATTR_CASE )
            {
            pStream->Write( "[case(" );
/*
            I removed this section just before check in for midl 3.00.12
            as it somehow was messing up with the print type's Buffer
            at the typedef level for an upper struct, when the
            expression had a (DWORD) cast in it.
            repro: test10, problem from spoolss. Rkk.
            
            expr_list * pExprList;
            expr_node * pExpr;
            BOOL        fFirstExpr = TRUE;

            pExprList = ((node_case *)pCur)->GetExprList();
            pExprList->Init();
            while (( pExprList->GetPeer( &pExpr ) == STATUS_OK ))
                {
                if ( fFirstExpr )
                    fFirstExpr = FALSE;
                else
                    pStream->Write( "," );

                if ( pExpr )
                    pExpr->Print( pStream );
                }
*/

            pStream->Write( ")]" );
            }
        else
            {
            // returns a "[attrname]" string
            
            pStream->Write( pCur->GetNodeNameString() );
            }

        pCur = pCur->pNext;
        }
    };

/****************************************************************************
 miscellaneous attributes
 ****************************************************************************/

inline unsigned long
HexToULong( const char * pStr)
    {
    unsigned long   Cumulative      = 0;

    for ( ; *pStr; pStr++ )
        {
        Cumulative <<= 4;

        // add in another nibble
        Cumulative += ( *pStr >= 'a' ) ? ( *pStr - 'a' + 10  )
            : ( *pStr >= 'A' ) ? ( *pStr - 'A' + 10 )
                                                                                                                  : ( *pStr - '0' );
        }
    return Cumulative;
    }

#define GUID_STRING_1_SIZE  8
#define GUID_STRING_2_SIZE  4
#define GUID_STRING_3_SIZE  4
#define GUID_STRING_4_SIZE  4
#define GUID_STRING_5_SIZE  12

void
GUID_STRS::SetValue()
    {
    char    buffer[GUID_STRING_5_SIZE + 2];
    int     i,j;

    Value.Data1 = HexToULong( str1 );
    Value.Data2 = (unsigned short) HexToULong( str2 );
    Value.Data3 = (unsigned short) HexToULong( str3 );

    // go through the last strings backwards, advancing the null
    // byte as we go.

    // compute bytes 1 and 0
    strncpy( buffer, str4, GUID_STRING_4_SIZE+1 );
    for ( i = GUID_STRING_4_SIZE/2 - 1, j=GUID_STRING_4_SIZE-2  ; i >=0 ; i--, j-=2 )
        {
        Value.Data4[i] = (unsigned char) HexToULong( &buffer[j] );
        buffer[j] = '\0';
        }

    // compute bytes 7 to 2
    strncpy( buffer, str5, GUID_STRING_5_SIZE+1 );
    for ( i = GUID_STRING_5_SIZE/2 + 1, j=GUID_STRING_5_SIZE-2 ; i >=2 ; i--, j-=2 )
        {
        Value.Data4[i] = (unsigned char) HexToULong( &buffer[j] );
        buffer[j] = '\0';
        }
    }

node_guid::node_guid(char* pIn, ATTR_T At ) : ma( At )
    {
    char * p1  = pIn,
         * p2  = (p1) ? (strchr( p1+1 , '-')) : 0,
         * p3  = (p2) ? (strchr( p2+1 , '-')) : 0,
         * p4  = (p3) ? (strchr( p3+1 , '-')) : 0,
         * p5  = (p4) ? (strchr( p4+1 , '-')) : 0;

    if( p1 && p2 && p3 && p4 && p5 )
        {
        *p2++ = *p3++ = *p4++ = *p5++ = '\0';
        CheckAndSetGuid( p1, p2, p3, p4, p5 );
        }
    else
        ParseError( UUID_FORMAT, (char *)0 );
    }

node_guid::node_guid (
        char * pStr1,
        char * pStr2,
        char * pStr3,
        char * pStr4,
        char * pStr5,
        ATTR_T At ) : ma( At )
    {
    CheckAndSetGuid( pStr1, pStr2, pStr3, pStr4, pStr5 );
    }

void
node_guid::GetStrs (
        char ** pStr1,
        char ** pStr2,
        char ** pStr3,
        char ** pStr4,
        char ** pStr5 )
    {
    *pStr1 = cStrs.str1;
    *pStr2 = cStrs.str2;
    *pStr3 = cStrs.str3;
    *pStr4 = cStrs.str4;
    *pStr5 = cStrs.str5;
    };

void
node_guid::CheckAndSetGuid(
        char * pStr1,
        char * pStr2,
        char * pStr3,
        char * pStr4,
        char * pStr5 )
    {
    cStrs.SetStrs( pStr1, pStr2, pStr3, pStr4, pStr5 );

    int Len1 = (int) strlen(pStr1);
    int Len2 = (int) strlen(pStr2);
    int Len3 = (int) strlen(pStr3);
    int Len4 = (int) strlen(pStr4);
    int Len5 = (int) strlen(pStr5);

    if( (Len1 == GUID_STRING_1_SIZE) &&
    (Len2 == GUID_STRING_2_SIZE) &&
    (Len3 == GUID_STRING_3_SIZE) &&
    (Len4 == GUID_STRING_4_SIZE) &&
    (Len5 == GUID_STRING_5_SIZE) )
        {
        if( !HexCheck(pStr1)    ||
            !HexCheck(pStr2)    ||
            !HexCheck(pStr3)    ||
            !HexCheck(pStr4)    ||
            !HexCheck(pStr5) )
            {
            ParseError(UUID_NOT_HEX, (char *)NULL);
            }
        else
            {
            guidstr = new char[ Len1 + Len2 + Len3 + Len4 + Len5 + 5 ];
            strcpy(guidstr, pStr1);
            strcat(guidstr, "-");
            strcat(guidstr, pStr2);
            strcat(guidstr, "-");
            strcat(guidstr, pStr3);
            strcat(guidstr, "-");
            strcat(guidstr, pStr4);
            strcat(guidstr, "-");
            strcat(guidstr, pStr5);
            }
        }
    else
        {
        ParseError(UUID_FORMAT, (char *)NULL);
        }
    }

node_version::node_version(
        unsigned long   vMajor,
        unsigned long   vMinor ) : nbattr( ATTR_VERSION )
    {
    major   = vMajor;
    minor   = vMinor;

    if( (major > 0x0000ffff ) || (minor > 0x0000ffff))
        ParseError( VERSION_FORMAT, (char *)0);
    }

node_version::node_version(char *  pV ) : nbattr(ATTR_VERSION)
    {
    char * pMinor;
    char * pMajor  = pV;
    BOOL   fError  = TRUE;

    major = minor = 0;

    if( pMajor && *pMajor )
        {
        if( ( pMinor = strchr( pMajor, '.' ) ) != 0 )
            {
            fError = TRUE;
            if( *(++pMinor) )
                {
                minor = strtoul( pMinor, &pMinor, 10 );
                if( ! *pMinor )
                    fError = FALSE;
                }
            }
        else
            fError = FALSE;

        if( fError == FALSE )
            {
            //use pMinor to save pMajor value;

            major = strtoul( pMinor = pMajor, &pMajor, 10 );

            if( (*pMajor && (*pMajor != '.' )) || (pMajor == pMinor) )
                fError = TRUE;
            }
        }

    if( (fError == TRUE )                       ||
        (major > (unsigned long )0x0000ffff)    ||
        (minor > (unsigned long )0x0000ffff)    )
        {
        ParseError( VERSION_FORMAT, (char *)0 );
        }

    }

STATUS_T
node_version::GetVersion(
        unsigned short *pMajor,
        unsigned short *pMinor )
    {
    *pMajor = (unsigned short) major;
    *pMinor = (unsigned short) minor;
    return STATUS_OK;
    }

node_endpoint::node_endpoint(char * pEndPointString ) : nbattr( ATTR_ENDPOINT )
    {
    SetEndPointString( pEndPointString );
    }

void
node_endpoint::SetEndPointString(
        char * pString )
    {
    ENDPT_PAIR * pEntry  = new ENDPT_PAIR;
    char       * p1      = pString;
    char       * p2      = 0;
    char       * pTemp;
    short        Len;
    STATUS_T     Status  = ENDPOINT_SYNTAX;

    //
    // Parse the string. Note that we can assume that the string is at least
    // a null string, because it came from the parser. If it wasnt a string,
    // the parser would have barfed anyhow.
    //
    // Firstly, the string must have a ':' separator. Also, it must have
    // at least 1 character before the :.
    //

    if( pString && (pTemp = strchr( pString , ':' ) ) != 0 && ((pTemp - pString) > 0) )
        {
        //
        // pick up the first part of the string.
        //

        Len = short( pTemp - pString );
        p1  = new char [ Len + 1 ]; // one for null.
        strncpy( p1, pString, Len );
        p1[ Len ] = '\0';

        //
        // pick up the last part of the string. Skip beyond the :. There can be
        // some characters after the : and before the '['. This is the server
        // name. Then follows the port within the []. The actual string will
        // not have the [].
        //

        // skip the :

        pTemp   += 1;

        // find out the total length of the string. Allocate 2 less than that
        // 'cause we dont need the '[' and ']'. The string must be more than
        // 2 characters 'cause it must have the brackets anyhow.

        Len = (short) strlen( pTemp );

        if( (Len > 2 ) &&
            (strchr( pTemp, '[' )) &&
            (pTemp[ Len - 1] == ']'))
            {
            char *p2Cur;

            while( *pTemp != '[' )
                {
                pTemp++;
                Len--;
                }

            //
            // in the second half of the parse, just get the whole string till
            // the null. Now the user could be perverted, he could have a
            // ] embedded within the string, in addition to the last ]. To
            // ensure that he gets what he deserves, transfer till the end
            // except the last character which must be ']'.

            pTemp++; Len--;

            p2Cur   = p2 = new char[ Len ]; // Yes, not Len + 1 'cause we are
                                            // going to re-use the last char
                                            // which is ] for the null.

            strncpy( p2Cur, pTemp, --Len );

            p2Cur[ Len ] = '\0';

            Status = STATUS_OK;
            }
        else
            {
            delete p1;
            }

        }

    if( Status != STATUS_OK )
        {
        ParseError( Status, pString );
        p1 = p2 = 0;
        }

    //
    // set up the pair.
    //

    pEntry->pString1    = p1;
    pEntry->pString2    = p2;

    EndPointStringList.Insert( pEntry );

    }

ITERATOR &
node_endpoint::GetEndPointPairs()
    {
    EndPointStringList.Init();
    return EndPointStringList;
    }


/****************************************************************************
                                utility routines
 ****************************************************************************/
int
HexCheck(char *pStr)
    {
    if(pStr && *pStr)
        {
        while(*pStr)
            {
            if(! isxdigit(*pStr)) return 0;
            pStr++;
            }
        return 1;
        }
    return 0;
    }


//+---------------------------------------------------------------------------
//
//  Function:   TranslateEscapeSequences
//
//  Purpose:    Replaces a string's escape sequences with the appropriate 
//              ASCII characters.
//
//              NOTE: this can be done in place because the resulting string
//              length will always be shorter than or equal to the input string 
//              length.
//
//  Assumes:    The string is NULL terminated and in writable memory.
//
//----------------------------------------------------------------------------

#define ESCAPE_CHARACTER '\\'
void TranslateEscapeSequences(char * sz)
{
    char * pchNextOut = sz;
    char ch; 
    
    while (0 != (ch = *sz))
        {
        if ((char)ESCAPE_CHARACTER == ch)
            {
            ch = *(++sz);
            switch ((char)tolower(ch))
                {
                case '0':   // octal sequence
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                    {
                    char count = 3;
                    unsigned char value = 0;
                    do 
                        {
                        value *= 8;
                        value = unsigned char( value + ch - '0' );
                        ch = *(++sz);
                        count--;
                        }
                    while (ch <= '8' && ch >= '0' && count);
                    sz--;
                    ch = (char) value;
                    break;
                    }
                case 'x':   // hex sequence
                    {
                    unsigned char value = 0;
                    ch = (char)tolower(*(++sz));
                    if ((ch <= '8' && ch >= '0') || (ch <= 'f' && ch >= 'a'))
                        {
                        do
                            {
                            value *= 16;
                            if (ch < 'a')
                                value = unsigned char(value + ch - '0');
                            else 
                                value = unsigned char(value + ch - 'a' + 10);
                            ch = (char)tolower(*(++sz));
                            }
                        while ((ch <= '8' && ch >= '0') || (ch <= 'f' && ch >= 'a'));
                        sz--;
                        ch = (char) value;
                        }
                    else    // "\x" with no trailing hex digits is treated as an "x"
                        {
                        ch = *(--sz);
                        }
                    break;
                    }
                case 'n':   // newline
                    ch = (char) '\n';
                    break;
                case 't':   // tab
                    ch = (char) '\t';
                    break;
                case 'v':   // vertical tab
                    ch = (char) '\v';
                    break;
                case 'b':   // backspace
                    ch = (char) '\b';
                    break;
                case 'r':   // carriage return
                    ch = (char) '\r';
                    break;
                case 'f':   // formfeed
                    ch = (char) '\f';
                    break;
                case 'a':   // alert
                    ch = (char) '\a';
                    break;
                case 0:     // just in case the last character in the string is an escape character
                    ch = (char) ESCAPE_CHARACTER;
                    sz--;
                    break;
                default:
                    break;
                }
            }
        *(pchNextOut++) = ch;
        ++sz;

        if (CurrentCharSet.IsMbcsLeadByte(ch))
            *(pchNextOut++) = *(sz++);
        }
    *(pchNextOut++) = ch;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\front\filehndl.cxx ===
/*****************************************************************************/
/**						Microsoft LAN Manager								**/
/**				Copyright(c) Microsoft Corp., 1987-1999						**/
/*****************************************************************************/
/*****************************************************************************
File				: filehndl.cxx
Title				: file i/o handler for the MIDL compiler. Handles nested
					: file accessing, preprocessed file handling etc
Description			: Used by the compiler for handling import files, pre-
					  processing of files etc
History				:
	25-Aug-1990	VibhasC	Create
	26-Aug-1990	VibhasC	Add functionality

*****************************************************************************/

#pragma warning ( disable : 4514 )

/****************************************************************************
 ***		local defines
 ***************************************************************************/


#define MAX_LINE_LENGTH			(256)
#define INTERMEDIATE_EXT		("._i")
#define SMART_INCLUDE_STRING	("smart_include")

/****************************************************************************
 ***		include files
 ***************************************************************************/
#include "nulldefs.h"
extern	"C"	
	{
	#include <stdio.h>
	#include <stdlib.h>
	#include <string.h>
	
	#include <process.h>
	#include <ctype.h>
	#include <errno.h>
	#include <malloc.h>
	#include <fcntl.h>
	#include <sys\types.h>
	#include <sys\stat.h>
	#include <io.h>
	#include <share.h>
	}
#include "common.hxx"
#include "errors.hxx"
#include "filehndl.hxx"
#include "cmdana.hxx"
#include "control.hxx"
#include "linenum.hxx"
#include "midlvers.h"

/****************************************************************************
 ***		public data
 ***************************************************************************/

short  		DebugLine = 0;
char	*	pDebugFile;
int			StdoutSave = -1;
int			StderrSave = -1;
FILE 	*	pNullFile  = NULL;

/****************************************************************************
 ***		extern procs
 ***************************************************************************/

extern void			StripSlashes( char * );
extern void			ChangeToForwardSlash( char *, char * ); 
extern STATUS_T		CreateFullPathAndFName( char *, char **, char ** );
extern "C" long     __stdcall    GetTempPathA( long, char * );
extern "C" long     __stdcall    GetTempFileNameA( const char*, const char*, unsigned int, char * );
extern "C" long     __stdcall     lstrcmpiA(const char* lpString1, const char* lpString2 );

/****************************************************************************
 ***		extern data
 ***************************************************************************/

extern CCONTROL	*	pCompiler;
extern CMD_ARG	*	pCommand;
extern short		curr_line_G;
extern FILE		*	hFile_G;
extern BOOL			fRedundantImport;


/*** _nfa_info *************************************************************
 * Purpose	: constructor for the _nfa_info class
 * Input	: nothing
 * Output	:
 * Notes	: Initialize
 ***************************************************************************/
_nfa_info::_nfa_info( void )
	{

	BOOL	fMinusIDefined		= pCommand->IsSwitchDefined(SWITCH_I);
	BOOL	fNoDefIDirDefined	= pCommand->IsSwitchDefined(SWITCH_NO_DEF_IDIR);
	char *	pDefault			= ".";
	char *	pEnv				= (char *)0;
	char *	pIPaths				= (char *)0;
	char *	p1					= (char *)0;
	char *	p2					= (char *)0;
	char *	p3					= (char *)0;

	/***
	 *** init
	 ***/

	pFileList			= 0;
	pPathList			= (PATH_LIST *)NULL;
	pStack = pStackFirst= (IN_STACK_ELEMENT *)NULL;
	iCurLexLevel		= 0;
	Flags.fPreProcess	= 0;
	Flags.fFileSet		= 0;
	Flags.fEOI			= 0;
	Flags.fBaseFileName= 0;
	Flags.fInInclude	= 0;

	// macro expansion handling

	pTextDict			= new ISTACK( 10 );



	// init the search paths. If the -no_def-idir switch is defined, then
	// dont set the default paths. But if the -no_def_idir switch IS defined,
	// then if the -I switch is not found, set the current path to .

	if ( fMinusIDefined )
		pIPaths		= pCommand->GetMinusISpecification();

	if ( ( pEnv  = getenv( "INCLUDE" ) ) == 0 )
		pEnv = getenv( "include" );

	//
	// make a copy of this because we will be doing strtoks on this.
	//

	if( pEnv )
		{
		// use p1 as temp;
		p1	= new char [ strlen( pEnv ) + 1 ];
		strcpy( p1, pEnv );
		pEnv = p1;
		}

	p1	= pDefault;
	p2	= pIPaths;
	p3	= pEnv;

	if( fNoDefIDirDefined && fMinusIDefined )
		{
		p1	= p3 = (char *)0;
		}
	else if( fNoDefIDirDefined && !fMinusIDefined )
		{
		p2 = p3 = (char *)0;
		}
	else if( !fNoDefIDirDefined && !fMinusIDefined )
		{
		p1	= pDefault;
		p2	= (char *)0;
		p3	= pEnv;
		}

	SetSearchPathsInOrder( p1, p2, p3 );

	if( pIPaths ) delete pIPaths;

	//
	// we have made a copy of the env variable, so we can delete this copy
	// now.
	//

	if( pEnv ) delete pEnv;

	}
void
_nfa_info::Init()
	{

	CMD_ARG	*	pCommandProcessor = pCompiler->GetCommandProcessor();

	// set preprocessing on or off depending upon the need

	if( !pCommandProcessor->IsSwitchDefined( SWITCH_NO_CPP ) )
		SetPreProcessingOn();

	}

void
_nfa_info::SetSearchPathsInOrder(
	char	*	p1,
	char	*	p2,
	char	*	p3 )
	{
	if( p1 )
		RegisterIt( p1 );
	if( p2 )
		RegisterIt( p2 );
	if( p3 )
		RegisterIt( p3 );
	}

void
_nfa_info::RegisterIt(
	char	*	pPath
	)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

	register command paths.

 Arguments:

	pPath	-	pointer to path bein registered.

 Return Value:

	None.

 Notes:

	We expect the path components to be separated by a ';'. register those
	with the import controller. This function must become part of the import
	controller class.

----------------------------------------------------------------------------*/
	{
#define TOKEN_STRING (";")

	char	*	pToken = strtok( pPath, TOKEN_STRING );

	if( pToken )
		{
		SetPath( pToken );

		while ( ( pToken = strtok( 0, TOKEN_STRING ) ) != 0 )
			{
			SetPath( pToken );
			}
		}
	}

void
_nfa_info::RegisterTextSubsObject( TEXT_BUFFER* )
	{
	MIDL_ASSERT(0);
	}

_nfa_info::~_nfa_info()
	{
	EndOperations();
	}

/*** GetLexLevel **********************************************************
 * Purpose	: to return the current lexical level of the nfa
 * Input	: nothing
 * Output	: current lexical level
 * Notes	:
 **************************************************************************/
short
NFA_INFO::GetLexLevel( void )
	{
		return iCurLexLevel;
	}

/*** PushLexLevel **********************************************************
 * Purpose	: push lexical level in preparation of a new input file
 * Input	: nothing
 * Output	: 0 if all is well, error otherwise.
 * Notes	: 
 **************************************************************************/
short
NFA_INFO::PushLexLevel ( void )
	{

	// if an attempt to push the lexical level without opening any file
	// at that level was made, assert

	MIDL_ASSERT( Flags.fFileSet == 1 );

	// if we are in a deep imports heirarchy,
	// close the current file, record its position so that we can start
	// reading at the same place when we come back to it on a poplexlevel

	if ( iCurLexLevel > 12 )
		{
		pStack->ulPos		= ftell( pStack->hFile );
		fclose(pStack->hFile);
		pStack->fOpen		= 0;
		}
	Flags.fFileSet		= 0;
	iCurLexLevel++;
	return 0;
	}

/*** PopLexLevel **********************************************************
 * Purpose	: pop the lexical level
 * Input	: nothing
 * Output	: returns STATUS_OK if all is well.Error otherwise
 *	Notes	: pop involves, re-opening the input file, if it was closed
 *			: retsoring the input file handle back, deleting the stack
 *			: element for that lexical level.
 *************************************************************************/
STATUS_T
NFA_INFO::PopLexLevel( void )
	{

	IN_STACK_ELEMENT *	pCurStack;
	char			 *	pName;

	MIDL_ASSERT( iCurLexLevel > 0 );

	//
	// remove the current stack level, by closing the file at that 
	// level and deleting the stack element. reduce the current lexical
	// level by one
	// 

	iCurLexLevel--;

	if( ! pStack->fRedundantImport )
		{
		EndOneOperation( pStack );
		}
	else	// close the nul file
		{
//		if ( pStack->hFile && pStack->fOpen && )
//			fclose( pStack->hFile );
		}

	pCurStack = pStack	= pStack->pPrev;
	delete pStack->pNext;
	pStack->pNext		= (IN_STACK_ELEMENT *)NULL;

	//
	//  if the file at this lexical level is closed, open it
	// 

	pName = pStack->pName;

	if( !pStack->fOpen )
		{

		if( (pStack->hFile = fopen( pStack->pIFileName, "rb" )) == (FILE *)NULL)
			{
			RpcError((char *)NULL, 0, INPUT_OPEN, pName);
			return INPUT_OPEN;
			}
		if ( !pStack->pBuffer )
			pStack->pBuffer = new char [MIDL_RD_BUFSIZE];
		setvbuf( pStack->hFile, pStack->pBuffer,_IOFBF, MIDL_RD_BUFSIZE );

		// restore the system-wide file handle

		pStack->fOpen	= 1;

		// the input file is open now, position it to where it was before
		// we changed current lexical level

		if( fseek( pStack->hFile, pStack->ulPos, SEEK_SET) )
			{
			RpcError((char *)NULL, 0, INPUT_READ, pName);
			return INPUT_READ;
			}
		
		}

	// update the line number information, and set current file
	curr_line_G = pStack->uLine;
	hFile_G = pStack->hFile;
	AddFileToDB( pName );

	// everything is fine , lets go
	return STATUS_OK;

	}
STATUS_T
NFA_INFO::EndOperations()
	{
	IN_STACK_ELEMENT * pS	= pStackFirst;

	while( pStackFirst = pS )
		{
		EndOneOperation( pS );
		pS	= pS->pNext;
		delete pStackFirst;
		}
	pStackFirst = pStack = (IN_STACK_ELEMENT *)0;
	Flags.fFileSet		= 0;
	return STATUS_OK;
	}

STATUS_T
NFA_INFO::EndOneOperation( IN_STACK_ELEMENT * pSElement)
	{
	BOOL	fSavePP	= pCommand->IsSwitchDefined( SWITCH_SAVEPP );

	if( pSElement && pSElement->hFile )
		{
		fclose( pSElement->hFile );
		if( Flags.fPreProcess  && !fSavePP )
			{
			MIDL_UNLINK( pSElement->pIFileName );
			delete pSElement->pIFileName;
			}
		if( pSElement->pMIFileName && !fSavePP )
			{
			MIDL_UNLINK( pSElement->pMIFileName );
			delete pSElement->pMIFileName;
			}
		}
	return STATUS_OK;
	}

/*** SetNewInputFile *******************************************************
 * Purpose	: to set the input file to a new one
 * Input	: pointer to the new input file name
 * Output	: STATUS_OK if all is ok, error otherwise.
 * Notes	:
 **************************************************************************/
#define _MAX_FILE_NAME (_MAX_DRIVE+_MAX_DIR+_MAX_FNAME+_MAX_EXT)

STATUS_T
NFA_INFO::SetNewInputFile(
	char *pFullInputName)
	{
	FILE			*hFile = (FILE *)NULL;
	STATUS_T 		uError;
	IN_STACK_ELEMENT	*pStackCur = pStack;
	char			agNameBuf[ _MAX_FILE_NAME + 1];
	char			agDrive[_MAX_DRIVE];
	char			agPath[_MAX_DIR];
	char			agName[_MAX_FNAME];
	char			agExt[_MAX_EXT];
	char			*pPath;
	char			*pIFileName = (char *)NULL,
					*pMIFileName = (char *) NULL;
	char			*pFullName	= new char[ strlen( pFullInputName ) + 1];

	// make sure everything opened in binary mode
	_fmode = _O_BINARY;

	//
	// if the filename has any forward slashes, change them to back-slashes.
	//

	ChangeToForwardSlash( pFullInputName, pFullName ); 

	// if we have seen this file before, do not process it again, just return
	// an error

	if( IsDuplicateInput( pFullName ) )
		{
		pStack	= new IN_STACK_ELEMENT;
		if(pStackCur)
			{
			pStackCur->pNext	= pStack;
			pStack->pPrev		= pStackCur;
			pStackCur->uLine	= curr_line_G;
			}
		else
			{
			pStack->pPrev		= (IN_STACK_ELEMENT *)NULL;
			pStackFirst			= pStack;
			}
		pStack->pNext		= (IN_STACK_ELEMENT *)NULL;
		pStack->fNewLine	= 0;
		pStack->fRedundantImport	= 1;
		fRedundantImport = 1;

		// make the next read get eof
		if ( !pNullFile )
			{
			pNullFile = fopen("nul", "rb");
			hFile = 0;
			}
			 
		// fseek(hFile, 0, SEEK_END );
		pStack->fOpen		= 1;
		pStack->fShadow		= 0;
		pStack->ulPos		= 
		pStack->uShadowLine	= 0;
	
		curr_line_G		= 1;

		pStack->pShadowName = 
		pStack->pName		= pFullName;
		pStack->pIFileName	= pIFileName;
		pStack->hFile		= hFile;
		hFile_G				= pNullFile;
		Flags.fFileSet		= 1;
		return STATUS_OK;
		}

	// We need to find details of the file name. We need to see if the user
	// has already specified path, if so, override the current paths.
	// if the user has specified a file extension, get the extension. We
	// need to do that in order to have uniformity with the case where
	// a preprocessed file is input with a different extension

	_splitpath( pFullName, agDrive, agPath, agName, agExt );
//	fprintf( stdout, "Processing %s:\n", pFullName);

	// if file is specified with a path, the user knows fully the location
	// else search for the path of the file

	pPath = agPath;
	if( !*pPath && !agDrive[0] )
		{
		sprintf(agNameBuf, "%s%s", agName, agExt);
		if( (pPath = SearchForFile(agNameBuf)) == (char *)NULL)
			{
			RpcError((char *)NULL, 0, INPUT_OPEN, agNameBuf);
			return INPUT_OPEN;
			}
		strcpy(agPath, pPath);
		}
	else
		{
		// there is a path specification, which we must tag to this name
		// for all subsequent accesses to the file although it should not 
		// be considered as part of the list of paths the user gave.
		// Remember, in our file list we store the paths too

		pPath	= new char[ strlen(agPath) + 1];
		strcpy( pPath, agPath );
		}

	// do we need to preprocess the file ?

    if ( pCommand->Is64BitEnv() )
    	fprintf( stdout, "64 bit " );
	fprintf( stdout, "Processing " );

	if( agDrive[0] )
		fprintf( stdout, "%s", agDrive );
	if( agPath[0] )
		fprintf( stdout, "%s", agPath );
	if( agName[0] )
		fprintf( stdout, "%s", agName );
	if( agExt[0] )
		fprintf( stdout, "%s", agExt );
	fprintf( stdout, "\n" );

	fflush( stdout );

	if (Flags.fPreProcess)
		{
		if ( ( uError = PreProcess( agDrive, agPath, agName, agExt, pIFileName) ) != 0 )
			return uError;
		}
	else  // if no_cpp...
		{
		pIFileName = new char [ strlen( agDrive ) + 
								strlen( agPath ) +
								strlen( agName ) +
								strlen( agExt ) + 2 ];
		strcpy( pIFileName, agDrive );
		strcat( pIFileName, agPath);
		if( agPath[0] &&  (agPath[ strlen(agPath)-1 ] != '\\'))
			strcat(pIFileName,"\\");
		strcat( pIFileName, agName );
		strcat( pIFileName, agExt );
		}

	
	if( (hFile = fopen(pIFileName, "rb")) == (FILE *)NULL)
		{
		// error obtained while reading file, return the error

		RpcError((char *)NULL, 0, INPUT_OPEN, pIFileName);
		return INPUT_OPEN;
		}

	// file was sucessfully opened, initialize its info

	// if a file has not been set at this nested level , a stack element 
	// must be allocated for it. else the current file must be closed
	
	if( ! Flags.fFileSet )
		{
		pStack	= new IN_STACK_ELEMENT;
		if(pStackCur)
			{
			pStackCur->pNext	= pStack;
			pStack->pPrev		= pStackCur;
			pStackCur->uLine	= curr_line_G;
			}
		else
			{
			pStack->pPrev		= (IN_STACK_ELEMENT *)NULL;
			pStackFirst			= pStack;
			}
		pStack->pNext		= (IN_STACK_ELEMENT *)NULL;
		pStack->fNewLine	= 1;
		Flags.fFileSet		= 1;
		}
	else
		{
		// file was set. That means input was coming from a file. Close
		// that file.
		fclose(pStack->hFile);
		}

	if ( !pStack->pBuffer )
		pStack->pBuffer = new char [MIDL_RD_BUFSIZE];
	setvbuf( hFile, pStack->pBuffer,_IOFBF, MIDL_RD_BUFSIZE );

	pStack->fOpen		= 1;
	pStack->fRedundantImport	= 0;
	fRedundantImport 	= 0;
	pStack->fShadow		= 0;
	pStack->uShadowLine	= 0;

	curr_line_G		= 1;

	pStack->pShadowName = 
	pStack->pName		= pFullName;
	pStack->pIFileName	= pIFileName;
	pStack->pMIFileName	= pMIFileName;
	pStack->hFile		= hFile;
	hFile_G				= hFile;

	// update the line number information, and set current file
	AddFileToDB( pFullName );

	// add the file to the list of files that we have seen

	AddFileToFileList(pFullName, pPath);
	return STATUS_OK;
	}

/*** SetLineFilename ******************************************************
 * Purpose	: to add filename to the list of files we have input from
 * Input	: filename to add to the list of files, file path
 * Output	: STATUS_OK if all is well, error otherwise
 * Notes	:
 ****************************************************************************/
void
NFA_INFO::SetLineFilename(
	char *	pFName
	)
{
	if(strcmp(pFName, pStack->pName) != 0)
		{
		pStack->pName = new char[strlen( pFName ) + 1 ];
		strcpy(pStack->pName, pFName);
		
		// update the line number information, and set current file
		AddFileToDB( pStack->pName );

		}
}


/*** AddFileToFileList ******************************************************
 * Purpose	: to add filename to the list of files we have input from
 * Input	: filename to add to the list of files, file path
 * Output	: STATUS_OK if all is well, error otherwise
 * Notes	:
 ****************************************************************************/
STATUS_T
NFA_INFO::AddFileToFileList(
	char 	*pName ,
	char	*pPath )
	{
	FNAME_LIST	*pList	= pFileList;
	FNAME_LIST	*pTemp;
	char		agNameBuf[ _MAX_DRIVE+_MAX_DIR+_MAX_FNAME+_MAX_EXT+1];
	char *		pN;
	char *		pP;
	STATUS_T	Status;
	char			agDrive[_MAX_DRIVE];
	char			agPath[_MAX_DIR];
	char			agName[_MAX_FNAME];
	char			agExt[_MAX_EXT];
	BOOL		fNameHadNoPath = FALSE;

#if 1
	_splitpath( pName, agDrive, agPath, agName, agExt );

	//
	// if the filename came with a path component choose that to add to the file
	// list else use the path parameter.
	//

	strcpy( agNameBuf, agDrive );
	strcat( agNameBuf, agPath );

    fNameHadNoPath = strlen( agNameBuf ) == 0;
	if ( fNameHadNoPath )
		strcpy( agNameBuf, pPath );
	
	if( pPath[ strlen(pPath) - 1] != '\\' )
		strcat( agNameBuf, "\\" );

	//
	// if the filename had  a path component, then dont use that name, use the
	// name provided by splitpath.
	//

	if( fNameHadNoPath )
		strcat( agNameBuf, pName );
	else
		{
		strcat( agNameBuf, agName );
		strcat( agNameBuf, agExt );
		}

	if( (Status = CreateFullPathAndFName( agNameBuf, &pP, &pN )) != STATUS_OK )
		return OUT_OF_MEMORY;
#endif // 1

	while(pList && pList->pNext) pList = pList->pNext;
	
	if ( (pTemp = new FNAME_LIST) == 0 )
		return OUT_OF_MEMORY;

	if(pList) 
		pList->pNext	= pTemp;
	else
		pFileList	= pTemp;
	pList			= pTemp;
	pList->pName = pN;
	pList->pPath = pP;
	pList->pNext	= (FNAME_LIST *)NULL;
	return	STATUS_OK;
	}

STATUS_T
CreateFullPathAndFName( char * pInput, char **ppPOut, char **ppNOut )
	{
	char			agNameBuf[ _MAX_DRIVE+_MAX_DIR+_MAX_FNAME+_MAX_EXT+1];
	char			agDrive[_MAX_DRIVE];
	char			agPath[_MAX_DIR];
	char			agName[_MAX_FNAME];
	char			agExt[_MAX_EXT];

	_fullpath( agNameBuf, pInput,_MAX_DRIVE+_MAX_DIR+_MAX_FNAME+_MAX_EXT+1);
	_splitpath( agNameBuf, agDrive, agPath, agName, agExt );
	strcpy( agNameBuf, agDrive );
	strcat( agNameBuf, agPath );
	*ppPOut = new char [strlen( agNameBuf ) + 1];
	strcpy( *ppPOut, agNameBuf );

	strcpy( agNameBuf, agName );
	strcat( agNameBuf, agExt );
	*ppNOut = new char [strlen( agNameBuf ) + 1];
	strcpy( *ppNOut, agNameBuf );

	return STATUS_OK;
	}
BOOL
NFA_INFO::IsDuplicateInput(
	char	*	pThisName)
	{
	FNAME_LIST	*pList	= pFileList;
	char		* pN;
	char		* pP;
	BOOL		f = FALSE;
	char			agNameBuf[ _MAX_DRIVE+_MAX_DIR+_MAX_FNAME+_MAX_EXT+1];
	char			agDrive[_MAX_DRIVE];
	char			agPath[_MAX_DIR];
	char			agName[_MAX_FNAME];
	char			agExt[_MAX_EXT];

	//
	// if the file did not come with a path component, then try the normal
	// search for file.
	//

	_splitpath( pThisName, agDrive, agPath, agName, agExt );
	strcpy( agNameBuf, agDrive );
	strcat( agNameBuf, agPath );
	

	if( strlen( agNameBuf ) == 0 )
		{
		if ( ( pP = SearchForFile( pThisName ) ) != 0 )
			{
			strcpy( agNameBuf, pP );
			strcat( agNameBuf, pThisName );
			}
		else
			{
			strcpy( agNameBuf, pThisName );
			}
		}
	else
		strcpy( agNameBuf, pThisName );

	CreateFullPathAndFName( agNameBuf, &pP, &pN );

	while( pList && pList->pName )
		{
		if( (lstrcmpiA( pList->pName , pN ) == 0 ) &&
			(lstrcmpiA( pList->pPath , pP ) == 0 ) 
		  )
		  {
		  f = TRUE;
		  break;
		  }
		pList = pList->pNext;
		}
	delete pN;
	delete pP;
	return f;
	}
/*** SetPath *****************************************************************
 * Purpose	: to add a string to the list of possible paths
 * Input	: path to add to the list of paths
 * Output	: STATUS_OK if all is well, error otherwise
 * Notes	:
 ****************************************************************************/
STATUS_T
NFA_INFO::SetPath(
	char	*pPath )
	{
	PATH_LIST 	*pList	= pPathList;
	PATH_LIST 	*pTemp;
	size_t		 Len;

	while(pList && pList->pNext) pList = pList->pNext;
	
	if ( (pTemp = new PATH_LIST) == 0 )
		return OUT_OF_MEMORY;

	if(pList) 
		pList->pNext	= pTemp;
	else
		pPathList		= pTemp;

#if 0
	// The user could specify a path using a leading space, for example, he can
	// specify the -I with a leading space. Even tho the -I should be presented
	// to the user with the leading space, we should not get confused. We omit 
	// leading spaces.

	while( isspace( *pPath ) ) pPath++;
#endif

	pList			= pTemp;
	pList->pPath	= new char[ (Len = strlen(pPath)) + 2];// one possible "\\"
	pList->pNext	= (PATH_LIST *)NULL;
	strcpy( pList->pPath, pPath );

	if( Len  &&  (pPath[ Len - 1 ] != '\\' ) )
		strcat( pList->pPath, "\\");

	return	STATUS_OK;
	}

/*** SetPreProcessingOn *****************************************************
 * Purpose	: to set preprocessing on
 * Input	: nothing
 * Output	: STATUS_OK if all is well, error otherwise
 * Notes	: Set the preprocessing flag on. This denotes that preprocessing
 *			: will be on for all the files that are input to the compiler
 ****************************************************************************/
STATUS_T
NFA_INFO::SetPreProcessingOn(void)
	{
	Flags.fPreProcess	= 1;
	return STATUS_OK;
	}

/*** SearchForFile ********************************************************
 * Purpose	: to search for a file in a previously registered set of paths
 * Input	: file name
 * Output	: (char *)NULL if the file was not found in the given set of paths
 *			: else a pointer to the path where it was found
 * Notes	:
 *************************************************************************/
char *
NFA_INFO::SearchForFile(
	char	*pName)
	{

	PATH_LIST	*pPathTemp = pPathList;
	char		agNameBuf[ _MAX_DRIVE+_MAX_DIR+_MAX_FNAME+_MAX_EXT+1];

	// the name is guaranteed not to have path or drive info, just the 
	// base name and extension. We must figure out the paths, from 
	// the list of paths that we have registered so far

	while(pPathTemp)
		{
		sprintf(agNameBuf, "%s%s", pPathTemp->pPath, pName);
		// check for existence only. The read errors need to be checked
		// only at read time.

		if( _access( agNameBuf, 0 ) == 0 )
			return pPathTemp->pPath;

		pPathTemp = pPathTemp->pNext;
		}
	
	// we did not find the file, return an error
	return (char *)NULL;
	}

/*** PreProcess ************************************************************
 * Purpose	: to preprocess the given file into an intermediate file
 * Input	: drive, path, name and current extension of the file
 * Output	: STATUS_OK if all is well, error otherwise
 * Notes	: The c compiler uses the /E switch to generate the 
 *			: the preprocessed output with line numbers to a file.
 *			: Now the way to do the preprocessing is to spawn the
 *			: c compiler with the /E switch. But we need to redirect the
 *			: output to a file. To force the spawnee to redirect, we 
 *			: must also do the redirection in this process, so that the
 *			: spawnee inherits our file handles.
 **************************************************************************/
STATUS_T
NFA_INFO::PreProcess(
	char	*pDrive,
	char	*pPath,
	char	*pName,
	char	*pExt,
	char	*&pIFileName )
	{
	STATUS_T	Status = STATUS_OK;
	char		agNameBuf[ _MAX_DRIVE+_MAX_DIR+_MAX_FNAME+_MAX_EXT+1];
	char	*	pCppCmd = (pCompiler->GetCommandProcessor())->GetCPPCmd();
	char	*	pCppOptions;
	char	*	pCppBaseOptions;
	intptr_t	SpawnError;
	int			IFHandle;
	BOOL		fStderrSaved	= FALSE;
	FILE	*	hIFile;
	int			XHandle;
	FILE	*	hXHandle = 0;
	BOOL		fEraseFile		= FALSE;
	char        TempPathBuffer[1000];


    // build up the arguments
	strcpy( agNameBuf, "\"" );
	strcat( agNameBuf, pDrive );
	strcat(agNameBuf,pPath);
	if( *pPath &&  (pPath[ strlen(pPath)-1 ] != '\\'))
		strcat(agNameBuf,"\\");
	strcat( agNameBuf, pName );
	strcat( agNameBuf, pExt );
	strcat( agNameBuf, "\"" );

	pCppBaseOptions = pCommand->GetCPPOpt();
	pCppOptions = new char[ strlen( pCppBaseOptions ) + 40 ];

    int nVersion = ( rmj * 100 ) + ( rmm % 100 );
	if (pCommand->IsSwitchDefined(SWITCH_MKTYPLIB))
        {
        sprintf(pCppOptions, "-D__midl=%d -D__MKTYPLIB__=%d ", nVersion, nVersion );
        }
    else
        {
        sprintf(pCppOptions, "-D__midl=%d ", nVersion );
        }
	strcat( pCppOptions, pCppBaseOptions );
	
	// generate the name of the intermediate file into a buffer

//	pIFileName = _tempnam( NULL, "MIDL" );
	GetTempPathA( 1000, TempPathBuffer );
	pIFileName = new char[1000];
	if ( GetTempFileNameA( TempPathBuffer, "MIDL", 0, pIFileName ) == 0)
		{
		RpcError(	(char *)NULL,
					0,
					Status = INTERMEDIATE_FILE_CREATE,
					TempPathBuffer);
		return Status;
		}

//    printf("Intermediary files\n filename is %s\n agNameBuf is %s\n pCppOptions is %s\n", pIFileName, agNameBuf, pCppOptions );

	// open the intermediate file for writing.

	if( (hIFile = _fsopen( pIFileName, "w", SH_DENYWR )) == (FILE *)0 )
		{
		RpcError(	(char *)NULL,
					0,
					Status = INTERMEDIATE_FILE_CREATE,
					pIFileName);
		return Status;
		}

	IFHandle = MIDL_FILENO( hIFile );

	// save the current stdout handle

	if ( StdoutSave == -1 )
		{
		if( (StdoutSave = _dup(1)) == -1 )
			{
			RpcError(	(char *)NULL,
						0,
						Status = OUT_OF_SYSTEM_FILE_HANDLES,
						(char *)NULL);

			return Status;
			}
		}

	// now force the stdout to refer to the intermediate file handle,
	// thus establishing redirection.

	if( _dup2( IFHandle, 1 ) == -1 )
		{
		RpcError(	(char *)NULL,
					0,
					Status = OUT_OF_SYSTEM_FILE_HANDLES,
					(char *)NULL);
		return Status;
		}


	if( pCommand->IsSwitchDefined(SWITCH_X) )
		{


		fStderrSaved	= TRUE;
		if( (hXHandle = fopen( "nul", "w" ) ) == (FILE *)0 )
			{
			RpcError(	(char *)NULL,
						0,
						Status = INTERMEDIATE_FILE_CREATE,
						"nul");
	
			return Status;
			}

		XHandle = MIDL_FILENO( hXHandle );
	
		// save the current stderr handle
		StderrSave = -1;
		if( (StderrSave = _dup(2)) == -1 )
			{
			RpcError(	(char *)NULL,
						0,
						Status = OUT_OF_SYSTEM_FILE_HANDLES,
						(char *)NULL);

			return Status;
			}
	
		// now force the stdout to refer to the intermediate file handle,
		// thus establishing redirection.
	
		if( _dup2( XHandle, 2 ) == -1 )
			{
			RpcError(	(char *)NULL,
						0,
						Status = OUT_OF_SYSTEM_FILE_HANDLES,
						(char *)NULL);
			return Status;
			}
	
		}

	// From now on, stdout is no longer stdout, till we restore it back.
	// thus if there are intermediate errors, stdout MUST be restored
	// before returning.

	// From now on, stderr is no longer stderr, till we restore it back.
	// stderr MUST be restored before returning.

	SpawnError = MIDL_SPAWNLP(	 P_WAIT
							,pCppCmd
							,pCppCmd
							,pCppOptions
							,agNameBuf
							,(char *)NULL );
	
	delete pCppOptions;

	// before doing anything, close the intermediate file handle

	fclose( hIFile );

	// restore the stdout back

	_dup2( StdoutSave, 1 );

	if( fStderrSaved )
		{
		fclose( hXHandle );
		_dup2( StderrSave, 2 );
		}

	if( SpawnError == -1 )
		{
		switch( errno )
			{
			case ENOMEM:
				Status	= OUT_OF_MEMORY;
				break;
			case ENOENT:
				Status	= NO_PREPROCESSOR;
				break;
			case ENOEXEC:
				Status	= PREPROCESSOR_INVALID;
				break;
			default:
				Status	= PREPROCESSOR_EXEC;
				break;
			}

		RpcError((char *)NULL, 0, Status , pCppCmd);
		fEraseFile	= TRUE;
		}
	else if( SpawnError )
		{
		char	buf[10];
		sprintf(buf, "(%d)", SpawnError );
		RpcError((char *)NULL, 0, Status = PREPROCESSOR_ERROR, buf);
		fEraseFile	= TRUE;
		}

	if( fEraseFile )
		{
		MIDL_UNLINK( pIFileName );
		}


	return Status;
	}

/*** GetChar ****************************************************************
 * Purpose	: get a character from the input stream
 * Input	: nothing
 * Output	: a character from the file
 * Notes	: returns 0 if at end of file
 ****************************************************************************/
short
NFA_INFO::GetChar( void )
	{
		short	ch;

		if( pStack->fRedundantImport )
			{
			fRedundantImport = TRUE;
			return 0x0;
			}

		if( !Flags.fFileSet || !pStack->fOpen) return 0;

		if( ( (ch=(short)getc(pStack->hFile)) == EOF ) && feof(pStack->hFile) )
			return 0;

#if 0
		// if the line starts off with a '#', it may be a line number
		// indicator.

		if(pStack->fNewLine && (ch == '#'))
			{
			unsigned long SavePos = ftell(pStack->hFile);
			char buffer[_MAX_DRIVE + _MAX_PATH + _MAX_FNAME + _MAX_EXT ];
			short Count = 0;
			short fLinePresent = 0;

			// it coule be a # <space> number or #line <space> number

			while( (ch = getc( pStack->hFile ) ) == ' ' );

			if( isdigit( ch ) )
				{
				fLinePresent = 1;
				}
			else
				{
				buffer[ Count++ ] = (char)ch;

				// if it is #line, the first 5 characters will be #line
				while(Count < 4)
					buffer[Count++] = (char) getc(pStack->hFile);
				buffer[Count] = '\0';
				fLinePresent = (strcmp( buffer, "line" ) == 0 );
				if( fLinePresent )
					while( (ch = getc( pStack->hFile )) == ' ' );
				}

			if( fLinePresent )
				{
				Count = 0;
				do
					{
					buffer[Count++] = (char) ch;
					} while( (ch = getc(pStack->hFile)) != ' ');

				buffer[Count] = '\0';

				// line to be seen now is the line number indicated.
				// but the line number indicator is on a line
				// previous to that it indicates, so reflect that in
				// the line number
				pStack->uLine = atoi(buffer) - 1;

				while( (ch=getc(pStack->hFile)) == ' ');
				Count = 0;
//				buffer[Count++] = ch;
//				fgetc(pStack->hFile);		// skip the quote

				if(ch == '\"')
					{
					while( (ch=getc(pStack->hFile)) != '\"')
						{
						buffer[Count++] = (char) ch;
						}
					buffer[Count] = 0;

					// make the collected filename as the new name

					StripSlashes( buffer );

					if(strcmp(buffer, pStack->pName) != 0)
						{
						pStack->pName = new char[Count+1];
						strcpy(pStack->pName, buffer);
						
						// update the line number information, and set current file
						AddFileToDB( pStack->pName );

						}
					}

				while( (ch = getc( pStack->hFile )) != '\n');
				goto newline;
				}
			else
				{
				fseek(pStack->hFile, SavePos, SEEK_SET);
				ch = '#';
				}
			}
newline:
		if(ch == '\n')
			{
			DebugLine = pStack->uLine++;
			pDebugFile= pStack->pName;
			pStack->fNewLine = 1;

			}
		else
			{
			// leave fNewLine set for leading white space
			pStack->fNewLine = pStack->fNewLine && isspace( ch );
			}
#endif // 0
		return ch;
	}

/*** UnGetChar **************************************************************
 * Purpose	: to unget the given character
 * Input	: the character to unget
 * Output	: the character which was unget-ed
 * Notes	:
 ***************************************************************************/
short
NFA_INFO::UnGetChar( 
	short	c)
	{

	if( !Flags.fFileSet || !pStack->fOpen) return 0;
	ungetc( c, pStack->hFile );

#if 0
	if(c == '\n')
		{
		pStack->uLine--;
		// dont know what to do with column, really
		}
#endif
	return c;
	}

/*** GetCurrentInputDetails *************************************************
 * Purpose	: to return details of the current input
 * Input	: pointer to name pointer, pointer to line no, pointer to col
 * Output	: STATUS_OK if all is well, error otherwise
 * Notes	:
 ****************************************************************************/
STATUS_T
NFA_INFO::GetCurrentInputDetails( 
	char **ppName,
	short	 *pLineNo,
	short	 *pColNo )
	{
	if(!pStack)
		{
		(*ppName)	= "";
		(*pLineNo)	= 0;
		(*pColNo)	= 0;
		return NO_INPUT_FILE;
		}

	(*ppName)	= pStack->pName;
	(*pLineNo)	= curr_line_G;
	(*pColNo)	= 0;
	return STATUS_OK;
	}
/*** GetInputDetails ********************************************************
 * Purpose	: to return details of the input
 * Input	: pointer to name pointer, pointer to line no, pointer to col
 * Output	: STATUS_OK if all is well, error otherwise
 * Notes	:
 ****************************************************************************/
STATUS_T
NFA_INFO::GetInputDetails( 
	char **ppName,
	short	 *pLineNo)
	{
	if(!pStack)
		{
		(*ppName)	= "";
		(*pLineNo)	= 0;
		return NO_INPUT_FILE;
		}

	(*ppName)	= pStack->pShadowName;
	(*pLineNo)	= curr_line_G;
	return STATUS_OK;
	}
/*** GetInputDetails ********************************************************
 * Purpose	: to return details of the current input
 * Input	: pointer to name pointer
 * Output	: STATUS_OK if all is well, error otherwise
 * Notes	:
 ****************************************************************************/
STATUS_T
NFA_INFO::GetInputDetails( 
	char **ppName)
	{
	if(!pStack) return NO_INPUT_FILE;

	(*ppName)	= pStack->pShadowName;
	return STATUS_OK;
	}

void
NFA_INFO::SetEOIFlag()
	{
	Flags.fEOI	= 1;
	}

short
NFA_INFO::GetEOIFlag()
	{
	return (short)Flags.fEOI;
	}
BOOL
NFA_INFO::IsInInclude()
	{
	return Flags.fInInclude;
	}
/****************************************************************************
 ****	temp functions to see if things are fine
 ****************************************************************************/
void
NFA_INFO::Dump()
	{
	PATH_LIST	*pPathTemp = pPathList;
	FNAME_LIST	*pNameTemp = pFileList;

	printf("\nDump of file handler data structure:");
	printf("\nPreprocessing      :%d", Flags.fPreProcess);
	printf("\nfFileSet           :%d", Flags.fFileSet);
	printf("\nCurrentLexLevel    :%d", iCurLexLevel);


	printf("\n");
	if(pPathTemp)
		{
		printf("\nList of paths:");
		while( pPathTemp )
			{
			printf("\nPATH:	%s", pPathTemp->pPath);
			pPathTemp	= pPathTemp->pNext;
			}
		}
	if(pNameTemp)
		{
		printf("\nList of input files so far:");
		while(pNameTemp)
			{
			printf("\nFILE:	%s", pNameTemp->pName);
			pNameTemp	= pNameTemp->pNext;
			}
		}
	}

/******************************************************************************
 *	general utility routines
 ******************************************************************************/
/*** SplitFileName ************************************************************
 * Purpose	: to analyse the filename and return individual components
 * Input	: pointers to individual components
 * Output	: nothing
 * Notes	:
 *****************************************************************************/
void
SplitFileName(
	char	*	pFullName,
	char	**	pagDrive,
	char	**	pagPath,
	char	**	pagName,
	char	**	pagExt )
	{
	char		agDrive[ _MAX_DRIVE ];
	char		agPath[ _MAX_DIR ];
	char		agName[ _MAX_FNAME ];
	char		agExt[ _MAX_EXT ];

	_splitpath( pFullName, agDrive, agPath, agName, agExt );

	if( agDrive[0] )
		{
		(*pagDrive) = new char[ strlen(agDrive) + 1 ];
		strcpy( (*pagDrive), agDrive );
		}
	else
		{
		(*pagDrive) = new char[ 1 ];
		*(*pagDrive) = '\0';
		}

	if( agPath[0] )
		{
		(*pagPath) = new char[ strlen(agPath) + 1 ];
		strcpy( (*pagPath), agPath );
		}
	else
		{
		(*pagPath) = new char[ 2 + 1 ];
		strcpy( (*pagPath), ".\\");
		}

	if( agName[0] )
		{
		(*pagName) = new char[ strlen(agName) + 1 ];
		strcpy( (*pagName), agName );
		}
	else
		{
		(*pagName) = new char[ 1 ];
		*(*pagName) = '\0';
		}
	if( agExt[0] )
		{
		(*pagExt) = new char[ strlen(agExt) + 1 ];
		strcpy( (*pagExt), agExt );
		}
	else
		{
		(*pagExt) = new char[ 1 ];
		*(*pagExt) = '\0';
		}

	}

void
StripSlashes(
	char	*	p )
	{
	char	*	pSave = p;
	char	*	p1;
	char	*	dest = new char [ 256 ],
			*	destSave = dest;
	short		n;

	if( p )
		{

		dest[0] = 0;

		while ( ( p1 = strstr( p, "\\\\" ) ) != 0 )
			{
			strncpy( dest, p, n = short(p1 - p) );
			dest 	+= n;
			*dest++  = '\\';
			*dest	 = 0;
			p		 = p1 + 2;
			while( *p == '\\') p++;
			}

		strcat( dest, p );
		strcpy( pSave, destSave );

		}

	delete destSave;
	}

void
ChangeToForwardSlash(
char	* pFullInputName,
char	* pFullName )
	{
	short ch;
	while ( (ch = *pFullInputName++ ) != 0 )
		{
		if( ch == '/' )
			ch = '\\';
		*pFullName++ = (char) ch;
		}
	*pFullName = '\0';
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\front\dict.cxx ===
/* --------------------------------------------------------------------

                      Microsoft OS/2 LAN Manager
                  Copyright(c) Microsoft Corp., 1990-1999

          RPC - Written by Dov Harel


    This file contains the implementation for splay tree self
    adjusting binary trees
-------------------------------------------------------------------- */

#pragma warning ( disable : 4514 )

#include "dict.hxx"

// Handy macros used to define common tree operations.
// Dummy is a member of the Dictionary now, not a global.

#define ROTATELEFT  tmp=t->right; t->right=tmp->left;  tmp->left =t; t=tmp
#define ROTATERIGHT tmp=t->left;  t->left =tmp->right; tmp->right=t; t=tmp

#define LINKLEFT  tmp=t; t = t->right; l = l->right = tmp
#define LINKRIGHT tmp=t; t = t->left;  r = r->left = tmp

#define ASSEMBLE r->left = t->right;     l->right = t->left; \
         t->left = Dummy->right; t->right = Dummy->left


// initialize the memory allocator for TreeNode

FreeListMgr
TreeNode::MyFreeList( sizeof ( TreeNode ) );

//*************************************************************************
//*****       Core functions (internal)               *****
//*************************************************************************

SSIZE_T                  // return last comparision
Dictionary::SplayUserType(        // general top down splay

    pUserType keyItem    // pointer to a "key item" searched for

) //-----------------------------------------------------------------------//
{
    TreeNode*   t;      // current search point
    TreeNode*   l;      // root of "left subtree" < keyItem
    TreeNode*   r;      // root of "right subtree" > keyItem
    SSIZE_T     kcmp;   // cash comparison results
    TreeNode*   tmp;

    if ((fCompare = Compare(keyItem, root->item)) == 0)
    return (fCompare);

    Dummy = l = r = &Dumbo;
    Dumbo.left = Dumbo.right = Nil;

    t = root;

    do {
    if ( fCompare < 0 ) {
     if ( t->left == Nil ) break;

     if ( (kcmp = Compare(keyItem, t->left->item)) == 0 ) {
        LINKRIGHT;
     }
     else if ( kcmp < 0 ) {
                ROTATERIGHT;
        if ( t->left != Nil ) {
         LINKRIGHT;
        }
     }
            else { // keyItem > t->left->item
                LINKRIGHT;
        if ( t->right != Nil ) {
         LINKLEFT;
        }
     }
    }
        else { // keyItem > t->item
     if ( t->right == Nil ) break;

     if ( (kcmp = Compare(keyItem, t->right->item)) == 0 ) {
        LINKLEFT;
     }
     else if ( kcmp > 0 ) {
                ROTATELEFT;
        if ( t->right != Nil ) {
         LINKLEFT;
        }
     }
            else { // keyItem < t->right->item
                LINKLEFT;
        if ( t->left != Nil ) {
         LINKRIGHT;
        }
     }
        }
    } while ( (fCompare = Compare(keyItem, t->item)) != 0 );

    ASSEMBLE;

//  if (fCompare != Compare(keyItem, t->item))
//    printf("Dictionary error!");

    root = t;
    return(fCompare);
}

//-----------------------------------------------------------------------

TreeNode *
Dictionary::SplayLeft(
    TreeNode * t )          // root of tree & current "search" point
{
    TreeNode *  l = Dummy;  // root of "left subtree" < keyItem
    TreeNode *  r = Dummy;  // root of "right subtree" > keyItem
    TreeNode *  tmp;

    if (t == Nil || t->left == Nil)
    return(t);

    if (t->left->left == Nil) {
    ROTATERIGHT;
    return(t);
    }

    Dummy->left = Dummy->right = Nil;

    while ( t->left != Nil ) {
        ROTATERIGHT;

    if ( t->left != Nil ) {
     LINKRIGHT;
    }
    }
    ASSEMBLE;
    return(t);
}

#ifndef DICT_NOPREV

//-----------------------------------------------------------------------

TreeNode *
Dictionary::SplayRight(
    TreeNode * t )          // root of tree & current "search" point
{
    TreeNode *  l = Dummy;  // root of "left subtree" < keyItem
    TreeNode *  r = Dummy;  // root of "right subtree" > keyItem
    TreeNode *  tmp;

    if (t == Nil || t->right == Nil)
    return(t);

    Dummy->left = Dummy->right = Nil;

    while ( t->right != Nil ) {
        ROTATELEFT;

    if ( t->right != Nil ) {
     LINKLEFT;
    }
    }
    ASSEMBLE;
    return(t);
}

#endif



// Class methods for Splay Tree

Dict_Status
Dictionary::Dict_Find(     // return a item that matches

    pUserType itemI        // this value

  // Returns:
  //   itemCur - Nil if at not in Dict, else found item
) //-----------------------------------------------------------------------//
{
    itemCur = Nil;

    if (root == Nil)
    return (EMPTY_DICTIONARY);

    if (itemI == Nil)
    return (NULL_ITEM);

    if (SplayUserType (itemI) == 0){

    itemCur = root->item;
    return(SUCCESS);
    }
//  printf("After NotFound %ld: (", this); PrintItem(itemI); printf(")\n"); Dict_Print();
    return(ITEM_NOT_FOUND);
}

#ifndef DICT_NONEXT

Dict_Status
Dictionary::Dict_Next(        // return the next item

    pUserType itemI        // of a key greater then this

  // Returns:
  //   itemCur - Nil if at end of Dict, else current item
) //-----------------------------------------------------------------------//
{
    TreeNode* t;

    itemCur = Nil;

    if (root == Nil)
    return (EMPTY_DICTIONARY);

    if (itemI == Nil) {         // no arg, return first record
    root = SplayLeft (root);

    itemCur = root->item;
        return (SUCCESS);
    }

    if (itemI != root->item)

    if (SplayUserType (itemI) > 0) {
     itemCur = root->item;
     return (SUCCESS);
    }

    if (root->right == Nil)
    return (LAST_ITEM);

    t = root;

    root = SplayLeft (root->right);
    root->left = t;
    t->right = Nil;

    itemCur = root->item;
    return (SUCCESS);
}
#endif // DICT_NONEXT

#ifndef DICT_NOPREV

Dict_Status
Dictionary::Dict_Prev(        // return the previous item

    pUserType itemI        // of a key less then this

  // Returns:
  //   itemCur - Nil if at begining of Dict, else current item
) //-----------------------------------------------------------------------//
{
    TreeNode* t;

    itemCur = Nil;

    if (root == Nil)
    return (EMPTY_DICTIONARY);

    if (itemI == Nil) {         // no arg, return last record
    root = SplayRight (root);

    itemCur = root->item;
        return (SUCCESS);
    }

    if (itemI != root->item)

    if (SplayUserType (itemI) < 0) {
     itemCur = root->item;
     return (SUCCESS);
    }

    if (root->left == Nil)
    return (LAST_ITEM);

    t = root;
    root = SplayRight (root->left);
    root->right = t;
    t->left = Nil;

    itemCur = root->item;
    return (SUCCESS);
}

#endif // DICT_NOPREV

Dict_Status
Dictionary::Dict_Insert(        // insert the given item into the tree

    pUserType itemI        // the item to be inserted

  // Returns:
  //  itemCur - point to new item
) //-----------------------------------------------------------------------//
{
    TreeNode *newNode, *t;

    if ((itemCur = itemI) == Nil)
    return (NULL_ITEM);

    if (root == Nil) {
    root = new TreeNode(itemI);
        size++;
        return (SUCCESS);
    }

    if (SplayUserType (itemI) == 0)
        return (ITEM_ALREADY_PRESENT);

    newNode = new TreeNode(itemI);
    size++;

    t = root;

    if (fCompare > 0) {
    newNode->right = t->right;    //  item >= t->item
    newNode->left = t;
    t->right = Nil;
    }
    else {
    newNode->left = t->left;
    newNode->right = t;
    t->left = Nil;
    }
    root = newNode;

//  printf("After Insert %ld: (", this); PrintItem(itemI); printf(")\n"); Dict_Print();
    return (SUCCESS);
}


Dict_Status
Dictionary::Dict_Delete(    // delete the given item from the tree

    pUserType *itemI        // points to the (key) item to be deleted

  // Returns:
  //   itemCur is Nil - undefined
) //-----------------------------------------------------------------------//
{
    TreeNode *t, *r;

    itemCur = Nil;

    if (root == Nil)
    return (EMPTY_DICTIONARY);

    if (itemI == Nil)
    return (NULL_ITEM);

    if (itemI != root->item) {

    if (SplayUserType (*itemI) != 0)
     return(ITEM_NOT_FOUND);
    }

    *itemI = root->item;
    t = root;

    if (t->left == Nil)
        root = t->right;

    else if ( (r = t->right) == Nil)
        root = t->left;

    else {
    r = SplayLeft (r);
    r->left = t->left;    // at this point r->left == Nil
        root = r;
    }

    delete t;
    size--;

    return (SUCCESS);
}


pUserType        
Dictionary::Dict_Delete_One()
{
    TreeNode     *    pCurrent    = root;
    TreeNode    *    pPrev        = NULL;        // NULL indicates prev is root
    pUserType        pResult;
    BOOL            fLeft = FALSE;

    while ( pCurrent )
        {
        if ( pCurrent->left )
            {
            pPrev        = pCurrent;
            pCurrent    = pCurrent->left;
            fLeft         = TRUE;
            continue;
            }

        if ( pCurrent->right )
            {
            pPrev        = pCurrent;
            pCurrent    = pCurrent->right;
            fLeft        = FALSE;
            continue;
            }

        // found a leaf
        break;
        }

    // we are now at a leaf (or tree empty)
    if ( !pCurrent )
        return NULL;

    // unhook from parent
    if ( pPrev )
        {
        if ( fLeft )
            pPrev->left        = NULL;
        else
            pPrev->right    = NULL;
        }
    else
        root    = NULL;

    // return the item, and delete the treenode
    pResult    = pCurrent->item;
    delete pCurrent;
    size--;
    return pResult;
}

short
Dictionary::Dict_GetList( 
    gplistmgr & ListIter )
{
    pUserType        pN;
    Dict_Status        Status;
    short            Count = 0;

    // Get to the top of the dictionary.

    Status    = Dict_Next( (pUserType)0 );

    // make sure we start with a clean iterator
    ITERATOR_DISCARD( ListIter );

    // Iterate till the entire dictionary is looked at.

    while( SUCCESS == Status )
        {
        pN    = Dict_Curr_Item();
        ListIter.Insert( pN );
        Count++;
        Status = Dict_Next( pN );
        }

    return Count;
}

// Utility functions to print of a tree

#ifndef DICT_NOPRINT

static indentCur;
static PrintFN printCur;

static char spaces[] =
"                                                                           ";

void
Dictionary::PrinTree(        // recursively print out a tree
    int lmargin,    // current depth & margen
    TreeNode *np    // subtree to print

) //-----------------------------------------------------------------------//
{
    if (np == Nil)
       return;

    PrinTree(lmargin+indentCur, np->right);

    if (lmargin > sizeof(spaces))
    lmargin = sizeof(spaces);;

    spaces[lmargin] = 0;
    printf(spaces);
    spaces[lmargin] = ' ';

    Print(np->item);
    printf("\n");

    PrinTree(lmargin+indentCur, np->left);

}

void
Dictionary::Dict_Print(
long indent

  // prints the binary tree (indented right subtree,
  // followed by the root, followed by the indented right dubtree)
) //-----------------------------------------------------------------------//
{
    indentCur = indent;

    PrinTree(0, root);
}

#endif // DICT_PRINT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\front\erep.cxx ===
/*****************************************************************************/
/**						Microsoft LAN Manager								**/
/**				Copyright(c) Microsoft Corp., 1987-1999						**/
/*****************************************************************************/
/*****************************************************************************
File				: erep.cxx
Title				: error reporting and recovery utility routines
Description			: contains associated routines for the grammar (pass 1)
History				:
	02-Jan-1992	VibhasC	Created
*****************************************************************************/

#pragma warning ( disable : 4514 )

/****************************************************************************
 *			include files
 ***************************************************************************/

#include "nulldefs.h"
extern	"C" {
	#include <stdio.h>
	#include <ctype.h>
	#include <string.h>
	
	#include "ebase.h"
	#include "idlerec.h"
	#include "acferec.h"
	#include "grammar.h"
	}
#include <limits.h>
#include "common.hxx"
#include "errors.hxx"
#include "filehndl.hxx"
#include "control.hxx"


/****************************************************************************
 *			external data
 ***************************************************************************/

extern CCONTROL	*	pCompiler;

/****************************************************************************
 *			external functions
 ***************************************************************************/

/****************************************************************************
 *			local  functions
 ***************************************************************************/

/****************************************************************************
 *			local definitions 
 ***************************************************************************/

#define IDENTIFIER_WEIGHT	(6)
#define NUMBER_WEIGHT		(6)
#define LBRACE_WEIGHT		(5)
#define RBRACE_WEIGHT		(5)
#define RBRACK_WEIGHT		(4)
#define LBRACK_WEIGHT		(4)
#define SEMI_WEIGHT			(3)
#define LPARAN_WEIGHT		(2)
#define RPARAN_WEIGHT		(2)
#define COMMA_WEIGHT		(1)
#define NO_WEIGHT			(0)

short					TokenWeight( short );

typedef short ELEMTYPE;

#define COMPARE_LESS( a, b )	 	( TokenWeight(a) < TokenWeight(b) )
#define COMPARE_GREATER( a, b ) 	( TokenWeight(a) > TokenWeight(b) )

extern char			*	GetExpectedSyntax( char *, short );
void					qsort( ELEMTYPE a[], int l, int r );
int						SearchForGotoStates( short, SGOTO ** );
BOOL					IsValidTokenInState( SGOTO *, short );

/*
   search in the state vs token table to see if a possible missing token
   can be detected. This routine is called when there is a syntax error, and
   a missing token may be the case. A token is a missing token, if the current
   state has a goto where the current token is valid. 

   For each state in the goto entries for the current state, check if the
   current token is a valid token. If it is , then this is a possible missing
   token.

   After the list of possinble missing tokens has been made, the tough part
   is deciding which is the best possible token. Im afraid, the only simple
   thing right now is to decide on the token, on some kind of priority basis.
   Later we might extend the parser semantic actions to indicate which token
   is the token of choice. But for now, this stays.
 */


short
PossibleMissingToken(
	short	State,
	short	CurrentToken)
	{
	short		Token;
	short	*	pToken;
	short	*	pTokenSave;
	SGOTO	*	pSGoto;
	int			Count, i;


	/*
	 * search for the states goto array
	 */

	Count = SearchForGotoStates( State, &pSGoto );

	if( !Count ) return -1;

	pToken = pTokenSave = new short[ Count ];

	/*
	   for each goto in the array, search for the state where the current
	   token is valid.
	 */
	
	for( i = 0;
		 i < Count;
		 i++ )
		 {

		 if( IsValidTokenInState( pSGoto + i, CurrentToken ))
			{
			Token 	  = (pSGoto+i)->Token;

		 	if( (Token < 128 )			||
			 	(Token == IDENTIFIER)	||
			 	(Token == NUMERICCONSTANT))
				{
				*pToken++ = Token;
				}

			}

		 }
	/*
		if we cannot make any intelligent decision about the lookahead token
		pick up the ones in the current lookahead set

	 */

	if( (pToken - pTokenSave) == 0 )
		{
		delete pTokenSave;
		return -1;
		}

	if( pCompiler->GetPassNumber() == IDL_PASS )
		{
		if( (pToken - pTokenSave) == 0 )
			{
			for( i = 0;
		 		i < Count;
		 		i++ )
		 		{
		
	
				Token = (pSGoto+i)->Token;
	
		 		if( (Token < 128 )			||
			 		(Token == IDENTIFIER)	||
			 		(Token == NUMERICCONSTANT))
					{
					*pToken++ = Token;
					}
	
		 		}
			}
		}


	/*
		We now have a list of possible tokens. Sort them in the order of
		priority.
	 */
	
	if( pToken - pTokenSave )
		{
        MIDL_ASSERT( (pToken - pTokenSave - 1) <= INT_MAX );
		qsort( pTokenSave, 0, (int) (pToken - pTokenSave - 1));

		/* return the first in the list */

		CurrentToken =  *pTokenSave;

		}
	else
		CurrentToken = -1;


	delete pTokenSave;

	return CurrentToken;
	}

int
SearchForGotoStates(
	short	State,
	SGOTO	**	ppSGoto)
	{
	int				i;
	SGOTOVECTOR	*	p = SGotoIDL;
	short			ValidStates;

	if( (pCompiler->GetPassNumber() == IDL_PASS ) )
		{
		ValidStates = VALIDSTATES_IDL;
		p = SGotoIDL;
		}
	else
		{
		ValidStates = VALIDSTATES_ACF;
		p = SGotoACF;
		}

	for( i = 0; i < ValidStates; ++i,++p )
		{
		if( p->State == State )
			{
			*ppSGoto = p->pSGoto;
			return p->Count;
			}
		}
	return 0;
	}

BOOL
IsValidTokenInState(
	SGOTO *	pSGoto,
	short	Token )
	{
	int			Count,i;
	SGOTO	*	p;
	short		State = pSGoto->Goto;
	
	Count = SearchForGotoStates( State, &p );

	if( !Count )
		{

	if( pCompiler->GetPassNumber() == IDL_PASS )
		{
		if( ( (pSGoto->Token == IDENTIFIER ) ||
			  (pSGoto->Token == NUMERICCONSTANT) &&
			  (Token == (short) ';' )) )
			  {
			  return TRUE;
			  }
		}

		return FALSE;
		}

	for( i = 0; i < Count; ++i, ++p )
		{
		if( p->Token == Token )
			return TRUE;
		}
	return FALSE;
	}

void
qsort( 
	ELEMTYPE	a[],
	int			l,
	int			r )
	{

	ELEMTYPE	v, t;
	int			i, j;


	if( r > l )
		{

		v	= a[ r ];
		i 	= l - 1;
		j	= r;

		for (;; )
			{

			/** sort in reverse order of token weight **/

			while( COMPARE_GREATER( a[ ++i ], v ) );
			while( COMPARE_LESS( a[ --j ], v ) );

			if( i >= j ) break;

			t		= a[ i ];
			a[ i ]	= a[ j ];
			a[ j ] 	= t;

			}

		t		= a[ i ];
		a[ i ]	= a[ r ];
		a[ r ] 	= t;

		qsort( a, l, i - 1 );
		qsort( a, i+1, r );
		}
	}

char *
GetExpectedSyntax(
	char	*	pBuffer,
	short		state )
	{
	int 		i = 0;
	int			Max;
	DBENTRY *	pDB;

	if( (pCompiler->GetPassNumber() == IDL_PASS ) )
		{
		pDB	= IDL_SyntaxErrorDB;
		Max	= MAXSTATEVSEXPECTED_SIZE_IDL;
		}
	else
		{
		pDB	= ACF_SyntaxErrorDB;
		Max	= MAXSTATEVSEXPECTED_SIZE_ACF;
		}

	while( i < Max ) 
		{
		if( pDB[ i ].State == state )
			{
			char fFirst = 1;
			strcpy( pBuffer , "expecting ");

			while( pDB[ i ].State == state )
				{
				// make sure not to report the same translated string twice, when two non-terminals
				// have the same translated string
				if ( !strstr( pBuffer, pDB[ i ].pTranslated ) )
					{
					if( !fFirst )
						strcat( pBuffer, " or ");
					fFirst = 0;
					strcat( pBuffer, pDB[ i ].pTranslated );
					}
				i++;
				}
			return pBuffer;
			}
		else
			i++;
		}
	return (char *)NULL;
	}

short
TokenWeight(
	short	Token)
	{
	switch( Token )
		{
		case IDENTIFIER:			return IDENTIFIER_WEIGHT;

		case NUMERICCONSTANT:		return NUMBER_WEIGHT;

		case (short)(']'):			return RBRACK_WEIGHT;

		case (short)('['):			return LBRACK_WEIGHT;

		case (short)('{'):			return LBRACE_WEIGHT;

		case (short)('}'):			return RBRACE_WEIGHT;

		case (short)(';'):			return SEMI_WEIGHT;

		case (short)('('):			return LPARAN_WEIGHT;

		case (short)(')'):			return RPARAN_WEIGHT;

		case (short)(','):			return COMMA_WEIGHT;

		default:					return NO_WEIGHT;
		}
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\front\gramutil.cxx ===
/*****************************************************************************/
/**						Microsoft LAN Manager								**/
/**				Copyright(c) Microsoft Corp., 1987-1999						**/
/*****************************************************************************/
/*****************************************************************************
File				: gramutil.cxx
Title				: grammar utility routines
Description			: contains associated routines for the grammar (pass 1)
History				:
	05-Aug-1991	VibhasC	Created
*****************************************************************************/

#pragma warning ( disable : 4514 4710 )

/****************************************************************************
 *			include files
 ***************************************************************************/

#include "nulldefs.h"
extern	"C" {
	#include <stdio.h>
	#include <ctype.h>
	#include <string.h>
	
	}
#include "lextable.hxx"
#include "allnodes.hxx"
#include "gramutil.hxx"
#include "filehndl.hxx"
#include "idict.hxx"
#include "control.hxx"
#include "cmdana.hxx"

/****************************************************************************
 *			external data
 ***************************************************************************/

extern CMD_ARG			*	pCommand;
extern class _nfa_info	*	pImportCntrl;
extern pre_type_db		*	pPreAllocTypes;
extern SymTable			*	pBaseSymTbl;
extern node_error		*	pErrorTypeNode;
extern short				CompileMode;
extern node_e_attr		*	pErrorAttrNode;
extern CCONTROL			*	pCompiler;
extern LexTable			*	pMidlLexTable;
extern IINFODICT		*	pInterfaceInfoDict;
extern short				ImportLevel;
extern node_e_status_t	*	pError_status_t;
extern IDICT			*	pInterfaceDict;

/****************************************************************************
 *			external functions
 ***************************************************************************/

extern char			*	GetTypeName( short );
extern STATUS_T			GetBaseTypeNode( node_skl **, short, short, short);
extern ATTRLIST			GenerateFieldAttribute(ATTR_T, expr_list *);

extern char			*	GetExpectedSyntax( char *, short );
extern int				GetExpectedChar( short );
extern void				CheckGlobalNamesClash( SymKey );
extern void             NormalizeString( char*   szSrc, char*   szNrm );

/****************************************************************************
 *			local  functions
 ***************************************************************************/

/****************************************************************************
 *			local definitions
 ***************************************************************************/
//
// the parse stack
//
lextype_t	yyv[YYMAXDEPTH];	/* where the values are stored */
short		yys[YYMAXDEPTH];	/* the parse stack */


struct pre_init
	{
	unsigned short		TypeSpec;
	NODE_T				NodeType;
	ATTR_T				Attr; // signed or unsigned
	ATTR_T				Attr2; // __w64
	char			*	pSymName;
	};
struct pre_init PreInitArray[ PRE_TYPE_DB_SIZE ] =
{
 { /** float **/
   MAKE_TYPE_SPEC( SIGN_UNDEF, SIZE_UNDEF, TYPE_FLOAT, ATT_NONE )
  ,NODE_FLOAT
  ,(ATTR_T)ATTR_NONE
  ,(ATTR_T)ATTR_NONE
  ,"float"
 }
,{ /** double **/
   MAKE_TYPE_SPEC( SIGN_UNDEF, SIZE_UNDEF, TYPE_DOUBLE, ATT_NONE )
  ,NODE_DOUBLE
  ,(ATTR_T)ATTR_NONE
  ,(ATTR_T)ATTR_NONE
  ,"double"
 }
,{  /** __float80 **/
   MAKE_TYPE_SPEC( SIGN_UNDEF, SIZE_UNDEF, TYPE_FLOAT80, ATT_NONE )
  ,NODE_FLOAT80
  ,(ATTR_T)ATTR_NONE
  ,(ATTR_T)ATTR_NONE
  ,"__float80"
}
,{  /** __float128 **/
   MAKE_TYPE_SPEC( SIGN_UNDEF, SIZE_UNDEF, TYPE_FLOAT128, ATT_NONE )
  ,NODE_FLOAT128
  ,(ATTR_T)ATTR_NONE
  ,(ATTR_T)ATTR_NONE
  ,"__float128"
}
,{ /** signed hyper **/
   MAKE_TYPE_SPEC( SIGN_SIGNED, SIZE_HYPER, TYPE_INT, ATT_NONE )
  ,NODE_HYPER
  ,(ATTR_T)ATTR_NONE
  ,(ATTR_T)ATTR_NONE
  ,"hyper"
 }
,{ /** unsigned hyper **/
   MAKE_TYPE_SPEC( SIGN_UNSIGNED, SIZE_HYPER, TYPE_INT, ATT_NONE )
  ,NODE_HYPER
  ,(ATTR_T)ATTR_UNSIGNED
  ,(ATTR_T)ATTR_NONE
  ,"hyper"
 }
,{ /** signed int32 **/
   MAKE_TYPE_SPEC( SIGN_SIGNED, SIZE_INT32, TYPE_INT, ATT_NONE )
  ,NODE_INT32
  ,(ATTR_T)ATTR_NONE
  ,(ATTR_T)ATTR_NONE
  ,"__int32"
 }
,{ /** unsigned int32 **/
   MAKE_TYPE_SPEC( SIGN_UNSIGNED, SIZE_INT32, TYPE_INT, ATT_NONE )
  ,NODE_INT32
  ,(ATTR_T)ATTR_UNSIGNED
  ,(ATTR_T)ATTR_NONE
  ,"__int32"
 }
,{ /** signed int3264 **/
   MAKE_TYPE_SPEC( SIGN_SIGNED, SIZE_INT3264, TYPE_INT, ATT_NONE )
  ,NODE_INT3264
  ,(ATTR_T)ATTR_NONE
  ,(ATTR_T)ATTR_NONE
  ,"__int3264"
 }
,{ /** unsigned int3264 **/
   MAKE_TYPE_SPEC( SIGN_UNSIGNED, SIZE_INT3264, TYPE_INT, ATT_NONE )
  ,NODE_INT3264
  ,(ATTR_T)ATTR_UNSIGNED
  ,(ATTR_T)ATTR_NONE
  ,"__int3264"
 }
,{ /** signed int64 **/
   MAKE_TYPE_SPEC( SIGN_SIGNED, SIZE_INT64, TYPE_INT, ATT_NONE )
  ,NODE_INT64
  ,(ATTR_T)ATTR_NONE
  ,(ATTR_T)ATTR_NONE
  ,"__int64"
 }
,{ /** unsigned int64 **/
   MAKE_TYPE_SPEC( SIGN_UNSIGNED, SIZE_INT64, TYPE_INT, ATT_NONE )
  ,NODE_INT64
  ,(ATTR_T)ATTR_UNSIGNED
  ,(ATTR_T)ATTR_NONE
  ,"__int64"
 }
,{ /** signed int128 **/
   MAKE_TYPE_SPEC( SIGN_SIGNED, SIZE_INT128, TYPE_INT, ATT_NONE )
  ,NODE_INT128
  ,(ATTR_T)ATTR_NONE
  ,(ATTR_T)ATTR_NONE
  ,"__int128"
 }
,{ /** unsigned int128 **/
   MAKE_TYPE_SPEC( SIGN_UNSIGNED, SIZE_INT128, TYPE_INT, ATT_NONE )
  ,NODE_INT128
  ,(ATTR_T)ATTR_UNSIGNED
  ,(ATTR_T)ATTR_NONE
  ,"__int128"
 }
,{ /** signed long **/
   MAKE_TYPE_SPEC( SIGN_SIGNED, SIZE_LONG, TYPE_INT, ATT_NONE )
  ,NODE_LONG
  ,(ATTR_T)ATTR_NONE
  ,(ATTR_T)ATTR_NONE
  ,"long"
 }
,{ /** unsigned long **/
   MAKE_TYPE_SPEC( SIGN_UNSIGNED, SIZE_LONG, TYPE_INT, ATT_NONE )
  ,NODE_LONG
  ,(ATTR_T)ATTR_UNSIGNED
  ,(ATTR_T)ATTR_NONE
  ,"long"
 }
,{ /** signed int **/
   MAKE_TYPE_SPEC( SIGN_SIGNED, SIZE_UNDEF, TYPE_INT, ATT_NONE )
  ,NODE_INT
  ,(ATTR_T)ATTR_NONE
  ,(ATTR_T)ATTR_NONE
  ,"int"
 }
,{ /** unsigned int **/
   MAKE_TYPE_SPEC( SIGN_UNSIGNED, SIZE_UNDEF, TYPE_INT, ATT_NONE )
  ,NODE_INT
  ,(ATTR_T)ATTR_UNSIGNED
  ,(ATTR_T)ATTR_NONE
  ,"int"
 }
,{ /** __w64 signed long **/
   MAKE_TYPE_SPEC( SIGN_SIGNED, SIZE_LONG, TYPE_INT, ATT_W64 )
  ,NODE_LONG
  ,(ATTR_T)ATTR_NONE
  ,(ATTR_T)ATTR_W64
  ,"long"
 }
,{ /** __w64 unsigned long **/
   MAKE_TYPE_SPEC( SIGN_UNSIGNED, SIZE_LONG, TYPE_INT, ATT_W64 )
  ,NODE_LONG
  ,(ATTR_T)ATTR_UNSIGNED
  ,(ATTR_T)ATTR_W64
  ,"long"
 }
,{ /** __w64 signed int **/
   MAKE_TYPE_SPEC( SIGN_SIGNED, SIZE_UNDEF, TYPE_INT, ATT_W64 )
  ,NODE_INT
  ,(ATTR_T)ATTR_NONE
  ,(ATTR_T)ATTR_W64
  ,"int"
 }
,{ /** __w64 unsigned int **/
   MAKE_TYPE_SPEC( SIGN_UNSIGNED, SIZE_UNDEF, TYPE_INT, ATT_W64 )
  ,NODE_INT
  ,(ATTR_T)ATTR_UNSIGNED
  ,(ATTR_T)ATTR_W64
  ,"int"
 }
,{ /** signed short **/
   MAKE_TYPE_SPEC( SIGN_SIGNED, SIZE_SHORT, TYPE_INT, ATT_NONE )
  ,NODE_SHORT
  ,(ATTR_T)ATTR_NONE
  ,(ATTR_T)ATTR_NONE
  ,"short"
 }
,{ /** unsigned short **/
   MAKE_TYPE_SPEC( SIGN_UNSIGNED, SIZE_SHORT, TYPE_INT, ATT_NONE )
  ,NODE_SHORT
  ,(ATTR_T)ATTR_UNSIGNED
  ,(ATTR_T)ATTR_NONE
  ,"short"
 }
,{ /** signed small **/
   MAKE_TYPE_SPEC( SIGN_SIGNED, SIZE_SMALL, TYPE_INT, ATT_NONE )
  ,NODE_SMALL
  ,(ATTR_T)ATTR_SIGNED
  ,(ATTR_T)ATTR_NONE
  ,"small"
 }
,{ /** small **//** NOTE : SMALL W/O SIGN IS A SPECIAL HACK FOR THE BACKEND **/
   MAKE_TYPE_SPEC( SIGN_UNDEF, SIZE_SMALL, TYPE_INT, ATT_NONE )
  ,NODE_SMALL
  ,(ATTR_T)ATTR_NONE
  ,(ATTR_T)ATTR_NONE
  ,"small"
 }
,{ /** unsigned small **/
   MAKE_TYPE_SPEC( SIGN_UNSIGNED, SIZE_SMALL, TYPE_INT, ATT_NONE )
  ,NODE_SMALL
  ,(ATTR_T)ATTR_UNSIGNED
  ,(ATTR_T)ATTR_NONE
  ,"small"
 }
,{ /** signed char **/
   MAKE_TYPE_SPEC( SIGN_SIGNED, SIZE_CHAR, TYPE_INT, ATT_NONE )
  ,NODE_CHAR
  ,(ATTR_T)ATTR_SIGNED
  ,(ATTR_T)ATTR_NONE
  ,"char"
 }
,{ /** plain char **/
   MAKE_TYPE_SPEC( SIGN_UNDEF, SIZE_CHAR, TYPE_INT, ATT_NONE )
  ,NODE_CHAR
  ,(ATTR_T)ATTR_NONE
  ,(ATTR_T)ATTR_NONE
  ,"char"
 }
,{ /** unsigned char **/
   MAKE_TYPE_SPEC( SIGN_UNSIGNED, SIZE_CHAR, TYPE_INT, ATT_NONE )
  ,NODE_CHAR
  ,(ATTR_T)ATTR_UNSIGNED
  ,(ATTR_T)ATTR_NONE
  ,"char"
 }
,{ /** boolean **/
   MAKE_TYPE_SPEC( SIGN_UNDEF, SIZE_UNDEF, TYPE_BOOLEAN, ATT_NONE )
  ,NODE_BOOLEAN
  ,(ATTR_T)ATTR_NONE
  ,(ATTR_T)ATTR_NONE
  ,"boolean"
 }
,{ /** byte **/
   MAKE_TYPE_SPEC( SIGN_UNDEF, SIZE_UNDEF, TYPE_BYTE, ATT_NONE )
  ,NODE_BYTE
  ,(ATTR_T)ATTR_NONE
  ,(ATTR_T)ATTR_NONE
  ,"byte"
 }
,{ /** void **/
   MAKE_TYPE_SPEC( SIGN_UNDEF, SIZE_UNDEF, TYPE_VOID, ATT_NONE )
  ,NODE_VOID
  ,(ATTR_T)ATTR_NONE
  ,(ATTR_T)ATTR_NONE
  ,"void"
 }
,{ /** handle_t **/
   MAKE_TYPE_SPEC( SIGN_UNDEF, SIZE_UNDEF, TYPE_HANDLE_T, ATT_NONE )
  ,NODE_HANDLE_T
  ,(ATTR_T)ATTR_NONE
  ,(ATTR_T)ATTR_NONE
  ,"handle_t"
 }
,{ /** signed long long **/
   MAKE_TYPE_SPEC( SIGN_SIGNED, SIZE_LONGLONG, TYPE_INT, ATT_NONE )
  ,NODE_LONGLONG
  ,(ATTR_T)ATTR_NONE
  ,(ATTR_T)ATTR_NONE
  ,"long long"
 }
,{ /** unsigned long **/
   MAKE_TYPE_SPEC( SIGN_UNSIGNED, SIZE_LONGLONG, TYPE_INT, ATT_NONE )
  ,NODE_LONGLONG
  ,(ATTR_T)ATTR_UNSIGNED
  ,(ATTR_T)ATTR_NONE
  ,"long long"
 }
};


/*****************************************************************************/


SIBLING_LIST
SIBLING_LIST::Add( named_node * pNewNode )
	{
	if (pTail == NULL)
		{
		return Init( pNewNode );
		};

	if ( pNewNode )
		{
		named_node * pHead =  (named_node *) pTail->GetSibling();

		pNewNode->SetSibling( pHead );
		pTail->SetSibling(pNewNode);
		pTail = pNewNode;
		};

	return *this;
	};

SIBLING_LIST
SIBLING_LIST::Merge( SIBLING_LIST & NewList )
	{
	if (NewList.pTail == NULL)
		{
		return *this;
		};

	if ( pTail != NULL )
		{
		named_node * tmp = (named_node *)
					NewList.pTail->GetSibling();
		NewList.pTail->SetSibling( pTail->GetSibling());
		pTail->SetSibling(tmp);
		};

	pTail = NewList.pTail;
	return *this;
	};

named_node *
SIBLING_LIST::Linearize()
	{
	named_node * pHead;

	if (pTail == NULL)
		{
		pHead = NULL;
		}
	else
		{
		pHead =  (named_node *) pTail->GetSibling();

		pTail->SetSibling( (named_node *) NULL);
		};

	return pHead;
	};

void
SIBLING_LIST::AddAttributes( ATTRLIST & AList )
{
	named_node * 	pCur;
	ATTRLIST		pClone;

	// for each of the node_skl nodes, apply the ATTRLIST
	if ( pTail == NULL) return;

	pCur = pTail->GetSibling();
	// this traversal skips the last node on the list;
	// that one gets the original list added.
	while (pCur != pTail)
		{
		// clone attr list
		// apply to pCur
		pClone = AList.Clone();
		pCur->AddAttributes( AList );

		pCur = pCur->GetSibling();
		}

	pCur->AddAttributes( AList );

}

/*****************************************************************************/

/*** ParseError ************************************************************
 * Purpose	: format and report parsing errors
 * Input	:
 * Output	:
 * Notes	: errors will be reported many times. This is one localised place
 *			: for the RpcError Call
 ***************************************************************************/
void
ParseError(
	STATUS_T		Err,
	char 		*	pSuffix )
	{
	char	*	pFileName;
	short		Line;
	short		Col;
	char		TempBuf[512 + 50];
	char	*	pBuffer;
	ErrorInfo	ErrStats( Err );

	if ( !ErrStats.IsRelevant() )
		return;

	pImportCntrl->GetCurrentInputDetails( &pFileName, &Line, &Col);

	if (pSuffix)
		{
		strcpy( TempBuf, ": " );
		strcat( TempBuf, pSuffix );
		pBuffer = TempBuf;
		}
	else
		{
		pBuffer = "";
		}

	ErrStats.ReportError(pFileName, Line, pBuffer);
	}

void
SyntaxError(
	STATUS_T	Err,
	short		State )
	{

#define NEAR_STRING 			(" near ")
#define STRLEN_OF_NEAR_STRING	(6)

	extern	char *tokptr_G;
	char	*	pTemp;
	short		len		= (short) strlen( tokptr_G );
	char	*	pBuffer	= new char[
									512	+
									STRLEN_OF_NEAR_STRING +
									len + 2 +
									1 ];



#ifndef NO_GOOD_ERRORS

	if( Err == BENIGN_SYNTAX_ERROR )
		{
		GetExpectedSyntax( pBuffer, State );
		strcat( pBuffer, NEAR_STRING );
		strcat( pBuffer, "\"" );
		strcat( pBuffer, tokptr_G );
		strcat( pBuffer, "\"" );
		pTemp = pBuffer;
		}
	else
		pTemp = (char *)0;

	ParseError( Err, pTemp );

#else // NO_GOOD_ERRORS

	strcpy( pBuffer, "syntax error" );
	ParseError( Err, pBuffer );

#endif // NO_GOOD_ERRORS

	delete pBuffer;

	}


/*** BaseTypeSpecAnalysis  *************************************************
 * Purpose	: to check for valid base type specification
 * Input	: pointer to already collected specs, new base type spec
 * Output	: modified collected specs
 * Notes	:
 ***************************************************************************/
void
BaseTypeSpecAnalysis(
	struct _type_ana *pType,
	short			 NewBaseType )
	{
	char	TempBuf[ 50 ];

	if( pType->BaseType == TYPE_PIPE )
		return;
	if( (pType->BaseType != TYPE_UNDEF)  && (NewBaseType != TYPE_UNDEF) )
		{
		sprintf(TempBuf,", ignoring %s", GetTypeName(NewBaseType));
		ParseError(BENIGN_SYNTAX_ERROR, TempBuf);
		}
	if(NewBaseType != TYPE_UNDEF)
		pType->BaseType = NewBaseType;
	}

/**************************************************************************
 *		routines for the pre_type_db class
 **************************************************************************/
/*** pre_type_db *********************************************************
 * Purpose	: constructor for pre-allocated type data base
 * Input	: nothing
 * Output	:
 * Notes	: inits the prellocated types data base. This routine exist mainly
 *			: because static preallocation was giving a problem. If that is
 *			: solved, remove this
 **************************************************************************/
pre_type_db::pre_type_db (void)
	{
	named_node			*	pNode;
	int						i			= 0;
	struct _pre_type	*	pPreType	= &TypeDB[ 0 ];
	struct pre_init		*	pInitCur	= PreInitArray;

	while( i < PRE_TYPE_DB_SIZE )
		{
		pPreType->TypeSpec	= pInitCur->TypeSpec;
		pPreType->pPreAlloc	= pNode = new node_base_type(
										pInitCur->NodeType,
										pInitCur->Attr );
        if ( pInitCur->Attr2 == ATTR_W64 )
            {
            pNode->GetModifiers().SetModifier( pInitCur->Attr2 );
            }
		pNode->SetSymName( pInitCur->pSymName );
		pInitCur++;
		pPreType++;
		++i;
		}

	}

/*** GetPreAllocType ******************************************************
 * Purpose	: to search for a preallocated base type node, whose type
 *			: spec is provided
 * Input	: pointer to the resultant base node
 * Output	: STATUS_OK if all is well, error otherwise
 * Notes	:
 **************************************************************************/
STATUS_T
pre_type_db::GetPreAllocType(
	node_skl	 **	ppNode,
	unsigned short		TypeSpec )
	{
	int i = 0;

	if( GET_TYPE( TypeSpec ) == TYPE_PIPE )
		{
		(*ppNode) = pErrorTypeNode;
		return STATUS_OK;
		}

	while(i < sizeof(TypeDB) / sizeof(struct _pre_type) )
		{
		if( TypeDB[i].TypeSpec	== TypeSpec )
			{
			(*ppNode)	= TypeDB[i].pPreAlloc;
			return STATUS_OK;
			}
		++i;
		}
	return SYNTAX_ERROR;
	}


/****************************************************************************
 *			nested symbol table access support
 ***************************************************************************/
nsa::nsa( void )
	{
	SymTable *	pSymTable = new GlobalSymTable;
	CurrentLevel	= 0;
	InsertHead( (void *)pSymTable );
	}
STATUS_T
nsa::PushSymLevel(
	SymTable **ppSymTable )
	{
	STATUS_T	Status;
	SymTable *pSymTable = new SymTable;

	CurrentLevel++;
	Status = InsertHead( (void *)pSymTable);
	*ppSymTable = pSymTable;
	return Status;
	}
STATUS_T
nsa::PopSymLevel(
	SymTable **ppSymTable )
	{
	if(CurrentLevel == 0)
		return I_ERR_SYMTABLE_UNDERFLOW;
	CurrentLevel--;
	RemoveHead();
	return GetCurrent( (void **)ppSymTable );
	}
short
nsa::GetCurrentLevel( void )
	{
	return CurrentLevel;
	}
SymTable *
nsa::GetCurrentSymbolTable()
	{
	SymTable *pSymbolTable;
	GetCurrent( (void **)&pSymbolTable );
	return pSymbolTable;
	}

/****************************************************************************
 *			nested symbol table access support
 ***************************************************************************/
void
IINFODICT::StartNewInterface()
	{
	IINFO	*	pInfo	= new IINFO;

	pInfo->fLocal					= FALSE;
	pInfo->InterfacePtrAttribute	= ATTR_NONE;
	pInfo->pInterfaceNode			= NULL;
	pInfo->CurrentTagNumber			= 1;
	pInfo->fPtrDefErrorReported		= 0;
	pInfo->fPtrWarningIssued		= FALSE;
	pInfo->IntfKey					= CurrentIntfKey;

	Push( (IDICTELEMENT) pInfo );

	}

BOOL
IINFODICT::IsPtrWarningIssued()
	{
	IINFO	*	pInfo	= (IINFO *)GetTop();
	return pInfo->fPtrWarningIssued;
	}

void
IINFODICT::SetPtrWarningIssued()
	{
	IINFO	*	pInfo	= (IINFO *)GetTop();
	pInfo->fPtrWarningIssued  =  TRUE;
	}

void
IINFODICT::EndNewInterface()
	{
	IINFO	*	pInfo	= (IINFO *)GetTop();

	delete pInfo;
	Pop();

	pInfo = (IINFO *) GetTop();
	if ( pInfo )
		CurrentIntfKey = pInfo->IntfKey;	
	}
void
IINFODICT::SetInterfacePtrAttribute(
	ATTR_T	A )
	{
	IINFO	*	pInfo	= (IINFO *)GetTop();
	pInfo->InterfacePtrAttribute	= A;
	if( ImportLevel == 0 ) BaseInterfacePtrAttribute = A;
	}
void
IINFODICT::SetInterfaceLocal()
	{
	IINFO	*	pInfo	= (IINFO *)GetTop();
	pInfo->fLocal	= TRUE;
	if( ImportLevel == 0 ) fBaseLocal = TRUE;
	}
void
IINFODICT::SetInterfaceNode(
	node_interface	*	p )
	{
	IINFO	*	pInfo	= (IINFO *)GetTop();
	pInfo->pInterfaceNode	= p;
	if( ImportLevel == 0 ) pBaseInterfaceNode = p;
	CurrentIntfKey	= (unsigned short) pInterfaceDict->AddElement( p );
	pInfo->IntfKey = CurrentIntfKey;
	}
void
IINFODICT::IncrementCurrentTagNumber()
	{
	IINFO	*	pInfo	= (IINFO *)GetTop();
	pInfo->CurrentTagNumber++;
	}
ATTR_T
IINFODICT::GetInterfacePtrAttribute()
	{
	IINFO	*	pInfo	= (IINFO *)GetTop();
	return pInfo->InterfacePtrAttribute;
	}
ATTR_T
IINFODICT::GetBaseInterfacePtrAttribute()
	{
	return BaseInterfacePtrAttribute;
	}
BOOL
IINFODICT::IsInterfaceLocal()
	{
	IINFO	*	pInfo	= (IINFO *)GetTop();
	return pInfo->fLocal;
	}
node_interface *
IINFODICT::GetInterfaceNode()
	{
	IINFO	*	pInfo	= (IINFO *)GetTop();
	return pInfo->pInterfaceNode;
	}
short
IINFODICT::GetCurrentTagNumber()
	{
	IINFO	*	pInfo	= (IINFO *)GetTop();
	return pInfo->CurrentTagNumber;
	}
void
IINFODICT::SetPtrDefErrorReported()
	{
	IINFO	*	pInfo	= (IINFO *) GetTop();
	pInfo->fPtrDefErrorReported = 1;
	}
BOOL
IINFODICT::IsPtrDefErrorReported()
	{
	IINFO	*	pInfo	= (IINFO *) GetTop();
	return (BOOL) (pInfo->fPtrDefErrorReported == 1);
	}


/****************************************************************************
 *			utility functions
 ***************************************************************************/
char *
GetTypeName(
	short Type )
	{
	char	*p;
	switch(Type)
		{
		case  TYPE_INT:			p = "\"int\""; break;
		case  TYPE_FLOAT:		p = "\"float\""; break;
		case  TYPE_DOUBLE:		p = "\"double\""; break;
                case  TYPE_FLOAT80:             p = "\"__float80\""; break;
                case  TYPE_FLOAT128:            p = "\"__float128\""; break;
		case  TYPE_VOID:		p = "\"void\""; break;
		case  TYPE_BOOLEAN:		p = "\"boolean\""; break;
		case  TYPE_HANDLE_T:	p = "\"handle_t\""; break;
		default:				p = ""; break;
		}
	return p;
	}

STATUS_T
GetBaseTypeNode(
	node_skl	**	ppNode,
	short				TypeSign,
	short				TypeSize,
	short				BaseType,
    short               TypeAttrib)
	{

	STATUS_T uStatus = STATUS_OK;

	if( pPreAllocTypes->GetPreAllocType(
					ppNode,
					(unsigned short)MAKE_TYPE_SPEC(TypeSign,TypeSize,BaseType,TypeAttrib)) != STATUS_OK)
		{
		// this should never happen
		MIDL_ASSERT( FALSE );
		*ppNode = (node_skl *)new node_error;
		}
	return uStatus;

	}

STATUS_T
GetBaseTypeNode(
	node_skl	**	ppNode,
	struct _type_ana	Type)
	{

	STATUS_T uStatus = STATUS_OK;

	if( pPreAllocTypes->GetPreAllocType(
					ppNode,
					(unsigned short)MAKE_TYPE_SPEC(Type.TypeSign,Type.TypeSize,Type.BaseType, Type.TypeAttrib)) != STATUS_OK)
		{
		// this should never happen
		*ppNode = (node_skl *) NULL;
		}
	return uStatus;

	}

#define TEMPNAME				("__MIDL_")
#define TEMP_NAME_LENGTH		(7)
#define INTF_ADDITION			("itf_")
#define INTF_ADDITION_LENGTH	(4)
#define LENGTH_OF_1_UNDERSCORE	(1)

char *
GenTempName()
	{
static short NameCounter = 0;
	char TempBuf[ TEMP_NAME_LENGTH + 4 + 1 ];
	sprintf(TempBuf, "%s%.4d", TEMPNAME, NameCounter++);
	return pMidlLexTable->LexInsert( TempBuf );
	}

char *
GenIntfName()
	{
static short NameCounter = 0;
	char TempBuf[ TEMP_NAME_LENGTH + INTF_ADDITION_LENGTH + 4 + 1 + _MAX_PATH ];
	char FileBase[_MAX_PATH];
	char dbcsFileBase[_MAX_PATH*2];
	pCommand->GetInputFileNameComponents(NULL, NULL, FileBase, NULL );
    
    // account for spaces and DBCS chars.
    NormalizeString( FileBase, dbcsFileBase );

	sprintf(TempBuf, "%s%s%s_%.4d", 
                TEMPNAME, 
                INTF_ADDITION, 
                dbcsFileBase, 
                NameCounter++);

	return pMidlLexTable->LexInsert( TempBuf );
	}

char *
GenCompName()
	{
	char*	pCurrentInterfaceName = pInterfaceInfoDict->GetInterfaceName();
	short	Length = (short) strlen(pCurrentInterfaceName);
	char*	pBuffer;
	char*	pTemp;
	short	CurrentTagNumber;

	pBuffer	= new char[	TEMP_NAME_LENGTH +			// __MIDL_
						Length +					// intface name
						LENGTH_OF_1_UNDERSCORE +	// _
						4 +							// temp number
						1 ];						// term. zero.

	CurrentTagNumber		= pInterfaceInfoDict->GetCurrentTagNumber();

	sprintf( pBuffer, "%s%s_%.4d", TEMPNAME, pCurrentInterfaceName, CurrentTagNumber );

	pInterfaceInfoDict->IncrementCurrentTagNumber();

	pTemp	= pMidlLexTable->LexInsert( pBuffer );
	delete pBuffer;
	return pTemp;

	}

BOOL
IsTempName(
	char *pName )
	{
	return !(strncmp( pName, TEMPNAME , TEMP_NAME_LENGTH ) );
	}

void
ApplyAttributes(
	named_node		*	pNode,
	ATTRLIST		&	attrs )
	{
	if( attrs )
		{
		pNode->SetAttributes(attrs);
		}
	}


/****************************************************************************
 This routine exists to share code for setting up the field attribute nodes
 ****************************************************************************/
ATTRLIST
GenerateFieldAttribute(
	ATTR_T					NodeType,
	expr_list			*	pExprList )
	{
	node_base_attr 	*	pAttr = 0;
	expr_node		*	pExpr = 0;
	ATTRLIST			AList;

	AList.MakeAttrList();

	/**
	 ** we delibrately dont set the bits in the summary attribute 'cause
	 ** these bits will get set in the set attribute anyways for the
	 ** field attributes
	 **/

	if(pExprList != (expr_list *)NULL)
		{
		pExprList->Init();
		while( pExprList->GetNext( (void **)&pExpr )  == STATUS_OK)
			{
			switch(NodeType)
				{
				case ATTR_FIRST:
				case ATTR_LAST:
				case ATTR_LENGTH:
				case ATTR_SIZE:
				case ATTR_MIN:
				case ATTR_MAX:
					pAttr = new size_attr( pExpr, NodeType );
					break;
				default:
					//this should never happen
					MIDL_ASSERT(FALSE && "Attribute not supported");
					break;
				}
			AList.SetPeer( pAttr );
			}
		}
	delete pExprList;
	AList.Reverse();
	return AList;
	}
/****************************************************************************
 SearchTag:
	This routine provides a means of searching the global symbol space for
	struct/union tags, and enums. These share the same name space but we want to
	keep the symbol table identity of enums, struct tags etc separate. so
	we need to search for all of these separately when verifying that a tag
	has really not been seen before.

	This routine returns:
		1. (node_skl *)NULL if NO struct/union/enum was defined by that name
		2. node_skl * if the a definition was found for what you are looking
		   for.
		3. (node_skl *) error type node if a definition was found, but it is
		   not what you are looking for.
 ****************************************************************************/
node_skl *
SearchTag(
	char	*	pName,
	NAME_T		Tag )
	{
	node_skl	*	pNode;
	NAME_T			MyTag;
	SymKey			SKey( pName, MyTag = NAME_TAG );

	/**
	 ** Has it been declared as a struct ?
	 **/

	if ( (pNode = pBaseSymTbl->SymSearch(SKey) ) == 0 )
		{

		/**
		 ** not a tag - maybe enum / union
		 **/

		SKey.SetKind( MyTag = NAME_ENUM );

		if ( (pNode = pBaseSymTbl->SymSearch(SKey) ) == 0 )
			{

			/**
			 ** not a enum maybe union
			 **/

			SKey.SetKind( MyTag = NAME_UNION );

			if ( (pNode = pBaseSymTbl->SymSearch(SKey) ) == 0 )
				return (node_skl *)NULL;
			}
		}

	/**
	 ** search was sucessful. Check whether this was what you were looking
	 ** for. If it is , it means we found a definition of the symbol. If not
	 ** then we found a definition all right, but it is of a different entity.
	 ** The routine can find this out by verifying that the typenode returned
	 ** was an error type node or not
	 **/

	return (MyTag == Tag ) ? pNode : pErrorTypeNode;
	}


/****************************************************************************
 SetPredefinedTypes:
	Set up predefined types for the midl compiler. The predefined types
	are error_status_t and wchar_t( the latter dependent on compile mode )
 ****************************************************************************/
void
SetPredefinedTypes()
	{

	char			*	pName = 0;
	node_e_status_t	*	pNew = new node_e_status_t;
	node_def_fe		*	pDef = new node_def_fe( pName = pNew->GetSymName(), pNew );

	// set global version
	pError_status_t	= pNew;

	// the typedef of error_status_t in the symbol table

	SymKey			SKey( pName, NAME_DEF);
	pBaseSymTbl->SymInsert(SKey, (SymTable *)NULL, pDef );

	//
	// we always predefine wchar_t and report the error to the user. If
	// we dont enter wchar_t in the predefined types, then we get all
	// kinds of syntax and error recovery errors which could be confusing
	// in this context. We therefore explicitly give an error on wchar_t.
	//

	node_wchar_t *	pNew2 = new node_wchar_t;

	pDef = new node_def_fe( pName = pNew2->GetSymName(), pNew2 );

	// the typedef of wchar_t in the symbol table

	SKey.SetString( pName );
	pBaseSymTbl->SymInsert(SKey, (SymTable *)NULL, pDef );

	}

//
// We check for a proc/typedef/member/param/tag/enum/label name already defined
// as an identifier. Only if the identifier is one which will be turned into
// a #define, do we report an error. However, it is not worth it to check if
// an identifier is used as a name because in any case we will not be able to
// check for clashes with field / param names since they are at a lower than
// global, symbol table scope. Generally checking if the name of a member etc
// is already defined as an id which will be turned into a #define should be
// enough.
//

void
CheckGlobalNamesClash(
	SymKey	SKeyOfSymbolBeingDefined )
	{
	NAME_T		NT		= SKeyOfSymbolBeingDefined.GetKind();
	char	*	pName	= SKeyOfSymbolBeingDefined.GetString();
	SymKey		SKey;

	SKey.SetString( pName );

	switch( NT )
		{
		case NAME_PROC:
		case NAME_MEMBER:
		case NAME_TAG:
		case NAME_DEF:
		case NAME_LABEL:
		case NAME_ENUM:

			node_id	*	pID;

			SKey.SetKind( NAME_ID );

			if ( ( pID = (node_id *) pBaseSymTbl->SymSearch( SKey ) ) != 0 )
				{
				BOOL	fWillBeAHashDefine = !pID->FInSummary( ATTR_EXTERN ) &&
											 !pID->FInSummary( ATTR_STATIC ) &&
											 pID->GetInitList();
				if( fWillBeAHashDefine )
					ParseError( NAME_ALREADY_USED, pName );
				}
			break;

		case NAME_ID:

#if 0
			SKey.SetKind( NAME_PROC );
			if( !pBaseSymTbl->SymSearch( SKey ) )
				{
				SKey.SetKind( NAME_TAG );
				if( !pBaseSymTbl->SymSearch( SKey ) )
					{
					SKey.SetKind( NAME_DEF );
					if( !pBaseSymTbl->SymSearch( SKey ) )
						{
						SKey.SetKind( NAME_LABEL );
						if( !pBaseSymTbl->SymSearch( SKey ) )
							{
							SKey.SetKind( NAME_ENUM );
							if( !pBaseSymTbl->SymSearch( SKey ) )
								break;
							}
						}
					}
				}
			ParseError( NAME_CLASH_WITH_CONST_ID, pName );
			break;
#endif // 0
		default:
			break;
		}
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\front\fldattr.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-1999 Microsoft Corporation

 Module Name:
	
	fldattr.cxx

 Abstract:

	field attribute handling routines

 Notes:


 Author:

	GregJen	Oct-27-1993	Created.

 Notes:


 ----------------------------------------------------------------------------*/

#pragma warning ( disable : 4514 )

/****************************************************************************
 *	include files
 ***************************************************************************/

#include "allnodes.hxx"
#include "fldattr.hxx"
#include "semantic.hxx"

/****************************************************************************
 *	local data
 ***************************************************************************/

expr_constant	*	pZero	= NULL;
expr_constant	*	pOne	= NULL;
node_skl		*	pInt	= NULL;

/****************************************************************************
 *	externs
 ***************************************************************************/

/****************************************************************************
 *	definitions
 ***************************************************************************/

/////////////////
// helper routines for Normalize functions; 

//Don't add or subtract 0.
expr_node	*
CreateSimpleBinaryArithExpression( 
	OPERATOR 		Op,
	expr_node	* 	pL,
	expr_node	* 	pR
	)
{
	MIDL_ASSERT( (Op==OP_PLUS) || (Op==OP_MINUS) );
	MIDL_ASSERT( pL );
	MIDL_ASSERT( pR );


	if ( pR->IsConstant() && (pR->GetValue() == 0) )
		return pL;

	if ( pL->IsConstant() && (pL->GetValue() == 0) )
		return pR;

	expr_node	*	pRet	= new expr_b_arithmetic( Op, pL, pR );

	if ( pL->GetType() )
		pRet->SetType( pL->GetType() );
	else if ( pR->GetType() )
		pRet->SetType( pR->GetType() );
	else
		MIDL_ASSERT( !"no type for expression" );

	return pRet;

}


// return the constant 0 over and over
expr_constant	*
GetConstant0()
{
	if ( pZero )	return pZero;

	pZero	= new expr_constant( 0L, VALUE_TYPE_NUMERIC );
	
	if ( !pInt )
		GetBaseTypeNode( &pInt, SIGN_SIGNED, SIZE_UNDEF, TYPE_INT );

	pZero->SetType( pInt );
	return pZero; 
}
	
// return the constant 1 over and over
expr_constant	*
GetConstant1()
{
	if ( pOne )	return pOne;

	pOne	= new expr_constant( 1L, VALUE_TYPE_NUMERIC );
	if ( !pInt )
		GetBaseTypeNode( &pInt, SIGN_SIGNED, SIZE_UNDEF, TYPE_INT );

	pOne->SetType( pInt );
	return pOne; 
}
	
BOOL
IsInValidOutOnly( SEM_ANALYSIS_CTXT * pCtxt )
{
	// an out-only size is valid only on out-only non-top-level things

	// in, in/out things not allowed
	if ( pCtxt->AnyAncestorBits( UNDER_IN_PARAM ) )
		return TRUE;

	// look up the stack for a pointer (or array) that is unique
	SEM_ANALYSIS_CTXT	*	pCurCtxt = pCtxt;
	NODE_T					Kind;
	node_skl			*	pNode;
	while ( pCurCtxt )
		{
		pNode	= pCurCtxt->GetParent();
		Kind	= pNode->NodeKind();

		switch ( Kind )
			{
			case NODE_DEF:
			case NODE_ARRAY:
				break;
			case NODE_POINTER:
				if ( pCtxt->AnyAncestorBits( IN_NON_REF_PTR ) )
					return FALSE;
				break;
			case NODE_PARAM:
			case NODE_PROC:
			default:
				return TRUE;
			}
		pCurCtxt = ( SEM_ANALYSIS_CTXT	* ) pCurCtxt->GetParentContext();
		}
	return TRUE;
}

BOOL Xxx_Is_Type_OK( node_skl * pType)
{
	if ( !pType )
		return FALSE;

	for (;;)
		{
		switch ( pType->NodeKind() )
			{
			case NODE_PARAM:
			case NODE_FIELD:
				if ( !pType->GetChild() )
					return FALSE;

				break;

			// make sure that there is no transmit_as or represent_as
			case NODE_DEF:
				if ( pType->FInSummary( ATTR_TRANSMIT ) ||
				     pType->FInSummary( ATTR_REPRESENT_AS ) ||
				     pType->FInSummary( ATTR_USER_MARSHAL ) ||
				     pType->FInSummary( ATTR_WIRE_MARSHAL ) )
					return FALSE;

				break;
			
			// for an ID, make sure it is a const decl, then use its type
			case NODE_ID:
				{
				node_id		*	pID	= (node_id *) pType;
				if ( !pID->pInit )
					return FALSE;

				break;
				}
			case NODE_ENUM:
			case NODE_LONG:
			case NODE_SHORT:
			case NODE_INT:
			case NODE_INT32:
			case NODE_SMALL:
			case NODE_CHAR:
			case NODE_BOOLEAN:
			case NODE_BYTE:
                return TRUE;

            // 64b expr support
			case NODE_INT3264:
			case NODE_INT64:
			case NODE_HYPER:
				return FALSE;

            // no 128b expr support
            case NODE_INT128:
            case NODE_FLOAT80:
            case NODE_FLOAT128:
                return FALSE;

			default:
				return FALSE;
			}
		pType = pType->GetChild();
		}
}


BOOL IID_Is_Type_OK( node_skl * pType )
{
	if ( !pType )
		return FALSE;

    for (;;)
        {
		switch ( pType->NodeKind() )
			{
			case NODE_PARAM:
			case NODE_FIELD:
				if ( !pType->GetChild() )
					return FALSE;

				break;

			case NODE_DEF:
				if ( pType->FInSummary( ATTR_TRANSMIT ) ||
				     pType->FInSummary( ATTR_REPRESENT_AS ) ||
				     pType->FInSummary( ATTR_USER_MARSHAL ) ||
				     pType->FInSummary( ATTR_WIRE_MARSHAL )  )
					return FALSE;

				break;
			
			case NODE_POINTER:
				if ( pType->GetChild() )
					return ( 16 == pType->GetChild()->GetSize() );
				
			default:
				return FALSE;
			}
		pType = pType->GetChild();
		}
}

// validate the bunch of attributes for pointers: check combinations, ranges, 
// and expressions

void			
FIELD_ATTR_INFO::Validate( SEM_ANALYSIS_CTXT * pCtxt )
{
	if ( Kind == FA_NONE )
		return;

	node_skl	*		pParent		= pCtxt->GetParent();

// things to check:
// expression types (must be integral types)
	
	if ( pMaxIsExpr )
		{
		EXPR_CTXT		MaxCtxt( pCtxt );

		pMaxIsExpr->ExprAnalyze( &MaxCtxt );

		if ( MaxCtxt.AnyUpFlags( EX_UNSAT_FWD ) )
			SemError( pParent, *pCtxt, ATTRIBUTE_ID_UNRESOLVED, NULL );

		if ( MaxCtxt.AnyUpFlags( EX_OUT_ONLY_PARAM ) && IsInValidOutOnly( pCtxt ) )
			RpcSemError( pParent, *pCtxt, SIZE_SPECIFIER_CANT_BE_OUT, NULL );

		if ( !MaxCtxt.AnyUpFlags( EX_VALUE_INVALID ) )
			SemError( pParent, *pCtxt, ATTRIBUTE_ID_MUST_BE_VAR, NULL );

		if ( !Xxx_Is_Type_OK( pMaxIsExpr->GetType() ) &&
			 pCtxt->AnyAncestorBits( IN_RPC ) )
			RpcSemError( pParent, *pCtxt, ATTR_MUST_BE_INT, NULL );

		}

	if ( pMinIsExpr )
		{
		EXPR_CTXT		MinCtxt( pCtxt );

		pMinIsExpr->ExprAnalyze( &MinCtxt );

		if ( MinCtxt.AnyUpFlags( EX_UNSAT_FWD ) )
			RpcSemError( pParent, *pCtxt, ATTRIBUTE_ID_UNRESOLVED, NULL );

		if ( MinCtxt.AnyUpFlags( EX_OUT_ONLY_PARAM ) && IsInValidOutOnly( pCtxt ) )
			SemError( pParent, *pCtxt, SIZE_SPECIFIER_CANT_BE_OUT, NULL );

		if ( !MinCtxt.AnyUpFlags( EX_VALUE_INVALID ) )
			SemError( pParent, *pCtxt, ATTRIBUTE_ID_MUST_BE_VAR, NULL );

		if ( !Xxx_Is_Type_OK( pMinIsExpr->GetType() ) &&
			 pCtxt->AnyAncestorBits( IN_RPC ) )
			SemError( pParent, *pCtxt, ATTR_MUST_BE_INT, NULL );

		}

	if ( pSizeIsExpr )
		{
		EXPR_CTXT		SizeCtxt( pCtxt );

		pSizeIsExpr->ExprAnalyze( &SizeCtxt );

		if ( SizeCtxt.AnyUpFlags( EX_UNSAT_FWD ) )
			SemError( pParent, *pCtxt, ATTRIBUTE_ID_UNRESOLVED, NULL );

		if ( SizeCtxt.AnyUpFlags( EX_OUT_ONLY_PARAM ) && IsInValidOutOnly( pCtxt ) )
			SemError( pParent, *pCtxt, SIZE_SPECIFIER_CANT_BE_OUT, NULL );

		if ( !SizeCtxt.AnyUpFlags( EX_VALUE_INVALID ) )
			SemError( pParent, *pCtxt, ATTRIBUTE_ID_MUST_BE_VAR, NULL );

		if ( !Xxx_Is_Type_OK( pSizeIsExpr->GetType() )  &&
			 pCtxt->AnyAncestorBits( IN_RPC ) )
			SemError( pParent, *pCtxt, ATTR_MUST_BE_INT, NULL );

		}

	if ( pFirstIsExpr )
		{
		EXPR_CTXT		FirstCtxt( pCtxt );

		pFirstIsExpr->ExprAnalyze( &FirstCtxt );

		if ( FirstCtxt.AnyUpFlags( EX_UNSAT_FWD ) )
			SemError( pParent, *pCtxt, ATTRIBUTE_ID_UNRESOLVED, NULL );

		if ( !FirstCtxt.AnyUpFlags( EX_VALUE_INVALID ) )
			SemError( pParent, *pCtxt, ATTRIBUTE_ID_MUST_BE_VAR, NULL );

		if ( !Xxx_Is_Type_OK( pFirstIsExpr->GetType() )  &&
			 pCtxt->AnyAncestorBits( IN_RPC ) )
			SemError( pParent, *pCtxt, ATTR_MUST_BE_INT, NULL );

		}

	if ( pLastIsExpr )
		{
		EXPR_CTXT		LastCtxt( pCtxt );

		pLastIsExpr->ExprAnalyze( &LastCtxt );

		if ( LastCtxt.AnyUpFlags( EX_UNSAT_FWD ) )
			SemError( pParent, *pCtxt, ATTRIBUTE_ID_UNRESOLVED, NULL );

		if ( !LastCtxt.AnyUpFlags( EX_VALUE_INVALID ) )
			SemError( pParent, *pCtxt, ATTRIBUTE_ID_MUST_BE_VAR, NULL );

		if ( !Xxx_Is_Type_OK( pLastIsExpr->GetType() )  &&
			 pCtxt->AnyAncestorBits( IN_RPC ) )
			SemError( pParent, *pCtxt, ATTR_MUST_BE_INT, NULL );

		}

	if ( pLengthIsExpr )
		{
		EXPR_CTXT		LengthCtxt( pCtxt );

		pLengthIsExpr->ExprAnalyze( &LengthCtxt );

		if ( LengthCtxt.AnyUpFlags( EX_UNSAT_FWD ) )
			SemError( pParent, *pCtxt, ATTRIBUTE_ID_UNRESOLVED, NULL );

		if ( !LengthCtxt.AnyUpFlags( EX_VALUE_INVALID ) )
			SemError( pParent, *pCtxt, ATTRIBUTE_ID_MUST_BE_VAR, NULL );

		if ( !Xxx_Is_Type_OK( pLengthIsExpr->GetType() )  &&
			 pCtxt->AnyAncestorBits( IN_RPC ) )
			SemError( pParent, *pCtxt, ATTR_MUST_BE_INT, NULL );

		}

	if ( pIIDIsExpr )
		{
		EXPR_CTXT		IIDCtxt( pCtxt );

		pIIDIsExpr->ExprAnalyze( &IIDCtxt );

		if ( IIDCtxt.AnyUpFlags( EX_UNSAT_FWD ) )
			SemError( pParent, *pCtxt, ATTRIBUTE_ID_UNRESOLVED, NULL );

		if ( !IIDCtxt.AnyUpFlags( EX_VALUE_INVALID ) )
			SemError( pParent, *pCtxt, ATTRIBUTE_ID_MUST_BE_VAR, NULL );

		if ( !IID_Is_Type_OK( pIIDIsExpr->GetType() )  &&
			 pCtxt->AnyAncestorBits( IN_RPC ) )
			SemError( pParent, *pCtxt, IID_IS_EXPR_NON_POINTER, NULL );

		}

// min_is == 0 ( for now )
// constant min_is <= constant max_is
// size_is not with max_is
	if ( pMaxIsExpr && pSizeIsExpr )
		SemError( pParent, *pCtxt, MAX_AND_SIZE, NULL );

// min_is not alone

// constant first_is <= constant last_is + 1
// length_is not with last_is
	if ( pLengthIsExpr && pLastIsExpr )
		SemError( pParent, *pCtxt, LAST_AND_LENGTH, NULL );

// constant first_is, last_is both within min<->max range
// length_is <= size_is 
// string attrs not with varying attrs
// string and bstring not together

// conformant strings may leave out size_is if [in] or [in,out]

// accept the NULL value ( turn expression back null, clear kind bits )
// make sure variables come from the correct context

// lengthed, unsized pointer

	if ( ( pLengthIsExpr || pFirstIsExpr || pLastIsExpr || pMinIsExpr) &&
		!( pSizeIsExpr || pMaxIsExpr ) )
		SemError( pParent, *pCtxt, UNSIZED_ARRAY, NULL );
}

void			
FIELD_ATTR_INFO::Validate( SEM_ANALYSIS_CTXT * pCtxt, 
							  expr_node * pLower, 
							  expr_node * pUpper )
{
	node_skl	*		pParent		= pCtxt->GetParent();

    if ( pUpper	== (expr_node *) -1 )
		{
		pUpper	=	NULL;
		Kind	|=	FA_CONFORMANT;
		}
	else if ( pUpper )
		{
		if ( pUpper->GetValue() <= 0 )
			{
			SemError( pParent, *pCtxt, ILLEGAL_ARRAY_BOUNDS, NULL );
			}
		}
		
	if (   pLower && 
		 ( pLower != (expr_node *) -1 ) &&
		 ( pLower->GetValue() != 0 ) )
		{
		SemError( pParent, *pCtxt, ARRAY_BOUNDS_CONSTRUCT_BAD, NULL );
		}

	if ( pUpper && ( pMaxIsExpr || pSizeIsExpr ) )
		{
		SemError( pParent, *pCtxt, SIZING_ON_FIXED_ARRAYS, NULL );
		}

// things to check:
// expression types (must be integral types)
	
	if ( pMaxIsExpr )
		{
		EXPR_CTXT		MaxCtxt( pCtxt );

		pMaxIsExpr->ExprAnalyze( &MaxCtxt );

		if ( MaxCtxt.AnyUpFlags( EX_UNSAT_FWD ) )
			SemError( pParent, *pCtxt, ATTRIBUTE_ID_UNRESOLVED, NULL );

		if ( MaxCtxt.AnyUpFlags( EX_OUT_ONLY_PARAM ) )
			SemError( pParent, *pCtxt, SIZE_SPECIFIER_CANT_BE_OUT, NULL );

		if ( !MaxCtxt.AnyUpFlags( EX_VALUE_INVALID ) )
			SemError( pParent, *pCtxt, ATTRIBUTE_ID_MUST_BE_VAR, NULL );

		if ( !Xxx_Is_Type_OK( pMaxIsExpr->GetType() )  &&
			 pCtxt->AnyAncestorBits( IN_RPC ) )
			SemError( pParent, *pCtxt, ATTR_MUST_BE_INT, NULL );

		}

	if ( pMinIsExpr )
		{
		EXPR_CTXT		MinCtxt( pCtxt );

		pMinIsExpr->ExprAnalyze( &MinCtxt );

		if ( MinCtxt.AnyUpFlags( EX_UNSAT_FWD ) )
			SemError( pParent, *pCtxt, ATTRIBUTE_ID_UNRESOLVED, NULL );

		if ( MinCtxt.AnyUpFlags( EX_OUT_ONLY_PARAM ) )
			SemError( pParent, *pCtxt, SIZE_SPECIFIER_CANT_BE_OUT, NULL );

		if ( !MinCtxt.AnyUpFlags( EX_VALUE_INVALID ) )
			SemError( pParent, *pCtxt, ATTRIBUTE_ID_MUST_BE_VAR, NULL );

		if ( !Xxx_Is_Type_OK( pMinIsExpr->GetType() )  &&
			 pCtxt->AnyAncestorBits( IN_RPC ) )
			SemError( pParent, *pCtxt, ATTR_MUST_BE_INT, NULL );

		}

	if ( pSizeIsExpr )
		{
		EXPR_CTXT		SizeCtxt( pCtxt );

		pSizeIsExpr->ExprAnalyze( &SizeCtxt );

		if ( SizeCtxt.AnyUpFlags( EX_UNSAT_FWD ) )
			SemError( pParent, *pCtxt, ATTRIBUTE_ID_UNRESOLVED, NULL );

		if ( SizeCtxt.AnyUpFlags( EX_OUT_ONLY_PARAM ) )
			SemError( pParent, *pCtxt, SIZE_SPECIFIER_CANT_BE_OUT, NULL );

		if ( !SizeCtxt.AnyUpFlags( EX_VALUE_INVALID ) )
			SemError( pParent, *pCtxt, ATTRIBUTE_ID_MUST_BE_VAR, NULL );

		if ( !Xxx_Is_Type_OK( pSizeIsExpr->GetType() )  &&
			 pCtxt->AnyAncestorBits( IN_RPC ) )
			SemError( pParent, *pCtxt, ATTR_MUST_BE_INT, NULL );

		}


	if ( pFirstIsExpr )
		{
		EXPR_CTXT		FirstCtxt( pCtxt );

		pFirstIsExpr->ExprAnalyze( &FirstCtxt );

		if ( FirstCtxt.AnyUpFlags( EX_UNSAT_FWD ) )
			SemError( pParent, *pCtxt, ATTRIBUTE_ID_UNRESOLVED, NULL );

		if ( !FirstCtxt.AnyUpFlags( EX_VALUE_INVALID ) )
			SemError( pParent, *pCtxt, ATTRIBUTE_ID_MUST_BE_VAR, NULL );

		if ( !Xxx_Is_Type_OK( pFirstIsExpr->GetType() )  &&
			 pCtxt->AnyAncestorBits( IN_RPC ) )
			SemError( pParent, *pCtxt, ATTR_MUST_BE_INT, NULL );

		}

	if ( pLastIsExpr )
		{
		EXPR_CTXT		LastCtxt( pCtxt );

		pLastIsExpr->ExprAnalyze( &LastCtxt );

		if ( LastCtxt.AnyUpFlags( EX_UNSAT_FWD ) )
			SemError( pParent, *pCtxt, ATTRIBUTE_ID_UNRESOLVED, NULL );

		if ( !LastCtxt.AnyUpFlags( EX_VALUE_INVALID ) )
			SemError( pParent, *pCtxt, ATTRIBUTE_ID_MUST_BE_VAR, NULL );

		if ( !Xxx_Is_Type_OK( pLastIsExpr->GetType() )  &&
			 pCtxt->AnyAncestorBits( IN_RPC ) )
			SemError( pParent, *pCtxt, ATTR_MUST_BE_INT, NULL );

		}

	if ( pLengthIsExpr )
		{
		EXPR_CTXT		LengthCtxt( pCtxt );

		pLengthIsExpr->ExprAnalyze( &LengthCtxt );

		if ( LengthCtxt.AnyUpFlags( EX_UNSAT_FWD ) )
			SemError( pParent, *pCtxt, ATTRIBUTE_ID_UNRESOLVED, NULL );

		if ( !LengthCtxt.AnyUpFlags( EX_VALUE_INVALID ) )
			SemError( pParent, *pCtxt, ATTRIBUTE_ID_MUST_BE_VAR, NULL );

		if ( !Xxx_Is_Type_OK( pLengthIsExpr->GetType() )  &&
			 pCtxt->AnyAncestorBits( IN_RPC ) )
			SemError( pParent, *pCtxt, ATTR_MUST_BE_INT, NULL );

		}


	if ( pIIDIsExpr )
		{
		SemError( pParent, *pCtxt, IID_IS_NON_POINTER, NULL );
		}

// min_is == 0 ( for now )
// constant min_is <= constant max_is
// size_is not with max_is
	if ( pMaxIsExpr && pSizeIsExpr )
		SemError( pParent, *pCtxt, MAX_AND_SIZE, NULL );

	// a conformant unsized array:
	//		must have string
	//		must not be out_only
	if ( ( Kind & FA_CONFORMANT ) && !pMaxIsExpr && !pSizeIsExpr && !pUpper )
		{
		if ( !( Kind & FA_STRING ) )
			{
			if ( pCtxt->AnyAncestorBits( IN_RPC ) )
				SemError( pParent, *pCtxt, UNSIZED_ARRAY, NULL );
			}
		else
			{
			if ( pCtxt->AllAncestorBits( IN_RPC |
										 IN_PARAM_LIST |
										 UNDER_OUT_PARAM ) &&
				 !pCtxt->AnyAncestorBits( UNDER_IN_PARAM ) )
				SemError( pParent, *pCtxt, DERIVES_FROM_UNSIZED_STRING, NULL );
			}
		}
		

// min_is not alone

// constant first_is <= constant last_is + 1
// length_is not with last_is
	if ( pLengthIsExpr && pLastIsExpr )
		SemError( pParent, *pCtxt, LAST_AND_LENGTH, NULL );

// constant first_is, last_is both within min<->max range
// length_is <= size_is 
// string attrs not with varying attrs
// string and bstring not together

// conformant strings may leave out size_is if [in] or [in,out]

// accept the NULL value ( turn expression back null, clear kind bits )
// make sure variables come from the correct context

}


//
// normalize for pointers ( no default bound )
void
FIELD_ATTR_INFO::Normalize()
{
	expr_node	*	pTmp1;
	expr_node	*	pTmp2;

	// convert the set: min_is, max_is, size_is to 			min_is + size_is

	if ( Kind & FA_CONFORMANT )
		{
		// default min_is is 0
		if ( ! pMinIsExpr )
			{
			pMinIsExpr		=	GetConstant0();
			}

		// size_is = (max_is - min_is) + 1;
		if ( ! pSizeIsExpr )
			{
			if ( pMaxIsExpr )
				{
				pTmp1		=	GetConstant1();
				pTmp2		=	CreateSimpleBinaryArithExpression( OP_MINUS, pMaxIsExpr, pMinIsExpr);
				pSizeIsExpr	=	CreateSimpleBinaryArithExpression( OP_PLUS, pTmp2, pTmp1 );
				}
			}
		}


	// convert the set: first_is, last_is, length_is to:	first_is + length_is
	if ( Kind & FA_VARYING )
		{
		// default first_is is 0
		if ( ! pFirstIsExpr )
			{
			pFirstIsExpr	=	GetConstant0();
			}

		// default last_is is max_is or size_is+1
		if ( ! pLastIsExpr )
			{
			if ( pMaxIsExpr )
				pLastIsExpr	= pMaxIsExpr;
			else if ( pSizeIsExpr )
				pLastIsExpr = CreateSimpleBinaryArithExpression( OP_MINUS, pSizeIsExpr, GetConstant1() ); 
			}

		// length_is = (last_is - first_is) + 1;
		if ( ! pLengthIsExpr )
			{
			if ( pLastIsExpr )
				{
				pTmp1			=	GetConstant1();
				pTmp2			=	CreateSimpleBinaryArithExpression( OP_MINUS, pLastIsExpr, pFirstIsExpr);
				pLengthIsExpr	=	CreateSimpleBinaryArithExpression( OP_PLUS, pTmp2, pTmp1 );
				}
			}
		}

}

// normalize for arrays (provided lower and upper bound)
void
FIELD_ATTR_INFO::Normalize(expr_node * pLower, expr_node * pUpper)
{
	expr_node	*	pTmp1;
	expr_node	*	pTmp2;
	BOOL			OneBound = FALSE;

	if ( pLower == (expr_node *) 0 )
		{
		pLower	=	GetConstant0();
		OneBound	= TRUE;
		}

	if ( pUpper	== (expr_node *) -1 )
		{
		pUpper	=	NULL;
		Kind	|=	FA_CONFORMANT;
		}

	// convert the set: min_is, max_is, size_is to:	min_is + size_is

	// first, copy from the bounds
	if ( ! pMinIsExpr )
		{
		pMinIsExpr		=	pLower;
		}

	if ( ! pMaxIsExpr && ! pSizeIsExpr && pUpper )
		{
            // note that the [n..m] case has m already incremented by 1
			pTmp1		= GetConstant1();
			pMaxIsExpr	= CreateSimpleBinaryArithExpression( OP_MINUS, pUpper, pTmp1 );
		}

	// size_is = (max_is - min_is) + 1;
	if ( ! pSizeIsExpr )
		{
		if ( pMaxIsExpr )
			{
			pTmp1		= GetConstant1();
			pTmp2		= CreateSimpleBinaryArithExpression( OP_MINUS, pMaxIsExpr, pMinIsExpr);
			pSizeIsExpr	= CreateSimpleBinaryArithExpression( OP_PLUS, pTmp2, pTmp1 );
			}
		}


	// convert the set: first_is, last_is, length_is to:	first_is + length_is

	// default first_is is min_is
	if ( ! pFirstIsExpr )
		{
		pFirstIsExpr	= pMinIsExpr;
		}

	// default last_is is max_is or size_is+1
	if ( ! pLastIsExpr )
		{
		if ( pMaxIsExpr )
			pLastIsExpr	= pMaxIsExpr;
		else if ( pSizeIsExpr )
			pLastIsExpr = CreateSimpleBinaryArithExpression( OP_MINUS, pSizeIsExpr, GetConstant1() ); 
		}

	// length_is = (last_is - first_is) + 1;
	if ( ! pLengthIsExpr )
		{
		if ( pLastIsExpr )
			{
			pTmp1			= GetConstant1();
			pTmp2			= CreateSimpleBinaryArithExpression( OP_MINUS, pLastIsExpr, pFirstIsExpr);
			pLengthIsExpr	= CreateSimpleBinaryArithExpression( OP_PLUS, pTmp2, pTmp1 );
			}
		}
		
}


bool
FIELD_ATTR_INFO::VerifyOnlySimpleExpression()
{
    const int nExprTypes = 7;

    expr_node *pExpr[nExprTypes] = 
                    {
                    pSizeIsExpr,
                    pMinIsExpr,
                    pMaxIsExpr,
                    pLengthIsExpr,
                    pFirstIsExpr,
                    pIIDIsExpr,
                    pLastIsExpr,
                    };

    for ( int i = 0; i < nExprTypes; i++ )
    {
        // No expression is ok
        if ( NULL == pExpr[i] )
            continue;

        // A simple variable is ok
        if ( pExpr[i]->IsAVariable() )
            continue;

        // A pointer to a simple variable is ok
        if ( OP_UNARY_INDIRECTION == pExpr[i]->GetOperator() 
             && pExpr[i]->GetLeft()->IsAVariable() )
            {
            continue;
            }   

        // Everything else is not ok
        return false;
    }

    return true;
}


BOOL
FIELD_ATTR_INFO::SetExpressionVariableUsage( SIZE_LENGTH_USAGE )
{
    return TRUE;
}

#if 0

BUGBUG: CG_INTERFACE_POINTER has a bug.  See nodeskl.h for details

BOOL 
FIELD_ATTR_INFO::SetExpressionVariableUsage( SIZE_LENGTH_USAGE usage )
{
    const int nExprTypes = 7;

    expr_node *pExpr[nExprTypes] =
                    {
                    pSizeIsExpr,
                    pMinIsExpr,
                    pMaxIsExpr,
                    pLengthIsExpr,
                    pFirstIsExpr,
                    pIIDIsExpr,
                    pLastIsExpr,
                    };

    for ( int i = 0; i < nExprTypes; i++ )
        if ( ! SetExpressionVariableUsage( pExpr[i], usage ) )
            return false;

    return true;
}

BOOL
FIELD_ATTR_INFO::SetExpressionVariableUsage(
        expr_node          *pExpr,
        SIZE_LENGTH_USAGE   usage )
{
    if ( !pExpr )
        return true;

    if ( pExpr->IsAVariable() )
        {
        node_skl *pParent = NULL;
        node_skl *pType = pExpr->GetType();

        while ( NULL != pType && !pType->IsBasicType() )
            {
            pParent = pType;
            pType = pType->GetChild();
            }

        if ( NULL != pType && pType->IsBasicType() )
            {
            SIZE_LENGTH_USAGE TypeUsage = ((node_base_type *) pType)
                                                   ->GetSizeLengthUsage();
            if ( CSSizeLengthUsage == usage  
                 && NoSizeLengthUsage != TypeUsage )
                {
                return FALSE;
                }
            
            if ( CSSizeLengthUsage == TypeUsage  
                 && NoSizeLengthUsage != usage )
                {
                return FALSE;
                }

            if ( NoSizeLengthUsage != usage )
                {
                // Typically base type nodes are preallocated and identical.
                // Pointing at them with size_is, etc makes the different
                // because we need to note that fact.  So clone it to get
                // a new one.

                MIDL_ASSERT( NULL != pParent );
                pType = new node_base_type( (node_base_type *) pType );   
                ((node_base_type *) pType)->SetSizeLengthUsage( usage );
                pParent->SetChild( pType );
                }
            }
        }

    if ( ! SetExpressionVariableUsage( pExpr->GetLeft(), usage ) )
        return false;

    return SetExpressionVariableUsage( pExpr->GetRight(), usage );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\front\lex.cxx ===
/********************************** module *********************************/
/*              Copyright (c) 1993-2000 Microsoft Corporation              */
/*                                                                         */
/*                                  cclex                                  */
/*                  lexical analyser for the C compiler                    */
/*                                                                         */
/***************************************************************************/
/*                                                                         */
/*    @ Purpose:                                                           */
/*                                                                         */
/*    @ Functions included:                                                */
/*                                                                         */
/*                                                                         */
/*    @ Author: Gerd Immeyer              @ Version:                       */
/*                                                                         */
/*    @ Creation Date: 1987.02.09         @ Modification Date:             */
/*                                                                         */
/***************************************************************************/


#pragma warning ( disable : 4514 4310 4710 )

#include "nulldefs.h"
extern "C" {
    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>
    #include <ctype.h>
}

#include "common.hxx"
#include "errors.hxx"
#include "midlnode.hxx"
#include "listhndl.hxx"
#include "filehndl.hxx"
#include "lextable.hxx"
#include "lexutils.hxx"
#include "grammar.h"
#include "gramutil.hxx"
#include "cmdana.hxx"
#include "mbcs.hxx"

extern "C" {
    #include "lex.h"
}

extern void ParseError( STATUS_T, char *);
extern  NFA_INFO *pImportCntrl;

extern  lextype_t   yylval;

extern token_t  toktyp_G;           /* token type */
extern short    toklen_G;           /* len of token string */
extern char     *tokptr_G;          /* pointer to token string */
extern long     tokval_G;           /* value of constant token */
extern short    curr_line_G;


extern LexTable *pMidlLexTable;
extern short    CompileMode;
extern CMD_ARG * pCommand;

int chCached = 0;

char NewCCputbackc( char ch )
    {
    if (chCached)
    {
        pImportCntrl->UnGetChar(short(chCached));
    }
    chCached = ch;

    if ( ch == '\n' )
        curr_line_G--;
    return ch;
    }


/*****              definition of state table fields            ****/

#define ERR 0x7f0c          /* character not in character set */

#define X10 0x0100
#define X11 0x0101
#define X20 0x0200
#define X21 0x0201
#define X23 0x0203
#define X30 0x0300
#define X40 0x0400
#define X41 0x0401
#define X43 0x0403
#define X50 0x0500
#define X51 0x0501
#define X53 0x0503
#define X62 0x0602
#define X70 0x0700
#define X71 0x0701
#define X73 0x0703
#define X82 0x0802
#define X90 0x0900
#define X91 0x0901

#define XLQ 0x0a00
#define XLD 0x0b00

/*----              define of single operators          ----*/

#define O65     0x410d                      /* ' 65 */
#define O43     ('(' * 256 + 12)            /* ( 43 */
#define O44     (')' * 256 + 12)            /* ) 44 */
#define O49     (',' *256 + 12)             /* , 49 */
#define O24     ('.' *256 + 10)             /* . 24 */
#define O14     (':'  *256 + 12)            /* : 14 */
#define O50     (';'  *256 + 12)            /* ; 50 */
#define O13     ('?'  *256 + 12)            /* ? 13 */
#define O47     ('['  *256 + 12)            /* [ 47 */
#define O48     (']'  *256 + 12)            /* ] 48 */
#define O45     ('{'  *256 + 12)            /* { 45 */
#define O46     ('}'  *256 + 12)            /* } 46 */
#define O23     ('~'  *256 + 12)            /* ~ 23 */
#define OHS     ('#'  *256 + 12)            /* #    */
#define O64     0x400e                      /* " 64 */
#define O7d     0x0000                      /*  eol */
#define O7e     (short)0x9f0c               /*  eof */

/*----         define of possible multi character operator      ----*/

#define D00 0x000b      /* - 00 */
#define D01 0x010c      /* / 01 */
#define D02 0x020c      /* < 02 */
#define D03 0x030c      /* > 03 */
#define D04 0x040c      /* ! 04 */
#define D05 0x050c      /* % 05 */
#define D06 0x060c      /* & 06 */
#define D07 0x070c      /* * 07 */
#define D08 0x080b      /* + 08 */
#define D09 0x090c      /* = 09 */
#define D0a 0x0a0c      /* ^ 0a */
#define D0b 0x0b0c      /* | 0b */


/*****             character table              *****/
/*  MIDL supports the ANSI character set as input   */

const extern short ct[256]= {

/*     0   1   2   3   4   5   6   7   8   9   a   b   c   d   e   f    */
     O7e,ERR,ERR,ERR,ERR,  0,ERR,ERR,ERR,  0,O7d,ERR,  0,  0,ERR,ERR,
/*    10  11  12  13  14  15  16  17  18  19  1a  1b  1c  1d  1e  1f    */
     ERR,ERR,ERR,ERR,ERR,ERR,ERR,ERR,ERR,ERR,O7e,ERR,ERR,ERR,ERR,ERR,
/*         !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /    */
       0,D04,O64,OHS,ERR,D05,D06,O65,O43,O44,D07,D08,O49,D00,O24,D01,
/*     0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?    */
       7,  8,  8,  8,  8,  8,  8,  8,  9,  9,O14,O50,D02,D09,D03,O13,
/*     @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O    */ 
     ERR,  1,  1,  1,  1,  2,  3,  4,  4,  4,  4,  4, 15,  4,  4,  4,
/*     P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _    */ 
       4,  4,  4,  4,  4,  4,  4,  4,  6,  4,  4,O47,ERR,O48,D0a,  4,
/*     `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o    */ 
     ERR,  1,  1,  1,  1,  2,  3,  4,  4,  4,  4,  4,  5,  4,  4,  4,
/*     p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~ DEL    */ 
       4,  4,  4,  4,  4,  4,  4,  4,  6,  4,  4,O45,D0b,O46,O23,ERR,
/*    80  81  82  83  84  85  86  87  88  89  8a  8b  8c  8d  8e  8f    */
       4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,
/*    90  91  92  93  94  95  96  97  98  99  9a  9b  9c  9d  9e  9f    */
       4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,
/*    a0  a1  a2  a3  a4  a5  a6  a7  a8  a9  aa  ab  ac  ad  ae  af    */
       4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,
/*    b0  b1  b2  b3  b4  b5  b6  b7  b8  b9  ba  bb  bc  bd  be  bf    */
       4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,
/*    c0  c1  c2  c3  c4  c5  c6  c7  c8  c9  ca  cb  cc  cd  ce  cf    */
       4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,
/*    d0  d1  d2  d3  d4  d5  d6  d7  d8  d9  da  db  dc  dd  de  df    */
       4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,
/*    e0  e1  e2  e3  e4  e5  e6  e7  e8  e9  ea  eb  ec  ed  ee  ef    */
       4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,
/*    f0  f1  f2  f3  f4  f5  f6  f7  f8  f9  fa  fb  fc  fd  fe  ff    */
       4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4};


/*****              state transition table          *****/

const extern short st[ 13 ][ 16 ] = {

//               0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15 
//             spc a-d   e   f g-z   l   x   0 1-7 8-9   . + -  op   '  "    L
//                                                                    
/* start 0 */    0,  1,  1,  1,  1,  1,  1,  2,  5,  5,X90,X90,X90,X90,X90, 12,
/* name  1 */  X10,  1,  1,  1,  1,  1,  1,  1,  1,  1,X11,X11,X11,X11,X11,  1,
/* 0     2 */  X20,X23,  9,X23,X23,X30,  3,  6,  6,  6,X23,X21,X21,X21,X21,X30,
/* 0x    3 */  X53,  4,  4,  4,X53,X53,X53,  4,  4,  4,X53,X53,X53,X53,X53,X53,
/* hex   4 */  X50,  4,  4,  4,X53,X53,X53,  4,  4,  4,X53,X51,X51,X51,X51,X53,
/* int   5 */  X20,X23,  9,X23,X23,X23,X23,  5,  5,  5,X21,X21,X21,X21,X21,X23,
/* oct   6 */  X70,X73,  9,X73,X73,X73,X73,  6,  6,  5,  8,X71,X71,X71,X71,X73,
/* .     7 */  X91,X91,X91,X91,X91,X91,X91,X91,X91,X91,X91,X91,X91,X91,X91,X91,
/* int.  8 */  X40,X43,  9,X43,X43,X43,X43,  8,  8,  8,X43,X41,X41,X41,X41,X43,
/* .e    9 */  X40,X43,X43,X43,X43,X43,X43, 11, 11, 11,X43, 10,X41,X41,X41,X43,
/* .e-   10*/  X43,X43,X43,X43,X43,X43,X43, 11, 11, 11,X43,X43,X43,X43,X43,X43,
/* .e-i  11*/  X40,X43,X43,X43,X43,X43,X43, 11, 11, 11,X43,X41,X41,X41,X41,X43,
/* L     12*/  X10,  1,  1,  1,  1,  1,  1,  1,  1,  1,X11,X11,X11,XLQ,XLD,  1

};


/*****             multi character operator table           *****/

const token_t moptab[]     = {

/*             0   1   2   3   4   5   6   7   8   9  10  11      */
/*             -   /   <   >   !   %   &   *   +   =   ^   |      */
/*                                                                */
/*  single */ MINUS,DIV,LT,GT,EXCLAIM, MOD,
                                AND,  MULT, PLUS, ASSIGN, XOR, OR,
/*  op =   */ SUBASSIGN, DIVASSIGN, LTEQ, GTEQ, NOTEQ, 
              MODASSIGN, ANDASSIGN, MULASSIGN, ADDASSIGN, EQUALS, 
              XORASSIGN, ORASSIGN,
/*  op op  */ DECOP, GARBAGETOKEN, LSHIFT, RSHIFT, 0, 0,
                                ANDAND, 0, INCOP, EQUALS, 0, OROR   };

/*****          define of the action routines           *****/

token_t name(void);
token_t mulop(void);
token_t character(void);
token_t string(void);
token_t ProcessHash();
token_t ProcessComplexDefine( char *, char *, int );
token_t LChar();
token_t LStr();

extern token_t ScanGuid( void );
extern token_t ScanVersion( void );
extern token_t ScanImplicitImports(void);

typedef token_t (*TOKEN_PFN)(void);

const static TOKEN_PFN action[] = {
    0,              /* unused */
    name,               /* handle name token */
    cnv_int,            /* convert integer token */
    cnv_int,            /* convert integer token */
    cnv_hex,                /* convert hex constant */
    cnv_hex,                /* convert hex constant */
    cnv_octal,          /* convert octal constant */
    cnv_octal,          /* convert octal constant */
    cnv_float,          /* convert floating point constant */
    mulop,          /* handle multi character operator */
    LChar,          /* wide character */
    LStr,           /* wide character string */
    };

/*****          declare of global varables          *****/

static short ci;            /* current state character index */
static char ch;         /* current character */
static int pbch;        /* flag describing whether to take the next char
                            or not */
char LastLexChar;

unsigned short LexContext   = LEX_NORMAL;

#define MAX_LINE_SIZE 256
static char tok_buffer[MAX_LINE_SIZE];

token_t IsValidPragma( char *);


/*............................. internal function ..........................*/
/*                                      */ 
/*              comment analyzer                */ 
/*                                      */ 

token_t comment()
{
    BOOL    fParseError = FALSE;

    for (;;)
        {
        ch = NewCCGetch();
        if (ch == 0)
            {
            fParseError = TRUE;
            break;
            }
        if (CurrentCharSet.IsMbcsLeadByte(ch))
            {
            NewCCGetch();
            }
        else if (ch == '*')
            {
            char    chNext = NewCCGetch();
            if (chNext == 0)
                {
                fParseError = TRUE;
                break;
                }
            if (CurrentCharSet.IsMbcsLeadByte(chNext))
                {
                NewCCGetch();
                }
            else if (chNext == '/')
                {
                break;
                }
            else if (chNext == '*')
                {
                NewCCputbackc(chNext);
                }
            }
        }
    if (fParseError)
        {
        ParseError(EOF_IN_COMMENT, (char *)NULL);   /*   no end of comment operator */
        exit( EOF_IN_COMMENT );
        }
    return ( NOTOKEN );
}

token_t commentline()
{
    for (;;)
        {
        ch =  NewCCGetch();
        if( ch == 0 )
            {
            ParseError(EOF_IN_COMMENT, (char *)NULL);
            exit( EOF_IN_COMMENT );
            break;
            }
        else if (CurrentCharSet.IsMbcsLeadByte(ch))
            {
            NewCCGetch();
            }
        else if (ch == '\n')
            {
            break;
            }
        }
    return ( NOTOKEN );         /* get the next token */
}


/*............................. internal function ..........................*/
/*                                      */ 
/*              multi character operator                */
/*                                      */ 

const static token_t *snglop = &moptab[0];  /* adr of single character operator */
const static token_t *assgop = &moptab[12]; /* adr of assignment operator */
const static token_t *dblop  = &moptab[24]; /* adr of double character operator */

token_t mulop()
    {
    REG unsigned short i;                   /* index into multi operator table */
    REG char lstch;
//printf ("in mulop ch = %c\n", ch);

    i = unsigned short(((unsigned short)ci) >> 8);  /* get high byte of character index */
    if( i > 11 ) {          /* is it a type specification ? */
        // check for EOI
        if ( ci == short(0x9f0c) ) 
            {
            if(pImportCntrl->GetLexLevel() == 0)
                {
                if(pImportCntrl->GetEOIFlag())
                    return 0;
                else
                    pImportCntrl->SetEOIFlag();
                }
            return EOI;
            }
        if( i == 64 )           /* character is " */
            return ( string() );    /* handle string token */
        if( i == 65 )           /* character is ' */
            return ( character() ); /* handle character constant */
        if( i == '#' )
            return ProcessHash();   /* process any hash tokens */
        if( i == '.' )
            {
            if( (ch = NewCCGetch()) == '.' )
                {
                return DOTDOT;
                }
            NewCCputbackc( ch );
            }

        if ( i == LBRACK )
            {
            inside_rpc++;
            return i;
            }
        if ( i == RBRACK )
            {
            inside_rpc--;
            return i;
            }

        return ( i );               /* return type of single operator */
    }
    lstch = ch;                     /* save entry character */
    ch = NewCCGetch();              /* get a new one */
    if (CurrentCharSet.IsMbcsLeadByte(ch))
        {
        toklen_G = 1;
        tokptr_G[1] = 0;
        NewCCputbackc(ch);
        return *(snglop+i);
        }
    tokptr_G[1] = ch; tokptr_G[2] = 0;
    toklen_G = 2;                   /* add to token string */
    if( ch == '=' ) {               /* is next character an equal op. */
        return *(assgop+i);         /* return an assign operator */
    }
    if( lstch == ch ) {             /* is next char. = current char. ? */
        toktyp_G = *(dblop+i);      /*   yes, get its type */
        if( !toktyp_G ) {           /* is it a doppel operator ? */ 
            toklen_G = 1;           /* update token string */
            tokptr_G[1] = 0;
            NewCCputbackc(ch);      /* deliberate, puback of EOF is ignored */
            return *(snglop+i);     /*   no, return single operator */
        }
        if( ch == '/' )             /* if the operator is double // */
            {
            // potentially an error

//          ParseError( SINGLE_LINE_COMMENT, (char *)0 );
            return(commentline());  /*   the next line is a comment */
            }
        ch = NewCCGetch();                  /* get next character */
        if (ch == '=') {
            tokptr_G[2] = '='; tokptr_G[3] = '\0';
            toklen_G = 3;           /* update token string */
                        if(toktyp_G == LSHIFT) {              /* if shift op.and equal sign ? */
                                return (LEFTASSIGN);                     /* return as assign operator */
                        }
                        if(toktyp_G == RSHIFT) {
                                return (RIGHTASSIGN);
            }
            tokptr_G[2] = '\0'; toklen_G = 2;
        }
        NewCCputbackc(ch);                  /* put back unused character */
        return (toktyp_G);              /* else return doppel char. operator */
    }
    if( lstch == '-' && ch == '>' ) {   /* if structure operator */
                return (POINTSTO);                    /* return structure operator */
    }
    if( lstch == '/' && ch == '*' ) {   /* if comment */
        return( comment() );            /* ignore the comment */
    }
    tokptr_G[1] = '\0'; toklen_G = 1;   /* remove from token string */
    NewCCputbackc(ch);                      /* putback unused character */
    return *(snglop+i);                 /* return single character operator */
}

/*............................. internal function ..........................*/
/*                                      */ 
/*          convert escape (\) character                */ 
/*                                      */ 

char convesc()
    {
    unsigned short  value = 0;
    unsigned short  tmp;
    BOOL            fConstantIsIllegal  = FALSE;

    ch = NewCCGetch();

    if ( ch == 'n' )
        ch = 0xa;
    else if (ch == 't')
        ch = 0x9;
    else if (ch == 'v')
        ch = 0xb;
    else if (ch == 'b')
        ch = 0x8;
    else if( ch == 'r' )
        ch = 0xd;
    else if( ch == 'f' )
        ch = 0xc;
    else if( ch == 'a' )
        ch = 0x7;
    else if( (ch == 'x') || (ch == 'X') )
        {
        int i;

        for( i = 0, value = 0, fConstantIsIllegal = FALSE; i < 2; ++i )
            {
            tmp = ch = NewCCGetch();
            tmp = (unsigned short)toupper( tmp );
            if( isxdigit( tmp ) )
                {
                tmp = unsigned short( (tmp >= '0') && (tmp <= '9') ? (tmp - '0') : (tmp - 'A') + 0xa );
                }
            else if( ch == '\'' )
                {
                NewCCputbackc( ch );
                break;
                }
            else
                {
                fConstantIsIllegal  = TRUE;
                }
            value = unsigned short( value * 16 + tmp );
        }

        if( fConstantIsIllegal || (value > (unsigned short) 0x00ff) )
            ParseError( ILLEGAL_CONSTANT, (char *)0 );

        ch = (char )value;
        }
    else if( (ch >= '0') && (ch <= '7'))
        {
        int i;
        value = unsigned short(ch - '0');

        // the limit for this for loop is 2 because we already saw 1 character

        for ( i = 0, value = unsigned short(ch - '0'), fConstantIsIllegal = FALSE; i < 2; ++i)
            {
            tmp = ch = NewCCGetch();
            if( (ch >= '0') && (ch <= '7'))
                {
                tmp = unsigned short(tmp - '0');
                value = unsigned short(value * 8 + tmp);
                }
            else if( ch == '\'' )
                {
                NewCCputbackc( ch );
                break;
                }
            else
                fConstantIsIllegal = TRUE;
            }


        if( fConstantIsIllegal || (value > (unsigned short) 0x00ff) )
            ParseError( ILLEGAL_CONSTANT, (char *)0 );
        ch = (char )value;
        }

    return ( ch );
    }


/*............................. internal function ..........................*/
/*                                      */ 
/*               string analyzer                */ 
/*                                      */ 

token_t
character()
    {
        ch = NewCCGetch();
        if (CurrentCharSet.IsMbcsLeadByte(ch))
            {
            tokptr_G[0] = ch;
            tokptr_G[1] = NewCCGetch();
            tokptr_G[2] = 0;
            toklen_G = 2;
            }
        else
            {
            if (ch == '\\')
                {
                ch = convesc();
                }
            tokptr_G[0] = ch;
            tokptr_G[1] = '\0';

            yylval.yy_numeric.Val = tokval_G = ch;
            }
        if (NewCCGetch() != '\'')
            {
            ParseError(CHAR_CONST_NOT_TERMINATED,(char *)NULL );
            exit( CHAR_CONST_NOT_TERMINATED );
            }
         return (CHARACTERCONSTANT);
    }

// this rtn is called when the quote has been sensed.

char*    g_pchStrBuffer   = 0;
unsigned long g_ulStrBufferLen = 1024;

//
// Scan ahead in the current file to see if the next non-space character is a
// quote.  If it is then this is a string constant that is split into two
// pieces (e.g. "this" ... " is a " ... "test").  If the next character is 
// not a quote reset the file back to where we started from.
//
// If this is a multi-string situation return MULTIPLE_PROPERTY_ATTRIBUTES.
// This is a bit of a mis-use of that error code but it sounds nice.
//
// HACKHACK: The routine depends on internal knowledge of how NewCCGetch works.
//           Doing something similiar using the grammar was tried but failed
//           when processing imports because of details of how the trickery
//           played on the lexer works to get it to change streams in mid-go.
//

STATUS_T spacereadahead()
{
    fpos_t  fpos;
    short   newlines = 0;
    int     ch = ' ';

    if (0 != fgetpos(hFile_G, &fpos))
        return INPUT_READ;

    while (isspace(ch) && !feof(hFile_G))
        {
        ch = getc(hFile_G);

        if ( '\n' == ch )
            ++newlines;
        }

    if ('\"' == ch)
        {
        curr_line_G = (short) (curr_line_G + newlines);
        return MULTIPLE_PROPERTY_ATTRIBUTES;
        }
    else
        {
        if (0 != fsetpos(hFile_G, &fpos))
            return INPUT_READ;

        return STATUS_OK;
        }
}


token_t
string()
    {
    STATUS_T    Status          = STATUS_OK;
    char    *   ptr;

    if ( !g_pchStrBuffer )
        {
        g_pchStrBuffer = ( char * )malloc( sizeof( char ) * g_ulStrBufferLen );
        if ( NULL == g_pchStrBuffer )
            {
            RpcError( 0, 0, OUT_OF_MEMORY, 0 );
            exit( OUT_OF_MEMORY );
            }
        }

    strncpy( g_pchStrBuffer, tokptr_G, toklen_G );
    ptr = g_pchStrBuffer;

    ch  = 0;
    while( ( ch != '"' ) && ( Status == STATUS_OK ) )
        {
        if ( ( unsigned long ) ( ptr - g_pchStrBuffer ) > ( g_ulStrBufferLen - 3 ) )
            {
            char* pTempStrBuffer = ( char* ) realloc( g_pchStrBuffer, g_ulStrBufferLen * 2 );
            if ( pTempStrBuffer )
                {
                ptr = ( ptr - g_pchStrBuffer ) + pTempStrBuffer;
                g_pchStrBuffer = pTempStrBuffer;
                g_ulStrBufferLen = g_ulStrBufferLen * 2;
                }
            else
                {
                Status = STRING_TOO_LONG;
                }
            }

        ch  = NewCCGetch();

        if( ch == 0 )
            {
            Status  = EOF_IN_STRING;
            }
        else if ( ch == '\\' )
            {
            *ptr++ = ch;
            *ptr++ = NewCCGetch();
            ch = 0;
            }
        else if ( ch != '\"' )
            {
            *ptr++  = ch;
            if (CurrentCharSet.IsMbcsLeadByte(ch))
                *ptr++ = NewCCGetch();
            }
        else
            {
            Status = spacereadahead();

            if ( MULTIPLE_PROPERTY_ATTRIBUTES == Status )
                {
                Status = STATUS_OK;
                ch = 0;
                }
            }
        }
    
    *ptr = 0;

    if( Status != STATUS_OK )
        {
        ParseError( Status, (char *)0 );
        exit( Status );
        }

    yylval.yy_string = pMidlLexTable->LexInsert( g_pchStrBuffer );
    return ( STRING );
    }
/****************************** external function ***************************/
/*                                      */ 
/*              lexical analyzer                */ 
/*                                      */ 

static BOOL     fLastToken  = 0;
static BOOL     fLineLengthError = 0;
static token_t  LastToken;

void
initlex()
    {
    fLastToken  = 0;
    }


void
yyunlex( token_t T )
    {
    LastToken   = T;
    fLastToken  = 1;
    }

token_t yylex()
{
    REG short state;        /* token state */
    REG char *ptr;

    if( fLastToken )
        {
        fLastToken  = 0;
        return LastToken;
        }

    if ( LexContext != LEX_NORMAL )
        {
        switch ( LexContext )
            {
            case LEX_GUID:
                {
                LexContext = LEX_NORMAL;
                return ScanGuid();
                }
            case LEX_VERSION:
                {
                LexContext = LEX_NORMAL;
                return ScanVersion();
                }
            case LEX_ODL_BASE_IMPORT:
            case LEX_ODL_BASE_IMPORT2:
                {
                return ScanImplicitImports();
                break;
                }
            default:
                MIDL_ASSERT(0);

            }
        }

again:
    state = 0;              /* initial state */
    ptr = tokptr_G = tok_buffer;    /* remember token begin position */
    toklen_G = 0;
    
    do
        {
        ci = ct[ (unsigned char) (ch=NewCCGetch()) ];         /* character index out of char.tab. */
        state = st[ state ][ ci & 0x00ff ]; /* determine new state */
        } while ( state == 0 );                 /* skip white space */
    
    *(ptr++) = ch;
    toklen_G++;             /* add chacter to token string */

    if (CurrentCharSet.IsMbcsLeadByte(ch))
        {
        *(ptr++) = NewCCGetch();
        toklen_G++;
        }
    
    while( state < 13 )
        {           /* loop til end state */
        ci = ct[ (unsigned char) (ch=NewCCGetch()) ];       /* character index out of char.tab. */
        state = st[ state ][ ci & 0x00ff ]; /* determine new state */
        if (state < 13)
            {                   /* if still going, */
            if (toklen_G + 1 != MAX_LINE_SIZE) /* and the token isn't too large */
                {
                *(ptr++) = ch;  toklen_G++;     /* add chacter to token string */
                if (CurrentCharSet.IsMbcsLeadByte(ch))
                    {
                    *(ptr++) = NewCCGetch();
                    toklen_G++;
                    }
                }
            else
                {
                fLineLengthError = 1;
                }
            }
        };
    
    *ptr = '\0';
    LastLexChar = ch;

    if (fLineLengthError)
        {
        ParseError(IDENTIFIER_TOO_LONG, (char *)0 );    
        fLineLengthError = 0;
        }

    switch( state & 0x00ff )
        {
        case 2: ch = NewCCGetch();      /* position to next character */
            break;

        case 3: 
        case 1: NewCCputbackc(ch);          /* position to current character */
            break;
        /* case 0 - do nothing */
        }
//printf ("current ch = %c\n", ch);
    toktyp_G = (*action[ state >> 8 ])();   /* execute action */

    // skip fluff like #line
    if (toktyp_G == NOTOKEN)
        goto again;

    return(toktyp_G);
}

token_t
LChar()
    {
    character();
    return WIDECHARACTERCONSTANT;
    }

token_t
LStr()
    {
    string();
    return WIDECHARACTERSTRING;
    }

// process line number tokens
token_t
ProcessLine()
    {
    char    *   ptr     = tokptr_G;

    curr_line_G = short( atoi( ptr ) - 1 );
    
    // skip spaces before file name
    while ( ( ch = NewCCGetch() ) == ' ' ) 
        ;

    ptr = tokptr_G;
    // see if we got a filename
    if ( ch == '\"' )
        {
        for (;;)
            {
            ch = NewCCGetch();
            *ptr++ = ch;
            if (CurrentCharSet.IsMbcsLeadByte(ch))
                {
                *ptr++ = NewCCGetch();
                }
            else if (ch == '\"')
                {
                break;
                }
            }
        *(--ptr) = '\0';

        StripSlashes( tokptr_G );

        pImportCntrl->SetLineFilename( tokptr_G );

        }
    
    // skip to end of line
    for (;;)
        {
        ch = NewCCGetch();
        if (ch == 0)
            {
            break;
            }
        else if (CurrentCharSet.IsMbcsLeadByte(ch))
            {
            ch = NewCCGetch();
            }
        else if (ch == '\n')
            {
            break;
            }
        }

    return NOTOKEN;
    }

// process # <something>
token_t
ProcessHash()
    {
    char    *   ptr     = tokptr_G,
            *   ptrsave = ptr;
    token_t     PragmaToken;

    do  // eat spaces
        {
        ch = NewCCGetch();
        } while( isspace( ch ) );

    // collect first token
    while( !isspace( ch ) )
        {
        *ptr++ = ch;
        if (CurrentCharSet.IsMbcsLeadByte(ch))
            {
            *ptr++ = NewCCGetch();
            }
        ch = NewCCGetch();
        }
    *ptr = '\0';

    // is this hash a pragma starter ?

#define PRAGMA_STRING               ("pragma")
#define LEN_PRAGMA_STRING           (6)
#define MIDL_PRAGMA_PREFIX          ("midl_")
#define LEN_MIDL_PRAGMA_PREFIX      (5)
#define LINE_STRING                 ("line")
#define LEN_LINE_STRING             (4)

    // we handle #pragma and #line directives

    // #line found
    if (strncmp( tokptr_G, LINE_STRING, LEN_LINE_STRING ) == 0 ) 
        {
        ptr = tokptr_G;
        // get the next token (the number)
        do  // eat spaces
            {
            ch = NewCCGetch();
            } while( isspace( ch ) );

        // collect first token
        while( !isspace( ch ) )
            {
            *ptr++ = ch;
            if (CurrentCharSet.IsMbcsLeadByte(ch))
                {
                *ptr++ = NewCCGetch();
                }
            ch = NewCCGetch();
            }
        *ptr = '\0';
        return ProcessLine();   // this needs to be called with tokptr_G pointing after
                                // the #line part
        }
    // # <number> found
    else if ( isdigit(*tokptr_G) )
        {
        *ptr = '\0';
        return ProcessLine();
        }
    else if( strncmp( tokptr_G, PRAGMA_STRING, LEN_PRAGMA_STRING ) == 0 )
        {
        // eat white space between #pragma and next word
        for(;;)
            {
            ch = NewCCGetch();
            if(!isspace(ch) ) break;
            *ptr++ = ch;
            }

        ptrsave = ptr;

        *ptr++ = ch;

        // pull next word in
        for(;;)
            {
            ch = NewCCGetch();
            if(!isalpha(ch) && (ch != '_') ) break;
            *ptr++ = ch;
            if (CurrentCharSet.IsMbcsLeadByte(ch))
                {
                *ptr++ = NewCCGetch();
                }
            }

        // put back next char (it may even be the \n)
        NewCCputbackc( ch );
        *ptr = 0;

        // check if it is a MIDL pragma or not
        if ( ( PragmaToken  = IsValidPragma( ptrsave ) ) != 0 )
            {
            return PragmaToken;
            }


        // assume it is some other C pragma, so return the string

        for (;;)
            {
            ch = NewCCGetch();
            *ptr++ = ch;
            if (CurrentCharSet.IsMbcsLeadByte(ch))
                {
                *ptr++ = NewCCGetch();
                }
            else if (ch == '\n')
                {
                break;
                }
            }
        *(--ptr) = 0;

        yylval.yy_string = pMidlLexTable->LexInsert( ptrsave );
        return KWCPRAGMA;

        }
    else
        {
        // some graceful recovery by the parser
        return GARBAGETOKEN;
        }
    }

token_t
IsValidPragma( 
    char    *   p )
    {
static char * agPragmaNames[] = {
       "midl_import"
      ,"midl_echo"
      ,"midl_import_clnt_aux"
      ,"midl_import_srvr_aux"
      ,"pack"
};
static token_t agTokenVal[] = {
      KWMPRAGMAIMPORT
     ,KWMPRAGMAECHO
     ,KWMPRAGMAIMPORTCLNTAUX
     ,KWMPRAGMAIMPORTSRVRAUX
     ,KWCPRAGMAPACK
};

    short   Index = 0;

    while( Index < sizeof( agPragmaNames ) / sizeof(char *) )
        {
        if( !strcmp( p, agPragmaNames[ Index ] ) )
            return agTokenVal[ Index ];
        ++Index;
        }
    return 0;
    }

token_t
ScanGuid( void )
    {
    char        c;
    char    *   p = tokptr_G;

    if( (c = NewCCGetch()) == '\"' )
        {
        string();
        ParseError( QUOTED_UUID_NOT_OSF, (char *)0 );
        return UUIDTOKEN;
        }

    NewCCputbackc( c );

    // remove leading spaces.

    while ( (c = NewCCGetch()) != 0  && isspace( c ) )
        ;

    while ( c && (c  != ')') && (c != ',') && !isspace(c) )
        {
        *p++ = c;
        if (CurrentCharSet.IsMbcsLeadByte(c))
            {
            *p++ = NewCCGetch();
            }
        c = NewCCGetch();
        }

    NewCCputbackc( c );
    *p++ = 0;
    yylval.yy_string = pMidlLexTable->LexInsert(tokptr_G);

    return UUIDTOKEN;
    }

token_t
ScanVersion( void )
    {
    char        c;
    char    *   p = tokptr_G;

    //
    // remove leading spaces.
    //

    while ( (c = NewCCGetch()) != 0 && isspace(c) )
        ;

    while ( c && (c  != ')') && !isspace(c) )
        {
        *p++ = c;
        if (CurrentCharSet.IsMbcsLeadByte(c))
            {
            *p++ = NewCCGetch();
            }
        c    = NewCCGetch();
        }

    NewCCputbackc( c );
    *p++ = 0;
    yylval.yy_string = pMidlLexTable->LexInsert(tokptr_G);

    return VERSIONTOKEN;
    }

token_t
ScanImplicitImports( void )
    {
    switch ( LexContext )
        {
        case LEX_ODL_BASE_IMPORT:
            {
            tokptr_G    = "import";
            toktyp_G    = KWIMPORTODLBASE;
            LexContext  = LEX_ODL_BASE_IMPORT2;
            break;
            }
        case LEX_ODL_BASE_IMPORT2:
            {
            tokptr_G    = "oaidl.idl";
            toktyp_G    = STRING;
            yylval.yy_string = pMidlLexTable->LexInsert(tokptr_G);
            LexContext  = LEX_NORMAL;
            break;
            }
        default:
            MIDL_ASSERT(0);
        }


    return toktyp_G;    

    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\front\lex.h ===
// Copyright (c) 1993-1999 Microsoft Corporation

/* SCCSWHAT( "@(#)lex.h	3.2 88/12/08 15:03:58	" ) */
/*
**	union used to return values from the lexer
*/

#if !defined(_LEX_H)

#define _LEX_H

typedef unsigned short token_t;

extern 	token_t yylex(void);
extern  void    yyunlex( token_t token);

token_t is_keyword(char*, short);

/*
 *	These parser flags control three things:
 *	1] whether the has parser has parsed a valid t_spec yet (ATYPE)
 *	2] whether "const" and "volatile" are modifiers (ACVMOD)
 *	3] whether we have a declaration with no type (AEMPTY)
 *	4] whether the rpc keywords are active. (RPC)
 *	5] whether we are in an enum\struct\union (AESU)
 *
 *	ISTYPENAME checks that we have not seen a type yet.
 */

#define REG
#define	PF_ATYPE		0x01
#define	PF_AESU			0x02
#define	PF_ASTROP		0x04
#define PF_ACVMOD		0x08
#define PF_AEMPTY		0x10
#define PF_RPC			0x20

#define PF_TMASK		(PF_ATYPE | PF_AESU | PF_ASTROP)
#define PF_MMASK		(PF_ACVMOD | PF_AEMPTY)
#define	PF_ISTYPENAME	((ParseFlags & PF_TMASK) == 0)
#define PF_ISMODIFIER	((ParseFlags & PF_MMASK) != 0)
#define PF_ISEMPTY		((ParseFlags & PF_AEMPTY) != 0)
#define PF_INRPC		(ParseFlags & PF_RPC)
#define PF_SET(a)		(ParseFlags |= (a))
#define PF_CLEAR(a)		(ParseFlags &= (~(a)))

#define PF_LOOKFORTYPENAME ((ParseFlags & PF_ATYPE) == 0)

extern short inside_rpc;

/* some notes about the parse flags....

PF_ATYPE is the important part of PF_LOOKFORTYPENAME, the macro that
tells the lexer whether or not it is valid to return an L_TYPENAME
token.  It should be cleared after a valid type is read (int, another
typedefed name, struct x, etc) and reset after an identifier is assigned
to that type.

*/

#define KW_IN_IDL	0x0001
#define KW_IN_ACF	0x0002
#define KW_IN_BOTH	( KW_IN_IDL | KW_IN_ACF )

#define M_OSF		0x0010
#define M_MSE		0x0020
#define M_CPORT		0x0040
#define M_ALL		(M_OSF | M_MSE | M_CPORT)

#define INBRACKET		0x0100
#define UNCONDITIONAL	0x0000
#define BRACKET_MASK	0x0100

#define LEX_NORMAL			0x0000
#define LEX_VERSION			0x0001	// return VERSION and set mode back to LEX_NORMAL
#define LEX_GUID			0x0002	// return GUID and set mode back to LEX_NORMAL
#define LEX_ODL_BASE_IMPORT     0x0005  // return KWIMPORTODLBASE STRING as next two tokens
#define LEX_ODL_BASE_IMPORT2    0x0006  // return STRING

#define MAX_STRING_SIZE	255

#endif // _LEX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\front\lextable.cxx ===
/**********************************************************************/
/**                      Microsoft LAN Manager                       **/
/**             Copyright(c) Microsoft Corp., 1987-1999              **/
/**********************************************************************/

/*

lextable.cxx
MIDL Compiler Lexeme Table Implementation 

This class centralizes access to allocated strings throughout the
compiler.

*/

/*

FILE HISTORY :

DonnaLi     08-23-1990      Created.

*/

#pragma warning ( disable : 4514 )

#include "nulldefs.h"
extern "C" {

#include <stdio.h>
#include <malloc.h>
#include <string.h>

}
#include "common.hxx"
#include "lextable.hxx"

/**********************************************************************\

NAME:		PrintLexeme

SYNOPSIS:	Prints out the name of a lexeme table entry.

ENTRY:		key	- the key to lexeme table entry to be printed.

EXIT:

NOTES:

HISTORY:
	Donnali		08-06-1991		Move to LM/90 UI Coding Style

\**********************************************************************/

void 
PrintLexeme(
	void * key
	)
{
	printf ("%s", ((LexKey *)key)->sz);
}

/**********************************************************************\

NAME:		CompareLexeme

SYNOPSIS:	Compares keys to two lexeme table entries.

ENTRY:		key1	- the key to 1st lexeme table entry to be compared.
			key2	- the key to 2nd lexeme table entry to be compared.

EXIT:		Returns a positive number if key1 > key2.
			Returns a negative number if key1 < key2.
			Returns 0 if key1 = key2.

NOTES:

HISTORY:
	Donnali		08-06-1991		Move to LM/90 UI Coding Style

\**********************************************************************/

int
CompareLexeme(
	void * key1,
	void * key2
	)
{
	return(strcmp(((LexKey *)key1)->sz, ((LexKey *)key2)->sz));
}

/**********************************************************************\

NAME:		LexTable::LexTable

SYNOPSIS:	Constructor.

ENTRY:		Allocates memory according to Size.
			Passes the compare and print functions to base class.

EXIT:

NOTES:

HISTORY:
	Donnali		08-06-1991		Move to LM/90 UI Coding Style

\**********************************************************************/

LexTable::LexTable(
	size_t	Size,
	int		(* )(void *, void *),
	void	(* )(void *)
	) 
#ifdef unique_lextable
	: Dictionary(pfnCompare, pfnPrint)
#endif // unique_lextable
{
	BufferSize = Size;
	BufferNext = 0;
	pBuffer = new char[BufferSize];
}

/**********************************************************************\

NAME:		LexTable::LexInsert

SYNOPSIS:	Inserts a lexeme into the lexeme table.

ENTRY:		psz	- the string to be inserted.

EXIT:		Returns the string.

NOTES:

HISTORY:
	Donnali		08-06-1991		Move to LM/90 UI Coding Style

\**********************************************************************/

char *
LexTable::LexInsert(
	char * psz
	)
{
	char *		NewString;
#ifdef unique_lextable
	LexKey *	NewLexeme;
	Dict_Status	Status;

	SearchKey.SetString(psz);
	Status = Dict_Find(&SearchKey);
	switch (Status)
		{
		case EMPTY_DICTIONARY:
		case ITEM_NOT_FOUND:
#endif // unique_lextable
			if ((BufferSize - BufferNext) <= strlen(psz))
				{
				BufferSize *= 2;
				if ( BufferSize > 32700 )
					BufferSize = 32700;
				BufferNext = 0;
				pBuffer = new char[BufferSize];
				}
			NewString = (char *)(pBuffer + BufferNext);
			(void) strcpy(NewString, psz);
			BufferNext += strlen(psz) + 1;

#ifdef unique_lextable
			NewLexeme = new LexKey (NewString);
			Status = Dict_Insert(NewLexeme);
#endif // unique_lextable
			return NewString;
#ifdef unique_lextable
		default:
			return ((LexKey *)Dict_Curr_Item())->GetString();
		}
#endif // unique_lextable
}

/**********************************************************************\

NAME:		LexSearch

SYNOPSIS:	Searches the lexeme table for a lexeme.

ENTRY:		psz	- the string to be searched.

EXIT:		Returns the string.

NOTES:

HISTORY:
	Donnali		08-06-1991		Move to LM/90 UI Coding Style

\**********************************************************************/

char *
LexTable::LexSearch(
	char *
	)
{
#ifdef unique_lextable
	Dict_Status	Status;

	SearchKey.SetString(psz);
	Status = Dict_Find(&SearchKey);
	if (Status == SUCCESS)
		return ((LexKey *)Dict_Curr_Item())->GetString();
	else
#endif // unique_lextable
		return (char *)0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\front\listhndl.cxx ===
/*****************************************************************************
/**                     Microsoft LAN Manager                               **/
/**             Copyright(c) Microsoft Corp., 1987-1999                     **/
/*****************************************************************************/
/*****************************************************************************
File                : listhndl.cxx
Title               : general purpose list handler
                    :
Description         : this file handles the general purpose list routines
History             :
    16-Oct-1990 VibhasC     Created
    11-Dec-1990 DonnaLi     Fixed include dependencies

*****************************************************************************/

#pragma warning ( disable : 4514 )

/****************************************************************************
 ***        local defines
 ***************************************************************************/
#define IS_AGGREGATE_TYPE(NodeType) (   (NodeType == NODE_ARRAY)    ||  \
                                        (NodeType == NODE_STRUCT) )
#define ADJUST_OFFSET(Offset, M, AlignFactor)   \
            Offset += (M = Offset % AlignFactor) ? (AlignFactor-M) : 0
/****************************************************************************
 ***        include files
 ***************************************************************************/
#include "nulldefs.h"
extern "C"  {
    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>
    #include <malloc.h>

    typedef char far * FARPOINTER;
}
#include "gramutil.hxx"

/****************************************************************************
 ***        external procedures 
 ***************************************************************************/
int                 AttrComp( void *, void *);
/****************************************************************************
 ***        external data 
 ***************************************************************************/


/****************************************************************************
 ***        local data 
 ***************************************************************************/




/*****************************************************************************
 *  general purpose list (iterator) control functions
 *****************************************************************************/
/****************************************************************************
 _gplist:
    the private memory allocator
 ****************************************************************************/

// initialize the memory allocator for _gplist

FreeListMgr
_gplist::MyFreeList( sizeof (_gplist ) );


gplistmgr::~gplistmgr( void )
    {
    while(pFirst)
        {
        pCurrent    = pFirst->pNext;
        delete pFirst;
        pFirst  = pCurrent;
        }
    }

STATUS_T
gplistmgr::Discard()
    {
    while(pFirst)
        {
        pCurrent    = pFirst->pNext;
        delete pFirst;
        pFirst  = pCurrent;
        }
    pTail = pFirst;
    return STATUS_OK;
    }

STATUS_T
gplistmgr::Insert( 
    void * pNewElement )
    {
    struct _gplist *pNew = new struct _gplist( pNewElement );

    if(pNew != (struct _gplist *)NULL)
        {
        if(pTail != (struct _gplist *)NULL)
            {
            pTail->pNext    = pNew;
            }
        pTail   = pNew;
        if(pFirst == NULL) pFirst = pNew;
        if(pCurrent == NULL) pCurrent = pNew;
        return STATUS_OK;
        }
    return OUT_OF_MEMORY;
    }

STATUS_T    
gplistmgr::InsertHead( 
    void * pNewElement )
    {
    struct _gplist *pNew = new struct _gplist( pNewElement );

    if(pNew != (struct _gplist *)NULL)
        {
        pNew->pNext     = pFirst;
        pFirst          = pNew;
        pCurrent        = pNew;
        if(pTail == NULL)   pTail = pNew;
        return STATUS_OK;
        }
    return OUT_OF_MEMORY;
    }

STATUS_T
gplistmgr::RemoveHead( void )
    {
    struct _gplist  *pDel;
    
    pDel    = pFirst;
    pFirst  = pFirst->pNext;

    if ( pCurrent == pDel )
        {
        pCurrent = pFirst;
        }

    if ( pFirst == NULL )
        {
        pTail       = NULL;
        }

    delete pDel;
    return STATUS_OK;
    }

STATUS_T
gplistmgr::GetCurrent(
    void **ppReturn )
    {
    if( pCurrent != (struct _gplist *)NULL )
        {
        (*ppReturn) = pCurrent->pElement;
        return STATUS_OK;
        }
    return I_ERR_NO_PEER;
    }

short
gplistmgr::GetCount()
    {
    short               cnt = 0;
    struct _gplist *    pCur = pFirst;

    while( pCur )
        {
        cnt++;
        pCur = pCur->pNext;
        };

    return cnt;
    }

STATUS_T
gplistmgr::MergeToTail(
    gplistmgr   *pSrcList,
    BOOL bDeleteList )
    {
        if(pSrcList)
        {
        if (pSrcList->pFirst)
            {
            if ( pTail )    // glue to tail of current list
                {
                pTail->pNext    = pSrcList->pFirst;
                pTail           = pSrcList->pTail;
                }
            else    // add to empty list
                {
                pFirst          = pSrcList->pFirst;
                pTail           = pSrcList->pTail;
                }
            }

        // Clear pointer in previous list since
        // we are assuming ownership of the nodes.
        pSrcList->pFirst    = NULL;
        pSrcList->pTail     = NULL;
        
        // delete the source list.
        if ( bDeleteList )
            delete pSrcList;
        }
    return STATUS_OK;
    }

STATUS_T
gplistmgr::Clone(
    gplistmgr   *pOldList )
    {
    if(pOldList)
        {
        struct _gplist  *   pCur = pOldList->pFirst;
        struct _gplist  *   pNew;

        while ( pCur )
            {
            
            pNew = new struct _gplist( pCur->pElement );

            if ( pTail )
                {
                pTail->pNext    = pNew;
                pTail           = pNew;
                }
            else        // first element
                {
                pFirst      = 
                pCurrent    =
                pTail       = pNew;
                }

            pCur = pCur->pNext;
            }
        }
    return STATUS_OK;
    }

/**************************************************************************
 *              public functions for type_node_list
 **************************************************************************/
type_node_list::type_node_list( void )
    {
    }
type_node_list::type_node_list( 
    node_skl    *   p)
    {
    SetPeer( p );
    }
STATUS_T
type_node_list::SetPeer( 
    class node_skl *pNode )
    {
    return Insert( (void *)pNode );
    }
STATUS_T
type_node_list::GetPeer(
    class node_skl **pNode )
    {
    return GetNext ( (void **)pNode );
    }

STATUS_T
type_node_list::GetFirst(
    class node_skl **pNode )
    {
    STATUS_T Status;

    if( (Status = Init())  == STATUS_OK)
        {
        Status = GetNext( (void**)pNode );
        }
    return Status;
    }


short
IndexedList::Insert(
    void *pData
    )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Routine Description:

    Insert a pointer into a list and return a unique index representing that
    pointer.  Duplicate pointers return the same index.

  ReturnValue:

    The index of the pointer in the list.

----------------------------------------------------------------------------*/
{
    _gplist    *pCurrent = pFirst;
    short       i        = 0;

    while ( NULL != pCurrent )
    {
        if ( pCurrent->pElement == pData )
            return i;

        ++i;
        pCurrent = pCurrent->pNext;
    }

    gplistmgr::Insert( pData );

    return i;
}


short
IndexedStringList::Insert(
    char * pString
    )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Insert a strint into the list such that the string is associated with a
    unqiue index.   If the name already exists don't insert it again and 
    return the index of the previous entry.

  ReturnValue:

    The index of the string in the list.

----------------------------------------------------------------------------*/
{
    _gplist    *pCurrent = pFirst;
    short       i        = 0;

    while ( NULL != pCurrent )
    {
        if ( 0 == strcmp( (char *) pCurrent->pElement, pString ) )
            return i;

        ++i;
        pCurrent = pCurrent->pNext;
    }

    gplistmgr::Insert( pString );

    return i;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\front\mbcs.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1995-1999 Microsoft Corporation

 Module Name:

    mbcs.cxx

 Abstract:

    MBCS support related code used by the lexer.

 Notes:

 History:

    RyszardK   Sep-1996        Created.
    
 ----------------------------------------------------------------------------*/

#pragma warning ( disable : 4514 )

#include <windows.h>
#include <stdlib.h>
#include "mbcs.hxx"

CharacterSet CurrentCharSet;

int
CharacterSet::DBCSDefaultToCaseSensitive()
    {
    // these languages do not distinguish cases
    return (
            PRIMARYLANGID(LANGIDFROMLCID(CurrentLCID)) == LANG_JAPANESE ||
            PRIMARYLANGID(LANGIDFROMLCID(CurrentLCID)) == LANG_CHINESE  ||
            PRIMARYLANGID(LANGIDFROMLCID(CurrentLCID)) == LANG_KOREAN
            );
    }


CharacterSet::CharacterSet()
{
    memset( DbcsLeadByteTable, 0, 128 );
    SetDbcsLeadByteTable( GetSystemDefaultLCID() );
}

CharacterSet::DBCS_ERRORS
CharacterSet::SetDbcsLeadByteTable( 
    unsigned long   ulLocale )
{
    DBCS_ERRORS dbcsRet     = dbcs_Failure;
    
    if (CurrentLCID != ulLocale)
        {
        dbcsRet = dbcs_Success;
        char  szCodePage[6];

        if ( GetLocaleInfo( ulLocale,
                            LOCALE_NOUSEROVERRIDE | LOCALE_IDEFAULTANSICODEPAGE,
                            szCodePage,
                            sizeof(szCodePage) ) )
            {
            unsigned int  CodePage = atoi( szCodePage );

            for (int i = 128; i < 256; i++ )
                {
                DbcsLeadByteTable[i] = (char) IsDBCSLeadByteEx( CodePage,
                                                                (char) i );
                }
            }
        else
            {
            unsigned char i = 0;
	        switch (PRIMARYLANGID(ulLocale))
                {
	            case LANG_CHINESE:
                    if (SUBLANGID(ulLocale) == SUBLANG_CHINESE_SIMPLIFIED)
                        {
                        for (i=0xA1; i <= 0xFE; i++)
                            {
                            DbcsLeadByteTable[i] = 1;
                            }
                        }
                    break;
                case LANG_KOREAN:
                    for (i = 0x81; i <= 0xFE; i++)
                        {
                        DbcsLeadByteTable[i] = 1;
                        }
                    break;
                case LANG_JAPANESE:
                    for (i = 0x81; i <= 0x9F; i++)
                        {
                        DbcsLeadByteTable[i] = 1;
                        }
                    for (i = 0xE0; i <= 0xFC; i++)
                        {
                        DbcsLeadByteTable[i] = 1;
                        }
                    break;
                default:
                    dbcsRet = dbcs_BadLCID;
                    break;
	            }
            }
        }
    else
        {
        dbcsRet = dbcs_Success;
        }
    if (CurrentLCID != (unsigned long)-1 &&
        CurrentLCID != ulLocale &&
        ulLocale    != 0)
        {
        dbcsRet = dbcs_LCIDConflict;
        }
    CurrentLCID = ulLocale;
    return dbcsRet;
}

int
CharacterSet::CompareDBCSString(
    char*           szLHStr,
    char*           szRHStr,
    unsigned long   ulFlags
    )
{
    int     nRet = CompareStringA(  CurrentLCID,
                                    NORM_IGNOREWIDTH | NORM_IGNOREKANATYPE | ulFlags,
                                    szLHStr,
                                    -1,
                                    szRHStr,
                                    -1) - 2;
    if (nRet == -2)
        {
        nRet = strcmp(szLHStr, szRHStr);
        }
    return nRet;
}

unsigned int
GetConsoleMaxLineCount()
{
    CONSOLE_SCREEN_BUFFER_INFO  ConsoleInfo;
    HANDLE hOutput = GetStdHandle( STD_OUTPUT_HANDLE );
    ZeroMemory( &ConsoleInfo,  sizeof( ConsoleInfo ) );
    BOOL fResult = GetConsoleScreenBufferInfo( hOutput, &ConsoleInfo );
    if ( fResult )
    {
        return ConsoleInfo.srWindow.Bottom - 1;
    }
    else
    {
        return 23;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\front\misc.cxx ===
// Copyright (c) 1993-1999 Microsoft Corporation

#pragma warning ( disable : 4514 4710 )

#include <stdio.h>
#include "cmdana.hxx"

extern CMD_ARG* pCommand;

/*
put the following lines in rpcndr.h

     // MIDL 3.03.98
#define __RPCNDR_H_VERSION__        440

#ifdef __REQUIRED_RPCNDR_H_VERSION__ 
    #if ( __RPCNDR_H_VERSION__ < __REQUIRED_RPCNDR_H_VERSION__ )
        #error incorrect <rpcndr.h> version. Use the header that matches with the MIDL compiler.
    #endif 
#endif // __REQUIRED_RPCNDR_H_VERSION__

put the following lines in rpcproxy.h
     
       // MIDL 3.03.98
#define __RPCPROXY_H_VERSION__      440

#ifdef __REQUIRED_RPCPROXY_H_VERSION__ 
    #if ( __RPCPROXY_H_VERSION__ < __REQUIRED_RPCPROXY_H_VERSION__ )
        #error incorrect <rpcproxy.h> version. Use the header that matches with the MIDL compiler.
    #endif 
#endif // __REQUIRED_RPCPROXY_H_VERSION__

*/

#define RPC_HEADERS_VERSION "/* verify that the %s version is high enough to compile this file*/\n" \
                            "#ifndef %s\n#define %s %d\n#endif\n\n"
                                    
char*
GetRpcNdrHVersionGuard( char* szVer )
    {
    unsigned long   ulVersion = 440;

    *szVer = 0;
    if ( !pCommand->IsSwitchDefined( SWITCH_VERSION_STAMP ) )
        {
        if ( pCommand->GetNdrVersionControl().HasNdr50Feature() )
            {
            if (pCommand->GetNdrVersionControl().HasAsyncUUID() ||
                pCommand->GetNdrVersionControl().HasDOA() ||
                pCommand->GetNdrVersionControl().HasContextSerialization() ||
                pCommand->GetNdrVersionControl().HasInterpretedNotify() )
                {
                ulVersion = 475;
                }
            else
                {
                ulVersion = 450;
                }
            }
        sprintf( szVer, RPC_HEADERS_VERSION, "<rpcndr.h>",
                "__REQUIRED_RPCNDR_H_VERSION__", "__REQUIRED_RPCNDR_H_VERSION__", ulVersion );
        }
    return szVer;
    }

char*
GetRpcProxyHVersionGuard( char* szVer )
    {
    unsigned long   ulVersion = 440;

    *szVer = 0;
    if ( !pCommand->IsSwitchDefined( SWITCH_VERSION_STAMP ) )
        {
        if ( pCommand->GetNdrVersionControl().HasNdr50Feature() )
            {
            if (pCommand->GetNdrVersionControl().HasAsyncUUID() ||
                pCommand->GetNdrVersionControl().HasDOA() ||
                pCommand->GetNdrVersionControl().HasContextSerialization() ||
                pCommand->GetNdrVersionControl().HasInterpretedNotify() )
                {
                ulVersion = 475;
                }
            else
                {
                ulVersion = 450;
                }
            }
        sprintf( szVer, RPC_HEADERS_VERSION, "<rpcproxy.h>",
                "__REDQ_RPCPROXY_H_VERSION__", "__REQUIRED_RPCPROXY_H_VERSION__", ulVersion );
        }
    return szVer;
    }

void 
MidlSleep( int sec )
    {
    _sleep( 1000 * sec );
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\front\linenum.cxx ===
/*****************************************************************************/
/**						Microsoft LAN Manager								**/
/**				Copyright(c) Microsoft Corp., 1987-1999						**/
/*****************************************************************************/
/*****************************************************************************
File				: linenum.cxx
Title				: Line number storage routines
History				:
	29-Oct-93	GregJen	Created

*****************************************************************************/

#pragma warning ( disable : 4514 )

/****************************************************************************
 local defines and includes
 ****************************************************************************/

#include "nulldefs.h"
extern	"C"
	{
	#include <stdio.h>
	
	}

#include "common.hxx"
#include "linenum.hxx"
#include "filehndl.hxx"
#include "idict.hxx"


/****************************************************************************
 external data
 ****************************************************************************/

extern NFA_INFO					*	pImportCntrl;
extern short						curr_line_G;

/****************************************************************************
 external procs
 ****************************************************************************/


/****************************************************************************
 global data
 ****************************************************************************/

short		FileIndex;

IDICT	*	pFileDict;


/****************************************************************************/


void
tracked_node::SetLine()
{
	//FLine = pImportCntrl->GetCurrentLineNo();
	FLine = curr_line_G;
}


STATUS_T
tracked_node::GetLineInfo( 
	char *& pName,
	short & Line )
{
	if (FIndex)
		{
		// fetch file name from dictionary and line number from here
		pName	= FetchFileFromDB( FIndex );
		Line = FLine;
		return STATUS_OK;
		}
	
	pName = "";
	Line = 0;
	return NO_INPUT_FILE;
}



/****************************************************************************/

short 
AddFileToDB( char * pFile )
{
	FileIndex = (short) pFileDict->AddElement( (IDICTELEMENT) pFile );
	return FileIndex;
};

char *
FetchFileFromDB( short Index )
{
	return (char *) pFileDict->GetElement( (IDICTKEY) Index );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\front\lexutils.cxx ===
// Copyright (c) 1993-1999 Microsoft Corporation

/*
** helper functions for Gerd Immeyer's grammar
**
*/

/****************************************************************************
 *			include files
 ***************************************************************************/

#pragma warning ( disable : 4514 4710 )

#include "nulldefs.h"
extern "C" {
	#include <stdio.h>
	#include <io.h>
	#include <process.h>
	#include <string.h>

	#include <stdlib.h>
}

#include "common.hxx"
#include "errors.hxx"
#include "midlnode.hxx"
#include "listhndl.hxx"
#include "filehndl.hxx"
#include "lextable.hxx"
#include "lexutils.hxx"
#include "grammar.h"
#include "gramutil.hxx"
#include "cmdana.hxx"
#include "control.hxx"
#include "tlgen.hxx"
#include <float.h>

extern "C" {
    #include "lex.h"
}

/****************************************************************************
 *		local definitions and macros
 ***************************************************************************/

#define warning(p)		/* temp defintion to get rid of compiler probs */

#define MAX_ID_LENGTH  		(31)
#define MAX_DECIMAL_LENGTH	(10)
#define MAX_HEX_LENGTH		(8)
#define MAX_OCTAL_LENGTH	(25)

/***************************************************************************
 *		local data
 ***************************************************************************/

/***************************************************************************
 *		local procedures
 ***************************************************************************/
long 						convert(char *, short, short);
token_t 					cnv_int(void);
token_t 					cnv_hex(void);
token_t 					cnv_octal(void);
token_t 					cnv_float(void);
inline token_t              GetNextToken() {return yylex();}
inline void                 UngetToken(token_t token) {yyunlex(token);}
token_t 					name(void);
token_t 					map_token(token_t token);
void 						lex_error(int number);

/***************************************************************************
 *		global data
 ***************************************************************************/

// token_t 					TokenMap[LASTTOKEN];
short						handle_import;
short						inside_rpc;
lextype_t					yylval;
token_t						toktyp_G;			/* token type */
short						toklen_G;			/* len of token string */
char 						*tokptr_G;			/* pointer to token string */
short						curr_line_G;		/* current line in file */
char						*curr_file_G;		/* current file name */
long						tokval_G;			/* value of constant token */
FILE						*hFile_G;			/* current file */
BOOL						fAbandonNumberLengthLimits;

/***************************************************************************
 *		external data
 ***************************************************************************/
extern short				DebugLine;
extern NFA_INFO				*pImportCntrl;
extern LexTable 	*		pMidlLexTable;
extern short				CompileMode;
extern SymTable		*		pBaseSymTbl;
extern CMD_ARG		*		pCommand;
extern ccontrol		*		pCompiler;
extern char					LastLexChar;

/***************************************************************************
 *		external procedures
 ***************************************************************************/

token_t						is_keyword( char *, short);


/***************************************************************************/

const extern short st[ 13 ][ 16 ];
const extern short ct[256];

// Used to disable identifier to keyword mapping for declspec parsing. 
BOOL                        IdToKeywordMapping = TRUE;

#define __isdigit(c)      (((c) >= '0' && (c) <= '9'))

token_t cnv_int(void)
{
    LastLexChar = NewCCGetch();
    int chBeyond = NewCCGetch();
    NewCCputbackc((char)chBeyond);

    if( LastLexChar == '.' && chBeyond!= '.')
        {
        STATUS_T	Status			= STATUS_OK;
        short		LengthCollected	= (short)strlen(tokptr_G);
        char	*	ptr				= &tokptr_G[LengthCollected];

        char ch	= LastLexChar;

        *ptr++ = ch;
        *ptr++ = ch	= NewCCGetch();
        if (__isdigit(ch))
            {
            *ptr++ = ch	= NewCCGetch();
            while (__isdigit(ch))
                {
                *ptr++ = ch	= NewCCGetch();
                }
            if (ch == 'e' || ch == 'E')
                {
                *ptr++ = ch	= NewCCGetch();
                if (ch == '-' || ch == '+')
                    {
                    *ptr++ = ch	= NewCCGetch();
                    if (__isdigit(ch))
                        {
                        *ptr++ = ch	= NewCCGetch();
                        while (__isdigit(ch))
                            {
                            *ptr++ = ch	= NewCCGetch();
                            }
                        }
                    else
                        {
                        Status = ERROR_PARSING_NUMERICAL;
                        }
                    }
                else if (__isdigit(ch))
                    {
                    *ptr++ = ch	= NewCCGetch();
                    while (__isdigit(ch))
                        {
                        *ptr++ = ch	= NewCCGetch();
                        }
                    }
                }
            }
        else
            {
            Status = ERROR_PARSING_NUMERICAL;
            }

        if (Status != STATUS_OK)
            {
            ParseError( Status, (char *)0 );
            exit( Status );
            }

        *ptr = 0;
        token_t tokenType = DOUBLECONSTANT;
        double d = atof(tokptr_G);

        if (ch != 'l' && ch != 'L')
            {
            NewCCputbackc(ch);
            *(ptr-1) = 0;
            tokenType = unsigned short( (d < FLT_MAX || d > FLT_MIN) ? FLOATCONSTANT : DOUBLECONSTANT );
            }
        else
            {
            NewCCputbackc(NewCCGetch());
            }
        
        if ( tokenType == DOUBLECONSTANT )
            {
	        yylval.yy_numeric.dVal = d;
           }
        else
            {
	        yylval.yy_numeric.fVal = (float) d;
            }

	    yylval.yy_numeric.pValStr = pMidlLexTable->LexInsert(tokptr_G);
        return tokenType;
        }
    else
        {
	    token_t	Tok	= NUMERICCONSTANT;
	    yylval.yy_numeric.pValStr = pMidlLexTable->LexInsert(tokptr_G);
	    yylval.yy_numeric.Val = tokval_G = convert(tokptr_G, 10, MAX_DECIMAL_LENGTH );

	    if( (LastLexChar == 'L') || (LastLexChar == 'l'))
    		{
		    Tok = NUMERICLONGCONSTANT;
		    }
	    else
    		{
	    	if( (LastLexChar == 'U') || (LastLexChar == 'u'))
		    	{
			    Tok = NUMERICULONGCONSTANT;
			    if( ((LastLexChar = NewCCGetch()) != 'L') && (LastLexChar != 'l'))
				    {
				    NewCCputbackc(LastLexChar);
				    Tok = NUMERICUCONSTANT;
				    }
			    }
		    else
    			{
        	    NewCCputbackc( LastLexChar );
		        return NUMERICCONSTANT;
			    }
		    }
        return Tok;
        }
}

token_t cnv_hex(void)
{
	token_t Tok = HEXCONSTANT;
	unsigned long Val;

	yylval.yy_numeric.pValStr = pMidlLexTable->LexInsert(tokptr_G);
	tokptr_G += 2;	/* skip 0x */
	Val = yylval.yy_numeric.Val = tokval_G = convert(tokptr_G, 16, MAX_HEX_LENGTH);
	tokptr_G -= 2;	

	LastLexChar = NewCCGetch();

	if( (LastLexChar == 'L') || (LastLexChar == 'l'))
		{
		Tok = HEXLONGCONSTANT;
		}
	else
		{
//		LastLexChar = NewCCGetch();

		if( (LastLexChar == 'U') || (LastLexChar == 'u'))
			{
			Tok = HEXULONGCONSTANT;
			if( ((LastLexChar = NewCCGetch()) != 'L') && (LastLexChar != 'l'))
				{
				NewCCputbackc(LastLexChar);
				Tok = HEXUCONSTANT;
				}
			}
		else
			{
			NewCCputbackc(LastLexChar);
				return HEXCONSTANT;
			}
		}
    return Tok;
}

token_t cnv_octal(void)
{
	token_t	Tok	= OCTALCONSTANT;
	unsigned long Val;

	yylval.yy_numeric.pValStr = pMidlLexTable->LexInsert(tokptr_G);
	Val = yylval.yy_numeric.Val = tokval_G = convert(tokptr_G, 8, MAX_OCTAL_LENGTH);

	LastLexChar = NewCCGetch();

	if( (LastLexChar == 'L') || (LastLexChar == 'l'))
		{
		Tok = OCTALLONGCONSTANT;
		}
	else
		{
//		LastLexChar = NewCCGetch();

		if( (LastLexChar == 'U') || (LastLexChar == 'u'))
			{
			Tok = OCTALULONGCONSTANT;
			if( ((LastLexChar = NewCCGetch()) != 'L') && (LastLexChar != 'l'))
				{
				NewCCputbackc(LastLexChar);
				Tok = OCTALUCONSTANT;
				}
			}
		else
			{
			NewCCputbackc(LastLexChar);
			return OCTALCONSTANT;
			}
		}

    return Tok;
}

token_t cnv_float(void)
{
	warning("floating point constants not allowed");
	yylval.yy_numeric.Val = tokval_G = 0;
	lex_error(101);
	yylval.yy_numeric.pValStr = pMidlLexTable->LexInsert(tokptr_G);
    return NUMERICCONSTANT;
}

long convert(char *ptr, short base, short MaxSize)
{
	REG	long	answer = 0;
	REG	char	ch;
	BOOL		fZeroIsNotALeadingZeroAnymore = FALSE;
		short count = 0;

	while ((ch = *ptr++) != 0)
		 {
		if ((ch & 0x5f) >= 'A')
			answer = answer * base + (ch & 0x5f) - 'A'+ 10;
		else
			answer = answer * base + ch - '0';

		if( ch == '0')
			{
			if( fZeroIsNotALeadingZeroAnymore )
				count++;
			}
		else
			{
			fZeroIsNotALeadingZeroAnymore = TRUE;
			count++;
			}
		}

	if( ( count > MaxSize ) && !fAbandonNumberLengthLimits )
		{
		ParseError( CONSTANT_TOO_BIG, (char *)NULL );
		}

	return answer;
}

void SkipToToken(token_t token)
{
    token_t NextToken;
    do {
        NextToken = GetNextToken();
    } while( ( token != NextToken) && (EOI != NextToken) );
}

MODIFIER_SET ParseUnknownDeclSpecItem(char *pIdentifier)
{

    INITIALIZED_MODIFIER_SET ModifierSet;
    unsigned long Level = 0;

    char AppendTxt[512];
    unsigned int CurChar = 0;

    memset( AppendTxt, '\0', sizeof(AppendTxt) );

    const unsigned int MaxCurChar = 512 - 1 - sizeof(')') - sizeof(' ') - sizeof('\0');

    char ch;
    short ci;
    for(;;) // skip white space
        {
        ci = ct[ (unsigned char)(ch = NewCCGetch()) ];
        if (0 == st[ 0 ][ ci & 0x00ff ])
		    {
     		AppendTxt[CurChar++] = ch;
            if ( CurChar >= MaxCurChar )
			    {
                ParseError(SYNTAX_ERROR, "Invalid _declspec");
                return ModifierSet;
                }
            }       
        else 
			break;
		}
      
    if ('(' == ch) 
        {
        // identifier(...) form
        Level++;
        AppendTxt[CurChar++] = '(';

        do
            {
            ch = NewCCGetch();
            switch(ch)
                {
                case 0:
                    //end of file
                    goto Exit;
                case '(':
                    Level++;
                    break;
                case ')':
                    Level--;
                    break;
                }

            AppendTxt[CurChar++] = ch;
            if ( CurChar >= MaxCurChar )
                {
                ParseError(SYNTAX_ERROR, "Invalid _declspec");
                return ModifierSet;
                }

            }
        while ( Level );
        

        }

    else
        {
        NewCCputbackc(ch);
        }
    
    Exit:   
    
    AppendTxt[CurChar++] = ')';
    AppendTxt[CurChar++] = ' ';    
    size_t StringLength = sizeof("__declspec(") + strlen(pIdentifier) + CurChar + sizeof('\0');
    char *UnknownDeclspec = new char[StringLength];
    strcpy( UnknownDeclspec, "__declspec(");
    strcat( UnknownDeclspec, pIdentifier );
    strcat( UnknownDeclspec, AppendTxt);
    ModifierSet.SetDeclspecUnknown( UnknownDeclspec );
    delete[] UnknownDeclspec;

    return ModifierSet;
    
}

#pragma warning(push)
#pragma warning( disable : 4244 ) // disable long to short conversion warning

MODIFIER_SET ParseDeclSpecAlign()
{

    unsigned short AlignmentValue = 8;
    
    toktyp_G = GetNextToken();

    if (toktyp_G != '(')
        {
        ParseError( BENIGN_SYNTAX_ERROR, "( expected after _declspec( align");
        UngetToken(toktyp_G);
        goto exit;
        }

    toktyp_G = GetNextToken();

    switch(toktyp_G) 
        {
        case NUMERICCONSTANT:
        case NUMERICLONGCONSTANT:
        case HEXCONSTANT:
        case HEXLONGCONSTANT:
        case OCTALCONSTANT:
        case OCTALLONGCONSTANT:
        case NUMERICUCONSTANT:
        case NUMERICULONGCONSTANT:
        case HEXUCONSTANT:
        case HEXULONGCONSTANT:
        case OCTALUCONSTANT:
        case OCTALULONGCONSTANT:
            break; //valid case 

        default:
            ParseError( MSCDECL_INVALID_ALIGN, NULL);
            SkipToToken(')');
            goto exit;
        }

    //Check if value is nonzero power of 2 <= 8192
    switch((long)tokval_G)
        {
        case 1:
        case 2:
        case 4:
        case 8:
        case 16:
        case 32:
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
            AlignmentValue = (unsigned short)tokval_G;
            break; //valid case
        default:
            ParseError( MSCDECL_INVALID_ALIGN, NULL);
            AlignmentValue = 8;
            break;
        }      

    toktyp_G = GetNextToken();

    if (toktyp_G != ')')
        {
        ParseError( BENIGN_SYNTAX_ERROR, ") expected to follow _declspec(align(N \n");        
        SkipToToken(')');
        }

exit:
    INITIALIZED_MODIFIER_SET ModifierSet;
    ModifierSet.SetDeclspecAlign(AlignmentValue);
    ParseError( BENIGN_SYNTAX_ERROR, "_declspec(align()) is not supported." );
    return ModifierSet;
}

#pragma warning(pop)

token_t ParseDeclSpec() 
{
  /* Parses the MS_VC declspec() syntax.
     syntax: _declspec(declspeclist )        
            declspeclist:  declspecitemlist declspecitem |
                           declspecitem                  |
                           nothing
                        
            declspecitem:  identifier |
                           identifier(...)
  */
  
  token_t LParen = GetNextToken();
  if ('(' != LParen)
      {
      ParseError( BENIGN_SYNTAX_ERROR, "( expected after _declspec");
      return LParen;
      }

  // Disable ID to keyword mapping.

  BOOL OldIdToKeywordMapping = IdToKeywordMapping;
  IdToKeywordMapping = FALSE;

  INITIALIZED_MODIFIER_SET ModifierSet;

  for(;;) 
      {
      // VC skips comma, so we skip commas.
      while(',' == (toktyp_G = GetNextToken()));
   
      if (')' == toktyp_G)
          {
          break;
          }

      if (IDENTIFIER == toktyp_G || TYPENAME == toktyp_G || LIBNAME == toktyp_G)
          {
          if (strcmp( tokptr_G, "dllimport") == 0)
              {
              ModifierSet.SetModifier(ATTR_DLLIMPORT);
              }
          else if (strcmp( tokptr_G, "dllexport") == 0)
              {
              ModifierSet.SetModifier(ATTR_DLLEXPORT);
              }
          else if (strcmp( tokptr_G, "align") == 0)
              {
              ModifierSet.Merge(ParseDeclSpecAlign());
              }
          else 
              {
              ModifierSet.Merge(ParseUnknownDeclSpecItem(tokptr_G));
              }
          }
      else 
          {
          ParseError( BENIGN_SYNTAX_ERROR, "Invalid _declspec" );
          SkipToToken(')');
          break;
          }
      }

  IdToKeywordMapping = OldIdToKeywordMapping;

  yylval.yy_modifiers = ModifierSet;
  return (toktyp_G = KWMSCDECLSPEC);
}

const extern short ct[256];
const extern short st[13][16];

token_t name(void)
{
    /* have received a name from the input file,  first we */
    /* check to see if it is a keyword. */

	short	InBracket	= short( inside_rpc ? INBRACKET : 0 );

    if ( IdToKeywordMapping )
        toktyp_G = is_keyword(tokptr_G, InBracket);
    else 
		toktyp_G = IDENTIFIER;

    if (KWMSCDECLSPEC == toktyp_G)
    {
        return ParseDeclSpec();
    }

    if( KWSAFEARRAY == toktyp_G)
    {
        /* SAFEARRAY is a special case
         * In order to correctly parse the ODL SAFEARRAY syntax:
         *      SAFEARRAY ( FOO * ) BAR;
         * we look ahead at the next non white space character
         * to see if it's an open parenthasis.  If it is then we eat
         * the character and return KWSAFEARRAY, otherwise we
         * put the character back into the stream and return the
         * string "SAFEARRAY" as an IDENTIFIER.
         */
        char ch;
        short ci;
        do
            ci = ct[ (unsigned char)(ch = NewCCGetch()) ];
        while (0 == st[ 0 ][ ci & 0x00ff ]);  /* skip white space */
        if ('(' != ch)
        {
            NewCCputbackc(ch);
            toktyp_G = IDENTIFIER;
        }
    }

	if (toktyp_G == IDENTIFIER)
		{
		if( strlen( tokptr_G ) > MAX_ID_LENGTH )
			{
			ParseError( ID_TRUNCATED, tokptr_G );
//				tokptr_G[ MAX_ID_LENGTH ] = '\0'; // dont truncate
			}

        /* We need to know if the identifier is followed by a period.
         * If it is, it may be a library name and so we need to check
         * the libary name table to see if we should return LIBNAME
         * instead of TYPENAME or IDENTIFIER.
         * We look ahead to the next non white space character as above;
         * the difference being that we do not consume the non whitespace
         * character as we would for "SAFEARRAY(".
         */
        char ch;
        short ci;
        do
            ci = ct[ (unsigned char)(ch = NewCCGetch()) ];
        while (0 == st[ 0 ][ ci & 0x00ff ]);  /* skip white space */
        NewCCputbackc(ch);
        if( '.' == ch )
            {
            // we need to check to see if the identifier is a library name
            if (FIsLibraryName(tokptr_G))
                {
                toktyp_G = LIBNAME;
                yylval.yy_pSymName = new char [toklen_G + 1];
                strcpy(yylval.yy_pSymName, tokptr_G);
                return toktyp_G;
                }
            }
        /* Check the symbol table to see if the identifier
         * is a TYPENAME.
         */
#ifdef unique_lextable
		// all names go in the lex table -- this is important for the symtable search
		yylval.yy_pSymName = pMidlLexTable->LexInsert(tokptr_G);

		// see if the name corresponds to a base level typedef
		SymKey	SKey( yylval.yy_pSymName, NAME_DEF );

		if( pBaseSymTbl->SymSearch( SKey ) )
			{
			toktyp_G = TYPENAME;
			}
		}
#else // unique_lextable
		// see if the name corresponds to a base level typedef
		SymKey			SKey( tokptr_G, NAME_DEF );
		named_node	*	pNode;

		if ( ( pNode = pBaseSymTbl->SymSearch( SKey ) ) != 0 )
			{
            char * szTemp = new char[toklen_G + 1];
            strcpy(szTemp, tokptr_G);
			pNode->SetCurrentSpelling(szTemp);
			toktyp_G = TYPENAME;
            yylval.yy_graph = pNode;
            }
		else
			{
			yylval.yy_pSymName = pMidlLexTable->LexInsert(tokptr_G);
			}

		}
#endif // unique_lextable

	return toktyp_G;
}

void lex_error(int number)
{
	printf("lex error : %d\n", number);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\front\makefile.inc ===
# Copyright (c) 1993-1999 Microsoft Corporation

!ifndef		MIDLTOOLS
YACC	= midlyacc.exe
PREGRAM	= midlpg.exe
EBASE	= midleb.exe
!else	#	MIDLTOOLS
YACC	= $(MIDLTOOLS)\yacc\midlyacc.exe
PREGRAM	= $(MIDLTOOLS)\pg\midlpg.exe
EBASE	= $(MIDLTOOLS)\erec\obj\os2\midleb.exe
!endif	#	MIDLTOOLS

TARGETS=$(O)\grammar.cxx \
        $(O)\acfgram.cxx

grammars: $(TARGETS)

.SUFFIXES: .y .c

{.}.y{$(O)}.y:
	copy $? $(O)

{.}.c{$(O)}.c:
	copy $? $(O)

$(O)\grammar.cxx : $(O)\grammar.y xlatidl.dat $(O)\yypars.c makefile.inc
    cd $(O)
    
    $(YACC) -his -t "YYCONST " grammar.y
    findstr -v /c:"#line " grammar.c > grammar.tmp
    erase grammar.c
    $(PREGRAM) grammar.tmp > grammar.cxx
    erase grammar.tmp
    $(EBASE) - ..\..\xlatidl.dat IDL > idlerec.h
    
    cd ..\..

$(O)\acfgram.cxx : $(O)\acfgram.y xlatacf.dat yypars.c makefile.inc
    cd $(O)
     
    $(YACC) -his -t "YYCONST " acfgram.y
    findstr -v /c:"#line " acfgram.c > acfgram.tmp
    erase acfgram.c
    $(PREGRAM) acfgram.tmp > acfgram.cxx
    erase acfgram.tmp
    $(EBASE) - ..\..\xlatacf.dat ACF > acferec.h
    
    cd ..\..
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\front\main.cxx ===
/**                        Microsoft LAN Manager                            **/
/**                Copyright(c) Microsoft Corp., 1987-1999                  **/
/*****************************************************************************/
/*****************************************************************************
File                : main.cxx
Title                : compiler controller object management routines
History                :
    05-Aug-1991    VibhasC    Created

*****************************************************************************/

#if 0
                        Notes
                        -----
This file provides the entry point for the MIDL compiler. The main routine
creates the compiler controller object, which in turn fans out control to
the various passes of the compiler.

#endif // 0

#pragma warning ( disable : 4514 )

/****************************************************************************
 includes
 ****************************************************************************/

#include "nulldefs.h"
extern    "C"    {
    #include <stdio.h>
    #include <stdlib.h>
    #include <malloc.h>
    #include <excpt.h>
    #include <process.h>
    #include <io.h>
    #include <fcntl.h>
    #include <sys/types.h>
    #include <sys/stat.h>
}

#include "allnodes.hxx"
#include "cmdana.hxx"
#include "filehndl.hxx"
#include "lextable.hxx"
#include "control.hxx"
#include "idict.hxx"
#include "Pragma.hxx"
#include "midlvers.h"
extern unsigned long BackAllocation;
extern unsigned long				Skl_Bytes;

#define MAX_LEX_STRINGS (1000)
#define MIDL_LEX_TABLE_SIZE (unsigned long)(1 * MAX_LEX_STRINGS)

#ifdef MIDL_INTERNAL
#define MIDL_FREE_BUILD  0
#define MIDL_INTERNAL_PRINTF(x)  printf(x)  
#else
#define MIDL_FREE_BUILD  1
#define MIDL_INTERNAL_PRINTF(x)  
#endif

/****************************************************************************
    extern procedures
 ****************************************************************************/
extern void                 Test();
extern STATUS_T             MIDL_4();
extern void                 CGMain( node_skl    *    pNode );
extern void                 Ndr64CGMain( node_skl    *    pNode );


/****************************************************************************
    extern data
 ****************************************************************************/
extern unsigned long        TotalAllocation;
extern CCONTROL          *  pCompiler;
extern NFA_INFO          *  pImportCntrl;
extern LexTable          *  pMidlLexTable;
extern PASS_1            *  pPass1;
extern PASS_2            *  pPass2;
extern PASS_3            *  pPass3;
extern CMD_ARG           *  pCommand;
extern node_source       *  pSourceNode;
extern BOOL                 fNoLogo;
extern CMessageNumberList   GlobalMainMessageNumberList;

/****************************************************************************
    extern functions
 ****************************************************************************/

extern    void              print_memstats();
extern    void              print_typegraph();

/****************************************************************************
    local data
 ****************************************************************************/

#define szVerName    ""


const char *pSignon1 = "Microsoft (R) 32b/64b MIDL Compiler Engine Version %s " szVerName " " "\n";
const char *pSignon2 = "Copyright (c) Microsoft Corporation 1991-2002. All rights reserved.\n";

/****************************************************************************/

void
DumpArgs(
    int         argc,
    char    *   argv[],
    char *      Comment )
{
    printf("Dumping args %s\n", Comment );

    for (int i = 0; i < argc  &&  argv[i]; i++ )
        printf("  %s\n", argv[i] );
}



/****************************************************************************

    Read the command file into a in-memory buffer.

    The pointer returned is a pointer to the contents of the command file.
    To aid debugging the size of the file is tucked away just in front of it.
 ****************************************************************************/

char * ReadCommandFile(const char *pszFilename)
{
    int             fileCmd = -1;
    struct _stat    filestat = {0};
    char           *Buffer = NULL;
    int             bytesread;

    fileCmd = _open( pszFilename, _O_BINARY | _O_RDONLY | _O_SEQUENTIAL );

    if ( -1 == fileCmd )
        goto Error;

    if ( -1 == _fstat( fileCmd, &filestat ) )
        goto Error;

    Buffer = new char[filestat.st_size + sizeof(filestat.st_size)];

    // Tuck away the size of the buffer to make debugging easier

    * (_off_t *) Buffer = filestat.st_size;
    Buffer += sizeof( _off_t );

    bytesread = _read( fileCmd, Buffer, filestat.st_size );

    if ( bytesread != filestat.st_size )
        goto Error;

    _close(fileCmd);

    return Buffer;

Error:

    if (NULL != Buffer)
        delete [] (Buffer - sizeof(_off_t));

    if (-1 != fileCmd )
        _close( fileCmd );

    char message[1024];
    sprintf(message, ": %s (%s)", _strerror(NULL), pszFilename);

    // _strerror embeds a newline in the error string, get rid of it
    * ( strchr( message, '\n') ) = ' ';

    RpcError( 0, 0, UNABLE_TO_OPEN_CMD_FILE, message );

    return NULL;
}



/****************************************************************************

    If the command file is corrupt do a hex dump of (up to) the first 
    256 bytes of the file to aid in finding out what whacked it.

    REVIEW: This was intended to be a temporary feature.  It may be useful
             to just leave it in.

 ****************************************************************************/

void HexDumpCommandFile(char *buffer)
{
    _off_t  length = * (_off_t *) (buffer - sizeof(_off_t));
    _off_t  bytes = 0;

    for (int i = 0; i < 16 && bytes < length; i++)
        {
        printf("%02x: ", i * 16);

        for ( int j = 0; j < 16 && bytes < length; j++)
            {
            printf( "%02x ", buffer[i*16+j] );
            ++bytes;
            }

        for ( int k = j; k < 16; k++ )
            printf("   ");

        for ( int l = 0; l < j; l++ )
            if ( iscntrl( buffer[i*16+l] ) )
                putchar( '.' );
            else
                putchar( buffer[i*16+l] );

        printf("\n");
        }                
}



/****************************************************************************

  If this is a fre build and the -debugexc switch is *not* present then
  catch any exceptions and shutdown MIDL at least semi-gracefully.  Otherwise
  allow the system to throw up a popup / enter a debugger / etc to make
  debugging easier.

  In any case print a message saying that something bad happened.
    
 ****************************************************************************/

int FilterException()
{
    printf( "\nmidl : error MIDL%d : internal compiler problem -",
            I_ERR_UNEXPECTED_INTERNAL_PROBLEM );
    printf( " See documentation for suggestions on how to find a workaround.\n" );

#if MIDL_FREE_BUILD
    if ( ! pCommand->IsSwitchDefined( SWITCH_DEBUGEXC ) )
        return EXCEPTION_EXECUTE_HANDLER;
#endif

    return EXCEPTION_CONTINUE_SEARCH;
}



int
main    (
        int     argc,
        char*   argv[]
        )
    {
    STATUS_T Status = UNABLE_TO_OPEN_CMD_FILE;

    pCommand = new CMD_ARG;

    __try
        {

        if ( argc  != 2 )
            {
            char szCompilerVersion[32];
            Status = NO_INTERMEDIATE_FILE;
            sprintf( szCompilerVersion, "%d.%02d.%04d", rmj, rmm, rup );
            fprintf( stderr, pSignon1, szCompilerVersion );
            fprintf( stderr, pSignon2 );
            fflush( stderr );
            RpcError( 0, 0, Status, 0 );
            }
        else
            {
            char *Buffer;

            Buffer = ReadCommandFile( argv[1] );

            if ( NULL != Buffer )
                Status = pCommand->StreamIn( Buffer );

            switch (Status)
                {
                case STATUS_OK:
                    pCompiler = new ccontrol( pCommand );    
                    Status = pCompiler->Go();
                    break;

                case BAD_CMD_FILE:
                    RpcError( 0, 0, Status, argv[1] );
                    HexDumpCommandFile( Buffer );
                    break;

                case UNABLE_TO_OPEN_CMD_FILE:
                    // This should have been reported in ReadCommandFile
                    break;      

                default:
                    RpcError( 0, 0, Status, NULL );
                }

            if ( NULL != Buffer )
                {
                // The buffer was biased by it's size to make debugging easier.
                delete [] (Buffer - sizeof(_off_t));
                }
            }
        }
    __except( FilterException() )
        {
        // The real work is done in FilterException
        Status = (STATUS_T) GetExceptionCode();
        }

    return Status;
    }

/****************************************************************************
 ccontrol:
    the constructor
 ****************************************************************************/
ccontrol::ccontrol( CMD_ARG* pCommand )
    {
    // initialize
    ErrorCount = 0;
    pCompiler  = this;

    // set up the command processor
    SetCommandProcessor( pCommand );

    // set up the lexeme table
    pMidlLexTable = new LexTable( (size_t )MIDL_LEX_TABLE_SIZE );
    }


_inline void
DumpStatsTypeGraph()
{
#ifdef MIDL_INTERNAL

    if((pCompiler->GetCommandProcessor())->IsSwitchDefined( SWITCH_DUMP ) )
        {
        print_memstats();
        print_typegraph();
        };
#endif
}


/****************************************************************************
 go:
    the actual compiler execution
 ****************************************************************************/

STATUS_T
ccontrol::Go()
    {
    STATUS_T   Status = STATUS_OK;

    pPass1 = new PASS_1;
    if( (Status = pPass1->Go() ) == STATUS_OK )
        {

        MIDL_INTERNAL_PRINTF( "starting ACF pass\n" );

        pPass2    = new PASS_2;
        if( (Status = pPass2->Go() ) == STATUS_OK )
            {
            // DumpStatsTypeGraph();

            MIDL_INTERNAL_PRINTF( "starting Semantic pass\n" );

//      allow midl_pragma warning (disable:) here.
//            GlobalMainMessageNumberList.SetAll();
            pPass3 = new PASS_3;
            if ( ( (Status = pPass3->Go() ) == STATUS_OK )
#ifdef MIDL_INTERNAL
                 || pCommand->IsSwitchDefined( SWITCH_OVERRIDE )     
#endif // MIDL_INTERNAL
                                    )
                {
                DumpStatsTypeGraph();

                // Complain if the user used -wire_compat.  Put it here so
                // that they can turn it off with midl_pragma if they want to.

                if ( pCommand->IsSwitchDefined( SWITCH_WIRE_COMPAT ) )
                    RpcError( NULL, 0, WIRE_COMPAT_WARNING, NULL );

                //UseBackEndHeap();
#ifndef NOBACKEND
                if( !pCommand->IsSwitchDefined( SWITCH_SYNTAX_CHECK ) &&
                    !pCommand->IsSwitchDefined( SWITCH_ZS ) &&
                    pCommand->NeedsNDRRun() )
                    {
                    MIDL_INTERNAL_PRINTF( "starting codegen pass\n");
                    pCommand->SetIsNDRRun();

//                    GlobalMainMessageNumberList.SetAll();
                    CGMain( pSourceNode );

                    pCommand->ResetIsNDRRun();
#endif // NOBACKEND
                    }
                //DestroyBackEndHeap();



                // BUGBUG: for now assume NDR is always the first, unless in ndr64 only case.

                if (pCommand->NeedsNDR64Run() )
                    {
                    //UseBackEndHeap();

                    pCommand->SetIsNDR64Run();
                    if ( pCommand->NeedsNDRRun() )
                        pCommand->SetIs2ndCodegenRun();
                        
                    GlobalMainMessageNumberList.SetAll();
                    Ndr64CGMain( pSourceNode );

                    //DestroyBackEndHeap();
                    }
                    
                }

            }
        }

#ifdef DEBUG
    printf("front end %d , back end %d, other %d \n",Skl_Bytes,BackAllocation,TotalAllocation);
#endif
    if((pCompiler->GetCommandProcessor())->IsSwitchDefined( SWITCH_DUMP ) )
        {
        print_memstats();
        // print_typegraph();
        }

      return Status;
    }


void
IncrementErrorCount()
    {
    if ( pCompiler )
        pCompiler->IncrementErrorCount();
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\front\pass3.cxx ===
/*****************************************************************************/
/**						Microsoft LAN Manager								**/
/**				Copyright(c) Microsoft Corp., 1987-1999						**/
/*****************************************************************************/
/*****************************************************************************
File				: pass3.cxx
Title				: pass3 controller
History				:
	24-Sep-1993	GregJen Created

*****************************************************************************/

#if 0
						Notes
						-----
This file provides the interface for the semantic analysis pass. It also
initializes the pass3 controller object.

#endif // 0

#pragma warning ( disable : 4514 )

/****************************************************************************
 includes
 ****************************************************************************/

#include "nulldefs.h"
extern	"C"	{
	#include <stdio.h>
	#include <stdlib.h>
	#include <malloc.h>
	extern int yyacfparse();
}

#include "allnodes.hxx"
#include "control.hxx"
#include "cmdana.hxx"
#include "filehndl.hxx"
#include "idict.hxx"
#include "semantic.hxx"

/****************************************************************************
	local definitions
 ****************************************************************************/


/****************************************************************************
	extern procedures
 ****************************************************************************/


/****************************************************************************
	extern data 
 ****************************************************************************/

extern class ccontrol		*	pCompiler;
extern node_source			*	pSourceNode;
extern CMD_ARG				*	pCommand;

/****************************************************************************
	local data
 ****************************************************************************/


/****************************************************************************/


_pass3::_pass3()
	{
	
	pCompiler->SetPassNumber( SEMANTIC_PASS );
	}

STATUS_T
_pass3::Go()
	{
	MEM_ITER			MemIter( pSourceNode );
	node_file		*	pFNode;

	// turn off line number additions
	FileIndex = 0;

	/**
	 ** for each idl file, check semantics of all interfaces.
	 **/

	while ( ( pFNode = (node_file *) MemIter.GetNext() ) != 0 )
		{
				SEM_ANALYSIS_CTXT		FileSemAnalysis(pSourceNode);

				pFNode->SemanticAnalysis( &FileSemAnalysis );
		}

    // last check if we have incorrect target combination
    if (pCompiler->GetErrorCount() == 0 )
    	pCommand->VerifyTargetSwitch();

	// terminate compilation if we found errors
	return (pCompiler->GetErrorCount()) ? ERRORS_PASS1_NO_PASS2 : STATUS_OK;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\front\nodeskl.cxx ===
/*****************************************************************************/
/**                     Microsoft LAN Manager                               **/
/**             Copyright(c) Microsoft Corp., 1987-1999                     **/
/*****************************************************************************/
/*****************************************************************************
File                : nodeskl.cxx
Title               : skeletal node build routines
History             :
    04-Aug-1991 VibhasC Created

*****************************************************************************/

#pragma warning ( disable : 4514 )

/****************************************************************************
 local defines and includes
 ****************************************************************************/

#include "nulldefs.h"
extern  "C"
    {
    #include <stdio.h>
    
    #include <string.h>
    }

#include "allnodes.hxx"
#include "gramutil.hxx"
#include "cmdana.hxx"
#include "attrnode.hxx"
#include "ndrtypes.h"
#include "lextable.hxx"
#include "control.hxx"

inline
unsigned short ComputeAlignmentForZP( unsigned short Align, unsigned short ZeePee, BOOL IsMustAlign)
{
    return ((Align > ZeePee) && !IsMustAlign) ? ZeePee : Align;
}

inline
unsigned long RoundToAlignment( unsigned long Size, unsigned short Align)
{
    Align--;
    return (Size + Align) & ~Align; 
}

/****************************************************************************
 external data
 ****************************************************************************/

extern CMD_ARG                  *   pCommand;
extern node_e_attr              *   pErrorAttrNode;
extern node_error               *   pErrorTypeNode;
extern SymTable                 *   pBaseSymTbl;
extern IDICT                    *   pInterfaceDict;
extern ISTACK                   *   pZpStack;
extern LexTable                 *   pMidlLexTable;
extern CCONTROL                 *   pCompiler;

/****************************************************************************
 external procs
 ****************************************************************************/

extern BOOL                         IsTempName( char * );
extern void                         ParseError( STATUS_T, char * );
/****************************************************************************/


void
MEMLIST::SetMembers( class SIBLING_LIST & MEMLIST )
    {
    pMembers = MEMLIST.Linearize();
    }

void
MEMLIST::MergeMembersToTail( class SIBLING_LIST & MEMLIST )
    {
    AddLastMember( MEMLIST.Linearize() );
    }

STATUS_T
MEMLIST::GetMembers( class type_node_list * MEMLIST )
    {
    named_node      *   pCur     = pMembers;

    while ( pCur )
        {
        MEMLIST->SetPeer( pCur );
        pCur = pCur->GetSibling();
        }

    return (pMembers)? STATUS_OK: I_ERR_NO_MEMBER;
    };

short
MEMLIST::GetNumberOfArguments()
    {
    short           count   = 0;
    named_node  *   pNext   = pMembers;

    while ( pNext )
        {
        count++;
        pNext = pNext->GetSibling();
        };

    return count;
    };

// add a new member onto the very tail
void            
MEMLIST::AddLastMember( named_node * pNode )
{
    named_node  *   pPrev   = NULL;
    named_node  *   pCur    = pMembers;

    while ( pCur )
        {
        pPrev   = pCur;
        pCur    = pCur->GetSibling();
        }

    // pPrev is now null (empty list) or points to last element of list
    if ( pPrev )
        {
        pPrev->SetSibling( pNode );
        }
    else
        {
        pMembers = pNode;
        }

}


// Remove the last member from the tail
void            
MEMLIST::RemoveLastMember()
{
    named_node  *   pPrev   = NULL;
    named_node  *   pCur    = pMembers;

    while ( pCur && pCur->GetSibling() )
        {
        pPrev   = pCur;
        pCur    = pCur->GetSibling();
        }

    // pPrev is now null (empty list) or points to next to last element of list
    if ( pPrev )
        {
        pPrev->SetSibling( NULL);
        }

}

void            
MEMLIST::AddSecondMember( named_node * pNode )
{
    named_node* pFirst = (named_node*)GetFirstMember();

    if ( pFirst )
        {
        named_node* pSecond = pFirst->GetSibling();
        pFirst->SetSibling( pNode );
        pNode->SetSibling( pSecond );
        }
    else
        {
        pMembers = pNode;
        }

}

/****************************************************************************
 node_id:
    the private memory allocator
 ****************************************************************************/

// initialize the memory allocators for node_id and node_id_fe

FreeListMgr
node_id::MyFreeList( sizeof (node_id ) );

FreeListMgr
node_id_fe::MyFreeList( sizeof (node_id_fe ) );

FRONT_MEMORY_INFO
node_skl::AdjustMemoryInfoForModifiers(FRONT_MEMORY_INFO OrigInfo)
{
   if (!GetModifiers().IsModifierSet(ATTR_DECLSPEC_ALIGN))
       return OrigInfo;

   OrigInfo.IsMustAlign = TRUE;
   OrigInfo.Align = __max(OrigInfo.Align, GetModifiers().GetDeclspecAlign());

   return OrigInfo;
}

FRONT_MEMORY_INFO
node_skl::GetModifiedMemoryInfoFromChild()
{
    node_skl *pChild = GetChild();
    MIDL_ASSERT( pChild );
    return AdjustMemoryInfoForModifiers( pChild->GetMemoryInfo() );
}

FRONT_MEMORY_INFO
node_skl::GetInvalidMemoryInfo()
{
    return FRONT_MEMORY_INFO(0, 1, 0);
}

FRONT_MEMORY_INFO
node_enum::GetMemoryInfo()
{
    unsigned long EnumSize = pCommand->GetEnumSize();
    return AdjustMemoryInfoForModifiers( FRONT_MEMORY_INFO( EnumSize, (short)EnumSize, 0 ) ); 
}

FRONT_MEMORY_INFO 
node_pointer::GetMemoryInfo()
{
   unsigned long PointerSize = SIZEOF_MEM_PTR();
   return AdjustMemoryInfoForModifiers( FRONT_MEMORY_INFO( PointerSize, (short)PointerSize, 0 ) );
}

FRONT_MEMORY_INFO
node_safearray::GetMemoryInfo()
{
    unsigned long PointerSize = SIZEOF_MEM_PTR();
    return AdjustMemoryInfoForModifiers( FRONT_MEMORY_INFO( PointerSize, (short)PointerSize, 0 ) ); 
}

FRONT_MEMORY_INFO
node_union::GetMemoryInfo()
{

   // The size of a union is the size of the largest element rounded
   // to the largest alignment.   
    
   FRONT_MEMORY_INFO UnionSize(0, 1, 0);
   unsigned short    ZeePee = GetZeePee();
   MEM_ITER			 MemIter( this );
   node_skl       *  pNode;

   while ( ( pNode = MemIter.GetNext() ) != NULL )
   {
       FRONT_MEMORY_INFO TempSize = pNode->GetMemoryInfo();

       // Merge in the size of the new union arm.
       UnionSize.Size = __max(UnionSize.Size, TempSize.Size);
       UnionSize.Align = __max(UnionSize.Align, TempSize.Align);
       UnionSize.IsMustAlign = (UnionSize.IsMustAlign || TempSize.IsMustAlign);
   }

   // Add padding to end of union.
   UnionSize = AdjustMemoryInfoForModifiers(UnionSize);
   
   UnionSize.Align = ComputeAlignmentForZP( UnionSize.Align, ZeePee, UnionSize.IsMustAlign );
   UnionSize.Size = RoundToAlignment( UnionSize.Size, UnionSize.Align );

   return UnionSize;
}

FRONT_MEMORY_INFO
node_array::GetMemoryInfo()
{
    // The size of an array is the size of the array element times the element count.

    FRONT_MEMORY_INFO ArraySize = GetChild()->GetMemoryInfo();
    
    unsigned long ArrayElements;
    if ( pUpperBound && ( pUpperBound != (expr_node *) -1) )
        {

        ArrayElements = (ulong)pUpperBound->Evaluate();
        }
    else 
        {
        // A conformant array is not sized.
        ArrayElements = 0;
        }

    ArraySize.Size *= ArrayElements;

    return AdjustMemoryInfoForModifiers(ArraySize);
}


FRONT_MEMORY_INFO
node_struct::GetMemoryInfo()
{
    
    // The alignment of a structure is the largest alignment of all the members.
    // Each structure is aligned according to the following rules.
    // 1. If the field is a must align, the field is aligned to the Alignment.
    // 2. If the field is not a must align, the field is aligned to min(Zp, Alignment).


    MEM_ITER            MemIter( this );
    unsigned short ZeePee = GetZeePee();
    FRONT_MEMORY_INFO StructSize(0,1,0);
    node_skl          * pNode;

    while ( ( pNode = MemIter.GetNext() ) != 0 )
       {
       
       FRONT_MEMORY_INFO FieldSize = pNode->GetMemoryInfo();
       FieldSize.Align = ComputeAlignmentForZP( FieldSize.Align, ZeePee, FieldSize.IsMustAlign );

       StructSize.Size = RoundToAlignment( StructSize.Size, FieldSize.Align );

       // StructSize.Size now contains the offset of the field.
       
       // Merge in the attributes from the member
       StructSize.Size += FieldSize.Size;
       StructSize.Align = __max( FieldSize.Align, StructSize.Align );
       StructSize.IsMustAlign = ( StructSize.IsMustAlign || FieldSize.IsMustAlign );

       }

    // Add padding to end of structure.
    StructSize = AdjustMemoryInfoForModifiers( StructSize );

    StructSize.Align = ComputeAlignmentForZP( StructSize.Align, ZeePee, StructSize.IsMustAlign );
    StructSize.Size = RoundToAlignment( StructSize.Size, StructSize.Align );

    return StructSize;

}

FRONT_MEMORY_INFO
node_def::GetMemoryInfo()
{
  FRONT_MEMORY_INFO TypedefSize;
  node_represent_as *pRep = (node_represent_as *)GetAttribute(ATTR_REPRESENT_AS);
  node_user_marshal *pUserMarshall = (node_user_marshal *)GetAttribute(ATTR_USER_MARSHAL);
  node_cs_char      *pCSChar = (node_cs_char *) GetAttribute(ATTR_CSCHAR);

  if (!pUserMarshall && !pRep && !pCSChar)
      {
      // Just use the modified child sizes.
      return GetModifiedMemoryInfoFromChild();
      }

  if (pCSChar)
    {
    MIDL_ASSERT( NULL != pCSChar->GetUserType() );
    return AdjustMemoryInfoForModifiers( 
                        pCSChar->GetUserType()->GetMemoryInfo() );
    }

  // If both user_marshal and represent_as are specified, use represent_as and let semantic 
  // analysis flag the error.

  if (pUserMarshall)
      pRep = pUserMarshall;

  node_skl *pNode = pRep->GetRepresentationType();

  if (!pNode)
      {
          // unknown type. Use 0 as the size.
          TypedefSize.Init(0, 1, 0);
      }
  else 
      {
      TypedefSize = pNode->GetMemoryInfo();
      }

  return AdjustMemoryInfoForModifiers(TypedefSize);
}

FRONT_MEMORY_INFO
node_label::GetMemoryInfo()
{
    return AdjustMemoryInfoForModifiers( FRONT_MEMORY_INFO(sizeof(short), (short)sizeof(short), 0) ); 
}

FRONT_MEMORY_INFO
node_base_type::GetMemoryInfo()
{
    unsigned long size;

    switch( NodeKind() )
        {
        case NODE_FLOAT:    size = sizeof(float); break;
        case NODE_DOUBLE:   size = sizeof(double); break;
        case NODE_FLOAT80:  size = 16; break; //BUG, BUG double check once
                                              //VC supports this
        case NODE_FLOAT128: size = 16; break; 
        case NODE_HYPER:    size = sizeof(__int64); break;
        case NODE_INT64:    size = sizeof(__int64); break;
        case NODE_INT128:   size = 16; break;
        case NODE_INT3264:  size = SIZEOF_MEM_INT3264(); break;
        case NODE_INT32:    size = sizeof(long); break;
        case NODE_LONG:     size = sizeof(long); break;
        case NODE_LONGLONG: size = sizeof(LONGLONG); break;
        case NODE_SHORT:    size = sizeof(short); break;
        case NODE_INT:      size = sizeof(int); break;
        case NODE_SMALL:    size = sizeof(char); break;
        case NODE_CHAR:     size = sizeof(char); break;
        case NODE_BOOLEAN:  size = sizeof(char); break;
        case NODE_BYTE:     size = sizeof(char); break;
        case NODE_HANDLE_T: size = SIZEOF_MEM_PTR(); break;
        case NODE_VOID:     
             return AdjustMemoryInfoForModifiers(FRONT_MEMORY_INFO(0, 1, 0));
        default:
            size = 0;
            MIDL_ASSERT(0);
        }

    return AdjustMemoryInfoForModifiers(FRONT_MEMORY_INFO(size, (short)size, 0));
}

FRONT_MEMORY_INFO
node_href::GetMemoryInfo()
{
    node_skl *pChild = Resolve();
    MIDL_ASSERT(pChild);
    return AdjustMemoryInfoForModifiers(pChild->GetMemoryInfo());
}

/***************************************************************************
 GetBasicType:
    Get the basic type of the typenode
 ***************************************************************************/
node_skl *
node_skl::GetBasicType()
    {
    node_skl *  pChildPtr;

    switch( NodeKind() )
        {
        case NODE_STRUCT:
        case NODE_ENUM:
        case NODE_UNION:

            return this;

        case NODE_ID:

            return GetChild();

        default:
            if ( ( pChildPtr = GetChild() ) != 0 )
                {
                if ( pChildPtr->NodeKind() == NODE_DEF  ||  
                     pChildPtr->NodeKind() == NODE_FORWARD  || 
                     pChildPtr->NodeKind() == NODE_HREF )
                    return pChildPtr->GetBasicType();

                return pChildPtr;
                }
            return this;
        }
    }


/***************************************************************************
 GetMyInterfaceNode:
    Get the interface node for the typenode
 ***************************************************************************/
node_interface *
node_skl::GetMyInterfaceNode()
{
    return (node_interface *) pInterfaceDict->GetElement( IntfKey );
}


void
node_interface::ResetCGIfNecessary()
{
if ( !fIs2ndCodegen &&
     pCompiler->GetPassNumber() == NDR64_ILXLAT_PASS  )
     {
     fIs2ndCodegen = TRUE;
     SetCG(TRUE,NULL);
     SetCG(FALSE,NULL);
     }
}


node_file *
node_skl::GetDefiningFile()
{
    if (GetMyInterfaceNode())
        return GetMyInterfaceNode()->GetFileNode();
    else
        return NULL;
}

node_skl*
node_skl::GetDuplicateGuid  (
                            node_guid*  pGuid,
                            SymTable*   pUUIDTable
                            )
    {
    node_skl* pDuplicate = 0;

    if ( pGuid )
        {
        char * GuidStr = pGuid->GetGuidString();
        SymKey SKey(GuidStr, NAME_DEF);
        if ( !pUUIDTable->SymInsert( SKey, 0, (named_node*) this) )
            {
            pDuplicate = pUUIDTable->SymSearch( SKey );
            }
        }
    return ( pDuplicate == this ) ? 0 : pDuplicate;
    }

/*****************************************************************************
    utility functions
 *****************************************************************************/

BOOL
COMPARE_ATTR(
    ATTR_VECTOR &   A1,
    ATTR_VECTOR &   A2 )
    {
    int i;
    for( i = 0; i < MAX_ATTR_SUMMARY_ELEMENTS; ++i )
        {
        if( (A1[ i ] & A2[ i ] ) != A2[i] )
            return FALSE;
        }
    return TRUE;
    }

void
OR_ATTR(
    ATTR_VECTOR &   A1,
    ATTR_VECTOR &   A2 )
    {
    int i;
    for( i= 0; i < MAX_ATTR_SUMMARY_ELEMENTS; ++i )
        {
        A1[ i ] |= A2[ i ];
        }
    }
void
XOR_ATTR(
    ATTR_VECTOR &   A1,
    ATTR_VECTOR &   A2 )
    {
    int i;
    for( i= 0; i < MAX_ATTR_SUMMARY_ELEMENTS; ++i )
        {
        A1[ i ] ^= A2[ i ];
        }
    }
void
CLEAR_ATTR(
    ATTR_VECTOR &   A1 )
    {
    int i;
    for( i= 0; i < MAX_ATTR_SUMMARY_ELEMENTS; ++i )
        {
        A1[ i ] = 0;
        }
    }
void
SET_ALL_ATTR(
    ATTR_VECTOR &   A1 )
    {
    int i;
    for( i= 0; i < MAX_ATTR_SUMMARY_ELEMENTS; ++i )
        {
        A1[ i ] = 0xffffffff;
        }
    }


ATTR_T  
CLEAR_FIRST_SET_ATTR ( ATTR_VECTOR & A)
{
    int             i;
    unsigned long   mask;
    short           at;
            
    for ( i = 0; i < MAX_ATTR_SUMMARY_ELEMENTS; ++i )
        {
        for ( at = 0, mask = 1;
              mask != 0;
              ++at, mask = mask<<1 )
            {
            if ( mask & A[i] )
                {
                A[i] &= ~mask;
                return (ATTR_T) (at + ( i * 32 ));
                }
            }
        }
    return ATTR_NONE;
    
}

BOOL
node_base_type::IsUnsigned()
{

    // make obvious choices
    if ( FInSummary( ATTR_UNSIGNED ) ) 
        return TRUE;

    if ( FInSummary( ATTR_SIGNED ) )
        return FALSE;

    // unspec'd char is always unsigned
    if ( NodeKind() == NODE_CHAR )
        {
        return TRUE;
        }
    // unspec'd small is always signed
    else if ( NodeKind() == NODE_SMALL )
        {
        return FALSE;
        }

    // the cracks...
    return FALSE;
}

EXPR_VALUE
node_base_type::ConvertMyKindOfValueToEXPR_VALUE( EXPR_VALUE value )
{

    // make obvious choice
    if ( FInSummary( ATTR_UNSIGNED ) ) 
        return value;
    
    // small values are irrelevant
    if ( (value & 0xffffff80) == 0 )
        return value;

    // handle default signedness
    // simple type should be converted to int in expression evaluation.
    switch ( NodeKind() )
        {
        case NODE_CHAR:
            if ( !FInSummary( ATTR_SIGNED ) )
                return value;
            // fall through to sign extend
        case NODE_SMALL:
            {
            signed int     ch  = (signed int) value;
            return (EXPR_VALUE) ch;
            }
        case NODE_SHORT:
            {
            signed int    sh  = (signed int) value;
            return (EXPR_VALUE) sh;
            }
        case NODE_LONG:
        case NODE_INT32:
        case NODE_INT:
            {
            signed long     lng = (signed long) value;
            return (EXPR_VALUE) lng;
            }
        case NODE_INT3264:
            {
            if ( ! pCommand->Is64BitEnv() )
                {
                signed long     lng = (signed long) value;
                return (EXPR_VALUE) lng;
                }
            }
        }

    return value;
}

BOOL
named_node::IsNamedNode()
{
    return ( ( pName ) && !IsTempName( pName ) );
};

// return the transmit_as type (or NULL)
node_skl    *   
node_def::GetTransmittedType()
    {
    ta *        pXmit = (ta *) GetAttribute( ATTR_TRANSMIT );

/*
Rkk just in case
*/
    if ( !pXmit )
        pXmit = (ta *) GetAttribute( ATTR_WIRE_MARSHAL );

    // allow for transitive xmit_as
    if ( !pXmit && ( GetChild()->NodeKind() == NODE_DEF ) )
        return ((node_def*)GetChild())->GetTransmittedType();

    return (pXmit) ? pXmit->GetType() : NULL;
    }

// return the represent_as type (or NULL)
char        *   
node_def::GetRepresentationName()
    {
    node_represent_as   *   pRep    = 
                        (node_represent_as *) GetAttribute( ATTR_REPRESENT_AS );

    if ( !pRep )
        pRep = (node_represent_as *) GetAttribute( ATTR_USER_MARSHAL );

    return (pRep) ? pRep->GetRepresentationName() : NULL;
    }


    // link self on as new top node
void                    
node_pragma_pack::Push( node_pragma_pack *& pTop )
{
    pStackLink = pTop;
    pTop       = this;
}

    // search for matching push and pop it off, returning new ZP
unsigned short          
node_pragma_pack::Pop( node_pragma_pack *& pTop )
{
    unsigned short      result = 0;

    if ( pString )
        {
        while ( pTop->PackType != PRAGMA_PACK_GARBAGE )
            {
            if ( pTop->pString &&
                 !strcmp( pTop->pString, pString ) )
                {
                result = pTop->usPackingLevel;
                pTop = pTop->pStackLink;
                return result;
                }

            pTop = pTop->pStackLink;
            }
                 
        }
    else
        {
        if ( pTop->PackType != PRAGMA_PACK_GARBAGE )
            {
            result = pTop->usPackingLevel;
            pTop = pTop->pStackLink;
            }
        }

    return result;
}

// routines to save the pragma stack across files

class PRAGMA_FILE_STACK_ELEMENT
    {
public:
    node_pragma_pack *  pPackStack;
    unsigned short      SavedZp;

                        PRAGMA_FILE_STACK_ELEMENT( node_pragma_pack * pSt,
                                                   unsigned short  usZp )
                            {
                            pPackStack  = pSt;
                            SavedZp     = usZp;
                            }
    };


void                        
PushZpStack( node_pragma_pack * & PackStack, 
             unsigned short & CurrentZp )
{
    PRAGMA_FILE_STACK_ELEMENT   *   pSave   = new PRAGMA_FILE_STACK_ELEMENT (
                                                        PackStack, CurrentZp );
    
    pZpStack->Push( (IDICTELEMENT) pSave );
    
    // make new zp stack and start new file with command line Zp
    PackStack           = new node_pragma_pack( NULL,
                                                pCommand->GetZeePee(),
                                                PRAGMA_PACK_GARBAGE );
    CurrentZp   = pCommand->GetZeePee();
}

// restore the Zp stack and current Zp on returning from imported file
void                        
PopZpStack( node_pragma_pack * & PackStack, 
             unsigned short & CurrentZp )
{

    PRAGMA_FILE_STACK_ELEMENT   *   pSaved  = (PRAGMA_FILE_STACK_ELEMENT *)
                                                    pZpStack->Pop();

    PackStack = pSaved->pPackStack;
    CurrentZp = pSaved->SavedZp;

}

BOOL MODIFIER_SET::IsFlagAModifier(ATTR_T flag) const 
   {
   return (flag >= ATTR_CPORT_ATTRIBUTES_START && flag <= ATTR_CPORT_ATTRIBUTES_END);
   }

BOOL MODIFIER_SET::IsModifierSet(ATTR_T flag) const
   {
   return (BOOL)( ModifierBits & SetModifierBit( flag ) );
   }

BOOL MODIFIER_SET::AnyModifiersSet() const
   {
   return ModifierBits != 0; 
   }

void MODIFIER_SET::SetModifier(ATTR_T flag)
   {
   ModifierBits |= SetModifierBit( flag );
   }

void MODIFIER_SET::ClearModifier(ATTR_T flag)
   {
   unsigned _int64 ModifierMask = SetModifierBit( flag );
   ModifierBits &= ~ModifierMask;
   if (ATTR_DECLSPEC_ALIGN == flag)
       Align = 0;
   }

void MODIFIER_SET::SetDeclspecAlign( unsigned short NewAlign)
   {
   SetModifier( ATTR_DECLSPEC_ALIGN);
   Align = NewAlign; 
   }

unsigned short MODIFIER_SET::GetDeclspecAlign() const
   {
   if ( !IsModifierSet( ATTR_DECLSPEC_ALIGN ) )
       return 1;
   return Align;
   }

void MODIFIER_SET::SetDeclspecUnknown(char *pNewUnknownTxt)
   {
   pUnknownTxt = pMidlLexTable->LexInsert(pNewUnknownTxt);
   SetModifier( ATTR_DECLSPEC_UNKNOWN );
   return;
   } 
        
char *MODIFIER_SET::GetDeclspecUnknown() const
   {
   if ( !IsModifierSet( ATTR_DECLSPEC_UNKNOWN ) )
       return " ";
   return pUnknownTxt;
   }

void MODIFIER_SET::Clear()
   {
   ModifierBits = 0; Align = 0; pUnknownTxt = 0;
   }

void MODIFIER_SET::Merge(const MODIFIER_SET & MergeModifierSet)
   { 
   if ( MergeModifierSet.IsModifierSet( ATTR_DECLSPEC_ALIGN ) )
       {
	   if (! IsModifierSet( ATTR_DECLSPEC_ALIGN ) ) 
	       {
           Align = MergeModifierSet.Align;
	       }
       else 
           {
           Align = __max(MergeModifierSet.Align, Align);
           }
       }
   
   if (MergeModifierSet.pUnknownTxt)
       {
       if (!pUnknownTxt)
           {
           pUnknownTxt = MergeModifierSet.pUnknownTxt;
           }
       else 
           {
           size_t StrSize = strlen(MergeModifierSet.pUnknownTxt);
           StrSize += strlen(pUnknownTxt) + 1;
           char *pNewText = new char[StrSize];
           strcpy(pNewText, pUnknownTxt);
           strcat(pNewText, MergeModifierSet.pUnknownTxt);
           pUnknownTxt = pMidlLexTable->LexInsert(pNewText);
           delete[] pNewText;
           }
       
       }
   
   ModifierBits |= MergeModifierSet.ModifierBits;
   
   }

void MODIFIER_SET::PrintDebugInfo() const 
   {
   printf("Modifiers: 0x%I64X\n", ModifierBits);
   printf("Align: %u\n", Align);
   if (pUnknownTxt)
       {
       printf("UnknownTxt: %s\n", pUnknownTxt);
       }
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\front\pass1.cxx ===
/*****************************************************************************/
/**                     Microsoft LAN Manager                               **/
/**             Copyright(c) Microsoft Corp., 1987-1999                     **/
/*****************************************************************************/
/*****************************************************************************
File                : pass1.cxx
Title               : pass1 controller
History             :
    05-Aug-1991 VibhasC Created

*****************************************************************************/

#if 0
                        Notes
                        -----
This file provides the entry point for the MIDL compiler front end.
It initializes the data structures for the front end , and makes the parsing
pass over the idl file. Does the semantics and second semantics passes if
needed.

#endif // 0

#pragma warning ( disable : 4514 )

/****************************************************************************
 includes
 ****************************************************************************/

#include "nulldefs.h"
extern  "C" {
    #include <stdio.h>
    #include <stdlib.h>
    #include <malloc.h>
    extern int yyparse();
}

#include "allnodes.hxx"
#include "control.hxx"
#include "gramutil.hxx"
#include "cmdana.hxx"
#include "filehndl.hxx"
#include "idict.hxx"
#include "treg.hxx"

/****************************************************************************
    extern procedures
 ****************************************************************************/

extern void                     SetUpAttributeMasks( void );
extern void                     SetPredefinedTypes();
extern void                     initlex();

/****************************************************************************
    extern data
 ****************************************************************************/

extern unsigned short           CurrentZp;
extern ATTR_SUMMARY             DisallowedAttrs[INTERNAL_NODE_END];
extern ATTR_SUMMARY             FieldAttrs;
extern TREGISTRY            *   pCallAsTable;
extern class ccontrol       *   pCompiler;
extern nsa                  *   pSymTblMgr;
extern SymTable             *   pBaseSymTbl;
extern SymTable             *   pCurSymTbl;
extern node_error           *   pErrorTypeNode;
extern IDICT                *   pFileDict;
extern IDICT                *   pInterfaceInfo;
extern node_pragma_pack     *   pPackStack;
extern pre_type_db          *   pPreAllocTypes;
extern node_source          *   pSourceNode;
extern NFA_INFO             *   pImportCntrl;
extern CMD_ARG              *   pCommand;
extern node_e_attr          *   pErrorAttrNode;
extern IINFODICT            *   pInterfaceInfoDict;
extern IDICT                *   pInterfaceDict;
extern SymTable             *   pUUIDTable;
extern ISTACK               *   pZpStack;
extern ATTR_SUMMARY             RedundantsOk;

/****************************************************************************
    local data
 ****************************************************************************/

/****************************************************************************/


/****************************************************************************
_pass1:
    The constructor.
 ****************************************************************************/
_pass1::_pass1()
    {
    pSymTblMgr      = new nsa;
    pBaseSymTbl     = pCurSymTbl = pSymTblMgr->GetCurrentSymbolTable();
    pUUIDTable      = new SymTable;
    pCallAsTable    = new TREGISTRY;
    pCompiler->SetPassNumber( IDL_PASS );

    }
/****************************************************************************
 Go:
    The execution of pass1
 ****************************************************************************/
STATUS_T
_pass1::Go()
    {
    STATUS_T    Status;

    /**
     ** set up the input file for each pass
     **/

    pImportCntrl    = pCompiler->SetImportController( new NFA_INFO );
    pImportCntrl->Init();

    pFileDict       = new IDICT( 8, 8 );
    AddFileToDB( "Dummy" );     // to get index to be non-zero

    Status = pImportCntrl->SetNewInputFile( pCommand->GetInputFileName() );
    AddFileToDB( pCommand->GetInputFileName() );

    if( Status == STATUS_OK )
        {

        /**
         ** set up for the 1st pass, allocate the semantics context manager
         ** and the pre-allocated types data base
         **/

        pPreAllocTypes      = new pre_type_db;
        pErrorTypeNode      = new node_error;
        pErrorAttrNode      = new node_e_attr;
        pInterfaceInfoDict  = new IINFODICT;
        pInterfaceInfoDict->StartNewInterface();
        pInterfaceDict      = new IDICT(8,8);
        pInterfaceDict->AddElement( NULL ); // so that 0 is a reserved value
        pPackStack          = new node_pragma_pack( NULL,
                                                    pCommand->GetZeePee(),
                                                    PRAGMA_PACK_GARBAGE );
        CurrentZp   = pCommand->GetZeePee();
        pZpStack            = new ISTACK( 10 );

        /**
         ** Set up the predefined types and bit attributes.
         **/

#ifdef gajdebug4
    printf("about to do predefined types...\n");
#endif
        SetPredefinedTypes();
#ifdef gajdebug4
    printf("\t\t\t...done\n");
#endif

        /**
         ** set up attribute masks, to indicate which node takes what attribute.
         ** also set up acf conflicts.
         **/

        SetUpAttributeMasks();

        /**
         ** go parse.
         **/

        initlex();

        if( yyparse() )
            Status = SYNTAX_ERROR;
        pInterfaceInfoDict->EndNewInterface();
        }

    delete pImportCntrl;


    return Status;
    }
/****************************************************************************
 SetUpAttributeMasks:
    This function exists to initialize the attribute masks. Attribute masks
    are nothing but summary attribute bit vectors, which have bits set up
    in them to indicate which attributes are acceptable at a node. The way
    the attribute distribution occurs, we need to indicate the attributes
    collected on the way down the chain and up the chain. That is why we need
    two attribute summary vectors. We init them up front so that we need not
    do this at run-time. This whole operation really is too large to my liking
    but for the time being, it stays

    NOTE: A pointer node handles its own attribute mask setting, it varies
          with the type graph underneath a pointer
 ****************************************************************************/
void
SetUpAttributeMasks( void )
    {
    MIDL_ASSERT(MAX_ATTR_SUMMARY_ELEMENTS == ((ACF_ATTR_END / 32) + 1));

    int i = 0;

    // RedundantsOk is the set of attributes we silently allow duplicates of
    // All other duplicates are redundant and need complaining about
    CLEAR_ATTR( RedundantsOk );
    SET_ATTR( RedundantsOk, ATTR_FIRST );
    SET_ATTR( RedundantsOk, ATTR_LAST );
    SET_ATTR( RedundantsOk, ATTR_LENGTH );
    SET_ATTR( RedundantsOk, ATTR_MIN );
    SET_ATTR( RedundantsOk, ATTR_MAX );
    SET_ATTR( RedundantsOk, ATTR_SIZE );
    SET_ATTR( RedundantsOk, ATTR_RANGE );
    SET_ATTR( RedundantsOk, ATTR_CASE );
    SET_ATTR( RedundantsOk, ATTR_FUNCDESCATTR );
    SET_ATTR( RedundantsOk, ATTR_IDLDESCATTR );
    SET_ATTR( RedundantsOk, ATTR_TYPEDESCATTR );
    SET_ATTR( RedundantsOk, ATTR_VARDESCATTR );
    SET_ATTR( RedundantsOk, ATTR_TYPE );
    SET_ATTR( RedundantsOk, ATTR_MEMBER );

    // FieldAttrs is the set of all field attributes
    CLEAR_ATTR( FieldAttrs );
    SET_ATTR( FieldAttrs, ATTR_FIRST );
    SET_ATTR( FieldAttrs, ATTR_LAST );
    SET_ATTR( FieldAttrs, ATTR_LENGTH );
    SET_ATTR( FieldAttrs, ATTR_MIN );
    SET_ATTR( FieldAttrs, ATTR_MAX );
    SET_ATTR( FieldAttrs, ATTR_SIZE );
    SET_ATTR( FieldAttrs, ATTR_STRING );
    SET_ATTR( FieldAttrs, ATTR_BSTRING );
    SET_ATTR( FieldAttrs, ATTR_IID_IS );


    // initialize the array of valid attributes to globally allow everything
    for ( i = 0; i < INTERNAL_NODE_END; i++ )
        CLEAR_ATTR( DisallowedAttrs[i] );

    // turn off bits for attributes allowed on arrays
    SET_ALL_ATTR( DisallowedAttrs[ NODE_ARRAY ] );
    RESET_ATTR( DisallowedAttrs[ NODE_ARRAY ], ATTR_FIRST );
    RESET_ATTR( DisallowedAttrs[ NODE_ARRAY ], ATTR_LAST );
    RESET_ATTR( DisallowedAttrs[ NODE_ARRAY ], ATTR_LENGTH );
    RESET_ATTR( DisallowedAttrs[ NODE_ARRAY ], ATTR_MIN );
    RESET_ATTR( DisallowedAttrs[ NODE_ARRAY ], ATTR_MAX );
    RESET_ATTR( DisallowedAttrs[ NODE_ARRAY ], ATTR_SIZE );
    RESET_ATTR( DisallowedAttrs[ NODE_ARRAY ], ATTR_PTR_KIND );
    RESET_ATTR( DisallowedAttrs[ NODE_ARRAY ], ATTR_STRING );
    RESET_ATTR( DisallowedAttrs[ NODE_ARRAY ], ATTR_CONTEXT );
    RESET_ATTR( DisallowedAttrs[ NODE_ARRAY ], ATTR_NOSERIALIZE);
    RESET_ATTR( DisallowedAttrs[ NODE_ARRAY ], ATTR_SERIALIZE);
    RESET_ATTR( DisallowedAttrs[ NODE_ARRAY ], ATTR_SWITCH_IS );
    RESET_ATTR( DisallowedAttrs[ NODE_ARRAY ], ATTR_IID_IS );
    RESET_ATTR( DisallowedAttrs[ NODE_ARRAY ], ATTR_SWITCH_TYPE );
    RESET_ATTR( DisallowedAttrs[ NODE_ARRAY ], ATTR_BYTE_COUNT );
    RESET_ATTR( DisallowedAttrs[ NODE_ARRAY ], ATTR_V1_ENUM );
    RESET_ATTR( DisallowedAttrs[ NODE_ARRAY ], ATTR_ID );

    // turn off bits for attributes allowed on pointers
    SET_ALL_ATTR( DisallowedAttrs[ NODE_POINTER ] );
    RESET_ATTR( DisallowedAttrs[ NODE_POINTER ], ATTR_FIRST );
    RESET_ATTR( DisallowedAttrs[ NODE_POINTER ], ATTR_LAST );
    RESET_ATTR( DisallowedAttrs[ NODE_POINTER ], ATTR_LENGTH );
    RESET_ATTR( DisallowedAttrs[ NODE_POINTER ], ATTR_MIN );
    RESET_ATTR( DisallowedAttrs[ NODE_POINTER ], ATTR_MAX );
    RESET_ATTR( DisallowedAttrs[ NODE_POINTER ], ATTR_SIZE );
    RESET_ATTR( DisallowedAttrs[ NODE_POINTER ], ATTR_PTR_KIND );
    RESET_ATTR( DisallowedAttrs[ NODE_POINTER ], ATTR_STRING );
    RESET_ATTR( DisallowedAttrs[ NODE_POINTER ], ATTR_BSTRING );
    RESET_ATTR( DisallowedAttrs[ NODE_POINTER ], ATTR_CONTEXT );
    RESET_ATTR( DisallowedAttrs[ NODE_POINTER ], ATTR_NOSERIALIZE);
    RESET_ATTR( DisallowedAttrs[ NODE_POINTER ], ATTR_SERIALIZE);
    RESET_ATTR( DisallowedAttrs[ NODE_POINTER ], ATTR_ALLOCATE );
    RESET_ATTR( DisallowedAttrs[ NODE_POINTER ], ATTR_IGNORE );
    RESET_ATTR( DisallowedAttrs[ NODE_POINTER ], ATTR_BYTE_COUNT );
    RESET_ATTR( DisallowedAttrs[ NODE_POINTER ], ATTR_SWITCH_IS );
    RESET_ATTR( DisallowedAttrs[ NODE_POINTER ], ATTR_IID_IS );
    RESET_ATTR( DisallowedAttrs[ NODE_POINTER ], ATTR_COMMSTAT );
    RESET_ATTR( DisallowedAttrs[ NODE_POINTER ], ATTR_FAULTSTAT );
    RESET_ATTR( DisallowedAttrs[ NODE_POINTER ], ATTR_SWITCH_TYPE );
    RESET_ATTR( DisallowedAttrs[ NODE_POINTER ], ATTR_BYTE_COUNT );
    RESET_ATTR( DisallowedAttrs[ NODE_POINTER ], ATTR_V1_ENUM );
    RESET_ATTR( DisallowedAttrs[ NODE_POINTER ], ATTR_ID );

    // turn off bits for attributes allowed on interface
    SET_ALL_ATTR( DisallowedAttrs[ NODE_INTERFACE ] );
    RESET_ATTR( DisallowedAttrs[ NODE_INTERFACE ], ATTR_PTR_KIND );
    RESET_ATTR( DisallowedAttrs[ NODE_INTERFACE ], ATTR_GUID );
    RESET_ATTR( DisallowedAttrs[ NODE_INTERFACE ], ATTR_VERSION );
    RESET_ATTR( DisallowedAttrs[ NODE_INTERFACE ], ATTR_ENDPOINT );
    RESET_ATTR( DisallowedAttrs[ NODE_INTERFACE ], ATTR_LOCAL );
    RESET_ATTR( DisallowedAttrs[ NODE_INTERFACE ], ATTR_OBJECT );
    RESET_ATTR( DisallowedAttrs[ NODE_INTERFACE ], ATTR_AUTO );
    RESET_ATTR( DisallowedAttrs[ NODE_INTERFACE ], ATTR_IMPLICIT );
    RESET_ATTR( DisallowedAttrs[ NODE_INTERFACE ], ATTR_EXPLICIT );
    RESET_ATTR( DisallowedAttrs[ NODE_INTERFACE ], ATTR_CODE );
    RESET_ATTR( DisallowedAttrs[ NODE_INTERFACE ], ATTR_NOCODE );
    RESET_ATTR( DisallowedAttrs[ NODE_INTERFACE ], ATTR_PTRSIZE );
    RESET_ATTR( DisallowedAttrs[ NODE_INTERFACE ], ATTR_OPTIMIZE );
    RESET_ATTR( DisallowedAttrs[ NODE_INTERFACE ], ATTR_MS_UNION );
    RESET_ATTR( DisallowedAttrs[ NODE_INTERFACE ], ATTR_MS_CONF_STRUCT );
    RESET_ATTR( DisallowedAttrs[ NODE_INTERFACE ], ATTR_ENABLE_ALLOCATE );
    RESET_ATTR( DisallowedAttrs[ NODE_INTERFACE ], ATTR_ENCODE );
    RESET_ATTR( DisallowedAttrs[ NODE_INTERFACE ], ATTR_DECODE );
    RESET_ATTR( DisallowedAttrs[ NODE_INTERFACE ], ATTR_HELPCONTEXT );
    RESET_ATTR( DisallowedAttrs[ NODE_INTERFACE ], ATTR_HELPSTRINGCONTEXT );
    RESET_ATTR( DisallowedAttrs[ NODE_INTERFACE ], ATTR_HELPSTRING );
    RESET_ATTR( DisallowedAttrs[ NODE_INTERFACE ], ATTR_TYPE);
    RESET_ATTR( DisallowedAttrs[ NODE_INTERFACE ], ATTR_MEMBER);
    RESET_ATTR( DisallowedAttrs[ NODE_INTERFACE ], ATTR_HIDDEN );
    RESET_ATTR( DisallowedAttrs[ NODE_INTERFACE ], ATTR_TYPEDESCATTR);
    RESET_ATTR( DisallowedAttrs[ NODE_INTERFACE ], ATTR_DEFAULT );
    RESET_ATTR( DisallowedAttrs[ NODE_INTERFACE ], ATTR_CUSTOM );
    RESET_ATTR( DisallowedAttrs[ NODE_INTERFACE ], ATTR_ASYNC );
    RESET_ATTR( DisallowedAttrs[ NODE_INTERFACE ], ATTR_ASYNCUUID );
    RESET_ATTR( DisallowedAttrs[ NODE_INTERFACE ], ATTR_MESSAGE );
    RESET_ATTR( DisallowedAttrs[ NODE_INTERFACE ], ATTR_STRICT_CONTEXT_HANDLE );
    RESET_ATTR( DisallowedAttrs[ NODE_INTERFACE ], ATTR_CSTAGRTN );

    // turn off bits for attributes allowed on an object pipe interface
    SET_ALL_ATTR( DisallowedAttrs[ NODE_PIPE_INTERFACE ] );
    RESET_ATTR( DisallowedAttrs[ NODE_PIPE_INTERFACE ], ATTR_GUID );
    RESET_ATTR( DisallowedAttrs[ NODE_PIPE_INTERFACE ], ATTR_VERSION );
    RESET_ATTR( DisallowedAttrs[ NODE_PIPE_INTERFACE ], ATTR_OBJECT );
    RESET_ATTR( DisallowedAttrs[ NODE_PIPE_INTERFACE ], ATTR_IMPLICIT );
    RESET_ATTR( DisallowedAttrs[ NODE_PIPE_INTERFACE ], ATTR_EXPLICIT );
    RESET_ATTR( DisallowedAttrs[ NODE_PIPE_INTERFACE ], ATTR_CODE );
    RESET_ATTR( DisallowedAttrs[ NODE_PIPE_INTERFACE ], ATTR_NOCODE );
    RESET_ATTR( DisallowedAttrs[ NODE_PIPE_INTERFACE ], ATTR_OPTIMIZE );
    RESET_ATTR( DisallowedAttrs[ NODE_PIPE_INTERFACE ], ATTR_RANGE );

    // turn off bits for attributes allowed on library
    SET_ALL_ATTR( DisallowedAttrs[ NODE_LIBRARY ] );
    RESET_ATTR( DisallowedAttrs[ NODE_LIBRARY ], ATTR_GUID );
    RESET_ATTR( DisallowedAttrs[ NODE_LIBRARY ], ATTR_VERSION );
    RESET_ATTR( DisallowedAttrs[ NODE_LIBRARY ], ATTR_HELPCONTEXT );
    RESET_ATTR( DisallowedAttrs[ NODE_LIBRARY ], ATTR_HELPSTRINGCONTEXT );
    RESET_ATTR( DisallowedAttrs[ NODE_LIBRARY ], ATTR_HELPSTRING );
    RESET_ATTR( DisallowedAttrs[ NODE_LIBRARY ], ATTR_HELPFILE );
    RESET_ATTR( DisallowedAttrs[ NODE_LIBRARY ], ATTR_HELPSTRINGDLL );
    // MATTR_RESTRICTED is grouped under ATTR_MEMBER so allow ATTR_MEMBER
    RESET_ATTR( DisallowedAttrs[ NODE_LIBRARY ], ATTR_MEMBER );
    // TATTR_CONTROL is grouped under ATTR_TYPE so allow ATTR_TYPE
    RESET_ATTR( DisallowedAttrs[ NODE_LIBRARY ], ATTR_TYPE );
    RESET_ATTR( DisallowedAttrs[ NODE_LIBRARY ], ATTR_LCID);
    RESET_ATTR( DisallowedAttrs[ NODE_LIBRARY ], ATTR_HIDDEN );
    RESET_ATTR( DisallowedAttrs[ NODE_LIBRARY ], ATTR_CUSTOM );

    // turn off bits for attributes allowed on module
    SET_ALL_ATTR( DisallowedAttrs[ NODE_MODULE ] );
    RESET_ATTR( DisallowedAttrs[ NODE_MODULE ], ATTR_GUID );
    RESET_ATTR( DisallowedAttrs[ NODE_MODULE ], ATTR_VERSION );
    RESET_ATTR( DisallowedAttrs[ NODE_MODULE ], ATTR_HELPCONTEXT );
    RESET_ATTR( DisallowedAttrs[ NODE_MODULE ], ATTR_HELPSTRINGCONTEXT );
    RESET_ATTR( DisallowedAttrs[ NODE_MODULE ], ATTR_HELPSTRING );
    RESET_ATTR( DisallowedAttrs[ NODE_MODULE ], ATTR_TYPE );
    RESET_ATTR( DisallowedAttrs[ NODE_MODULE ], ATTR_MEMBER );
    RESET_ATTR( DisallowedAttrs[ NODE_MODULE ], ATTR_DLLNAME );
    RESET_ATTR( DisallowedAttrs[ NODE_MODULE ], ATTR_HIDDEN );
    RESET_ATTR( DisallowedAttrs[ NODE_MODULE ], ATTR_CUSTOM );

    // turn off bits for attributes allowed on dispinterface
    SET_ALL_ATTR( DisallowedAttrs[ NODE_DISPINTERFACE ] );
    RESET_ATTR( DisallowedAttrs[ NODE_DISPINTERFACE ], ATTR_GUID );
    RESET_ATTR( DisallowedAttrs[ NODE_DISPINTERFACE ], ATTR_VERSION );
    RESET_ATTR( DisallowedAttrs[ NODE_DISPINTERFACE ], ATTR_HELPCONTEXT );
    RESET_ATTR( DisallowedAttrs[ NODE_DISPINTERFACE ], ATTR_HELPSTRINGCONTEXT );
    RESET_ATTR( DisallowedAttrs[ NODE_DISPINTERFACE ], ATTR_HELPSTRING );
    RESET_ATTR( DisallowedAttrs[ NODE_DISPINTERFACE ], ATTR_TYPE );
    RESET_ATTR( DisallowedAttrs[ NODE_DISPINTERFACE ], ATTR_MEMBER );
    RESET_ATTR( DisallowedAttrs[ NODE_DISPINTERFACE ], ATTR_HIDDEN );
    RESET_ATTR( DisallowedAttrs[ NODE_DISPINTERFACE ], ATTR_CUSTOM );
    
    // turn off bits for attributes allowed on coclass
    SET_ALL_ATTR( DisallowedAttrs[ NODE_COCLASS ] );
    RESET_ATTR( DisallowedAttrs[ NODE_COCLASS ], ATTR_GUID );
    RESET_ATTR( DisallowedAttrs[ NODE_COCLASS ], ATTR_VERSION );
    RESET_ATTR( DisallowedAttrs[ NODE_COCLASS ], ATTR_HELPCONTEXT );
    RESET_ATTR( DisallowedAttrs[ NODE_COCLASS ], ATTR_HELPSTRINGCONTEXT );
    RESET_ATTR( DisallowedAttrs[ NODE_COCLASS ], ATTR_HELPSTRING );
    RESET_ATTR( DisallowedAttrs[ NODE_COCLASS ], ATTR_TYPE );
    RESET_ATTR( DisallowedAttrs[ NODE_COCLASS ], ATTR_MEMBER );
    RESET_ATTR( DisallowedAttrs[ NODE_COCLASS ], ATTR_HIDDEN );
    RESET_ATTR( DisallowedAttrs[ NODE_COCLASS ], ATTR_CUSTOM );
    
    // turn off bits for attributes allowed on enumeration labels
    SET_ALL_ATTR( DisallowedAttrs[ NODE_LABEL ] );                                    
    RESET_ATTR( DisallowedAttrs[ NODE_LABEL ], ATTR_VERSION );
    RESET_ATTR( DisallowedAttrs[ NODE_LABEL ], ATTR_HELPCONTEXT );
    RESET_ATTR( DisallowedAttrs[ NODE_LABEL ], ATTR_HELPSTRINGCONTEXT );
    RESET_ATTR( DisallowedAttrs[ NODE_LABEL ], ATTR_HELPSTRING );
    RESET_ATTR( DisallowedAttrs[ NODE_LABEL ], ATTR_MEMBER );
    RESET_ATTR( DisallowedAttrs[ NODE_LABEL ], ATTR_IDLDESCATTR );
    RESET_ATTR( DisallowedAttrs[ NODE_LABEL ], ATTR_VARDESCATTR );
    RESET_ATTR( DisallowedAttrs[ NODE_LABEL ], ATTR_ID );
    RESET_ATTR( DisallowedAttrs[ NODE_LABEL ], ATTR_HIDDEN );
    RESET_ATTR( DisallowedAttrs[ NODE_LABEL ], ATTR_CUSTOM );

    // turn off bits for attributes allowed on proc (and return)
    SET_ALL_ATTR( DisallowedAttrs[ NODE_PROC ] );
    RESET_ATTR( DisallowedAttrs[ NODE_PROC ], ATTR_PTR_KIND );
    RESET_ATTR( DisallowedAttrs[ NODE_PROC ], ATTR_LOCAL );
    RESET_ATTR( DisallowedAttrs[ NODE_PROC ], ATTR_CODE );
    RESET_ATTR( DisallowedAttrs[ NODE_PROC ], ATTR_NOCODE );
    RESET_ATTR( DisallowedAttrs[ NODE_PROC ], ATTR_PTRSIZE );
    RESET_ATTR( DisallowedAttrs[ NODE_PROC ], ATTR_OPTIMIZE );
    RESET_ATTR( DisallowedAttrs[ NODE_PROC ], ATTR_MS_UNION );
    RESET_ATTR( DisallowedAttrs[ NODE_PROC ], ATTR_HANDLE );
    RESET_ATTR( DisallowedAttrs[ NODE_PROC ], ATTR_CONTEXT );
    RESET_ATTR( DisallowedAttrs[ NODE_PROC ], ATTR_NOSERIALIZE);
    RESET_ATTR( DisallowedAttrs[ NODE_PROC ], ATTR_SERIALIZE);
    RESET_ATTR( DisallowedAttrs[ NODE_PROC ], ATTR_IDEMPOTENT );
    RESET_ATTR( DisallowedAttrs[ NODE_PROC ], ATTR_BROADCAST );
    RESET_ATTR( DisallowedAttrs[ NODE_PROC ], ATTR_MAYBE );
    RESET_ATTR( DisallowedAttrs[ NODE_PROC ], ATTR_ASYNC );
    RESET_ATTR( DisallowedAttrs[ NODE_PROC ], ATTR_MESSAGE );
    RESET_ATTR( DisallowedAttrs[ NODE_PROC ], ATTR_INPUTSYNC );
    RESET_ATTR( DisallowedAttrs[ NODE_PROC ], ATTR_CALLBACK );
    RESET_ATTR( DisallowedAttrs[ NODE_PROC ], ATTR_COMMSTAT );
    RESET_ATTR( DisallowedAttrs[ NODE_PROC ], ATTR_FAULTSTAT );
    RESET_ATTR( DisallowedAttrs[ NODE_PROC ], ATTR_NOTIFY );
    RESET_ATTR( DisallowedAttrs[ NODE_PROC ], ATTR_NOTIFY_FLAG );
    RESET_ATTR( DisallowedAttrs[ NODE_PROC ], ATTR_ENABLE_ALLOCATE );
    RESET_ATTR( DisallowedAttrs[ NODE_PROC ], ATTR_EXPLICIT );
    RESET_ATTR( DisallowedAttrs[ NODE_PROC ], ATTR_STRING );
    RESET_ATTR( DisallowedAttrs[ NODE_PROC ], ATTR_SWITCH_TYPE );
    RESET_ATTR( DisallowedAttrs[ NODE_PROC ], ATTR_BYTE_COUNT );
    RESET_ATTR( DisallowedAttrs[ NODE_PROC ], ATTR_V1_ENUM );
    RESET_ATTR( DisallowedAttrs[ NODE_PROC ], ATTR_ENCODE );
    RESET_ATTR( DisallowedAttrs[ NODE_PROC ], ATTR_DECODE );
    RESET_ATTR( DisallowedAttrs[ NODE_PROC ], ATTR_CALL_AS );
    RESET_ATTR( DisallowedAttrs[ NODE_PROC ], ATTR_ID );
    RESET_ATTR( DisallowedAttrs[ NODE_PROC ], ATTR_HELPCONTEXT );
    RESET_ATTR( DisallowedAttrs[ NODE_PROC ], ATTR_HELPSTRINGCONTEXT );
    RESET_ATTR( DisallowedAttrs[ NODE_PROC ], ATTR_HELPSTRING );
    RESET_ATTR( DisallowedAttrs[ NODE_PROC ], ATTR_HIDDEN );
    RESET_ATTR( DisallowedAttrs[ NODE_PROC ], ATTR_MEMBER );
    RESET_ATTR( DisallowedAttrs[ NODE_PROC ], ATTR_ENTRY );
    RESET_ATTR( DisallowedAttrs[ NODE_PROC ], ATTR_VARDESCATTR );
    RESET_ATTR( DisallowedAttrs[ NODE_PROC ], ATTR_FUNCDESCATTR );
    RESET_ATTR( DisallowedAttrs[ NODE_PROC ], ATTR_IDLDESCATTR );
    RESET_ATTR( DisallowedAttrs[ NODE_PROC ], ATTR_CUSTOM );
    RESET_ATTR( DisallowedAttrs[ NODE_PROC ], ATTR_CSTAGRTN );

    // turn off bits for attributes allowed on typedef
    SET_ALL_ATTR( DisallowedAttrs[ NODE_DEF ] );
    RESET_ATTR( DisallowedAttrs[ NODE_DEF ], ATTR_PTR_KIND );
    RESET_ATTR( DisallowedAttrs[ NODE_DEF ], ATTR_TRANSMIT );
    RESET_ATTR( DisallowedAttrs[ NODE_DEF ], ATTR_WIRE_MARSHAL );
    RESET_ATTR( DisallowedAttrs[ NODE_DEF ], ATTR_HANDLE );
    RESET_ATTR( DisallowedAttrs[ NODE_DEF ], ATTR_REPRESENT_AS );
    RESET_ATTR( DisallowedAttrs[ NODE_DEF ], ATTR_USER_MARSHAL );
    RESET_ATTR( DisallowedAttrs[ NODE_DEF ], ATTR_CONTEXT );
    RESET_ATTR( DisallowedAttrs[ NODE_DEF ], ATTR_ALLOCATE );
    RESET_ATTR( DisallowedAttrs[ NODE_DEF ], ATTR_HEAP );
    RESET_ATTR( DisallowedAttrs[ NODE_DEF ], ATTR_STRING );
    RESET_ATTR( DisallowedAttrs[ NODE_DEF ], ATTR_BSTRING );
    RESET_ATTR( DisallowedAttrs[ NODE_DEF ], ATTR_FIRST );
    RESET_ATTR( DisallowedAttrs[ NODE_DEF ], ATTR_LAST );
    RESET_ATTR( DisallowedAttrs[ NODE_DEF ], ATTR_LENGTH );
    RESET_ATTR( DisallowedAttrs[ NODE_DEF ], ATTR_MIN );
    RESET_ATTR( DisallowedAttrs[ NODE_DEF ], ATTR_MAX );
    RESET_ATTR( DisallowedAttrs[ NODE_DEF ], ATTR_SIZE );
    RESET_ATTR( DisallowedAttrs[ NODE_DEF ], ATTR_RANGE );
    RESET_ATTR( DisallowedAttrs[ NODE_DEF ], ATTR_SWITCH_TYPE );
    RESET_ATTR( DisallowedAttrs[ NODE_DEF ], ATTR_MS_UNION );
    RESET_ATTR( DisallowedAttrs[ NODE_DEF ], ATTR_COMMSTAT );
    RESET_ATTR( DisallowedAttrs[ NODE_DEF ], ATTR_FAULTSTAT );
    RESET_ATTR( DisallowedAttrs[ NODE_DEF ], ATTR_BYTE_COUNT );
    RESET_ATTR( DisallowedAttrs[ NODE_DEF ], ATTR_SWITCH_IS );
    RESET_ATTR( DisallowedAttrs[ NODE_DEF ], ATTR_V1_ENUM );
    RESET_ATTR( DisallowedAttrs[ NODE_DEF ], ATTR_IID_IS );
    RESET_ATTR( DisallowedAttrs[ NODE_DEF ], ATTR_ENCODE );
    RESET_ATTR( DisallowedAttrs[ NODE_DEF ], ATTR_DECODE );
    RESET_ATTR( DisallowedAttrs[ NODE_DEF ], ATTR_ID );
    RESET_ATTR( DisallowedAttrs[ NODE_DEF ], ATTR_HELPCONTEXT );
    RESET_ATTR( DisallowedAttrs[ NODE_DEF ], ATTR_HELPSTRINGCONTEXT );
    RESET_ATTR( DisallowedAttrs[ NODE_DEF ], ATTR_HELPSTRING );
    RESET_ATTR( DisallowedAttrs[ NODE_DEF ], ATTR_HIDDEN );
    RESET_ATTR( DisallowedAttrs[ NODE_DEF ], ATTR_TYPE );
    RESET_ATTR( DisallowedAttrs[ NODE_DEF ], ATTR_MEMBER );
    RESET_ATTR( DisallowedAttrs[ NODE_DEF ], ATTR_TYPEDESCATTR );
    RESET_ATTR( DisallowedAttrs[ NODE_DEF ], ATTR_GUID );
    RESET_ATTR( DisallowedAttrs[ NODE_DEF ], ATTR_VERSION );
    RESET_ATTR( DisallowedAttrs[ NODE_DEF ], ATTR_CUSTOM );
    RESET_ATTR( DisallowedAttrs[ NODE_DEF ], ATTR_NOSERIALIZE );
    RESET_ATTR( DisallowedAttrs[ NODE_DEF ], ATTR_SERIALIZE );
    RESET_ATTR( DisallowedAttrs[ NODE_DEF ], ATTR_CSCHAR );

    // turn off bits for attributes allowed on param
    SET_ALL_ATTR( DisallowedAttrs[ NODE_PARAM ] );
    RESET_ATTR( DisallowedAttrs[ NODE_PARAM ], ATTR_PTR_KIND );
    RESET_ATTR( DisallowedAttrs[ NODE_PARAM ], ATTR_IN );
    RESET_ATTR( DisallowedAttrs[ NODE_PARAM ], ATTR_OUT );
    RESET_ATTR( DisallowedAttrs[ NODE_PARAM ], ATTR_PARTIAL_IGNORE );
    RESET_ATTR( DisallowedAttrs[ NODE_PARAM ], ATTR_COMMSTAT );
    RESET_ATTR( DisallowedAttrs[ NODE_PARAM ], ATTR_FAULTSTAT );
    RESET_ATTR( DisallowedAttrs[ NODE_PARAM ], ATTR_HEAP );
    RESET_ATTR( DisallowedAttrs[ NODE_PARAM ], ATTR_CONTEXT );
    RESET_ATTR( DisallowedAttrs[ NODE_PARAM ], ATTR_NOSERIALIZE);
    RESET_ATTR( DisallowedAttrs[ NODE_PARAM ], ATTR_SERIALIZE);
    RESET_ATTR( DisallowedAttrs[ NODE_PARAM ], ATTR_HANDLE );
    RESET_ATTR( DisallowedAttrs[ NODE_PARAM ], ATTR_BYTE_COUNT );
    RESET_ATTR( DisallowedAttrs[ NODE_PARAM ], ATTR_SWITCH_IS );
    RESET_ATTR( DisallowedAttrs[ NODE_PARAM ], ATTR_IID_IS );
    RESET_ATTR( DisallowedAttrs[ NODE_PARAM ], ATTR_CASE );
    RESET_ATTR( DisallowedAttrs[ NODE_PARAM ], ATTR_FIRST );
    RESET_ATTR( DisallowedAttrs[ NODE_PARAM ], ATTR_LAST );
    RESET_ATTR( DisallowedAttrs[ NODE_PARAM ], ATTR_LENGTH );
    RESET_ATTR( DisallowedAttrs[ NODE_PARAM ], ATTR_MIN );
    RESET_ATTR( DisallowedAttrs[ NODE_PARAM ], ATTR_MAX );
    RESET_ATTR( DisallowedAttrs[ NODE_PARAM ], ATTR_SIZE );
    RESET_ATTR( DisallowedAttrs[ NODE_PARAM ], ATTR_RANGE );
    RESET_ATTR( DisallowedAttrs[ NODE_PARAM ], ATTR_STRING );
    RESET_ATTR( DisallowedAttrs[ NODE_PARAM ], ATTR_ALLOCATE );
    RESET_ATTR( DisallowedAttrs[ NODE_PARAM ], ATTR_BYTE_COUNT );
    RESET_ATTR( DisallowedAttrs[ NODE_PARAM ], ATTR_SWITCH_TYPE );
    RESET_ATTR( DisallowedAttrs[ NODE_PARAM ], ATTR_V1_ENUM );
    RESET_ATTR( DisallowedAttrs[ NODE_PARAM ], ATTR_HIDDEN );
    RESET_ATTR( DisallowedAttrs[ NODE_PARAM ], ATTR_MEMBER );
    RESET_ATTR( DisallowedAttrs[ NODE_PARAM ], ATTR_IDLDESCATTR );
    RESET_ATTR( DisallowedAttrs[ NODE_PARAM ], ATTR_VARDESCATTR );
    RESET_ATTR( DisallowedAttrs[ NODE_PARAM ], ATTR_FLCID );
    RESET_ATTR( DisallowedAttrs[ NODE_PARAM ], ATTR_DEFAULTVALUE );
    RESET_ATTR( DisallowedAttrs[ NODE_PARAM ], ATTR_CUSTOM );
    RESET_ATTR( DisallowedAttrs[ NODE_PARAM ], ATTR_DRTAG );
    RESET_ATTR( DisallowedAttrs[ NODE_PARAM ], ATTR_RTAG );
    RESET_ATTR( DisallowedAttrs[ NODE_PARAM ], ATTR_STAG );
    RESET_ATTR( DisallowedAttrs[ NODE_PARAM ], ATTR_FORCEALLOCATE );

    // turn off bits for attributes allowed on field
    SET_ALL_ATTR( DisallowedAttrs[ NODE_FIELD ] );
    RESET_ATTR( DisallowedAttrs[ NODE_FIELD ], ATTR_PTR_KIND );
    RESET_ATTR( DisallowedAttrs[ NODE_FIELD ], ATTR_SWITCH_IS );
    RESET_ATTR( DisallowedAttrs[ NODE_FIELD ], ATTR_IID_IS );
    RESET_ATTR( DisallowedAttrs[ NODE_FIELD ], ATTR_CASE );
    RESET_ATTR( DisallowedAttrs[ NODE_FIELD ], ATTR_DEFAULT );
    RESET_ATTR( DisallowedAttrs[ NODE_FIELD ], ATTR_FIRST );
    RESET_ATTR( DisallowedAttrs[ NODE_FIELD ], ATTR_LAST );
    RESET_ATTR( DisallowedAttrs[ NODE_FIELD ], ATTR_LENGTH );
    RESET_ATTR( DisallowedAttrs[ NODE_FIELD ], ATTR_MIN );
    RESET_ATTR( DisallowedAttrs[ NODE_FIELD ], ATTR_MAX );
    RESET_ATTR( DisallowedAttrs[ NODE_FIELD ], ATTR_SIZE );
    RESET_ATTR( DisallowedAttrs[ NODE_FIELD ], ATTR_RANGE );
    RESET_ATTR( DisallowedAttrs[ NODE_FIELD ], ATTR_STRING );
    RESET_ATTR( DisallowedAttrs[ NODE_FIELD ], ATTR_CONTEXT );
    RESET_ATTR( DisallowedAttrs[ NODE_FIELD ], ATTR_NOSERIALIZE);
    RESET_ATTR( DisallowedAttrs[ NODE_FIELD ], ATTR_SERIALIZE);
    RESET_ATTR( DisallowedAttrs[ NODE_FIELD ], ATTR_ALLOCATE );
    RESET_ATTR( DisallowedAttrs[ NODE_FIELD ], ATTR_IGNORE );
    RESET_ATTR( DisallowedAttrs[ NODE_FIELD ], ATTR_BYTE_COUNT );
    RESET_ATTR( DisallowedAttrs[ NODE_FIELD ], ATTR_SWITCH_TYPE );
    RESET_ATTR( DisallowedAttrs[ NODE_FIELD ], ATTR_V1_ENUM );
    RESET_ATTR( DisallowedAttrs[ NODE_FIELD ], ATTR_ID );
    RESET_ATTR( DisallowedAttrs[ NODE_FIELD ], ATTR_HELPCONTEXT );
    RESET_ATTR( DisallowedAttrs[ NODE_FIELD ], ATTR_HELPSTRINGCONTEXT );
    RESET_ATTR( DisallowedAttrs[ NODE_FIELD ], ATTR_HELPSTRING );
    RESET_ATTR( DisallowedAttrs[ NODE_FIELD ], ATTR_HIDDEN );
    RESET_ATTR( DisallowedAttrs[ NODE_FIELD ], ATTR_MEMBER );
    RESET_ATTR( DisallowedAttrs[ NODE_FIELD ], ATTR_IDLDESCATTR);
    RESET_ATTR( DisallowedAttrs[ NODE_FIELD ], ATTR_VARDESCATTR);
    RESET_ATTR( DisallowedAttrs[ NODE_FIELD ], ATTR_CUSTOM);

    // turn off bits for attributes allowed on structs
    SET_ALL_ATTR( DisallowedAttrs[ NODE_STRUCT ] );
    RESET_ATTR( DisallowedAttrs[ NODE_STRUCT ], ATTR_GUID );
    RESET_ATTR( DisallowedAttrs[ NODE_STRUCT ], ATTR_CONTEXT );
    RESET_ATTR( DisallowedAttrs[ NODE_STRUCT ], ATTR_NOSERIALIZE);
    RESET_ATTR( DisallowedAttrs[ NODE_STRUCT ], ATTR_SERIALIZE);
    RESET_ATTR( DisallowedAttrs[ NODE_STRUCT ], ATTR_HIDDEN );
    RESET_ATTR( DisallowedAttrs[ NODE_STRUCT ], ATTR_TYPE );
    RESET_ATTR( DisallowedAttrs[ NODE_STRUCT ], ATTR_TYPEDESCATTR );
    RESET_ATTR( DisallowedAttrs[ NODE_STRUCT ], ATTR_CUSTOM );
    RESET_ATTR( DisallowedAttrs[ NODE_STRUCT ], ATTR_MEMBER );

    // turn off bits for attributes allowed on unions
    SET_ALL_ATTR( DisallowedAttrs[ NODE_UNION ] );
    RESET_ATTR( DisallowedAttrs[ NODE_UNION ], ATTR_GUID );
    RESET_ATTR( DisallowedAttrs[ NODE_UNION ], ATTR_CONTEXT );
    RESET_ATTR( DisallowedAttrs[ NODE_UNION ], ATTR_NOSERIALIZE);
    RESET_ATTR( DisallowedAttrs[ NODE_UNION ], ATTR_SERIALIZE);
    RESET_ATTR( DisallowedAttrs[ NODE_UNION ], ATTR_SWITCH_TYPE );
    RESET_ATTR( DisallowedAttrs[ NODE_UNION ], ATTR_SWITCH_IS );
    RESET_ATTR( DisallowedAttrs[ NODE_UNION ], ATTR_MS_UNION );
    RESET_ATTR( DisallowedAttrs[ NODE_UNION ], ATTR_HIDDEN );
    RESET_ATTR( DisallowedAttrs[ NODE_UNION ], ATTR_TYPE );
    RESET_ATTR( DisallowedAttrs[ NODE_UNION ], ATTR_TYPEDESCATTR );
    RESET_ATTR( DisallowedAttrs[ NODE_UNION ], ATTR_CUSTOM );
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\front\pass2.cxx ===
/*****************************************************************************/
/**						Microsoft LAN Manager								**/
/**				Copyright(c) Microsoft Corp., 1987-1999						**/
/*****************************************************************************/
/*****************************************************************************
File				: pass2.cxx
Title				: pass2 controller
History				:
	24-Aug-1991	VibhasC	Created

*****************************************************************************/

#if 0
						Notes
						-----
This file provides the interface for the acf semantics pass. It also
initializes the pass2 controller object.

#endif // 0

#pragma warning ( disable : 4514 )

/****************************************************************************
 includes
 ****************************************************************************/

#include "nulldefs.h"
extern	"C"	{
	#include <string.h>
	#include <stdio.h>
	#include <stdlib.h>
	#include <malloc.h>
	extern int yyacfparse();
}

#include "allnodes.hxx"
#include "control.hxx"
#include "cmdana.hxx"
#include "filehndl.hxx"
#include "idict.hxx"

/****************************************************************************
	local definitions
 ****************************************************************************/

#define ACF_ATTR_COUNT	(ACF_ATTR_END - ACF_ATTR_START)
#define ACF_ATTR_MAX	(ACF_ATTR_COUNT - 1)

/****************************************************************************
	extern procedures
 ****************************************************************************/

extern void						initlex();
extern void						ParseError( STATUS_T, char * );

/****************************************************************************
	extern data 
 ****************************************************************************/

extern class ccontrol		*	pCompiler;
extern node_source			*	pSourceNode;
extern NFA_INFO				*	pImportCntrl;
extern CMD_ARG				*	pCommand;

/****************************************************************************
	local data
 ****************************************************************************/

/****************************************************************************/


_pass2::_pass2()
	{
	pCompiler->SetPassNumber( ACF_PASS );
	}

STATUS_T
_pass2::Go()
	{
	MEM_ITER			MemIter( pSourceNode );
	node_file		*	pFNode;
	node_file		*	pBaseFileNode = 0;
	char				Buffer[_MAX_DRIVE+_MAX_PATH+_MAX_FNAME+_MAX_EXT+1];
	STATUS_T			Status = STATUS_OK;

	/**
	 ** create a new import controller for the acf and
	 ** set the defaults needed
	 **/

	pImportCntrl	= pCompiler->SetImportController( new NFA_INFO );
	pImportCntrl->Init();

	/**
	 ** for each idl file, check if the corresponding acf exists.
	 ** if yes, process it.
	 **/


	while ( ( pFNode = (node_file *) MemIter.GetNext() ) != 0 )
		{
		pFileNode = pFNode;
		if(pFNode->GetImportLevel() == 0)
			pBaseFileNode = pFNode;

		if( pFNode->AcfExists() )
			{
			pFNode->AcfName( Buffer );

			if( !pImportCntrl->IsDuplicateInput( Buffer ) )
				{
				Status = pImportCntrl->SetNewInputFile( Buffer );
				char * pCopy	= new char[ strlen( Buffer) + 1];
				strcpy( pCopy, Buffer );
				AddFileToDB( pCopy );

				if( Status != STATUS_OK)
					break;

				pImportCntrl->ResetEOIFlag();

				initlex();


				if( yyacfparse()  || pCompiler->GetErrorCount() )
					{
					Status = SYNTAX_ERROR;
					break;
					}
				}
			}
		else if(pFNode->GetImportLevel() == 0)
			{

			// he could not find  the acf file. If the user did specify 
			// an acf switch then we must error out if we do not find
			// the acf.

			if( pCommand->IsSwitchDefined( SWITCH_ACF ) )
				{
				RpcError((char *)NULL,
						 0,
						 (Status = INPUT_OPEN) ,
						 pCommand->GetAcfFileName());
				break;
				}
			}

		// clean up
		pImportCntrl->EndOperations();

		} // end of outer while loop

	if( (Status == STATUS_OK) )
		{
		/**
	 	 ** The acf pass may have created include file nodes They must translate
	 	 ** into include statements in the generated stubs. We handle that by
	 	 ** merging the include file list with the members of the source node.
	 	 **/

		pSourceNode->MergeMembersToHead( AcfIncludeList );	

		}
	else
		{
		ParseError( ERRORS_PASS1_NO_PASS2, (char *)0 );
		}

	delete pImportCntrl;
	return Status;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\front\procnode.cxx ===
/*****************************************************************************/
/**                     Microsoft LAN Manager                               **/
/**             Copyright(c) Microsoft Corp., 1987-1999                     **/
/*****************************************************************************/
/*****************************************************************************
File                : procnode.cxx
Title               : proc / param semantic analyser routines
History             :
    10-Aug-1991 VibhasC Created

*****************************************************************************/

#pragma warning ( disable : 4514 4710 )

/****************************************************************************
 includes
 ****************************************************************************/

#include "nulldefs.h"
extern  "C" {
    #include <stdio.h>
    
    #include <string.h>
}
#include "allnodes.hxx"
#include "cmdana.hxx"
#include "idict.hxx"

/****************************************************************************
 local defines
 ****************************************************************************/
/****************************************************************************
 externs 
 ****************************************************************************/

extern CMD_ARG              *   pCommand;

extern node_e_status_t      *   pError_status_t;

/****************************************************************************
 extern  procedures
 ****************************************************************************/


/****************************************************************************/

/****************************************************************************
    proc node procedures
 ****************************************************************************/

//
// add extra "hidden" [comm_status] or [fault_status] parameter
//

void
node_proc::AddStatusParam( 
    char * pName, 
    ATTRLIST AList )
{
    // find error_status_t, make pointer, make param
    // add param to end of param list

    node_pointer *      pPtr    = new node_pointer;
    node_param      *   pParam  = new node_param;

    pPtr->SetChild( pError_status_t );
    pParam->SetChild( pPtr );
    pParam->SetSymName( pName );

    // add param to end of MY param list

    AddLastMember( pParam );

    pParam->AddAttributes( AList );

    // Take note that the parameter is "invisible".

    SetHasExtraStatusParam();
    pParam->SetExtraStatusParam();
}

// force a proc to use -Os 
BOOL
node_proc::ForceNonInterpret()
{
    // ndr64 doesn't do -Os.  In theory we've caught all the cases where
    // a switch to -Os is required.  Just in case we missed one, catch it now

    if ( pCommand->NeedsNDR64Run() )
        RpcError( NULL, 0, UNEXPECTED_OS_IN_NDR64, GetSymName() );

    unsigned short      NewOpt  = GetOptimizationFlags();
    unsigned short      OldOpt = NewOpt;

    // remove interpret, set size
    // zero all the possible interpreter flags

    NewOpt  &= ~OPTIMIZE_ALL_I2_FLAGS;
    NewOpt  |=  OPTIMIZE_SIZE;   

    // did anything change?
    BOOL fChanged = OldOpt != NewOpt;
    if (fChanged)
        SetOptimizationFlags( NewOpt );

    fForcedS = TRUE;
    return fChanged;
}

// force a proc to use -Oi2
BOOL
node_proc::ForceInterpret2()
{
    unsigned short      NewOpt  = GetOptimizationFlags();
    unsigned short      OldOpt = NewOpt;

    // remove interpret, set size
    NewOpt  &= ~OPTIMIZE_SIZE;   
    NewOpt  |= OPTIMIZE_ALL_I2_FLAGS;
    
    // did anything change?
    BOOL fChanged = OldOpt != NewOpt;
    if (fChanged)
        SetOptimizationFlags( NewOpt );

    fForcedI2 = TRUE;
    return fChanged;
}

BOOL
node_proc::HasAtLeastOneShipped()
{
    MEM_ITER        MemIter( this );
    node_skl    *   pNode;
    BOOL            f = FALSE;

    while ( ( pNode = MemIter.GetNext() ) != 0 )
        {
        if( pNode->FInSummary( ATTR_IN ) )
            {
            node_skl * pT = pNode->GetBasicType();

            if( pT->NodeKind() == NODE_POINTER )
                pT = pT->GetBasicType();

            if( pT->GetBasicType()->NodeKind() != NODE_HANDLE_T )
                {
                f = TRUE;
                break; // from the while loop.
                }
            }
        }
    return f;
}

// returns ATTR_NONE if none explicitly specified

BOOL            
node_proc::GetCallingConvention( ATTR_T & Attr )
{
    Attr = ATTR_NONE;
    if ( FInSummary( ATTR_STDCALL ) )
        {
        Attr = ATTR_STDCALL;
        }
    if ( FInSummary( ATTR_CDECL ) )
        {
        if ( Attr != ATTR_NONE ) return FALSE;
        Attr = ATTR_CDECL;
        }
    if ( FInSummary( ATTR_FASTCALL ) )
        {
        if ( Attr != ATTR_NONE ) return FALSE;
        Attr = ATTR_FASTCALL;
        }
    if ( FInSummary( ATTR_PASCAL ) )
        {
        if ( Attr != ATTR_NONE ) return FALSE;
        Attr = ATTR_PASCAL;
        }
    if ( FInSummary( ATTR_FORTRAN ) )
        {
        if ( Attr != ATTR_NONE ) return FALSE;
        Attr = ATTR_FORTRAN;
        }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\front\nkeyw.c ===
/*****************************************************************************
 *      Copyright (c) 1990-1999 Microsoft Corporation
 *
 *                      RPC compiler: Pass1 handler
 *
 *      Author  : Vibhas Chandorkar
 *      Created : 01st-Sep-1990
 *
 ****************************************************************************/

#pragma warning ( disable : 4514 4214 )

/****************************************************************************
 *                      include files
 ***************************************************************************/
#include "nulldefs.h"
#include "midldebug.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "grammar.h"
#include "lex.h"

/****************************************************************************
 *                      local definitions and macros
 ***************************************************************************/

const struct _keytable
    {

    const char  *   pString;
    token_t         Token   : 16;
    short           flag    : 16;

    } KeywordTable[] =
{
 {"FALSE",              TOKENFALSE,         UNCONDITIONAL }
,{"ISO_LATIN_1",        KWISOLATIN1,        UNCONDITIONAL }
,{"ISO_UCS",            KWISOUCS,           UNCONDITIONAL }
,{"ISO_MULTI_LINGUAL",  KWISOMULTILINGUAL,  UNCONDITIONAL }
,{"NULL",               KWTOKENNULL,        UNCONDITIONAL }
,{"SAFEARRAY",          KWSAFEARRAY,        UNCONDITIONAL }
,{"TRUE",               TOKENTRUE,          UNCONDITIONAL }
,{"__alignof",          KWALIGNOF,          UNCONDITIONAL }
,{"__asm",              MSCASM,             UNCONDITIONAL }
,{"__cdecl",            MSCCDECL,           UNCONDITIONAL }
,{"__declspec",         KWMSCDECLSPEC,      UNCONDITIONAL }
,{"__export",           MSCEXPORT,          UNCONDITIONAL }
,{"__far",              MSCFAR,             UNCONDITIONAL }
,{"__fastcall",         MSCFASTCALL,        UNCONDITIONAL }
,{"__float128",         KWFLOAT128,         UNCONDITIONAL }
,{"__float80",          KWFLOAT80,          UNCONDITIONAL }
,{"__fortran",          MSCFORTRAN,         UNCONDITIONAL }
,{"__huge",             MSCHUGE,            UNCONDITIONAL }
,{"__inline",           KW_C_INLINE,        UNCONDITIONAL }
,{"__int128",           KWINT128,           UNCONDITIONAL }
,{"__int32",            KWINT32,            UNCONDITIONAL }
,{"__int3264",          KWINT3264,          UNCONDITIONAL }
,{"__int64",            KWINT64,            UNCONDITIONAL }
,{"__loadds",           MSCLOADDS,          UNCONDITIONAL }
,{"__near",             MSCNEAR,            UNCONDITIONAL }
,{"__pascal",           MSCPASCAL,          UNCONDITIONAL }
,{"__ptr32",            MSCPTR32,           UNCONDITIONAL }
,{"__ptr64",            MSCPTR64,           UNCONDITIONAL }
,{"__saveregs",         MSCSAVEREGS,        UNCONDITIONAL }
,{"__segment",          MSCSEGMENT,         UNCONDITIONAL }
,{"__self",             MSCSELF,            UNCONDITIONAL }
,{"__stdcall",          MSCSTDCALL,         UNCONDITIONAL }
,{"__unaligned",        MSCUNALIGNED,       UNCONDITIONAL }
,{"__w64",              MSCW64,             UNCONDITIONAL }
,{"_asm",               MSCASM,             UNCONDITIONAL }
,{"_cdecl",             MSCCDECL,           UNCONDITIONAL }
,{"_declspec",          KWMSCDECLSPEC,      UNCONDITIONAL }
,{"_export",            MSCEXPORT,          UNCONDITIONAL }
,{"_far",               MSCFAR,             UNCONDITIONAL }
,{"_fastcall",          MSCFASTCALL,        UNCONDITIONAL }
,{"_fortran",           MSCFORTRAN,         UNCONDITIONAL }
,{"_huge",              MSCHUGE,            UNCONDITIONAL }
,{"_inline",            KW_C_INLINE,        UNCONDITIONAL }
,{"_loadds",            MSCLOADDS,          UNCONDITIONAL }
,{"_near",              MSCNEAR,            UNCONDITIONAL }
,{"_pascal",            MSCPASCAL,          UNCONDITIONAL }
,{"_saveregs",          MSCSAVEREGS,        UNCONDITIONAL }
,{"_segment",           MSCSEGMENT,         UNCONDITIONAL }
,{"_self",              MSCSELF,            UNCONDITIONAL }
,{"_stdcall",           MSCSTDCALL,         UNCONDITIONAL }
,{"aggregatable",       KWAGGREGATABLE,     INBRACKET }
,{"align",              KWALIGN,            INBRACKET }
,{"allocate",           KWALLOCATE,         INBRACKET }
,{"appobject",          KWAPPOBJECT,        INBRACKET }
,{"async",              KWASYNC,            INBRACKET }
,{"async_uuid",         KWASYNCUUID,        INBRACKET }
,{"auto",               KWAUTO,             UNCONDITIONAL }
,{"auto_handle",        KWAUTOHANDLE,       INBRACKET }
,{"bindable",           KWBINDABLE,         INBRACKET }
,{"boolean",            KWBOOLEAN,          UNCONDITIONAL }
,{"broadcast",          KWBROADCAST,        INBRACKET }
,{"bstring",            KWBSTRING,          INBRACKET }
,{"byte",               KWBYTE,             UNCONDITIONAL }
,{"byte_count",         KWBYTECOUNT,        INBRACKET }
,{"call_as",            KWCALLAS,           INBRACKET }
,{"callback",           KWCALLBACK,         INBRACKET }
,{"case",               KWCASE,             UNCONDITIONAL }
,{"cdecl",              MSCCDECL,           UNCONDITIONAL }
,{"char",               KWCHAR,             UNCONDITIONAL }
,{"coclass",            KWCOCLASS,          UNCONDITIONAL }
,{"code",               KWCODE,             INBRACKET }
,{"comm_status",        KWCOMMSTATUS,       INBRACKET }
,{"const",              KWCONST,            UNCONDITIONAL }
,{"context_handle",     KWCONTEXTHANDLE,    INBRACKET }
,{"context_handle_noserialize",KWNOSERIALIZE,      INBRACKET }
,{"context_handle_serialize",  KWSERIALIZE,        INBRACKET }
,{"control",            KWCONTROL,          INBRACKET }
,{"cpp_quote",          KWCPPQUOTE,         UNCONDITIONAL }
,{"cs_char",            KWCSCHAR,           INBRACKET }
,{"cs_drtag",           KWCSDRTAG,          INBRACKET }
,{"cs_rtag",            KWCSRTAG,           INBRACKET }
,{"cs_stag",            KWCSSTAG,           INBRACKET }
,{"cs_tag_rtn",         KWCSTAGRTN,         INBRACKET }
,{"custom",             KWCUSTOM,           INBRACKET }
,{"declare_guid",       KWDECLGUID,         UNCONDITIONAL }
,{"decode",             KWDECODE,           INBRACKET }
,{"default",            KWDEFAULT,          UNCONDITIONAL }
,{"defaultbind",        KWDEFAULTBIND,      INBRACKET }
,{"defaultcollelem",    KWDEFAULTCOLLELEM,  INBRACKET }
,{"defaultvalue",       KWDEFAULTVALUE,     INBRACKET }
,{"defaultvtable",      KWDEFAULTVTABLE,    INBRACKET }
,{"dispinterface",      KWDISPINTERFACE,    UNCONDITIONAL }
,{"displaybind",        KWDISPLAYBIND,      INBRACKET }
,{"dllname",            KWDLLNAME,          INBRACKET }
,{"double",             KWDOUBLE,           UNCONDITIONAL }
,{"dual",               KWDUAL,             INBRACKET }
,{"enable_allocate",    KWENABLEALLOCATE,   INBRACKET }
,{"encode",             KWENCODE,           INBRACKET }
,{"endpoint",           KWENDPOINT,         INBRACKET }
,{"entry",              KWENTRY,            INBRACKET}
,{"enum",               KWENUM,             UNCONDITIONAL }
,{"explicit_handle",    KWEXPLICITHANDLE,   INBRACKET }
,{"extern",             KWEXTERN,           UNCONDITIONAL }
,{"far",                MSCFAR,             UNCONDITIONAL }
,{"fault_status",       KWFAULTSTATUS,      INBRACKET }
,{"first_is",           KWFIRSTIS,          INBRACKET }
,{"float",              KWFLOAT,            UNCONDITIONAL }
,{"force_allocate",		KWFORCEALLOCATE,	INBRACKET }
,{"funcdescattr",       KWFUNCDESCATTR,     INBRACKET }
,{"handle",             KWHANDLE,           INBRACKET }
,{"handle_t",           KWHANDLET,          UNCONDITIONAL }
,{"heap",               KWHEAP,             INBRACKET }
,{"helpcontext",        KWHC,               INBRACKET }
,{"helpfile",           KWHELPFILE,         INBRACKET }
,{"helpstring",         KWHELPSTR,          INBRACKET }
,{"helpstringcontext",  KWHSC,              INBRACKET }
,{"helpstringdll",      KWHELPSTRINGDLL,    INBRACKET }
,{"hidden",             KWHIDDEN,           INBRACKET }
,{"hyper",              KWHYPER,            UNCONDITIONAL }
,{"id",                 KWID,               INBRACKET }
,{"idempotent",         KWIDEMPOTENT,       INBRACKET }
,{"idldescattr",        KWIDLDESCATTR,      INBRACKET }
,{"ignore",             KWIGNORE,           INBRACKET }
,{"iid_is",             KWIIDIS,            INBRACKET }
,{"immediatebind",      KWIMMEDIATEBIND,    INBRACKET }
,{"implicit_handle",    KWIMPLICITHANDLE,   INBRACKET }
,{"import",             KWIMPORT,           UNCONDITIONAL }
,{"importlib",          KWIMPORTLIB,        UNCONDITIONAL }
,{"in",                 KWIN,               INBRACKET }
,{"in_line",            KWINLINE,           INBRACKET }
,{"include",            KWINCLUDE,          UNCONDITIONAL }
,{"inline",             KW_C_INLINE,        UNCONDITIONAL }
,{"input_sync",         KWINPUTSYNC,        INBRACKET }
,{"int",                KWINT,              UNCONDITIONAL }
,{"interface",          KWINTERFACE,        UNCONDITIONAL }
,{"interpret",          KWINTERPRET,        INBRACKET }
,{"last_is",            KWLASTIS,           INBRACKET }
,{"lcid",               KWLCID,             INBRACKET}
,{"length_is",          KWLENGTHIS,         INBRACKET }
,{"library",            KWLIBRARY,          UNCONDITIONAL }
,{"licensed",           KWLICENSED,         INBRACKET }
,{"local",              KWLOCAL,            INBRACKET }
,{"local_call",         KWLOCAL,            INBRACKET }
,{"long",               KWLONG,             UNCONDITIONAL }
,{"long_enum",          KWLONGENUM,         INBRACKET }
,{"manual",             KWMANUAL,           INBRACKET }
,{"max_is",             KWMAXIS,            INBRACKET }
,{"maybe",              KWMAYBE,            INBRACKET }
,{"message",            KWMESSAGE,          INBRACKET }
,{"methods",            KWMETHODS,          UNCONDITIONAL }
,{"midl_pragma",        KWMIDLPRAGMA,       UNCONDITIONAL }
,{"min_is",             KWMINIS,            INBRACKET }
,{"module",             KWMODULE,           UNCONDITIONAL }
,{"ms_conf_struct",     KWMS_CONF_STRUCT,   INBRACKET }
,{"ms_union",           KWMSUNION,          INBRACKET }
,{"near",               MSCNEAR,            UNCONDITIONAL }
,{"nocode",             KWNOCODE,           INBRACKET }
,{"nointerpret",        KWNOINTERPRET,      INBRACKET }
,{"nonbrowsable",       KWNONBROWSABLE,     INBRACKET }
,{"noncreatable",       KWNONCREATABLE,     INBRACKET }
,{"nonextensible",      KWNONEXTENSIBLE,    INBRACKET }
,{"notify",             KWNOTIFY,           INBRACKET }
,{"notify_flag",        KWNOTIFYFLAG,       INBRACKET }
,{"object",             KWOBJECT,           INBRACKET }
,{"odl",                KWODL,              INBRACKET }
,{"off_line",           KWOFFLINE,          INBRACKET }
,{"oleautomation",      KWOLEAUTOMATION,    INBRACKET }
,{"optimize",           KWOPTIMIZE,         INBRACKET }
,{"optional",           KWOPTIONAL,         INBRACKET }
,{"out",                KWOUT,              INBRACKET }
,{"out_of_line",        KWOUTOFLINE,        INBRACKET }
,{"partial_ignore",     KWPARTIALIGNORE,    INBRACKET }
,{"pascal",             MSCPASCAL,          UNCONDITIONAL }
,{"pipe",               KWPIPE,             UNCONDITIONAL }
,{"pointer_default",    KWDEFAULTPOINTER,   INBRACKET }
,{"predeclid",          KWPREDECLID,        INBRACKET }
,{"private_char_16",    KWPRIVATECHAR16,    UNCONDITIONAL }
,{"private_char_8",     KWPRIVATECHAR8,     UNCONDITIONAL }
,{"properties",         KWPROPERTIES,       UNCONDITIONAL }
,{"propget",            KWPROPGET,          INBRACKET }
,{"propput",            KWPROPPUT,          INBRACKET }
,{"propputref",         KWPROPPUTREF,       INBRACKET }
,{"proxy",              KWPROXY,            INBRACKET }
,{"ptr",                KWPTR,              INBRACKET }
,{"public",             KWPUBLIC,           INBRACKET }
,{"range",              KWRANGE,            INBRACKET }
,{"readonly",           KWREADONLY,         INBRACKET }
,{"ref",                KWREF,              INBRACKET }
,{"register",           KWREGISTER,         UNCONDITIONAL }
,{"replaceable",        KWREPLACEABLE,      INBRACKET }
,{"represent_as",       KWREPRESENTAS,      INBRACKET }
,{"requestedit",        KWREQUESTEDIT,      INBRACKET }
,{"restricted",         KWRESTRICTED,       INBRACKET }
,{"retval",             KWRETVAL,           INBRACKET }
,{"shape",              KWSHAPE,            INBRACKET }
,{"short",              KWSHORT,            UNCONDITIONAL }
,{"short_enum",         KWSHORTENUM,        INBRACKET }
,{"signed",             KWSIGNED,           UNCONDITIONAL }
,{"size_is",            KWSIZEIS,           INBRACKET }
,{"sizeof",             KWSIZEOF,           UNCONDITIONAL }
,{"small",              KWSMALL,            UNCONDITIONAL }
,{"source",             KWSOURCE,           INBRACKET }
,{"static",             KWSTATIC,           UNCONDITIONAL }
,{"stdcall",            MSCSTDCALL,         UNCONDITIONAL }
,{"strict_context_handle", KWSTRICTCONTEXTHANDLE, INBRACKET }
,{"string",             KWSTRING,           INBRACKET }
,{"struct",             KWSTRUCT,           UNCONDITIONAL }
,{"switch",             KWSWITCH,           UNCONDITIONAL }
,{"switch_is",          KWSWITCHIS,         INBRACKET }
,{"switch_type",        KWSWITCHTYPE,       INBRACKET }
,{"transmit_as",        KWTRANSMITAS,       INBRACKET }
,{"typedef",            KWTYPEDEF,          UNCONDITIONAL }
,{"typedescattr",       KWTYPEDESCATTR,     INBRACKET }
,{"uidefault",          KWUIDEFAULT,        INBRACKET }
,{"unaligned",          KWUNALIGNED,        INBRACKET }
,{"union",              KWUNION,            UNCONDITIONAL }
,{"unique",             KWUNIQUE,           INBRACKET }
,{"unsigned",           KWUNSIGNED,         UNCONDITIONAL }
,{"user_marshal",       KWUSERMARSHAL,      INBRACKET }
,{"usesgetlasterror",   KWUSESGETLASTERROR, INBRACKET }
,{"uuid",               KWUUID,             INBRACKET }
,{"v1_array",           KWV1ARRAY,          INBRACKET }
,{"v1_enum",            KWV1ENUM,           INBRACKET }
,{"v1_string",          KWV1STRING,         INBRACKET }
,{"v1_struct",          KWV1STRUCT,         INBRACKET }
,{"vararg",             KWVARARG,           INBRACKET }
,{"vardescattr",        KWVARDESCATTR,      INBRACKET }
,{"version",            KWVERSION,          INBRACKET }
,{"void",               KWVOID,             UNCONDITIONAL }
,{"volatile",           KWVOLATILE,         UNCONDITIONAL }
,{"wire_marshal",       KWWIREMARSHAL,      INBRACKET }
};

#define SIZE_OF_KEYWORD_TABLE   \
        ( sizeof( KeywordTable ) / sizeof(struct _keytable ) )

/****************************************************************************
 *                      local data
 ***************************************************************************/

/****************************************************************************
 *                      local procedure prototypes
 ***************************************************************************/


/****************************************************************************
 *                      external data
 ***************************************************************************/

/****************************************************************************
 *                      external procedures/prototypes/etc
 ***************************************************************************/

/**************************************************************************
 is_keyword:
    Is the given string a keyword ? if yes, return the token value of
    the token. Else return IDENTIFIER.
 **************************************************************************/
token_t
is_keyword(
        char    *       pID,
        short           InBracket
        )
    {
    short cmp;

    short low  = 0;
    short high = SIZE_OF_KEYWORD_TABLE - 1;
    short mid;


    while ( low <= high )
        {
        mid = (short)( (low + high) / 2 );

        cmp =  (short) strcmp( pID, KeywordTable[mid].pString );
        if( cmp < 0 )
            {
            high = (short)( mid - 1 );
            }
        else if (cmp > 0)
            {
            low = (short)( mid + 1 );
            }
        else
            {
            // since InBracket is the only flag, this check is enough
            if (KeywordTable[mid].flag <= InBracket)
                return KeywordTable[mid].Token;
            else
                return IDENTIFIER;
            }

        }
    return IDENTIFIER;
    }

// The final return from KeywordToString is unreachable because of the
// MIDL_ASSERT.
#pragma warning(push)
#pragma warning(disable:4702)

char *
KeywordToString(
        token_t Token )
    {
    struct _keytable *  pTable      = (struct _keytable *) KeywordTable;
    struct _keytable *  pTableEnd   = pTable + SIZE_OF_KEYWORD_TABLE;


    while( pTable < pTableEnd )
        {
        if( pTable->Token == Token )
            return (char*) pTable->pString;
        pTable++;
        }

    MIDL_ASSERT( 0 );
    return "";
    }

#pragma warning(pop)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\front\prttype.cxx ===
/*++

Copyright (c) 1991-2000 Microsoft Corporation

Module Name:

    prttype.cxx

Abstract:

    This module collects implementations of DoPrintType and DoPrintDecl
    virtual methods for various classes derived from node_skl.

Author:

    Greg Jensenworth

Revision History:


--*/

#if defined(DBG)
#if DBG == 1
// Switch front end size comments on.
#define gajsize
#endif
#endif

#pragma warning ( disable : 4514 4706 4710 )

#include "nulldefs.h"
extern "C" {
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <malloc.h>

}

#include "allnodes.hxx"
#include "cmdana.hxx"
#include "prttype.hxx"
#include "buffer.hxx"


extern CMD_ARG *                pCommand;
extern node_source *    pSourceNode;

#ifdef gaj_debug_prt
#define midl_debug(str) printf("%s", str);
#else
#define midl_debug(str)
#endif

#ifdef _SPITGENSEQ_
#define DUMP_DEBUG_INFO( infotext )                                           \
    printf( infotext " %20s, %16X\n", GetSymName(), Flags);                   \
    GetModifiers().PrintDebugInfo();                                          \

#else
#define DUMP_DEBUG_INFO( infotext )                                           \
    Flags;                                                                    \

#endif

extern  BOOL                    IsTempName( char *);
extern  char *                  GetOperatorString( OPERATOR );
extern  node_skl*               GetNonDefType   ( node_skl*  pType );

////////////////////////////////////////////////////////
// local variables

enum STRING_COMPONENT {
        CHAR_BLANK,
        CHAR_TAB,
        CHAR_COMMA,
        CHAR_EQUAL,
        CHAR_LBRACK,
        CHAR_RBRACK,
        CHAR_LPAREN,
        CHAR_RPAREN,
        CHAR_SEMICOLON,
        OP_DEREF,
        OP_ADDRESS,
        OP_MEMBER,
        OP_POINTER,
        WORD_STRUCT,
        WORD_UNION,
        WORD_ENUM,
        WORD_VOID,
        RETURN_VALUE,
        WORD_SIGNED,
        WORD_UNSIGNED,
        UHYPER_PREFIX,
        WORD_COLON_COLON,
        WORD_W64,
        LAST_COMPONENT
} ;


const char * STRING_TABLE[LAST_COMPONENT+1] =
        {
        " ",
        "\t",
        ", ",
        "= ",
        "[ ",
        " ]",
        "( ",
        " )",
        ";",
        "*",
        "&",
        ".",
        "->",
        "struct ",
        "union ",
        "enum ",
        "void ",
        "_ret_value ",
        "signed ",
        "unsigned ",
        "MIDL_u",
        "::",
        "__w64",
        "--filler--"
        } ;

void
node_skl::EmitModelModifiers( BufferManager * pBuffer)
{
/*
REVIEW: We should probably just get rid of these and maybe some of the
        others also

        if (GetModifiers().IsModifierSet(ATTR_FAR))
                pBuffer->ConcatHead("__far ");
        if (GetModifiers().IsModifierSet(ATTR_NEAR))
                pBuffer->ConcatHead("__near ");
        if (GetModifiers().IsModifierSet(ATTR_HUGE))
                pBuffer->ConcatHead("__huge ");
*/
        if (GetModifiers().IsModifierSet(ATTR_SEGMENT))
                pBuffer->ConcatHead("__segment ");
        if (GetModifiers().IsModifierSet(ATTR_SELF))
                pBuffer->ConcatHead("__self ");
        if (GetModifiers().IsModifierSet(ATTR_BASE))
                pBuffer->ConcatHead("__based ");
        if (GetModifiers().IsModifierSet(ATTR_MSCUNALIGNED))
                pBuffer->ConcatHead("__unaligned ");

};


void
node_skl::EmitModifiers( BufferManager * pBuffer, bool fSuppressConst )
{
        if (GetModifiers().IsModifierSet(ATTR_VOLATILE))
                pBuffer->ConcatHead("volatile ");
        if (GetModifiers().IsModifierSet(ATTR_CONST) && !fSuppressConst )
                pBuffer->ConcatHead("const ");
        if (GetModifiers().IsModifierSet(ATTR_DLLIMPORT))
                pBuffer->ConcatHead("__MIDL_DECLSPEC_DLLIMPORT ");
        if (GetModifiers().IsModifierSet(ATTR_DLLEXPORT))
                pBuffer->ConcatHead("__MIDL_DECLSPEC_DLLEXPORT ");
        if (GetModifiers().IsModifierSet(ATTR_DECLSPEC_ALIGN)) 
            {
            char *Chars = new char[256];
            unsigned long Alignment = GetModifiers().GetDeclspecAlign();
            sprintf(Chars, "__declspec(align(%d)) ", Alignment);
            pBuffer->ConcatHead(Chars);
            }
        if (GetModifiers().IsModifierSet(ATTR_DECLSPEC_UNKNOWN))
            {
            pBuffer->ConcatHead(GetModifiers().GetDeclspecUnknown());
            }

};

void node_skl::EmitPtrModifiers( BufferManager* pBuffer, unsigned long )
{
    if ( GetModifiers().IsModifierSet( ATTR_PTR32 ) )
        {
        pBuffer->ConcatHead("__ptr32 ");
        }
    else if ( GetModifiers().IsModifierSet( ATTR_PTR64 ) )
        {
        pBuffer->ConcatHead("__ptr64 ");
        }
}

void
node_skl::EmitProcModifiers( BufferManager * pBuffer, PRTFLAGS Flags)
{
        ATTR_T          CallConv;

        ( (node_proc *) this)->GetCallingConvention( CallConv );

        switch ( CallConv )
                {
                case ATTR_PASCAL:
                        pBuffer->ConcatHead("__pascal ");
                        break;
                case ATTR_FORTRAN:
                        pBuffer->ConcatHead("__fortran ");
                        break;
                case ATTR_CDECL:
                        pBuffer->ConcatHead("__cdecl ");
                        break;
                case ATTR_FASTCALL:
                        pBuffer->ConcatHead("__fastcall ");
                        break;
                case ATTR_STDCALL:
                        pBuffer->ConcatHead("__stdcall ");
                        break;
                default:
                        if ( Flags & PRT_FORCE_CALL_CONV )
                                {
                                // tbd - allow command line switch for default
                                pBuffer->ConcatHead("STDMETHODCALLTYPE ");
                                }
                }

        if (GetModifiers().IsModifierSet(ATTR_LOADDS))
                pBuffer->ConcatHead("__loadds ");
        if (GetModifiers().IsModifierSet(ATTR_SAVEREGS))
                pBuffer->ConcatHead("__saveregs ");
        if (GetModifiers().IsModifierSet(ATTR_INTERRUPT))
                pBuffer->ConcatHead("__interrupt ");
        if (GetModifiers().IsModifierSet(ATTR_EXPORT))
                pBuffer->ConcatHead("__export ");
        if (GetModifiers().IsModifierSet(ATTR_C_INLINE))
                pBuffer->ConcatHead("__inline ");

};

void
node_skl::PrintMemoryInfo( ISTREAM *pStream, BOOL bNewLine )
{
#if defined(DBG) && (DBG==1)
    char NumBuf[40];
    memset(NumBuf, 0, sizeof(NumBuf));
    FRONT_MEMORY_INFO MemInfo = GetMemoryInfo();
                        

    pStream->Write("/* size is ");
    _snprintf(NumBuf, 39, "%u", MemInfo.Size); 
    pStream->Write(NumBuf);
    pStream->Write(", align is ");
    _snprintf(NumBuf, 39, "%u", (unsigned long)MemInfo.Align);
    pStream->Write(NumBuf);
    if (MemInfo.IsMustAlign)
        {
        pStream->Write(", must align ");
        }
    pStream->Write("*/");
    if (bNewLine)
        pStream->Write("\n");
#else
    pStream; bNewLine;
#endif
    return;
}

void 
node_echo_string::PrintMemoryInfo( ISTREAM *pStream, BOOL bNewLine )
{
    // do nothing;
    pStream; bNewLine;
    return;
}

inline void
named_node::DumpAttributes( ISTREAM * pStream )
        {
        if (AttrList)
                {
                pStream->Write("/* ");
                AttrList.Dump( pStream );
                pStream->Write(" */ ");
                }
        };

STATUS_T
node_base_type::DoPrintType(
        PRTFLAGS                Flags,
        BufferManager * pBuffer,
        ISTREAM           * ,
        node_skl        *       pParent,
        node_skl        *       )
/*++

Routine Description:

    This routine prints definition for a node of base type. 

Arguments:

    Parent - Supplies type of the parent node.

    pBuffer - Supplies a buffer to accumulate output.

--*/
{
        DUMP_DEBUG_INFO( "node_base_type::DoPrintType" );

        char *                  pName;
        NODE_T                  Type;
        unsigned short  Option;

        midl_debug ("node_base_type::DoPrintType\n");

        pName = GetSymName();
        MIDL_ASSERT (pName != (char *)0);

        Type = NodeKind();

        Option = pCommand->GetCharOption ();

        if ( pParent &&
             ( ( Flags & PRT_SUPPRESS_MODEL ) == 0)  )
                {
                pParent->EmitModelModifiers (pBuffer);
                }

        switch (Type)
                {
                case NODE_BOOLEAN :
                    {
                        if (pCommand->IsSwitchDefined(SWITCH_MKTYPLIB))
                            {
                            pBuffer->ConcatHead(CHAR_BLANK);
                            pBuffer->ConcatHead("VARIANT_BOOL");
                            if (FInSummary(ATTR_UNSIGNED))
                                {
                                pBuffer->ConcatHead (WORD_UNSIGNED);
                                }
                            else if (FInSummary(ATTR_SIGNED))
                                {
                                pBuffer->ConcatHead (WORD_SIGNED);
                                }
                            break;
                            }
                    // deliberately fall through        
                    }
                case NODE_DOUBLE :
                case NODE_FLOAT :
                case NODE_FLOAT80 : 
                case NODE_FLOAT128 :
                case NODE_INT64 :
                case NODE_INT128:
                case NODE_LONGLONG :
                case NODE_INT3264 :
                case NODE_INT32 :
                case NODE_LONG :
                case NODE_SHORT :
                case NODE_BYTE :
                case NODE_INT :
                case NODE_HANDLE_T :
                case NODE_VOID :
                        pBuffer->ConcatHead (CHAR_BLANK);
                        pBuffer->ConcatHead (pName);
                        if (FInSummary(ATTR_UNSIGNED))
                                {
                                pBuffer->ConcatHead (WORD_UNSIGNED);
                                }
                        else if (FInSummary(ATTR_SIGNED))
                                {
                                pBuffer->ConcatHead (WORD_SIGNED);
                                }
                        if (FInSummary(ATTR_W64))
                                {
                                pBuffer->ConcatHead (CHAR_BLANK);
                                pBuffer->ConcatHead (WORD_W64);
                                }
                        break;
                case NODE_HYPER :
                        pBuffer->ConcatHead (CHAR_BLANK);
                        pBuffer->ConcatHead (pName);
                        if (FInSummary(ATTR_UNSIGNED))
                                {
                                pBuffer->ConcatHead (UHYPER_PREFIX);
                                }
                        break;
                case NODE_CHAR :
                        pBuffer->ConcatHead (CHAR_BLANK);
                        pBuffer->ConcatHead (pName);
                        if (FInSummary(ATTR_UNSIGNED))
                                {
                                pBuffer->ConcatHead (WORD_UNSIGNED);
                                }
                        else if (FInSummary(ATTR_SIGNED))
                                {
                                pBuffer->ConcatHead (WORD_SIGNED);
                                }
                        else if (Option == CHAR_SIGNED)
                                {
                                pBuffer->ConcatHead (WORD_UNSIGNED);
                                }
                        break;
                case NODE_SMALL :
                        pBuffer->ConcatHead (CHAR_BLANK);
                        pBuffer->ConcatHead (pName);
                        if (FInSummary(ATTR_UNSIGNED))
                                {
                                pBuffer->ConcatHead (WORD_UNSIGNED);
                                }
                        else if (FInSummary(ATTR_SIGNED))
                                {
                                pBuffer->ConcatHead (WORD_SIGNED);
                                }
                        else if (Option == CHAR_UNSIGNED)
                                {
                                pBuffer->ConcatHead (WORD_SIGNED);
                                }
                        break;
                default :
                        return I_ERR_INVALID_NODE_TYPE;
                }

        if (pParent)
                {
                pParent->EmitModifiers (pBuffer, ( ( Flags & PRT_SUPPRESS_MODIFIERS ) != 0 ) );
                }
        return STATUS_OK;
}

STATUS_T
node_base_type::DoPrintDecl(
        PRTFLAGS                Flags,
        BufferManager * pBuffer,
        ISTREAM           * pStream,
        node_skl        *       pParent,
        node_skl        *       pIntf)
/*++

Routine Description:

    This routine prints declaration for a node of base type.

Arguments:

    pParent - Supplies type of the parent node.

    pBuffer - Supplies a buffer to accumulate output.

--*/
{

        DUMP_DEBUG_INFO( "node_base_type::DoPrintDecl" );

        return DoPrintType( Flags, pBuffer, pStream, pParent, pIntf );
}

STATUS_T
node_e_status_t::DoPrintType(
        PRTFLAGS                Flags,
        BufferManager * pBuffer,
        ISTREAM           * ,
        node_skl        *       pParent,
        node_skl        *       )
/*++

Routine Description:

    This routine prints definition for a node of error_status_t type.

Arguments:

    pParent - Supplies type of the parent node to pass to the child node.

    pBuffer - Supplies a buffer to pass to the child node.

--*/
{
        DUMP_DEBUG_INFO( "node_e_status_t::DoPrintType" );

        char     *              pName;

        midl_debug ("node_e_status_t::DoPrintType\n");

        pName = GetSymName();

        MIDL_ASSERT (pName != (char *)0);

        if ( pParent  &&
             ( ( Flags & PRT_SUPPRESS_MODEL ) == 0))
                {
                pParent->EmitModelModifiers (pBuffer);
                }

        pBuffer->ConcatHead(CHAR_BLANK);
        pBuffer->ConcatHead(pName);

        if (pParent)
                {
                pParent->EmitModifiers (pBuffer, false );
                }

        return STATUS_OK;
}

STATUS_T
node_e_status_t::DoPrintDecl(
        PRTFLAGS                Flags,
        BufferManager * pBuffer,
        ISTREAM           * pStream,
        node_skl        *       pParent,
        node_skl        *       pIntf)
/*++

Routine Description:

    This routine prints declaration for a node of error_status_t type.

Arguments:

    pParent - Supplies type of the parent node.

    pBuffer - Supplies a buffer to accumulate output.

--*/
{

   DUMP_DEBUG_INFO( "node_e_status_t::DoPrintDecl" ); 

   return DoPrintType( Flags, pBuffer, pStream, pParent, pIntf );
}

STATUS_T
node_wchar_t::DoPrintType(
        PRTFLAGS                Flags,
        BufferManager * pBuffer,
        ISTREAM           * ,
        node_skl        *       pParent,
        node_skl        *       )
/*++

Routine Description:

    This routine prints definition for a node of wchar_t type.

Arguments:

    pParent - Supplies type of the parent node to pass to the child node.

    pBuffer - Supplies a buffer to pass to the child node.

--*/
{

        DUMP_DEBUG_INFO( "node_wchar_t::DoPrintType" );

        char    *               pName;

        midl_debug ("node_wchar_t::DoPrintType\n");
        pName = GetSymName();
        MIDL_ASSERT (pName != (char *)0);

        if ( pParent  &&
             ( ( Flags & PRT_SUPPRESS_MODEL ) == 0))
                {
                pParent->EmitModelModifiers (pBuffer);
                }

        pBuffer->ConcatHead(CHAR_BLANK);
        pBuffer->ConcatHead(pName);

        if (pParent)
                {
                pParent->EmitModifiers (pBuffer, false);
                }

        return STATUS_OK;
}

STATUS_T
node_wchar_t::DoPrintDecl(
        PRTFLAGS                Flags,
        BufferManager * pBuffer,
        ISTREAM           * pStream,
        node_skl        *       pParent,
        node_skl        *       pIntf)
/*++

Routine Description:

    This routine prints declaration for a node of wchar_t type.

Arguments:

    pParent - Supplies type of the parent node.

    pBuffer - Supplies a buffer to accumulate output.

--*/
{
        DUMP_DEBUG_INFO( "node_wchar_t::DoPrintDecl" );

        return DoPrintType( Flags, pBuffer, pStream, pParent, pIntf );
}

STATUS_T
node_def::DoPrintType(
        PRTFLAGS                Flags,
        BufferManager * pBuffer,
        ISTREAM           * pStream,
        node_skl        *       pParent,
        node_skl        *       pIntf)
/*++

Routine Description:

    This routine prints definition for a node of typedef.

Arguments:

    pParent - Supplies type of the parent node.

    pBuffer - Supplies a buffer to accumulate output.

--*/
{

        DUMP_DEBUG_INFO( "node_def::DoPrintType" );

        node_skl *              pNode;
        char *                  pName;
        NODE_T                  Type;
        STATUS_T                Status;

        midl_debug ("node_def::DoPrintType\n");
        pNode = GetChild();
        pName = GetSymName();
        MIDL_ASSERT (pName != (char *)0);
        Type = pNode->NodeKind();

        if( !IsTempName( pName ) )
            {
            pStream->Write ("typedef ");

            DumpAttributes( pStream );

            pStream->Write( GetDeclSpecGuid() );

            pBuffer->Clear ();
            if (pParent)
                {
                pParent->EmitModifiers (pBuffer, ( ( Flags & PRT_SUPPRESS_MODIFIERS ) != 0 ) );
                }

            pBuffer->Print(pStream);

            pBuffer->Clear ();
            pBuffer->ConcatHead (pName);
            }

        // the type specification is no longer at the top level
        Flags &= ~PRT_TRAILING_SEMI;
        if ( !IsDef() )
            {
            Status = pNode->DoPrintDecl (Flags, pBuffer, pStream, this, pIntf);
            }
        else
            {
            Status = pNode->DoPrintType (Flags, pBuffer, pStream, this, pIntf);
            }

        pBuffer->Print(pStream);
        pStream->Write (';');
        pStream->NewLine();

        return Status;
}

STATUS_T
node_def::DoPrintDecl(
        PRTFLAGS                Flags,
        BufferManager * pBuffer,
        ISTREAM           * ,
        node_skl        *       pParent,
        node_skl        *       )
/*++

Routine Description:

    This routine prints declaration for a node of typedef.

Arguments:

    pParent - Supplies type of the parent node.

    pBuffer - Supplies a buffer to accumulate output.

--*/
{
 
        DUMP_DEBUG_INFO( "node_def::DoPrintDecl" );

        char                            *       pName;
        node_represent_as       *       pRep;

        midl_debug ("node_def::DoPrintDecl\n");

        pName = GetSymName();

        node_cs_char *pCSChar = (node_cs_char *) GetAttribute( ATTR_CSCHAR );

        if ( pCSChar )
            pName = pCSChar->GetUserTypeName();

        MIDL_ASSERT (pName != (char *)0);

        if (pParent )
            {
            if ( ( Flags & PRT_SUPPRESS_MODEL ) == 0)
                    pParent->EmitModelModifiers (pBuffer);
            else
                    Flags &= ~PRT_SUPPRESS_MODEL;
            }

        pBuffer->ConcatHead(CHAR_BLANK);
        pRep = (node_represent_as *)GetAttribute( ATTR_REPRESENT_AS );
        if ( pRep )
                pName = pRep->GetRepresentationName();
    else
        {
        // Same thing for user_marshal (this is mut. exclusive with rep as)

        pRep = (node_represent_as *)GetAttribute( ATTR_USER_MARSHAL );
            if ( pRep )
                pName = pRep->GetRepresentationName();
        }

    char*       szNameToPrint = pName;
    node_skl*   pChild = GetChild();
    if ( pChild && pChild->NodeKind() == NODE_PIPE && Flags & PRT_ASYNC_DEFINITION )
        {
        szNameToPrint = new char[strlen(pName) + strlen(SZ_ASYNCPIPEDEFPREFIX) + 1];
        strcpy( szNameToPrint, SZ_ASYNCPIPEDEFPREFIX );
        strcat( szNameToPrint, pName );
        }

    pBuffer->ConcatHead(szNameToPrint);

    if (pParent)
            {
            pParent->EmitModifiers (pBuffer, ( ( Flags & PRT_SUPPRESS_MODIFIERS ) != 0 ) );
            }

    return STATUS_OK;
}

STATUS_T
node_array::DoPrintDecl(
        PRTFLAGS                Flags,
        BufferManager * pBuffer,
        ISTREAM           * pStream,
        node_skl        *       pParent,
        node_skl        *       pIntf)
/*++

Routine Description:

    This routine prints declaration for a node of array type.

Arguments:

    pParent - Supplies type of the parent node.

    pBuffer - Supplies a buffer to accumulate output.

--*/
{

        DUMP_DEBUG_INFO( "node_array::DoPrintDecl" );

        node_skl *      pNode;
        STATUS_T        Status;
        NODE_T          Parent  = (pParent)? pParent->NodeKind() : NODE_SOURCE;

        midl_debug ("node_array::DoPrintDecl\n");

        pNode = GetChild ();

        if (pParent )
                {
                if ( ( Flags & PRT_SUPPRESS_MODEL ) == 0)
                        pParent->EmitModelModifiers (pBuffer);
                else
                        Flags &= ~PRT_SUPPRESS_MODEL;
                }

        if (Parent == NODE_POINTER)
                {
                pBuffer->ConcatHead (CHAR_LPAREN);
                pBuffer->ConcatTail (CHAR_RPAREN);
                }

        pBuffer->ConcatTail (CHAR_LBRACK);
        if ( (pUpperBound) && (pUpperBound != (expr_node *) -1 ) )
            {
            char    *pNumBuf        = new char[16];

            pBuffer->ConcatTail (MIDL_ITOA( (ulong) pUpperBound->GetValue(), 
                                            pNumBuf, 
                                            10));
            }
        else
            {
            if ( Parent == NODE_FIELD || Parent == NODE_ARRAY
                || ( ( Flags & PRT_ARRAY_SIZE_ONE ) != 0 ) )
                {
                // conformant struct
                pBuffer->ConcatTail( "1" );
                }
            }
        pBuffer->ConcatTail (CHAR_RBRACK);

        if (pParent)
                {
                pParent->EmitModifiers (pBuffer, false);
                }

        // the type specification is no longer at the top level
        Flags &= ~PRT_TRAILING_SEMI;
        if ( ! IsDef() )
                {
                Status = pNode->DoPrintDecl (Flags, pBuffer, pStream, this, pIntf);
                }
        else
                {
                Status = pNode->DoPrintType (Flags, pBuffer, pStream, this, pIntf);
                }

        return Status;
}

STATUS_T
node_array::DoPrintType(
        PRTFLAGS                Flags,
        BufferManager * pBuffer,
        ISTREAM           * pStream,
        node_skl        *       pParent,
        node_skl        *       pIntf)
/*++

Routine Description:

    This routine prints definition for a node of array type.

Arguments:

    pParent - Supplies type of the parent node.

    pBuffer - Supplies a buffer to accumulate output.

--*/
{

        DUMP_DEBUG_INFO( "node_array::DoPrintType" );

        midl_debug ("node_array::DoPrintType\n");

        return DoPrintDecl (Flags, pBuffer, pStream, pParent, pIntf);
}

STATUS_T
node_pointer::DoPrintDecl(
        PRTFLAGS                Flags,
        BufferManager * pBuffer,
        ISTREAM           * pStream,
        node_skl        *       pParent,
        node_skl        *       pIntf)
/*++

Routine Description:

    This routine prints declaration for a node of pointer type.

Arguments:

    pParent - Supplies type of the parent node.

    pBuffer - Supplies a buffer to accumulate output.

--*/
{

        DUMP_DEBUG_INFO( "node_pointer::DoPrintDecl" );

        node_skl *      pNode;
        STATUS_T        Status;

        midl_debug ("node_pointer::DoPrintDecl\n");

        pNode = GetChild ();

        if (pParent )
            {
            if ( ( Flags & PRT_SUPPRESS_MODEL ) == 0)
                {
                pParent->EmitModelModifiers (pBuffer);
                }
            else
                {
                Flags &= ~PRT_SUPPRESS_MODEL;
                }

            pParent->EmitModifiers (pBuffer, ( Flags & PRT_SUPPRESS_MODIFIERS ) != 0 );
            }

        EmitPtrModifiers( pBuffer );
        pBuffer->ConcatHead (OP_DEREF);

        // the type specification is no longer at the top level
        Flags &= ~PRT_TRAILING_SEMI;
        if ( ! IsDef() )
            {
            Status = pNode->DoPrintDecl (Flags, pBuffer, pStream, this, pIntf);
            }
        else
            {
            Status = pNode->DoPrintType (Flags, pBuffer, pStream, this, pIntf);
            }

        return Status;
}

STATUS_T
node_pointer::DoPrintType(
        PRTFLAGS                Flags,
        BufferManager * pBuffer,
        ISTREAM           * pStream,
        node_skl        *       pParent,
        node_skl        *       pIntf)
/*++

Routine Description:

    This routine prints definition for a node of pointer type.

Arguments:

    pParent - Supplies type of the parent node.

    pBuffer - Supplies a buffer to accumulate output.

--*/
{

        DUMP_DEBUG_INFO( "node_pointer::DoPrintType" );
        midl_debug ("node_pointer::DoPrintType\n");

        return DoPrintDecl (Flags, pBuffer, pStream, pParent, pIntf);
}

STATUS_T
node_param::DoPrintType(
        PRTFLAGS                Flags,
        BufferManager * pBuffer,
        ISTREAM           * pStream,
        node_skl        *       ,
        node_skl        *       pIntf)
/*++

Routine Description:

    This routine prints declaration for a node of param type.

Arguments:

    pParent - Supplies type of the parent node.

    pBuffer - Supplies a buffer to accumulate output.

--*/
{

    DUMP_DEBUG_INFO( "node_param::DoPrintType" );

    node_skl *      pNode;
    char *          pName;
    STATUS_T        Status;
    BOOL            fAddSemi        = Flags & PRT_TRAILING_SEMI;
	node_constant_attr *	pAttr;

    midl_debug ("node_param::DoPrintType\n");

    pNode = GetChild ();
    pName = GetSymName ();
    MIDL_ASSERT (pName != (char *)0);

    pBuffer->Clear ();
    pBuffer->ConcatHead (pName);
    if (!strcmp(pName, "void")) return STATUS_OK;
    if (!strcmp(pName, "..."))
        {
        pStream->NewLine();
        pBuffer->Print( pStream );
        return STATUS_OK;
        }

    pStream->NewLine();

    DumpAttributes( pStream );

    // the type specification is no longer at the top level
    Flags &= ~PRT_TRAILING_SEMI;
    Status = pNode->DoPrintDecl (Flags, pBuffer, pStream, this, pIntf);

    pBuffer->Print(pStream);

    /* we want to force printing defaultvalue of BSTR to be wchar. scenarios:
          defaultvalue("value"); 
          defaultvalue(L"value"); 
          defaultvalue(0); 
          defaultvalue(NULL); 
          defaultvalue(VALUE); BSTR VALUE=L"value". 
          We can do nothing about char * VALUE = "value"

    */
    if ( (Flags & PRT_CPP_PROTOTYPE) && 
         HasGenDefaultValueExpr() &&
         (pAttr = (node_constant_attr *) GetAttribute( ATTR_DEFAULTVALUE ) ) )
        {
        expr_node   *pExpr = pAttr->GetExpr();
    	
        pStream->Write(" = ");

        if ( pNode->NodeKind() == NODE_DEF && !strcmp( pNode->GetSymName(), "BSTR" ) )
            {
            NODE_T Kind = ( pExpr->GetType()) ? (NODE_T) pExpr->GetType()->NodeKind()
                                              : (NODE_T) NODE_ILLEGAL;

            if ( pExpr->GetValue() != 0 && (Kind != NODE_ILLEGAL ) )
                {                
                // node_named_constant can only be NODE_ID or NODE_LABEL
                // only constant expr is allowed here, so this must be node_constant
                if  ( !(Kind == NODE_ID || Kind == NODE_LABEL  ) )
                    {
                    if ( ((expr_constant *)pExpr)->GetFormat() != VALUE_TYPE_WSTRING )
                        pStream->Write("L");
                    }
                pExpr->Print(pStream);
                }
            else
                {
		        pStream->Write("0");
                }
            }
        else
            {
                pExpr->Print(pStream);
            }
        }

    if ( fAddSemi )
        {
        pStream->Write (';');
        pStream->NewLine();
        };

    return Status;
}

STATUS_T
node_param::DoPrintDecl(
        PRTFLAGS                Flags,
        BufferManager * pBuffer,
        ISTREAM           * ,
        node_skl        *       pParent,
        node_skl        *       )
/*++

Routine Description:

    This routine emits the parameter as a local variable in callee stub.

Arguments:

    pParent - Supplies type of the parent node.

    pBuffer - Supplies a buffer to accumulate output.

--*/
{

        DUMP_DEBUG_INFO( "node_param::DoPrintDecl" );

        char                            *       pName;

        midl_debug ("node_param::DoPrintDecl\n");
        pName = GetSymName();
        MIDL_ASSERT (pName != (char *)0);
        if (pParent )
                {
                if ( ( Flags & PRT_SUPPRESS_MODEL ) == 0)
                        pParent->EmitModelModifiers (pBuffer);
                else
                        Flags &= ~PRT_SUPPRESS_MODEL;
                }

        pBuffer->ConcatHead(CHAR_BLANK);
        pBuffer->ConcatHead(pName);

        if (pParent)
                {
                pParent->EmitModifiers (pBuffer, false);
                }

        return STATUS_OK;
}

STATUS_T
node_proc::DoPrintDecl(
        PRTFLAGS                Flags,
        BufferManager * pBuffer,
        ISTREAM           * pStream,
        node_skl        *       pParent,
        node_skl        *       pIntf)
/*++

Routine Description:

    This routine prints procedure declaration.

Arguments:

    pParent - Supplies type of the parent node.

    pBuffer - Supplies a buffer to accumulate output.

--*/
{

    DUMP_DEBUG_INFO( "node_proc::DoPrintDecl" );

    MEM_ITER	MemIter( this );
    node_skl *  pNode;
    char *      pName   = GetSymName();
    char    *   pPrefix;
    NODE_T      Parent  = (pParent)? pParent->NodeKind() : NODE_ID;
    BOOL        fHasParameter = FALSE;
    PRTFLAGS    ChildFlags = Flags & ~(PRT_CALL_AS |
                                       PRT_THIS_POINTER |
                                       PRT_TRAILING_SEMI |
                                       PRT_CSTUB_PREFIX |
                                       PRT_SSTUB_PREFIX |
                                       PRT_SWITCH_PREFIX |
                                       PRT_QUALIFIED_NAME );

    midl_debug ("node_proc::DoPrintDecl\n");

    //
    // If PRT_OMIT_CS_TAG_PARAMS is on but we don't have a tag routine
    // the turn it back off
    //
    if ( Flags & PRT_OMIT_CS_TAG_PARAMS && NULL == GetCSTagRoutine() )
        {
        Flags &= ~PRT_OMIT_CS_TAG_PARAMS;
        }

    if ( (Flags & PRT_CALL_AS) == PRT_CALL_AS )
        {
        node_call_as            *       pAttr;
        node_skl                        *       pCallType;
        if ( pAttr = (node_call_as *) GetAttribute( ATTR_CALL_AS ) )
            {
            if ( pCallType = pAttr->GetCallAsType() )
                {
                return pCallType->DoPrintDecl(Flags, pBuffer, pStream, pParent, pIntf);
                }
            else
                {
                MIDL_ASSERT( 0 );
                }
            }
        }

    MIDL_ASSERT (pName != (char *)0);

    DumpAttributes( pStream );

    pNode = GetReturnType();

#ifdef gajdebug5
printf("\t parent type is %d, NODE_INTERFACE is %d\n", Parent, NODE_INTERFACE);
#endif

    if (pParent)
            {
            pParent->EmitModifiers (pBuffer, false);
            }

    if ( !pNode )
            {
            EmitModifiers( pBuffer, false );
            }

    if ( pParent )
            {
            pParent->EmitProcModifiers( pBuffer, Flags & ~PRT_FORCE_CALL_CONV );
            }

    EmitProcModifiers( pBuffer, Flags );

    // append the class name + :: to the proc name
    if ( Flags & PRT_QUALIFIED_NAME )
            {
            char    *               pIntfName;
            if ( pIntf )
                    pIntfName = pIntf->GetSymName();
            else
                    pIntfName = GetMyInterfaceNode()->GetSymName();

            pBuffer->ConcatTail( pIntfName );
            pBuffer->ConcatTail( WORD_COLON_COLON );
            }

    // append the client or server or switch prefix
    if ( (Parent == NODE_ID) ||
         (Parent == NODE_INTERFACE) ||
         (Parent == NODE_MODULE ) ||
         (Parent == NODE_COCLASS ) )
        {
        if( (Flags & PRT_CSTUB_PREFIX) == PRT_CSTUB_PREFIX )
                {
                if( (pPrefix = pCommand->GetUserPrefix( PREFIX_CLIENT_STUB )) )
                        {
                        pBuffer->ConcatTail( pPrefix );
                        }
                }
        else if( (Flags & PRT_SSTUB_PREFIX) == PRT_SSTUB_PREFIX )
                {
                if( (pPrefix = pCommand->GetUserPrefix( PREFIX_SERVER_MGR )) )
                        {
                        pBuffer->ConcatTail( pPrefix );
                        }
                }
        else if( (Flags & PRT_SWITCH_PREFIX) == PRT_SWITCH_PREFIX )
                {
                if( (pPrefix = pCommand->GetUserPrefix( PREFIX_SWICH_PROTOTYPE )) )
                        {
                        pBuffer->ConcatTail( pPrefix );
                        }
                }
        pBuffer->ConcatTail (pName);
        }
    else if (Parent != NODE_DEF)
        {
        ChildFlags |= PRT_SUPPRESS_MODEL;       // turn off __far's
        pBuffer->ConcatHead (CHAR_LPAREN);
        pBuffer->ConcatTail (CHAR_RPAREN);
        }

    // the type specification is no longer at the top level
    if (pNode)
        {
        if ( HasAsyncHandle() )
            {
            if ( pNode->GetBasicType()->NodeKind() == NODE_E_STATUS_T ||
                 ( !strcmp( pNode->GetSymName(), "HRESULT" ) && IsObjectProc() ) )
                {
                pNode->DoPrintDecl (ChildFlags, pBuffer, pStream, this, pIntf);
                }
            else
                {
                pBuffer->ConcatHead (CHAR_BLANK);
                pBuffer->ConcatHead ("void ");
                }
            }
        else
            {
            pNode->DoPrintDecl (ChildFlags, pBuffer, pStream, this, pIntf);
            }
        }
    pBuffer->ConcatTail (CHAR_LPAREN);

    ChildFlags &= ~PRT_SUPPRESS_MODEL;      // turn __far's back on
    pBuffer->Print(pStream );
    pStream->IndentInc();

    pBuffer->Clear ();

    if ( Flags & PRT_THIS_POINTER )
            {
            char    *               pIntfName;
            if ( pIntf )
                    pIntfName = pIntf->GetSymName();
            else
                    pIntfName = GetMyInterfaceNode()->GetSymName();

            pStream->NewLine();
            pStream->Write( pIntfName );
            pStream->Write( " * This" );
            fHasParameter = TRUE;
            }

    if ( HasAsyncHandle() )
        {
        ChildFlags |= PRT_ASYNC_DEFINITION;
        }

    // Emit the parameters
    while ( pNode = MemIter.GetNext() )
            {
            MIDL_ASSERT( NODE_PARAM == pNode->NodeKind() );

            node_param *pParam = ( node_param * ) pNode;

            if ( pParam->HasCSTag() && ( Flags & PRT_OMIT_CS_TAG_PARAMS ) )
                {
                continue;
                }   

            if( fHasParameter == TRUE )
                    {
                    //If this is not the first parameter, then print a ",".
                    pStream->Write (',');
                    }
            pBuffer->Clear ();
            pParam->DoPrintType (ChildFlags, pBuffer, pStream, this, pIntf);
            fHasParameter = TRUE;
            }
#ifdef _SPITGENSEQ_
printf("\n");
#endif

    if(fHasParameter == FALSE)
            {
            //If there are no parameters, then print void.
            pStream->Write("void");
            }
    pStream->Write (')');

    pBuffer->Clear ();
    pStream->IndentDec();

    return STATUS_OK;
}

STATUS_T
node_proc::DoPrintType(
        PRTFLAGS                Flags,
        BufferManager * pBuffer,
        ISTREAM           * pStream,
        node_skl        *       pParent,
        node_skl        *       pIntf)
/*++

Routine Description:

    This routine prints procedure definition.

Arguments:

    pParent - Supplies type of the parent node.

    pBuffer - Supplies a buffer to accumulate output.

--*/
{

        DUMP_DEBUG_INFO( "node_proc::DoPrintType" );

        char *                                  pName;

        midl_debug ("node_proc::DoPrintType\n");

        pName = GetSymName();

        MIDL_ASSERT (pName != (char *)0);

    //.. If a local proc, just emit the prototype to the *.h file.

        // pBuffer->Clear ();
        DoPrintDecl (Flags, pBuffer, pStream, pParent, pIntf);
        pBuffer->Print(pStream);

        if (Flags & PRT_TRAILING_SEMI)
                {
                pStream->Write (';');
                pStream->NewLine();
                };
        return STATUS_OK;

}

STATUS_T
node_label::DoPrintType(
        PRTFLAGS                Flags,
        BufferManager * ,
        ISTREAM           * pStream,
        node_skl        *       ,
        node_skl        *       )
/*++

Routine Description:

    This routine prints an enum label and its value.

Arguments:

    pParent - Supplies type of the parent node.

    pBuffer - Supplies a buffer to accumulate output.

--*/
{
    
        DUMP_DEBUG_INFO( "node_label::DoPrintType" );

        midl_debug ("node_label::DoPrintType\n");

        char* pName = GetSymName();

        MIDL_ASSERT (pName != (char *)0);

        pStream->Write('\t');
        pStream->Write( pName );
        if (pExpr)
                {
                pStream->Write("\t= ");
                pExpr->Print( pStream );
                };

        return STATUS_OK;
}

STATUS_T
node_enum::DoPrintDecl(
    PRTFLAGS                Flags,
    BufferManager * pBuffer,
    ISTREAM           *,
    node_skl        *       pParent,
    node_skl        * )
/*++

Routine Description:

    This routine prints an enum declaration.

Arguments:

    pParent - Supplies type of the parent node.

    pBuffer - Supplies a buffer to accumulate output.

--*/
{

        DUMP_DEBUG_INFO( "node_enum::DoPrintDecl" );

        char *          pName;

        midl_debug ("node_enum::DoPrintDecl\n");

        pName = GetSymName();

        MIDL_ASSERT (pName != (char *)0);

        if ( pParent &&
             ( ( Flags & PRT_SUPPRESS_MODEL ) == 0)  )
                {
                pParent->EmitModelModifiers (pBuffer);
                }

        pBuffer->ConcatHead (CHAR_BLANK);
        pBuffer->ConcatHead (pName);
        pBuffer->ConcatHead (WORD_ENUM);

        if (pParent)
                {
                pParent->EmitModifiers (pBuffer, ( ( Flags & PRT_SUPPRESS_MODIFIERS ) != 0 ) );
                }

        return STATUS_OK;
}

STATUS_T
node_enum::DoPrintType(
     PRTFLAGS                Flags,
     BufferManager * ,
     ISTREAM           * pStream,
     node_skl        *       pParent,
     node_skl        *       pIntf)

/*++

Routine Description:

    This routine prints an enum definition.

Arguments:

    pParent - Supplies type of the parent node.

    pBuffer - Supplies a buffer to accumulate output.

--*/
{

        DUMP_DEBUG_INFO( "node_enum::DoPrintType" );

        MEM_ITER                MemIter( this );
        node_skl *              pNode;
        char *                  pName;
        BufferManager   TempBuffer(8, LAST_COMPONENT, STRING_TABLE);
        PRTFLAGS                ChildFlags              = Flags & ~PRT_TRAILING_SEMI;

        midl_debug ("node_enum::DoPrintType\n");
        pName = GetSymName();
        MIDL_ASSERT (pName != (char *)0);
        DumpAttributes( pStream );
        TempBuffer.Clear ();
        TempBuffer.ConcatHead (pName);
        TempBuffer.ConcatHead (GetDeclSpecGuid());
        TempBuffer.ConcatHead (WORD_ENUM);

        // Print the modifiers on the enum since the enum has no child that can print them.
        EmitModifiers (&TempBuffer, ( ( Flags & PRT_SUPPRESS_MODIFIERS ) != 0 ) );

        if (pParent)
                {
                pParent->EmitModifiers (&TempBuffer, ( ( Flags & PRT_SUPPRESS_MODIFIERS ) != 0 ) );
                }

        pStream->NewLine();
        TempBuffer.Print(pStream);

        pStream->IndentInc();
        pStream->NewLine();
        pStream->Write('{');

        if ( pNode = MemIter.GetNext() )
                {
                TempBuffer.Clear ();
                pNode->DoPrintType (ChildFlags, &TempBuffer, pStream, this, pIntf);
                while ( pNode = MemIter.GetNext() )
                        {
                        pStream->Write (",\n");
                        TempBuffer.Clear ();
                        pNode->DoPrintType (ChildFlags, &TempBuffer, pStream, this, pIntf);
                        }
                }

        pStream->NewLine();
        pStream->Write('}');
        pStream->IndentDec();

        TempBuffer.Clear();
        if ( pParent &&
             ( ( Flags & PRT_SUPPRESS_MODEL ) == 0)  )
                {
                pParent->EmitModelModifiers (&TempBuffer);
                TempBuffer.ConcatHead(CHAR_BLANK);                
                }

        TempBuffer.Print( pStream );

        if (Flags & PRT_TRAILING_SEMI)
                pStream->Write (';');
        else
                pStream->Write ('\t');

        return STATUS_OK;
}

STATUS_T
node_field::DoPrintType(
        PRTFLAGS                Flags,
        BufferManager * pBuffer,
        ISTREAM           * pStream,
        node_skl        *       ,
        node_skl        *       pIntf)
/*++

Routine Description:

    This routine prints definition for a node of field type.

Arguments:

    pParent - Supplies type of the parent node.

    pBuffer - Supplies a buffer to accumulate output.

--*/
{

        DUMP_DEBUG_INFO( "node_field::DoPrintType" );

        node_skl *      pNode;
        char *          pName;
        STATUS_T        Status;
        char            NumBuf[16];

        midl_debug ("node_field::DoPrintType\n");

        pNode = GetChild ();

        pName = GetSymName ();

        MIDL_ASSERT (pName != (char *)0);

        if( IsTempName( pName ) && !( Flags & PRT_ALL_NAMES) )
                pName = "";

        pStream->NewLine();

        DumpAttributes( pStream );

        if (IsEmptyArm())
                {
                pStream->Write(" /* Empty union arm */ ");
                return STATUS_OK;
                }

        pBuffer->Clear ();

        pBuffer->ConcatHead (pName);

        // the type specification is no longer at the top level
        Flags &= ~PRT_TRAILING_SEMI;
        if ( ! IsDef() )
                {
                Status = pNode->DoPrintDecl (Flags, pBuffer, pStream, this, pIntf);
                }
        else
                {
                Status = pNode->DoPrintType (Flags, pBuffer, pStream, this, pIntf);
                }

        if (IsBitField())
                {
                pBuffer->ConcatTail ("\t: ");
                // safe to have buffer on stack, since we print below
                pBuffer->ConcatTail (MIDL_ITOA(GetFieldSize(), NumBuf, 10));
                }
        pBuffer->ConcatTail (CHAR_SEMICOLON);
        pBuffer->Print(pStream);

        return Status;
}

STATUS_T
node_union::DoPrintDecl(
        PRTFLAGS        Flags,
        BufferManager * pBuffer,
        ISTREAM           * ,
        node_skl        * pParent,
        node_skl        *       )
/*++

Routine Description:

    This routine prints a union declaration.

Arguments:

    pParent - Supplies type of the parent node.

    pBuffer - Supplies a buffer to accumulate output.

--*/
{

        DUMP_DEBUG_INFO( "node_union::DoPrintDecl" );

        midl_debug ("node_union::DoPrintDecl\n");

        char*  pName = GetSymName();
        MIDL_ASSERT (pName != (char *)0);

        if ( pParent &&
             ( ( Flags & PRT_SUPPRESS_MODEL ) == 0)  )
                {
                pParent->EmitModelModifiers (pBuffer);
                }

        pBuffer->ConcatHead (CHAR_BLANK);
        pBuffer->ConcatHead (pName);
        pBuffer->ConcatHead (WORD_UNION);

        if (pParent)
                {
                pParent->EmitModifiers (pBuffer, ( ( Flags & PRT_SUPPRESS_MODIFIERS ) != 0 ) );
                }

        return STATUS_OK;
}

STATUS_T
node_union::DoPrintType(
        PRTFLAGS                Flags,
        BufferManager * ,
        ISTREAM           * pStream,
        node_skl        *       pParent,
        node_skl        *       pIntf)
/*++

Routine Description:

    This routine prints a union definition.

Arguments:

    pParent - Supplies type of the parent node.

    pBuffer - Supplies a buffer to accumulate output.

--*/
{
 
        DUMP_DEBUG_INFO( "node_union::DoPrintType" );

        MEM_ITER                MemIter( this );
        node_skl *              pNode;
        char *                  pName;
        BufferManager   TempBuffer(8, LAST_COMPONENT, STRING_TABLE);
        NODE_T                  Parent  = (pParent)? pParent->NodeKind() : NODE_INTERFACE;
        BOOL                    AddPragmas;
        unsigned short  zp;
        char                    NumBuf[4];
        PRTFLAGS                ChildFlags      = Flags & ~PRT_TRAILING_SEMI;

        midl_debug ("node_union::DoPrintType\n");
        pName = GetSymName();
        MIDL_ASSERT (pName != (char *)0);
        DumpAttributes( pStream );
        zp      = GetZeePee();
        AddPragmas = ( zp != pCommand->GetZeePee() )
                                 && (Parent != NODE_FIELD )
                                 && !(Flags & PRT_OMIT_PRAGMA_PACK);

        TempBuffer.Clear ();
        if ( ( ( Flags & PRT_INSIDE_OF_STRUCT ) != PRT_INSIDE_OF_STRUCT)  ||
                 !IsTempName( pName ) || IsEncapsulatedUnion())
            {
            TempBuffer.ConcatHead (pName);
            TempBuffer.ConcatHead (GetDeclSpecGuid());
            }

        TempBuffer.ConcatHead (WORD_UNION);

        // Print the modifiers on the union since the union has no child that can
        // print them.
        EmitModifiers (&TempBuffer, ( ( Flags & PRT_SUPPRESS_MODIFIERS ) != 0 ) ); 

        if (pParent)
                {
                pParent->EmitModifiers (&TempBuffer, ( ( Flags & PRT_SUPPRESS_MODIFIERS ) != 0 ) );
                }

        if ( AddPragmas )
                {
                TempBuffer.ConcatHead (")\n");
                TempBuffer.ConcatHead (MIDL_ITOA(zp, NumBuf, 10));
                TempBuffer.ConcatHead ("\n#pragma pack (");
                };

        TempBuffer.Print( pStream );

        pStream->IndentInc();
        pStream->NewLine();
        pStream->Write('{');
        while ( pNode = MemIter.GetNext() )
                {
                TempBuffer.Clear ();
                
                pNode->DoPrintType (ChildFlags, &TempBuffer, pStream, this, pIntf);}
        pStream->NewLine();
        pStream->Write('}');
        pStream->IndentDec();

        TempBuffer.Clear();
        if ( pParent &&
             ( ( Flags & PRT_SUPPRESS_MODEL ) == 0)  )
                {
                pParent->EmitModelModifiers (&TempBuffer);
                TempBuffer.ConcatHead(CHAR_BLANK);                
                }

        TempBuffer.Print( pStream );

        if ( AddPragmas )
                {
                pStream->Write ("\n#pragma pack ()\n");
                };

        if (Flags & PRT_TRAILING_SEMI)
                pStream->Write (';');
        else
                pStream->Write ('\t');

        return STATUS_OK;
}

STATUS_T
node_struct::DoPrintDecl(
        PRTFLAGS        Flags,
        BufferManager * pBuffer,
        ISTREAM           * ,
        node_skl        * pParent      ,
        node_skl        *       )
/*++

Routine Description:

    This routine prints a struct declaration.

Arguments:

    pParent - Supplies type of the parent node.

    pBuffer - Supplies a buffer to accumulate output.

--*/
{

        DUMP_DEBUG_INFO( "node_struct::DoPrintDecl" );

        midl_debug ("node_struct::DoPrintDecl\n");

        char* pName = GetSymName();
        MIDL_ASSERT (pName != (char *)0);

        if ( pParent &&
             ( ( Flags & PRT_SUPPRESS_MODEL ) == 0)  )
                {
                pParent->EmitModelModifiers (pBuffer);
                }

        pBuffer->ConcatHead (CHAR_BLANK);
        pBuffer->ConcatHead (pName);
        pBuffer->ConcatHead (WORD_STRUCT);

        if (pParent)
                {
                pParent->EmitModifiers (pBuffer, ( ( Flags & PRT_SUPPRESS_MODIFIERS ) != 0 ) );
                }

        return STATUS_OK;
}

STATUS_T
node_struct::DoPrintType(
        PRTFLAGS                Flags,
        BufferManager * ,
        ISTREAM           * pStream,
        node_skl        *       pParent,
        node_skl        *       pIntf)
/*++

Routine Description:

    This routine prints a struct definition.

Arguments:

    pParent - Supplies type of the parent node.

    pBuffer - Supplies a buffer to accumulate output.

--*/
{

        DUMP_DEBUG_INFO( "node_struct::DoPrintType" );

        MEM_ITER                MemIter( this );
        node_skl *              pNode;
        char *                  pName = GetSymName();
        BufferManager   TempBuffer(8, LAST_COMPONENT, STRING_TABLE);
        NODE_T                  Parent  = (pParent)? pParent->NodeKind() : NODE_INTERFACE;
        char                    NumBuf[4];
        BOOL                    AddPragmas;
        unsigned short  zp;
        PRTFLAGS                ChildFlags      = ( Flags & ~PRT_TRAILING_SEMI)
                                                  | PRT_INSIDE_OF_STRUCT;

        midl_debug ("node_struct::DoPrintType\n");
        MIDL_ASSERT (pName != (char *)0);
        DumpAttributes( pStream );
        zp      = GetZeePee();
        AddPragmas = ( zp != pCommand->GetZeePee() )
                                 && (Parent != NODE_FIELD )
                                 && !(Flags & PRT_OMIT_PRAGMA_PACK);

        TempBuffer.Clear ();
        if ( ( ( Flags & PRT_INSIDE_OF_STRUCT ) != PRT_INSIDE_OF_STRUCT)  ||
                 !IsTempName( pName ) )
            {
            TempBuffer.ConcatHead (pName);
            TempBuffer.ConcatHead (GetDeclSpecGuid());
            }
        TempBuffer.ConcatHead (WORD_STRUCT);

        // Print the modifiers on the struct since the struct
        // has no child that can print them.
        EmitModifiers (&TempBuffer, ( ( Flags & PRT_SUPPRESS_MODIFIERS ) != 0 ) );

        if (pParent)
                {
                pParent->EmitModifiers (&TempBuffer, ( ( Flags & PRT_SUPPRESS_MODIFIERS ) != 0 ) );
                }

        if ( AddPragmas )
                {
                TempBuffer.ConcatHead (")\n");
                TempBuffer.ConcatHead (MIDL_ITOA(zp, NumBuf, 10));
                TempBuffer.ConcatHead ("\n#pragma pack (");
                };


        TempBuffer.Print( pStream );

        pStream->IndentInc();
        pStream->NewLine();
        pStream->Write('{');

        while ( pNode = MemIter.GetNext() )
                {
                TempBuffer.Clear ();
                pNode->DoPrintType (ChildFlags, &TempBuffer, pStream, this, pIntf);
                pNode->PrintMemoryInfo( pStream, FALSE );
                }
        pStream->NewLine();
        pStream->Write('}');
        pStream->IndentDec();

        TempBuffer.Clear();
        if ( pParent &&
             ( ( Flags & PRT_SUPPRESS_MODEL ) == 0)  )
                {
                pParent->EmitModelModifiers (&TempBuffer);
                TempBuffer.ConcatHead(CHAR_BLANK);
                }

        TempBuffer.Print( pStream );

        if ( AddPragmas )
                {
                pStream->Write ("\n#pragma pack ()\n");
                };

        if (Flags & PRT_TRAILING_SEMI)
                pStream->Write (';');
        else
                pStream->Write ('\t');

        return STATUS_OK;
}



STATUS_T
node_id::DoPrintType(
        PRTFLAGS                Flags,
        BufferManager * pBuffer,
        ISTREAM           * pStream,
        node_skl        *       pParent,
        node_skl        *       pIntf)
/*++

Routine Description:

    This routine prints an identifier and its initializer.

Arguments:

    pParent - Supplies type of the parent node.

    pBuffer - Supplies a buffer to accumulate output.

--*/
{
        DUMP_DEBUG_INFO( "node_id::DoPrintType" );

        node_skl *      pNode;
        char *          pName;
        STATUS_T        Status;
        BOOL            fDummyDecl;
        PRTFLAGS                ChildFlags      = Flags & ~PRT_TRAILING_SEMI;

        midl_debug ("node_id::DoPrintType\n");
        DumpAttributes( pStream );
        pNode = GetChild ();
        pName = GetSymName ();
        MIDL_ASSERT (pName != (char *)0);
        fDummyDecl      = IsTempName( pName );
        pBuffer->Clear ();

        // convert const <type> <id> = <expr> to:
        //                 #define <id> <expr>
        if (!fDummyDecl && pInit )
                {
                if ( (Flags & PRT_CONVERT_CONSTS) &&
                         ( FInSummary( ATTR_CONST ) || IsConstantString() )     )
                        {
                        //expr_cast             CastExpr( pNode, pInit );

                        pStream->Write ( "#define\t" );
                        pStream->Write ( pName );
                        pStream->Write ( '\t' );

                        // print "( <expr> )
                        pStream->Write ( "( ");
                        pInit->Print( pStream );
                        pStream->Write ( " )");

                        pStream->NewLine ();
                        return STATUS_OK;
                        }
                }

        // id which is NOT a constant declaration
        if( !fDummyDecl || ( Flags & PRT_ALL_NAMES) )
                {
                if (pParent )
                        {
                        if ( ( Flags & PRT_SUPPRESS_MODEL ) == 0)
                                pParent->EmitModelModifiers (pBuffer);
                        else
                                Flags &= ~PRT_SUPPRESS_MODEL;
                        }

                pBuffer->ConcatHead (pName);
                }

        if (pParent)
                {
                pParent->EmitModifiers ( pBuffer, false );
                }

        // emit storage class
        if (GetModifiers().IsModifierSet(ATTR_EXTERN))                 pStream->Write("extern ");
        if (GetModifiers().IsModifierSet(ATTR_STATIC))                 pStream->Write("static ");
        if (GetModifiers().IsModifierSet(ATTR_AUTOMATIC))              pStream->Write("auto ");
        if (GetModifiers().IsModifierSet(ATTR_REGISTER))               pStream->Write("register ");

        if ( ! IsDef() )
                {
                Status = pNode->DoPrintDecl (ChildFlags, pBuffer, pStream, this, pIntf);
                }
        else
                {
                Status = pNode->DoPrintType (ChildFlags, pBuffer, pStream, this, pIntf);
                }

        pBuffer->Print(pStream);

        pBuffer->Clear ();
        pBuffer->Print(pStream);

        // if there is an initializer, print it...  #defines came out above and returned
        if ( pInit )
                {
                pStream->Write ( "\t=\t" );
                pInit->Print( pStream );
                }

        pStream->Write (';');
        pStream->NewLine();

        return Status;
}

STATUS_T
node_id::DoPrintDecl(
        PRTFLAGS                Flags,
        BufferManager * pBuffer,
        ISTREAM           * ,
        node_skl        *       pParent,
        node_skl        *       )
/*++

Routine Description:

    This routine prints declaration for an id node.

Arguments:

    pParent - Supplies type of the parent node.

    pBuffer - Supplies a buffer to accumulate output.

--*/
{

        DUMP_DEBUG_INFO( "node_id::DoPrintDecl" );

        midl_debug ("node_id::DoPrintDecl\n");

        char* pName = GetSymName();
        MIDL_ASSERT (pName != (char *)0);

        if (pParent )
                {
                if ( ( Flags & PRT_SUPPRESS_MODEL ) == 0)
                        pParent->EmitModelModifiers (pBuffer);
                else
                        Flags &= ~PRT_SUPPRESS_MODEL;
                }

        pBuffer->ConcatHead(CHAR_BLANK);
        pBuffer->ConcatHead(pName);

        if (pParent)
                {
                pParent->EmitModifiers ( pBuffer, false );
                }

        return STATUS_OK;
}


STATUS_T
node_echo_string::DoPrintType(
        PRTFLAGS                Flags,
        BufferManager * ,
        ISTREAM           * pStream,
        node_skl        *       ,
        node_skl        *       )
/*++

Routine Description:

    This routine reproduces a string into the output header file.

Arguments:

    pParent - Supplies type of the parent node.

    pBuffer - Supplies a buffer to accumulate output.

--*/
{

        DUMP_DEBUG_INFO( "node_echo_string::DoPrintType" );

        midl_debug ("node_echo_string::DoPrintType\n");

        PrintSelf( pStream );
        pStream->NewLine();
        return STATUS_OK;
}

void
node_echo_string::PrintSelf( ISTREAM * pStream )
{
        pStream->Write (GetEchoString());
}

void
node_pragma_pack::PrintSelf( ISTREAM * pStream )
{
        char    NumBuf[10];

        pStream->Write( "\n#pragma pack(" );
        switch ( PackType )
                {
                case PRAGMA_PACK_PUSH:
                        pStream->Write( "push" );
                        if ( pString )
                                {
                                pStream->Write (", ");
                                pStream->Write (pString);
                                }
                        if ( usNewLevel )
                                {
                                pStream->Write (", ");
                                pStream->Write(MIDL_ITOA(usNewLevel, NumBuf, 10));
                                }
                        break;
                case PRAGMA_PACK_POP:
                        pStream->Write( "pop" );
                        if ( pString )
                                {
                                pStream->Write (", ");
                                pStream->Write (pString);
                                }
                        break;
                case PRAGMA_PACK_SET:
                        pStream->Write(MIDL_ITOA(usNewLevel, NumBuf, 10));
                        break;
                case PRAGMA_PACK_RESET:
                        break;
                }
        pStream->Write(')' );
}

STATUS_T
PrintMultiple(
        node_proc *             pNode,
        PRTFLAGS                Flags,
        BufferManager * pBuffer,
        ISTREAM           * pStream,
        node_skl        *       pParent,
        node_skl        *       pIntf)
/*++

Routine Description:

    This routine prints all the prototype flavors for a proc.

Arguments:

    pParent - Supplies type of the parent node.

    pBuffer - Supplies a buffer to accumulate output.

--*/
{
        PRTFLAGS        ChildFlags;

        char    *       pCPrefix        = pCommand->GetUserPrefix( PREFIX_CLIENT_STUB );
        char    *       pSPrefix        = pCommand->GetUserPrefix( PREFIX_SERVER_MGR );
        char    *       pSwPrefix       = pCommand->GetUserPrefix( PREFIX_SWICH_PROTOTYPE );

        if ( !pCPrefix ) pCPrefix = "";
        if ( !pSPrefix ) pSPrefix = "";
        if ( !pSwPrefix ) pSwPrefix = "";

        BOOL            fCeqS           = !(BOOL) strcmp( pCPrefix, pSPrefix );
        BOOL            fSeqSw          = !(BOOL) strcmp( pSPrefix, pSwPrefix );
        BOOL            fCeqSw          = !(BOOL) strcmp( pCPrefix, pSwPrefix );

        // print both client and server flavors of proc
        if ( fCeqS )
                pStream->Write("/* client and server prototype */");
        else
                pStream->Write("/* client prototype */");
        pStream->NewLine();
        ChildFlags = ( Flags & ~PRT_BOTH_PREFIX ) | PRT_CSTUB_PREFIX;
        pNode->DoPrintType (ChildFlags, pBuffer, pStream, pParent, pIntf );

        if ( !fCeqS )
                {
                pStream->Write("/* server prototype */");
                pStream->NewLine();
                ChildFlags = ( Flags & ~PRT_BOTH_PREFIX ) | PRT_SSTUB_PREFIX;
                pNode->DoPrintType (ChildFlags, pBuffer, pStream, pParent, pIntf );
                }

        if ( !( fSeqSw || fCeqSw ) )
                {
                pStream->Write("/* switch prototype */");
                pStream->NewLine();
                ChildFlags = ( Flags & ~PRT_BOTH_PREFIX ) | PRT_SWITCH_PREFIX;
                pNode->DoPrintType (ChildFlags, pBuffer, pStream, pParent, pIntf );
                }

        return STATUS_OK;
}

STATUS_T
node_interface::DoPrintType(
        PRTFLAGS                Flags,
        BufferManager * pBuffer,
        ISTREAM           * pStream,
        node_skl        *       ,
        node_skl        *       )
/*++

Routine Description:

    This routine walks the type graph under an interface node to emit code.

Arguments:

    pParent - Supplies type of the parent node.

    pBuffer - Supplies a buffer to accumulate output.

--*/
{

        DUMP_DEBUG_INFO( "node_interface::DoPrintType" );

        MEM_ITER                MemIter( this );
        node_skl *              pNode;
        NODE_T                  ChildKind;
        char *                  pName;
        short                   Option;
        // unsigned short       zp;
        PRTFLAGS                ChildFlags;
        BOOL                    fPrtBoth        = FALSE;

        midl_debug ("node_interface::DoPrintType\n");
        pName = GetSymName();
        MIDL_ASSERT (pName != (char *)0);

        Option = pCommand->GetErrorOption ();


        ///////////////////////////////////////////////////
        // prefix determination
        // turn off prefix stuff if we don't want the stubs
        // see which flags are really needed
        if ( ( ( Flags & PRT_BOTH_PREFIX ) == PRT_BOTH_PREFIX ) &&
                 pCommand->IsPrefixDifferentForStubs() )
                fPrtBoth = TRUE;

        ChildFlags      = Flags | PRT_OMIT_PRAGMA_PACK;

        pStream->Write("/* interface ");
        pStream->Write(pName);
        pStream->Write(" */");
        pStream->NewLine();
        DumpAttributes( pStream );
        pStream->NewLine(2);

        while ( pNode = MemIter.GetNext() )
                {
                ChildKind = pNode->NodeKind();

                // skip procs.
                if ( ( Flags & PRT_OMIT_PROTOTYPE ) &&
                         ( ChildKind == NODE_PROC ) )
                        continue;

                pBuffer->Clear ();

                pNode->PrintMemoryInfo( pStream, TRUE );

                // print the type
                if ( fPrtBoth &&
                         (pNode->NodeKind()==NODE_PROC) )
                        {
                        PrintMultiple( (node_proc *)pNode, ChildFlags, pBuffer, pStream, this, this );
                        }
                else
                        pNode->DoPrintType (ChildFlags, pBuffer, pStream, this, this );

                if ( ChildKind != NODE_ECHO_STRING )
                        pStream->NewLine();

                }
        return STATUS_OK;
}

STATUS_T
node_interface_reference::DoPrintDecl(
        PRTFLAGS                Flags,
        BufferManager * pBuffer,
        ISTREAM           * ,
        node_skl        *       pParent,
        node_skl        *       )
/*++

Routine Description:

    This routine emits an interface name.

Arguments:

    pParent - Supplies type of the parent node.

    pBuffer - Supplies a buffer to accumulate output.

--*/
{
  
        DUMP_DEBUG_INFO( "node_interface_reference::DoPrintDecl" );

        midl_debug ("node_interface_reference::DoPrintDecl\n");

        char *pName = GetSymName();
        MIDL_ASSERT (pName != (char *)0);

        if (pParent )
                {
                if ( ( Flags & PRT_SUPPRESS_MODEL ) == 0)
                        pParent->EmitModelModifiers (pBuffer);
                else
                        Flags &= ~PRT_SUPPRESS_MODEL;
                }

        pBuffer->ConcatHead(CHAR_BLANK);
        pBuffer->ConcatHead(pName);

        if (pParent)
                {
                pParent->EmitModifiers ( pBuffer, false );
                }

        return STATUS_OK;
}

STATUS_T
node_interface_reference::DoPrintType(
        PRTFLAGS                Flags,
        BufferManager * pBuffer,
        ISTREAM           * pStream,
        node_skl        *       pParent,
        node_skl        *       pIntf)
/*++

Routine Description:

    This routine emits an interface name.

Arguments:

    pParent - Supplies type of the parent node.

    pBuffer - Supplies a buffer to accumulate output.

--*/
{

        DUMP_DEBUG_INFO( "node_interface_reference::DoPrintType" );

        midl_debug ("node_interface_reference::DoPrintType\n");

        return DoPrintDecl( Flags, pBuffer, pStream, pParent, pIntf );
}

STATUS_T
node_file::DoPrintType(
        PRTFLAGS                Flags,
        BufferManager * pBuffer,
        ISTREAM           * pStream,
        node_skl        *       ,
        node_skl        *       pIntf)
/*++

Routine Description:

    This routine walks the type graph under a file node to emit code.

Arguments:

    pParent - Supplies type of the parent node.

    pBuffer - Supplies a buffer to accumulate output.

--*/
{

        DUMP_DEBUG_INFO( "node_file::DoPrintType" );

        MEM_ITER                MemIter( this );
        node_skl *      pNode;

        midl_debug ("node_file::DoPrintType\n");

        while ( pNode = MemIter.GetNext() )
                {
                pBuffer->Clear ();

                pNode->DoPrintType (Flags, pBuffer, pStream, this, pIntf);
                }

        return STATUS_OK;
}

STATUS_T
node_source::DoPrintType(
        PRTFLAGS                Flags,
        BufferManager * pBuffer,
        ISTREAM           * pStream,
        node_skl        *       ,
        node_skl        *       pIntf)
/*++

Routine Description:

    This routine walks the type graph under a source node to emit code.

Arguments:

    pParent - Supplies type of the parent node.

    pBuffer - Supplies a buffer to accumulate output.

--*/
{

        DUMP_DEBUG_INFO( "node_source::DoPrintType" );

        MEM_ITER                MemIter( this );
        node_skl *              pNode;

        midl_debug ("node_source::DoPrintType\n");
        while ( pNode = MemIter.GetNext() )
                {
#ifdef gajdebug10
                char * pNm = pNode->GetSymName();
                printf("printing decl %s\n",
                        pNm? pNm: "(unknown)");
#endif
                pNode->DoPrintType (Flags, pBuffer, pStream, this, pIntf);
                }

        return STATUS_OK;
}

STATUS_T
node_forward::DoPrintDecl(
        PRTFLAGS                Flags,
        BufferManager * pBuffer,
        ISTREAM           * ,
        node_skl        *       ,
        node_skl        *       )
/*++

Routine Description:

    This routine walks the type graph under a source node to emit code.

Arguments:

    pParent - Supplies type of the parent node.

    pBuffer - Supplies a buffer to accumulate output.

--*/
{

        DUMP_DEBUG_INFO( "node_source::DoPrintType" );

        char            *       pName;
        named_node      *       pChild = (named_node *) GetChild();

        if ( pChild )
                pName = pChild->GetSymName();
        else
                pName = GetSymName();

        pBuffer->ConcatHead( CHAR_BLANK );
        pBuffer->ConcatHead( pName );
        switch ( SKey.GetKind() )
                {
                case NAME_TAG:
                        pBuffer->ConcatHead(WORD_STRUCT);
                        break;
                case NAME_ENUM:
                        pBuffer->ConcatHead(WORD_ENUM);
                        break;
                case NAME_UNION:
                        if ( pChild && (pChild->IsEncapsulatedStruct() ) )
                                pBuffer->ConcatHead(WORD_STRUCT);
                        else
                                pBuffer->ConcatHead(WORD_UNION);
                        break;
                default:
                        break;

                }
        return STATUS_OK;
}

STATUS_T
node_href::DoPrintDecl(
        PRTFLAGS                Flags,
        BufferManager * pBuffer,
        ISTREAM           * ,
        node_skl        *       ,
        node_skl        *       )
{

        DUMP_DEBUG_INFO( "node_href::DoPrintDecl" );

        named_node      *       pChild = (named_node *) GetChild();
        char            *       pName= pChild->GetSymName();

        pBuffer->ConcatHead( CHAR_BLANK );
        pBuffer->ConcatHead( pName );
        pBuffer->ConcatHead( "/* external definition not present */ ");
        switch ( SKey.GetKind() )
                {
                case NAME_TAG:
                        pBuffer->ConcatHead(WORD_STRUCT);
                        break;
                case NAME_ENUM:
                        pBuffer->ConcatHead(WORD_ENUM);
                        break;
                case NAME_UNION:
                        if ( pChild && (pChild->IsEncapsulatedStruct() ) )
                                pBuffer->ConcatHead(WORD_STRUCT);
                        else
                                pBuffer->ConcatHead(WORD_UNION);
                        break;
                default:
                        break;

                }
        return STATUS_OK;
}

/*++

Routine Description:

    This routine walks a portion of the type graph

Arguments:

        none.

--*/
STATUS_T
node_skl::PrintType(
        PRTFLAGS                Flags,
        ISTREAM         *       pStream,
        node_skl        *       pParent,
        node_skl        *       pIntf )
{

        DUMP_DEBUG_INFO( "node_skl::PrintType" );

        static
        BufferManager   Buffer(8, LAST_COMPONENT, STRING_TABLE);

        PRTFLAGS                ChildFlags      = Flags & ~(PRT_CAST_SYNTAX | PRT_DECL);
        STATUS_T                rc;

        Buffer.Clear();

        if ( Flags & PRT_CAST_SYNTAX ) pStream->Write("( ");

        if ( Flags & PRT_DECL )
                {
                rc = DoPrintDecl(ChildFlags, &Buffer, pStream, pParent, pIntf);
                }
        else
                {
                rc = DoPrintType(ChildFlags, &Buffer, pStream, pParent, pIntf);
                };

        Buffer.Print( pStream );

        if ( Flags & PRT_CAST_SYNTAX ) pStream->Write(" )");

        pStream->Flush();

        return rc;
};


/*++

Routine Description:

    This routine walks the type graph to emit type declarations

Arguments:

        none.

--*/

void
print_typegraph()
        {
        ISTREAM         Stream("dumpfile", 4);
        ISTREAM *       pStream         = &Stream;

        pStream->Write("\t\t\t/* dump of typegraph */\n\n");
        if (pSourceNode)
                {
                pSourceNode->PrintType(PRT_INTERFACE, pStream, NULL);
                }
        else
                {
                pStream->Write(
                   "\n\n------------- syntax errors; no info available ------------\n");
                }
        pStream->Flush();
        pStream->Close();

        }


STATUS_T
node_library::DoPrintType(
        PRTFLAGS                Flags,
        BufferManager * pBuffer,
        ISTREAM           * pStream,
        node_skl        *       ,
        node_skl        *       )
/*++

Routine Description:

    This routine walks the type graph under a library node to emit code.

Arguments:

    pParent - Supplies type of the parent node.

    pBuffer - Supplies a buffer to accumulate output.

--*/
{

        DUMP_DEBUG_INFO( "node_libray::DoPrintType" );

        MEM_ITER                MemIter( this );
        node_skl *              pNode;
        NODE_T                  ChildKind;
        char *                  pName;
        short                   Option;
        // unsigned short       zp;
        PRTFLAGS                ChildFlags;

        BOOL                    fPrtBoth        = FALSE;

        midl_debug ("node_library::DoPrintType\n");
        pName = GetSymName();
        MIDL_ASSERT (pName != (char *)0);
        Option = pCommand->GetErrorOption ();
        ///////////////////////////////////////////////////
        // prefix determination

        // turn off prefix stuff if we don't want the stubs
        // see which flags are really needed
        if ( ( ( Flags & PRT_BOTH_PREFIX ) == PRT_BOTH_PREFIX ) &&
                 pCommand->IsPrefixDifferentForStubs() )
                fPrtBoth = TRUE;

        ChildFlags      = Flags | PRT_OMIT_PRAGMA_PACK;

        pStream->Write("/* library ");
        pStream->Write(pName);
        pStream->Write(" */");
        pStream->NewLine();
        DumpAttributes( pStream );
        pStream->NewLine(2);

        while ( pNode = MemIter.GetNext() )
                {
                ChildKind = pNode->NodeKind();

                // skip procs.
                if ( ( Flags & PRT_OMIT_PROTOTYPE ) &&
                         ( ChildKind == NODE_PROC ) )
                        continue;
                
                // skip interfaces, object interfaces, dispinterfaces, modules, and coclasses
                // for now (they will be dumped explicitly by CG_LIBRARY::GenHeader)
                if ( NODE_INTERFACE == ChildKind ||
                     NODE_DISPINTERFACE == ChildKind ||
                     NODE_MODULE == ChildKind ||
                     NODE_COCLASS == ChildKind  )
                        continue;

                pBuffer->Clear ();

                pNode->PrintMemoryInfo( pStream, TRUE );

                // print the type
                if ( fPrtBoth &&
                         (pNode->NodeKind()==NODE_PROC) )
                        {
                        PrintMultiple( (node_proc *)pNode, ChildFlags, pBuffer, pStream, this, this );
                        }
                else
                        pNode->DoPrintType (ChildFlags, pBuffer, pStream, this, this );

                if ( ChildKind != NODE_ECHO_STRING )
                        pStream->NewLine();

                }
        return STATUS_OK;
}

STATUS_T
node_module::DoPrintType(
        PRTFLAGS                Flags,
        BufferManager * pBuffer,
        ISTREAM           * pStream,
        node_skl        *       ,
        node_skl        *       )
/*++

Routine Description:

    This routine walks the type graph under a module node to emit code.

Arguments:

    pParent - Supplies type of the parent node.

    pBuffer - Supplies a buffer to accumulate output.

--*/
{

        DUMP_DEBUG_INFO( "node_module::DoPrintType" );

        MEM_ITER                MemIter( this );
        node_skl *              pNode;
        NODE_T                  ChildKind;
        // unsigned short       zp;
        PRTFLAGS                ChildFlags;
        char * szName = GetSymName();

        ChildFlags      = Flags | PRT_OMIT_PRAGMA_PACK;

        pStream->Write("/* module ");
        pStream->Write(szName);
        pStream->Write(" */");
        pStream->NewLine();
        DumpAttributes( pStream );
        pStream->NewLine(2);

        while ( pNode = MemIter.GetNext() )
                {
                ChildKind = pNode->NodeKind();

                pBuffer->Clear ();

                pNode->PrintMemoryInfo( pStream, TRUE );

                // print the type
                pNode->DoPrintType (ChildFlags, pBuffer, pStream, this, this );

                if ( ChildKind != NODE_ECHO_STRING )
                        pStream->NewLine();

                }
    return STATUS_OK;
}

STATUS_T        
node_coclass::DoPrintDecl( PRTFLAGS Flags,
        BufferManager * ,
        ISTREAM * pStream,
        node_skl * ,
        node_skl *  )
{

    DUMP_DEBUG_INFO( "node_coclass::DoPrintDecl" );

    char * pName = GetSymName();

    MIDL_ASSERT (pName != (char *)0);

    pStream->Write(pName);

    if (Flags & PRT_TRAILING_SEMI)
            pStream->Write (';');
    else
            pStream->Write ('\t');

    return STATUS_OK;
}

STATUS_T
node_coclass::DoPrintType(
        PRTFLAGS                Flags,
        BufferManager * ,
        ISTREAM           * ,
        node_skl        *       ,
        node_skl        *       )
/*++

Routine Description:

    This routine would walk the type graph under a coclass node to emit code
    except for the fact that a coclass doesn't emit any code.

Arguments:

    pParent - Supplies type of the parent node.

    pBuffer - Supplies a buffer to accumulate output.

--*/
{

    DUMP_DEBUG_INFO( "node_coclass::DoPrintType" );

    return STATUS_OK;
}

STATUS_T
node_dispinterface::DoPrintType(
        PRTFLAGS                Flags,
        BufferManager * ,
        ISTREAM           * pStream,
        node_skl        *       ,
        node_skl        *       )
/*++

Routine Description:

    This routine walks the type graph under a dispinterface node to emit code.

Arguments:

    pParent - Supplies type of the parent node.

    pBuffer - Supplies a buffer to accumulate output.

--*/
{

        DUMP_DEBUG_INFO( "node_dispinterface::DoPrintType" );

        char* pName= GetSymName();
        
        midl_debug ("node_dispinterface::DoPrintType\n");
        MIDL_ASSERT (pName != (char *)0);

        pStream->Write("/* dispinterface ");
        pStream->Write(pName);
        pStream->Write(" */");
        pStream->NewLine();
        DumpAttributes( pStream );
        pStream->NewLine(2);

        return STATUS_OK;
}

STATUS_T
node_dispinterface::DoPrintDecl (
                                PRTFLAGS        Flags,
                                BufferManager*  ,
                                ISTREAM*        pStream,
                                node_skl*       ,
                                node_skl*       
                                )
{

    DUMP_DEBUG_INFO( "node_dispinterface::DoPrintDecl" );

    char* pName = GetSymName();

    midl_debug ("node_dispinterface::DoPrintDecl\n");
    MIDL_ASSERT (pName != (char *)0);
    pStream->Write(pName);
    if (Flags & PRT_TRAILING_SEMI)
        {
        pStream->Write (';');
        }
    else
        {
        pStream->Write ('\t');
        }

    return STATUS_OK;
}

STATUS_T        
node_pipe::PrintDeclaration (
                            PRTFLAGS        Flags,
                            BufferManager*  ,
                            ISTREAM*        pStream,
                            node_skl*       ,
                            node_skl*       pIntf,
                            char*           szPrefix
                            )
{
    node_skl *              pNode = GetChild();
    char                    pName[128] = { 0 };
    char*                   szSymName;
    PRTFLAGS                ChildFlags = ( Flags & ~PRT_TRAILING_SEMI) | PRT_INSIDE_OF_STRUCT;
    BufferManager           TempBuffer(8, LAST_COMPONENT, STRING_TABLE);
    char*                   szReturn = szPrefix == 0 ? "void " : "RPC_STATUS ";

    szSymName = GetSymName();
    MIDL_ASSERT ( szSymName != (char *)0 );

    if ( szPrefix != 0 )
        {
        strcpy( pName, szPrefix );
        }
    strcat( pName, szSymName );

    DumpAttributes( pStream );

    pStream->Write("struct ");
    pStream->Write(pName);
    pStream->IndentInc();
    pStream->NewLine();
    pStream->Write('{');
    // definition of pull 
    pStream->NewLine();
    pStream->Write(szReturn);
    pStream->Write("(__RPC_USER * pull) (");
    pStream->IndentInc();
    pStream->NewLine();
    pStream->Write("char * state,");
    pStream->NewLine();
    TempBuffer.Clear ();
    pNode->DoPrintDecl (ChildFlags, &TempBuffer, pStream, this, pIntf);
    //pNode->DoPrintType(ChildFlags, &TempBuffer, pStream, this, pIntf);
    TempBuffer.Print(pStream);
    pStream->Write("* buf,");
    pStream->NewLine();
    pStream->Write("unsigned long esize,");
    pStream->NewLine();
    pStream->Write("unsigned long * ecount );");
    pStream->IndentDec();
    // definition of push
    pStream->NewLine();
    pStream->Write(szReturn);
    pStream->Write("(__RPC_USER * push) (");
    pStream->IndentInc();
    pStream->NewLine();
    pStream->Write("char * state,");
    pStream->NewLine();
    pNode->DoPrintDecl (ChildFlags, &TempBuffer, pStream, this, pIntf);
    //pNode->DoPrintType(ChildFlags, &TempBuffer, pStream, this, pIntf);
    TempBuffer.Print(pStream);
    pStream->Write("* buf,");
    pStream->NewLine();
    pStream->Write("unsigned long ecount );");
    pStream->IndentDec();
    // definition of alloc 
    pStream->NewLine();
    pStream->Write(szReturn);
    pStream->Write("(__RPC_USER * alloc) (");
    pStream->IndentInc();
    pStream->NewLine();
    pStream->Write("char * state,");
    pStream->NewLine();
    pStream->Write("unsigned long bsize,");
    pStream->NewLine();
    pNode->DoPrintDecl (ChildFlags, &TempBuffer, pStream, this, pIntf);
    //pNode->DoPrintType(ChildFlags, &TempBuffer, pStream, this, pIntf);
    TempBuffer.Print(pStream);
    pStream->Write("* * buf,");
    pStream->NewLine();
    pStream->Write("unsigned long * bcount );");
    pStream->IndentDec();
    pStream->NewLine();
    pStream->Write("char * state;");
    pStream->NewLine();
    pStream->Write("} ");
    pStream->IndentDec();

    if (Flags & PRT_TRAILING_SEMI)
            pStream->Write (';');
    else
            pStream->Write ('\t');

    return STATUS_OK;
}

STATUS_T
node_pipe::DoPrintDecl(
        PRTFLAGS                Flags,
        BufferManager * pBuffer,
        ISTREAM           * pStream,
        node_skl        *       pParent,
        node_skl        *       pIntf)
/*++

Routine Description:

    This routine prints declaration for a node of pipe type.

Arguments:

    pParent - Supplies type of the parent node.

    pBuffer - Supplies a buffer to accumulate output.

--*/
{

    DUMP_DEBUG_INFO( "node_dispinterface::DoPrintDecl" );

    // print async defn. if the pipe has been used in an async call
    if ( GenAsyncPipeFlavor() )
        {
        PrintDeclaration(
                        Flags,
                        pBuffer,
                        pStream,
                        pParent,
                        pIntf,
                        SZ_ASYNCPIPEDEFPREFIX
                        );
        pStream->Write(SZ_ASYNCPIPEDEFPREFIX);
        pStream->Write(pParent->GetSymName());
        pStream->Write(';');
        pStream->NewLine();
        pStream->NewLine();
        pStream->Write("typedef ");
        }

    PrintDeclaration(
                    Flags,
                    pBuffer,
                    pStream,
                    pParent,
                    pIntf,
                    0
                    );
    return STATUS_OK;
}

STATUS_T
node_pipe::DoPrintType(
        PRTFLAGS                Flags,
        BufferManager * pBuffer,
        ISTREAM           * pStream,
        node_skl        *       pParent,
        node_skl        *       pIntf)
/*++

Routine Description:

    This routine prints definition for a node of pipe type.

Arguments:

    pParent - Supplies type of the parent node.

    pBuffer - Supplies a buffer to accumulate output.

--*/
{

        DUMP_DEBUG_INFO( "node_pipe::DoPrintType" );

        midl_debug ("node_pipe::DoPrintType\n");
        return DoPrintDecl (Flags, pBuffer, pStream, pParent, pIntf);
}


STATUS_T
node_safearray::DoPrintDecl(
        PRTFLAGS                Flags,
        BufferManager * ,
        ISTREAM           * pStream,
        node_skl        *       ,
        node_skl        *       )
/*++

Routine Description:

    This routine prints declaration for a node of safearray type.

Arguments:

    pParent - Supplies type of the parent node.

    pBuffer - Supplies a buffer to accumulate output.

--*/
{
  
        DUMP_DEBUG_INFO( "node_safearray::DoPrintDecl" );

        midl_debug ("node_safearray::DoPrintDecl\n");
        pStream->Write("SAFEARRAY * ");
        return STATUS_OK;
}

STATUS_T
node_safearray::DoPrintType(
        PRTFLAGS                Flags,
        BufferManager * pBuffer,
        ISTREAM           * pStream,
        node_skl        *       pParent,
        node_skl        *       pIntf)
/*++

Routine Description:

    This routine prints definition for a node of safearray type.

Arguments:

    pParent - Supplies type of the parent node.

    pBuffer - Supplies a buffer to accumulate output.

--*/
{

        DUMP_DEBUG_INFO( "node_safearray::DoPrintType" );
 
        midl_debug ("node_safearray::DoPrintType\n");
        return DoPrintDecl (Flags, pBuffer, pStream, pParent, pIntf);
}

STATUS_T
node_async_handle::DoPrintDecl( PRTFLAGS        Flags,
                                BufferManager*  pBuffer,
                                ISTREAM*        pStream,
                                node_skl*       pParent,
                                node_skl*       pIntf )
    {

    DUMP_DEBUG_INFO( "node_async_handle::DoPrintDecl" );

    midl_debug ("node_async_handle::DoPrintDecl\n");

    return DoPrintType (Flags, pBuffer, pStream, pParent, pIntf);
    }

STATUS_T
node_async_handle::DoPrintType( PRTFLAGS        Flags,
                                BufferManager*  ,
                                ISTREAM*        pStream,
                                node_skl*       ,
                                node_skl*       )
    {

    DUMP_DEBUG_INFO( "node_async_handle::DoPrintType" );

    midl_debug ("node_async_handle::DoPrintType\n");

    pStream->Write(GetSymName());
    pStream->Spaces(1);
    return STATUS_OK;
    }

char szDeclSpecGuid[128] = {""};

char*
named_node::GetDeclSpecGuid()
{
    node_guid* pGuid = ( node_guid* ) GetAttribute( ATTR_GUID );

    if ( pGuid && pCommand->GetMSCVer() >= 1100 )
        {
        sprintf( szDeclSpecGuid, " DECLSPEC_UUID(\"%s\") ", pGuid->GetGuidString() );
        }
    else
        {
        szDeclSpecGuid[0] = 0;
        }
    return szDeclSpecGuid;
}

STATUS_T
node_decl_guid::DoPrintType(
        PRTFLAGS        Flags,
        BufferManager * pBuffer,
        ISTREAM           * pStream,
        node_skl        *,
        node_skl        *)
{

        DUMP_DEBUG_INFO( "node_decl_guid::DoPrintType" );

        INTERNAL_UUID guid;

        midl_debug ("node_decl_guid::DoPrintType\n");
        DumpAttributes( pStream );
        pBuffer->Clear ();

        // convert const declare_guid( <name>, <guid> ); to:
        //                 EXTERN_GUID( itf,l1,s1,s2,c1,c2,c3,c4,c5,c6,c7,c8 );
        pStream->Write ( "EXTERN_GUID( " );
        pStream->Write ( GetSymName() );
        pStream->Write ( ',' ); // node_guid
        pGuid->GetGuid( *( (struct _GUID*) &guid ) );
        char tmp[64];
        
        sprintf( tmp, " 0x%x, 0x%x, 0x%x",  guid.Data1, guid.Data2, guid.Data3 );
        pStream->Write ( tmp );
        for ( int i = 0;i < 8;i++ )
            {
            sprintf( tmp, ", 0x%x", guid.Data4[i] );
            pStream->Write( tmp );
            }
        pStream->Write ( " );");

        pStream->NewLine();
        return STATUS_OK;
}

STATUS_T
node_decl_guid::DoPrintDecl(
        PRTFLAGS                Flags,
        BufferManager * pBuffer,
        ISTREAM           * ,
        node_skl        *       pParent,
        node_skl        *       )
{

        DUMP_DEBUG_INFO( "node_decl_guid::DoPrintDecl" );

        midl_debug ("node_decl_guid::DoPrintDecl\n");

        char* pName = GetSymName();
        MIDL_ASSERT (pName != (char *)0);

        if (pParent )
                {
                if ( ( Flags & PRT_SUPPRESS_MODEL ) == 0)
                        pParent->EmitModelModifiers (pBuffer);
                else
                        Flags &= ~PRT_SUPPRESS_MODEL;
                }

        pBuffer->ConcatHead(CHAR_BLANK);
        pBuffer->ConcatHead(pName);

        if (pParent)
                {
                pParent->EmitModifiers ( pBuffer, false );
                }

        return STATUS_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\front\miscnode.cxx ===
/*****************************************************************************/
/**						Microsoft LAN Manager								**/
/**				Copyright(c) Microsoft Corp., 1987-1999						**/
/*****************************************************************************/
/*****************************************************************************
File				: miscnode.cxx
Title				: miscellaneous typenode handler
History				:
	08-Aug-1991	VibhasC	Created

*****************************************************************************/

#pragma warning ( disable : 4514 )

/****************************************************************************
 includes
 ****************************************************************************/

#include "nulldefs.h"
extern	"C"	{
	#include <stdio.h>
	#include <stdlib.h>
	#include <string.h>
	
}

#include "allnodes.hxx"
#include "gramutil.hxx"
#include "cmdana.hxx"
#include "control.hxx"
#include "filehndl.hxx"
#include "lextable.hxx"

extern BOOL							IsTempName( char * );

/****************************************************************************
 extern data
 ****************************************************************************/

extern SymTable					*	pBaseSymTbl;
extern CCONTROL					*	pCompiler;
extern PASS_1					*	pPass1;
extern node_error				*	pErrorTypeNode;
extern short						ImportLevel;
extern CMD_ARG					*	pCommand;
extern NFA_INFO					*	pImportCntrl;
extern IINFODICT				*	pInterfaceInfoDict;
extern LexTable 				*	pMidlLexTable;

/****************************************************************************
 local defines
 ****************************************************************************/
/****************************************************************************/

/****************************************************************************
 						node_interface procedures
 ****************************************************************************/
node_interface::node_interface( NODE_T Kind )
        : named_node( Kind )
    {
    ProcCount           = 0;
    CallBackProcCount   = 0;
    pBaseIntf           = NULL;
    pDefiningFile       = NULL;
    OptimFlags          = OPTIMIZE_NONE;
    OptimLevel          = OPT_LEVEL_OS;
    fIAmIUnknown        = 0;
    fPickle             = 0;
    fHasProcsWithRpcSs  = 0;
    fSemAnalyzed        = 0;
    fPrintedDef         = 0;
    fPrintedIID         = 0;
    pMyCG               = NULL;
    pMyTlbCG            = NULL;
    pProcTbl            = NULL;
    fHasOLEAutomation   = 0;
    fIsAsyncClone       = 0;
    pAsyncInterface     = 0;
    if ( pCommand->IsSwitchDefined( SWITCH_MS_CONF_STRUCT ) )
        {
        fHasMSConfStructAttr = TRUE;
        }
    else
        {
        fHasMSConfStructAttr = FALSE;
        }
    }

void                
node_interface::GetVersionDetails( unsigned short * Maj, 
								   unsigned short * Min )
	{
	node_version	*	pAttr;

	pAttr = (node_version *)
				 GetAttribute( ATTR_VERSION );
	if (pAttr)
		{
		pAttr->GetVersion( Maj, Min );
		}
	else
		{
		*Maj = 0;
		*Min = 0;
		};
	};

node_interface *
node_interface::GetMyBaseInterface()
{
	node_interface *pRealBaseInterface = 0;
	node_interface_reference *pRef;

	//Get the real base interface node, skipping over the 
	//node_forward and the node_interface_reference.
	if(pBaseIntf)
		{
		//if necessary, skip over forward reference node
		if(pBaseIntf->NodeKind() == NODE_FORWARD)
			pRef = (node_interface_reference *)pBaseIntf->GetChild();
		else
			pRef = (node_interface_reference *)pBaseIntf;

		//skip over the interface reference node.
		if(pRef)		
	    	pRealBaseInterface = pRef->GetRealInterface();
		}

	return pRealBaseInterface;
}


/****************************************************************************
 						node_file procedures
 ****************************************************************************/
node_file::node_file(
	char	*	pInputName,
	short		ImpLevel ) : named_node( NODE_FILE, pInputName )
	{

	fHasComClasses = FALSE;

	/**
	 ** save our file name and import level
	 **/

	ImportLevel		= ImpLevel;

	pActualFileName	= new char[ strlen( pInputName ) + 1 ];
	strcpy( pActualFileName, pInputName );

	/**
	 ** if the pass is the acf pass, then just set the symbol name to
	 ** be the input name, else munge it.
	 **/

	if( pCompiler->GetPassNumber() == IDL_PASS )
		{
		fAcfInclude = FALSE;
		SetFileName( pInputName );
		}
	else
		{
		fAcfInclude = TRUE;
		SetSymName( pInputName );
		}

	fIsXXXBaseIdl = FALSE;

	}

void
node_file::SetFileName(
	char	*	pFullName )
	{
	char		pDrive[ _MAX_DRIVE ],
				pPath[ _MAX_PATH ],
				pName[ _MAX_FNAME ],
				pExt[ _MAX_EXT ];
	short		lenDrive,
				lenPath,
				lenName,
				lenExt;
	char	*	pNewName;
	CMD_ARG	*	pCmd	= pCompiler->GetCommandProcessor();

	_splitpath( pFullName, pDrive, pPath, pName, pExt );

	if( (GetImportLevel() != 0 ) ||
		!pCmd->IsSwitchDefined( SWITCH_HEADER ) )
		{
		strcpy( pExt, ".h" );
		}
	else
		{
		pCmd->GetHeaderFileNameComponents( pDrive,pPath,pName,pExt);
		}

	lenDrive= (short) strlen( pDrive );
	lenPath	= (short) strlen( pPath );
	lenName	= (short) strlen( pName );
	lenExt	= (short) strlen( pExt );

	pNewName = new char [ lenDrive + lenPath + lenName + lenExt + 1 ];
	strcpy( pNewName, pDrive );
	strcat( pNewName, pPath );
	strcat( pNewName, pName );
	strcat( pNewName, pExt );

	SetSymName( pNewName );

	// insert the original name into the symbol table to be able to
	// access the filename later and get at the aux thru the symbol table

	SymKey	SKey( pFullName, NAME_FILE );

	pBaseSymTbl->SymInsert( SKey, (SymTable *)NULL, (named_node *)this );

	}
BOOL
node_file::AcfExists()
	{
	char		agBuf[ _MAX_DRIVE + _MAX_PATH + _MAX_FNAME + _MAX_EXT + 1];
	FILE	*	hFile;

	AcfName( agBuf );

	if ( agBuf[0] && ( hFile = fopen( agBuf, "r") ) != 0 )
		{
		fclose( hFile );
		return (BOOL)1;
		}
	return (BOOL)0;
	}

void
node_file::AcfName(
	char	*	pBuf )
	{
	char		agDrive[ _MAX_DRIVE ] ,
				agPath[ _MAX_PATH ],
				agName[ _MAX_FNAME ],
				agExt[ _MAX_EXT ];
	char		agLast[ _MAX_PATH];
	char	*	pPath;
	BOOL		fUserSpecifiedAcf;
	char	*	pTemp;


	// if this is the base idl file, then it can potentially have
	// an acf called differently. The imported file will have its acf
	// only derived from the idl files name.

	fUserSpecifiedAcf	= ( ( GetImportLevel() == 0 ) &&
							  pCommand->IsSwitchDefined( SWITCH_ACF ) );

	if( fUserSpecifiedAcf )
		pTemp	= pCommand->GetAcfFileName();
	else
		pTemp	= pActualFileName;

	strcpy( agLast, pTemp );

	//
	// we need to figure out the complete file name of the file we are searching
	// for.
	// If the user specified a file
	//	{
	//	if it did not have a path component
	// 		then we need to search in the path list that we derive from his
	//		-I and include env vsriable specification.
	//	else // (if he did have a path )
	//		we pick that file up from this path.
	//  }
	// else // (the user did not specify a file )
	//	{
	//	we derive the file name from he idl file name and add a .acf to it.
	//	}

	_splitpath( agLast, agDrive, agPath, agName, agExt );

	if( fUserSpecifiedAcf )
		{
		if( (agDrive[0] == '\0') && (agPath[0] == '\0') )
			{

			// no path was specified,

			pPath	= (char *)0;

			}
		else
			{
			// agLast has the whole thing...
			pPath	= "";
			}
		}
	else
		{

		// he did not specify an acf switch, so derive the filename and
		// the path. The basename is available, the extension in this case
		// is .acf

		pPath	= (char *)0;
		strcpy( agExt, ".acf" );

		}

	if( ! pPath )
		{
		strcpy( agLast, agName );
		strcat( agLast, agExt );

		pPath	= pImportCntrl->SearchForFile( agLast );

		}

	//
	// now we know all components of the full file name. Go ahead and
	// reconstruct the file name.
	//

	sprintf(pBuf, "%s%s", pPath, agLast);
	//_makepath( pBuf, agDrive, pPath, agName, agExt );

	}

/****************************************************************************
 						node_e_status_t procedures
 ****************************************************************************/
node_e_status_t::node_e_status_t() : named_node( NODE_E_STATUS_T, (char *) NULL )
	{
	node_skl	*	pC;
	char		*	pName;

	GetBaseTypeNode( &pC, SIGN_UNSIGNED, SIZE_LONG, TYPE_INT );
 	// force name into lexeme table
 	pName = pMidlLexTable->LexInsert("error_status_t");	
	SetSymName( pName );
	SetChild( pC);
	}

/****************************************************************************
 						node_wchar_t procedures
 ****************************************************************************/
node_wchar_t::node_wchar_t() : named_node( NODE_WCHAR_T, (char *) NULL )
	{
	node_skl	*	pC;
	char		*	pName;

	GetBaseTypeNode( &pC, SIGN_UNSIGNED, SIZE_SHORT, TYPE_INT );
 	pName = pMidlLexTable->LexInsert("wchar_t");	
	SetSymName( pName );
	SetChild( pC);
	}

void
node_forward::GetSymDetails(
	NAME_T	*	pTag,
	char	**	ppName )
	{
	*pTag	= SKey.GetKind();
	*ppName	= SKey.GetString();
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\front\walkctxt.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-1999 Microsoft Corporation

 Module Name:

    walkctxt.cxx

 Abstract:

        typegraph walk context block routines

 Notes:


 Author:

        GregJen Oct-27-1993     Created.

 Notes:


 ----------------------------------------------------------------------------*/

#pragma warning ( disable : 4514 4706 )

/****************************************************************************
 *      include files
 ***************************************************************************/

#include "allnodes.hxx"
#include "walkctxt.hxx"
#include "cmdana.hxx"
#include "semantic.hxx"
#include "control.hxx"

/****************************************************************************
 *      local data
 ***************************************************************************/

/****************************************************************************
 *      externs
 ***************************************************************************/

extern ATTR_SUMMARY                             FieldAttrs;
extern CMD_ARG                          *       pCommand;
extern ccontrol                         *       pCompiler;
extern ATTR_SUMMARY                             RedundantsOk;

/****************************************************************************
 *      definitions
 ***************************************************************************/

// Extract a single attribute from the attribute list (and remove from
// summary).

node_base_attr *
ATTR_ITERATOR::GetAttribute( ATTR_T Attr )
{
    return AllAttrs[ Attr ];
}

// Extract a single attribute from the attribute list (and remove from
// summary).

node_base_attr *
ATTR_ITERATOR::ExtractAttribute( ATTR_T Attr )
{
    node_base_attr  *   pResult = AllAttrs[ Attr ];

    if ( !pResult )
        {
        return pResult;
        }

    // if there were extras of a redundant attr, get the next one from the list
    if ( ( Attr <= REDUNDANT_ATTR_END ) && RedundantAttrExtras[ Attr ].NonNull() )
        {
        RedundantAttrExtras[ Attr ].GetCurrent( (void **)&AllAttrs[Attr] );
        RedundantAttrExtras[ Attr ].RemoveHead();
        }
    else    // no more of this attribute
        {
        AllAttrs[Attr] = NULL;
        RESET_ATTR( Summary, Attr );
        }

    return pResult;
}

void
ATTR_ITERATOR::ExtractFieldAttributes( FIELD_ATTR_INFO * FACtxt )
{
    node_base_attr  *   pAttrNode;
    expr_node       *   pExpr;

    if ( pAttrNode = ExtractAttribute( ATTR_FIRST ) )
        {
        pExpr = pAttrNode->GetExpr();
        if ( pExpr )
            FACtxt->SetFirstIs( pExpr );
        }

    if ( pAttrNode = ExtractAttribute( ATTR_LAST ) )
        {
        pExpr = pAttrNode->GetExpr();
        if ( pExpr )
            FACtxt->SetLastIs( pExpr );
        }

    if ( pAttrNode = ExtractAttribute( ATTR_LENGTH ) )
        {
        pExpr = pAttrNode->GetExpr();
        if ( pExpr )
            FACtxt->SetLengthIs( pExpr );
        }

    if ( pAttrNode = ExtractAttribute( ATTR_MIN ) )
        {
        pExpr = pAttrNode->GetExpr();
        if ( pExpr )
            FACtxt->SetMinIs( pExpr );
        }

    if ( pAttrNode = ExtractAttribute( ATTR_MAX ) )
        {
        pExpr = pAttrNode->GetExpr();
        if ( pExpr )
            FACtxt->SetMaxIs( pExpr );
        }

    if ( pAttrNode = ExtractAttribute( ATTR_SIZE ) )
        {
        pExpr = pAttrNode->GetExpr();
        if ( pExpr )
            FACtxt->SetSizeIs( pExpr );
        }

    // pass iid_is and string attrs on to child
    if ( (FACtxt->Control & FA_CHILD_IS_ARRAY_OR_PTR) == 0 )
        {

        if ( pAttrNode = ExtractAttribute( ATTR_IID_IS ) )
            {
            FACtxt->SetIIDIs( pAttrNode->GetExpr() );
            }

        if ( pAttrNode = ExtractAttribute( ATTR_STRING ) )
            {
            FACtxt->SetString();
            }

        if ( pAttrNode = ExtractAttribute( ATTR_BSTRING ) )
            {
            FACtxt->SetBString();
            }

        }
}


// this routine searches up the context stack looking for a
// matching node

WALK_CTXT   *
WALK_CTXT::FindAncestorContext( NODE_T Kind )
{
    WALK_CTXT   *   pCur    = this;

    while ( pCur )
        {
        if ( (pCur->GetParent())->NodeKind() == Kind )
            return pCur;
        pCur    = pCur->GetParentContext();
        }

    return NULL;
}

// this routine searches up the context stack looking for a
// matching node

WALK_CTXT   *
WALK_CTXT::FindRecursiveContext( node_skl * self )
{
    WALK_CTXT   *   pCur    = this;

    while ( pCur )
        {
        if ( pCur->GetParent() == self )
            return pCur;
        pCur    = pCur->GetParentContext();
        }

    return NULL;
}

// this routine searches up the context stack looking for a
// node other than a typedef

WALK_CTXT   *
WALK_CTXT::FindNonDefAncestorContext( )
{
    WALK_CTXT   *   pCur    = this->GetParentContext();

    while ( pCur )
        {
        if ( (pCur->GetParent())->NodeKind() != NODE_DEF )
            return pCur;
        pCur    = pCur->GetParentContext();
        }

    return NULL;
}


// for my context, find the appropriate pointer kind ( and extract it if needed )
PTRTYPE
WALK_CTXT::GetPtrKind( BOOL * pfExplicitPtrAttr )
{
    PTRTYPE             PtrKind =   PTR_UNKNOWN;
    node_ptr_attr   *   pPtrAttr;
    node_interface  *   pIntf;
    BOOL                fMsExt  =   pCommand->IsSwitchDefined( SWITCH_MS_EXT );
    WALK_CTXT       *   pImportantCtxt = ( fMsExt ) ? FindNonDefAncestorContext() :
                                                                                                          GetParentContext();
    BOOL                fBelowParam = (pImportantCtxt->GetParent()->NodeKind())
                                                                                                        == NODE_PARAM;
    node_interface  *   pItsIntf = GetParent()->GetMyInterfaceNode();

    ////////////////////////////////////////////////////////////////////////
    // process pointer attributes

    if ( pfExplicitPtrAttr )
        *pfExplicitPtrAttr = FALSE;

    if ( FInSummary( ATTR_PTR_KIND ) )
        {
        pPtrAttr = (node_ptr_attr *) ExtractAttribute( ATTR_PTR_KIND );

        PtrKind = pPtrAttr->GetPtrKind();

        if ( pfExplicitPtrAttr  &&
            ( PtrKind == PTR_REF  ||  PtrKind == PTR_FULL ) )
            {
            *pfExplicitPtrAttr = TRUE;
            }
        }
    // top level pointer under param is ref ptr unless explicitly changed
    else if ( fBelowParam )
        {
        PtrKind = PTR_REF;
        }
    // pointer default on defining interface
    else if ( pItsIntf->FInSummary( ATTR_PTR_KIND ) )
        {
        pPtrAttr = (node_ptr_attr *) pItsIntf->GetAttribute( ATTR_PTR_KIND );

        PtrKind = pPtrAttr->GetPtrKind();
        }
    // pointer default on using interface
    else if ( (pIntf=GetInterfaceNode()) ->FInSummary( ATTR_PTR_KIND ) )
        {
        pPtrAttr = (node_ptr_attr *) pIntf->GetAttribute( ATTR_PTR_KIND );

        // semantics verifies that there is exactly one here...
        // ...and adds REF if needed
        PtrKind = pPtrAttr->GetPtrKind();
        }
    else    // global default -- full for DCE, unique for MS_EXT
        {
        if ( fMsExt )
            {
            PtrKind = PTR_UNIQUE;
            }
        else
            {
            PtrKind = PTR_FULL;
            }
        }

    return PtrKind;

}

// get all the operation bits (MAYBE, IDEMPOTENT, BROADCAST, etc.
unsigned short
WALK_CTXT::GetOperationBits()
{
    unsigned short  Bits = 0;

    if ( ExtractAttribute( ATTR_MAYBE ))
        Bits |= OPERATION_MAYBE;

    if ( ExtractAttribute( ATTR_BROADCAST ))
        Bits |= OPERATION_BROADCAST;

    if ( ExtractAttribute( ATTR_IDEMPOTENT ))
        Bits |= OPERATION_IDEMPOTENT;

    if ( ExtractAttribute( ATTR_MESSAGE ))
        Bits |= OPERATION_MESSAGE;

    if ( ExtractAttribute( ATTR_INPUTSYNC ))
        Bits |= OPERATION_INPUT_SYNC;

    return Bits;
}

// add all the attributes to the attribute list; for duplicates, report the duplicate
void
WALK_CTXT::AddAttributes( named_node * pNode )
{
    ATTRLIST            MyAttrs;
    node_base_attr  *   pCurAttr;
    ATTR_T              CurAttrKind;

    pNode->GetAttributeList( MyAttrs );

    pCurAttr    =   MyAttrs.GetFirst();
    while ( pCurAttr )
        {
        CurAttrKind = pCurAttr->GetAttrID();

        if (   ( pDownAttrList->FInSummary( CurAttrKind ) )
                && ( !IS_ATTR( RedundantsOk , CurAttrKind ) )   )
            {
            ProcessDuplicates( pCurAttr );
            }
        else
            pDownAttrList->Add( pCurAttr );

        pCurAttr        = pCurAttr->GetNext();
        }
}

void
WALK_CTXT::ProcessDuplicates( node_base_attr * pAttr )
{
    if ( pCompiler->GetPassNumber() == SEMANTIC_PASS )
        {
        STATUS_T errnum = ((pAttr->GetAttrID() > NO_DUPLICATES_END)? REDUNDANT_ATTRIBUTE : DUPLICATE_ATTR);

        // it is safe to use SemError on us, since it only uses parts of OUR
        // context that are ready, even though this is called during the constructor
        if ( pAttr->IsAcfAttr() )
            {
            AcfError( (acf_attr *)pAttr,
                NULL,
                *((SEM_ANALYSIS_CTXT *)this),
                errnum,
                NULL);
            }
        else
            {
            char    *   pAttrName = pAttr->GetNodeNameString();
            SemError( NULL, *((SEM_ANALYSIS_CTXT *)this), errnum ,pAttrName);
            }
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\front\yypars.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

/* SCCSWHAT( "@(#)yypars.c	2.4 88/05/09 15:22:59	" ) */
___a_r_u_start
static char *SCCSID = "@(#)yypars.c:1.3";
# define YYFLAG -1000
# define YYERROR goto yyerrlab
# define YYACCEPT return(0)
# define YYABORT return(1)

#ifdef YYDEBUG				/* RRR - 10/9/85 */
#define yyprintf(a, b, c, d, e) printf(a, b, c, d, e)
#else
#define yyprintf(a, b, c, d)
#endif

#ifndef YYPRINT
#define	YYPRINT	printf
#endif

#if ! defined YYSTATIC
#define YYSTATIC
#endif

/*	parser for yacc output	*/

#ifdef YYDEBUG
YYSTATIC int yydebug = 0; /* 1 for debugging */
#endif
extern YYSTYPE yyv[YYMAXDEPTH];	/* where the values are stored */
extern short	yys[YYMAXDEPTH];	/* the parse stack */
YYSTATIC short yychar = -1;			/* current input token number */
YYSTATIC int yynerrs = 0;			/* number of errors */
YYSTATIC short yyerrflag = 0;		/* error recovery flag */

#ifdef YYRECOVER
/*
**  yyscpy : copy f onto t and return a ptr to the null terminator at the
**  end of t.
*/
YYSTATIC	char	*yyscpy(t,f)
	register	char	*t, *f;
	{
	while(*t = *f++)
		t++;
	return(t);	/*  ptr to the null char  */
	}
#endif

#ifndef YYNEAR
#define YYNEAR
#endif
#ifndef YYPASCAL
#define YYPASCAL
#endif
#ifndef YYLOCAL
#define YYLOCAL
#endif
#if ! defined YYPARSER
#define YYPARSER yyparse
#endif
#if ! defined YYLEX
#define YYLEX yylex
#endif

static	void	yy_vc_init();
typedef	void	(*pfn)();
static	pfn	*	pcase_fn_array;
static	int		returnflag = 0;
static	YYSTYPE	*yypvt;
static	int		yym_vc_max = 0;
extern  short	GrammarAct;

extern short	yysavestate;

#define MAX_RECOVERY_ATTEMPTS	(50)
#define MAX_RETRY_COUNT			(3)
static short RetryCount = 0;
static short MaxRecoveryAttempts = 0;
static short fJustDiscarded = 0;

YYLOCAL YYNEAR YYPASCAL YYPARSER()
{
	register	short	yyn;
	short		yystate, *yyps, *yysave_yyps;
	YYSTYPE		*yypv,*yysave_yypv;
	YYSTYPE		yysave_yyval;
	short		yyj, yym;
	short		fHaveRecoveredChar	= 0;

	yy_vc_init();
#ifdef YYDEBUG
	yydebug = 1;
#endif /* YYDEBUG */

	yystate = 0;
	yychar = -1;
	yynerrs = 0;
	yyerrflag = 0;
	yyps= &yys[-1];
	yypv= &yyv[-1];

 yystack:    /* put a state and value onto the stack */

	RetryCount = 0;

#ifdef YYDEBUG
	yyprintf( "[yydebug] state %d, char %d = %c\n", yystate, yychar,yychar, 0 );
#else /* YYDEBUG */
	yyprintf( "[yydebug] state %d, char %d\n", yystate, yychar, 0 );
#endif /* YYDEBUG */
	if( ++yyps > &yys[YYMAXDEPTH] ) {
/*		yyerror( "yacc stack overflow" ); */
		ParseError(C_STACK_OVERFLOW, (char *)NULL);
		return(1);
	}
	*yyps = yystate;
	++yypv;

#ifdef UNION
	yyunion(yypv, &yyval);
#else
	*yypv = yyval;
#endif

yynewstate:

	yysavestate	= yystate;
	yysave_yypv	= yypv;
	yysave_yyval= yyval;
	yysave_yyps	= yyps;

	yyn = yypact[yystate];

	if( yyn <= YYFLAG ) {	/*  simple state, no lookahead  */
		goto yydefault;
	}

	if( ! fHaveRecoveredChar )
		{
		if( yychar < 0 ) /*  need a lookahead */
			{
			yychar = YYLEX();
			}
		}

	fHaveRecoveredChar	= 0;

	if( ((yyn += yychar) < 0) || (yyn >= YYLAST) ) {
		goto yydefault;
	}

	if( yychk[ yyn = yyact[ yyn ] ] == yychar ) {		/* valid shift */
		yychar = -1;
#ifdef UNION
		yyunion(&yyval, &yylval);
#else
		yyval = yylval;
#endif
		yystate = yyn;
		if( yyerrflag > 0 ) {
			--yyerrflag;
		}
		goto yystack;
	}

 yydefault:
	/* default state action */

	if( (yyn = yydef[yystate]) == -2 ) {
		register	short	*yyxi;

		if( yychar < 0 ) {
			yychar = YYLEX();
		}
/*
**  search exception table, we find a -1 followed by the current state.
**  if we find one, we'll look through terminal,state pairs. if we find
**  a terminal which matches the current one, we have a match.
**  the exception table is when we have a reduce on a terminal.
*/

#if YYOPTTIME
		yyxi = yyexca + yyexcaind[yystate];
		while(( *yyxi != yychar ) && ( *yyxi >= 0 )){
			yyxi += 2;
		}
#else
		for(yyxi = (short *) yyexca;
			(*yyxi != (-1)) || (yyxi[1] != yystate);
			yyxi += 2
		) {
			; /* VOID */
			}

		while( *(yyxi += 2) >= 0 ){
			if( *yyxi == yychar ) {
				break;
				}
		}
#endif
		if( (yyn = yyxi[1]) < 0 ) {
			return(0);   /* accept */
			}
		}

	if( yyn == 0 ) /* error */
		{ 

		short yytempchar;


		if( (yychar != EOI ) &&
			 ( RetryCount < MAX_RETRY_COUNT ) &&
			 ( MaxRecoveryAttempts < MAX_RECOVERY_ATTEMPTS ) )
			{ 
			if( RetryCount == 0 )
				SyntaxError( BENIGN_SYNTAX_ERROR, yysavestate );

			if((( yytempchar = PossibleMissingToken( yysavestate, yychar ) ) != -1 ))
				{
				char Buf[ 50 ];


				fHaveRecoveredChar	= 1;
				yyunlex( yychar );
				yychar	= yytempchar;

				if( (yytempchar < 128 ) && isprint( yytempchar ) )
					{
					sprintf( Buf, " %c ", yytempchar );
					}
				else if( yytempchar == IDENTIFIER )
					{
					yylval.yy_pSymName = GenTempName();
					sprintf( Buf, " identifier %s", yylval.yy_pSymName );
					}
				else if( (yytempchar == NUMERICCONSTANT ) ||
						 (yytempchar == NUMERICLONGCONSTANT ) ||
						 (yytempchar == NUMERICULONGCONSTANT ) ||
						 (yytempchar == HEXCONSTANT ) ||
						 (yytempchar == HEXLONGCONSTANT ) ||
						 (yytempchar == HEXULONGCONSTANT ) )
					{
					sprintf( Buf, "a number" );
					yylval.yy_numeric.Val = 0;
					yylval.yy_numeric.pValStr = new char[2];
					strcpy( yylval.yy_numeric.pValStr, "0");
					}

				ParseError( ASSUMING_CHAR, Buf );
				RetryCount = 0;
				MaxRecoveryAttempts++;
				fJustDiscarded = 0;
				}
			else 
				{
				char buf[ 20 ];
				if( (yychar < 128 ) && isprint( yychar ) )
					{
					sprintf( buf, " %c ", yychar );
					}
				else
					{
					sprintf( buf, " the last token " );
					}

				ParseError( DISCARDING_CHAR, buf );
				yychar = -1;
				RetryCount++;
				MaxRecoveryAttempts++;
				fJustDiscarded = 1;
				}

			yystate	= yysavestate;
			yypv	= yysave_yypv;
			yyval	= yysave_yyval;
			yyps	= yysave_yyps;

			goto yynewstate;

			}
		else if( (yychar == EOI ) && (fJustDiscarded == 0 ) )
			{
			SyntaxError( UNEXPECTED_END_OF_FILE, yysavestate );
			return 1;
			}
		else
			{
			SyntaxError( SYNTAX_ERROR, yysavestate );
			return 1;
			}
		}

	/* reduction by production yyn */
/* yyreduce: */
		{
#ifdef YYDEBUG
		yyprintf("[yydebug] reduce %d\n",yyn, 0, 0, 0);
#else /* YYDEBUG */
		yyprintf("[yydebug] reduce %d\n",yyn, 0, 0);
#endif /* YYDEBUG */
		yypvt = yypv;
		yyps -= yyr2[yyn];
		yypv -= yyr2[yyn];
#ifdef UNION
		yyunion(&yyval, &yypv[1]);
#else
		yyval = yypv[1];
#endif
		yym = yyn;
		yyn = yyr1[yyn];		/* consult goto table to find next state */
		yyj = yypgo[yyn] + *yyps + 1;
		if( (yyj >= YYLAST) || (yychk[ yystate = yyact[yyj] ] != -yyn) ) {
			yystate = yyact[yypgo[yyn]];
			}
		returnflag = 0;
		GrammarAct = yym;
		(*(pcase_fn_array[ (yym <= yym_vc_max) ? yym : 0  ]))();
		if(returnflag != 0)
			return returnflag;
		}
		goto yystack;  /* stack new state and value */
	}
___a_r_u_myact
$A
___a_r_u_end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\front\semantic.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-1999 Microsoft Corporation

 Module Name:

    semantic.cxx

 Abstract:

    semantic analysis routines

 Notes:


 Author:

    GregJen Jun-11-1993     Created.

 Notes:


 ----------------------------------------------------------------------------*/
// unreferenced inline/local function has been removed
#pragma warning ( disable : 4514 )

 /****************************************************************************
 *      include files
 ***************************************************************************/
#include <basetsd.h>
#include "allnodes.hxx"
#include "semantic.hxx"
#include "cmdana.hxx"
extern "C"
    {
    #include <string.h>
    }
#include "treg.hxx"
#include "tlgen.hxx"
#include "Pragma.hxx"
// #include "attrguid.hxx"

BOOL
IsOLEAutomationType (
                    char*
                    );
BOOL
IsOLEAutomationCompliant(
                        node_skl*
                        );
node_interface*
CloneIFAndSplitMethods  (
                        node_interface*
                        );
node_skl*
GetInOnlyParamPairedWithOut (
                            MEM_ITER&    MemParamList
                            );
bool
HasCorrelation  (
                node_skl*
                );

#define RPC_ASYNC_HANDLE_NAME       "PRPC_ASYNC_STATE"
#define RPC_ASYNC_STRUCT_NAME       "_RPC_ASYNC_STATE"
#define OBJECT_ASYNC_HANDLE_NAME    "IAsyncManager"

#define IS_OLD_INTERPRETER( x ) ( ((x) & OPTIMIZE_INTERPRETER) && !((x) & OPTIMIZE_INTERPRETER_V2) )
#define IsCoclassOrDispKind(x)  ( (x) == NODE_DISPINTERFACE || (x) == NODE_COCLASS )
#define IsInterfaceKind(x)      ( (x) == NODE_INTERFACE_REFERENCE || (x) == NODE_INTERFACE )

//
// This state table defines the rules that govern valid [propput] methods.
//

namespace PropPut
{
    enum State
    {
        NoParam      = 0,
        GeneralParam = 1,
        Optional     = 2,
        Default      = 3,
        LCID         = 4,
        LastParam    = 5,
        Reject       = 6,
        Accept       = 7,
    };

    // Accept = Param* (optional|default)* (param|lcidparam|default)

    State StateTable[][5] = 
    {
//       no param   regular         optional    default     lcid
//      -----------------------------------------------------------
        {Reject,    GeneralParam,   Optional,   Default,    LCID},      // NoParam
        {Accept,    GeneralParam,   Optional,   Default,    LCID},      // GeneralParam
        {Reject,    LastParam,      Optional,   Default,    LCID},      // Optional
        {Accept,    LastParam,      Optional,   Default,    LCID},      // Default
        {Reject,    LastParam,      Reject,     Reject,     Reject},    // LCID
        {Accept,    Reject,         Reject,     Reject,     Reject},    // LastParam
        {Reject,    Reject,         Reject,     Reject,     Reject},    // Reject
        {Accept,    Reject,         Reject,     Reject,     Reject}     // Accept
    };
}

/****************************************************************************
 *      externs
 ***************************************************************************/

extern BOOL         IsTempName( char * );
extern CMD_ARG  *   pCommand;
extern SymTable *   pUUIDTable;
extern SymTable *   pBaseSymTbl;
extern TREGISTRY *  pCallAsTable;

extern BOOL Xxx_Is_Type_OK( node_skl * pType );

extern "C"
    {
#ifndef GUID_DEFINED
#define GUID_DEFINED
    typedef struct _GUID {          // size is 16
        unsigned long   Data1;
        unsigned short   Data2;
        unsigned short   Data3;
        unsigned char  Data4[8];
    } GUID;
#endif 
    typedef GUID IID;

    extern const GUID IID_IAdviseSink;
    extern const GUID IID_IAdviseSink2;
    extern const GUID IID_IAdviseSinkEx;
    extern const GUID IID_AsyncIAdviseSink;
    extern const GUID IID_AsyncIAdviseSink2;

    // {DE77BA62-517C-11d1-A2DA-0000F8773CE9}
    static const GUID IID_AsyncIAdviseSinkEx2 = 
    { 0xde77ba62, 0x517c, 0x11d1, { 0xa2, 0xda, 0x0, 0x0, 0xf8, 0x77, 0x3c, 0xe9 } };

    };

bool
IsAnyIAdviseSinkIID (
                    GUID&    rIID
                    )
    {
        return (
                    !memcmp( &IID_IAdviseSink, &rIID, sizeof(GUID) ) 
                ||  !memcmp( &IID_IAdviseSink2, &rIID, sizeof(GUID) )
                ||  !memcmp( &IID_AsyncIAdviseSink, &rIID, sizeof(GUID) )
                ||  !memcmp( &IID_AsyncIAdviseSink2, &rIID, sizeof(GUID) )
                // IAdviseSinkEx will be converted to sync interface.
                ||  !memcmp( &IID_IAdviseSinkEx, &rIID, sizeof(GUID) ) 
                );
    }

node_skl*
GetIndirectionLevel (
                    node_skl*       pType,
                    unsigned int&   nIndirectionLevel
                    )
    {
        if ( pType )
            {
            node_skl* pChild = pType->GetChild();

            if ( pChild )
                {
                pType = pChild;
                NODE_T nodeKind = pType->NodeKind();
                if ( nodeKind == NODE_POINTER )
                    {
                    return GetIndirectionLevel( pType, ++nIndirectionLevel );
                    }
                else if ( nodeKind == NODE_INTERFACE )
                    {
                    return pType;
                    }
                else
                    {
                    return GetIndirectionLevel( pType, nIndirectionLevel );
                    }
                }
            }
        return pType;
    }

node_skl*
GetNonDefType   (
                node_skl*  pType
                )
    {
    node_skl*   pChild = pType->GetChild();
    if ( pChild && pType->NodeKind() == NODE_DEF )
        {
        pType = GetNonDefType( pChild );
        }
    return pType;
    }

void
node_skl::SemanticAnalysis( SEM_ANALYSIS_CTXT * )
{
    MIDL_ASSERT( !"node_skl semantic analysis called" );
}

void
node_skl::CheckDeclspecAlign( SEM_ANALYSIS_CTXT & MyContext )
{
    if (GetModifiers().IsModifierSet( ATTR_DECLSPEC_ALIGN ) &&
        MyContext.AnyAncestorBits( IN_LIBRARY ) )
        {
        SemError( this, MyContext, DECLSPEC_ALIGN_IN_LIBRARY, GetSymName() ); 
        }
}

void
node_href::SemanticAnalysis( SEM_ANALYSIS_CTXT * )
{
    // If this reference hasn't already been expanded, Resolve() will expand it.

    named_node * pRef = Resolve();
    MIDL_ASSERT(pRef || !"node_href::Resolve() failed" );

    // NOTE - we might want to just skip this step and simply clear any
    //        remaining attributes.
    //        Presumably, if it came from a type library, it must have
    //        been previously analyzed and found to be correct.
    //    pRef->SemanticAnalysis(pParentCtxt);
    // pParentCtxt->ClearAttributes();
}

void
node_forward::SemanticAnalysis( SEM_ANALYSIS_CTXT * pParentCtxt )
{
    if ( fBeingAnalyzed )
        {
        return;
        }
    fBeingAnalyzed = TRUE;

    SEM_ANALYSIS_CTXT MyContext( this, pParentCtxt );

    named_node * pRef = ResolveFDecl();

    MyContext.ExtractAttribute( ATTR_HELPSTRING );
    MyContext.ExtractAttribute( ATTR_DEFAULT );
    while(MyContext.ExtractAttribute( ATTR_CUSTOM ));

    // check for illegal member attributes
    node_member_attr * pMA;
    while ( ( pMA = (node_member_attr *)MyContext.ExtractAttribute(ATTR_MEMBER) ) != 0 )
        {
        switch (pMA->GetAttr())
            {
            case MATTR_PROPGET:
            case MATTR_PROPPUT:
            case MATTR_PROPPUTREF:
            case MATTR_BINDABLE:
            case MATTR_DISPLAYBIND:
            case MATTR_DEFAULTBIND:
            case MATTR_REQUESTEDIT:
            case MATTR_RETVAL:
            case MATTR_VARARG:
            case MATTR_SOURCE:
            case MATTR_DEFAULTVTABLE:
            case MATTR_RESTRICTED:
            case MATTR_OPTIONAL:
            case MATTR_PREDECLID:
            case MATTR_UIDEFAULT:
            case MATTR_NONBROWSABLE:
            case MATTR_DEFAULTCOLLELEM:
            case MATTR_IMMEDIATEBIND:
            case MATTR_USESGETLASTERROR:
                break;
            case MATTR_REPLACEABLE:
            default:
                {
                char * pAttrName = pMA->GetNodeNameString();
                SemError( this, MyContext, INAPPLICABLE_ATTRIBUTE, pAttrName);
                break;
                }
            }
        }

    if ( !pRef && MyContext.AnyAncestorBits( IN_RPC )  )
        {
        SemError( this, MyContext, UNRESOLVED_TYPE, GetSymName() );
        }

    if ( pRef && ( pRef->NodeKind() == NODE_HREF ))
    {
        // expand the href
        pRef->SemanticAnalysis( &MyContext );
        node_skl* pChild = pRef->GetChild();
        if (pChild && pChild->NodeKind() == NODE_INTERFACE)
        {
            pRef = new node_interface_reference((node_interface *)pRef->GetChild());
        }
    }

    // we must go on and process interface references; they will
    // control any recursing and eliminate the forward reference.
    if ( pRef )
        {
        pRef->SemanticAnalysis( &MyContext );

        node_skl * pParent = pParentCtxt->GetParent();
        if ( pParent )
            {
            // if we came from an interface, set the base interface
            if ( pParent->IsInterfaceOrObject() && pRef->NodeKind() == NODE_INTERFACE_REFERENCE )
                {
                ((node_interface *)pParent)->SetMyBaseInterfaceReference( pRef );
                }
            else // otherwise, probably an interface pointer
                {
                pParent->SetChild( pRef );
                }
            }
        }
    else
        {
        // incomplete types may only be used in certain contexts...
        MyContext.SetDescendantBits( HAS_INCOMPLETE_TYPE );
        }

    if ( MyContext.FindRecursiveContext( pRef ) )
        {
        MyContext.SetDescendantBits( HAS_RECURSIVE_DEF );
        MyContext.SetAncestorBits( IN_RECURSIVE_DEF );
        }
    MyContext.RejectAttributes();
    pParentCtxt->ReturnValues( MyContext );
    fBeingAnalyzed = FALSE;
}

// checking the void usage in dispinterface. 
// currently we only check:
// . void is not allowed as property or part of a structure. 
void node_base_type::CheckVoidUsageInDispinterface( SEM_ANALYSIS_CTXT * pContext )
{
    SEM_ANALYSIS_CTXT *     pCtxt = (SEM_ANALYSIS_CTXT *)
                                pContext->GetParentContext();
    node_skl *                pCur = pCtxt->GetParent();
    BOOL                     fHasPointer = FALSE;

    while ( pCur->NodeKind() != NODE_FIELD && pCur->NodeKind() != NODE_PROC )
        {
        if ( pCur->NodeKind() == NODE_POINTER )
            fHasPointer = TRUE;
        else
            {
            if ( pCur->NodeKind() != NODE_DEF )
                {
                RpcSemError( this, *pContext, NON_RPC_RTYPE_VOID, NULL );
                return;
                }
            }
        pCtxt   = (SEM_ANALYSIS_CTXT *) pCtxt->GetParentContext();
        pCur    = pCtxt->GetParent();        
        }

    // This is either a property or part of a structure. 
    if ( pCur->NodeKind() == NODE_FIELD )
        {
        if ( !fHasPointer )
            {
            SemError( this, *pContext, INVALID_VOID_IN_DISPINTERFACE, NULL );
            return;
            }
        }
}
void
node_base_type::CheckVoidUsage( SEM_ANALYSIS_CTXT * pContext )
{

    SEM_ANALYSIS_CTXT * pCtxt = (SEM_ANALYSIS_CTXT *)
                                pContext->GetParentContext();
    node_skl * pCur = pCtxt->GetParent();

    // we assume that we are in an RPC, so we are in the return type
    // or we are in the param list
    if (pContext->AnyAncestorBits( IN_FUNCTION_RESULT ) )
        {
        // check up for anything other than def below proc
        while ( pCur->NodeKind() != NODE_PROC )
            {
            if ( pCur->NodeKind() != NODE_DEF )
                {
                RpcSemError( this, *pContext, NON_RPC_RTYPE_VOID, NULL );
                return;
                }
            pCtxt   = (SEM_ANALYSIS_CTXT *) pCtxt->GetParentContext();
            pCur    = pCtxt->GetParent();
            }
        return;
        }

    // else param list...
    node_proc * pProc;
    node_param * pParam;

    // check up for anything other than def below proc
    // make sure the proc only has one param
    while ( pCur->NodeKind() != NODE_PARAM )
        {
        if ( pCur->NodeKind() != NODE_DEF )
            {
            RpcSemError( this, *pContext, NON_RPC_PARAM_VOID, NULL );
            return;
            }
        pCtxt   = (SEM_ANALYSIS_CTXT *) pCtxt->GetParentContext();
        pCur    = pCtxt->GetParent();
        }

    // now we know the param derives directly from void
    // assume the proc is the immediate parent of the param
    pParam  = ( node_param * ) pCur;
    pProc = ( node_proc * ) pCtxt->GetParentContext()->GetParent();

    MIDL_ASSERT ( pProc->NodeKind() == NODE_PROC );

    if ( ! IsTempName( pParam->GetSymName() ) )
        SemError( this, *pContext, VOID_PARAM_WITH_NAME, NULL );

    if ( pProc->GetNumberOfArguments() != 1 )
        SemError( this, *pContext, VOID_NON_FIRST_PARAM, NULL );

    // We know that the parameter is void.
    // So, chop it off to prevent complications from renaming etc.
    // and then using in a node_def in ILxlate.

    pProc->SetFirstMember( NULL );
    pProc->SetSibling( NULL );

}

void
node_base_type::SemanticAnalysis( SEM_ANALYSIS_CTXT * pParentCtxt )
{
    SEM_ANALYSIS_CTXT   MyContext( this, pParentCtxt );

    CheckContextHandle( MyContext );

    CheckDeclspecAlign( MyContext );

    // warn about OUT const things
    if ( FInSummary( ATTR_CONST ) )
        {
        if ( MyContext.AnyAncestorBits(  UNDER_OUT_PARAM ) )
            RpcSemError( this, MyContext, CONST_ON_OUT_PARAM, NULL );
        else if ( MyContext.AnyAncestorBits( IN_FUNCTION_RESULT ) )
            RpcSemError( this, MyContext, CONST_ON_RETVAL, NULL );
        }

    while(MyContext.ExtractAttribute(ATTR_CUSTOM));
    
    node_range_attr* pRange = ( node_range_attr* ) MyContext.ExtractAttribute(ATTR_RANGE);
    MyContext.ExtractAttribute(ATTR_RANGE);
    if ( pRange )
        {
        if ( pRange->GetMinExpr()->GetValue() > pRange->GetMaxExpr()->GetValue() )
            {
            SemError(this, MyContext, INCORRECT_RANGE_DEFN, 0);
            }
        }

    switch ( NodeKind() )
        {
        case NODE_FLOAT:
        case NODE_DOUBLE:
        case NODE_HYPER:
        case NODE_INT64:
        case NODE_LONGLONG:
            if ( pRange )
                {
                SemError( this, MyContext, INAPPLICABLE_ATTRIBUTE, 0 );
                }
            break;
        case NODE_INT3264:
            if ( MyContext.AnyAncestorBits( IN_LIBRARY ) )
                {
                SemError( this, MyContext, NO_SUPPORT_IN_TLB, 0 );
                }
            if ( pRange  &&  pCommand->Is64BitEnv() )
                {
                SemError( this, MyContext, INAPPLICABLE_ATTRIBUTE, 0 );
                }
            break;
        case NODE_INT:
            if ( MyContext.AnyAncestorBits( IN_FUNCTION_RESULT ) )
                RpcSemError( this, MyContext, NON_RPC_RTYPE_INT, NULL );
            else
                RpcSemError( this, MyContext, NON_RPC_PARAM_INT, NULL );

            break;
        case NODE_INT128:
        case NODE_FLOAT80:
        case NODE_FLOAT128:
            if ( pRange )
                {
                SemError( this, MyContext, INAPPLICABLE_ATTRIBUTE, 0 );
                }
            if ( MyContext.AnyAncestorBits( IN_LIBRARY ) )
                {
                SemError( this, MyContext, NO_SUPPORT_IN_TLB, 0 );
                }
            break;
        case NODE_VOID:
            MyContext.SetDescendantBits( DERIVES_FROM_VOID );
            // if we are in an RPC, then we must be THE return type,
            // or we must be the sole parameter, which must be tempname'd
            // (except that void * is allowed in [iid_is] constructs)
            if (MyContext.AnyAncestorBits( IN_RPC ) && !MyContext.AnyAncestorBits( IN_INTERFACE_PTR ) )
                CheckVoidUsage( &MyContext );
            if ( MyContext.AnyAncestorBits( IN_DISPINTERFACE ) )
                CheckVoidUsageInDispinterface( &MyContext );
            break;
        case NODE_HANDLE_T:
            MyContext.SetDescendantBits( HAS_HANDLE );
            if (MyContext.AnyAncestorBits( IN_PARAM_LIST ) )
                {
                SEM_ANALYSIS_CTXT * pParamCtxt;
                node_param * pParamNode;

                pParamCtxt = (SEM_ANALYSIS_CTXT *)
                             pParentCtxt->FindAncestorContext( NODE_PARAM );
                pParamNode = (node_param *) pParamCtxt->GetParent();
                if ( MyContext.AnyAncestorBits( IN_RPC ) )
                    pParamNode->HandleKind  = HDL_PRIM;

                if ( MyContext.AnyAncestorBits( UNDER_OUT_PARAM ) &&
                        !MyContext.AnyAncestorBits( UNDER_IN_PARAM ) )
                    RpcSemError( this, MyContext, HANDLE_T_CANNOT_BE_OUT, NULL );

                if ( MyContext.AnyAncestorBits( IN_HANDLE ) )
                    {
                    RpcSemError( this, MyContext, GENERIC_HDL_HANDLE_T, NULL );
                    }

                node_skl * pParamBasic = pParamNode->GetBasicType();
                if ( pParamBasic->NodeKind() == NODE_POINTER )
                    {
                    if ( pParamBasic->GetBasicType()->NodeKind() != NODE_HANDLE_T )
                        RpcSemError( pParamNode, *pParamCtxt, HANDLE_T_NO_TRANSMIT, NULL );
                    }
                }
            break;
        default:
            break;
        }

    MyContext.RejectAttributes();

    pParentCtxt->ReturnValues( MyContext );
};

BOOL
node_id::IsConstantString()
{
    // check for *, and const stringable type below
    node_skl * pBasic  = GetBasicType();

    if ( pBasic->NodeKind() != NODE_POINTER )
        return FALSE;

    node_skl * pParent = pBasic;
    node_skl * pChild  = pParent->GetChild();
    BOOL       fConst  = FALSE;

    while ( pChild )
        {
        // if we reached a stringable type, report it's constness
        if ( pChild->IsStringableType() || ( pChild->NodeKind() == NODE_VOID ) )
            {
            return fConst || pParent->FInSummary( ATTR_CONST );
            }

        // skip only typedefs looking for the base type
        if ( pChild->NodeKind() != NODE_DEF )
            return FALSE;

        // catch intervening const's
        if ( pParent->FInSummary( ATTR_CONST ) )
            fConst = TRUE;

        pParent = pChild;
        pChild  = pParent->GetChild();
        }

    return FALSE;
}


void
node_id::SemanticAnalysis( SEM_ANALYSIS_CTXT * pParentCtxt )
{
    SEM_ANALYSIS_CTXT MyContext( this, pParentCtxt );
    BOOL fIsConstant;
    node_constant_attr * pID = (node_constant_attr *) MyContext.ExtractAttribute(ATTR_ID);
    MyContext.ExtractAttribute(ATTR_HELPCONTEXT);
    MyContext.ExtractAttribute(ATTR_HELPSTRINGCONTEXT);
    MyContext.ExtractAttribute(ATTR_HELPSTRING);

    if ( HasCorrelation( this ) )
        {
        MyContext.IncCorrelationCount();
        }

        
    CheckDeclspecAlign( MyContext );


    /*
    // NishadM: Stricter type checking
    if ( pID && pID->GetExpr()->AlwaysGetType() )
        {
        if ( !( ( node_base_type*) pID->GetExpr()->GetType() )->IsCompatibleType( ts_FixedPoint ) )
            {
            SemError( this, MyContext, EXPR_INCOMPATIBLE_TYPES, NULL);
            }
        }

    if ( pHC && pHC->GetExpr()->AlwaysGetType() )
        {
        if ( !( ( node_base_type*) pHC->GetExpr()->GetType() )->IsCompatibleType( ts_UnsignedFixedPoint ) )
            {
            SemError( this, MyContext, EXPR_INCOMPATIBLE_TYPES, NULL);
            }
        }

    if ( pHSC && pHSC->GetExpr()->AlwaysGetType() )
        {
        if ( !( ( node_base_type*) pHSC->GetExpr()->GetType() )->IsCompatibleType( ts_UnsignedFixedPoint ) )
            {
            SemError( this, MyContext, EXPR_INCOMPATIBLE_TYPES, NULL);
            }
        }
    */

    if (MyContext.ExtractAttribute(ATTR_HELPSTRINGDLL))
        {
        SemError(this, MyContext, INAPPLICABLE_ATTRIBUTE, 0);
        }
    MyContext.ExtractAttribute(ATTR_HIDDEN);
    GetChild()->SemanticAnalysis( &MyContext );

    fIsConstant = FInSummary( ATTR_CONST ) ||
        IsConstantString() ||
        GetChild()->FInSummary( ATTR_CONST );

    if (pID)
    {
        SEM_ANALYSIS_CTXT * pIntfCtxt = (SEM_ANALYSIS_CTXT *)
                                            MyContext.GetInterfaceContext();
        node_interface * pIntf = (node_interface *) pIntfCtxt->GetParent();
        if (!pIntf->AddId(pID->GetExpr()->GetValue(), GetSymName()))
            SemError( this, MyContext, DUPLICATE_IID, NULL);
        if (fIsConstant)
            {
            SemError(this, MyContext, INAPPLICABLE_ATTRIBUTE, 0);
            }
    }

    // don't allow instantiation of data
    if ( GetChild()->NodeKind() != NODE_PROC )
        {
        if ( !FInSummary( ATTR_EXTERN ) &&
                !FInSummary( ATTR_STATIC ) &&
                !fIsConstant )
            SemError( this, MyContext, ACTUAL_DECLARATION, NULL );

        // error here if dce for extern or static, too
        if ( !GetInitList() || !fIsConstant )
            SemError( this, MyContext, ILLEGAL_OSF_MODE_DECL, NULL );
        }

    if ( pInit )
        {
        EXPR_CTXT InitCtxt( &MyContext );
        node_skl * pBasicType = GetBasicType();
        node_skl * pInitType = NULL;

        pInit->ExprAnalyze( &InitCtxt );

        if ( InitCtxt.AnyUpFlags( EX_UNSAT_FWD ) )
            TypeSemError( this,
                MyContext,
                EXPR_NOT_EVALUATABLE,
                NULL );

        pInitType = pInit->GetType();
        if ( pInitType && !pInitType->IsBasicType() )
            pInitType = pInitType->GetBasicType();

        if ( pBasicType &&
                pInitType &&
                pBasicType->IsBasicType() &&
                pInitType->IsBasicType() )
            {
            if ( !((node_base_type *)pBasicType)
                    ->RangeCheck( pInit->GetValue() ) )
                TypeSemError( this, MyContext, VALUE_OUT_OF_RANGE, NULL );
            }

        if ( !pInit->IsConstant() )
            TypeSemError( this, MyContext, RHS_OF_ASSIGN_NOT_CONST, NULL );

        }

    if ( MyContext.AnyAncestorBits( HAS_OLEAUTOMATION )|| MyContext.AnyAncestorBits( IN_DISPINTERFACE ) )
        {
        if ( !IsOLEAutomationCompliant( this ) )
            {
            SemError(this, MyContext, NOT_OLEAUTOMATION_INTERFACE, NULL);
            }
        }

    // disallow forward references on declarations
    if ( MyContext.AnyDescendantBits( HAS_INCOMPLETE_TYPE ) )
        {
        if (! MyContext.AnyAncestorBits( IN_LIBRARY ))
            SemError( this, MyContext, UNDEFINED_SYMBOL, NULL );
        MyContext.ClearDescendantBits( HAS_INCOMPLETE_TYPE );
        }
    MyContext.ClearDescendantBits( HAS_RECURSIVE_DEF );

    pParentCtxt->ReturnValues( MyContext );
}

void
node_label::SemanticAnalysis( SEM_ANALYSIS_CTXT * pParentCtxt )
{
    SEM_ANALYSIS_CTXT MyContext( this, pParentCtxt );
    while(MyContext.ExtractAttribute(ATTR_CUSTOM));
    if ( MyContext.ExtractAttribute(ATTR_IDLDESCATTR) )
        {
        SemError(this, MyContext, NEWLYFOUND_INAPPLICABLE_ATTRIBUTE, 0);
        }
    if ( MyContext.ExtractAttribute(ATTR_VARDESCATTR) )
        {
        SemError(this, MyContext, NEWLYFOUND_INAPPLICABLE_ATTRIBUTE, 0);
        }
    
    if ( MyContext.ExtractAttribute(ATTR_ID) )
        {
        SemError(this, MyContext, NEWLYFOUND_INAPPLICABLE_ATTRIBUTE, 0);
        }
    
    MyContext.ExtractAttribute(ATTR_HIDDEN);    
    MyContext.ExtractAttribute( ATTR_HELPSTRING );
    MyContext.ExtractAttribute( ATTR_HELPSTRINGCONTEXT );
    MyContext.ExtractAttribute( ATTR_HELPCONTEXT );
    if (MyContext.ExtractAttribute(ATTR_HELPSTRINGDLL))
        {
        SemError(this, MyContext, INAPPLICABLE_ATTRIBUTE, 0);
        }

    // check for illegal member attributes
    node_member_attr * pMA;
    while ( ( pMA = (node_member_attr *)MyContext.ExtractAttribute(ATTR_MEMBER) ) != 0 )
        {
        switch (pMA->GetAttr())
            {
            case MATTR_PROPGET:
            case MATTR_PROPPUT:
            case MATTR_PROPPUTREF:
            case MATTR_BINDABLE:
            case MATTR_DISPLAYBIND:
            case MATTR_DEFAULTBIND:
            case MATTR_REQUESTEDIT:
            case MATTR_RETVAL:
            case MATTR_VARARG:
            case MATTR_SOURCE:
            case MATTR_DEFAULTVTABLE:
            case MATTR_RESTRICTED:
            case MATTR_OPTIONAL:
            case MATTR_PREDECLID:
            case MATTR_UIDEFAULT:
            case MATTR_NONBROWSABLE:
            case MATTR_DEFAULTCOLLELEM:
            case MATTR_IMMEDIATEBIND:
            case MATTR_USESGETLASTERROR:
                break;
            case MATTR_REPLACEABLE:
            default:
                {
                char * pAttrName = pMA->GetNodeNameString();
                SemError( this, MyContext, NEWLYFOUND_INAPPLICABLE_ATTRIBUTE, pAttrName);
                break;
                }
            }
        }
        

    if ( HasCorrelation( this ) )
        {
        MyContext.IncCorrelationCount();
        }
        
    CheckDeclspecAlign( MyContext );

    if ( pExpr )
        {
        EXPR_CTXT ExprCtxt( &MyContext );

        pExpr->ExprAnalyze( &ExprCtxt );

        if ( ExprCtxt.AnyUpFlags( EX_UNSAT_FWD ) )
            TypeSemError( this,
                MyContext,
                EXPR_NOT_EVALUATABLE,
                NULL );
        }

    pParentCtxt->ReturnValues( MyContext );
};

#define DIRECT_NONE     0
#define DIRECT_IN       1
#define DIRECT_OUT      2
#define DIRECT_PARTIAL_IGNORE (DIRECT_IN | DIRECT_OUT | 4 )
#define DIRECT_IN_OUT   (DIRECT_IN | DIRECT_OUT)

void
node_param::SemanticAnalysis( SEM_ANALYSIS_CTXT * pParentCtxt )
{
    SEM_ANALYSIS_CTXT MyContext( this, pParentCtxt );
    unsigned short Direction = DIRECT_NONE;
    char * pName = GetSymName();
    node_skl * pChild = GetChild();
    BOOL NoDirection = FALSE;
    
    MyContext.SetAncestorBits( IN_PARAM_LIST );
    MyContext.MarkImportantPosition();
    while(MyContext.ExtractAttribute(ATTR_CUSTOM));
    MyContext.ExtractAttribute(ATTR_IDLDESCATTR);
    
    if ( MyContext.ExtractAttribute(ATTR_FLCID) )
        {
        LCID();
        }
              
    CheckDeclspecAlign( MyContext );

    // check for illegal member attributes
    node_member_attr * pMA;
    while ( ( pMA = (node_member_attr *)MyContext.ExtractAttribute(ATTR_MEMBER) ) != 0 )
        {
        switch (pMA->GetAttr())
            {
            case MATTR_OPTIONAL:
                {
                node_skl * pBase = this;
                do {
                    pBase = pBase->GetChild()->GetBasicType();
                } while (NODE_ARRAY == pBase->NodeKind() || NODE_POINTER == pBase->NodeKind());

                if ( !pBase->GetSymName() || 
                     ( (0 != _stricmp(pBase->GetSymName(), "tagVARIANT") ) 
                       && FNewTypeLib() 
                       && ( MyContext.AnyAncestorBits( HAS_OLEAUTOMATION )
                            || MyContext.AnyAncestorBits( IN_DISPINTERFACE ) ) ) )
                    {
                    SemError(this, MyContext, INAPPLICABLE_OPTIONAL_ATTRIBUTE, pMA->GetNodeNameString());
                    }

                if ( ! MyContext.AnyAncestorBits( IN_LIBRARY ) )
                {
                    SemError(this, MyContext, OPTIONAL_OUTSIDE_LIBRARY, NULL);
                }
                Optional();
                break;
                }
            case MATTR_RETVAL:
                Retval();
                break;
            case MATTR_RESTRICTED:
            case MATTR_SOURCE:
            case MATTR_PROPGET:
            case MATTR_PROPPUT:
            case MATTR_PROPPUTREF:
                {
                char * pAttrName = pMA->GetNodeNameString();
                SemError( this, MyContext, NEWLYFOUND_INAPPLICABLE_ATTRIBUTE, pAttrName);
                break;
                }
            
            case MATTR_BINDABLE:
            case MATTR_DISPLAYBIND:
            case MATTR_DEFAULTBIND:
            case MATTR_REQUESTEDIT:
            case MATTR_VARARG:
            case MATTR_DEFAULTVTABLE:
            case MATTR_PREDECLID:
            case MATTR_UIDEFAULT:
            case MATTR_NONBROWSABLE:
            case MATTR_DEFAULTCOLLELEM:
            case MATTR_USESGETLASTERROR:
            case MATTR_IMMEDIATEBIND:
                break;
            case MATTR_REPLACEABLE:
            default:
                {
                char * pAttrName = pMA->GetNodeNameString();
                SemError( this, MyContext, INAPPLICABLE_ATTRIBUTE, pAttrName);
                break;
                }
            }
        }

    node_constant_attr * pcaDefaultValue = (node_constant_attr *)MyContext.ExtractAttribute(ATTR_DEFAULTVALUE);
    if ( pcaDefaultValue )
        {
        // UNDONE: Check that this attribute has a legal default value

        // We already have an [optional] flag. MIDL should issue a warning 
        // that we shouldn't have both.
        if ( IsOptional() )
        {
            SemError( this, MyContext, DEFAULTVALUE_WITH_OPTIONAL, 0);
        }
        pParentCtxt->SetDescendantBits( HAS_DEFAULT_VALUE );
        Optional();
        }

    if ( MyContext.ExtractAttribute(ATTR_IN) )
        {
        pParentCtxt->SetDescendantBits( HAS_IN );
        MyContext.SetAncestorBits( UNDER_IN_PARAM );
        Direction |= DIRECT_IN;
        }
    if ( MyContext.ExtractAttribute(ATTR_OUT) )
        {
        pParentCtxt->SetDescendantBits( HAS_OUT );
        MyContext.SetAncestorBits( UNDER_OUT_PARAM );
        Direction |= DIRECT_OUT;
        }
   
    if ( MyContext.ExtractAttribute( ATTR_PARTIAL_IGNORE ) )
        {
        pCommand->GetNdrVersionControl().SetHasPartialIgnore();

        pParentCtxt->SetDescendantBits( HAS_PARTIAL_IGNORE );
        MyContext.SetAncestorBits( UNDER_PARTIAL_IGNORE_PARAM );
        
        if ( !( Direction & DIRECT_IN ) || !( Direction & DIRECT_OUT ) )
            {
            SemError( this, MyContext, PARTIAL_IGNORE_IN_OUT, GetSymName() );
            }
        
        if ( FInSummary( ATTR_STRING )
             && ! ( FInSummary( ATTR_SIZE ) || FInSummary( ATTR_MAX) ) )
            {
            SemError( this, MyContext, UNSIZED_PARTIAL_IGNORE, GetSymName() );
            }

        Direction |= DIRECT_PARTIAL_IGNORE;   
        }

    if ( IsExtraStatusParam() )
        MyContext.SetAncestorBits( UNDER_HIDDEN_STATUS );

    // [retval] parameter must be on an [out] parameter and it
    // must be the last parameter in the list
    if (IsRetval() && (Direction != DIRECT_OUT || GetSibling() != NULL))
        SemError(this, MyContext, INVALID_USE_OF_RETVAL, NULL );

    // if the parameter has no IN or OUT, it is an IN parameter by default.
    // if so, issue a warning message
    // REVIEW: No warning is being issued.  What about hidden status params
    //         which are neither in nor out?
    if ( (Direction == DIRECT_NONE) &&
            MyContext.AnyAncestorBits( IN_RPC ) )
        {
        NoDirection = TRUE;
        MyContext.SetAncestorBits( UNDER_IN_PARAM );
        Direction |= DIRECT_IN;
        }

    // warn about OUT const things
    if ( ( Direction & DIRECT_OUT ) &&
            FInSummary( ATTR_CONST ) )
        RpcSemError( this, MyContext, CONST_ON_OUT_PARAM, NULL );


    if ( MyContext.FInSummary(ATTR_HANDLE) )
        {
        HandleKind |= HDL_GEN;
        fAppliedHere = 1;
        }

    if ( MyContext.FInSummary(ATTR_CONTEXT) )
        {
        HandleKind |= HDL_CTXT;
        fAppliedHere = 1;
        }

    if (HandleKind != HDL_NONE)
        MyContext.SetDescendantBits( HAS_HANDLE | HAS_CONTEXT_HANDLE );

    // notice comm and fault statuses; the attributes are extracted by
    // the error_status_t
    if ( MyContext.FInSummary( ATTR_COMMSTAT ) )
        {
        Statuses |= STATUS_COMM;
        }
    if ( MyContext.FInSummary( ATTR_FAULTSTAT ) )
        {
        Statuses |= STATUS_FAULT;
        }

    acf_attr *pDRtag = (acf_attr *) MyContext.ExtractAttribute( ATTR_DRTAG );
    acf_attr *pStag  = (acf_attr *) MyContext.ExtractAttribute( ATTR_STAG );
    acf_attr *pRtag  = (acf_attr *) MyContext.ExtractAttribute( ATTR_RTAG );

    if ( pDRtag )
        {
        if ( !( Direction & DIRECT_IN ) )
            AcfError(pDRtag, this, MyContext, IN_TAG_WITHOUT_IN, NULL);

        SetHasCSDRTag();
        MyContext.SetDescendantBits( HAS_DRTAG );
        }

    if ( pStag )
        {
        if ( !( Direction & DIRECT_IN ) )
            AcfError(pStag, this, MyContext, IN_TAG_WITHOUT_IN, NULL);

        SetHasCSSTag();
        MyContext.SetDescendantBits( HAS_STAG );
        }

    if ( pRtag )
        {
        if ( !( Direction & DIRECT_OUT ) )
            AcfError(pRtag, this, MyContext, OUT_TAG_WITHOUT_OUT, NULL);
    
        SetHasCSRTag();
        MyContext.SetDescendantBits( HAS_RTAG );
        }

    acf_attr * pForceAllocate = (acf_attr *) MyContext.ExtractAttribute( ATTR_FORCEALLOCATE );
    if ( pForceAllocate )
        {
        // we allow force allocation on [in] and [in,out] parameters. server allocate 
        if ( ! (Direction & DIRECT_IN ) )
            AcfError( pForceAllocate, this, MyContext, OUT_ONLY_FORCEALLOCATE, NULL );

        MyContext.SetDescendantBits ( HAS_FORCEALLOCATE );
    	pCommand->GetNdrVersionControl().SetHasForceAllocate();
        }
        
    pChild->SemanticAnalysis( &MyContext );

    // OUT parameters should be pointers or arrays.
    // Don't use HAS_POINTER or arrays as it may come from a field.

    if ( ( Direction & DIRECT_PARTIAL_IGNORE ) == DIRECT_PARTIAL_IGNORE )
        {   
        node_skl *pPointer = GetNonDefChild();

        if ( ( pPointer->NodeKind() != NODE_POINTER ) ||
             MyContext.AnyDescendantBits((DESCENDANT_FLAGS) HAS_PIPE) )
            {
            SemError( this, MyContext, PARTIAL_IGNORE_UNIQUE, NULL );
            }

        node_skl *pPointee = pPointer->GetNonDefChild();

        if ( pPointee->IsStructOrUnion() )
            if ( ((node_su_base *) pPointee)->HasConformance() )
                SemError( this, MyContext, UNSIZED_PARTIAL_IGNORE, NULL );

        }

    else if ( (Direction & DIRECT_OUT) && !(
            GetNonDefChild()->IsPtrOrArray()
            || MyContext.AnyDescendantBits((DESCENDANT_FLAGS) HAS_PIPE)))
        {
        SemError( this, MyContext, NON_PTR_OUT, NULL );
        }

    if ( pForceAllocate )
        {
        if ( MyContext.AnyDescendantBits((DESCENDANT_FLAGS) HAS_PIPE) )
            AcfError( pForceAllocate, this, MyContext, FORCEALLOCATE_ON_PIPE, NULL );
        }
        
    // if no direction was specified, and we are not just void or a hidden
    // status parameter, then error
    if ( NoDirection )
        {
        pParentCtxt->SetDescendantBits( HAS_IN );
        
        if (     !MyContext.AnyDescendantBits( DERIVES_FROM_VOID ) 
             &&  !IsExtraStatusParam() )
            {
            RpcSemError( this, MyContext, NO_EXPLICIT_IN_OUT_ON_PARAM, NULL );
            }
        }

    // disallow forward references as union members
    if ( MyContext.AnyDescendantBits( HAS_INCOMPLETE_TYPE ) )
        {
        if (! MyContext.AnyAncestorBits( IN_LIBRARY ))
            SemError( this, MyContext, UNDEFINED_SYMBOL, NULL );
        MyContext.ClearDescendantBits( HAS_INCOMPLETE_TYPE );
        }
    MyContext.ClearDescendantBits( HAS_RECURSIVE_DEF );

    // disallow  module as params
    
    if ( GetBasicType()->NodeKind() == NODE_MODULE )
        {
        SemError( this, MyContext, DERIVES_FROM_COCLASS_OR_MODULE, 0);
        }
    else if (GetBasicType()->NodeKind() == NODE_POINTER)
        {
        if (GetBasicType()->GetChild()->NodeKind() == NODE_MODULE )
            {
            SemError( this, MyContext, DERIVES_FROM_COCLASS_OR_MODULE, 0);
            }
        }

    if ( GetBasicType()->NodeKind() == NODE_INTERFACE || 
         GetBasicType()->NodeKind() == NODE_DISPINTERFACE )
    {
        SemError( this, MyContext, INTF_NON_POINTER, 0);
    }
    

    // compound types may not be declared in param lists
    NODE_T ChildKind = pChild->NodeKind();

    if ( ( ChildKind == NODE_ENUM )
            || ( ChildKind == NODE_STRUCT )
            || ( ChildKind == NODE_UNION ) )
        {
        if ( IsDef() )
            SemError( this, MyContext, COMP_DEF_IN_PARAM_LIST, NULL );
        }

    // things not allowed in an RPC
    if ( MyContext.AnyAncestorBits( IN_RPC | IN_LIBRARY ) )
        {
        if ( strcmp( pName, "..." ) == 0 )
            SemError( this, MyContext, PARAM_IS_ELIPSIS, NULL );

        if ( IsTempName( pName ) )
            RpcSemError( this, MyContext, ABSTRACT_DECL, NULL );

        }

    if ( ( HandleKind != HDL_NONE ) &&
            ( Direction & DIRECT_IN ) )
        fBindingParam = TRUE;

    if ( ( HandleKind == HDL_CTXT ) &&
            MyContext.AnyDescendantBits( HAS_TRANSMIT_AS ) )
        RpcSemError( this, MyContext, CTXT_HDL_TRANSMIT_AS, NULL );

    if ( MyContext.AnyAncestorBits( HAS_OLEAUTOMATION ) || MyContext.AnyAncestorBits( IN_DISPINTERFACE ) ) 
        {
        // check the child type instead of NODE_PARAM directly. nt bug #371499
        if ( !IsOLEAutomationCompliant( GetBasicType() ) )
            {
            SemError(this, MyContext, NOT_OLEAUTOMATION_INTERFACE, NULL);
            }
        }

    // don't allow functions as params
    if ( MyContext.AnyDescendantBits( HAS_FUNC ) &&
            MyContext.AllAncestorBits( IN_INTERFACE | IN_RPC ) )
        RpcSemError( this, MyContext, BAD_CON_PARAM_FUNC, NULL );

    if (MyContext.ExtractAttribute(ATTR_HELPSTRINGDLL))
        {
        SemError(this, MyContext, INAPPLICABLE_ATTRIBUTE, 0);
        }

    if ( HasCorrelation( this ) )
        {
        MyContext.IncCorrelationCount();
        }
    if ( ( Direction & DIRECT_OUT ) && MyContext.GetCorrelationCount() )
        {
        MyContext.SetDescendantBits( HAS_CLIENT_CORRELATION );
        }
    if ( ( Direction & DIRECT_IN ) && MyContext.GetCorrelationCount() )
        {
        MyContext.SetDescendantBits( HAS_SERVER_CORRELATION );
        }

    if ( MyContext.AnyAncestorBits( HAS_ASYNCHANDLE ) && 
            MyContext.AnyDescendantBits( (DESCENDANT_FLAGS) HAS_PIPE ) && 
                pChild->GetNonDefSelf()->NodeKind() != NODE_POINTER )
        {
        SemError(this, MyContext, ASYNC_PIPE_BY_REF, GetSymName() );
        }

    // This is completely banned with the new transfer syntax.
    if ( pCommand->NeedsNDR64Run() )
        {
        if ( MyContext.AnyDescendantBits( HAS_UNSAT_REP_AS ) )
            {
            RpcSemError( this, MyContext, UNSPECIFIED_EMBEDDED_REPRESENT_AS_NOT_SUPPORTED, NULL );
            }        
        }

    pParentCtxt->ReturnValues( MyContext );
}

void
node_file::SemanticAnalysis( SEM_ANALYSIS_CTXT * pParentCtxt )
{
    MEM_ITER MemIter( this );
    node_skl * pN;
    SEM_ANALYSIS_CTXT MyContext( this, pParentCtxt );

    if ( ImportLevel == 0 )
        {
        MyContext.SetAncestorBits( IN_INTERFACE );
        }
#ifdef ReducedImportSemAnalysis
    else
        return;
#endif


    while ( ( pN = MemIter.GetNext() ) != 0 )
        {
        // each interface node gets a fresh context
        MyContext.SetInterfaceContext( &MyContext );
        // allow echo string and midl_grama outside library block,
        // even in mktyplib compatible mode
        if ( ( 0 == ImportLevel )
             && ( NODE_LIBRARY != pN->NodeKind() )
             && ( NODE_ECHO_STRING != pN->NodeKind() ) 
             && ( NODE_MIDL_PRAGMA != pN->NodeKind() )
             && ( pCommand->IsSwitchDefined(SWITCH_MKTYPLIB ) ) )
            {
            SEM_ANALYSIS_CTXT DummyContext( pN, &MyContext );
            SemError(pN, DummyContext, ILLEGAL_IN_MKTYPLIB_MODE, NULL);
            }
        pN->SemanticAnalysis( &MyContext );
        };

    pParentCtxt->ReturnValues( MyContext );

};

// for fault_status and comm_status
#define NOT_SEEN        0
#define SEEN_ON_RETURN  1
#define SEEN_ON_PARAM   2

void
node_proc::SemanticAnalysis( SEM_ANALYSIS_CTXT * pParentCtxt )
{
    node_param*         pN;
    node_optimize*      pOptAttr;
    acf_attr*           pAttr;
    ATTR_T              CallingConv;

    MEM_ITER            MemIter( this );
    SEM_ANALYSIS_CTXT   MyContext( this, pParentCtxt );
    SEM_ANALYSIS_CTXT*  pIntfCtxt = (SEM_ANALYSIS_CTXT *) MyContext.GetInterfaceContext();
    node_interface*     pIntf = (node_interface *) pIntfCtxt->GetParent();
    node_entry_attr*    pEntry = NULL;
    node_base_attr*     pAttrAsync      = MyContext.ExtractAttribute( ATTR_ASYNC );

    unsigned short Faultstat    = NOT_SEEN;
    unsigned short Commstat     = NOT_SEEN;
    unsigned short OpBits       = MyContext.GetOperationBits();

    BOOL fNoCode        = FALSE;
    BOOL fCode          = FALSE;
    BOOL Skipme         = FALSE;
    BOOL fNonOperation  = FALSE;
    BOOL fEncode        = (NULL != MyContext.ExtractAttribute( ATTR_ENCODE ));
    BOOL fDecode        = (NULL != MyContext.ExtractAttribute( ATTR_DECODE ));
    // Use bitwise or because otherwise the C/C++ compiler will incorrectly 
    // short-circuit the call to ExtractAttribute(ATTR_DECODE).
    BOOL HasPickle      = fEncode | fDecode;
    BOOL fExpHdlAttr    = FALSE;
    BOOL fMaybe         = OpBits & OPERATION_MAYBE;
    BOOL fMessage       = OpBits & OPERATION_MESSAGE;
    BOOL fBindingFound  = FALSE;

    BOOL fProcIsCallback= (NULL != MyContext.ExtractAttribute( ATTR_CALLBACK ));
    BOOL fLocal         = (NULL != MyContext.ExtractAttribute( ATTR_LOCAL ));
    BOOL fNotify        = (NULL != MyContext.ExtractAttribute( ATTR_NOTIFY ));
    BOOL fNotifyFlag    = (NULL != MyContext.ExtractAttribute( ATTR_NOTIFY_FLAG ));

    node_skl*           pRet            = GetReturnType();
    NODE_T              BasicChildKind  = pRet->GetBasicType()->NodeKind();
    node_call_as*       pCallAs         = (node_call_as *) MyContext.ExtractAttribute( ATTR_CALL_AS );
    acf_attr*           pEnableAllocate = (acf_attr *) MyContext.ExtractAttribute( ATTR_ENABLE_ALLOCATE );
    node_constant_attr* pID             = (node_constant_attr *) MyContext.ExtractAttribute(ATTR_ID);
    node_constant_attr* pHC             = (node_constant_attr *) MyContext.ExtractAttribute(ATTR_HELPCONTEXT);
    node_constant_attr* pHSC            = (node_constant_attr *) MyContext.ExtractAttribute(ATTR_HELPSTRINGCONTEXT);
    node_text_attr*     pHelpStr        = (node_text_attr *) MyContext.ExtractAttribute(ATTR_HELPSTRING);
    bool                fAddExplicitHandle = false;
    long                nAfterLastOptionalParam = 0;
    node_cs_tag_rtn *   pCSTagAttr = (node_cs_tag_rtn *) MyContext.ExtractAttribute( ATTR_CSTAGRTN );
 
    if (MyContext.ExtractAttribute(ATTR_HELPSTRINGDLL))
        {
        SemError(this, MyContext, INAPPLICABLE_ATTRIBUTE, 0);
        }

    while(MyContext.ExtractAttribute(ATTR_CUSTOM));
    MyContext.ExtractAttribute(ATTR_FUNCDESCATTR);
    MyContext.ExtractAttribute( ATTR_HIDDEN );

    fHasDeny = pCommand->IsSwitchDefined( SWITCH_ROBUST );

    if (MyContext.AnyAncestorBits( IN_MODULE ))
    {
        pEntry = (node_entry_attr *) MyContext.ExtractAttribute( ATTR_ENTRY );
        if (pEntry)
        {

            if (pEntry->IsNumeric())
            {
                char * szEntry = (char *)pEntry->GetID();
                if ( ((LONG_PTR) szEntry) > 0xFFFF )
                {
                    SemError( this, MyContext, BAD_ENTRY_VALUE, NULL);
                }
            }
            else
            {
                char * szEntry = pEntry->GetSz();
                if ( ((LONG_PTR) szEntry) <= 0xFFFF )
                {
                    SemError( this, MyContext, BAD_ENTRY_VALUE, NULL);
                }
            }
        }
        else
        {
            SemError(this, MyContext, BAD_ENTRY_VALUE, NULL);
        }
    }

    bool fBindable = false;
    bool fPropSomething = false;
    bool fPropGet = false;
    int  nchSkip = 0;
    bool fHasVarArg = false;
    // check for illegal member attributes
    node_member_attr * pMA;
    while ( ( pMA = (node_member_attr *)MyContext.ExtractAttribute(ATTR_MEMBER) ) != 0 )
        {
        switch (pMA->GetAttr())
            {
            case MATTR_BINDABLE:
                fBindable = TRUE;
                break;
            case MATTR_PROPGET:
                nchSkip = 4;
                fPropSomething = TRUE;
                fPropGet = TRUE;
                break;
            case MATTR_PROPPUT:
                nchSkip = 4;
                fPropSomething = TRUE;
                break;
            case MATTR_PROPPUTREF:
                nchSkip = 7;
                fPropSomething = TRUE;
                break;
            case MATTR_VARARG:
                fHasVarArg = true;
                break;
            case MATTR_RESTRICTED:
            case MATTR_SOURCE:
                if ( MyContext.AnyAncestorBits( IN_MODULE ))
                {
                char * pAttrName = pMA->GetNodeNameString();
                SemError( this, MyContext, NEWLYFOUND_INAPPLICABLE_ATTRIBUTE, pAttrName);
                break;
                }                    
            case MATTR_DISPLAYBIND:
            case MATTR_DEFAULTBIND:
            case MATTR_REQUESTEDIT:
            case MATTR_UIDEFAULT:
            case MATTR_NONBROWSABLE:
            case MATTR_DEFAULTCOLLELEM:
            case MATTR_DEFAULTVTABLE:
            case MATTR_IMMEDIATEBIND:
            case MATTR_REPLACEABLE:
            case MATTR_READONLY:
                break;
            case MATTR_USESGETLASTERROR:
                {
                if ( !MyContext.AnyAncestorBits( IN_MODULE ) )
                    {
                    char * pAttrName = pMA->GetNodeNameString();
                    SemError( this, MyContext, NEWLYFOUND_INAPPLICABLE_ATTRIBUTE, pAttrName);
                    }
                break;
                }
            
            case MATTR_RETVAL:
            case MATTR_OPTIONAL:
            case MATTR_PREDECLID:
                {
                char * pAttrName = pMA->GetNodeNameString();
                SemError( this, MyContext, INAPPLICABLE_ATTRIBUTE, pAttrName);
                break;
                }
            }
        }

    if (pID)
    {
        if (!pIntf->AddId(pID->GetExpr()->GetValue(),GetSymName() + nchSkip))
            SemError( this, MyContext, DUPLICATE_IID, NULL);
    }

    if (fBindable && !fPropSomething)
        SemError(this, MyContext, INVALID_USE_OF_BINDABLE, NULL);

    if ( pEnableAllocate )
        pIntf->SetHasProcsWithRpcSs();

    fNonOperation = !pParentCtxt->GetParent()->IsInterfaceOrObject();

    if ( !GetCallingConvention( CallingConv ) )
        SemError( this, MyContext, MULTIPLE_CALLING_CONVENTIONS, NULL );

    // locally applied [code] attribute overrides global [nocode] attribute
    fNoCode = (NULL != MyContext.ExtractAttribute( ATTR_NOCODE ));
    fCode   = (NULL != MyContext.ExtractAttribute( ATTR_CODE ));
    if ( fCode && fNoCode )
        {
        SemError( this, MyContext, CODE_NOCODE_CONFLICT, NULL );
        }

    fNoCode = fNoCode || pIntfCtxt->FInSummary( ATTR_NOCODE );
    fNoCode = !fCode && fNoCode;

    if ( fNoCode && pCommand->GenerateSStub() )
        RpcSemError( this, MyContext, NOCODE_WITH_SERVER_STUBS, NULL );

    // do my attribute parsing...

    fObjectProc = MyContext.ExtractAttribute( ATTR_OBJECT ) || pIntfCtxt->FInSummary( ATTR_OBJECT );
    SetObjectProc( fObjectProc );
    if ( fObjectProc )
        {
        if ( pCommand->GetEnv() != ENV_WIN32  &&
             pCommand->GetEnv() != ENV_WIN64  &&
             !pCommand->IsSwitchDefined(SWITCH_MKTYPLIB))
            {
            // REVIEW: We can eliminate the warning if object procs can be
            //         in win64.  It was necessary for dos, mac, etc.
            SemError( this, MyContext, OBJECT_PROC_MUST_BE_WIN32, NULL );
            }
        if ( pEnableAllocate )
            {
            AcfError( pEnableAllocate, this, MyContext, INAPPROPRIATE_ON_OBJECT_PROC, NULL );
            }
        if ( HasPickle )
            {
            SemError( this, MyContext, PICKLING_INVALID_IN_OBJECT, NULL );
            }
        }

    bool fAsync = ( MyContext.AnyAncestorBits( HAS_ASYNCHANDLE ) != 0 ) || ( pAttrAsync != 0 );
    if ( fAsync )
        {
        MyContext.SetAncestorBits( HAS_ASYNCHANDLE );
        // because we don't support async retry now, we need to issue an
        // explicit warning about this. 
        if ( pCommand->NeedsNDR64Run() && !pCommand->NeedsNDRRun() )
            SemError( this, MyContext, ASYNC_NDR64_ONLY, 0 );
        }
        

    // check return types for non object proc.s with maybe, message
    // object proc.s should have HRESULT. This is checked later.
    if ( ( fMessage || fMaybe ) && !fObjectProc )
        {
        if ( BasicChildKind != NODE_VOID )
            {
            if ( BasicChildKind != NODE_E_STATUS_T )
                {
                SemError( this, MyContext, MAYBE_NO_OUT_RETVALS, NULL );
                }
            else
                {
                unsigned long   ulCommStat = (unsigned long) ( MyContext.FInSummary(ATTR_COMMSTAT) ? 1 : 0 ),
                                ulFaultStat = (unsigned long) ( MyContext.FInSummary(ATTR_FAULTSTAT) ? 1 : 0);
                if ( ulCommStat ^ ulFaultStat )
                    {
                    SemError( this, MyContext, ASYNC_INCORRECT_ERROR_STATUS_T, 0 );
                    }
                }
            }
        }

    // check call_as characteristics
    if ( pCallAs )
        {
        node_proc*  pCallType = pCallAs->GetCallAsType();

        // if we don't have it yet, search for the call_as target
        if ( !pCallType )
            {
            // search the proc table for the particular proc
            SymKey SKey( pCallAs->GetCallAsName(), NAME_PROC );

            pCallType = ( node_proc* ) pIntf->GetProcTbl()->SymSearch( SKey );

            if ( !pCallType )
                {
                if ( pIntfCtxt->FInSummary( ATTR_OBJECT ) )
                    AcfError( pCallAs,
                        this,
                        MyContext,
                        CALL_AS_UNSPEC_IN_OBJECT,
                        pCallAs->GetCallAsName() );
                }
            else
                {
                pCallAs->SetCallAsType(pCallType);
                }
            }

        // now we should have the call_as type
        if ( pCallType )        // found the call_as proc
            {
            ((node_proc *)pCallType)->fCallAsTarget = TRUE;

            if ( ( pCallType->NodeKind() != NODE_PROC )     ||
                    !pCallType->FInSummary( ATTR_LOCAL ) )
                AcfError( pCallAs,
                    this,
                    MyContext,
                    CALL_AS_NON_LOCAL_PROC,
                    pCallType->GetSymName() );

            // insert pCallType into pCallAsTable
            if ( pCallAsTable->IsRegistered( pCallType ) )
                // error
                AcfError( pCallAs,
                    this,
                    MyContext,
                    CALL_AS_USED_MULTIPLE_TIMES,
                    pCallType->GetSymName() );
            else
                pCallAsTable->Register( pCallType );

            }
            SetCallAsType( pCallType );
        }


    // local procs don't add to count
    Skipme = fLocal;
    if ( Skipme )
        {
        SemError( this, MyContext, LOCAL_ATTR_ON_PROC, NULL );
        }

    Skipme = Skipme || pIntfCtxt->FInSummary( ATTR_LOCAL );
    if ( Skipme )
        {
        MyContext.SetAncestorBits( IN_LOCAL_PROC );
        }

    // do my attribute parsing...

    // check for the [explicit_handle] attribute
    fExpHdlAttr = (NULL != MyContext.ExtractAttribute( ATTR_EXPLICIT ));
    fExpHdlAttr = fExpHdlAttr || pIntfCtxt->FInSummary( ATTR_EXPLICIT );

    // we are in an RPC if we are in the main interface, its not local, and
    // we are not a typedef of a proc...
    if  (
        (ImportLevel == 0) &&
        !MyContext.FindAncestorContext( NODE_DEF ) &&
        pIntf &&
        !Skipme
        )
        {
        MyContext.SetAncestorBits( IN_RPC );
        }
    else
        {
        MyContext.ClearAncestorBits( IN_RPC );
        }

    // our optimization is controlled either locally or for the whole interface
    if ( ( pOptAttr = (node_optimize *) MyContext.ExtractAttribute( ATTR_OPTIMIZE ) ) != 0 )
        {
        SetOptimizationFlags( pOptAttr->GetOptimizationFlags() );
        SetOptimizationLevel( pOptAttr->GetOptimizationLevel() );
        }
    else
        {
        SetOptimizationFlags( pIntf->GetOptimizationFlags() );
        SetOptimizationLevel( pIntf->GetOptimizationLevel() );
        }

    unsigned long   fOptimize = GetOptimizationFlags();
    if ( fOptimize & OPTIMIZE_INTERPRETER )
        {
        MyContext.SetAncestorBits( IN_INTERPRET );
        }

    HasPickle = HasPickle || pIntfCtxt->FInSummary( ATTR_ENCODE )
                || pIntfCtxt->FInSummary( ATTR_DECODE );

    if ( HasPickle && pCommand->IsSwitchDefined( SWITCH_ROBUST ) )
        {
        if ( fOptimize & OPTIMIZE_INTERPRETER_V2 )
            {
            pCommand->GetNdrVersionControl().SetHasOicfPickling();
            if ( pCommand->GetTargetSystem() == NT40 )
                SemError( this, MyContext, INVALID_FEATURE_FOR_TARGET, ":oicf pickling" );                
            }
        else
            {
            SemError( this, MyContext, ROBUST_PICKLING_NO_OICF, 0 );
            }
        }

    BOOL HasCommFault = MyContext.FInSummary( ATTR_COMMSTAT )
                        || MyContext.FInSummary( ATTR_FAULTSTAT );

    if ( HasPickle && HasCommFault )
        {
        if ( ! ( fOptimize & OPTIMIZE_INTERPRETER_V2 ) )
            {
            SemError( this, MyContext, COMMFAULT_PICKLING_NO_OICF, 0 );
            }
        }

    // determine the proc number (local procs don't get a number)
    if ( !fNonOperation )
        {
        if ( !fLocal )
            {
            if ( fProcIsCallback )
                {
                ProcNum = ( pIntf ->GetCallBackProcCount() )++;
                RpcSemError( this, MyContext, CALLBACK_NOT_OSF, NULL );
                }
            else
                {
                ProcNum = ( pIntf ->GetProcCount() )++;
                }
            }
        // object procs need the procnum set for local procs, too
        else if ( fObjectProc && fLocal )
            {
            ProcNum = ( pIntf ->GetProcCount() )++;
            }
        }
    else if ( MyContext.AnyAncestorBits( IN_RPC ) )
        {
        RpcSemError( this, MyContext, FUNC_NON_RPC, NULL );
        }
    else            // proc not an operation, validate its usage
        {
        SEM_ANALYSIS_CTXT * pAbove  = (SEM_ANALYSIS_CTXT *)
        MyContext.FindNonDefAncestorContext();
        node_skl * pAboveNode = pAbove->GetParent();

        if ( !pAboveNode->IsInterfaceOrObject() )
            {
            if ( pAboveNode->NodeKind() != NODE_POINTER )
                {
                TypeSemError( this, MyContext, FUNC_NON_POINTER, NULL );
                }
            }
        }

    if ( MyContext.FInSummary( ATTR_COMMSTAT ) )
        Commstat = SEEN_ON_RETURN;
    if ( MyContext.FInSummary( ATTR_FAULTSTAT ) )
        Faultstat = SEEN_ON_RETURN;

    //////////////////////////////////////
    // process the return type (it will eat commstat or faultstat)
    MyContext.SetAncestorBits( IN_FUNCTION_RESULT );
    MyContext.MarkImportantPosition();

    // warn about OUT const things
    if ( FInSummary( ATTR_CONST ) )
        RpcSemError( this, MyContext, CONST_ON_RETVAL, NULL );

    pRet->SemanticAnalysis( &MyContext );

    MyContext.UnMarkImportantPosition();

    if ( MyContext.AnyDescendantBits( HAS_UNION | HAS_STRUCT ) 
         && !pCommand->GetNdrVersionControl().AllowIntrepretedComplexReturns() )
        {
        // REVIEW: complex return types work for protocol all and ndr64.
        //         make it work for dce also.
        if (HasPickle)
            {
            if (pCommand->Is64BitEnv())
                RpcSemError( this, MyContext, PICKLING_RETVAL_TO_COMPLEX64, NULL );    
            }
        else if (ForceNonInterpret())
            {
            RpcSemError( this, MyContext, NON_OI_BIG_RETURN, NULL );
            }
        }
    else if ( MyContext.AnyDescendantBits( HAS_TOO_BIG_HDL ) )
        {
        if (ForceNonInterpret())
            RpcSemError( this, MyContext, NON_OI_BIG_GEN_HDL, NULL );
        }
    else if ( !pCommand->NeedsNDR64Run()
              && MyContext.AnyDescendantBits( HAS_UNSAT_REP_AS ))
        {
        // REVIEW: Another case of an error that has already been caught
        // elsewhere.  Investigate removing this check.
        if (ForceNonInterpret())
            RpcSemError( this, MyContext, NON_OI_UNK_REP_AS, NULL );
        }
    else if ( !pCommand->NeedsNDR64Run() &&
              ( MyContext.AnyDescendantBits( HAS_REPRESENT_AS 
                                                    | HAS_TRANSMIT_AS ) &&
                MyContext.AnyDescendantBits( HAS_ARRAY ) ) )
        {
        if (ForceNonInterpret())
            RpcSemError( this, MyContext, NON_OI_XXX_AS_ON_RETURN, NULL );
        }
    else if ( ( BasicChildKind == NODE_INT128 ) ||
              ( BasicChildKind == NODE_FLOAT80 ) ||
              ( BasicChildKind == NODE_FLOAT128 ) )
        {
            if (ForceNonInterpret())
                RpcSemError( this, MyContext, RETURNVAL_TOO_COMPLEX_FORCE_OS, NULL );     
        }
    else if ( !pCommand->GetNdrVersionControl().AllowIntrepretedComplexReturns() && 
              ( ( ( BasicChildKind == NODE_HYPER ) && !pCommand->Is64BitEnv() )
                || ( BasicChildKind == NODE_FLOAT )
                || ( BasicChildKind == NODE_DOUBLE ) ) )
        {
        if ( HasPickle )
            {
            if ( fOptimize & OPTIMIZE_INTERPRETER_V2 )
                {
                if ( pCommand->Is64BitEnv() )
                    {
                    RpcSemError( this, MyContext, PICKLING_RETVAL_TO_COMPLEX64, NULL );
                    }
                else if (ForceNonInterpret())
                    {
                    // For pickling -Os is the same as -Oi
                    RpcSemError( this, MyContext, PICKLING_RETVAL_FORCING_OI, NULL );
                    }
                }
            }
        else if ( ( fOptimize & OPTIMIZE_INTERPRETER_V2) ) 
            {
            if ( fObjectProc )
                {
                // Don't switch, generate NT 4.0 guard
                pCommand->GetNdrVersionControl().SetHasFloatOrDoubleInOi();
                }
            else
                if (ForceNonInterpret())
                    RpcSemError( this, MyContext, NON_OI_RETVAL_64BIT, NULL );
            }
        else if ( ( fOptimize & OPTIMIZE_ALL_I1_FLAGS ) )
            {
            if (ForceNonInterpret())
                RpcSemError( this, MyContext, NON_OI_RETVAL_64BIT, NULL );
            }
        }
    else if ( ( CallingConv != ATTR_NONE ) &&
            ( CallingConv != ATTR_STDCALL ) &&
            ( CallingConv != ATTR_CDECL ) && 
              !Skipme )
        {
        if (ForceNonInterpret())
            RpcSemError( this, MyContext, NON_OI_WRONG_CALL_CONV, NULL );
        }

    if ( fProcIsCallback )
        {
        if ( MyContext.AnyDescendantBits( HAS_HANDLE) )
            RpcSemError( this, MyContext, HANDLES_WITH_CALLBACK, NULL );
        if ( fObjectProc )
            RpcSemError( this, MyContext, INVALID_ON_OBJECT_PROC, "[callback]" );
        }

    if ( MyContext.AnyDescendantBits( HAS_FULL_PTR ) )
        fHasFullPointer = TRUE;

    // all object methods must return HRESULT (except those of IUnknown and async methods)
    if ( fObjectProc &&
        !Skipme &&
        !MyContext.AnyDescendantBits( HAS_HRESULT ) )
        {
        if ( !MyContext.AnyAncestorBits( IN_ROOT_CLASS ) && // not IUnknown
             !fAsync ) // not [async]
            {
            RpcSemError( this, MyContext, OBJECT_PROC_NON_HRESULT_RETURN, NULL );
            }
        }

    //////////////////////////////////////
    // process the parameters

    if ( !pIntf->IsAsyncClone() )
        {
        if ( MyContext.AnyAncestorBits( HAS_ASYNC_UUID ) )
            {
            node_skl* pParam = GetInOnlyParamPairedWithOut( MemIter );
            if ( pParam )
                {
                SemError( this, MyContext, ASYNC_INVALID_IN_OUT_PARAM_COMBO, pParam->GetSymName() );
                }
            }
        }

    BOOL    fParentIsAnyIAdviseSink = MyContext.AnyAncestorBits( IN_IADVISESINK );
    BOOL    fHasAsyncManager        = FALSE;
    MyContext.ClearAncestorBits( IN_FUNCTION_RESULT );
    MyContext.SetAncestorBits( IN_PARAM_LIST );

    BOOL    fLastParamWasOptional   = FALSE;
    BOOL    fHasInPipeParam           = FALSE;
    BOOL    fHasInConfOrVaryingParam  = FALSE;
    BOOL    fGenDefaultValueExpr    = FALSE;
    BOOL    fHasDRtag               = FALSE;
    BOOL    fHasRtag                = FALSE;
    BOOL    fHasStag                = FALSE;
    BOOL    fHasInCSType            = FALSE;
    BOOL    fHasOutCSType           = FALSE;

    node_param* pFirstParamWithDefValue = 0;
    node_param* pLastParam = 0;
    node_param* p2LastParam = 0;
    node_param* p3LastParam = 0;
    
    bool fRetval = false;
    bool fLCID = false;

    unsigned long ulParamNumber = 0;

    MemIter.Init();
    while ( ( pN = (node_param *) MemIter.GetNext() ) != 0 )
        {
        fOptimize    = GetOptimizationFlags();
        BasicChildKind = pN->GetBasicType()->NodeKind();
        p3LastParam = p2LastParam;
        p2LastParam = pLastParam;
        pLastParam = pN;
        MyContext.ClearAllDescendantBits();
        MyContext.ResetCorrelationCount();
        pN->SemanticAnalysis( &MyContext );

        fRetval = fRetval || pN->IsRetval();
        if ( pN->IsLCID() )
        {
            if (BasicChildKind != NODE_LONG)
            {
                SemError( this, MyContext, LCID_SHOULD_BE_LONG, 0 );
            }
            if (fLCID)
            {
                SemError( this, MyContext, INVALID_USE_OF_LCID, 0 );
            }
            else
                fLCID = true;
        }


        if ( MyContext.AnyDescendantBits( HAS_MULTIDIM_VECTOR ) )
            {
            if ( ForceInterpret2() )
                {
                RpcSemError( this, MyContext, MULTI_DIM_VECTOR, NULL );
                }
            }

        if ( MyContext.AnyDescendantBits( HAS_PARTIAL_IGNORE ) )
            {

            if ( (fOptimize & OPTIMIZE_INTERPRETER ) )
                {
                if ( ForceInterpret2() )
                    {
                    RpcSemError( this, MyContext, PARTIAL_IGNORE_NO_OI, NULL );
                    }
                }

            if ( MyContext.AnyAncestorBits( IN_LIBRARY ) )
                {
                SemError( this, MyContext, PARTIAL_IGNORE_IN_TLB, NULL );
                }

            if ( pCommand->IsSwitchDefined( SWITCH_OSF ) )
                {
                SemError( this, MyContext, INVALID_OSF_ATTRIBUTE, "[partial_ignore]" );
                }

            }

        if ( MyContext.AnyDescendantBits( HAS_SERVER_CORRELATION ) )
            {
            SetHasServerCorr();
            IncServerCorrelationCount( MyContext.GetCorrelationCount() );
            }
        if ( MyContext.AnyDescendantBits( HAS_CLIENT_CORRELATION ) )
            {
            SetHasClientCorr();
            IncClientCorrelationCount( MyContext.GetCorrelationCount() );
            }
        BOOL fDefaultValue = MyContext.AnyDescendantBits( HAS_DEFAULT_VALUE );
        if ( fDefaultValue )
            {
            if ( !pFirstParamWithDefValue )
                {
                pFirstParamWithDefValue = pN;
                fGenDefaultValueExpr = TRUE;
                }
            // can't have defaultvalue in vararg
            if ( fHasVarArg )
                SemError(this, MyContext, NOT_VARARG_COMPATIBLE, 0);
            }
        else
            {
            // don't generate defaultvalue is c++ header if we have 
            // non-defaultvalue parameter after it.
            fGenDefaultValueExpr = FALSE;
            pFirstParamWithDefValue = 0;
            }

        if ( MyContext.AnyDescendantBits( HAS_PIPE ) )
            {
            if ( MyContext.AnyDescendantBits( HAS_IN ) )
                fHasInPipeParam = TRUE;
            node_skl* pBasicType = pN->GetBasicType();
            while ( pBasicType && pBasicType->NodeKind() == NODE_POINTER )
                {
                pBasicType = pBasicType->GetChild();
                }
            if ( ( pBasicType->NodeKind() == NODE_INTERFACE_REFERENCE && !fObjectProc ) ||
                 ( pBasicType->NodeKind() == NODE_PIPE && fObjectProc ) )
                {
                SemError(this, MyContext, UNIMPLEMENTED_FEATURE, pN->GetSymName() );
                }
            }
        else if ( MyContext.AnyDescendantBits( HAS_IN ) &&  
            MyContext.AnyDescendantBits   (
                                                HAS_STRING          |
                                                HAS_FULL_PTR        |
                                                HAS_VAR_ARRAY       |
                                                HAS_CONF_ARRAY      |
                                                HAS_CONF_VAR_ARRAY
                                                ) )
            {
            fHasInConfOrVaryingParam = TRUE;
            }

        if ( ulParamNumber == 0 ) // first parameter
            {
            // if parent interface is is any IAdviseSink ignore [async].
            if ( fAsync && fObjectProc )
                {
                unsigned int    nIndirection    = 0;
                node_skl*       pFType          = GetIndirectionLevel   (
                                                                        pN,
                                                                        nIndirection
                                                                        );
                // check async handle type
                if ( nIndirection != 2 )
                    {
                    if ( !fParentIsAnyIAdviseSink )
                        {
                        SemError(this, MyContext, OBJECT_ASYNC_NOT_DOUBLE_PTR, pN->GetChild()->GetSymName() );
                        }
                    }
                if ( strcmp( pFType->GetSymName(), OBJECT_ASYNC_HANDLE_NAME ) )
                    {
                    if ( !fParentIsAnyIAdviseSink )
                        {
                        SemError(this, MyContext, ASYNC_INCORRECT_TYPE, pN->GetChild()->GetSymName() );
                        }
                    }
                else
                    {
                    fHasAsyncManager = TRUE;
                    }
                // flag the first param of an object interface as async handle
                pN->SetIsAsyncHandleParam();
                if ( MyContext.AnyDescendantBits( HAS_OUT ) )
                    {
                    SemError( this, MyContext, ASYNC_NOT_IN, NULL );
                    }
                }

            // Oicf interpreter cannot handle floats as first param, switch to Os.
            // This is a non-issue for ORPC because of the 'this' pointer.

            if ( ! pCommand->NeedsNDR64Run()
                  && ( ( BasicChildKind == NODE_FLOAT ) 
                         || ( BasicChildKind == NODE_DOUBLE ) ) )
                {
                if ( ( fOptimize & OPTIMIZE_INTERPRETER_V2) )
                    {
                    if ( fObjectProc )
                        {
                        // Don't switch, generate NT 4.0 guard
                        pCommand->GetNdrVersionControl().SetHasFloatOrDoubleInOi();
                        }
                    else
                        if ( ForceNonInterpret() )
                            {
                            RpcSemError( this, MyContext, NON_OI_TOPLEVEL_FLOAT, NULL );
                            }
                    }
                }
            } // first parameter

        // Oi/Oic interpreter cannot handle float params on alpha, switch to Os.

        if ( ( BasicChildKind == NODE_FLOAT ) 
                   || ( BasicChildKind == NODE_DOUBLE )  )
            {
            if ( ! pCommand->NeedsNDR64Run() &&
                 ( fOptimize & OPTIMIZE_INTERPRETER ) )
                {
                // Old interpreter, always switch to -Os.
                if ( !( fOptimize & OPTIMIZE_INTERPRETER_V2 ) )
                    {
                    if (ForceNonInterpret())
                        {
                        RpcSemError( this, MyContext, NON_OI_TOPLEVEL_FLOAT, NULL );
                        }
                    }
                // For -Oicf, there were no problems for object rpc; check standard
                else if ( !fObjectProc  &&  ulParamNumber > 0 )
                    {
                    // For 64b, float and double work for object and standard rpc.
                    // The 32b NT4 engine didn't work for float args in standard rpc.
                    if ( !pCommand->Is64BitEnv()  &&  ( BasicChildKind == NODE_FLOAT ) )
                        {
                        if (ForceNonInterpret())
                            {
                            RpcSemError( this, MyContext, NON_OI_TOPLEVEL_FLOAT, NULL );
                            }
                        }
                    }
                    // For param0 and retval we force above.

                }
            }

/*
parameter sequence of odl:
1. Required parameters (parameters that do not have the defaultvalue or optional 
    attributes), 
2. optional parameters with or without the defaultvalue attribute, 
3. parameters with the optional attribute and without the defaultvalue attribute, 
4. lcid parameter, if any, 
5. retval parameter 
*/
        if ( pN->IsOptional() )
            {
            fLastParamWasOptional = TRUE;
            // [in,optional] VARIANT v1, [in] long l1, [in,optional] VARIANT v2
            if (nAfterLastOptionalParam > 0)
                nAfterLastOptionalParam++;
            // vararg can't coexist with optional parameter.
            if ( fHasVarArg )
                SemError(this, MyContext , NOT_VARARG_COMPATIBLE, 0 );
            
            }
        else
            {
            // If the following parameter after [optional] is either a RetVal or
            // LCID, we don't fail. The logic between Retval and LCID will be 
            // checked later.
            if ( fLastParamWasOptional )
                {
                // The only other parameter allowed to come after [optional]
                // in a propput/propget method is lcid. 
                if ( fPropSomething && !pN->IsLCID() )
                    nAfterLastOptionalParam++;
                else
                    if ( (!pN->IsRetval() && !pN->IsLCID()) && FNewTypeLib() )
                        {
                        // In regular method, we can only have retval and lcid coming
                        // after optional
                        SemError( this, MyContext, OPTIONAL_PARAMS_MUST_BE_LAST, NULL );
                        }
                }
            }

        if ( ( pAttr = (acf_attr *) pN->GetAttribute( ATTR_COMMSTAT ) ) != 0 )
            {
            if ( !MyContext.AnyDescendantBits( HAS_E_STAT_T ) )
                AcfError( pAttr, this, MyContext, INVALID_COMM_STATUS_PARAM, NULL );

            if ( Commstat == NOT_SEEN )
                Commstat = SEEN_ON_PARAM;
            else if ( Commstat == SEEN_ON_RETURN )
                AcfError( pAttr, this, MyContext, PROC_PARAM_COMM_STATUS, NULL );
            else // already on another parameter
                AcfError( pAttr, this, MyContext, ERROR_STATUS_T_REPEATED, NULL );
            }

        if ( ( pAttr = (acf_attr *) pN->GetAttribute( ATTR_FAULTSTAT ) ) != 0 )
            {
            if ( !MyContext.AnyDescendantBits( HAS_E_STAT_T ) )
                AcfError( pAttr, this, MyContext, INVALID_COMM_STATUS_PARAM, NULL );

            if ( Faultstat == NOT_SEEN )
                Faultstat = SEEN_ON_PARAM;
            else if ( Faultstat == SEEN_ON_RETURN )
                AcfError( pAttr, this, MyContext, PROC_PARAM_FAULT_STATUS, NULL );
            else // already on another parameter
                AcfError( pAttr, this, MyContext, ERROR_STATUS_T_REPEATED, NULL );
            }

        if (MyContext.AnyDescendantBits( HAS_HANDLE) )
            fHasExplicitHandle = TRUE;
        if (MyContext.AnyDescendantBits( HAS_IN ) )
            fHasAtLeastOneIn = TRUE;
        if ( MyContext.AnyDescendantBits( HAS_POINTER ) )
            fHasPointer = TRUE;
        if ( MyContext.AnyDescendantBits( HAS_FULL_PTR ) )
            fHasFullPointer = TRUE;
        if (MyContext.AnyDescendantBits( HAS_OUT) )
            {
            fHasAtLeastOneOut = TRUE;

            // complain about [out] on [maybe] procs
            if ( fMaybe )
                RpcSemError( this, MyContext, MAYBE_NO_OUT_RETVALS, NULL );
            }
        if (MyContext.AnyDescendantBits( (DESCENDANT_FLAGS) HAS_PIPE ))
        {
#if defined(TARGET_RKK)
            if ( pCommand->GetTargetSystem() < NT40 )
                RpcSemError( this, MyContext, REQUIRES_NT40, NULL );
#endif

            if (ForceInterpret2())
                RpcSemError( this, MyContext, REQUIRES_OI2, NULL );
            fHasPipes = TRUE;

            if ( HasPickle )
                RpcSemError( this, MyContext, PIPES_WITH_PICKLING, NULL );
        }

        // handle checks
        if ( pN->GetHandleKind() != HDL_NONE )
            {
            if ( !fBindingFound )   // first handle seen
                {
                // dce only allows in handles as the first param
                if ( ulParamNumber != 0 )
                    RpcSemError( this, MyContext, HANDLE_NOT_FIRST, NULL );

                // if the first binding handle is out-only, complain
                if ( !MyContext.AnyDescendantBits( HAS_IN ) &&
                        MyContext.AnyDescendantBits( HAS_OUT ) )
                    {
                    if ( !( MyContext.AnyAncestorBits( HAS_AUTO_HANDLE | HAS_IMPLICIT_HANDLE ) || 
                            fExpHdlAttr ) )
                        {
                        RpcSemError( this, MyContext, BINDING_HANDLE_IS_OUT_ONLY, NULL );
                        }
                    else if ( fExpHdlAttr )
                        {
                        fAddExplicitHandle = true;
                        }
                    }
                else if ( MyContext.AnyDescendantBits( HAS_OUT ) &&
                        ( pN->GetHandleKind() == HDL_PRIM ) )
                    {
                    RpcSemError( this, MyContext, HANDLE_T_CANNOT_BE_OUT, NULL );
                    }
                else  // plain [in], or [in,out]
                    {
                    fBindingFound = TRUE;
                    MyContext.SetAncestorBits( BINDING_SEEN );
                    }
                }
            else    // binding handle after the real one
                {
                if ( pN->GetHandleKind() == HDL_PRIM )
                    RpcSemError( this, MyContext, HANDLE_T_NO_TRANSMIT, NULL );
                }
            }       // if it had a handle

        if ( MyContext.AnyDescendantBits( HAS_TOO_BIG_HDL ) )
            {
            if (ForceNonInterpret())
                RpcSemError( this, MyContext, NON_OI_BIG_GEN_HDL, NULL );
            }
        else if ( !pCommand->NeedsNDR64Run() 
                  &&MyContext.AnyDescendantBits( HAS_UNSAT_REP_AS ) )
            {
            // This case should have been caught earlier.
            // REVIEW: Is this still relevant?
            if (ForceNonInterpret())
                RpcSemError( this, MyContext, NON_OI_UNK_REP_AS, NULL );
            }
        else if ( MyContext.AnyDescendantBits( HAS_UNION ) && IS_OLD_INTERPRETER( GetOptimizationFlags() ) )
            {
            node_skl * pNDC = pN->GetNonDefChild();
            if (pNDC->NodeKind() != NODE_PIPE && !pNDC->IsPtrOrArray())
                {
                // unions by value but not arrays of unions
                if (ForceNonInterpret())
                    RpcSemError( this, MyContext, NON_OI_UNION_PARM, NULL );
                }
            }

        if ( MyContext.AnyDescendantBits( HAS_DRTAG ) )
            fHasDRtag = TRUE;
        if ( MyContext.AnyDescendantBits( HAS_RTAG ) )
            fHasRtag = TRUE;
        if ( MyContext.AnyDescendantBits( HAS_STAG ) )
            fHasStag = TRUE;
        if ( MyContext.AnyDescendantBits( HAS_IN_CSTYPE ) )
            fHasInCSType = TRUE;
        if ( MyContext.AnyDescendantBits( HAS_OUT_CSTYPE ) )
            fHasOutCSType = TRUE;

        ulParamNumber++;
        }      // end of param list

    if ( MyContext.AnyDescendantBits( HAS_FORCEALLOCATE ) )
        {
        if ( ! ( GetOptimizationFlags() & OPTIMIZE_INTERPRETER_V2 ) )
            SemError( this, MyContext, FORCEALLOCATE_SUPPORTED_IN_OICF_ONLY, NULL );
        }

    if ( fGenDefaultValueExpr )
        {
        bool fReallyGenDefaultValueExpr = true;
        MemIter.Init();
        do
            {
            pN = (node_param *) MemIter.GetNext();
            }
        while ( pN != pFirstParamWithDefValue );
        do
            {
            node_skl* pType = GetNonDefType( pN->GetChild() );
            if ( !pType->IsBasicType() && pType->NodeKind() != NODE_POINTER && 
                 pType->NodeKind() != NODE_ENUM )
                {
                SemError( this, MyContext, DEFAULTVALUE_NOT_ALLOWED, pN->GetSymName() );
                fReallyGenDefaultValueExpr = false;
                break;
                }
                pN->GenDefaultValueExpr();
            pN = (node_param *) MemIter.GetNext();
            }
        while ( pN != 0 );
        // don't genereate any defaultvalue in c++ header at all 
        if ( !fReallyGenDefaultValueExpr )
            {
            MemIter.Init();
            while ( ( pN = (node_param *) MemIter.GetNext() ) != 0 )
                {
                pN->GenDefaultValueExpr( false );
                }
            }
        }

    if (  fHasInConfOrVaryingParam )
        {
        if ( fHasInPipeParam )
            SemError( this, MyContext, PIPE_INCOMPATIBLE_PARAMS, 0 );
        else if (fHasPipes )
            SemError( this, MyContext, OUT_PIPE_INCOMPATIBLE_PARAMS, 0 );
            
        }

    ///////////////////////////////////////////////////////////////////////

    if ( fHasExplicitHandle )
        {
        if ( fProcIsCallback )
            RpcSemError( this, MyContext, HANDLES_WITH_CALLBACK, NULL );
        }
    if ( !fHasExplicitHandle || fAddExplicitHandle )
        {
        if ( fExpHdlAttr )
            {
            // async handle should be first param,
            // programmer supplies IAsyncManager in ORPC
            // MIDL adds PRPC_ASYNC_STATE in RPC
            // if parent interface is is any IAdviseSink ignore async.
            if ( fObjectProc && fAsync && fHasAsyncManager )
                {
                AddExplicitHandle( &MyContext, 2 );
                }
            else
                {
                // MIDL will add async handle later
                AddExplicitHandle( &MyContext, 1 );
                }
            }
        else if ( !(pIntfCtxt->FInSummary( ATTR_IMPLICIT ) ) )
            {
            // no explicit handle, no implicit handle, use auto_handle
            if ( !fProcIsCallback &&
                    MyContext.AnyAncestorBits( IN_RPC ) &&
                    !fObjectProc )
                {
                if ( !pIntfCtxt->FInSummary( ATTR_AUTO ) )
                    RpcSemError( this, MyContext, NO_HANDLE_DEFINED_FOR_PROC, NULL );
                }
            }
        }

    if ( fObjectProc || MyContext.AnyAncestorBits( IN_LIBRARY ))
        {
        if (fHasExplicitHandle || 
            fExpHdlAttr ||
            MyContext.FInSummary( ATTR_IMPLICIT ) ||
            MyContext.FInSummary( ATTR_AUTO ) ||
            pIntfCtxt->FInSummary( ATTR_AUTO ) ||
            pIntfCtxt->FInSummary( ATTR_IMPLICIT ) ||
            pIntfCtxt->FInSummary( ATTR_EXPLICIT )  )
            {
            SemError( this, MyContext, HANDLES_WITH_OBJECT, NULL );
            }
        }

    // record whether there are any comm/fault statuses
    if ( ( Faultstat != NOT_SEEN ) || ( Commstat != NOT_SEEN ) )
        {
        fHasStatuses = TRUE;

        // [comm_status] and [fault_status] are supported in -Os.  Intrepreted
        // modes are only supported in NT 3.51 or later.  Hidden status 
        // params are only supported in interpreted mode post-Win2000.

        // REVIEW: We can get hidden status params to work for Win2000 by
        //         adding a line to the client stub that zero's the status
        //         before calling the interpreter.

        if ( GetOptimizationFlags() & OPTIMIZE_ANY_INTERPRETER )
            {
            if ( HasExtraStatusParam() 
                 && ( ! ( GetOptimizationFlags() & OPTIMIZE_INTERPRETER_V2 )
                      || !pCommand->NeedsNDR64Run() ) )
                {
                // invisible fault/comm status are not supported in the V1
                // interpreter.  Switch to -Os

                // REVIEW: For now, only support hidden status params in the
                //         V2 interpreter in -protocol all and -protocol ndr64

                if (ForceNonInterpret())
                    RpcSemError( this, MyContext, NON_OI_ERR_STATS, NULL );
                }
            else
                pCommand->GetNdrVersionControl().SetHasCommFaultStatusInOi12();
            }
        }

    // record info for statuses on the return type
    if ( Faultstat == SEEN_ON_RETURN )
        RTStatuses |= STATUS_FAULT;
    if ( Commstat == SEEN_ON_RETURN )
        RTStatuses |= STATUS_COMM;

    if ( fHasPointer && !pCommand->IsSwitchDefined( SWITCH_MS_EXT ) )
        pIntf->SetHasProcsWithRpcSs();

    if ( ( OpBits & ( OPERATION_MAYBE | OPERATION_BROADCAST | OPERATION_IDEMPOTENT ) ) != 0 &&
           fObjectProc )
        {
        SemError(this, MyContext, ILLEGAL_COMBINATION_OF_ATTRIBUTES, NULL);
        }

    // [message] only allowed in ORPC interfaces and RPC procs.
    if ( fMessage && fObjectProc )
        {
        // [message] applied on proc.
        SemError(this, MyContext, INAPPLICABLE_ATTRIBUTE, 0);
        }
    if ( MyContext.AnyAncestorBits( HAS_MESSAGE ) )
        {
        // [message] applied on interface.
        if ( !fObjectProc )
            {
            SemError(this, MyContext, INAPPLICABLE_ATTRIBUTE, 0);
            }
        fMessage = TRUE;
        }

    if ( fMessage )
        {
        if (    OpBits & OPERATION_BROADCAST
            ||  OpBits & OPERATION_IDEMPOTENT
            ||  OpBits & OPERATION_INPUT_SYNC
            ||  fMaybe
            ||  fAsync
            ||  fProcIsCallback
            ||  pCallAs
            ||  HasPickle
            ||  pHC
            ||  pHSC
            ||  pID
            ||  pHelpStr
            ||  MyContext.FInSummary(ATTR_BYTE_COUNT)
            ||  MyContext.FInSummary(ATTR_COMMSTAT)
            ||  MyContext.FInSummary(ATTR_CONTEXT)
            ||  MyContext.FInSummary(ATTR_CUSTOM)
            ||  MyContext.FInSummary(ATTR_ENABLE_ALLOCATE)
            ||  MyContext.FInSummary(ATTR_ENTRY)
            ||  MyContext.FInSummary(ATTR_FAULTSTAT)
            ||  MyContext.FInSummary(ATTR_FUNCDESCATTR)
            ||  MyContext.FInSummary(ATTR_HIDDEN)
            ||  MyContext.FInSummary(ATTR_MEMBER)
            ||  MyContext.FInSummary(ATTR_PTR_KIND)
            ||  MyContext.FInSummary(ATTR_VARDESCATTR)
            ||  MyContext.FInSummary(ATTR_OBJECT)
            ||  MyContext.FInSummary(ATTR_TYPEDESCATTR)
            ||  MyContext.FInSummary(ATTR_TYPE)
           )
            {
            SemError(this, MyContext, ILLEGAL_COMBINATION_OF_ATTRIBUTES, NULL);
            }
        if ( HasAtLeastOneOut() )
            {
            SemError(this, MyContext, MAYBE_NO_OUT_RETVALS, NULL);
            }
        }

    if ( MyContext.AnyAncestorBits( HAS_OLEAUTOMATION ) )
        {
        char*       szRetTypeNonDefName = 0;
        node_skl*   pReturnType         = GetReturnType();
        if (pReturnType)
            {
            szRetTypeNonDefName = pReturnType->GetSymName();
            }
        if ( GetReturnType()->GetBasicType()->NodeKind() != NODE_VOID && 
             (  !szRetTypeNonDefName || 
                _stricmp(szRetTypeNonDefName, "HRESULT") ) )
            {
            SemError(this, MyContext, NOT_OLEAUTOMATION_INTERFACE, NULL);
            }
        }

    if ( fPropSomething && MyContext.AnyAncestorBits( IN_LIBRARY ) )
        {
        // propget can either return the property in an out parameter or
        // in the return value.
        if ( fPropGet && !HasAParameter() && !HasReturn() )
            {
            SemError(this, MyContext, INVALID_USE_OF_PROPGET, NULL);
            }
        // propput must set the property in a parameter
        else if ( !fPropGet && !HasAParameter() )  
            {   
            SemError(this, MyContext, INVALID_USE_OF_PROPPUT, NULL);
            }
        }

    if (MyContext.AnyAncestorBits( (ANCESTOR_FLAGS) IN_DISPINTERFACE ) && !pID)
        {
        SemError(this, MyContext, DISPATCH_ID_REQUIRED, NULL);
        }
    if ( fAsync )
        {
        if ( fForcedS                       ||
             pOptAttr                       ||
             fNotify                        ||
             HasPickle                      || 
             fProcIsCallback                ||
             fLocal                         ||
             fCode                          ||
             fNoCode                        ||
             fMaybe                         ||
             fMessage                       ||
             OpBits & OPERATION_INPUT_SYNC  ||
             pIntfCtxt->FInSummary( ATTR_AUTO ) )
            {
            SemError(this, MyContext, ILLEGAL_COMBINATION_OF_ATTRIBUTES, NULL);
            }

        // async handle should be first param,
        // programmer supplies IAsyncManager in ORPC
        // MIDL adds PRPC_ASYNC_STATE in RPC
        if ( fObjectProc )
            {
            if ( fHasAsyncManager )
                {
                SetHasAsyncHandle();
                }
            // if parent interface is is any IAdviseSink ignore.
            if ( !fParentIsAnyIAdviseSink )
                {
                if ( ulParamNumber == 0 )
                    {
                    SemError( this, MyContext, ASYNC_INCORRECT_TYPE, 0);
                    }
                pCommand->GetNdrVersionControl().SetHasAsyncHandleRpc();
                }
            }
        else
            {
            AddFullAsyncHandle( &MyContext, 0, RPC_ASYNC_HANDLE_NAME );
            if ( pAttrAsync && !pAttrAsync->IsAcfAttr() )
                {
                SemError( this, MyContext, INAPPLICABLE_ATTRIBUTE, 0);
                }
            if ( !pIntfCtxt->FInSummary( ATTR_IMPLICIT ) &&
                 !fExpHdlAttr &&
                 !fHasExplicitHandle )
                {
                SemError( this, MyContext, ASYNC_INCORRECT_BINDING_HANDLE, 0 );
                }
            pCommand->GetNdrVersionControl().SetHasAsyncHandleRpc();
            }

        if ( pCommand->IsSwitchDefined( SWITCH_OSF ) )
            {
            SemError( this, MyContext, INVALID_OSF_ATTRIBUTE, "[async]" );
            }
        // switch compiler modes
        if (ForceInterpret2())
            {
            RpcSemError( this, MyContext, ASYNC_REQUIRES_OI2, NULL );
            }
        }

    // I don't like this complex logic, but unfortunately this is the right logic. It's easier
    // to code this logic in mktyplib code structure but hard to do it here...
    if ( fLCID )
        {
        node_param* pLCID;
        // if there is a [retval], [lcid] must be the second last
        if ( fRetval)
            pLCID = p2LastParam;
        else
        {
            if (fPropSomething)
            {
                // in propget without a retval, the lcid must be the last.
                // in propput/propputref, lcid is second last.
                if (fPropGet)
                    pLCID = pLastParam;
                else
                    pLCID = p2LastParam;
            }
            // lcid should be the last if it's a regular method without propsomething & retval
            else
                pLCID = pLastParam;
        }
                
        if ( !pLCID || !pLCID->IsLCID() )
            {
            SemError( this, MyContext, INVALID_USE_OF_LCID, 0 );
            }
        }

    // we can only have one parameter after optioanl in propput/propget, other than lcid.
    if ( fLastParamWasOptional && fPropSomething && ( nAfterLastOptionalParam > 1 ) )
        SemError(this, MyContext , INVALID_PROP_PARAMS , 0);
        
    // Verify that a propput method is valid.
    // TODO: much of the above code relating to propput/get could be simplified
    //       with state driven logic and is redundent with the code below

    if ( fPropSomething & !fPropGet )
    {
        using namespace PropPut;

        State       state = NoParam;
        node_param *pParam;

        MemIter.Init();

        while ( NULL != (pParam = (node_param *) MemIter.GetNext()) )
        {
            if ( pParam->FInSummary( ATTR_DEFAULTVALUE ) )
                state = StateTable[state][Default];

            else if ( pParam->IsOptional() )
                state = StateTable[state][Optional];

            else if ( pParam->IsLCID() )
                state = StateTable[state][LCID];

            else
                state = StateTable[state][GeneralParam];
        }

        state = StateTable[state][NoParam];

        if ( Accept != state )
            SemError(this, MyContext , INVALID_PROPPUT , 0);
    }


    if ( fHasVarArg )
        {
        // [vararg]  [lcid]   [retval]
        //  last        0        0       
        //  2 last    last       0
        //  2 last      0       last
        //  3 last    2last     last
        node_param* pVarargParam = fRetval ? ( fLCID ? p3LastParam : p2LastParam ) : ( fLCID ? p2LastParam : pLastParam );

        if ( pVarargParam )
            {
            node_skl* pType = pVarargParam->GetChild();

            if ( pType->NodeKind() == NODE_POINTER )
                {
                pType = pType->GetChild();
                }
            pType = GetNonDefType( pType );
            if ( pType->NodeKind() != NODE_SAFEARRAY || 
                 strcmp( GetNonDefType( pType->GetChild() )->GetSymName(), "tagVARIANT" ) )
                {
                SemError( this, MyContext, NOT_VARARG_COMPATIBLE, 0 );
                }
            }
        else
            {
            SemError( this, MyContext, NOT_VARARG_COMPATIBLE, 0 );
            }
        }

    if ( pIntf->IsAsyncClone() )
        {
        SetHasAsyncUUID();
        ForceInterpret2();
        }

    if ( fNotify || fNotifyFlag )
        {
        unsigned short uOpt = GetOptimizationFlags();
        if ( !( uOpt & OPTIMIZE_SIZE ) )
            {
            pCommand->GetNdrVersionControl().SetHasInterpretedNotify();
            if ( pCommand->GetTargetSystem() == NT40 )
                SemError( this, MyContext, INVALID_FEATURE_FOR_TARGET, "interpreted notify" );
            if ( IS_OLD_INTERPRETER(uOpt) )
                {
                if (ForceInterpret2())
                    RpcSemError( this, MyContext, NON_OI_NOTIFY, NULL );
                }
            }
        }

    if ( fHasInCSType && !fHasStag )
        SemError( this, MyContext, NO_TAGS_FOR_IN_CSTYPE, 0 );

    if ( fHasOutCSType && ( !fHasDRtag || !fHasRtag ) )
        SemError( this, MyContext, NO_TAGS_FOR_OUT_CSTYPE, 0 );

    if ( fHasInCSType || fHasOutCSType )
        {
        if ( NULL != pCSTagAttr )
            SetCSTagRoutine( pCSTagAttr->GetCSTagRoutine() );
        else
            MyContext.SetDescendantBits( HAS_IN_CSTYPE );
        }

    if ( HasPickle && MyContext.AnyDescendantBits( HAS_PARTIAL_IGNORE ) )
        {
        SemError( this, MyContext, PARTIAL_IGNORE_PICKLING, GetSymName() );
        }

    MyContext.SetDescendantBits( HAS_FUNC );
    pParentCtxt->ReturnValues( MyContext );
}

void
node_field::SemanticAnalysis( SEM_ANALYSIS_CTXT * pParentCtxt )
{
    SEM_ANALYSIS_CTXT MyContext( this, pParentCtxt );
    BOOL fLastField = ( GetSibling() == NULL );

    node_case * pCaseAttr;
    expr_list * pCaseExprList;
    expr_node * pCaseExpr;
    BOOL fHasCases = FALSE;
    node_su_base * pParent = (node_su_base *)
                             MyContext.GetParentContext()->GetParent();
    BOOL fInUnion = ( pParent->NodeKind() == NODE_UNION );
    node_switch_type * pSwTypeAttr = ( node_switch_type *)
                                     pParent->GetAttribute( ATTR_SWITCH_TYPE );
    node_skl * pSwType = NULL;
    char * pName = GetSymName();
    node_constant_attr * pID = (node_constant_attr *) MyContext.ExtractAttribute(ATTR_ID);
    MyContext.ExtractAttribute(ATTR_HELPCONTEXT);
    MyContext.ExtractAttribute(ATTR_HELPSTRINGCONTEXT);
    MyContext.ExtractAttribute(ATTR_HELPSTRING);
    if (MyContext.ExtractAttribute(ATTR_HELPSTRINGDLL))
        {
        SemError(this, MyContext, INAPPLICABLE_ATTRIBUTE, 0);
        }
    while(MyContext.ExtractAttribute(ATTR_CUSTOM));
    if ( MyContext.ExtractAttribute(ATTR_IDLDESCATTR) )
        {
        SemError(this, MyContext, NEWLYFOUND_INAPPLICABLE_ATTRIBUTE, 0);
        }

    if ( MyContext.ExtractAttribute(ATTR_VARDESCATTR) )
        {
        SemError(this, MyContext, NEWLYFOUND_INAPPLICABLE_ATTRIBUTE, 0);
        }
    

    MyContext.ExtractAttribute(ATTR_HIDDEN); 
        

    if ( HasCorrelation( this ) )
        {
        MyContext.IncCorrelationCount();
        }
            
    CheckDeclspecAlign( MyContext );

    if (pID)
    {
        SEM_ANALYSIS_CTXT * pIntfCtxt = (SEM_ANALYSIS_CTXT *)
                                    MyContext.GetInterfaceContext();
        node_interface * pIntf = (node_interface *) pIntfCtxt->GetParent();
        if (!pIntf->AddId(pID->GetExpr()->GetValue(), GetSymName()))
            SemError( this, MyContext, DUPLICATE_IID, NULL);
    }
    else
    {
        if ( MyContext.AnyAncestorBits( (ANCESTOR_FLAGS) IN_DISPINTERFACE ) &&
             pParent->NodeKind() == NODE_DISPINTERFACE)
            {
            SemError(this, MyContext, DISPATCH_ID_REQUIRED, NULL);
            }
    }

    node_entry_attr * pEntry = NULL;

    // check for illegal member attributes
    node_member_attr * pMA;
    while ( ( pMA = (node_member_attr *)MyContext.ExtractAttribute(ATTR_MEMBER) ) != 0 )
        {
        switch (pMA->GetAttr())
            {
            case MATTR_BINDABLE:
            case MATTR_DISPLAYBIND:
            case MATTR_DEFAULTBIND:
            case MATTR_REQUESTEDIT:
            case MATTR_DEFAULTVTABLE:
            case MATTR_PREDECLID:
            case MATTR_READONLY:
            case MATTR_UIDEFAULT:
            case MATTR_NONBROWSABLE:
            case MATTR_DEFAULTCOLLELEM:
            case MATTR_IMMEDIATEBIND:
            case MATTR_REPLACEABLE:
                break;
            case MATTR_SOURCE:
                {
                char * pAttrName = pMA->GetNodeNameString();
                if ( MyContext.AnyAncestorBits( IN_STRUCT | IN_UNION ) )
                    SemError( this, MyContext, NEWLYFOUND_INAPPLICABLE_ATTRIBUTE, pAttrName);
                break;
                }
            case MATTR_RESTRICTED:
                {
                char * pAttrName = pMA->GetNodeNameString();
                if ( !MyContext.AnyAncestorBits( IN_DISPINTERFACE ) )
                    SemError( this, MyContext, NEWLYFOUND_INAPPLICABLE_ATTRIBUTE, pAttrName);
                break;
                }
            case MATTR_PROPGET:
            case MATTR_PROPPUT:
            case MATTR_PROPPUTREF:
            case MATTR_OPTIONAL:
            case MATTR_RETVAL:
            case MATTR_VARARG:
            case MATTR_USESGETLASTERROR:
            default:
                {
                char * pAttrName = pMA->GetNodeNameString();
                SemError( this, MyContext, INAPPLICABLE_ATTRIBUTE, pAttrName);
                break;
                }
            }
        }


    if (MyContext.AnyAncestorBits( IN_MODULE ))
        pEntry = (node_entry_attr *) MyContext.ExtractAttribute( ATTR_ENTRY );

    if ( pSwTypeAttr )
        pSwType = pSwTypeAttr->GetType();

    // process all the cases and the default
    while ( ( pCaseAttr = (node_case *) MyContext.ExtractAttribute( ATTR_CASE ) ) != 0 )
        {
        if ( !fInUnion )
            TypeSemError( this, MyContext, INAPPLICABLE_ATTRIBUTE, "[case]" );

        fHasCases = TRUE;
        if ( pSwType )
            {
            pCaseExprList = pCaseAttr->GetExprList();
            pCaseExprList->Init();
            while ( pCaseExprList->GetPeer( &pCaseExpr ) == STATUS_OK )
                {
                // make sure the expression has the proper type, so sign extension behaves
                node_skl * pCaseType = pCaseExpr->GetType();

                if ( ( !pCaseType )  ||
                       ( pCaseType->GetNonDefSelf()->IsBasicType() ) )
                    {
                    pCaseExpr->SetType( pSwType->GetBasicType() );
                    }
                // range/type checks
                __int64 CaseValue = pCaseExpr->GetValue();
                if ( !((node_base_type *)pSwType)->RangeCheck( CaseValue ) )
                    TypeSemError( this, MyContext, CASE_VALUE_OUT_OF_RANGE, NULL );
                }
            }
        }

    if ( MyContext.ExtractAttribute( ATTR_DEFAULT ) )
        {
        if ( !fInUnion )
            TypeSemError( this, MyContext, INAPPLICABLE_ATTRIBUTE, "[default]" );

        fHasCases = TRUE;
        }

    // union fields in an RPC MUST have cases
    if ( fInUnion && !fHasCases )
        RpcSemError( this, MyContext, CASE_LABELS_MISSING_IN_UNION, NULL );

    // temp field names valid for: structs/enums/empty arms
    if ( IsTempName( pName ) )
        {
        NODE_T BaseType = GetBasicType()->NodeKind();
        if ( ( BaseType != NODE_UNION ) &&
                ( BaseType != NODE_STRUCT ) &&
                ( BaseType != NODE_ERROR ) )
            SemError( GetBasicType(), MyContext, BAD_CON_UNNAMED_FIELD_NO_STRUCT, NULL );
        }

    GetChild()->SemanticAnalysis( &MyContext );

    // allow conformant array or struct only as last field, and not in unions!
    if ( MyContext.AnyDescendantBits( HAS_CONF_ARRAY
            | HAS_CONF_VAR_ARRAY ) )
        {
        if ( fInUnion )
            {
            RpcSemError( this, MyContext, BAD_CON_UNION_FIELD_CONF , NULL );
            }
        else if (!fLastField )
            {
            SemError( this, MyContext, CONFORMANT_ARRAY_NOT_LAST, NULL );
            }
        }

    // disallow forward references as members
    if ( MyContext.AnyDescendantBits( HAS_INCOMPLETE_TYPE ) )
        {
        if (! MyContext.AnyAncestorBits( IN_LIBRARY ))
            SemError( this, MyContext, UNDEFINED_SYMBOL, NULL );
        MyContext.ClearDescendantBits( HAS_INCOMPLETE_TYPE );
        }
    MyContext.ClearDescendantBits( HAS_RECURSIVE_DEF );

    // don't allow functions as fields
    if ( MyContext.AnyDescendantBits( HAS_FUNC ) &&
            MyContext.AllAncestorBits( IN_INTERFACE | IN_RPC ) )
        RpcSemError( this, MyContext, BAD_CON_FIELD_FUNC, NULL );

    if ( MyContext.AnyDescendantBits( HAS_UNSAT_REP_AS ) )
        SetHasUnknownRepAs();

    pParentCtxt->ReturnValues( MyContext );
}

void
node_bitfield::SemanticAnalysis( SEM_ANALYSIS_CTXT * pParentCtxt )
{
    SEM_ANALYSIS_CTXT MyContext( this, pParentCtxt );
        
    CheckDeclspecAlign( MyContext );

    RpcSemError( this, MyContext, BAD_CON_BIT_FIELDS, NULL );

    if ( MyContext.AnyAncestorBits( IN_PARAM_LIST ) )
        {
        RpcSemError( this, MyContext, NON_RPC_PARAM_BIT_FIELDS, NULL );
        }
    else
        {
        RpcSemError( this, MyContext, NON_RPC_RTYPE_BIT_FIELDS, NULL );
        }

    GetChild()->SemanticAnalysis( &MyContext );

    node_skl * pType = GetBasicType();

    switch ( pType->NodeKind() )
        {
        case NODE_INT:
            break;
        case NODE_BOOLEAN:
        case NODE_SHORT:
        case NODE_CHAR:
        case NODE_LONG:
        case NODE_INT32:
        case NODE_INT3264:
        case NODE_INT64:
        case NODE_INT128:
        case NODE_HYPER:
            SemError( this, MyContext, BAD_CON_BIT_FIELD_NON_ANSI, NULL );
            break;
        default:
            SemError( this, MyContext, BAD_CON_BIT_FIELD_NOT_INTEGRAL, NULL );
            break;
        }

    // disallow forward references as members
    if ( MyContext.AnyDescendantBits( HAS_INCOMPLETE_TYPE ) )
        {
        if (! MyContext.AnyAncestorBits( IN_LIBRARY ))
            SemError( this, MyContext, UNDEFINED_SYMBOL, NULL );
        MyContext.ClearDescendantBits( HAS_INCOMPLETE_TYPE );
        }
    MyContext.ClearDescendantBits( HAS_RECURSIVE_DEF );

    pParentCtxt->ReturnValues( MyContext );
}

void
node_su_base::CheckLegalParent(SEM_ANALYSIS_CTXT & MyContext)
{
    WALK_CTXT * pParentCtxt = MyContext.GetParentContext();
    node_file * pFile = GetDefiningFile();
    if (NULL == pFile)
    {
        node_skl * pParent = pParentCtxt->GetParent();
        if (NULL == pParent || pParent->NodeKind() == NODE_LIBRARY)
            SemError( this, MyContext, ILLEGAL_SU_DEFINITION, NULL );
    }
};


void
node_enum::SemanticAnalysis( SEM_ANALYSIS_CTXT * pParentCtxt )
{
    MEM_ITER MemIter( this );
    node_skl * pN;
    SEM_ANALYSIS_CTXT MyContext( this, pParentCtxt );
    MyContext.ExtractAttribute( ATTR_V1_ENUM );
    while(MyContext.ExtractAttribute(ATTR_CUSTOM));
    MyContext.ExtractAttribute(ATTR_TYPEDESCATTR);
    MyContext.ExtractAttribute(ATTR_HELPCONTEXT);
    MyContext.ExtractAttribute(ATTR_HELPSTRINGCONTEXT);
    MyContext.ExtractAttribute( ATTR_HELPSTRING );
    if (MyContext.ExtractAttribute(ATTR_HELPSTRINGDLL))
        {
        SemError( this, MyContext, INAPPLICABLE_ATTRIBUTE, 0);
        }

    if ( MyContext.ExtractAttribute(ATTR_IDLDESCATTR) )
        {
        SemError(this, MyContext, INAPPLICABLE_ATTRIBUTE, 0);
        }

    // check for illegal type attributes
    node_type_attr * pTA;
    while ( ( pTA = (node_type_attr *)MyContext.ExtractAttribute(ATTR_TYPE) ) != 0 )
        {
        switch (pTA->GetAttr())
            {
            // acceptable attributes
            case TATTR_PUBLIC:
                {
                char        *       pAttrName = pTA->GetNodeNameString();
                SemError( this, MyContext, INAPPLICABLE_ATTRIBUTE, pAttrName);
                break;
                }
            }
        }

    // check for illegal member attributes
    node_member_attr * pMA;
    while ( ( pMA = (node_member_attr *)MyContext.ExtractAttribute(ATTR_MEMBER) ) != 0 )
        {
        switch (pMA->GetAttr())
            {
            case MATTR_USESGETLASTERROR:
                {
                char * pAttrName = pMA->GetNodeNameString();
                SemError( this, MyContext, NEWLYFOUND_INAPPLICABLE_ATTRIBUTE, pAttrName);
                break;
                }
            }
        }
        

    CheckDeclspecAlign( MyContext );

    node_guid * pGuid = (node_guid *) MyContext.ExtractAttribute( ATTR_GUID );
    // make sure the UUID is unique
    if ( pGuid )
        {
        node_skl* pDuplicate = GetDuplicateGuid( pGuid, pUUIDTable );
        if ( pDuplicate )
            {
            SemError(this, MyContext, DUPLICATE_UUID, pDuplicate->GetSymName());
            }
        }

    if (pCommand->IsSwitchDefined(SWITCH_MKTYPLIB))
        CheckLegalParent(MyContext);

    node_range_attr* pRange = ( node_range_attr* ) MyContext.ExtractAttribute(ATTR_RANGE);
    if ( pRange )
        {
        if ( pRange->GetMinExpr()->GetValue() > pRange->GetMaxExpr()->GetValue() )
            {
            SemError(this, MyContext, INCORRECT_RANGE_DEFN, 0);
            }
        }

    while ( ( pN = MemIter.GetNext() ) != 0 )
        {
        pN->SemanticAnalysis( &MyContext );
        }

    MyContext.SetDescendantBits( HAS_ENUM );
    pParentCtxt->ReturnValues( MyContext );
}

// structs are stringable if all the fields are "byte"
BOOL					
node_struct::IsStringableType()
{
	MEM_ITER	 			MemIter( this );
	node_skl		*		pBasic;
	node_skl		*		pN;

	// make sure all the fields are BYTE! with no attributes on the way
	while ( ( pN = (node_skl *) MemIter.GetNext() ) != 0 )
		{
		pBasic = pN->GetBasicType();
		do {
			if ( pN->HasAttributes() )
				return FALSE;
			pN = pN->GetChild();
			}
		while ( pN != pBasic );

		pBasic = pN->GetBasicType();

		if ( pBasic &&
			 (pBasic->NodeKind() != NODE_BYTE ) )
			{
			return FALSE;
			}
		}

	return TRUE;	
}

void
node_struct::SemanticAnalysis( SEM_ANALYSIS_CTXT * pParentCtxt )
{
    MEM_ITER MemIter( this );
    node_skl * pN;
    SEM_ANALYSIS_CTXT MyContext( this, pParentCtxt );

    if ( fBeingAnalyzed )
        {
        // if we hit the same node more than once (it can only be through a ptr),
        // and the ptr type is ref, we flag an error; recursive defn. through a ref ptr.
        if ( !MyContext.AnyAncestorBits( IN_NON_REF_PTR ) &&
             MyContext.AnyAncestorBits( IN_RPC ) )
            {
            TypeSemError( this, MyContext, RECURSION_THRU_REF, NULL );
            }
        return;
        }
    fBeingAnalyzed = TRUE;
        
    CheckDeclspecAlign( MyContext );

    BOOL fString = (NULL != MyContext.ExtractAttribute( ATTR_STRING ));
    node_guid * pGuid = (node_guid *) MyContext.ExtractAttribute( ATTR_GUID );
    // make sure the UUID is unique
    if ( pGuid )
        {
        node_skl* pDuplicate = GetDuplicateGuid( pGuid, pUUIDTable );
        if ( pDuplicate )
            {
            SemError(this, MyContext, DUPLICATE_UUID, pDuplicate->GetSymName());
            }
        }

    MyContext.MarkImportantPosition();
    MyContext.SetAncestorBits( IN_STRUCT );

    // clear NE union flag
    MyContext.ClearAncestorBits( IN_UNION | IN_NE_UNION );
    while(MyContext.ExtractAttribute(ATTR_CUSTOM));
    MyContext.ExtractAttribute(ATTR_TYPEDESCATTR);
    MyContext.ExtractAttribute(ATTR_HELPCONTEXT);
    MyContext.ExtractAttribute(ATTR_HELPSTRINGCONTEXT);
    MyContext.ExtractAttribute( ATTR_HELPSTRING );

    if ( MyContext.ExtractAttribute( ATTR_VERSION ) )
        {
        SemError(this, MyContext, NEWLYFOUND_INAPPLICABLE_ATTRIBUTE, 0);
        }
    
    if (MyContext.ExtractAttribute(ATTR_HELPSTRINGDLL))
        {
        SemError(this, MyContext, INAPPLICABLE_ATTRIBUTE, 0);
        }

    // clear member attributes
    while (MyContext.ExtractAttribute(ATTR_MEMBER));

    if (pCommand->IsSwitchDefined(SWITCH_MKTYPLIB))
        CheckLegalParent(MyContext);

    // See if context_handle applied to param reached us
    if ( CheckContextHandle( MyContext ) )
        {
        MyContext.SetDescendantBits( HAS_HANDLE | HAS_CONTEXT_HANDLE );
        }

    while ( ( pN = MemIter.GetNext() ) != 0 )
        {
        pN->SemanticAnalysis( &MyContext );

        if ( MyContext.AnyDescendantBits( HAS_HANDLE ) )
            TypeSemError( pN, MyContext, BAD_CON_CTXT_HDL_FIELD, NULL );
        }

    if ( fString && !IsStringableType() )
        {
        TypeSemError( this, MyContext, WRONG_TYPE_IN_STRING_STRUCT, NULL );
        }

    // If a structure has an embedded array of pointers the back end gets 
    // really confused and generates bad pointer layouts.  Work around the
    // problem by forcing the structure to be complex.

    if ( MyContext.AnyDescendantBits( HAS_VAR_ARRAY | HAS_ARRAYOFPOINTERS ) )
        Complexity |= FLD_VAR;
    if ( MyContext.AnyDescendantBits( HAS_CONF_ARRAY ) )
        {
        Complexity |= FLD_CONF;
        fHasConformance = 1;
        }
    if ( MyContext.AnyDescendantBits( HAS_CONF_VAR_ARRAY ) )
        {
        Complexity |= FLD_CONF_VAR;
        fHasConformance = 1;
        }

    // don't pass up direct conformance characteristic
    MyContext.ClearDescendantBits( HAS_DIRECT_CONF_OR_VAR );

    // disallow direct forward references as struct members
    if ( MyContext.AnyDescendantBits( HAS_INCOMPLETE_TYPE ) )
        {
        if (! MyContext.AnyAncestorBits( IN_LIBRARY ))
            SemError( this, MyContext, UNDEFINED_SYMBOL, NULL );
        MyContext.ClearDescendantBits( HAS_INCOMPLETE_TYPE );
        }
    MyContext.ClearDescendantBits( HAS_RECURSIVE_DEF );

    if ( MyContext.AnyDescendantBits( HAS_POINTER ) )
        SetHasAtLeastOnePointer( TRUE );

    // save info on complexity for code generation
    if ( MyContext.AnyDescendantBits( HAS_VAR_ARRAY |
            HAS_TRANSMIT_AS |
            HAS_REPRESENT_AS |
            HAS_INTERFACE_PTR |
            HAS_MULTIDIM_SIZING |
            HAS_ARRAY_OF_REF ) )
        {
        Complexity |= FLD_COMPLEX;
        }

    if(  fHasConformance &&
          !MyContext.AnyAncestorBits(IN_POINTER ) &&
          !MyContext.AnyAncestorBits(IN_TRANSMIT_AS ))
        {
        RpcSemError( this, MyContext, CONF_BY_VALUE , NULL );
        }
          
    if ( pCommand->NeedsNDR64Run() )
        {
        if ( MyContext.AnyDescendantBits( HAS_UNSAT_REP_AS ) )
            {
            RpcSemError( this, MyContext, UNSPECIFIED_EMBEDDED_REPRESENT_AS_NOT_SUPPORTED, NULL );
            }        
        }

    MyContext.ClearDescendantBits( HAS_ARRAY | HAS_MULTIDIM_VECTOR );
    MyContext.SetDescendantBits( HAS_STRUCT );

    pParentCtxt->ReturnValues( MyContext );
    fBeingAnalyzed = FALSE;
}


// note: this lets HAS_UNION propogate up to any enclosing structs
void
node_en_struct::SemanticAnalysis( SEM_ANALYSIS_CTXT * pParentCtxt )
{
    MEM_ITER MemIter( this );
    node_skl * pN;
    SEM_ANALYSIS_CTXT MyContext( this, pParentCtxt );

    if ( fBeingAnalyzed )
        {
        // if we hit the same node more than once (it can only be through a ptr),
        // and the ptr type is ref, we flag an error; recursive defn. through a ref ptr.
        if ( !MyContext.AnyAncestorBits( IN_NON_REF_PTR ) &&
             MyContext.AnyAncestorBits( IN_RPC ) )
            {
            TypeSemError( this, MyContext, RECURSION_THRU_REF, NULL );
            }
        return;
        }
    fBeingAnalyzed = TRUE;
    MyContext.ExtractAttribute(ATTR_HELPCONTEXT);
    MyContext.ExtractAttribute(ATTR_HELPSTRINGCONTEXT);
    MyContext.ExtractAttribute( ATTR_HELPSTRING );
    if (MyContext.ExtractAttribute(ATTR_HELPSTRINGDLL))
        {
        SemError(this, MyContext, INAPPLICABLE_ATTRIBUTE, 0);
        }

    CheckDeclspecAlign( MyContext );

    node_guid * pGuid = (node_guid *) MyContext.ExtractAttribute( ATTR_GUID );
    // make sure the UUID is unique
    if ( pGuid )
        {
        node_skl* pDuplicate = GetDuplicateGuid( pGuid, pUUIDTable );
        if ( pDuplicate )
            {
            SemError(this, MyContext, DUPLICATE_UUID, pDuplicate->GetSymName());
            }
        }

    if (pCommand->IsSwitchDefined(SWITCH_MKTYPLIB))
        CheckLegalParent(MyContext);

    MyContext.SetAncestorBits( IN_STRUCT );
    // See if context_handle applied to param reached us
    if ( CheckContextHandle( MyContext ) )
        {
        MyContext.SetDescendantBits( HAS_HANDLE | HAS_CONTEXT_HANDLE );
        }

    while ( ( pN = MemIter.GetNext() ) != 0 )
        {
        pN->SemanticAnalysis( &MyContext );
        };

    if ( pCommand->NeedsNDR64Run() )
        {
        if ( MyContext.AnyDescendantBits( HAS_UNSAT_REP_AS ) )
            {
            RpcSemError( this, MyContext, UNSPECIFIED_EMBEDDED_REPRESENT_AS_NOT_SUPPORTED, NULL );
            }
        }

    if ( MyContext.AnyDescendantBits( HAS_POINTER ) )
        SetHasAtLeastOnePointer( TRUE );

    pParentCtxt->ReturnValues( MyContext );
    fBeingAnalyzed = FALSE;
}

void
node_union::SemanticAnalysis( SEM_ANALYSIS_CTXT * pParentCtxt )
{
    MEM_ITER MemIter( this );
    node_field * pN;
    SEM_ANALYSIS_CTXT MyContext( this, pParentCtxt );
    BOOL fEncap  = IsEncapsulatedUnion();
    node_switch_type * pSwTypeAttr = (node_switch_type *) MyContext.ExtractAttribute( ATTR_SWITCH_TYPE );
    node_switch_is * pSwIsAttr = (node_switch_is *) MyContext.ExtractAttribute( ATTR_SWITCH_IS );
    BOOL NonEmptyArm = FALSE;
    BOOL HasCases = FALSE;
    BOOL HasBadExpr = FALSE;

    if ( HasCorrelation( this ) )
        {
        MyContext.IncCorrelationCount();
        }

    if (pCommand->IsSwitchDefined(SWITCH_MKTYPLIB))
        CheckLegalParent(MyContext);

    MyContext.ExtractAttribute(ATTR_TYPEDESCATTR);
    while(MyContext.ExtractAttribute(ATTR_CUSTOM));
    MyContext.ExtractAttribute(ATTR_HELPCONTEXT);
    MyContext.ExtractAttribute(ATTR_HELPSTRINGCONTEXT);
    MyContext.ExtractAttribute( ATTR_HELPSTRING );
    if (MyContext.ExtractAttribute(ATTR_HELPSTRINGDLL))
        {
        SemError(this, MyContext, INAPPLICABLE_ATTRIBUTE, 0);
        }

    if ( MyContext.ExtractAttribute( ATTR_HIDDEN ) )
        {
        SemError(this, MyContext, NEWLYFOUND_INAPPLICABLE_ATTRIBUTE, 0);
        }    

    if ( MyContext.ExtractAttribute( ATTR_VERSION ) )
        {
        SemError(this, MyContext, NEWLYFOUND_INAPPLICABLE_ATTRIBUTE, 0);
        }    
    

    if ( fBeingAnalyzed )
        {
        // if we hit the same node more than once (it can only be through a ptr),
        // and the ptr type is ref, we flag an error; recursive defn. through a ref ptr.
        if ( !MyContext.AnyAncestorBits( IN_NON_REF_PTR ) &&
             MyContext.AnyAncestorBits( IN_RPC ) )
            {
            TypeSemError( this, MyContext, RECURSION_THRU_REF, NULL );
            }
        return;
        }
    fBeingAnalyzed = TRUE;
        
    CheckDeclspecAlign( MyContext );

    if ( pSwIsAttr )
        {
        EXPR_CTXT SwCtxt( &MyContext );
        expr_node * pSwIsExpr = pSwIsAttr->GetExpr();

        pSwIsExpr->ExprAnalyze( &SwCtxt );

        if ( SwCtxt.AnyUpFlags( EX_UNSAT_FWD ) )
            {
            TypeSemError( this,
                MyContext,
                ATTRIBUTE_ID_UNRESOLVED,
                pSwIsAttr->GetNodeNameString() );
            HasBadExpr = TRUE;
            }

        if ( !SwCtxt.AnyUpFlags( EX_VALUE_INVALID ) )
            {
            TypeSemError( this,
                MyContext,
                ATTRIBUTE_ID_MUST_BE_VAR,
                pSwIsAttr->GetNodeNameString() );
            HasBadExpr = TRUE;
            }
        }

    // if they left off the switch_type, take it from the switch_is type
    if ( !pSwTypeAttr && !fEncap && pSwIsAttr && !HasBadExpr )
        {
        node_skl * pSwIsType = pSwIsAttr->GetSwitchIsType();

        MIDL_ASSERT( pSwIsType || !"no type for switch_is expr");
        if ( ( pSwIsType->NodeKind() == NODE_FIELD ) ||
                ( pSwIsType->NodeKind() == NODE_PARAM ) )
            pSwIsType = pSwIsType->GetChild();

        pSwTypeAttr = new node_switch_type( pSwIsType );
        SetAttribute( pSwTypeAttr );
        }

    if ( pSwIsAttr && pSwTypeAttr && !HasBadExpr )
        {
        node_skl * pSwIsType = pSwIsAttr->GetSwitchIsType();
        node_skl * pSwType  = pSwTypeAttr->GetType();

        pSwIsType = pSwIsType->GetBasicType();
        if ( pSwIsType && pSwIsType->IsBasicType() && pSwType->IsBasicType() )
            {
            if ( !((node_base_type *)pSwType)
                    ->IsAssignmentCompatible( (node_base_type *) pSwIsType ) )
                TypeSemError( this, MyContext, SWITCH_TYPE_MISMATCH, NULL );
            }

        if ( !pSwType || !Xxx_Is_Type_OK( pSwType ) )
            {
            TypeSemError( this,
                MyContext,
                SWITCH_IS_TYPE_IS_WRONG,
                pSwType ? pSwType->GetSymName() : NULL );
            }

        if ( !pSwIsType || !Xxx_Is_Type_OK( pSwIsType ) )
            {
            TypeSemError( this,
                MyContext,
                SWITCH_IS_TYPE_IS_WRONG,
                pSwIsType ? pSwIsType->GetSymName() : NULL );
            }
        }

    // We don't care about local: it can be anything.
    if ( MyContext.AnyAncestorBits( IN_RPC ) )
        {
        if ( !fEncap && !pSwTypeAttr && !pSwIsAttr )
            {
            if ( MyContext.AnyAncestorBits( IN_PARAM_LIST ) )
                RpcSemError( this, MyContext, NON_RPC_UNION, NULL );
            else
                RpcSemError( this, MyContext, NON_RPC_RTYPE_UNION, NULL );
            }
        if ( !fEncap &&
                MyContext.AnyAncestorBits( IN_FUNCTION_RESULT ) &&
                !MyContext.AnyAncestorBits( IN_STRUCT | IN_UNION ) )
            RpcSemError( this, MyContext, RETURN_OF_UNIONS_ILLEGAL, NULL );

        if ( pSwTypeAttr && !pSwIsAttr )
            RpcSemError( this, MyContext, NO_SWITCH_IS, NULL );
        }

    // See if context_handle applied to param reached us
    if ( CheckContextHandle( MyContext ) )
        {
        MyContext.SetDescendantBits( HAS_HANDLE | HAS_CONTEXT_HANDLE );
        }

    MyContext.MarkImportantPosition();

    if ( MyContext.AllAncestorBits( IN_INTERFACE | IN_NE_UNION ) )
        {
        RpcSemError( this, MyContext, NE_UNION_FIELD_NE_UNION, NULL );
        }
    if ( ( MyContext.FindNonDefAncestorContext()->GetParent()
            ->NodeKind() == NODE_UNION ) &&
            MyContext.AnyAncestorBits( IN_INTERFACE ) )
        {
        RpcSemError( this, MyContext, ARRAY_OF_UNIONS_ILLEGAL, NULL );
        }

    MyContext.SetAncestorBits( IN_UNION | IN_NE_UNION );
    MyContext.SetDescendantBits( HAS_UNION );

    // eat the union flavor determiner
    MyContext.ExtractAttribute( ATTR_MS_UNION );

    while ( ( pN = (node_field *) MemIter.GetNext() ) != 0 )
        {
        // tbd - put cases into case database...
        // tbd - check type, range, and duplication
        pN->SemanticAnalysis( &MyContext );

        if ( !NonEmptyArm && !pN->IsEmptyArm() )
            NonEmptyArm = TRUE;

        if ( !HasCases && (pN->FInSummary( ATTR_CASE ) || pN->FInSummary( ATTR_DEFAULT ) ) )
            HasCases = TRUE;

        }

    // at least one arm should be non-empty
    if ( !NonEmptyArm )
        SemError( this, MyContext, UNION_NO_FIELDS, NULL );

    if ( !fEncap && !pSwTypeAttr && !HasCases )
        RpcSemError( this, MyContext, BAD_CON_NON_RPC_UNION, NULL );

    // disallow forward references as union members
    if ( MyContext.AnyDescendantBits( HAS_INCOMPLETE_TYPE ) )
        {
        if (! MyContext.AnyAncestorBits( IN_LIBRARY ))
            SemError( this, MyContext, UNDEFINED_SYMBOL, NULL );
        MyContext.ClearDescendantBits( HAS_INCOMPLETE_TYPE );
        }
    MyContext.ClearDescendantBits( HAS_RECURSIVE_DEF );

    if ( MyContext.AnyDescendantBits( HAS_POINTER ) )
        SetHasAtLeastOnePointer( TRUE );

    if ( MyContext.AnyDescendantBits( HAS_CONF_ARRAY | HAS_CONF_VAR_ARRAY ) )
        {
        RpcSemError( this, MyContext, BAD_CON_UNION_FIELD_CONF , NULL );
        }

    if ( pCommand->NeedsNDR64Run() )
        {
        if ( MyContext.AnyDescendantBits( HAS_UNSAT_REP_AS ) )
            {
            RpcSemError( this, MyContext, UNSPECIFIED_EMBEDDED_REPRESENT_AS_NOT_SUPPORTED, NULL );
            }
        }

    // clear flags not affecting complexity above
    MyContext.ClearDescendantBits( HAS_POINTER |
        HAS_CONF_PTR |
        HAS_VAR_PTR |
        HAS_CONF_VAR_PTR |
        HAS_MULTIDIM_SIZING |
        HAS_MULTIDIM_VECTOR |
        HAS_ARRAY_OF_REF |
        HAS_ENUM |
        HAS_DIRECT_CONF_OR_VAR |
        HAS_ARRAY |
        HAS_REPRESENT_AS |
        HAS_TRANSMIT_AS |
        HAS_CONF_VAR_ARRAY |
        HAS_CONF_ARRAY |
        HAS_VAR_ARRAY );

    pParentCtxt->ReturnValues( MyContext );
    fBeingAnalyzed = FALSE;
}

void
node_en_union::SemanticAnalysis( SEM_ANALYSIS_CTXT * pParentCtxt )
{
    MEM_ITER MemIter( this );
    node_field * pN;
    SEM_ANALYSIS_CTXT MyContext( this, pParentCtxt );
    node_switch_type* pSwTypeAttr = ( node_switch_type* ) MyContext.ExtractAttribute( ATTR_SWITCH_TYPE );
    node_skl * pSwType;
    node_switch_is* pSwIsAttr = ( node_switch_is* ) MyContext.ExtractAttribute( ATTR_SWITCH_IS );
    BOOL NonEmptyArm = FALSE;

    if ( HasCorrelation( this ) )
        {
        MyContext.IncCorrelationCount();
        }

    // gaj - tbd do semantic checks on these attributes
    MyContext.ExtractAttribute( ATTR_HELPSTRING );
    MyContext.ExtractAttribute( ATTR_HELPSTRINGCONTEXT );
    MyContext.ExtractAttribute( ATTR_HELPCONTEXT );
    if (MyContext.ExtractAttribute(ATTR_HELPSTRINGDLL))
        {
        SemError(this, MyContext, INAPPLICABLE_ATTRIBUTE, 0);
        }

    node_guid * pGuid = (node_guid *) MyContext.ExtractAttribute( ATTR_GUID );
    // make sure the UUID is unique
    if ( pGuid )
        {
        node_skl* pDuplicate = GetDuplicateGuid( pGuid, pUUIDTable );
        if ( pDuplicate )
            {
            SemError(this, MyContext, DUPLICATE_UUID, pDuplicate->GetSymName());
            }
        }

    if ( fBeingAnalyzed )
        {
        // if we hit the same node more than once (it can only be through a ptr),
        // and the ptr type is ref, we flag an error; recursive defn. through a ref ptr.
        if ( !MyContext.AnyAncestorBits( IN_NON_REF_PTR ) &&
             MyContext.AnyAncestorBits( IN_RPC ) )
            {
            TypeSemError( this, MyContext, RECURSION_THRU_REF, NULL );
            }
        return;
        }
    fBeingAnalyzed = TRUE;
        
    CheckDeclspecAlign( MyContext );

    if ( pSwTypeAttr )
        {
        pSwType = pSwTypeAttr->GetSwitchType();
        if ( !pSwType ||
             !Xxx_Is_Type_OK( pSwType )  ||
             pSwType->NodeKind() == NODE_BYTE )
            {
            TypeSemError( this,
                MyContext,
                SWITCH_IS_TYPE_IS_WRONG,
                pSwType ? pSwType->GetSymName() : NULL );
            }
        }

    if ( pSwIsAttr )
        {
        EXPR_CTXT SwCtxt( &MyContext );
        expr_node * pSwIsExpr = pSwIsAttr->GetExpr();

        pSwIsExpr->ExprAnalyze( &SwCtxt );

        if ( SwCtxt.AnyUpFlags( EX_UNSAT_FWD ) )
            TypeSemError( this,
                MyContext,
                ATTRIBUTE_ID_UNRESOLVED,
                pSwIsAttr->GetNodeNameString() );

        if ( !SwCtxt.AnyUpFlags( EX_VALUE_INVALID ) )
            TypeSemError( this,
                MyContext,
                ATTRIBUTE_ID_MUST_BE_VAR,
                pSwIsAttr->GetNodeNameString() );
        }

    MyContext.MarkImportantPosition();
    MyContext.SetAncestorBits( IN_UNION );
    MyContext.SetDescendantBits( HAS_UNION );

    while ( ( pN = (node_field *) MemIter.GetNext() ) != 0 )
        {
        // tbd - put cases into case database...
        // tbd - check type, range, and duplication
        pN->SemanticAnalysis( &MyContext );
        if ( !pN->IsEmptyArm() )
            NonEmptyArm = TRUE;
        }

    // at least one arm should be non-empty
    if ( !NonEmptyArm )
        SemError( this, MyContext, UNION_NO_FIELDS, NULL );

    // remember if we have a pointer
    if ( MyContext.AnyDescendantBits( HAS_POINTER ) )
        SetHasAtLeastOnePointer( TRUE );

    if ( MyContext.AnyDescendantBits( HAS_CONF_ARRAY | HAS_CONF_VAR_ARRAY ) )
        {
        RpcSemError( this, MyContext, BAD_CON_UNION_FIELD_CONF , NULL );
        }

    // clear flags not affecting complexity above
    MyContext.ClearDescendantBits( HAS_POINTER |
        HAS_CONF_PTR |
        HAS_VAR_PTR |
        HAS_CONF_VAR_PTR |
        HAS_MULTIDIM_SIZING |
        HAS_MULTIDIM_VECTOR |
        HAS_ARRAY_OF_REF |
        HAS_ENUM |
        HAS_DIRECT_CONF_OR_VAR |
        HAS_ARRAY |
        HAS_REPRESENT_AS |
        HAS_TRANSMIT_AS |
        HAS_CONF_VAR_ARRAY |
        HAS_CONF_ARRAY |
        HAS_VAR_ARRAY );

    pParentCtxt->ReturnValues( MyContext );
    fBeingAnalyzed = FALSE;
}


void
node_def::SemanticAnalysisForTransmit( 
    SEM_ANALYSIS_CTXT * pMyContext,
    BOOL                fPresented )
{
    if ( fPresented )
        {
        // the presented type may not be conformant.
        if ( pMyContext->AnyDescendantBits( HAS_VAR_ARRAY
             | HAS_CONF_ARRAY
             | HAS_CONF_VAR_ARRAY ) )
            TypeSemError( this, *pMyContext, TRANSMIT_TYPE_CONF, NULL );
        }
    else
        {
        // transmitted type may not have a pointer.
        if ( pMyContext->AnyDescendantBits( HAS_POINTER | HAS_INTERFACE_PTR ) )
            TypeSemError( this,*pMyContext, TRANSMIT_AS_POINTER, NULL );

        // transmitted type may not derive from void
        if ( pMyContext->AnyDescendantBits(  DERIVES_FROM_VOID ) )
            TypeSemError( this, *pMyContext, TRANSMIT_AS_VOID, NULL );
        }

} 

void
node_def::SemanticAnalysisForWireMarshal( 
    SEM_ANALYSIS_CTXT * pMyContext,
    BOOL fPresented )
{

    if ( fPresented )
        {
        // We need to check if the presented type is not void; note, void * is ok.
        }
    else
        {
        // We check only the transmitted type for wire_marshal, user marshal.
        //
        // The transmitted type must not have full pointers, since
        // the app has no mechanism to generate the full pointer ids.

        // BUG, BUG semantic analysis treats arrays in structures 
        // as pointers.  Change to error once the bug is fixed. 

        if ( pMyContext->AnyDescendantBits( HAS_FULL_PTR ) )
            TypeSemError( this, *pMyContext, WIRE_HAS_FULL_PTR, NULL);
      
        // The wire type must have a fully defined memory size. It cannot be
        // conformant or conformant varying.  Arrays have a problem
        // in that the app can't marshal the MaxCount, Actual Count, or Offset properly.
        if ( pMyContext->AnyDescendantBits( HAS_CONF_ARRAY
                                            | HAS_CONF_VAR_ARRAY ) )
            TypeSemError( this, *pMyContext, WIRE_NOT_DEFINED_SIZE, NULL);  

        // transmitted type may not derive from void
        if ( pMyContext->AnyDescendantBits(  DERIVES_FROM_VOID ) )
            TypeSemError( this, *pMyContext, TRANSMIT_AS_VOID, NULL );
        }

}

void
node_def::SemanticAnalysis( SEM_ANALYSIS_CTXT * pParentCtxt )
{
    SEM_ANALYSIS_CTXT MyContext( this, pParentCtxt );
    BOOL fInRpc = MyContext.AnyAncestorBits( IN_RPC );
    BOOL fInPresented = MyContext.AnyAncestorBits( IN_PRESENTED_TYPE );
    SEM_ANALYSIS_CTXT * pIntfCtxt = (SEM_ANALYSIS_CTXT *)
        MyContext.GetInterfaceContext();
    node_represent_as * pRepresent  = (node_represent_as *)
        MyContext.ExtractAttribute( ATTR_REPRESENT_AS );
    node_transmit * pTransmit = (node_transmit *)
        MyContext.ExtractAttribute( ATTR_TRANSMIT );
    node_user_marshal * pUserMarshal = (node_user_marshal *)
        MyContext.ExtractAttribute( ATTR_USER_MARSHAL );
    node_wire_marshal * pWireMarshal = (node_wire_marshal *)
        MyContext.ExtractAttribute( ATTR_WIRE_MARSHAL );
    BOOL fRepMarshal  = pRepresent || pUserMarshal;
    BOOL fXmitMarshal = pTransmit  || pWireMarshal;
    BOOL fEncodeDecode = (NULL != MyContext.ExtractAttribute( ATTR_ENCODE ));
    MyContext.ExtractAttribute(ATTR_HELPSTRING);
    MyContext.ExtractAttribute( ATTR_HELPCONTEXT );
    MyContext.ExtractAttribute( ATTR_HELPSTRINGCONTEXT );
    
    
    // Partial ignore may not be used directly on an xmit or rep as.
    if (MyContext.AnyAncestorBits( UNDER_PARTIAL_IGNORE_PARAM ) && 
        ( fRepMarshal || fXmitMarshal ) )
        {
        SemError( this, MyContext, PARTIAL_IGNORE_UNIQUE, 0 );
        }
    
    if (MyContext.ExtractAttribute(ATTR_HELPSTRINGDLL))
        {
        SemError(this, MyContext, INAPPLICABLE_ATTRIBUTE, 0);
        }

    if ( HasCorrelation( this ) )
        {
        MyContext.IncCorrelationCount();
        }

    CheckDeclspecAlign( MyContext );

    node_range_attr* pRange = ( node_range_attr* ) MyContext.GetAttribute(ATTR_RANGE);
    if ( pRange )
        {
        if ( pRange->GetMinExpr()->GetValue() > pRange->GetMaxExpr()->GetValue() )
            {
            SemError(this, MyContext, INCORRECT_RANGE_DEFN, 0);
            }
        }

    BOOL fPropogateChild = TRUE; // propogate direct child info
    unsigned long ulHandleKind;

    // check for illegal type attributes
    node_type_attr * pTA;
    while ( ( pTA = (node_type_attr *)MyContext.ExtractAttribute(ATTR_TYPE) ) != 0 )
        {
        switch (pTA->GetAttr())
            {
            // acceptable attributes
            case TATTR_PUBLIC:
                {
                break;
                }
                // unacceptable attributes
            case TATTR_LICENSED:
            case TATTR_OLEAUTOMATION:
            case TATTR_APPOBJECT:
            case TATTR_CONTROL:
            case TATTR_PROXY:
            case TATTR_DUAL:
            case TATTR_NONEXTENSIBLE:
            case TATTR_NONCREATABLE:
            case TATTR_AGGREGATABLE:
                {
                char        *       pAttrName = pTA->GetNodeNameString();
                SemError( this, MyContext, INAPPLICABLE_ATTRIBUTE, pAttrName);
                break;
                }
            }
        }
    // check for illegal member attributes
    node_member_attr * pMA;
    while ( ( pMA = (node_member_attr *)MyContext.ExtractAttribute(ATTR_MEMBER) ) != 0 )
        {
        switch (pMA->GetAttr())
            {
            case MATTR_RESTRICTED:
                break;
            case MATTR_OPTIONAL:
            case MATTR_RETVAL:
            case MATTR_BINDABLE:
            case MATTR_DISPLAYBIND:
            case MATTR_DEFAULTBIND:
            case MATTR_REQUESTEDIT:
            case MATTR_PROPGET:
            case MATTR_PROPPUT:
            case MATTR_PROPPUTREF:
            case MATTR_VARARG:
            case MATTR_SOURCE:
            case MATTR_DEFAULTVTABLE:
            case MATTR_PREDECLID:
            case MATTR_UIDEFAULT:
            case MATTR_NONBROWSABLE:
            case MATTR_DEFAULTCOLLELEM:
            case MATTR_USESGETLASTERROR:
            case MATTR_IMMEDIATEBIND:
            case MATTR_REPLACEABLE:
            default:
                {
                char * pAttrName = pMA->GetNodeNameString();
                SemError( this, MyContext, INAPPLICABLE_ATTRIBUTE, pAttrName);
                break;
                }
            }
        }

#if defined(TARGET_RKK)
    // Checking the release compatibility

    if ( pCommand->GetTargetSystem() < NT40 )
        {
        if ( pWireMarshal )
            SemError( this, MyContext, REQUIRES_NT40, "[wire_marshal]" );
        if ( pUserMarshal )
            SemError( this, MyContext, REQUIRES_NT40, "[user_marshal]" );
        }

    if ( pCommand->GetTargetSystem() < NT351 )
        {
        if ( fEncodeDecode )
            SemError( this, MyContext, REQUIRES_NT351, "[encode,decode]" );
        }
#endif

    MyContext.ExtractAttribute(ATTR_TYPEDESCATTR);
    while(MyContext.ExtractAttribute(ATTR_CUSTOM));

    // clear the GUID, VERSION and HIDDEN attributes if set
    MyContext.ExtractAttribute( ATTR_HIDDEN );
    MyContext.ExtractAttribute( ATTR_VERSION );
    MyContext.ExtractAttribute( ATTR_HELPCONTEXT);
    MyContext.ExtractAttribute( ATTR_HELPSTRINGCONTEXT);

    node_guid * pGuid = (node_guid *) MyContext.ExtractAttribute( ATTR_GUID );
    // make sure the UUID is unique
    if ( pGuid )
        {
        node_skl* pDuplicate = GetDuplicateGuid( pGuid, pUUIDTable );
        if ( pDuplicate )
            {
            SemError(this, MyContext, DUPLICATE_UUID, pDuplicate->GetSymName());
            }
        }

    // get the encode and decode attributes
    fEncodeDecode |= (NULL != MyContext.ExtractAttribute( ATTR_DECODE ));
    fEncodeDecode |= pIntfCtxt->FInSummary( ATTR_ENCODE );
    fEncodeDecode |= pIntfCtxt->FInSummary( ATTR_DECODE );

    if ( fEncodeDecode )
        {
        // only direct children of the interface get these bits
        if ( !pParentCtxt->GetParent()->IsInterfaceOrObject() )
            {
            fEncodeDecode = FALSE;
            }
        else if (MyContext.AnyAncestorBits( IN_OBJECT_INTF ) )
            {
            fEncodeDecode = FALSE;
            TypeSemError( this, MyContext, PICKLING_INVALID_IN_OBJECT, NULL );
            }
        else
            {
            // note that this is an rpc-able interface
            GetMyInterfaceNode()->SetPickleInterface();
            MyContext.SetAncestorBits( IN_RPC );
            }

        SemError( this, MyContext, TYPE_PICKLING_INVALID_IN_OSF, NULL );

        BOOL HasV2Optimize = pCommand->GetOptimizationFlags() & OPTIMIZE_INTERPRETER_V2;

        if ( pCommand->IsSwitchDefined( SWITCH_ROBUST ) )
            {
            if ( HasV2Optimize )
                {
                pCommand->GetNdrVersionControl().SetHasOicfPickling(); 
                if ( pCommand->GetTargetSystem() == NT40 )
                    SemError( this, MyContext, INVALID_FEATURE_FOR_TARGET, ":oicf pickling" );                
                }
                else
                {
                SemError( this, MyContext, ROBUST_PICKLING_NO_OICF, 0 );
                }
            }

        BOOL HasCommFault = MyContext.FInSummary( ATTR_COMMSTAT )
                            || MyContext.FInSummary( ATTR_FAULTSTAT );

        if ( HasCommFault && !HasV2Optimize)
            {
            SemError( this, MyContext, COMMFAULT_PICKLING_NO_OICF, 0 );
            }
        }

    // kind of handle applied right now     (HandleKind only set for ones on this
    // typedef node)

    if ( FInSummary(ATTR_HANDLE) )
        {
        MyContext.ExtractAttribute( ATTR_HANDLE );
        SetHandleKind( HDL_GEN );
        }

    bool fSerialize = MyContext.ExtractAttribute( ATTR_SERIALIZE ) != 0;
    bool fNoSerialize = MyContext.ExtractAttribute( ATTR_NOSERIALIZE ) != 0;
    // See if context_handle applied to param reached us
    if ( FInSummary(ATTR_CONTEXT) )
        {
        if ( ( GetHandleKind() != HDL_NONE ) &&
                ( GetHandleKind() != HDL_CTXT ) )
            TypeSemError( this, MyContext, CTXT_HDL_GENERIC_HDL, NULL );

        MyContext.ExtractAttribute( ATTR_CONTEXT );
        if ( fSerialize && fNoSerialize )
            {
            SemError( this, MyContext, CONFLICTING_ATTRIBUTES, GetSymName() );
            }
        SetHandleKind( HDL_CTXT );

        // since the base type is not transmitted, we aren't really
        // in an rpc after here
        MyContext.ClearAncestorBits( IN_RPC );
        }
    else
        {
        if ( fSerialize || fNoSerialize )
            {
            SemError( this, MyContext, NO_CONTEXT_HANDLE, GetSymName() );
            }
        }

    ulHandleKind = GetHandleKind();
    if ( ulHandleKind != HDL_NONE )
        {
        MyContext.SetAncestorBits( IN_HANDLE );
        }

    // effectively, the presented type is NOT involved in an RPC

    if ( fXmitMarshal )
        {
        MyContext.ClearAncestorBits( IN_RPC );
        MyContext.SetAncestorBits( IN_PRESENTED_TYPE );

        if ( MyContext.FInSummary( ATTR_ALLOCATE ) )
            AcfError( (acf_attr *) MyContext.ExtractAttribute( ATTR_ALLOCATE ),
                this,
                MyContext,
                ALLOCATE_ON_TRANSMIT_AS,
                NULL );

        if ( GetHandleKind() == HDL_CTXT )
            TypeSemError( this, MyContext, TRANSMIT_AS_CTXT_HANDLE, NULL );

        }

    if ( MyContext.ExtractAttribute( ATTR_CSCHAR ) )
        {
        if ( MyContext.AnyAncestorBits( UNDER_IN_PARAM ) )
            MyContext.SetDescendantBits( HAS_IN_CSTYPE );

        if ( MyContext.AnyAncestorBits( UNDER_OUT_PARAM ) )
            MyContext.SetDescendantBits( HAS_OUT_CSTYPE );
        }

    // process the child
    GetChild()->SemanticAnalysis( &MyContext );

    if (pCommand->IsSwitchDefined(SWITCH_MKTYPLIB))
        {
        switch (GetChild()->NodeKind())
            {
            case NODE_STRUCT:
            case NODE_UNION:
            case NODE_ENUM:
                {
                // This is the 'typedef' part of a 'typedef struct',
                // 'typedef union', or 'typedef enum' declaration.
                // Make sure that the type info name is set to the name of the
                // typedef and not the child.
                ((node_su_base *)GetChild())->SetTypeInfoName(GetSymName());
                }
                break;
            }
        }
    else
        {
        if (GetChild()->GetSymName() && IsTempName(GetChild()->GetSymName()))
            {
            // Make sure that at least the [public] attribute is
            // set on this typedef, forcing this typedef to be put
            // in a type library if it is referenced from within one.
            SetAttribute(new node_type_attr(TATTR_PUBLIC));
            }
        }
/* yongqu: don't enable this before we read custom data. 
    if ( GetChild()->NodeKind() == NODE_INT3264 )
        {
        SetAttribute( GetCustomAttrINT3264() );
        }
*/
    // process all the nasties of transmit_as and wire_marshal
    if ( fXmitMarshal && !fInPresented && fInRpc )
        {
        SEM_ANALYSIS_CTXT TransmitContext( &MyContext );
        // eat the attributes added by the above constructor
        TransmitContext.ClearAttributes();

        // process the transmitted type
        TransmitContext.SetAncestorBits( IN_TRANSMIT_AS );
        if ( pWireMarshal )
            TransmitContext.SetAncestorBits( IN_USER_MARSHAL );
        TransmitContext.ClearAncestorBits( IN_PRESENTED_TYPE );

        if ( fInRpc)
            TransmitContext.SetAncestorBits( IN_RPC );

        if ( pTransmit )
            pTransmit->GetType()->SemanticAnalysis( &TransmitContext );
        else if ( pWireMarshal )
            pWireMarshal->GetType()->SemanticAnalysis( &TransmitContext );
        else
            MIDL_ASSERT(0);

        if ( pTransmit )
            {
            // check the transmitted type.
            SemanticAnalysisForTransmit( &TransmitContext, FALSE );
            
            // Check the presented type.
            SemanticAnalysisForTransmit( &MyContext, TRUE );

            }
        else if ( pWireMarshal )
            {
            // check the transmitted type
            SemanticAnalysisForWireMarshal( &TransmitContext, FALSE );

            // check the presented type
            SemanticAnalysisForWireMarshal( &MyContext, TRUE );

            }
        else {
           MIDL_ASSERT(0);
           }

        if ( TransmitContext.AnyDescendantBits( HAS_HANDLE ) )
            {
            //gaj TypeSemError( this, MyContext, HANDLE_T_XMIT, NULL );
            }

        if ( TransmitContext.AnyDescendantBits( HAS_TRANSMIT_AS ) )
            {
            TypeSemError( this, MyContext, TRANSMIT_AS_NON_RPCABLE, NULL );
            }

        TransmitContext.SetDescendantBits( HAS_TRANSMIT_AS );
        // since the base type is not transmitted, we aren't really
        // in an rpc after here
        pParentCtxt->ReturnValues( TransmitContext );
        fPropogateChild = FALSE;
        }

    // process all the nasties of represent_as and user_marshal
    if ( fRepMarshal )
        {
        node_represent_as * pRepUser = (pRepresent) ? pRepresent
                                                    : pUserMarshal ;

        if ( ulHandleKind == HDL_CTXT )
            AcfError( pRepUser, this, MyContext, TRANSMIT_AS_CTXT_HANDLE, NULL );

        // process the transmitted type
        MyContext.SetAncestorBits( IN_REPRESENT_AS  );
        if ( pUserMarshal )
            MyContext.SetAncestorBits( IN_USER_MARSHAL );
        pParentCtxt->SetDescendantBits( HAS_REPRESENT_AS );
        if ( !pRepUser->GetRepresentationType() )
           {
           pParentCtxt->SetDescendantBits( HAS_UNSAT_REP_AS );
           
           if ( pCommand->NeedsNDR64Run() )
               {
               AcfError( pRepUser, this, MyContext, UNSPECIFIED_REP_OR_UMRSHL_IN_NDR64, NULL );
               }
           }

        if ( pUserMarshal )
           {
           // Check the transmitted type.
           SemanticAnalysisForWireMarshal( &MyContext, FALSE );
           }
        else if ( pRepresent )
           {
           // Check the transmitted type.
           SemanticAnalysisForTransmit( &MyContext, FALSE );
           }

        // since the base type is not transmitted, we aren't really
        // in an rpc after here
        }

    // make checks for encode/decode
    if ( fEncodeDecode )
        {
        if ( MyContext.AnyDescendantBits( HAS_DIRECT_CONF_OR_VAR ) )
            TypeSemError( this, MyContext, ENCODE_CONF_OR_VAR, NULL );

        }

    // process handles
    if ( ulHandleKind != HDL_NONE)
        {
        if  ( ulHandleKind == HDL_GEN )
            {
            if ( MyContext.AnyDescendantBits( DERIVES_FROM_VOID ) )
                TypeSemError( this, MyContext, GENERIC_HDL_VOID, NULL );

            if ( MyContext.AnyDescendantBits( HAS_TRANSMIT_AS ) )
                TypeSemError( this, MyContext, GENERIC_HANDLE_XMIT_AS, NULL );

            if ( MyContext.AnyAncestorBits( IN_INTERPRET ) &&
                    ( GetChild()->GetSize() > (unsigned long)(SIZEOF_MEM_PTR()) ) )
                {
                if ( pCommand->NeedsNDR64Run() )
                    TypeSemError( this, MyContext, UNSUPPORTED_LARGE_GENERIC_HANDLE, NULL );
                else
                    MyContext.SetDescendantBits( HAS_TOO_BIG_HDL );
                }
            }

        if ( ulHandleKind == HDL_CTXT )
            {
            MyContext.SetDescendantBits( HAS_CONTEXT_HANDLE );
            if ( GetBasicType()->NodeKind() != NODE_POINTER )
                TypeSemError( this, MyContext, CTXT_HDL_NON_PTR, NULL );
            }

        MyContext.SetDescendantBits( HAS_HANDLE );

        WALK_CTXT * pParamCtxt = (SEM_ANALYSIS_CTXT *)
            MyContext.GetParentContext();
        node_param * pParamNode;
        node_skl * pCurNode;
        short PtrDepth = 0;

        // this returns NULL if no appropriate ancestor found
        while ( pParamCtxt )
            {
            pCurNode = pParamCtxt->GetParent();
            if ( pCurNode->NodeKind() == NODE_PARAM )
                break;

            if ( ( pCurNode->NodeKind() == NODE_DEF ) &&
                    pCurNode->FInSummary( ATTR_TRANSMIT ) )
                {
                pParamCtxt = NULL;
                break;
                }

            if ( pCurNode->NodeKind() == NODE_POINTER )
                {
                PtrDepth ++;

                if ( MyContext.AllAncestorBits( IN_RPC | IN_FUNCTION_RESULT ) )
                    {
                    SemError( this, MyContext, CTXT_HDL_MUST_BE_DIRECT_RETURN, NULL );
                    pParamCtxt = NULL;
                    break;
                    }
                }

            pParamCtxt = (SEM_ANALYSIS_CTXT *)pParamCtxt->GetParentContext();
            }

        pParamNode = (pParamCtxt) ? (node_param *) pParamCtxt->GetParent() : NULL;

        // stuff handle info into our param node
        if ( pParamNode )
            pParamNode->HandleKind = ulHandleKind;

        // out context/generic handles must be two levels deep
        if ( pParamCtxt &&
                MyContext.AnyAncestorBits( UNDER_OUT_PARAM ) &&
                ( PtrDepth < 1 ) )
            TypeSemError( this, MyContext, OUT_CONTEXT_GENERIC_HANDLE, NULL );

        }

    if ( IsHResultOrSCode() )
        {
        MyContext.SetDescendantBits( HAS_HRESULT );
        }

    // don't propogate info here from below if we had transmit_as,
    // it is propogated above...
    if ( fPropogateChild )
        {
        pParentCtxt->ReturnValues( MyContext );
        }

    // set the DontCallFreeInst flag on the param
    if ( ( pTransmit || pRepresent ) &&
            fInRpc &&
            MyContext.AllAncestorBits( IN_PARAM_LIST ) &&
            !MyContext.AnyAncestorBits( UNDER_OUT_PARAM ) )
        {
        // look up the context stack.  If any non-pointer, non-def found,
        // set the fDontCallFreeInst flag on the param
        MarkDontCallFreeInst( &MyContext );
        }
}


// look up the context stack.  If any non-pointer, non-def found,
// set the fDontCallFreeInst flag on the param
void
node_def::MarkDontCallFreeInst( SEM_ANALYSIS_CTXT * pCtxt )
{
    SEM_ANALYSIS_CTXT * pCurCtxt = pCtxt;
    node_skl * pCurNode;
    NODE_T Kind;
    unsigned long MarkIt = 2;

    for(;;)
        {
        pCurCtxt = (SEM_ANALYSIS_CTXT *) pCurCtxt->GetParentContext();
        pCurNode = pCurCtxt->GetParent();
        Kind = pCurNode->NodeKind();

        switch ( Kind )
            {
            case NODE_DEF:
            case NODE_POINTER:
                break;
            case NODE_PARAM:
                // if we only found defs and pointers, this will
                // leave it unchanged
                ((node_param *)pCurNode)->fDontCallFreeInst |= MarkIt;
                return;
            default:
                MarkIt = 1;
                break;
            }
        }

}


// interface nodes have two entries on the context stack;
// one for the interface node, and one for info to pass to
// the children
void
node_interface::SemanticAnalysis( SEM_ANALYSIS_CTXT * pParentCtxt )
{
    SEM_ANALYSIS_CTXT   MyContext( this, pParentCtxt );
    MEM_ITER            MemList( this );
    named_node*         pN;
    SEM_ANALYSIS_CTXT   ChildCtxt( &MyContext );

    BOOL IsLocal    = MyContext.FInSummary( ATTR_LOCAL );
    BOOL HasGuid    = MyContext.FInSummary( ATTR_GUID );
    BOOL IsObject   = MyContext.FInSummary( ATTR_OBJECT );
    BOOL fEncode    = MyContext.FInSummary( ATTR_ENCODE );
    BOOL fDecode    = MyContext.FInSummary( ATTR_DECODE );
    BOOL IsPickle   = fEncode || fDecode;
    BOOL HasVersion = MyContext.FInSummary( ATTR_VERSION );
    BOOL IsIUnknown = FALSE;
    BOOL fAuto      = MyContext.FInSummary( ATTR_AUTO );
    BOOL fCode      = MyContext.FInSummary( ATTR_CODE );
    BOOL fNoCode    = MyContext.FInSummary( ATTR_NOCODE );
    
    fHasMSConfStructAttr   = fHasMSConfStructAttr || MyContext.ExtractAttribute( ATTR_MS_CONF_STRUCT ) != 0;

    node_implicit*  pImplicit       = ( node_implicit* ) MyContext.GetAttribute( ATTR_IMPLICIT );
    acf_attr*       pExplicit       = ( acf_attr* ) MyContext.GetAttribute( ATTR_EXPLICIT );
    node_optimize*  pOptAttr        = 0;
    bool            fAnalizeAsyncIf = false;
    node_cs_tag_rtn*    pCSTagAttr  = 0;

    // [message] only allowed in ORPC interfaces and RPC procs.
    node_base_attr* pTemp = MyContext.GetAttribute( ATTR_MESSAGE );
    if ( pTemp )
        {
        if ( !IsObject )
            {
            SemError(
                    this,
                    MyContext,
                    INAPPLICABLE_ATTRIBUTE, 
                    pTemp->GetNodeNameString()
                    );
            }
        ChildCtxt.SetAncestorBits( HAS_MESSAGE );
        }

    // process async_uuid before doing anything
    if ( !IsAsyncClone() )
        {
        node_guid*  pAsyncGuid = (node_guid*) MyContext.GetAttribute( ATTR_ASYNCUUID );

        if ( pAsyncGuid )
            {
            if ( GetDefiningFile()->GetImportLevel() == 0 )
                {
                pCommand->GetNdrVersionControl().SetHasAsyncUUID();
                }

            ChildCtxt.SetAncestorBits( HAS_ASYNC_UUID );
            // async_uuid can only be applied to an object interface.
            if ( !IsObject || !pBaseIntf )
                {
                SemError(
                        this,
                        MyContext,
                        INAPPLICABLE_ATTRIBUTE, 
                        pAsyncGuid->GetNodeNameString()
                        );
                }

            if (  !GetAsyncInterface() )
                {
                // duplicate this interface and split its methods
                SetAsyncInterface( CloneIFAndSplitMethods( this ) );
                if ( GetAsyncInterface() )
                    {
                    fAnalizeAsyncIf = true;
                    GetAsyncInterface()->SetIsAsyncClone();
                    }
                }
            }
        }
    else
        {
        // This is the cloned interface, don't clone it again.
        ChildCtxt.SetAncestorBits( HAS_ASYNC_UUID );
        }

    while( MyContext.ExtractAttribute(ATTR_CUSTOM) )
        ;
    MyContext.ExtractAttribute( ATTR_TYPEDESCATTR );
    MyContext.ExtractAttribute( ATTR_HIDDEN );
    MyContext.ExtractAttribute( ATTR_VERSION );
    MyContext.ExtractAttribute( ATTR_HELPSTRING );
    MyContext.ExtractAttribute( ATTR_HELPSTRINGCONTEXT );
    MyContext.ExtractAttribute( ATTR_HELPCONTEXT );
    MyContext.ExtractAttribute( ATTR_LCID );

    if (MyContext.ExtractAttribute(ATTR_HELPSTRINGDLL))
        {
        SemError(this, MyContext, INAPPLICABLE_ATTRIBUTE, 0);
        }

    // don't pass the interface attributes down directly...
    // pass them down elsewhere

    ChildCtxt.SetInterfaceContext( &MyContext );

    //
    // check the interface attributes
    //

    // make sure we only get analyzed once when object interfaces
    // check their inherited info
    if ( fSemAnalyzed )
        return;

    fSemAnalyzed = TRUE;

#ifdef gajgaj
    // look for pointer default
    if ( !FInSummary( ATTR_PTR_KIND ) &&
            MyContext.AnyAncestorBits( IN_INTERFACE ) )
        {
        RpcSemError(this, MyContext, NO_PTR_DEFAULT_ON_INTERFACE, NULL );
        }
#endif // gajgaj

    // must have exactly one of [local] or [UUID]
    if (IsLocal && HasGuid && !IsObject )
        {
        SemError( this, MyContext, UUID_LOCAL_BOTH_SPECIFIED, NULL );
        }

    // object interface error checking
    if ( IsObject )
        {
        MyContext.SetAncestorBits( IN_OBJECT_INTF );
        ChildCtxt.SetAncestorBits( IN_OBJECT_INTF );

        if ( HasVersion )
            {
            SemError( this, MyContext, OBJECT_WITH_VERSION, NULL );
            }
        }

    // make sure the uuid is unique
    node_guid * pGuid = (node_guid *) MyContext.ExtractAttribute( ATTR_GUID );
    // make sure the UUID is unique
    if ( pGuid )
        {
        node_skl* pDuplicate = GetDuplicateGuid( pGuid, pUUIDTable );
        if ( pDuplicate )
            {
            SemError(this, MyContext, DUPLICATE_UUID, pDuplicate->GetSymName());
            }
        }

    /////////////////////////////////////////////////////////////////////
    //Check the base interface
    if (pBaseIntf)
        {
        if ( !IsObject  && !MyContext.AnyAncestorBits(IN_LIBRARY))
            {
            SemError( this, MyContext, ILLEGAL_INTERFACE_DERIVATION, NULL );
            }

        ChildCtxt.SetAncestorBits( IN_BASE_CLASS );

        pBaseIntf->SemanticAnalysis( &ChildCtxt );

        if ( ChildCtxt.AnyDescendantBits( HAS_INCOMPLETE_TYPE ) )
            {
            SemError( pBaseIntf, ChildCtxt, UNRESOLVED_TYPE, pBaseIntf->GetSymName() );
            }
        else
            {
            if ( pBaseIntf->NodeKind() != NODE_INTERFACE_REFERENCE &&  pBaseIntf->NodeKind() != NODE_HREF )
                {
                SemError( this, MyContext, ILLEGAL_BASE_INTERFACE, NULL );
                }
            
            node_interface* pRealBaseIf = ( ( node_interface_reference* ) pBaseIntf )->GetRealInterface();

            // verify the base interface is really an interface. 
            if ( pRealBaseIf == NULL || ( pRealBaseIf->NodeKind() != NODE_INTERFACE && 
                                          pRealBaseIf->NodeKind() != NODE_DISPINTERFACE ) )
                {
                SemError( this, MyContext, ILLEGAL_BASE_INTERFACE, NULL );          
                }
            
            if ( fAnalizeAsyncIf )
                {
                if ( pBaseIntf->NodeKind() != NODE_INTERFACE_REFERENCE )
                    {
                    SemError( this, MyContext, ILLEGAL_BASE_INTERFACE, NULL );
                    }
                else
                    {
                    node_interface* pRealBaseIf = ( ( node_interface_reference* ) pBaseIntf )->GetRealInterface();
                    if ( !pRealBaseIf->GetAsyncInterface() && strcmp( pRealBaseIf->GetSymName(), "IUnknown" ) ) 
                        {
                        SemError( this, MyContext, ILLEGAL_BASE_INTERFACE, NULL );
                        }
                    }
                }

            if ( pBaseIntf->NodeKind() == NODE_INTERFACE_REFERENCE && HasGuid )
                {
                node_interface* pRealBaseIf = ( ( node_interface_reference* ) pBaseIntf )->GetRealInterface();
                if ( pRealBaseIf )
                    {
                    node_guid * pNodeGuid = (node_guid *) pRealBaseIf->GetAttribute( ATTR_GUID );
                    if ( pNodeGuid )
                        {
                        GUID thisGuid;
                        pGuid->GetGuid( thisGuid );
                        GUID baseIFGuid;
                        pNodeGuid->GetGuid( baseIFGuid );
                        if ( !IsAnyIAdviseSinkIID( thisGuid ) )
                            {
                            if ( IsAnyIAdviseSinkIID( baseIFGuid ) )
                                {
                                SemError( this, MyContext, CANNOT_INHERIT_IADVISESINK, pBaseIntf->GetSymName() );
                                }
                            }
                        else 
                            {
                            ChildCtxt.SetAncestorBits( IN_IADVISESINK );
                            }
                        }
                    }
                }
            }

        // note that the above deletes intervening forwards
        ChildCtxt.ClearAncestorBits( IN_BASE_CLASS );
        }

    if ( IsValidRootInterface() )
        {
        ChildCtxt.SetAncestorBits( IN_ROOT_CLASS );
        IsIUnknown = TRUE;
        }

    if ( IsObject && !pBaseIntf && !IsIUnknown && !MyContext.AnyAncestorBits(IN_LIBRARY))
        {
        SemError( pBaseIntf, MyContext, ILLEGAL_INTERFACE_DERIVATION, NULL );
        }

    // our optimization is controlled either here or for the whole compile
    if ( IsAsyncClone() )
        {
        SetOptimizationFlags( OPTIMIZE_ALL_I2_FLAGS );
        }
    else
        {
        if ( ( pOptAttr = (node_optimize *) GetAttribute( ATTR_OPTIMIZE ) ) != 0 )
            {
            SetOptimizationFlags( pOptAttr->GetOptimizationFlags() );
            SetOptimizationLevel( pOptAttr->GetOptimizationLevel() );
            }
        else
            {
            SetOptimizationFlags( pCommand->GetOptimizationFlags() );
            SetOptimizationLevel( pCommand->GetOptimizationLevel() );
            }
        }

    if ( MyContext.FInSummary( ATTR_NOCODE ) &&
            pCommand->GenerateSStub() &&
            !pCommand->IsSwitchDefined( SWITCH_MS_EXT ) )
        {
        SemError( this, MyContext, NOCODE_WITH_SERVER_STUBS, NULL );
        }

    if ( IsPickle && pCommand->IsSwitchDefined( SWITCH_ROBUST ) )
        {
        if ( GetOptimizationFlags() & OPTIMIZE_INTERPRETER_V2 )
            {
            pCommand->GetNdrVersionControl().SetHasOicfPickling();
            }
        else
            {
            SemError(this, MyContext, ROBUST_PICKLING_NO_OICF, 0);
            }
        }

    BOOL HasCommFault = MyContext.FInSummary( ATTR_COMMSTAT )
                        || MyContext.FInSummary( ATTR_FAULTSTAT );

    if ( HasCommFault )
        {
        if ( ! ( GetOptimizationFlags() & OPTIMIZE_INTERPRETER_V2 ) )
            {
            SemError( this, MyContext, COMMFAULT_PICKLING_NO_OICF, 0 );
            if ( pCommand->GetTargetSystem() == NT40 )
                SemError( this, MyContext, INVALID_FEATURE_FOR_TARGET, ":oicf pickling" );                
            }
        }

    // mark the interface as a pickle interface
    if ( IsPickle )
        SetPickleInterface();

    // default the handle type, if needed
    if ( !IsObject && !pImplicit && !pExplicit && !fAuto && !IsLocal )
        {
        if ( IsPickleInterface() )
            {
            pExplicit = new acf_attr( ATTR_EXPLICIT );
            SetAttribute( pExplicit );
            }
        else
            {
            fAuto = TRUE;
            SetAttribute( new acf_attr( ATTR_AUTO ) );
            }
        }

    // make sure no pickle w/ auto handle
    if ( IsPickleInterface() )
        {
        ChildCtxt.SetAncestorBits( IN_ENCODE_INTF );
        if ( fAuto )
            SemError( this, MyContext, ENCODE_AUTO_HANDLE, NULL );
        }

    // check for handle conflicts
    if ( ( fAuto && pImplicit ) ||
            ( fAuto && pExplicit ) ||
            ( pImplicit && pExplicit ) )
        SemError( this, MyContext, CONFLICTING_INTF_HANDLES, NULL );

    if ( pImplicit )
        {
        node_id * pID;
        node_skl * pType;
        pImplicit->ImplicitHandleDetails( &pType, &pID );
        char* szName = pType->GetNonDefSelf()->GetSymName();

        if ( pImplicit->IsHandleTypeDefined() )
            {
            if ( !pType->FInSummary( ATTR_HANDLE ) &&
                    strcmp( szName, "handle_t" ) &&
                    !pID->FInSummary( ATTR_HANDLE ) )
                {
                SemError( this, MyContext, IMPLICIT_HANDLE_NON_HANDLE, NULL );
                }
            }
        else
            {
            if ( !pID->FInSummary( ATTR_HANDLE ) )
                SemError( this, MyContext, IMPLICIT_HDL_ASSUMED_GENERIC, NULL );
            }
        }

    if ( fAuto )
        {
        ChildCtxt.SetAncestorBits( HAS_AUTO_HANDLE );
        }
    else if ( pExplicit )
        {
        ChildCtxt.SetAncestorBits( HAS_EXPLICIT_HANDLE );
        }
    else if ( pImplicit )
        {
        ChildCtxt.SetAncestorBits( HAS_IMPLICIT_HANDLE );
        }

    // check for illegal type attributes
    node_type_attr * pTA;
    BOOL fIsDual = FALSE;
    while ( ( pTA = (node_type_attr *)MyContext.ExtractAttribute(ATTR_TYPE) ) != 0 )
        {
        switch (pTA->GetAttr())
            {
                // acceptable attributes
            case TATTR_DUAL:
                fIsDual = TRUE;
                // fall through
            case TATTR_OLEAUTOMATION:
                HasOLEAutomation(TRUE);
                break;
            case TATTR_PROXY:
            case TATTR_PUBLIC:
            case TATTR_NONEXTENSIBLE:
                break;
                // unacceptable attributes
            case TATTR_CONTROL:
            case TATTR_LICENSED:
                {
                char * pAttrName = pTA->GetNodeNameString();
                SemError( this, MyContext, NEWLYFOUND_INAPPLICABLE_ATTRIBUTE, pAttrName);
                break;
                }
            
            case TATTR_APPOBJECT:
            case TATTR_NONCREATABLE:
            case TATTR_AGGREGATABLE:
                {
                char * pAttrName = pTA->GetNodeNameString();
                SemError( this, MyContext, INAPPLICABLE_ATTRIBUTE, pAttrName);
                break;
                }

            }
        }

    if (HasOLEAutomation())
        {
        node_interface* pUltimate           = 0;
        node_interface* pIntf               = this;
        STATUS_T        ErrorCode           = NOT_OLEAUTOMATION_INTERFACE;

        while ( pIntf )
            {
            pUltimate = pIntf;
            pIntf = pIntf->GetMyBaseInterface();

            if ( !pUltimate->IsValidRootInterface() )
            {
            // pUltimate is not IUnknown. If it is not a IDispatch either, it is not
            // an oleautomation compliant interface.
                char* szName = pUltimate->GetSymName();
                if ( _stricmp(szName, "IDispatch") == 0 )
                    {
                    ErrorCode = STATUS_OK;
                    break;
                    }
            }
           else
                {
                // IUnknown could be OLEAUTOMATION compatible, but not DUAL
                if ( fIsDual )
                    ErrorCode = NOT_DUAL_INTERFACE;
                else
                    ErrorCode = STATUS_OK;
                break;
                }
            }

        if ( ErrorCode != STATUS_OK )
            SemError( this, MyContext, ErrorCode, GetSymName() );
            
        ChildCtxt.SetAncestorBits( HAS_OLEAUTOMATION );
        }

    // check for illegal member attributes
    node_member_attr * pMA;
    while ( ( pMA = (node_member_attr *)MyContext.ExtractAttribute(ATTR_MEMBER) ) != 0 )
        {
        switch (pMA->GetAttr())
            {
            case MATTR_RESTRICTED:
                break;
            case MATTR_DEFAULTVTABLE:
            case MATTR_SOURCE:
                {
                if ( MyContext.AnyAncestorBits( IN_COCLASS ) )
                    // [source] and [defaultvtable] are only allowed on
                    // interface's defined as members of coclasses.
                    break;
                // illegal attribute, so fall through
                }
            case MATTR_READONLY:
                {
                char * pAttrName = pMA->GetNodeNameString();
                SemError( this, MyContext, NEWLYFOUND_INAPPLICABLE_ATTRIBUTE, pAttrName);
                break;
                }
            case MATTR_BINDABLE:
            case MATTR_DISPLAYBIND:
            case MATTR_DEFAULTBIND:
            case MATTR_REQUESTEDIT:
            case MATTR_PROPGET:
            case MATTR_PROPPUT:
            case MATTR_PROPPUTREF:
            case MATTR_OPTIONAL:
            case MATTR_RETVAL:
            case MATTR_VARARG:
            case MATTR_PREDECLID:
            case MATTR_UIDEFAULT:
            case MATTR_NONBROWSABLE:
            case MATTR_DEFAULTCOLLELEM:
            case MATTR_IMMEDIATEBIND:
            case MATTR_USESGETLASTERROR:
            case MATTR_REPLACEABLE:
                {
                char * pAttrName = pMA->GetNodeNameString();
                SemError( this, MyContext, INAPPLICABLE_ATTRIBUTE, pAttrName);
                break;
                }
            }
        }

    node_base_attr* pAttrAsync = MyContext.ExtractAttribute( ATTR_ASYNC );
    if ( pAttrAsync )
        {
        if ( !pAttrAsync->IsAcfAttr() )
            {
            SemError( this, MyContext, INAPPLICABLE_ATTRIBUTE, 0);
            }
        if ( fCode || fNoCode || IsLocal || pOptAttr || IsObject || HasOLEAutomation() )
            {
            SemError( this, MyContext, ILLEGAL_COMBINATION_OF_ATTRIBUTES, 0 );
            }
        ChildCtxt.SetAncestorBits( HAS_ASYNCHANDLE );
        }

    pCSTagAttr = ( node_cs_tag_rtn *) MyContext.ExtractAttribute( ATTR_CSTAGRTN );

    ////////////////////////////////////////////////////////////////////////
    // process all the children of the interface
    //
    while ( ( pN = MemList.GetNext() ) != 0 )
        {
        pN->SemanticAnalysis( &ChildCtxt );

        // Set the cs tag routine for the proc if it needs one and doesn't
        // have one yet

        if ( NODE_PROC == pN->NodeKind() )
            {
            node_proc *pProc = ( node_proc * ) pN;

            if ( ChildCtxt.AnyDescendantBits( HAS_IN_CSTYPE | HAS_OUT_CSTYPE )
                 && ( NULL == pProc->GetCSTagRoutine() )
                 && ( NULL != pCSTagAttr ) )
                {
                pProc->SetCSTagRoutine( pCSTagAttr->GetCSTagRoutine() );
                }
            }
        }

    // make sure we had some rpc-able routines

    if ( IsObject )
        {
        //UUID must be specified on object procs.
        if( !HasGuid )
            {
            SemError( this, MyContext, NO_UUID_SPECIFIED, NULL );
            }
        }
    else if( MyContext.AnyAncestorBits( IN_INTERFACE ) &&
            pCommand->GenerateStubs() &&
            !IsLocal )
        {
        if ( ProcCount == 0 )
            {
            if ( !IsPickleInterface() &&
                    !IsObject )
                {
                if (CallBackProcCount == 0 )
                    {
                    SemError( this, MyContext, NO_REMOTE_PROCS_NO_STUBS, NULL );
                    }
                else
                    {
                    SemError( this, MyContext, INTERFACE_ONLY_CALLBACKS, NULL );
                    }
                }
            }
        else
            {
            //UUID must be specified when interface has remote procs.
            if( !HasGuid )
                {
                SemError( this, MyContext, NO_UUID_SPECIFIED, NULL );
                }
            }
        }

    if (pExplicit && MyContext.AnyAncestorBits( IN_LIBRARY ))
        {
        SemError(this, MyContext, INAPPLICABLE_ATTRIBUTE, NULL);
        }

    if (fCode && fNoCode)
        {
        SemError(this, MyContext, CODE_NOCODE_CONFLICT, NULL);
        }

    if ( IsObject )
        {
        unsigned short uProcCount = GetProcCount();
        
        if ( GetFileNode() && GetFileNode()->GetImportLevel() > 0 )
            {
            if ( uProcCount > 64 && uProcCount <= 256 )
                {
                pCommand->GetNdrVersionControl().SetHasMoreThan64DelegatedProcs();
                }
            else if ( uProcCount > 256 )
                {
                SemError(this, MyContext, TOO_MANY_DELEGATED_PROCS, NULL);
                }
            }

        // method limits apply only to stubless proxies. /Oicf not /Oi or /Os
        /*
            < 32        Windows NT 3.51-
            32 - 110    Windows NT 4.0
            110 - 512   Windows NT 4.0 SP3
            > 512       Windows 2000
        */
        unsigned short uOpt = GetOptimizationFlags();
        if ( GetFileNode() && GetFileNode()->GetImportLevel() == 0 && ( uOpt & OPTIMIZE_STUBLESS_CLIENT ) )
            {
            if ( (uProcCount > 512) && MyContext.AnyAncestorBits(IN_LIBRARY))
                {
                SemError(this, MyContext, TOO_MANY_PROCS, 0);
                pCommand->GetNdrVersionControl().SetHasNT5VTableSize();
                }
            else if ( (uProcCount > 110) && (uProcCount <= 512) && MyContext.AnyAncestorBits(IN_LIBRARY))
                {
                SemError(this, MyContext, TOO_MANY_PROCS_FOR_NT4, 0);
                pCommand->GetNdrVersionControl().SetHasNT43VTableSize();
                }
            else if ( uProcCount > 32 && uProcCount <= 110 )
                {
                pCommand->GetNdrVersionControl().SetHasNT4VTableSize();
                }
            }
        }

    if ( GetAsyncInterface() && fAnalizeAsyncIf )
        {
        GetAsyncInterface()->SemanticAnalysis( pParentCtxt );
        }

    MyContext.ReturnValues(ChildCtxt);
    // consume all the interface attributes
    MyContext.ClearAttributes();
    pParentCtxt->ReturnValues( MyContext );
}

// a reference to an interface...
//Check for ms_ext mode.
//Check if the interface has the [object] attribute
//if used in an RPC, the parent must be a pointer.
void
node_interface_reference::SemanticAnalysis( SEM_ANALYSIS_CTXT * pParentCtxt )
{
    SEM_ANALYSIS_CTXT MyContext( this, pParentCtxt );

    CheckDeclspecAlign( MyContext );

    // see if we are detecting class dependencies
    if ( MyContext.AnyAncestorBits( IN_BASE_CLASS ) )
        {
        if ( !GetRealInterface()->FInSummary( ATTR_OBJECT ) && !MyContext.AnyAncestorBits(IN_LIBRARY))
            {
            SemError( this, MyContext, ILLEGAL_INTERFACE_DERIVATION, NULL );
            }

        // fetch my interface's BaseInteraceReference
        named_node * pBaseClass = GetMyBaseInterfaceReference();
        if ( pBaseClass )
            {
            if ( MyContext.FindRecursiveContext( pBaseClass ) )
                SemError( this, MyContext, CIRCULAR_INTERFACE_DEPENDENCY, NULL);
            else
                {
                // make sure our base class got analyzed
                SEM_ANALYSIS_CTXT BaseContext( this, &MyContext );

                BaseContext.ClearAncestorBits( IN_BASE_CLASS | IN_INTERFACE );
                BaseContext.SetInterfaceContext( &BaseContext );
                GetRealInterface()->SemanticAnalysis( &BaseContext );

                pBaseClass->SemanticAnalysis( &MyContext );
                }
            }
        else    // root base class
            {
            if ( !GetRealInterface()->IsValidRootInterface() && !MyContext.AnyAncestorBits(IN_LIBRARY))
                SemError( this, MyContext, NOT_VALID_AS_BASE_INTF, NULL );
            }
        }

    else if ( ( pParentCtxt->GetParent()->NodeKind() == NODE_FORWARD ) &&
            ( pParentCtxt->GetParentContext()->GetParent()->IsInterfaceOrObject() ) )
        {
        // we are an interface forward decl
        }
    else    // we are at an interface pointer
        {
        node_interface * pIntf = GetRealInterface();

        if ( !MyContext.AnyAncestorBits( IN_POINTER ) && !MyContext.AnyAncestorBits( IN_LIBRARY ))
            {
            SemError( this, MyContext, INTF_NON_POINTER, NULL );
            }

        if ( !pIntf->FInSummary( ATTR_GUID ) )
            {
            SemError( this, MyContext, PTR_INTF_NO_GUID, NULL );
            }

        MyContext.SetDescendantBits( HAS_INTERFACE_PTR );

        }

    pParentCtxt->ReturnValues( MyContext );
    return;
};

void
node_source::SemanticAnalysis( SEM_ANALYSIS_CTXT * pParentCtxt )
{
    MEM_ITER MemIter( this );
    node_skl * pN;
    SEM_ANALYSIS_CTXT MyContext( this, pParentCtxt );

    while ( ( pN = MemIter.GetNext() ) != 0 )
        {
        pN->SemanticAnalysis( &MyContext );
        }

    pParentCtxt->ReturnValues( MyContext );
};

void
node_pointer::SemanticAnalysis( SEM_ANALYSIS_CTXT * pParentCtxt )
{
    SEM_ANALYSIS_CTXT MyContext( this, pParentCtxt );
    PTRTYPE           PtrKind = PTR_UNKNOWN;
    FIELD_ATTR_INFO   FAInfo;
    node_ptr_attr *   pPAttr;                 // pointer attribute
    node_byte_count * pCountAttr;
    node_allocate *   pAlloc;

    BOOL fInterfacePtr = FALSE;
    BOOL fUnderAPtr = MyContext.AnyAncestorBits( IN_POINTER | IN_ARRAY );
    BOOL fIgnore;
    BOOL fIsSizedPtr = FALSE;

    if ( (GetChild()->NodeKind() == NODE_INTERFACE_REFERENCE ) ||
          (GetChild()->NodeKind() == NODE_FORWARD &&
            GetChild()->GetChild() &&
            GetChild()->GetChild()->NodeKind() == NODE_INTERFACE_REFERENCE ) )
            fInterfacePtr = TRUE;

    // see if we have allocate
    pAlloc = (node_allocate *) MyContext.ExtractAttribute( ATTR_ALLOCATE );

    if ( HasCorrelation( this ) )
        {
        MyContext.IncCorrelationCount();
        }

    CheckDeclspecAlign( MyContext );

    ////////////////////////////////////////////////////////////////////////
    // process pointer attributes

    BOOL fExplicitPtrAttr = FALSE;

    PtrKind = MyContext.GetPtrKind( &fExplicitPtrAttr );

    if ( PtrKind == PTR_FULL )
        {
        MyContext.SetDescendantBits( HAS_FULL_PTR );
        }

    if ( ( pPAttr = (node_ptr_attr *)MyContext.ExtractAttribute( ATTR_PTR_KIND) ) != 0 )
        {
        TypeSemError( this, MyContext, MORE_THAN_ONE_PTR_ATTR, NULL );
        }

    if ( MyContext.AnyAncestorBits( UNDER_PARTIAL_IGNORE_PARAM )  &&
         ( PtrKind != PTR_UNIQUE ) )
        {
        TypeSemError( this, MyContext, PARTIAL_IGNORE_UNIQUE, NULL );
        }
    MyContext.ClearAncestorBits( UNDER_PARTIAL_IGNORE_PARAM );

    // mark this pointer as ref or non-ref.  This flag is only valid for the
    // pointer nodes themselves.
    if ( PtrKind == PTR_REF )
        MyContext.ClearAncestorBits( IN_NON_REF_PTR );
    else
        MyContext.SetAncestorBits( IN_NON_REF_PTR );

    // detect top level ref pointer on return type
    if ( ( PtrKind == PTR_REF ) &&
            MyContext.AllAncestorBits( IN_RPC | IN_FUNCTION_RESULT ) )
        {
        if (MyContext.FindNonDefAncestorContext()->GetParent()->NodeKind()
                == NODE_PROC )
            TypeSemError( this, MyContext, BAD_CON_REF_RT, NULL );
        }

    // unique or full pointer may not be out only
    if ( ( PtrKind != PTR_REF ) &&
            MyContext.AllAncestorBits( IN_RPC | IN_PARAM_LIST ) &&
            !fUnderAPtr &&
            !MyContext.AnyAncestorBits( UNDER_IN_PARAM |
            IN_STRUCT | IN_UNION ))
        TypeSemError( this, MyContext, UNIQUE_FULL_PTR_OUT_ONLY, NULL );

    MyContext.SetAncestorBits( IN_POINTER );

    // warn about OUT const things
    if ( FInSummary( ATTR_CONST ) )
        {
        if ( MyContext.AnyAncestorBits( UNDER_OUT_PARAM ) )
            RpcSemError( this, MyContext, CONST_ON_OUT_PARAM, NULL );
        else if ( MyContext.AnyAncestorBits( IN_FUNCTION_RESULT ) )
            RpcSemError( this, MyContext, CONST_ON_RETVAL, NULL );
        }

    // ignore pointers do not need to be rpc-able
    fIgnore = (NULL != MyContext.ExtractAttribute( ATTR_IGNORE ));
    if ( fIgnore )
        {
        MyContext.ClearAncestorBits( IN_RPC );
        }

    ////////////////////////////////////////////////////////////////////////
    // process field attributes

    // see if we have any field attributes (are conformant or varying)
    FAInfo.SetControl( TRUE, GetBasicType()->IsPtrOrArray() );
    MyContext.ExtractFieldAttributes( &FAInfo );
    FAInfo.Validate( &MyContext );    

    // ptr is conf or varying or conf/varying
    if ( FAInfo.Kind & FA_CONFORMANT_VARYING )
        {
        fIsSizedPtr = TRUE;
        }

    switch ( FAInfo.Kind )
        {
        case FA_NONE:
            {
            break;
            }
        case FA_STRING:
            {
            // string attributes only allowed on char and wchar_t
            if ( !GetBasicType()->IsStringableType() )
                TypeSemError( this, MyContext, STRING_NOT_ON_BYTE_CHAR, NULL );

            if ( MyContext.AllAncestorBits( UNDER_OUT_PARAM |
                    IN_PARAM_LIST | IN_RPC ) &&
                    !fUnderAPtr &&
                    !MyContext.AnyAncestorBits( IN_STRUCT | IN_UNION |
                    UNDER_IN_PARAM ) )
                TypeSemError( this, MyContext, DERIVES_FROM_UNSIZED_STRING, NULL );

            MyContext.SetDescendantBits( HAS_STRING );
            // break;  deliberate fall through to case below
            }
        case FA_VARYING:
            {
            MyContext.SetDescendantBits( HAS_VAR_PTR );
            break;
            }
        case FA_CONFORMANT:
            {
            MyContext.SetDescendantBits( HAS_CONF_PTR );
            break;
            }
        case FA_CONFORMANT_STRING:
            {
            // string attributes only allowed on char and wchar_t
            if ( !GetBasicType()->IsStringableType() )
                TypeSemError( this, MyContext, STRING_NOT_ON_BYTE_CHAR, NULL );
            if ( FAInfo.StringKind == STR_BSTRING )
                TypeSemError( this, MyContext, BSTRING_NOT_ON_PLAIN_PTR, NULL );
            // break;  deliberate fall through to case below
            }
        case FA_CONFORMANT_VARYING:
            {
            MyContext.SetDescendantBits( HAS_CONF_VAR_PTR );
            break;
            }
        case FA_INTERFACE:
            {
            if ( !fInterfacePtr && (GetBasicType()->NodeKind() != NODE_VOID ) )
                {
                TypeSemError( this, MyContext, IID_IS_NON_POINTER, NULL );
                }
            fInterfacePtr = TRUE;
            break;
            }
        default:        // string + varying combinations
            {
            TypeSemError( this, MyContext, INVALID_SIZE_ATTR_ON_STRING, NULL );
            break;
            }
        }
    // tell our children we are constructing an interface pointer
    if (fInterfacePtr)
        MyContext.SetAncestorBits( IN_INTERFACE_PTR );

    // interface pointer shouldn't have explicit pointer attributes

    if ( fInterfacePtr  &&  fExplicitPtrAttr  &&
         (PtrKind == PTR_FULL || PtrKind == PTR_REF ) )
        {
        TypeSemError( this, MyContext, INTF_EXPLICIT_PTR_ATTR, NULL );
        }

    // Non pipe [out] interface pointers must use double indirection.
    // However, pipe interface pointers can use only a single indirection.
    // Note that fInterfacePtr may be true for a void *.

    if (  fInterfacePtr  &&  MyContext.AnyAncestorBits( UNDER_OUT_PARAM )  &&
          !fUnderAPtr )
        {
        if ( GetChild()->NodeKind() == NODE_INTERFACE_REFERENCE )
            TypeSemError( this, MyContext, NON_INTF_PTR_PTR_OUT, NULL );
        }

    if ( MyContext.FInSummary( ATTR_SWITCH_IS ) &&
            ( FAInfo.Kind != FA_NONE) )
        TypeSemError( this, MyContext, ARRAY_OF_UNIONS_ILLEGAL, NULL );

    // see if a param or return type context attr reached us...
    bool fSerialize = MyContext.ExtractAttribute( ATTR_SERIALIZE ) != 0;
    bool fNoSerialize = MyContext.ExtractAttribute( ATTR_NOSERIALIZE ) != 0;
    if ( MyContext.FInSummary( ATTR_CONTEXT ) )
        {
        if (GetBasicType()->NodeKind() != NODE_POINTER )
            {
            if ( fSerialize && fNoSerialize )
                {
                SemError( this, MyContext, CONFLICTING_ATTRIBUTES, GetSymName() );
                }
            MyContext.ExtractAttribute( ATTR_CONTEXT );
            MyContext.SetDescendantBits( HAS_HANDLE | HAS_CONTEXT_HANDLE );
            pParentCtxt->SetDescendantBits( HAS_HANDLE | HAS_CONTEXT_HANDLE );
            MyContext.ClearAncestorBits( IN_RPC );
            if (GetBasicType()->NodeKind() != NODE_VOID )
                {
                TypeSemError( this, MyContext, CONTEXT_HANDLE_VOID_PTR, NULL );
                }
            }
        }
    else
        {
        if ( fSerialize || fNoSerialize )
            {
            SemError( this, MyContext, NO_CONTEXT_HANDLE, GetSymName() );
            }
        }


    // see if a byte_count reached us...
    pCountAttr = (node_byte_count *)
        MyContext.ExtractAttribute( ATTR_BYTE_COUNT );

    if (pCountAttr)
        {
        // byte count error checking
        
        if ( pCommand->NeedsNDR64Run() )
            TypeSemError( this, MyContext, BYTE_COUNT_IN_NDR64, 0 );

        node_param * pParam  = pCountAttr->GetByteCountParam();

        if ( !MyContext.AnyAncestorBits( UNDER_OUT_PARAM ) ||
                        MyContext.AnyAncestorBits( UNDER_IN_PARAM ) )
            {
            TypeSemError( this, MyContext, BYTE_COUNT_NOT_OUT_PTR, 0 );
            }

        if ( !pParam || !pParam->FInSummary( ATTR_IN ) || pParam->FInSummary( ATTR_OUT ) )
            TypeSemError( this, MyContext, BYTE_COUNT_PARAM_NOT_IN, 0 );

        if ( pParam )
            {
            NODE_T nodeKind = pParam->GetBasicType()->NodeKind();
            if ( nodeKind < NODE_HYPER || nodeKind > NODE_BYTE )
                {
                SemError( this, MyContext, BYTE_COUNT_PARAM_NOT_INTEGRAL, 0 );
                }
            }

        if ( !pCommand->IsSwitchDefined( SWITCH_MS_EXT ) )
            {
            SemError( this, MyContext, BYTE_COUNT_INVALID, 0 );
            }

        if ( MyContext.AnyDescendantBits( HAS_CONF_VAR_PTR | HAS_VAR_PTR | HAS_CONF_PTR ) )
            {
            SemError( this, MyContext, BYTE_COUNT_INVALID, 0 );
            }
        }

    if ( PtrKind == PTR_REF )
        {
        SEM_ANALYSIS_CTXT * pCtxt = (SEM_ANALYSIS_CTXT *)
            MyContext.FindNonDefAncestorContext();
        if ( ( pCtxt->GetParent()->NodeKind() == NODE_FIELD ) &&
                ( pCtxt->GetParentContext()->GetParent()->NodeKind() == NODE_UNION ) )
            TypeSemError( this, MyContext, REF_PTR_IN_UNION, NULL );
        }

    MyContext.ClearAncestorBits( IN_UNION | IN_NE_UNION | IN_ARRAY );

    ////////////////////////////////////////////////////////////////////////
    // finally, process the child

    GetChild()->SemanticAnalysis( &MyContext );

    // if the child and this node is a conf and/or varying pointer
    if ( fIsSizedPtr )
        {
        if ( MyContext.AnyDescendantBits( HAS_SIZED_PTR ) )
            {
            MyContext.SetDescendantBits( HAS_MULTIDIM_VECTOR );
            }
        else
            {
            MyContext.SetDescendantBits( HAS_SIZED_PTR );
            }
        }

    // allocate error checking
    if ( pAlloc )
        {
        if ( MyContext.AnyDescendantBits( HAS_TRANSMIT_AS | HAS_REPRESENT_AS ) )
            {
            if ( MyContext.AnyAncestorBits( IN_RPC ) )
                SemError( this, MyContext, ALLOCATE_ON_TRANSMIT_AS, NULL );
            else
                AcfError( pAlloc, this, MyContext, ALLOCATE_ON_TRANSMIT_AS, NULL );
            }

        if ( MyContext.AnyDescendantBits( HAS_HANDLE ) )
            {
            if ( MyContext.AnyAncestorBits( IN_RPC ) )
                SemError( this, MyContext, ALLOCATE_ON_HANDLE, NULL );
            else
                AcfError( pAlloc, this, MyContext, ALLOCATE_ON_HANDLE, NULL );
            }

        // warn about allocate(all_nodes) with [in,out] parameter
        if ( MyContext.AllAncestorBits( IN_RPC |
                IN_PARAM_LIST |
                UNDER_IN_PARAM |
                UNDER_OUT_PARAM ) &&
                ( pAlloc->GetAllocateDetails() & ALLOCATE_ALL_NODES ) )
            {
            SemError( this, MyContext, ALLOCATE_IN_OUT_PTR, NULL );
            }

        }

    if ( fInterfacePtr )
        MyContext.SetAncestorBits( IN_INTERFACE_PTR );

    if ( MyContext.AnyDescendantBits( HAS_CONF_ARRAY |
            HAS_CONF_VAR_ARRAY ) &&
            !MyContext.AnyDescendantBits( HAS_ARRAY |
            HAS_TRANSMIT_AS ) &&
            MyContext.AllAncestorBits( IN_RPC | UNDER_OUT_PARAM ) &&
            !MyContext.AnyAncestorBits( UNDER_IN_PARAM |
            IN_ARRAY |
            IN_STRUCT |
            IN_UNION |
            IN_TRANSMIT_AS |
            IN_REPRESENT_AS )      &&
            ( PtrKind == PTR_REF ) )
        TypeSemError( this, MyContext, DERIVES_FROM_PTR_TO_CONF, NULL );

#if 0
    if ( MyContext.AnyDescendantBits( HAS_DIRECT_CONF_OR_VAR ) )
        {
        TypeSemError( this, MyContext, ILLEGAL_CONFORMANT_ARRAY, NULL );
        }
#endif

    // incomplete types are OK below a pointer
    // array characteristics blocked by pointer
    MyContext.ClearDescendantBits( HAS_INCOMPLETE_TYPE
        | HAS_RECURSIVE_DEF
        | HAS_ARRAY
        | HAS_VAR_ARRAY
        | HAS_CONF_ARRAY
        | HAS_CONF_VAR_ARRAY
        | HAS_MULTIDIM_SIZING
        | HAS_UNION
        | HAS_STRUCT
        | HAS_TRANSMIT_AS
        | HAS_REPRESENT_AS
        | HAS_UNSAT_REP_AS
        | HAS_DIRECT_CONF_OR_VAR
        | HAS_ENUM
        | HAS_ARRAY_OF_REF
        | HAS_CONTEXT_HANDLE
        | HAS_HRESULT );

    if ( !fInterfacePtr && !fIgnore )
        MyContext.SetDescendantBits( HAS_POINTER );

    if ( ( FAInfo.Kind != FA_NONE ) &&
            ( FAInfo.Kind != FA_STRING ) &&
            ( FAInfo.Kind != FA_INTERFACE ) )
        MyContext.SetDescendantBits( HAS_DIRECT_CONF_OR_VAR );

    if ( ( PtrKind == PTR_REF ) &&
            ( MyContext.FindNonDefAncestorContext()
            ->GetParent()->NodeKind() == NODE_ARRAY ) )
        {
        MyContext.SetDescendantBits( HAS_ARRAY_OF_REF );
        }

#ifdef gajgaj
    if ( (PtrKind != PTR_REF ) &&
            MyContext.AnyDescendantBits( HAS_HANDLE ) &&
            MyContext.AnyAncestorBits( IN_RPC ) )
        TypeSemError( this, MyContext, PTR_TO_HDL_UNIQUE_OR_FULL, NULL );
#endif //gajgaj

    if ( MyContext.AnyDescendantBits( HAS_IN_CSTYPE | HAS_OUT_CSTYPE ) )
        {
        if ( !FAInfo.VerifyOnlySimpleExpression() )
            SemError( this, MyContext, CSCHAR_EXPR_MUST_BE_SIMPLE, NULL );

        if ( FA_CONFORMANT == FAInfo.Kind )
            SemError( this, MyContext, NO_CONFORMANT_CSCHAR, NULL );

        if ( MyContext.AnyDescendantBits( HAS_MULTIDIM_SIZING
                                            | HAS_MULTIDIM_VECTOR ) )
            {
            SemError( this, MyContext, NO_MULTIDIM_CSCHAR, NULL );
            }

        // We want to propagate the the descendant bits up so that the proc
        // and interface know the cs stuff is around but we only want to set
        // the "this is a cs array" flag if it's actually a cs array

        if ( GetChild()->FInSummary( ATTR_CSCHAR ) )
            SetHasCSType();
        }

    SIZE_LENGTH_USAGE usage;

    if ( HasCSType() )
        usage = CSSizeLengthUsage;            
    else
        usage = NonCSSizeLengthUsage;

    if ( ! FAInfo.SetExpressionVariableUsage( usage ) )
        SemError( this, MyContext, SHARED_CSCHAR_EXPR_VAR, NULL );

    pParentCtxt->ReturnValues( MyContext );
}

void
node_array::SemanticAnalysis( SEM_ANALYSIS_CTXT * pParentCtxt )
{
    SEM_ANALYSIS_CTXT MyContext( this, pParentCtxt );
    FIELD_ATTR_INFO FAInfo;
    PTRTYPE PtrKind = PTR_UNKNOWN;
    BOOL fArrayParent = MyContext.AnyAncestorBits( IN_ARRAY );

    if ( HasCorrelation( this ) )
        {
        MyContext.IncCorrelationCount();
        }

    CheckDeclspecAlign( MyContext );

    // See if context_handle applied to param reached us
    if ( CheckContextHandle( MyContext ) )
        {
        MyContext.SetDescendantBits( HAS_HANDLE | HAS_CONTEXT_HANDLE );
        }

    if ( MyContext.FInSummary( ATTR_SWITCH_IS ) )
        TypeSemError( this, MyContext, ARRAY_OF_UNIONS_ILLEGAL, NULL );

    ////////////////////////////////////////////////////////////////////////
    // process pointer attributes

    PtrKind = MyContext.GetPtrKind();

    MIDL_ASSERT( PtrKind != PTR_UNKNOWN );

    if ( PtrKind == PTR_FULL )
        {
        MyContext.SetDescendantBits( HAS_FULL_PTR );
        }

    if ( MyContext.ExtractAttribute( ATTR_PTR_KIND) )
        TypeSemError( this, MyContext, MORE_THAN_ONE_PTR_ATTR, NULL );

    // ref pointer may not be returned
    if ( ( PtrKind == PTR_REF ) &&
            MyContext.AllAncestorBits( IN_RPC | IN_FUNCTION_RESULT ) )
        {
        if (MyContext.FindNonDefAncestorContext()->GetParent()->NodeKind()
            == NODE_PROC )
        TypeSemError( this, MyContext, BAD_CON_REF_RT, NULL );
        }

    // unique or full pointer may not be out only
    if ( ( PtrKind != PTR_REF ) &&
            MyContext.AllAncestorBits( IN_RPC | IN_PARAM_LIST ) &&
            !MyContext.AnyAncestorBits( UNDER_IN_PARAM |
            IN_STRUCT |
            IN_UNION |
            IN_ARRAY |
            IN_POINTER ) )
        TypeSemError( this, MyContext, UNIQUE_FULL_PTR_OUT_ONLY, NULL );

    MyContext.SetAncestorBits( IN_ARRAY );

    // warn about OUT const things
    if ( FInSummary( ATTR_CONST ) )
        {
        if ( MyContext.AnyAncestorBits( UNDER_OUT_PARAM ) )
            RpcSemError( this, MyContext, CONST_ON_OUT_PARAM, NULL );
        else if ( MyContext.AnyAncestorBits( IN_FUNCTION_RESULT ) )
            RpcSemError( this, MyContext, CONST_ON_RETVAL, NULL );
        }

    /////////////////////////////////////////////////////////////////////////
    // process field attributes

    FAInfo.SetControl( FALSE, GetBasicType()->IsPtrOrArray() );
    MyContext.ExtractFieldAttributes( &FAInfo );
    FAInfo.Validate( &MyContext, pLowerBound, pUpperBound );

    if (MyContext.AnyAncestorBits( IN_LIBRARY ))
    {
        if ( FA_NONE != FAInfo.Kind  && FA_CONFORMANT != FAInfo.Kind)
        {
            // only Fixed size arrays and SAFEARRAYs are allowed in Type Libraries
            SemError( this, MyContext, NOT_FIXED_ARRAY, NULL );
        }
    }

    switch ( FAInfo.Kind )
        {
        case FA_NONE:
            {
            break;
            }
        case FA_STRING:
            {
            // string attributes only allowed on char and wchar_t
            if ( !GetBasicType()->IsStringableType() )
                TypeSemError( this, MyContext, STRING_NOT_ON_BYTE_CHAR, NULL );

            if ( MyContext.AllAncestorBits( UNDER_OUT_PARAM |
                    IN_PARAM_LIST |
                    IN_RPC ) &&
                    !MyContext.AnyAncestorBits( IN_STRUCT |
                    IN_UNION |
                    IN_POINTER |
                    IN_ARRAY |
                    UNDER_IN_PARAM ) )
                TypeSemError( this, MyContext, DERIVES_FROM_UNSIZED_STRING, NULL );

            if ( FAInfo.StringKind == STR_BSTRING )
                TypeSemError( this, MyContext, BSTRING_NOT_ON_PLAIN_PTR, NULL );
            // break;  deliberate fall through to case below
            }
        case FA_VARYING:
            {
            MyContext.SetDescendantBits( HAS_VAR_ARRAY );
            break;
            }
        case FA_CONFORMANT:
            {
            MyContext.SetDescendantBits( HAS_CONF_ARRAY );
            break;
            }
        case FA_CONFORMANT_STRING:
            {
            // string attributes only allowed on char and wchar_t
            if ( !GetBasicType()->IsStringableType() )
                TypeSemError( this, MyContext, STRING_NOT_ON_BYTE_CHAR, NULL );
            if ( FAInfo.StringKind == STR_BSTRING )
                TypeSemError( this, MyContext, BSTRING_NOT_ON_PLAIN_PTR, NULL );
            MyContext.SetDescendantBits( HAS_STRING );
            // break;  deliberate fall through to case below
            }
        case FA_CONFORMANT_VARYING:
            {
            MyContext.SetDescendantBits( HAS_CONF_VAR_ARRAY );
            break;
            }
        case FA_INTERFACE:
            {
            // gaj - tbd
            break;
            }
        default:    // string + varying combinations
            {
            TypeSemError( this, MyContext, INVALID_SIZE_ATTR_ON_STRING, NULL );
            break;
            }
        }

    // detect things like arrays of conf structs...
    // if we have an array as an ancestor, and we have conformance, then complain
    if ( MyContext.AnyDescendantBits( HAS_CONF_ARRAY | HAS_CONF_VAR_ARRAY ) &&
            fArrayParent )
        {
        // see if there are any bad things between us and our parent array
        SEM_ANALYSIS_CTXT * pCtxt = (SEM_ANALYSIS_CTXT *) pParentCtxt;
        node_skl * pCur = pCtxt->GetParent();

        // check up for anything other than def below proc
        // make sure the proc only has one param
        while ( pCur->NodeKind() != NODE_ARRAY )
            {
            if ( pCur->NodeKind() != NODE_DEF )
                {
                SemError( this, MyContext, ILLEGAL_CONFORMANT_ARRAY, NULL );
                break;
                }
            pCtxt = (SEM_ANALYSIS_CTXT *) pCtxt->GetParentContext();
            pCur = pCtxt->GetParent();
            }

        }


    //////////////////////////////////////////////////////////////
    // process the array element
    GetChild()->SemanticAnalysis( &MyContext );

    if ( MyContext.AnyDescendantBits( HAS_PIPE ) )
        {
        SemError( this, MyContext, INVALID_ARRAY_ELEMENT, 0 );
        }

    BOOL IsMultiDim = MyContext.AnyDescendantBits( HAS_ARRAY );

    if ( MyContext.AnyDescendantBits( HAS_ARRAY ) &&
            MyContext.AnyDescendantBits( HAS_CONF_ARRAY |
            HAS_CONF_VAR_ARRAY |
            HAS_VAR_ARRAY ) )
        {
        MyContext.SetDescendantBits( HAS_MULTIDIM_SIZING );
        MyContext.SetDescendantBits( HAS_MULTIDIM_VECTOR );
        }

    MyContext.SetDescendantBits( HAS_ARRAY );

    MIDL_ASSERT( GetNonDefChild != NULL );
    if ( NODE_POINTER == GetNonDefChild()->NodeKind() )
        MyContext.SetDescendantBits( HAS_ARRAYOFPOINTERS );

    // disallow forward references as array elements
    if ( MyContext.AnyDescendantBits( HAS_INCOMPLETE_TYPE ) )
        {
        if (! MyContext.AnyAncestorBits( IN_LIBRARY ))
            SemError( this, MyContext, UNDEFINED_SYMBOL, NULL );
        MyContext.ClearDescendantBits( HAS_INCOMPLETE_TYPE );
        }
    MyContext.ClearDescendantBits( HAS_RECURSIVE_DEF );

    if ( MyContext.AllDescendantBits( HAS_DIRECT_CONF_OR_VAR |
            HAS_MULTIDIM_SIZING ) &&
            MyContext.AnyDescendantBits( HAS_CONF_ARRAY | HAS_CONF_VAR_ARRAY ) &&
            ( GetChild()->NodeKind() == NODE_DEF ) )
        {
        SemError( this, MyContext, NON_ANSI_MULTI_CONF_ARRAY, NULL );
        }

    MyContext.ClearDescendantBits( HAS_DIRECT_CONF_OR_VAR );
    if ( ( FAInfo.Kind != FA_NONE ) &&
            ( FAInfo.Kind != FA_STRING ) &&
            ( FAInfo.Kind != FA_INTERFACE ) )
        MyContext.SetDescendantBits( HAS_DIRECT_CONF_OR_VAR );

    if ( MyContext.AnyDescendantBits( HAS_POINTER ) )
        fHasPointer = TRUE;

    if ( MyContext.AnyDescendantBits( HAS_HANDLE ) )
        TypeSemError( this, MyContext, BAD_CON_CTXT_HDL_ARRAY, NULL );

    // don't allow functions as elements
    if ( MyContext.AnyDescendantBits( HAS_FUNC ) &&
            MyContext.AllAncestorBits( IN_INTERFACE | IN_RPC ) )
        TypeSemError( this, MyContext, BAD_CON_ARRAY_FUNC, NULL );

    if ( MyContext.AnyDescendantBits( HAS_IN_CSTYPE | HAS_OUT_CSTYPE ) )
        {
        if ( FA_CONFORMANT == FAInfo.Kind )
            SemError( this, MyContext, NO_CONFORMANT_CSCHAR, NULL );

        if ( IsMultiDim )
            SemError( this, MyContext, NO_MULTIDIM_CSCHAR, NULL );

        SetHasCSType();
        }

    SIZE_LENGTH_USAGE usage;

    if ( HasCSType() )
        usage = CSSizeLengthUsage;            
    else
        usage = NonCSSizeLengthUsage;

    if ( ! FAInfo.SetExpressionVariableUsage( usage ) )
        SemError( this, MyContext, SHARED_CSCHAR_EXPR_VAR, NULL );

    MyContext.ClearDescendantBits( HAS_STRUCT );

    pParentCtxt->ReturnValues( MyContext );
}

void
node_echo_string::SemanticAnalysis( SEM_ANALYSIS_CTXT * pParentCtxt )
{
    SEM_ANALYSIS_CTXT MyContext( this, pParentCtxt );

    pParentCtxt->ReturnValues( MyContext );
};

void
node_e_status_t::VerifyParamUsage( SEM_ANALYSIS_CTXT * pCtxt )
{
    // verify that we are under an OUT-only pointer
    // or a "hidden" status parameter (only specified in the acf file)

    if ( pCtxt->AnyAncestorBits( UNDER_IN_PARAM ) ||
            !pCtxt->AnyAncestorBits( UNDER_OUT_PARAM ) )
        {
        if ( !pCtxt->AnyAncestorBits( UNDER_HIDDEN_STATUS ) )
            {
            TypeSemError( this, *pCtxt, E_STAT_T_MUST_BE_PTR_TO_E, NULL );
            return;
            }
        }

    SEM_ANALYSIS_CTXT * pCurCtxt = (SEM_ANALYSIS_CTXT *)pCtxt->GetParentContext();
    node_skl * pPar = pCurCtxt->GetParent();
    unsigned short PtrSeen = 0;
    NODE_T Kind;

    while ( ( Kind = pPar->NodeKind() ) != NODE_PARAM )
        {
        switch ( Kind )
            {
            case NODE_POINTER:      // count pointers (must see just 1 )
                PtrSeen++;
                break;
            case NODE_DEF:          // skip DEF nodes
            case NODE_E_STATUS_T:   // and the error_status_t node
                break;
            default:                // error on anything else
                TypeSemError( this, *pCtxt, E_STAT_T_MUST_BE_PTR_TO_E, NULL );
                return;
            }
        // advance up the stack
        pCurCtxt = (SEM_ANALYSIS_CTXT *) pCurCtxt->GetParentContext();
        pPar = pCurCtxt->GetParent();
        }

    // complain about wrong number of pointers
    if ( PtrSeen != 1 )
        TypeSemError( this, *pCtxt, E_STAT_T_MUST_BE_PTR_TO_E, NULL );

}

void
node_e_status_t::SemanticAnalysis( SEM_ANALYSIS_CTXT * pParentCtxt )
{

    SEM_ANALYSIS_CTXT MyContext( this, pParentCtxt );
    BOOL fFaultstat = (NULL != MyContext.ExtractAttribute( ATTR_FAULTSTAT ));
    BOOL fCommstat = (NULL != MyContext.ExtractAttribute( ATTR_COMMSTAT ));

    MyContext.SetDescendantBits( HAS_E_STAT_T );

    CheckDeclspecAlign( MyContext );

    // an error status_t can only be:
    //      1: a parameter return type, or
    //      2: an [out] only pointer parameter
    // and it must have at least one of [comm_status] or
    // [fault_status] applied

    // make sure parameter is an OUT-only pointer if it has comm/fault_status
    if ( fFaultstat || fCommstat )
        {
        if ( MyContext.AnyAncestorBits( IN_RPC ) )
            {
            // A proc in an actual remote interface.
            // Then it must be an appropriate parameter
            if ( MyContext.AnyAncestorBits( IN_PARAM_LIST ) )
                {
                VerifyParamUsage( &MyContext );
                }
            // or on a return type.
            else if ( !MyContext.AnyAncestorBits( IN_FUNCTION_RESULT ) )
                {
                TypeSemError( this, MyContext, E_STAT_T_MUST_BE_PTR_TO_E , NULL );
                }
            }

        if ( MyContext.AnyAncestorBits( IN_ARRAY ) )
            TypeSemError( this, MyContext, E_STAT_T_ARRAY_ELEMENT, NULL );

        if ( MyContext.AnyAncestorBits( IN_TRANSMIT_AS | IN_REPRESENT_AS ) )
            TypeSemError( this, MyContext, TRANSMIT_AS_ON_E_STAT_T, NULL );

        if ( MyContext.AnyAncestorBits( IN_STRUCT | IN_UNION ) )
            TypeSemError( this, MyContext, BAD_CON_E_STAT_T_FIELD, NULL );

        if ( MyContext.AnyAncestorBits( IN_USER_MARSHAL ) )
            TypeSemError( this, MyContext, TRANSMIT_AS_ON_E_STAT_T, NULL );
        }

    MyContext.RejectAttributes();

    pParentCtxt->ReturnValues( MyContext );

};

void
node_error::SemanticAnalysis( SEM_ANALYSIS_CTXT * pParentCtxt )
{
    SEM_ANALYSIS_CTXT MyContext( this, pParentCtxt );

    MyContext.RejectAttributes();
        
    CheckDeclspecAlign( MyContext );

    pParentCtxt->ReturnValues( MyContext );
};

void
node_wchar_t::SemanticAnalysis( SEM_ANALYSIS_CTXT * pParentCtxt )
{
    SEM_ANALYSIS_CTXT MyContext( this, pParentCtxt );
        
    CheckDeclspecAlign( MyContext );

    TypeSemError( this, MyContext, WCHAR_T_INVALID_OSF, NULL );

    if ( MyContext.AllAncestorBits( IN_PARAM_LIST | IN_RPC ) )
        SemError( this, MyContext, WCHAR_T_NEEDS_MS_EXT_TO_RPC, NULL );

    MyContext.RejectAttributes();

    pParentCtxt->ReturnValues( MyContext );
};

void
node_library::SemanticAnalysis( SEM_ANALYSIS_CTXT * pParentCtxt)
{
    MEM_ITER MemIter(this);
    SEM_ANALYSIS_CTXT MyContext(this, pParentCtxt);

    BOOL HasGuid = MyContext.FInSummary( ATTR_GUID );

    MyContext.ExtractAttribute(ATTR_HELPSTRING);
    MyContext.ExtractAttribute(ATTR_HELPCONTEXT);
    MyContext.ExtractAttribute(ATTR_HELPSTRINGCONTEXT);
    MyContext.ExtractAttribute(ATTR_HELPSTRINGDLL);

    gfCaseSensitive=FALSE;

    // check for illegal attributes
    node_member_attr * pMA;
    while ( ( pMA = (node_member_attr *)MyContext.ExtractAttribute(ATTR_MEMBER) ) != 0 )
        {
        switch (pMA->GetAttr())
            {
            // acceptable attributes
            case MATTR_RESTRICTED:
                break;
            // unacceptable attributes
            case MATTR_READONLY:
            case MATTR_SOURCE:
            case MATTR_DEFAULTVTABLE:
            case MATTR_BINDABLE:
            case MATTR_DISPLAYBIND:
            case MATTR_DEFAULTBIND:
            case MATTR_REQUESTEDIT:
            case MATTR_PROPGET:
            case MATTR_PROPPUT:
            case MATTR_PROPPUTREF:
            case MATTR_OPTIONAL:
            case MATTR_RETVAL:
            case MATTR_VARARG:
            case MATTR_PREDECLID:
            case MATTR_UIDEFAULT:
            case MATTR_NONBROWSABLE:
            case MATTR_DEFAULTCOLLELEM:
            case MATTR_IMMEDIATEBIND:
            case MATTR_USESGETLASTERROR:
            case MATTR_REPLACEABLE:
                {
                char * pAttrName = pMA->GetNodeNameString();
                SemError( this, MyContext, INAPPLICABLE_ATTRIBUTE, pAttrName);
                break;
                }

            }
        }
    node_type_attr * pTA;
    while ( ( pTA = (node_type_attr *)MyContext.ExtractAttribute(ATTR_TYPE) ) != 0 )
        {
        switch (pTA->GetAttr())
            {
            // acceptable attributes
            case TATTR_CONTROL:
                break;
            // unacceptable attributes
            case TATTR_LICENSED:
            case TATTR_APPOBJECT:
            case TATTR_PUBLIC:
            case TATTR_DUAL:
            case TATTR_PROXY:
            case TATTR_NONEXTENSIBLE:
            case TATTR_OLEAUTOMATION:
            case TATTR_NONCREATABLE:
            case TATTR_AGGREGATABLE:
                {
                char * pAttrName = pTA->GetNodeNameString();
                SemError( this, MyContext, INAPPLICABLE_ATTRIBUTE, pAttrName);
                break;
                }

            }
        }

    // make sure the UUID is unique
    if ( HasGuid )
        {
        node_guid * pGuid = (node_guid *) MyContext.ExtractAttribute( ATTR_GUID );
        node_skl* pDuplicate = GetDuplicateGuid( pGuid, pUUIDTable );
        if ( pDuplicate )
            {
            SemError(this, MyContext, DUPLICATE_UUID, pDuplicate->GetSymName());
            }
        }
    else
        {
        SemError(this, MyContext, NO_UUID_SPECIFIED, NULL);
        }
    node_skl * pN;
    NODE_T     nodeKind;

    while ( ( pN = MemIter.GetNext() ) != 0 )
        {
        SEM_ANALYSIS_CTXT ChildContext(MyContext);
        ChildContext.SetInterfaceContext( &MyContext );
        ChildContext.SetAncestorBits(IN_LIBRARY);
        nodeKind = pN->NodeKind();
        
        if ( nodeKind == NODE_PROC )
            {
            SemError( this, MyContext, INVALID_MEMBER, pN->GetSymName() );
            }
        else if (
                nodeKind != NODE_MODULE &&
                nodeKind != NODE_DISPINTERFACE &&
                nodeKind != NODE_COCLASS &&
                nodeKind != NODE_INTERFACE &&
                nodeKind != NODE_STRUCT &&
                nodeKind != NODE_UNION &&
                nodeKind != NODE_ENUM &&
                nodeKind != NODE_LABEL &&
                nodeKind != NODE_DEF &&
                nodeKind != NODE_INTERFACE_REFERENCE &&
                nodeKind != NODE_ID &&
                nodeKind != NODE_ECHO_STRING &&
                nodeKind != NODE_FORWARD && 
                nodeKind != NODE_MIDL_PRAGMA
                )
            {
            SemError(this, MyContext, POSSIBLE_INVALID_MEMBER, pN->GetSymName());
            }

        pN->SemanticAnalysis(&ChildContext);
        }

    // consume all the library attributes
    MyContext.CheckAttributes( );
    // MyContext.ReturnValues(ChildContext);
    pParentCtxt->ReturnValues( MyContext );
    gfCaseSensitive=TRUE;
}

void
node_coclass::SemanticAnalysis( SEM_ANALYSIS_CTXT * pParentCtxt)
{
    // make sure each coclass only gets analyzed once
    if (fSemAnalyzed)
        return;
    fSemAnalyzed = TRUE;

    MEM_ITER MemIter(this);
    SEM_ANALYSIS_CTXT MyContext(this, pParentCtxt);
    while(MyContext.ExtractAttribute(ATTR_CUSTOM));
    MyContext.ExtractAttribute(ATTR_TYPEDESCATTR);
    MyContext.ExtractAttribute( ATTR_HIDDEN );
    MyContext.ExtractAttribute( ATTR_VERSION );
    MyContext.ExtractAttribute( ATTR_HELPSTRING );
    MyContext.ExtractAttribute( ATTR_HELPSTRINGCONTEXT );
    MyContext.ExtractAttribute( ATTR_HELPCONTEXT );
    MyContext.ExtractAttribute( ATTR_LCID );
    if (MyContext.ExtractAttribute(ATTR_HELPSTRINGDLL))
        {
        SemError(this, MyContext, INAPPLICABLE_ATTRIBUTE, 0);
        }

    SEM_ANALYSIS_CTXT ChildContext(MyContext);
    ChildContext.SetInterfaceContext( &MyContext );

    // check for illegal attributes
    node_type_attr * pTA;
    while ( ( pTA = (node_type_attr *)MyContext.ExtractAttribute(ATTR_TYPE) ) != 0 )
        {
        switch (pTA->GetAttr())
            {
            // acceptable attributes
            case TATTR_NONCREATABLE:
                SetNotCreatable(TRUE);
                break;
            case TATTR_LICENSED:
            case TATTR_APPOBJECT:
            case TATTR_CONTROL:
            case TATTR_AGGREGATABLE:
                break;
            // unacceptable attributes
            case TATTR_PUBLIC:
                {
                char * pAttrName = pTA->GetNodeNameString();
                SemError( this, MyContext, NEWLYFOUND_INAPPLICABLE_ATTRIBUTE, pAttrName);
                break;
                }
            
            case TATTR_DUAL:
            case TATTR_PROXY:
            case TATTR_NONEXTENSIBLE:
            case TATTR_OLEAUTOMATION:
                {
                char * pAttrName = pTA->GetNodeNameString();
                SemError( this, MyContext, INAPPLICABLE_ATTRIBUTE, pAttrName);
                break;
                }

            }
        }
        // check for illegal attributes
    node_member_attr * pMA;
    while ( ( pMA = (node_member_attr *)MyContext.ExtractAttribute(ATTR_MEMBER) ) != 0 )
        {
        switch (pMA->GetAttr())
            {
            // acceptable attributes
            case MATTR_RESTRICTED:
                break;
            // unacceptable attributes
            case MATTR_READONLY:
            case MATTR_SOURCE:
            case MATTR_DEFAULTVTABLE:
            case MATTR_BINDABLE:
            case MATTR_DISPLAYBIND:
            case MATTR_DEFAULTBIND:
            case MATTR_REQUESTEDIT:
            case MATTR_PROPGET:
            case MATTR_PROPPUT:
            case MATTR_PROPPUTREF:
            case MATTR_OPTIONAL:
            case MATTR_RETVAL:
            case MATTR_VARARG:
            case MATTR_UIDEFAULT:
            case MATTR_NONBROWSABLE:
            case MATTR_DEFAULTCOLLELEM:
            case MATTR_IMMEDIATEBIND:
            case MATTR_USESGETLASTERROR:
            case MATTR_REPLACEABLE:
                {
                char * pAttrName = pMA->GetNodeNameString();
                SemError( this, MyContext, INAPPLICABLE_ATTRIBUTE, pAttrName);
                break;
                }

            }
        }
    BOOL HasGuid = MyContext.FInSummary( ATTR_GUID );

    // make sure the UUID is unique
    if ( HasGuid )
        {
        node_guid * pGuid = (node_guid *) MyContext.ExtractAttribute( ATTR_GUID );
        node_skl* pDuplicate = GetDuplicateGuid( pGuid, pUUIDTable );
        if ( pDuplicate )
            {
            SemError(this, MyContext, DUPLICATE_UUID, pDuplicate->GetSymName());
            }
        }
    else
        {
        SemError(this, MyContext, NO_UUID_SPECIFIED, NULL);
        }

    ChildContext.SetAncestorBits(IN_COCLASS);

    BOOL fHasDefaultSource = FALSE;
    BOOL fHasDefaultSink = FALSE;

    named_node * pN = (named_node *)MemIter.GetNext();
    named_node * pNFirstSource = NULL;
    named_node * pNFirstSink = NULL;
    while (pN)
        {
        BOOL fSource = pN->FMATTRInSummary(MATTR_SOURCE);
        BOOL fDefaultVtable = pN->FMATTRInSummary(MATTR_DEFAULTVTABLE);
        if (fSource)
            {
            if (NULL == pNFirstSource && !pN->FMATTRInSummary(MATTR_RESTRICTED))
                pNFirstSource = pN;
            }
        else
            {
            if (NULL == pNFirstSink && !pN->FMATTRInSummary(MATTR_RESTRICTED))
                pNFirstSink = pN;
            }
        if (fDefaultVtable)
            {
            if (!fSource)
                {
                SemError(this, MyContext, DEFAULTVTABLE_REQUIRES_SOURCE, pN->GetSymName());
                }
            }
        if (pN->GetAttribute(ATTR_DEFAULT))
            {
            if (fSource)
                {
                if (fHasDefaultSource)
                    {
                    SemError(this, MyContext, TWO_DEFAULT_INTERFACES, pN->GetSymName());
                    }
                fHasDefaultSource = TRUE;
                }
            else
                {
                if (fHasDefaultSink)
                    {
                    SemError(this, MyContext, TWO_DEFAULT_INTERFACES, pN->GetSymName());
                    }
                fHasDefaultSink = TRUE;
                }
            }
        pN->SemanticAnalysis(&ChildContext);
        pN = MemIter.GetNext();
        }

    if (!fHasDefaultSink)
        {
        if (pNFirstSink)
            pNFirstSink->SetAttribute(ATTR_DEFAULT);
        }
    if (!fHasDefaultSource)
        {
        if (pNFirstSource)
            pNFirstSource->SetAttribute(ATTR_DEFAULT);
        }

    MyContext.CheckAttributes( );
    MyContext.ReturnValues(ChildContext);
    pParentCtxt->ReturnValues( MyContext );
}

void
node_dispinterface::SemanticAnalysis( SEM_ANALYSIS_CTXT * pParentCtxt)
{
    // make sure each dispinterface gets analyzed only once
    if (fSemAnalyzed)
        return;
    fSemAnalyzed = TRUE;

    MEM_ITER MemIter(this);
    SEM_ANALYSIS_CTXT MyContext(this, pParentCtxt);
    while(MyContext.ExtractAttribute(ATTR_CUSTOM));
    MyContext.ExtractAttribute(ATTR_TYPEDESCATTR);
    MyContext.ExtractAttribute( ATTR_HIDDEN );
    MyContext.ExtractAttribute( ATTR_VERSION );
    MyContext.ExtractAttribute( ATTR_HELPSTRING );
    MyContext.ExtractAttribute( ATTR_HELPSTRINGCONTEXT );
    MyContext.ExtractAttribute( ATTR_HELPCONTEXT );
    MyContext.ExtractAttribute( ATTR_LCID );
    if (MyContext.ExtractAttribute(ATTR_HELPSTRINGDLL))
        {
        SemError(this, MyContext, INAPPLICABLE_ATTRIBUTE, 0);
        }

    SEM_ANALYSIS_CTXT ChildContext(MyContext);
    ChildContext.SetInterfaceContext( &MyContext );

    // check for illegal attributes
    node_type_attr * pTA;
    while ( ( pTA = (node_type_attr *)MyContext.ExtractAttribute(ATTR_TYPE) ) != 0 )
        {
        switch (pTA->GetAttr())
            {
            // acceptable attributes
            case TATTR_NONEXTENSIBLE:
                break;
            // unacceptable attributes
            case TATTR_OLEAUTOMATION:
            case TATTR_PUBLIC:
                {
                char * pAttrName = pTA->GetNodeNameString();
                SemError( this, MyContext, NEWLYFOUND_INAPPLICABLE_ATTRIBUTE, pAttrName);
                break;
                }
            case TATTR_PROXY:
            case TATTR_DUAL:
            case TATTR_LICENSED:
            case TATTR_APPOBJECT:
            case TATTR_CONTROL:
            case TATTR_NONCREATABLE:
            case TATTR_AGGREGATABLE:
                {
                char * pAttrName = pTA->GetNodeNameString();
                SemError( this, MyContext, INAPPLICABLE_ATTRIBUTE, pAttrName);
                break;
                }

            }
        }

    node_member_attr * pMA;
    while ( ( pMA = (node_member_attr *)MyContext.ExtractAttribute(ATTR_MEMBER) ) != 0 )
        {
        switch (pMA->GetAttr())
            {
            // acceptable attributes
            case MATTR_RESTRICTED:
                break;
            // unacceptable attributes
            case MATTR_READONLY:
            case MATTR_SOURCE:
            case MATTR_DEFAULTVTABLE:
            case MATTR_BINDABLE:
            case MATTR_DISPLAYBIND:
            case MATTR_DEFAULTBIND:
            case MATTR_REQUESTEDIT:
            case MATTR_PROPGET:
            case MATTR_PROPPUT:
            case MATTR_PROPPUTREF:
            case MATTR_OPTIONAL:
            case MATTR_RETVAL:
            case MATTR_VARARG:
            case MATTR_PREDECLID:
            case MATTR_UIDEFAULT:
            case MATTR_NONBROWSABLE:
            case MATTR_DEFAULTCOLLELEM:
            case MATTR_IMMEDIATEBIND:
            case MATTR_USESGETLASTERROR:
            case MATTR_REPLACEABLE:
                {
                char * pAttrName = pMA->GetNodeNameString();
                SemError( this, MyContext, INAPPLICABLE_ATTRIBUTE, pAttrName);
                break;
                }

            }
        }
    BOOL HasGuid = MyContext.FInSummary( ATTR_GUID );

    // make sure the UUID is unique
    if ( HasGuid )
        {
        node_guid * pGuid = (node_guid *) MyContext.ExtractAttribute( ATTR_GUID );
        node_skl* pDuplicate = GetDuplicateGuid( pGuid, pUUIDTable );
        if ( pDuplicate )
            {
            SemError(this, MyContext, DUPLICATE_UUID, pDuplicate->GetSymName());
            }
        }
    else
        {
        SemError(this, MyContext, NO_UUID_SPECIFIED, NULL);
        }

    // make sure IDispatch is defined.
    SymKey SKey("IDispatch", NAME_DEF);
    pDispatch = pBaseSymTbl->SymSearch(SKey);
    if (!pDispatch)
        {
        // IDispatch is not defined: generate error.
        SemError(this, MyContext, NO_IDISPATCH, GetSymName());
        }
    else
        {
        if (pDispatch->NodeKind() == NODE_INTERFACE_REFERENCE)
            pDispatch = ((node_interface_reference *)pDispatch)->GetRealInterface();
        }
    ChildContext.SetAncestorBits((ANCESTOR_FLAGS) IN_DISPINTERFACE);

    node_skl * pN;
    while ( ( pN = MemIter.GetNext() ) != 0 )
        {
        pN->SemanticAnalysis(&ChildContext);
        }
    MyContext.CheckAttributes( );
    MyContext.ReturnValues(ChildContext);
    pParentCtxt->ReturnValues( MyContext );
}

void
node_module::SemanticAnalysis( SEM_ANALYSIS_CTXT * pParentCtxt)
{
    // make sure each module gets analyzed only once
    if (fSemAnalyzed)
        return;
    fSemAnalyzed = TRUE;

    MEM_ITER MemIter(this);
    SEM_ANALYSIS_CTXT MyContext(this, pParentCtxt);
    BOOL HasGuid = MyContext.FInSummary( ATTR_GUID );
    MyContext.ExtractAttribute(ATTR_DLLNAME);
    while(MyContext.ExtractAttribute(ATTR_CUSTOM));
    MyContext.ExtractAttribute(ATTR_TYPEDESCATTR);
    MyContext.ExtractAttribute( ATTR_HIDDEN );
    MyContext.ExtractAttribute( ATTR_VERSION );
    MyContext.ExtractAttribute( ATTR_HELPSTRING );
    MyContext.ExtractAttribute( ATTR_HELPSTRINGCONTEXT );
    MyContext.ExtractAttribute( ATTR_HELPCONTEXT );
    MyContext.ExtractAttribute( ATTR_LCID );
    if (MyContext.ExtractAttribute(ATTR_HELPSTRINGDLL))
        {
        SemError(this, MyContext, INAPPLICABLE_ATTRIBUTE, 0);
        }

    if ( !MyContext.AnyAncestorBits( IN_LIBRARY ) )
        {
        SemError(this, MyContext, NO_LIBRARY, 0);
        }

    SEM_ANALYSIS_CTXT ChildContext(MyContext);
    ChildContext.SetInterfaceContext( &MyContext );

    // make sure the UUID is unique
    if ( HasGuid )
        {
        node_guid * pGuid = (node_guid *) MyContext.ExtractAttribute( ATTR_GUID );
        node_skl* pDuplicate = GetDuplicateGuid( pGuid, pUUIDTable );
        if ( pDuplicate )
            {
            SemError(this, MyContext, DUPLICATE_UUID, pDuplicate->GetSymName());
            }
        }

    // check for illegal attributes
    node_type_attr * pTA;
    while ( ( pTA = (node_type_attr *)MyContext.ExtractAttribute(ATTR_TYPE) ) != 0 )
        {
        switch (pTA->GetAttr())
            {
            // acceptable attributes
            case TATTR_PUBLIC:
                {
                char * pAttrName = pTA->GetNodeNameString();
                SemError( this, MyContext, NEWLYFOUND_INAPPLICABLE_ATTRIBUTE, pAttrName);
                break;
                }
                break;
            // unacceptable attributes
            case TATTR_OLEAUTOMATION:
            case TATTR_LICENSED:
            case TATTR_APPOBJECT:
            case TATTR_CONTROL:
            case TATTR_PROXY:
            case TATTR_DUAL:
            case TATTR_NONEXTENSIBLE:
            case TATTR_NONCREATABLE:
            case TATTR_AGGREGATABLE:
                {
                char * pAttrName = pTA->GetNodeNameString();
                SemError( this, MyContext, INAPPLICABLE_ATTRIBUTE, pAttrName);
                break;
                }

            }
        }
    node_member_attr * pMA;
    node_member_attr * pUsesGetLastErrorAttr = 0;

    while ( ( pMA = (node_member_attr *)MyContext.ExtractAttribute(ATTR_MEMBER)  ) != 0 )
        {
        switch (pMA->GetAttr())
            {
            // acceptable attributes
            case MATTR_RESTRICTED:
                break;
            case MATTR_USESGETLASTERROR:
                pUsesGetLastErrorAttr = pMA;
                break;
            // unacceptable attributes
            case MATTR_READONLY:
            case MATTR_SOURCE:
            case MATTR_DEFAULTVTABLE:
            case MATTR_BINDABLE:
            case MATTR_DISPLAYBIND:
            case MATTR_DEFAULTBIND:
            case MATTR_REQUESTEDIT:
            case MATTR_PROPGET:
            case MATTR_PROPPUT:
            case MATTR_PROPPUTREF:
            case MATTR_OPTIONAL:
            case MATTR_RETVAL:
            case MATTR_VARARG:
            case MATTR_PREDECLID:
            case MATTR_UIDEFAULT:
            case MATTR_NONBROWSABLE:
            case MATTR_DEFAULTCOLLELEM:
            case MATTR_IMMEDIATEBIND:
            case MATTR_REPLACEABLE:
                {
                char * pAttrName = pMA->GetNodeNameString();
                SemError( this, MyContext, INAPPLICABLE_ATTRIBUTE, pAttrName);
                break;
                }

            }
        }
        if (pUsesGetLastErrorAttr != 0)
            {
            MyContext.Add(pUsesGetLastErrorAttr);
            }

    ChildContext.SetAncestorBits(IN_MODULE);
    node_skl * pN;
    while ( (pN = MemIter.GetNext() ) != 0 )
        {
        pN->SemanticAnalysis(&ChildContext);
        }

    MyContext.CheckAttributes( );
    MyContext.ReturnValues(ChildContext);
    pParentCtxt->ReturnValues( MyContext );
}

void
node_pipe::SemanticAnalysis( SEM_ANALYSIS_CTXT * pParentCtxt )
{
    SEM_ANALYSIS_CTXT MyContext( this, pParentCtxt );
    if (!GetSymName())
    {
        char * pParentName = pParentCtxt->GetParent()->GetSymName();
        char * pName = new char [strlen(pParentName) + 6]; // the length of "pipe_" plus terminating null
        strcpy(pName, "pipe_");
        strcat(pName,pParentName);
        SetSymName(pName);
    }

    if ( MyContext.AnyAncestorBits( HAS_ASYNCHANDLE ) &&
         !MyContext.AnyAncestorBits( IN_OBJECT_INTF ) )
        {
        SetGenAsyncPipeFlavor();
        }

    GetChild()->SemanticAnalysis(&MyContext);

    CheckDeclspecAlign( MyContext );

    // Remove the following statement once support for UNIONS within PIPES is provided by the interpreter.
    if (MyContext.AnyDescendantBits( HAS_UNION ))
        {
        // pipe with a UNION
        RpcSemError(this , MyContext, UNIMPLEMENTED_FEATURE, "pipes can't contain unions" );
        }

    if (MyContext.AnyDescendantBits( HAS_HANDLE
                                   | HAS_POINTER
                                   | HAS_VAR_ARRAY
                                   | HAS_CONF_ARRAY
                                   | HAS_CONF_VAR_ARRAY
                                   | HAS_CONTEXT_HANDLE
                                   | HAS_CONF_PTR
                                   | HAS_VAR_PTR
                                   | HAS_CONF_VAR_PTR
                                   | HAS_TRANSMIT_AS
                                   | HAS_REPRESENT_AS
                                   | HAS_INTERFACE_PTR
                                   | HAS_DIRECT_CONF_OR_VAR ))
        {
        // All the above are illegal types within a pipe
        RpcSemError(this, MyContext, ILLEGAL_PIPE_TYPE, NULL );
        }

    MyContext.ClearAncestorBits( IN_UNION | IN_NE_UNION | IN_ARRAY );
    if ( MyContext.AnyAncestorBits( IN_ARRAY |
                                    IN_UNION |
                                    IN_NE_UNION |
                                    IN_STRUCT ))
        TypeSemError( this, MyContext, ILLEGAL_PIPE_EMBEDDING, NULL );

    if ( MyContext.AnyAncestorBits( IN_TRANSMIT_AS  |
                                    IN_REPRESENT_AS |
                                    IN_USER_MARSHAL |
                                    IN_FUNCTION_RESULT ))
        TypeSemError( this, MyContext, ILLEGAL_PIPE_CONTEXT, NULL );

    if ( MyContext.AnyAncestorBits( IN_ENCODE_INTF ))
        TypeSemError( this, MyContext, PIPES_WITH_PICKLING, NULL );

    if ( MyContext.AnyAncestorBits( IN_OBJECT_INTF ) )
        {
        node_skl* pType = pParentCtxt->GetParent();
        if ( pType->GetChild() )
            {
            pType = pType->GetChild();
            }
        }    
    // BUGBUG UNDONE

    // Basically, a pipe can only be used as a parameter.

    // Pipe parameters may only be passed by value or by reference.

    // Need to make sure that /-Os mode isn't enabled (until support
    // for it has been implemented).

    // Need to enable /-Oi2 mode for the containing proc if we decide not
    // to implement /-Oi mode.

    MyContext.SetDescendantBits( (DESCENDANT_FLAGS) HAS_PIPE );

    pParentCtxt->ReturnValues( MyContext );
}

void
node_safearray::SemanticAnalysis( SEM_ANALYSIS_CTXT * pParentCtxt )
{
    SEM_ANALYSIS_CTXT MyContext( this, pParentCtxt );
    FIELD_ATTR_INFO FAInfo;
    PTRTYPE PtrKind = PTR_UNKNOWN;
    BOOL fArrayParent = MyContext.AnyAncestorBits( IN_ARRAY );

    // this maintains a reference to LPSAFEARRAY. This is
    // necessary to generate the appropriate code when
    // SAFEARRAY(type) construct is used outside the library block
    char*       szSafeArray = "LPSAFEARRAY";
    SymKey      SKey( szSafeArray, NAME_DEF );
    named_node* pSafeArrayNode =  pBaseSymTbl->SymSearch( SKey );

    if ( pSafeArrayNode == 0 )
        {
        SemError( this, MyContext, UNDEFINED_SYMBOL, szSafeArray );
        }
    else
        {
        SetTypeAlias( pSafeArrayNode );
        }

    CheckDeclspecAlign( MyContext );

    // See if context_handle applied to param reached us
    if ( CheckContextHandle( MyContext ) )
        {
        MyContext.SetDescendantBits( HAS_HANDLE | HAS_CONTEXT_HANDLE );
        }

    if ( MyContext.FInSummary( ATTR_SWITCH_IS ) )
        TypeSemError( this, MyContext, ARRAY_OF_UNIONS_ILLEGAL, NULL );


//    if ( !MyContext.AnyAncestorBits( IN_LIBRARY ) )
//        {
//        SemError(this, MyContext, SAFEARRAY_NOT_SUPPORT_OUTSIDE_TLB, 0);
//        }
    ////////////////////////////////////////////////////////////////////////
    // process pointer attributes

    PtrKind = MyContext.GetPtrKind();

    MIDL_ASSERT( PtrKind != PTR_UNKNOWN );

    if ( PtrKind == PTR_FULL )
        {
        MyContext.SetDescendantBits( HAS_FULL_PTR );
        }

    if ( MyContext.ExtractAttribute( ATTR_PTR_KIND) )
        TypeSemError( this, MyContext, MORE_THAN_ONE_PTR_ATTR, NULL );

    // ref pointer may not be returned
    if ( ( PtrKind == PTR_REF ) &&
            MyContext.AllAncestorBits( IN_RPC | IN_FUNCTION_RESULT ) )
        {
        if (MyContext.FindNonDefAncestorContext()->GetParent()->NodeKind()
                == NODE_PROC )
            TypeSemError( this, MyContext, BAD_CON_REF_RT, NULL );
        }

    // unique or full pointer may not be out only
    if ( ( PtrKind != PTR_REF ) &&
            MyContext.AllAncestorBits( IN_RPC | IN_PARAM_LIST ) &&
            !MyContext.AnyAncestorBits( UNDER_IN_PARAM |
            IN_STRUCT |
            IN_UNION |
            IN_ARRAY |
            IN_POINTER ) )
        TypeSemError( this, MyContext, UNIQUE_FULL_PTR_OUT_ONLY, NULL );

    MyContext.SetAncestorBits( IN_ARRAY );

    // warn about OUT const things
    if ( FInSummary( ATTR_CONST ) )
        {
        if ( MyContext.AnyAncestorBits( UNDER_OUT_PARAM ) )
            RpcSemError( this, MyContext, CONST_ON_OUT_PARAM, NULL );
        else if ( MyContext.AnyAncestorBits( IN_FUNCTION_RESULT ) )
            RpcSemError( this, MyContext, CONST_ON_RETVAL, NULL );
        }

    /////////////////////////////////////////////////////////////////////////
    // process field attributes

    FAInfo.SetControl( FALSE, GetBasicType()->IsPtrOrArray() );
    MyContext.ExtractFieldAttributes( &FAInfo );

    switch ( FAInfo.Kind )
        {
        case FA_NONE:
            {
            break;
            }
        case FA_STRING:
            {
            // string attributes only allowed on char and wchar_t
            if ( !GetBasicType()->IsStringableType() )
                TypeSemError( this, MyContext, STRING_NOT_ON_BYTE_CHAR, NULL );

            if ( MyContext.AllAncestorBits( UNDER_OUT_PARAM |
                    IN_PARAM_LIST |
                    IN_RPC ) &&
                    !MyContext.AnyAncestorBits( IN_STRUCT |
                    IN_UNION |
                    IN_POINTER |
                    IN_ARRAY |
                    UNDER_IN_PARAM ) )
                TypeSemError( this, MyContext, DERIVES_FROM_UNSIZED_STRING, NULL );

            if ( FAInfo.StringKind == STR_BSTRING )
                TypeSemError( this, MyContext, BSTRING_NOT_ON_PLAIN_PTR, NULL );
            // break;  deliberate fall through to case below
            }
        case FA_VARYING:
            {
            MyContext.SetDescendantBits( HAS_VAR_ARRAY );
            break;
            }
        case FA_CONFORMANT:
            {
            MyContext.SetDescendantBits( HAS_CONF_ARRAY );
            break;
            }
        case FA_CONFORMANT_STRING:
            {
            // string attributes only allowed on char and wchar_t
            if ( !GetBasicType()->IsStringableType() )
                TypeSemError( this, MyContext, STRING_NOT_ON_BYTE_CHAR, NULL );
            if ( FAInfo.StringKind == STR_BSTRING )
                TypeSemError( this, MyContext, BSTRING_NOT_ON_PLAIN_PTR, NULL );
            // break;  deliberate fall through to case below
            }
        case FA_CONFORMANT_VARYING:
            {
            MyContext.SetDescendantBits( HAS_CONF_VAR_ARRAY );
            break;
            }
        case FA_INTERFACE:
            {
            // gaj - tbd
            break;
            }
        default:    // string + varying combinations
            {
            TypeSemError( this, MyContext, INVALID_SIZE_ATTR_ON_STRING, NULL );
            break;
            }
        }

    // detect things like arrays of conf structs...
    // if we have an array as an ancestor, and we have conformance, then complain
    if ( MyContext.AnyDescendantBits( HAS_CONF_ARRAY | HAS_CONF_VAR_ARRAY ) &&
            fArrayParent )
        {
        // see if there are any bad things between us and our parent array
        SEM_ANALYSIS_CTXT * pCtxt = (SEM_ANALYSIS_CTXT *) pParentCtxt;
        node_skl * pCur = pCtxt->GetParent();

        // check up for anything other than def below proc
        // make sure the proc only has one param
        while ( pCur->NodeKind() != NODE_ARRAY )
            {
            if ( pCur->NodeKind() != NODE_DEF )
                {
                SemError( this, MyContext, ILLEGAL_CONFORMANT_ARRAY, NULL );
                break;
                }
            pCtxt = (SEM_ANALYSIS_CTXT *) pCtxt->GetParentContext();
            pCur = pCtxt->GetParent();
            }

        }

    //////////////////////////////////////////////////////////////
    // process the array element
    GetChild()->SemanticAnalysis( &MyContext );

/*
    // BSTR has sizeis_ptr, eventhough under variant, and it would be ugly to
    // hardcode checking variant here. well...
    if ( MyContext.AnyDescendantBits( HAS_CONF_ARRAY |
                                      HAS_CONF_VAR_ARRAY |
                                      HAS_VAR_ARRAY |
                                      HAS_UNSAT_REP_AS |
                                      HAS_CONTEXT_HANDLE |
                                      HAS_CONF_PTR |
                                      HAS_VAR_PTR |
                                      HAS_CONF_VAR_PTR |
                                      HAS_DIRECT_CONF_OR_VAR |
                                      HAS_FUNC |
                                      HAS_FULL_PTR |
                                      HAS_TOO_BIG_HDL |
                                      HAS_MULTIDIM_SIZING |
                                      HAS_PIPE |
                                      HAS_MULTIDIM_VECTOR |
                                      HAS_SIZED_ARRAY |
                                      HAS_SIZED_PTR ) )
        TypeSemError( this, MyContext, INVALID_SAFEARRAY_ATTRIBUTE, NULL );
*/                                      
    MyContext.SetDescendantBits( HAS_ARRAY );

	// early binding of safearray(interface pointer) doesn't work
    node_skl * pChild = GetChild()->GetBasicType();
    SEM_ANALYSIS_CTXT * pIntfCtxt = (SEM_ANALYSIS_CTXT *)
        MyContext.GetInterfaceContext();
    BOOL fLocal         = pIntfCtxt->FInSummary( ATTR_LOCAL );
    fLocal |= MyContext.AnyAncestorBits( IN_LOCAL_PROC );
        
    if ( pChild->NodeKind() == NODE_POINTER ) 
        pChild = pChild->GetChild();
    if ( IsInterfaceKind( pChild->NodeKind() )  &&
         !MyContext.AnyAncestorBits( IN_LIBRARY ) &&
         !fLocal )
        SemError( this, MyContext, SAFEARRAY_IF_OUTSIDE_LIBRARY, NULL );

    // disallow forward references as array elements
    // NOTE- all safearray elements are VARIANTS, we don't really need
    // to enforce this restriction for safearrays.  Besides, enforcing
    // this restriction breaks some of our test cases.
    if ( MyContext.AnyDescendantBits( HAS_INCOMPLETE_TYPE ) )
        {
        MyContext.ClearDescendantBits( HAS_INCOMPLETE_TYPE );
        }
    MyContext.ClearDescendantBits( HAS_RECURSIVE_DEF );

    if ( MyContext.AllDescendantBits( HAS_DIRECT_CONF_OR_VAR |
            HAS_MULTIDIM_SIZING ) &&
            MyContext.AnyDescendantBits( HAS_CONF_ARRAY | HAS_CONF_VAR_ARRAY ) &&
            ( GetChild()->NodeKind() == NODE_DEF ) )
        {
        SemError( this, MyContext, NON_ANSI_MULTI_CONF_ARRAY, NULL );
        }

    MyContext.ClearDescendantBits( HAS_DIRECT_CONF_OR_VAR );
    if ( ( FAInfo.Kind != FA_NONE ) &&
            ( FAInfo.Kind != FA_STRING ) &&
            ( FAInfo.Kind != FA_INTERFACE ) )
        MyContext.SetDescendantBits( HAS_DIRECT_CONF_OR_VAR );

    if ( MyContext.AnyDescendantBits( HAS_HANDLE ) )
        TypeSemError( this, MyContext, BAD_CON_CTXT_HDL_ARRAY, NULL );

    // don't allow functions as elements
    if ( MyContext.AnyDescendantBits( HAS_FUNC ) &&
            MyContext.AllAncestorBits( IN_INTERFACE | IN_RPC ) )
        TypeSemError( this, MyContext, BAD_CON_ARRAY_FUNC, NULL );

    // This is a hack to propagate the correct attributes up to the next level.
    // Unfortunately, semantic analysis does more then just determine 
    // if the *.idl file is legal.  It also catches known limitations of the 
    // engine, aids in determining the complexity of the marshaling problem,
    // and other checks that change the state of the front end which directly 
    // affect the backend.
 
    // gracelly handle the error case and the library case.
    if ( ! pSafeArrayNode || MyContext.AnyAncestorBits( IN_LIBRARY ) )
    {
        // Is this class was used in a proxy, continue to pass up the proxy bits.
        if ( fInProxy )
            {
            pSafeArrayNode->SemanticAnalysis( pParentCtxt );
            return;
            }
        MyContext.ClearDescendantBits( HAS_STRUCT );
        pParentCtxt->ReturnValues( MyContext );
        return;
    }  

    fInProxy = TRUE;
    pSafeArrayNode->SemanticAnalysis( pParentCtxt );
    
};

void
node_async_handle::SemanticAnalysis( SEM_ANALYSIS_CTXT* )
    {
    }


BOOL IsOLEAutomationType( char* szTypeName )
    {
    BOOL    fRet = FALSE;
    // keep this list sorted!
    static char*   szOLEAutomationTypes[] =
        {
        "BSTR",             // wchar_t
        "CURRENCY",         // struct
        "DATE",             // double
        "SCODE",            // long
        "VARIANT",
        "VARIANT_BOOL",
        };

    int uFirst = 0;
    int uLast  = (sizeof(szOLEAutomationTypes) - 1) / sizeof(char*);
    int uMid   = (uFirst + uLast) / 2;
    
    while (uLast >= uFirst && uLast >= 0 && uFirst <= (sizeof(szOLEAutomationTypes) - 1) / sizeof(char*))
        {
        int nCmp = strcmp(szOLEAutomationTypes[uMid], szTypeName);

        if (nCmp == 0)
            {
            fRet = TRUE;
            break;
            }
        else if (nCmp > 0)
            {
            uLast = uMid - 1;
            }
        else
            {
            uFirst = uMid + 1;
            }
        uMid = (uFirst + uLast) / 2;
        }

    return fRet;
    }


BOOL IsBasicOleAutoKind( NODE_T x)
    {
    // NODE_INT128, NODE_FLOAT80, NODE_FLOAT128 is not supported.
    return ( (x) == NODE_DOUBLE || (x) == NODE_FLOAT || (x) == NODE_INT ||  
             (x) == NODE_SHORT || (x) == NODE_LONG || (x) == NODE_CHAR  ||
             (x) == NODE_INT32 ||
             (x) == NODE_HYPER  || (x) == NODE_INT64  ||  (x) == NODE_INT3264 ||
             (x) == NODE_BOOLEAN || (x) == NODE_WCHAR_T 
             );
    }

BOOL IsOLEAutoBasicType ( node_base_type* pNBT )
    {
    NODE_T          nodeKind    = pNBT->NodeKind();

    if ( nodeKind == NODE_CHAR )
        {
        return ( (node_base_type*) pNBT )->IsUnsigned();
        }
    else
        {
        return TRUE;
        }
    }

BOOL IsOLEAutoInterface ( node_interface* pType )
    {
    node_interface* pNodeIf;
    BOOL            fRet = FALSE;

    // pType may be a node_interface or a node_interaface_reference
    // "normalize" it.
    if ( pType->NodeKind() == NODE_INTERFACE_REFERENCE )
        {
        pNodeIf = (( node_interface_reference *) pType )->GetRealInterface();
        }
    else
        {
        pNodeIf = pType;
        }

    fRet = pNodeIf->HasOLEAutomation();
    if ( !fRet )
        {
        // the interface is forward declared,
        // and has not been analyzed for semantic errors,
        // it does not have HasOleAutomation flag set.
        fRet = pNodeIf->FTATTRInSummary( TATTR_OLEAUTOMATION ) ||
               pNodeIf->FTATTRInSummary( TATTR_DUAL );
        if ( !fRet )
            {
            // interface may be an IUnknown or an IDispatch and these do not
            // have HasOleAutomation flag set.
            fRet = pNodeIf->IsValidRootInterface();
            if ( !fRet )
                {
                // It is not IUnknown. If it is not IFont or IDispatch, it is not
                // an oleautomation compliant interface.
                char*  szIfName = pNodeIf->GetSymName();
                fRet = !_stricmp(szIfName, "IDispatch") || !_stricmp(szIfName, "IFontDisp");
                }
            }
        }

    return fRet;
    }

BOOL 
IsOLEAutomationCompliant( node_skl* pParamType )
    {

    if ( pParamType == 0 )
        {
        return FALSE;
        }

    BOOL    fConforms   = FALSE;
    NODE_T  nKind       = pParamType->NodeKind();

    if ( nKind == NODE_SAFEARRAY || nKind == NODE_HREF || nKind == NODE_POINTER )
        {
        fConforms = IsOLEAutomationCompliant( pParamType->GetChild() );
        }
    else if ( IsInterfaceKind( nKind ) )
        {
        fConforms = IsOLEAutoInterface( (node_interface*) pParamType );
        }
    else if ( IsCoclassOrDispKind( nKind ) || nKind == NODE_ENUM || nKind == NODE_STRUCT || 
            IsBasicOleAutoKind( nKind ) )
        {
        fConforms = TRUE;
        }
    else if ( nKind == NODE_DEF )
        {
        node_skl* pChild = pParamType->GetChild();
        fConforms = IsOLEAutomationType( pParamType->GetSymName() ) ? TRUE : IsOLEAutomationCompliant( pChild );
        }
    else if ( nKind == NODE_FORWARD )
        {
        node_skl* pChild = ( (node_forward*) pParamType )->ResolveFDecl();

        fConforms = ( pChild ) ? IsOLEAutomationCompliant( pChild ) : FALSE;
        }

    return fConforms;
    }

bool
HasCorrelation( node_skl* pNode )
    {
    if (
        pNode->FInSummary( ATTR_SIZE ) ||
        pNode->FInSummary( ATTR_FIRST ) ||
        pNode->FInSummary( ATTR_BYTE_COUNT ) ||
        pNode->FInSummary( ATTR_LAST ) ||
        pNode->FInSummary( ATTR_LENGTH ) ||
        pNode->FInSummary( ATTR_MAX ) ||
        pNode->FInSummary( ATTR_MIN ) ||
        pNode->FInSummary( ATTR_SIZE ) ||
        pNode->FInSummary( ATTR_IID_IS ) ||
        pNode->FInSummary( ATTR_SWITCH_IS )
       )
        {
        return true;
        }
    return false;
    }

bool
node_skl::CheckContextHandle( SEM_ANALYSIS_CTXT& MyContext )
    {
    bool fSerialize = MyContext.ExtractAttribute( ATTR_SERIALIZE ) != 0;
    bool fNoSerialize = MyContext.ExtractAttribute( ATTR_NOSERIALIZE ) != 0;
    bool fContextHandle = MyContext.ExtractAttribute( ATTR_CONTEXT ) != 0;
    // See if context_handle applied to param reached us
    if ( fContextHandle )
        {
        // not allowed in DCE mode; context handle must be void *
        TypeSemError( this, MyContext, CONTEXT_HANDLE_VOID_PTR, 0 );
        TypeSemError( this, MyContext, CTXT_HDL_NON_PTR, 0 );
        }
    else
        {
        if ( fSerialize || fNoSerialize )
            {
            SemError( this, MyContext, NO_CONTEXT_HANDLE, GetSymName() );
            }
        }
    if ( fSerialize && fNoSerialize )
        {
        SemError( this, MyContext, CONFLICTING_ATTRIBUTES, GetSymName() );
        }
    return fContextHandle;
    }

extern CMessageNumberList   GlobalMainMessageNumberList;

void
node_midl_pragma::SemanticAnalysis( SEM_ANALYSIS_CTXT* )
    {
    ProcessPragma();
    }

void
node_midl_pragma::ProcessPragma()
    {
    LONG_PTR ulMsg = 0;
    m_pMsgList->Init();
    while ( m_pMsgList->GetNext( (void**) &ulMsg ) == STATUS_OK )
        {
        if ( m_PragmaType == mp_MessageDisable )
            {
            GlobalMainMessageNumberList.ResetMessageFlag( (long)ulMsg );
            }
        else
            {
            GlobalMainMessageNumberList.SetMessageFlag( (long)ulMsg );
            }
        }
    }

void
node_decl_guid::SemanticAnalysis( SEM_ANALYSIS_CTXT* )
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\inc\ebase.h ===
// Copyright (c) 1993-1999 Microsoft Corporation

#ifndef __EBASE_H__
#define __EBASE_H__

typedef struct _sgoto
	{
	short	Goto;
	short	Token;
	} _SGOTO;

#define	SGOTO	const _SGOTO

typedef struct _sgotovector
	{

	short		State;
	SGOTO	*	pSGoto;
	short		Count;

	} _SGOTOVECTOR;

#define SGOTOVECTOR	const _SGOTOVECTOR

typedef struct _tokvsstatevector
	{
	short		Token;
	short	*	pTokenVsState;
	short		Count;
	} _TOKVSSTATEVECTOR;

#define TOKVSSTATEVECTOR	const _TOKVSSTATEVECTOR

#define _DBENTRY_DEFINED

typedef struct _DBENTRY {
	 short State;
	 const char *  pTranslated;
} _DBENTRY;

#define DBENTRY const _DBENTRY
#endif//__EBASE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\front\symtable.cxx ===
/**********************************************************************/
/**                      Microsoft LAN Manager                       **/
/**             Copyright(c) Microsoft Corp., 1987-1999              **/
/**********************************************************************/

/*

symtable.cxx
MIDL Compiler Symbol Table Implementation

This class centralizes access to the symbol table throughout the
compiler.

*/

/*

FILE HISTORY :

DonnaLi     08-25-1990      Created.

*/

#pragma warning ( disable : 4514 )

#include "nulldefs.h"
extern "C" {

#include <stdio.h>
#include <string.h>

}
#include "common.hxx"
#include "errors.hxx"
#include "symtable.hxx"
#include "tlgen.hxx"
#include "mbcs.hxx"

BOOL gfCaseSensitive = TRUE; // initialize things under case sensitive mode

CaseStack gCaseStack;

class named_node;

/**********************************************************************\

NAME:		SymEntry

SYNOPSIS:	Defines an entry in the symbol table.

INTERFACE:

CAVEATS:	This is an internal class used by the symbol table only.

NOTES:

HISTORY:
	Donnali			08-25-1990		Initial creation

\**********************************************************************/

class SymEntry : public SymKey
{
	named_node	*	pTypeGraph;	// pointer to type graph associated with entry
	SymTable 	*	pNextScope;	// pointer to next scope associated with entry

public:

	SymEntry(void)
		{
		pTypeGraph = (named_node *)0;
		pNextScope = (SymTable *)0;
		}
	SymEntry( SymKey NewKey )
			: SymKey( &NewKey )
		{
		pTypeGraph = (named_node *)0;
		pNextScope = (SymTable *)0;
		}

	SymEntry(
		SymKey		NewKey,
		SymTable *	pNext,
		named_node *	pNode) : SymKey( &NewKey )
		{
		pTypeGraph = pNode;
		pNextScope = pNext;
		}

	void SetTypeGraph (named_node * pNode)
		{
		pTypeGraph = pNode;
		}

	named_node * GetTypeGraph (void)
		{
		return pTypeGraph;
		}

	void SetNextScope (SymTable * pNext)
		{
		pNextScope = pNext;
		}

	SymTable * GetNextScope (void)
		{
		return pNextScope;
		}

// here is the use of the private memory allocator
private:

	static
	FreeListMgr				MyFreeList;
	

public:


	void		*			operator new (size_t size)
								{
								return (MyFreeList.Get (size));
								}

	void 					operator delete (void * pX)
								{
								MyFreeList.Put (pX);
								}


} ;


// initialize the memory allocator for SymEntry

FreeListMgr
SymEntry::MyFreeList( sizeof ( SymEntry ) );

/**********************************************************************\

NAME:		PrintSymbol

SYNOPSIS:	Prints out the name of a symbol table entry.

ENTRY:		sym	- the key to symbol table entry to be printed.

EXIT:

NOTES:

HISTORY:
	Donnali		08-06-1991		Move to LM/90 UI Coding Style

\**********************************************************************/

void
SymTable::Print(
	void * sym
	)
{
	 printf ("%s", ((SymKey *)sym)->name);
}

/**********************************************************************\

NAME:		CompareSymbol

SYNOPSIS:	Compares keys to two symbol table entries.

ENTRY:		sym1 -	the key to 1st symbol table entry to be compared.
			sym2 -	the key to 2nd symbol table entry to be compared.

EXIT:		Returns a positive number if sym1 > sym2.
			Returns a negative number if sym1 < sym2.
			Returns 0 if sym1 = sym2.

NOTES:

			Since all the strings are in the lex table, we can just compare
			pointers to do the string compares.

HISTORY:
	Donnali		08-06-1991		Move to LM/90 UI Coding Style

\**********************************************************************/

SSIZE_T
SymTable::Compare(
	void * sym1,
	void * sym2
	)
{
	int	result;

#ifdef unique_lextable
	// compare pointers into lex table
	result = 	( (int)((SymKey *)sym1)->name )
			-	( (int)((SymKey *)sym2)->name );
#else
	// compare names from keys
    // 1 refers to the value for the flag NORM_IGNORECASE
	result = CurrentCharSet.CompareDBCSString( ((SymKey *)sym1)->name,
					                            ((SymKey *)sym2)->name,
                                                gfCaseSensitive ? 0 : 1);
#endif // unique_lextable
	if (!result)
		{
		return ( ( ((SymKey *)sym1)->kind & NAME_MASK )-
				 ( ((SymKey *)sym2)->kind & NAME_MASK ) );
		}
	else
		{
		return result;
		}
}

/**********************************************************************\

NAME:		SymTable::SymInsert

SYNOPSIS:	Inserts a symbol into the symbol table.

ENTRY:		NewKey	- identifies the symbol table entry.
			pNext	- points to the next scope.
			pNode	- points to the type graph.

EXIT:

NOTES:

HISTORY:
	Donnali		08-06-1991		Move to LM/90 UI Coding Style

\**********************************************************************/

named_node *
SymTable::SymInsert(
	SymKey		NewKey,
	SymTable *	pNext,
	named_node *	pNode
	)
{
	SymEntry *	NewSymbol;
	Dict_Status	Status;

	NewSymbol = new SymEntry(NewKey, pNext, pNode);

    CaselessEntry * NewEntry = new CaselessEntry(NewSymbol);

    if (!gfCaseSensitive)
    {
        if (NULL != caseless_list.Find(NewEntry))
        {
            // it's allready entered into the caseless table
            // and we're in case insensitive mode so we
            // should fail here (duplicate identifier)
            delete NewSymbol;
            delete NewEntry;
            return NULL;
        }
    }

    Status = Dict_Insert(NewSymbol);
	if (Status == SUCCESS)
    {
        caseless_list.Add(NewEntry);
		return pNode;
    }

	delete NewSymbol;
    delete NewEntry;
	return (named_node *)0;
}

/**********************************************************************\

NAME:		SymTable::SymDelete

SYNOPSIS:	Deletes a symbol from the symbol table.

ENTRY:		OldKey	- identifies the symbol table entry.

EXIT:		Returns the type graph associated with the entry.

NOTES:

HISTORY:
	Donnali		08-06-1991		Move to LM/90 UI Coding Style

\**********************************************************************/

named_node *
SymTable::SymDelete(
	SymKey	OldKey
	)
{
    SymEntry	TempEntry( OldKey );

    CaselessEntry * OldEntry = new CaselessEntry(&TempEntry);
    SymEntry * OldSymbol;

    // make sure we delete the right symbol from both tables
    if (!gfCaseSensitive)
    {
        OldSymbol = (caseless_list.Delete(OldEntry))->pSymEntry;
    }
    else
    {
        OldSymbol = &TempEntry;
        caseless_list.DeleteExact(OldEntry);
    }

	named_node *	pNode;
    Dict_Status	Status;

    Status = Dict_Delete((void ** )&OldSymbol);

	if (Status == SUCCESS)
		{
		pNode = OldSymbol->GetTypeGraph();
		delete OldSymbol;
#ifdef gajdebug3
			printf("\t\t--- deleting name from symbol table: %d - %s\n",
					OldKey.GetKind(), OldKey.GetString());
#endif
		return pNode;
		}
	else
		{
		return (named_node *)0;
		}
}

/**********************************************************************\

NAME:		SymTable::SymSearch

SYNOPSIS:	Searches the symbol table for a symbol.

ENTRY:		OldKey	- identifies the symbol table entry.

EXIT:		Returns the type graph associated with the entry.

NOTES:

HISTORY:
	Donnali		08-06-1991		Move to LM/90 UI Coding Style

\**********************************************************************/

named_node *
SymTable::SymSearch(
	SymKey	OldKey
	)
{
	Dict_Status	Status;

    if (gfCaseSensitive)
    {
	    Status = Dict_Find(&OldKey);
	    if (Status == SUCCESS)
		    {
    		return ((SymEntry * )Dict_Curr_Item())->GetTypeGraph();
		    }
	    else
		    {						
			return NULL;
		    }
    }
    else
    {
        SymEntry TempEntry(OldKey);
        CaselessEntry OldEntry(&TempEntry);
        CaselessEntry * pFound = caseless_list.Find(&OldEntry);
        if (pFound)
        {
            return pFound->pSymEntry->GetTypeGraph();
        }
        else
        {
			return NULL;
        }
    }
}

/**********************************************************************\

NAME:		SymTable::EnterScope

SYNOPSIS:	Transition from current scope to inner scope.

ENTRY:		key	- identifies the symbol table entry.

EXIT:		ContainedDict	- returns the inner scope.

NOTES:

HISTORY:
	Donnali		08-06-1991		Move to LM/90 UI Coding Style

\**********************************************************************/

STATUS_T
SymTable::EnterScope(
	SymKey		key,
	SymTable **	ContainedDict
	)
{
	SymEntry 	ContainerNode( key );
	Dict_Status	Status;

	if (ContainedDict == (SymTable **)0)
		{
		return I_ERR_NULL_OUT_PARAM;
		}

	Status = Dict_Find(&ContainerNode);
	if (Status != SUCCESS)
		{
		return I_ERR_SYMBOL_NOT_FOUND;
		}
	else if (((SymEntry * )Dict_Curr_Item())->GetNextScope() == (SymTable *)0)
		{
		return I_ERR_NO_NEXT_SCOPE;
		}
	else
		{
		* ContainedDict = ((SymEntry * )Dict_Curr_Item())->GetNextScope();
		(*ContainedDict)->pPrevScope = this;
		return STATUS_OK;
		}
}

/**********************************************************************\

NAME:		SymTable::ExitScope

SYNOPSIS:	Transition from current scope to outer scope.

ENTRY:

EXIT:		ContainerDict	- returns the outer scope.

NOTES:

HISTORY:
	Donnali		08-06-1991		Move to LM/90 UI Coding Style

\**********************************************************************/

STATUS_T
SymTable::ExitScope(
	SymTable **	ContainerDict
	)
{
	if (ContainerDict == (SymTable **)0)
		{
		return I_ERR_NULL_OUT_PARAM;
		}
	else if (pPrevScope == (SymTable *)0)
		{
		return I_ERR_NO_PREV_SCOPE;
		}
	else
		{
		* ContainerDict = pPrevScope;
		pPrevScope = (SymTable *)0;
		return STATUS_OK;
		}
}

/**********************************************************************\

NAME:		SymTable::DiscardScope

SYNOPSIS:	Discard all entries in the current scope (if no fwds).

ENTRY:

EXIT:		.

NOTES:

HISTORY:

\**********************************************************************/

void
SymTable::DiscardScope()
{
	// do nothing if there are forwards
	if ( fHasFwds )
		return;

	SymEntry	*	pCurrent;

	// delete all the SymEntry's in this scope
	while ( ( pCurrent = (SymEntry *) Dict_Delete_One() ) != 0 )
		{
		delete pCurrent;
		}

}

CaselessEntry::CaselessEntry(SymEntry * pItem)
{
    pSymEntry = pItem;
    // compute the hash value
    hash = 0;
    char ch;
    unsigned u = 0;
    while (0 != (ch = pSymEntry->name[u++]))
    {
        hash += ch | 32; // makes sure the hash value is case insensitive
    };
}

int CaselessEntry::Compare(CaselessEntry * pEntry2)
{
    int rval = hash - pEntry2->hash;
    if (0 == rval)
    {
        rval = CurrentCharSet.CompareDBCSString(pSymEntry->name, pEntry2->pSymEntry->name, 1); // ignore case
        if (0 == rval)
        {
            rval = pSymEntry->kind - pEntry2->pSymEntry->kind;
        }
    }
    return rval;
}

CaselessEntry * CaselessList::Add(CaselessEntry * pEl)
{
    CaselessListElement * pNew = new CaselessListElement(pEl);
    pNew->pNext = pHead;
    pHead = pNew;
    return pEl;
}

CaselessEntry * CaselessList::Find(CaselessEntry * pEntry)
{
    CaselessListElement * pThis = pHead;
    while (pThis && 0 != pThis->pEntry->Compare(pEntry))
    {
        pThis = pThis->pNext;
    }
    if (pThis != NULL)
        return pThis->pEntry;
    else
        return NULL;
}

CaselessEntry * CaselessList::Delete(CaselessEntry * pEntry)
{
    CaselessListElement ** ppThis = &pHead;
    while (*ppThis)
    {
        if (0 == (*ppThis)->pEntry->Compare(pEntry))
        {
            CaselessListElement * pFound = *ppThis;
            *ppThis = pFound->pNext;
            CaselessEntry * pReturn = pFound->pEntry;
            delete pFound;
            return pReturn;
        }
        ppThis = &((*ppThis)->pNext);
    }
    return NULL;
}

CaselessList::~CaselessList()
{
    CaselessListElement * pNext;
    while(pHead);
    {
        pNext = pHead->pNext;
        delete pHead;
        pHead = pNext;
    }
}

CaselessEntry * CaselessList::DeleteExact(CaselessEntry * pEntry)
{
    CaselessListElement ** ppThis = &pHead;
    while (*ppThis)
    {
        if ((*ppThis)->pEntry->hash == pEntry->hash)
        {
            if (0 == strcmp((*ppThis)->pEntry->pSymEntry->name, pEntry->pSymEntry->name))
            {
                if ((*ppThis)->pEntry->pSymEntry->kind == pEntry->pSymEntry->kind)
                {
                    CaselessListElement * pFound = *ppThis;
                    *ppThis = pFound->pNext;
                    CaselessEntry * pReturn = pFound->pEntry;
                    delete pFound;
                    return pReturn;
                }
            }
        }
        ppThis = &((*ppThis)->pNext);
    }
    return NULL;
}

SSIZE_T
CaselessDictionary::Compare(void * p1, void *p2)
{
    return ((CaselessEntry *)p1)->Compare((CaselessEntry *) p2);
}

/**********************************************************************\

NAME:		GlobalSymTable::SymInsert

SYNOPSIS:	Inserts a symbol into the symbol table.

ENTRY:		NewKey	- identifies the symbol table entry.
			pNext	- points to the next scope.
			pNode	- points to the type graph.

EXIT:

NOTES:

HISTORY:
	Donnali		08-06-1991		Move to LM/90 UI Coding Style

\**********************************************************************/

named_node *
GlobalSymTable::SymInsert(
	SymKey		NewKey,
	SymTable *	pNext,
	named_node *	pNode
	)
{
	SymEntry *	NewSymbol;
	Dict_Status	Status;

	NewSymbol = new SymEntry(NewKey, pNext, pNode);

    CaselessEntry * NewEntry = new CaselessEntry(NewSymbol);

    if (!gfCaseSensitive)
    {
        Status = pCaselessDictionary->Dict_Find(NewEntry);

        if (SUCCESS == Status)
        {
            // it's allready entered into the caseless table
            // and we're in case insensitive mode so we
            // should fail here (duplicate identifier)
            delete NewSymbol;
            delete NewEntry;
            return NULL;
        }
    }

    Status = Dict_Insert(NewSymbol);
	if (Status == SUCCESS)
    {
        Status = pCaselessDictionary->Dict_Insert(NewEntry);
        if (SUCCESS != Status)
        {
            // We must be in case sensitive mode otherwise the
            // Dict_Find above would have succeeded and we would
            // have already returned failure to the caller.
            // Therefore, it doesn't really matter that this name
            // won't have an entry in the caseless table.  Just
            // clean up the new entry and move on.
            delete NewEntry;

        }
		return pNode;
    }

	delete NewSymbol;
    delete NewEntry;
	return (named_node *)0;
}

/**********************************************************************\

NAME:		GlobalSymTable::SymDelete

SYNOPSIS:	Deletes a symbol from the symbol table.

ENTRY:		OldKey	- identifies the symbol table entry.

EXIT:		Returns the type graph associated with the entry.

NOTES:      This operation could potentially mess up the case insensitive
            table because there is no guarantee that the symbol removed
            from the case insensitive table will match the symbol removed
            from the case sensitive table.  However, since MIDL always
            re-adds the symbol to the symbol table immediately after
            deleting it (deletions only serve to replace forward references)
            it will effectively correct any inconsistencies between the
            two tables when it re-adds the symbol.

HISTORY:
	Donnali		08-06-1991		Move to LM/90 UI Coding Style

\**********************************************************************/

named_node *
GlobalSymTable::SymDelete(
	SymKey	OldKey
	)
{
    SymEntry	TempEntry( OldKey );

    CaselessEntry * OldEntry = new CaselessEntry(&TempEntry);
    SymEntry * OldSymbol;

    Dict_Status	Status;

    Status = pCaselessDictionary->Dict_Delete((void **)&OldEntry);

    if (!gfCaseSensitive && SUCCESS == Status)
    {
        // make sure we delete the same symbol from the case
        // sensitive table
        OldSymbol = OldEntry->pSymEntry;
    }
    else
    {
        OldSymbol = &TempEntry;
    }

	named_node *	pNode;

    Status = Dict_Delete((void ** )&OldSymbol);

	if (Status == SUCCESS)
		{
		pNode = OldSymbol->GetTypeGraph();
		delete OldSymbol;
#ifdef gajdebug3
			printf("\t\t--- deleting name from symbol table: %d - %s\n",
					OldKey.GetKind(), OldKey.GetString());
#endif
		return pNode;
		}
	else
		{
		return (named_node *)0;
		}
}

/**********************************************************************\

NAME:		GlobalSymTable::SymSearch

SYNOPSIS:	Searches the symbol table for a symbol.

ENTRY:		OldKey	- identifies the symbol table entry.

EXIT:		Returns the type graph associated with the entry.

NOTES:

HISTORY:
	Donnali		08-06-1991		Move to LM/90 UI Coding Style

\**********************************************************************/

named_node *
GlobalSymTable::SymSearch(
	SymKey	OldKey
	)
{
	Dict_Status	Status;

    // DBCSDefaultToCaseSensitive() is introduced to handle the
    // equivalence of full width and half width characters in
    // far east languages; specifically Japanese
    if (gfCaseSensitive || CurrentCharSet.DBCSDefaultToCaseSensitive())
    {
	    Status = Dict_Find(&OldKey);
	    if (Status == SUCCESS)
		    {
    		return ((SymEntry * )Dict_Curr_Item())->GetTypeGraph();
		    }
	    else
		    {
			return NULL;
		    }
        }
        else
    {
        SymEntry TempEntry(OldKey);
        CaselessEntry OldEntry(&TempEntry);
        Status = pCaselessDictionary->Dict_Find(&OldEntry);
        if (Status == SUCCESS)
        {
            return ((CaselessEntry *)(pCaselessDictionary->Dict_Curr_Item()))->pSymEntry->GetTypeGraph();
        }
        else
        {
			return NULL;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\front\semutil.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-1999 Microsoft Corporation

 Module Name:

    semutil.cxx

 Abstract:

    semantic analysis utility routines

 Notes:


 Author:

    GregJen 28-Oct-1993     Created.

 Notes:


 ----------------------------------------------------------------------------*/

#pragma warning ( disable : 4514 4710 )

/****************************************************************************
 *      include files
 ***************************************************************************/

#include "nulldefs.h"
extern  "C"     {
    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>
}
#include "allnodes.hxx"
#include "semantic.hxx"
#include "symtable.hxx"
#include "cmdana.hxx"

/****************************************************************************
 *      local data
 ***************************************************************************/

/****************************************************************************
 *      externs
 ***************************************************************************/

extern SymTable *       pBaseSymTbl;
extern ATTR_SUMMARY     DisallowedAttrs[INTERNAL_NODE_END];
extern BOOL             IsTempName( char * );
extern CMD_ARG *        pCommand;

/****************************************************************************
 *      definitions
 ***************************************************************************/





void
WALK_CTXT::FindImportantPosition(tracked_node & Posn)
{
    WALK_CTXT * pCurCtxt = this;
    WALK_CTXT * pParCtxt;
    node_skl * pNode;

    // walk up until we find one whose PARENT was not important
    while ( (pParCtxt=(WALK_CTXT *)pCurCtxt->GetParentContext()) != 0 &&
            ( pParCtxt->IsImportantPosition() ) )
        {
        pCurCtxt = pParCtxt;
        }

    // continue walking up until we find one with a position
    do
        {
        pNode = pCurCtxt->GetParent();
        pNode->GetPositionInfo( Posn );
        pCurCtxt = (WALK_CTXT *) pCurCtxt->GetParentContext();
        }
    while( !Posn.HasTracking() && pCurCtxt );
}

void
SEM_ANALYSIS_CTXT::CheckAttributes()
{
    ATTR_VECTOR & BadAttrs = DisallowedAttrs[ GetParent()->NodeKind() ];
    ATTR_VECTOR ExcessAttrs;
    ATTR_T Attr;
    node_base_attr * pAttr;
    char * pAttrName;

    MASKED_COPY_ATTR( ExcessAttrs, *(pDownAttrList->GetSummary()), BadAttrs );
    while (!IS_CLEAR_ATTR( ExcessAttrs ) )
        {
        Attr = CLEAR_FIRST_SET_ATTR( ExcessAttrs );
        pAttr = ExtractAttribute( Attr );
        pAttrName = pAttr->GetNodeNameString();

        if (pAttr->IsAcfAttr() )
            AcfError( (acf_attr *)pAttr,
                GetParent(),
                *this,
                INAPPLICABLE_ATTRIBUTE,
                pAttrName);
        else
            SemError( GetParent(), *this, INAPPLICABLE_ATTRIBUTE ,pAttrName);

        }
}

void
SEM_ANALYSIS_CTXT::RejectAttributes()
{
    ATTR_VECTOR ExcessAttrs;
    ATTR_T Attr;
    node_base_attr * pAttr;
    char * pAttrName;

    COPY_ATTR( ExcessAttrs, *(pDownAttrList->GetSummary()));
    while (!IS_CLEAR_ATTR( ExcessAttrs ) )
        {
        Attr = CLEAR_FIRST_SET_ATTR( ExcessAttrs );
        pAttr = ExtractAttribute( Attr );
        pAttrName = pAttr->GetNodeNameString();

        if (pAttr->IsAcfAttr() )
            AcfError( (acf_attr *)pAttr,
                GetParent(),
                *this,
                INAPPLICABLE_ATTRIBUTE,
                pAttrName);
        else
            SemError( GetParent(), *this, INAPPLICABLE_ATTRIBUTE ,pAttrName);

        }
}



//
// resolve forward declarations
//
named_node *
node_forward::ResolveFDecl()
{
    if ( !GetChild() )
        {
        named_node * pRef = pSymTbl->SymSearch( SKey );

        if (pRef && ( pRef != this ) && ( pRef->NodeKind() != NODE_FORWARD ) )
            {
            SetChild( pRef );
            }
        }
    return (named_node *) GetChild();
}

void
node_proc::AddExplicitHandle    (
                                SEM_ANALYSIS_CTXT* pParentCtxt,
                                unsigned int       uParamNumber
                                )
{
    node_skl * pHand;
    node_param * pParm;

    // only add the handle once
    if ( !strcmp( GetChild()->GetSymName(), "IDL_handle" ) )
        return;

    GetBaseTypeNode( &pHand, SIGN_UNDEF, SIZE_UNDEF, TYPE_HANDLE_T, 0 );

    // set up [in] param "IDL_handle", pointing to handle_t, add as first parameter
    pParm = new node_param;
    pParm->SetSymName( "IDL_handle" );
    pParm->SetChild( pHand );
    pParm->SetAttribute( new battr( ATTR_IN ) );

    if ( uParamNumber == 1 )
        {
        AddFirstMember( pParm );
        }
    else
        {
        AddSecondMember( pParm );
        }

    // update the information for the parameter
    pParm->SemanticAnalysis( pParentCtxt );

    fHasExplicitHandle = TRUE;
    fHasAtLeastOneIn = TRUE;
}

void
node_proc::AddFullAsyncHandle   (
                                SEM_ANALYSIS_CTXT*  pParentCtxt,
                                node_skl*           pType,
                                char*               szTypeName
                                )
{
    const char* szNameSuffix    = "_AsyncHandle";
    char*       szFullName      = new char[strlen(GetSymName()) + strlen(szNameSuffix) + 1];

    strcpy(szFullName, GetSymName());
    strcat(szFullName, szNameSuffix);
    node_skl*   pAsyncHandle = new node_async_handle( szTypeName );

    if ( pType )
        {
        pAsyncHandle->SetChild( pType );
        }
    node_param* pParm = new node_param;

    pParm->SetSymName( szFullName );
    pParm->SetChild( pAsyncHandle );

    pParm->SetAttribute( new battr( ATTR_IN ) );
    AddFirstMember( pParm );
    pParm->SemanticAnalysis( pParentCtxt );
    SetHasAsyncHandle();
    pParm->SetIsAsyncHandleParam();
    fHasAtLeastOneIn = TRUE;
}

BOOL
node_base_type::RangeCheck( __int64 Val )
{
    NODE_T Kind = NodeKind();

    switch ( Kind )
        {
        case NODE_BOOLEAN:
            return ( Val >= 0 ) && ( Val <= 1 );
        case NODE_SHORT:
            if ( FInSummary( ATTR_UNSIGNED ) )
                return ( Val >= 0 ) && ( Val <= _UI16_MAX );
            else
                return ( Val >= _I16_MIN ) && ( Val <= _I16_MAX );
        case NODE_BYTE:
            return ( Val >= 0 ) && ( Val <= 255 );
        case NODE_CHAR:
            if ( FInSummary( ATTR_UNSIGNED ) )
                return ( Val >= 0 ) && ( Val <= 255 );
            else if ( FInSummary( ATTR_SIGNED ) )
                return ( Val >= -128 ) && ( Val <= 127 );
            else if ( pCommand->GetCharOption() == CHAR_SIGNED )
                return ( Val >= 0 ) && ( Val <= 255 );
            else
                return ( Val >= -128 ) && ( Val <= 127 );
        case NODE_SMALL:
            if ( FInSummary( ATTR_UNSIGNED ) )
                return ( Val >= 0 ) && ( Val <= 255 );
            else if ( FInSummary( ATTR_SIGNED ) )
                return ( Val >= -128 ) && ( Val <= 127 );
            else if ( pCommand->GetCharOption() == CHAR_UNSIGNED )
                return ( Val >= -128 ) && ( Val <= 127 );
            else
                return ( Val >= 0 ) && ( Val <= 255 );
        case NODE_LONG:
        case NODE_INT32:
        case NODE_INT:
            if ( FInSummary( ATTR_UNSIGNED ) )
                return ( Val >= 0 ) && ( Val <= _UI32_MAX );
            else
                return ( Val >= _I32_MIN ) && ( Val <= _I32_MAX );
        case NODE_INT3264:
            if ( ! pCommand->Is64BitEnv() )
                {
                if ( FInSummary( ATTR_UNSIGNED ) )
                    return ( Val >= 0 ) && ( Val <= _UI32_MAX );
                else
                    return ( Val >= _I32_MIN ) && ( Val <= _I32_MAX );
                }
            // else fall through to 64b integral
        case NODE_HYPER:
        case NODE_INT64:
        case NODE_INT128:
            return TRUE;
        }
    return TRUE;
}


BOOL
node_base_type::IsAssignmentCompatible( node_base_type * pOther )
{
    unsigned long MySize = GetSize();
    unsigned long HisSize = pOther->GetSize();

    // tbd - fill in more cases
    if ( MySize < HisSize )
        return FALSE;

    // unsigned <= signed
    if ( FInSummary( ATTR_UNSIGNED ) &&
            !pOther->FInSummary( ATTR_UNSIGNED ) )
        return FALSE;

    // signed <= unsigned ( only OK if dest is larger )
    if ( pOther->FInSummary( ATTR_UNSIGNED ) &&
            FInSummary( ATTR_SIGNED ) &&
            (MySize <= HisSize) )
        return FALSE;

    if ( ( NodeKind() == NODE_BOOLEAN ) &&
            ( pOther->NodeKind() != NODE_BOOLEAN ) )
        return FALSE;

    return TRUE;
}




char *
GetErrorNamePrefix( node_skl * pNode )
{
    if ( !pNode )
        return NULL;

    switch ( pNode->NodeKind() )
        {
        case NODE_FIELD:
            return " Field ";
        case NODE_STRUCT:
            return " Struct ";
        case NODE_UNION:
            return " Union ";
        case NODE_ENUM:
            return " Enum ";
        case NODE_PARAM:
            return " Parameter ";
        case NODE_PROC:
            return " Procedure ";
        case NODE_INTERFACE:
        case NODE_INTERFACE_REFERENCE:
            return " Interface ";
        case NODE_PIPE_INTERFACE:
            return " Object Pipe ";
        case NODE_DEF:
            return " Type ";
        case NODE_LIBRARY:
            return " Library ";
        case NODE_MODULE:
            return " Module ";
        case NODE_COCLASS:
            return " Coclass ";
        case NODE_DISPINTERFACE:
            return " Dispinterface ";
        default:
            return NULL;
        }
}

#define SUFFIX_SIZE         1000
#define CONTEXT_STR_SIZE    1000

void
GetSemContextString(
    char * pResult,
    node_skl * pNode,
    WALK_CTXT * pCtxt )
{
    node_skl * pBase = NULL;
    node_skl * pParent = NULL;
    node_skl * pUsage = NULL;
    char * pPrefix;

    pResult[0] = '\0';

    if ( !pNode )
        {
        pNode = ( pCtxt ) ? pCtxt->GetParent() : NULL;
        }

    // compute base part and parent part
    while ( pCtxt && !pParent && pNode )
        {
        switch ( pNode->NodeKind() )
            {
            case NODE_FIELD:
            case NODE_PARAM:
                pBase = pNode;
                break;
            case NODE_STRUCT:
            case NODE_UNION:
            case NODE_ENUM:
            case NODE_PROC:
            case NODE_INTERFACE:
            case NODE_PIPE_INTERFACE:
            case NODE_INTERFACE_REFERENCE:
            case NODE_DEF:
            case NODE_LIBRARY:
            case NODE_MODULE:
            case NODE_COCLASS:
            case NODE_DISPINTERFACE:
                pParent = pNode;
                break;
            }

        pCtxt = pCtxt->GetParentContext();
        pNode = ( pCtxt ) ? pCtxt->GetParent() : NULL;
        }

    // compute usage part (param or proc or interface)
    // note that pCtxt is one level up above the current pNode
    pCtxt = pCtxt->GetParentContext();
    while ( pCtxt && ! pUsage )
        {
        switch ( pCtxt->GetParent()->NodeKind() )
            {
            // stop at the top-most level ( child of interface, or proc )
            // therefore highest type/proc/param
            case NODE_INTERFACE:
            case NODE_PIPE_INTERFACE:
            case NODE_PROC:
            case NODE_LIBRARY:
            case NODE_MODULE:
            case NODE_COCLASS:
            case NODE_DISPINTERFACE:
                pUsage = pNode;
                break;
            }

        pNode = ( pCtxt ) ? pCtxt->GetParent() : NULL;
        pCtxt = pCtxt->GetParentContext();
        }


    if ( pBase || pParent || pUsage )
        {
        strcat( pResult, "[");

        if ( pBase )
            {
            pPrefix = GetErrorNamePrefix( pBase );
            if ( pPrefix )
                strcat( pResult, pPrefix );
            if ( !IsTempName( pBase->GetSymName() ) )
                {
                strcat( pResult, "'");
                strcat( pResult, pBase->GetSymName() );
                strcat( pResult, "' ");
                }
            }

        if ( pParent )
            {
            if ( !IsTempName( pParent->GetSymName() ) )
                {
                if ( pBase )
                    strcat(pResult, "of");
                pPrefix = GetErrorNamePrefix( pParent );
                if ( pPrefix )
                    strcat( pResult, pPrefix );
                strcat( pResult, "'");
                strcat( pResult, pParent->GetSymName() );
                strcat( pResult, "' ");
                }
            else
                {
                pPrefix = GetErrorNamePrefix( pBase );
                if ( pPrefix && !pBase )
                    strcat( pResult, pPrefix );
                }
            }

        if ( pUsage )
            {
            strcat( pResult, "(");
            pPrefix = GetErrorNamePrefix( pUsage );
            if ( pPrefix )
                strcat( pResult, pPrefix );
            strcat( pResult, "'");
            strcat( pResult, pUsage->GetSymName() );
            strcat( pResult, "' )");
            }

        strcat( pResult, " ]");
        }
}

void
SemError(
    node_skl * pNode,
    WALK_CTXT & Ctxt,
    STATUS_T ErrNum,
    char * pExtra )
{
    ErrorInfo ErrStats( ErrNum );

    // if the error is not relevant to this compile, return right away
    if ( !ErrStats.IsRelevant() )
        return;

    short CurLen = 1; // for the null byte
    char Suffix[SUFFIX_SIZE];
    char ContextStr[ CONTEXT_STR_SIZE ];
    char * pSuffix = Suffix;
    char * pFile;
    short Line;
    tracked_node Posn((void*)NULL);
    WALK_CTXT * pCurCtxt;
    // extract file and line info, and context info

    pCurCtxt = &Ctxt;

    GetSemContextString( ContextStr, pNode, &Ctxt );
    CurLen = short( CurLen + strlen( ContextStr ) );

    // unless the string is REALLY long, just use stack space
    if ( CurLen + 1 > SUFFIX_SIZE )
        pSuffix = new char [CurLen + 1];

    if ( pExtra || strlen( ContextStr ) )
        {
        strcpy( pSuffix, ": " );
        if ( pExtra )
            strcat( pSuffix, pExtra );

        // make sure pSuffix has a trailing space at this point
        if ( pSuffix[ strlen(pSuffix) - 1 ] != ' ' )
            {
            strcat( pSuffix, " " );
            }

        if ( strlen(ContextStr) )
            {
            strcat( pSuffix, ContextStr );
            }
        }
    else
        strcpy( pSuffix, "" );


    // fetch the file position from the context stack
    Ctxt.FindImportantPosition(Posn);
    Posn.GetLineInfo( pFile, Line);

    ErrStats.ReportError( pFile,
        Line,
        pSuffix );

    // clean up if we had to allocate space
    if ( pSuffix != Suffix )
        delete pSuffix;
}

void
AcfError(
    acf_attr * pAttr,
    node_skl * ,
    WALK_CTXT & ,
    STATUS_T ErrNum,
    char * pExtra )
{
    short CurLen  = 1; // for the null byte
    char Suffix[SUFFIX_SIZE];
    char * pSuffix = Suffix;
    char * pName;
    char * pFile;
    short Line;
    tracked_node Posn((void*)NULL);

    // extract file and line info, and context info


    pName = pAttr->GetNodeNameString();
    // <name>[: <extra>]
    CurLen = short( CurLen + strlen(pName) );
    CurLen = short( CurLen + ( (pExtra) ? strlen(pExtra) + 2 : 0 ) );

    // unless the string is REALLY long, just use stack space
    if ( CurLen + 1 > SUFFIX_SIZE )
        pSuffix = new char [CurLen + 1];

    strcpy( pSuffix, pName );
    if (pExtra)
        {
        strcat( pSuffix, ": " );
        strcat( pSuffix, pExtra );
        }

    // fetch the file position from the context stack
    pAttr->Position.GetLineInfo( pFile, Line);

    RpcError( pFile,
        Line,
        ErrNum,
        pSuffix );

    // clean up if we had to allocate space
    if ( pSuffix != Suffix )
        delete pSuffix;
}

BOOL CIDLIST::AddId(__int64 lId, char * szName)
{
    IDLISTMEM ** pThis = &pHead;
    while (*pThis && (*pThis)->lId < lId)
    {
        pThis = &((*pThis)->pNext);
    }
    if (*pThis && (*pThis)->lId == lId)
    {
        if (_stricmp(szName, (*pThis)->szName))
            return FALSE;
        else
            return TRUE;
    }
    IDLISTMEM * pNew = new IDLISTMEM;
    pNew->lId = lId;
    pNew->pNext = *pThis;
	pNew->szName = szName;
    *pThis = pNew;
    return TRUE;
}

/*
Nishad

bool
node_base_type::IsCompatibleType(
                                TypeSet     set
                                )
{
    bool    fReturnCode = false;
    NODE_T  nodeKind = NodeKind();

    switch ( set )
        {
        case ts_UnsignedFixedPoint:
            fReturnCode =   ( 
                            nodeKind == NODE_INT128 ||
                            nodeKind == NODE_HYPER ||
                            nodeKind == NODE_INT64 ||
                            nodeKind == NODE_INT32 ||
                            nodeKind == NODE_LONG ||
                            nodeKind == NODE_LONGLONG ||
                            nodeKind == NODE_SHORT ||
                            nodeKind == NODE_INT ||
                            nodeKind == NODE_SMALL ||
                            nodeKind == NODE_CHAR ||
                            nodeKind == NODE_BOOLEAN ||
                            nodeKind == NODE_BYTE
                            )
                            &&
                            IsUnsigned();
            break;
        case ts_FixedPoint:
            fReturnCode =   (
                            nodeKind == NODE_INT128 || 
                            nodeKind == NODE_HYPER ||
                            nodeKind == NODE_INT64 ||
                            nodeKind == NODE_INT32 ||
                            nodeKind == NODE_LONG ||
                            nodeKind == NODE_LONGLONG ||
                            nodeKind == NODE_SHORT ||
                            nodeKind == NODE_INT ||
                            nodeKind == NODE_SMALL ||
                            nodeKind == NODE_CHAR ||
                            nodeKind == NODE_BOOLEAN ||
                            nodeKind == NODE_BYTE
                            );
            break;
        case ts_FloatingPoint:
            fReturnCode = ( nodeKind == NODE_FLOAT || 
                            nodeKind == NODE_DOUBLE ||
                            nodeKind == NODE_FLOAT80 ||
                            nodeKind == NODE_FLOAT128 );
            break;
        case ts_Character:
            fReturnCode = ( nodeKind == NODE_CHAR || nodeKind == NODE_BYTE || nodeKind == NODE_WCHAR_T );
            break;
        case ts_String:
            // TBD
            break;
        case ts_Interface:
            // TBD
            break;
        }

    return fReturnCode;
}

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\inc\midl64types.h ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1999-2000 Microsoft Corporation

 Module Name:
    
    midl64types.cxx

 Abstract:

    Definitions for the ndr64 transfer syntax.

 Notes:


 History:

 ----------------------------------------------------------------------------*/

#include "ndr64tkn.h"
class FormatFragment;
class CompositeFormatFragment;
class RootFormatFragment;
class MIDL_NDR64_POINTER_FORMAT;
class MIDL_NDR64_CORRELATION_DESCRIPTOR;
class MIDL_NDR64_TRANSMIT_AS_FORMAT;


extern const char *pNDR64FormatCharNames[];
extern const char *pExprFormatCharNames[];
extern const char *pExprOpFormatCharNames[];

                                        
#define NDR64_FORMATINFO_NAME              "NDR64_MIDL_FORMATINFO"
#define NDR64_FORMATINFO_STRUCT_NAME       "__MIDL_NDR64FORMATINFO"


void OutputParamFlagDescription( CCB *pCCB, const NDR64_PARAM_FLAGS &flags );
void OutputFlagDescriptions(
        ISTREAM     *stream, 
        const void  *pvFlags, 
        int          bytes, 
        const PNAME *description);

#define ASSERT_STACKABLE( type ) C_ASSERT( (sizeof(type) % sizeof(PNDR64_FORMAT)) == 0 );

//+--------------------------------------------------------------------------
//
//  Class:      GenNdr64Format
//
//  Synopsis:   The central object to manage generation of Ndr64 format
//              strings
//
//---------------------------------------------------------------------------

class GenNdr64Format
{
private:

    CCB                       *pCCB;
    RootFormatFragment        *pRoot;
    CompositeFormatFragment   *pCurrent;
    CG_VISITOR                *pVisitor;

protected:

    void GenRangeFormat( CG_BASETYPE *pClass );

    // Pointer layout functions
    FormatFragment *GenSimplePtrLayout(CG_STRUCT *pStruct,
                                       bool bGenHeaderFooter = true,
                                       ulong *pPtrInstances  = NULL );

    FormatFragment *GenSimplePtrLayout( CG_NDR *pArray,
                                        bool bGenHeaderFooter = true,
                                        ulong MemoryOffset = 0);

    FormatFragment *GenCmplxPtrLayout( CG_COMPLEX_STRUCT *pStruct );
    

    // Structure generation helpers
    FormatFragment *GenerateStructureMemberLayout( CG_STRUCT *pStruct, bool bIsDebug );  
    void GenerateSimpleStructure( CG_STRUCT *pStruct,
                                  bool IsConformant );
    void GenerateComplexStruct( CG_COMPLEX_STRUCT *pStruct,
                                                bool IsConformant );

    void GenExtendedProcInfo( CompositeFormatFragment *composite );

    void GenerateUnionArmSelector( 
                    CG_UNION                *pUnion, 
                    CompositeFormatFragment *list );

    // Array/Pointer helper functions
    FormatFragment *GenerateArrayElementInfo( CG_CLASS *pChild );
    void GenerateFixBogusArrayCommon( CG_FIXED_ARRAY *pArray, 
                                      bool IsFullBogus );

    MIDL_NDR64_POINTER_FORMAT* GenQualifiedPtrHdr( CG_QUALIFIED_POINTER *pPointer );
    MIDL_NDR64_POINTER_FORMAT* GenQualifiedArrayPtr( CG_ARRAY *pArray );    
    
    void GenerateNonStringQualifiedPtr( CG_QUALIFIED_POINTER *pPointer );
    FormatFragment * GenerateNonStringQualifiedArrayLayout( CG_NDR *pNdr,
                                                            CompositeFormatFragment *pComp );
    void GenerateNonStringQualifiedArray( CG_ARRAY *pArray );

    // String helpers
        
    void InitStringHeader( CG_NDR *pString, NDR64_STRING_HEADER_FORMAT *pHeader,
                           bool bIsConformant, bool IsSized );

    void GenerateStringArray( CG_ARRAY *pArray, bool bIsSized );

    FormatFragment*
    GenerateCorrelationDescriptor(expr_node               *pSizeExpr );

    void GenInterfacePointer( CG_POINTER *pPtr, BOOL IsConstantIID );

    void GenXmitOrRepAsFormat(
            CG_TYPEDEF                     *pXmitNode,
            MIDL_NDR64_TRANSMIT_AS_FORMAT  *format,
            char                           *pPresentedTypeName,
            node_skl                       *pPresentedType,
            node_skl                       *pTransmittedType );

    NDR64_ALIGNMENT ConvertAlignment( unsigned short Alignment )
    {
        MIDL_ASSERT( Alignment <= 0xFF && Alignment > 0);
        return (NDR64_ALIGNMENT)( Alignment - 1);
    }

public:

    static GenNdr64Format * CreateInstance( CCB *pCCB );
    FormatInfoRef Generate( CG_CLASS *pClass ); 
    void Output( );

    FormatInfoRef ContinueGeneration( 
                    CG_CLASS *pClass, 
                    CompositeFormatFragment *pComposite = NULL );
    FormatInfoRef ContinueGenerationInRoot( CG_CLASS *pClass );

    CCB * GetCCB()
        {
        return pCCB;
        }

    RootFormatFragment      * GetRoot()             { return pRoot; }
    CompositeFormatFragment * GetCurrent()          { return pCurrent; }
    CompositeFormatFragment * SetCurrent( CompositeFormatFragment *pNew )       
        { 
        CompositeFormatFragment *pBak = GetCurrent();
        pCurrent = pNew;
        return pBak;
        }
  
    void Visit( CG_CLASS *pClass);
    void Visit( CG_BASETYPE *pClass );
    void Visit( CG_ENCAPSULATED_STRUCT *pUnion );
    void Visit( CG_PARAM *pParam );
    void Visit( CG_PROC *pProc );
    void Visit( CG_UNION *pUnion );
    void Visit( CG_INTERFACE *pInterface );
    void Visit( CG_CONTEXT_HANDLE *pHandle );
    void Visit( CG_GENERIC_HANDLE *pHandle );
    void Visit( CG_TRANSMIT_AS *pTransmitAs );
    void Visit( CG_REPRESENT_AS *pRepresentAs );
    void Visit( CG_USER_MARSHAL *pUserMarshal );
    void Visit( CG_PIPE *pPipe );
    void Visit( CG_STRING_POINTER *pPointer );

    // Pointer types
    void Visit( CG_POINTER *pPointer );
    void Visit( CG_INTERFACE_POINTER *pPtr )       { GenInterfacePointer(pPtr, TRUE); }
    void Visit( CG_IIDIS_INTERFACE_POINTER *pPtr ) { GenInterfacePointer(pPtr, FALSE); }
    
    void Visit( CG_QUALIFIED_POINTER *pPointer )   { pPointer; MIDL_ASSERT(0); }

    void Visit( CG_SIZE_POINTER *pPointer )        { GenerateNonStringQualifiedPtr( pPointer ); }
    void Visit( CG_LENGTH_POINTER *pPointer )      { GenerateNonStringQualifiedPtr( pPointer ); }
    void Visit( CG_SIZE_LENGTH_POINTER *pPointer ) { GenerateNonStringQualifiedPtr( pPointer ); } 

    // Not supported in 64bit transfer syntax
    void Visit( CG_BYTE_COUNT_POINTER *pPointer ) { pPointer; MIDL_ASSERT(0); }

    // Structure types
    void Visit( CG_STRUCT *pStruct )            { GenerateSimpleStructure( pStruct, false ); }
    void Visit( CG_CONFORMANT_STRUCT *pStruct ) { GenerateSimpleStructure( pStruct, true ); }
    void Visit( CG_COMPLEX_STRUCT *pStruct ) 
        { GenerateComplexStruct( pStruct, false ); } 
    void Visit( CG_CONFORMANT_FULL_COMPLEX_STRUCT *pStruct )
        { GenerateComplexStruct( pStruct, true ); }
    void Visit( CG_CONFORMANT_FORCED_COMPLEX_STRUCT *pStruct )
        { GenerateComplexStruct( pStruct, true ); }

    // Array types    
    void Visit( CG_FIXED_ARRAY *pArray );    
    void Visit( CG_FULL_COMPLEX_FIXED_ARRAY *pArray )
        { GenerateFixBogusArrayCommon( pArray, true ); }
    void Visit( CG_FORCED_COMPLEX_FIXED_ARRAY *pArray )
        { GenerateFixBogusArrayCommon( pArray, false ); }

    void Visit( CG_CONFORMANT_ARRAY *pArray )         { GenerateNonStringQualifiedArray( pArray ); }
    void Visit( CG_VARYING_ARRAY *pArray )            { GenerateNonStringQualifiedArray( pArray ); }
    void Visit( CG_CONFORMANT_VARYING_ARRAY *pArray ) { GenerateNonStringQualifiedArray( pArray ); }

    // String types
    void Visit( CG_STRING_ARRAY *pArray )             { GenerateStringArray( pArray, false ); }
    void Visit( CG_CONFORMANT_STRING_ARRAY *pArray )  { GenerateStringArray( pArray, true );  }
};

//+--------------------------------------------------------------------------
//
//  Class:      FormatFragment
//
//  Synopsis:   Contains a fragment of what will become the format string
//              and has functions to compare and output fragments.
//
//  Notes:      Generally derived types are responsible for setting pClass 
//              field.  The FormatInfo class takes care of the Root, Parent,
//              RefID and the Next field.
//
//---------------------------------------------------------------------------

class FormatFragment
{
protected:

    CompositeFormatFragment *   Parent;             // Parent composite
    FormatFragment          *   Next;               // Next fragment
    FormatFragment          *   Prev;               // Previous fragment
    FormatInfoRef               RefID;              // ID of this fragment
    CG_CLASS                *   pClass;             // CG node for this frag
    FormatFragment          *   pNextOptimized;     // Optimization chain
    FormatFragment          *   pPrevOptimized;

    void Init( CG_CLASS *pNewClass )
        {
        Parent         = NULL;
        Next           = NULL; 
        Prev           = NULL;
        RefID          = 0;
        pClass         = pNewClass;
        pNextOptimized = NULL;
        pPrevOptimized = NULL;
        }

public: 

    friend CompositeFormatFragment;
    friend RootFormatFragment;

    FormatFragment( const FormatFragment & Node ) 
        {
        // When copying, 0 out the Next and ID.
        Init( Node.pClass );
        }

    FormatFragment() 
        { 
        Init(NULL);
        }

    FormatFragment( CG_CLASS *pNewClass ) 
        {
        Init( pNewClass );
        }

    virtual bool IsEqualTo( FormatFragment *frag ) = 0;

    virtual void OutputFragmentType(CCB *pCCB) = 0;
    virtual void OutputFragmentData(CCB *pCCB) = 0;

    virtual const char * GetTypeName() = 0;

    FormatInfoRef GetRefID()
        {
        return RefID;
        }

    CG_CLASS * GetCGNode()
        {
        return pClass;
        }

    void SetParent( CompositeFormatFragment *parent )
        {
        Parent = parent;
        }

    CompositeFormatFragment * GetParent()
        {
        return Parent;
        }

    bool WasOptimizedOut() 
        {
        return NULL != pPrevOptimized;
        }    

    void OutputFormatChar( CCB *pCCB, NDR64_FORMAT_CHAR format, bool nocomma = false )
    {
        ISTREAM *stream = pCCB->GetStream();
        stream->NewLine();
        stream->WriteNumber("0x%x", format);
        if (!nocomma) stream->Write(",");
        stream->Write("    /* ");
        stream->Write(pNDR64FormatCharNames[format]);
        stream->Write(" */");
    }

    void OutputExprFormatChar( CCB *pCCB, NDR64_FORMAT_CHAR format, bool nocomma = false )
    {
        ISTREAM *stream = pCCB->GetStream();
        stream->NewLine();
        stream->WriteNumber("0x%x", format);
        if (!nocomma) stream->Write(",");
        stream->Write("    /* ");
        stream->Write(pExprFormatCharNames[format]);
        stream->Write(" */");       
    }

    void OutputExprOpFormatChar( CCB *pCCB, NDR64_FORMAT_CHAR format, bool nocomma = false )
    {
        ISTREAM *stream = pCCB->GetStream();
        stream->NewLine();
        stream->WriteNumber("0x%x", format);
        if (!nocomma) stream->Write(",");
        stream->Write("    /* ");
        stream->Write(pExprOpFormatCharNames[format]);
        stream->Write(" */");       
    }
        
        
    void OutputFormatInfoRef( CCB *pCCB, FormatInfoRef id, bool nocomma = false )
    {
        ISTREAM *stream = pCCB->GetStream();
        stream->NewLine();
        if ( 0 == id )
            stream->Write( "0" );
        else
            stream->WriteFormat( "&__midl_frag%d", (ulong) (size_t) id );
        if (!nocomma) stream->Write(",");
    }

    void Output( CCB *pCCB, NDR64_UINT8 n, bool nocomma = false )
    {
        ISTREAM *stream = pCCB->GetStream();
        stream->NewLine();
        stream->WriteFormat("(NDR64_UINT8) %u /* 0x%x */", n, n);
        if (!nocomma) stream->Write(",");
    }
    void Output( CCB *pCCB, NDR64_UINT16 n, bool nocomma = false )
    {
        ISTREAM *stream = pCCB->GetStream();
        stream->NewLine();
        stream->WriteFormat("(NDR64_UINT16) %u /* 0x%x */", n, n);
        if (!nocomma) stream->Write(",");
    }
    void Output( CCB *pCCB, NDR64_UINT32 n, bool nocomma = false )
    {
        ISTREAM *stream = pCCB->GetStream();
        stream->NewLine();
        stream->WriteFormat("(NDR64_UINT32) %u /* 0x%x */", n, n);
        if (!nocomma) stream->Write(",");
    }
    void Output( CCB *pCCB, NDR64_UINT64 n, bool nocomma = false )
    {
        ISTREAM *stream = pCCB->GetStream();
        stream->NewLine();
        stream->WriteFormat("(NDR64_UINT64) %I64u /* 0x%I64x */", n, n);
        if (!nocomma) stream->Write(",");
    }
    void Output( CCB *pCCB, NDR64_INT8 n, bool nocomma = false )
    {
        ISTREAM *stream = pCCB->GetStream();
        stream->NewLine();
        stream->WriteFormat("(NDR64_INT8) %d /* 0x%x */", n, n);
        if (!nocomma) stream->Write(",");
    }
    void Output( CCB *pCCB, NDR64_INT16 n, bool nocomma = false )
    {
        ISTREAM *stream = pCCB->GetStream();
        stream->NewLine();
        stream->WriteFormat("(NDR64_INT16) %d /* 0x%x */", n, n);
        if (!nocomma) stream->Write(",");
    }
    void Output( CCB *pCCB, NDR64_INT32 n, bool nocomma = false )
    {
        ISTREAM *stream = pCCB->GetStream();
        stream->NewLine();
        stream->WriteFormat("(NDR64_INT32) %d /* 0x%x */", n, n);
        if (!nocomma) stream->Write(",");
    }
    void Output( CCB *pCCB, NDR64_INT64 n, bool nocomma = false )
    {
        ISTREAM *stream = pCCB->GetStream();
        stream->NewLine();
        stream->WriteFormat("(NDR64_INT64) %I64d /* 0x%I64x */", n, n);
        if (!nocomma) stream->Write(",");
    }
    void Output( CCB *pCCB, StackOffsets &offsets, bool nocomma = false )
    {
        // used only in MIDL_NDR64_BIND_AND_NOTIFY_EXTENSION 

        ISTREAM *stream = pCCB->GetStream();
        stream->NewLine();
        stream->WriteFormat("%d /* 0x%x */", offsets.ia64, offsets.ia64 );
        if (!nocomma) stream->Write(",");
        stream->Write("   /* Stack offset */");
    }

    void OutputMultiType( 
                CCB *           pCCB, 
                const char *    type, 
                NDR64_UINT32    a, 
                char *          pComment,
                bool            nocomma = false)
    {
        ISTREAM *stream = pCCB->GetStream();
        stream->WriteOnNewLine( type );
        stream->WriteFormat("%d /* 0x%x */ ", a, a );
        if (!nocomma) stream->Write(", ");
        stream->WriteFormat( pComment );
    }
    void OutputBool( CCB *pCCB, bool val, bool nocomma = false )
    {
        ISTREAM *stream = pCCB->GetStream();
        stream->NewLine();
        stream->WriteFormat( "%d", val ? 1 : 0 );
        if (!nocomma) stream->Write(",");
    }
    void OutputGuid( CCB *pCCB, const GUID &guid, bool nocomma = false )
    {
        // REVIEW: It would be nice to print the name of the interface
        //         (e.g. IDispatch).  That does require linking to ole32
        //         though.
        ISTREAM *stream = pCCB->GetStream();
        stream->WriteOnNewLine( "{" );
        stream->IndentInc();
        stream->NewLine();
        stream->WriteFormat( "0x%08x,", guid.Data1 );
        stream->NewLine();
        stream->WriteFormat( "0x%04x,", guid.Data2 );
        stream->NewLine();
        stream->WriteFormat( "0x%04x,", guid.Data3 );
        stream->WriteOnNewLine( "{" );
        for (int i = 0; i < 8; i++)
        {
            if (0 != i) stream->Write( ", " );
            stream->WriteFormat( "0x%02x", guid.Data4[i] );
        }
        stream->Write( "}" );
        stream->IndentDec();
        stream->WriteOnNewLine( "}" );
        if (!nocomma) stream->Write(",");
    }

    void OutputDescription( ISTREAM *stream );

    void OutputStructDataStart( 
                    CCB *pCCB, 
                    const char *comment1 = NULL,
                    const char *comment2 = NULL)
    {
        ISTREAM *stream = pCCB->GetStream();
        stream->WriteOnNewLine( "{ " );
        OutputDescription( stream );
        if (comment1)
            {
            stream->Write("      /* ");
            stream->Write( comment1 );
            if (comment2)
                {
                stream->Write(" ");
                stream->Write( comment2 );
                }
            stream->Write( " */" );
            }
        stream->IndentInc();
    }
    void OutputStructDataEnd( CCB *pCCB )
    {
        ISTREAM *stream = pCCB->GetStream();
        stream->IndentDec();
        stream->WriteOnNewLine("}");
    }
    NDR64_ALIGNMENT ConvertAlignment( unsigned short Alignment )
    {
        MIDL_ASSERT( Alignment <= 0xFF && Alignment > 0);
        return (NDR64_ALIGNMENT)( Alignment - 1);
    }
};

//+--------------------------------------------------------------------------
//
//  Class:      CompositeFormatFragment
//
//  Synopsis:   List of fragments and is also a fragment. 
//
//---------------------------------------------------------------------------

class CompositeFormatFragment : public FormatFragment
{
protected:

    FormatFragment *            pHead;
    FormatFragment *            pTail;
    FormatInfoRef               NextRefID;
    const char *                pTypeName;

    void Init( )
    {
        pHead     = NULL;
        pTail     = NULL;
        pTypeName = NULL;
        NextRefID = (FormatInfoRef) 1; // 0 is reserved for an invalid id value
    }

public:

    CompositeFormatFragment( ) : FormatFragment() { Init(); }
    CompositeFormatFragment( CG_CLASS *pClass, const char *pNewTypeName = NULL ) : 
        FormatFragment( pClass )
        { Init(); pTypeName = pNewTypeName; }
    
    virtual bool IsEqualTo( FormatFragment *frag );

    //
    // Container management
    //

    FormatInfoRef   AddFragment( FormatFragment *frag );
    FormatFragment *LookupFragment( CG_CLASS *pClass );

    FormatInfoRef   LookupFragmentID( CG_CLASS *pClass )
                        {
                        FormatFragment *frag = LookupFragment(pClass );
                        return frag ? frag->GetRefID() : INVALID_FRAGMENT_ID;
                        }


    bool            HasClassFragment( CG_CLASS *pClass )
                        {
                        return NULL != LookupFragment( pClass );
                        }

    FormatFragment * GetFirstFragment()
        {
        return pHead;
        }

    // Printing functions
    virtual void OutputFragmentType( CCB *pCCB );
    virtual void OutputFragmentData( CCB *pCCB );
    virtual const char * GetTypeName() { return pTypeName; }

    // Optimization.
    FormatInfoRef OptimizeFragment( FormatFragment *frag );


};



//+--------------------------------------------------------------------------
//
//  Class:      RootFormatFragment
//
//  Synopsis:   Manage a tree of format fragments. Should only be 
//              created for the root.
//
//---------------------------------------------------------------------------

class RootFormatFragment : public CompositeFormatFragment
{
public:

    RootFormatFragment( ) : CompositeFormatFragment( NULL, NDR64_FORMATINFO_STRUCT_NAME )
        {
        }

    void Output( CCB *pCCB );
};



//+--------------------------------------------------------------------------
//
//  Class:      SimpleFormatFragment
//
//  Synopsis:   An intermediary class that brings together a format fragment
//              and some type.  It's also a useful place to hang stuff like
//              generate type handling, etc.
//
//---------------------------------------------------------------------------

template< class T >
class SimpleFormatFragment : public FormatFragment, 
                             public T
{
private:

    void Init() 
        {
        memset( (T*)this, 0, sizeof(T) );
        }

public:

    SimpleFormatFragment( ) : FormatFragment() { Init(); }
    SimpleFormatFragment( CG_CLASS *pClass ) : FormatFragment( pClass ) { Init(); }

    virtual bool IsEqualTo( FormatFragment *frag )
        {
        // Make sure that we're comparing structures of the same type.
        // This should have been checked by the fragment optimizer.
        MIDL_ASSERT( NULL != dynamic_cast<SimpleFormatFragment *> (frag) );
        MIDL_ASSERT( NULL != dynamic_cast<T *>
                           ( dynamic_cast<SimpleFormatFragment *> (frag) ) );

        // Can't compare structures for equality...
//        return *(T*)(SimpleFormatFragment*)frag == *(T*)this ; 

        return (0 == memcmp(
                        (T*) (SimpleFormatFragment*) frag, 
                        (T*) this, 
                        sizeof(T) ) );
        }

    virtual void OutputFragmentType( CCB *pCCB )
        {
        ISTREAM *stream = pCCB->GetStream();
        stream->WriteOnNewLine( GetTypeName() );
        }

    virtual const char * GetTypeName()
        {
        return typeid(T).name();
        }
};



//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_PROC_FORMAT
//
//  Synopsis:   MIDL abstraction of the ndr proc type
//
//---------------------------------------------------------------------------

class MIDL_NDR64_PROC_FORMAT : public SimpleFormatFragment<NDR64_PROC_FORMAT>
{
public:

    // Processor-specific stack sizes.  The field in NDR64_PROC_FORMAT is just
    // a generic placeholder as far as midl is concerned.

    long    ia64StackSize;

    // These fields override the corresponding fields in the NDR_64_PROC_FORMAT
    // structure.  That structure just has integral types to make initializing
    // the structure easier on the C compiler (not to mention more readable)
    // to a human....

    NDR64_PROC_FLAGS    Flags;
    NDR64_RPC_FLAGS     RpcFlags;

public:

    MIDL_NDR64_PROC_FORMAT( CG_PROC *pProc ) :
        SimpleFormatFragment<NDR64_PROC_FORMAT>( pProc )
        {
        }

    void OutputFragmentData( CCB *pCCB )
        {
        OutputStructDataStart( 
                pCCB, 
                "procedure", 
                ((CG_PROC *) pClass)->GetSymName() );
        Output( pCCB, * (NDR64_UINT32 *) &Flags );
        OutputProcFlagDescription( pCCB );
        OutputMultiType( 
                pCCB, 
                "(NDR64_UINT32) ", 
                ia64StackSize,
                " /* Stack size */" );
        Output( pCCB, ConstantClientBufferSize );
        Output( pCCB, ConstantServerBufferSize );
        Output( pCCB, * (NDR64_UINT16 *) &RpcFlags );
        Output( pCCB, FloatDoubleMask );
        Output( pCCB, NumberOfParams );
        Output( pCCB, ExtensionSize, true );
        OutputStructDataEnd( pCCB );
        }

    void OutputProcFlagDescription( CCB *pCCB )
        {
        static const PNAME flag_descrip[32] = 
                    {
                    NULL,       // HandleType1
                    NULL,       // HandleType2
                    NULL,       // HandleType3
                    NULL,       // ProcType1
                    NULL,       // ProcType2
                    NULL,       // ProcType3
                    "IsIntrepreted",    
                    NULL,       // Extra intrepreted bit
                    "[object]",
                    "[async]",
                    "[encode]",
                    "[decode]",
                    "[ptr]",
                    "[enable_allocate]",
                    "pipe",
                    "[comm_status] and/or [fault_status]",
                    NULL,       // Reserved for DCOM
                    "ServerMustSize",
                    "ClientMustSize",
                    "HasReturn",
                    "HasComplexReturn",
                    "ServerCorrelation",
                    "ClientCorrelation",
                    "[notify]",
                    "HasExtensions",
                    NULL,       // Reserved
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL
                    };

        static const PNAME handle_type[8] = 
                    {    
                    "explicit handle",
                    "generic handle",
                    "primitive handle",
                    "auto handle",
                    "callback handle",
                    "no handle",
                    NULL,       // Reserved
                    NULL        // Reserved
                    };


        ISTREAM     *stream = pCCB->GetStream();

        MIDL_ASSERT( NULL != handle_type[Flags.HandleType] );
        stream->WriteFormat( "    /* %s */ ", handle_type[Flags.HandleType]) ;

        OutputFlagDescriptions( stream, &Flags, sizeof(Flags), flag_descrip );
        }
};

//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_BIND_AND_NOTIFY_EXTENSION
//
//  Synopsis:   MIDL abstraction of the ndr proc extenstion containing the
//              notify index and the explicit handle description
//
//---------------------------------------------------------------------------

class MIDL_NDR64_BIND_AND_NOTIFY_EXTENSION 
      : public SimpleFormatFragment<NDR64_BIND_AND_NOTIFY_EXTENSION>
{
public:

    NDR64_BINDINGS  Binding;
    StackOffsets    StackOffsets;

public:

    void OutputFragmentData( CCB *pCCB )
        {
        OutputStructDataStart( pCCB );

        OutputStructDataStart( pCCB, NULL );
        OutputFormatChar( pCCB, Binding.Context.HandleType );
        Output( pCCB, Binding.Context.Flags );
        Output( pCCB, StackOffsets );
        Output( pCCB, Binding.Context.RoutineIndex );
        Output( pCCB, Binding.Context.Ordinal, true );
        OutputStructDataEnd( pCCB );

        pCCB->GetStream()->Write(",");
        Output( pCCB, NotifyIndex, true );
        pCCB->GetStream()->Write("      /* Notify index */");

        OutputStructDataEnd( pCCB );
        }
};



//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_PARAM_FORMAT
//
//  Synopsis:   MIDL abstraction of the ndr param type
//
//---------------------------------------------------------------------------

class MIDL_NDR64_PARAM_FORMAT 
        : public SimpleFormatFragment<NDR64_PARAM_FORMAT>
{
public:

    // Processor-specific stack offsets.

    StackOffsets    StackOffset;

public:

    MIDL_NDR64_PARAM_FORMAT( CG_PARAM *pParam ) :
        SimpleFormatFragment<NDR64_PARAM_FORMAT>( pParam )
        {
        }

    void OutputFlags( CCB *pCCB ) 
        {
        MIDL_ASSERT( 0 == Attributes.Reserved );

        OutputStructDataStart( pCCB );
        
        OutputBool( pCCB, Attributes.MustSize );
        OutputBool( pCCB, Attributes.MustFree );
        OutputBool( pCCB, Attributes.IsPipe );
        OutputBool( pCCB, Attributes.IsIn );
        OutputBool( pCCB, Attributes.IsOut );
        OutputBool( pCCB, Attributes.IsReturn );
        OutputBool( pCCB, Attributes.IsBasetype );
        OutputBool( pCCB, Attributes.IsByValue );
        OutputBool( pCCB, Attributes.IsSimpleRef );
        OutputBool( pCCB, Attributes.IsDontCallFreeInst );
        OutputBool( pCCB, Attributes.SaveForAsyncFinish );
        OutputBool( pCCB, Attributes.IsPartialIgnore );
        OutputBool( pCCB, Attributes.IsForceAllocate ); 
        Output( pCCB, Attributes.Reserved );
        OutputBool( pCCB, Attributes.UseCache, true );
        
        OutputStructDataEnd( pCCB );
        pCCB->GetStream()->Write( ',' );
        
        OutputParamFlagDescription( pCCB, Attributes );
        }        

    void OutputFragmentData( CCB *pCCB )
    {
        MIDL_ASSERT( 0 == Reserved );

        OutputStructDataStart( 
                pCCB,
                "parameter",
                ((CG_PARAM *) pClass)->GetSymName() );

        OutputFormatInfoRef( pCCB, Type );
        OutputFlags( pCCB );
        Output( pCCB, Reserved );
        Output( pCCB, StackOffset );

        OutputStructDataEnd( pCCB );
    }
};



//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_FORMAT_SIMPLE_TYPE
//
//  Synopsis:   MIDL abstraction of NDR64_FORMAT_CHAR
//
//---------------------------------------------------------------------------
extern char * _SimpleTypeName[];

template <class T>
class MIDL_NDR64_FORMAT_SIMPLE_TYPE : public FormatFragment
{

public:

    T  Data;
    int Index;

    MIDL_NDR64_FORMAT_SIMPLE_TYPE(){
        int size = sizeof(T);
        for (Index = 0; size; size = size >>= 1 ) Index++; 
        };
    ~MIDL_NDR64_FORMAT_SIMPLE_TYPE(){};

    MIDL_NDR64_FORMAT_SIMPLE_TYPE( CG_CLASS *pClass, T NewFormatCode ) :
        FormatFragment( pClass ),
        Data( NewFormatCode )
        {
        int size = sizeof(T);
        for (Index = 0; size; size >>= 1 ) Index++; 
        
        }
    MIDL_NDR64_FORMAT_SIMPLE_TYPE( T NewFormatCode ) :
        FormatFragment(),
        Data( NewFormatCode )
        {
        int size = sizeof(T);
        for (Index = 0; size; size >>= 1 ) Index++; 
        }

    virtual void OutputFragmentType( CCB *pCCB )
        {
        ISTREAM *stream = pCCB->GetStream();
        stream->WriteOnNewLine( _SimpleTypeName[Index] );
        }

    virtual void OutputFragmentData(CCB *pCCB)
        {
        Output( pCCB, Data, true );
        }

    virtual bool IsEqualTo( FormatFragment *frag )
        {
        MIDL_ASSERT( typeid(*frag) == typeid( *this) );
        return Data == ((MIDL_NDR64_FORMAT_SIMPLE_TYPE*)frag)->Data;
        }

    virtual const char * GetTypeName()
        {
        return _SimpleTypeName[Index];
        }

};

class MIDL_NDR_FORMAT_UINT32 : public MIDL_NDR64_FORMAT_SIMPLE_TYPE<NDR64_UINT32>
{
};


//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_FORMAT_CHAR
//
//  Synopsis:   MIDL abstraction of NDR64_FORMAT_CHAR
//
//---------------------------------------------------------------------------

class MIDL_NDR64_FORMAT_CHAR : public FormatFragment
{

public:

    NDR64_FORMAT_CHAR  FormatCode;

    MIDL_NDR64_FORMAT_CHAR( CG_CLASS *pClass, NDR64_FORMAT_CHAR NewFormatCode ) :
        FormatFragment( pClass ),
        FormatCode( NewFormatCode )
        {
        }
    MIDL_NDR64_FORMAT_CHAR( NDR64_FORMAT_CHAR NewFormatCode ) :
        FormatFragment(),
        FormatCode( NewFormatCode )
        {
        }
    MIDL_NDR64_FORMAT_CHAR( CG_BASETYPE *pBase ) :
        FormatFragment( pBase ),
        FormatCode( (NDR64_FORMAT_CHAR) pBase->GetNDR64FormatChar() )
        {
        }
    virtual void OutputFragmentType( CCB *pCCB )
        {
        ISTREAM *stream = pCCB->GetStream();
        stream->WriteOnNewLine("NDR64_FORMAT_CHAR");
        }

    virtual void OutputFragmentData(CCB *pCCB)
        {
        OutputFormatChar( pCCB, FormatCode, true );
        }

    virtual bool IsEqualTo( FormatFragment *frag )
        {
        MIDL_ASSERT( typeid(*frag) == typeid( *this) );
        return FormatCode == ((MIDL_NDR64_FORMAT_CHAR*)frag)->FormatCode;
        }

    virtual const char * GetTypeName()
        {
        return "NDR64_FORMAT_CHAR";
        }

};



//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_RANGE_FORMAT
//
//  Synopsis:   MIDL abstraction of the ndr range type
//
//---------------------------------------------------------------------------

class MIDL_NDR64_RANGE_FORMAT : public SimpleFormatFragment<NDR64_RANGE_FORMAT>
{
public:

    MIDL_NDR64_RANGE_FORMAT( CG_BASETYPE *pRangeCG ) :
        SimpleFormatFragment<NDR64_RANGE_FORMAT>( pRangeCG )
        {
        }

    void OutputFragmentData( CCB *pCCB )
        {
        OutputStructDataStart( pCCB );
        OutputFormatChar( pCCB, FormatCode );
        OutputFormatChar( pCCB, RangeType );
        Output( pCCB, Reserved );
        Output( pCCB, MinValue );
        Output( pCCB, MaxValue, true );
        OutputStructDataEnd( pCCB );
        }
};






//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_CONTEXT_HANDLE_FORMAT
//
//  Synopsis:   MIDL abstraction of the ndr context handle type type
//
//---------------------------------------------------------------------------

class MIDL_NDR64_CONTEXT_HANDLE_FORMAT 
        : public SimpleFormatFragment<NDR64_CONTEXT_HANDLE_FORMAT>
{
public:

    NDR64_CONTEXT_HANDLE_FLAGS  ContextFlags;

public:

    MIDL_NDR64_CONTEXT_HANDLE_FORMAT( CG_CONTEXT_HANDLE *pHandle ) :
        SimpleFormatFragment<NDR64_CONTEXT_HANDLE_FORMAT>( pHandle )
        {
        }

    void OutputFragmentData( CCB *pCCB )
        {
        OutputStructDataStart( pCCB );
        OutputFormatChar( pCCB, FormatCode );
        Output( pCCB, * (NDR64_UINT8 *) &ContextFlags );
        Output( pCCB, RundownRoutineIndex );
        Output( pCCB, Ordinal, true );
        OutputStructDataEnd( pCCB );
        }
};



//
//
//  Pointer related items 
//
//

//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_POINTER_FORMAT
//
//  Synopsis:   MIDL abstraction of the ndr pointer type (including 
//              interface pointers)
//
//---------------------------------------------------------------------------

class MIDL_NDR64_POINTER_FORMAT : public SimpleFormatFragment<NDR64_POINTER_FORMAT>
{ 
public:

    
    MIDL_NDR64_POINTER_FORMAT( CG_NDR *pNdr ) :
        SimpleFormatFragment<NDR64_POINTER_FORMAT>( pNdr )
        {
        }

    void OutputFragmentData( CCB *pCCB )
    {
        OutputStructDataStart( pCCB );
        OutputFormatChar( pCCB, FormatCode );
        Output( pCCB, Flags );
        Output( pCCB, Reserved );
        OutputFormatInfoRef( pCCB, Pointee, true );
        OutputStructDataEnd( pCCB );
    }
};

ASSERT_STACKABLE( NDR64_POINTER_FORMAT )

//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_NO_REPEAT_FORMAT
//
//  Synopsis:   MIDL abstraction of NDR64_NO_REPEAT_FORMAT
//
//---------------------------------------------------------------------------

class MIDL_NDR64_NO_REPEAT_FORMAT : 
    public SimpleFormatFragment<NDR64_NO_REPEAT_FORMAT>
{
public:
   MIDL_NDR64_NO_REPEAT_FORMAT( )
      {
      FormatCode    = FC64_NO_REPEAT;
      Flags         = 0;
      Reserved1     = 0;
      Reserved2     = 0;
      }

   void OutputFragmentData( CCB *pCCB )
      {
      OutputStructDataStart( pCCB );
      OutputFormatChar( pCCB, FormatCode );
      Output( pCCB, Flags );
      Output( pCCB, Reserved1 );
      Output( pCCB, Reserved2, true );
      OutputStructDataEnd( pCCB );
      }
};

ASSERT_STACKABLE( NDR64_NO_REPEAT_FORMAT )

//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_REPEAT_FORMAT
//
//  Synopsis:   MIDL abstraction of NDR64_REPEAT_FORMAT
//
//---------------------------------------------------------------------------

class MIDL_NDR64_REPEAT_FORMAT :
    public SimpleFormatFragment<NDR64_REPEAT_FORMAT>
{

public:
    MIDL_NDR64_REPEAT_FORMAT( NDR64_UINT32 MemorySize,
                              NDR64_UINT32 Offset,
                              NDR64_UINT32 Pointers,
                              BOOL         SetCorrMark )
    {
        FormatCode          = FC64_VARIABLE_REPEAT;
        Flags.SetCorrMark   = SetCorrMark;
        Flags.Reserved      = 0;
        Reserved            = 0;
        Increment           = MemorySize;
        OffsetToArray       = Offset;
        NumberOfPointers    = Pointers;
    }

    void OutputFragmentData( CCB *pCCB )
       {
       OutputStructDataStart( pCCB );
       OutputFormatChar( pCCB, FormatCode );

       OutputStructDataStart( pCCB );
       Output( pCCB, Flags.SetCorrMark );
       Output( pCCB, Flags.Reserved, true );
       OutputStructDataEnd( pCCB );
       pCCB->GetStream()->Write(",");


       Output( pCCB, Reserved );
       Output( pCCB, Increment );
       Output( pCCB, OffsetToArray );
       Output( pCCB, NumberOfPointers, true );
       OutputStructDataEnd( pCCB );
       }


};

ASSERT_STACKABLE(NDR64_REPEAT_FORMAT) 

//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_FIXED_REPEAT_FORMAT
//
//  Synopsis:   MIDL abstraction of NDR64_FIXED_REPEAT_FORMAT
//
//---------------------------------------------------------------------------


class MIDL_NDR64_FIXED_REPEAT_FORMAT :
    public SimpleFormatFragment<NDR64_FIXED_REPEAT_FORMAT>

{
public:
    MIDL_NDR64_FIXED_REPEAT_FORMAT( NDR64_UINT32 MemorySize,
                                    NDR64_UINT32 Offset,
                                    NDR64_UINT32 Pointers,
                                    NDR64_UINT32 NumberOfIterations,
                                    BOOL SetCorrMark )
    {
        RepeatFormat.FormatCode         = FC64_FIXED_REPEAT;
        RepeatFormat.Flags.SetCorrMark  = SetCorrMark;
        RepeatFormat.Flags.Reserved     = 0;
        RepeatFormat.Reserved           = 0;
        RepeatFormat.Increment          = MemorySize;
        RepeatFormat.OffsetToArray      = Offset;
        RepeatFormat.NumberOfPointers   = Pointers;
        Iterations                      = NumberOfIterations;
        Reserved                        = 0;
    }

    void OutputFragmentData( CCB *pCCB )
       {
       OutputStructDataStart( pCCB );
       
           OutputStructDataStart( pCCB );
           OutputFormatChar( pCCB, RepeatFormat.FormatCode );

           OutputStructDataStart( pCCB );
           Output( pCCB, RepeatFormat.Flags.SetCorrMark );
           Output( pCCB, RepeatFormat.Flags.Reserved, true );
           OutputStructDataEnd( pCCB );
           pCCB->GetStream()->Write(",");

           Output( pCCB, RepeatFormat.Reserved );
           Output( pCCB, RepeatFormat.Increment );
           Output( pCCB, RepeatFormat.OffsetToArray );
           Output( pCCB, RepeatFormat.NumberOfPointers, true );
           OutputStructDataEnd( pCCB );
           pCCB->GetStream()->Write(",");

       Output( pCCB, Iterations, true );
       OutputStructDataEnd( pCCB );
       }
};

ASSERT_STACKABLE( NDR64_FIXED_REPEAT_FORMAT )

//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_POINTER_INSTANCE_HEADER_FORMAT
//
//  Synopsis:   MIDL abstraction of NDR64_POINTER_INSTANCE_HEADER_FORMAT
//
//---------------------------------------------------------------------------

class MIDL_NDR64_POINTER_INSTANCE_HEADER_FORMAT : 
    public SimpleFormatFragment<NDR64_POINTER_INSTANCE_HEADER_FORMAT>
{
public:
   MIDL_NDR64_POINTER_INSTANCE_HEADER_FORMAT( NDR64_UINT32 OffsetInMemory )
       {
       Offset   = OffsetInMemory;
       Reserved = 0;
       }

   void OutputFragmentData( CCB *pCCB )
       {
       OutputStructDataStart( pCCB );
       Output( pCCB, Offset );
       Output( pCCB, Reserved, true );
       OutputStructDataEnd( pCCB );
       }
};

ASSERT_STACKABLE( NDR64_POINTER_INSTANCE_HEADER_FORMAT )

//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_MIDL_CONSTANT_IID_FORMAT
//
//  Synopsis:   MIDL abstraction of the ndr constant iid interface pointer 
//              type
//
//---------------------------------------------------------------------------

class MIDL_NDR64_CONSTANT_IID_FORMAT 
      : public SimpleFormatFragment<NDR64_CONSTANT_IID_FORMAT>
{ 
public:

    NDR64_IID_FLAGS Flags;

    void OutputFragmentData( CCB *pCCB )
    {
        OutputStructDataStart( pCCB );
        OutputFormatChar( pCCB, FormatCode );
        Output( pCCB, * (NDR64_UINT8 *) &Flags );
        Output( pCCB, Reserved );
        OutputGuid( pCCB, Guid, true );
        OutputStructDataEnd( pCCB );
    }
};

//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_MIDL_IID_FORMAT
//
//  Synopsis:   MIDL abstraction of the ndr iid_is interface pointer 
//              type
//
//---------------------------------------------------------------------------

class MIDL_NDR64_IID_FORMAT 
      : public SimpleFormatFragment<NDR64_IID_FORMAT>
{ 
public:

    NDR64_IID_FLAGS Flags;

    void OutputFragmentData( CCB *pCCB )
    {
        OutputStructDataStart( pCCB );
        OutputFormatChar( pCCB, FormatCode );
        Output( pCCB, * (NDR64_UINT8 *) &Flags );
        Output( pCCB, Reserved );
        OutputFormatInfoRef( pCCB, IIDDescriptor, true );
        OutputStructDataEnd( pCCB );
    }
};


//
//
// Structure related items
//
//

//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_STRUCTURE_UTILITIES
//
//  Synopsis:   Provides utility functions for all the structure types
//
//---------------------------------------------------------------------------


class MIDL_NDR64_STRUCTURE_UTILITIES 
{
public:
    void OutputFlags( FormatFragment *frag, CCB *pCCB, NDR64_STRUCTURE_FLAGS flags, 
                      bool nocomma = false )
    {
        ISTREAM *stream = pCCB->GetStream();
        frag->OutputStructDataStart( pCCB );
        frag->OutputBool( pCCB, flags.HasPointerInfo );
        frag->OutputBool( pCCB, flags.HasMemberInfo );
        frag->OutputBool( pCCB, flags.HasConfArray );
        frag->OutputBool( pCCB, flags.HasOrigMemberInfo );
        frag->OutputBool( pCCB, flags.HasOrigPointerInfo );
        frag->OutputBool( pCCB, flags.Reserved1 );
        frag->OutputBool( pCCB, flags.Reserved2 );
        frag->OutputBool( pCCB, flags.Reserved3, true );
        frag->OutputStructDataEnd( pCCB );
        if (!nocomma) stream->Write(",");
    }
    void ClearFlags( NDR64_STRUCTURE_FLAGS * pFlags )
    {
        memset( pFlags, 0, sizeof( NDR64_STRUCTURE_FLAGS ) );
    }
};

//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_STRUCTURE_HEADER_FORMAT
//
//  Synopsis:   MIDL abstraction of NDR64_STRUCTURE_HEADER_FORMAT
//
//---------------------------------------------------------------------------

class MIDL_NDR64_STRUCTURE_HEADER_FORMAT : 
    public SimpleFormatFragment<NDR64_STRUCTURE_HEADER_FORMAT>,
    protected MIDL_NDR64_STRUCTURE_UTILITIES
{
public:
    MIDL_NDR64_STRUCTURE_HEADER_FORMAT( CG_STRUCT         *pStruct,
                                        bool bHasPointerLayout,
                                        bool bHasMemberLayout ) :
        SimpleFormatFragment<NDR64_STRUCTURE_HEADER_FORMAT> ( pStruct )
    {
        FormatCode              = (NDR64_FORMAT_CHAR)
                                  ( bHasPointerLayout ? FC64_PSTRUCT : FC64_STRUCT );
        Alignment               = ConvertAlignment( pStruct->GetWireAlignment() );

        ClearFlags( &Flags );
        Flags.HasPointerInfo    = bHasPointerLayout;
        Flags.HasMemberInfo     = bHasMemberLayout;

        Reserve                 = 0;
        MemorySize              = pStruct->GetMemorySize();
    }

    void OutputFragmentData( CCB *pCCB )
    {
        OutputStructDataStart( pCCB );
        OutputFormatChar( pCCB, FormatCode );
        Output( pCCB, Alignment );
        OutputFlags( this, pCCB, Flags );
        Output( pCCB, Reserve );
        Output( pCCB, MemorySize, true );
        OutputStructDataEnd( pCCB );
    }

};

ASSERT_STACKABLE( NDR64_STRUCTURE_HEADER_FORMAT )

//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_CONF_STRUCTURE_HEADER_FORMAT
//
//  Synopsis:   MIDL abstraction of NDR64_CONF_VAR_STRUCTURE_HEADER_FORMAT
//
//---------------------------------------------------------------------------

class MIDL_NDR64_CONF_STRUCTURE_HEADER_FORMAT : 
    public SimpleFormatFragment<NDR64_CONF_STRUCTURE_HEADER_FORMAT>,
    protected MIDL_NDR64_STRUCTURE_UTILITIES
{
public:
    MIDL_NDR64_CONF_STRUCTURE_HEADER_FORMAT( CG_CONFORMANT_STRUCT *pStruct,
                                             bool bHasPointerLayout,
                                             bool bHasMemberLayout,
                                             PNDR64_FORMAT ArrayID ) :
       SimpleFormatFragment<NDR64_CONF_STRUCTURE_HEADER_FORMAT> ( pStruct )
    {
       FormatCode = (NDR64_FORMAT_CHAR) 
                    ( bHasPointerLayout ? FC64_CONF_PSTRUCT : FC64_CONF_STRUCT );
        
       Alignment   = ConvertAlignment( pStruct->GetWireAlignment() );
       
       ClearFlags( &Flags );
       Flags.HasPointerInfo        = bHasPointerLayout;
       Flags.HasMemberInfo         = bHasMemberLayout;
       Flags.HasConfArray          = 1;

       Reserve                     = 0;
       MemorySize                  = pStruct->GetMemorySize();
       ArrayDescription            = ArrayID;
    }

    void OutputFragmentData( CCB *pCCB )
    {
        OutputStructDataStart( pCCB );
        OutputFormatChar( pCCB, FormatCode );
        Output( pCCB, Alignment );
        OutputFlags( this, pCCB, Flags );
        Output( pCCB, Reserve );
        Output( pCCB, MemorySize );
        OutputFormatInfoRef( pCCB, ArrayDescription, true );
        OutputStructDataEnd( pCCB );
    }

};

ASSERT_STACKABLE( NDR64_CONF_STRUCTURE_HEADER_FORMAT )

//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_BOGUS_STRUCTURE_HEADER_FORMAT
//
//  Synopsis:   MIDL abstraction of NDR64_BOGUS_STRUCTURE_HEADER_FORMAT
//
//---------------------------------------------------------------------------

class MIDL_NDR64_BOGUS_STRUCTURE_HEADER_FORMAT : 
    public SimpleFormatFragment<NDR64_BOGUS_STRUCTURE_HEADER_FORMAT>,
    protected MIDL_NDR64_STRUCTURE_UTILITIES
{
public:
    MIDL_NDR64_BOGUS_STRUCTURE_HEADER_FORMAT( CG_COMPLEX_STRUCT    *pStruct,
                                              PNDR64_FORMAT        OriginalMemberLayoutID,
                                              PNDR64_FORMAT        OriginalPointerLayoutID,
                                              PNDR64_FORMAT        PointerLayoutID ) :
        SimpleFormatFragment<NDR64_BOGUS_STRUCTURE_HEADER_FORMAT> ( pStruct )
    {
        if ( dynamic_cast<CG_FORCED_COMPLEX_STRUCT*>( pStruct ) != NULL )
            {
            FormatCode = FC64_FORCED_BOGUS_STRUCT; 
            }
        else 
            {
            FormatCode= FC64_BOGUS_STRUCT;
            }
        
        Alignment   = ConvertAlignment( pStruct->GetWireAlignment() );
        
        ClearFlags( &Flags );
        Flags.HasPointerInfo            = ( INVALID_FRAGMENT_ID != PointerLayoutID );
        Flags.HasMemberInfo             = 1;
        Flags.HasOrigPointerInfo        = ( INVALID_FRAGMENT_ID != OriginalPointerLayoutID );
        Flags.HasOrigMemberInfo         = ( INVALID_FRAGMENT_ID != OriginalMemberLayoutID );

        Reserve                         = 0;
        MemorySize                      = pStruct->GetMemorySize();
        OriginalMemberLayout            = OriginalMemberLayoutID;
        OriginalPointerLayout           = OriginalPointerLayoutID;
        PointerLayout                   = PointerLayoutID;

    }
    
    void OutputFragmentData( CCB *pCCB )
    {
        OutputStructDataStart( pCCB );
        OutputFormatChar( pCCB, FormatCode );
        Output( pCCB, Alignment );
        OutputFlags( this, pCCB, Flags );
        Output( pCCB, Reserve );
        Output( pCCB, MemorySize );
        OutputFormatInfoRef( pCCB, OriginalMemberLayout );
        OutputFormatInfoRef( pCCB, OriginalPointerLayout );
        OutputFormatInfoRef( pCCB, PointerLayout );
        OutputStructDataEnd( pCCB );
    }

};

ASSERT_STACKABLE( NDR64_BOGUS_STRUCTURE_HEADER_FORMAT ) 

//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_CONF_BOGUS_STRUCTURE_HEADER_FORMAT
//
//  Synopsis:   MIDL abstraction of NDR64_CONF_BOGUS_STRUCTURE_HEADER_FORMAT
//
//---------------------------------------------------------------------------

class MIDL_NDR64_CONF_BOGUS_STRUCTURE_HEADER_FORMAT : 
    public SimpleFormatFragment<NDR64_CONF_BOGUS_STRUCTURE_HEADER_FORMAT>,
    protected MIDL_NDR64_STRUCTURE_UTILITIES

{
public:
    MIDL_NDR64_CONF_BOGUS_STRUCTURE_HEADER_FORMAT( CG_COMPLEX_STRUCT    *pStruct,
                                                   CG_ARRAY             *pArray,
                                                   PNDR64_FORMAT        ConfArrayID,
                                                   PNDR64_FORMAT        OriginalMemberLayoutID,
                                                   PNDR64_FORMAT        OriginalPointerLayoutID,
                                                   PNDR64_FORMAT        PointerLayoutID ) :
        SimpleFormatFragment<NDR64_CONF_BOGUS_STRUCTURE_HEADER_FORMAT>( pStruct )
    {
        if ( dynamic_cast<CG_CONFORMANT_FULL_COMPLEX_STRUCT*>( pStruct ) != NULL )
            {
            FormatCode = FC64_CONF_BOGUS_STRUCT; 
            }
        else if ( dynamic_cast<CG_CONFORMANT_FORCED_COMPLEX_STRUCT*>( pStruct ) != NULL )
            {
            FormatCode= FC64_FORCED_CONF_BOGUS_STRUCT;
            }
        else 
            {
            MIDL_ASSERT(0);
            }

        Alignment   = ConvertAlignment( pStruct->GetWireAlignment() );
        
        ClearFlags( &Flags );
        Flags.HasPointerInfo            = ( INVALID_FRAGMENT_ID != PointerLayoutID );
        Flags.HasMemberInfo             = 1;
        Flags.HasConfArray              = 1;
        Flags.HasOrigPointerInfo        = ( INVALID_FRAGMENT_ID != OriginalPointerLayoutID );
        Flags.HasOrigMemberInfo         = ( INVALID_FRAGMENT_ID != OriginalMemberLayoutID );
        
        MIDL_ASSERT( pArray->GetDimensions() <= 0xFF );
        Dimensions                      = (NDR64_UINT8)pArray->GetDimensions();
        MemorySize                      = pStruct->GetMemorySize();
        ConfArrayDescription            = ConfArrayID;
        OriginalMemberLayout            = OriginalMemberLayoutID;
        OriginalPointerLayout           = OriginalPointerLayoutID;
        PointerLayout                   = PointerLayoutID;

    }

    void OutputFragmentData( CCB *pCCB )
    {
        OutputStructDataStart( pCCB );        
        OutputFormatChar( pCCB, FormatCode );
        Output( pCCB, Alignment );
        OutputFlags( this, pCCB, Flags );
        Output( pCCB, Dimensions );
        Output( pCCB, MemorySize );
        OutputFormatInfoRef( pCCB, OriginalMemberLayout );
        OutputFormatInfoRef( pCCB, OriginalPointerLayout );
        OutputFormatInfoRef( pCCB, PointerLayout );
        OutputFormatInfoRef( pCCB, ConfArrayDescription );
        OutputStructDataEnd( pCCB );
    }

};

ASSERT_STACKABLE( NDR64_CONF_BOGUS_STRUCTURE_HEADER_FORMAT ) 

//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_SIMPLE_MEMBER_FORMAT
//
//  Synopsis:   MIDL abstraction of NDR64_SIMPLE_MEMBER_FORMAT
//
//---------------------------------------------------------------------------

class MIDL_NDR64_SIMPLE_MEMBER_FORMAT : 
    public SimpleFormatFragment<NDR64_SIMPLE_MEMBER_FORMAT>, 
    protected MIDL_NDR64_STRUCTURE_UTILITIES
{
public:
    
    MIDL_NDR64_SIMPLE_MEMBER_FORMAT( NDR64_FORMAT_CHAR NewFormatCode )
        {
        FormatCode = NewFormatCode;
        Reserved1  = 0;
        Reserved2  = 0;
        Reserved3  = 0;
        }

    void OutputFragmentData( CCB *pCCB )
        {
        OutputStructDataStart( pCCB );
        OutputFormatChar( pCCB, FormatCode );
        Output( pCCB, Reserved1 );
        Output( pCCB, Reserved2 );
        Output( pCCB, Reserved3, true );
        OutputStructDataEnd( pCCB );
        }

};

ASSERT_STACKABLE( NDR64_SIMPLE_MEMBER_FORMAT )

//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_MEMPAD_FORMAT
//
//  Synopsis:   MIDL abstraction of NDR64_MEMPAD_FORMAT
//
//---------------------------------------------------------------------------
class MIDL_NDR64_MEMPAD_FORMAT : 
    public SimpleFormatFragment<NDR64_MEMPAD_FORMAT>,
    protected MIDL_NDR64_STRUCTURE_UTILITIES
{
public:
    MIDL_NDR64_MEMPAD_FORMAT( unsigned long NewMemPad ) 
        {
        MIDL_ASSERT( NewMemPad <= 0xFFFF );
        FormatCode = FC64_STRUCTPADN;
        Reserve1 = 0;
        MemPad = (NDR64_UINT16)NewMemPad;
        Reserved2 = 0;
        }

    void OutputFragmentData(CCB *pCCB)
        {
        OutputStructDataStart( pCCB );
        OutputFormatChar( pCCB, FormatCode );
        Output( pCCB, Reserve1 );
        Output( pCCB, MemPad );
        Output( pCCB, Reserved2, true );
        OutputStructDataEnd( pCCB );
        }
};

ASSERT_STACKABLE( NDR64_MEMPAD_FORMAT )

//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_EMBEDDED_COMPLEX_FORMAT
//
//  Synopsis:   MIDL abstraction of NDR64_EMBEDDED_COMPLEX_FORMAT
//
//---------------------------------------------------------------------------

class MIDL_NDR64_EMBEDDED_COMPLEX_FORMAT : 
    public SimpleFormatFragment<NDR64_EMBEDDED_COMPLEX_FORMAT>,
    protected MIDL_NDR64_STRUCTURE_UTILITIES

{

public:
    MIDL_NDR64_EMBEDDED_COMPLEX_FORMAT( PNDR64_FORMAT TypeID )
        {
        FormatCode = FC64_EMBEDDED_COMPLEX;
        Reserve1 = 0;
        Reserve2 = 0;
        Type     = TypeID;
        }

    void OutputFragmentData( CCB *pCCB)
        {
        OutputStructDataStart( pCCB );
        OutputFormatChar( pCCB, FormatCode );
        Output( pCCB, Reserve1 );
        Output( pCCB, Reserve2 );
        OutputFormatInfoRef( pCCB, Type, true );
        OutputStructDataEnd( pCCB );
        }
};

ASSERT_STACKABLE( NDR64_EMBEDDED_COMPLEX_FORMAT )

//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_BUFFER_ALIGN_FORMAT
//
//  Synopsis:   MIDL abstraction of NDR64_BUFFER_ALIGN_FORMAT
//
//---------------------------------------------------------------------------

class MIDL_NDR64_BUFFER_ALIGN_FORMAT : 
    public SimpleFormatFragment<NDR64_BUFFER_ALIGN_FORMAT>,
    protected MIDL_NDR64_STRUCTURE_UTILITIES

{
public:
    MIDL_NDR64_BUFFER_ALIGN_FORMAT( CG_PAD *pPad ) :
        SimpleFormatFragment<NDR64_BUFFER_ALIGN_FORMAT>( pPad ) 
       {
        // BUGBUG: Redo assert to prevent unref'd var warinng
       //unsigned short NewAlignment = pPad->GetWireAlignment();
       //assert( NewAlignment <= 0xFF && NewAlignment > 0 );
       FormatCode   = FC64_BUFFER_ALIGN;
       Alignment    = ConvertAlignment( pPad->GetWireAlignment() );
       Reserved     = 0;
       Reserved2    = 0;
       }

    void OutputFragmentData( CCB *pCCB )
       {
       OutputStructDataStart( pCCB );
       OutputFormatChar( pCCB, FormatCode );
       Output( pCCB, Alignment );
       Output( pCCB, Reserved );
       Output( pCCB, Reserved2, true );
       OutputStructDataEnd( pCCB );
       }
};

ASSERT_STACKABLE( NDR64_BUFFER_ALIGN_FORMAT )

//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_SIMPLE_REGION_FORMAT
//
//  Synopsis:   MIDL abstraction of NDR64_SIMPLE_REGION_FORMAT
//
//---------------------------------------------------------------------------

class MIDL_NDR64_SIMPLE_REGION_FORMAT : 
    public SimpleFormatFragment<NDR64_SIMPLE_REGION_FORMAT>,
    protected MIDL_NDR64_STRUCTURE_UTILITIES

{
public:
    MIDL_NDR64_SIMPLE_REGION_FORMAT( CG_SIMPLE_REGION *pRegion ) :
        SimpleFormatFragment<NDR64_SIMPLE_REGION_FORMAT>( pRegion )
        {
        FormatCode  = FC64_STRUCT; // BUG BUG, Add new token
        Alignment   = ConvertAlignment( pRegion->GetWireAlignment() );
        MIDL_ASSERT( pRegion->GetWireSize() < 0xFFFF );
        RegionSize  = (NDR64_UINT16)pRegion->GetWireSize();
        Reserved    = 0;
        }

    void OutputFragmentData( CCB *pCCB )
        {
        OutputStructDataStart( pCCB );
        OutputFormatChar( pCCB, FormatCode );
        Output( pCCB, Alignment );
        Output( pCCB, RegionSize );
        Output( pCCB, Reserved, true );
        OutputStructDataEnd( pCCB );
        }
};

ASSERT_STACKABLE( NDR64_SIMPLE_REGION_FORMAT )

//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_ENCAPSULATED_UNION
//
//  Synopsis:   MIDL abstraction of the ndr encapsulated union type
//
//---------------------------------------------------------------------------

class MIDL_NDR64_ENCAPSULATED_UNION
      : public SimpleFormatFragment<NDR64_ENCAPSULATED_UNION>
{
public:

    MIDL_NDR64_ENCAPSULATED_UNION( CG_ENCAPSULATED_STRUCT *pEncapUnion ) :
        SimpleFormatFragment<NDR64_ENCAPSULATED_UNION>( pEncapUnion )
        {
        }

    void OutputFragmentData( CCB *pCCB )
        {
        OutputStructDataStart( pCCB );
        OutputFormatChar( pCCB, FormatCode );
        Output( pCCB, Alignment );
        Output( pCCB, Flags );
        OutputFormatChar( pCCB, SwitchType );
        Output( pCCB, MemoryOffset );
        Output( pCCB, MemorySize );
        Output( pCCB, Reserved, true );
        OutputStructDataEnd( pCCB );
        }
};

ASSERT_STACKABLE( NDR64_ENCAPSULATED_UNION )

//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_NON_ENCAPSULATED_UNION
//
//  Synopsis:   MIDL abstraction of the ndr non encapsulated union type
//
//---------------------------------------------------------------------------

class MIDL_NDR64_NON_ENCAPSULATED_UNION
      : public SimpleFormatFragment<NDR64_NON_ENCAPSULATED_UNION>
{
public:

    MIDL_NDR64_NON_ENCAPSULATED_UNION( CG_UNION *pUnion ) :
        SimpleFormatFragment<NDR64_NON_ENCAPSULATED_UNION>( pUnion )
        {
        }

    void OutputFragmentData( CCB *pCCB )
        {
        OutputStructDataStart( pCCB );
        OutputFormatChar( pCCB, FormatCode );
        Output( pCCB, Alignment );
        Output( pCCB, Flags );
        OutputFormatChar( pCCB, SwitchType );
        Output( pCCB, MemorySize );
        OutputFormatInfoRef( pCCB, Switch );
        Output( pCCB, Reserved, true );
        OutputStructDataEnd( pCCB );
        }
};

ASSERT_STACKABLE( NDR64_NON_ENCAPSULATED_UNION )

//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_UNION_ARM_SELECTOR
//
//  Synopsis:   MIDL abstraction of the ndr arm selector type
//
//---------------------------------------------------------------------------

class MIDL_NDR64_UNION_ARM_SELECTOR
      : public SimpleFormatFragment<NDR64_UNION_ARM_SELECTOR>
{
public:

    void OutputFragmentData( CCB *pCCB )
        {
        OutputStructDataStart( pCCB );
        Output( pCCB, Reserved1 );
        Output( pCCB, Alignment );
        Output( pCCB, Reserved2 );
        Output( pCCB, Arms, true );
        OutputStructDataEnd( pCCB );
        }
};

ASSERT_STACKABLE( NDR64_UNION_ARM_SELECTOR )

//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_UNION_ARM
//
//  Synopsis:   MIDL abstraction of the ndr arm type
//
//---------------------------------------------------------------------------

class MIDL_NDR64_UNION_ARM : public SimpleFormatFragment<NDR64_UNION_ARM>
{
public:

    void OutputFragmentData( CCB *pCCB )
        {
        OutputStructDataStart( pCCB );
        Output( pCCB, CaseValue );
        OutputFormatInfoRef( pCCB, Type );
        Output( pCCB, Reserved, true );
        OutputStructDataEnd( pCCB );
        }
};

ASSERT_STACKABLE( NDR64_UNION_ARM );

//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_DEFAULT_CASE
//
//  Synopsis:   MIDL abstraction of a union's default case
//
//---------------------------------------------------------------------------

class MIDL_NDR64_DEFAULT_CASE : public FormatFragment
{
    PNDR64_FORMAT   Type;

    bool ValidType()
        {
        return ( 0 != Type && (FormatInfoRef) -1 != Type);
        }
public:

    MIDL_NDR64_DEFAULT_CASE( PNDR64_FORMAT _Type )
        {
        Type = _Type;
        }

    void OutputFragmentType( CCB *pCCB )
        {
        pCCB->GetStream()->WriteOnNewLine( GetTypeName() );
        }

    void OutputFragmentData( CCB *pCCB )
        {
        if ( ValidType() )
            OutputFormatInfoRef( pCCB, Type, true );
        else
            Output( pCCB, * (NDR64_UINT32 *) &Type, true );
        }

    bool IsEqualTo( FormatFragment *frag )
        {
        return Type == dynamic_cast<MIDL_NDR64_DEFAULT_CASE *>(frag)->Type;
        }

    const char * GetTypeName()
        {
        return ValidType() ? "PNDR64_FORMAT" : "NDR64_UINT32";
        }
};

//
//
//  Array related data
//
//

//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_ARRAY_UTILITIES
//
//  Synopsis:   Utility functions for arrays strings.
//
//---------------------------------------------------------------------------

class MIDL_NDR64_ARRAY_UTILITIES
{
public:
    void OutputFlags( FormatFragment *frag, CCB *pCCB, NDR64_ARRAY_FLAGS flags, 
                      bool nocomma = false )
    {
        ISTREAM *stream = pCCB->GetStream();
        frag->OutputStructDataStart( pCCB );
        frag->OutputBool( pCCB, flags.HasPointerInfo );
        frag->OutputBool( pCCB, flags.HasElementInfo );
        frag->OutputBool( pCCB, flags.IsMultiDimensional );
        frag->OutputBool( pCCB, flags.IsArrayofStrings );
        frag->OutputBool( pCCB, flags.Reserved1 );
        frag->OutputBool( pCCB, flags.Reserved2 );
        frag->OutputBool( pCCB, flags.Reserved3 );
        frag->OutputBool( pCCB, flags.Reserved4, true );
        frag->OutputStructDataEnd( pCCB );
        if (!nocomma) stream->Write(",");
    }
};

//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_ARRAY_ELEMENT_INFO
//
//  Synopsis:   MIDL abstraction of an array element description
//
//---------------------------------------------------------------------------

class MIDL_NDR64_ARRAY_ELEMENT_INFO :
    public SimpleFormatFragment<NDR64_ARRAY_ELEMENT_INFO>,
    protected MIDL_NDR64_ARRAY_UTILITIES
{
public:
    
    void OutputFragmentData( CCB *pCCB )
    {
        OutputStructDataStart( pCCB );
        Output( pCCB, ElementMemSize );
        OutputFormatInfoRef( pCCB, Element, true );
        OutputStructDataEnd( pCCB );
    }    
};

ASSERT_STACKABLE( NDR64_ARRAY_ELEMENT_INFO )

//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_FIX_ARRAY_HEADER_FORMAT
//
//  Synopsis:   MIDL abstraction of header for a fixed size array
//
//---------------------------------------------------------------------------


class MIDL_NDR64_FIX_ARRAY_HEADER_FORMAT : 
    public SimpleFormatFragment<NDR64_FIX_ARRAY_HEADER_FORMAT>,
    protected MIDL_NDR64_ARRAY_UTILITIES
{
public:
    MIDL_NDR64_FIX_ARRAY_HEADER_FORMAT( CG_FIXED_ARRAY *pArray ) :
        SimpleFormatFragment<NDR64_FIX_ARRAY_HEADER_FORMAT> ( pArray )
    {
    }

    void OutputFragmentData( CCB *pCCB )
    {
        OutputStructDataStart( pCCB );
        OutputFormatChar( pCCB, FormatCode );
        Output( pCCB, Alignment );
        OutputFlags( this, pCCB, Flags );
        Output( pCCB, Reserved );
        Output( pCCB, TotalSize, true );
        OutputStructDataEnd( pCCB );
    }

};

ASSERT_STACKABLE( NDR64_FIX_ARRAY_HEADER_FORMAT )

//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_CONF_ARRAY_HEADER_FORMAT
//
//  Synopsis:   MIDL abstraction of header for a conformant array
//
//---------------------------------------------------------------------------

class MIDL_NDR64_CONF_ARRAY_HEADER_FORMAT : 
    public SimpleFormatFragment<NDR64_CONF_ARRAY_HEADER_FORMAT>,
    protected MIDL_NDR64_ARRAY_UTILITIES
{
public:
    MIDL_NDR64_CONF_ARRAY_HEADER_FORMAT( CG_NDR *pNdr ) :
        SimpleFormatFragment<NDR64_CONF_ARRAY_HEADER_FORMAT> ( pNdr )
    {
    }

    void OutputFragmentData( CCB *pCCB )
    {
        OutputStructDataStart( pCCB );
        OutputFormatChar( pCCB, FormatCode );
        Output( pCCB, Alignment );
        OutputFlags( this, pCCB, Flags );
        Output( pCCB, Reserved );
        Output( pCCB, ElementSize );
        OutputFormatInfoRef( pCCB, ConfDescriptor, true );
        OutputStructDataEnd( pCCB );
    }

};

ASSERT_STACKABLE( NDR64_CONF_ARRAY_HEADER_FORMAT )

//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_VAR_ARRAY_HEADER_FORMAT
//
//  Synopsis:   MIDL abstraction of header for a varying array
//
//---------------------------------------------------------------------------


class MIDL_NDR64_VAR_ARRAY_HEADER_FORMAT : 
public SimpleFormatFragment<NDR64_VAR_ARRAY_HEADER_FORMAT>, 
    protected MIDL_NDR64_ARRAY_UTILITIES
{
public:
    MIDL_NDR64_VAR_ARRAY_HEADER_FORMAT( CG_NDR *pNdr ) :
        SimpleFormatFragment<NDR64_VAR_ARRAY_HEADER_FORMAT> ( pNdr )
    {
    }

    void OutputFragmentData( CCB *pCCB )
    {
        OutputStructDataStart( pCCB );
        OutputFormatChar( pCCB, FormatCode );
        Output( pCCB, Alignment );
        OutputFlags( this, pCCB, Flags );
        Output( pCCB, Reserved );
        Output( pCCB, TotalSize );
        Output( pCCB, ElementSize );
        OutputFormatInfoRef( pCCB, VarDescriptor, true );
        OutputStructDataEnd( pCCB );
    }
};

ASSERT_STACKABLE( NDR64_VAR_ARRAY_HEADER_FORMAT )

//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_CONF_VAR_ARRAY_HEADER_FORMAT
//
//  Synopsis:   MIDL abstraction of header for a conf varying array
//
//---------------------------------------------------------------------------

class MIDL_NDR64_CONF_VAR_ARRAY_HEADER_FORMAT :
    public SimpleFormatFragment<NDR64_CONF_VAR_ARRAY_HEADER_FORMAT>, 
    protected MIDL_NDR64_ARRAY_UTILITIES
{
public:
     
    MIDL_NDR64_CONF_VAR_ARRAY_HEADER_FORMAT( CG_NDR *pNdr ) :
       SimpleFormatFragment<NDR64_CONF_VAR_ARRAY_HEADER_FORMAT> ( pNdr )
    {
    }

    void OutputFragmentData( CCB *pCCB )
    {
        OutputStructDataStart( pCCB );
        OutputFormatChar( pCCB, FormatCode );
        Output( pCCB, Alignment );
        OutputFlags( this, pCCB, Flags );
        Output( pCCB, Reserved );
        Output( pCCB, ElementSize );
        OutputFormatInfoRef( pCCB, ConfDescriptor );
        OutputFormatInfoRef( pCCB, VarDescriptor, true );
        OutputStructDataEnd( pCCB );
    }
};

ASSERT_STACKABLE( NDR64_CONF_VAR_ARRAY_HEADER_FORMAT )

//+--------------------------------------------------------------------------
//
//  Class:      NDR64_BOGUS_ARRAY_HEADER_FORMAT
//
//  Synopsis:   MIDL abstraction of a fixed bogus array
//
//---------------------------------------------------------------------------

class MIDL_NDR64_BOGUS_ARRAY_HEADER_FORMAT : 
    public SimpleFormatFragment<NDR64_BOGUS_ARRAY_HEADER_FORMAT>,
    protected MIDL_NDR64_ARRAY_UTILITIES
{
public:
    MIDL_NDR64_BOGUS_ARRAY_HEADER_FORMAT( CG_NDR *pNdr ) :
        SimpleFormatFragment<NDR64_BOGUS_ARRAY_HEADER_FORMAT> ( pNdr )
    {
    }
    
    void OutputFragmentData( CCB *pCCB )
    {
        OutputStructDataStart( pCCB );
        OutputFormatChar( pCCB, FormatCode );
        Output( pCCB, Alignment );
        OutputFlags( this, pCCB, Flags );
        Output( pCCB, NumberDims );
        Output( pCCB, NumberElements );
        OutputFormatInfoRef( pCCB, Element, true );
        OutputStructDataEnd( pCCB );
    }
};

ASSERT_STACKABLE( NDR64_BOGUS_ARRAY_HEADER_FORMAT )

//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_CONF_VAR_BOGUS_ARRAY_HEADER_FORMAT
//
//  Synopsis:   MIDL abstraction of a bogus array
//
//---------------------------------------------------------------------------

class MIDL_NDR64_CONF_VAR_BOGUS_ARRAY_HEADER_FORMAT : 
    public SimpleFormatFragment<NDR64_CONF_VAR_BOGUS_ARRAY_HEADER_FORMAT>,
    protected MIDL_NDR64_ARRAY_UTILITIES
{
public:
    
    MIDL_NDR64_CONF_VAR_BOGUS_ARRAY_HEADER_FORMAT( CG_NDR *pNdr ) :
        SimpleFormatFragment<NDR64_CONF_VAR_BOGUS_ARRAY_HEADER_FORMAT> ( pNdr )
    {
    }

    void OutputFragmentData( CCB *pCCB )
    {
        OutputStructDataStart( pCCB );

            OutputStructDataStart( pCCB );
            OutputFormatChar( pCCB, FixedArrayFormat.FormatCode );
            Output( pCCB, FixedArrayFormat.Alignment );
            OutputFlags( this, pCCB, FixedArrayFormat.Flags );
            Output( pCCB, FixedArrayFormat.NumberDims );
            Output( pCCB, FixedArrayFormat.NumberElements );
            OutputFormatInfoRef( pCCB, FixedArrayFormat.Element, true );
            OutputStructDataEnd( pCCB );
            pCCB->GetStream()->Write(",");

        OutputFormatInfoRef( pCCB, ConfDescription );
        OutputFormatInfoRef( pCCB, VarDescription );
        OutputFormatInfoRef( pCCB, OffsetDescription, true );
        
        OutputStructDataEnd( pCCB );
        
    }
};

ASSERT_STACKABLE( NDR64_CONF_VAR_BOGUS_ARRAY_HEADER_FORMAT )

//
//
//  String types
//
//

//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_STRING_UTILITIES
//
//  Synopsis:   Utility functions for string format strings
//
//---------------------------------------------------------------------------


class MIDL_NDR64_STRING_UTILITIES
{
public:
    void OutputFlags( FormatFragment *pFrag,
                      CCB *pCCB,
                      NDR64_STRING_FLAGS Flags,
                      bool nocomma = false )
    {
        ISTREAM *stream = pCCB->GetStream();
        pFrag->OutputStructDataStart( pCCB );
        pFrag->OutputBool( pCCB, Flags.IsSized );
        pFrag->OutputBool( pCCB, Flags.Reserved2 );
        pFrag->OutputBool( pCCB, Flags.Reserved3 );
        pFrag->OutputBool( pCCB, Flags.Reserved4 );
        pFrag->OutputBool( pCCB, Flags.Reserved5 );
        pFrag->OutputBool( pCCB, Flags.Reserved6 );
        pFrag->OutputBool( pCCB, Flags.Reserved7 );
        pFrag->OutputBool( pCCB, Flags.Reserved8, true );        
        pFrag->OutputStructDataEnd( pCCB );
        if ( !nocomma ) stream->Write(",");

    }

    void OutputHeader( FormatFragment *pFrag,
                       NDR64_STRING_HEADER_FORMAT *pHeader, 
                       CCB *pCCB,
                       bool nocomma = false )
    {
        ISTREAM *stream = pCCB->GetStream();
        pFrag->OutputStructDataStart( pCCB );
        pFrag->OutputFormatChar( pCCB, pHeader->FormatCode );
        OutputFlags( pFrag, pCCB, pHeader->Flags );
        pFrag->Output( pCCB, pHeader->ElementSize, true );
        pFrag->OutputStructDataEnd( pCCB );
        if ( !nocomma ) stream->Write(",");
    }
};


//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_NON_CONFORMANT_STRING_FORMAT
//
//  Synopsis:   MIDL abstraction of a non conformant string
//
//---------------------------------------------------------------------------


class MIDL_NDR64_NON_CONFORMANT_STRING_FORMAT :
    public SimpleFormatFragment<NDR64_NON_CONFORMANT_STRING_FORMAT>,
    protected MIDL_NDR64_STRING_UTILITIES

{
public:
    MIDL_NDR64_NON_CONFORMANT_STRING_FORMAT( CG_ARRAY *pArray ) :
        SimpleFormatFragment<NDR64_NON_CONFORMANT_STRING_FORMAT>( pArray )
    {   
    }
    void OutputFragmentData( CCB *pCCB )
    {
        OutputStructDataStart( pCCB );
        OutputHeader( this, &Header, pCCB );
        Output( pCCB, TotalSize, true );
        OutputStructDataEnd( pCCB );
    }

};

//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_CONFORMANT_STRING_FORMAT
//
//  Synopsis:   MIDL abstraction of an unsized conformant string
//
//---------------------------------------------------------------------------

class MIDL_NDR64_CONFORMANT_STRING_FORMAT :
    public SimpleFormatFragment<NDR64_CONFORMANT_STRING_FORMAT>,
    protected MIDL_NDR64_STRING_UTILITIES
{
public:
    MIDL_NDR64_CONFORMANT_STRING_FORMAT( CG_NDR *pNdr ) :
        SimpleFormatFragment<NDR64_CONFORMANT_STRING_FORMAT>( pNdr )
    {
    }
    void OutputFragmentData( CCB *pCCB )
    {
        OutputStructDataStart( pCCB );
        OutputHeader( this, &Header, pCCB, true );
        OutputStructDataEnd( pCCB );
    }
};


//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_CONFORMANT_STRING_FORMAT
//
//  Synopsis:   MIDL abstraction of a sized conformant string
//
//---------------------------------------------------------------------------

class MIDL_NDR64_SIZED_CONFORMANT_STRING_FORMAT :
    public SimpleFormatFragment<NDR64_SIZED_CONFORMANT_STRING_FORMAT>,
    protected MIDL_NDR64_STRING_UTILITIES
{
public:
    MIDL_NDR64_SIZED_CONFORMANT_STRING_FORMAT( CG_NDR *pNdr ) :
        SimpleFormatFragment<NDR64_SIZED_CONFORMANT_STRING_FORMAT>( pNdr )
    {
    }
    void OutputFragmentData( CCB *pCCB )
    {
        OutputStructDataStart( pCCB );
        OutputHeader( this, &Header, pCCB );
        OutputFormatInfoRef( pCCB, SizeDescription, true );
        OutputStructDataEnd( pCCB );
    }
};
    
//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_EXPR_OPERATOR
//
//  Synopsis:   MIDL abstraction of expression operator
//
//---------------------------------------------------------------------------

class MIDL_NDR64_EXPR_OPERATOR
      : public SimpleFormatFragment<NDR64_EXPR_OPERATOR>
{
public:
    MIDL_NDR64_EXPR_OPERATOR()
    {
    ExprType = FC_EXPR_OPER;
    Reserved = 0;
    CastType = 0;
    }
    
    void OutputFragmentData( CCB *pCCB )
        {
        OutputStructDataStart( pCCB );
        OutputExprFormatChar( pCCB, ExprType );
        OutputExprOpFormatChar( pCCB,  Operator );
        OutputFormatChar( pCCB, CastType );
        Output( pCCB, * (NDR64_UINT8 *) &Reserved, true );

        OutputStructDataEnd( pCCB );
        }            
};

//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_EXPR_CONST32
//
//  Synopsis:   MIDL abstraction of a correlation descriptor
//
//---------------------------------------------------------------------------

class MIDL_NDR64_EXPR_CONST32
      : public SimpleFormatFragment<NDR64_EXPR_CONST32>
{

public:
    MIDL_NDR64_EXPR_CONST32()
    {
    Reserved = 0;
    ExprType = FC_EXPR_CONST32;
    }
    void OutputFragmentData( CCB *pCCB )
        {
        OutputStructDataStart( pCCB );
        OutputExprFormatChar( pCCB, ExprType );
        OutputFormatChar( pCCB, FC64_INT32 );
        Output( pCCB, * (NDR64_UINT16 *) &Reserved );
        Output( pCCB, * (NDR64_UINT32 *) &ConstValue, true );

        OutputStructDataEnd( pCCB );
        }            
};


//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_EXPR_CONST64
//
//  Synopsis:   MIDL abstraction of a 64bit const.
//             
//  Note:       ConstValue will be aligned at 4 but not necessary at 8.
//
//---------------------------------------------------------------------------

class MIDL_NDR64_EXPR_CONST64
      : public SimpleFormatFragment<NDR64_EXPR_CONST64>
{

public:
    MIDL_NDR64_EXPR_CONST64()
    {
    Reserved = 0;
    ExprType = FC_EXPR_CONST64;
    memset( &ConstValue, 0, sizeof( ConstValue ) );
    }

    void OutputFragmentData( CCB *pCCB )
        {
        OutputStructDataStart( pCCB );
        OutputExprFormatChar( pCCB, ExprType );
        OutputFormatChar( pCCB, FC64_INT64 );
        Output( pCCB, * (NDR64_UINT16 *) &Reserved1 );
        Output( pCCB, * (NDR64_UINT64 *) &ConstValue,true );

        OutputStructDataEnd( pCCB );
        }            
};


//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_EXPR_VAR
//
//  Synopsis:   MIDL abstraction of an expression variable.
//             
//---------------------------------------------------------------------------

class MIDL_NDR64_EXPR_VAR
      : public SimpleFormatFragment<NDR64_EXPR_VAR>
{
public:

    NDR64_UINT32    ia64Offset;
    // true when in proc, meaning this is stack offset; false when this is 
    // structure. 
    // This can be removed if we'll have only one run per processor
    BOOL            fStackOffset;

public:
    MIDL_NDR64_EXPR_VAR()
    {
    ExprType = FC_EXPR_VAR;
    Reserved = 0;
    ia64Offset = 0;
    Offset = 0;
    fStackOffset = FALSE;
    }

    void OutputFragmentData( CCB *pCCB )
        {
        OutputStructDataStart( pCCB );
        OutputExprFormatChar( pCCB, ExprType );
        OutputFormatChar( pCCB, VarType );
        Output( pCCB, * (NDR64_UINT16 *) &Reserved );

        if ( fStackOffset )
            {
            OutputMultiType( 
                    pCCB, 
                    "(NDR64_UINT32) ", 
                    ia64Offset,
                    " /* Offset */",
                    true );
            }
        else
            {
            Output( pCCB, Offset, true );
            }

        OutputStructDataEnd( pCCB );
        }            

    virtual bool IsEqualTo( FormatFragment *_frag )
        {
        MIDL_NDR64_EXPR_VAR *frag = dynamic_cast<MIDL_NDR64_EXPR_VAR *>(_frag);

        MIDL_ASSERT( NULL != frag );

        if ( !SimpleFormatFragment<NDR64_EXPR_VAR>::IsEqualTo( frag ) )
            return false;

        return ( frag->ia64Offset == this->ia64Offset )
               && ( frag->fStackOffset == this->fStackOffset );
        }
};



class MIDL_NDR64_EXPR_NOOP 
        : public SimpleFormatFragment<NDR64_EXPR_NOOP>
{
public:
    MIDL_NDR64_EXPR_NOOP()
        {
        ExprType = FC_EXPR_NOOP;
        Reserved = 0;
        Size = 4;
        }

    void OutputFragmentData( CCB * pCCB)
        {
        OutputStructDataStart( pCCB );
        OutputExprFormatChar( pCCB, ExprType );
        Output( pCCB, * (NDR64_UINT8 *) &Size );
        Output( pCCB, * (NDR64_UINT16 *) &Reserved, true );
        OutputStructDataEnd( pCCB );
        }
};





//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_TRANSMIT_AS_FORMAT
//
//  Synopsis:   MIDL abstraction of the ndr trasmit_as / represent_as type
//
//---------------------------------------------------------------------------

class MIDL_NDR64_TRANSMIT_AS_FORMAT
      : public SimpleFormatFragment<NDR64_TRANSMIT_AS_FORMAT>
{
public:

    NDR64_TRANSMIT_AS_FLAGS Flags;

public:

    MIDL_NDR64_TRANSMIT_AS_FORMAT( CG_TYPEDEF *pTransmitAs ) :
        SimpleFormatFragment<NDR64_TRANSMIT_AS_FORMAT>( pTransmitAs )
        {
        }

    void OutputFragmentData( CCB *pCCB )
        {
        OutputStructDataStart( pCCB );
        OutputFormatChar( pCCB, FormatCode );
        Output( pCCB, * (NDR64_UINT8 *) &Flags );
        Output( pCCB, RoutineIndex );
        Output( pCCB, TransmittedTypeWireAlignment );
        Output( pCCB, MemoryAlignment );
        Output( pCCB, PresentedTypeMemorySize );
        Output( pCCB, TransmittedTypeBufferSize );
        OutputFormatInfoRef( pCCB, TransmittedType, true );
        OutputStructDataEnd( pCCB );
        }
};



//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_TRANSMIT_AS_FORMAT
//
//  Synopsis:   MIDL abstraction of the ndr trasmit_as / represent_as type
//
//  Notes:      transmit_as / represent_as have indentical format info
//              layouts.  We only bother to have a new class so that the
//              type name printing in the stubs is correct.
//
//---------------------------------------------------------------------------

class MIDL_NDR64_REPRESENT_AS_FORMAT : public MIDL_NDR64_TRANSMIT_AS_FORMAT
{
public:

    MIDL_NDR64_REPRESENT_AS_FORMAT( CG_REPRESENT_AS *pRepresentAs ) :
        MIDL_NDR64_TRANSMIT_AS_FORMAT( pRepresentAs )
        {
        }

    virtual const char * GetTypeName()
        {
        return "NDR64_REPRESENT_AS_FORMAT"; // REVIEW: struct _NDR64...
        }
};



//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_USER_MARSHAL_FORMAT
//
//  Synopsis:   MIDL abstraction of the ndr user_marshal type
//
//---------------------------------------------------------------------------

class MIDL_NDR64_USER_MARSHAL_FORMAT
      : public SimpleFormatFragment<NDR64_USER_MARSHAL_FORMAT>
{
public:

    NDR64_USER_MARSHAL_FLAGS Flags;

public:

    MIDL_NDR64_USER_MARSHAL_FORMAT( CG_USER_MARSHAL *pUserMarshal) :
        SimpleFormatFragment<NDR64_USER_MARSHAL_FORMAT>( pUserMarshal )
        {
        }

    void OutputFragmentData( CCB *pCCB )
        {
        OutputStructDataStart( pCCB );
        OutputFormatChar( pCCB, FormatCode );
        Output( pCCB, * (NDR64_UINT8 *) &Flags );
        Output( pCCB, RoutineIndex );
        Output( pCCB, TransmittedTypeWireAlignment );
        Output( pCCB, MemoryAlignment );
        Output( pCCB, UserTypeMemorySize );
        Output( pCCB, TransmittedTypeBufferSize );
        OutputFormatInfoRef( pCCB, TransmittedType, true );
        OutputStructDataEnd( pCCB );
        }
};



//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_PIPE_FORMAT
//
//  Synopsis:   MIDL abstraction of the ndr pipe type
//
//  Notes:      There are two ndr pipe types.  One with ranges and one
//              without.  This class derives from the one with ranges but
//              omits them from the output if they aren't necessary.
//
//---------------------------------------------------------------------------

class MIDL_NDR64_PIPE_FORMAT
      : public SimpleFormatFragment<NDR64_RANGE_PIPE_FORMAT>
{
public:

    NDR64_PIPE_FLAGS Flags;

public:

    MIDL_NDR64_PIPE_FORMAT( CG_PIPE *pPipe) :
        SimpleFormatFragment<NDR64_RANGE_PIPE_FORMAT>( pPipe )
        {
        }

    void OutputFragmentData( CCB *pCCB )
        {
        OutputStructDataStart( pCCB );
        OutputFormatChar( pCCB, FormatCode );
        Output( pCCB, * (NDR64_UINT8 *) &Flags );
        Output( pCCB, Alignment );
        Output( pCCB, Reserved );
        OutputFormatInfoRef( pCCB, Type );
        Output( pCCB, MemorySize );
        Output( pCCB, BufferSize, (bool) !Flags.HasRange );

        if ( Flags.HasRange )
            {
            Output( pCCB, MinValue );
            Output( pCCB, MaxValue, true );
            }
        
        OutputStructDataEnd( pCCB );
        }

    const char * GetTypeName()
        {
        return Flags.HasRange 
                        ? "NDR64_RANGE_PIPE_FORMAT" 
                        : "NDR64_PIPE_FORMAT";
        }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\inc\nulldefs.h ===
// Copyright (c) 1993-1999 Microsoft Corporation

#define _far
#define _near
#define _huge
#define _cdecl
#define _pascal
#define far
#define near
#define huge
#define cdecl
#define pascal
#define _syscall
#define _stdcall
#define _based(x)
#define _segment int
#define volatile
#define __far
#define __near
#define __huge
#define __cdecl
#define __pascal
#define __syscall
#define __based(x)
#define __segment int
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\inc\ndr64tkn.h ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 2000 Microsoft Corporation

Module Name :

    ndr64tkn.h

Abstract :

    This file defines all the tokens for NDR64
    
Author :

    Mike Zoran  mzoran   May 2000.

Revision History :

  ---------------------------------------------------------------------*/

#ifndef __NDR64TKN_H__
#define __NDR64TKN_H__

// Define the 64bit tokens from the token table.

#define NDR64_BEGIN_TABLE \
typedef enum { 

#define NDR64_TABLE_END \
} NDR64_FORMAT_CHARACTER;

#define NDR64_ZERO_ENTRY \
FC64_ZERO = 0x0

#define NDR64_TABLE_ENTRY( number, tokenname, marshal, embeddedmarshall, unmarshall, embeddedunmarshal, buffersize, embeddedbuffersize, memsize, embeddedmemsize, free, embeddedfree, typeflags ) \
, tokenname = number

#define NDR64_SIMPLE_TYPE_TABLE_ENTRY( number, tokenname, simpletypebuffersize, simpletypememorysize ) \
, tokenname = number

#define NDR64_UNUSED_TABLE_ENTRY( number, tokenname ) \
, tokenname = number

#define NDR64_UNUSED_TABLE_ENTRY_NOSYM( number )

#include "tokntbl.h"

#undef NDR64_BEGIN_TABLE
#undef NDR64_TABLE_END
#undef NDR64_ZERO_ENTRY
#undef NDR64_TABLE_ENTRY
#undef NDR64_SIMPLE_TYPE_TABLE_ENTRY
#undef NDR64_UNUSED_TABLE_ENTRY
#undef NDR64_UNUSED_TABLE_ENTRY_NOSYM

#endif // __NDR64TKN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\inc\ndrtypes.h ===
/*++

Copyright (c) 1993-1999 Microsoft Corporation

Module Name:

    ndrtypes.h

Abstract:

    Definitions of new NDR format string types.

Revision History:

    DKays    Sep-1993     Created.

--*/

#ifndef __NDRTYPES_H__
#define __NDRTYPES_H__

#include <limits.h>
#ifdef __cplusplus
extern "C" {
#endif

//
// C_ASSERT() can be used to perform many compile-time assertions:
//            type sizes, field offsets, etc.
//
// An assertion failure results in error C2118: negative subscript.
//

#ifndef C_ASSERT
#define C_ASSERT(e) typedef char __C_ASSERT__[(e)?1:-1]
#endif

//
// We use C compiler constants like _I16_MIN or _UI32_MAX from limits.h
// when we need to check for integral boundaries.

#define UNION_OFFSET16_MIN      -32512 /*0x8100*/

// These are pointer sizes used by the compiler.
// As they we do cross-compilation, they cannot be expressed as sizeof(void*).
// The native pointer sizes used by the NDR engine are defined in ndrp.h.

#define NT64_PTR_SIZE       (8)
#define NT32_PTR_SIZE       (4)
#define NDR64_PTR_WIRE_SIZE (8)
#define NDR32_PTR_WIRE_SIZE (4)
#define SIZEOF_PTR( f64 )   ((f64) ? NT64_PTR_SIZE : NT32_PTR_SIZE )
#define SIZEOF_MEM_PTR()    ( ( pCommand->Is64BitEnv() ) ? NT64_PTR_SIZE : NT32_PTR_SIZE )
#define SIZEOF_WIRE_PTR()   ( ( pCommand->IsNDR64Run() && pCommand->Is64BitEnv() ) ? NDR64_PTR_WIRE_SIZE : NDR32_PTR_WIRE_SIZE )
#define SIZEOF_MEM_INT3264() ( ( pCommand->Is64BitEnv() ) ? 8 : 4 )
#define SIZEOF_WIRE_INT3264() ( ( pCommand->Is64BitEnv() && pCommand->IsNDR64Run() ) ? 8 : 4 )

#define MAX_WIRE_ALIGNMENT  (16)

//
// This macro is used to get a pointer to the type description given a 
// FormatInfoRef
//

//
// Ndr versions.  Versions history is as follows :
//
//      1.1 - Windows NT version 3.5
//      1.1 - Windows NT version 3.51
//      2.0 - Windows NT version 4.0
//               2.0 is switched on for Oi2, user_marshal, pipes.
//      5.0 - Windows NT version 5.0, beta1
//               [message], object pipes, async rpc
//      5.2 - Windows NT version 5.0, beta2
//               /robust, [notify] in -Oicf, [async_uuid()]
//               extensions to the format string descriptors.
//      5.3 - Windows 2000 (NT ver. 5.0), beta3 RC1
//               unlimited number of methods with stubless proxies
//      5.4 - Windows 2000 (NT ver. 5.0), beta3
//              pickling with -Oicf
//
// A stub can not be used with an rpcrt4.dll which has a version number
// less than the version number emitted in the stub.  A stub with a lower
// version number than the rpcrt4.dll must work.
//
// Note that the MIDL version is used to choose between -Oi and -Oi2
// interpreters when NDR version is 2.0 or later as now the compiler
// generates an explicit flag indicating the interpreter flavor.
// The compiler version needs to be 3.0.39 or later for that.
//
// Since MIDL 3.3.126, for object interfaces, we have proc header extensions,
// and async uuid supported. Also since the same version, for object interfaces
// the header has a fixed size as we always generate rpcflags into the header
// and always generate an "autohandle" handle. Hence, the oicf interpreter flags
// and also the extended header is always at the fixed position.
//
// The MIDL version history is as follows.
//
//     Windows NT ver. 3.1   - MIDL 1.0
//     Windows NT ver. 3.5   - MIDL 2.0.72              __midl macro
//     Windows NT ver. 3.51  - MIDL 2.0.102 (internally, .104)   vers. in StubDesc
//     Windows NT ver. 4.0   - MIDL 3.0.44              user_marshal, pipes
//     VC 5.0                - MIDL 3.1.75
//     Windows NT ver. 5.0   - MIDL 3.1.76  IDW
//                           - MIDL 3.2.88  IDW
//                           - MIDL 3.3.110 beta1       async rpc
//                           - MIDL 5.0.140             async_uuid, robust
//                           - MIDL 5.1.164 beta2       midl_pragma warning
//     VC 6.0                - MIDL 5.1.164
//     Windows NT 5.0 saga   - MIDL 5.2.204             64b support
//        now WIndows 2000   - MIDL 5.2.235 beta3       netmon 
//                           - MIDL 5.3.266             midl/midlc exe split
//
// The MIDL version is generated into the stub descriptor starting with
// MIDL ver.2.0.96 (pre NT 3.51 beta 2, Feb 95).
// See ndr20\ndrp.h for constants used for specific versions.
//


#define NDR_MAJOR_VERSION   6UL
#define NDR_MINOR_VERSION   0UL
#define NDR_VERSION         ((NDR_MAJOR_VERSION << 16) | NDR_MINOR_VERSION)

#define NDR_VERSION_1_1     ((1UL << 16) | 1UL)
#define NDR_VERSION_2_0     ((2UL << 16) | 0UL)
#define NDR_VERSION_5_0     ((5UL << 16) | 0UL)
#define NDR_VERSION_5_2     ((5UL << 16) | 2UL)
#define NDR_VERSION_5_3     ((5UL << 16) | 3UL)
#define NDR_VERSION_5_4     ((5UL << 16) | 4UL)
#define NDR_VERSION_6_0     ((6UL << 16) | 0UL)

#define NDR_VERSION_6_0     ((6UL << 16) | 0UL)

//
// NOTE: The following stuff now lives in ndrtoken.h (\com\inc\ndrshared):
//       --Format character definitions
//       --interpreter flags
//       --Conformance and Variance constants
//       --Pointer attributes
//       --Interpreter bit flag structures
//
#include <ndrtoken.h>

#define MAX_INTERPRETER_OUT_SIZE        128
#define MAX_INTERPRETER_PARAM_OUT_SIZE  7 * 8

#define INTERPRETER_THUNK_PARAM_SIZE_THRESHOLD  (sizeof(long) * 32)

#define INTERPRETER_PROC_STACK_FRAME_SIZE_THRESHOLD  ( ( 64 * 1024 ) - 1 )

typedef  struct  _NDR_CORRELATION_FLAGS
    {
    unsigned char   Early    : 1;
    unsigned char   Split    : 1;
    unsigned char   IsIidIs  : 1;
    unsigned char   DontCheck: 1;
    unsigned char   Unused   : 4;
    } NDR_CORRELATION_FLAGS;

#define FC_EARLY_CORRELATION            (unsigned char) 0x01
#define FC_SPLIT_CORRELATION            (unsigned char) 0x02
#define FC_IID_CORRELATION              (unsigned char) 0x04
#define FC_NOCHECK_CORRELATION          (unsigned char) 0x08

#define FC_NDR64_EARLY_CORRELATION      (unsigned char) 0x01
#define FC_NDR64_NOCHECK_CORRELATION    (unsigned char) 0x02

typedef struct _NDR_CS_TAG_FLAGS
    {
    unsigned char   STag                : 1;
    unsigned char   DRTag               : 1;
    unsigned char   RTag                : 1;
    } NDR_CS_TAG_FLAGS;

typedef struct _NDR_CS_TAG_FORMAT
    {
    unsigned char       FormatCode;
    NDR_CS_TAG_FLAGS    Flags;
    unsigned short      TagRoutineIndex;
    } NDR_CS_TAG_FORMAT;

C_ASSERT( 4 == sizeof( NDR_CS_TAG_FORMAT ) );

#define NDR_INVALID_TAG_ROUTINE_INDEX 0x7FFF

typedef struct _NDR_CS_ARRAY_FORMAT
    {
    unsigned char   FormatCode;
    unsigned char   Reserved;
    unsigned short  UserTypeSize;
    unsigned short  CSRoutineIndex;
    unsigned short  Reserved2;
    long            DescriptionOffset;
    } NDR_CS_ARRAY_FORMAT;

C_ASSERT( 12 == sizeof( NDR_CS_ARRAY_FORMAT ) );

typedef enum 
{
XFER_SYNTAX_DCE = 0x8A885D04,
XFER_SYNTAX_NDR64 = 0x71710533,
XFER_SYNTAX_TEST_NDR64 = 0xb4537da9,
//XFER_SYNTAX_NONE,
//XFER_SYNTAX_MAX = XFER_SYNTAX_NONE
} SYNTAX_TYPE;

#define LOW_NIBBLE(Byte)            (((unsigned char)Byte) & 0x0f)
#define HIGH_NIBBLE(Byte)           (((unsigned char)Byte) >> 4)

#define INVALID_RUNDOWN_ROUTINE_INDEX   255

//
// internal bits to represent operation bits
//

#define OPERATION_MAYBE         0x0001
#define OPERATION_BROADCAST     0x0002
#define OPERATION_IDEMPOTENT    0x0004
#define OPERATION_INPUT_SYNC    0x0008
#define OPERATION_ASYNC         0x0010
#define OPERATION_MESSAGE       0x0020

//
//  Transmit as / Represent as flag field flags.
//
//     Lower nibble of this byte has an alignment of the transmitted type.
//     Upper nibble keeps flags.
//

#define PRESENTED_TYPE_NO_FLAG_SET  0x00
#define PRESENTED_TYPE_IS_ARRAY     0x10
#define PRESENTED_TYPE_ALIGN_4      0x20
#define PRESENTED_TYPE_ALIGN_8      0x40

//
//  User marshal flags

#define USER_MARSHAL_POINTER        0xc0  /* unique or ref */

#define USER_MARSHAL_UNIQUE         0x80
#define USER_MARSHAL_REF            0x40
#define USER_MARSHAL_IID            0x20  /* user marshal has optional info */


//
//  Handle flags.
//
//  Lower nibble of this byte may have a generic handle size.
//  Upper nibble keeps flags.  ALL FLAGS ARE NOW USED.
//

#define HANDLE_PARAM_IS_VIA_PTR     0x80
#define HANDLE_PARAM_IS_IN          0x40
#define HANDLE_PARAM_IS_OUT         0x20
#define HANDLE_PARAM_IS_RETURN      0x10

// Lower nibble of this byte may have a generic handle size.
// For context handles, it is used for the following flags.

#define NDR_STRICT_CONTEXT_HANDLE             0x08   /* NT5 */
#define NDR_CONTEXT_HANDLE_NOSERIALIZE        0x04   /* NT5 */
#define NDR_CONTEXT_HANDLE_SERIALIZE          0x02   /* NT5 */
#define NDR_CONTEXT_HANDLE_CANNOT_BE_NULL     0x01   /* NT5 */

//  These are old interpreter flags.
//  Oi and pickling per procedure flags.
//

#define Oi_FULL_PTR_USED                        0x01
#define Oi_RPCSS_ALLOC_USED                     0x02
#define Oi_OBJECT_PROC                          0x04
#define Oi_HAS_RPCFLAGS                         0x08

//
// Bits 5, 6 and 7 are overloaded for use by both pickling and
// non-pickling conditions.
//
// Bit 5 (0x20) is overloaded for object interfaces to distinguish
//       between invocations of V1 and V2 intepreters for proxies and stubs.
//       Note that for backward compatibility the bit is actually set
//       for V1 as it is checked only when NDR version is 2 or later.
//

#define Oi_IGNORE_OBJECT_EXCEPTION_HANDLING     0x10

#define ENCODE_IS_USED                          0x10
#define DECODE_IS_USED                          0x20
#define PICKLING_HAS_COMM_OR_FAULT              0x40    // In -Oicf mode only

#define Oi_HAS_COMM_OR_FAULT                    0x20
#define Oi_OBJ_USE_V2_INTERPRETER               0x20

#define Oi_USE_NEW_INIT_ROUTINES                0x40
#define Oi_UNUSED                               0x80

//  The new -Oicf interpreter flags

#define Oif_HAS_ASYNC_UUID                     0x20

//  Extended new interpreter flags


//
// Union arm description types.
//
#define UNION_CONSECUTIVE_ARMS      1
#define UNION_SMALL_ARMS            2
#define UNION_LARGE_ARMS            3

// Pipe flags
#define FC_BIG_PIPE                 0x80
#define FC_OBJECT_PIPE              0x40
#define FC_PIPE_HAS_RANGE           0x20

//
// Union ex. magic union byte, now short
//
#define MAGIC_UNION_SHORT           ((unsigned short) 0x8000)

//
//      NDR64 related data types / definitions
//

typedef enum _operators
	{
	 OP_START
	,OP_ILLEGAL = OP_START

	,OP_UNARY_START

	,OP_UNARY_ARITHMETIC_START	= OP_UNARY_START
	,OP_UNARY_PLUS 				= OP_UNARY_ARITHMETIC_START
	,OP_UNARY_MINUS
	,OP_UNARY_ARITHMETIC_END

	,OP_UNARY_LOGICAL_START		= OP_UNARY_ARITHMETIC_END
	,OP_UNARY_NOT				= OP_UNARY_LOGICAL_START
	,OP_UNARY_COMPLEMENT
	,OP_UNARY_LOGICAL_END

	,OP_UNARY_INDIRECTION		= OP_UNARY_LOGICAL_END
	,OP_UNARY_CAST
	,OP_UNARY_AND
	,OP_UNARY_SIZEOF
        ,OP_UNARY_ALIGNOF
	,OP_PRE_INCR
	,OP_PRE_DECR
	,OP_POST_INCR
	,OP_POST_DECR

	,OP_UNARY_END

	,OP_BINARY_START			= OP_UNARY_END

	,OP_BINARY_ARITHMETIC_START	= OP_BINARY_START
	,OP_PLUS					= OP_BINARY_ARITHMETIC_START
	,OP_MINUS
	,OP_STAR
	,OP_SLASH
	,OP_MOD
	,OP_BINARY_ARITHMETIC_END

	,OP_BINARY_SHIFT_START		= OP_BINARY_ARITHMETIC_END
	,OP_LEFT_SHIFT				= OP_BINARY_SHIFT_START
	,OP_RIGHT_SHIFT
	,OP_BINARY_SHIFT_END

	,OP_BINARY_RELATIONAL_START	= OP_BINARY_SHIFT_END
	,OP_LESS					= OP_BINARY_RELATIONAL_START
	,OP_LESS_EQUAL
	,OP_GREATER_EQUAL
	,OP_GREATER
	,OP_EQUAL
	,OP_NOT_EQUAL
	,OP_BINARY_RELATIONAL_END

	,OP_BINARY_BITWISE_START	= OP_BINARY_RELATIONAL_END
	,OP_AND						= OP_BINARY_BITWISE_START
	,OP_OR
	,OP_XOR
	,OP_BINARY_BITWISE_END

	,OP_BINARY_LOGICAL_START	= OP_BINARY_BITWISE_END
	,OP_LOGICAL_AND				= OP_BINARY_LOGICAL_START
	,OP_LOGICAL_OR
	,OP_BINARY_LOGICAL_END

	,OP_BINARY_TERNARY_START	= OP_BINARY_LOGICAL_END
	,OP_QM						= OP_BINARY_TERNARY_START
	,OP_COLON
	,OP_BINARY_TERNARY_END

	,OP_BINARY_END				= OP_BINARY_TERNARY_END

	,OP_INTERNAL_START			= OP_BINARY_END
	,OP_FUNCTION
	,OP_PARAM

	,OP_POINTSTO
	,OP_DOT
	,OP_INDEX
	,OP_COMMA
	,OP_STMT
	,OP_ASSIGN

	,OP_ASYNCSPLIT
	,OP_CORR_POINTER
	,OP_CORR_TOP_LEVEL
	
	,OP_END
	} OPERATOR;


typedef enum _NDR64_EXPRESSION_TYPE
{
    EXPR_MAXCOUNT,
    EXPR_ACTUALCOUNT,
    EXPR_OFFSET,
    EXPR_IID,
    EXPR_SWITCHIS
} NDR64_EXPRESSION_TYPE;

#ifdef __cplusplus
}
#endif

#endif  // !__NDRTYPES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\support\freelist.cxx ===
/*************************************************************************/
/**             Copyright(c) Microsoft Corp., 1993-1999                 **/
/*************************************************************************/
/**************************************************************************
File            FreeListMgr.cxx
Title       :Get and Put functions for the MIDL compiler
History     :
    13-Apr-94   GregJen Created from freelist.hxx
**************************************************************************/

#pragma warning ( disable : 4201 )  // Unnamed struct/union
#pragma warning ( disable : 4514 )  // Unreferenced inline function

/************************************************************************* 
 ** includes                                                
 *************************************************************************/

#include "freelist.hxx"
#include <windef.h>         // REVIEW: Just give up and include windows.h?
#include <basetsd.h>

// checked compiler has list checking
#ifndef NDEBUG

// turn on the below flag to get checked freelist
#define LIST_CHECK

#endif

/************************************************************************* 
 ** definitions
 *************************************************************************/

// The user should see allocated memory aligned at LONG_PTR alignment.
// The allocator returns us memory with this alignment so make sure the
// signature preserves it.
typedef LONG_PTR HeapSignature;


#define USED_SIGNATURE( pMgr, pNode )       \
                 ( ((HeapSignature) pMgr) % ((HeapSignature) pNode) )

#define FREE_SIGNATURE( pMgr, pNode )       \
                 ( ((HeapSignature) pMgr) - ((HeapSignature) pNode) )
        
void * 
FreeListMgr::Get (size_t size)
    {
    void *  pEntry;
#ifdef LIST_CHECK
    HeapSignature   *   pSignature;
#endif
 
    /* Count this call (even if it fails).
     */

#ifndef NDEBUG
    GetCount++;
#endif

    /* Make sure the "size" requested is the same as the previous 
     * requests.
     */

    MIDL_ASSERT (size == element_size);

    /* Get an entry from the free-list, if the free-list is not empty */

    if (pHead != NULL)
        {
        pEntry  = pHead;
        pHead   = pHead->next;
#ifdef LIST_CHECK
        // check to make sure the entry is really OK
        // signature is before entry pointer
        // signature of free nodes is ( &mgr - &node )
        // signature of used nodes is ( &mgr % &node )
        pSignature = ((HeapSignature *)pEntry)-1;

        MIDL_ASSERT( *pSignature == FREE_SIGNATURE( this, pEntry ) );

        *pSignature = USED_SIGNATURE( this, pEntry );
        memset( pEntry, 0xB3, size );
#endif
        return (void *) pEntry;
        }

    /* Get it from the allocator, since the free-list is empty */

    else
        {
#ifdef LIST_CHECK
        pSignature  = (HeapSignature *)
                            AllocateOnceNew( size + sizeof( *pSignature ) );
        pEntry  = ( (char *) pSignature ) + sizeof( *pSignature );

        *pSignature = USED_SIGNATURE( this, pEntry );
        memset( pEntry, 0xB2, size );
        return pEntry;
#else
        return AllocateOnceNew(size);
#endif
        }

    } /* Get */

    /*********************************************************************/ 
    // This routine "releases" the given element, by putting it on
    // the free-list for later re-use.  The given element, must be 
    // the same size as the elements provided by the "Get" function.
    /*********************************************************************/ 
        
void    
FreeListMgr::Put (void * pEntry)
    {
#ifdef LIST_CHECK
    HeapSignature   *   pSignature;
#endif
    // Count this call.

#ifndef NDEBUG
    PutCount++;
#endif

    // Put the given element on the head of the free-list.

#ifdef LIST_CHECK
    // check to make sure the entry is really OK
    // signature is before entry pointer
    // signature of free nodes is ( &mgr - &node )
    // signature of used nodes is ( &mgr % &node )
    pSignature = ((HeapSignature *)pEntry)-1;

    MIDL_ASSERT( *pSignature == USED_SIGNATURE( this, pEntry ) );

    *pSignature = FREE_SIGNATURE( this, pEntry );

    memset( pEntry, 0xA1, element_size );
#endif
    ( (FreeListType *) pEntry ) -> next = pHead;
    pHead = (FreeListType *) pEntry;


    }; /* Put */




#ifdef example



// 
// Example of use...
//
// copy the following into a class definition and replace the X's with 
// the name of the class
//

/*********************************************************************/ 
// here is the free list manager for a particular class.  it should
// NOT be inherited unless the derived classes have no extra data members.
// 
// Otherwise, the derived classes should have their own new and delete
// elsewhere.
/*********************************************************************/ 
private:

    static
    FreeListMgr         MyFreeList( sizeof( X ) );
    

public:

/*********************************************************************/ 
// Return a new element of the specified size.
// 
// The FreeListMgr "Get" routine is used, so that the element may be
// retrieved from a free-list, if possible, and extra get-memory calls
// can thus be avoided.  
/*********************************************************************/ 

X *
operator new (size_t size)
    {
    return (MyFreeList.Get (size));
    } 

/*********************************************************************/ 
// Release an element allocated by the "New" routine.
//
/*********************************************************************/ 
void operator delete (X* pX)
    {
    MyFreeList.Put (pX);
    } 

#endif // example
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\typelib\implib.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999.
//
//  File:       implib.cxx
//
//  Contents:   import lib functions
//
//  Classes:    NODE_MANAGER
//
//  Functions:  TypelibError
//              TypeinfoError
//              GetStringFromGuid
//              AddTypeLibraryMembers
//
//  History:    5-02-95   stevebl   Created
//
//----------------------------------------------------------------------------

#pragma warning ( disable : 4514 )

#include "tlcommon.hxx"
#include "tlgen.hxx"
#include "tllist.hxx"
#include "becls.hxx"
#include "walkctxt.hxx"

// Initialize an instance of a type library list.
// This way it will clean itself up as necessary.
CTypeLibraryList gtllist;

extern short ImportLevel;

//+---------------------------------------------------------------------------
//
//  Function:   TypelibError
//
//  Synopsis:   Report generic type library error and exit.
//
//  Arguments:  [szFile] - file associated with the error
//
//  History:    5-02-95   stevebl   Created
//
//----------------------------------------------------------------------------

void TypelibError(char * szFile, HRESULT /* UNREF hr */)
{
    RpcError(NULL, 0, ERR_TYPELIB, szFile);
    exit(ERR_TYPELIB);
}

//+---------------------------------------------------------------------------
//
//  Function:   TypeinfoError
//
//  Synopsis:   Report generic type info error and exit.
//
//  History:    5-02-95   stevebl   Created
//
//----------------------------------------------------------------------------

void TypeinfoError(HRESULT /* UNREF hr */)
{
    RpcError(NULL, 0, ERR_TYPEINFO, NULL);
    exit(ERR_TYPEINFO);
}

//+---------------------------------------------------------------------------
//
//  Function:   AddToGuidString
//
//  Synopsis:   Private helper function for GetStringFromGuid.
//              Adds exactly cch hex characters to the string pch.
//
//  Arguments:  [pch]  - pointer to the next available position in the string
//                       buffer
//              [cch]  - number of characters to add to the string buffer
//              [uVal] - value to be converted to text representation
//
//  History:    5-02-95   stevebl   Created
//
//  Modifies:   pch is advanced by cch characters (i.e. left pointing to the
//              next available position in the buffer).
//
//  Notes:      pch must be large enough to accept the characters.
//              The resulting string is not null terminated.
//
//----------------------------------------------------------------------------

void AddToGuidString(char * &pch, unsigned cch, unsigned long uVal)
{
    char bVal;
    unsigned long uMask = 0xf << ((cch - 1) * 4);
    while (cch)
    {
        bVal = (char)((uVal & uMask) >> ((cch - 1) * 4));
        if (bVal < 10)
            *(pch++) = char( '0' + bVal );
        else
            *(pch++) = char ( 'a' + bVal - 10 );
        uMask >>= 4;
        cch--;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   GetStringFromGuid
//
//  Synopsis:   returns the string representation of a guid
//
//  Arguments:  [g] - guid
//
//  Returns:    pointer to a newly allocated string
//
//  History:    5-02-95   stevebl   Created
//
//  Notes:      It is up to the caller to free the resulting string.
//
//----------------------------------------------------------------------------

char * GetStringFromGuid(GUID &g)
{
    char * sz = new char [37];
    char * pch = sz;
    AddToGuidString(pch, 8, g.Data1);
    *(pch++) = '-';
    AddToGuidString(pch, 4, g.Data2);
    *(pch++) = '-';
    AddToGuidString(pch, 4, g.Data3);
    *(pch++) = '-';
    int i;
    for (i = 0; i < 2; i++)
    {
        AddToGuidString(pch, 2, g.Data4[i]);
    }
    *(pch++) = '-';
    for (; i < 8; i++)
    {
        AddToGuidString(pch, 2, g.Data4[i]);
    }
    *(pch++) = '\0';
    return sz;
}

struct NODE_MANAGER_ELEMENT
{
    ITypeInfo * pti;
    named_node * pskl;
    NODE_MANAGER_ELEMENT * pNext;
};

//+---------------------------------------------------------------------------
//
//  Class:      NODE_MANAGER
//
//  Purpose:    Maintains an ordered list of every ITypeInfo for which a
//              node_skl has been generated.
//
//  Interface:  GetNode -- retrieve a node_skl * from a type library
//
//  History:    5-02-95   stevebl   Created
//
//  Notes:      A client can call GetNode() to get a node_skl * from an
//              ITypeInfo pointer.  If one has previously been generated then
//              the caller will get a pointer to the previously generated
//              node.  Otherwise, GetNode() will call ExpandTI to generate one.
//
//              This class exists as a mechanism to avoid infinite recursion
//              when importing type infos with cyclic type dependencies.
//
//----------------------------------------------------------------------------

class NODE_MANAGER
{
private:
    NODE_MANAGER_ELEMENT * pHead;
    void ExpandTI(named_node * &pNode, ITypeInfo * pti);
    node_skl * GetNodeFromTYPEDESC(TYPEDESC tdesc, ITypeInfo * pti);
    named_node * GetNodeFromVARDESC(VARDESC vdesc, ITypeInfo * pti);
    named_node * GetNodeFromFUNCDESC(FUNCDESC fdesc, ITypeInfo *pti);
    void SetIDLATTRS(named_node * pNode, IDLDESC idldesc);
    void AddMembers(MEMLIST * pNode, TYPEATTR * ptattr, ITypeInfo * pti);
    expr_node * GetValueOfConstant(VARIANT * pVar);
public:
    NODE_MANAGER()
    {
        pHead = NULL;
    }

    ~NODE_MANAGER()
    {
        NODE_MANAGER_ELEMENT * pNext;
        while (pHead)
        {
            pHead->pti->Release();
            pNext = pHead->pNext;
            delete(pHead);
            pHead = pNext;
        };
    }

    node_skl * GetNode(ITypeInfo * pti);

} gNodeManager;

BOOL FAddImportLib(char * szLibraryFileName)
{
    return gtllist.Add(szLibraryFileName);
}

BOOL FIsLibraryName(char * szName)
{
    return (NULL != gtllist.FindLibrary(szName));
}

extern SymTable * pBaseSymTbl;

node_href::~node_href()
{
    if (pTypeInfo)
        ((ITypeInfo *)pTypeInfo)->Release();
}

extern IINFODICT * pInterfaceInfoDict;
char * GenIntfName();

//+---------------------------------------------------------------------------
//
//  Member:     node_href::Resolve
//
//  Synopsis:   Expands a referenced type info into a complete type graph.
//
//  Returns:    Pointer to the expanded typegraph.
//
//  History:    5-02-95   stevebl   Created
//
//----------------------------------------------------------------------------

named_node * node_href::Resolve()
{
    char *          sz;
    named_node * pReturn = (named_node *)GetChild();
    if (!pReturn)
    {
        pInterfaceInfoDict->StartNewInterface();

        // start a dummy interface for intervening stuff
        node_interface * pOuter = new node_interface;
        pOuter->SetSymName( GenIntfName() );
        pOuter->SetFileNode( GetDefiningFile() );
        pInterfaceInfoDict->SetInterfaceNode( pOuter );

        pReturn = (named_node *)gNodeManager.GetNode((ITypeInfo*)pTypeInfo);
        SetChild(pReturn);
        sz = pReturn->GetSymName();
        if ( sz )
            SetSymName(sz);

        pInterfaceInfoDict->EndNewInterface();
    }
    return pReturn;
}

//+---------------------------------------------------------------------------
//
//  Member:     NODE_MANAGER::GetNode
//
//  Synopsis:   Gets a type graph node from a type info pointer.
//
//  Arguments:  [pti] - type info pointer
//
//  Returns:    pointer to the type graph described by the type info
//
//  History:    5-02-95   stevebl   Created
//
//----------------------------------------------------------------------------

node_skl * NODE_MANAGER::GetNode(ITypeInfo * pti)
{
    NODE_MANAGER_ELEMENT ** ppThis = &pHead;
    while (*ppThis && (*ppThis)->pti <= pti)
    {
        if ((*ppThis)->pti == pti)
            return (*ppThis)->pskl;
        ppThis = &((*ppThis)->pNext);
    }
    NODE_MANAGER_ELEMENT * pNew = new NODE_MANAGER_ELEMENT;
    pNew->pti = pti;
    // Make sure no one can release this ITypeInfo pointer out from under us.
    // The corresponding release() occurs in NODE_MANAGER's destructor.
    pti->AddRef();
    // insert the new node into the table
    pNew->pNext = *ppThis;
    *ppThis = pNew;
    // expand the node
    ExpandTI(pNew->pskl, pti);
    ((named_node*)(pNew->pskl))->SetFileNode(pInterfaceInfoDict->GetInterfaceNode()->GetDefiningFile() );
    ((named_node*)(pNew->pskl))->SetDefiningTLB(pInterfaceInfoDict->GetInterfaceNode()->GetDefiningFile() );
    return pNew->pskl;
}

//+---------------------------------------------------------------------------
//
//  Member:     NODE_MANAGER::ExpandTI
//
//  Synopsis:   This is where all the work gets done.
//              Takes a type info pointer and expands it into a type graph.
//
//  Arguments:  [pti] - pointer to the type info
//
//  Returns:    pointer to the type graph
//
//  History:    5-02-95   stevebl   Created
//
//----------------------------------------------------------------------------

void NODE_MANAGER::ExpandTI(named_node * &pNode, ITypeInfo * pti)
{
    TYPEATTR *  ptattr;
    HRESULT     hr;
    BSTR        bstrName;

    pNode = NULL;
    hr = pti->GetTypeAttr(&ptattr);
    pti->GetDocumentation(-1, &bstrName, NULL, NULL, NULL);
    char * szName = TranscribeO2A( bstrName );
    LateBound_SysFreeString(bstrName);
    BOOL fExtractGuid = TRUE;

    switch(ptattr->typekind)
    {
    case TKIND_MODULE:
        pNode = new node_module();
        pNode->SetSymName(szName);
        // Add properties and methods
        AddMembers((MEMLIST *)((node_module *)pNode), ptattr, pti);
        break;

    case TKIND_DISPATCH:
        // The code under the if has never been run due to the bug in the condition.
        // The condition according to the comment below should read as in the next line.
        //
        // if ( ! (ptattr->wTypeFlags & (TYPEFLAG_FOLEAUTOMATION | TYPEFLAG_FDUAL)) )
        //
        // However, fixing the line according to the original intentions brought in 
        // a regression because the code paths have changed.
        // Hence, this has been commented out as a workaround for the VC 5.0 release
        // to force the code to execute like previously.
        //
/*
      if ( 0 == ptattr->wTypeFlags & (TYPEFLAG_FOLEAUTOMATION | TYPEFLAG_FDUAL) )
            {
            pNode = new node_dispinterface();
            pNode->SetSymName(szName);
            // Ignore impltypes, add properties and methods
            AddMembers((MEMLIST *)((node_dispinterface *)pNode), ptattr, pti);
            break;
            }
*/

        // if TYPEFLAG_FOLEAUTOMATION or TYPEFLAG_FDUAL is set,
        // erase it's impltype (which will be IDispatch since it is
        // really a dispinterface) then fall through and treat it as a
        // normal interface

        ptattr->cImplTypes = 0;

        // fall through

    case TKIND_INTERFACE:
        {
            pNode = new node_interface();

            // consider processing all attributes
            if ( ( ptattr->wTypeFlags & ( TYPEFLAG_FOLEAUTOMATION | TYPEFLAG_FDUAL ) ) != 0 )
                {
                ( ( node_interface* ) pNode )->HasOLEAutomation( TRUE );
                }
            pNode->SetSymName(szName);
            // Add impltype as base interface reference
            if (ptattr->cImplTypes)
            {
                ITypeInfo * ptiRef;
                HREFTYPE hrt;
                hr = pti->GetRefTypeOfImplType(0, &hrt);
                hr = pti->GetRefTypeInfo(hrt, &ptiRef);
                if (FAILED(hr))
                {
                    TypeinfoError(hr);
                }
                node_interface_reference * pir =
                    new node_interface_reference((node_interface *)GetNode(ptiRef));
                int implflags;
                hr = pti->GetImplTypeFlags(0, &implflags);
                if (implflags & IMPLTYPEFLAG_FDEFAULT)
                {
                    pir->SetAttribute(ATTR_DEFAULT);
                }
                if (implflags & IMPLTYPEFLAG_FSOURCE)
                {
                    pir->SetAttribute(new node_member_attr(MATTR_SOURCE));
                }
                if (implflags & IMPLTYPEFLAG_FDEFAULTVTABLE)
                {
                    pir->SetAttribute(new node_member_attr(MATTR_DEFAULTVTABLE));
                }
                if (implflags & IMPLTYPEFLAG_FRESTRICTED)
                {
                    pir->SetAttribute(new node_member_attr(MATTR_RESTRICTED));
                }
                ((node_interface *)pNode)->SetMyBaseInterfaceReference(pir);
                ptiRef->Release();
                // NOTE - Multiple inheritance is not supported.
            }
            else
            {
                if (0 == _stricmp(szName, "IUnknown"))
                    ((node_interface *)pNode)->SetValidRootInterface();
            }
            // Add properties and methods as children
            AddMembers((MEMLIST *)((node_interface *)pNode), ptattr, pti);
        }
        break;

    case TKIND_COCLASS:
        pNode = new node_coclass();
        pNode->SetSymName(szName);
        // Add impltypes
        {
            unsigned cImplTypes = ptattr->cImplTypes;
            while (cImplTypes--)
            {
                ITypeInfo * ptiRef;
                HREFTYPE hrt;
                hr = pti->GetRefTypeOfImplType(cImplTypes, &hrt);
                hr = pti->GetRefTypeInfo(hrt, &ptiRef);
                if (FAILED(hr))
                {
                    TypeinfoError(hr);
                }
                node_interface_reference * pir =
                    new node_interface_reference((node_interface *)GetNode(ptiRef));
                int implflags;
                hr = pti->GetImplTypeFlags(cImplTypes, &implflags);
                if (implflags & IMPLTYPEFLAG_FDEFAULT)
                {
                    pir->SetAttribute(ATTR_DEFAULT);
                }
                if (implflags & IMPLTYPEFLAG_FSOURCE)
                {
                    pir->SetAttribute(new node_member_attr(MATTR_SOURCE));
                }
                if (implflags & IMPLTYPEFLAG_FDEFAULTVTABLE)
                {
                    pir->SetAttribute(new node_member_attr(MATTR_DEFAULTVTABLE));
                }
                if (implflags & IMPLTYPEFLAG_FRESTRICTED)
                {
                    pir->SetAttribute(new node_member_attr(MATTR_RESTRICTED));
                }
                ((node_coclass *)pNode)->AddFirstMember(pir);
                ptiRef->Release();
            }
        }
        break;

    case TKIND_ALIAS:
        pNode = new node_def(szName);
        // add the type as a child
        pNode->SetChild(GetNodeFromTYPEDESC(ptattr->tdescAlias, pti));
        pNode->SetAttribute(new node_type_attr(TATTR_PUBLIC));
        fExtractGuid = FALSE;
        break;

    case TKIND_ENUM:
        pNode = new node_enum(szName);
        // add enumeration fields
        AddMembers((MEMLIST *)((node_enum *)pNode), ptattr, pti);
        fExtractGuid = FALSE;
        ( ( node_enum * ) pNode )->SetZeePee( ptattr->cbAlignment );
        break;

    case TKIND_RECORD:
        pNode = new node_struct(szName);
        // add members
        AddMembers((MEMLIST *)((node_struct *)pNode), ptattr, pti);
        fExtractGuid = FALSE;
        ( ( node_struct * ) pNode )->SetZeePee( ptattr->cbAlignment );
        break;

    case TKIND_UNION:
        pNode = new node_union(szName);
        // add members
        AddMembers((MEMLIST *)((node_union *)pNode), ptattr, pti);
        fExtractGuid = FALSE;
        ( ( node_union * ) pNode )->SetZeePee( ptattr->cbAlignment );
        break;

    default:
        MIDL_ASSERT(!"Illegal TKIND");
        break;
    }
    // make sure that all the TYPEDESC flags are preserved
    pNode->SetAttribute(new node_constant_attr(
        new expr_constant(ptattr->wTypeFlags), ATTR_TYPEDESCATTR));
    // and set each individual flag that we know about as of this writing
    if (ptattr->wTypeFlags & TYPEFLAG_FLICENSED)
    {
        pNode->SetAttribute(new node_type_attr(TATTR_LICENSED));
    }
    if (ptattr->wTypeFlags & TYPEFLAG_FAPPOBJECT)
    {
        pNode->SetAttribute(new node_type_attr(TATTR_APPOBJECT));
    }
    if (ptattr->wTypeFlags & TYPEFLAG_FCONTROL)
    {
        pNode->SetAttribute(new node_type_attr(TATTR_CONTROL));
    }
    if (ptattr->wTypeFlags & TYPEFLAG_FDUAL)
    {
        pNode->SetAttribute(new node_type_attr(TATTR_DUAL));
    }
    if (ptattr->wTypeFlags & TYPEFLAG_FPROXY)
    {
        pNode->SetAttribute(new node_type_attr(TATTR_PROXY));
    }
    if (ptattr->wTypeFlags & TYPEFLAG_FNONEXTENSIBLE)
    {
        pNode->SetAttribute(new node_type_attr(TATTR_NONEXTENSIBLE));
    }
    if (ptattr->wTypeFlags & TYPEFLAG_FOLEAUTOMATION)
    {
        pNode->SetAttribute(new node_type_attr(TATTR_OLEAUTOMATION));
    }
    if (ptattr->wTypeFlags & TYPEFLAG_FRESTRICTED)
    {
        pNode->SetAttribute(new node_member_attr(MATTR_RESTRICTED));
    }
    if (ptattr->wTypeFlags & TYPEFLAG_FPREDECLID)
    {
        pNode->SetAttribute(new node_member_attr(MATTR_PREDECLID));
    }
    if (ptattr->wTypeFlags & TYPEFLAG_FHIDDEN)
    {
        pNode->SetAttribute(ATTR_HIDDEN);
    }
    if (fExtractGuid)
    {
        char * szGuid = GetStringFromGuid(ptattr->guid);
        pNode->SetAttribute(new node_guid(szGuid));
    }
    pti->ReleaseTypeAttr(ptattr);
}

//+---------------------------------------------------------------------------
//
//  Member:     NODE_MANAGER::GetNodeFromTYPEDESC
//
//  Synopsis:   Returns part of a type graph from a TYPEDESC structure.
//
//  Arguments:  [tdesc] - the TYPEDESC
//              [pti]   - the type info from which the TYPEDESC was retrieved
//
//  Returns:    type graph node
//
//  History:    5-02-95   stevebl   Created
//
//  Notes:      There are currently a couple of problem base types:
//              VT_CY, VT_BSTR, VT_VARIANT, VT_DISPATCH, and VT_UNKNOWN.
//
//              These types are currently expanded by looking them up in the
//              global symbol table.  This works because currently oaidl.idl
//              is always imported when an ODL library statement is
//              ecountered.  It would be nice to be able to remove our
//              dependancy on oaidl.idl but before we can do that, we need to
//              reimplement this code to expand these types in another way.
//              (NOTE that because these are BASE TYPES in ODL, there is no
//              way to place their definitions in a type library.  This means
//              that it is not sufficient to simply get their definitions
//              from some standard type library such as STDLIB.TLB.)
//
//----------------------------------------------------------------------------

node_skl * NODE_MANAGER::GetNodeFromTYPEDESC(TYPEDESC tdesc, ITypeInfo * pti)
{
    node_skl * pReturn = NULL;
    switch (tdesc.vt)
    {
    // base types
    case VT_I2:
        pReturn = new node_base_type(NODE_SHORT, ATTR_SIGNED);
        ((named_node *)pReturn)->SetSymName("short");
        break;
    case VT_I4:
        pReturn = new node_base_type(NODE_LONG, ATTR_SIGNED);
        ((named_node *)pReturn)->SetSymName("long");
        break;
    case VT_R4:
        pReturn = new node_base_type(NODE_FLOAT, ATTR_NONE);
        ((named_node *)pReturn)->SetSymName("float");
        break;
    case VT_R8:
        pReturn = new node_base_type(NODE_DOUBLE, ATTR_NONE);
        ((named_node *)pReturn)->SetSymName("double");
        break;
    case VT_I1:
        pReturn = new node_base_type(NODE_CHAR, ATTR_SIGNED);
        ((named_node *)pReturn)->SetSymName("char");
        break;
    case VT_UI1:
        pReturn = new node_base_type(NODE_CHAR, ATTR_UNSIGNED);
        ((named_node *)pReturn)->SetSymName("char");
        break;
    case VT_UI2:
        pReturn = new node_base_type(NODE_SHORT, ATTR_UNSIGNED);
        ((named_node *)pReturn)->SetSymName("short");
        break;
    case VT_UI4:
        pReturn = new node_base_type(NODE_LONG, ATTR_UNSIGNED);
        ((named_node *)pReturn)->SetSymName("long");
        break;
    case VT_I8:
        pReturn = new node_base_type(NODE_INT64, ATTR_SIGNED);
        ((named_node *)pReturn)->SetSymName("int64");
        break;
    case VT_UI8:
        pReturn = new node_base_type(NODE_INT64, ATTR_UNSIGNED);
        ((named_node *)pReturn)->SetSymName("int64");
        break;
    case VT_INT:
        pReturn = new node_base_type(NODE_INT, ATTR_SIGNED);
        ((named_node *)pReturn)->SetSymName("INT");
        break;
    case VT_UINT:
        pReturn = new node_base_type(NODE_INT, ATTR_UNSIGNED);
        ((named_node *)pReturn)->SetSymName("UINT");
        break;
    case VT_VOID:
        pReturn = new node_base_type(NODE_VOID, ATTR_NONE);
        ((named_node *)pReturn)->SetSymName("void");
        break;
    case VT_BOOL:
        pReturn = new node_base_type(NODE_BOOLEAN, ATTR_NONE);
        ((named_node *)pReturn)->SetSymName("BOOLEAN");
        break;
    // simple ODL base types (not base types in IDL)
    case VT_HRESULT:
        pReturn = new node_base_type(NODE_SHORT, ATTR_NONE);
        ((named_node *)pReturn)->SetSymName("HRESULT");
        break;
    case VT_DATE:
        pReturn = new node_base_type(NODE_LONGLONG, ATTR_NONE);
        ((named_node *)pReturn)->SetSymName("DATE");
        break;
    case VT_LPSTR:
        pReturn = new node_base_type(NODE_LONGLONG, ATTR_NONE);
        ((named_node *)pReturn)->SetSymName("LPSTR");
        break;
    case VT_LPWSTR:
        pReturn = new node_base_type(NODE_LONGLONG, ATTR_NONE);
        ((named_node *)pReturn)->SetSymName("LPWSTR");
        break;
    case VT_ERROR:
        pReturn = new node_base_type(NODE_INT64, ATTR_NONE);
        ((named_node *)pReturn)->SetSymName("SCODE");
        break;
    // complex ODL base types
    case VT_DECIMAL:
        {
            SymKey key("DECIMAL", NAME_DEF);
            pReturn = pBaseSymTbl->SymSearch(key);
        }
        break;
    case VT_CY:
        {
            SymKey key("CURRENCY", NAME_DEF);
            pReturn = pBaseSymTbl->SymSearch(key);
        }
        break;
    case VT_BSTR:
        {
            SymKey key("BSTR", NAME_DEF);
            pReturn = pBaseSymTbl->SymSearch(key);
        }
        break;
    case VT_VARIANT:
        {
            SymKey key("VARIANT", NAME_DEF);
            pReturn = pBaseSymTbl->SymSearch(key);
        }
        break;
    case VT_DISPATCH:
        {
            SymKey key("IDispatch", NAME_DEF);
            pReturn = new node_pointer(pBaseSymTbl->SymSearch(key));
        }
        break;
    case VT_UNKNOWN:
        {
            SymKey key("IUnknown", NAME_DEF);
            pReturn = new node_pointer(pBaseSymTbl->SymSearch(key));
        }
        break;
    // complex types
    case VT_PTR:
        pReturn = new node_pointer(GetNodeFromTYPEDESC(*(tdesc.lptdesc), pti));
        break;
    case VT_SAFEARRAY:
        pReturn = new node_safearray(GetNodeFromTYPEDESC(*(tdesc.lptdesc), pti));
        break;
    case VT_CARRAY:
        {
            node_skl * pCurrent = NULL;
            node_skl * pPrev = NULL;
            for (int i = 0; i < tdesc.lpadesc->cDims; i++)
            {
                pCurrent = new node_array(
                    new expr_constant(tdesc.lpadesc->rgbounds[i].lLbound),
                    new expr_constant((tdesc.lpadesc->rgbounds[i].cElements
                                      + tdesc.lpadesc->rgbounds[i].lLbound) - 1 )
                    );
                if (pPrev)
                {
                    pPrev->SetChild(pCurrent);
                }
                else
                {
                    pReturn = pCurrent;
                }
                pPrev = pCurrent;
            }
            if (pCurrent)
                (pCurrent)->SetChild(GetNodeFromTYPEDESC(tdesc.lpadesc->tdescElem, pti));
        }
        break;
    case VT_USERDEFINED:
        {
            ITypeInfo * pRef;
            HRESULT hr = pti->GetRefTypeInfo(tdesc.hreftype, &pRef);
            if (FAILED(hr))
            {
                TypeinfoError(hr);
            }
            node_skl* pNode = GetNode(pRef);
            NODE_T nk = pNode->NodeKind();
            if ( nk == NODE_INTERFACE_REFERENCE || nk == NODE_INTERFACE )
                {
                pReturn = new node_interface_reference( (node_interface *) pNode );
                }
            else
               {
               pReturn = pNode;
               }
            pRef->Release();
        }
        break;
    default:
        MIDL_ASSERT(!"Illegal variant type found in a TYPEDESC");
        break;
    }
    if (pReturn && (pReturn->NodeKind() == NODE_DEF) &&
        pReturn->GetChild() &&
        (pReturn->GetChild()->NodeKind() == NODE_FORWARD))
    {
        node_forward * pFwd = (node_forward *) pReturn->GetChild();
        node_skl * pNewSkl = pFwd->ResolveFDecl();
        if (pNewSkl)
        {
            pReturn = new node_def_fe(pReturn->GetSymName(), pNewSkl);
        }
    }
    return pReturn;
}

//+---------------------------------------------------------------------------
//
//  Member:     NODE_MANAGER::AddMembers
//
//  Synopsis:   Generic routine to add type graph elements for variables and
//              functions to a type graph element.
//
//  Arguments:  [pNode]  - pointer to the parent type graph node's MEMLIST
//              [ptattr] - pointer to the parent type info's TYPEATTR struct
//              [pti]    - pointer to the parent type info
//
//  Returns:    nothing
//
//  Modifies:   adds each new node to the MEMLIST referred to by pNode
//
//  History:    5-02-95   stevebl   Created
//
//----------------------------------------------------------------------------

void NODE_MANAGER::AddMembers(MEMLIST * pNode, TYPEATTR * ptattr, ITypeInfo * pti)
{
    HRESULT hr;
    named_node * pNew;
    unsigned i = ptattr->cFuncs;
    while (i--)
    {
        FUNCDESC *pfdesc;
        hr = pti->GetFuncDesc(i, &pfdesc);
        pNew = GetNodeFromFUNCDESC(*pfdesc, pti);
        pNode->AddFirstMember(pNew);
        pti->ReleaseFuncDesc(pfdesc);
    }
    i = ptattr->cVars;
    while (i--)
    {
        VARDESC * pvdesc;
        hr = pti->GetVarDesc(i, &pvdesc);
        pNew = GetNodeFromVARDESC(*pvdesc, pti);
        pNode->AddFirstMember(pNew);
        pti->ReleaseVarDesc(pvdesc);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     NODE_MANAGER::GetNodeFromVARDESC
//
//  Synopsis:   gets a type graph node from a VARDESC
//
//  Arguments:  [vdesc] - VARDESC describing the variable
//              [pti]   - type info containing the VARDESC
//
//  Returns:    type graph node describing the varible
//
//  History:    5-02-95   stevebl   Created
//
//----------------------------------------------------------------------------

named_node * NODE_MANAGER::GetNodeFromVARDESC(VARDESC vdesc, ITypeInfo * pti)
{
    BSTR        bstrName;
    unsigned    cNames;

    pti->GetNames(vdesc.memid, &bstrName, 1, &cNames);
    char *  szName = TranscribeO2A( bstrName );
    LateBound_SysFreeString(bstrName);

    named_node *pNode;
    if (vdesc.varkind == VAR_CONST)
    {
        expr_node * pExpr = GetValueOfConstant(vdesc.lpvarValue);
        pNode = new node_label(szName, pExpr);
    }
    else
    {
        pNode = new node_field(szName);
    }
    pNode->SetBasicType(GetNodeFromTYPEDESC(vdesc.elemdescVar.tdesc, pti));
    SetIDLATTRS(pNode, vdesc.elemdescVar.idldesc);
    pNode->SetAttribute(new node_constant_attr(
        new expr_constant(vdesc.wVarFlags), ATTR_VARDESCATTR));
    if (vdesc.wVarFlags == VARFLAG_FREADONLY)
    {
        pNode->SetAttribute(new node_member_attr(MATTR_READONLY));
    }
    if (vdesc.wVarFlags == VARFLAG_FSOURCE)
    {
        pNode->SetAttribute(new node_member_attr(MATTR_SOURCE));
    }
    if (vdesc.wVarFlags == VARFLAG_FBINDABLE)
    {
        pNode->SetAttribute(new node_member_attr(MATTR_BINDABLE));
    }
    if (vdesc.wVarFlags == VARFLAG_FDISPLAYBIND)
    {
        pNode->SetAttribute(new node_member_attr(MATTR_DISPLAYBIND));
    }
    if (vdesc.wVarFlags == VARFLAG_FDEFAULTBIND)
    {
        pNode->SetAttribute(new node_member_attr(MATTR_DEFAULTBIND));
    }
    if (vdesc.wVarFlags == VARFLAG_FREQUESTEDIT)
    {
        pNode->SetAttribute(new node_member_attr(MATTR_REQUESTEDIT));
    }
    if (vdesc.wVarFlags == VARFLAG_FHIDDEN)
    {
        pNode->SetAttribute(ATTR_HIDDEN);
    }

    pNode->SetAttribute(new node_constant_attr(
        new expr_constant(vdesc.memid), ATTR_ID ));

    return pNode;
}

//+---------------------------------------------------------------------------
//
//  Member:     NODE_MANAGER::GetNodeFromFUNCDESC
//
//  Synopsis:   gets a type graph node from a FUNCDESC
//
//  Arguments:  [fdesc] - FUNCDESC describing the function
//              [pti]   - type info containing the FUNCDESC
//
//  Returns:    type graph node describing the function
//
//  History:    5-02-95   stevebl   Created
//
//----------------------------------------------------------------------------

named_node * NODE_MANAGER::GetNodeFromFUNCDESC(FUNCDESC fdesc, ITypeInfo *pti)
{
    node_proc * pNode = new node_proc(ImportLevel, FALSE);

    BSTR  * rgbstrName = new BSTR [fdesc.cParams + 1];

    unsigned cNames;
    pti->GetNames(fdesc.memid, rgbstrName, fdesc.cParams + 1, &cNames);
    char *   szName = TranscribeO2A( rgbstrName[0] );
    LateBound_SysFreeString( rgbstrName[0] );
    pNode->SetSymName(szName);

    if (fdesc.invkind == DISPATCH_PROPERTYGET 
        || fdesc.funckind == FUNC_DISPATCH 
        || (fdesc.elemdescFunc.paramdesc.wParamFlags & PARAMFLAG_FRETVAL) != 0)
    {
        /*
         * Functions with the DISPATCH_PROPERTYGET attribute are special cases.
         * Their return values in the type graph are always of type HRESULT.
         * The last parameter of the function (after those listed in the fdesc)
         * is a pointer to the return type listed in the fdesc and it has
         * the OUT and RETVAL attributes.
         */
        node_skl* pChild = new node_pointer(GetNodeFromTYPEDESC(fdesc.elemdescFunc.tdesc, pti));
        node_param * pParam = new node_param();
        pChild->GetModifiers().SetModifier( ATTR_TAGREF );
        pParam->SetSymName("retval");
        pParam->SetChild( pChild );
        pParam->SetAttribute(ATTR_OUT);
        pParam->SetAttribute(new node_member_attr(MATTR_RETVAL));
        // add the [retval] parameter at the end of the parameter list
        // (the parameter list is currently empty and the other parameters
        // will be added in front of this one in reverse order so that's why
        // we use AddFirstMember)
        pNode->AddFirstMember(pParam);
        node_skl * pReturn = new node_base_type(NODE_SHORT, ATTR_NONE);
        ((named_node *)pReturn)->SetSymName("HRESULT");
        pNode->SetChild(pReturn);
    }
    else
    {
        node_skl* pChild = GetNodeFromTYPEDESC(fdesc.elemdescFunc.tdesc, pti);
        pNode->SetChild( pChild );
        NODE_T nk = pChild->NodeKind();
        if (nk == NODE_POINTER || nk == NODE_DEF)
            {
            pChild->GetModifiers().SetModifier( ATTR_TAGREF );
            }
    }
    unsigned cParams = fdesc.cParams;
    unsigned cParamsOpt = fdesc.cParamsOpt;
    while (cParams--)
    {
        node_param * pParam = new node_param();
        if (cParams + 1 < cNames)
        {
            szName = TranscribeO2A( rgbstrName[ cParams + 1] );
            pParam->SetSymName(szName);
            LateBound_SysFreeString(rgbstrName[cParams + 1]);
        }
        else
            pParam->SetSymName("noname");

        pParam->SetChild(GetNodeFromTYPEDESC(fdesc.lprgelemdescParam[cParams].tdesc, pti));
        SetIDLATTRS(pParam, fdesc.lprgelemdescParam[cParams].idldesc);
        if (cParamsOpt)
        {
            cParamsOpt--;
            pParam->SetAttribute(new node_member_attr(MATTR_OPTIONAL));
        }
        if (pParam && pParam->GetChild())
            {
            NODE_T nk = pParam->GetChild()->NodeKind();
            if (nk == NODE_POINTER || nk == NODE_DEF)
                {
                pParam->GetChild()->GetModifiers().SetModifier( ATTR_TAGREF );
                }
            }
        pNode->AddFirstMember(pParam);
    }

    delete[]rgbstrName;

    pNode->SetAttribute(new node_constant_attr(
        new expr_constant(fdesc.wFuncFlags), ATTR_FUNCDESCATTR));
    if (fdesc.wFuncFlags == FUNCFLAG_FRESTRICTED)
    {
        pNode->SetAttribute(new node_member_attr(MATTR_RESTRICTED));
    }
    if (fdesc.wFuncFlags == FUNCFLAG_FSOURCE)
    {
        pNode->SetAttribute(new node_member_attr(MATTR_SOURCE));
    }
    if (fdesc.wFuncFlags == FUNCFLAG_FBINDABLE)
    {
        pNode->SetAttribute(new node_member_attr(MATTR_BINDABLE));
    }
    if (fdesc.wFuncFlags == FUNCFLAG_FDISPLAYBIND)
    {
        pNode->SetAttribute(new node_member_attr(MATTR_DISPLAYBIND));
    }
    if (fdesc.wFuncFlags == FUNCFLAG_FDEFAULTBIND)
    {
        pNode->SetAttribute(new node_member_attr(MATTR_DEFAULTBIND));
    }
    if (fdesc.wFuncFlags == FUNCFLAG_FREQUESTEDIT)
    {
        pNode->SetAttribute(new node_member_attr(MATTR_REQUESTEDIT));
    }
    if (fdesc.wFuncFlags == FUNCFLAG_FHIDDEN)
    {
        pNode->SetAttribute(ATTR_HIDDEN);
    }
    if (fdesc.invkind == DISPATCH_PROPERTYGET)
    {
        szName = pNode->GetSymName();
        char * szNewName = new char[strlen(szName) + 5];
        sprintf(szNewName , "get_%s", szName);
        pNode->SetSymName(szNewName);
        pNode->SetAttribute(new node_member_attr(MATTR_PROPGET));
    }
    else if (fdesc.invkind == DISPATCH_PROPERTYPUT)
    {
        szName = pNode->GetSymName();
        char * szNewName = new char[strlen(szName) + 5];
        sprintf(szNewName , "put_%s", szName);
        pNode->SetSymName(szNewName);
        pNode->SetAttribute(new node_member_attr(MATTR_PROPPUT));
    }
    else if (fdesc.invkind == DISPATCH_PROPERTYPUTREF)
    {
        szName = pNode->GetSymName();
        char * szNewName = new char[strlen(szName) + 8];
        sprintf(szNewName , "putref_%s", szName);
        pNode->SetSymName(szNewName);
        pNode->SetAttribute(new node_member_attr(MATTR_PROPPUTREF));
    }

    pNode->GetModifiers().SetModifier( ATTR_TAGREF );
    pNode->SetAttribute(new node_constant_attr(
        new expr_constant(fdesc.memid), ATTR_ID ));

    return pNode;
}

//+---------------------------------------------------------------------------
//
//  Member:     NODE_MANAGER::SetIDLATTRS
//
//  Synopsis:   Adds IDL attributes to a type graph node
//
//  Arguments:  [pNode]   - pointer to the type graph node
//              [idldesc] - IDLDESC containing the IDL attributes
//
//  History:    5-02-95   stevebl   Created
//
//----------------------------------------------------------------------------

void NODE_MANAGER::SetIDLATTRS(named_node * pNode, IDLDESC idldesc)
{
    pNode->SetAttribute(new node_constant_attr(
        new expr_constant(idldesc.wIDLFlags), ATTR_IDLDESCATTR));
    if (idldesc.wIDLFlags & IDLFLAG_FIN)
    {
        pNode->SetAttribute(ATTR_IN);
    }
    if (idldesc.wIDLFlags & IDLFLAG_FOUT)
    {
        pNode->SetAttribute(ATTR_OUT);
    }
    if (idldesc.wIDLFlags & IDLFLAG_FLCID)
    {
        pNode->SetAttribute(ATTR_FLCID);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     NODE_MANAGER::GetValueOfConstant
//
//  Synopsis:   creates an expr_constant node from a VARIANT
//
//  Arguments:  [pVar] - pointer to the variant containing the constant
//
//  Returns:    expr_node describing the constant expression
//
//  History:    5-02-95   stevebl   Created
//
//----------------------------------------------------------------------------

expr_node * NODE_MANAGER::GetValueOfConstant(VARIANT * pVar)
{
    expr_node * pReturn;
    switch(pVar->vt)
    {
    case VT_UI1:
        pReturn = new expr_constant(pVar->bVal);
        break;
    case VT_BOOL:
    case VT_I2:
        pReturn = new expr_constant(pVar->iVal);
        break;
    case VT_I4:
        pReturn = new expr_constant(pVar->lVal);
        break;
    case VT_R4:
        pReturn = new expr_constant(pVar->fltVal);
        break;
    case VT_R8:
        pReturn = new expr_constant(pVar->dblVal);
        break;
    case VT_CY:
    case VT_DATE:
    case VT_BSTR:
    case VT_ERROR:
    case VT_UNKNOWN:
    case VT_VARIANT:
    case VT_DISPATCH:
    default:
        // This case is currently illegal in every situation that I am
        // aware of.  However, just in case this ever changes, (and since
        // it is possible to handle this situation even though it may be
        // illeagal) I'll go ahead and allow it anyway.  The alternative
        // would be to choke on it and put out an error message.

        // FUTURE - perhaps display a warning here

        pReturn = new expr_constant(pVar->lVal);
        break;
    }
    return pReturn;
}

//+---------------------------------------------------------------------------
//
//  Function:   CTypeLibraryList::AddTypeLibraryMembers
//
//  Synopsis:   Adds each of a type library's members to the global symbol
//              table as a node_href.  If another symbol with the same name
//              already exists in the table, then no node will be added
//              for that member.
//
//  Arguments:  [ptl]        - type library pointer
//              [szFileName] - name of the file containing the type library
//
//  History:    5-02-95   stevebl   Created
//
//  Notes:      Typeinfos added to the global symbol table in this manner are
//              not parsed and expanded into their type graphs at this time;
//              type info expansion occurs during the semantic pass.
//
//----------------------------------------------------------------------------

void CTypeLibraryList::AddTypeLibraryMembers(ITypeLib * ptl, char * szFileName)
{
    unsigned int    nMem = ptl->GetTypeInfoCount();
    BSTR            bstrName;
    HRESULT         hr;
    ITypeInfo *     pti;
    char *          sz;
    node_file *     pFile = new node_file(szFileName, 1);

    while (nMem--)
    {
        hr = ptl->GetDocumentation(nMem, &bstrName, NULL, NULL, NULL);
        if (FAILED(hr))
        {
            TypelibError(szFileName, hr);
        }

        sz = TranscribeO2A( bstrName );
        LateBound_SysFreeString(bstrName);

        NAME_T type;
        TYPEKIND tkind;
        hr = ptl->GetTypeInfoType(nMem, &tkind);
        if (FAILED(hr))
       {
            TypelibError(szFileName, hr);
        }

        if (!pCommand->IsSwitchDefined(SWITCH_MKTYPLIB))
        {        
            switch (tkind)
            {
            case TKIND_ENUM:
                type = NAME_ENUM;
                break;
            case TKIND_UNION:
                type = NAME_UNION;
                break;
            case TKIND_RECORD:
                type = NAME_TAG;
                break;
            default:
                type = NAME_DEF;
                break;
            }
        }
        else
        {    
            type = NAME_DEF;
        }
        SymKey key(sz, type);
        if (!pBaseSymTbl->SymSearch(key))
        {
            hr = ptl->GetTypeInfo(nMem, &pti);
            if (FAILED(hr))
            {
                TypelibError(szFileName, hr);
            }
            pItfList->Add(pti, sz);
            node_href * pref = new node_href(key, pBaseSymTbl, pti, pFile);
            pref->SetSymName(sz);
            pBaseSymTbl->SymInsert(key, NULL, pref);
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   AddQualifiedReferenceToType
//
//  Synopsis:   Verifies that a library contains a given type and returns
//              a typegraph node pointer to the type.
//
//  Arguments:  [szLibrary] - name of the library (_NOT_ the TLB file)
//              [szType]    - name of the type to be referenced
//
//  Returns:    a node_href * to the referenced type.
//              If the type isn't found to exist in the given library then
//              this routine returns NULL.
//
//  History:    12-20-95   stevebl   Created
//
//  Notes:      These types are not added to the global symbol table.
//              They are also not parsed and expanded into their complete
//              type graphs at this time; type info expansion occurs
//              during the semantic pass.
//
//----------------------------------------------------------------------------

void * AddQualifiedReferenceToType(char * szLibrary, char * szType)
{
    return gtllist.AddQualifiedReferenceToType(szLibrary, szType);
}

void * CTypeLibraryList::AddQualifiedReferenceToType(char * szLibrary, char * szType)
{
    ITypeLib * pTL = FindLibrary(szLibrary);
    if (NULL != pTL)
    {
        node_file * pFile = new node_file(szLibrary, 1);
        WCHAR *     wsz = TranscribeA2O( szType );
        ITypeInfo * ptiFound;
        SYSKIND sk = ( SYSKIND ) ( pCommand->Is64BitEnv() ? SYS_WIN64 : SYS_WIN32 );
        ULONG       lHashVal = LateBound_LHashValOfNameSys(sk, NULL, wsz);
        HRESULT     hr;
        MEMBERID    memid;
        unsigned short c;
        c = 1;
        hr = pTL->FindName(wsz, lHashVal, &ptiFound, &memid, &c);
        if (SUCCEEDED(hr))
        {
            if (c)
            {
                if (-1 == memid)
                {
                    // found a matching name
                    NAME_T type;
                    TYPEATTR * ptattr;
                    hr = ptiFound->GetTypeAttr(&ptattr);
                    if (FAILED(hr))
                    {
                        TypeinfoError(hr);
                    }

                    if (!pCommand->IsSwitchDefined(SWITCH_MKTYPLIB))
                    {        
                        switch (ptattr->typekind)
                        {
                        case TKIND_ENUM:
                            type = NAME_ENUM;
                            break;
                        case TKIND_UNION:
                            type = NAME_UNION;
                            break;
                        case TKIND_RECORD:
                            type = NAME_TAG;
                            break;
                        default:
                            type = NAME_DEF;
                        break;
                        }
                    }
                    else
                    {
                        type = NAME_DEF;
                    }
                    ptiFound->ReleaseTypeAttr(ptattr);
                    pItfList->Add(ptiFound, szType);
                    SymKey key(szType, type);
                    node_href * pref = new node_href(key, pBaseSymTbl, ptiFound, pFile);
                    return pref;
                }
                // found a parameter name or some other non-global name
                ptiFound->Release();
            }
        }
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\inc\szbuffer.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999.
//
//  File:       szbuffer.h
//
//  Contents:   simple class for a string buffer that dynamically reallocates
//              space for itself as necessary
//
//  Classes:    CSzBuffer
//
//  History:    4-22-96   stevebl   Created
//
//----------------------------------------------------------------------------

#ifndef CSZBUFFER
#define CSZBUFFER

//+---------------------------------------------------------------------------
//
//  Class:      CSzBuffer
//
//  Purpose:    string buffer that automatically allocates space as needed
//
//  Interface:  Set        -- resets buffer to new string
//              Append     -- adds string (or number) to end of data
//              Prepend    -- adds string (or number) to front of data
//              GetData    -- gets pointer to string buffer
//              GetLength  -- gets length of string in buffer (in chars)
//
//  History:    4-22-96   stevebl   Created
//
//----------------------------------------------------------------------------

class CSzBuffer
{
public:
    CSzBuffer(const char * sz);
    CSzBuffer();
    ~CSzBuffer();

    void Set(const char * sz);
    void Append(const char * sz);
    void Prepend(const char * sz);
    void Append(const long l);
    void Prepend(const long l);

    char * GetData();

    int GetLength();

    operator char *()
    {
        return GetData();
    };

private:
    int cchLength;
    int cchBufSize;
    char * szData;
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\support\memory.cxx ===
/*****************************************************************************/
/**						Microsoft LAN Manager								**/
/**				Copyright(c) Microsoft Corp., 1987-1999						**/
/*****************************************************************************/
/*****************************************************************************
File				: memory.cxx
Title				: new and delete functions for the midl compiler
History				:
	06-Aug-1991	VibhasC	Created

*****************************************************************************/

#pragma warning ( disable : 4514 )

/****************************************************************************
 includes
 ****************************************************************************/

#include "nulldefs.h"
#include <basetsd.h>
extern	"C"	{
	#include <stdio.h>
	#include <stdlib.h>
	#include <malloc.h>
}
#include "errors.hxx"
#include "nodeskl.hxx"
#include "attrnode.hxx"

/****************************************************************************
	extern data
 ****************************************************************************/

extern	unsigned long		TotalAllocation;

extern	char	*		Skl_bufstart;
extern	char	*		Skl_bufend;
extern	unsigned long	Skl_Allocations;
extern	unsigned long	Skl_Bytes;
extern	unsigned long	Skl_Deletions;

/****************************************************************************/

/****************************************************************************
 *** print memory statistics
 ****************************************************************************/

void
print_memstats()
	{
	printf("\t\t***** memory use **************\n");
	printf("\tglobal operator new allocations:\t %ld bytes\n", TotalAllocation);
	printf("\tAllocateOnce allocations: %ld, \t\t(%ld bytes)\n",
			Skl_Allocations, Skl_Bytes);
	printf("\t\tand deletions: %ld\n", Skl_Deletions );


#ifdef print_sizes
	printf("sizes:\n");
	printf("node_skl: %d\n",sizeof(node_skl) );
	printf("named_node: %d\n",sizeof(named_node) );
	printf("tracked_node: %d\n",sizeof(tracked_node) );
	printf("node_id: %d\n",sizeof(node_id) );
	printf("node_label: %d\n",sizeof(node_label) );
	printf("node_param: %d\n",sizeof(node_param) );
	printf("node_file: %d\n",sizeof(node_file) );
	printf("node_proc: %d\n",sizeof(node_proc) );
	printf("node_forward: %d\n",sizeof(node_forward) );
	printf("node_field: %d\n",sizeof(node_field) );
	printf("node_bitfield: %d\n",sizeof(node_bitfield) );
	printf("node_su_base: %d\n",sizeof(node_su_base) );
	printf("node_enum: %d\n",sizeof(node_enum) );
	printf("node_struct: %d\n",sizeof(node_struct) );
	printf("node_en_struct: %d\n",sizeof(node_en_struct) );
	printf("node_union: %d\n",sizeof(node_union) );
	printf("node_en_union: %d\n",sizeof(node_en_union) );
	printf("node_def: %d\n",sizeof(node_def) );
	printf("node_interface: %d\n",sizeof(node_interface) );
	printf("node_source: %d\n",sizeof(node_source) );
	printf("npa_nodes: %d\n",sizeof(npa_nodes) );
	printf("node_pointer: %d\n",sizeof(node_pointer) );
	printf("node_array: %d\n",sizeof(node_array) );
	printf("node_e_status_t: %d\n",sizeof(node_e_status_t) );
	printf("node_error: %d\n",sizeof(node_error) );
	printf("node_base_type: %d\n",sizeof(node_base_type) );
	printf("node_wchar_t: %d\n",sizeof(node_wchar_t) );
	printf("\n");
#endif // print_sizes

	};

/****************************************************************************
 *** the special memory functions for allocate once and never delete objects
 ***
 *** No space is returned on delete
 ****************************************************************************/

// Round all allocations up to the nearest long and/or pointer alignment
#define	ROUNDING	(sizeof(LONG_PTR)-1)

// The buffer size appears to be picked out of thin air
#define BUFSIZE (32748 & ~ROUNDING)

void * 
AllocateOnceNew(
	size_t	size )
	{
	char * _last_allocation;

	// check for enough free space

	if ( ((SIZE_T) Skl_bufend) -
		 ((SIZE_T) Skl_bufstart ) < size )
		{

		// get a new big block of memory
		if ( (_last_allocation = (char *) malloc( BUFSIZE ) )== 0)
			{
	
			RpcError( (char *)NULL,
					  	0,
					  	OUT_OF_MEMORY,
					  	(char *)NULL );
	
			exit( OUT_OF_MEMORY );
			}
		else
			{
			Skl_bufstart	= _last_allocation;
			Skl_bufend		= Skl_bufstart  + BUFSIZE;
			}
		
		}

	_last_allocation = Skl_bufstart ;
	Skl_bufstart  += (size + ROUNDING) & ~ROUNDING;

#ifndef NDEBUG
	Skl_Allocations ++;
	Skl_Bytes += size;
#endif

	return _last_allocation;

	};


void  
AllocateOnceDelete( void* )
	{
#ifndef NDEBUG
	Skl_Deletions ++;
#endif
	};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\support\buffer.cxx ===
/*++

Copyright (c) 1991-1999 Microsoft Corporation

Module Name:

    buffer.cxx

Abstract:

    MIDL Compiler Buffer Manager Definition 

    This class manages a collection of pre-allocated strings.

Author:

    Donna Liu (donnali) 09-Nov-1990

Revision History:

    26-Feb-1992     donnali

        Moved toward NT coding style.

--*/

#pragma warning ( disable : 4514 4710 )


#include "nulldefs.h"
extern "C" {
#include <stdio.h>
#include <malloc.h>
#include <string.h>
}
#include "buffer.hxx"

#ifdef gaj_debug_buf
extern void midl_debug (char *);
#else
#define midl_debug(s)
#endif

BufferManager::BufferManager(
	unsigned short	usBufferSize
	)
/*++

Routine Description:

    This method constructs a BufferManager object.

Arguments:

    usBufferSize - Supplies the size of each managed buffer.

--*/
{
	char **	pTemp = new (char *[usBufferSize]);

	usBufSize = usBufferSize;
	usTabSize = 0;
	pszTable = (char **)0;
	pHead = pTail = pSave = new BufferElement(
							NULL,
							NULL,
							pTemp);
	iHead = iTail = unsigned short(usBufSize - 2);
}

BufferManager::BufferManager(
	unsigned short	usBufferSize,
	unsigned short	usTableSize,
	const char *	aStringTable[]
	)
/*++

Routine Description:

    This method constructs a BufferManager object.

Arguments:

    usBufferSize - Supplies the size of each managed buffer.

    usTableSize - Supplies the size of the table containing string
        constants.

    aStringTable - Supplies the table containing string constants.

--*/
{
	char **	pTemp = new (char *[usBufferSize]);

	usBufSize = usBufferSize;
	usTabSize = usTableSize;
	pszTable = (char**) aStringTable;
	pHead = pTail = pSave = new BufferElement(
							NULL,
							NULL,
							pTemp);
	iHead = iTail = unsigned short(usBufSize - 2);
}


void BufferManager::Print(
	ISTREAM * pStream
	)
/*++

Routine Description:

    This method prints all the strings managed by a BufferManager
    to a file.

Arguments:

    pStream - Supplies the output file handle.

--*/
{
	unsigned short	usCount;
	BufferElement *	pTemp;
	char			BigBuffer[1000];
	char		  * pBigBufferNext;

	if (pHead == pTail)
		{
		pBigBufferNext = &BigBuffer[0];
		*pBigBufferNext = '\0';
		for (usCount = iHead ; usCount < iTail ; usCount++)
			{
			strcpy( pBigBufferNext, pHead->pBuffer[usCount] );
			pBigBufferNext += strlen( pBigBufferNext );
			}
		pStream->Write( BigBuffer );
		}
	else
		{

		pBigBufferNext = &BigBuffer[0];
		*pBigBufferNext = '\0';
		for (usCount = iHead ; usCount < usBufSize ; usCount++)
			{
			strcpy( pBigBufferNext, pHead->pBuffer[usCount] );
			pBigBufferNext += strlen( pBigBufferNext );
			}
		pStream->Write( BigBuffer );

		for (pTemp = pHead->GetNext() ; 
			pTemp != pTail ; 
			pTemp = pTemp->GetNext())
			{
			pBigBufferNext = &BigBuffer[0];
			*pBigBufferNext = '\0';
			for (usCount = 0 ; usCount < usBufSize ; usCount++)
				{
				strcpy( pBigBufferNext, pTemp->pBuffer[usCount] );
				pBigBufferNext += strlen( pBigBufferNext );
				}
			pStream->Write( BigBuffer );
			}

		pBigBufferNext = &BigBuffer[0];
		*pBigBufferNext = '\0';
		for (usCount = 0 ; usCount < iTail ; usCount++)
			{
			strcpy( pBigBufferNext, pTail->pBuffer[usCount] );
			pBigBufferNext += strlen( pBigBufferNext );
			}
		pStream->Write( BigBuffer );
		
		}

	Clear();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\inc\tokntbl.h ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 2000 Microsoft Corporation

Module Name :

    tokntbl.h

Abstract :

    This file contains the template for the token tables used in marshalling,
    unmarshalling, memsizeing, buffersizing, freeing, and type attributes.
    
Author :

    Mike Zoran  mzoran   March 2000.

Revision History :

  ---------------------------------------------------------------------*/

// The following macros need to be defined by users of this table
// 
// NDR64_BEGIN_TABLE -- Begining of the table
// NDR64_TABLE_END   -- End of table
// NDR64_ZERO_ENTRY  -- First entry in the table
// NDR64_TABLE_ENTRY( number, tokenname,
//                    marshal, embeddedmarshal,
//                    unmarshal, embeddedunmarshal,
//                    buffersize, embeddedbuffersize,
//                    memsize, embeddedmemsize,
//                    free, embeddedfree,
//                    typeflags )
// NDR64_SIMPLE_TYPE_TABLE_ENTRY( number, tokenname,
//                                simpletypebuffersize,
//                                simpletypememorysize )
// NDR64_UNUSED_TABLE_ENTRY( number, tokenname )
// NDR64_UNUSED_TABLE_ENTRY_NOSYM( number )
// 

NDR64_BEGIN_TABLE

// Simple Types

NDR64_ZERO_ENTRY
NDR64_SIMPLE_TYPE_TABLE_ENTRY( 0x1, FC64_UINT8, 1, 1 )
NDR64_SIMPLE_TYPE_TABLE_ENTRY( 0x2, FC64_INT8, 1, 1 ) 
NDR64_SIMPLE_TYPE_TABLE_ENTRY( 0x3, FC64_UINT16, 2, 2 )
NDR64_SIMPLE_TYPE_TABLE_ENTRY( 0x4, FC64_INT16, 2, 2 )          
NDR64_SIMPLE_TYPE_TABLE_ENTRY( 0x5, FC64_INT32, 4, 4 )          
NDR64_SIMPLE_TYPE_TABLE_ENTRY( 0x6, FC64_UINT32, 4, 4  )          
NDR64_SIMPLE_TYPE_TABLE_ENTRY( 0x7, FC64_INT64, 8, 8  )          
NDR64_SIMPLE_TYPE_TABLE_ENTRY( 0x8, FC64_UINT64, 8, 8 )
NDR64_UNUSED_TABLE_ENTRY( 0x9, FC64_INT128 )       
NDR64_UNUSED_TABLE_ENTRY( 0xA, FC64_UINT128 )
NDR64_SIMPLE_TYPE_TABLE_ENTRY( 0xB, FC64_FLOAT32, 4, 4 )
NDR64_SIMPLE_TYPE_TABLE_ENTRY( 0xC, FC64_FLOAT64, 8, 8 )
NDR64_UNUSED_TABLE_ENTRY( 0xD, FC64_FLOAT80 )
NDR64_UNUSED_TABLE_ENTRY( 0xE, FC64_FLOAT128 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xF )

NDR64_SIMPLE_TYPE_TABLE_ENTRY( 0x10, FC64_CHAR, 1, 1 )                                   
NDR64_SIMPLE_TYPE_TABLE_ENTRY( 0x11, FC64_WCHAR, 2, 2 )               
NDR64_SIMPLE_TYPE_TABLE_ENTRY( 0x12, FC64_IGNORE, sizeof(NDR64_PTR_WIRE_TYPE), PTR_MEM_SIZE ) 
NDR64_SIMPLE_TYPE_TABLE_ENTRY( 0x13, FC64_ERROR_STATUS_T, 4, 4 ) 
NDR64_UNUSED_TABLE_ENTRY( 0x14, FC64_POINTER )               
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x15 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x16 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x17 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x18 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x19 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x1A )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x1B )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x1C )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x1D )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x1E )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x1F )

// Pointers

NDR64_TABLE_ENTRY( 0x20, FC64_RP,
                   Ndr64TopLevelPointerMarshall,   Ndr64EmbeddedPointerMarshall,
                   Ndr64TopLevelPointerUnmarshall, Ndr64EmbeddedPointerUnmarshall,
                   Ndr64TopLevelPointerBufferSize, Ndr64EmbeddedPointerBufferSize,
                   Ndr64TopLevelPointerMemorySize, Ndr64EmbeddedPointerMemorySize,
                   Ndr64TopLevelPointerFree,       Ndr64EmbeddedPointerFree,     
                   _BASIC_POINTER_ | _POINTER_ )
NDR64_TABLE_ENTRY( 0x21, FC64_UP,
                   Ndr64TopLevelPointerMarshall,   Ndr64EmbeddedPointerMarshall,
                   Ndr64TopLevelPointerUnmarshall, Ndr64EmbeddedPointerUnmarshall,
                   Ndr64TopLevelPointerBufferSize, Ndr64EmbeddedPointerBufferSize,
                   Ndr64TopLevelPointerMemorySize, Ndr64EmbeddedPointerMemorySize,
                   Ndr64TopLevelPointerFree,       Ndr64EmbeddedPointerFree,     
                   _BASIC_POINTER_ | _POINTER_ )
NDR64_TABLE_ENTRY( 0x22, FC64_OP,
                   Ndr64TopLevelPointerMarshall,   Ndr64EmbeddedPointerMarshall, 
                   Ndr64TopLevelPointerUnmarshall, Ndr64EmbeddedPointerUnmarshall,
                   Ndr64TopLevelPointerBufferSize, Ndr64EmbeddedPointerBufferSize,
                   Ndr64TopLevelPointerMemorySize, Ndr64EmbeddedPointerMemorySize,
                   Ndr64TopLevelPointerFree,       Ndr64EmbeddedPointerFree,     
                   _BASIC_POINTER_ | _POINTER_ )
NDR64_TABLE_ENTRY( 0x23, FC64_FP,
                   Ndr64TopLevelPointerMarshall,   Ndr64EmbeddedPointerMarshall, 
                   Ndr64TopLevelPointerUnmarshall, Ndr64EmbeddedPointerUnmarshall,
                   Ndr64TopLevelPointerBufferSize, Ndr64EmbeddedPointerBufferSize,
                   Ndr64TopLevelPointerMemorySize, Ndr64EmbeddedPointerMemorySize,
                   Ndr64TopLevelPointerFree,       Ndr64EmbeddedPointerFree,     
                   _BASIC_POINTER_ | _POINTER_ )
NDR64_TABLE_ENTRY(  0x24, FC64_IP,
                    Ndr64TopLevelPointerMarshall,  Ndr64EmbeddedPointerMarshall,
                    Ndr64TopLevelPointerUnmarshall,Ndr64EmbeddedPointerUnmarshall,
                    Ndr64TopLevelPointerBufferSize,Ndr64EmbeddedPointerBufferSize,
                    Ndr64TopLevelPointerMemorySize,Ndr64EmbeddedPointerMemorySize,
                    Ndr64TopLevelPointerFree,      Ndr64EmbeddedPointerFree,
                    _POINTER_ )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x25 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x26 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x27 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x28 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x29 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x2A )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x2B )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x2C )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x2D )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x2E )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x2F )

// Structures

NDR64_TABLE_ENTRY( 0x30, FC64_STRUCT,
                   Ndr64SimpleStructMarshall,      Ndr64SimpleStructMarshall,
                   Ndr64SimpleStructUnmarshall,    Ndr64SimpleStructUnmarshall,
                   Ndr64SimpleStructBufferSize,    Ndr64SimpleStructBufferSize,
                   Ndr64SimpleStructMemorySize,    Ndr64SimpleStructMemorySize,
                   Ndr64pNoopFree,                 Ndr64pNoopFree,
                   _STRUCT_ | _BY_VALUE_ )
NDR64_TABLE_ENTRY( 0x31, FC64_PSTRUCT,
                   Ndr64SimpleStructMarshall,      Ndr64SimpleStructMarshall,
                   Ndr64SimpleStructUnmarshall,    Ndr64SimpleStructUnmarshall,
                   Ndr64SimpleStructBufferSize,    Ndr64SimpleStructBufferSize,
                   Ndr64SimpleStructMemorySize,    Ndr64SimpleStructMemorySize,
                   Ndr64SimpleStructFree,          Ndr64SimpleStructFree,
                   _STRUCT_ | _BY_VALUE_ )

NDR64_TABLE_ENTRY( 0x32, FC64_CONF_STRUCT,
                   Ndr64ConformantStructMarshall,      Ndr64ConformantStructMarshall,
                   Ndr64ConformantStructUnmarshall,    Ndr64ConformantStructUnmarshall,
                   Ndr64ConformantStructBufferSize,    Ndr64ConformantStructBufferSize,
                   Ndr64ConformantStructMemorySize,    Ndr64ConformantStructMemorySize,
                   Ndr64ConformantStructFree,          Ndr64ConformantStructFree,
                   _STRUCT_ | _BY_VALUE_ )
NDR64_TABLE_ENTRY( 0x33, FC64_CONF_PSTRUCT,
                   Ndr64ConformantStructMarshall,      Ndr64ConformantStructMarshall,
                   Ndr64ConformantStructUnmarshall,    Ndr64ConformantStructUnmarshall,
                   Ndr64ConformantStructBufferSize,    Ndr64ConformantStructBufferSize,
                   Ndr64ConformantStructMemorySize,    Ndr64ConformantStructMemorySize,
                   Ndr64ConformantStructFree,          Ndr64ConformantStructFree,
                   _STRUCT_ | _BY_VALUE_ )

NDR64_TABLE_ENTRY( 0x34, FC64_BOGUS_STRUCT,
                   Ndr64ComplexStructMarshall,     Ndr64ComplexStructMarshall,
                   Ndr64ComplexStructUnmarshall,   Ndr64ComplexStructUnmarshall,
                   Ndr64ComplexStructBufferSize,   Ndr64ComplexStructBufferSize,
                   Ndr64ComplexStructMemorySize,   Ndr64ComplexStructMemorySize,
                   Ndr64ComplexStructFree,         Ndr64ComplexStructFree,
                   _STRUCT_ | _BY_VALUE_ )

NDR64_TABLE_ENTRY( 0x35, FC64_FORCED_BOGUS_STRUCT,
                   Ndr64ComplexStructMarshall,         Ndr64ComplexStructMarshall,
                   Ndr64ComplexStructUnmarshall,       Ndr64ComplexStructUnmarshall,
                   Ndr64ComplexStructBufferSize,       Ndr64ComplexStructBufferSize,
                   Ndr64ComplexStructMemorySize,       Ndr64ComplexStructMemorySize,
                   Ndr64ComplexStructFree,             Ndr64ComplexStructFree,
                   _STRUCT_ | _BY_VALUE_ )
NDR64_TABLE_ENTRY( 0x36, FC64_CONF_BOGUS_STRUCT,
                   Ndr64ComplexStructMarshall,         Ndr64ComplexStructMarshall,
                   Ndr64ComplexStructUnmarshall,       Ndr64ComplexStructUnmarshall,
                   Ndr64ComplexStructBufferSize,       Ndr64ComplexStructBufferSize,
                   Ndr64ComplexStructMemorySize,       Ndr64ComplexStructMemorySize,
                   Ndr64ComplexStructFree,             Ndr64ComplexStructFree,
                   _STRUCT_ | _BY_VALUE_ )
NDR64_TABLE_ENTRY( 0x37, FC64_FORCED_CONF_BOGUS_STRUCT,
                   Ndr64ComplexStructMarshall,         Ndr64ComplexStructMarshall,
                   Ndr64ComplexStructUnmarshall,       Ndr64ComplexStructUnmarshall,
                   Ndr64ComplexStructBufferSize,       Ndr64ComplexStructBufferSize,
                   Ndr64ComplexStructMemorySize,       Ndr64ComplexStructMemorySize,
                   Ndr64ComplexStructFree,             Ndr64ComplexStructFree,
                   _STRUCT_ | _BY_VALUE_ )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x38 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x39 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x3A )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x3B )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x3C )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x3D )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x3E )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x3F )

// Arrays

NDR64_TABLE_ENTRY( 0x40, FC64_FIX_ARRAY,
                   Ndr64FixedArrayMarshall,        Ndr64FixedArrayMarshall,
                   Ndr64FixedArrayUnmarshall,      Ndr64FixedArrayUnmarshall,
                   Ndr64FixedArrayBufferSize,      Ndr64FixedArrayBufferSize,
                   Ndr64FixedArrayMemorySize,      Ndr64FixedArrayMemorySize,
                   Ndr64FixedArrayFree,            Ndr64FixedArrayFree,
                   _ARRAY_ )

NDR64_TABLE_ENTRY( 0x41, FC64_CONF_ARRAY,
                   Ndr64ConformantArrayMarshall,   Ndr64ConformantArrayMarshall,
                   Ndr64ConformantArrayUnmarshall, Ndr64ConformantArrayUnmarshall,
                   Ndr64ConformantArrayBufferSize, Ndr64ConformantArrayBufferSize,
                   Ndr64ConformantArrayMemorySize, Ndr64ConformantArrayMemorySize,
                   Ndr64ConformantArrayFree,       Ndr64ConformantArrayFree,
                   _ARRAY_ )

NDR64_TABLE_ENTRY( 0x42, FC64_VAR_ARRAY,
                   Ndr64VaryingArrayMarshall,      Ndr64VaryingArrayMarshall,
                   Ndr64VaryingArrayUnmarshall,    Ndr64VaryingArrayUnmarshall,
                   Ndr64VaryingArrayBufferSize,    Ndr64VaryingArrayBufferSize,
                   Ndr64VaryingArrayMemorySize,    Ndr64VaryingArrayMemorySize,
                   Ndr64VaryingArrayFree,          Ndr64VaryingArrayFree,
                   _ARRAY_ )

NDR64_TABLE_ENTRY( 0x43, FC64_CONFVAR_ARRAY,
                   Ndr64ConformantVaryingArrayMarshall,    Ndr64ConformantVaryingArrayMarshall,
                   Ndr64ConformantVaryingArrayUnmarshall,  Ndr64ConformantVaryingArrayUnmarshall,
                   Ndr64ConformantVaryingArrayBufferSize,  Ndr64ConformantVaryingArrayBufferSize,
                   Ndr64ConformantVaryingArrayMemorySize,  Ndr64ConformantVaryingArrayMemorySize,
                   Ndr64ConformantVaryingArrayFree,        Ndr64ConformantVaryingArrayFree,
                   _ARRAY_ )
NDR64_TABLE_ENTRY( 0x44, FC64_FIX_FORCED_BOGUS_ARRAY,
                   Ndr64ComplexArrayMarshall,        Ndr64ComplexArrayMarshall,
                   Ndr64ComplexArrayUnmarshall,      Ndr64ComplexArrayUnmarshall,
                   Ndr64ComplexArrayBufferSize,      Ndr64ComplexArrayBufferSize,
                   Ndr64ComplexArrayMemorySize,      Ndr64ComplexArrayMemorySize,
                   Ndr64ComplexArrayFree,            Ndr64ComplexArrayFree,
                   _ARRAY_ )
NDR64_TABLE_ENTRY( 0x45, FC64_FIX_BOGUS_ARRAY,
                   Ndr64ComplexArrayMarshall,        Ndr64ComplexArrayMarshall,
                   Ndr64ComplexArrayUnmarshall,      Ndr64ComplexArrayUnmarshall,
                   Ndr64ComplexArrayBufferSize,      Ndr64ComplexArrayBufferSize,
                   Ndr64ComplexArrayMemorySize,      Ndr64ComplexArrayMemorySize,
                   Ndr64ComplexArrayFree,            Ndr64ComplexArrayFree,
                   _ARRAY_ )
NDR64_TABLE_ENTRY( 0x46, FC64_FORCED_BOGUS_ARRAY,
                   Ndr64ComplexArrayMarshall,        Ndr64ComplexArrayMarshall,
                   Ndr64ComplexArrayUnmarshall,      Ndr64ComplexArrayUnmarshall,
                   Ndr64ComplexArrayBufferSize,      Ndr64ComplexArrayBufferSize,
                   Ndr64ComplexArrayMemorySize,      Ndr64ComplexArrayMemorySize,
                   Ndr64ComplexArrayFree,            Ndr64ComplexArrayFree,
                   _ARRAY_ )
NDR64_TABLE_ENTRY(  0x47, FC64_BOGUS_ARRAY,
                    Ndr64ComplexArrayMarshall,     Ndr64ComplexArrayMarshall,
                    Ndr64ComplexArrayUnmarshall,   Ndr64ComplexArrayUnmarshall,
                    Ndr64ComplexArrayBufferSize,   Ndr64ComplexArrayBufferSize,
                    Ndr64ComplexArrayMemorySize,   Ndr64ComplexArrayMemorySize,
                    Ndr64ComplexArrayFree,         Ndr64ComplexArrayFree,
                    _ARRAY_ )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x48 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x49 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x4A )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x4B )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x4C )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x4D )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x4E )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x4F )

// Unions

NDR64_TABLE_ENTRY(  0x50, FC64_ENCAPSULATED_UNION,
                    Ndr64UnionMarshall,            Ndr64UnionMarshall,  
                    Ndr64UnionUnmarshall,          Ndr64UnionUnmarshall,
                    Ndr64UnionBufferSize,          Ndr64UnionBufferSize,
                    Ndr64UnionMemorySize,          Ndr64UnionMemorySize,
                    Ndr64UnionFree,                Ndr64UnionFree,
                    _UNION_ | _BY_VALUE_ )
NDR64_TABLE_ENTRY(  0x51, FC64_NON_ENCAPSULATED_UNION,
                    Ndr64UnionMarshall,            Ndr64UnionMarshall,
                    Ndr64UnionUnmarshall,          Ndr64UnionUnmarshall,
                    Ndr64UnionBufferSize,          Ndr64UnionBufferSize,
                    Ndr64UnionMemorySize,          Ndr64UnionMemorySize,
                    Ndr64UnionFree,                Ndr64UnionFree,
                    _UNION_ | _BY_VALUE_ )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x52 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x53 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x54 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x55 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x56 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x57 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x58 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x59 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x5A )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x5B )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x5C )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x5D )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x5E )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x5F )

// Strings

NDR64_TABLE_ENTRY( 0x60, FC64_CHAR_STRING,
                   Ndr64NonConformantStringMarshall,   Ndr64NonConformantStringMarshall,
                   Ndr64NonConformantStringUnmarshall, Ndr64NonConformantStringUnmarshall,
                   Ndr64NonConformantStringBufferSize, Ndr64NonConformantStringBufferSize,
                   Ndr64NonConformantStringMemorySize, Ndr64NonConformantStringMemorySize,
                   Ndr64pNoopFree,                     Ndr64pNoopFree,
                   _STRING_ )
NDR64_TABLE_ENTRY( 0x61, FC64_WCHAR_STRING,
                   Ndr64NonConformantStringMarshall,   Ndr64NonConformantStringMarshall,
                   Ndr64NonConformantStringUnmarshall, Ndr64NonConformantStringUnmarshall,
                   Ndr64NonConformantStringBufferSize, Ndr64NonConformantStringBufferSize,
                   Ndr64NonConformantStringMemorySize, Ndr64NonConformantStringMemorySize,
                   Ndr64pNoopFree,                     Ndr64pNoopFree,
                   _STRING_ )

NDR64_TABLE_ENTRY( 0x62, FC64_STRUCT_STRING,
                   Ndr64NonConformantStringMarshall,   Ndr64NonConformantStringMarshall,
                   Ndr64NonConformantStringUnmarshall, Ndr64NonConformantStringUnmarshall,
                   Ndr64NonConformantStringBufferSize, Ndr64NonConformantStringBufferSize,
                   Ndr64NonConformantStringMemorySize, Ndr64NonConformantStringMemorySize,
                   Ndr64pNoopFree,                     Ndr64pNoopFree,
                   _STRING_ )

NDR64_TABLE_ENTRY( 0x63, FC64_CONF_CHAR_STRING,
                   Ndr64ConformantStringMarshall,      Ndr64ConformantStringMarshall,
                   Ndr64ConformantStringUnmarshall,    Ndr64ConformantStringUnmarshall,
                   Ndr64ConformantStringBufferSize,    Ndr64ConformantStringBufferSize,
                   Ndr64ConformantStringMemorySize,    Ndr64ConformantStringMemorySize,
                   Ndr64pNoopFree,                     Ndr64pNoopFree,
                   _STRING_ )
NDR64_TABLE_ENTRY( 0x64, FC64_CONF_WCHAR_STRING,
                   Ndr64ConformantStringMarshall,      Ndr64ConformantStringMarshall,
                   Ndr64ConformantStringUnmarshall,    Ndr64ConformantStringUnmarshall,
                   Ndr64ConformantStringBufferSize,    Ndr64ConformantStringBufferSize,
                   Ndr64ConformantStringMemorySize,    Ndr64ConformantStringMemorySize,
                   Ndr64pNoopFree,                     Ndr64pNoopFree,
                   _STRING_ )
NDR64_TABLE_ENTRY( 0x65, FC64_CONF_STRUCT_STRING,
                   Ndr64ConformantStringMarshall,      Ndr64ConformantStringMarshall,
                   Ndr64ConformantStringUnmarshall,    Ndr64ConformantStringUnmarshall,
                   Ndr64ConformantStringBufferSize,    Ndr64ConformantStringBufferSize,
                   Ndr64ConformantStringMemorySize,    Ndr64ConformantStringMemorySize,
                   Ndr64pNoopFree,                     Ndr64pNoopFree,
                   _STRING_ )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x66 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x67 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x68 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x69 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x6A )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x6B )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x6C )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x6D )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x6E )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x6F )

// Handles

NDR64_TABLE_ENTRY(  0x70, FC64_BIND_CONTEXT,
                    Ndr64MarshallHandle,           Ndr64MarshallHandle,
                    Ndr64UnmarshallHandle,         Ndr64UnmarshallHandle,
                    Ndr64ContextHandleSize,        Ndr64ContextHandleSize,
                    NULL,                          NULL,
                    Ndr64pNoopFree,                Ndr64pNoopFree,
                    _HANDLE_ )                     
NDR64_TABLE_ENTRY(  0x71, FC64_BIND_GENERIC,
                    NULL,                          NULL,
                    NULL,                          NULL,
                    NULL,                          NULL,
                    NULL,                          NULL,
                    Ndr64pNoopFree,                Ndr64pNoopFree,
                    _HANDLE_ )
NDR64_TABLE_ENTRY(  0x72, FC64_BIND_PRIMITIVE,
                    NULL,                          NULL,
                    NULL,                          NULL,
                    NULL,                          NULL,
                    NULL,                          NULL,
                    Ndr64pNoopFree,                Ndr64pNoopFree,
                    _HANDLE_ )

NDR64_UNUSED_TABLE_ENTRY( 0x73, FC64_AUTO_HANDLE )
NDR64_UNUSED_TABLE_ENTRY( 0x74, FC64_CALLBACK_HANDLE )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x75 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x76 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x77 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x78 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x79 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x7A )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x7B )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x7C )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x7D )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x7E )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x7F )

// Pointer Layout

NDR64_UNUSED_TABLE_ENTRY( 0x80, FC64_NO_REPEAT )
NDR64_UNUSED_TABLE_ENTRY( 0x81, FC64_FIXED_REPEAT )
NDR64_UNUSED_TABLE_ENTRY( 0x82, FC64_VARIABLE_REPEAT )
NDR64_UNUSED_TABLE_ENTRY( 0x83, FC64_FIXED_OFFSET )
NDR64_UNUSED_TABLE_ENTRY( 0x84, FC64_VARIABLE_OFFSET )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x85 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x86 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x87 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x88 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x89 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x8A )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x8B )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x8C )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x8D )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x8E )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x8F )


// Member layout
NDR64_UNUSED_TABLE_ENTRY( 0x90, FC64_STRUCTPADN )
NDR64_UNUSED_TABLE_ENTRY( 0x91, FC64_EMBEDDED_COMPLEX )
NDR64_UNUSED_TABLE_ENTRY( 0x92, FC64_BUFFER_ALIGN )
NDR64_UNUSED_TABLE_ENTRY( 0x93, FC64_END )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x94 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x95 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x96 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x97 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x98 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x99 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x9A )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x9B )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x9C )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x9D )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x9E )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x9F )

// Misc
NDR64_TABLE_ENTRY(  0xA0, FC64_TRANSMIT_AS,
                    Ndr64TopLevelXmitOrRepAsMarshall,      Ndr64EmbeddedXmitOrRepAsMarshall,
                    Ndr64TopLevelXmitOrRepAsUnmarshall,    Ndr64EmbeddedXmitOrRepAsUnmarshall,
                    Ndr64TopLevelXmitOrRepAsBufferSize,    Ndr64EmbeddedXmitOrRepAsBufferSize,
                    Ndr64TopLevelXmitOrRepAsMemorySize,    Ndr64EmbeddedXmitOrRepAsMemorySize,
                    Ndr64XmitOrRepAsFree,                  Ndr64XmitOrRepAsFree,
                    _XMIT_AS_ | _BY_VALUE_ )
NDR64_TABLE_ENTRY(  0xA1, FC64_REPRESENT_AS,
                    Ndr64TopLevelXmitOrRepAsMarshall,      Ndr64EmbeddedXmitOrRepAsMarshall,
                    Ndr64TopLevelXmitOrRepAsUnmarshall,    Ndr64EmbeddedXmitOrRepAsUnmarshall,
                    Ndr64TopLevelXmitOrRepAsBufferSize,    Ndr64EmbeddedXmitOrRepAsBufferSize, 
                    Ndr64TopLevelXmitOrRepAsMemorySize,    Ndr64EmbeddedXmitOrRepAsMemorySize,
                    Ndr64XmitOrRepAsFree,                  Ndr64XmitOrRepAsFree,
                    _XMIT_AS_ | _BY_VALUE_ )

NDR64_TABLE_ENTRY( 0xA2, FC64_USER_MARSHAL,
                   Ndr64TopLevelUserMarshalMarshall,    Ndr64EmbeddedUserMarshalMarshall,
                   Ndr64TopLevelUserMarshalUnmarshall,  Ndr64EmbeddedUserMarshalUnmarshall,
                   Ndr64TopLevelUserMarshalBufferSize,  Ndr64EmbeddedUserMarshallBufferSize,
                   Ndr64TopLevelUserMarshalMemorySize,  Ndr64EmbeddedUserMarshalMemorySize,
                   Ndr64UserMarshalFree,                Ndr64UserMarshalFree,
                   _XMIT_AS_ | _BY_VALUE_ )
NDR64_UNUSED_TABLE_ENTRY( 0xA3, FC64_PIPE )
NDR64_TABLE_ENTRY( 0xA4, FC64_RANGE,
                   Ndr64pRangeMarshall,            Ndr64pRangeMarshall,
                   Ndr64RangeUnmarshall,           Ndr64RangeUnmarshall,
                   Ndr64pRangeBufferSize,          Ndr64pRangeBufferSize,
                   Ndr64pRangeMemorySize,          Ndr64pRangeMemorySize,
                   Ndr64pRangeFree,                Ndr64pRangeFree,
                   0 )
NDR64_UNUSED_TABLE_ENTRY( 0xA5, FC64_PAD )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xA6 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xA7 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xA8 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xA9 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xAA )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xAB )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xAC )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xAD )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xAE )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xAF )

NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xB0 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xB1 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xB2 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xB3 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xB4 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xB5 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xB6 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xB7 )

NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xB8 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xB9 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xBA )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xBB )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xBC )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xBD )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xBE )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xBF )

NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xC0 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xC1 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xC2 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xC3 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xC4 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xC5 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xC6 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xC7 )

NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xC8 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xC9 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xCA )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xCB )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xCC )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xCD )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xCE )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xCF )

NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xD0 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xD1 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xD2 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xD3 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xD4 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xD5 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xD6 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xD7 )

NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xD8 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xD9 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xDA )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xDB )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xDC )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xDD )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xDE )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xDF )

NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xE0 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xE1 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xE2 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xE3 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xE4 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xE5 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xE6 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xE7 )

NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xE8 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xE9 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xEA )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xEB )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xEC )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xED )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xEE )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xEF )

NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xF0 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xF1 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xF2 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xF3 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xF4 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xF5 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xF6 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xF7 )

NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xF8 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xF9 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xFA )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xFB )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xFC )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xFD )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xFE )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xFF )

NDR64_TABLE_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\typelib\tllist.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999.
//
//  File:       tllist.cxx
//
//  Contents:   type library list class
//              and IUnknown holder
//
//  Classes:    CTypeLibraryList
//              CObjHolder
//
//  Functions:
//
//  History:    4-10-95   stevebl   Created
//
//----------------------------------------------------------------------------

#pragma warning ( disable : 4514 )

#include "tlcommon.hxx"
#include "tllist.hxx"
#include "filehndl.hxx"

class TLNODE{
public:
    char * szName;
    ITypeLib * pTL;
    class TLNODE * pNext;

    TLNODE()
    {
        pNext = NULL;
        pTL = NULL;
        szName = NULL;
    }

    ~TLNODE()
    {
        if (NULL != pTL)
        {
            pTL->Release();
        }
    }
};

CTypeLibraryList::~CTypeLibraryList()
{
    delete pItfList;
    TLNODE * pNext;
    while (NULL != pHead)
    {
        pNext = pHead->pNext;
        delete(pHead);
        pHead = pNext;
    }
    // make sure OLE gets uninitialized at the right time
    TLUninitialize();
}

#define _MAX_FILE_NAME (_MAX_DRIVE+_MAX_DIR+_MAX_FNAME+_MAX_EXT)
extern NFA_INFO* pImportCntrl;

BOOL CTypeLibraryList::Add(char *sz)
{
    TLNODE * pThis = new TLNODE;
    WCHAR * wsz = new WCHAR[MAX_PATH + 1];

    if (NULL == wsz || NULL == pThis)
        return FALSE;

    	// We need to find details of the file name. We need to see if the user
	// has already specified path, if so, override the current paths.
	// if the user has specified a file extension, get the extension. We
	// need to do that in order to have uniformity with the case where
	// a preprocessed file is input with a different extension

	char			agDrive[_MAX_DRIVE];
	char			agPath[_MAX_DIR];
	char			agName[_MAX_FNAME];
	char			agExt[_MAX_EXT];
    char            szFileName[ _MAX_PATH + _MAX_EXT + _MAX_FNAME + _MAX_DIR + _MAX_DRIVE ];

    _splitpath( sz, agDrive, agPath, agName, agExt );

	// if file is specified with a path, the user knows fully the location
	// else search for the path of the file

	if( !agPath[0] && !agDrive[0] )
		{
	    char			agNameBuf[ _MAX_FILE_NAME + 1];
        char*           pPath;

		sprintf(agNameBuf, "%s%s", agName, agExt);
		
        if( ( pPath = pImportCntrl->SearchForFile(agNameBuf) ) == 0 )
			{
            // TLB not found in the search paths.
            // it might be a system TLB <stdole2.tlb> which does not 
            // require a path. If TLB is not found, the error is caught
            // trying to load a non-existent TLB.
		    strcpy( szFileName, sz );
			}
        else
            {
            // TLB is found in the search path. Form the entire path to filename.
		    strcpy( szFileName, pPath );
		    strcat( szFileName, agNameBuf );
            }
		}
    else
        {
		strcpy( szFileName, sz );
        }

    A2O(wsz, szFileName, MAX_PATH);
    HRESULT hr = LateBound_LoadTypeLib(wsz, &(pThis->pTL));

    if SUCCEEDED(hr)
    {
        BSTR bstrName;
        // Add new libraries to the END of the list

        TLNODE ** ppTail = &pHead;
        while (*ppTail)
            ppTail = &((*ppTail)->pNext);

        pThis->pTL->GetDocumentation(-1, &bstrName, NULL, NULL, NULL);
        pThis->szName = TranscribeO2A( bstrName );
        LateBound_SysFreeString(bstrName);

        AddTypeLibraryMembers(pThis->pTL, sz);
        pThis->pNext = NULL;
        (*ppTail) = pThis;
        return TRUE;
    }
    else
        return FALSE;
}

ITypeLib * CTypeLibraryList::FindLibrary(char * sz)
{
    TLNODE * pThis = pHead;
    while (pThis)
    {
        if (0 == _stricmp(sz, pThis->szName))
            return pThis->pTL;
        pThis = pThis->pNext;
    }
    return NULL;
}

ITypeInfo * CTypeLibraryList::FindName(char * szFileHint, WCHAR * wsz)
{
    if (pHead)
    {
        if (0 == _stricmp(szFileHint, "unknwn.idl") || 0 == _stricmp(szFileHint, "oaidl.idl"))
        {
            szFileHint = "stdole";
        }
        BOOL fFirst = TRUE;
        TLNODE * pThis = pHead;
        while (pThis && szFileHint)
        {
            if (0 == _stricmp(szFileHint, pThis->szName))
                break;
            pThis = pThis->pNext;
        }
        if (!pThis)
        {
            pThis = pHead;
            fFirst = FALSE;
        }
        ITypeInfo * ptiFound;
        SYSKIND sk = ( SYSKIND ) ( pCommand->Is64BitEnv() ? SYS_WIN64 : SYS_WIN32 );
        ULONG lHashVal = LateBound_LHashValOfNameSys(sk, NULL, wsz);
        HRESULT hr;
        MEMBERID memid;
        unsigned short c;
        while (pThis)
        {
            c = 1;
            hr = pThis->pTL->FindName(wsz, lHashVal, &ptiFound, &memid, &c);
            if (SUCCEEDED(hr))
            {
                if (c)
                {
                    // found a matching name
                    if (-1 == memid)
                    {
                        return ptiFound;
                    }
                    // found a parameter name or some other non-global name
                    ptiFound->Release();
                }
            }
            if (fFirst)
            {
                pThis = pHead;
                fFirst = FALSE;
            }
            else
                pThis = pThis->pNext;
        }
    }
    return NULL;
}

class IUNKNODE
{
public:
    IUnknown * pUnk;
    char * szName;
    IUNKNODE * pNext;

    IUNKNODE()
    {
        pUnk = NULL;
        szName = NULL;
        pNext = NULL;
    }

    ~IUNKNODE()
    {
        if (NULL != pUnk)
        {
            pUnk->Release();
        }
    }
};

CObjHolder::~CObjHolder()
{
    IUNKNODE * pNext;
    while (pHead)
    {
        pNext = pHead->pNext;
        delete pHead;
        pHead = pNext;
    }
}

void CObjHolder::Add(IUnknown * pUnk, char * szName)
{
    IUNKNODE ** ppNext = &pHead;
    while (*ppNext && (*ppNext)->pUnk > pUnk)
    {
        ppNext = &((*ppNext)->pNext);
    }
    if (*ppNext && (*ppNext)->pUnk == pUnk)
    {
        // We already have this one ref-counted.
        pUnk->Release();
    }
    else
    {
        IUNKNODE * pNew = new IUNKNODE;
        pNew->szName = szName;
        pNew->pUnk = pUnk;
        pNew->pNext = *ppNext;
        *ppNext = pNew;
    }
}

IUnknown * CObjHolder::Find(char * szName)
{
    IUNKNODE * pThis = pHead;
    while (pThis)
    {
        if (NULL != pThis->szName && 0 == _stricmp(pThis->szName, szName))
            return pThis->pUnk;
        pThis = pThis->pNext;
    }
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr20\async.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1996-2000 Microsoft Corporation

Module Name :

    async.c

Abstract :

    This file contains the ndr async implementation.

Author :

    Ryszard K. Kott     (ryszardk)    Nov 1996

Revision History :

---------------------------------------------------------------------*/



#define USE_STUBLESS_PROXY

#define CINTERFACE

#include "ndrp.h"
#include "ndrole.h"
#include "rpcproxy.h"
#include "hndl.h"
#include "interp.h"
#include "interp2.h"
#include "pipendr.h"
#include "mulsyntx.h"
#include "asyncndr.h"
#include "attack.h"
#include <stdarg.h>

#pragma code_seg(".orpc")

#ifdef _PPC_
#error PPC code has been removed
#endif



CLIENT_CALL_RETURN  RPC_VAR_ENTRY
NdrAsyncClientCall(
    PMIDL_STUB_DESC     pStubDescriptor,
    PFORMAT_STRING      pFormat,
    ...
    )
/*
    This entry is used for raw rpc only.
    No support for OLE [async] attribute anymore.
*/
{
    va_list             ArgList;
    unsigned char  *    StartofStack;
    CLIENT_CALL_RETURN  Ret;
    //
    // Get address of argument to this function following pFormat. This
    // is the address of the address of the first argument of the function
    // calling this function.
    // Then get the address of the stack where the parameters are.
    //

    RPC_ASYNC_HANDLE            AsyncHandle;
    PNDR_ASYNC_MESSAGE          pAsyncMsg;

    RPC_MESSAGE *               pRpcMsg;
    MIDL_STUB_MESSAGE *         pStubMsg;
    ulong                       ProcNum, RpcFlags;

    handle_t                    Handle;
    uchar                       HandleType;
    INTERPRETER_FLAGS           OldOiFlags;
    INTERPRETER_OPT_FLAGS       NewOiFlags;
    PPARAM_DESCRIPTION          Params;

    RPC_STATUS                  Status;
    NDR_PROC_CONTEXT            *pContext; 

    Ret.Simple = 0;

    INIT_ARG( ArgList, pFormat);
    GET_FIRST_IN_ARG(ArgList);
    StartofStack = (uchar *) GET_STACK_START(ArgList);

    pAsyncMsg = (NDR_ASYNC_MESSAGE*) I_RpcBCacheAllocate( sizeof( NDR_ASYNC_MESSAGE) );
    if ( ! pAsyncMsg )
        Status = RPC_S_OUT_OF_MEMORY;
    else
        {
        memset( pAsyncMsg, 0, sizeof( NDR_ASYNC_MESSAGE ) );
        ProcNum = MulNdrpInitializeContextFromProc( 
                                     XFER_SYNTAX_DCE, 
                                     pFormat,
                                    &pAsyncMsg->ProcContext,
                                     NULL );    // server StartofStack
                                     
        Status = NdrpInitializeAsyncMsg( 
                                     StartofStack,
                                     pAsyncMsg );
        }
        
    if ( Status )
        {
        // if something is wrong during setup, we need to cleanup 
        // immediately. We have to process format string here explicitly
        NDR_PROC_CONTEXT TempContext;
        MIDL_STUB_MESSAGE      StubMsgTemp;
        ProcNum = MulNdrpInitializeContextFromProc( 
                                     XFER_SYNTAX_DCE, 
                                     pFormat,
                                    &TempContext,
                                     NULL );    // server StartofStack

        OldOiFlags = TempContext.NdrInfo.InterpreterFlags;
        if ( OldOiFlags.HasCommOrFault )
            {

            // It's easier to map the error here than to go through the error
            // recovery and normal cleanup without valid handle etc.

            StubMsgTemp.StubDesc = pStubDescriptor;
            StubMsgTemp.StackTop = StartofStack;

            NdrClientMapCommFault( & StubMsgTemp,
                                   ProcNum,
                                   Status,
                                   (ULONG_PTR*) &Ret.Simple );
            return Ret;
            }
        else
            RpcRaiseException( Status );
        }

    pContext = &pAsyncMsg->ProcContext;
    HandleType = pContext->HandleType;
    NewOiFlags = pContext->NdrInfo.pProcDesc->Oi2Flags;
    OldOiFlags = pContext->NdrInfo.InterpreterFlags;
    Params = (PARAM_DESCRIPTION *)pContext->Params;

    // We need to switch to our copy of the stack everywhere, including pStubMsg.

    StartofStack = pAsyncMsg->ProcContext.StartofStack;

    // We abstract the level of indirection here.

    AsyncHandle = pAsyncMsg->AsyncHandle;

    pRpcMsg   = & pAsyncMsg->RpcMsg;
    pStubMsg  = & pAsyncMsg->StubMsg;

    //
    // Set Params and NumberParams before a call to initialization.
    //

    // Wrap everything in a try-finally pair. The finally clause does the
    // required freeing of resources (RpcBuffer and Full ptr package).
    //
    RpcTryFinally
        {
        // Use a nested try-except pair to support [comm_status][fault_status].
        //
        RpcTryExcept
            {
            BOOL fRaiseExcFlag;

            NdrClientInitializeNew( pRpcMsg,
                                    pStubMsg,
                                    pStubDescriptor,
                                    (uint) ProcNum );

            if ( HandleType )
                {
                //
                // We have an implicit handle.
                //
                Handle = ImplicitBindHandleMgr( pStubDescriptor,
                                                HandleType,
                                                &pContext->SavedGenericHandle);
                }
            else
                {
                Handle = ExplicitBindHandleMgr( pStubDescriptor,
                                                StartofStack,
                                                (PFORMAT_STRING)pContext->pHandleFormatSave,
                                                &pContext->SavedGenericHandle );
                }

            pStubMsg->pAsyncMsg = pAsyncMsg;

            NdrpClientInit( pStubMsg, 
                            NULL );     // return value

            
            //
            // Skip buffer size pass if possible.
            //
            if ( NewOiFlags.ClientMustSize )
                {
                NdrpSizing( pStubMsg,
                            TRUE );     // isclient
                }

            pRpcMsg->RpcFlags |= RPC_BUFFER_ASYNC;

            if ( NewOiFlags.HasPipes )
                NdrGetPipeBuffer( pStubMsg,
                                  pStubMsg->BufferLength,
                                  Handle );
            else
                NdrGetBuffer( pStubMsg,
                              pStubMsg->BufferLength,
                              Handle );

            NDR_ASSERT( pStubMsg->fBufferValid, "Invalid buffer" );

            // Let runtime associate async handle with the call.

            NdrpRegisterAsyncHandle( pStubMsg, AsyncHandle );

            pAsyncMsg->StubPhase = NDR_ASYNC_SET_PHASE;

            //
            // ----------------------------------------------------------
            // Marshall Pass.
            // ----------------------------------------------------------
            //

            NdrpClientMarshal( pStubMsg,
                         FALSE );   // IsObject
                         
            pAsyncMsg->StubPhase = NDR_ASYNC_CALL_PHASE;

            NdrAsyncSend( pStubMsg,
                          NewOiFlags.HasPipes && pContext->pPipeDesc->InPipes );

            pAsyncMsg->Flags.ValidCallPending = 1;
            }
        RpcExcept( OldOiFlags.HasCommOrFault )
            {
            RPC_STATUS ExceptionCode = RpcExceptionCode();

            // Actually dismantle the call.
            // This is a request call and there is nothing left at the runtime.

            pAsyncMsg->StubPhase = NDR_ASYNC_ERROR_PHASE;

            NdrClientMapCommFault( pStubMsg,
                                   ProcNum,
                                   ExceptionCode,
                                   (ULONG_PTR*) &Ret.Simple );
            }
        RpcEndExcept
        }
    RpcFinally
        {
        if ( pAsyncMsg->Flags.ValidCallPending )
            {
            if ( NewOiFlags.HasPipes )
                {
                NdrMarkNextActivePipe( pContext->pPipeDesc );
                pContext->pPipeDesc->Flags.NoBufferCallPending = 1;
                }
            }
        else
            {
            // Cleanup everything but the user's handle.

            NdrpFreeAsyncMsg( pAsyncMsg );

            AsyncHandle->StubInfo = 0;
            }

        InterlockedDecrement( & AsyncHandle->Lock );
        }
    RpcEndFinally

    return Ret;
}


RPC_STATUS
NdrpCompleteAsyncClientCall(
    RPC_ASYNC_HANDLE            AsyncHandle,
    PNDR_ASYNC_MESSAGE          pAsyncMsg,
    void *                      pReturnValue
    )
{
    RPC_MESSAGE *               pRpcMsg   = & pAsyncMsg->RpcMsg;
    MIDL_STUB_MESSAGE *         pStubMsg  = & pAsyncMsg->StubMsg;

    PFORMAT_STRING              pFormatParam;
    NDR_PROC_CONTEXT        *   pContext   = &pAsyncMsg->ProcContext;
    NDR_PROC_INFO           *   pNdrInfo  = &pContext->NdrInfo;
    INTERPRETER_FLAGS           OldOiFlags       = pNdrInfo->InterpreterFlags;
    INTERPRETER_OPT_FLAGS       NewOiFlags       = pNdrInfo->pProcDesc->Oi2Flags;
    PPARAM_DESCRIPTION          Params           = (PPARAM_DESCRIPTION )pContext->Params;
    uchar *                     StartofStack     = pContext->StartofStack ;

    PMIDL_STUB_DESC             pStubDescriptor  = pStubMsg->StubDesc;
    ulong                       RpcFlags         = pRpcMsg->RpcFlags;

    ULONG_PTR                   RetVal           = 0;

    long                        NumberParams     = pContext->NumberParams;
    long                        n;
    NDR_ASYNC_CALL_FLAGS        CallFlags = pAsyncMsg->Flags;
                                            
    RpcTryFinally
        {
        // Use a nested try-except pair to support [comm_status][fault_status].
        //
        RpcTryExcept
            {

            if ( ! CallFlags.ValidCallPending )
                RpcRaiseException( RPC_S_INVALID_ASYNC_HANDLE );

            CallFlags.ValidCallPending = 0;

            // Non-pipe case or after pipe args case.

            // runtime could issue a call complete notification if netowrk failed, before it issues 
            // a read notification. We could come to here beccause the call failed yet NDR doesn't 
            // know at this point. We'll check the status first here
            // call_pending: we should check pipe as usual
            if ( NewOiFlags.HasPipes )
                {
                RPC_STATUS rc = RpcAsyncGetCallStatus( AsyncHandle );
                if ( rc == RPC_S_OK  || rc == RPC_S_ASYNC_CALL_PENDING )
                    NdrIsAppDoneWithPipes( pContext->pPipeDesc );
                else
                    RpcRaiseException( rc );
                }

            NdrLastAsyncReceive( pStubMsg );

            //
            // ----------------------------------------------------------
            // Unmarshall Pass.
            // ----------------------------------------------------------
            //

            NdrpClientUnMarshal( pStubMsg, 
                           (CLIENT_CALL_RETURN *)pReturnValue  );
                           

            }
        RpcExcept( OldOiFlags.HasCommOrFault )
            {
            RPC_STATUS ExceptionCode = RpcExceptionCode();

            CallFlags.ValidCallPending = ExceptionCode == RPC_S_ASYNC_CALL_PENDING;

                NdrClientMapCommFault( pStubMsg,
                                       pRpcMsg->ProcNum,
                                       ExceptionCode,
                                       &RetVal );

                if ( ExceptionCode == RPC_S_ASYNC_CALL_PENDING )
                    {
                    // If the call is just pending, force the pending error code
                    // to show up in the return value of RpcAsyncCallComplete.

                    RetVal = RPC_S_ASYNC_CALL_PENDING;
                    }
            }
        RpcEndExcept

        }
    RpcFinally
        {
        // There is only one way a valid call may be pending at this stage:
        // that is the receive call returned with RPC_S_CALL_PENDING.

        if ( ! CallFlags.ValidCallPending )
            {
            // Cleanup everything. However, don't free user's handle.

            NdrpFreeAsyncMsg( pAsyncMsg );

            AsyncHandle->StubInfo = 0;
            }

        InterlockedDecrement( & AsyncHandle->Lock );
        }
    RpcEndFinally

    return (RPC_STATUS)RetVal;
}


void RPC_ENTRY
NdrAsyncServerCall(
    PRPC_MESSAGE    pRpcMsg
    )
/*++
Routine Description :

    The server side entry point for regular asynchronous RPC procs.

Arguments :

    pRpcMsg         - The RPC message.

Return :

    None.
--*/
{
    RPC_ASYNC_HANDLE        AsyncHandle = 0;
    PNDR_ASYNC_MESSAGE      pAsyncMsg;

    PRPC_SERVER_INTERFACE   pServerIfInfo;
    PMIDL_SERVER_INFO       pServerInfo;
    PMIDL_STUB_DESC         pStubDesc;
    const SERVER_ROUTINE  * DispatchTable;
    ushort                  ProcNum;

    ushort                  FormatOffset;
    PFORMAT_STRING          pFormat;
    PFORMAT_STRING          pFormatParam;

    PMIDL_STUB_MESSAGE      pStubMsg;

    uchar *                 pArgBuffer;
    uchar **                ppArg;

    PPARAM_DESCRIPTION      Params;
    INTERPRETER_FLAGS       OldOiFlags;
    INTERPRETER_OPT_FLAGS   NewOiFlags;
    long                    NumberParams;


    ushort                  ClientBufferSize;
    BOOL                    HasExplicitHandle;
    long                    n;
    NDR_PROC_CONTEXT        * pContext;

    RPC_STATUS              Status = RPC_S_OK;


    //
    // In the case of a context handle, the server side manager function has
    // to be called with NDRSContextValue(ctxthandle). But then we may need to
    // marshall the handle, so NDRSContextValue(ctxthandle) is put in the
    // argument buffer and the handle itself is stored in the following array.
    // When marshalling a context handle, we marshall from this array.
    //
    // The handle table is part of the async handle.

    ProcNum = (ushort) pRpcMsg->ProcNum;

    NDR_ASSERT( ! ((ULONG_PTR)pRpcMsg->Buffer & 0x7),
                "marshaling buffer misaligned at server" );

    pServerIfInfo = (PRPC_SERVER_INTERFACE)pRpcMsg->RpcInterfaceInformation;
    pServerInfo = (PMIDL_SERVER_INFO)pServerIfInfo->InterpreterInfo;
    DispatchTable = pServerInfo->DispatchTable;

    pStubDesc = pServerInfo->pStubDesc;

    FormatOffset = pServerInfo->FmtStringOffset[ProcNum];
    pFormat = &((pServerInfo->ProcString)[FormatOffset]);

    
    AsyncHandle = 0;
    pAsyncMsg = (NDR_ASYNC_MESSAGE*) I_RpcBCacheAllocate( sizeof( NDR_ASYNC_MESSAGE) );
    if ( ! pAsyncMsg )
        Status = RPC_S_OUT_OF_MEMORY;
    else
        {
        memset( pAsyncMsg, 0, sizeof( NDR_ASYNC_MESSAGE ) );
        MulNdrpInitializeContextFromProc( 
                                     XFER_SYNTAX_DCE, 
                                     pFormat,
                                    &pAsyncMsg->ProcContext,
                                     NULL );    // server StartofStack

        Status = NdrpInitializeAsyncMsg( 0,                 // StartofStack, server
                                         pAsyncMsg
                                    );
        }
        
    if ( Status )
        RpcRaiseException( Status );

    pAsyncMsg->StubPhase = STUB_UNMARSHAL;

    pStubMsg = & pAsyncMsg->StubMsg;

    // from Kamen: 
    // we don't need to copy RpcMsg : it's provided by runtime in server side
    pContext = &pAsyncMsg->ProcContext;
    // setup the type format string in old code.
    pContext->DceTypeFormatString = pStubDesc->pFormatTypes;

    pStubMsg->RpcMsg = pRpcMsg;
    pStubMsg->SavedContextHandles = pAsyncMsg->CtxtHndl;

    // The arg buffer is zeroed out already.
    pArgBuffer = pAsyncMsg->ProcContext.StartofStack;

    OldOiFlags = pContext->NdrInfo.InterpreterFlags;
    NewOiFlags = pContext->NdrInfo.pProcDesc->Oi2Flags;
    NumberParams = pContext->NumberParams;
    Params = ( PPARAM_DESCRIPTION ) pContext->Params;
    //
    // Wrap the unmarshalling and the invoke call in the try block of
    // a try-finally. Put the free phase in the associated finally block.
    //
    BOOL        fManagerCodeInvoked = FALSE;
    BOOL        fErrorInInvoke = FALSE;
    RPC_STATUS  ExceptionCode = 0;

    // We abstract the level of indirection here.

    AsyncHandle = pAsyncMsg->AsyncHandle;

    RpcTryFinally
    {
        RpcTryExcept
        {
        // Put the async handle on stack.
        ((void **)pArgBuffer)[0] = AsyncHandle;  

        NdrpServerInit( pStubMsg, 
                        pRpcMsg, 
                        pStubDesc, 
                        NULL,       // pThis
                        NULL,       // pChannel
                        pAsyncMsg ); 

        // Let runtime associate async handle with the call.

        NdrpRegisterAsyncHandle( pStubMsg, AsyncHandle );

        pAsyncMsg->StubPhase = NDR_ASYNC_SET_PHASE;
            
        NdrpServerUnMarshal( pStubMsg  ); 

            if ( pRpcMsg->BufferLength  <
                 (uint)(pStubMsg->Buffer - (uchar *)pRpcMsg->Buffer) )
                {
                RpcRaiseException( RPC_X_BAD_STUB_DATA );
                }


            }
        RpcExcept( NdrServerUnmarshallExceptionFlag(GetExceptionInformation()) )
            {
            ExceptionCode = RpcExceptionCode();

            if( RPC_BAD_STUB_DATA_EXCEPTION_FILTER )
                {
                ExceptionCode = RPC_X_BAD_STUB_DATA;
                }

            // we always free the memory list if exception happened 
            // during unmarshalling. Exception code will tell if this
            // is really RPC_X_BAD_STUB_DATA;
            pAsyncMsg->Flags.BadStubData = 1;
            pAsyncMsg->ErrorCode = ExceptionCode;
            NdrpFreeMemoryList( pStubMsg );
            RpcRaiseException( ExceptionCode );
            }
        RpcEndExcept

        // Two separate blocks because the filters are different.
        // We need to catch exception in the manager code separately
        // as the model implies that there will be no other call from
        // the server app to clean up.

        RpcTryExcept
            {
            //
            // Do [out] initialization before the invoke.
            //

            NdrpServerOutInit( pStubMsg );

            //
            // Unblock the first pipe; this needs to be after unmarshalling
            // because the buffer may need to be changed to the secondary one.
            // In the out only pipes case this happens immediately.
            //
            if ( NewOiFlags.HasPipes )
                NdrMarkNextActivePipe( pContext->pPipeDesc );

            pAsyncMsg->StubPhase = STUB_CALL_SERVER;

            //
            // Check for a thunk.  Compiler does all the setup for us.
            //
            if ( pServerInfo->ThunkTable && pServerInfo->ThunkTable[ProcNum] )
                {
                pAsyncMsg->Flags.ValidCallPending = 1;
                InterlockedDecrement( & AsyncHandle->Lock );

                fManagerCodeInvoked = TRUE;
                fErrorInInvoke = TRUE;
                pServerInfo->ThunkTable[ProcNum]( pStubMsg );
                }
            else
                {
                //
                // Note that this ArgNum is not the number of arguments declared
                // in the function we called, but really the number of
                // REGISTER_TYPEs occupied by the arguments to a function.
                //
                long                ArgNum;
                MANAGER_FUNCTION    pFunc;
                REGISTER_TYPE       returnValue;

                if ( pRpcMsg->ManagerEpv )
                    pFunc = ((MANAGER_FUNCTION *)pRpcMsg->ManagerEpv)[ProcNum];
                else
                    pFunc = (MANAGER_FUNCTION) DispatchTable[ProcNum];

                ArgNum = (long) pContext->StackSize / sizeof(REGISTER_TYPE);

                //
                // The StackSize includes the size of the return. If we want
                // just the number of REGISTER_TYPES, then ArgNum must be reduced
                // by 1 when there is a return value AND the current ArgNum count
                // is greater than 0.
                //
                if ( ArgNum && NewOiFlags.HasReturn )
                    ArgNum--;

                // Being here means that we can expect results. Note that the user
                // can call RpcCompleteCall from inside of the manager code.

                pAsyncMsg->Flags.ValidCallPending = 1;

                // Unlock the handle - the app is allowed to call RpCAsyncManager
                //  or RpcAsyncAbort from the manager code.

                InterlockedDecrement( & AsyncHandle->Lock );

                fManagerCodeInvoked = TRUE;
                fErrorInInvoke = TRUE;

                returnValue = Invoke( pFunc,
                                      (REGISTER_TYPE *)pArgBuffer,
#if defined(_WIN64)
                                      NewOiFlags.HasExtensions ? ((PNDR_PROC_HEADER_EXTS64)&pContext->NdrInfo.pProcDesc->NdrExts)->FloatArgMask
                                                               : 0,
#endif
                                      ArgNum);

                // We are discarding the return value as it is not the real one.
                // The real return value is passed in the complete call.
                }

            fErrorInInvoke = FALSE;
            }
        RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) )
            {
            ExceptionCode = RpcExceptionCode();

            if ( ExceptionCode == 0 )
                ExceptionCode = ERROR_INVALID_PARAMETER;

            // We may not have the async message around anymore.

            RpcRaiseException( ExceptionCode );
            }
        RpcEndExcept

        }
    RpcFinally
        {
        if ( fManagerCodeInvoked  &&  !fErrorInInvoke )
            {
            // Success. Just skip everything if the manager code was invoked
            // and returned successfully.
            // Note that manager code could have called Complete or Abort by now
            // and so the async handle may not be valid anymore.
            }
        else
            {
            // See if we can clean up;

            Status = RPC_S_OK;
            if ( fErrorInInvoke )
                {
                // After an exception in invoking, let's see if we can get a hold
                // of the handle. If so, we will be able to clean up.
                // If not, there may be a leak there that we can do nothing about.
                // The rule is: after an exception the app cannot call Abort or
                // Complete. So, we need to force complete if we can.

                Status = NdrValidateBothAndLockAsyncHandle( AsyncHandle );
                }

            if ( Status == RPC_S_OK )
                {
                // Something went wrong but we are able to do the cleanup.

                // Cleanup parameters and async message/handle.
                // propagate the exception.

                NdrpCleanupServerContextHandles( pStubMsg,
                                                 pArgBuffer,
                                                 TRUE ); // die in manager routine 
                
                if (!pAsyncMsg->Flags.BadStubData)
                   {
                   NdrpFreeParams( pStubMsg,
                                   NumberParams,
                                   Params,
                                   pArgBuffer );
                   }

                NdrpFreeAsyncHandleAndMessage( AsyncHandle );
                }

            // else manager code invoked and we could not recover.
            // Exception will be raised by the EndFinally below.
            }

        }
    RpcEndFinally
}


RPC_STATUS
NdrpCompleteAsyncServerCall(
    RPC_ASYNC_HANDLE            AsyncHandle,
    PNDR_ASYNC_MESSAGE          pAsyncMsg,
    void *                      pReturnValue
    )
/*++

Routine Description :

    Complete an async call on the server side.  If an exception occurs, the
    asynchronous rpc call is aborted with the exception code and the server side
    caller is returned S_OK.

Arguments :

    AsyncHandle  - validated asynchronous handle,
    pAsyncMsg    - pointer to async msg structure,
    pReturnValue - pointer to the return value to be passed to the client.

Return :

    Status of S_OK.

--*/
{
    // in the server side, we don't use pAsyncMsg->RpcMsg. for Kamen 
    MIDL_STUB_MESSAGE *     pStubMsg       = & pAsyncMsg->StubMsg;
    RPC_MESSAGE *           pRpcMsg        = pStubMsg->RpcMsg;

    PFORMAT_STRING          pFormatParam;
    NDR_PROC_CONTEXT   *    pContext       = & pAsyncMsg->ProcContext;
    
    INTERPRETER_FLAGS       OldOiFlags     = pContext->NdrInfo.InterpreterFlags;
    INTERPRETER_OPT_FLAGS   NewOiFlags     = pContext->NdrInfo.pProcDesc->Oi2Flags;
    PPARAM_DESCRIPTION      Params         = ( PPARAM_DESCRIPTION )pContext->Params;
    uchar *                 pArgBuffer     = pContext->StartofStack;
    unsigned long           StackSize      = pContext->StackSize;
    PMIDL_STUB_DESC         pStubDesc      = pStubMsg->StubDesc;

    long                    NumberParams   = pContext->NumberParams;
    long                    n;
    boolean                 fParamsFreed   = FALSE;

    //
    // Wrap the unmarshalling, mgr call and marshalling in the try block of
    // a try-except. Put the call to abort in the except clause.
    //
    RpcTryExcept
    {
        // At this point, this is a valid RPC call since the asynchronous handle
        // is owned by NDR on the server side and NDR passes the handle
        // to the server during the invoke call.  During invoke
        // the parameters have already been unmarshalled.

        pAsyncMsg->StubPhase = STUB_MARSHAL;

        if( NewOiFlags.HasReturn )
            {
            // Put user's return value on the stack as usual.
            // See the invoke for comments on folding return into the arg satck.

            NDR_ASSERT( !pContext->HasComplexReturn, "complex return is not supported in async" );

            long  ArgNum = (long) StackSize / sizeof(REGISTER_TYPE);

            if ( ArgNum )
                ArgNum--;

            if ( ! pReturnValue )
                RpcRaiseException( RPC_S_INVALID_ARG );

            // We don't support return value larger than register_type,
            // and memcpy avoid alignment issue.
            if ( Params[NumberParams-1].ParamAttr.IsBasetype )
                memcpy( &((REGISTER_TYPE *)pArgBuffer)[ArgNum], 
                    pReturnValue, 
                    (size_t)SIMPLE_TYPE_MEMSIZE( Params[NumberParams-1].SimpleType.Type ) );
            else
                ((REGISTER_TYPE *)pArgBuffer)[ArgNum] = *(REGISTER_TYPE*)pReturnValue;
            }

        //
        // Buffer size pass.
        //
        ushort  ConstantBufferSize = pContext->NdrInfo.pProcDesc->ServerBufferSize;

        if ( NewOiFlags.HasPipes )
            {
            NdrIsAppDoneWithPipes( pContext->pPipeDesc );
            pStubMsg->BufferLength += ConstantBufferSize;
            }
        else
            pStubMsg->BufferLength = ConstantBufferSize;

        if ( NewOiFlags.ServerMustSize )
            {
            NdrpSizing( pStubMsg,
                        FALSE );    // this is server
            }

        // Get buffer.

        if ( NewOiFlags.HasPipes && pContext->pPipeDesc->OutPipes )
            {
            NdrGetPartialBuffer( pStubMsg );
            pStubMsg->RpcMsg->RpcFlags &= ~RPC_BUFFER_PARTIAL;
            }
        else
            {
            NdrGetBuffer( pStubMsg,
                          pStubMsg->BufferLength,
                          0 );
            }

        //
        // Marshall pass.
        //
        NdrpServerMarshal( pStubMsg,
                     FALSE );   // IsObject

        pRpcMsg->BufferLength = (ulong)(pStubMsg->Buffer - (uchar *)pRpcMsg->Buffer);

        // We don't drop to the runtime like for synchronous calls,
        // we send the last buffer explicitly.

        // set the freed flag.
        fParamsFreed = TRUE;
        /*
            we have to do release twice here:
                After the last piece of data is sent via NdrAsyncSend, dispatch buffer
            will be freed by runtime. We'll have problem calling ndr free routines to
            free unique pointers (where both pointer and pointee are in the buffer). So
            we call ndr free routines BEFORE the send, because it won't free anything
            inside dispatch buffer, and runtime send only cares about dispatch buffer.
                We still have to call ndr free routines in RpcFinally for exception cleanup. we
            check the flag to avoid calling free twice.
        */
        NdrpFreeParams( pStubMsg,
                        NumberParams,
                        Params,
                        pArgBuffer );

        NdrAsyncSend( pStubMsg,
                      FALSE );    // the last call is always non-partial
        }
    RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) )
        {

        // Abort the call which will result in the exception being propagated to
        // the client.

        NdrpAsyncAbortCall( AsyncHandle,
                            pAsyncMsg,
                            RpcExceptionCode(),
                            !fParamsFreed ); // Do not free if second attempt.
        return S_OK;
        }
    RpcEndExcept

    NdrpFreeAsyncHandleAndMessage( AsyncHandle );
    return S_OK;
}



RPC_STATUS
NdrpInitializeAsyncMsg(
    void *              StartofStack,
    PNDR_ASYNC_MESSAGE  pAsyncMsg )
/*
    This method creates and initializes async msg.
    Additionally, it creates the handle itself in object case.

    pHandleArg      - pointer to the proc's async handle argument.
                      Note the handle arg semantics on the client:
                      *pHandleArg is
                        raw: a handle (arg is a *)
                                - the handle cannot be 0
                        obj: a pHandle (arg is a **)
                                pHandle ==0 means a "don't care" call
                               *pHandle ==0 means "create handle while calling"
                               *pHandle !=0 means a handle created by the app.

    StartofStack    - side marker as well:
                        != 0 - client
                        == 0 - server
*/
{
    RPC_STATUS          Status = 0;
    BOOL                fIsClient = StartofStack != 0;
    BOOL                fHandleCreated = FALSE;
    RPC_ASYNC_HANDLE    AsyncHandle = 0;
    RPC_ASYNC_HANDLE *  pHandleArg = (RPC_ASYNC_HANDLE *)StartofStack;

    // Do this first to simplify error conditions.


    ulong  StackSize =  pAsyncMsg->ProcContext.StackSize;

    
    if ( fIsClient )
        {
        // Client always supplies a handle.

        if ( *pHandleArg )
            {
            AsyncHandle = *pHandleArg;
            Status = NdrpValidateAndLockAsyncHandle( AsyncHandle );
            }
        else
            Status = RPC_S_INVALID_ASYNC_HANDLE;
        }
    else
        {
        // Server - the stub creates the handle.

        AsyncHandle = (RPC_ASYNC_STATE *)I_RpcAllocate( sizeof(RPC_ASYNC_STATE) );
        if ( ! AsyncHandle )
            Status = RPC_S_OUT_OF_MEMORY;
        else
            {
            MIDL_memset( AsyncHandle, 0x0, sizeof( RPC_ASYNC_STATE) );
            RpcAsyncInitializeHandle( AsyncHandle, RPC_ASYNC_VERSION_1_0 );
            AsyncHandle->Lock = 1;
            fHandleCreated = TRUE;
            }
        }

    if ( Status )
        {
        I_RpcBCacheFree( pAsyncMsg );
        return Status;
        }

    // Initialize the async message properly

    pAsyncMsg->Signature = NDR_ASYNC_SIGNATURE;
    pAsyncMsg->Version   = NDR_ASYNC_VERSION;
    pAsyncMsg->StubMsg.pContext = & pAsyncMsg->ProcContext;

    pAsyncMsg->ProcContext.StartofStack = (uchar *) NdrpAlloca( 
                & pAsyncMsg->ProcContext.AllocateContext, 
                StackSize );

    // Must do this before the sizing pass!
    pAsyncMsg->StubMsg.StackTop = (uchar *)StartofStack;
    
    pAsyncMsg->StubPhase    = NDR_ASYNC_PREP_PHASE;

    if ( fIsClient )
        {
        // Client: copy stack from the app's request call.
        RpcpMemoryCopy( pAsyncMsg->ProcContext.StartofStack, StartofStack, StackSize );
        }
    else
        {
        // Server: zero out stack for allocs.
        MIDL_memset( pAsyncMsg->ProcContext.StartofStack, 0x0, StackSize );
        }

    MIDL_memset( pAsyncMsg->AsyncGuard,
                 0x71,
                 NDR_ASYNC_GUARD_SIZE );

    AsyncHandle->StubInfo  = pAsyncMsg;
    pAsyncMsg->AsyncHandle = AsyncHandle;

    return RPC_S_OK;
}


void
NdrpFreeAsyncMsg(
    PNDR_ASYNC_MESSAGE  pAsyncMsg )
/*
    This routine would free the AsyncMsg but not the AsyncHandle, as on the server
    the user may need it and on the client it is user's to begin with.
*/
{
    NDR_PROC_CONTEXT    * pContext = & pAsyncMsg->ProcContext;
    if ( pAsyncMsg )
        {
        PMIDL_STUB_MESSAGE  pStubMsg  = & pAsyncMsg->StubMsg;

        NdrFullPointerXlatFree(pStubMsg->FullPtrXlatTables);

        NdrCorrelationFree( pStubMsg );

        // Free the RPC buffer.

        if ( pStubMsg->IsClient )
            {
            if ( ! pAsyncMsg->Flags.RuntimeCleanedUp )
                NdrFreeBuffer( pStubMsg );
            }


        RPC_STATUS Status = 0;

        if ( pStubMsg->IsClient )
            {
            if ( pContext->SavedGenericHandle )
                {
                // Note that we cannot unbind after freeing the handle as the stack would be gone.

                RpcTryExcept
                    {
                    GenericHandleUnbind( pStubMsg->StubDesc,
                                         pContext->StartofStack,
                                         pContext->pHandleFormatSave,
                                         (pContext->HandleType) ? IMPLICIT_MASK : 0,
                                         & pContext->SavedGenericHandle );
                    }
                RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) )
                    {
                    Status = RpcExceptionCode();
                    }
                RpcEndExcept;
                }
            }

        NdrpAllocaDestroy( &pContext->AllocateContext );

        // Prevent reusing of a handle that has been freed;
        pAsyncMsg->Signature = NDR_FREED_ASYNC_SIGNATURE;

        I_RpcBCacheFree( pAsyncMsg );

        if ( Status )
            RpcRaiseException( Status );
        }
}


VOID
NdrpFreeAsyncHandleAndMessage(
    PRPC_ASYNC_STATE  AsyncHandle)
/*++

Routine Description:
    Frees an async handle and its associated async message.

Arguments:
    AsyncHandle - Supplies the async handle to be freed.

Return Value:
    None.
--*/
{
    PNDR_ASYNC_MESSAGE pAsyncMsg = (PNDR_ASYNC_MESSAGE)AsyncHandle->StubInfo;
    NdrpFreeAsyncMsg( pAsyncMsg );

    AsyncHandle->StubInfo = 0;
    AsyncHandle->Signature = RPC_FREED_ASYNC_SIGNATURE;
    I_RpcFree( AsyncHandle );
}


void
NdrAsyncSend(
    PMIDL_STUB_MESSAGE  pStubMsg,
    BOOL                fPartialSend )
{
    pStubMsg->RpcMsg->RpcFlags |= RPC_BUFFER_ASYNC;

    if ( fPartialSend )
        NdrPartialSend( pStubMsg->pContext->pPipeDesc,
                        pStubMsg );
    else
        {
        NdrSend( 0,         // not used
                 pStubMsg,
                 FALSE );   // not partial
        }
}


void
NdrLastAsyncReceive(
    PMIDL_STUB_MESSAGE  pStubMsg )
{
    pStubMsg->RpcMsg->RpcFlags |= RPC_BUFFER_ASYNC;

    // A complete call.
    // We may have a complete buffer already when pipes are involved.

    if ( pStubMsg->pContext->pPipeDesc )
        {
        if ( pStubMsg->RpcMsg->RpcFlags & RPC_BUFFER_COMPLETE )
            return;
        
        if ( pStubMsg->pContext->pPipeDesc->OutPipes ) 
            {
            pStubMsg->RpcMsg->RpcFlags |= RPC_BUFFER_EXTRA;
            }
        else 
            {
            pStubMsg->RpcMsg->RpcFlags &= ~RPC_BUFFER_EXTRA;
            }

        }
           

    NdrReceive( pStubMsg->pContext->pPipeDesc,
                pStubMsg,
                0,         // size, ignored for complete calls
                FALSE );   // complete buffer
}


void
NdrpRegisterAsyncHandle(
    PMIDL_STUB_MESSAGE  pStubMsg,
    void *              AsyncHandle )
{
    RPC_STATUS Status;

    Status = I_RpcAsyncSetHandle( pStubMsg->RpcMsg,
                                  (RPC_ASYNC_STATE *)AsyncHandle );

    if ( Status )
        RpcRaiseException( Status );
}


RPC_STATUS
NdrpValidateAsyncMsg(
    PNDR_ASYNC_MESSAGE  pAsyncMsg )
{
    if ( ! pAsyncMsg  )
        return RPC_S_INVALID_ASYNC_HANDLE;

    if ( 0 != IsBadWritePtr( pAsyncMsg, sizeof(NDR_ASYNC_MESSAGE)) )
        return RPC_S_INVALID_ASYNC_HANDLE;

    if ( pAsyncMsg->Signature != NDR_ASYNC_SIGNATURE ||
         pAsyncMsg->Version   != NDR_ASYNC_VERSION )
        return RPC_S_INVALID_ASYNC_HANDLE;

    return RPC_S_OK;
}


RPC_STATUS
NdrpValidateAndLockAsyncHandle(
    IN PRPC_ASYNC_STATE AsyncHandle )
{
    if ( 0 != IsBadWritePtr( AsyncHandle, sizeof(RPC_ASYNC_STATE)) )
        return RPC_S_INVALID_ASYNC_HANDLE;

    // Prevent multiple simultanous abort and complete calls.

    if ( 0 != InterlockedCompareExchange( & AsyncHandle->Lock, 1, 0 ) )
        {
        return RPC_S_INVALID_ASYNC_CALL;
        }
    else
        {
        if ( AsyncHandle->Signature != RPC_ASYNC_SIGNATURE ||
             AsyncHandle->Size != RPC_ASYNC_VERSION_1_0 )
            {
            InterlockedDecrement( & AsyncHandle->Lock );
            return RPC_S_INVALID_ASYNC_HANDLE;
            }
        }

    return RPC_S_OK;
}


RPC_STATUS
NdrValidateBothAndLockAsyncHandle(
    IN PRPC_ASYNC_STATE AsyncHandle )
{
    RPC_STATUS Status = NdrpValidateAndLockAsyncHandle( AsyncHandle );

    if ( Status != RPC_S_OK )
        return Status;

    Status =  NdrpValidateAsyncMsg( (PNDR_ASYNC_MESSAGE) AsyncHandle->StubInfo );

    if ( Status != RPC_S_OK )
        InterlockedDecrement( & AsyncHandle->Lock );

    return Status;
}


RPC_STATUS
NdrpAsyncAbortCall (
    PRPC_ASYNC_STATE   AsyncHandle,
    PNDR_ASYNC_MESSAGE pAsyncMsg,
    unsigned long      ExceptionCode,
    BOOL               bFreeParams
    )
/*++
Routine Description:

    Aborts the asynchronous RPC call indicated by AsyncHandle on the server and
    frees memory allocated for the parameters, message, and handle.

Arguments:
    AsyncHandle   - supplies the async handle for the call
    AsyncMessage  - supplies the async message for the call
    ExceptionCode - supplies the exception code to send to the client.
    bFreeParams   - TRUE if the parameters should be freed.

Return Value:
    NONE.

--*/
{

    RPC_STATUS Status = RPC_S_OK;

    // If the async call is aborted, see if context handles are fine.
    // We know there is no manager routine exception. 
    NdrpCleanupServerContextHandles( &pAsyncMsg->StubMsg, 
                                     pAsyncMsg->ProcContext.StartofStack, 
                                     FALSE ); 

    if (bFreeParams)
        {
        NdrpFreeParams( & pAsyncMsg->StubMsg,
                        pAsyncMsg->ProcContext.NumberParams,  //Number of parameters
                        ( PPARAM_DESCRIPTION )pAsyncMsg->ProcContext.Params,
                        pAsyncMsg->ProcContext.StartofStack );
        }

    if ( ! pAsyncMsg->Flags.RuntimeCleanedUp )
        Status = I_RpcAsyncAbortCall( AsyncHandle, ExceptionCode);

    NdrpFreeAsyncHandleAndMessage( AsyncHandle );

    return Status;
}


RPC_STATUS
Ndr64pCompleteAsyncClientCall(
    RPC_ASYNC_HANDLE            AsyncHandle,
    IN PNDR_ASYNC_MESSAGE       pAsyncMsg,
    void *                      pReturnValue
    );

RPC_STATUS
Ndr64pCompleteAsyncServerCall(
    RPC_ASYNC_HANDLE            AsyncHandle,
    PNDR_ASYNC_MESSAGE          pAsyncMsg,
    void *                      pReturnValue
    );

RPC_STATUS
Ndr64pAsyncAbortCall(
    PRPC_ASYNC_STATE   AsyncHandle,
    PNDR_ASYNC_MESSAGE pAsyncMsg,
    unsigned long      ExceptionCode,
    BOOL               bFreeParams
    );

//////////////////////////////////////////////////////////////////////////////
//
//                          Runtime APIs
//
//////////////////////////////////////////////////////////////////////////////

RPC_STATUS RPC_ENTRY
RpcAsyncInitializeHandle (
    IN PRPC_ASYNC_STATE AsyncHandle,
    IN unsigned int     Size
    )
/*++

Routine Description:
    Initializes an async handle.

Arguments:
    AsyncHandle - the async handle directing the call

Return Value:
    RPC_S_OK - the call succeeded.
    RPC_S_INVALID_HANDLE - the handle was bad.

--*/

{
    if ( ! AsyncHandle  ||
         Size < RPC_ASYNC_VERSION_1_0  ||  Size > RPC_ASYNC_CURRENT_VERSION )
        return RPC_S_INVALID_ARG;

    if ( 0 != IsBadWritePtr( AsyncHandle, sizeof(RPC_ASYNC_STATE)) )
        return RPC_S_INVALID_ASYNC_HANDLE;

    AsyncHandle->Size      = RPC_ASYNC_CURRENT_VERSION;
    AsyncHandle->Signature = RPC_ASYNC_SIGNATURE;
    AsyncHandle->Flags     = 0;
    AsyncHandle->Lock      = 0;
    AsyncHandle->StubInfo  = 0;
    AsyncHandle->RuntimeInfo = 0;
    AsyncHandle->Reserved[0] = 0;
    AsyncHandle->Reserved[1] = 0;
    AsyncHandle->Reserved[2] = 0;
    AsyncHandle->Reserved[3] = 0;

    return RPC_S_OK;
}


RPC_STATUS RPC_ENTRY
RpcAsyncAbortCall (
    IN PRPC_ASYNC_STATE   AsyncHandle,
    IN unsigned long      ExceptionCode
    )
/*++

Routine Description:
    This API is valid only on the server side and is a request to abort
    the call. The asynchronous handle is deleted and no additional API calls
    on that handle are permitted.

    Note that RpcCancelAsyncCall is a different API that is used on the client
    side only.

Arguments:
    AsyncHandle - the async handle directing the call

Return Value:
    RPC_S_OK - the call succeeded.
    RPC_S_INVALID_HANDLE - the handle was bad.
    RPC_S_INVALID_ASYNC_CALL - May not be called on the client.
    Other errors from the RPC runtime layer.

Note: This API cannot be called on the client side.

--*/

{
    RPC_STATUS  Status;
    PNDR_ASYNC_MESSAGE pAsyncMsg;

    Status = NdrValidateBothAndLockAsyncHandle( AsyncHandle );
    if (RPC_S_OK != Status)
       {
       return Status;
       }

    pAsyncMsg = (PNDR_ASYNC_MESSAGE)AsyncHandle->StubInfo;
    if ( pAsyncMsg->StubMsg.IsClient )
       {
       // Abort is not valid on the client.
       InterlockedDecrement( & AsyncHandle->Lock );
       return RPC_S_INVALID_ASYNC_CALL;
       }

    RpcTryExcept
        {
        NdrSetupLowStackMark( &pAsyncMsg->StubMsg );
#if defined(BUILD_NDR64)
    if ( pAsyncMsg->ProcContext.CurrentSyntaxType == XFER_SYNTAX_DCE )
        Status = NdrpAsyncAbortCall( AsyncHandle,
                               pAsyncMsg,
                               ExceptionCode,
                               TRUE ); // Free parameters
    else                
        Status = Ndr64pAsyncAbortCall( AsyncHandle,
                               pAsyncMsg,
                               ExceptionCode,
                               TRUE ); // Free parameters
#else

    Status = NdrpAsyncAbortCall( AsyncHandle,
                               pAsyncMsg,
                               ExceptionCode,
                               TRUE ); // Free parameters
#endif                                
        }
    RpcExcept( RpcExceptionCode() == RPC_S_OUT_OF_MEMORY )
        {
        Status = RPC_S_OUT_OF_MEMORY;
        }
    RpcEndExcept

    return Status;
}



RPC_STATUS
Ndr64pCompleteAsyncCall (
    IN PRPC_ASYNC_STATE     AsyncHandle,
    IN PNDR_ASYNC_MESSAGE   pAsyncMsg,
    IN void *               pReply
    )
/*++

Routine Description:

    Completes the virtual async call on server or client side.

Arguments:

    AsyncHandle - the async handle controlling the call
    Reply       - return value:
                    on server - passed in
                    on client - returned out

Return Value:

    RPC_S_OK - Function succeeded
    RPC_S_OUT_OF_MEMORY - we ran out of memory

--*/
{
    RPC_STATUS  Status;

    RpcTryExcept
        {
        // the complete stack is quite possibly different from dispatch stack, and we need to
        // adjust the low stack mark for finish call
        NdrSetupLowStackMark( &pAsyncMsg->StubMsg );
        if ( pAsyncMsg->StubMsg.IsClient )
            {
#if defined(BUILD_NDR64)
            if ( pAsyncMsg->ProcContext.CurrentSyntaxType == XFER_SYNTAX_DCE )
                Status = NdrpCompleteAsyncClientCall( AsyncHandle, pAsyncMsg, pReply );
            else                
                Status = Ndr64pCompleteAsyncClientCall( AsyncHandle, pAsyncMsg, pReply );
#else
            NDR_ASSERT( pAsyncMsg->ProcContext.CurrentSyntaxType == XFER_SYNTAX_DCE,
                        "Invalid transfer syntax" );
            Status = NdrpCompleteAsyncClientCall( AsyncHandle, pAsyncMsg, pReply );
#endif
            }
        else
            {
#if defined(BUILD_NDR64)
            if ( pAsyncMsg->ProcContext.CurrentSyntaxType == XFER_SYNTAX_DCE )
                Status = NdrpCompleteAsyncServerCall ( AsyncHandle, pAsyncMsg, pReply );
            else
                Status = Ndr64pCompleteAsyncServerCall( AsyncHandle, pAsyncMsg, pReply );
#else
            NDR_ASSERT( pAsyncMsg->ProcContext.CurrentSyntaxType == XFER_SYNTAX_DCE,
                    "Invalid transfer Syntax" );
            Status = NdrpCompleteAsyncServerCall ( AsyncHandle, pAsyncMsg, pReply );
#endif            
            }
        }
    RpcExcept( !(RPC_BAD_STUB_DATA_EXCEPTION_FILTER) )
        {
        Status = RpcExceptionCode();
        }
    RpcEndExcept

    return Status;
}

RPC_STATUS RPC_ENTRY
RpcAsyncCompleteCall (
    IN PRPC_ASYNC_STATE AsyncHandle,
    IN void *           pReply
    )
/*++

Routine Description:

    Completes the virtual async call on server or client side.

Arguments:

    AsyncHandle - the async handle controlling the call
    Reply       - return value:
                    on server - passed in
                    on client - returned out

Return Value:

    RPC_S_OK - Function succeeded
    RPC_S_OUT_OF_MEMORY - we ran out of memory

--*/
{
    RPC_STATUS  Status = NdrValidateBothAndLockAsyncHandle( AsyncHandle );

    if ( Status == RPC_S_OK )
        {
        Status = Ndr64pCompleteAsyncCall( AsyncHandle,
                                        (PNDR_ASYNC_MESSAGE) AsyncHandle->StubInfo,
                                        pReply );
        }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\typelib\typelib.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       typelib.cxx
//
//  Contents:   Run-time linking support for OLEAUT32.DLL
//
//  Functions:  TLError
//              TLUnintialize
//              InitOleOnce
//              LoadOleAut32Once
//              LateBound_SysFreeString
//              LateBound_LHashValOfNameSysA
//              LateBound_LHashValOfNameSys
//              LateBound_LoadTypeLib
//              LateBound_QueryPathOfRegTypeLib
//              LateBound_RegisterTypeLib
//              LateBound_DeregisterTypeLib
//              LateBound_CreateTypeLib
//
//  History:    4-10-95   stevebl   Created
//
//----------------------------------------------------------------------------

#pragma warning ( disable : 4514 )

#include "tlcommon.hxx"
#include "typelib.hxx"
#include <stdio.h>
#include "errors.hxx"
#include "tlgen.hxx"
#include "ndrtypes.h"

extern "C" BOOL Is64BitEnv();

// Uncomment the following #define to remove the OleInitialize and
// OleUninitialize calls from the code.
//
// Experimentation has proven that it really isn't necessary to initialize
// OLE before using the type library creation functions in OleAut32.DLL;
// however, I have been told that it is not safe.  Therefore, I will go
// ahead and leave in the calls to OleInitialize etc.
//
// This mechanism is left in place to allow for further experimentation.
//
//#define NO_OLE_INITIALIZE

#ifndef NO_OLE_INITIALIZE
static BOOL fOleInitialized = FALSE;

HINSTANCE hInstOle = NULL;
#endif // NO_OLE_INITIALIZE

//+---------------------------------------------------------------------------
//
//  Function:   TLError
//
//  Synopsis:   Generic error reporting mechanism.
//              Reports error and exits.
//
//  Arguments:  [err]     - error code (see notes)
//              [sz]      - descriptive string (generally the DLL or API name)
//              [errInfo] - further error information
//                          (generally an extended error code retrieved by
//                          GetLastError())
//
//  History:    6-14-95   stevebl   Commented
//
//  Notes:      Any of the error codes in errors.hxx are potentially legal but
//              the only codes really expected here are: ERR_BIND, ERR_INIT
//              and ERR_LOAD.
//
//              If the SHOW_ERROR_CODES macro is defined, then the errInfo
//              value is appended to the end of the input string.  Otherwise,
//              errInfo is ignored.  This is intended to be used for debugging
//              purposes.
//
//              It is assumed that the length of the input string will not
//              exceed 100 characters (minus the number of characters needed
//              for the string representation of the errInfo value).  Since
//              this is a local function, this is a safe assumption.
//
//----------------------------------------------------------------------------

void TLError(STATUS_T err, char * sz, DWORD )
{
#ifdef SHOW_ERROR_CODES
    char szBuffer[100];
    sprintf(szBuffer, "%s (0x%X)", sz, errInfo);
    RpcError(NULL, 0, err, szBuffer);
#else
    RpcError(NULL, 0, err, sz);
#endif
    exit(err);
}

#ifndef NO_OLE_INITIALIZE
typedef HRESULT (STDAPICALLTYPE * LPOLEINITIALIZE)(LPVOID);
typedef void (STDAPICALLTYPE * LPOLEUNINITIALIZE)(void);
#endif // NO_OLE_INITIALIE

//+---------------------------------------------------------------------------
//
//  Function:   TLUninitialize
//
//  Synopsis:   general function for unintializing anything to do with type
//              library generation
//
//  Returns:    FALSE - success
//
//  Modifies:   fOleInitialized
//
//  History:    6-14-95   stevebl   Commented
//
//  Notes:      Uninitializes OLE
//
//----------------------------------------------------------------------------

int __cdecl TLUninitialize(void)
{
#ifndef NO_OLE_INITIALIZE
    if (fOleInitialized)
        {
            LPOLEUNINITIALIZE pFunc = (LPOLEUNINITIALIZE) GetProcAddress(hInstOle, "OleUninitialize");
            if (NULL == pFunc )
                {
                TLError(ERR_BIND, "OleUninitialize", GetLastError());
                }
            pFunc();
            fOleInitialized = FALSE;
        }

    return fOleInitialized;
#else
    return FALSE;
#endif // NO_OLE_INITIALIZE
}

#ifndef NO_OLE_INITIALIZE
//+---------------------------------------------------------------------------
//
//  Function:   InitOleOnce
//
//  Synopsis:   Makes sure that OLE gets initialized once and only once.
//
//  Modifies:   fOleInitialized, hInstOle
//
//  History:    6-14-95   stevebl   Commented
//
//  Notes:      OleInitialize is called by dynamically linking to the
//              procedure in OLE32.DLL.  This ensures that MIDL doesn't
//              perform the expensive operations of loading OLE32.DLL and
//              initializing OLE unless it absolutely has to (there is a
//              library statement in the input file).
//
//----------------------------------------------------------------------------

void InitOleOnce(void)
{
    if (!fOleInitialized)
    {
        hInstOle = LoadLibrary("ole32.dll");
        if (NULL == hInstOle)
        {
            TLError(ERR_LOAD, "ole32.dll", GetLastError());
        }
        LPOLEINITIALIZE pFunc = (LPOLEINITIALIZE) GetProcAddress(hInstOle, "OleInitialize");
        if (NULL == pFunc)
        {
            TLError(ERR_BIND, "OleInitialize", GetLastError());
        }
        HRESULT hr = pFunc(NULL);
        if (FAILED(hr))
        {
            TLError(ERR_INIT, "", hr);
        }
        fOleInitialized = TRUE;
    }
}
#endif // NO_OLE_INITIALIZE

//+---------------------------------------------------------------------------
//
//  Function:   LoadOleAut32Once
//
//  Synopsis:   Makes sure that oleaut32.dll gets loaded once and only once
//
//  Returns:    pointer to the HINSTANCE for oleaut32.dll
//
//  History:    6-14-95   stevebl   Commented
//
//  Notes:      Returning the HINSTANCE enables dynamic binding to functions
//              within oleaut32.dll.
//
//----------------------------------------------------------------------------

HINSTANCE LoadOleAut32Once(void)
{
    static HINSTANCE hInst = NULL;
    if (NULL == hInst)
    {
#ifndef NO_OLE_INITIALIZE
        InitOleOnce();
#endif // NO_OLE_INITIALIZE
        hInst = LoadLibrary("oleaut32.dll");
        if (NULL == hInst)
        {
            TLError(ERR_LOAD, "oleaut32.dll", GetLastError());
        }
    }
    return(hInst);
}

BOOL fNewTypeLibChecked = FALSE;
BOOL fNewTypeLib = FALSE;

typedef HRESULT (STDAPICALLTYPE * LPFNCREATETYPELIB)(SYSKIND, const OLECHAR FAR *, ICreateTypeLib FAR * FAR *);

//+---------------------------------------------------------------------------
//
//  Function:   BindToCreateTypeLib
//
//  Synopsis:   Binds to CreateTypeLib2 or CreateTypeLib as appropriate.
//
//  Returns:    pointer to the appropriate CreateTypeLib function
//
//  Notes:      This will actually first attempt to bind to CreateTypeLib2 
//              if the user does not specify that he wants to create old type 
//              libraries.
//
//              We can get away with mapping CreateTypeLib2 to CreateTypeLib
//              because, with the exception of the ICreateTypeLib2 pointer,
//              they have the same signiture.  
//
//              This scheme will prevent us from using any of the extended
//              methods provided by ICreateTypeLib2 (unless we explicitly 
//              cast the interface pointer) but that's OK because we don't
//              need any of those functions, we simply want to make sure
//              that the new type library format is used where appropriate.
//
//              If the user explicitly requests new type libraries on a system
//              that doesn't support it, this routine generates the error
//              message.  
//
//              If the user does not explicitly request one version over the
//              other, this routine binds to the latest supported version.
//
//  History:    1-11-96    stevebl   Created
//
//----------------------------------------------------------------------------

LPFNCREATETYPELIB BindToCreateTypeLib(void)
{
    HINSTANCE hInst = LoadOleAut32Once();
    static LPFNCREATETYPELIB pFunc = NULL;
    // we don't need to go through the check again if it's initialized already.
    if (NULL != pFunc)
        return pFunc;
        
    if ( !FOldTlbSwitch() )   
    // If the user hasn't specifically requested old type lib support
    {
        pFunc = (LPFNCREATETYPELIB) GetProcAddress(hInst, "CreateTypeLib2");
    }
    if (NULL == pFunc)
    {
        // If the user has specifically requested new type lib support
        if ( FNewTlbSwitch() )
        {
            TLError(ERR_BIND, "CreateTypeLib2", GetLastError());
        }
        pFunc = (LPFNCREATETYPELIB) GetProcAddress(hInst, "CreateTypeLib");
        if (NULL == pFunc)
        {
            TLError(ERR_BIND, "CreateTypeLib", GetLastError());
        }
        else
        {
            fNewTypeLib = FALSE;
            fNewTypeLibChecked = TRUE;
        }
    }
    else
    {
        fNewTypeLib = TRUE;
        fNewTypeLibChecked = TRUE;
    }
    return pFunc;
}

//+---------------------------------------------------------------------------
//
//  Function:   FNewTypeLib
//
//  Synopsis:   Detects if the new type library support is available to MIDL.
//              For the new support to be available, two things must be
//              satisfied: the new oleaut32.dll must be installed in the
//              user's machine, and the user must not have specifically
//              requested the old type library support via the -old option.
//
//  Returns:    TRUE  - new type lib support available
//              FALSE - new type lib support not available
//
//  History:    1-11-96    stevebl   Created
//
//----------------------------------------------------------------------------
BOOL FNewTypeLib(void)
{
    if (!fNewTypeLibChecked)
    {
        // force a bind to CreateTypeLib or CreateTypeLib2
        BindToCreateTypeLib();
    }
    return fNewTypeLib;
}

//+---------------------------------------------------------------------------
//
//  Function:   LateBound_<Function Name>
//
//  Synopsis:   Each of these functions performs the same function as its
//              namesake.
//
//              The difference is that these functions are dynamically bound.
//              They cause the DLL to be loaded when the first one of them
//              is called, and they bind to the appropriate code upon demand.
//
//              This ensures that MIDL only loads OLEAUT32.DLL when the
//              input stream needs to generate type information.
//
//  History:    6-14-95   stevebl   Commented
//
//----------------------------------------------------------------------------

typedef BSTR (STDAPICALLTYPE * LPSYSALLOCSTRING) (OLECHAR FAR *);

BSTR LateBound_SysAllocString(OLECHAR FAR * sz)
{
    HINSTANCE hInst = LoadOleAut32Once();
    static LPSYSALLOCSTRING pFunc = NULL;
    if (NULL == pFunc)
    {
        pFunc = (LPSYSALLOCSTRING) GetProcAddress(hInst, "SysAllocString");
        if (NULL == pFunc)
        {
            TLError(ERR_BIND, "SysAllocString", GetLastError());
        }
    }
    return(pFunc(sz));
}

typedef void (STDAPICALLTYPE * LPSYSFREESTRING) (BSTR);

void LateBound_SysFreeString(BSTR bstr)
{
    HINSTANCE hInst = LoadOleAut32Once();
    static LPSYSFREESTRING pFunc = NULL;
    if (NULL == pFunc)
    {
        pFunc = (LPSYSFREESTRING) GetProcAddress(hInst, "SysFreeString");
        if (NULL == pFunc)
        {
            TLError(ERR_BIND, "SysFreeString", GetLastError());
        }
    }
    pFunc(bstr);
}

typedef HRESULT (STDAPICALLTYPE * LPVARIANTCHANGETYPEEX) (VARIANTARG FAR * , VARIANTARG FAR *, LCID, unsigned short, VARTYPE);

HRESULT LateBound_VariantChangeTypeEx(
    VARIANTARG FAR * pvargDest, 
    VARIANTARG FAR * pvargSrc, 
    LCID lcid,
    unsigned short wFlags,
    VARTYPE vtNew)
{
    HINSTANCE hInst = LoadOleAut32Once();
    static LPVARIANTCHANGETYPEEX pFunc = NULL;
    if (NULL == pFunc)
    {
        pFunc = (LPVARIANTCHANGETYPEEX) GetProcAddress(hInst, "VariantChangeTypeEx");
        if (NULL == pFunc)
        {
            TLError(ERR_BIND, "VariantChangeTypeEx", GetLastError());
        }
    }
    return(pFunc(pvargDest, pvargSrc, lcid, wFlags, vtNew));
}

typedef ULONG (STDAPICALLTYPE * LPHASHVALOFNAMESYSA)(SYSKIND, LCID, const char FAR *);

ULONG LateBound_LHashValOfNameSysA(SYSKIND syskind, LCID lcid, const char FAR* szName)
{
    HINSTANCE hInst = LoadOleAut32Once();
    static LPHASHVALOFNAMESYSA pFunc = NULL;
    if (NULL == pFunc)
    {
        pFunc = (LPHASHVALOFNAMESYSA) GetProcAddress(hInst, "LHashValOfNameSysA");
        if (NULL == pFunc)
        {
            TLError(ERR_BIND, "LHashValOfNameSysA", GetLastError());
        }
    }
    return(pFunc(syskind, lcid, szName));
}

typedef ULONG (STDAPICALLTYPE * LPHASHVALOFNAMESYS)(SYSKIND, LCID, const OLECHAR FAR *);

ULONG LateBound_LHashValOfNameSys(SYSKIND syskind, LCID lcid, const OLECHAR FAR* szName)
{
    HINSTANCE hInst = LoadOleAut32Once();
    static LPHASHVALOFNAMESYS pFunc = NULL;
    if (NULL == pFunc)
    {
        pFunc = (LPHASHVALOFNAMESYS) GetProcAddress(hInst, "LHashValOfNameSys");
        if (NULL == pFunc)
        {
            TLError(ERR_BIND, "LHashValOfNameSys", GetLastError());
        }
    }
    return(pFunc(syskind, lcid, szName));
}

typedef HRESULT (STDAPICALLTYPE * LPLOADTYPELIBEX)(LPCOLESTR szFile, REGKIND regkind, ITypeLib ** pptlib);

// from oleauto.h:
// Constants for specifying format in which TLB should be loaded
// (the default format is 32-bit on WIN32 and 64-bit on WIN64)
//  #define LOAD_TLB_AS_32BIT   0x20
//  #define LOAD_TLB_AS_64BIT   0x40
HRESULT LateBound_LoadTypeLib(const OLECHAR FAR *szFile, ITypeLib FAR* FAR* pptlib)
{
    HINSTANCE hInst = LoadOleAut32Once();
    static LPLOADTYPELIBEX pFunc = NULL;
    REGKIND Kind;
    HRESULT hr;
    
    if (NULL == pFunc)
    {
        pFunc = (LPLOADTYPELIBEX) GetProcAddress(hInst, "LoadTypeLibEx");
        if (NULL == pFunc)
            {
            TLError(ERR_BIND, "LoadTypeLibEx", GetLastError());
            }
    }
// we don't need to set the flag on 32bit     
#ifdef _WIN64    
    Kind = ( REGKIND ) ( REGKIND_NONE | ( Is64BitEnv() ? LOAD_TLB_AS_64BIT  : LOAD_TLB_AS_32BIT ) );
#else
    Kind = ( REGKIND ) ( REGKIND_NONE | ( Is64BitEnv() ? LOAD_TLB_AS_64BIT : 0 ) );
#endif

    hr = pFunc(szFile, Kind, pptlib);

    // cleanup the bit if we failed: it's likely we are using an old oleaut32.dll that
    // doesn't support these two bits. 
    if ( hr == E_INVALIDARG )
        {
        MIDL_ASSERT( Kind != REGKIND_NONE );
            // UGLY UGLY 
            // issue warning when we are really generating tlb: this code is 
            // called during grammar check and we might not generate tlb in 
            // the current run
#ifdef _WIN64
            bool fGenTypeLib = pCommand->Is64BitEnv() || ( pCommand->Is32BitEnv() && pCommand->IsSwitchDefined( SWITCH_ENV ) );
#else
            bool fGenTypeLib = pCommand->Is32BitEnv() || ( pCommand->Is64BitEnv() && pCommand->IsSwitchDefined( SWITCH_ENV ) );
#endif
            // in w2k and before, there is oleaut bug that doesn't check SYS_WIN
            // so while midl read/write 32bit tlb, the syskind is set to SYS_WIN64
            // and oleaut32.dll in 64bit got confused and generate wrong vtbl.
            // We decided to disallow generating 64bit tlb on w2k and before.
            if ( fGenTypeLib && pCommand->GenerateTypeLibrary() )
                RpcError(NULL, 0, OLEAUT_NO_CROSSPLATFORM_TLB, "");
        Kind = REGKIND_NONE;
        hr = pFunc(szFile, Kind, pptlib);
        }

    return hr;
}


typedef HRESULT (STDAPICALLTYPE * LPQUERYPATHOFREGTYPELIB)(REFGUID, unsigned short, unsigned short, LCID, LPBSTR);

HRESULT LateBound_QueryPathOfRegTypeLib(
    REFGUID guid,
    unsigned short wMaj,
    unsigned short wMin,
    LCID lcid,
    LPBSTR lpbstrPathName)
{
    HINSTANCE hInst = LoadOleAut32Once();
    static LPQUERYPATHOFREGTYPELIB pFunc = NULL;
    if (NULL == pFunc)
    {
        pFunc = (LPQUERYPATHOFREGTYPELIB) GetProcAddress(hInst, "QueryPathOfRegTypeLib");
        if (NULL == pFunc)
        {
            TLError(ERR_BIND, "QueryPathOfRegTypeLib", GetLastError());
        }
    }
    return(pFunc(guid, wMaj, wMin, lcid, lpbstrPathName));
}

typedef HRESULT (STDAPICALLTYPE * LPREGISTERTYPELIB)(ITypeLib FAR *, OLECHAR FAR *, OLECHAR FAR *);

HRESULT LateBound_RegisterTypeLib(ITypeLib FAR* ptlib, OLECHAR FAR *szFullPath,
            OLECHAR FAR *szHelpDir)
{
    HINSTANCE hInst = LoadOleAut32Once();
    static LPREGISTERTYPELIB pFunc = NULL;
    if (NULL == pFunc)
    {
        pFunc = (LPREGISTERTYPELIB) GetProcAddress(hInst, "RegisterTypeLib");
        if (NULL == pFunc)
        {
            TLError(ERR_BIND, "RegisterTypeLib", GetLastError());
        }
    }
    return(pFunc(ptlib, szFullPath, szHelpDir));
}

typedef HRESULT (STDAPICALLTYPE * LPDEREGISTERTYPELIB)(REFGUID, WORD, WORD, LCID);

HRESULT LateBound_DeregisterTypeLib(REFGUID rguid, WORD wVerMajor, WORD wVerMinor, LCID lcid)
{
    HINSTANCE hInst = LoadOleAut32Once();
    static LPDEREGISTERTYPELIB pFunc = NULL;
    if (NULL == pFunc)
    {
        pFunc = (LPDEREGISTERTYPELIB) GetProcAddress(hInst, "DeregisterTypeLib");
        if (NULL == pFunc)
        {
            TLError(ERR_BIND, "DeregisterTypeLib", GetLastError());
        }
    }
    return(pFunc(rguid, wVerMajor, wVerMinor, lcid));
}

HRESULT LateBound_CreateTypeLib(SYSKIND syskind, const OLECHAR FAR *szFile,
            ICreateTypeLib FAR* FAR* ppctlib)
{
    LPFNCREATETYPELIB pFunc = BindToCreateTypeLib();
    return(pFunc(syskind, szFile, ppctlib));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\midl\typelib\tlgen.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999.
//
//  File:       tlgen.cxx
//
//  Contents:   type library generation methods
//
//  Classes:    various
//
//  Functions:  various
//
//  History:    4-10-95   stevebl   Created
//
//----------------------------------------------------------------------------

#pragma warning ( disable : 4514 4706 )

#include "tlcommon.hxx"
#include "tlgen.hxx"
#include "tllist.hxx"
#include "becls.hxx"
#include "walkctxt.hxx"
#include "ilxlat.hxx"
#include "midlvers.h"
#include <time.h>

#define SHOW_ERROR_CODES 1
extern "C"
BOOL
Is64BitEnv()
    {
    return pCommand->Is64BitEnv();
    }

//+---------------------------------------------------------------------------
//
//  Notes on CG_STATUS return types:
//
//  CG_STATUS is an enumeration which can have the following values:
//  CG_OK, CG_NOT_LAYED_OUT, and CG_REF_NOT_LAYED_OUT.  The type generation
//  methods assign the following meanings to these values:
//
//  CG_OK                => success
//  CG_NOT_LAYED_OUT     => the type info was created but (due to cyclic
//                          dependencies) LayOut() could not be called on it.
//  CG_REF_NOT_LAYED_OUT => same as CG_NOT_LAYED_OUT except that the type
//                          is a referenced type: in other words, it is a
//                          pointer type or an array type.
//
//  The methods in this file use the CG_STATUS value to help detect and
//  correct errors that occur due to cyclic dependencies like this one:
//
//      struct foo {
//          int x;
//          union bar * pBar;   // the type (union bar *) is a referenced type
//      };
//
//      union bar {
//          struct foo;
//      }
//
//  This creates a problem because ICreateTypeInfo::LayOut() will fail on any
//  structure or union which contains another structure or union which has not
//  already been layed out.
//
//  If a structure (or union) receives a CG_STATUS value of CG_NOT_LAYED_OUT
//  from any of its members, then it knows that it will not be able to call
//  LayOut on itself and it will have to return CG_NOT_LAYED_OUT to tell
//  its dependents that it hasn't been layed out.
//
//  If (on the other hand) the structure (or union) receives
//  CG_REF_NOT_LAYED_OUT from one or more of its members and CG_OK from all
//  the others then it knows that there is a cyclic dependency somewhere,
//  but that it WILL be able to call LayOut() because all of the members that
//  encountered difficulty were references (pointers or arrays) to a cyclicly
//  dependent type.  Calling LayOut() may break the dependency (they may be
//  waiting on this structure) and so LayOut must be called, and then all of
//  the structure's members should be told to try again.
//
//  If the structure receives CG_OK from all of its members, then there is
//  no cyclic depency (or the cycle has already been broken), LayOut()
//  may be called and CG_OK may be returned to the caller.
//
//  Note that it is impossible to get in an unbreakable cyclic dependency
//  because at some point in the cycle one of the members must be a
//  referenced type.
//
//----------------------------------------------------------------------------

// Maintain a global pointer to the list of open ICreateTypeInfo pointers.
CObjHolder * gpobjholder;

// global pointer to the root ICreateTypeLibrary
ICreateTypeLib * pMainCTL = NULL;

char* szErrTypeFlags   = "Could not set type flags";
char* szErrHelpString  = "Could not set help string";
char* szErrHelpContext = "Could not set help context";
char* szErrVersion     = "Could not set version";
char* szErrUUID        = "Could not set UUID";

//+---------------------------------------------------------------------------
//
//  Function:   ReportTLGenError
//
//  Synopsis:   Generic routine for reporting typelib generation errors.
//              Reports typelib generation error and then exits.
//
//  Arguments:  [szText]     - description of failure
//              [error_code] - typically an HRESULT
//
//  History:    6-13-95   stevebl   Commented
//
//  Notes:      The error code is only displayed if the
//              SHOW_ERROR_CODES macro is defined.
//
//              It is assumed that szText will never exceed 100 characters
//              (minus space for the string representation of error_code).
//              Since this is a local function, this is a safe assumption.
//
//----------------------------------------------------------------------------

void ReportTLGenError( char * szText, char * szName, long error_code)
{
    char szBuffer [512];
    // there are places we don't have an error_code, and pass in 0.
    if ( error_code != 0 )
        sprintf(szBuffer, ": %s : %s (0x%0X)", szText, szName, error_code);
    else
        sprintf(szBuffer, ": %s : %s", szText, szName);

    RpcError("midl\\oleaut32.dll", 0, ERR_TYPELIB_GENERATION, szBuffer);

    delete gpobjholder;

    if (pMainCTL)
        pMainCTL->Release();
    exit(ERR_TYPELIB_GENERATION);
}

void ReportTLGenWarning( char * szText, char * szName, long error_code )
{
    char szBuffer [512];
#ifdef SHOW_ERROR_CODES
    sprintf(szBuffer, ": %s : %s (0x%0X)", szText, szName, error_code);
#else
    sprintf(szBuffer, ": %s : %s", szText, szName);
#endif
    RpcError("midl\\oleaut32.dll", 0, WARN_TYPELIB_GENERATION, szBuffer);
}


OLECHAR wszScratch [MAX_PATH];

extern CTypeLibraryList gtllist;

extern BOOL IsTempName( char * );

void GetValueFromExpression(VARIANT & var, TYPEDESC tdesc, expr_node * pExpr, LCID lcid, char * szSymName);
void ConvertToVariant(VARIANT & var, expr_node * pExpr, LCID lcid);

BOOL IsVariantBasedType(TYPEDESC tdesc)
{
    while (tdesc.vt >= VT_PTR && tdesc.vt <= VT_CARRAY)
    {
        // This simplification works for VT_CARRAY as well as VT_PTR because
        // the ARRAYDESC structure's first member is a TYPEDESC.
        tdesc = *tdesc.lptdesc;
    };
    return tdesc.vt == VT_VARIANT;
}

//+---------------------------------------------------------------------------
//
//  Function:   DeleteTypedescChildren
//
//  Synopsis:   deletes all structures pointed to by a TYPEDESC so that the
//              TYPEDESC can be safely deleted.
//
//  Arguments:  [ptd] - pointer to a TYEPDESC
//
//  History:    6-13-95   stevebl   Commented
//
//  Notes:      ptd is not deleted
//
//----------------------------------------------------------------------------

void DeleteTypedescChildren(TYPEDESC * ptd)
{
    if (VT_CARRAY == ptd->vt)
        {
            DeleteTypedescChildren(&ptd->lpadesc->tdescElem);
            delete ptd->lpadesc;
        }
    else if (VT_PTR == ptd->vt)
        {
            DeleteTypedescChildren(ptd->lptdesc);
            delete ptd->lptdesc;
        }
}

//+---------------------------------------------------------------------------
//
//  Function:   GetTypeFlags
//
//  Synopsis:   extracts TYPEFLAGS from a context
//
//  Arguments:  [pctxt] - pointer to the context
//
//  Returns:    TYPEFLAGS built from attributes found in the context
//
//  Modifies:   ATTR_TYPEDESCATTR, all ATTR_TYPE and all ATTR_MEMBER
//              attributes are consumed from the context.
//
//  History:    6-13-95   stevebl   Commented
//
//----------------------------------------------------------------------------

UINT GetTypeFlags(WALK_CTXT * pctxt)
{
    UINT rVal = 0;
    node_constant_attr * pTdescAttr = (node_constant_attr *) pctxt->ExtractAttribute(ATTR_TYPEDESCATTR);
    if (pTdescAttr)
        rVal = (short) pTdescAttr->GetExpr()->GetValue();

    node_type_attr * pTA;
    while (pTA = (node_type_attr *)pctxt->ExtractAttribute(ATTR_TYPE))
    {
        switch (pTA->GetAttr())
        {
        case TATTR_LICENSED:
            rVal |= TYPEFLAG_FLICENSED;
            break;
        case TATTR_APPOBJECT:
            rVal |= TYPEFLAG_FAPPOBJECT;
            break;
        case TATTR_CONTROL:
            rVal |= TYPEFLAG_FCONTROL;
            break;
        case TATTR_DUAL:
            rVal |= TYPEFLAG_FDUAL | TYPEFLAG_FOLEAUTOMATION;
            break;
        case TATTR_PROXY:
            rVal |= TYPEFLAG_FPROXY;
            break;
        case TATTR_NONEXTENSIBLE:
            rVal |= TYPEFLAG_FNONEXTENSIBLE;
            break;
        case TATTR_OLEAUTOMATION:
            rVal |= TYPEFLAG_FOLEAUTOMATION;
            break;
        case TATTR_AGGREGATABLE:
            rVal |= TYPEFLAG_FAGGREGATABLE;
            break;
        case TATTR_PUBLIC:
        default:
            break;
        }
    }
    node_member_attr * pMA;
    while (pMA = (node_member_attr *)pctxt->ExtractAttribute(ATTR_MEMBER))
    {
        switch (pMA->GetAttr())
        {
        case MATTR_RESTRICTED:
            rVal |= TYPEFLAG_FRESTRICTED;
            break;
        case MATTR_PREDECLID:
            rVal |= TYPEFLAG_FPREDECLID;
            break;
        case MATTR_REPLACEABLE:
            rVal |= TYPEFLAG_FREPLACEABLE;
            break;
        default:
            break;
        }
    }

    if (pctxt->AttrInSummary(ATTR_HIDDEN))
    {
        rVal |= TYPEFLAG_FHIDDEN;
    }
    return rVal;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetImplTypeFlags
//
//  Synopsis:   extracts IMPLTYPEFLAGS from a context
//
//  Arguments:  [pctxt] - pointer to the context
//
//  Returns:    IMPLTYPEFLAGS build from attributes found in the context
//
//  Modifies:   ATTR_DEFAULT, and all ATTR_MEMBER attributes are consumed from
//              the context.
//
//  History:    6-13-95   stevebl   Commented
//
//----------------------------------------------------------------------------

unsigned short GetImplTypeFlags(WALK_CTXT * pctxt)
{
    unsigned short rVal = 0;
    if (pctxt->ExtractAttribute(ATTR_DEFAULT))
        rVal |= IMPLTYPEFLAG_FDEFAULT;
    node_member_attr * pMA;
    while (pMA = (node_member_attr *)pctxt->ExtractAttribute(ATTR_MEMBER))
    {
        switch(pMA->GetAttr())
        {
        case MATTR_SOURCE:
            rVal |= IMPLTYPEFLAG_FSOURCE;
            break;
        case MATTR_RESTRICTED:
            rVal |= IMPLTYPEFLAG_FRESTRICTED;
            break;
        case MATTR_DEFAULTVTABLE:
            rVal |= IMPLTYPEFLAG_FDEFAULTVTABLE;
            break;
        default:
            break;
        }
    }
    return rVal;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetIDLFlags
//
//  Synopsis:   extracts IDLFLAGS from a context
//
//  Arguments:  [pctxt] - pointer to a context
//
//  Returns:    IDLFLAGS built from attributes found in the context
//
//  Modifies:   ATTR_IDLDESCATTR, ATTR_OUT, and ATTR_IN attributes are
//              consumed from the context.
//
//  History:    6-13-95   stevebl   Commented
//
//----------------------------------------------------------------------------

unsigned short GetIDLFlags(WALK_CTXT * pctxt)
{
    unsigned short rVal = 0;
    node_constant_attr * pIDLDescAttr = (node_constant_attr *) pctxt->ExtractAttribute(ATTR_IDLDESCATTR);
    if (pIDLDescAttr)
        rVal = (short) pIDLDescAttr->GetExpr()->GetValue();

    if (pctxt->AttrInSummary(ATTR_OUT))
        rVal |= IDLFLAG_FOUT;

    if (pctxt->AttrInSummary(ATTR_IN))
        rVal |= IDLFLAG_FIN;

    if (pctxt->AttrInSummary(ATTR_FLCID))
        rVal |= IDLFLAG_FLCID;

    return rVal;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetVarFlags
//
//  Synopsis:   extracts VARFLAGS from a context
//
//  Arguments:  [pctxt] - pointer to a context
//
//  Returns:    VARFLAGS built from attributes found in the context
//
//  Modifies:   ATTR_VDESCATTR, ATTR_HIDDEN and all ATTR_MEMBER attributes
//              are consumed from the context.
//
//  History:    6-13-95   stevebl   Commented
//
//----------------------------------------------------------------------------

UINT GetVarFlags(WALK_CTXT * pctxt)
{
    unsigned short rVal = 0;
    node_constant_attr * pVdescAttr = (node_constant_attr *) pctxt->ExtractAttribute(ATTR_VARDESCATTR);
    if (pVdescAttr)
        rVal = (short) pVdescAttr->GetExpr()->GetValue();

    node_member_attr * pMA;
    while (pMA = (node_member_attr *)pctxt->ExtractAttribute(ATTR_MEMBER))
    {
        switch (pMA->GetAttr())
        {
        case MATTR_READONLY:
            rVal |= VARFLAG_FREADONLY;
            break;
        case MATTR_SOURCE:
            rVal |= VARFLAG_FSOURCE;
            break;
        case MATTR_BINDABLE:
            rVal |= VARFLAG_FBINDABLE;
            break;
        case MATTR_DISPLAYBIND:
            rVal |= VARFLAG_FDISPLAYBIND;
            break;
        case MATTR_DEFAULTBIND:
            rVal |= VARFLAG_FDEFAULTBIND;
            break;
        case MATTR_REQUESTEDIT:
            rVal |= VARFLAG_FREQUESTEDIT;
            break;
        case MATTR_UIDEFAULT:
            rVal |= VARFLAG_FUIDEFAULT;
            break;
        case MATTR_NONBROWSABLE:
            rVal |= VARFLAG_FNONBROWSABLE;
            break;
        case MATTR_DEFAULTCOLLELEM:
            rVal |= VARFLAG_FDEFAULTCOLLELEM;
            break;
        case MATTR_IMMEDIATEBIND:
            rVal |= VARFLAG_FIMMEDIATEBIND;
            break;
        case MATTR_REPLACEABLE:
            rVal |= VARFLAG_FREPLACEABLE;
            break;
        case MATTR_RESTRICTED:
            rVal |= VARFLAG_FRESTRICTED;
            break;
        default:
            break;
        }
    }

    if (pctxt->AttrInSummary(ATTR_HIDDEN))
    {
        rVal |= VARFLAG_FHIDDEN;
    }
    return rVal;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetFuncFlags
//
//  Synopsis:   extracts FUNCFLAGS from a context
//
//  Arguments:  [pctxt] - pointer to a context
//
//  Returns:    FUNCFLAGS built from attributes found in the context
//
//  Modifies:   ATTR_FUNCDESCATTR, ATTR_HIDDEN and all ATTR_MEMBER attributes
//              are consumed from the context.
//
//  History:    6-13-95   stevebl   Commented
//
//----------------------------------------------------------------------------

UINT GetFuncFlags(WALK_CTXT * pctxt, BOOL * pfPropGet, BOOL * pfPropPut, BOOL * pfPropPutRef, BOOL * pfVararg)
{
    unsigned short rVal = 0;
    node_constant_attr * pVdescAttr = (node_constant_attr *) pctxt->ExtractAttribute(ATTR_FUNCDESCATTR);
    if (pVdescAttr)
        rVal = (short) pVdescAttr->GetExpr()->GetValue();

    * pfPropGet = * pfPropPut = * pfPropPutRef = * pfVararg = FALSE;

    node_member_attr * pMA;
    while (pMA = (node_member_attr *)pctxt->ExtractAttribute(ATTR_MEMBER))
    {
         switch (pMA->GetAttr())
        {
        case MATTR_RESTRICTED:
            rVal |= FUNCFLAG_FRESTRICTED;
            break;
        case MATTR_SOURCE:
            rVal |= FUNCFLAG_FSOURCE;
            break;
        case MATTR_BINDABLE:
            rVal |= FUNCFLAG_FBINDABLE;
            break;
        case MATTR_REQUESTEDIT:
            rVal |= FUNCFLAG_FREQUESTEDIT;
            break;
        case MATTR_DISPLAYBIND:
            rVal |= FUNCFLAG_FDISPLAYBIND;
            break;
        case MATTR_DEFAULTBIND:
            rVal |= FUNCFLAG_FDEFAULTBIND;
            break;
        case MATTR_UIDEFAULT:
            rVal |= FUNCFLAG_FUIDEFAULT;
            break;
        case MATTR_NONBROWSABLE:
            rVal |= FUNCFLAG_FNONBROWSABLE;
            break;
        case MATTR_DEFAULTCOLLELEM:
            rVal |= FUNCFLAG_FDEFAULTCOLLELEM;
            break;
        case MATTR_PROPGET:
            *pfPropGet = TRUE;
            break;
        case MATTR_PROPPUT:
            *pfPropPut = TRUE;
            break;
        case MATTR_PROPPUTREF:
            *pfPropPutRef = TRUE;
            break;
        case MATTR_VARARG:
            *pfVararg = TRUE;
            break;
        case MATTR_IMMEDIATEBIND:
            rVal |= FUNCFLAG_FIMMEDIATEBIND;
            break;
        case MATTR_USESGETLASTERROR:
            rVal |= FUNCFLAG_FUSESGETLASTERROR;
            break;
        case MATTR_REPLACEABLE:
            rVal |= FUNCFLAG_FREPLACEABLE;
            break;
        default:
            break;
        }
    }

// What about FUNCFLAG_FUSEGETLASTERROR?

    if (pctxt->AttrInSummary(ATTR_HIDDEN))
    {
        rVal |= FUNCFLAG_FHIDDEN;
    }
    return rVal;
}

//+---------------------------------------------------------------------------
//
//  Member:     node_guid::GetGuid
//
//  Synopsis:   method to retrieve a GUID from a node_guid
//
//  History:    6-13-95   stevebl   Commented
//
//----------------------------------------------------------------------------

void node_guid::GetGuid(_GUID & guid)
{
    guid.Data1 = cStrs.Value.Data1;
    guid.Data2 = cStrs.Value.Data2;
    guid.Data3 = cStrs.Value.Data3;
    memmove(guid.Data4, cStrs.Value.Data4, 8);
}

//+---------------------------------------------------------------------------
//
//  Member:     CG_NDR::CheckImportLib
//
//  Synopsis:   Checks to see if a particular CG node has a definition in
//              an imported type libaray.
//
//  Returns:    NULL  => the node has no imported definition
//              !NULL => ITypeInfo pointer for the imported type definition
//
//  History:    6-13-95   stevebl   Commented
//
//  Notes:      It is possible that the CG node may have been created from
//              an IDL file and yet this routine may stil return a pointer to
//              an imported ITypeInfo.
//
//              This is desirable.
//
//              Because type libraries cannot represent as rich a set of
//              information as IDL files can, the user may wish to directly
//              include an IDL file containing a definintion of the type,
//              thereby making the full IDL definition available for reference
//              by other types.   At the same time the user may wish to
//              IMPORTLIB a type library describing the same type so that the
//              new type library will be able to link directly to the imported
//              ODL definition, rather than forcing the new type library to
//              contain a definition of the imported type.
//
//              This makes the assumption that although two definitions with
//              the same name may exist in the global namespace, they will
//              both refer to the same type.
//
//----------------------------------------------------------------------------

void * CG_NDR::CheckImportLib()
{
    node_skl * pn = GetType();
    node_file * pf = NULL;
    void * pReturn;

    for(;;)
    {
        if (pn->GetMyInterfaceNode())
        {
            pf = pn->GetDefiningFile();
        }
        else
        {
            pf = pn->GetDefiningTLB();
        }
        if (pf)
        {
            if (pf->GetImportLevel() > 0)
            {
                A2O(wszScratch, pn->GetSymName(), MAX_PATH);

                pReturn = gtllist.FindName(pf->GetFileName(), wszScratch);
                if (pReturn)
                    return pReturn;
            }
            else
                return NULL;
        }

        NODE_T kind = pn->NodeKind();
        if (kind != NODE_DEF && kind != NODE_HREF)
            return NULL;
        pn = pn->GetChild();      
    }
}

void * CG_TYPEDEF::CheckImportLib()
{
    node_skl * pn = GetType();
    node_file * pf = NULL;
    void * pReturn;
    if (pn->GetMyInterfaceNode())
    {
        pf = pn->GetDefiningFile();
    }
    else
    {
        pf = pn->GetDefiningTLB();
    }
    if (pf)
    {
        if (pf->GetImportLevel() > 0)
        {
            A2O(wszScratch, pn->GetSymName(), MAX_PATH);

            pReturn = gtllist.FindName(pf->GetFileName(), wszScratch);
            if (pReturn)
                return pReturn;
        }
    }
    return NULL;
}

typedef struct tagINTRINSIC
{
    char * szType;
    VARTYPE vt;
} INTRINSIC;

INTRINSIC rgIntrinsic [] =
{
    "DATE",         VT_DATE,
    "HRESULT",      VT_HRESULT,
    "LPSTR",        VT_LPSTR,
    "LPWSTR",       VT_LPWSTR,
    "SCODE",        VT_ERROR,
    "VARIANT_BOOL", VT_BOOL,
    "wireBSTR",     VT_BSTR,
    "BSTR",         VT_BSTR,
    "VARIANT",      VT_VARIANT,
    "wireVARIANT",  VT_VARIANT,
    "CURRENCY",     VT_CY,
    "CY",           VT_CY,
    "DATE",         VT_DATE,
    "DECIMAL",      VT_DECIMAL,
};


//+---------------------------------------------------------------------------
//
//  Member:     CG_CLASS::GetTypeDesc
//
//  Synopsis:   Default implementation of GetTypeDesc.
//              Creates a TYPEDESC from a CG node.
//
//  Arguments:  [ptd]  - reference of a pointer to a TYPEDESC
//              [pCCB] - CG control block pointer
//
//  Returns:    CG_OK
//              CG_NOT_LAYED_OUT
//
//  Modifies:   ptd points to a new TYPEDESC
//
//  History:    6-13-95   stevebl   Commented
//
//  Notes:      Except for the special cases listed below, this method
//              calls GenTypeInfo to generate an ICreateTypeInfo for this
//              node.  Then it creates a TYPEDESC of type VT_USERDEFINED
//              which contains an HREFTYPE to the new type info.
//
//              The special casses are the ODL base types: CURRENCY, and
//              VARIANT, which simply generate the appropriate TYPEDESC and
//              do not need to create any additional type infos.
//
//----------------------------------------------------------------------------

CG_STATUS CG_CLASS::GetTypeDesc(TYPEDESC * &ptd, CCB *pCCB)
{
    node_skl * pskl = GetType();
    char * szName;
    int iIntrinsicType;
    if (ID_CG_TYPEDEF != GetCGID())
    {
        while (NODE_DEF == pskl->NodeKind())
        {
            szName = pskl->GetSymName();
            iIntrinsicType = 0;
            if ( szName )
            {
                while (iIntrinsicType < (sizeof(rgIntrinsic) / sizeof(INTRINSIC)))
                {
                    int i = _stricmp(szName, rgIntrinsic[iIntrinsicType].szType);
                    if (i == 0)
                    {
                        ptd = new TYPEDESC;
                        ptd->lptdesc = NULL;
                        ptd->vt = rgIntrinsic[iIntrinsicType].vt;
                        return CG_OK;
                    }
                    iIntrinsicType++;
                }
            }
            pskl = pskl->GetChild();
        }
    }
    szName = pskl->GetSymName();
    iIntrinsicType = 0;
    if ( szName )
        while (iIntrinsicType < (sizeof(rgIntrinsic) / sizeof(INTRINSIC)))
        {
            int i = _stricmp(szName, rgIntrinsic[iIntrinsicType].szType);
            if (i == 0)
            {
                ptd = new TYPEDESC;
                ptd->lptdesc = NULL;
                ptd->vt = rgIntrinsic[iIntrinsicType].vt;
                return CG_OK;
            }
            iIntrinsicType++;
        }

    // remember the current ICreateTypeInfo
    ICreateTypeInfo * pCTI = pCCB->GetCreateTypeInfo();
    MIDL_ASSERT(NULL != pCTI);

    ITypeInfo * pTI;
    HRESULT hr;
    CG_STATUS cgs = CG_OK;

    // make sure this typedef has been generated
    if (NULL == (pTI = (ITypeInfo *)CheckImportLib()))
    {
        BOOL fRemember = pCCB->IsInDispinterface();
        pCCB->SetInDispinterface(FALSE);
        cgs = GenTypeInfo(pCCB);
        pCCB->SetInDispinterface(fRemember);
        ICreateTypeInfo * pNewCTI = pCCB->GetCreateTypeInfo();
        MIDL_ASSERT(NULL != pNewCTI);
        // get an ITypeInfo so we can create a reference to it
        hr = pNewCTI->QueryInterface(IID_ITypeInfo, (void **)&pTI);
        if FAILED(hr)
        {
            ReportTLGenError(  "QueryInterface failed", szName, hr);
        }
    }

    // restore the current ICreateTypeInfo pointer
    pCCB->SetCreateTypeInfo(pCTI);

    // get an HREFTYPE for it
    HREFTYPE hrt = 0;
    hr = pCTI->AddRefTypeInfo(pTI, &hrt);
    // DO NOT CHECK THIS HRESULT FOR ERRORS
    // If we get here after pCTI has been layed out (which is possible on
    // structures or unions with circular references) then this will fail.

    // TYPE_E_TYPEMISMATCH will be returned if pTI is TKIND_MODULE
    // the above comment is in @v1, and I don't want to get rid of it, even
    // though oleaut32 is not reporting error in above scenario now. 
    if ( TYPE_E_TYPEMISMATCH == hr )
    {
        ReportTLGenError("AddRefTypeInfo failed", szName, hr );
    }

    // release the ITypeInfo.
    pTI->Release();

    ptd = new TYPEDESC;
    ptd->vt = VT_USERDEFINED;
    ptd->hreftype = hrt;
    return cgs;
}

//+---------------------------------------------------------------------------
//
//  Member:     CG_TYPELIBRARY_FILE::GenCode
//
//  Synopsis:   generates the type library file
//
//  Arguments:  [pCCB] - CG controller block
//
//  Returns:    CG_OK
//
//  History:    6-13-95   stevebl   Commented
//
//----------------------------------------------------------------------------

CG_STATUS CG_TYPELIBRARY_FILE::GenCode(CCB * pCCB)
{
    CG_ITERATOR I;
    CG_INTERFACE *  pCG;

    //
    // Create the ICreateTypeLibrary
    //

    char * szName = GetFileName();

    // don't generate tlb if /notlb is specified (don't have a filename)
    if (NULL == szName)
        return CG_OK;

    A2O(wszScratch, szName, MAX_PATH);

    //
    // initialize the open ICreateTypeInfo list
    //
    gpobjholder = new CObjHolder;
    
    SYSKIND syskind;
    switch(pCommand->GetEnv())
    {
    case ENV_WIN64:
        syskind = ( SYSKIND ) SYS_WIN64;
        break;
    case ENV_WIN32:
        syskind = SYS_WIN32;
        break;
    default:
        syskind = SYS_WIN32;
        ReportTLGenError(  "invalid syskind", szName, 0);
        break;
    }

    HRESULT hr = LateBound_CreateTypeLib(syskind, wszScratch, &pMainCTL);
    if FAILED(hr)
    {
        ReportTLGenError(  "CreateTypeLibFailed", szName, hr);
    }
    else
    {
        pCCB->SetCreateTypeLib(pMainCTL);

        //
        // Find the CG_LIBRARY node and use it to populate the type library
        //

        GetMembers( I );

        I.Init();
        while( ITERATOR_GETNEXT( I, pCG ) )
            {
            switch(pCG->GetCGID())
            {
            case ID_CG_LIBRARY:
                pCG->GenTypeInfo(pCCB);
                break;
            default:
                break;
            }
        }

        hr = pMainCTL->SaveAllChanges();
        if FAILED(hr)
        {
            ReportTLGenError(  "SaveAllChanges Failed", szName, hr);
        }

        //
        // free all the object pointers in the object holder
        //
        delete gpobjholder;

        pMainCTL->Release();
    }

    return CG_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CG_LIBRARY::GenTypeInfo
//
//  Synopsis:   sets a type library's attributes and generates its type infos
//
//  Arguments:  [pCCB] - CG control block
//
//  Returns:    CG_OK
//
//  History:    6-13-95   stevebl   Commented
//
//----------------------------------------------------------------------------

CG_STATUS CG_LIBRARY::GenTypeInfo(CCB * pCCB)
{
    ICreateTypeLib * pCTL = pCCB->GetCreateTypeLib();


    // Set the type library attributes

    node_library * pType = (node_library *) GetType();

    char * szName = pType->GetSymName();
    if (szName)
    {
        A2O(wszScratch, szName, MAX_PATH);
        pCTL->SetName(wszScratch);
    }

    node_guid * pGuid = (node_guid *) pType->GetAttribute( ATTR_GUID );
    if (pGuid)
    {
        GUID guid;
        pGuid->GetGuid(guid);
        pCTL->SetGuid(guid);
    }

    node_text_attr * pTA;
    if (pTA = (node_text_attr *) pType->GetAttribute(ATTR_HELPFILE))
    {
        char * szHelpFile = pTA->GetText();
        A2O(wszScratch, szHelpFile, MAX_PATH);
        pCTL->SetHelpFileName(wszScratch);
    }

    if (pTA = (node_text_attr *)pType->GetAttribute(ATTR_HELPSTRING))
    {
        char * szHelpString = pTA->GetText();
        A2O(wszScratch, szHelpString, MAX_PATH);
        pCTL->SetDocString(wszScratch);
    }

    HRESULT hr = ResultFromScode(S_OK);
    if (pTA = (node_text_attr *)pType->GetAttribute(ATTR_HELPSTRINGDLL))
    {
        char * szHelpStringDll = pTA->GetText();
        A2O(wszScratch, szHelpStringDll, MAX_PATH);
        hr = ((ICreateTypeLib2*)pCTL)->SetHelpStringDll(wszScratch);
    }

    node_constant_attr *pCA;
    if (pCA = (node_constant_attr *) pType->GetAttribute(ATTR_HELPCONTEXT))
    {
        DWORD hc = (DWORD) pCA->GetExpr()->GetValue();
        pCTL->SetHelpContext(hc);
    }

    if (pCA = (node_constant_attr *) pType->GetAttribute(ATTR_HELPSTRINGCONTEXT))
    {
        DWORD hc = (DWORD) pCA->GetExpr()->GetValue();
        ((ICreateTypeLib2 *)pCTL)->SetHelpStringContext(hc);
    }

    ATTRLIST            myAttrs;
    node_base_attr  *   pCurAttr;
    ATTR_T              curAttrID;
    VARIANT             var;
    GUID                guid;

    ((named_node*)GetType())->GetAttributeList( myAttrs );

    pCurAttr    =   myAttrs.GetFirst();
    while ( pCurAttr )
        {
        curAttrID = pCurAttr->GetAttrID();

        if (curAttrID == ATTR_CUSTOM)
            {
            ZeroMemory( &var,
                        sizeof(VARIANT));
            ConvertToVariant(   var,
                                ((node_custom_attr*)pCurAttr)->GetVal(), 
                                pCCB->GetLcid());
            ((node_custom_attr*)pCurAttr)->GetGuid()->GetGuid(guid);
            ((ICreateTypeLib2 *)pCTL)->SetCustData(guid,
                                                    &var);
            }
        pCurAttr = pCurAttr->GetNext();
        }

    // set compiler version and time stamp
    if ( !pCommand->IsSwitchDefined( SWITCH_NO_STAMP ) )
        {
        CHAR szBuffer[MAX_PATH];  // long enough for the readable data
        // {DE77BA63-517C-11d1-A2DA-0000F8773CE9}
        const GUID TimeStampGuid =
        { 0xde77ba63, 0x517c, 0x11d1, { 0xa2, 0xda, 0x0, 0x0, 0xf8, 0x77, 0x3c, 0xe9 } };

        // {DE77BA64-517C-11d1-A2DA-0000F8773CE9}
        const GUID CompilerVersionGuid =
        { 0xde77ba64, 0x517c, 0x11d1, { 0xa2, 0xda, 0x0, 0x0, 0xf8, 0x77, 0x3c, 0xe9 } };

        // {DE77BA65-517C-11d1-A2DA-0000F8773CE9}
        const GUID ReadableMIDLInfoGuid = { 0xde77ba65, 0x517c, 0x11d1, { 0xa2, 0xda, 0x0, 0x0, 0xf8, 0x77, 0x3c, 0xe9 } };

        strcpy(szBuffer, "Created by MIDL version ");
        strcat(szBuffer,pCommand->GetCompilerVersion());
        strcat(szBuffer, " at ");
        strcat(szBuffer,pCommand->GetCompileTime() );
        A2O(wszScratch, szBuffer, MAX_PATH);

        var.vt = VT_BSTR;
        var.bstrVal = LateBound_SysAllocString( wszScratch );
        ( ( ICreateTypeLib2* ) pCTL )->SetCustData( ReadableMIDLInfoGuid, &var );
        LateBound_SysFreeString( var.bstrVal );
        
        ZeroMemory( &var, sizeof( VARIANT ) );

        time( ( time_t* ) &var.lVal );
        var.vt = VT_UI4;
        ( ( ICreateTypeLib2* ) pCTL )->SetCustData( TimeStampGuid, &var );

        var.lVal = ( rmj << 24 ) + ( rmm << 16 ) + rup;
        ( ( ICreateTypeLib2* ) pCTL )->SetCustData( CompilerVersionGuid, &var );
       
        }

    unsigned short Maj;
    unsigned short Min;
    pType->GetVersionDetails(&Maj, &Min);
    pCTL->SetVersion(Maj, Min);

    if (pCA = (node_constant_attr *) pType->GetAttribute(ATTR_LCID))
    {
        DWORD lcid = (DWORD) pCA->GetExpr()->GetValue();
        pCTL->SetLcid(pCCB->SetLcid(lcid));
    }
    else
    {
        pCTL->SetLcid(pCCB->SetLcid(0));
    }

    UINT libflags = 0;
    if (pType->FMATTRInSummary(MATTR_RESTRICTED))
        libflags |= LIBFLAG_FRESTRICTED;
    if (pType->FTATTRInSummary(TATTR_CONTROL))
        libflags |= LIBFLAG_FCONTROL;
    if (pType->FInSummary(ATTR_HIDDEN))
        libflags |= LIBFLAG_FHIDDEN;
    pCTL->SetLibFlags(libflags);

    CG_ITERATOR I;
    CG_INTERFACE *  pCG;

    GetMembers( I );

    I.Init();
    while( ITERATOR_GETNEXT( I, pCG ) )
        {
        ITypeInfo * pTI;
        char*       sz = pCG->GetSymName();
        if (0 != _stricmp(sz, "IDispatch") &&
            0 != _stricmp(sz, "IUnknown"))
            {
            if (!(pTI = (ITypeInfo *)pCG->CheckImportLib()))
                {
                // we postpone the creation of typeinfo for interface reference
                // (which actually results in the creation of typeinfo for an
                // interface) to maintain the equivalence in the order of 
                // definition in the source file and the resulting type library.
                ID_CG cgId = pCG->GetCGID();
                if ( cgId != ID_CG_INTERFACE_REFERENCE )
                    {
                    pCG->GenTypeInfo(pCCB);
                    }
                }
            else
                {
                pTI->Release();
                }
            }
        }

    I.Init();
    while( ITERATOR_GETNEXT( I, pCG ) )
        {
        ITypeInfo * pTI;
        char*       sz = pCG->GetSymName();
        if (0 != _stricmp(sz, "IDispatch") &&
            0 != _stricmp(sz, "IUnknown"))
            {
            if (!(pTI = (ITypeInfo *)pCG->CheckImportLib()))
                {
                // this trict ensures that type info for the base interface is created
                // before the typeinfo for the derived interface. This is important for
                // utilities that generate .H .TLH and .TLI from the .TLB
                ID_CG cgId = pCG->GetCGID();
                if ( cgId == ID_CG_INTERFACE_REFERENCE )
                    {
                    pCG->GenTypeInfo(pCCB);
                    }
                }
            else
                {
                pTI->Release();
                }
            }
        }

    CG_CLASS*           pCGI = 0;
    ICreateTypeInfo*    pCTI = 0;

    pCCB->InitVTableLayOutList();
    while (pCCB->GetNextVTableLayOutInfo(&pCGI, &pCTI))
        {
        szName = pCGI->GetType()->GetSymName();
        if (pCGI && pCTI)
            {
            HRESULT hr = (HRESULT)pCGI->LayOut();
            if FAILED(hr)
                {
                ReportTLGenError(  "LayOut failed", szName, hr);
                }
            pCTI->Release();
            }
        else
            {
            ReportTLGenError(  "LayOut failed", szName, hr);
            }
        }
    pCCB->DiscardVTableLayOutList();

    return CG_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CG_LIBRARY::GenHeader
//
//  Synopsis:   generates header file information for a type library
//
//  Arguments:  [pCCB] - CG control block
//
//  Returns:    CG_OK
//
//  History:    6-13-95   stevebl   Commented
//
//----------------------------------------------------------------------------

CG_STATUS CG_LIBRARY::GenHeader(CCB * pCCB)
{
    CG_ITERATOR I;
    CG_NDR *  pCG;
    node_library * pLibrary = (node_library *) GetType();
    char * szName = pLibrary->GetSymName();

    ISTREAM * pStream = pCCB->GetStream();
    pStream->Write("\n\n#ifndef __");
    pStream->Write(szName);
    pStream->Write("_LIBRARY_DEFINED__\n");
    pStream->Write("#define __");
    pStream->Write(szName);
    pStream->Write("_LIBRARY_DEFINED__\n");
    GetMembers( I );

    // dump all of the types
    pStream->NewLine();
    pLibrary->PrintType((PRT_INTERFACE | PRT_BOTH_PREFIX), pStream, 0);

    pStream->NewLine();
    if (pCommand->IsSwitchDefined(SWITCH_MKTYPLIB))
    {
        node_guid * pGuid = (node_guid *) pLibrary->GetAttribute( ATTR_GUID );
        if (pGuid)
            Out_MKTYPLIB_Guid(pCCB, pGuid->GetStrs(), "LIBID_", szName);
    }
    else
    {
        pStream->Write("EXTERN_C const IID LIBID_");
        pStream->Write(szName);
        pStream->Write(';');
        pStream->NewLine();
    }


    // now dump all of the interfaces, dispinterfaces, etc.
    I.Init();
    while( ITERATOR_GETNEXT( I, pCG ) )
    {
        pCG->GenHeader(pCCB);
    }

    pStream->Write("#endif /* __");
    pStream->Write(szName);
    pStream->Write("_LIBRARY_DEFINED__ */\n");
    return CG_OK;
}

// create the typeinfo but do not populate it.
// helps preserve the order or interface declaration.
CG_STATUS  CG_INTERFACE::CreateTypeInfo( CCB * pCCB )
{
    ICreateTypeLib*     pCTL = pCCB->GetCreateTypeLib();
    char*               szName = GetType()->GetSymName();

    A2O(wszScratch, szName, MAX_PATH);
    HRESULT hr = pCTL->CreateTypeInfo(wszScratch, TKIND_INTERFACE, ( ICreateTypeInfo ** )&_pCTI);
    if (SUCCEEDED(hr))
        {
        gpobjholder->Add( ( IUnknown* ) _pCTI);
        }
    else
        {
        ReportTLGenError(  "CreateTypeInfo failed", szName, hr);
        }
    return CG_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CG_INTERFACE::GenTypeInfo
//
//  Synopsis:   generates a type info for an interface
//
//  Arguments:  [pCCB] - CG control block
//
//  Returns:    CG_OK
//
//  History:    6-13-95   stevebl   Commented
//
//----------------------------------------------------------------------------

CG_STATUS CG_INTERFACE::GenTypeInfo(CCB *pCCB)
{
    // check to see if we've already been initialized.
    if ( fTypeInfoInitialized )
    {
        pCCB->SetCreateTypeInfo((ICreateTypeInfo *) _pCTI);
        return CG_OK;
    }

    // if typeinfo was not created, create it.
    if ( _pCTI == 0 )
        {
        CreateTypeInfo( pCCB );
        if ( _pCTI == 0 )
            {
            return CG_OK;
            }
        }
    fTypeInfoInitialized = TRUE;

    HRESULT             hr      = S_OK;
    node_interface*     pItf    = (node_interface *) GetType();
    char*               szName  = pItf->GetSymName();
    ICreateTypeInfo*    pCTI    = ( ICreateTypeInfo * ) _pCTI;

    pCCB->SetCreateTypeInfo(pCTI);
    BOOL fRemember = pCCB->IsInDispinterface();
    pCCB->SetInDispinterface(FALSE);

    WALK_CTXT ctxt(GetType());
    UINT uTypeFlags = GetTypeFlags(&ctxt);
    if (FNewTypeLib())
    {
        if ( IsDispatchable(TRUE) )
        {
            uTypeFlags |= TYPEFLAG_FDISPATCHABLE;
        }        
    }
    hr = pCTI->SetTypeFlags(uTypeFlags);
    if ( FAILED( hr ) )
        {
        ReportTLGenError( szErrTypeFlags, szName, hr);
        }

    node_guid * pGuid = (node_guid *) ctxt.GetAttribute( ATTR_GUID );
    if (pGuid)
    {
        GUID guid;
        pGuid->GetGuid(guid);
        hr = pCTI->SetGuid(guid);
        if ( FAILED( hr ) )
            {
            ReportTLGenError(  "Could not add UUID, STDOLE2.TLB probably needs to be imported", szName, hr);
            }
    }
    node_text_attr * pTA;
    if (pTA = (node_text_attr *)ctxt.GetAttribute(ATTR_HELPSTRING))
    {
        char * szHelpString = pTA->GetText();
        A2O(wszScratch, szHelpString, MAX_PATH);
        hr = pCTI->SetDocString(wszScratch);
        if ( FAILED( hr ) )
            {
            ReportTLGenError( szErrHelpString, szName, hr);
            }
    }

    node_constant_attr *pCA;
    if (pCA = (node_constant_attr *) ctxt.GetAttribute(ATTR_HELPCONTEXT))
    {
        DWORD hc = (DWORD) pCA->GetExpr()->GetValue();
        hr = pCTI->SetHelpContext(hc);
        if ( FAILED( hr ) )
            {
            ReportTLGenError( szErrHelpContext, szName, hr);
            }
    }

    if (pCA = (node_constant_attr *) ctxt.GetAttribute(ATTR_HELPSTRINGCONTEXT))
    {
        DWORD hc = (DWORD) pCA->GetExpr()->GetValue();
        ((ICreateTypeInfo2 *)pCTI)->SetHelpStringContext(hc);
    }


    ATTRLIST            myAttrs;
    node_base_attr  *   pCurAttr;
    ATTR_T              curAttrID;
    VARIANT             var;
    GUID                guid;

    ((named_node*)GetType())->GetAttributeList( myAttrs );

    pCurAttr    =   myAttrs.GetFirst();
    while ( pCurAttr )
        {
        curAttrID = pCurAttr->GetAttrID();

        if (curAttrID == ATTR_CUSTOM)
            {
            ZeroMemory( &var,
                        sizeof(VARIANT));
            ConvertToVariant(   var,
                                ((node_custom_attr*)pCurAttr)->GetVal(), 
                                pCCB->GetLcid());
            ((node_custom_attr*)pCurAttr)->GetGuid()->GetGuid(guid);
            ((ICreateTypeInfo2 *)pCTI)->SetCustData(guid,
                                                    &var);
            }
        pCurAttr = pCurAttr->GetNext();
        }

    unsigned short Maj;
    unsigned short Min;
    pItf->GetVersionDetails(&Maj, &Min);
    hr = pCTI->SetVersion(Maj, Min);
    if ( FAILED( hr ) )
        {
        ReportTLGenError( szErrVersion, szName, hr);
        }

    // CONSIDER - may still need to check for MATTR_RESTRICTED

    CG_CLASS *  pCG;
    named_node * pBaseIntf;

    node_skl * pType = GetType();
    if (pBaseIntf = ((node_interface *)(pType))->GetMyBaseInterfaceReference())
    {
        node_interface_reference * pRef = (node_interface_reference *)pBaseIntf;
        // skip forward reference if necessary
        if (pRef->NodeKind() == NODE_FORWARD)
        {
            pRef = (node_interface_reference *)pRef->GetChild();
        }
        pCG = ((node_interface *)(pRef->GetChild()))->GetCG( TRUE);

        ITypeInfo * pTI;
        if (NULL == (pTI = (ITypeInfo *)pCG->CheckImportLib()))
        {
            pCG->GenTypeInfo(pCCB);
            ICreateTypeInfo * pNewCTI = pCCB->GetCreateTypeInfo();
            hr = pNewCTI->QueryInterface(IID_ITypeInfo, (void **)&pTI);
            if FAILED(hr)
            {
                ReportTLGenError(  "QueryInterface failed", szName, hr);
            }
        }
        // get an HREFTYPE for it
        HREFTYPE hrt;
        hr = pCTI->AddRefTypeInfo(pTI, &hrt);
        if FAILED(hr)
        {
            ReportTLGenError(  "AddRefTypeInfo failed", szName, hr);
        }

        // release the ITypeInfo.
        pTI->Release();

        // add the impltype
        hr = pCTI->AddImplType(0, hrt);
        if FAILED(hr)
        {
            ReportTLGenError(  "AddImplType failed", szName, hr);
        }

/*
        ATTRLIST            myAttrs;
        node_base_attr  *   pCurAttr;
        ATTR_T              curAttrID;
        VARIANT             var;
        GUID                guid;
*/
        ((named_node*)GetType())->GetAttributeList( myAttrs );

        pCurAttr    =   myAttrs.GetFirst();
        while ( pCurAttr )
            {
            curAttrID = pCurAttr->GetAttrID();

            if (curAttrID == ATTR_CUSTOM)
                {
                ZeroMemory( &var,
                            sizeof(VARIANT));
                ConvertToVariant(   var,
                                    ((node_custom_attr*)pCurAttr)->GetVal(), 
                                    pCCB->GetLcid());
                ((node_custom_attr*)pCurAttr)->GetGuid()->GetGuid(guid);
                ((ICreateTypeInfo2 *)pCTI)->SetCustData(guid,
                                                        &var);
                }
            pCurAttr = pCurAttr->GetNext();
            }
        }
    // restore current type info pointer
    pCCB->SetCreateTypeInfo(pCTI);

    CG_ITERATOR I;
    GetMembers( I );

    I.Init();

    unsigned uRememberPreviousFuncNum = pCCB->GetProcNum();
    unsigned uRememberPreviousVarNum = pCCB->GetVarNum();
    pCCB->SetProcNum(0);
    pCCB->SetVarNum(0);

    // walk members, adding them to the type info
    while (ITERATOR_GETNEXT(I, pCG))
    {
        pCG->GenTypeInfo(pCCB);
    }
    pCCB->SetInDispinterface(fRemember);
    
    pCCB->SetProcNum((unsigned short)uRememberPreviousFuncNum);
    pCCB->SetVarNum((unsigned short)uRememberPreviousVarNum);

    // the complementary Release() is called in CG_LIBRARY::GenTypeInfo()
    pCTI->AddRef();

    // add this node to the list of nodes to be laid out.
    pCCB->SaveVTableLayOutInfo(this, pCTI);
    return CG_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CG_INTERFACE_REFERENCE::GenTypeInfo
//
//  Synopsis:   generates type info for an interface reference
//
//  Arguments:  [pCCB] - CG control block
//
//  Returns:    CG_OK
//              CG_NOT_LAYED_OUT
//              CG_REF_NOT_LAYED_OUT
//
//  History:    6-13-95   stevebl   Commented
//
//----------------------------------------------------------------------------

CG_STATUS CG_INTERFACE_REFERENCE::GenTypeInfo(CCB *pCCB)
{
    CG_INTERFACE * pCG = (CG_INTERFACE *)((node_interface_reference *)GetType())->GetRealInterface()->GetCG(TRUE);
    return pCG->GenTypeInfo(pCCB);
}

//+---------------------------------------------------------------------------
//
//  Member:     CG_INTERFACE_REFERENCE::GenHeader
//
//  Synopsis:   generates header information for an interface reference
//
//  Arguments:  [pCCB] - CG control block
//
//  Returns:    CG_OK
//
//  History:    6-13-95   stevebl   Commented
//
//----------------------------------------------------------------------------

CG_STATUS CG_INTERFACE_REFERENCE::GenHeader(CCB * pCCB)
{
    CG_INTERFACE * pCG = (CG_INTERFACE *)((node_interface_reference *)GetType())->GetRealInterface()->GetCG(TRUE);
    return pCG->GenHeader(pCCB);
}

#if 0 // code disabled but retained in case it's ever needed again
//+---------------------------------------------------------------------------
//
//  Function:   AddInheritedMembers
//
//  Synopsis:   helper function used by a dispinterface to add entries for all
//              of the members in all of the interfaces from which it inherits
//
//  Arguments:  [pcgInterface] - pointer to an inherited interface
//              [pCCB]         - CG control block
//
//  History:    6-13-95   stevebl   Commented
//
//  Notes:      Members are added to the current ICreateTypeInfo which is
//              found in the CG control block.
//
//----------------------------------------------------------------------------

void AddInheritedMembers(CG_INTERFACE * pcgInterface, CCB * pCCB)
{
    // do any base interfaces first
    named_node * pBase = ((node_interface *)(pcgInterface->GetType()))->GetMyBaseInterfaceReference();
    if (pBase)
    {
        node_interface_reference * pRef = (node_interface_reference *) pBase;
        if (pRef->NodeKind() == NODE_FORWARD)
        {
            pRef = (node_interface_reference *)pRef->GetChild();
        }
        AddInheritedMembers((CG_INTERFACE *)((node_interface *)(pRef->GetChild()))->GetCG(TRUE), pCCB);
    }

    CG_CLASS * pCG;
    CG_ITERATOR I;
    pcgInterface->GetMembers(I);
    I.Init();
    while (ITERATOR_GETNEXT(I,pCG))
    {
        // add this interface's members to the type info
        pCG->GenTypeInfo(pCCB);
    }
}
#endif // end of disabled code


//+---------------------------------------------------------------------------
//
//  Member:     CG_DISPINTERFACE::GenTypeInfo
//
//  Synopsis:   generates a type info for a dispinterface
//
//  Arguments:  [pCCB] - CG control block
//
//  Returns:    CG_OK
//
//  History:    6-13-95   stevebl   Commented
//
//----------------------------------------------------------------------------

CG_STATUS CG_DISPINTERFACE::GenTypeInfo(CCB *pCCB)
{
    // check to see if we've already been created
    if (NULL != _pCTI)
    {
        pCCB->SetCreateTypeInfo((ICreateTypeInfo *) _pCTI);
        return CG_OK;
    }

    ICreateTypeLib * pCTL = pCCB->GetCreateTypeLib();
    ICreateTypeInfo * pCTI;

    node_dispinterface * pDispItf = (node_dispinterface *) GetType();

    char * szName = pDispItf->GetSymName();

    A2O(wszScratch, szName, MAX_PATH);

    HRESULT hr = pCTL->CreateTypeInfo(wszScratch, TKIND_DISPATCH, &pCTI);

    if (SUCCEEDED(hr))
    {
        _pCTI = pCTI;
        pCCB->SetCreateTypeInfo(pCTI);
        gpobjholder->Add(pCTI);

        WALK_CTXT ctxt(GetType());

        UINT uTypeFlags = GetTypeFlags(&ctxt);
        if (FNewTypeLib())
        {
            uTypeFlags |= TYPEFLAG_FDISPATCHABLE;
        }
        hr = pCTI->SetTypeFlags(uTypeFlags);
        if ( FAILED( hr ) )
            {
            ReportTLGenError( "SetTypeFlags() failed", szName, hr);
            }

        ATTRLIST            myAttrs;
        node_base_attr  *   pCurAttr;
        ATTR_T              curAttrID;
        VARIANT             var;
        GUID                guid;

        ((named_node*)GetType())->GetAttributeList( myAttrs );

        pCurAttr    =   myAttrs.GetFirst();
        while ( pCurAttr )
            {
            curAttrID = pCurAttr->GetAttrID();

            if (curAttrID == ATTR_CUSTOM)
                {
                ZeroMemory( &var,
                            sizeof(VARIANT));
                ConvertToVariant(   var,
                                    ((node_custom_attr*)pCurAttr)->GetVal(), 
                                    pCCB->GetLcid());
                ((node_custom_attr*)pCurAttr)->GetGuid()->GetGuid(guid);
                ((ICreateTypeInfo2 *)pCTI)->SetCustData(guid,
                                                        &var);
                }
            pCurAttr = pCurAttr->GetNext();
            }

        node_guid * pGuid = (node_guid *) ctxt.GetAttribute( ATTR_GUID );
        if (pGuid)
        {
            GUID guid1;
            pGuid->GetGuid(guid1);
            hr = pCTI->SetGuid(guid1);
            if ( FAILED( hr ) )
                {
                ReportTLGenWarning( szErrUUID, szName, hr);
                }
        }
        node_text_attr * pTA;
        if (pTA = (node_text_attr *)ctxt.GetAttribute(ATTR_HELPSTRING))
        {
            char * szHelpString = pTA->GetText();
            A2O(wszScratch, szHelpString, MAX_PATH);
            hr = pCTI->SetDocString(wszScratch);
            if ( FAILED( hr ) )
                {
                ReportTLGenError( szErrHelpString, szName, hr);
                }
        }

        node_constant_attr *pCA;
        if (pCA = (node_constant_attr *) ctxt.GetAttribute(ATTR_HELPCONTEXT))
        {
            DWORD hc = (DWORD) pCA->GetExpr()->GetValue();
            hr = pCTI->SetHelpContext(hc);
            if ( FAILED( hr ) )
                {
                ReportTLGenError( szErrHelpContext, szName, hr);
                }
        }

        if (pCA = (node_constant_attr *) ctxt.GetAttribute(ATTR_HELPSTRINGCONTEXT))
        {
            DWORD hc = (DWORD) pCA->GetExpr()->GetValue();
            ((ICreateTypeInfo2 *)pCTI)->SetHelpStringContext(hc);
        }

        unsigned short Maj;
        unsigned short Min;
        pDispItf->GetVersionDetails(&Maj, &Min);
        hr = pCTI->SetVersion(Maj, Min);
        if ( FAILED( hr ) )
            {
            ReportTLGenError( szErrVersion, szName, hr);
            }

        // CONSIDER - may still need to check for MATTR_RESTRICTED
        CG_CLASS * pCG;
        // Put in the impltype to IDispatch
        pCG = GetCGDispatch();
        ITypeInfo * pTI;

        if (NULL == (pTI = (ITypeInfo *)pCG->CheckImportLib()))
        {
            pCG->GenTypeInfo(pCCB);
            ICreateTypeInfo * pNewCTI = pCCB->GetCreateTypeInfo();
            hr = pNewCTI->QueryInterface(IID_ITypeInfo, (void **)&pTI);
            if FAILED(hr)
            {
                ReportTLGenError(  "QueryInterface failed", szName, hr);
            }
        }
        // get an HREFTYPE for it
        HREFTYPE hrt;
        hr = pCTI->AddRefTypeInfo(pTI, &hrt);
        if FAILED(hr)
        {
            ReportTLGenError(  "AddRefTypeInfo failed", szName, hr);
        }
        
        // release the ITypeInfo.
        pTI->Release();

        // add the impltype
        hr = pCTI->AddImplType(0, hrt);
        if FAILED(hr)
        {
            ReportTLGenError(  "AddImplType failed", szName, hr);
        }
        // restore current type info pointer
        pCCB->SetCreateTypeInfo(pCTI);

        CG_ITERATOR I;
        GetMembers( I );

        I.Init();

        unsigned uRememberPreviousFuncNum = pCCB->GetProcNum();
        unsigned uRememberPreviousVarNum = pCCB->GetVarNum();
        pCCB->SetProcNum(0);
        pCCB->SetVarNum(0);
        BOOL fRemember = pCCB->IsInDispinterface();
        pCCB->SetInDispinterface(TRUE);

        BOOL fContinue = ITERATOR_GETNEXT(I,pCG);

        if (fContinue)
        {
            if (ID_CG_INTERFACE_PTR == pCG->GetCGID())
            {
                // syntax 1
                // get the first base interface
                node_interface * pI = (node_interface *)((CG_INTERFACE_POINTER *)pCG)->GetTheInterface();
                CG_INTERFACE * pcgInterface = (CG_INTERFACE *)(pI->GetCG(TRUE));
                // Put in the impltype to inherited interface
                ITypeInfo * pTI1;

                if (NULL == pcgInterface)
                {
                    // This must be an imported definition.
                    // Call ILxlate to manufacture a CG node for it
                    XLAT_CTXT ctxt1(GetType());
                    ctxt1.SetAncestorBits(IL_IN_LIBRARY);
                    pcgInterface = (CG_INTERFACE *)(pI->ILxlate(&ctxt1));
                    // make sure we get the right CG node
                    if (pI->GetCG(TRUE))
                       pcgInterface = (CG_INTERFACE *)(pI->GetCG(TRUE));
                }

                if (NULL == (pTI1 = (ITypeInfo *)pcgInterface->CheckImportLib()))
                {
                    pcgInterface->GenTypeInfo(pCCB);
                    ICreateTypeInfo * pNewCTI = pCCB->GetCreateTypeInfo();
                    hr = pNewCTI->QueryInterface(IID_ITypeInfo, (void **)&pTI1);
                    if FAILED(hr)
                    {
                        ReportTLGenError(  "QueryInterface failed", szName, hr);
                    }
                }
                // get an HREFTYPE for it
                HREFTYPE hrt1;
                hr = pCTI->AddRefTypeInfo(pTI1, &hrt1);
                if FAILED(hr)
                {
                    ReportTLGenError(  "AddRefTypeInfo failed", szName, hr);
                }

                // release the ITypeInfo.
                pTI1->Release();

                // add the impltype
                hr = pCTI->AddImplType(1, hrt1);
                if FAILED(hr)
                {
                    ReportTLGenError(  "AddImplType failed", szName, hr);
                }
                // restore current type info pointer
                pCCB->SetCreateTypeInfo(pCTI);
            }
            else
            {
                // syntax 2
                // walk members, adding them to the type info
                while (fContinue)
                {
                    pCG->GenTypeInfo(pCCB);
                    fContinue = ITERATOR_GETNEXT(I,pCG);
                }
            }
        }

        pCCB->SetProcNum((unsigned short)uRememberPreviousFuncNum);
        pCCB->SetVarNum((unsigned short)uRememberPreviousVarNum);
        pCCB->SetInDispinterface(fRemember);
        
        // the complementary Release() is called in CG_LIBRARY::GenTypeInfo()
        pCTI->AddRef();

        // add this node to the list of nodes to be laid out.
        pCCB->SaveVTableLayOutInfo(this, pCTI);
    }
    else
    {
        ReportTLGenError(  "CreateTypeInfo failed", szName, hr);
    }
    return CG_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CG_DISPINTERFACE::GenHeader
//
//  Synopsis:   generates header file information for a dispinterface
//
//  Arguments:  [pCCB] - CG control block
//
//  Returns:    CG_OK
//
//  History:    6-13-95   stevebl   Commented
//
//----------------------------------------------------------------------------

CG_STATUS CG_DISPINTERFACE::GenHeader(CCB * pCCB)
{
    node_interface *    pInterface = (node_interface *) GetType();
    ISTREAM *           pStream = pCCB->GetStream();
        char                    *       pName   = pInterface->GetSymName();
    CG_OBJECT_INTERFACE * pCGDispatch = (CG_OBJECT_INTERFACE *)GetCGDispatch();

    //Initialize the CCB for this interface.
    InitializeCCB(pCCB);

        // put out the interface guards
        pStream->Write("\n#ifndef __");
        pStream->Write( pName );
        pStream->Write( "_DISPINTERFACE_DEFINED__\n" );

        pStream->Write( "#define __");
        pStream->Write( pName );
        pStream->Write( "_DISPINTERFACE_DEFINED__\n" );

    // Print out the declarations of the types
    pStream->NewLine();
    pInterface->PrintType( PRT_INTERFACE | PRT_OMIT_PROTOTYPE, pStream, 0);

    pStream->NewLine();
    if (pCommand->IsSwitchDefined(SWITCH_MKTYPLIB))
    {
        node_guid * pGuid = (node_guid *) pInterface->GetAttribute( ATTR_GUID );
        if (pGuid)
            Out_MKTYPLIB_Guid(pCCB, pGuid->GetStrs(), "DIID_", pName);
    }
    else
    {
        pStream->Write("EXTERN_C const IID DIID_");
        pStream->Write(pName);
        pStream->Write(';');
        pStream->NewLine();
    }

    // print out the vtable/class definitions
    pStream->NewLine();
    pStream->Write("#if defined(__cplusplus) && !defined(CINTERFACE)");

    pStream->IndentInc();
    pStream->NewLine(2);

    // put out the declspec for the uuid
    if ( pCommand->GetMSCVer() >= 1100 )
        {
        pStream->Write("MIDL_INTERFACE(\"");
        pStream->Write(GuidStrs.str1);
        pStream->Write('-');
        pStream->Write(GuidStrs.str2);
        pStream->Write('-');
        pStream->Write(GuidStrs.str3);
        pStream->Write('-');
        pStream->Write(GuidStrs.str4);
        pStream->Write('-');
        pStream->Write(GuidStrs.str5);
        pStream->Write("\")");
        }
    else
        {
        pStream->Write(" struct ");
        }

    pStream->NewLine();
    pStream->Write(pName);
    pStream->Write(" : public IDispatch");
    pStream->NewLine();
    pStream->Write('{');
    pStream->NewLine();
    pStream->Write("};");
    pStream->NewLine();
    pStream->IndentDec();

    pStream->NewLine();
    pStream->Write("#else \t/* C style interface */");

    pStream->IndentInc();
    pCGDispatch->CLanguageBinding(pCCB);
    pStream->IndentDec();

        // print out the C Macros
        pCGDispatch->CLanguageMacros( pCCB );
    pStream->NewLine( 2 );

    pStream->Write("#endif \t/* C style interface */");
    pStream->NewLine( 2 );

    // print out the commented prototypes for the dispatch methods and procedures

        // put out the trailing interface guard
        pStream->Write( "\n#endif \t/* __");
        pStream->Write( pName );
        pStream->Write( "_DISPINTERFACE_DEFINED__ */\n" );

    pStream->NewLine();
    return CG_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CG_MODULE::GenTypeInfo
//
//  Synopsis:   generates a type info for a module
//
//  Arguments:  [pCCB] - CG control block
//
//  Returns:    CG_OK
//
//  History:    6-13-95   stevebl   Commented
//
//----------------------------------------------------------------------------

CG_STATUS CG_MODULE::GenTypeInfo(CCB *pCCB)
{
    // check to see if we've already been created
    if (NULL != _pCTI)
    {
        pCCB->SetCreateTypeInfo((ICreateTypeInfo *) _pCTI);
        return CG_OK;
    }

    ICreateTypeLib * pCTL = pCCB->GetCreateTypeLib();
    ICreateTypeInfo * pCTI;

    node_coclass * pCC = (node_coclass *) GetType();

    char * szName = pCC->GetSymName();

    A2O(wszScratch, szName, MAX_PATH);

    HRESULT hr = pCTL->CreateTypeInfo(wszScratch, TKIND_MODULE, &pCTI);

    if (SUCCEEDED(hr))
    {
        _pCTI = pCTI;
        pCCB->SetCreateTypeInfo(pCTI);
        gpobjholder->Add(pCTI);

        WALK_CTXT ctxt(GetType());
        hr = pCTI->SetTypeFlags(GetTypeFlags(&ctxt));
        if ( FAILED( hr ) )
            {
            ReportTLGenError( szErrTypeFlags, szName, hr);
            }

        ATTRLIST            myAttrs;
        node_base_attr  *   pCurAttr;
        ATTR_T              curAttrID;
        VARIANT             var;
        GUID                guid;

        ((named_node*)GetType())->GetAttributeList( myAttrs );

        pCurAttr    =   myAttrs.GetFirst();
        while ( pCurAttr )
            {
            curAttrID = pCurAttr->GetAttrID();

            if (curAttrID == ATTR_CUSTOM)
                {
                ZeroMemory( &var,
                            sizeof(VARIANT));
                ConvertToVariant(   var,
                                    ((node_custom_attr*)pCurAttr)->GetVal(), 
                                    pCCB->GetLcid());
                ((node_custom_attr*)pCurAttr)->GetGuid()->GetGuid(guid);
                ((ICreateTypeInfo2 *)pCTI)->SetCustData(guid,
                                                        &var);
                }
            pCurAttr = pCurAttr->GetNext();
            }

        node_guid * pGuid = (node_guid *) ctxt.GetAttribute( ATTR_GUID );
        if (pGuid)
        {
            GUID guid;
            pGuid->GetGuid(guid);
            hr = pCTI->SetGuid(guid);
            if ( FAILED( hr ) )
                {
                ReportTLGenWarning( szErrUUID, szName, hr);
                }
        }

        node_text_attr * pTA;
        if (pTA = (node_text_attr *)ctxt.GetAttribute(ATTR_HELPSTRING))
        {
            char * szHelpString = pTA->GetText();
            A2O(wszScratch, szHelpString, MAX_PATH);
            hr = pCTI->SetDocString(wszScratch);
            if ( FAILED( hr ) )
                {
                ReportTLGenError( szErrHelpString, szName, hr);
                }
        }

        if (pTA = (node_text_attr *)ctxt.GetAttribute(ATTR_DLLNAME))
        {
            pCCB->SetDllName(pTA->GetText());
        }

        node_constant_attr *pCA;
        if (pCA = (node_constant_attr *) ctxt.GetAttribute(ATTR_HELPCONTEXT))
        {
            DWORD hc = (DWORD) pCA->GetExpr()->GetValue();
            hr = pCTI->SetHelpContext(hc);
            if ( FAILED( hr ) )
                {
                ReportTLGenError( szErrHelpContext, szName, hr);
                }
        }

        if (pCA = (node_constant_attr *) ctxt.GetAttribute(ATTR_HELPSTRINGCONTEXT))
        {
            DWORD hc = (DWORD) pCA->GetExpr()->GetValue();
            ((ICreateTypeInfo2 *)pCTI)->SetHelpStringContext(hc);
        }

        unsigned short Maj;
        unsigned short Min;
        pCC->GetVersionDetails(&Maj, &Min);
        hr = pCTI->SetVersion(Maj, Min);
        if ( FAILED( hr ) )
            {
            ReportTLGenError( szErrVersion, szName, hr);
            }

        // CONSIDER - may still need to check for MATTR_RESTRICTED

        CG_CLASS *  pCG;

        CG_ITERATOR I;
        GetMembers( I );

        I.Init();

        unsigned uRememberPreviousFuncNum = pCCB->GetProcNum();
        unsigned uRememberPreviousVarNum = pCCB->GetVarNum();
        pCCB->SetProcNum(0);
        pCCB->SetVarNum(0);

        // walk members, adding them to the type info
        while (ITERATOR_GETNEXT(I, pCG))
        {
            pCG->GenTypeInfo(pCCB);
        }

        pCCB->SetProcNum((unsigned short)uRememberPreviousFuncNum);
        pCCB->SetVarNum((unsigned short)uRememberPreviousVarNum);

        // the complementary Release() is called in CG_LIBRARY::GenTypeInfo()
        pCTI->AddRef();

        // add this node to the list of nodes to be laid out.
        pCCB->SaveVTableLayOutInfo(this, pCTI);
    }
    else
    {
        ReportTLGenError(  "CreateTypeInfo failed", szName, hr);
    }
    return CG_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CG_MODULE::GenHeader
//
//  Synopsis:   generates header information for a module
//
//  Arguments:  [pCCB] - CG control block
//
//  Returns:    CG_OK
//
//  History:    6-13-95   stevebl   Commented
//
//----------------------------------------------------------------------------

CG_STATUS CG_MODULE::GenHeader(CCB * pCCB)
{
    CG_ITERATOR I;
    node_module * pModule = (node_module *) GetType();
    char * szName = pModule->GetSymName();

    ISTREAM * pStream = pCCB->GetStream();
    pStream->Write("\n\n#ifndef __");
    pStream->Write(szName);
    pStream->Write("_MODULE_DEFINED__\n");
    pStream->Write("#define __");
    pStream->Write(szName);
    pStream->Write("_MODULE_DEFINED__\n");
    pStream->NewLine();

    // Print out the declarations of the types
    pStream->NewLine();
    pModule->PrintType( PRT_DECLARATION , pStream, 0);

    pStream->Write("#endif /* __");
    pStream->Write(szName);
    pStream->Write("_MODULE_DEFINED__ */\n");
    return CG_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CG_COCLASS::GenTypeInfo
//
//  Synopsis:   generates a type info for a coclass
//
//  Arguments:  [pCCB] - CG control block
//
//  Returns:    CG_OK
//
//  History:    6-13-95   stevebl   Commented
//
//----------------------------------------------------------------------------

CG_STATUS CG_COCLASS::GenTypeInfo(CCB *pCCB)
{
    // check to see if we've already been created
    if (NULL != _pCTI)
    {
        pCCB->SetCreateTypeInfo((ICreateTypeInfo *) _pCTI);
        return CG_OK;
    }

    ICreateTypeLib * pCTL = pCCB->GetCreateTypeLib();
    ICreateTypeInfo * pCTI;

    node_coclass * pCC = (node_coclass *) GetType();

    char * szName = pCC->GetSymName();

    A2O(wszScratch, szName, MAX_PATH);

    HRESULT hr = pCTL->CreateTypeInfo(wszScratch, TKIND_COCLASS, &pCTI);

    if (SUCCEEDED(hr))
    {
        _pCTI = pCTI;
        pCCB->SetCreateTypeInfo(pCTI);
        gpobjholder->Add(pCTI);

        WALK_CTXT ctxt(GetType());
        UINT uTypeFlags = GetTypeFlags(&ctxt);
        if (!pCC->IsNotCreatable())
        {
            uTypeFlags |= TYPEFLAG_FCANCREATE;
        }
        hr = pCTI->SetTypeFlags(uTypeFlags);
        if ( FAILED( hr ) )
            {
            ReportTLGenError( szErrTypeFlags, szName, hr);
            }

        ATTRLIST            myAttrs;
        node_base_attr  *   pCurAttr;
        ATTR_T              curAttrID;
        VARIANT             var;
        GUID                guid;

        ((named_node*)GetType())->GetAttributeList( myAttrs );

        pCurAttr    =   myAttrs.GetFirst();
        while ( pCurAttr )
            {
            curAttrID = pCurAttr->GetAttrID();

            if (curAttrID == ATTR_CUSTOM)
                {
                ZeroMemory( &var,
                            sizeof(VARIANT));
                ConvertToVariant(   var,
                                    ((node_custom_attr*)pCurAttr)->GetVal(), 
                                    pCCB->GetLcid());
                ((node_custom_attr*)pCurAttr)->GetGuid()->GetGuid(guid);
                ((ICreateTypeInfo2 *)pCTI)->SetCustData(guid,
                                                        &var);
                }
            pCurAttr = pCurAttr->GetNext();
            }

        node_guid * pGuid = (node_guid *) ctxt.GetAttribute( ATTR_GUID );
        if (pGuid)
        {
            GUID guid;
            pGuid->GetGuid(guid);
            hr = pCTI->SetGuid(guid);
            if ( FAILED( hr ) )
                {
                ReportTLGenWarning( szErrUUID, szName, hr);
                }
        }
        node_text_attr * pTA;
        if (pTA = (node_text_attr *)ctxt.GetAttribute(ATTR_HELPSTRING))
        {
            char * szHelpString = pTA->GetText();
            A2O(wszScratch, szHelpString, MAX_PATH);
            hr = pCTI->SetDocString(wszScratch);
            if ( FAILED( hr ) )
                {
                ReportTLGenError( szErrHelpString, szName, hr);
                }
        }

        node_constant_attr *pCA;
        if (pCA = (node_constant_attr *) ctxt.GetAttribute(ATTR_HELPCONTEXT))
        {
            DWORD hc = (DWORD) pCA->GetExpr()->GetValue();
            hr = pCTI->SetHelpContext(hc);
            if ( FAILED( hr ) )
                {
                ReportTLGenError( szErrHelpContext, szName, hr);
                }
        }

        if (pCA = (node_constant_attr *) ctxt.GetAttribute(ATTR_HELPSTRINGCONTEXT))
        {
            DWORD hc = (DWORD) pCA->GetExpr()->GetValue();
            ((ICreateTypeInfo2 *)pCTI)->SetHelpStringContext(hc);
        }

        unsigned short Maj;
        unsigned short Min;
        pCC->GetVersionDetails(&Maj, &Min);
        hr = pCTI->SetVersion(Maj, Min);
        if ( FAILED( hr ) )
            {
            ReportTLGenError( "SetTypeFlags() failed", szName, hr);
            }

        // CONSIDER - may still need to check for MATTR_RESTRICTED
        CG_CLASS *  pCG;
        CG_ITERATOR I;
        GetMembers( I );

        I.Init();
        MEM_ITER MemIter(pCC);

        unsigned nImpltype = 0;
        // walk members, adding them to the type info
        while (ITERATOR_GETNEXT(I, pCG))
        {
            ITypeInfo * pTI;
//            if (ID_CG_INTERFACE_POINTER == pCG->GetCGID())
//                pCG= pCG->GetChild();
            if (NULL == (pTI = (ITypeInfo *)pCG->CheckImportLib()))
            {
                pCG->GenTypeInfo(pCCB);
                ICreateTypeInfo * pNewCTI = pCCB->GetCreateTypeInfo();
                hr = pNewCTI->QueryInterface(IID_ITypeInfo, (void **)&pTI);
                if FAILED(hr)
                {
                    ReportTLGenError(  "QueryInterface failed", szName, hr);
                }
            }
            // get an HREFTYPE for it
            HREFTYPE hrt;
            hr = pCTI->AddRefTypeInfo(pTI, &hrt);
            if FAILED(hr)
            {
                ReportTLGenError(  "AddRefTypeInfo failed", szName, hr);
            }
            
            // release the ITypeInfo.
            pTI->Release();
            
            // add the impltype
            hr = pCTI->AddImplType(nImpltype, hrt);
            if FAILED(hr)
            {
                ReportTLGenError(  "AddImplType failed", szName, hr);
            }

            // Get the ipltype attributes from the node_forward
            WALK_CTXT ctxt(MemIter.GetNext());
            hr = pCTI->SetImplTypeFlags(nImpltype, GetImplTypeFlags(&ctxt));
            if ( FAILED( hr ) )
                {
                ReportTLGenError( szErrTypeFlags, szName, hr);
                }

            node_custom_attr * pC;

            if (pC = (node_custom_attr *) ctxt.GetAttribute(ATTR_CUSTOM))
            {
                VARIANT var;
                memset(&var, 0, sizeof(VARIANT));
                ConvertToVariant(var, pC->GetVal(), pCCB->GetLcid());
                GUID guid;
                pC->GetGuid()->GetGuid(guid);
                ((ICreateTypeInfo2 *)pCTI)->SetImplTypeCustData(nImpltype, guid, &var);
            }

            pCCB->SetCreateTypeInfo(pCTI);

            nImpltype++;
        }

        // the complementary Release() is called in CG_LIBRARY::GenTypeInfo()
        pCTI->AddRef();

        // add this node to the list of nodes to be laid out.
        pCCB->SaveVTableLayOutInfo(this, pCTI);
    }
    else
    {
        ReportTLGenError(  "CreateTypeInfo failed", szName, hr);
    }
    return CG_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CG_COCLASS::GenHeader
//
//  Synopsis:   generates header information for a coclass
//
//  Arguments:  [pCCB] - CG control block
//
//  Returns:    CG_OK
//
//  History:    6-13-95   stevebl   Commented
//
//----------------------------------------------------------------------------

CG_STATUS CG_COCLASS::GenHeader(CCB * pCCB)
{
    node_coclass *    pCoclass = (node_coclass *) GetType();
    ISTREAM *           pStream = pCCB->GetStream();
        char                    *       pName   = pCoclass->GetSymName();
    node_guid * pGuid = (node_guid *) pCoclass->GetAttribute(ATTR_GUID);

    pStream->NewLine();
    if (pCommand->IsSwitchDefined(SWITCH_MKTYPLIB))
    {
        if (pGuid)
            Out_MKTYPLIB_Guid(pCCB, pGuid->GetStrs(), "CLSID_", pName);
    }
    else
    {
        pStream->Write("EXTERN_C const CLSID CLSID_");
        pStream->Write(pName);
        pStream->Write(';');
        pStream->NewLine();
    }
    
    pStream->Write("\n#ifdef __cplusplus");
    pStream->NewLine();
    pStream->Write("\nclass ");

    if (pGuid)
    {
        GUID_STRS         GuidStrs = pGuid->GetStrs();
        // put out the declspec for the uuid
        pStream->Write("DECLSPEC_UUID(\"");
        pStream->Write(GuidStrs.str1);
        pStream->Write('-');
        pStream->Write(GuidStrs.str2);
        pStream->Write('-');
        pStream->Write(GuidStrs.str3);
        pStream->Write('-');
        pStream->Write(GuidStrs.str4);
        pStream->Write('-');
        pStream->Write(GuidStrs.str5);
        pStream->Write("\")");
    }

    pStream->NewLine();
    pStream->Write(pName);

    pStream->Write(";\n#endif");
    pStream->NewLine();

    return CG_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CG_ID::GenTypeInfo
//
//  Synopsis:   adds a constant variable to a type info
//
//  Arguments:  [pCCB] - CG control block
//
//  Returns:    CG_OK
//
//  History:    6-13-95   stevebl   Created
//
//  Notes:      Because of the way the CG tree is constructed, this method
//              can only be called from within a module.
//
//              CONSIDER - might want to add an assert to check this
//
//----------------------------------------------------------------------------

CG_STATUS CG_ID::GenTypeInfo(CCB *pCCB)
{
    VARDESC vdesc;
    memset(&vdesc, 0, sizeof(VARDESC));
    vdesc.memid = DISPID_UNKNOWN;

    TYPEDESC * ptdesc;
    GetChild()->GetTypeDesc(ptdesc, pCCB);
    memcpy(&vdesc.elemdescVar.tdesc, ptdesc, sizeof(TYPEDESC));
    vdesc.varkind = VAR_CONST;

    WALK_CTXT ctxt(GetType());
    vdesc.elemdescVar.idldesc.wIDLFlags = GetIDLFlags(&ctxt);
    vdesc.wVarFlags = (unsigned short)GetVarFlags(&ctxt);

    VARIANT var;
    memset(&var, 0, sizeof(VARIANT));
    vdesc.lpvarValue = &var;

    node_id * pId = (node_id *) GetType();

    GetValueFromExpression(var, vdesc.elemdescVar.tdesc, pId->GetExpr(), pCCB->GetLcid(), GetSymName());

    ICreateTypeInfo * pCTI = pCCB->GetCreateTypeInfo();

    char * szName = GetSymName();
    unsigned uVar = pCCB->GetVarNum();
    HRESULT hr = pCTI->AddVarDesc(uVar, &vdesc);
    if (FAILED(hr))
    {
        ReportTLGenError(  "AddVarDesc failed", szName, hr);
    }
    DeleteTypedescChildren(ptdesc);
    delete ptdesc;

    ATTRLIST            myAttrs;
    node_base_attr  *   pCurAttr;
    ATTR_T              curAttrID;
    GUID                guid;

    ((named_node*)GetType())->GetAttributeList( myAttrs );

    pCurAttr    =   myAttrs.GetFirst();
    while ( pCurAttr )
        {
        curAttrID = pCurAttr->GetAttrID();

        if (curAttrID == ATTR_CUSTOM)
            {
            ZeroMemory( &var,
                        sizeof(VARIANT));
            ConvertToVariant(   var,
                                ((node_custom_attr*)pCurAttr)->GetVal(), 
                                pCCB->GetLcid());
            ((node_custom_attr*)pCurAttr)->GetGuid()->GetGuid(guid);
            ((ICreateTypeInfo2 *)pCTI)->SetVarCustData( uVar,
                                                        guid,
                                                        &var);
            }
        pCurAttr = pCurAttr->GetNext();
        }

    if (szName)
    {
        A2O(wszScratch, szName, MAX_PATH);
        hr = pCTI->SetVarName(uVar, wszScratch);
        if (FAILED(hr))
        {
            ReportTLGenError(  "SetVarName failed", szName, hr);
        }
    }

    node_text_attr * pTA;
    if (pTA = (node_text_attr *)ctxt.GetAttribute(ATTR_HELPSTRING))
    {
        char * szHelpString = pTA->GetText();
        A2O(wszScratch, szHelpString, MAX_PATH);
        hr = pCTI->SetVarDocString(uVar,wszScratch);
        if ( FAILED( hr ) )
            {
            ReportTLGenError( szErrHelpString, szName, hr);
            }
    }

    node_constant_attr *pCA;
    if (pCA = (node_constant_attr *) ctxt.GetAttribute(ATTR_HELPCONTEXT))
    {
        DWORD hc = (DWORD) pCA->GetExpr()->GetValue();
        hr = pCTI->SetVarHelpContext(uVar, hc);
        if ( FAILED( hr ) )
            {
            ReportTLGenError( szErrHelpContext, szName, hr);
            }
    }

    if (pCA = (node_constant_attr *) ctxt.GetAttribute(ATTR_HELPSTRINGCONTEXT))
    {
            DWORD hc = (DWORD) pCA->GetExpr()->GetValue();
        ((ICreateTypeInfo2 *)pCTI)->SetVarHelpStringContext( uVar, hc );
    }

    // bump the variable number
    pCCB->SetVarNum(unsigned short(uVar + 1));

    return CG_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     CG_ENUM::GenTypeInfo
//
//  Synopsis:   generates a type info for an ENUM
//
//  Arguments:  [pCCB] - CG control block
//
//  Returns:    CG_OK
//
//  History:    6-13-95   stevebl   Commented
//
//----------------------------------------------------------------------------

CG_STATUS CG_ENUM::GenTypeInfo(CCB *pCCB)
{
    // check to see if we've already been created
    if (NULL != _pCTI)
    {
        pCCB->SetCreateTypeInfo((ICreateTypeInfo *) _pCTI);
        return CG_OK;
    }

    char * szName = ((node_su_base *)GetBasicType())->GetTypeInfoName();
    ICreateTypeLib * pCTL = pCCB->GetCreateTypeLib();
    ICreateTypeInfo * pCTI;

    A2O(wszScratch, szName, MAX_PATH);

    HRESULT hr = pCTL->CreateTypeInfo(wszScratch, TKIND_ENUM, &pCTI);
    if SUCCEEDED(hr)
    {
        _pCTI = pCTI;
        gpobjholder->Add(pCTI, szName);
        pCCB->SetCreateTypeInfo(pCTI);
        node_enum * pEnum = (node_enum *) GetType()->GetBasicType();

        // walk members, adding them to the type info
        MEM_ITER MemIter( pEnum );
        node_label * pLabel;

        unsigned uIndex = 0;

        VARDESC vdElem;
        memset(&vdElem, 0, sizeof(VARDESC));
        vdElem.memid = DISPID_UNKNOWN;
        vdElem.varkind = VAR_CONST;

        VARIANT var;
        memset(&var, 0, sizeof(VARIANT));
/*
 * It appears that MKTYPLIB always uses the VT_INT/VT_I4 combination
 * regardless of the target platform.  For now I'll duplicate this
 * behavior but the commented out code below is what I
 * would have expected to be correct.
        unsigned uSize = pEnum->GetSize(0, 0);
        switch (uSize)
        {
        case 2:
            vdElem.elemdescVar.tdesc.vt = VT_I2;
            var.vt = VT_I2;
            break;
        case 4:
            vdElem.elemdescVar.tdesc.vt = VT_I4;
            var.vt = VT_I4;
            break;
        default:
            vdElem.elemdescVar.tdesc.vt = VT_I2;
            var.vt = VT_I2;
            break;
        }
 */
        vdElem.elemdescVar.tdesc.vt = VT_INT;
        var.vt = VT_I4;

        vdElem.lpvarValue = &var;

        while ( pLabel = (node_label *) MemIter.GetNext() )
        {
            WALK_CTXT ctxt(pLabel);
            vdElem.wVarFlags = (unsigned short)GetVarFlags(&ctxt);
            vdElem.elemdescVar.idldesc.wIDLFlags = GetIDLFlags(&ctxt);

/* see previous comment
            switch (uSize)
            {
            case 2:
                vdElem.lpvarValue->iVal = (short) pLabel->GetValue();
                break;
            case 4:
 */
                vdElem.lpvarValue->lVal = (long) pLabel->GetValue();
 /*
                break;
            default:
                vdElem.lpvarValue->iVal = (short) pLabel->GetValue();
                break;
            }
 */
            hr = pCTI->AddVarDesc(uIndex, &vdElem);
            if (FAILED(hr))
            {
                ReportTLGenError( "AddVarDesc failed", szName, hr);
            }

            szName = pLabel->GetSymName();

            A2O(wszScratch, szName, MAX_PATH);

            hr = pCTI->SetVarName(uIndex, wszScratch);
            if ( FAILED( hr ) )
                {
                ReportTLGenError( "Could not set name", szName, hr);
                }

            node_text_attr * pTA;
            if (pTA = (node_text_attr *)ctxt.GetAttribute(ATTR_HELPSTRING))
            {
                char * szHelpString = pTA->GetText();
                A2O(wszScratch, szHelpString, MAX_PATH);
                hr = pCTI->SetVarDocString(uIndex, wszScratch);
                if ( FAILED( hr ) )
                    {
                    ReportTLGenError( szErrHelpString, szName, hr);
                    }
            }

            node_constant_attr *pCA;
            if (pCA = (node_constant_attr *) ctxt.GetAttribute(ATTR_HELPCONTEXT))
            {
                DWORD hc = (DWORD) pCA->GetExpr()->GetValue();
                hr = pCTI->SetVarHelpContext(uIndex, hc);
                if ( FAILED( hr ) )
                    {
                    ReportTLGenError( szErrHelpContext, szName, hr);
                    }
            }

            if (pCA = (node_constant_attr *) ctxt.GetAttribute(ATTR_HELPSTRINGCONTEXT))
            {
                DWORD hc = (DWORD) pCA->GetExpr()->GetValue();
                ((ICreateTypeInfo2 *)pCTI)->SetVarHelpStringContext( uIndex, hc );
            }
            ATTRLIST            myAttrs;
            node_base_attr  *   pCurAttr;
            VARIANT             variant;
            ATTR_T              curAttrID;
            GUID                guid;

            ((named_node*)pLabel)->GetAttributeList( myAttrs );

            pCurAttr    =   myAttrs.GetFirst();
            while ( pCurAttr )
                {
                curAttrID = pCurAttr->GetAttrID();

                if (curAttrID == ATTR_CUSTOM)
                    {
                    ZeroMemory( &variant,
                                sizeof(variant));
                    ConvertToVariant(   variant,
                                        ((node_custom_attr*)pCurAttr)->GetVal(), 
                                        pCCB->GetLcid());
                    ((node_custom_attr*)pCurAttr)->GetGuid()->GetGuid(guid);
                    ((ICreateTypeInfo2 *)pCTI)->SetVarCustData( uIndex,
                                                                guid,
                                                                &variant);
                    }
                pCurAttr = pCurAttr->GetNext();
                }
            uIndex++;
        };

        // Set all common type attributes
        WALK_CTXT ctxt(GetType());
        hr = pCTI->SetTypeFlags(GetTypeFlags(&ctxt));
        if ( FAILED( hr ) )
            {
            ReportTLGenError( szErrTypeFlags, szName, hr);
            }

        ATTRLIST            myAttrs;
        node_base_attr  *   pCurAttr;
        VARIANT             variant;
        ATTR_T              curAttrID;
        GUID                guid;

        ((named_node*)GetType())->GetAttributeList( myAttrs );
        pCurAttr    =   myAttrs.GetFirst();
        while ( pCurAttr )
            {
            curAttrID = pCurAttr->GetAttrID();

            if (curAttrID == ATTR_CUSTOM)
                {
                ZeroMemory( &variant,
                            sizeof(variant));
                ConvertToVariant(   variant,
                                    ((node_custom_attr*)pCurAttr)->GetVal(), 
                                    pCCB->GetLcid());
                ((node_custom_attr*)pCurAttr)->GetGuid()->GetGuid(guid);
                ((ICreateTypeInfo2 *)pCTI)->SetCustData(guid,
                                                        &variant);
                }
            pCurAttr = pCurAttr->GetNext();
            }

        node_guid * pGuid = (node_guid *)ctxt.ExtractAttribute(ATTR_GUID);

        if (pGuid)
        {
            GUID guid;
            pGuid->GetGuid(guid);
            hr = pCTI->SetGuid(guid);
            if ( FAILED( hr ) && hr != 0x800288C6L )
                {
                // do not report duplicate UUID errors. Duplicate UUIDs
                // are caught by the front end. They only way they can
                // occur here is because tries to set the UUID on both
                // the typedef and the enum. This is benign.
                ReportTLGenWarning( szErrUUID, pEnum->GetSymName(), hr);
                }
        }

        node_text_attr * pTA;
        if (pTA = (node_text_attr *)ctxt.GetAttribute(ATTR_HELPSTRING))
        {
            char * szHelpString = pTA->GetText();
            A2O(wszScratch, szHelpString, MAX_PATH);
            hr = pCTI->SetDocString(wszScratch);
            if ( FAILED( hr ) )
                {
                ReportTLGenError( szErrHelpString, szName, hr);
                }
        }

        node_constant_attr *pCA;
        if (pCA = (node_constant_attr *) ctxt.GetAttribute(ATTR_HELPCONTEXT))
        {
            DWORD hc = (DWORD) pCA->GetExpr()->GetValue();
            hr = pCTI->SetHelpContext(hc);
            if ( FAILED( hr ) )
                {
                ReportTLGenError( szErrHelpContext, szName, hr);
                }
        }

        if (pCA = (node_constant_attr *) ctxt.GetAttribute(ATTR_HELPSTRINGCONTEXT))
        {
            DWORD hc = (DWORD) pCA->GetExpr()->GetValue();
            ((ICreateTypeInfo2 *)pCTI)->SetHelpStringContext(hc);
        }

        unsigned short Maj;
        unsigned short Min;
        node_version * pVer = (node_version *) ctxt.GetAttribute(ATTR_VERSION);
        if (pVer)
            pVer->GetVersion(&Maj, &Min);
        else
        {
            Maj = Min = 0;
        }
        hr = pCTI->SetVersion(Maj, Min);
        if ( FAILED( hr ) )
            {
            ReportTLGenError( szErrVersion, szName, hr);
            }

        hr = pCTI->SetAlignment( GetMemoryAlignment() );
        hr = pCTI->LayOut();
        if FAILED(hr)
        {
            ReportTLGenError( "LayOut failed on enum", szName, hr);
        }
        LayedOut();
    }
    else
    {
        // It's possible that this type has already been created.
        if (NULL == (pCTI = (ICreateTypeInfo *)gpobjholder->Find(szName)))
            ReportTLGenError( "CreateTypeInfo failed", szName, hr);
        pCCB->SetCreateTypeInfo(pCTI);
    }
    return CG_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CG_STRUCT::GenTypeInfo
//
//  Synopsis:   generates a type info for a struct
//
//  Arguments:  [pCCB] - CG control block
//
//  Returns:    CG_OK
//              CG_NOT_LAYED_OUT
//              CG_REF_NOT_LAYED_OUT
//
//  History:    6-13-95   stevebl   Commented
//
//  Notes:      see note at beginning of this file about CG_STATUS return
//              codes and cyclic dependencies
//
//----------------------------------------------------------------------------

CG_STATUS CG_STRUCT::GenTypeInfo(CCB *pCCB)
{
    HRESULT hr;

    // check to see if we've already been created
    if (NULL != _pCTI)
    {
        // we have
        pCCB->SetCreateTypeInfo((ICreateTypeInfo *) _pCTI);
        if (!IsReadyForLayOut())
        {
            return CG_NOT_LAYED_OUT;
        }
        if (!AreDepsLayedOut())
        {
            // avoid infinite loops
            DepsLayedOut();

            // give dependents a chance to be layed out
            CG_ITERATOR I;
            CG_CLASS *pCG;
            GetMembers(I);
            I.Init();
            CG_STATUS cgs = CG_OK;
            while(ITERATOR_GETNEXT(I, pCG))
            {
                switch(pCG->GenTypeInfo(pCCB))
                {
                case CG_NOT_LAYED_OUT:
                    cgs = CG_NOT_LAYED_OUT;
                    break;
                case CG_REF_NOT_LAYED_OUT:
                    if (CG_OK == cgs)
                        cgs = CG_REF_NOT_LAYED_OUT;
                    break;
                default:
                    break;
                }
            }
            if (cgs != CG_OK)
            {
                ClearDepsLayedOut();
                return cgs;
            }
        }

        // SetAlignment()
        hr = ((ICreateTypeInfo *)_pCTI)->SetAlignment( GetMemoryAlignment() );
        hr = ((ICreateTypeInfo *)_pCTI)->LayOut();
        LayedOut();
        return CG_OK;
    }
    BOOL fDependentsLayedOut = TRUE;
    BOOL fICanLayOut = TRUE;

    char * szName = ((node_su_base *)GetBasicType())->GetTypeInfoName();
    // HACK HACK HACK: special case to keep the base types 
    //                 CY and DECIMAL from getting entered into the library
    if (0 == _stricmp(szName, "CY") || 0 == _stricmp(szName, "DECIMAL"))
        return CG_OK;
    ICreateTypeLib * pCTL = pCCB->GetCreateTypeLib();
    ICreateTypeInfo * pCTI;

    A2O(wszScratch, szName, MAX_PATH);
    hr = pCTL->CreateTypeInfo(wszScratch, TKIND_RECORD, &pCTI);
    if SUCCEEDED(hr)
    {
        // remember the ICreateTypeInfo pointer
        _pCTI = pCTI;
        gpobjholder->Add(pCTI);
        pCCB->SetCreateTypeInfo(pCTI);

        CG_ITERATOR I;
        CG_CLASS * pCG;

        GetMembers(I);
        I.Init();

        unsigned uRememberPreviousVarNum = pCCB->GetVarNum();
        pCCB->SetVarNum(0);

        // walk members, adding them to the type info
        while (ITERATOR_GETNEXT(I, pCG))
        {
            CG_STATUS cgs = pCG->GenTypeInfo(pCCB);
            switch (cgs)
            {
            case CG_NOT_LAYED_OUT:
                fICanLayOut = FALSE;
                // fall through
            case CG_REF_NOT_LAYED_OUT:
                fDependentsLayedOut = FALSE;
                // fall through
            default:
                break;
            }
        }

        pCCB->SetVarNum((unsigned short)uRememberPreviousVarNum);

        // Set all common type attributes
        WALK_CTXT ctxt(GetType());
        hr = pCTI->SetTypeFlags(GetTypeFlags(&ctxt));
        if ( FAILED( hr ) )
            {
            ReportTLGenError( szErrTypeFlags, szName, hr);
            }

        ATTRLIST            myAttrs;
        node_base_attr  *   pCurAttr;
        ATTR_T              curAttrID;
        VARIANT             var;
        GUID                guid;

        ((named_node*)GetType())->GetAttributeList( myAttrs );

        pCurAttr    =   myAttrs.GetFirst();
        while ( pCurAttr )
            {
            curAttrID = pCurAttr->GetAttrID();

            if (curAttrID == ATTR_CUSTOM)
                {
                ZeroMemory( &var,
                            sizeof(VARIANT));
                ConvertToVariant(   var,
                                    ((node_custom_attr*)pCurAttr)->GetVal(), 
                                    pCCB->GetLcid());
                ((node_custom_attr*)pCurAttr)->GetGuid()->GetGuid(guid);
                ((ICreateTypeInfo2 *)pCTI)->SetCustData(guid,
                                                        &var);
                }
            pCurAttr = pCurAttr->GetNext();
            }

        node_guid * pGuid = (node_guid *)ctxt.ExtractAttribute(ATTR_GUID);

        if (pGuid)
        {
            GUID guid;
            pGuid->GetGuid(guid);
            hr = pCTI->SetGuid(guid);
            if ( FAILED( hr ) )
                {
                ReportTLGenWarning( szErrUUID, szName, hr);
                }
        }

        node_text_attr * pTA;
        if (pTA = (node_text_attr *)ctxt.GetAttribute(ATTR_HELPSTRING))
        {
            char * szHelpString = pTA->GetText();
            A2O(wszScratch, szHelpString, MAX_PATH);
            hr = pCTI->SetDocString(wszScratch);
            if ( FAILED( hr ) )
                {
                ReportTLGenError( szErrHelpString, szName, hr);
                }
        }

        node_constant_attr *pCA;
        if (pCA = (node_constant_attr *) ctxt.GetAttribute(ATTR_HELPCONTEXT))
        {
            DWORD hc = (DWORD) pCA->GetExpr()->GetValue();
            hr = pCTI->SetHelpContext(hc);
            if ( FAILED( hr ) )
                {
                ReportTLGenError( szErrHelpContext, szName, hr);
                }
        }

        if (pCA = (node_constant_attr *) ctxt.GetAttribute(ATTR_HELPSTRINGCONTEXT))
        {
            DWORD hc = (DWORD) pCA->GetExpr()->GetValue();
            ((ICreateTypeInfo2 *)pCTI)->SetHelpStringContext(hc);
        }

        unsigned short Maj;
        unsigned short Min;
        node_version * pVer = (node_version *) ctxt.GetAttribute(ATTR_VERSION);
        if (pVer)
            pVer->GetVersion(&Maj, &Min);
        else
        {
            Maj = Min = 0;
        }
        hr = pCTI->SetVersion(Maj, Min);
        if ( FAILED( hr ) )
            {
            ReportTLGenError( szErrVersion, szName, hr);
            }

        ReadyForLayOut();
        if (fICanLayOut)
        {
            // SetAlignment()
            hr = pCTI->SetAlignment( GetMemoryAlignment() );
            hr = pCTI->LayOut();
            if FAILED(hr)
            {
                ReportTLGenError( "LayOut failed on struct",szName, hr);
            }
            LayedOut();
            if (!fDependentsLayedOut)
            {
                // The only way I can get here is if my dependents were either blocked by me
                // or blocked by one of my ancestors.
                // Now that I've been layed out, they may no longer be blocked.
                BOOL fSucceeded = TRUE;
                I.Init();
                while (ITERATOR_GETNEXT(I, pCG))
                {
                    CG_STATUS cgs = pCG->GenTypeInfo(pCCB);
                    if (CG_OK != cgs)
                        fSucceeded = FALSE;
                }
                if (fSucceeded)
                {
                    DepsLayedOut();
                    return CG_OK;
                }
                return CG_REF_NOT_LAYED_OUT;
            }
            DepsLayedOut();
            return CG_OK;
        }
    }
    else
    {
        ReportTLGenError( "CreateTypeInfo failed", szName, hr);
    }
    return CG_NOT_LAYED_OUT;
}

//+---------------------------------------------------------------------------
//
//  Member:     CG_UNION::GenTypeInfo
//
//  Synopsis:   generates a type info for a union
//
//  Arguments:  [pCCB] - CG control block
//
//  Returns:    CG_OK
//              CG_NOT_LAYED_OUT
//              CG_REF_NOT_LAYED_OUT
//
//  History:    6-13-95   stevebl   Commented
//
//  Notes:      see note at beginning of this file about CG_STATUS return
//              codes and cyclic dependencies
//
//----------------------------------------------------------------------------

CG_STATUS CG_UNION::GenTypeInfo(CCB *pCCB)
{
    HRESULT hr;

    // check to see if we've already been created
    if (NULL != _pCTI)
    {
        // we have
        pCCB->SetCreateTypeInfo((ICreateTypeInfo *) _pCTI);
        if (!IsReadyForLayOut())
        {
            return CG_NOT_LAYED_OUT;
        }
        if (!AreDepsLayedOut())
        {
            // avoid infinite loops
            DepsLayedOut();

            // give dependents a chance to be layed out
            CG_ITERATOR I;
            CG_CLASS *pCG;
            GetMembers(I);
            I.Init();
            CG_STATUS cgs = CG_OK;
            while(ITERATOR_GETNEXT(I, pCG))
            {
                switch(pCG->GenTypeInfo(pCCB))
                {
                case CG_NOT_LAYED_OUT:
                    cgs = CG_NOT_LAYED_OUT;
                    break;
                case CG_REF_NOT_LAYED_OUT:
                    if (CG_OK == cgs)
                        cgs = CG_REF_NOT_LAYED_OUT;
                    break;
                default:
                    break;
                }
            }
            if (cgs != CG_OK)
            {
                ClearDepsLayedOut();
                return cgs;
            }
        }

        hr = ((ICreateTypeInfo *)_pCTI)->SetAlignment( GetMemoryAlignment() );
        hr = ((ICreateTypeInfo *)_pCTI)->LayOut();
        if FAILED(hr)
        {
            char * szName = ((node_su_base *)GetBasicType())->GetTypeInfoName();
            if ( !szName )
                szName = GetSymName();
            ReportTLGenError( "LayOut failed on union", szName, hr);
        }
        LayedOut();
        return CG_OK;
    }
    BOOL fDependentsLayedOut = TRUE;
    BOOL fICanLayOut = TRUE;
    char * szName = ((node_su_base *)GetBasicType())->GetTypeInfoName();
    ICreateTypeLib * pCTL = pCCB->GetCreateTypeLib();
    ICreateTypeInfo * pCTI;

    A2O(wszScratch, szName, MAX_PATH);
    hr = pCTL->CreateTypeInfo(wszScratch, TKIND_UNION, &pCTI);
    if SUCCEEDED(hr)
    {
        // remember the ICreateTypeInfo pointer
        _pCTI = pCTI;
        gpobjholder->Add(pCTI);
        pCCB->SetCreateTypeInfo(pCTI);

        CG_ITERATOR I;
        CG_CLASS * pCG;

        GetMembers(I);
        I.Init();

        unsigned uRememberPreviousVarNum = pCCB->GetVarNum();
        pCCB->SetVarNum(0);

        // walk members, adding them to the type info
        while (ITERATOR_GETNEXT(I, pCG))
        {
            CG_STATUS cgs = pCG->GenTypeInfo(pCCB);
            switch (cgs)
            {
            case CG_NOT_LAYED_OUT:
                fICanLayOut = FALSE;
                // fall through
            case CG_REF_NOT_LAYED_OUT:
                fDependentsLayedOut = FALSE;
                // fall through
            default:
                break;
            }
        }

        pCCB->SetVarNum((unsigned short)uRememberPreviousVarNum);

        // Set all common type attributes
        WALK_CTXT ctxt(GetType());
        hr = pCTI->SetTypeFlags(GetTypeFlags(&ctxt));
        if ( FAILED( hr ) )
            {
            ReportTLGenError( szErrTypeFlags, szName, hr);
            }

        ATTRLIST            myAttrs;
        node_base_attr  *   pCurAttr;
        ATTR_T              curAttrID;
        VARIANT             var;
        GUID                guid;

        ((named_node*)GetType())->GetAttributeList( myAttrs );

        pCurAttr    =   myAttrs.GetFirst();
        while ( pCurAttr )
            {
            curAttrID = pCurAttr->GetAttrID();

            if (curAttrID == ATTR_CUSTOM)
                {
                ZeroMemory( &var,
                            sizeof(VARIANT));
                ConvertToVariant(   var,
                                    ((node_custom_attr*)pCurAttr)->GetVal(), 
                                    pCCB->GetLcid());
                ((node_custom_attr*)pCurAttr)->GetGuid()->GetGuid(guid);
                ((ICreateTypeInfo2 *)pCTI)->SetCustData(guid,
                                                        &var);
                }
            pCurAttr = pCurAttr->GetNext();
            }

        node_guid * pGuid = (node_guid *)ctxt.ExtractAttribute(ATTR_GUID);

        if (pGuid)
        {
            GUID guid;
            pGuid->GetGuid(guid);
            hr = pCTI->SetGuid(guid);
            if ( FAILED( hr ) )
                {
                ReportTLGenWarning( szErrUUID, szName, hr);
                }
        }

        node_text_attr * pTA;
        if (pTA = (node_text_attr *)ctxt.GetAttribute(ATTR_HELPSTRING))
        {
            char * szHelpString = pTA->GetText();
            A2O(wszScratch, szHelpString, MAX_PATH);
            hr = pCTI->SetDocString(wszScratch);
            if ( FAILED( hr ) )
                {
                ReportTLGenError( szErrHelpString, szName, hr);
                }
        }

        node_constant_attr *pCA;
        if (pCA = (node_constant_attr *) ctxt.GetAttribute(ATTR_HELPCONTEXT))
        {
            DWORD hc = (DWORD) pCA->GetExpr()->GetValue();
            hr = pCTI->SetHelpContext(hc);
            if ( FAILED( hr ) )
                {
                ReportTLGenError( szErrHelpContext, szName, hr);
                }
        }

        if (pCA = (node_constant_attr *) ctxt.GetAttribute(ATTR_HELPSTRINGCONTEXT))
        {
            DWORD hc = (DWORD) pCA->GetExpr()->GetValue();
            ((ICreateTypeInfo2 *)pCTI)->SetHelpStringContext(hc);
        }

        unsigned short Maj;
        unsigned short Min;
        node_version * pVer = (node_version *) ctxt.GetAttribute(ATTR_VERSION);
        if (pVer)
            pVer->GetVersion(&Maj, &Min);
        else
        {
            Maj = Min = 0;
        }
        hr = pCTI->SetVersion(Maj, Min);
        if ( FAILED( hr ) )
            {
            ReportTLGenError( szErrVersion, szName, hr);
            }

        ReadyForLayOut();
        if (fICanLayOut)
        {
            hr = pCTI->SetAlignment( GetMemoryAlignment() );
            hr = pCTI->LayOut();
            if FAILED(hr)
            {
                ReportTLGenError( "LayOut failed on union", szName, hr);
            }
            LayedOut();
            if (!fDependentsLayedOut)
            {
                // The only way I can get here is if my dependents were either blocked by me
                // or blocked by one of my ancestors.
                // Now that I've been layed out, they may no longer be blocked.
                BOOL fSucceeded = TRUE;
                I.Init();
                while (ITERATOR_GETNEXT(I, pCG))
                {
                    CG_STATUS cgs = pCG->GenTypeInfo(pCCB);
                    if (CG_OK != cgs)
                        fSucceeded = FALSE;
                }
                if (fSucceeded)
                {
                    DepsLayedOut();
                    return CG_OK;
                }
                return CG_REF_NOT_LAYED_OUT;
            }
            DepsLayedOut();
            return CG_OK;
        }
    }
    else
    {
        ReportTLGenError( "CreateTypeInfo failed", szName, hr);
    }
    return CG_NOT_LAYED_OUT;
}

//+---------------------------------------------------------------------------
//
//  Member:     CG_PROC::GenTypeInfo
//
//  Synopsis:   generates a type info for a procedure
//
//  Arguments:  [pCCB] - CG control block
//
//  Returns:    CG_OK
//
//  History:    6-13-95   stevebl   Commented
//
//----------------------------------------------------------------------------

CG_STATUS CG_PROC::GenTypeInfo(CCB *pCCB)
{
    OLECHAR ** rgwsz = NULL;
    FUNCDESC fdesc;
    memset(&fdesc, 0, sizeof(FUNCDESC));
    fdesc.memid = DISPID_UNKNOWN;
    CG_RETURN * pRet = GetReturnType();
    TYPEDESC * ptdesc = NULL;
    CG_CLASS * pComplexReturnType = NULL;

    // 
    // If the function has a complex return type, it get's transformed such
    // that the return type is represented as an extra parameter which is a
    // simple ref pointer to the type.  The actual return type is void.  
    // Oleaut doesn't like this however so mangle things around.
    //

    if ( HasComplexReturnType() )
        {
        CG_CLASS *pPrev = NULL;
        CG_CLASS *pCur  = GetChild();

        // Find the last param

        while ( NULL != pCur->GetSibling() )
            {
            pPrev = pCur;
            pCur = pCur->GetSibling();
            }

        MIDL_ASSERT( NULL == pRet );
        pRet = (CG_RETURN *) pCur;
        
        // Make the return type the actual type, not a pointer to the type
        pComplexReturnType = pRet->GetChild();
        pRet->SetChild( pComplexReturnType->GetChild() );

        SetReturnType( pRet );

        // Remove the extra "return type" param

        if ( NULL == pPrev )
            SetChild( NULL );
        else
            pPrev->SetSibling( NULL );
        }

    if (pRet)
    {
        pRet->GetTypeDesc(ptdesc, pCCB);
        if (!ptdesc)
        {
            ReportTLGenError( "return type has no type", GetSymName(), 0);
        }
        memcpy(&fdesc.elemdescFunc.tdesc, ptdesc, sizeof(TYPEDESC));
    }
    else
    {
        // no return type specified
        // CONSIDER - emit warning?
        fdesc.elemdescFunc.tdesc.vt = VT_VOID;
    }

    node_proc * pProc = (node_proc *)GetType();
    WALK_CTXT ctxt(pProc);
    fdesc.elemdescFunc.idldesc.wIDLFlags = GetIDLFlags(&ctxt);
    BOOL fPropGet, fPropPut, fPropPutRef, fVararg;
    fdesc.wFuncFlags = (unsigned short)GetFuncFlags(&ctxt, &fPropGet, &fPropPut, &fPropPutRef, &fVararg);

    ICreateTypeInfo * pCTI = pCCB->GetCreateTypeInfo();

    CG_ITERATOR I;
    CG_PARAM * pCG;
    GetMembers(I);
    int cParams = I.GetCount();
    fdesc.cParams = (unsigned short)cParams;
    fdesc.lprgelemdescParam = new ELEMDESC [fdesc.cParams];
    memset(fdesc.lprgelemdescParam, 0, sizeof(ELEMDESC) * fdesc.cParams);
    rgwsz = new WCHAR * [fdesc.cParams + 1];
    memset(rgwsz, 0, sizeof (WCHAR *) * (fdesc.cParams + 1));

    I.Init();

    int nParam = 0;

    while (ITERATOR_GETNEXT(I, pCG))
    {
        rgwsz[nParam + 1] = TranscribeA2O( pCG->GetSymName() );

        TYPEDESC * ptdesc;
        pCG->GetTypeDesc(ptdesc, pCCB);
        memcpy(&fdesc.lprgelemdescParam[nParam].tdesc, ptdesc, sizeof (TYPEDESC));
        delete ptdesc;

        node_constant_attr * pCA;
        WALK_CTXT ctxt(pCG->GetType());
        fdesc.lprgelemdescParam[nParam].idldesc.wIDLFlags = GetIDLFlags(&ctxt);

        if (pCG->IsOptional())
        {
            fdesc.cParamsOpt++;
            fdesc.lprgelemdescParam[nParam].paramdesc.wParamFlags |= PARAMFLAG_FOPT;
            if (pCA = (node_constant_attr *)ctxt.GetAttribute(ATTR_DEFAULTVALUE))
            {
                fdesc.cParamsOpt = 0;
                fdesc.lprgelemdescParam[nParam].paramdesc.wParamFlags |= PARAMFLAG_FHASDEFAULT;
                fdesc.lprgelemdescParam[nParam].paramdesc.pparamdescex = new PARAMDESCEX;
                fdesc.lprgelemdescParam[nParam].paramdesc.pparamdescex->cBytes = sizeof(PARAMDESCEX);
                TYPEDESC tdesc = fdesc.lprgelemdescParam[nParam].tdesc;
                if (tdesc.vt == VT_PTR && (fdesc.lprgelemdescParam[nParam].idldesc.wIDLFlags & IDLFLAG_FOUT) != 0)
                {
                    // handle OUT parameters correctly
                    tdesc = *tdesc.lptdesc;
                }
                GetValueFromExpression(
                fdesc.lprgelemdescParam[nParam].paramdesc.pparamdescex->varDefaultValue,
                tdesc,
                pCA->GetExpr(),
                pCCB->GetLcid(),
                GetSymName());
            }
            else
            {
                if (!IsVariantBasedType(fdesc.lprgelemdescParam[nParam].tdesc))
                {
                fdesc.cParamsOpt = 0;
                }
            }
        }
        else
        {
            if (!pCG->IsRetval())
            {
                fdesc.cParamsOpt = 0;
            }
        }

        nParam++;
        if (pCG->IsRetval())
        {
            fdesc.lprgelemdescParam[nParam - 1].paramdesc.wParamFlags |= PARAMFLAG_FRETVAL;
        }
    }

    unsigned cchPrefixString = 0;
    if (fVararg)
    {
        fdesc.cParamsOpt = -1;
    }
    if (fPropGet)
    {
        fdesc.invkind = INVOKE_PROPERTYGET;
        cchPrefixString = 4;
    }
    else if (fPropPut)
    {
        fdesc.invkind = INVOKE_PROPERTYPUT;
        cchPrefixString = 4;
    }
    else if (fPropPutRef)
    {
        fdesc.invkind = INVOKE_PROPERTYPUTREF;
        cchPrefixString = 7;
    }
    else
    {
        fdesc.invkind = INVOKE_FUNC;
    }

    switch(GetProckind())
    {
    case PROC_STATIC:
        fdesc.funckind = FUNC_STATIC;
        break;
    case PROC_PUREVIRTUAL:
    default:
        fdesc.funckind = FUNC_PUREVIRTUAL;
        break;
    }

    node_constant_attr *pCA;

    unsigned uFunc = pCCB->GetProcNum();
    if (pCCB->IsInDispinterface())
    {
        fdesc.funckind = FUNC_DISPATCH;
        fdesc.memid = 0x60000000 + uFunc;
    }

    if (pCA = (node_constant_attr *) ctxt.GetAttribute(ATTR_ID))
    {
        fdesc.memid = (ulong) pCA->GetExpr()->GetValue();
    }

    ATTR_T cc;
    pProc->GetCallingConvention(cc);
    switch(cc)
    {
    case ATTR_STDCALL:
        fdesc.callconv = CC_STDCALL;
        break;
    case ATTR_CDECL:
        fdesc.callconv = CC_CDECL;
        break;
    case ATTR_PASCAL:
        fdesc.callconv = CC_PASCAL;
        break;
    case ATTR_FASTCALL:
    case ATTR_FORTRAN:
        // There is no appropriate CC setting for FASTCALL or FORTRAN
        // CONSIDER - consider displaying a warning
    default:
        fdesc.callconv = CC_STDCALL;
        break;
    }

    char * szName = GetSymName();

    HRESULT hr = pCTI->AddFuncDesc(uFunc, &fdesc);
    if (FAILED(hr))
    {
        ReportTLGenError( "AddFuncDesc failed", szName, hr);
    }

    ATTRLIST            myAttrs;
    node_base_attr  *   pCurAttr;
    ATTR_T              curAttrID;
    VARIANT             var;
    GUID                guid;

    // process custom attributes for function
    ((named_node*)GetType())->GetAttributeList( myAttrs );
    pCurAttr    =   myAttrs.GetFirst();
    while ( pCurAttr )
        {
        curAttrID = pCurAttr->GetAttrID();

        if (curAttrID == ATTR_CUSTOM)
            {
            ZeroMemory( &var,
                        sizeof(VARIANT));
            ConvertToVariant(   var,
                                ((node_custom_attr*)pCurAttr)->GetVal(), 
                                pCCB->GetLcid());
            ((node_custom_attr*)pCurAttr)->GetGuid()->GetGuid(guid);
            ((ICreateTypeInfo2 *)pCTI)->SetFuncCustData(uFunc,
                                                        guid,
                                                        &var);
            }
        pCurAttr = pCurAttr->GetNext();
        }

    // process custom attributes for each param.
    I.Init();
    nParam = 0;
    while (ITERATOR_GETNEXT(I, pCG))
        {
        ((named_node*)(pCG->GetType()))->GetAttributeList( myAttrs );
        pCurAttr    =   myAttrs.GetFirst();

        while ( pCurAttr )
            {
            curAttrID = pCurAttr->GetAttrID();

            if (curAttrID == ATTR_CUSTOM)
                {
                ZeroMemory( &var,
                            sizeof(VARIANT));
                ConvertToVariant(   var,
                                    ((node_custom_attr*)pCurAttr)->GetVal(), 
                                    pCCB->GetLcid());
                ((node_custom_attr*)pCurAttr)->GetGuid()->GetGuid(guid);
                ((ICreateTypeInfo2 *)pCTI)->SetParamCustData(   uFunc,
                                                                nParam,
                                                                guid,
                                                                &var);
                }
            pCurAttr = pCurAttr->GetNext();
            }
        pCA = (node_constant_attr *) ctxt.GetAttribute( ATTR_HELPSTRINGCONTEXT );
        if ( pCA )
            {
            DWORD hc = (DWORD) pCA->GetExpr()->GetValue();
            ((ICreateTypeInfo2 *)pCTI)->SetVarHelpStringContext( nParam, hc );
            }
        nParam++;
        }

    if (ptdesc)
    {
        DeleteTypedescChildren(ptdesc);
        delete ptdesc;
    }

    if (szName)
    {
        rgwsz[0] = TranscribeA2O( szName + cchPrefixString );
        hr = pCTI->SetFuncAndParamNames(uFunc, rgwsz, fdesc.cParams + (fPropPut | fPropPutRef ? 0 : 1));
        if (FAILED(hr))
        {
            ReportTLGenError( "SetFuncAndParamNames failed", szName, hr);
        }
    }

    node_text_attr * pTA;
    if (pTA = (node_text_attr *)ctxt.GetAttribute(ATTR_HELPSTRING))
    {
        char * szHelpString = pTA->GetText();
        A2O(wszScratch, szHelpString, MAX_PATH);
        hr = pCTI->SetFuncDocString(uFunc, wszScratch);
        if ( FAILED( hr ) )
            {
            ReportTLGenError( szErrHelpString, szName, hr);
            }
    }

    if (pCA = (node_constant_attr *) ctxt.GetAttribute(ATTR_HELPCONTEXT))
    {
        DWORD hc = (DWORD) pCA->GetExpr()->GetValue();
        hr = pCTI->SetFuncHelpContext(uFunc, hc);
        if ( FAILED( hr ) )
            {
            ReportTLGenError( szErrHelpContext, szName, hr);
            }
    }

    if (pCA = (node_constant_attr *) ctxt.GetAttribute(ATTR_HELPSTRINGCONTEXT))
    {
        DWORD hc = (DWORD) pCA->GetExpr()->GetValue();
        ((ICreateTypeInfo2 *)pCTI)->SetFuncHelpStringContext(uFunc, hc);
    }

    node_entry_attr * pEA;
    if (pEA = (node_entry_attr *)ctxt.GetAttribute(ATTR_ENTRY))
    {
        if (!pCCB->GetDllName())
            {
            RpcError(NULL, 0, DLLNAME_REQUIRED, szName);
            exit(ERR_TYPELIB_GENERATION);
            }

        A2O(wszScratch, pCCB->GetDllName(), MAX_PATH);

        WCHAR * wszEntry;
        if (pEA->IsNumeric())
        {
            wszEntry = (WCHAR *)pEA->GetID();
            MIDL_ASSERT(HIWORD(wszEntry) == 0);
        }
        else
        {
            char * szEntry = pEA->GetSz();
            MIDL_ASSERT(HIWORD(szEntry) != 0);
            wszEntry = TranscribeA2O( szEntry );
        }
        hr = pCTI->DefineFuncAsDllEntry(uFunc, wszScratch, wszEntry);
        if ( FAILED( hr ) )
            {
            ReportTLGenError( "Could not set entry point", szName, hr);
            }
        if (HIWORD(wszEntry))
            delete [] wszEntry;
    }

    // clean up allocated stuff:
    unsigned n;
    // use cParams sinc fdesc.cParams might have been decrimented
    for (n = cParams; n--; )
    {
        DeleteTypedescChildren(&fdesc.lprgelemdescParam[n].tdesc);
    }
    delete [] fdesc.lprgelemdescParam;
    for (n = cParams + 1; n--; )
    {
        delete [] rgwsz[n];
    }
    delete [] rgwsz;

    // bump the variable number
    pCCB->SetProcNum(unsigned short(uFunc + 1));

    // Undo the complex return type changes from above

    if ( HasComplexReturnType() )
        {
        pRet->SetChild( pComplexReturnType );

        CG_CLASS *pCur = GetChild();

        if ( !pCur )
            {
            SetChild( pRet );
            }
        else
            {
            while ( NULL != pCur->GetSibling() )
                pCur = pCur->GetSibling();

            pCur->SetSibling( pRet );
            }
        }

    return CG_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CG_PARAM::GetTypeDesc
//
//  Synopsis:   generates a TYPEDESC for a parameter
//
//  Arguments:  [ptd]  - reference to a TYPEDESC pointer
//              [pCCB] - CG control block
//
//  Returns:    CG_OK
//              CG_NOT_LAYED_OUT
//              CG_REF_NOT_LAYED_OUT
//
//  History:    6-13-95   stevebl   Commented
//
//----------------------------------------------------------------------------

CG_STATUS CG_PARAM::GetTypeDesc(TYPEDESC * &ptd, CCB * pCCB)
{
    return(GetChild()->GetTypeDesc(ptd, pCCB));
}

//+---------------------------------------------------------------------------
//
//  Member:     CG_CASE::GenTypeInfo
//
//  Synopsis:   generates type information for a union member
//
//  Arguments:  [pCCB] - CG control block
//
//  Returns:    CG_OK
//              CG_NOT_LAYED_OUT
//              CG_REF_NOT_LAYED_OUT
//
//  History:    6-13-95   stevebl   Commented
//
//  Notes:      CG_CASE nodes are not interesting for type info generation
//              since case information can't be stored in type libraries.
//              However, CG_CASE nodes are often found between CG_UNION nodes
//              and CG_FIELD nodes.  This method just forwards the method
//              call on down the chain.
//
//----------------------------------------------------------------------------

CG_STATUS CG_CASE::GenTypeInfo(CCB *pCCB)
{
    return(GetChild()->GenTypeInfo(pCCB));
}

//+---------------------------------------------------------------------------
//
//  Member:     CG_FIELD::GenTypeInfo
//
//  Synopsis:   adds a Vardesc to the current type info for this union or
//              structure field
//
//  Arguments:  [pCCB] - CG control block
//
//  Returns:    CG_OK
//              CG_NOT_LAYED_OUT
//              CG_REF_NOT_LAYED_OUT
//
//  History:    6-13-95   stevebl   Commented
//
//----------------------------------------------------------------------------

CG_STATUS CG_FIELD::GenTypeInfo(CCB *pCCB)
{
    if (IsReadyForLayOut())
    {
        // this node has been visited before, just make sure its dependents
        // get the chance to lay themselves out
        CG_CLASS * pCG = GetChild();
        if (NULL == pCG)
            return CG_OK;
        TYPEDESC * ptdesc;
        CG_STATUS cgs = pCG->GetTypeDesc(ptdesc, pCCB);
        if (ptdesc)
        {
            DeleteTypedescChildren(ptdesc);
            delete ptdesc;
        }
        return cgs;
    }
    VARDESC vdesc;
    memset(&vdesc, 0, sizeof(VARDESC));
    CG_CLASS * pCG = GetChild();
    if (NULL == pCG)
        return CG_OK;
    char * szName = GetSymName();
    TYPEDESC * ptdesc;
    CG_STATUS cgs = pCG->GetTypeDesc(ptdesc, pCCB);
    if (!ptdesc)
    {
        ReportTLGenError( "field has no type", szName, 0);
    }
    memcpy(&vdesc.elemdescVar.tdesc, ptdesc, sizeof(TYPEDESC));

    WALK_CTXT ctxt(GetType());
    vdesc.elemdescVar.idldesc.wIDLFlags = GetIDLFlags(&ctxt);
    vdesc.wVarFlags = (unsigned short)GetVarFlags(&ctxt);

    ICreateTypeInfo * pCTI = pCCB->GetCreateTypeInfo();

    unsigned uVar = pCCB->GetVarNum();
    node_constant_attr *pCA;
    if (pCCB->IsInDispinterface())
    {
        if (pCA = (node_constant_attr *) ctxt.GetAttribute(ATTR_ID))
        {
            vdesc.memid = (ulong) pCA->GetExpr()->GetValue();
        }
        else
        {
            vdesc.memid = 0x30000000 + uVar;
        }
        vdesc.varkind = VAR_DISPATCH;
    }
    else
    {
        vdesc.memid = DISPID_UNKNOWN;
        vdesc.varkind = VAR_PERINSTANCE;
    }

    HRESULT hr = pCTI->AddVarDesc(uVar, &vdesc);
    if (FAILED(hr))
    {
        ReportTLGenError( "AddVarDesc failed", szName, hr);
    }
    DeleteTypedescChildren(ptdesc);
    delete ptdesc;


    ATTRLIST            myAttrs;
    node_base_attr  *   pCurAttr;
    ATTR_T              curAttrID;
    VARIANT             var;
    GUID                guid;

    ((named_node*)GetType())->GetAttributeList( myAttrs );

    pCurAttr    =   myAttrs.GetFirst();
    while ( pCurAttr )
        {
        curAttrID = pCurAttr->GetAttrID();

        if (curAttrID == ATTR_CUSTOM)
            {
            ZeroMemory( &var,
                        sizeof(VARIANT));
            ConvertToVariant(   var,
                                ((node_custom_attr*)pCurAttr)->GetVal(), 
                                pCCB->GetLcid());
            ((node_custom_attr*)pCurAttr)->GetGuid()->GetGuid(guid);
            ((ICreateTypeInfo2 *)pCTI)->SetVarCustData( uVar,
                                                        guid,
                                                        &var);
            }
        pCurAttr = pCurAttr->GetNext();
        }

    if (szName)
    {
        A2O(wszScratch, szName, MAX_PATH);
        hr = pCTI->SetVarName(uVar, wszScratch);
        if (FAILED(hr))
        {
            ReportTLGenError( "SetVarName failed", szName, hr);
        }
    }

    node_text_attr * pTA;
    if (pTA = (node_text_attr *)ctxt.GetAttribute(ATTR_HELPSTRING))
    {
        char * szHelpString = pTA->GetText();
        A2O(wszScratch, szHelpString, MAX_PATH);
        hr = pCTI->SetVarDocString(uVar,wszScratch);
        if ( FAILED( hr ) )
            {
            ReportTLGenError( szErrHelpString, szName, hr);
            }
    }

    if (pCA = (node_constant_attr *) ctxt.GetAttribute(ATTR_HELPCONTEXT))
    {
        DWORD hc = (DWORD) pCA->GetExpr()->GetValue();
        hr = pCTI->SetVarHelpContext(uVar, hc);
        if ( FAILED( hr ) )
            {
            ReportTLGenError( szErrHelpContext, szName, hr);
            }
    }

    if (pCA = (node_constant_attr *) ctxt.GetAttribute(ATTR_HELPSTRINGCONTEXT))
    {
        DWORD hc = (DWORD) pCA->GetExpr()->GetValue();
        ((ICreateTypeInfo2 *)pCTI)->SetVarHelpStringContext( uVar, hc );
    }

    // bump the variable number
    pCCB->SetVarNum(unsigned short(uVar + 1));

    ReadyForLayOut();
    return cgs;
}


//+---------------------------------------------------------------------------
//
//  Member:     CG_TYPEDEF::GenTypeInfo
//
//  Synopsis:   generates a type info for a TYPEDEF
//
//  Arguments:  [pCCB] - CG control block
//
//  Returns:    CG_OK
//              CG_NOT_LAYED_OUT
//              CG_REF_NOT_LAYED_OUT
//
//  History:    6-14-95   stevebl   Commented
//
//----------------------------------------------------------------------------

CG_STATUS CG_TYPEDEF::GenTypeInfo(CCB *pCCB)
{
    // check to see if we've already been created
    if (NULL != _pCTI)
    {
        pCCB->SetCreateTypeInfo((ICreateTypeInfo *) _pCTI);
        if (!IsLayedOut())
        {
            if (!IsReadyForLayOut())
            {
                return CG_NOT_LAYED_OUT;
            }
            // give dependents a chance to be layed out

            TYPEDESC * ptdesc;
            CG_STATUS cgs = GetChild()->GetTypeDesc(ptdesc, pCCB);
            if (ptdesc)
            {
                DeleteTypedescChildren(ptdesc);
                delete ptdesc;
            }

            if (cgs == CG_OK)
            {
                HRESULT hr;
                unsigned short MemAlignment = GetMemoryAlignment();

                if ( MemAlignment )
                    hr = ((ICreateTypeInfo *)_pCTI )->SetAlignment( MemAlignment);
                hr = ((ICreateTypeInfo *)_pCTI)->LayOut();
                if (SUCCEEDED(hr))
                {
                    LayedOut();
                    return CG_OK;
                }
            }
            return cgs;
        }
        return CG_OK;
    }
    char * szName = GetSymName();
    // Due to the nature of the MIDL compiler, it is possible that
    // certain OLE Automation base types may show up here.  The following
    // test makes sure that type info isn't created for these types.
    if ((0 == strcmp(szName, "VARIANT")) || (0 == strcmp(szName, "wireVARIANT"))
        || (0 == strcmp(szName, "DATE")) || (0 == strcmp(szName, "HRESULT"))
        || (0 == strcmp(szName, "CURRENCY")) || (0 == strcmp(szName, "CY"))
        || (0 == strcmp(szName, "DECIMAL")) 
        || (0 == strcmp(szName, "wireBSTR")))
    {
        return CG_OK;
    }
    // SPECIAL CASE: If both the typedef and it's child share the same name, then
    // we MUST NOT enter a TKIND_ALIAS for the typedef.  Otherwise we will get name
    // conflicts.
    node_skl * pBasicType = GetBasicType();
    NODE_T type = pBasicType->NodeKind();
    if (type == NODE_STRUCT || type == NODE_ENUM || type == NODE_UNION)
    {    
        char * szChildName = ((node_su_base *)pBasicType)->GetTypeInfoName();
        if (szChildName)
        {
            if ( 0 == strcmp(szName, szChildName) && !GetChild()->IsInterfacePointer() )
            {
                return GetChild()->GenTypeInfo(pCCB);
            }
        }
    }
    ICreateTypeLib * pCTL = pCCB->GetCreateTypeLib();
    ICreateTypeInfo * pCTI;

    A2O(wszScratch, szName, MAX_PATH);
    HRESULT hr = pCTL->CreateTypeInfo(wszScratch, TKIND_ALIAS, &pCTI);
    if SUCCEEDED(hr)
    {
        // remember the ICreateTypeInfo pointer
        _pCTI = pCTI;
        gpobjholder->Add(pCTI, szName);
        pCCB->SetCreateTypeInfo(pCTI);
        TYPEDESC * ptdesc;

        // Set all common type attributes
        WALK_CTXT ctxt(GetType());
        hr = pCTI->SetTypeFlags(GetTypeFlags(&ctxt));
        if ( FAILED( hr ) )
            {
            ReportTLGenError( szErrTypeFlags, szName, hr);
            }

        ATTRLIST            myAttrs;
        node_base_attr  *   pCurAttr;
        ATTR_T              curAttrID;
        VARIANT             var;
        GUID                guid;

        ((named_node*)GetType())->GetAttributeList( myAttrs );

        pCurAttr    =   myAttrs.GetFirst();
        while ( pCurAttr )
            {
            curAttrID = pCurAttr->GetAttrID();

            if (curAttrID == ATTR_CUSTOM)
                {
                ZeroMemory( &var,
                            sizeof(VARIANT));
                ConvertToVariant(   var,
                                    ((node_custom_attr*)pCurAttr)->GetVal(), 
                                    pCCB->GetLcid());
                ((node_custom_attr*)pCurAttr)->GetGuid()->GetGuid(guid);
                ((ICreateTypeInfo2 *)pCTI)->SetCustData(guid,
                                                        &var);
                }
            pCurAttr = pCurAttr->GetNext();
            }

        node_guid * pGuid = (node_guid *)ctxt.ExtractAttribute(ATTR_GUID);

        if (pGuid)
        {
            GUID guid;
            pGuid->GetGuid(guid);
            hr = pCTI->SetGuid(guid);
            if ( FAILED( hr ) )
                {
                ReportTLGenWarning( szErrUUID, szName, hr);
                }
        }

        node_text_attr * pTA;
        if (pTA = (node_text_attr *)ctxt.GetAttribute(ATTR_HELPSTRING))
        {
            char * szHelpString = pTA->GetText();
            A2O(wszScratch, szHelpString, MAX_PATH);
            hr = pCTI->SetDocString(wszScratch);
            if ( FAILED( hr ) )
                {
                ReportTLGenError( szErrHelpString, szName, hr);
                }
        }

        node_constant_attr *pCA;
        if (pCA = (node_constant_attr *) ctxt.GetAttribute(ATTR_HELPCONTEXT))
        {
            DWORD hc = (DWORD) pCA->GetExpr()->GetValue();
            hr = pCTI->SetHelpContext(hc);
            if ( FAILED( hr ) )
                {
                ReportTLGenError( szErrHelpContext, szName, hr);
                }
        }

        if (pCA = (node_constant_attr *) ctxt.GetAttribute(ATTR_HELPSTRINGCONTEXT))
        {
            DWORD hc = (DWORD) pCA->GetExpr()->GetValue();
            ((ICreateTypeInfo2 *)pCTI)->SetHelpStringContext(hc);
        }

        unsigned short Maj;
        unsigned short Min;
        node_version * pVer = (node_version *) ctxt.GetAttribute(ATTR_VERSION);
        if (pVer)
            pVer->GetVersion(&Maj, &Min);
        else
        {
            Maj = Min = 0;
        }
        hr = pCTI->SetVersion(Maj, Min);
        if ( FAILED( hr ) )
            {
            ReportTLGenError( szErrVersion, szName, hr);
            }

        CG_STATUS cgs = GetChild()->GetTypeDesc(ptdesc, pCCB);
        if (ptdesc)
        {
            hr = pCTI->SetTypeDescAlias(ptdesc);
            if FAILED(hr)
            {
                ReportTLGenError( "SetTypeDescAlias failed", szName, hr);
            }
            DeleteTypedescChildren(ptdesc);
            delete ptdesc;
        }

        ReadyForLayOut();
        if (CG_NOT_LAYED_OUT != cgs)
        {
            if ( GetMemoryAlignment() )
                hr = pCTI->SetAlignment( GetMemoryAlignment() );

            hr = pCTI->LayOut();
            if FAILED(hr)
            {
                ReportTLGenError( "LayOut failed on typedef",szName, hr);
            }
            LayedOut();
            if (CG_REF_NOT_LAYED_OUT == cgs)
            {
                // The only way I can get here is if my dependents were either blocked by me
                // or blocked by one of my ancestors.
                // Now that I've been layed out, they may no longer be blocked.
                TYPEDESC * ptdesc;
                cgs = GetChild()->GetTypeDesc(ptdesc, pCCB);
                if (ptdesc)
                {
                    DeleteTypedescChildren(ptdesc);
                    delete ptdesc;
                }
                return (CG_OK == cgs ? CG_OK : CG_REF_NOT_LAYED_OUT);
            }
        }
        return cgs;
    }
    else
    {
        // It's possible that this type has already been created.
        if (NULL == (pCTI = (ICreateTypeInfo *)gpobjholder->Find(szName)))
            ReportTLGenError( "CreateTypeInfo failed", szName, hr);
        pCCB->SetCreateTypeInfo(pCTI);
    }
    return CG_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CG_FIXED_ARRAY::GetTypeDesc
//
//  Synopsis:   generates a TYPEDESC for an array
//
//  Arguments:  [ptd]  - reference to a TYPEDESC pointer
//              [pCCB] - CG control block
//
//  Returns:    CG_OK
//              CG_NOT_LAYED_OUT
//              CG_REF_NOT_LAYED_OUT
//
//  History:    6-14-95   stevebl   Commented
//
//----------------------------------------------------------------------------

CG_STATUS CG_FIXED_ARRAY::GetTypeDesc(TYPEDESC * &ptd, CCB * pCCB)
{
    ptd = new TYPEDESC;
    CG_CLASS * pElement = this;
    unsigned short cDims = GetDimensions();

    MIDL_ASSERT(cDims > 0);

    ptd->vt = VT_CARRAY;
    ptd->lpadesc = (ARRAYDESC *) new BYTE [ sizeof(ARRAYDESC) +
                                            (cDims - 1) * sizeof (SAFEARRAYBOUND)
                                          ];
    ptd->lpadesc->cDims = cDims;
    int i;
    for (i = 0; i<cDims; i++)
    {
        ptd->lpadesc->rgbounds[i].lLbound = 0;
        ptd->lpadesc->rgbounds[i].cElements = ((CG_FIXED_ARRAY *)pElement)->GetNumOfElements();
        pElement = pElement->GetChild();
    }

    TYPEDESC * ptdElem;
    CG_STATUS cgs = pElement->GetTypeDesc(ptdElem, pCCB);
    memcpy(&ptd->lpadesc->tdescElem, ptdElem, sizeof(TYPEDESC));
    delete ptdElem;

    return cgs;
}

//+---------------------------------------------------------------------------
//
//  Member:     CG_CONFORMANT_ARRAY::GetTypeDesc
//
//  Synopsis:   generates a TYPEDESC for a conformant array
//
//  Arguments:  [ptd]  - reference to a TYPEDESC pointer
//              [pCCB] - CG control block
//
//  Returns:    CG_OK
//              CG_REF_NOT_LAYED_OUT
//
//  History:    6-14-95   stevebl   Commented
//
//  Notes:      Conformant arrays are not directly representable in type
//              info, so they get converted to pointers.
//
//----------------------------------------------------------------------------

CG_STATUS CG_CONFORMANT_ARRAY::GetTypeDesc(TYPEDESC * &ptd, CCB * pCCB)
{
    ptd = new TYPEDESC;
    MIDL_ASSERT(1 == GetDimensions());
    ptd->vt = VT_PTR;
    CG_CLASS * pElement = GetChild();
    CG_STATUS cgs = pElement->GetTypeDesc(ptd->lptdesc, pCCB);
    return (CG_OK == cgs ? CG_OK : CG_REF_NOT_LAYED_OUT);
}

//+---------------------------------------------------------------------------
//
//  Member:     CG_INTERFACE_POINTER::CheckImportLib
//
//  Synopsis:   Checks to see if a particular CG node has a definition in
//              an imported type libaray.
//
//  Returns:    NULL  => the node has no imported definition
//              !NULL => ITypeInfo pointer for the imported type definition
//
//  History:    6-14-95   stevebl   Commented
//
//  Notes:      see description of CG_NDR::CheckImportLib
//
//----------------------------------------------------------------------------

void * CG_INTERFACE_POINTER::CheckImportLib()
{
    node_skl * pn = GetTheInterface();
    node_file * pf = pn->GetDefiningFile();
    if (pf && (pf->GetImportLevel() > 0) )
    {
        A2O(wszScratch, pn->GetSymName(), MAX_PATH);

        return(gtllist.FindName(pf->GetFileName(), wszScratch));
    }
    return NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CG_IIDIS_INTERFACE_POINTER::CheckImportLib
//
//  Synopsis:   Checks to see if a particular CG node has a definition in
//              an imported type libaray.
//
//  Returns:    NULL  => the node has no imported definition
//              !NULL => ITypeInfo pointer for the imported type definition
//
//  History:    6-14-95   stevebl   Commented
//
//  Notes:      see description of CG_NDR::CheckImportLib
//
//----------------------------------------------------------------------------

void * CG_IIDIS_INTERFACE_POINTER::CheckImportLib()
{
    node_skl * pn = GetBaseInterface();
    node_file * pf = pn->GetDefiningFile();
    if (pf && (pf->GetImportLevel() > 0) )
    {
        A2O(wszScratch, pn->GetSymName(), MAX_PATH);

        return(gtllist.FindName(pf->GetFileName(), wszScratch));
    }
    return NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CG_INTERFACE_POINTER::GetTypeDesc
//
//  Synopsis:   creates a TYPEDESC for an interface pointer
//
//  Arguments:  [ptd]  - reference to a TYPEDESC pointer
//              [pCCB] - CG control block
//
//  Returns:    CG_OK
//              CG_NOT_LAYED_OUT
//              CG_REF_NOT_LAYED_OUT
//
//  History:    6-14-95   stevebl   Commented
//
//  Notes:      IDispatch* and IUnknown* are treated as special cases since
//              they are base types in ODL.
//
//----------------------------------------------------------------------------

CG_STATUS CG_INTERFACE_POINTER::GetTypeDesc(TYPEDESC * &ptd, CCB *pCCB)
{
    ptd = new TYPEDESC;
    named_node* pPointee = GetTheInterface();

    if ( pPointee && pPointee->NodeKind() == NODE_INTERFACE_REFERENCE )
        {
        pPointee = ( ( node_interface_reference* ) pPointee )->GetRealInterface();
        }

    node_interface * pI = (node_interface*) pPointee;
    char * sz = pI->GetSymName();
    CG_STATUS cgs = CG_OK;

    if (0 == _stricmp(sz, "IDispatch"))
    {
        ptd->vt = VT_DISPATCH;
    }
    else if (0 == _stricmp(sz, "IUnknown"))
    {
        ptd->vt = VT_UNKNOWN;
    }
    else
    {
        CG_CLASS * pCG = GetTypeAlias();

        if (!pCG)
            {
            pCG = pI->GetCG(TRUE);
            if (!pCG)
                {
                // This must be an imported definition.
                // Call ILxlate to manufacture a CG node for it
                XLAT_CTXT ctxt(GetType());
                ctxt.SetAncestorBits(IL_IN_LIBRARY);
                pCG = pI->ILxlate(&ctxt);
                // make sure we get the right CG node
                if (pI->GetCG(TRUE))
                    pCG = pI->GetCG(TRUE);
                }
            }
        ptd->vt = VT_PTR;
        cgs = pCG->GetTypeDesc(ptd->lptdesc, pCCB);
    }
    return cgs;
}

//+---------------------------------------------------------------------------
//
//  Member:     CG_IIDIS_INTERFACE_POINTER::GetTypeDesc
//
//  Synopsis:   creates a TYPEDESC for an interface pointer
//
//  Arguments:  [ptd]  - reference to a TYPEDESC pointer
//              [pCCB] - CG control block
//
//  Returns:    CG_OK
//              CG_NOT_LAYED_OUT
//              CG_REF_NOT_LAYED_OUT
//
//  History:    6-14-95   stevebl   Commented
//
//  Notes:      IDispatch* and IUnknown* are treated as special cases since
//              they are base types in ODL.
//
//----------------------------------------------------------------------------

CG_STATUS CG_IIDIS_INTERFACE_POINTER::GetTypeDesc(TYPEDESC * &ptd, CCB *pCCB)
{
    ptd = new TYPEDESC;
    pCCB;

    node_interface * pI = (node_interface*) GetBaseInterface();
    char * sz = pI->GetSymName();
    CG_STATUS cgs = CG_OK;

    if (0 == _stricmp(sz, "IDispatch"))
    {
        ptd->vt = VT_DISPATCH;
    }
    else if (0 == _stricmp(sz, "IUnknown"))
    {
        ptd->vt = VT_UNKNOWN;
    }
    else if ( pI->NodeKind() == NODE_VOID )
    {
        // this node is void * forced into interface because iid_is. 
        ptd->vt = VT_PTR ;
        ptd->lptdesc = new TYPEDESC;
        ptd->lptdesc->vt = VT_VOID;
    }
    else
    {
        // although it doesn't make sense to have (iid_is(riid), [out] IBar ** ppv),
        // I still have the tlb preserves what user specified.
        CG_CLASS * pCG = GetTypeAlias();

        if (!pCG)
            {
            pCG = pI->GetCG(TRUE);
            if (!pCG)
                {
                // This must be an imported definition.
                // Call ILxlate to manufacture a CG node for it
                XLAT_CTXT ctxt(GetType());
                ctxt.SetAncestorBits(IL_IN_LIBRARY);
                pCG = pI->ILxlate(&ctxt);
                // make sure we get the right CG node
                if (pI->GetCG(TRUE))
                    pCG = pI->GetCG(TRUE);
                }
            }
        ptd->vt = VT_PTR;
        cgs = pCG->GetTypeDesc(ptd->lptdesc, pCCB);
    }
    return cgs;
}



//+---------------------------------------------------------------------------
//
//  Member:     CG_INTERFACE_POINTER::GenTypeInfo
//
//  Synopsis:   generates type info for an interface pointer
//
//  Arguments:  [pCCB] - CG control block
//
//  Returns:    CG_OK
//              CG_NOT_LAYED_OUT
//              CG_REF_NOT_LAYED_OUT
//
//  History:    6-14-95   stevebl   Commented
//
//----------------------------------------------------------------------------

CG_STATUS CG_INTERFACE_POINTER::GenTypeInfo(CCB * pCCB)
{
    node_interface * pI = GetTheInterface();
    char * sz = pI->GetSymName();

    if (0 == _stricmp(sz, "IDispatch"))
    {
        return CG_OK;
    }
    else if (0 == _stricmp(sz, "IUnknown"))
    {
        return CG_OK;
    }

    CG_CLASS * pCG = pI->GetCG(TRUE);
    if (!pCG)
    {
        // This must be an imported definition.
        // Call ILxlate to manufacture a CG node for it
        XLAT_CTXT ctxt(GetType());
        ctxt.SetAncestorBits(IL_IN_LIBRARY);
        pCG = pI->ILxlate(&ctxt);
        // make sure we get the right CG node
        pCG = pI->GetCG(TRUE);
    }
    return pCG->GenTypeInfo(pCCB);
}

//+---------------------------------------------------------------------------
//
//  Member:     CG_IIDIS_INTERFACE_POINTER::GenTypeInfo
//
//  Synopsis:   generates type info for an interface pointer
//
//  Arguments:  [pCCB] - CG control block
//
//  Returns:    CG_OK
//              CG_NOT_LAYED_OUT
//              CG_REF_NOT_LAYED_OUT
//
//  History:    6-14-95   stevebl   Commented
//
//----------------------------------------------------------------------------

CG_STATUS CG_IIDIS_INTERFACE_POINTER::GenTypeInfo(CCB * pCCB)
{
    node_skl * pBase = GetBaseInterface();
    node_interface *pI;
    char * sz = pBase->GetSymName();

    // base can be void *
    if ( 0 == _stricmp(sz, "IDispatch") || 
         0 == _stricmp(sz, "IUnknown") ||
         pBase->NodeKind() == NODE_VOID  )
    {
        return CG_OK;
    }

    // semantic checking has forced the base to be either void ** 
    // or interface
    pI = (node_interface *)pBase;
    
    //preserve what's in the idl
    CG_CLASS * pCG = pI->GetCG(TRUE);
    if (!pCG)
    {
        // This must be an imported definition.
        // Call ILxlate to manufacture a CG node for it
        XLAT_CTXT ctxt(GetType());
        ctxt.SetAncestorBits(IL_IN_LIBRARY);
        pCG = pI->ILxlate(&ctxt);
        // make sure we get the right CG node
        pCG = pI->GetCG(TRUE);
    }
    return pCG->GenTypeInfo(pCCB);

}

//+---------------------------------------------------------------------------
//
//  Member:     CG_STRING_POINTER::GetTypeDesc
//
//  Synopsis:   creates a TYPEDESC for a string pointer
//
//  Arguments:  [ptd]  - reference to a TYPEDESC pointer
//              [pCCB] - CG control block
//
//  Returns:    CG_OK
//              CG_REF_NOT_LAYED_OUT
//
//  History:    10-26-95  stevebl   Created
//
//  Notes:      BSTR, LPSTR and LPWSTR are handled as special cases because
//              they are base types in ODL.
//
//----------------------------------------------------------------------------

CG_STATUS CG_STRING_POINTER::GetTypeDesc(TYPEDESC * &ptd, CCB* )
{
    ptd = new TYPEDESC;
    ptd->lptdesc = NULL;

    if (((CG_STRING_POINTER *)this)->IsBStr())
    {
        ptd->vt = VT_BSTR;
    }
    else if (1 == ((CG_NDR *)GetChild())->GetMemorySize())
    {
        ptd->vt = VT_LPSTR;
    }
    else
    {
        ptd->vt = VT_LPWSTR;
    }

    return CG_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CG_POINTER::GetTypeDesc
//
//  Synopsis:   creates a TYPEDESC for a pointer
//
//  Arguments:  [ptd]  - reference to a TYPEDESC pointer
//              [pCCB] - CG control block
//
//  Returns:    CG_OK
//              CG_REF_NOT_LAYED_OUT
//
//  History:    6-14-95   stevebl   Commented
//
//----------------------------------------------------------------------------

CG_STATUS CG_POINTER::GetTypeDesc(TYPEDESC * &ptd, CCB * pCCB)
{
    ptd = new TYPEDESC;
    ptd->vt = VT_PTR;
    CG_CLASS * pCG = GetChild();
    CG_STATUS cgs = pCG->GetTypeDesc(ptd->lptdesc, pCCB);
    return (CG_OK == cgs ? CG_OK : CG_REF_NOT_LAYED_OUT);
}

//+---------------------------------------------------------------------------
//
//  Member:     CG_SAFEARRAY::GetTypeDesc
//
//  Synopsis:   creates a TYPEDESC for a SAFEARRAY
//
//  Arguments:  [ptd]  - reference to a TYPEDESC pointer
//              [pCCB] - CG control block
//
//  Returns:    CG_OK
//              CG_REF_NOT_LAYED_OUT
//
//  History:    6-14-95   stevebl   Commented
//
//----------------------------------------------------------------------------

CG_STATUS CG_SAFEARRAY::GetTypeDesc(TYPEDESC * &ptd, CCB * pCCB)
{
    ptd = new TYPEDESC;
    ptd->vt = VT_SAFEARRAY;
    CG_STATUS cgs = GetChild()->GetTypeDesc(ptd->lptdesc, pCCB);
    return (CG_OK == cgs ? CG_OK : CG_REF_NOT_LAYED_OUT);
}

//+---------------------------------------------------------------------------
//
// The order of the items in this table must match the order of the items 
// in the node_t enumeration defined in midlnode.hxx.
//
// To make the dependency visible to C++ the browser, the third column has 
// explicit node_t enums that otherwise are not used for any purpose. (rkk).
//
// There is a VT_INT_PTR in the public headers that corresponds to __int3264.
// However, it is defined currently to VT_I4 or VT_I8, and definition can
// change on us unexpectedly. /use_vt_int_ptr switch addresses that problem.
//

// This table is used for Win32 with VT_INT_PTR being represented as VT_I4.
//
VARTYPE rgMapOldBaseTypeToVARTYPE[][3] =  // This table used for Win32.
    {
    //  unsigned        signed          not used
        {VT_R4,         VT_R4,          (VARTYPE) NODE_FLOAT },
        {VT_R8,         VT_R8,          (VARTYPE) NODE_DOUBLE },
        {0,             0,              (VARTYPE) NODE_FLOAT80 }, //not in TLB
        {0,             0,              (VARTYPE) NODE_FLOAT128 }, //not in TLB
        {VT_UI8,        VT_I8,          (VARTYPE) NODE_HYPER },
        {VT_UI8,        VT_I8,          (VARTYPE) NODE_INT64 },
        {0,             0,              (VARTYPE) NODE_INT128 },  //not in TLB
        {VT_UI4,        VT_I4,          (VARTYPE) NODE_INT3264 },
        {VT_UI4,        VT_I4,          (VARTYPE) NODE_INT32 },
        {VT_UI4,        VT_I4,          (VARTYPE) NODE_LONG },
        {VT_UI8,        VT_I8,          (VARTYPE) NODE_LONGLONG },
        {VT_UI2,        VT_I2,          (VARTYPE) NODE_SHORT },
        {VT_UINT,       VT_INT,         (VARTYPE) NODE_INT },
        {VT_UI1,        VT_I1,          (VARTYPE) NODE_SMALL },
        {VT_UI1,        VT_I1,          (VARTYPE) NODE_CHAR },
        {VT_UI1,        VT_I1,          (VARTYPE) NODE_BOOLEAN },
        {VT_UI1,        VT_I1,          (VARTYPE) NODE_BYTE },
        {VT_VOID,       VT_VOID,        (VARTYPE) NODE_VOID },
        {VT_UI2,        VT_I2,          (VARTYPE) NODE_HANDLE_T },
        {0,             0,              (VARTYPE) NODE_FORWARD },
        {VT_UI2,        VT_I2,          (VARTYPE) NODE_WCHAR_T }
    };

// This table used for Win32 with VT_INT_PTR being represented as VT_INT_PTR.
// The table is used when the -use_vt_int_ptr is used.

VARTYPE rgMapBaseTypeToVARTYPE[][3] =  // This table used for Win32.
    {
    //  unsigned        signed          not used
        {VT_R4,         VT_R4,          (VARTYPE) NODE_FLOAT },
        {VT_R8,         VT_R8,          (VARTYPE) NODE_DOUBLE },
        {0,             0,              (VARTYPE) NODE_FLOAT80 }, //not in TLB
        {0,             0,              (VARTYPE) NODE_FLOAT128 }, //not in TLB
        {VT_UI8,        VT_I8,          (VARTYPE) NODE_HYPER },
        {VT_UI8,        VT_I8,          (VARTYPE) NODE_INT64 },
        {0,             0,              (VARTYPE) NODE_INT128 }, //not in TLB
        {VT_UINT_PTR,   VT_INT_PTR,     (VARTYPE) NODE_INT3264 },
        {VT_UI4,        VT_I4,          (VARTYPE) NODE_INT32 },
        {VT_UI4,        VT_I4,          (VARTYPE) NODE_LONG },
        {VT_UI8,        VT_I8,          (VARTYPE) NODE_LONGLONG },
        {VT_UI2,        VT_I2,          (VARTYPE) NODE_SHORT },
        {VT_UINT,       VT_INT,         (VARTYPE) NODE_INT },
        {VT_UI1,        VT_I1,          (VARTYPE) NODE_SMALL },
        {VT_UI1,        VT_I1,          (VARTYPE) NODE_CHAR },
        {VT_UI1,        VT_I1,          (VARTYPE) NODE_BOOLEAN },
        {VT_UI1,        VT_I1,          (VARTYPE) NODE_BYTE },
        {VT_VOID,       VT_VOID,        (VARTYPE) NODE_VOID },
        {VT_UI2,        VT_I2,          (VARTYPE) NODE_HANDLE_T },
        {0,             0,              (VARTYPE) NODE_FORWARD },
        {VT_UI2,        VT_I2,          (VARTYPE) NODE_WCHAR_T }
    };

// This table used for Win64 with VT_INT_PTR being represented as VT_I8.

VARTYPE rgMapOld64BaseTypeToVARTYPE[][3] =  
    {
    //  unsigned        signed          not used
        {VT_R4,         VT_R4,          (VARTYPE) NODE_FLOAT },
        {VT_R8,         VT_R8,          (VARTYPE) NODE_DOUBLE },
        {0,             0,              (VARTYPE) NODE_FLOAT80 },  //not in TLB
        {0,             0,              (VARTYPE) NODE_FLOAT128 }, //not in TLB
        {VT_UI8,        VT_I8,          (VARTYPE) NODE_HYPER },
        {VT_UI8,        VT_I8,          (VARTYPE) NODE_INT64 },
        {0,             0,              (VARTYPE) NODE_INT128 },   //not in TLB
        {VT_UI8,        VT_I8,          (VARTYPE) NODE_INT3264 },
        {VT_UI4,        VT_I4,          (VARTYPE) NODE_INT32 },
        {VT_UI4,        VT_I4,          (VARTYPE) NODE_LONG },
        {VT_UI8,        VT_I8,          (VARTYPE) NODE_LONGLONG },
        {VT_UI2,        VT_I2,          (VARTYPE) NODE_SHORT },
        {VT_UINT,       VT_INT,         (VARTYPE) NODE_INT },
        {VT_UI1,        VT_I1,          (VARTYPE) NODE_SMALL },
        {VT_UI1,        VT_I1,          (VARTYPE) NODE_CHAR },
        {VT_UI1,        VT_I1,          (VARTYPE) NODE_BOOLEAN },
        {VT_UI1,        VT_I1,          (VARTYPE) NODE_BYTE },
        {VT_VOID,       VT_VOID,        (VARTYPE) NODE_VOID },
        {VT_UI2,        VT_I2,          (VARTYPE) NODE_HANDLE_T },
        {0,             0,              (VARTYPE) NODE_FORWARD },
        {VT_UI2,        VT_I2,          (VARTYPE) NODE_WCHAR_T }
    };

// This table used for Win64 with VT_INT_PTR being represented as VT_INT_PTR.
// The table is used when the -use_vt_int_ptr is used.

VARTYPE rgMap64BaseTypeToVARTYPE[][3] =  // This table used for Win64.
    {
    //  unsigned        signed          not used
        {VT_R4,         VT_R4,          (VARTYPE) NODE_FLOAT },
        {VT_R8,         VT_R8,          (VARTYPE) NODE_DOUBLE },
        {0,             0,              (VARTYPE) NODE_FLOAT80 },  // not in TLB
        {0,             0,              (VARTYPE) NODE_FLOAT128 }, // not in TLB
        {VT_UI8,        VT_I8,          (VARTYPE) NODE_HYPER },
        {VT_UI8,        VT_I8,          (VARTYPE) NODE_INT64 },
        {0,             0,              (VARTYPE) NODE_INT128 },   // not in TLB
        {VT_UINT_PTR,   VT_INT_PTR,     (VARTYPE) NODE_INT3264 },
        {VT_UI4,        VT_I4,          (VARTYPE) NODE_INT32 },
        {VT_UI4,        VT_I4,          (VARTYPE) NODE_LONG },
        {VT_UI8,        VT_I8,          (VARTYPE) NODE_LONGLONG },
        {VT_UI2,        VT_I2,          (VARTYPE) NODE_SHORT },
        {VT_UINT,       VT_INT,         (VARTYPE) NODE_INT },
        {VT_UI1,        VT_I1,          (VARTYPE) NODE_SMALL },
        {VT_UI1,        VT_I1,          (VARTYPE) NODE_CHAR },
        {VT_UI1,        VT_I1,          (VARTYPE) NODE_BOOLEAN },
        {VT_UI1,        VT_I1,          (VARTYPE) NODE_BYTE },
        {VT_VOID,       VT_VOID,        (VARTYPE) NODE_VOID },
        {VT_UI2,        VT_I2,          (VARTYPE) NODE_HANDLE_T },
        {0,             0,              (VARTYPE) NODE_FORWARD },
        {VT_UI2,        VT_I2,          (VARTYPE) NODE_WCHAR_T }
    };

//+---------------------------------------------------------------------------
//
//  Member:     CG_BASETYPE::GetTypeDesc
//
//  Synopsis:   creates a TYPEDESC for a base type
//
//  Arguments:  [ptd]  - reference to a TYPEDESC pointer
//              [pCCB] - CG control block
//
//  Returns:    CG_OK
//
//  History:    6-14-95   stevebl   Commented
//
//  Notes:      rgIntrinsic contains an array of types which are intrinsic
//              types in ODL but are not INTRINSIC types in IDL, therefore
//              they must be treated as a special case.
//
//----------------------------------------------------------------------------

CG_STATUS CG_BASETYPE::GetTypeDesc(TYPEDESC * &ptd, CCB* )
{
    node_skl * pskl = GetType();
    while (NODE_DEF == pskl->NodeKind())
    {
        char * szName = pskl->GetSymName();
        int iIntrinsicType = 0;
        while (iIntrinsicType < (sizeof(rgIntrinsic) / sizeof(INTRINSIC)))
        {
            int i = _stricmp(szName, rgIntrinsic[iIntrinsicType].szType);
            if (i == 0)
            {
                ptd = new TYPEDESC;
                ptd->lptdesc = NULL;
                ptd->vt = rgIntrinsic[iIntrinsicType].vt;
                return CG_OK;
            }
            iIntrinsicType++;
        }
        pskl = pskl->GetChild();
    }

    NODE_T type = pskl->NodeKind();
    unsigned short Option = pCommand->GetCharOption ();

    // CONSIDER - perhaps this should be an assertion
    if (type < BASE_NODE_START || type >= BASE_NODE_END || NODE_FORWARD == type)
    {
        ReportTLGenError( "bad type", GetSymName(), 0);
    }
    int iTable = 1;
    if (pskl->FInSummary(ATTR_UNSIGNED) || type == NODE_BYTE || type == NODE_WCHAR_T )
    {
        iTable = 0;
    }
    else if (pskl->FInSummary(ATTR_SIGNED))
    {
        iTable = 1;
    }
    else if (NODE_CHAR == type || NODE_SMALL == type)
    {
        iTable = (CHAR_SIGNED == Option) ? 1 : 0;
    }

    /*
    INT_PTR problem
    Old .tlb and old oleaut32.dll don't support VT_INT_PTR. Adding 32bit
    support for the new VT code creates backward compatibility problem.
    To work aroud the problem, we define a new switch -use_vt_int_ptr. 
    If this is not defined, we'll save VT_INT_PTR as VT_I4.
    */
    
    VARTYPE vt;
    if (NODE_BOOLEAN == type && pCommand->IsSwitchDefined(SWITCH_MKTYPLIB))
        vt = VT_BOOL;
    else
        if ( pCommand->Is64BitEnv() )
        {
            if ( pCommand->IsSwitchDefined(SWITCH_USE_VT_INT_PTR) )
                vt = rgMap64BaseTypeToVARTYPE[type - BASE_NODE_START][iTable];
            else
                vt = rgMapOld64BaseTypeToVARTYPE[type - BASE_NODE_START][iTable];
        }
        else
        {
            if ( pCommand->IsSwitchDefined(SWITCH_USE_VT_INT_PTR) )
                vt = rgMapBaseTypeToVARTYPE[type - BASE_NODE_START][iTable];
            else
                vt = rgMapOldBaseTypeToVARTYPE[type - BASE_NODE_START][iTable];
        }

    ptd = new TYPEDESC;
    ptd->lptdesc = NULL;
    ptd->vt = vt;
    return CG_OK;
}

// The following two functions are necessary because this information
// is needed within TYPELIB.CXX and pCommand isn't visible to
// that module.

int FOldTlbSwitch(void)
{
    return (pCommand->IsSwitchDefined(SWITCH_OLD_TLB));
}

int FNewTlbSwitch(void)
{
    return (pCommand->IsSwitchDefined(SWITCH_NEW_TLB));
}

/*
This routine returns TRUE if the expression is evaluated as a floating point expression.
The results of the evaluation are returned in var.
*/
BOOL EvaluateFloatExpr( VARIANT& var, expr_node* pExpr )
    {
    BOOL    fIsFloat = FALSE;
    if ( pExpr->IsConstant() )
        {
        SExprValue  v           = {VALUE_TYPE_UNDEFINED, 0};
        BOOL        fSuccess    = pExpr->GetExprValue( v );
    
        if (fSuccess)
            {
            if ( v.format == VALUE_TYPE_FLOAT )
                {
                var.vt = VT_R4;
                var.fltVal = v.f;
                fIsFloat = TRUE;
                }
            else if ( v.format == VALUE_TYPE_DOUBLE )
                {
                var.vt = VT_R8;
                var.dblVal = v.d;
                fIsFloat = TRUE;
                }
            }
        else if ( v.format != VALUE_TYPE_UNDEFINED )
            {
            RpcError(NULL, 0, INVALID_FLOAT, 0);
            }
        }
    return fIsFloat;
    }

//=============================================================================
//=============================================================================
//=============================================================================

void ConvertToVariant(VARIANT & var, expr_node * pExpr, LCID lcid)
{
    if ( EvaluateFloatExpr( var, pExpr) )
        {
        // this is a floating point expression.
        return;
        }

    EXPR_VALUE val = pExpr->GetValue();
    if (pExpr->IsStringConstant() && !IsBadStringPtr((char *)val, 256))
    {
        char * sz = (char *) val;
        TranslateEscapeSequences(sz);
        WCHAR * wsz = TranscribeA2O( sz );

        VARIANT varTemp;
        varTemp.bstrVal = LateBound_SysAllocString(wsz);
        varTemp.vt = VT_BSTR;

        HRESULT hr;
        // try floating point numeric types first
        hr = LateBound_VariantChangeTypeEx(&var, &varTemp, lcid, 0, VT_R8);
        if (FAILED(hr))
        {
            // if it can't be coerced into a floating point type, then just stuff the BSTR value
            var.bstrVal = LateBound_SysAllocString(wsz);
            var.vt = VT_BSTR;
        }
        LateBound_SysFreeString(varTemp.bstrVal);
        delete [] wsz;
    }
    else
    {
        var.vt = VT_I4;
        var.lVal = (long) val;
    }
}

void GetValueFromExpression(VARIANT & var, TYPEDESC tdesc, expr_node * pExpr, LCID lcid, char * szSymName)
{
    memset(&var, 0, sizeof(VARIANT));
    if ( EvaluateFloatExpr( var, pExpr) )
        {
        // this is a floating point expression.
        return;
        }

    if (tdesc.vt == VT_PTR && (tdesc.lptdesc->vt == VT_I1 || tdesc.lptdesc->vt == VT_VARIANT))
    {
        // Fool switch into realizing that the data should be in string form.
        tdesc.vt = VT_LPSTR;
    }
    // set the value
    switch (tdesc.vt)
    {
    case VT_BOOL:
//        var.vt = VT_BOOL;
//        var.boolVal = (pExpr->GetValue() ? VARIANT_TRUE : VARIANT_FALSE);
//        break;
    case VT_I1:
    case VT_UI1:
//        var.vt = VT_UI1;
//        var.bVal = (unsigned char) pExpr->GetValue();
//        break;
    case VT_UI2:
//        var.vt = VT_UI4;
//        var.ulVal = (unsigned short) pExpr->GetValue();
//        break;
    case VT_I2:
        var.vt = VT_I2;
        var.iVal = (short) pExpr->GetValue();
        break;
    case VT_UI4:
//        var.vt = VT_UI4;
//        var.ulVal = (unsigned long) pExpr->GetValue();
//        break;
    case VT_UINT:
//        var.vt = VT_UI4;
//        var.ulVal = (unsigned int) pExpr->GetValue();
//        break;
    case VT_INT:
    case VT_I4:
        var.vt = VT_I4;
        var.lVal = (long) pExpr->GetValue();
        break;
    case VT_DISPATCH:
    case VT_UNKNOWN:
        //var.vt = vt;
        var.vt = VT_I4;
        if (pExpr->GetValue())
        {
            RpcError(NULL, 0, ILLEGAL_CONSTANT, szSymName);
            exit(ERR_TYPELIB_GENERATION);
        }
        var.ppunkVal = NULL;    // the only supported value for constants of this type
        break;
    case VT_ERROR:
        var.vt = VT_I4;
//        var.vt = VT_ERROR;
        var.lVal = (long) pExpr->GetValue();
//        var.scode = (SCODE) pExpr->GetValue();
        break;
    case VT_LPSTR:
    case VT_LPWSTR:
        {
        var.vt = VT_BSTR;
        var.bstrVal = 0;
        EXPR_VALUE val = pExpr->GetValue();
        if (pExpr->IsStringConstant() && !IsBadStringPtr((char *)val, 256))
            {
            // Constants of these types may be defined as a string.
            // Convert the string to a BSTR and use VariantChangeType to
            // coerce the BSTR to the appropriate variant type.
            char * sz = (char *) val;
            TranslateEscapeSequences(sz);
            WCHAR * wsz = TranscribeA2O( sz );

            var.bstrVal = LateBound_SysAllocString(wsz);
            delete [] wsz;
            }
        else
            {
            // get the value as a LONG and coerce it to the correct type.
            // If the value is not a string then it should be NULL.
            if (pExpr->GetValue())
                {
                // value wasn't NULL
                // convert it to a string
                char sz[40];
                WCHAR wsz [40];
                sprintf(sz,"%li",val);
                A2O(wsz, sz, 40);
                var.bstrVal = LateBound_SysAllocString(wsz);
                }
            }
        }
        break;
    case VT_R4:
    case VT_R8:
    case VT_I8:
    case VT_UI8:
    case VT_CY:
    case VT_DATE:
    case VT_BSTR:
    case VT_DECIMAL:
        {
            VARIANT varTemp;
            HRESULT hr;
            EXPR_VALUE val = pExpr->GetValue();
            if (pExpr->IsStringConstant() && !IsBadStringPtr((char *)val, 256))
            {
                // Constants of these types may be defined as a string.
                // Convert the string to a BSTR and use VariantChangeType to
                // coerce the BSTR to the appropriate variant type.
                char *  sz = (char *) val;
                WCHAR * wsz = TranscribeA2O( sz );

                varTemp.bstrVal = LateBound_SysAllocString(wsz);
                varTemp.vt = VT_BSTR;
                delete [] wsz;

                hr = LateBound_VariantChangeTypeEx(&var, &varTemp, lcid, 0, tdesc.vt);
                if (FAILED(hr))
                {
                    RpcError(NULL, 0, CONSTANT_TYPE_MISMATCH, szSymName);
                    exit(ERR_TYPELIB_GENERATION);
                }

                LateBound_SysFreeString(varTemp.bstrVal);
            }
            else
            {
                // get the value as a LONG and coerce it to the correct type.
                varTemp.vt = VT_I4;
                varTemp.lVal = (long) val;
                hr = LateBound_VariantChangeTypeEx(&var, &varTemp, lcid, 0, tdesc.vt);
                if (FAILED(hr))
                {
                    RpcError(NULL, 0, CONSTANT_TYPE_MISMATCH, szSymName);
                    exit(ERR_TYPELIB_GENERATION);
                }
            }
        }
        break;
    case VT_VARIANT:
        ConvertToVariant(var, pExpr, lcid);
        break;
    case VT_VOID:
    case VT_HRESULT:
    case VT_SAFEARRAY:
    case VT_CARRAY:
    case VT_USERDEFINED:
    case VT_PTR:
    default:
        ConvertToVariant(var, pExpr, lcid);
        // assert(!"Illegal constant value");
        // var.vt = VT_I4; // put us in a legal state just to keep code from crashing
    }
}

unsigned long CG_INTERFACE::LayOut()
    {
    unsigned long ulRet = 0;
    if (!IsLayedOut())
        {
        if (GetBaseInterfaceCG())
            {
            GetBaseInterfaceCG()->LayOut();
            }
#ifdef __TRACE_LAYOUT__
        printf("LayOut, %s\n", GetType()->GetSymName());
#endif
        ICreateTypeInfo* pCTI = (ICreateTypeInfo*)_pCTI;
        // ulRet = (pCTI) ? pCTI->LayOut() : TYPE_E_INVALIDSTATE;
        if (pCTI)
            {
            HRESULT  hr;

            // Alignment is not defined for interfaces, so we set it
            // to an arbitrary value, same as mktplib.

            hr    = pCTI->SetAlignment( pCommand->GetZeePee() );
            ulRet = pCTI->LayOut();
            }
        LayedOut();
        }
    return ulRet;
    }

unsigned long CG_COCLASS::LayOut()
    {
    unsigned long ulRet = 0;
    if (!IsLayedOut())
        {
#ifdef __TRACE_LAYOUT__
        printf("LayOut, %s\n", GetType()->GetSymName());
#endif
        ICreateTypeInfo* pCTI = (ICreateTypeInfo*)_pCTI;
        // ulRet = (pCTI) ? pCTI->LayOut() : TYPE_E_INVALIDSTATE;
        if (pCTI)
            {
            HRESULT  hr;

            // Alignment is not defined for coclasses, so we set it
            // to an arbitrary value, same as mktplib.

            hr    = pCTI->SetAlignment( pCommand->GetZeePee() );
            ulRet = pCTI->LayOut();
            }
        LayedOut();
        }
    return ulRet;
    }

unsigned long CG_MODULE::LayOut()
    {
    unsigned long ulRet = 0;
    if (!IsLayedOut())
        {
#ifdef __TRACE_LAYOUT__
        printf("LayOut, %s\n", GetType()->GetSymName());
#endif
        ICreateTypeInfo* pCTI = (ICreateTypeInfo*)_pCTI;
        // ulRet = (pCTI) ? pCTI->LayOut() : TYPE_E_INVALIDSTATE;
        if (pCTI)
            {
            HRESULT  hr;

            // Alignment is not defined for modules, so we set it
            // to an arbitrary value, same as mktplib.

            hr    = pCTI->SetAlignment( pCommand->GetZeePee() );
            ulRet = pCTI->LayOut();
            }
        LayedOut();
        }
    return ulRet;
    }


WCHAR * 
TranscribeA2O( char * sz )
//+---------------------------------------------------------------------------
//
//  Synopsis:   creates a unicode string corresponding to a multibyte string.
//
//  Arguments:  sz - multibyte string
//
//  Returns:    the unicode string
//
//  History:    1-3-97   ryszardk   Created
//
//----------------------------------------------------------------------------
{
    // The length includes the terminating character.

    unsigned long cc  = (unsigned long) strlen(sz)+1;
    unsigned long cw  = MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, sz, cc, 0, 0);
    WCHAR *       wsz = new WCHAR [cw];

    wsz[0] = 0;
    MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, sz, cc, wsz, cw );

    return wsz;
}

char *  
TranscribeO2A( BSTR bstr )
//+---------------------------------------------------------------------------
//
//  Synopsis:   creates a multibyte string corresponding to a unicode string.
//
//  Arguments:  bstr - the unicode string
//
//  Returns:    the multibyte string
//
//  History:    1-3-97   ryszardk   Created
//
//----------------------------------------------------------------------------
{
    // The length includes the terminating character.

    unsigned long cw = (unsigned long) wcslen(bstr)+1;
    unsigned long cc = WideCharToMultiByte( CP_ACP, 0, bstr, cw, 0, 0, 0, 0);
    char *        sz = new char [cc];
            
    sz[0] = 0;
    WideCharToMultiByte( CP_ACP, 0, bstr, cw, sz, cc, 0, 0 );

    return sz;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr20\asyncu.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1996 - 2000 Microsoft Corporation

Module Name :

    asyncu.c

Abstract :

    This file contains the ndr async uuid implementation.

Author :

    Ryszard K. Kott     (ryszardk)    Oct 1997

Revision History :

---------------------------------------------------------------------*/



#define USE_STUBLESS_PROXY
#define CINTERFACE

#include "ndrp.h"
#include "ndrole.h"
#include "rpcproxy.h"
#include "mulsyntx.h"
#include "hndl.h"
#include "interp2.h"
#include "asyncu.h"
#include "attack.h"
#include <stddef.h>

#include <stdarg.h>

#pragma code_seg(".orpc")


RPC_STATUS
NdrpBeginDcomAsyncClientCall(
                            PMIDL_STUB_DESC     pStubDescriptor,
                            PFORMAT_STRING      pFormat,
                            unsigned char  *    StartofStack
                            );

RPC_STATUS
NdrpFinishDcomAsyncClientCall(
                             PMIDL_STUB_DESC     pStubDescriptor,
                             PFORMAT_STRING      pFormat,
                             unsigned char  *    StartofStack
                             );

const IID * RPC_ENTRY
NdrGetProxyIID(
    const void *pThis);



VOID
NdrpAsyncDCOMFreeParams(
                       PNDR_DCOM_ASYNC_MESSAGE pAsyncMsg )
{
/*++

Routine Description:
    Frees the parameters for both the begin and finish calls.

Arguments:
    pAsyncMsg - Supplies a pointer to the async message.

Return Value:
    None.

--*/

   if ( pAsyncMsg->BeginStack )
      {

      if ( pAsyncMsg->FinishStack )
         {

         // Clear out the IN OUT parameters on the begin stack
         // so that they are not freed twice.
         int n;
         REGISTER_TYPE       *pBeginStack      = (REGISTER_TYPE *)pAsyncMsg->BeginStack;
         PPARAM_DESCRIPTION  BeginParams       = (PPARAM_DESCRIPTION)pAsyncMsg->BeginParams;
         int                 BeginNumberParams = (int)pAsyncMsg->nBeginParams;

         for( n = 0; n < BeginNumberParams; n++ ) 
            {

            if ( BeginParams[n].ParamAttr.IsIn  &&
                 BeginParams[n].ParamAttr.IsOut )
               {

               pBeginStack[ BeginParams[ n ].StackOffset / sizeof(REGISTER_TYPE) ] = 0;
               
               }
                  
            }
         }

      pAsyncMsg->StubMsg.StackTop = pAsyncMsg->BeginStack; 
      NdrpFreeParams( & (pAsyncMsg->StubMsg),
                      pAsyncMsg->nBeginParams,
                      (PPARAM_DESCRIPTION)pAsyncMsg->BeginParams,
                      pAsyncMsg->BeginStack );
      }

   if ( pAsyncMsg->FinishStack )
      {

      pAsyncMsg->StubMsg.StackTop = pAsyncMsg->FinishStack; 
      NdrpFreeParams( & (pAsyncMsg->StubMsg),
                      pAsyncMsg->nFinishParams,
                      (PPARAM_DESCRIPTION)pAsyncMsg->FinishParams,
                      pAsyncMsg->FinishStack );
      }

}


CLIENT_CALL_RETURN  RPC_VAR_ENTRY
NdrDcomAsyncClientCall(
                      PMIDL_STUB_DESC     pStubDescriptor,
                      PFORMAT_STRING      pFormat,
                      ...
                      )
/*
    This entry is used by the stubless proxy invoker and also by OLE thunks.
    Sync stubless proxies would invoke to NdrClientCall2.
    On ia64, this entry would be used by -Oic generated code.

    Note that signaling on the client happens behind the async proxy's back
    as channel effectively signals to the app and the app issues the Finish.
*/

{
   va_list                 ArgList;
   unsigned char  *        StartofStack;
   CLIENT_CALL_RETURN      Ret;
   ulong                   ProcNum;
   //
   // Get address of argument to this function following pFormat. This
   // is the address of the address of the first argument of the function
   // calling this function.
   // Then get the address of the stack where the parameters are.
   //
   INIT_ARG( ArgList, pFormat);
   GET_FIRST_IN_ARG(ArgList);
   StartofStack = (uchar *) GET_STACK_START(ArgList);

   // Object proc layout is fixed for anything that can show up here.

   ProcNum = *(ushort *)(pFormat+6);

   if ( ProcNum & 0x1 )
      {
      // An odd proc number means a Begin call (0,1,2,Begin,Finish, ...).

      Ret.Simple = NdrpBeginDcomAsyncClientCall( pStubDescriptor,
                                                 pFormat,
                                                 StartofStack );
      }
   else
      {
      Ret.Simple = NdrpFinishDcomAsyncClientCall( pStubDescriptor,
                                                  pFormat,
                                                  StartofStack );
      }

   return Ret;
}


#if defined(_WIN64)
CLIENT_CALL_RETURN  RPC_ENTRY
NdrpDcomAsyncClientCall(
                       PMIDL_STUB_DESC     pStubDescriptor,
                       PFORMAT_STRING      pFormat,
                       unsigned char  *    StartofStack
                       )
/*
    Used only on WIN64,
    this entry is used by the stubless proxy invoker and also by OLE thunks.
    Sync stubless proxies would invoke to NdrpClientCall2.

    Note that signaling on the client happens behind the async proxy's back
    as channel effectively signals to the app and the app issues the Finish.
*/

{
   CLIENT_CALL_RETURN      Ret;
   ulong                   ProcNum;

   // Object proc layout is fixed for anything that can show up here.

   ProcNum = *(ushort *)(pFormat+6);

   if ( ProcNum & 0x1 )
      {
      // An odd proc number means a Begin call (0,1,2,Begin,Finish, ...).

      Ret.Simple = NdrpBeginDcomAsyncClientCall( pStubDescriptor,
                                                 pFormat,
                                                 StartofStack );
      }
   else
      {
      Ret.Simple = NdrpFinishDcomAsyncClientCall( pStubDescriptor,
                                                  pFormat,
                                                  StartofStack );
      }

   return Ret;
}
#endif


HRESULT
NdrpBeginDcomAsyncClientCall(
                            PMIDL_STUB_DESC     pStubDescriptor,
                            PFORMAT_STRING      pFormat,
                            unsigned char  *    StartofStack
                            )
/*
    Notes: OLE Refcounting.
    The model for async_uuid() is that async proxies or stubs
    are created with RefCount==1 and should never ever be
    addrefed by the engine.
    What the engine does is only the AsyncMsg clean up when done.

    The decision to destroy the AsyncPB or AsyncSB object is
    up to the client side PM or channel's SM for the server side.
*/
{
   PNDR_DCOM_ASYNC_MESSAGE     pAsyncMsg;

   RPC_MESSAGE *               pRpcMsg;
   MIDL_STUB_MESSAGE *         pStubMsg;
   PFORMAT_STRING              pFormatParam;

   uchar *                     pArg;
   void *                      pThis = *(void **)StartofStack;
   INTERPRETER_FLAGS           OldOiFlags;
   INTERPRETER_OPT_FLAGS       NewOiFlags;
   PPARAM_DESCRIPTION          Params;
   long                        NumberParams;
   long                        n;

   RPC_STATUS                  Status;
   PNDR_DCOM_OI2_PROC_HEADER   pProcHeader = (PNDR_DCOM_OI2_PROC_HEADER)pFormat;
   PNDR_PROC_HEADER_EXTS       pHeaderExts = 0;
   CStdAsyncProxyBuffer    *   pAsyncPB;
   const IID *                 piid;
   HRESULT                     hr = S_OK;
   BOOL                        fSendCalled = FALSE;
   NDR_PROC_CONTEXT *          pContext = NULL;

   pAsyncPB = (CStdAsyncProxyBuffer*)
              ((uchar*)pThis - offsetof(CStdProxyBuffer, pProxyVtbl));

   piid = NdrGetProxyIID( pThis );

   Status = NdrpSetupBeginClientCall( pAsyncPB,
                                      StartofStack,
                                      pProcHeader->StackSize,
                                      *piid );
   if ( !SUCCEEDED(Status) )
      return Status;

   pAsyncMsg = (PNDR_DCOM_ASYNC_MESSAGE)pAsyncPB->CallState.pAsyncMsg;

   // We need to switch to our copy of the stack everywhere, including pStubMsg.

   StartofStack = pAsyncMsg->ProcContext.StartofStack;

   pRpcMsg   = & pAsyncMsg->RpcMsg;
   pStubMsg  = & pAsyncMsg->StubMsg;
   pContext = ( NDR_PROC_CONTEXT * ) &pAsyncMsg->ProcContext;
   pStubMsg->pContext = pContext;
   pContext->StartofStack = StartofStack;

   pStubMsg->FullPtrXlatTables = 0;

   OldOiFlags   = pProcHeader->OldOiFlags;
   NewOiFlags   = pProcHeader->Oi2Flags;
   NumberParams = pProcHeader->NumberParams;

   //
   // Parameter descriptions are nicely spit out by MIDL.
   //
   Params = (PPARAM_DESCRIPTION)(pFormat + sizeof(NDR_DCOM_OI2_PROC_HEADER));

   // Proc header extentions, from NDR ver. 5.2, MIDL 5.0.+
   // Params must be set correctly here because of exceptions.

   if ( NewOiFlags.HasExtensions )
      {
      pHeaderExts = (NDR_PROC_HEADER_EXTS *)Params;
      Params = (PPARAM_DESCRIPTION)((uchar*)Params + pHeaderExts->Size);
      }

   pAsyncMsg->nBeginParams = pContext->NumberParams = NumberParams;
   pAsyncMsg->BeginParams = pContext->Params = Params;
   pAsyncMsg->pThis       = pThis;
   pContext->DceTypeFormatString = pStubDescriptor->pFormatTypes;

   // This is OLE only code path - use a single TryExcept.
   // After catching it just map it to OLE exception.

   RpcTryExcept
   {
      ulong  RpcFlags;

      // Note, pProcHeader->ProcNum is the async proc number.

      NdrProxyInitialize( pThis,
                          pRpcMsg,
                          pStubMsg,
                          pStubDescriptor,
                          (pProcHeader->ProcNum + 3)/2   // sync proc number
                        );

      pStubMsg->pAsyncMsg = (struct _NDR_ASYNC_MESSAGE *) pAsyncMsg;

      if ( OldOiFlags.FullPtrUsed )
         pStubMsg->FullPtrXlatTables = NdrFullPointerXlatInit( 0, XLAT_CLIENT );

      // Set Rpc flags after the call to client initialize.
      RpcFlags= *(ulong UNALIGNED *)(pFormat + 2);
      pStubMsg->RpcMsg->RpcFlags = RpcFlags;

      // Must do this before the sizing pass!
      pStubMsg->StackTop = pContext->StartofStack = StartofStack;

      if ( NewOiFlags.HasExtensions )
         {
         pStubMsg->fHasExtensions  = 1;
         pStubMsg->fHasNewCorrDesc = pHeaderExts->Flags2.HasNewCorrDesc;
         if ( pHeaderExts->Flags2.ClientCorrCheck )
            {
            void * pCache = NdrpAlloca( &pAsyncMsg->ProcContext.AllocateContext, NDR_DEFAULT_CORR_CACHE_SIZE );
            
            NdrCorrelationInitialize( pStubMsg,
                                      pCache,
                                      NDR_DEFAULT_CORR_CACHE_SIZE,
                                      0 /* flags */ );
            }
         }

      //
      // ----------------------------------------------------------------
      // Sizing Pass.
      // ----------------------------------------------------------------
      //

      //
      // Get the compile time computed buffer size.
      //
      pStubMsg->BufferLength = pProcHeader->ClientBufferSize;

      //
      // Check ref pointers and do object proc [out] zeroing.
      //

      for ( n = 0; n < NumberParams; n++ )
         {
         pArg = StartofStack + Params[n].StackOffset;

         if ( Params[n].ParamAttr.IsSimpleRef )
            {
            // We can raise the exception here as there is no out only args.

            if ( ! *((uchar **)pArg) )
               RpcRaiseException( RPC_X_NULL_REF_POINTER );
            }

         // [out] only argument on the Begin call.
         if ( ! Params[n].ParamAttr.IsIn &&
              Params[n].ParamAttr.IsOut  &&
              ! Params[n].ParamAttr.IsReturn)
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
         }

      //
      // Skip buffer size pass if possible.
      //
      if ( NewOiFlags.ClientMustSize )
         {
         NdrpSizing( pStubMsg, 
                     TRUE );    // IsObject
         }

      //
      // Do the GetBuffer.
      //

      pRpcMsg->RpcFlags |= RPC_BUFFER_ASYNC;

      NdrProxyGetBuffer( pThis, pStubMsg );

      NDR_ASSERT( pStubMsg->fBufferValid, "Invalid buffer" );

      pAsyncMsg->StubPhase = STUB_MARSHAL;

      //
      // ----------------------------------------------------------
      // Marshall Pass.
      // ----------------------------------------------------------
      //

      NdrpClientMarshal ( pStubMsg,
                          TRUE );   // IsObject
      //
      // Make the RPC call.
      //

      pAsyncMsg->StubPhase = NDR_ASYNC_CALL_PHASE;

      fSendCalled = NdrpDcomAsyncClientSend( pStubMsg,
                                             pAsyncPB->punkOuter );  // PM's entry
      if ( fSendCalled )
         hr = S_OK;
   }
   RpcExcept( 1 )
   {
      RPC_STATUS ExceptionCode = RpcExceptionCode();

      pAsyncPB->CallState.Flags.BeginError = 1;

      // Actually dismantle the call.
      // This is a request call and there is nothing left at the runtime.

      pAsyncMsg->StubPhase = NDR_ASYNC_ERROR_PHASE;
      pAsyncMsg->ErrorCode = ExceptionCode;

      hr = NdrHrFromWin32Error(ExceptionCode);
      pAsyncPB->CallState.Hr = hr;

      // Async call in request phase: don't touch [out] params.
   }
   RpcEndExcept

   // "Finally"
   // Dont touch anything, the client has to call the Finish method anyway.

   pAsyncPB->CallState.Flags.BeginDone = 1;
   if ( SUCCEEDED(hr) )
      {
      NdrpCloneInOnlyCorrArgs( pAsyncMsg, pAsyncMsg->StubMsg.StubDesc->pFormatTypes );
      // Channel will prompt signal
      }
   else
      if (!fSendCalled )
      NdrpAsyncProxySignal( pAsyncPB );

   // No need to release, our refcount should be 1 at this point.

   return hr;
}


void
NdrpCloneInOnlyCorrArgs(
                       NDR_DCOM_ASYNC_MESSAGE * pAsyncMsg,
                       PFORMAT_STRING           pTypeFormat
                       )
/*
    Walk the client stack looking for an in only argument flagged to clone.
    For each one, replace the arg with a clone that we control.
    Assumption is, we do it before returning to the user from the Begin call
    and also we clone walking the copy of the app's stack not the app stack.

    The stack modified in this way will be the one to access for the weird
    crossreferenced correlated args.

    This issue doesn't happen on the server, as we keep the Begin stack around
    when the Finish call is processed.

*/
{
   unsigned char  *    pBeginStack  = pAsyncMsg->BeginStack;
   PPARAM_DESCRIPTION  Params       = (PPARAM_DESCRIPTION)pAsyncMsg->BeginParams;
   int                 NumberParams = (int)pAsyncMsg->nBeginParams;
   unsigned char  *    pArg;
   int                 n;

   for ( n = 0; n < NumberParams; n++ )
      {
      if ( Params[n].ParamAttr.SaveForAsyncFinish )
         {
         // Note that the arguments that need cloning come from top level size_is,
         // length_is etc, switch_is and iid_is attributes.
         // Hence, the only types of interest are uuid clones and integral types
         // different from hyper.
         // On top of it, we deal with stack-slot chunks of memory, so we don't
         // have to care about mac issues.

         pArg = pBeginStack + Params[n].StackOffset;

         if ( Params[n].ParamAttr.IsBasetype )
            {
            if ( Params[n].ParamAttr.IsSimpleRef )
               {
               void * pPointee = AsyncAlloca( pAsyncMsg, 8 );

               // The assignment needs to follow the type.
               RpcpMemoryCopy( pPointee, *(void **)pArg, 
                               SIMPLE_TYPE_MEMSIZE( Params[n].SimpleType.Type ) );  
               *(void**)pArg = pPointee;
               }
            // else the stack slot has the simple value already.
            }
         else
            {
            // If it's not a base type, then it cannot be by value.
            // It has to be a pointer to a simple type or to an iid.

            PFORMAT_STRING  pParamFormat;

            pParamFormat = pTypeFormat +
                           Params[n].TypeOffset;

            if ( IS_BASIC_POINTER(*pParamFormat) )  // not FC_IP
               {
               if ( SIMPLE_POINTER(pParamFormat[1]) )
                  {
                  // Covers things like a unique pointer to a size
                  // Essentially the same as for the simple ref above.

                  void * pPointee = AsyncAlloca( pAsyncMsg, 8 );

                  // The assignment needs to follow the type.
                  RpcpMemoryCopy( pPointee, *(void **)pArg, 
                                  SIMPLE_TYPE_MEMSIZE( pParamFormat[2] ) );
                  *(void**)pArg = pPointee;
                  }
               else
                  {
                  // has to be the riid case.
                  // REFIID* comes out as FC_?P -> FC_?P -> FC_STRUCT

                  PFORMAT_STRING  pFormat;

                  pFormat = pParamFormat + *(short *)(pParamFormat + 2);

                  if ( IS_BASIC_POINTER(*pFormat)  &&
                       ! SIMPLE_POINTER(pParamFormat[1]) )
                     {
                     pParamFormat = pFormat + *(short *)(pFormat + 2);

                     if ( *pParamFormat == FC_STRUCT )
                        {
                        // one alloc for REFIID and IID itself.
                        IID** ppIID = 
                            (IID**)AsyncAlloca( pAsyncMsg,
                                                sizeof(IID *) + sizeof(IID));
                        IID* pIID = (IID *)(ppIID + 1);


                        *ppIID = pIID; //set pointer
                        RpcpMemoryCopy( pIID, **(IID ***)pArg, sizeof(IID));
                        *(IID ***)pArg = ppIID;
                        }
                     else
                        RpcRaiseException( RPC_S_INTERNAL_ERROR );
                     }
                  else
                     RpcRaiseException( RPC_S_INTERNAL_ERROR );
                  }
               }
            else
               {
               // has to be the riid case.
               // REFIID comes out as FC_STRUCT

               if ( *pParamFormat == FC_STRUCT )
                  {
                  IID *pIID = (IID*)AsyncAlloca( pAsyncMsg, sizeof(IID) );

                  RpcpMemoryCopy( pIID, *(IID **)pArg, sizeof(IID));
                  *(IID **)pArg = pIID;
                  }
               else
                  RpcRaiseException( RPC_S_INTERNAL_ERROR );
               }

            }

         }
      }
}


HRESULT
NdrpFinishDcomAsyncClientCall(
                             PMIDL_STUB_DESC     pStubDescriptor,
                             PFORMAT_STRING      pFormat,
                             unsigned char  *    StartofStack
                             )
{
   RPC_MESSAGE *               pRpcMsg;
   MIDL_STUB_MESSAGE *         pStubMsg;

   PFORMAT_STRING              pFormatParam;

   uchar *                     pArg;
   void *                      pThis = *(void **)StartofStack;
   CLIENT_CALL_RETURN          ReturnValue;

   INTERPRETER_FLAGS           OldOiFlags;      // Finish proc flags
   INTERPRETER_OPT_FLAGS       NewOiFlags;      //
   PPARAM_DESCRIPTION          Params;          //
   long                        NumberParams;
   long                        n;
   NDR_ASYNC_CALL_FLAGS        CallFlags;

   PNDR_DCOM_OI2_PROC_HEADER   pProcHeader = (PNDR_DCOM_OI2_PROC_HEADER)pFormat;
   PNDR_PROC_HEADER_EXTS       pHeaderExts = 0;
   CStdAsyncProxyBuffer    *   pAsyncPB;
   const IID *                 piid;
   HRESULT                     hr = S_OK;
   NDR_PROC_CONTEXT *          pContext = NULL;

   ReturnValue.Simple = 0;

   pAsyncPB = (CStdAsyncProxyBuffer*)
              ((uchar*)pThis - offsetof(CStdProxyBuffer, pProxyVtbl));

   piid = NdrGetProxyIID( pThis );

   hr = NdrpSetupFinishClientCall( pAsyncPB,
                                   StartofStack,
                                   pProcHeader->StackSize,
                                   *piid,
                                   pProcHeader->ProcNum );
   if ( !SUCCEEDED(hr) )
      return hr;

   // Note that we cant call to NdrProxyInitialize again.

   PNDR_DCOM_ASYNC_MESSAGE pAsyncMsg = 
       (PNDR_DCOM_ASYNC_MESSAGE)pAsyncPB->CallState.pAsyncMsg;

   pRpcMsg   = & pAsyncMsg->RpcMsg;
   pStubMsg  = & pAsyncMsg->StubMsg;
   pContext = ( NDR_PROC_CONTEXT * )pStubMsg->pContext;

   OldOiFlags   = pProcHeader->OldOiFlags;
   NewOiFlags   = pProcHeader->Oi2Flags;
   NumberParams = pProcHeader->NumberParams;

   //
   // Parameter descriptions are nicely spit out by MIDL.
   //
   Params = (PPARAM_DESCRIPTION)(pFormat + sizeof(NDR_DCOM_OI2_PROC_HEADER));
   if ( NewOiFlags.HasExtensions )
      {
      pHeaderExts = (NDR_PROC_HEADER_EXTS *)Params;
      Params = (PPARAM_DESCRIPTION)((uchar*)Params + pHeaderExts->Size);
      }

   CallFlags = pAsyncMsg->Flags;

   // Initialize the stack top in the stub msg to be
   // this stack, the stack for the finish call parameters.
   pAsyncMsg->nFinishParams = pContext->NumberParams = NumberParams;
   pAsyncMsg->FinishParams = pContext->Params = Params;
   pStubMsg->StackTop = pContext->StartofStack = StartofStack;

   // OLE only code path - single RpcTryExcept.
   //
   RpcTryExcept
   {
      BOOL fRaiseExcFlag = FALSE;

      if ( CallFlags.ErrorPending )
         RpcRaiseException( pAsyncMsg->ErrorCode );

      // We need to zero out the [out] parameters and to check
      // the ref pointers.

      for ( n = 0; n < NumberParams; n++ )
         {
         pArg = StartofStack + Params[n].StackOffset;

         if ( Params[n].ParamAttr.IsSimpleRef )
            {
            // We cannot raise the exception here,
            // as some out args may not be zeroed out yet.

            if ( ! *((uchar **)pArg) )
               {
               fRaiseExcFlag = TRUE;
               continue;
               }
            }

         // We do the basetype check to cover the
         // [out] simple ref to basetype case.
         //
         if ( Params[n].ParamAttr.IsPartialIgnore ||
              ( ! Params[n].ParamAttr.IsIn &&
                ! Params[n].ParamAttr.IsReturn ) )
            {
            if ( Params[n].ParamAttr.IsBasetype )
               {
               // [out] only arg can only be ref, we checked that above.
               MIDL_memset( *(uchar **)pArg, 
                            0, 
                            (size_t)SIMPLE_TYPE_MEMSIZE( Params[n].SimpleType.Type ));
               }
            else
               {
               pFormatParam = pStubDescriptor->pFormatTypes +
                              Params[n].TypeOffset;

               NdrClientZeroOut(
                               pStubMsg,
                               pFormatParam,
                               *(uchar **)pArg );
               }
            }
         }

      if ( fRaiseExcFlag )
         RpcRaiseException( RPC_X_NULL_REF_POINTER );


      NdrDcomAsyncReceive( pStubMsg );

      //
      // ----------------------------------------------------------
      // Unmarshall Pass.
      // ----------------------------------------------------------
      //

      NdrpClientUnMarshal( pStubMsg,
                           &ReturnValue );
                           
                           

      // DCOM interface must have HRESULT as return value.
      hr = (HRESULT) ReturnValue.Simple;
   }
   RpcExcept( 1 )
   {
      RPC_STATUS ExceptionCode = RpcExceptionCode();

      //
      // In OLE, since they don't know about error_status_t and wanted to
      // reinvent the wheel, check to see if we need to map the exception.
      // In either case, set the return value and then try to free the
      // [out] params, if required.
      //
      hr = NdrHrFromWin32Error(ExceptionCode);

      //
      // Set the Buffer endpoints so the NdrFree routines work.
      //
      pStubMsg->BufferStart = 0;
      pStubMsg->BufferEnd   = 0;

      for ( n = 0; n < NumberParams; n++ )
         {
         //
         // Skip everything but [out] only parameters.  We make
         // the basetype check to cover [out] simple ref pointers
         // to basetypes.
         //
         if ( !Params[n].ParamAttr.IsPartialIgnore )
             {
             if ( Params[n].ParamAttr.IsIn ||
                  Params[n].ParamAttr.IsReturn ||
                  Params[n].ParamAttr.IsBasetype )
                continue;
             }

         pArg = StartofStack + Params[n].StackOffset;

         pFormatParam = pStubDescriptor->pFormatTypes +
                        Params[n].TypeOffset;

         NdrClearOutParameters( pStubMsg,
                                pFormatParam,
                                *((uchar **)pArg) );
         }
   }
   RpcEndExcept

   // Finish
   // Cleanup everything. However, don't free pAsyncPB itself.

   NdrpAsyncProxyMsgDestructor( pAsyncPB );

   //  Never addref or release async proxy object, this is app's/PM's job.

   return hr;
}


HRESULT RPC_ENTRY
NdrDcomAsyncStubCall(
                    struct IRpcStubBuffer *     pThis,
                    struct IRpcChannelBuffer *  pChannel,
                    PRPC_MESSAGE                pRpcMsg,
                    ulong *                     pdwStubPhase
                    )
/*++

Routine Description :

    Server Interpreter entry point for DCOM async procs.
    This is the Begin entry for channel (regular dispatch entry from stub.c).
    The Finish happen when the channel calls stub's Synchronize::Signal method
    on the stub object. The call then comes to NdrpAsyncStubSignal later below.

Arguments :

    pThis           - Object proc's 'this' pointer.
    pChannel        - Object proc's Channel Buffer.
    pRpcMsg         - The RPC message.
    pdwStubPhase    - Used to track the current interpreter's activity.

Return :

    Status of S_OK.

Notes :
    The engine never calls a signal on behalf of the user, regardless what kind of
    errors happen during begin (cannot setup begin, cannot unmarshal, app dies in invoke).
    In each of these cases, the engine simply returns an error code to the channel.

    The only time the engine would call FreeBuffer on the server is if the engine died
    between a successful GetBuffer and the final Send.

Notes on OLE Refcounting.
    The model for async_uuid() is that async proxies or stubs are created
    with RefCount==1 and should never ever be addrefed by the engine.
    What the engine does is only the AsyncMsg clean up when done.

    The decision to destroy the AsyncPB or AsyncSB object is
    up to the client side PM or channel's SM for the server side.
*/
{
   PNDR_DCOM_ASYNC_MESSAGE     pAsyncMsg;

   PMIDL_SERVER_INFO           pServerInfo;
   PMIDL_STUB_DESC             pStubDesc;
   const SERVER_ROUTINE  *     DispatchTable;
   unsigned long               ProcNum;

   ushort                      FormatOffset;
   PFORMAT_STRING              pFormat;
   PFORMAT_STRING              pFormatParam;

   PMIDL_STUB_MESSAGE          pStubMsg;

   uchar *                     pArgBuffer;
   uchar *                     pArg;
   uchar **                    ppArg;

   PPARAM_DESCRIPTION          Params;
   INTERPRETER_FLAGS           OldOiFlags;
   INTERPRETER_OPT_FLAGS       NewOiFlags;
   long                        NumberParams;

   BOOL                        fBadStubDataException = FALSE;
   BOOL                        fManagerCodeInvoked = FALSE;
   long                        n;
   PNDR_DCOM_OI2_PROC_HEADER   pProcHeader;
   PNDR_PROC_HEADER_EXTS       pHeaderExts = 0;

   CStdAsyncStubBuffer *       pAsyncSB;

   HRESULT                     hr;

   const IID *                 piid = 0;
   BOOL                        fErrorInInvoke = FALSE;
   BOOL                        fRecoverableErrorInInvoke = FALSE;

   IUnknown *                  pSrvObj;
   CInterfaceStubVtbl *        pStubVTable;
   NDR_PROC_CONTEXT *          pContext = NULL ;
   RPC_STATUS                  ExceptionCode = 0;

   NDR_ASSERT( ! ((ULONG_PTR)pRpcMsg->Buffer & 0x7),
               "marshaling buffer misaligned at server" );

   // The channel dispatches to the engine with the sync proc num.
   // We need only async proc num at the engine level.
   ProcNum = pRpcMsg->ProcNum;
   ProcNum = 2 * ProcNum - 3;  // Begin method #

   pSrvObj = (IUnknown *)((CStdStubBuffer *)pThis)->pvServerObject;
   DispatchTable = (SERVER_ROUTINE *)pSrvObj->lpVtbl;

   pStubVTable = (CInterfaceStubVtbl *)
                 (*((uchar **)pThis) - sizeof(CInterfaceStubHeader));

   piid        = pStubVTable->header.piid;
   pServerInfo = (PMIDL_SERVER_INFO) pStubVTable->header.pServerInfo;

   pStubDesc    = pServerInfo->pStubDesc;
   FormatOffset = pServerInfo->FmtStringOffset[ ProcNum ];
   pFormat   = &((pServerInfo->ProcString)[FormatOffset]);

   // The proc header has a fixed layout now.

   pProcHeader = (PNDR_DCOM_OI2_PROC_HEADER) pFormat;

   pAsyncSB = (CStdAsyncStubBuffer *)
              ((uchar *)pThis - offsetof(CStdAsyncStubBuffer,lpVtbl));

   hr = NdrpSetupBeginStubCall( pAsyncSB,
                                pProcHeader->StackSize,
                                *piid );
   if ( FAILED(hr) )
      return hr;

   pAsyncMsg = (PNDR_DCOM_ASYNC_MESSAGE)pAsyncSB->CallState.pAsyncMsg;
   pStubMsg  = & pAsyncMsg->StubMsg;
   pContext = &pAsyncMsg->ProcContext;

   // Both rpc runtime and channel require that we use a copy of the rpc message.

   RpcpMemoryCopy( & pAsyncMsg->RpcMsg, pRpcMsg, sizeof(RPC_MESSAGE) );
   pRpcMsg = & pAsyncMsg->RpcMsg;

   pRpcMsg->RpcFlags |= RPC_BUFFER_ASYNC;

   // The arg buffer is zeroed out already.
   pArgBuffer = pAsyncMsg->ProcContext.StartofStack;

   //
   // Get new interpreter info.
   //
   OldOiFlags   = pProcHeader->OldOiFlags;
   NewOiFlags   = pProcHeader->Oi2Flags;
   NumberParams = pProcHeader->NumberParams;

   Params = (PPARAM_DESCRIPTION)(pFormat + sizeof(NDR_DCOM_OI2_PROC_HEADER));

   if ( NewOiFlags.HasExtensions )
      {
      pHeaderExts = (NDR_PROC_HEADER_EXTS *)Params;
      Params = (PPARAM_DESCRIPTION)((uchar*)Params + pHeaderExts->Size);
      }

   pAsyncMsg->nBeginParams = pContext->NumberParams = NumberParams;
   pAsyncMsg->BeginParams  = pContext->Params     = Params;
   pAsyncMsg->pThis            = pThis;
   pContext->DceTypeFormatString = pStubDesc->pFormatTypes;

   //
   // Wrap the unmarshalling and the invoke call in the try block of
   // a try-finally. Put the free phase in the associated finally block.
   //
   // We abstract the level of indirection here.

   RpcTryFinally
   {
      // OLE: put pThis in first dword of stack.
      //
      ((void **)pArgBuffer)[0] = ((CStdStubBuffer *)pThis)->pvServerObject;

      // Initialize the Stub message.
      //
      NdrStubInitialize( pRpcMsg,
                         pStubMsg,
                         pStubDesc,
                         pChannel );

      pStubMsg->pAsyncMsg     = (struct _NDR_ASYNC_MESSAGE *) pAsyncMsg;

      pAsyncMsg->pdwStubPhase = pdwStubPhase;    // the phase is STUB_UNMARSHAL

      // Raise exceptions after initializing the stub.

      if ( OldOiFlags.FullPtrUsed )
         pStubMsg->FullPtrXlatTables = NdrFullPointerXlatInit( 0, XLAT_SERVER );
      else
         pStubMsg->FullPtrXlatTables = 0;

      //
      // Set StackTop AFTER the initialize call, since it zeros the field
      // out.
      //
      pStubMsg->StackTop  = pArgBuffer;

      if ( NewOiFlags.HasExtensions )
         {
         pStubMsg->fHasExtensions  = 1;
         pStubMsg->fHasNewCorrDesc = pHeaderExts->Flags2.HasNewCorrDesc;

         if ( pHeaderExts->Flags2.ServerCorrCheck )
            {
            void * pCache = NdrpAlloca( &pAsyncMsg->ProcContext.AllocateContext, NDR_DEFAULT_CORR_CACHE_SIZE );
            
            NdrCorrelationInitialize( pStubMsg,
                                      pCache,
                                      NDR_DEFAULT_CORR_CACHE_SIZE,
                                      0 /* flags */ );
            }
         }

      // StubPhase set up by invoke is STUB_UNMARSHAL

      RpcTryExcept
      {

         // --------------------------------
         // Unmarshall all of our parameters.
         // --------------------------------

        NdrpServerUnMarshal( pStubMsg );   
                             

      }

      // Last ditch checks.

      if ( pRpcMsg->BufferLength  <
           (uint)(pStubMsg->Buffer - (uchar *)pRpcMsg->Buffer) )
         {
         RpcRaiseException( RPC_X_BAD_STUB_DATA );
         }


      RpcExcept( NdrServerUnmarshallExceptionFlag(GetExceptionInformation()) )
      {
         ExceptionCode = RpcExceptionCode();
         // Filter set in rpcndr.h to catch one of the following
         //     STATUS_ACCESS_VIOLATION
         //     STATUS_DATATYPE_MISALIGNMENT
         //     RPC_X_BAD_STUB_DATA

         fBadStubDataException = TRUE;

         pAsyncMsg->Flags.BadStubData  = 1;
         pAsyncMsg->Flags.ErrorPending = 1;

         if ( RPC_BAD_STUB_DATA_EXCEPTION_FILTER )
            {
            ExceptionCode = RPC_X_BAD_STUB_DATA;
            }
         pAsyncMsg->ErrorCode = ExceptionCode;

         pAsyncSB->CallState.Flags.BeginError = 1;
         pAsyncSB->CallState.Hr = NdrHrFromWin32Error( ExceptionCode);
         NdrpFreeMemoryList( pStubMsg );

         RpcRaiseException( ExceptionCode );

      }
      RpcEndExcept

      //
      // Do [out] initialization before the invoke.
      //
      for ( n = 0; n < NumberParams; n++ )
         {
         if ( Params[n].ParamAttr.IsIn     ||
              Params[n].ParamAttr.IsReturn )
            continue;

         // This is a Begin call, there cannot be any [out] only args.

         RpcRaiseException( RPC_S_INTERNAL_ERROR );
         }


      //
      // OLE interfaces use pdwStubPhase in the exception filter.
      // See CStdStubBuffer_Invoke in stub.c.
      //
      *pdwStubPhase = STUB_CALL_SERVER;

      // We need to catch exception in the manager code separately
      // as the model implies that there will be no other call from
      // the server app to clean up.

      pAsyncSB->CallState.Flags.BeginDone = 1;

      RpcTryExcept
      {
         //
         // Check for a thunk.  Compiler does all the setup for us.
         //
         if ( pServerInfo->ThunkTable && pServerInfo->ThunkTable[ ProcNum ] )
            {
            fManagerCodeInvoked = TRUE;
            pServerInfo->ThunkTable[ ProcNum ]( pStubMsg );
            }
         else
            {
            //
            // Note that this ArgNum is not the number of arguments declared
            // in the function we called, but really the number of
            // REGISTER_TYPEs occupied by the arguments to a function.
            //
            long                ArgNum;
            MANAGER_FUNCTION    pFunc;
            REGISTER_TYPE       ReturnValue;

            pFunc  = (MANAGER_FUNCTION) DispatchTable[ ProcNum ];
            ArgNum = (long)pProcHeader->StackSize  / sizeof(REGISTER_TYPE);

            //
            // The StackSize includes the size of the return. If we want
            // just the number of REGISTER_TYPES, then ArgNum must be reduced
            // by 1 when there is a return value AND the current ArgNum count
            // is greater than 0.
            //
            if ( ArgNum && NewOiFlags.HasReturn )
               ArgNum--;

            // Being here means that we can expect results. Note that the user
            // can call RpcCompleteCall from inside of the manager code.

            fManagerCodeInvoked = TRUE;
            ReturnValue = Invoke( pFunc,
                                  (REGISTER_TYPE *)pArgBuffer,
#if defined(_WIN64)
                                  NewOiFlags.HasExtensions ? ((PNDR_PROC_HEADER_EXTS64)pHeaderExts)->FloatArgMask
                                  : 0,
#endif
                                  ArgNum);

            if ( NewOiFlags.HasReturn )
               {
               // Pass the app's HR from Begin call to the channel.
               (*pfnDcomChannelSetHResult)( pRpcMsg, 
                                            NULL,   // reserved
                                            (HRESULT) ReturnValue);
               }

            // We are discarding the return value as it is not the real one.
            }
      }
      RpcExcept( 1 )
      {
         fErrorInInvoke = TRUE;

         pAsyncMsg->Flags.ErrorPending = 1;
         pAsyncMsg->ErrorCode = RpcExceptionCode();

         pAsyncSB->CallState.Flags.BeginError = 1;
         pAsyncSB->CallState.Hr = NdrHrFromWin32Error( RpcExceptionCode());
      }
      RpcEndExcept

      //  Done with invoking Begin
   }
   RpcFinally
   {
      if ( !fManagerCodeInvoked )
         {
         // Failed without invoking Begin - return an error. Remember the error.

         if ( fBadStubDataException )
            pAsyncMsg->ErrorCode = RPC_X_BAD_STUB_DATA;

         pAsyncSB->CallState.Flags.BeginDone = 1;
         hr = pAsyncSB->CallState.Hr;
         }
      else // fManagerCodeInvoked
         {
         hr = S_OK;

         if ( fErrorInInvoke )
            hr = pAsyncSB->CallState.Hr;
         }
   }
   RpcEndFinally

   return hr;
}



void
NdrpCloneInOutStubArgs(
                      NDR_DCOM_ASYNC_MESSAGE * pAsyncMsg )
/*
    Walk the second stack looking for an in-out argument.
    For each one, find the corresponding in-out atgument from the first stack
    and clone it to the second stack.

    Note, we need to do it only on the server side where we preserver the first
    stack, the dispatch buffer and all the arguments from the first stack. 

    On the client, this is the app's task to supply meaningful in-out arguments
    for the second stack.
*/
{
   REGISTER_TYPE *   pBeginStack  = (REGISTER_TYPE *)pAsyncMsg->BeginStack;
   REGISTER_TYPE *   pFinishStack = (REGISTER_TYPE *)pAsyncMsg->FinishStack;

   PPARAM_DESCRIPTION  BeginParams       = (PPARAM_DESCRIPTION)pAsyncMsg->BeginParams;
   int                 BeginNumberParams = (int)pAsyncMsg->nBeginParams;

   PPARAM_DESCRIPTION  FinishParams       = (PPARAM_DESCRIPTION)pAsyncMsg->FinishParams;
   int                 FinishNumberParams = pAsyncMsg->nFinishParams;

   int FirstIO = 0;
   int n;

   for ( n = 0; n < FinishNumberParams; n++ )
      {
      // Find in-out arg that needs cloning.

      if ( FinishParams[n].ParamAttr.IsIn  &&
           FinishParams[n].ParamAttr.IsOut )
         {
         // Find the first IO on the first stack

         while ( FirstIO < BeginNumberParams )
            {
            if ( BeginParams[ FirstIO ].ParamAttr.IsIn  &&
                 BeginParams[ FirstIO ].ParamAttr.IsOut )
               {
               break;
               }

            FirstIO++;
            }

         if ( BeginNumberParams <= FirstIO )
            RpcRaiseException( RPC_S_INTERNAL_ERROR );

         // Clone it to the second stack

         pFinishStack[ FinishParams[n].StackOffset / sizeof(REGISTER_TYPE) ] =
         pBeginStack[ BeginParams[ FirstIO ].StackOffset / sizeof(REGISTER_TYPE) ];
         FirstIO++;
         }
      }
}


HRESULT
NdrpCompleteDcomAsyncStubCall(
                             CStdAsyncStubBuffer *   pAsyncSB
                             )
/*++

Routine Description :

    Complete an async call on the server side.

Arguments :

    AsyncHandle  - raw or object handle (if pointer) as appropriate,
    pAsyncMsg    - pointer to async msg structure,
    pReturnValue - from the user to pass back to caller.

Return :

    Status of S_OK.

--*/
{
   PNDR_DCOM_ASYNC_MESSAGE     pAsyncMsg;

   PMIDL_SERVER_INFO           pServerInfo;
   PMIDL_STUB_DESC             pStubDesc;      // should be the same
   const SERVER_ROUTINE  *     DispatchTable;  // should be the same
   unsigned long               ProcNum;        // should be 1+

   ushort                      FormatOffset;
   PFORMAT_STRING              pFormat;
   PFORMAT_STRING              pFormatParam;

   RPC_MESSAGE *               pRpcMsg;
   MIDL_STUB_MESSAGE *         pStubMsg;

   INTERPRETER_FLAGS           OldOiFlags;     // Finish flags
   INTERPRETER_OPT_FLAGS       NewOiFlags;     // Finish flags
   PPARAM_DESCRIPTION          Params;         // Finish params
   uchar *                     pArgBuffer;     // new stack
   
   // MZ, BUG BUG, Fix after ship
   // ulong *                     pdwStubPhase;
 
   uchar *                     pArg;

   long                        NumberParams;
   long                        n;
   PNDR_DCOM_OI2_PROC_HEADER   pProcHeader;
   PNDR_PROC_HEADER_EXTS       pHeaderExts = 0;

   IUnknown *                  pSrvObj;
   CInterfaceStubVtbl *        pStubVTable;
   void *                      pThis;

   HRESULT                     hr;
   const IID *                 piid;           // should be the same

   BOOL                        fManagerCodeInvoked = FALSE;
   BOOL                        fErrorInInvoke = FALSE;
   RPC_STATUS                  ExceptionCode = 0;
   boolean                     fParamsFreed = FALSE;
   NDR_PROC_CONTEXT *          pContext = NULL;

   // We validated both the stub and the async context in the signal call.

   // We validated the pAsyncSB in the Signal call.
   // Do additional checks.

   pAsyncMsg = (PNDR_DCOM_ASYNC_MESSAGE)pAsyncSB->CallState.pAsyncMsg;
   pThis     = pAsyncMsg->pThis;

   // See if channel calls on the right stub
   if ( & pAsyncSB->lpVtbl != pThis)
      return E_INVALIDARG;


   pRpcMsg   = & pAsyncMsg->RpcMsg;
   pStubMsg  = & pAsyncMsg->StubMsg;
   // We have preserved the sync proc num that the channel used.
   // We need only async proc num at the engine level.
   //

   ProcNum = pRpcMsg->ProcNum;
   ProcNum = 2 * ProcNum - 3 + 1;  // Finish method #

   pSrvObj = (IUnknown *)((CStdStubBuffer *)pThis)->pvServerObject;
   DispatchTable = (SERVER_ROUTINE *)pSrvObj->lpVtbl;

   pStubVTable = (CInterfaceStubVtbl *)
                 (*((uchar **)pThis) - sizeof(CInterfaceStubHeader));

   piid        = pStubVTable->header.piid;
   pServerInfo = (PMIDL_SERVER_INFO) pStubVTable->header.pServerInfo;

   pStubDesc    = pServerInfo->pStubDesc;
   FormatOffset = pServerInfo->FmtStringOffset[ ProcNum ];
   pFormat   = &((pServerInfo->ProcString)[ FormatOffset ]);

   // The proc header has a fixed layout now.

   pProcHeader = (PNDR_DCOM_OI2_PROC_HEADER) pFormat;

   // Validate and setup for finish.

   hr = NdrpSetupFinishStubCall( pAsyncSB,
                                 pProcHeader->StackSize,
                                 *piid );
   if ( hr )
      return hr;

   // The arg buffer is zeroed out already. Note, this is the second stack.

   pContext = &pAsyncMsg->ProcContext;
   pArgBuffer = pContext->StartofStack;
   pStubMsg->StackTop = pArgBuffer;
   
   //
   // Get new interpreter info.
   //
   OldOiFlags   = pProcHeader->OldOiFlags;
   NewOiFlags   = pProcHeader->Oi2Flags;
   NumberParams = pProcHeader->NumberParams;

   Params = (PPARAM_DESCRIPTION)(pFormat + sizeof(NDR_DCOM_OI2_PROC_HEADER));

   if ( NewOiFlags.HasExtensions )
      {
      pHeaderExts = (NDR_PROC_HEADER_EXTS *)Params;
      Params = (PPARAM_DESCRIPTION)((uchar*)Params + pHeaderExts->Size);
      }

   pAsyncMsg->nFinishParams = pContext->NumberParams = NumberParams;
   pAsyncMsg->FinishParams = pContext->Params = Params;
   pContext->DceTypeFormatString = pStubDesc->pFormatTypes;
   pStubMsg->pContext = pContext;

   // Wrap the unmarshalling, mgr call and marshalling in the try block of
   // a try-finally. Put the free phase in the associated finally block.
   //
   RpcTryFinally
   {
      if ( pAsyncMsg->Flags.ErrorPending )
         RpcRaiseException( pAsyncMsg->ErrorCode );

      // Initialize the args of the new stack.

      // OLE: put pThis in first dword of stack.
      //
      ((void **)pArgBuffer)[0] = ((CStdStubBuffer *)pThis)->pvServerObject;

      //
      // Do [out] initialization before invoking Finish
      //

      NdrpCloneInOutStubArgs( pAsyncMsg );
      NdrpServerOutInit( pStubMsg );


      //
      // OLE interfaces use pdwStubPhase in the exception filter.
      // See CStdStubBuffer_Invoke in stub.c.
      //

      // MZ, BUG BUG, fix after ship
      // *pdwStubPhase = STUB_CALL_SERVER;

      // We need to catch exception in the manager code separately
      // as the model implies that there will be no other call from
      // the server app to clean up.

      RpcTryExcept
      {
         //
         // Check for a thunk.  Compiler does all the setup for us.
         //
         if ( pServerInfo->ThunkTable && pServerInfo->ThunkTable[ProcNum] )
            {
            fManagerCodeInvoked = TRUE;
            pServerInfo->ThunkTable[ProcNum]( pStubMsg );
            }
         else
            {
            //
            // Note that this ArgNum is not the number of arguments declared
            // in the function we called, but really the number of
            // REGISTER_TYPEs occupied by the arguments to a function.
            //
            long                ArgNum;
            MANAGER_FUNCTION    pFunc;
            REGISTER_TYPE       ReturnValue;

            pFunc  = (MANAGER_FUNCTION) DispatchTable[ProcNum];
            ArgNum = (long)pProcHeader->StackSize / sizeof(REGISTER_TYPE);

            //
            // The StackSize includes the size of the return. If we want
            // just the number of REGISTER_TYPES, then ArgNum must be reduced
            // by 1 when there is a return value AND the current ArgNum count
            // is greater than 0.
            //
            if ( ArgNum && NewOiFlags.HasReturn )
               ArgNum--;

            fManagerCodeInvoked = TRUE;
            ReturnValue = Invoke( pFunc,
                                  (REGISTER_TYPE *)pArgBuffer,
#if defined(_WIN64)
                                  NewOiFlags.HasExtensions ? ((PNDR_PROC_HEADER_EXTS64)pHeaderExts)->FloatArgMask
                                  : 0,
#endif
                                  ArgNum);

            // This is the return value that should be marshaled back.
            if ( NewOiFlags.HasReturn )
               {
               ((REGISTER_TYPE *)pArgBuffer)[ArgNum] = ReturnValue;
               // Pass the app's HR to the channel.
               (*pfnDcomChannelSetHResult)( pRpcMsg, 
                                            NULL,   // reserved
                                            (HRESULT) ReturnValue);
               }
            }
      }
      RpcExcept( 1 )
      {
         pAsyncMsg->Flags.ErrorPending = 1;

         pAsyncMsg->ErrorCode = RpcExceptionCode();
         fErrorInInvoke = TRUE;
      }
      RpcEndExcept

      //  Done with invoking Finish

      if ( pAsyncMsg->Flags.ErrorPending )
         RpcRaiseException( pAsyncMsg->ErrorCode );

      //
      // Buffer size pass.
      //
      pStubMsg->BufferLength = pProcHeader->ServerBufferSize;

      if ( NewOiFlags.ServerMustSize )
         {
         NdrpSizing( pStubMsg, 
                     FALSE );       // IsClient
         }

      // Get buffer.

      NdrStubGetBuffer( (IRpcStubBuffer*)pAsyncMsg->pThis,
                        pStubMsg->pRpcChannelBuffer,
                        pStubMsg );

      //
      // Marshall pass.
      //
      NdrpServerMarshal( pStubMsg, 
                         TRUE );    // IsObject
                         

      if ( pRpcMsg->BufferLength <
           (uint)(pStubMsg->Buffer - (uchar *)pRpcMsg->Buffer) )
         {
         NDR_ASSERT( 0, "NdrStubCall2 marshal: buffer overflow!" );
         RpcRaiseException( RPC_X_BAD_STUB_DATA );
         }

      pRpcMsg->BufferLength = (ulong)(pStubMsg->Buffer - (uchar *)pRpcMsg->Buffer);

      // We don't drop to the runtime like for synchronous calls,
      // we send the last buffer explicitly.

      fParamsFreed = TRUE;
      // see comment on async.cxx on why we call this twice.

      NdrpAsyncDCOMFreeParams( pAsyncMsg );

      NdrpDcomAsyncSend( pStubMsg,
                         0 );  // server doesn't pass pSynchronize back to channel.
   }
   RpcFinally
   {
      // Don't free parameters if we died because of bad stub data in unmarshaling.

      if ( ! pAsyncMsg->Flags.BadStubData && !fParamsFreed)
         {

         NdrpAsyncDCOMFreeParams( pAsyncMsg );

         }

      if ( pAsyncMsg->Flags.ErrorPending )
         hr = NdrHrFromWin32Error( pAsyncMsg->ErrorCode );
      else
         hr = S_OK;

      // If we are here, error or not, it means that we can (and need to) dispose of
      // the async context information

      NdrpAsyncStubMsgDestructor( pAsyncSB );

      // The engine never addrefs or releases the call object.
   }
   RpcEndFinally

   return hr;
}


HRESULT
NdrpAsyncProxyMsgConstructor(
                            CStdAsyncProxyBuffer * pAsyncPB )
{
   NdrDcomAsyncCallState * pCallState = & pAsyncPB->CallState;

   pCallState->Lock = 0;
   pCallState->Signature = NDR_ASYNC_PROXY_SIGNATURE;
   pCallState->pAsyncMsg = 0;
   *((long*)&pCallState->Flags) = 0;
   pCallState->Hr = 0;

   return S_OK;
}

HRESULT
NdrpAsyncStubMsgConstructor(
                           CStdAsyncStubBuffer * pAsyncSB )
{
   NdrDcomAsyncCallState * pCallState = & pAsyncSB->CallState;

   pCallState->Lock = 0;
   pCallState->Signature = NDR_ASYNC_STUB_SIGNATURE;
   pCallState->pAsyncMsg = 0;
   *((long*)&pCallState->Flags) = 0;
   pCallState->Hr = 0;

   return S_OK;
}


HRESULT
NdrpAsyncProxyMsgDestructor(
                           CStdAsyncProxyBuffer * pAsyncPB )
{
   NdrDcomAsyncCallState * pCallState = & pAsyncPB->CallState;

   if ( pCallState->pAsyncMsg )
      {
      NdrpFreeDcomAsyncMsg( (PNDR_DCOM_ASYNC_MESSAGE)pCallState->pAsyncMsg );
      pCallState->pAsyncMsg = 0;
      }
   *((long*)&pCallState->Flags) = 0;
   pCallState->Hr = 0;

   return S_OK;
}

HRESULT
NdrpAsyncStubMsgDestructor(
                          CStdAsyncStubBuffer * pAsyncSB )
{
   NdrDcomAsyncCallState * pCallState = & pAsyncSB->CallState;

   if ( pCallState->pAsyncMsg )
      {
      NdrpFreeDcomAsyncMsg( (PNDR_DCOM_ASYNC_MESSAGE)pCallState->pAsyncMsg );
      pCallState->pAsyncMsg = 0;
      }
   *((long*)&pCallState->Flags) = 0;
   pCallState->Hr = 0;

   return S_OK;
}


HRESULT
NdrpValidateAsyncProxyCall(
                          CStdAsyncProxyBuffer *  pAsyncPB
                          )
{
   HRESULT  hr = S_OK;

   RpcTryExcept
   {
      NdrDcomAsyncCallState * pCallState = & pAsyncPB->CallState;

      if ( pCallState->Signature != NDR_ASYNC_PROXY_SIGNATURE )
         hr = E_INVALIDARG;
   }
   RpcExcept(1)
   {
      hr = E_INVALIDARG;
   }
   RpcEndExcept;

   return hr;
}

HRESULT
NdrpValidateAsyncStubCall(
                         CStdAsyncStubBuffer *  pAsyncSB
                         )
{
   HRESULT  hr = S_OK;

   RpcTryExcept
   {
      NdrDcomAsyncCallState * pCallState = & pAsyncSB->CallState;

      if ( pCallState->Signature != NDR_ASYNC_STUB_SIGNATURE )
         hr = E_INVALIDARG;
   }
   RpcExcept(1)
   {
      hr = E_INVALIDARG;
   }
   RpcEndExcept;

   return hr;
}

HRESULT
NdrpValidateDcomAsyncMsg(
                        PNDR_DCOM_ASYNC_MESSAGE  pAsyncMsg )
{
   HRESULT  hr = RPC_S_OK;

   RpcTryExcept
   {
      if ( pAsyncMsg->Signature != NDR_DCOM_ASYNC_SIGNATURE ||
           pAsyncMsg->Version   != NDR_DCOM_ASYNC_VERSION )
         {
         hr = E_INVALIDARG;
         }
   }
   RpcExcept(1)
   {
      hr = E_INVALIDARG;
   }
   RpcEndExcept;

   return hr;
}


HRESULT
NdrpSetupBeginClientCall(
                        CStdAsyncProxyBuffer *  pAsyncPB,
                        void *                  StartofStack,
                        unsigned short          StackSize,
                        REFIID                  riid )
/*
    This method creates and initializes async msg.
*/
{
   PNDR_DCOM_ASYNC_MESSAGE     pAsyncMsg;
   HRESULT                     hr = S_OK;

   hr = NdrpValidateAsyncProxyCall( pAsyncPB );
   if ( ! SUCCEEDED(hr) )
      return hr;

   if ( pAsyncPB->CallState.pAsyncMsg != 0  ||
        pAsyncPB->CallState.Flags.BeginStarted )
      return E_FAIL;

   // Do this first to simplify error conditions.

   pAsyncMsg = (NDR_DCOM_ASYNC_MESSAGE*)
               I_RpcBCacheAllocate( sizeof(NDR_DCOM_ASYNC_MESSAGE) +
                                    StackSize + NDR_ASYNC_GUARD_SIZE );
   if ( ! pAsyncMsg )
      {
      NdrpAsyncProxySignal( pAsyncPB );
      return E_OUTOFMEMORY;
      }

   // Initialize the async message properly

   MIDL_memset( pAsyncMsg, 0x0, sizeof( NDR_DCOM_ASYNC_MESSAGE) );

   pAsyncMsg->Signature = NDR_DCOM_ASYNC_SIGNATURE;
   pAsyncMsg->Version   = NDR_DCOM_ASYNC_VERSION;
   pAsyncMsg->SyntaxType = XFER_SYNTAX_DCE;

   pAsyncMsg->ProcContext.StartofStack = (uchar *) & pAsyncMsg->AppStack;
   pAsyncMsg->BeginStack   = (uchar *) & pAsyncMsg->AppStack;
   pAsyncMsg->BeginStackSize = StackSize;
   pAsyncMsg->StubPhase    = NDR_ASYNC_PREP_PHASE;

   NdrpAllocaInit( &pAsyncMsg->ProcContext.AllocateContext );

   // Client: copy stack from the app's request call.
   RpcpMemoryCopy( & pAsyncMsg->AppStack, StartofStack, StackSize );

   MIDL_memset( ((char *)& pAsyncMsg->AppStack) + StackSize,
                0x71,
                NDR_ASYNC_GUARD_SIZE );

   pAsyncMsg->pAsyncPB = pAsyncPB;
   pAsyncPB->CallState.Flags.BeginStarted = 1;
   pAsyncPB->CallState.pAsyncMsg          = pAsyncMsg;

   return S_OK;
}


HRESULT
NdrpSetupFinishClientCall(
                         CStdAsyncProxyBuffer *  pAsyncPB,
                         void *                  StartofStack,
                         unsigned short          StackSize,
                         REFIID                  riid,
                         unsigned long           FinishProcNum )
/*
    This method creates and initializes async msg.
*/
{
   PNDR_DCOM_ASYNC_MESSAGE  pAsyncMsg;
   HRESULT                  hr = S_OK;

   hr = NdrpValidateAsyncProxyCall( pAsyncPB );
   if ( ! SUCCEEDED(hr) )
      return hr;

   if ( !pAsyncPB->CallState.Flags.BeginStarted  ||
        !pAsyncPB->CallState.Flags.BeginDone     ||
        pAsyncPB->CallState.Flags.FinishStarted )
      return E_FAIL;

   pAsyncMsg = (PNDR_DCOM_ASYNC_MESSAGE)pAsyncPB->CallState.pAsyncMsg;

   hr = NdrpValidateDcomAsyncMsg( pAsyncMsg );
   if ( ! SUCCEEDED(hr) )
      return hr;

   if ( (FinishProcNum + 3)/2  != (pAsyncMsg->RpcMsg.ProcNum & 0x7fff) )
      return E_FAIL;

   // Initialize the async message properly

   pAsyncMsg->ProcContext.StartofStack = (uchar *) StartofStack;
   pAsyncMsg->FinishStack  = (uchar *) StartofStack;
   pAsyncMsg->FinishStackSize = StackSize;
   pAsyncMsg->StubPhase    = NDR_ASYNC_PREP_PHASE;
   NdrSetupLowStackMark( &pAsyncMsg->StubMsg );
   // Dont allocate or copy the new stack anywhere.

   pAsyncPB->CallState.Flags.FinishStarted = 1;

   return S_OK;
}


HRESULT
NdrpSetupBeginStubCall(
                      CStdAsyncStubBuffer *   pAsyncSB,
                      unsigned short          StackSize,
                      REFIID                  riid )
/*
    This method creates and initializes async msg.

*/
{
   PNDR_DCOM_ASYNC_MESSAGE     pAsyncMsg;
   HRESULT                     hr = S_OK;

   hr = NdrpValidateAsyncStubCall( pAsyncSB );
   if ( ! SUCCEEDED(hr) )
      return hr;

   if ( pAsyncSB->CallState.pAsyncMsg != 0  ||
        pAsyncSB->CallState.Flags.BeginStarted )
      hr = E_FAIL;
   else
      {
      pAsyncMsg = (NDR_DCOM_ASYNC_MESSAGE*)
                  I_RpcBCacheAllocate( sizeof( NDR_DCOM_ASYNC_MESSAGE) +
                                       StackSize + NDR_ASYNC_GUARD_SIZE );
      if ( ! pAsyncMsg )
         hr = E_OUTOFMEMORY;
      }

   if ( ! SUCCEEDED(hr) )
      {
      // The stub never signals.

      pAsyncSB->CallState.Flags.BeginError = 1;
      pAsyncSB->CallState.Hr = hr;
      return hr;
      }

   // Initialize the async message properly

   MIDL_memset( pAsyncMsg, 0x0, sizeof( NDR_DCOM_ASYNC_MESSAGE) );

   pAsyncMsg->Signature = NDR_DCOM_ASYNC_SIGNATURE;
   pAsyncMsg->Version   = NDR_DCOM_ASYNC_VERSION;
   pAsyncMsg->SyntaxType = XFER_SYNTAX_DCE;

   pAsyncMsg->ProcContext.StartofStack = (uchar *) & pAsyncMsg->AppStack;
   pAsyncMsg->BeginStack   = (uchar *) & pAsyncMsg->AppStack;
   pAsyncMsg->BeginStackSize = StackSize;
   pAsyncMsg->StubPhase    = STUB_UNMARSHAL;
   pAsyncMsg->StubMsg.pContext = &pAsyncMsg->ProcContext;

   NdrpAllocaInit( &pAsyncMsg->ProcContext.AllocateContext );

   // Server: zero out stack for allocs.
   MIDL_memset( & pAsyncMsg->AppStack, 0x0, StackSize );

   MIDL_memset( ((char *)& pAsyncMsg->AppStack) + StackSize,
                0x71,
                NDR_ASYNC_GUARD_SIZE );

   pAsyncSB->CallState.pAsyncMsg = pAsyncMsg;
   pAsyncSB->CallState.Flags.BeginStarted = 1;
   pAsyncMsg->pAsyncSB = pAsyncSB;

   return S_OK;
}


HRESULT
NdrpSetupFinishStubCall(
                       CStdAsyncStubBuffer *   pAsyncSB,
                       unsigned short          StackSize,
                       REFIID                  riid )
/*
    This method creates and initializes async msg.

*/
{
   PNDR_DCOM_ASYNC_MESSAGE  pAsyncMsg;
   uchar *                  pFinishStack;
   HRESULT                     hr = S_OK;

   hr = NdrpValidateAsyncStubCall( pAsyncSB );
   if ( ! SUCCEEDED(hr) )
      return hr;

   if ( !pAsyncSB->CallState.Flags.BeginStarted  ||
        !pAsyncSB->CallState.Flags.BeginDone     ||
        pAsyncSB->CallState.Flags.FinishStarted )
      return E_FAIL;

   if ( pAsyncSB->CallState.Hr != 0 )
      return pAsyncSB->CallState.Hr;

   pAsyncMsg = (PNDR_DCOM_ASYNC_MESSAGE)pAsyncSB->CallState.pAsyncMsg;

   hr = NdrpValidateDcomAsyncMsg( pAsyncMsg );
   if ( ! SUCCEEDED(hr) )
      return hr;

   // We need to create the second stack for the app invoke.
   // Do this first to simplify error conditions.

   RpcTryExcept 
   {
      pFinishStack = (uchar*) AsyncAlloca( pAsyncMsg, 
                                           StackSize + NDR_ASYNC_GUARD_SIZE );
   }
   RpcExcept( 1 )
   {
      NdrpAsyncStubMsgDestructor( pAsyncSB );
      return E_OUTOFMEMORY;
   }
   RpcEndExcept

   // Initialize the async message properly
   // the finish stack is quite possibly different from beginning stack. we need to 
   // readjust the low stack mark for finish call
   NdrSetupLowStackMark( &pAsyncMsg->StubMsg );
   pAsyncMsg->ProcContext.StartofStack = (uchar *) pFinishStack;
   pAsyncMsg->FinishStack  = (uchar *) pFinishStack;
   pAsyncMsg->FinishStackSize    = StackSize;
   pAsyncMsg->StubMsg.pContext = &pAsyncMsg->ProcContext;

   // Server: zero out stack for allocs.
   MIDL_memset( pFinishStack, 0x0, StackSize );

   MIDL_memset( (char *)pFinishStack + StackSize,
                0x72,
                NDR_ASYNC_GUARD_SIZE );

   pAsyncSB->CallState.Flags.FinishStarted = 1;

   return S_OK;
}


HRESULT
NdrpAsyncProxySignal(
                    CStdAsyncProxyBuffer *  pAsyncPB )
{
   ISynchronize *  pSynchronize;
   HRESULT         hr;
   IUnknown *      punkOuter = pAsyncPB->punkOuter;

   hr = punkOuter->lpVtbl->QueryInterface( punkOuter,
                                           IID_ISynchronize,
                                           (void**)&pSynchronize );

   if ( SUCCEEDED(hr) )
      {
      pSynchronize->lpVtbl->Signal( pSynchronize );
      pSynchronize->lpVtbl->Release( pSynchronize );
      }

   return hr;
}



_inline
HRESULT
NdrpCallStateLock(
                 NdrDcomAsyncCallState *  pCallState )
{
   if ( 0 != InterlockedCompareExchange( (long*)& pCallState->Lock, 1, 0 ) )
      {
      return E_FAIL;
      }

   return RPC_S_OK;
}

_inline
void
NdrpCallStateUnlock(
                   NdrDcomAsyncCallState *  pCallState )
{
   InterlockedDecrement( (long*)& pCallState->Lock );
   return;
}


HRESULT
NdrpAsyncProxyLock(
                  CStdAsyncProxyBuffer *  pAsyncPB )
{
   return NdrpCallStateLock( & pAsyncPB->CallState );
}


void
NdrpAsyncProxyUnlock(
                    CStdAsyncProxyBuffer *  pAsyncPB )
{
   NdrpCallStateUnlock( & pAsyncPB->CallState );
}

HRESULT
NdrpAsyncStubLock(
                 CStdAsyncStubBuffer *  pAsyncSB )
{
   return NdrpCallStateLock( & pAsyncSB->CallState );
}

void
NdrpAsyncStubUnlock(
                   CStdAsyncStubBuffer *  pAsyncSB )
{
   NdrpCallStateUnlock( & pAsyncSB->CallState );
}



void
NdrpFreeDcomAsyncMsg(
                    PNDR_DCOM_ASYNC_MESSAGE pAsyncMsg )
/*
    This routine would free the AsyncMsg but not the AsyncHandle, as on the server
    the user may need it and on the client it is user's to begin with.
*/
{
   if ( pAsyncMsg )
      {
      PMIDL_STUB_MESSAGE  pStubMsg  = & pAsyncMsg->StubMsg;

      NdrFullPointerXlatFree(pStubMsg->FullPtrXlatTables);

      // in NDR64, we are using allocacontext to hold corr info, so we don't
      // want to free it there.
      if ( pAsyncMsg->SyntaxType == XFER_SYNTAX_DCE )
         NdrCorrelationFree( pStubMsg );

      // Free the RPC buffer.

      if ( pStubMsg->IsClient )
         {
         if ( ! pAsyncMsg->Flags.RuntimeCleanedUp )
            {
            void * pThis = *(void **)pAsyncMsg->ProcContext.StartofStack;

            NdrProxyFreeBuffer( pThis, pStubMsg );
            }
         }

      NdrpAllocaDestroy( &pAsyncMsg->ProcContext.AllocateContext );

      // Prevent reusing of a handle that has been freed;
      pAsyncMsg->Signature = NDR_FREED_ASYNC_SIGNATURE;

      I_RpcBCacheFree( pAsyncMsg );

      }
}


BOOL
NdrpDcomAsyncSend(
                 PMIDL_STUB_MESSAGE  pStubMsg,
                 ISynchronize *      pSynchronize )
/*
    Call the channel to send.
    On the client, pass the app's pSynchronize to it, such that channel can signal
    the app.
    On the server, pass NULL instead of a pSynchronize.

*/
{
   PRPC_MESSAGE    pRpcMsg = pStubMsg->RpcMsg;
   HRESULT         hr = S_OK;
   RPC_STATUS      Status = RPC_S_OK;
   BOOL            fSendCalled = FALSE;

   pRpcMsg->RpcFlags |= RPC_BUFFER_ASYNC;

   if ( pStubMsg->pRpcChannelBuffer )
      {
      IAsyncRpcChannelBuffer * pAsChannel;
      IRpcChannelBuffer *      pChannel = (IRpcChannelBuffer *)
                                          pStubMsg->pRpcChannelBuffer;

      hr = pChannel->lpVtbl->QueryInterface( pChannel,
                                             IID_IAsyncRpcChannelBuffer,
                                             (void**)& pAsChannel );
      if ( SUCCEEDED(hr) )
         {
         fSendCalled = TRUE;
         hr = pAsChannel->lpVtbl->Send( pAsChannel,
                                        (RPCOLEMESSAGE *)pRpcMsg,
                                        pSynchronize,
                                        (ulong*)& Status );

         pAsChannel->lpVtbl->Release( pAsChannel );

         // The channel never returns this code now for new async.
         NDR_ASSERT( Status != RPC_S_SEND_INCOMPLETE, "Unexpected channel error" );
         }
      }
   else
      hr = E_NOINTERFACE;

  if ( pSynchronize )
      pSynchronize->lpVtbl->Release(pSynchronize);

// Alex:
   if ( SUCCEEDED(hr)  &&  Status == RPC_S_OK )
      pStubMsg->fBufferValid = TRUE;
   else
      RpcRaiseException( Status );

   return fSendCalled;
}


BOOL
NdrpDcomAsyncClientSend(
                       PMIDL_STUB_MESSAGE  pStubMsg,
                       IUnknown *          punkOuter )
/*
    Call the channel to send.
    On the client pass app's pSynchronize to it, such that channel can signal
    the app.
    On the server pass NULL instead of a pSynchronize.

*/
{
   PRPC_MESSAGE    pRpcMsg = pStubMsg->RpcMsg;
   HRESULT         hr = S_OK;
   BOOL            fSendCalled = FALSE;

   ISynchronize * pSynchronize = 0;

   // Channel needs somebody to signal to, this will be the app.

   hr = punkOuter->lpVtbl->QueryInterface( punkOuter,
                                           IID_ISynchronize,
                                           (void**) &pSynchronize );
   if ( SUCCEEDED(hr) )
      fSendCalled = NdrpDcomAsyncSend( pStubMsg, pSynchronize );

   return fSendCalled;
}


void
NdrDcomAsyncReceive(
                   PMIDL_STUB_MESSAGE  pStubMsg )
{
   PRPC_MESSAGE    pRpcMsg = pStubMsg->RpcMsg;
   RPC_STATUS      Status = RPC_S_OK;
   HRESULT         hr;

   pRpcMsg->RpcFlags |= RPC_BUFFER_ASYNC;
   pRpcMsg->RpcFlags &= ~RPC_BUFFER_PARTIAL;

   // A complete call.

   if ( pStubMsg->pRpcChannelBuffer )
      {
      IAsyncRpcChannelBuffer * pAsyncChannel = (IAsyncRpcChannelBuffer *)
                                               pStubMsg->pRpcChannelBuffer;

      hr = pAsyncChannel->lpVtbl->Receive( pAsyncChannel,
                                           (PRPCOLEMESSAGE) pRpcMsg,
                                           (unsigned long *)&Status );
      }

   if ( Status )
      {
      // No pending, the call would have blocked, real bug happened.

      if ( pStubMsg->pAsyncMsg )
         ((PNDR_DCOM_ASYNC_MESSAGE)pStubMsg->pAsyncMsg)->Flags.RuntimeCleanedUp = 1;

      RpcRaiseException(Status);
      }
   else
      {
      pStubMsg->Buffer = (uchar*) pRpcMsg->Buffer;

      pStubMsg->BufferStart = (uchar*)pRpcMsg->Buffer;
      pStubMsg->BufferEnd   = (uchar*)pRpcMsg->Buffer + pRpcMsg->BufferLength;
      pStubMsg->fBufferValid = TRUE;
      }
}

HRESULT
Ndr64pCompleteDcomAsyncStubCall(
                             CStdAsyncStubBuffer *   pAsyncSB
                             );

HRESULT
NdrpAsyncStubSignal(
                   CStdAsyncStubBuffer * pAsyncSB )
/*
    Signal on the async stub object:
    The channel signals that the Finish call should be executed.

    See if the stub object is active (or find one that is).
    If the stub object is not active then the call fails.
*/
{
   HRESULT hr = S_OK;
   BOOL    fFoundActiveCall = FALSE;

   while ( SUCCEEDED(hr)  &&  ! fFoundActiveCall )
      {
      hr = NdrpValidateAsyncStubCall( pAsyncSB );
      if ( SUCCEEDED(hr) )
         {
         if ( pAsyncSB->CallState.Flags.BeginStarted )
            {
            fFoundActiveCall = TRUE;
            }
         else
            {
            // Switch to the base interface call object. In case of
            // delegation one of the base interface objects would be active.

            IRpcStubBuffer * pBaseStubBuffer = pAsyncSB->pBaseStubBuffer;

            if ( pBaseStubBuffer )
               {
               pAsyncSB = (CStdAsyncStubBuffer *) ((uchar *)pBaseStubBuffer
                                                   - offsetof(CStdAsyncStubBuffer,lpVtbl));
               }
            else
               {
               // None of the stubs active and a signal came.
               hr = E_FAIL;
               }
            }
         }
      }

   if ( SUCCEEDED(hr) )
      {
      PNDR_DCOM_ASYNC_MESSAGE   pAsyncMsg = 
          (PNDR_DCOM_ASYNC_MESSAGE)pAsyncSB->CallState.pAsyncMsg;
      hr = NdrpValidateDcomAsyncMsg( pAsyncMsg );
      if ( SUCCEEDED(hr) )
         {
#if defined(BUILD_NDR64)
         if ( pAsyncMsg->SyntaxType == XFER_SYNTAX_DCE )
             hr = NdrpCompleteDcomAsyncStubCall( pAsyncSB );
         else
             hr = Ndr64pCompleteDcomAsyncStubCall( pAsyncSB );
#else
         hr = NdrpCompleteDcomAsyncStubCall( pAsyncSB );
#endif
         }
      }
   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr20\asyncndr.h ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1996 - 2000 Microsoft Corporation

Module Name :

    asyncndr.h

Abstract :

    This file contains the ndr async related definitions.

Author :

    Ryszard K. Kott     (ryszardk)    Nov 1996

Revision History :

---------------------------------------------------------------------*/

#ifndef  __ASYNCNDR_H__
#define  __ASYNCNDR_H__

#define RPC_ASYNC_CURRENT_VERSION     RPC_ASYNC_VERSION_1_0


#define RPC_ASYNC_SIGNATURE         0x43595341  /* ASNC */
#define NDR_ASYNC_SIGNATURE         0x63797341  /* Asnc */
#define RPC_FREED_ASYNC_SIGNATURE   0x45454541  /* AEEE */
#define NDR_FREED_ASYNC_SIGNATURE   0x65656561  /* aeee */

#define RPC_ASYNC_HANDLE            PRPC_ASYNC_STATE

#define NDR_ASYNC_VERSION           sizeof( NDR_ASYNC_MESSAGE )

#define NDR_ASYNC_GUARD_SIZE        (0x10)

#define NDR_ASYNC_PREP_PHASE        1
#define NDR_ASYNC_SET_PHASE         2
#define NDR_ASYNC_CALL_PHASE        3
#define NDR_ASYNC_ERROR_PHASE       4

typedef struct _Flags
    {                      
        unsigned short          ValidCallPending    : 1;
        unsigned short          ErrorPending        : 1;
        unsigned short          BadStubData         : 1;
        unsigned short          RuntimeCleanedUp    : 1;
        unsigned short          ClientHandleCreated : 1;
        unsigned short          HandlelessObjCall   : 1;
        unsigned short          Unused              : 10;
    } NDR_ASYNC_CALL_FLAGS;

typedef struct _NDR_ASYNC_MESSAGE
{
    long                        Version;
    long                        Signature;
    RPC_ASYNC_HANDLE            AsyncHandle;    // raw and CAsyncMgr *
    NDR_ASYNC_CALL_FLAGS        Flags;
    unsigned short              StubPhase;

    unsigned long               ErrorCode;
    RPC_MESSAGE                 RpcMsg;
    MIDL_STUB_MESSAGE           StubMsg;
    NDR_SCONTEXT                CtxtHndl[MAX_CONTEXT_HNDL_NUMBER];

    ulong *                     pdwStubPhase;

    // Note: the correlation cache needs to be sizeof(pointer) aligned
    NDR_PROC_CONTEXT            ProcContext;

    // guard at the end of the message
    unsigned char               AsyncGuard[NDR_ASYNC_GUARD_SIZE]; 
}   NDR_ASYNC_MESSAGE, *PNDR_ASYNC_MESSAGE;

#define AsyncAlloca( msg, size )           \
    NdrpAlloca( &msg->ProcContext.AllocateContext, size )

RPC_STATUS
NdrpCompleteAsyncCall (
    IN PRPC_ASYNC_STATE     AsyncHandle,
    IN PNDR_ASYNC_MESSAGE   pAsyncMsg,
    IN void *               pReply
    );

RPC_STATUS
NdrpCompleteAsyncClientCall(
    RPC_ASYNC_HANDLE            AsyncHandle,
    IN PNDR_ASYNC_MESSAGE       pAsyncMsg,
    void *                      pReturnValue
    );

RPC_STATUS
NdrpCompleteAsyncServerCall(
    RPC_ASYNC_HANDLE            AsyncHandle,
    IN PNDR_ASYNC_MESSAGE       pAsyncMsg,
    void *                      pReturnValue
    );

RPC_STATUS
NdrpAsyncAbortCall(
    PRPC_ASYNC_STATE   AsyncHandle,
    PNDR_ASYNC_MESSAGE pAsyncMsg,
    unsigned long      ExceptionCode,
    BOOL               bFreeParams
    );
 
RPC_STATUS 
NdrpInitializeAsyncMsg( 
    void *                      StartofStack,
    PNDR_ASYNC_MESSAGE          pAsyncMsg );

void
NdrpFreeAsyncMsg( 
    PNDR_ASYNC_MESSAGE          pAsyncMsg );

void
NdrpFreeAsyncHandleAndMessage(
    PRPC_ASYNC_STATE AsyncHandle);

void
NdrAsyncSend(
    PMIDL_STUB_MESSAGE          pStubMsg,
    BOOL                        fPartial );

void
NdrLastAsyncReceive(
    PMIDL_STUB_MESSAGE          pStubMsg );

RPC_STATUS
NdrValidateBothAndLockAsyncHandle(
    RPC_ASYNC_HANDLE            AsyncHandle );

RPC_STATUS
NdrpValidateAndLockAsyncHandle(
    RPC_ASYNC_HANDLE            AsyncHandle );

RPC_STATUS
NdrUnlockHandle(
    RPC_ASYNC_HANDLE            AsyncHandle );

RPC_STATUS
NdrpValidateAsyncMsg(
    PNDR_ASYNC_MESSAGE          pAsyncMsg  );

void
NdrpRegisterAsyncHandle(
    PMIDL_STUB_MESSAGE  pStubMsg,
    void *              AsyncHandle );

#endif  // __ASYNCNDR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr20\asyncu.h ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name :

    asyncu.h

Abstract :

    This file contains the ndr async uuid implementation.

Author :

    Ryszard K. Kott     (ryszardk)    Oct 1997

Revision History :

---------------------------------------------------------------------*/

#ifndef  __ASYNCU_H__
#define  __ASYNCU_H__

#define NDR_ASYNC_PROXY_SIGNATURE   0x78507341  /* AsPx */
#define NDR_ASYNC_STUB_SIGNATURE    0x74537341  /* AsSt */

#define NDR_DCOM_ASYNC_SIGNATURE    0x734d7341  /* AsMs */
#define NDR_FREED_ASYNC_SIGNATURE   0x65656561  /* aeee */
#define NDR_FREED_DCOM_SIGNATURE    0x65656564  /* deee */


#define NDR_DCOM_ASYNC_VERSION      sizeof( NDR_DCOM_ASYNC_MESSAGE )
#define NDR_ASYNC_GUARD_SIZE        (0x10)

#define NDR_ASYNC_PREP_PHASE        1
#define NDR_ASYNC_SET_PHASE         2
#define NDR_ASYNC_CALL_PHASE        3
#define NDR_ASYNC_ERROR_PHASE       4


typedef struct _Flags
    {                      
        unsigned short          ValidCallPending    : 1;
        unsigned short          ErrorPending        : 1;
        unsigned short          BadStubData         : 1;
        unsigned short          RuntimeCleanedUp    : 1;
        unsigned short          ClientHandleCreated : 1;
        unsigned short          HandlelessObjCall   : 1;
        unsigned short          ClientDcomPipeCall  : 1;
        unsigned short          Unused              : 9;
    } NDR_ASYNC_CALL_FLAGS;

typedef struct _NDR_DCOM_ASYNC_MESSAGE
{
    long                        Version;
    long                        Signature;
    SYNTAX_TYPE                 SyntaxType;
    
    long                        nBeginParams;
    void *                      BeginParams;
    long                        nFinishParams;
    void *                      FinishParams;

    uchar *                     BeginStack;
    uchar *                     FinishStack;
    ulong 		                BeginStackSize;
    ulong 		                FinishStackSize;
    NDR_ASYNC_CALL_FLAGS        Flags;

    
    void   *                    pThis;
    CStdAsyncProxyBuffer  *     pAsyncPB;
    CStdAsyncStubBuffer  *      pAsyncSB;

    ulong *                     pdwStubPhase;
    unsigned short              StubPhase;

    unsigned long               ErrorCode;
    RPC_MESSAGE                 RpcMsg;
    MIDL_STUB_MESSAGE           StubMsg;
    NDR_PROC_CONTEXT            ProcContext;

    uchar *                     pArg;

    // Note: the correlation cache needs to be sizeof(pointer) aligned
    unsigned _int64             AppStack;  // stack continues on                  
}   NDR_DCOM_ASYNC_MESSAGE, *PNDR_DCOM_ASYNC_MESSAGE;

#define AsyncAlloca( msg, size )           \
    NdrpAlloca( &msg->ProcContext.AllocateContext, size )

HRESULT
NdrpSetupBeginClientCall( 
    CStdAsyncProxyBuffer *  pAsyncPB,
    void *                  StartofStack,
    unsigned short          StackSize,
    REFIID                  riid );

HRESULT
NdrpSetupFinishClientCall( 
    CStdAsyncProxyBuffer *  pAsyncPB,
    void *                  StartofStack,
    unsigned short          StackSize,
    REFIID                  riid,
    unsigned long           AsyncProcNum );

HRESULT
NdrpSetupBeginStubCall( 
    CStdAsyncStubBuffer *   pAsyncSB,
    unsigned short          StackSize,
    REFIID                  riid );

HRESULT
NdrpSetupFinishStubCall( 
    CStdAsyncStubBuffer *   pAsyncSB,
    unsigned short          StackSize,
    REFIID                  riid );

HRESULT
NdrpBeginDcomAsyncStubCall(
    struct IRpcStubBuffer *     pThis,
    struct IRpcChannelBuffer *  pChannel,
    PRPC_MESSAGE                pRpcMsg,
    ulong *                     pdwStubPhase );

ULONG STDMETHODCALLTYPE
NdrpAsyncProxyAddRef( 
    CStdAsyncProxyBuffer *  pAsyncPB );

ULONG STDMETHODCALLTYPE
NdrpAsyncProxyRelease( 
    CStdAsyncProxyBuffer *  pAsyncPB );

HRESULT
NdrpAsyncProxyLock( 
    CStdAsyncProxyBuffer *  pAsyncPB );

void
NdrpAsyncProxyUnlock( 
    CStdAsyncProxyBuffer *  pAsyncPB );

HRESULT
NdrpAsyncProxyCleanup( 
    CStdAsyncProxyBuffer *  pAsyncPB );

HRESULT
NdrpSetupBeginServerCall( 
    CStdAsyncStubBuffer *   pAsyncPB,
    void *                  StartofStack,
    unsigned short          StackSize,
    REFIID                  riid );


void
NdrpCloneInOutArgs( 
    NDR_DCOM_ASYNC_MESSAGE * pAsyncMsg, 
    PPARAM_DESCRIPTION       FinishParams,
    int                      FinishParamCount ); 

void
NdrpFreeDcomAsyncMsg( 
    PNDR_DCOM_ASYNC_MESSAGE pAsyncMsg );


HRESULT
NdrpAsyncStubSignal(
    CStdAsyncStubBuffer *  pAsyncSB );


HRESULT
NdrpAsyncStubAddRef( 
    CStdAsyncStubBuffer *  pAsyncSB );

ULONG STDMETHODCALLTYPE
NdrpAsyncStubRelease( 
    CStdAsyncStubBuffer *  pAsyncSB );

HRESULT
NdrpAsyncStubLock( 
    CStdAsyncStubBuffer *  pAsyncSB );

void
NdrpAsyncStubUnlock( 
    CStdAsyncStubBuffer *  pAsyncSB );

HRESULT
NdrpAsyncStubCleanup( 
    CStdAsyncStubBuffer *  pAsyncSB );


BOOL
NdrpDcomAsyncSend(
    PMIDL_STUB_MESSAGE  pStubMsg,
    ISynchronize *      pSynchronize );

BOOL
NdrpDcomAsyncClientSend(
    PMIDL_STUB_MESSAGE  pStubMsg,
    IUnknown *          punkOuter );

void
NdrDcomAsyncReceive(
    PMIDL_STUB_MESSAGE  pStubMsg );


HRESULT
NdrpValidateDcomAsyncMsg(
                        PNDR_DCOM_ASYNC_MESSAGE  pAsyncMsg );

HRESULT
NdrpValidateDcomAsyncMsg(
                        PNDR_DCOM_ASYNC_MESSAGE  pAsyncMsg
                        );
HRESULT
NdrpCompleteDcomAsyncStubCall(
                             CStdAsyncStubBuffer *   pAsyncSB
                             );

HRESULT
NdrpValidateAsyncStubCall(
                         CStdAsyncStubBuffer *  pAsyncSB
                         );
void
NdrpCloneInOnlyCorrArgs(
                       NDR_DCOM_ASYNC_MESSAGE * pAsyncMsg,
                       PFORMAT_STRING           pTypeFormat
                       );

HRESULT
NdrpValidateAsyncProxyCall(
                          CStdAsyncProxyBuffer *  pAsyncPB
                          );
                         

#define NdrHrFromWin32Error( exc )  NdrStubErrorHandler( exc )

#endif  // __ASYNCU_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr20\attack.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1996-2000 Microsoft Corporation

Module Name :

    attack.c

Abstract :

    This file contains the ndr correlation check for denial of attacks.

Author :

    Ryszard K. Kott     (ryszardk)    Sep 1997

Revision History :

---------------------------------------------------------------------*/

#include "ndrp.h"
#include "hndl.h"
#include "ndrole.h"
#include "attack.h"
#include "interp.h"
#include "interp2.h"
#include "mulsyntx.h"
#include "asyncu.h"

extern "C" {
extern const GUID CLSID_RpcHelper;
}

inline
PFORMAT_STRING
GetConformanceDescriptor(
    PFORMAT_STRING      pFormat )
{

    static const uchar    
    ConformanceDescIncrements[] = 
                            { 
                            4,              // Conformant array.
                            4,              // Conformant varying array.
                            0, 0,           // Fixed arrays - unused.
                            0, 0,           // Varying arrays - unused.
                            4,              // Complex array.

                            2,              // Conformant char string. 
                            2,              // Conformant byte string.
                            4,              // Conformant stringable struct. 
                            2,              // Conformant wide char string.

                            0, 0, 0, 0,     // Non-conformant strings - unused.

                            0,              // Encapsulated union - unused. 
                            2,              // Non-encapsulated union.
                            2,              // Byte count pointer.
                            0, 0,           // Xmit/Rep as - unused.
                            2               // Interface pointer.
                            };

    ASSERT( FC_CARRAY <= *pFormat  &&  *pFormat < FC_END);

    return pFormat + ConformanceDescIncrements[ *pFormat - FC_CARRAY ];
}

inline
PFORMAT_STRING
GetVarianceDescriptor(
    PFORMAT_STRING      pFormat )
{
    // The array gives offset according to the size of the new correlation descriptors.
    

    static const uchar    
    VarianceDescIncrements[] =     
            { 8 + NDR_CORR_EXTENSION_SIZE,    // Conformant varying array.
              0, 0,                           // Fixed arrays - unsed.
              8, 12,                          // Varying array.
              8 + NDR_CORR_EXTENSION_SIZE,    // Complex array. 
            };

    ASSERT( FC_CVARRAY <= *pFormat  &&  *pFormat <= FC_BOGUS_ARRAY );

    return pFormat + VarianceDescIncrements[ *pFormat - FC_CVARRAY ];
}


void 
NdrpCheckCorrelation(
    PMIDL_STUB_MESSAGE  pStubMsg,
    LONG_PTR            Value,
    PFORMAT_STRING      pFormat,
    int                 CheckKind )
/*
    Checks if a correlation check can be performed or needs postponing.
    For early correlations it performs the check.
    For late correlations it adds an entry in the late correlatrion data base.

  Parameters
    Value  - conformant value related to the descriptor
    pFormat - array, string etc object with the descriptor

    pStubMsg->pCorrMemory - current memory context like struct
*/
{
    // pStubMsg->pCorrelationInfo->pCorrFstr   - descriptor for the current object

//    ASSERT( pStubMsg->pCorrInfo );

    // TBD performance: index through 2 dim table could be faster.

    if ( ( CheckKind & ~NDR_RESET_VALUE ) == NDR_CHECK_CONFORMANCE )
        pFormat = GetConformanceDescriptor( pFormat );
    else
        pFormat = GetVarianceDescriptor( pFormat );

    // See if we can actually check it out or whether we have to postpone it
    // till the correlation pass.

    NDR_FCDEF_CORRELATION * pConf = (NDR_FCDEF_CORRELATION *)pFormat;

    if ( pConf->CorrFlags.DontCheck )
        return;

    unsigned char * pMemory = pStubMsg->pCorrMemory;

    if ( pConf->CorrFlags.Early )
        {
        ULONG_PTR MaxCountSave = pStubMsg->MaxCount;
        ulong OffsetSave   = pStubMsg->Offset;

        pStubMsg->Offset = 0;
        // this call overwrites pStubMsg->MaxCount

        NdrpValidateCorrelatedValue( pStubMsg, pMemory, pFormat, Value, CheckKind );

        pStubMsg->MaxCount = MaxCountSave;
        pStubMsg->Offset   = OffsetSave;
        }
    else 
        {
        // Create correlation data base entry for the correlation pass.
        NdrpAddCorrelationData( pStubMsg, pMemory, pFormat, Value, CheckKind );
        }
}

//
void
NdrpValidateCorrelatedValue ( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat,
    LONG_PTR            Value,
    int                 CheckKind 
    )
/*++

Routine Description :

    This routine computes the conformant size for an array or the switch_is
    value for a union.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the embedding entity: a struct or a stack top.
    pFormat     - Format string description of the correlation (at old).
                  It indicates the correlated argument value.
    Value       - value from the array etc, i.e. from the buffer, to be checked against

Return :

    The array or string size or the union switch_is.

--*/
{
    void          * pCount = 0;
    LONG_PTR        Count;

    unsigned char   FormatCopy[4];
    BOOL            fAsyncSplit = FALSE;

    BOOL            fResetValue;

    fResetValue = CheckKind & NDR_RESET_VALUE;
    CheckKind = CheckKind & ~NDR_RESET_VALUE;

     // Ignore top level checks for -Os stubs.
    if ( !pMemory )
        return;

    PNDR_FCDEF_CORRELATION   pFormatCorr = (PNDR_FCDEF_CORRELATION) pFormat;

    //
    // First check if this is a callback to an expression evaluation routine.
    //
    if ( pFormatCorr->Operation == FC_CALLBACK ) 
        {
        uchar *     pOldStackTop;
        ushort      Index;

        // Index into expression callback routines table.
        Index = (ushort) pFormatCorr->Offset;

        NDR_ASSERT(pStubMsg->StubDesc->apfnExprEval != 0,
                   "NdrpComputeConformance : no expr eval routines");
        NDR_ASSERT(pStubMsg->StubDesc->apfnExprEval[Index] != 0,
                   "NdrpComputeConformance : bad expr eval routine index");

        pOldStackTop = pStubMsg->StackTop;

        //
        // The callback routine uses the StackTop field of the stub message
        // to base it's offsets from.  So if this is a complex attribute for 
        // an embedded field of a structure then set StackTop equal to the 
        // pointer to the structure.
        //
        if ( (*pFormat & 0xf0) != FC_TOP_LEVEL_CONFORMANCE ) 
            {
            pStubMsg->StackTop = pMemory;
            }

        //
        // This call puts the result in pStubMsg->MaxCount.
        //
        (*pStubMsg->StubDesc->apfnExprEval[Index])( pStubMsg );

        pStubMsg->StackTop = pOldStackTop;

        if ( CheckKind == NDR_CHECK_OFFSET )
            pStubMsg->MaxCount = pStubMsg->Offset;

        goto ValidateValue;
        }

    if ( CheckKind == NDR_CHECK_OFFSET )
        {
        // Checking offset without a call to expr eval routine -
        // this means that the offset should be zero.

        pStubMsg->MaxCount = 0;
        goto ValidateValue;
        }

    if ( (*pFormat & 0xf0) == FC_NORMAL_CONFORMANCE )
        {
        // Get the address where the conformance variable is in the struct.
        pCount = pMemory + pFormatCorr->Offset;
        goto ComputeConformantGetCount;
        }

    // See if this is an async split

    if ( pFormat[1] & 0x20 )
        {
        fAsyncSplit = TRUE;
        RpcpMemoryCopy( & FormatCopy[0], pFormat, 4 );
        pFormat = (PFORMAT_STRING) & FormatCopy[0];

        // Remove the async marker
        FormatCopy[1] = pFormat[1] & 0xdf; // ~0x20
        }

     //
    // Get a pointer to the conformance describing variable.
    //
    if ( (*pFormat & 0xf0) == FC_TOP_LEVEL_CONFORMANCE ) 
        {
        //
        // Top level conformance.  For /Os stubs, the stubs put the max
        // count in the stub message.  For /Oi stubs, we get the max count
        // via an offset from the stack top.
        //
        if ( pStubMsg->StackTop ) 
            {
            if ( fAsyncSplit )
                {
                PNDR_DCOM_ASYNC_MESSAGE pAsyncMsg;

                pAsyncMsg = (PNDR_DCOM_ASYNC_MESSAGE) pStubMsg->pAsyncMsg;

                pCount = pAsyncMsg->BeginStack + (ushort)pFormatCorr->Offset;
                }
            else
                pCount = pStubMsg->StackTop + (ushort)pFormatCorr->Offset;
            goto ComputeConformantGetCount;
            }
        else
            {
            // Top level conformance with -Os - not supported yet.
            //
            // If this is top level conformance with /Os then 
            // a) For early correlation, the compiler should generate the code to
            //    assign appropriate value to pStubMsg->MaxCount.
            //    goto ValideValue
            // b) For late correlation, we should have a registration call generated,
            //    so there would be nothing to do.
            //
            return;
            }
        }

    //
    // If we're computing the size of an embedded sized pointer then we
    // use the memory pointer in the stub message, which points to the 
    // beginning of the embedding structure.
    //
    if ( (*pFormat & 0xf0) == FC_POINTER_CONFORMANCE )
        {
        pCount = pMemory + pFormatCorr->Offset;
        goto ComputeConformantGetCount;
        }

    //
    // Check for constant size/switch.
    //
    if ( (*pFormat & 0xf0) == FC_CONSTANT_CONFORMANCE )
        {
        //
        // The size/switch is contained in the lower three bytes of the 
        // long currently pointed to by pFormat.
        //
        Count =  (ULONG_PTR)pFormat[1] << 16;
        Count |= (ULONG_PTR) *((ushort *)(pFormat + 2));

        goto ComputeConformanceEnd;
        }

    //
    // Check for conformance of a multidimensional array element in 
    // a -Os stub.
    //
    if ( (*pFormat & 0xf0) == FC_TOP_LEVEL_MULTID_CONFORMANCE )
        {
        long Dimension;

        if ( fAsyncSplit )
            RpcRaiseException( RPC_X_WRONG_STUB_VERSION );

        //
        // If pArrayInfo is non-null than we have a multi-D array.  If it
        // is null then we have multi-leveled sized pointers.
        //
        if ( pStubMsg->pArrayInfo ) 
            {
            Dimension = pStubMsg->pArrayInfo->Dimension;
            pStubMsg->MaxCount = pStubMsg->pArrayInfo->MaxCountArray[Dimension];
            }
        else
            {
            Dimension = *((ushort *)(pFormat + 2));
            pStubMsg->MaxCount = pStubMsg->SizePtrCountArray[Dimension];
            }

        goto ValidateValue;
        }

    NDR_ASSERT(0, "NdrpValidateCorrelatedValue:, Invalid Correlation type");
    RpcRaiseException( RPC_S_INTERNAL_ERROR );
    return;

ComputeConformantGetCount:

    //
    // Must check now if there is a dereference op.
    //
    if ( pFormatCorr->Operation == FC_DEREFERENCE )
        {
        pCount = *(void **)pCount;
        }

    //
    // If we're supposed to whack the value instead of checking it do it 
    // and quit
    //

    if ( fResetValue )
        {
        // hypers are not legal types for cs_char size/length_is expressions

        if ( FC_HYPER == pFormatCorr->Type )
            RpcRaiseException( RPC_X_BAD_STUB_DATA );

        CHECK_BOUND( (long)Value, pFormatCorr->Type );

        switch ( pFormatCorr->Type )
            {
            case FC_ULONG:
                * (ulong *) pCount = (ulong) Value;
                return;

            case FC_LONG:
                * (ulong *) pCount = (long) Value;
                return;

            case FC_ENUM16 :
            case FC_USHORT :
                * (ushort *) pCount = (ushort) Value;
                return;

            case FC_SHORT :
                * (short *) pCount = (short) Value;
                return;

            case FC_USMALL :
                * (uchar *) pCount = (uchar) Value;
                return;

            case FC_SMALL :
                * (char *) pCount = (char) Value;
                return;

            default :
                NDR_ASSERT(0,"NdrpValidateCorrelatedValue : bad reset type");
                RpcRaiseException( RPC_S_INTERNAL_ERROR );
            }        
        }

    //
    // Now get the conformance count.
    //
    switch ( pFormatCorr->Type ) 
        {
        case FC_HYPER :
            // iid_is on 64b platforms only.
            Count = *((LONG_PTR *)pCount);
            break;

        case FC_ULONG :
            Count = (LONG_PTR)*((ulong *)pCount);
            break;

        case FC_LONG :
            Count = *((long *)pCount);
            break;

        case FC_ENUM16:
        case FC_USHORT :
            Count = (long) *((ushort *)pCount);
            break;

        case FC_SHORT :
            Count = (long) *((short *)pCount);
            break;

        case FC_USMALL :
            Count = (long) *((uchar *)pCount);
            break;

        case FC_SMALL :
            Count = (long) *((char *)pCount);
            break;

        default :
            NDR_ASSERT(0,"NdrpValidateCorrelatedValue : bad count type");
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
        } 

    //
    // Check the operator.
    //
    switch ( pFormatCorr->Operation ) 
        {
        case FC_DIV_2 :
            Count /= 2;
            break;
        case FC_MULT_2 :
            if ( (ulong)Count >= 0x40000000  )
                RpcRaiseException ( RPC_X_INVALID_BOUND );
            Count *= 2;
            break;
        case FC_SUB_1 :
            Count -= 1;
            if ( Count < 0 )
                RpcRaiseException ( RPC_X_INVALID_BOUND );
            break;
        case FC_ADD_1 :
            Count += 1;
            if ( Count < 0 )
                RpcRaiseException ( RPC_X_INVALID_BOUND );
            break;
        default :
            // OK
            break;
        }

ComputeConformanceEnd:

    pStubMsg->MaxCount = (ulong) Count;

ValidateValue:

    // Compare pStubMsg->MaxCount with the value

    BOOL            fValueOK = FALSE;
    LONG_PTR        ArgValue = (LONG_PTR) pStubMsg->MaxCount;
    unsigned char   FcType   = (uchar)pFormatCorr->Type;

    if ( (*pFormat & 0xf0) == FC_CONSTANT_CONFORMANCE  || 
          pFormatCorr->Operation == FC_CALLBACK ) 
        FcType = FC_ULONG;

    switch ( FcType ) 
        {
        case FC_HYPER :
            fValueOK = ArgValue == (LONG_PTR)Value;
            break;

        case FC_ULONG :
            fValueOK = ArgValue == (LONG_PTR)(ulong)Value;
            break;

        case FC_LONG :
            fValueOK = ArgValue == (LONG_PTR)(long)Value;
            break;

        case FC_ENUM16:
        case FC_USHORT :
            fValueOK = ArgValue == (LONG_PTR)(ushort)Value;
            break;

        case FC_SHORT :
            fValueOK = ArgValue == (LONG_PTR)(short)Value;
            break;

        case FC_USMALL :
            fValueOK = ArgValue == (LONG_PTR)(uchar)Value;
            break;

        case FC_SMALL :
            fValueOK = ArgValue == (LONG_PTR)(char)Value;
            break;

        default :
            NDR_ASSERT(0,"NdrpValidateCorrelatedValue : bad count type");
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
        } 


    if ( !pFormatCorr->CorrFlags.IsIidIs )
        {
        if (!fValueOK )
            RpcRaiseException( RPC_X_BAD_STUB_DATA );            
        }
    else
        {
        NDR_ASSERT( CheckKind != NDR_CHECK_OFFSET, "invalid check kind" );
        if ( CheckKind == NDR_CHECK_OFFSET )
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
        IID * piidValue = (IID *)Value;
        IID * piidArg   = (IID *)ArgValue;

        if ( 0 != memcmp( piidValue, piidArg, sizeof( IID )))
            RpcRaiseException( RPC_X_BAD_STUB_DATA );
        }

    return;
}

RPCRTAPI
void
RPC_ENTRY
NdrCorrelationInitialize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    void *              pCache,
    unsigned long       CacheSize,
    unsigned long       Flags
    )
/* 
    Initializes the correlation package for -Os stubs.
*/  
{
    PNDR_CORRELATION_INFO  pCorrInfo = (PNDR_CORRELATION_INFO)pCache;

    if ( CacheSize == 0xffffffff )
        CacheSize = NDR_DEFAULT_CORR_CACHE_SIZE;

    pCorrInfo->Header.pCache = (NDR_CORRELATION_INFO *)pCache;
    pCorrInfo->Header.pInfo  = (NDR_CORRELATION_INFO *)pCache;
    pCorrInfo->Header.DataLen  = 0;
    pCorrInfo->Header.DataSize = (CacheSize - sizeof(NDR_CORRELATION_INFO)) 
                                     / sizeof(NDR_CORRELATION_INFO_DATA);

    pStubMsg->pCorrMemory = pStubMsg->StackTop;
    pStubMsg->pCorrInfo   = (NDR_CORRELATION_INFO *)pCache;

    pStubMsg->fHasExtensions  = 1;
    pStubMsg->fHasNewCorrDesc = 1;
}


void
NdrpAddCorrelationData( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat,
    LONG_PTR            Value,
    int                 CheckKind 
    )
/* 
    Adds a check data to the correlation data base for a later evaluation.
*/  
{
    ASSERT( pStubMsg->pCorrInfo );

    PNDR_CORRELATION_INFO  pCorrInfo = (PNDR_CORRELATION_INFO)pStubMsg->pCorrInfo;

    if ( pCorrInfo->Header.DataSize <= pCorrInfo->Header.DataLen )
        {
        // Not enough space, need to realloc.

        unsigned long           NewDataSize;
        PNDR_CORRELATION_INFO   pCorrInfoNew;

        NewDataSize = 2 * pCorrInfo->Header.DataSize;
        pCorrInfoNew = (PNDR_CORRELATION_INFO) I_RpcAllocate( 
                            sizeof(NDR_CORRELATION_INFO_HEADER) + 
                                NewDataSize * sizeof(NDR_CORRELATION_INFO_DATA) );
        if ( ! pCorrInfoNew )
            RpcRaiseException( RPC_S_OUT_OF_MEMORY );

        RpcpMemoryCopy( pCorrInfoNew, 
                        pCorrInfo, 
                        sizeof(NDR_CORRELATION_INFO_HEADER) + 
                            pCorrInfo->Header.DataSize * sizeof(NDR_CORRELATION_INFO_DATA) );

        pCorrInfoNew->Header.pInfo    = pCorrInfoNew;
        pCorrInfoNew->Header.DataSize = NewDataSize;
        pStubMsg->pCorrInfo           = pCorrInfoNew;

        if ( pCorrInfo->Header.pInfo != pCorrInfo->Header.pCache )
            I_RpcFree( pCorrInfo->Header.pInfo );

        pCorrInfo = pCorrInfoNew;
        }

    pCorrInfo->Data[ pCorrInfo->Header.DataLen ].pMemoryObject = pMemory; 
    pCorrInfo->Data[ pCorrInfo->Header.DataLen ].Value         = Value; 
    pCorrInfo->Data[ pCorrInfo->Header.DataLen ].pCorrDesc     = pFormat; 
    pCorrInfo->Data[ pCorrInfo->Header.DataLen ].CheckKind     = CheckKind;
    pCorrInfo->Header.DataLen++;
}

RPCRTAPI
void
RPC_ENTRY
NdrCorrelationPass( 
    PMIDL_STUB_MESSAGE  pStubMsg
    )
/* 
    Walks the data base to check all the correlated values that could not be checked 
    on fly.
*/  
{
    ASSERT( pStubMsg->pCorrInfo );
    if ( pStubMsg->pCorrInfo->Header.DataLen == 0 )
        return;

    PNDR_CORRELATION_INFO  pCorrInfo = (PNDR_CORRELATION_INFO)pStubMsg->pCorrInfo;

    for ( int i = 0; i < pCorrInfo->Header.DataLen; i++ )
        {
        NdrpValidateCorrelatedValue( pStubMsg,
                                     pCorrInfo->Data[ i ].pMemoryObject,
                                     pCorrInfo->Data[ i ].pCorrDesc,
                                     pCorrInfo->Data[ i ].Value,
                                     pCorrInfo->Data[ i ].CheckKind );
        }
}

RPCRTAPI
void
RPC_ENTRY
NdrCorrelationFree( 
    PMIDL_STUB_MESSAGE  pStubMsg
    )
/* 
    Releases the correlation data structures.
    In /Os stub, NdrCorrelationInitialize is called after fullpointer initialization
    and NdrCorrelationFree is called without checking pStubMsg->pCorrInfo. changing
    ndr might be better in this case. 
*/  
{
//    ASSERT( pStubMsg->pCorrInfo );

    PNDR_CORRELATION_INFO  pCorrInfo = (PNDR_CORRELATION_INFO)pStubMsg->pCorrInfo;
    if ( NULL == pCorrInfo )
        return;

    if ( pCorrInfo->Header.pInfo != pCorrInfo->Header.pCache )
        {
        I_RpcFree( pCorrInfo->Header.pInfo );
        }        
}


HRESULT
NdrpGetRpcHelper(
    IRpcHelper **     ppRpcHelper )
/*++

    This routine attempts to get hold of an IRpcHelper interface pointer.
    We cache the one IP on each process and never release it. This is an inproc server
    and interface will be cleanup when process exit. 
--*/
{
    HRESULT     hr;
    static IRpcHelper  *pRpcHelper = NULL;   

    *ppRpcHelper = NULL;
    if (pRpcHelper)
    {
        *ppRpcHelper = pRpcHelper;
        hr = S_OK;
    }
    else
    {
        hr = NdrLoadOleRoutines();

        if (SUCCEEDED(hr))
            hr = (*pfnCoCreateInstance)( CLSID_RpcHelper, 
                                 NULL, 
                                 CLSCTX_INPROC_SERVER,
            	                 IID_IRpcHelper, 
                                 (void **)&pRpcHelper );

        if (SUCCEEDED(hr))
            *ppRpcHelper = pRpcHelper;
    }
        
    return hr;
}

void
NdrpGetIIDFromBuffer( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    IID **              ppIID
    )
/*
    The routine recovers an interface pointer IID from the marshaling buffer.
    The IID stays in the buffer, an IID* is returned by the routine.
*/
{
    IRpcHelper *    pRpcHelper = 0;
    HRESULT         hr;
    
    *ppIID = 0;

    hr = NdrpGetRpcHelper( & pRpcHelper );

    if(FAILED(hr))
        RpcRaiseException(hr);
    
    hr = pRpcHelper->GetIIDFromOBJREF(  pStubMsg->Buffer,
                                       ppIID );
    if (FAILED(hr))
        RpcRaiseException( RPC_X_BAD_STUB_DATA );

    // The IRpcHelper is cached in NdrpGetRpcHelper so we don't need to release it.
    //    pRpcHelper->Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr20\auxilary.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1993-2000 Microsoft Corporation

Module Name :

    auxilary.c

Abstract :

    This file contains auxilary routines used for initialization of the
    RPC and stub messages and the offline batching of common code sequences
    needed by the stubs.

Author :

    David Kays  dkays   September 1993.

Revision History :

  ---------------------------------------------------------------------*/
#define _OLE32_
#include "ndrp.h"
#include "ndrole.h"
#include "ndrtypes.h"
#include "limits.h"
#include "interp.h"
#include "mulsyntx.h"
#include "pipendr.h"
#include "asyncndr.h"
#include "auxilary.h"
#include "pointerq.h"

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    Static data for NS library operations
  ---------------------------------------------------------------------*/

int NsDllLoaded = 0;


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    OLE routines for interface pointer marshalling
  ---------------------------------------------------------------------*/

STDAPI NdrpCoCreateInstance(
    REFCLSID    rclsid,
    LPUNKNOWN   pUnkOuter,
    DWORD       dwClsContext, 
    REFIID      riid, 
    LPVOID *    ppv);

STDAPI NdrpCoReleaseMarshalData(
    IStream *pStm);

STDAPI NdrpDcomChannelSetHResult(
        PRPC_MESSAGE    pmsg,
        ULONG *         pulReserved,
        HRESULT         appsHR );

STDAPI NdrCoGetPSClsid(
    REFIID  iid,
    LPCLSID lpclsid);

HINSTANCE       hOle32 = 0;

RPC_GET_CLASS_OBJECT_ROUTINE        NdrCoGetClassObject;
RPC_GET_CLASS_OBJECT_ROUTINE     *  pfnCoGetClassObject = &NdrCoGetClassObject;

RPC_GET_MARSHAL_SIZE_MAX_ROUTINE    NdrCoGetMarshalSizeMax;
RPC_GET_MARSHAL_SIZE_MAX_ROUTINE *  pfnCoGetMarshalSizeMax = &NdrCoGetMarshalSizeMax;

RPC_MARSHAL_INTERFACE_ROUTINE       NdrCoMarshalInterface;
RPC_MARSHAL_INTERFACE_ROUTINE    *  pfnCoMarshalInterface = &NdrCoMarshalInterface;

RPC_UNMARSHAL_INTERFACE_ROUTINE     NdrCoUnmarshalInterface;
RPC_UNMARSHAL_INTERFACE_ROUTINE  *  pfnCoUnmarshalInterface = &NdrCoUnmarshalInterface;

RPC_STRING_FROM_IID                 OleStringFromIID;
RPC_STRING_FROM_IID              *  pfnStringFromIID = &OleStringFromIID;

RPC_GET_PS_CLSID                    NdrCoGetPSClsid;
RPC_GET_PS_CLSID                 *  pfnCoGetPSClsid = &NdrCoGetPSClsid;

RPC_CO_CREATE_INSTANCE              NdrpCoCreateInstance;
RPC_CO_CREATE_INSTANCE           *  pfnCoCreateInstance = &NdrpCoCreateInstance;

RPC_CLIENT_ALLOC                    NdrCoTaskMemAlloc;
RPC_CLIENT_ALLOC                 *  pfnCoTaskMemAlloc = &NdrCoTaskMemAlloc;

RPC_CLIENT_FREE                     NdrCoTaskMemFree;
RPC_CLIENT_FREE                  *  pfnCoTaskMemFree = &NdrCoTaskMemFree;

RPC_CO_RELEASEMARSHALDATA           NdrpCoReleaseMarshalData;
RPC_CO_RELEASEMARSHALDATA        *  pfnCoReleaseMarshalData = &NdrpCoReleaseMarshalData;

RPC_DCOMCHANNELSETHRESULT           NdrpDcomChannelSetHResult;
RPC_DCOMCHANNELSETHRESULT        *  pfnDcomChannelSetHResult = &NdrpDcomChannelSetHResult;

RPC_NS_GET_BUFFER_ROUTINE        pRpcNsGetBuffer;
RPC_NS_SEND_RECEIVE_ROUTINE      pRpcNsSendReceive;
RPC_NS_NEGOTIATETRANSFERSYNTAX_ROUTINE  pRpcNsNegotiateTransferSyntax;


HRESULT    NdrLoadOleRoutines()
{
    void * pTempRoutine;

    //Load ole32.dll
    if(hOle32 == 0)
    {
#ifdef DOSWIN32RPC
        hOle32 = LoadLibraryA("OLE32");
#else
        hOle32 = LoadLibraryW(L"OLE32");
#endif // DOSWIN32C
        if(hOle32 == 0)
            return HRESULT_FROM_WIN32(GetLastError());
    }

    pTempRoutine = GetProcAddress(hOle32, "CoGetClassObject");
    if(pTempRoutine == 0)
        return HRESULT_FROM_WIN32(GetLastError());
    else
        pfnCoGetClassObject = (RPC_GET_CLASS_OBJECT_ROUTINE*) pTempRoutine;

    pTempRoutine = GetProcAddress(hOle32, "CoGetMarshalSizeMax");
    if(pTempRoutine == 0)
        return HRESULT_FROM_WIN32(GetLastError());
    else
        pfnCoGetMarshalSizeMax = (RPC_GET_MARSHAL_SIZE_MAX_ROUTINE*) pTempRoutine;

    pTempRoutine = GetProcAddress(hOle32, "CoMarshalInterface");
    if(pTempRoutine == 0)
        return HRESULT_FROM_WIN32(GetLastError());
    else
        pfnCoMarshalInterface = (RPC_MARSHAL_INTERFACE_ROUTINE*) pTempRoutine;

    pTempRoutine = GetProcAddress(hOle32, "CoUnmarshalInterface");
    if(pTempRoutine == 0)
        return HRESULT_FROM_WIN32(GetLastError());
    else
        pfnCoUnmarshalInterface = (RPC_UNMARSHAL_INTERFACE_ROUTINE*) pTempRoutine;

    pTempRoutine = GetProcAddress(hOle32, "StringFromIID");
    if(pTempRoutine == 0)
        return HRESULT_FROM_WIN32(GetLastError());
    else
        pfnStringFromIID = (RPC_STRING_FROM_IID*) pTempRoutine;

    pTempRoutine = GetProcAddress(hOle32, "CoGetPSClsid");
    if(pTempRoutine == 0)
        return HRESULT_FROM_WIN32(GetLastError());
    else
        pfnCoGetPSClsid = (RPC_GET_PS_CLSID*) pTempRoutine;

    pTempRoutine = GetProcAddress(hOle32, "CoTaskMemAlloc");
    if(pTempRoutine == 0)
        return HRESULT_FROM_WIN32(GetLastError());
    else
        pfnCoTaskMemAlloc = (RPC_CLIENT_ALLOC*) pTempRoutine;

    pTempRoutine = GetProcAddress(hOle32, "CoTaskMemFree");
    if(pTempRoutine == 0)
        return HRESULT_FROM_WIN32(GetLastError());
    else
        pfnCoTaskMemFree = (RPC_CLIENT_FREE*) pTempRoutine;

    pTempRoutine = GetProcAddress(hOle32, "CoCreateInstance");
    if(pTempRoutine == 0)
        return HRESULT_FROM_WIN32(GetLastError());
    else
        pfnCoCreateInstance = (RPC_CO_CREATE_INSTANCE*) pTempRoutine;

    pTempRoutine = GetProcAddress(hOle32, "CoReleaseMarshalData");
    if(pTempRoutine == 0)
        return HRESULT_FROM_WIN32(GetLastError());
    else
        pfnCoReleaseMarshalData = (RPC_CO_RELEASEMARSHALDATA*) pTempRoutine;
    pTempRoutine = GetProcAddress(hOle32, "DcomChannelSetHResult");
    if(pTempRoutine == 0)
        return HRESULT_FROM_WIN32(GetLastError());
    else
        pfnDcomChannelSetHResult = (RPC_DCOMCHANNELSETHRESULT*) pTempRoutine;

    return( (HRESULT)0 );
}

HRESULT STDAPICALLTYPE
NdrCoGetClassObject(
    REFCLSID    rclsid,
    DWORD       dwClsContext,
    void       *pvReserved,
    REFIID      riid,
    void      **ppv)
/*++

Routine Description:
    Loads a class factory.  This function forwards the call to ole32.dll.

Arguments:
    rclsid          - Supplies the CLSID of the class to be loaded.
    dwClsContext    - Supplies the context in which to load the code.
    pvReserved      - Must be NULL.
    riid            - Supplies the IID of the desired interface.
    ppv             - Returns a pointer to the class factory.

Return Value:
    S_OK


--*/
{

    HRESULT hr;

    if ( FAILED(hr = NdrLoadOleRoutines()) )
        return hr;

    return (*pfnCoGetClassObject)(rclsid, dwClsContext, pvReserved, riid, ppv);
}

HRESULT STDAPICALLTYPE
NdrCoGetMarshalSizeMax(
    ULONG *     pulSize,
    REFIID      riid,
    LPUNKNOWN   pUnk,
    DWORD       dwDestContext,
    LPVOID      pvDestContext,
    DWORD       mshlflags)
/*++

Routine Description:
    Calculates the maximum size of a marshalled interface pointer.
    This function forwards the call to ole32.dll.

Arguments:
    pulSize         - Returns an upper bound for the size of a marshalled interface pointer.
    riid            - Supplies the IID of the interface to be marshalled.
    pUnk            - Supplies a pointer to the object to be marshalled.
    dwDestContext   - Supplies the destination of the marshalled interface pointer.
    pvDestContext
    mshlflags       - Flags.  See the MSHFLAGS enumeration.

Return Value:
    S_OK

--*/
{

    HRESULT hr;
    if ( FAILED(hr = NdrLoadOleRoutines()) )
        return hr;

    return (*pfnCoGetMarshalSizeMax)(pulSize, riid, pUnk, dwDestContext, pvDestContext, mshlflags);

}

RPC_STATUS
RPC_ENTRY
NdrGetDcomProtocolVersion(
    PMIDL_STUB_MESSAGE   pStubMsg,
    RPC_VERSION *        pVersion )
/*

    This is a helper routine for OLEAUT guys.
    It returns the actually negotiated protocol version for the connection,
    i.e. a "common denominator" - lower of the two.

*/
{
    HRESULT Hr = E_FAIL;

    if ( pStubMsg->pRpcChannelBuffer )
        {
        IRpcChannelBuffer2 * pBuffer2 = 0;

        Hr = ((IRpcChannelBuffer*)pStubMsg->pRpcChannelBuffer)->
                  QueryInterface( IID_IRpcChannelBuffer2,
                                  (void**) & pBuffer2 );
        if ( Hr == S_OK )
            {
            Hr = pBuffer2->GetProtocolVersion( (DWORD *) pVersion );
            pBuffer2->Release( );
            }
        }
    return Hr;
}

unsigned long
FixWireRepForDComVerGTE54(
    PMIDL_STUB_MESSAGE   pStubMsg )
/*
    Compares the current DCOM protocol version with the desired version ( 5.4 )
    Specific to interface pointer array and embedded conf struct wire rep fix.
*/
{
    if ( pStubMsg->pRpcChannelBuffer )
        {
        RPC_VERSION currRpcVersion = { 0, 0 };

        if ( SUCCEEDED ( NdrGetDcomProtocolVersion( pStubMsg, &currRpcVersion ) ) )
            {
            if ( currRpcVersion.MajorVersion > 5 )
                {
                return TRUE;
                }
            else
                {
                return currRpcVersion.MinorVersion >= 4;
                }
            }
        }
    return TRUE;
}

HRESULT STDAPICALLTYPE
NdrCoMarshalInterface(
    LPSTREAM    pStm,
    REFIID      riid,
    LPUNKNOWN   pUnk,
    DWORD       dwDestContext,
    LPVOID      pvDestContext,
    DWORD       mshlflags)
/*++

Routine Description:
    Marshals an interface pointer.
    This function forwards the call to ole32.dll.

Arguments:
    pStm            - Supplies the target stream.
    riid            - Supplies the IID of the interface to be marshalled.
    pUnk            - Supplies a pointer to the object to be marshalled.
    dwDestContext   - Specifies the destination context
    pvDestContext
    mshlflags       - Flags.  See the MSHFLAGS enumeration.

Return Value:
    S_OK

--*/
{
    HRESULT hr;
    if ( FAILED(hr = NdrLoadOleRoutines()) )
        return hr;

    return (*pfnCoMarshalInterface)(pStm, riid, pUnk, dwDestContext, pvDestContext, mshlflags);
}

HRESULT STDAPICALLTYPE
NdrCoUnmarshalInterface(
    LPSTREAM    pStm,
    REFIID      riid,
    void **     ppv)
/*++

Routine Description:
    Unmarshals an interface pointer from a stream.
    This function forwards the call to ole32.dll.

Arguments:
    pStm    - Supplies the stream containing the marshalled interface pointer.
    riid    - Supplies the IID of the interface pointer to be unmarshalled.
    ppv     - Returns the unmarshalled interface pointer.

Return Value:
    S_OK

--*/
{
    HRESULT hr;
    if ( FAILED(hr = NdrLoadOleRoutines()) )
        return hr;

    return (*pfnCoUnmarshalInterface)(pStm, riid, ppv);
}

STDAPI NdrpCoCreateInstance(
    REFCLSID    rclsid,
    LPUNKNOWN   pUnkOuter,
    DWORD       dwClsContext, 
    REFIID      riid, 
    LPVOID *    ppv)
{
    HRESULT hr;
    if ( FAILED(hr = NdrLoadOleRoutines()) )
        return hr;

    return (*pfnCoCreateInstance) (rclsid, pUnkOuter, dwClsContext, riid, ppv );
}

STDAPI NdrpCoReleaseMarshalData(
    IStream *pStm)
{
    HRESULT hr;
    if ( FAILED(hr = NdrLoadOleRoutines()) )
        return hr;

    return (*pfnCoReleaseMarshalData) (pStm );
}

STDAPI NdrpDcomChannelSetHResult(
        PRPC_MESSAGE    pmsg,
        ULONG *         pulReserved,
        HRESULT         appsHR )
{
    HRESULT hr;

    if ( FAILED(hr = NdrLoadOleRoutines()) )
        return hr;

    return (*pfnDcomChannelSetHResult)( pmsg, pulReserved, appsHR );
}


HRESULT STDAPICALLTYPE OleStringFromIID(
    REFIID rclsid,
    LPOLESTR FAR* lplpsz)
/*++

Routine Description:
    Converts an IID into a string.
    This function forwards the call to ole32.dll.

Arguments:
    rclsid  - Supplies the clsid to convert to string form.
    lplpsz  - Returns the string form of the clsid (with "{}" around it).

Return Value:
    S_OK

--*/
{
    HRESULT hr;
    
    if ( FAILED(hr = NdrLoadOleRoutines()) )
        return hr;

    return (*pfnStringFromIID)(rclsid, lplpsz);
}

STDAPI NdrCoGetPSClsid(
    REFIID  iid,
    LPCLSID lpclsid)
/*++

Routine Description:
    Converts an IID into a string.
    This function forwards the call to ole32.dll.

Arguments:
    rclsid  - Supplies the clsid to convert to string form.
    lplpsz  - Returns the string form of the clsid (with "{}" around it).

Return Value:
    S_OK

--*/
{
    
    HRESULT hr;
    if ( FAILED(hr = NdrLoadOleRoutines()) )
        return hr;

    return (*pfnCoGetPSClsid)(iid, lpclsid);
}


void * STDAPICALLTYPE
NdrCoTaskMemAlloc(
    size_t cb)
/*++

Routine Description:
    Allocate memory using OLE task memory allocator.
    This function forwards the call to ole32.dll.

Arguments:
    cb - Specifies the amount of memory to be allocated.

Return Value:
    This function returns a pointer to the allocated memory.
    If an error occurs, this function returns zero.

--*/
{
    if ( FAILED(NdrLoadOleRoutines()) )
        return 0;

    return (*pfnCoTaskMemAlloc)(cb);
}

void STDAPICALLTYPE
NdrCoTaskMemFree(
    void * pMemory)
/*++

Routine Description:
    Free memory using OLE task memory allocator.
    This function forwards the call to ole32.dll.

Arguments:
    pMemory - Supplies a pointer to the memory to be freed.

Return Value:
    None.

--*/
{
    if ( FAILED(NdrLoadOleRoutines()) )
        return;

   (*pfnCoTaskMemFree)(pMemory);
}


void * RPC_ENTRY NdrOleAllocate(size_t size)
/*++

Routine Description:
    Allocate memory via OLE task allocator.

Arguments:
    size - Specifies the amount of memory to be allocated.

Return Value:
    This function returns a pointer to the allocated memory.
    If an error occurs, this function raises an exception.

--*/
{
    void *pMemory;

    pMemory = (*pfnCoTaskMemAlloc)(size);

    if(pMemory == 0)
        RpcRaiseException(E_OUTOFMEMORY);

    return pMemory;
}

void RPC_ENTRY NdrOleFree(void *pMemory)
/*++

Routine Description:
    Free memory using OLE task allocator.

Arguments:
    None.

Return Value:
    None.

--*/
{
    (*pfnCoTaskMemFree)(pMemory);
}


HRESULT STDAPICALLTYPE NdrStringFromIID(
    REFIID rclsid,
    char * lpsz)
/*++

Routine Description:
    Converts an IID into a string.
    This function forwards the call to ole32.dll.

Arguments:
    rclsid  - Supplies the clsid to convert to string form.
    lplpsz  - Returns the string form of the clsid (with "{}" around it).

Return Value:
    S_OK

--*/
{
    HRESULT   hr;
    wchar_t * olestr;

    hr = (*pfnStringFromIID)(rclsid, &olestr);

    if(SUCCEEDED(hr))
    {
        WideCharToMultiByte(CP_ACP,
                            0,
                            (LPCWSTR)olestr,
                            -1,
                            (LPSTR)lpsz,
                            50,
                            NULL,
                            NULL);
        NdrOleFree(olestr);
    }

    return hr;
}



void RPC_ENTRY
NdrClientInitializeNew(
    PRPC_MESSAGE             pRpcMsg,
    PMIDL_STUB_MESSAGE         pStubMsg,
    PMIDL_STUB_DESC            pStubDescriptor,
    unsigned int            ProcNum
    )
/*++

Routine Description :

    This routine is called by client side stubs to initialize the RPC message
    and stub message, and to get the RPC buffer.

Arguments :

    pRpcMsg            - pointer to RPC message structure
    pStubMsg        - pointer to stub message structure
    pStubDescriptor    - pointer to stub descriptor structure
    HandleType        - type of binding handle
    ProcNum            - remote procedure number

--*/
{
    NdrClientInitialize( pRpcMsg,
                         pStubMsg,
                         pStubDescriptor,
                         ProcNum );

    if ( pStubDescriptor->pMallocFreeStruct )
        {
        MALLOC_FREE_STRUCT *pMFS = pStubDescriptor->pMallocFreeStruct;

        NdrpSetRpcSsDefaults(pMFS->pfnAllocate, pMFS->pfnFree);
        }

    // This exception should be raised after initializing StubMsg.

    if ( pStubDescriptor->Version > NDR_VERSION )
        {
        NDR_ASSERT( 0, "ClientInitialize : Bad version number" );

        RpcRaiseException( RPC_X_WRONG_STUB_VERSION );
        }

    //
    // This is where we initialize fields behind the NT3.5 - NT5.0 field set.
    //
#ifdef _CS_CHAR_
    if ( NDR_VERSION_6_0 <= pStubDescriptor->Version )
        {
        pStubMsg->pCSInfo = 0;
        }
#endif // _CS_CHAR_
}

void RPC_ENTRY
NdrClientInitialize(
    PRPC_MESSAGE            pRpcMsg,
    PMIDL_STUB_MESSAGE      pStubMsg,
    PMIDL_STUB_DESC         pStubDescriptor,
    unsigned int            ProcNum )
/*++

Routine Description :

    This routine is called by client side stubs to initialize the RPC message
    and stub message, and to get the RPC buffer.

Arguments :

    pRpcMsg          - pointer to RPC message structure
    pStubMsg         - pointer to stub message structure
    pStubDescriptor  - pointer to stub descriptor structure
    ProcNum          - remote procedure number
    
Notes:

    This routine has to be backward compatible with the old binaries built from
    -Os stubs. In particular, it cannot touch StubMsg fields outside of 
    the NT3.5 - NT5.0 field set, i.e. set of fields present since NT3.5 release.

--*/
{
    //
    // Initialize RPC message fields.
    //
    // The leftmost bit of the procnum field is supposed to be set to 1 inr
    // order for the runtime to know if it is talking to the older stubs or
    // not.
    //

    pRpcMsg->RpcInterfaceInformation = pStubDescriptor->RpcInterfaceInformation;
//#if !defined(__RPC_WIN64__)
    
    pRpcMsg->ProcNum = ProcNum | RPC_FLAGS_VALID_BIT;
//#endif     
    pRpcMsg->RpcFlags = 0;
    pRpcMsg->Handle = 0;

    //
    // Initialize the Stub messsage fields.
    //

    pStubMsg->RpcMsg = pRpcMsg;

    pStubMsg->StubDesc = pStubDescriptor;

    pStubMsg->pfnAllocate = pStubDescriptor->pfnAllocate;
    pStubMsg->pfnFree     = pStubDescriptor->pfnFree;

    pStubMsg->fInDontFree       = 0;
    pStubMsg->fDontCallFreeInst = 0;
    pStubMsg->fInOnlyParam      = 0;
    pStubMsg->fHasReturn        = 0;
    pStubMsg->fHasExtensions    = 0;
    pStubMsg->fHasNewCorrDesc   = 0;
    pStubMsg->UniquePtrCount= 0;

    pStubMsg->IsClient = TRUE;

    pStubMsg->BufferLength = 0;
    pStubMsg->BufferStart = 0;
    pStubMsg->BufferEnd = 0;
    pStubMsg->uFlags    = 0;

    pStubMsg->fBufferValid = FALSE;
    pStubMsg->ReuseBuffer = FALSE;

    pStubMsg->StackTop = 0;

    pStubMsg->IgnoreEmbeddedPointers = FALSE;
    pStubMsg->PointerBufferMark = 0;
    pStubMsg->pAllocAllNodesContext = 0;
    pStubMsg->pPointerQueueState = 0;

    pStubMsg->FullPtrRefId = 0;
    pStubMsg->PointerLength = 0;

    pStubMsg->dwDestContext = MSHCTX_DIFFERENTMACHINE;
    pStubMsg->pvDestContext = 0;
    pStubMsg->pRpcChannelBuffer = 0;

    pStubMsg->pArrayInfo = 0;

    pStubMsg->dwStubPhase = 0;

    NdrSetupLowStackMark( pStubMsg );
    pStubMsg->pAsyncMsg = 0;
    pStubMsg->pCorrInfo = 0;
    pStubMsg->pCorrMemory = 0;
    pStubMsg->pMemoryList = 0;
}


void
MakeSureWeHaveNonPipeArgs(
    PMIDL_STUB_MESSAGE  pStubMsg,
    unsigned long       BufferSize )
/*

Routine description:

    This routine is called for pipe calls at the server.
    After the runtime dispatched to the stub with the first packet,
    it makes sure that we have a portion of the buffer big enough
    to keep all the non-pipe args.

Arguments:

    BufferSize - a pipe call: addtional number of bytes over what we have.

Note:

    The buffer location may change from before to after the call.

*/
{
    RPC_STATUS      Status;
    PRPC_MESSAGE    pRpcMsg = pStubMsg->RpcMsg;

    if ( !(pRpcMsg->RpcFlags & RPC_BUFFER_COMPLETE ) )
        {
        // May be the args fit into the first packet.

        if ( BufferSize <= pRpcMsg->BufferLength )
            return;

        // Set the partial flag to get the non-pipe args.
        // For a partial call with the "extra", the meaning of the size
        // arg is the addition required above what we have already.

        pRpcMsg->RpcFlags |= (RPC_BUFFER_PARTIAL |  RPC_BUFFER_EXTRA);

        // We will receive at least BufferSize.
        // (buffer location may change)

        BufferSize -= pRpcMsg->BufferLength;

        Status = I_RpcReceive( pRpcMsg, (unsigned int) BufferSize );

        if ( Status != RPC_S_OK )
            {
            // Note, that for this particular error case, i.e. non-pipe
            // data receive failing, we don't want to restore the 
            // original dispatch buffer into the rpc message.
            // In case of an error the buffer coming back here would be 0.
            //
            RpcRaiseException( Status );
            }

        NDR_ASSERT( 0 == BufferSize ||
                    NULL != pRpcMsg->Buffer,
                    "Rpc runtime returned an invalid buffer.");

        // In case this is a new buffer

        pStubMsg->Buffer      = (uchar*)pRpcMsg->Buffer;
        pStubMsg->BufferStart = (uchar*)pRpcMsg->Buffer;
        pStubMsg->BufferEnd   = pStubMsg->BufferStart + pRpcMsg->BufferLength;
        }
}


unsigned char * RPC_ENTRY
NdrServerInitializeNew(
    PRPC_MESSAGE            pRpcMsg,
    PMIDL_STUB_MESSAGE      pStubMsg,
    PMIDL_STUB_DESC         pStubDescriptor
    )
/*++

Routine Description :

    This routine is called by the server stubs before unmarshalling.
    It initializes the stub message fields.

Aruguments :

    pStubMsg        - pointer to the stub message structure
    pStubDescriptor - pointer to the stub descriptor structure

Note.
    NdrServerInitializeNew is almost identical to NdrServerInitializePartial.
    NdrServerInitializeNew is generated for non-pipes and is backward comp.
    NdrServerInitializePartial is generated for routines with pipes args.

--*/
{
    NdrServerInitialize( pRpcMsg,
                         pStubMsg,
                         pStubDescriptor );

    if ( pStubDescriptor->pMallocFreeStruct )
        {
        MALLOC_FREE_STRUCT *pMFS = pStubDescriptor->pMallocFreeStruct;

        NdrpSetRpcSsDefaults(pMFS->pfnAllocate, pMFS->pfnFree);
        }

    // This exception should be raised after initializing StubMsg.

    if ( pStubDescriptor->Version > NDR_VERSION )
        {
        NDR_ASSERT( 0, "ServerInitializeNew : bad version number" );

        RpcRaiseException( RPC_X_WRONG_STUB_VERSION );
        }

    //
    // This is where we initialize fields behind the NT3.5 - NT5.0 field set.
    //
#ifdef _CS_CHAR_
    if ( NDR_VERSION_6_0 <= pStubDescriptor->Version )
        {
        pStubMsg->pCSInfo = 0;
        }
#endif // _CS_CHAR_
    if ( !(pRpcMsg->RpcFlags & RPC_BUFFER_COMPLETE ) )
        {
        // A non-pipe call with an incomplete buffer.
        // This can happen only for non-pipe calls in an interface that
        // has some pipe calls. 

        RPC_STATUS Status;

        pRpcMsg->RpcFlags = RPC_BUFFER_EXTRA;

        // The size argument is ignored, we will get everything.

        Status = I_RpcReceive( pRpcMsg, 0 );

        if ( Status != RPC_S_OK )
            {
            // This is the same behavior (and comment) as in MakeSure..
            //    routine above for non-pipe data case in a pipe call.
            // For this particular error case, i.e. a call to Receive to get 
            // all (non-pipe) data failing, we don't want to restore the 
            // original dispatch buffer into the rpc message.
            // In case of an error the buffer coming back here would be 0.
            //
            RpcRaiseException( Status );
            }

        NDR_ASSERT( 0 == pRpcMsg->BufferLength ||
                    NULL != pRpcMsg->Buffer,
                    "Rpc runtime returned an invalid buffer.");

        // In case this is a new buffer

        pStubMsg->Buffer      = (uchar*)pRpcMsg->Buffer;
        pStubMsg->BufferStart = (uchar*)pRpcMsg->Buffer;
        pStubMsg->BufferEnd   = pStubMsg->BufferStart + pRpcMsg->BufferLength;
        }

    return 0;
}

unsigned char * RPC_ENTRY
NdrServerInitialize(
    PRPC_MESSAGE            pRpcMsg,
    PMIDL_STUB_MESSAGE      pStubMsg,
    PMIDL_STUB_DESC         pStubDescriptor )
/*++

Routine Description :

    This routine is called by the server stubs before unmarshalling.
    It initializes the stub message fields.

Aruguments :

    pStubMsg        - pointer to the stub message structure
    pStubDescriptor - pointer to the stub descriptor structure

Note :

    This is a core server-side initializer, called by everybody.
    
    This routine has to be backward compatible with the old binaries built from
    -Os stubs. In particular, it cannot touch StubMsg fields outside of 
    the NT3.5 - NT5.0 field set, i.e. set of fields present since NT3.5 release.

--*/
{
    pStubMsg->IsClient = FALSE;
    pStubMsg->pAllocAllNodesContext = 0;
    pStubMsg->pPointerQueueState = 0;
    pStubMsg->IgnoreEmbeddedPointers = FALSE;
    pStubMsg->PointerBufferMark = 0;
    pStubMsg->BufferLength = 0;
    pStubMsg->StackTop = 0;

    pStubMsg->FullPtrXlatTables = 0;
    pStubMsg->FullPtrRefId = 0;
    pStubMsg->PointerLength = 0;

    pStubMsg->fDontCallFreeInst = 0;
    pStubMsg->fInDontFree       = 0;
    pStubMsg->fInOnlyParam      = 0;
    pStubMsg->fHasReturn        = 0;
    pStubMsg->fHasExtensions    = 0;
    pStubMsg->fHasNewCorrDesc   = 0;
    pStubMsg->UniquePtrCount = 0;

    pStubMsg->dwDestContext = MSHCTX_DIFFERENTMACHINE;
    pStubMsg->pvDestContext = 0;
    pStubMsg->pRpcChannelBuffer = 0;

    pStubMsg->pArrayInfo = 0;

    pStubMsg->RpcMsg = pRpcMsg;
    pStubMsg->Buffer = (uchar*)pRpcMsg->Buffer;

    //
    // Set BufferStart and BufferEnd before unmarshalling.
    // NdrPointerFree uses these values to detect pointers into the
    // rpc message buffer.
    //
    pStubMsg->BufferStart = (uchar*)pRpcMsg->Buffer;
    pStubMsg->BufferEnd   = pStubMsg->BufferStart + pRpcMsg->BufferLength;
    pStubMsg->uFlags      = 0;

    pStubMsg->pfnAllocate = pStubDescriptor->pfnAllocate;
    pStubMsg->pfnFree     = pStubDescriptor->pfnFree;

    pStubMsg->StubDesc = pStubDescriptor;
    pStubMsg->ReuseBuffer = FALSE;

    pStubMsg->dwStubPhase = 0;

    NdrSetupLowStackMark( pStubMsg );
    pStubMsg->pAsyncMsg = 0;
    pStubMsg->pCorrInfo = 0;
    pStubMsg->pCorrMemory = 0;
    pStubMsg->pMemoryList = 0;

    NdrRpcSetNDRSlot( pStubMsg );
    return(0);
}

void RPC_ENTRY
NdrServerInitializePartial(
    PRPC_MESSAGE            pRpcMsg,
    PMIDL_STUB_MESSAGE      pStubMsg,
    PMIDL_STUB_DESC         pStubDescriptor,
    unsigned long           RequestedBufferSize )
/*++

Routine Description :

    This routine is called by the server stubs for pipes.
    It is almost identical to NdrServerInitializeNew, except that
    it calls NdrpServerInitialize.

Aruguments :

    pStubMsg        - pointer to the stub message structure
    pStubDescriptor - pointer to the stub descriptor structure
    pBuffer         - pointer to the beginning of the RPC message buffer

--*/
{
    NdrServerInitialize( pRpcMsg,
                         pStubMsg,
                         pStubDescriptor );

    if ( pStubDescriptor->pMallocFreeStruct )
        {
        MALLOC_FREE_STRUCT *pMFS = pStubDescriptor->pMallocFreeStruct;

        NdrpSetRpcSsDefaults(pMFS->pfnAllocate, pMFS->pfnFree);
        }

    // This exception should be raised after initializing StubMsg.

    if ( pStubDescriptor->Version > NDR_VERSION )
        {
        NDR_ASSERT( 0, "ServerInitializePartial : bad version number" );

        RpcRaiseException( RPC_X_WRONG_STUB_VERSION );
        }

    //
    // This is where we initialize fields behind the NT3.5 - NT5.0 field set.
    //
#ifdef _CS_CHAR_
    if ( NDR_VERSION_6_0 <= pStubDescriptor->Version )
        {
        pStubMsg->pCSInfo = 0;
        }
#endif _CS_CHAR_    
    // Last but not least...

    MakeSureWeHaveNonPipeArgs( pStubMsg, RequestedBufferSize );
}


unsigned char * RPC_ENTRY
NdrGetBuffer(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned long           BufferLength,
    RPC_BINDING_HANDLE      Handle )
/*++

Routine Description :

    Performs an RpcGetBuffer.

Arguments :

    pStubMsg        - Pointer to stub message structure.
    BufferLength    - Length of requested rpc message buffer.
    Handle          - Bound handle.

--*/
{
    RPC_STATUS    Status;

    if ( pStubMsg->IsClient )
        pStubMsg->RpcMsg->Handle = pStubMsg->SavedHandle = Handle;

    LENGTH_ALIGN(BufferLength, 3);
    pStubMsg->RpcMsg->BufferLength = BufferLength;

    Status = I_RpcGetBuffer( pStubMsg->RpcMsg );

    if ( Status )
        {
        // For raw rpc, if async, don't call abort later.

        if ( pStubMsg->pAsyncMsg )
            pStubMsg->pAsyncMsg->Flags.RuntimeCleanedUp = 1;

        RpcRaiseException( Status );
        }

    NDR_ASSERT( 0 == BufferLength ||
                NULL != pStubMsg->RpcMsg->Buffer,
                "Rpc runtime returned an invalid buffer.");

    NDR_ASSERT( ! ((ULONG_PTR)pStubMsg->RpcMsg->Buffer & 0x7),
                "marshaling buffer misaligned" );

    pStubMsg->Buffer = (uchar *) pStubMsg->RpcMsg->Buffer;
    pStubMsg->fBufferValid = TRUE;

    return pStubMsg->Buffer;
}


void
EnsureNSLoaded()
/*++

Routine Description :

    Guarantee that the RpcNs4 DLL is loaded.  Throw exception if unable
    to load it.
    Will load the RpcNs4 DLL if not already loaded

Arguments :


--*/
{
    HINSTANCE   DllHandle;
    LPSTR       EntryName;


    if ( NsDllLoaded )
        return;

#ifdef DOSWIN32RPC
    DllHandle    = LoadLibraryA( "RPCNS4" );
#else
    DllHandle    = LoadLibraryW( L"RPCNS4" );
#endif // DOSWIN32RPC

    if ( DllHandle == 0 )
        {
        RpcRaiseException (RPC_S_INVALID_BINDING);
        }

    EntryName = "I_RpcNsGetBuffer";


    pRpcNsGetBuffer = (RPC_NS_GET_BUFFER_ROUTINE)
                      GetProcAddress( DllHandle,
                                      EntryName);

    if ( pRpcNsGetBuffer == 0 )
        {
        RpcRaiseException (RPC_S_INVALID_BINDING);
        }

    EntryName = "I_RpcNsSendReceive";


    pRpcNsSendReceive = (RPC_NS_SEND_RECEIVE_ROUTINE)
                        GetProcAddress( DllHandle,
                                        EntryName);

    if ( pRpcNsSendReceive == 0 )
        {
        RpcRaiseException (RPC_S_INVALID_BINDING);
        }


    EntryName = "I_RpcNsNegotiateTransferSyntax";
    pRpcNsNegotiateTransferSyntax = ( RPC_NS_NEGOTIATETRANSFERSYNTAX_ROUTINE )
                                    GetProcAddress( DllHandle,
                                                    EntryName );
                                                    
    if ( pRpcNsNegotiateTransferSyntax == 0 )
        {
        RpcRaiseException (RPC_S_INVALID_BINDING);
        }

    NsDllLoaded = 1;
}


unsigned char * RPC_ENTRY
NdrNsGetBuffer( PMIDL_STUB_MESSAGE    pStubMsg,
                unsigned long         BufferLength,
                RPC_BINDING_HANDLE    Handle )
/*++

Routine Description :

    Performs an RpcNsGetBuffer.
    Will load the RpcNs4 DLL if not already loaded

Arguments :

    pStubMsg        - Pointer to stub message structure.
    BufferLength    - Length of requested rpc message buffer.
    Handle          - Bound handle

--*/
{
    RPC_STATUS    Status;

    if( pStubMsg->IsClient == TRUE )
        pStubMsg->RpcMsg->Handle = pStubMsg->SavedHandle = Handle;

    EnsureNSLoaded();

    LENGTH_ALIGN(BufferLength, 3);
    pStubMsg->RpcMsg->BufferLength = BufferLength;

    Status = (*pRpcNsGetBuffer)( pStubMsg->RpcMsg );

    if ( Status )
        RpcRaiseException( Status );

    NDR_ASSERT( ! ((ULONG_PTR)pStubMsg->RpcMsg->Buffer & 0x7),
                "marshaling buffer misaligned" );

    pStubMsg->Buffer = (uchar *) pStubMsg->RpcMsg->Buffer;
    pStubMsg->fBufferValid = TRUE;

    return pStubMsg->Buffer;
}

unsigned char * RPC_ENTRY
NdrSendReceive(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pBufferEnd )
/*++

Routine Description :

    Performs an RpcSendRecieve.
    This routine is executed for the non-pipe calls only.
    It returns a whole marshaling buffer.

Arguments :

    pStubMsg    - Pointer to stub message structure.
    pBufferEnd  - End of the rpc message buffer being sent.

Return :

    The new message buffer pointer returned from the runtime after the
    SendReceive call to the server.

--*/
{
    RPC_STATUS      Status;
    PRPC_MESSAGE    pRpcMsg;

    pRpcMsg = pStubMsg->RpcMsg;

    if ( pRpcMsg->BufferLength <
                    (uint)(pBufferEnd - (uchar *)pRpcMsg->Buffer))
        {
        NDR_ASSERT( 0, "NdrSendReceive : buffer overflow" );
        RpcRaiseException( RPC_S_INTERNAL_ERROR );
        }

    pRpcMsg->BufferLength = (ulong)(pBufferEnd - (uchar *)pRpcMsg->Buffer);

    pStubMsg->fBufferValid = FALSE;

    Status = I_RpcSendReceive( pRpcMsg );

    if ( Status )
        RpcRaiseException(Status);

    NDR_ASSERT( 0 == pRpcMsg->BufferLength ||
                NULL != pRpcMsg->Buffer,
                "Rpc runtime returned an invalid buffer.");  

    NDR_ASSERT( ! ((ULONG_PTR)pRpcMsg->Buffer & 0x7),
                "marshaling buffer misaligned" );

    pStubMsg->Buffer = (uchar*)pRpcMsg->Buffer;
    pStubMsg->BufferStart = pStubMsg->Buffer;
    pStubMsg->BufferEnd   = pStubMsg->Buffer + pRpcMsg->BufferLength;
    pStubMsg->fBufferValid = TRUE;

    return 0;
}


unsigned char * RPC_ENTRY
NdrNsSendReceive(
    PMIDL_STUB_MESSAGE      pStubMsg,
    uchar *                 pBufferEnd,
    RPC_BINDING_HANDLE *    pAutoHandle )
/*++

Routine Description :

    Performs an RpcNsSendRecieve for a procedure which uses an auto handle.
    Will load the RpcNs4 DLL if not already loaded

Arguments :

    pStubMsg    - Pointer to stub message structure.
    pBufferEnd  - End of the rpc message buffer being sent.
    pAutoHandle - Pointer to the auto handle used in the call.

Return :

    The new message buffer pointer returned from the runtime after the
    SendReceive call to the server.

--*/
{
    RPC_STATUS      Status;
    PRPC_MESSAGE    pRpcMsg;

    EnsureNSLoaded();

    pRpcMsg = pStubMsg->RpcMsg;

    if ( pRpcMsg->BufferLength <
                    (uint)(pBufferEnd - (uchar *)pRpcMsg->Buffer) )
        {
        NDR_ASSERT( 0, "NdrNsSendReceive : buffer overflow" );
        RpcRaiseException( RPC_S_INTERNAL_ERROR );
        }

    pRpcMsg->BufferLength = (ulong)(pBufferEnd - (uchar *)pRpcMsg->Buffer);

    pStubMsg->fBufferValid = FALSE;

    Status = (*pRpcNsSendReceive)( pRpcMsg, pAutoHandle );

    if ( Status )
        RpcRaiseException(Status);

    pStubMsg->SavedHandle = *pAutoHandle;

    pStubMsg->Buffer = (uchar*)pRpcMsg->Buffer;
    pStubMsg->BufferStart = pStubMsg->Buffer;
    pStubMsg->BufferEnd   = pStubMsg->Buffer + pRpcMsg->BufferLength;
    pStubMsg->fBufferValid = TRUE;

    return pStubMsg->Buffer;
}

void RPC_ENTRY
NdrFreeBuffer(
    PMIDL_STUB_MESSAGE pStubMsg )
/*++

Routine Description :

    Performs an RpcFreeBuffer.

Arguments :

    pStubMsg    - pointer to stub message structure

Return :

    None.

--*/
{
    RPC_STATUS    Status;

    if ( ! pStubMsg->fBufferValid )
        return;

    if( ! pStubMsg->RpcMsg->Handle )
        return;

    Status = I_RpcFreeBuffer( pStubMsg->RpcMsg );

    pStubMsg->fBufferValid = FALSE;

    if ( Status )
        RpcRaiseException(Status);
}

void *  RPC_ENTRY
NdrAllocate(
    PMIDL_STUB_MESSAGE  pStubMsg,
    size_t              Len )
/*++

Routine Description :

    Private allocator.  Handles allocate all nodes cases.

Arguments :

    pStubMsg    - Pointer to stub message structure.
    Len         - Number of bytes to allocate.

Return :

    Valid memory pointer.

--*/
{
    void * pMemory;

    if ( pStubMsg->pAllocAllNodesContext )
        {
        //
        // We must guarantee 4 byte alignment on NT and MAC.
        //
#if defined(__RPC_WIN64__)
        ALIGN(pStubMsg->pAllocAllNodesContext->AllocAllNodesMemory,7);
#else
        ALIGN(pStubMsg->pAllocAllNodesContext->AllocAllNodesMemory,3);
#endif

        // Get the pointer.
        pMemory = pStubMsg->pAllocAllNodesContext->AllocAllNodesMemory;

        // Increment the block pointer.
        pStubMsg->pAllocAllNodesContext->AllocAllNodesMemory += Len;

        //
        // Check for memory allocs past the end of our allocated buffer.
        //
        if ( pStubMsg->pAllocAllNodesContext->AllocAllNodesMemoryEnd < 
             pStubMsg->pAllocAllNodesContext->AllocAllNodesMemory )
            {
            NDR_ASSERT( pStubMsg->pAllocAllNodesContext->AllocAllNodesMemory <=
                        pStubMsg->pAllocAllNodesContext->AllocAllNodesMemoryEnd,
                        "Not enough alloc all nodes memory!" );
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            }

        return pMemory;
        }
    else
        {
        size_t NodeOffset, FullSize;
        PNDR_MEMORY_LIST_TAIL_NODE pMemoryList;

        // Add linked list node to tail of allocation. Ensure that the tail
        // is at a 8 byte alignment so that the same code will work in 64bits.
        NodeOffset = Len;

        LENGTH_ALIGN(NodeOffset, 7); 
        
        FullSize = NodeOffset + sizeof(NDR_MEMORY_LIST_TAIL_NODE);

        // prevent arithmetic overflow
        if ( FullSize < Len )
            RpcRaiseException(  RPC_X_BAD_STUB_DATA );

        if ( ! (pMemory = (*pStubMsg->pfnAllocate)( FullSize )) )
            RpcRaiseException( RPC_S_OUT_OF_MEMORY );

        pMemoryList = (PNDR_MEMORY_LIST_TAIL_NODE)((char *)pMemory + NodeOffset);

        pMemoryList->Signature = NDR_MEMORY_LIST_SIGNATURE;
        pMemoryList->pMemoryHead = pMemory;
        pMemoryList->pNextNode = (PNDR_MEMORY_LIST_TAIL_NODE)pStubMsg->pMemoryList;
        pStubMsg->pMemoryList =  pMemoryList; 

        return pMemory;
        }
}

void
NdrpFreeMemoryList(
    MIDL_STUB_MESSAGE *     pStubMsg)
/*++

Routine Description :

    Freeing the list of memory allocated by NdrAllocate.

Arguments :

    pStubMsg    - Pointer to stub message structure.

Return :

    None.

--*/
{

// if the server memory is corrupted, it's probably better to let it die
         while(pStubMsg->pMemoryList) 
              {
              PNDR_MEMORY_LIST_TAIL_NODE pMemoryList = 
                  (PNDR_MEMORY_LIST_TAIL_NODE)pStubMsg->pMemoryList;

              if (pMemoryList->Signature != NDR_MEMORY_LIST_SIGNATURE) 
                 {
                 NDR_ASSERT( 0 , "bad rpc allocated memory signature" );
                 return;
                 }

              pStubMsg->pMemoryList = pMemoryList->pNextNode;
              (*pStubMsg->pfnFree)(pMemoryList->pMemoryHead); 
              }
}
    

unsigned char * RPC_ENTRY
NdrServerInitializeUnmarshall (
    PMIDL_STUB_MESSAGE      pStubMsg,
    PMIDL_STUB_DESC         pStubDescriptor,
    PRPC_MESSAGE            pRpcMsg )
/*++

Routine Description :

    Old NT Beta2 (build 683) server stub initialization routine.  Used for
    backward compatability only.

Aruguments :

    pStubMsg        - Pointer to the stub message structure.
    pStubDescriptor    - Pointer to the stub descriptor structure.
    pBuffer            - Pointer to the beginning of the RPC message buffer.

--*/
{
    return NdrServerInitialize( pRpcMsg,
                                pStubMsg,
                                pStubDescriptor );
}

void RPC_ENTRY
NdrServerInitializeMarshall (
    PRPC_MESSAGE        pRpcMsg,
    PMIDL_STUB_MESSAGE  pStubMsg )
/*++

Routine Description :

    Old NT Beta2 (build 683) server stub initialization routine.  Used for
    backward compatability only.

Arguments :

    pRpcMsg         - Pointer to the RPC message structure.
    pStubMsg        - Pointer to the stub message structure.

--*/
{
}

//
// Functions to simulate a alloca across a function call.
// Note that this code is optimized for simplicity and speed.  It does 
// not attempt to search a list on each allocation to reuse partially full
// blocks as much as it could.  This gives max speed, but hurts space
// utilization when allocations of significantly different sizes are requested.
//
// This code can easily be optimized more in the future.

#if defined(NDR_PROFILE_ALLOCA)

VOID
NdrpAllocaWriteLog( CHAR *pChar, DWORD Size )
{

    HANDLE hMutex = NULL;
    HANDLE hLogFile = INVALID_HANDLE_VALUE;
    BOOL bHasMutex = FALSE;   

    RpcTryFinally
       {

       
       // Open and acquire the log mutex
       hMutex = CreateMutex( NULL, FALSE, "NDR_ALLOCA_LOG_MUTEX");
       if ( !hMutex) return;

       DWORD dwWaitResult = WaitForSingleObject( hMutex, INFINITE );
       if ( WAIT_FAILED == dwWaitResult ) return;
       bHasMutex = TRUE;         
 
       CHAR LogFile[MAX_PATH];
       UINT DirResult = 
           GetSystemDirectoryA( LogFile, sizeof(LogFile) );

       if ( !DirResult) return;

       strcat( LogFile, "\\ndralloca.log" );

       hLogFile = CreateFileA( LogFile, 
                               GENERIC_WRITE,
                               FILE_SHARE_READ | FILE_SHARE_WRITE,
                               NULL,
                               OPEN_ALWAYS,
                               FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH,
                               NULL );

       SetFilePointer( hLogFile, 0, NULL, FILE_END );

       DWORD dwBytesWritten;
       WriteFile( hLogFile, pChar, Size, &dwBytesWritten, NULL ); 

       }
   RpcFinally
       {
       if ( bHasMutex ) ReleaseMutex( hMutex );
       if ( NULL != hMutex) CloseHandle( hMutex );
       if ( INVALID_HANDLE_VALUE != hLogFile )  CloseHandle( hLogFile );
       }
   RpcEndFinally

}

VOID
NdrpAllocaDumpStatistics(
    PNDR_ALLOCA_CONTEXT pAllocaContext
    )
{

   // Produce a record suitable for entry into Excel.
   CHAR DataBuffer[4048];
   CHAR AppName[MAX_PATH];
   memset(AppName, 0, sizeof(AppName ) );

   GetModuleFileNameA( NULL, AppName, sizeof(AppName ) ); 

   sprintf( DataBuffer, "EXE,%s,PID,0x%X,TID,0x%x,CS,%d,AB,%d,AA,%d,MB,%d,MA,%d\r\n",
            AppName,
            GetCurrentProcessId(),
            GetCurrentThreadId(),
            (long)NDR_ALLOCA_PREALLOCED_BLOCK_SIZE,
            pAllocaContext->AllocaBytes,
            pAllocaContext->AllocaAllocations,
            pAllocaContext->MemoryBytes,
            pAllocaContext->MemoryAllocations );

   NdrpAllocaWriteLog( DataBuffer, strlen( DataBuffer ) );

}

#endif

VOID
NdrpAllocaInit(
    PNDR_ALLOCA_CONTEXT pAllocaContext
    )
/*++

Routine Description :

    Initiaizes the alloca context. 

Arguments :

    pAllocaContext  - Pointer to the Alloca context..

Return :

    None.

--*/
{

    pAllocaContext->pBlockPointer = pAllocaContext->PreAllocatedBlock;
    pAllocaContext->BytesRemaining = NDR_ALLOCA_PREALLOCED_BLOCK_SIZE;

#if defined(NDR_PROFILE_ALLOCA)
    pAllocaContext->AllocaBytes = 0;
    pAllocaContext->AllocaAllocations = 0;
    pAllocaContext->MemoryBytes = 0;
    pAllocaContext->MemoryAllocations = 0;
#endif
    
    InitializeListHead( &pAllocaContext->MemoryList );

}

VOID
NdrpAllocaDestroy(
    PNDR_ALLOCA_CONTEXT pAllocaContext
    )
/*++

Routine Description :

    Deinitializes this Alloca context and frees all memory
    from the allocation calls that were associated with this context. 

Arguments :

    pAllocaContext  - Pointer to the Alloca context.

Return :

    None.

--*/
{

#if defined(NDR_PROFILE_ALLOCA)
    NdrpAllocaDumpStatistics( pAllocaContext );
#endif

    PLIST_ENTRY pMemoryList = pAllocaContext->MemoryList.Flink; 

    while( pMemoryList != &pAllocaContext->MemoryList ) 
       {
       PLIST_ENTRY pMemoryListNext = pMemoryList->Flink;
       
       I_RpcFree( pMemoryList );
       
       pMemoryList = pMemoryListNext;
       }

    InitializeListHead( &pAllocaContext->MemoryList );

}

PVOID 
NdrpAlloca(
    PNDR_ALLOCA_CONTEXT pAllocaContext,
    UINT Size 
    )
/*++

Routine Description :

    Allocates memory from the allocation context. If no memory is available 
    in the cache, more memory is added.  If more memory can not be
    added, a RPC_S_NO_MEMORY exception is raised.     

Arguments :

    pAllocaContext  - Pointer to the Alloca context.
    Size            - Size of the memory to allocate.

Return :

    Newly allocated memory.

--*/
{
    PVOID pReturnedBlock;

    LENGTH_ALIGN( Size, 15 );

#if defined(NDR_PROFILE_ALLOCA)
    pAllocaContext->AllocaAllocations++;
    pAllocaContext->AllocaBytes += Size;
#endif

    // Check if the current block has enough memory to handle the request.
    if (Size > pAllocaContext->BytesRemaining) 
       {

       // Allocate a new block
       ULONG NewBlockSize = max( Size + sizeof(LIST_ENTRY), 
                                 NDR_ALLOCA_MIN_BLOCK_SIZE );

#if defined(NDR_PROFILE_ALLOCA)
       pAllocaContext->MemoryAllocations++;
       pAllocaContext->MemoryBytes += NewBlockSize;
#endif

       PBYTE pNewBlock = (PBYTE)I_RpcAllocate( NewBlockSize );

       if ( !pNewBlock ) 
          {
          
          RpcRaiseException( RPC_S_OUT_OF_MEMORY );
          return NULL; // keep the compiler happy
          }

       InsertHeadList( &pAllocaContext->MemoryList, (PLIST_ENTRY) pNewBlock);
       pAllocaContext->pBlockPointer = pNewBlock + sizeof(LIST_ENTRY);
       pAllocaContext->BytesRemaining = NewBlockSize - sizeof(LIST_ENTRY);

       }

    // alloc memory from an existing block.
    pReturnedBlock = pAllocaContext->pBlockPointer;
    pAllocaContext->pBlockPointer += Size;
    pAllocaContext->BytesRemaining -= Size;

    return pReturnedBlock;

}

PVOID
NdrpPrivateAllocate(
    PNDR_ALLOCA_CONTEXT pAllocaContext,
    UINT Size 
    )
/*++

Routine Description :

    Allocates memory using I_RpcAllocate and adds the memory to the
    memory list block.  If no memory is available, and RPC_S_OUT_OF_MEMORY exception
    is thrown.     

Arguments :

    pAllocaContext  - Pointer to the Alloca context.
    Size            - Size of the memory to allocate.

Return :

    Newly allocated memory.

--*/
{
    PBYTE pNewBlock = (PBYTE)NdrpAlloca( pAllocaContext, Size );

    if ( !pNewBlock ) 
       {
       RpcRaiseException( RPC_S_OUT_OF_MEMORY );
       return NULL; // keep the compiler happy
       }

    return (uchar *)pNewBlock ;

}

void
NdrpPrivateFree(
    PNDR_ALLOCA_CONTEXT pAllocaContext,
    void *pMemory 
    )
/*++

Routine Description :

    Frees memory allocated with NdrpPrivateAllocate     

Arguments :

    pAllocaContext  - Pointer to the Alloca context.
    pMemory         - Memory allocated with NdrpPrivateAllocate.

Return :

    None.

--*/
{
    return;
}

void
NdrpInitUserMarshalCB(
    MIDL_STUB_MESSAGE   *   pStubMsg,
    PFORMAT_STRING          pFormat,
    USER_MARSHAL_CB_TYPE    CBType,
    USER_MARSHAL_CB     *   pUserMarshalCB
    )
/*++

Routine Description :

    Initialize a user marshall callback structure.
    
Arguments :

    pStubMsg         - Supplies the stub message for the call.
    pFormat          - Supplies the format string for the type(FC_USER_MARSHAL). 
    CBType           - Supplies the callback type.   
    pUserMarshalCB   - Pointer to the callback to be initialized.

Return :

    None.

--*/
{

    pUserMarshalCB->Flags    = USER_CALL_CTXT_MASK( pStubMsg->dwDestContext );
    if ( USER_MARSHAL_CB_UNMARSHALL == CBType )
        {
        pUserMarshalCB->Flags |=
            (((pStubMsg->RpcMsg->DataRepresentation & (ulong)0x0000FFFF)) << 16 );  
        }
    if ( pStubMsg->pAsyncMsg )
        pUserMarshalCB->Flags |= USER_CALL_IS_ASYNC;
    if ( pStubMsg->fHasNewCorrDesc )
        pUserMarshalCB->Flags |= USER_CALL_NEW_CORRELATION_DESC;
    
    pUserMarshalCB->pStubMsg = pStubMsg;
    pUserMarshalCB->pReserve = (pFormat[1] & USER_MARSHAL_IID)  ? pFormat + 10
                                                                : 0;
    pUserMarshalCB->Signature = USER_MARSHAL_CB_SIGNATURE;
    pUserMarshalCB->CBType = CBType;

    pUserMarshalCB->pFormat = pFormat;
    pUserMarshalCB->pTypeFormat = pFormat + 8;
    pUserMarshalCB->pTypeFormat = pUserMarshalCB->pTypeFormat +
                                  *(short *)pUserMarshalCB->pTypeFormat;

}

RPC_STATUS
RPC_ENTRY
NdrGetUserMarshalInfo (
    IN unsigned long          * pFlags,
    IN unsigned long            InformationLevel,
    OUT NDR_USER_MARSHAL_INFO * pMarshalInfo
    )
/*++

Routine Description :

    The NdrGetUserMarshalInfo function is called by a application provided
    wire_marshal or user_marshal helper function to receive extra information
    in addition to the pFlags parameter.
    
Arguments :

    pFlags           - Supplies the pFlags pointer that rpc passed to the helper function.
    InformationLevel - Supplies the desired level of detail to be received. The amount of
                       information increases as the level increases.  
    pMarshalInfo     - Points to the buffer that is to receive the extra information.   

Return :

    On sucesss - RPC_S_OK.

--*/
{

    MIDL_STUB_MESSAGE *pStubMsg;
    USER_MARSHAL_CB * pCBInfo = (USER_MARSHAL_CB *)pFlags; 

    if ( InformationLevel != 1)
       {
       return RPC_S_INVALID_ARG;
       }

    RpcTryExcept
       {
       if ( USER_MARSHAL_CB_SIGNATURE != pCBInfo->Signature )
          {
          return RPC_S_INVALID_ARG;    
          }
       MIDL_memset( pMarshalInfo, 0, sizeof(NDR_USER_MARSHAL_INFO) ); 
       }
    RpcExcept(1)
        {
        return RPC_S_INVALID_ARG;
        }
    RpcEndExcept   

       
    pMarshalInfo->InformationLevel = InformationLevel;
    pStubMsg = pCBInfo->pStubMsg;

    // The buffer pointer and the buffer length only
    // make sense if the callback is for marshalling
    // and unmarshalling.
    if ( USER_MARSHAL_CB_MARSHALL == pCBInfo->CBType ||
         USER_MARSHAL_CB_UNMARSHALL == pCBInfo->CBType )
       {

       char *CurrentBuffer = (char *)pStubMsg->Buffer;
       char *BufferStart = (char *)pStubMsg->RpcMsg->Buffer;
       unsigned long BufferUsed = (unsigned long)(ULONG_PTR)(CurrentBuffer 
                                                             - BufferStart);   
       unsigned long BufferLength = pStubMsg->RpcMsg->BufferLength - BufferUsed;

       if ( CurrentBuffer < BufferStart ||
            CurrentBuffer > (BufferStart + pStubMsg->RpcMsg->BufferLength ) )
          {
             return RPC_X_INVALID_BUFFER;
          }
       
       pMarshalInfo->Level1.Buffer = pStubMsg->Buffer;
       pMarshalInfo->Level1.BufferSize = BufferLength;
       }
    
    pMarshalInfo->Level1.pfnAllocate = pStubMsg->pfnAllocate;
    pMarshalInfo->Level1.pfnFree = pStubMsg->pfnFree;
    pMarshalInfo->Level1.pRpcChannelBuffer = pStubMsg->pRpcChannelBuffer;
    pMarshalInfo->Level1.Reserved[0] = (ULONG_PTR)pCBInfo->pFormat;
    pMarshalInfo->Level1.Reserved[1] = (ULONG_PTR)pCBInfo->pTypeFormat;

    return RPC_S_OK;    

}



void RPC_ENTRY
RpcUserFree( HANDLE AsyncHandle, void * pBuffer )
{
    PMIDL_STUB_MESSAGE pStubMsg;
    RPC_STATUS Status;
    PRPC_ASYNC_STATE pHandle = ( PRPC_ASYNC_STATE) AsyncHandle;
    // User passes in NULL in sync case.
    if ( NULL == pHandle )
        {
        pStubMsg = (PMIDL_STUB_MESSAGE )I_RpcGetNDRSlot();
        Status = S_OK;
        }
    else
        {
        Status = NdrValidateBothAndLockAsyncHandle( pHandle);
        if ( Status == RPC_S_OK )
            {
            PNDR_ASYNC_MESSAGE pAsyncMsg = (PNDR_ASYNC_MESSAGE) pHandle->StubInfo;
            pStubMsg = &pAsyncMsg->StubMsg;
            }
        }

    // REVIEW: default behavior is not to raise exception?
    if ( Status != RPC_S_OK )
        {
        NDR_ASSERT( 0, "invalid rpc handle" );
        return ;
        }
        
    // validate the stubmsg.
    NDR_ASSERT( pStubMsg, "invalid stub message" );

    // We'll call into user's free routine to free the buffer if it's not 
    // part of dispatch buffer. 
    // We don't care about allocate_on_stack: it can only happen on top level
    // out ref pointer or ref pointer to pointer case, and freeing that is 
    // very much shooting self on the foot.
    if (  (pBuffer < pStubMsg->BufferStart) || (pBuffer > pStubMsg->BufferEnd))
        {
        pStubMsg->pfnFree( pBuffer );
        }
    else
        return;
        
}


BOOL
IsWriteAV (

    IN struct _EXCEPTION_POINTERS *ExceptionPointers

    )

{

    EXCEPTION_RECORD *ExceptionRecord;

 

    ExceptionRecord = ExceptionPointers->ExceptionRecord;

    if ((ExceptionRecord->ExceptionCode == STATUS_ACCESS_VIOLATION)

        && (ExceptionRecord->ExceptionInformation[0]))

        {

        return TRUE;

        }

    else

        return FALSE;

}


int RPC_ENTRY
NdrServerUnmarshallExceptionFlag(
    IN struct _EXCEPTION_POINTERS *ExceptionPointers
)
{
    RPC_STATUS ExceptCode = ExceptionPointers->ExceptionRecord->ExceptionCode;
    if ( ( ExceptCode != STATUS_POSSIBLE_DEADLOCK )  && 
        ( ExceptCode != STATUS_INSTRUCTION_MISALIGNMENT )   && 
        ( ExceptCode != STATUS_DATATYPE_MISALIGNMENT )  && 
        ( ExceptCode != STATUS_PRIVILEGED_INSTRUCTION )  && 
        ( ExceptCode != STATUS_ILLEGAL_INSTRUCTION )  && 
        ( ExceptCode != STATUS_BREAKPOINT ) && 
        ( ExceptCode != STATUS_STACK_OVERFLOW ) && 
        !IsWriteAV(ExceptionPointers) ) 
        return EXCEPTION_EXECUTE_HANDLER;
    else
        return EXCEPTION_CONTINUE_SEARCH;
                
}



// check for overflow when calculating the total size. 
#if defined(_X86_)
ULONG MultiplyWithOverflowCheck( ULONG_PTR Count, ULONG_PTR ELemSize )
{
    register UINT32 IsOverFlowed = 0;
    NDR_CORRUPTION_ASSERT(  Count < 0x80000000, "invalid count" );
    NDR_CORRUPTION_ASSERT(  ELemSize < 0x80000000 , "invalid element size" );
    ULONG res = Count * ELemSize;
    __asm 
        {
        jno skip;
        mov IsOverFlowed, 1;
        skip:
        }
    if ( IsOverFlowed || res > 0x7fffffff )
        RpcRaiseException( RPC_X_INVALID_BOUND );

    return res;
}
#else   // we only have ia64 & amd64 here.
ULONG MultiplyWithOverflowCheck( ULONG_PTR Count, ULONG_PTR ElemSize )
{
    NDR_CORRUPTION_ASSERT( Count < 0x80000000, "invalid count" );
    NDR_CORRUPTION_ASSERT( ElemSize < 0x80000000 , "invalid element size" );
    UINT64 res = (UINT64)Count * ElemSize;
    if ( res > 0x7fffffff )
        RpcRaiseException( RPC_X_INVALID_BOUND );

    return (ULONG) res ;
}
#endif

void
NdrpInitArrayInfo( PMIDL_STUB_MESSAGE pStubMsg, ARRAY_INFO * pArrayInfo )
{
    // we cannot use pArrayInfo from stack if we are in pointer queue; also, pPointerQueueState
    // could be NULL if we have top level multiD array and pointer queue is on always. We have
    // to use stack in that case too. 
    if ( !NdrIsLowStack(pStubMsg) || (pStubMsg->pPointerQueueState == NULL ) )
        {
        pStubMsg->pArrayInfo = pArrayInfo;
        }
    else
        {
        NDR_POINTER_QUEUE_STATE *pActiveState = pStubMsg->pPointerQueueState;
        NDR_ASSERT( pActiveState != NULL, "invaild pointer queue");
        if ( pActiveState )
            pStubMsg->pArrayInfo = pActiveState->GetArrayInfo();    
        else
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
        }
        
    pStubMsg->pArrayInfo->Dimension = 0;
    pStubMsg->pArrayInfo->BufferConformanceMark = (unsigned long *)pStubMsg->BufferMark;
    pStubMsg->pArrayInfo->BufferVarianceMark = 0;
    pStubMsg->pArrayInfo->MaxCountArray = (unsigned long *) pStubMsg->MaxCount;
    pStubMsg->pArrayInfo->OffsetArray = (ulong *) UlongToPtr( pStubMsg->Offset );
    pStubMsg->pArrayInfo->ActualCountArray = (ulong *) UlongToPtr( pStubMsg->ActualCount );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr20\auxilary.h ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1993-2000 Microsoft Corporation

Module Name :

    auxilary.h

Abstract :

Author :

Revision History :

  ---------------------------------------------------------------------*/

#ifndef _AUXILARY_H
#define _AUXILARY_H

typedef
RPC_STATUS ( RPC_ENTRY *RPC_NS_GET_BUFFER_ROUTINE)(
    IN PRPC_MESSAGE         Message
    );

typedef
RPC_STATUS ( RPC_ENTRY *RPC_NS_SEND_RECEIVE_ROUTINE)(
    IN PRPC_MESSAGE          Message,
    OUT RPC_BINDING_HANDLE * Handle
    );

typedef
RPC_STATUS ( RPC_ENTRY *RPC_NS_NEGOTIATETRANSFERSYNTAX_ROUTINE) (
    IN OUT PRPC_MESSAGE     Message
    );



EXTERN_C void
NdrpSetRpcSsDefaults( RPC_CLIENT_ALLOC *pfnAlloc,
                      RPC_CLIENT_FREE *pfnFree);

extern RPC_NS_GET_BUFFER_ROUTINE       pRpcNsGetBuffer;
extern RPC_NS_SEND_RECEIVE_ROUTINE     pRpcNsSendReceive;
extern RPC_NS_NEGOTIATETRANSFERSYNTAX_ROUTINE  pRpcNsNegotiateTransferSyntax;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr20\attack.h ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1996 Microsoft Corporation

Module Name :

    attack.c

Abstract :

    This file contains code for the ndr correlation checks related to attacks
    on the marshaling buffer.

Author :

    Ryszard K. Kott     (ryszardk)    Sep 1997

Revision History :

---------------------------------------------------------------------*/

#include "ndrp.h"
#include "hndl.h"
#include "ndrole.h"

#if !defined(__ATTACK_H__)
#define  __ATTACK_H__

#define NO_CORRELATION

#define CORRELATION_RESOURCE_SAVE   \
            uchar *         pCorrMemorySave;

#define F_CORRELATION_CHECK         (pStubMsg->pCorrInfo != 0)

#define SAVE_CORRELATION_MEMORY()  \
            pCorrMemorySave = pStubMsg->pCorrMemory;

#define SET_CORRELATION_MEMORY( pMem )  \
            pCorrMemorySave = pStubMsg->pCorrMemory; \
            pStubMsg->pCorrMemory = pMem; 

#define RESET_CORRELATION_MEMORY()  \
            pStubMsg->pCorrMemory = pCorrMemorySave;  

#define NDR_CORR_EXTENSION_SIZE  2

#define CORRELATION_DESC_INCREMENT( pFormat ) \
            if ( pStubMsg->fHasNewCorrDesc ) \
                pFormat += NDR_CORR_EXTENSION_SIZE;

#define FC_CORR_NORMAL_CONFORMANCE           (FC_NORMAL_CONFORMANCE    >> 4  /* 0 */)
#define FC_CORR_POINTER_CONFORMANCE          (FC_TOP_LEVEL_CONFORMANCE >> 4  /* 1 */)
#define FC_CORR_TOP_LEVEL_CONFORMANCE        (FC_TOP_LEVEL_CONFORMANCE >> 4  /* 2 */)
#define FC_CORR_CONSTANT_CONFORMANCE         (FC_TOP_LEVEL_CONFORMANCE >> 4  /* 4 */)
#define FC_CORR_TOP_LEVEL_MULTID_CONFORMANCE (FC_TOP_LEVEL_MULTID_CONFORMANCE >> 4 /* 8 */)

#define NDR_CHECK_CONFORMANCE   0
#define NDR_CHECK_VARIANCE      1
#define NDR_CHECK_OFFSET        2
#define NDR_RESET_VALUE         8   // This can be or'd with one of the above

typedef  struct  _NDR_FCDEF_CORRELATION
    {
    unsigned short          Type      : 4;
    unsigned short          Kind      : 4;
    unsigned short          Operation : 8;
             short          Offset;
    NDR_CORRELATION_FLAGS   CorrFlags;
    unsigned short          Reserved  : 8;
    } NDR_FCDEF_CORRELATION, *PNDR_FCDEF_CORRELATION;


typedef struct _NDR_CORRELATION_INFO_HEADER
    {
    struct _NDR_CORRELATION_INFO *  pCache;
    struct _NDR_CORRELATION_INFO *  pInfo;
    long                            DataSize;
    long                            DataLen;
    } NDR_CORRELATION_INFO_HEADER;

typedef struct _NDR_CORRELATION_INFO_DATA
    {
    unsigned char *                 pMemoryObject;
    PFORMAT_STRING                  pCorrDesc;
    LONG_PTR                        Value;
    long                            CheckKind;
#if defined(__RPC_WIN64__)
    long                            Reserve64;
#endif
    } NDR_CORRELATION_INFO_DATA;

typedef struct _NDR_CORRELATION_INFO
    {
    NDR_CORRELATION_INFO_HEADER         Header;
    NDR_CORRELATION_INFO_DATA           Data[1];
    } NDR_CORRELATION_INFO, *PNDR_CORRELATION_INFO;


typedef  struct  _NDR_DEF_FC_RANGE
    {
    unsigned char           FcToken;
    unsigned char           Type      : 4;
    unsigned char           ConfFlags : 4;
    unsigned long           Low;
    unsigned long           High;
    } NDR_DEF_FC_RANGE, *PNDR_DEF_FC_RANGE;



void 
NdrpCheckCorrelation(
    PMIDL_STUB_MESSAGE  pStubMsg,
    LONG_PTR            Value,
    PFORMAT_STRING      pFormat,
    int                 CheckKind );

void
NdrpAddCorrelationData( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat,
    LONG_PTR            Value,
    int                 CheckKind );

void
NdrpValidateCorrelatedValue ( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat,
    LONG_PTR            Value,
    int                 CheckKind );

#endif // __ATTACK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr20\bufsizep.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright <c> 1993 Microsoft Corporation

Module Name :

    sizep.h

Abtract :

    Contains private sizing routine definitions.

Author :

    David Kays  dkays   October 1993

Revision History :

--------------------------------------------------------------------*/

typedef     void	(RPC_ENTRY * PSIZE_ROUTINE)(
                        PMIDL_STUB_MESSAGE	pStubMsg,
						uchar *				pMemory,
                        PFORMAT_STRING		pFormat
                    );

typedef     void	(* PPRIVATE_SIZE_ROUTINE)(
                        PMIDL_STUB_MESSAGE	pStubMsg,
						uchar *				pMemory,
                        PFORMAT_STRING		pFormat
                    );

IMPORTSPEC
extern const PSIZE_ROUTINE * pfnSizeRoutines;

void
NdrpPointerBufferSize ( 
	PMIDL_STUB_MESSAGE  pStubMsg,
    uchar * 			pMemory,
    PFORMAT_STRING		pFormat
	);

void
NdrpConformantArrayBufferSize ( 
	PMIDL_STUB_MESSAGE  pStubMsg,
    uchar * 			pMemory,
    PFORMAT_STRING		pFormat
	);

void
NdrpConformantVaryingArrayBufferSize ( 
	PMIDL_STUB_MESSAGE	pStubMsg,
    uchar * 			pMemory,
    PFORMAT_STRING		pFormat
	);

void
NdrpComplexArrayBufferSize ( 
	PMIDL_STUB_MESSAGE	pStubMsg,
    uchar * 			pMemory,
    PFORMAT_STRING		pFormat
	);

void
NdrpConformantStringBufferSize ( 
	PMIDL_STUB_MESSAGE	pStubMsg,
    uchar * 			pMemory,
    PFORMAT_STRING		pFormat
	);

void
NdrpUnionBufferSize(
	PMIDL_STUB_MESSAGE	pStubMsg,
    uchar *       		pMemory,
    PFORMAT_STRING		pFormat,
	long				SwitchIs,
	uchar				SwitchType
    );

void
NdrpEmbeddedPointerBufferSize(
	PMIDL_STUB_MESSAGE	pStubMsg,
    uchar *       		pMemory,
    PFORMAT_STRING		pFormat
    );

void
NdrpEmbeddedRepeatPointerBufferSize(
	PMIDL_STUB_MESSAGE	pStubMsg,
    uchar *         	pMemory,
    PFORMAT_STRING *	ppFormat
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr20\bufsize.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1993-2000 Microsoft Corporation

Module Name :

    bufsize.c

Abstract :

    This file contains the routines called by MIDL 2.0 stubs and the 
    interpreter for computing the buffer size needed for a parameter.  

Author :

    David Kays  dkays   September 1993.

Revision History :

  ---------------------------------------------------------------------*/

#include "ndrp.h"
#include "ndrole.h"
#include "attack.h"
#include "pointerq.h"

RPCRTAPI
void RPC_ENTRY
NdrUDTSimpleTypeSize( 
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char *         pMemory,
    PFORMAT_STRING          pFormat
    );

extern const
PSIZE_ROUTINE   SizeRoutinesTable[] =
                {
                NdrUDTSimpleTypeSize,
                NdrUDTSimpleTypeSize,
                NdrUDTSimpleTypeSize,
                NdrUDTSimpleTypeSize,
                NdrUDTSimpleTypeSize,
                NdrUDTSimpleTypeSize,
                NdrUDTSimpleTypeSize,
                NdrUDTSimpleTypeSize,
                NdrUDTSimpleTypeSize,
                NdrUDTSimpleTypeSize,
                NdrUDTSimpleTypeSize,
                NdrUDTSimpleTypeSize,
                NdrUDTSimpleTypeSize,
                NdrUDTSimpleTypeSize,
                NdrUDTSimpleTypeSize,
                NdrUDTSimpleTypeSize,
                NdrUDTSimpleTypeSize,
                
                NdrPointerBufferSize,
                NdrPointerBufferSize,
                NdrPointerBufferSize,
                NdrPointerBufferSize,

                NdrSimpleStructBufferSize,
                NdrSimpleStructBufferSize,
                NdrConformantStructBufferSize,
                NdrConformantStructBufferSize,
                NdrConformantVaryingStructBufferSize,

                NdrComplexStructBufferSize,

                NdrConformantArrayBufferSize,
                NdrConformantVaryingArrayBufferSize,
                NdrFixedArrayBufferSize,
                NdrFixedArrayBufferSize,
                NdrVaryingArrayBufferSize,
                NdrVaryingArrayBufferSize,

                NdrComplexArrayBufferSize,

                NdrConformantStringBufferSize,
                NdrConformantStringBufferSize,
                NdrConformantStringBufferSize,
                NdrConformantStringBufferSize,

                NdrNonConformantStringBufferSize,
                NdrNonConformantStringBufferSize,
                NdrNonConformantStringBufferSize,
                NdrNonConformantStringBufferSize,

                NdrEncapsulatedUnionBufferSize,
                NdrNonEncapsulatedUnionBufferSize,
    
                NdrByteCountPointerBufferSize,

                NdrXmitOrRepAsBufferSize,  // transmit as
                NdrXmitOrRepAsBufferSize,  // represent as

                NdrPointerBufferSize,

                NdrContextHandleSize,

                // New Post NT 3.5 token serviced from here on.

                0,                         // NdrHardStructBufferSize,

                NdrXmitOrRepAsBufferSize,  // transmit as ptr
                NdrXmitOrRepAsBufferSize,  // represent as ptr

                NdrUserMarshalBufferSize,

                0,   // FC_PIPE 
                0,   // FC_BLK_HOLE

                NdrpRangeBufferSize,

                0,   // FC_INT3264
                0,   // FC_UINT3264

                0, // NdrCsArrayBufferSize,
                0, // NdrCsTagBufferSize
                };

const
PSIZE_ROUTINE * pfnSizeRoutines = SizeRoutinesTable;

void
NdrpInterfacePointerBufferSize ( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat );

RPCRTAPI
void RPC_ENTRY
NdrTypeSize( 
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char *         pMemory,
    PFORMAT_STRING          pFormat
    )
{
    (*pfnSizeRoutines[ROUTINE_INDEX(*pFormat)])( pStubMsg,
                                                 pMemory,
                                                 pFormat );
}


void RPC_ENTRY
NdrUDTSimpleTypeSize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Get the size a top level or embedded simple type.

    Used for VT_USERDEFINED but in fact simple types,
    like TKIND_ENUM and TKIND_ALIAS

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the data being sized.
    pFormat     - Pointer's format string description.

Return :

    None.

--*/
{
    LENGTH_ALIGN( pStubMsg->BufferLength,
                  SIMPLE_TYPE_ALIGNMENT(*pFormat) );

    pStubMsg->BufferLength += SIMPLE_TYPE_BUFSIZE(*pFormat);

    pMemory += SIMPLE_TYPE_MEMSIZE(*pFormat);
}



void RPC_ENTRY
NdrPointerBufferSize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Computes the needed buffer size for a top level pointer to anything.
    Pointers embedded in structures, arrays, or unions call 
    NdrpPointerBufferSize directly.

    Used for FC_RP, FC_UP, FC_FP, FC_OP.

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the data being sized.
    pFormat     - Pointer's format string description.

Return :

    None.

--*/
{
    //
    // Add 4 bytes for a unique or full pointer.
    //
    if ( *pFormat != FC_RP )
        {
        LENGTH_ALIGN(pStubMsg->BufferLength,0x3);

        pStubMsg->BufferLength += PTR_WIRE_SIZE;
        }

    NdrpPointerBufferSize( pStubMsg,
                           pMemory,
                           pFormat );
}
    

__forceinline void 
NdrpPointerBufferSizeInternal( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Private routine for sizing a pointee.  This is the entry
    point for pointers embedded in structures, arrays, or unions.

    Used for FC_RP, FC_UP, FC_FP, FC_OP.

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the data being sized.
    pFormat     - Pointer's format string description.
    
    pStubMsg->BufferLength - ready for the pointee.

Return :

    None.

--*/
{

    if ( FC_IP == *pFormat )
        {

        if ( IS_BROKEN_INTERFACE_POINTER(pStubMsg->uFlags) )
            {
            // The pointee is effectivly both the pointer
            // and the pointee.

            NdrInterfacePointerBufferSize( 
                pStubMsg,
                pMemory,
                pFormat );
            return;
            }

        if ( ! pMemory )
            return;

        NdrpInterfacePointerBufferSize( pStubMsg,
                                        pMemory,
                                        pFormat );
        return;
        }

    uchar   uFlagsSave;

    if ( ! pMemory )
        return;

    if ( *pFormat == FC_FP )
        {
        //
        // Check if we have already sized this full pointer.
        //
        if ( NdrFullPointerQueryPointer( pStubMsg->FullPtrXlatTables,
                                         pMemory,
                                         FULL_POINTER_BUF_SIZED,
                                         0 ) )
            return;
        }

    if ( ! SIMPLE_POINTER(pFormat[1]) )
        {
        //
        // Pointer to complex type.
        //
        if ( POINTER_DEREF(pFormat[1]) )
            pMemory = *((uchar **)pMemory);

        pFormat += 2;

        pFormat += *((signed short *)pFormat);
        }
    else
        {
        switch ( pFormat[2] )
            {
            case FC_C_CSTRING :
            case FC_C_BSTRING :
            case FC_C_WSTRING :
            case FC_C_SSTRING :
                // Increment to the string description.
                pFormat += 2;
                break;
    
            default :
                //
                // Pointer to simple type.  Make an upper bound estimate.
                //
                SIMPLE_TYPE_BUF_INCREMENT(pStubMsg->BufferLength, pFormat[2]);
                return;
            }
        }

    uFlagsSave = pStubMsg->uFlags;
    RESET_CONF_FLAGS_TO_STANDALONE(pStubMsg->uFlags);

    (*pfnSizeRoutines[ROUTINE_INDEX(*pFormat)])( pStubMsg,
                                                 pMemory,
                                                 pFormat );
    pStubMsg->uFlags = uFlagsSave;
}

NDR_BUFSIZE_POINTER_QUEUE_ELEMENT::NDR_BUFSIZE_POINTER_QUEUE_ELEMENT( 
    MIDL_STUB_MESSAGE *pStubMsg, 
    uchar * const pMemoryNew,
    const PFORMAT_STRING pFormatNew) :

        pMemory(pMemoryNew),
        pFormat(pFormatNew),
        Memory(pStubMsg->Memory),
        uFlags(pStubMsg->uFlags)
{

}

void 
NDR_BUFSIZE_POINTER_QUEUE_ELEMENT::Dispatch(
    MIDL_STUB_MESSAGE *pStubMsg) 
{
    SAVE_CONTEXT<uchar*> MemorySave( pStubMsg->Memory, Memory );
    SAVE_CONTEXT<uchar> uFlagsSave( pStubMsg->uFlags, uFlags );
    NDR_ASSERT( !pStubMsg->PointerBufferMark, "PointerBufferMark is not 0\n");

    NdrpPointerBufferSizeInternal( pStubMsg,
                                   pMemory,
                                   pFormat );
}                          

#if defined(DBG)
void 
NDR_BUFSIZE_POINTER_QUEUE_ELEMENT::Print() 
{
    DbgPrint("NDR_BUFSIZE_POINTER_QUEUE_ELEMENT\n");
    DbgPrint("pNext:                   %p\n", pNext );
    DbgPrint("pMemory:                 %p\n", pMemory );
    DbgPrint("pFormat:                 %p\n", pFormat );
    DbgPrint("Memory:                  %p\n", Memory );
    DbgPrint("uFlags:                  %x\n", uFlags );
}
#endif

void
NdrpEnquePointerBufferSize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
{
   NDR32_POINTER_CONTEXT PointerContext( pStubMsg );

   RpcTryFinally
   {
       NDR_BUFSIZE_POINTER_QUEUE_ELEMENT *pElement = 
           new(PointerContext.GetActiveState()) 
               NDR_BUFSIZE_POINTER_QUEUE_ELEMENT(pStubMsg,
                                                 pMemory,
                                                 pFormat);
       PointerContext.Enque( pElement );
       PointerContext.DispatchIfRequired();

   }
   RpcFinally
   {
       PointerContext.EndContext();
   }
   RpcEndFinally

}

void
NdrpPointerBufferSize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
{

    if ( !NdrIsLowStack( pStubMsg ) )
        {
        NdrpPointerBufferSizeInternal( pStubMsg,
                                       pMemory,
                                       pFormat );
        return;
        }

    NdrpEnquePointerBufferSize(
        pStubMsg,
        pMemory,
        pFormat );

}


void RPC_ENTRY
NdrpRangeBufferSize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Computes the buffer size needed for a simple type with range on it.
    Used for FC_RANGE.

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the structure being sized.
    pFormat     - Structure's format string description.

Return :

    None.

--*/
{
    // This routine is needed because the precomputed buf size is missing in some cases.
    // So it is cheaper to have the routine than to change code paths elsewhere.

    FORMAT_CHARACTER    FcType = (FORMAT_CHARACTER)(pFormat[1] & 0x0f);

    LENGTH_ALIGN( pStubMsg->BufferLength, SIMPLE_TYPE_ALIGNMENT(FcType) );
    pStubMsg->BufferLength += SIMPLE_TYPE_BUFSIZE(FcType);
}


void RPC_ENTRY
NdrSimpleStructBufferSize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Computes the buffer size needed for a simple structure.

    Used for FC_STRUCT and FC_PSTRUCT.

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the structure being sized.
    pFormat     - Structure's format string description.

Return :

    None.

--*/
{
    LENGTH_ALIGN(pStubMsg->BufferLength,pFormat[1]);

    // Add size of the structure.
    pStubMsg->BufferLength += (ulong) *((ushort *)(pFormat + 2));  

    //
    // Add size of embedded pointers.
    //
    if ( *pFormat == FC_PSTRUCT ) 
        {
        NdrpEmbeddedPointerBufferSize( pStubMsg,
                                       pMemory, 
                                       pFormat + 4 );
        }
}


void RPC_ENTRY
NdrConformantStructBufferSize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Computes the buffer size needed for a conformant structure.

    Used for FC_CSTRUCT and FC_CPSTRUCT.

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the structure being sized.
    pFormat     - Structure's format string description.

Return :

    None.

--*/
{
    PFORMAT_STRING  pFormatArray;
    ulong           FlatSize;

    // set by the embedding complex struct
    uchar           fIsEmbeddedStructSave = IS_EMBED_CONF_STRUCT( pStubMsg->uFlags );

    // accounted for by the outermost embedding complex struct
    if ( !fIsEmbeddedStructSave )
        {
        // Align and add size for conformance count.
        LENGTH_ALIGN(pStubMsg->BufferLength,0x3);

        pStubMsg->BufferLength += 4;
        }
    
    // Align 
    LENGTH_ALIGN(pStubMsg->BufferLength, pFormat[1] );

    FlatSize = (ulong) *((ushort *)(pFormat + 2));

    pStubMsg->BufferLength += FlatSize;

    // Increment to the offset to array description.
    pFormat += 4;

    pFormatArray = pFormat + *((signed short *)pFormat);

    //
    // Size our array - pass a memory pointer to the conformant array.
    //
    NdrpConformantArrayBufferSize( pStubMsg,
                                   pMemory + FlatSize,
                                   pFormatArray );

    pFormat += 2;

    if ( *pFormat == FC_PP )  
        {
        NdrpEmbeddedPointerBufferSize( pStubMsg,
                                       pMemory,
                                       pFormat );
        }

    // Set the reverse flag to signal that array has been marshaled.

    if ( fIsEmbeddedStructSave )
        SET_CONF_ARRAY_DONE( pStubMsg->uFlags );
}


void RPC_ENTRY
NdrConformantVaryingStructBufferSize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Computes the buffer size needed for a conformant varying structure.

    Used for FC_CVSTRUCT.

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the structure being sized.
    pFormat     - Structure's format string description.

Return :

    None.

--*/
{
    PPRIVATE_SIZE_ROUTINE   pfnSize;
    PFORMAT_STRING          pFormatArray;
    ulong                   FlatSize;

    // set by the outermost embedding complex struct
    uchar                   fIsEmbeddedStructSave = IS_EMBED_CONF_STRUCT( pStubMsg->uFlags );

    // accounted for by the outermost embedding complex struct
    if ( !fIsEmbeddedStructSave )
        {
        // Align
        LENGTH_ALIGN(pStubMsg->BufferLength,0x3);

        pStubMsg->BufferLength += 4;
        }

    // Align 
    LENGTH_ALIGN(pStubMsg->BufferLength, pFormat[1] );

    FlatSize = (ulong) *((ushort *)(pFormat + 2));

    pStubMsg->BufferLength += FlatSize;

    // Increment to the offset to array description.
    pFormat += 4;

    pFormatArray = pFormat + *((signed short *)pFormat);

    switch ( *pFormatArray ) 
        {
        case FC_CVARRAY :
            pfnSize = NdrpConformantVaryingArrayBufferSize;
            break;
        default :
            pfnSize = NdrpConformantStringBufferSize;
            break;
        }

    (*pfnSize)( pStubMsg,
                pMemory + FlatSize,
                pFormatArray );

    pFormat += 2;

    if ( *pFormat == FC_PP ) 
        {
        pStubMsg->MaxCount = pStubMsg->ActualCount;
        
        NdrpEmbeddedPointerBufferSize( pStubMsg,
                                       pMemory,
                                       pFormat );
        }

    // Set the reverse flag to signal that array has been marshaled.

    if ( fIsEmbeddedStructSave )
        SET_CONF_ARRAY_DONE( pStubMsg->uFlags );
}


#if 0
void RPC_ENTRY
NdrHardStructBufferSize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Computes the buffer size needed for a hard structure.

    Used for FC_HARD_STRUCT.

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the structure being sized.
    pFormat     - Structure's format string description.

Return :

    None.

--*/
{
    LENGTH_ALIGN(pStubMsg->BufferLength,pFormat[1]);

    pStubMsg->BufferLength += *((ushort *)&pFormat[10]);

    if ( *((short *)&pFormat[14]) )
        {
        pFormat += 12;

        pMemory += *((ushort *)pFormat)++;

        pFormat += *((short *)pFormat);

        (*pfnSizeRoutines[ROUTINE_INDEX(*pFormat)])( pStubMsg,
                                                     pMemory,
                                                     pFormat );
        }
}
#endif // 0

void RPC_ENTRY
NdrComplexStructBufferSize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Computes the buffer size needed for a complex structure.

    Used for FC_BOGUS_STRUCT.

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the structure being sized.
    pFormat     - Structure's format string description.

Return :

    None.

--*/
{

    PFORMAT_STRING  pFormatPointers;
    PFORMAT_STRING  pFormatArray;
    PFORMAT_STRING  pFormatComplex;
    long            Alignment;
    long            Align8Mod;
    BOOL            fEmbedConfStructContext;
    uchar*          pMemoryLoop;
    PFORMAT_STRING  pFormatLoop;

    uchar           fIsEmbeddedStructSave = IS_EMBED_CONF_STRUCT( pStubMsg->uFlags );
    uchar *         pMemorySave = pStubMsg->Memory;

    //
    // If were not ignoring pointees and the the stub message PointerBufferMark field is 0, 
    // then determine the position in the buffer where pointees will be marshalled.
    //
    // We have to do this to handle embedded pointers.
    //

    bool  fSetPointerBufferMark = !pStubMsg->IgnoreEmbeddedPointers &&
                                  !pStubMsg->PointerBufferMark;
    if ( fSetPointerBufferMark )
        {

        pStubMsg->IgnoreEmbeddedPointers = TRUE;
        ulong BufferLengthSave = pStubMsg->BufferLength;
        
        NdrComplexStructBufferSize( pStubMsg,
                                    pMemory,
                                    pFormat );

        // If the size of the flat part is zero and this is the first item to be
        // marshalled, add a small offset to the buffer so that we can continue
        // to use PointerBufferMark as an is embedded flag.
        if ( !pStubMsg->BufferLength) 
            {
            pStubMsg->BufferLength      += NDR_MAX_BUFFER_ALIGNMENT;
            BufferLengthSave            += NDR_MAX_BUFFER_ALIGNMENT;
            }

        pStubMsg->IgnoreEmbeddedPointers = FALSE;
        pStubMsg->PointerBufferMark = (uchar *) UlongToPtr(pStubMsg->BufferLength);
        pStubMsg->BufferLength = BufferLengthSave;
        
        }

    //
    // This is used when computing the count(s) for size_is or length_is
    // pointers.
    //
    pStubMsg->Memory = pMemory;

    Alignment = pFormat[1];

    //
    // This is used for support of structs with doubles passed on an
    // i386 stack, and of struct with longs on 16 bit platforms.
    //
    // A cast to long is what we need.
    Align8Mod = 0x7 & PtrToLong( pMemory );

    pFormat += 4;

    fEmbedConfStructContext = fIsEmbeddedStructSave;

    // Get conformant array description.
    if ( *((ushort *)pFormat) )
        {
        pFormatArray = pFormat + *((signed short *)pFormat);

        // mark Complex struct embedding Conformant struct case
        if ( FixWireRepForDComVerGTE54( pStubMsg ) )
            fEmbedConfStructContext = TRUE;

        // accounted for by the outermost embedding complex struct
        if ( !fIsEmbeddedStructSave )
            {
            //
            // Align and add size of conformance count(s).
            //
            LENGTH_ALIGN(pStubMsg->BufferLength,0x3);
        
            pStubMsg->BufferLength += 4 * NdrpArrayDimensions( pStubMsg,
                                                              pFormatArray,
                                                              FALSE);
            }
        }
    else
        pFormatArray = 0;

    RESET_EMBED_CONF_STRUCT( pStubMsg->uFlags );

    pFormat += 2;

    // Get pointer layout description.
    if ( *((ushort *)pFormat) )
        pFormatPointers = pFormat + *((ushort *)pFormat);
    else
        pFormatPointers = 0;

    pFormat += 2;

    // save variables for second loop
    pMemoryLoop = pMemory;
    pFormatLoop = pFormat;

    LENGTH_ALIGN(pStubMsg->BufferLength,Alignment);
    //
    // size the structure member by member.
    //
    for ( ; *pFormat != FC_END; pFormat++ ) 
        {
        switch ( *pFormat ) 
            {
            //
            // simple types
            //
            case FC_CHAR :
            case FC_BYTE :
            case FC_SMALL :
            case FC_WCHAR :
            case FC_SHORT :
            case FC_LONG :
#if defined(__RPC_WIN64__)
            case FC_INT3264:
            case FC_UINT3264:
#endif
            case FC_FLOAT :
            case FC_HYPER :
            case FC_DOUBLE :
            case FC_ENUM16 :
            case FC_ENUM32 :
            case FC_IGNORE :
                LENGTH_ALIGN( pStubMsg->BufferLength,
                              SIMPLE_TYPE_ALIGNMENT(*pFormat) );
                pStubMsg->BufferLength += SIMPLE_TYPE_BUFSIZE(*pFormat);
                pMemory += SIMPLE_TYPE_MEMSIZE(*pFormat);
                break;

            case FC_POINTER :
                LENGTH_ALIGN(pStubMsg->BufferLength,0x3);
                pStubMsg->BufferLength += PTR_WIRE_SIZE;
                
                if ( !pStubMsg->IgnoreEmbeddedPointers )
                    {
                    POINTER_BUFFERLENGTH_SWAP_CONTEXT SwapContext( pStubMsg );

                    NdrpPointerBufferSize( pStubMsg,
                                           *((uchar **)pMemory),
                                           pFormatPointers );
                    }

                pFormatPointers += 4;
                pMemory += PTR_MEM_SIZE;
                break;

            //
            // Embedded complex types.
            //
            case FC_EMBEDDED_COMPLEX :
                // Add padding.
                pMemory += pFormat[1];

                pFormat += 2;

                // Get the type's description.
                pFormatComplex = pFormat + *((signed short UNALIGNED *)pFormat);

                if ( FC_IP == *pFormatComplex ) 
                    {
                    // Treat embedded interface pointers the same as regular pointers.

                    LENGTH_ALIGN( pStubMsg->BufferLength, 0x3 );
                    pStubMsg->BufferLength += PTR_WIRE_SIZE;

                    if ( !pStubMsg->IgnoreEmbeddedPointers ) 
                        {
                        POINTER_BUFFERLENGTH_SWAP_CONTEXT SwapContext( pStubMsg );

                        NdrpPointerBufferSize( pStubMsg,
                                               *((uchar **)pMemory),
                                               pFormatComplex);
                        }
                    pMemory += PTR_MEM_SIZE;
                    pFormat++;
					break;

                    }

                // Needed for embedded conf structs
                //
                if ( fEmbedConfStructContext )
                    SET_EMBED_CONF_STRUCT( pStubMsg->uFlags );

                (*pfnSizeRoutines[ROUTINE_INDEX(*pFormatComplex)])
                ( pStubMsg,
                  pMemory,
                  pFormatComplex );

                pMemory = NdrpMemoryIncrement( pStubMsg,
                                               pMemory,
                                               pFormatComplex );

                RESET_EMBED_CONF_STRUCT( pStubMsg->uFlags );

                //
                // Increment the main format string one byte.  The loop 
                // will increment it one more byte past the offset field.
                //
                pFormat++;

                break;

            case FC_ALIGNM2 :
                ALIGN( pMemory, 0x1 );
                break;

            case FC_ALIGNM4 :
                ALIGN( pMemory, 0x3 );
                break;

            case FC_ALIGNM8 :
                //
                // We have to play some tricks for the i386 to handle the case
                // when an 8 byte aligned structure is passed by value.  The
                // alignment of the struct on the stack is not guaranteed to be
                // on an 8 byte boundary.
                //
                pMemory -= Align8Mod;
                ALIGN( pMemory, 0x7 );
                pMemory += Align8Mod;

                break;

            case FC_STRUCTPAD1 :
            case FC_STRUCTPAD2 :
            case FC_STRUCTPAD3 :
            case FC_STRUCTPAD4 :
            case FC_STRUCTPAD5 :
            case FC_STRUCTPAD6 :
            case FC_STRUCTPAD7 :
                pMemory += (*pFormat - FC_STRUCTPAD1) + 1; 
                break;
            
            case FC_STRUCTPADN :
                // FC_STRUCTPADN 0 <unsigned short>
                pMemory += *(((unsigned short *)pFormat) + 1);
                pFormat += 3;
                break;


            case FC_PAD :
                break;

            //
            // Done with layout.
            //
            case FC_END :
                break;

            default :
                NDR_ASSERT(0,"NdrComplexStructBufferSize : bad format char");
                RpcRaiseException( RPC_S_INTERNAL_ERROR );
                return;
            } // switch 
        } // for

    //
    // Size any conformant array.
    //
    // accounted for by the outermost embedding complex struct
    // .. but not when embedded and not when array done by an embeded conf struct.

    if ( pFormatArray && !fIsEmbeddedStructSave  &&
         ! IS_CONF_ARRAY_DONE( pStubMsg->uFlags ) )
        {
        PPRIVATE_SIZE_ROUTINE   pfnSize;

        switch ( *pFormatArray )
            {
            case FC_CARRAY :
                pfnSize = NdrpConformantArrayBufferSize;
                break;

            case FC_CVARRAY :
                pfnSize = NdrpConformantVaryingArrayBufferSize;
                break;

            case FC_BOGUS_ARRAY :
                pfnSize = NdrpComplexArrayBufferSize;
                break;

            // case FC_C_WSTRING :
            // case FC_C_CSTRING :
            // case FC_C_BSTRING :
            // case FC_C_SSTRING :
            default :
                pfnSize = NdrpConformantStringBufferSize;
                break;
            }

        (*pfnSize)( pStubMsg,
                    pMemory,
                    pFormatArray );
        }

    if ( fIsEmbeddedStructSave )
        SET_EMBED_CONF_STRUCT( pStubMsg->uFlags );
    else
        RESET_CONF_ARRAY_DONE( pStubMsg->uFlags );

    pStubMsg->Memory = pMemorySave;

    if ( fSetPointerBufferMark )
        {
        pStubMsg->BufferLength = PtrToUlong(pStubMsg->PointerBufferMark);
        pStubMsg->PointerBufferMark = NULL;
        }
}


void RPC_ENTRY
NdrFixedArrayBufferSize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Computes the buffer size needed for a fixed array of any number of 
    dimensions.

    Used for FC_SMFARRAY and FC_LGFARRAY.

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the array being sized.
    pFormat     - Array's format string description.

Return :

    None.

--*/
{
    LENGTH_ALIGN(pStubMsg->BufferLength,pFormat[1]);

    if ( *pFormat == FC_SMFARRAY )  
        {
        pFormat += 2;
        pStubMsg->BufferLength += *((ushort *&)pFormat)++; 
        }
    else
        {
        pFormat += 2;
        pStubMsg->BufferLength += *((ulong UNALIGNED *&)pFormat)++;
        }

    if ( *pFormat == FC_PP ) 
        {
        NdrpEmbeddedPointerBufferSize( pStubMsg,
                                       pMemory,
                                       pFormat );
        }
}


void RPC_ENTRY
NdrConformantArrayBufferSize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Computes the buffer size needed for a top level one dimensional conformant 
    array.

    Used for FC_CARRAY.

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the array being sized.
    pFormat     - Array's format string description.

Return :

    None.

--*/
{
    //
    // Align and add size for conformance count.
    //
    LENGTH_ALIGN(pStubMsg->BufferLength,0x3);

    pStubMsg->BufferLength += 4;

    NdrpConformantArrayBufferSize( pStubMsg,
                                   pMemory,
                                   pFormat );
}


void 
NdrpConformantArrayBufferSize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Private routine for computing the buffer size needed for a one dimensional 
    conformant array.  This is the entry point for unmarshalling an embedded 
    conformant array.

    Used for FC_CARRAY.

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the array being sized.
    pFormat     - Array's format string description.

Return :

    None.

--*/
{
    ulong   ConformanceCount;

    ConformanceCount = (ulong) NdrpComputeConformance( pStubMsg, 
                                                       pMemory, 
                                                       pFormat );

    if ( ((long)ConformanceCount) < 0 )
        RpcRaiseException( RPC_X_INVALID_BOUND );

    if ( ! ConformanceCount ) 
        return;

    LENGTH_ALIGN(pStubMsg->BufferLength,pFormat[1]);

    pFormat += 2;

    // Add array size.
    pStubMsg->BufferLength += *((ushort *)pFormat) * ConformanceCount;

    pFormat += 6;
    CORRELATION_DESC_INCREMENT( pFormat );

    if ( *pFormat == FC_PP ) 
        {
        NdrpEmbeddedPointerBufferSize( pStubMsg,
                                       pMemory,
                                       pFormat );
        }
}


void RPC_ENTRY
NdrConformantVaryingArrayBufferSize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Computes the buffer size needed for a top level one dimensional conformant
    varying array.

    Used for FC_CVARRAY.

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the array being sized.
    pFormat     - Array's format string description.

Return :

    None.

--*/
{
    //
    // Align and add size for conformance count.
    //
    LENGTH_ALIGN(pStubMsg->BufferLength,0x3);

    pStubMsg->BufferLength += 4;

    NdrpConformantVaryingArrayBufferSize( pStubMsg,
                                          pMemory,
                                          pFormat );
}


void
NdrpConformantVaryingArrayBufferSize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Private routine for computing the buffer size needed for a one dimensional 
    conformant varying array. This is the entry point for buffer sizing an 
    embedded conformant varying array.

    Used for FC_CVARRAY.

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the array being sized.
    pFormat     - Array's format string description.

Return :

    None.

--*/
{
    ulong   ConformanceCount;

    //
    // Align and add size for offset and actual count.
    //
    LENGTH_ALIGN(pStubMsg->BufferLength,0x3);

    pStubMsg->BufferLength += 8;

    NdrpComputeVariance( pStubMsg, 
                         pMemory, 
                         pFormat );

    // Check if the bounds are valid

    ConformanceCount = (ulong) NdrpComputeConformance( pStubMsg, 
                                                       pMemory, 
                                                       pFormat );

    if ( ( ((long)ConformanceCount) < 0 ) ||
         ( ((long)pStubMsg->ActualCount) < 0 ) ||
         ( ((long)pStubMsg->Offset) < 0 ) ||
         ( (pStubMsg->Offset + pStubMsg->ActualCount) > ConformanceCount ) )
        RpcRaiseException( RPC_X_INVALID_BOUND );

    if ( ! pStubMsg->ActualCount ) 
        return;

    LENGTH_ALIGN(pStubMsg->BufferLength, pFormat[1]);

    pFormat += 2;

    // Add array size.
    pStubMsg->BufferLength += *((ushort *)pFormat) * pStubMsg->ActualCount;

    pFormat += 10;
    CORRELATION_DESC_INCREMENT( pFormat );
    CORRELATION_DESC_INCREMENT( pFormat );

    if ( *pFormat == FC_PP ) 
        {
        //
        // MaxCount must contain the number of shipped elements in the array
        // before sizing embedded pointers.
        //
        pStubMsg->MaxCount = pStubMsg->ActualCount;

        NdrpEmbeddedPointerBufferSize( pStubMsg,
                                       pMemory,
                                       pFormat );
        }
}


void RPC_ENTRY
NdrVaryingArrayBufferSize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Computes the buffer size needed for a top level or embedded one 
    dimensional varying array.

    Used for FC_SMVARRAY and FC_LGVARRAY.

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the array being sized.
    pFormat     - Array's format string description.

Return :

    None.

Arguments : 

    pMemory     - pointer to the parameter to size
    pFormat     - pointer to the format string description of the parameter

--*/
{
    ulong   Elements;
    ulong   ElementSize;

    //
    // Align and add size for offset and actual count.
    //
    LENGTH_ALIGN(pStubMsg->BufferLength,0x3);

    pStubMsg->BufferLength += 8;

    NdrpComputeVariance( pStubMsg, 
                         pMemory, 
                         pFormat );

    // Check if the bounds are valid

    Elements = 
        (*pFormat == FC_SMVARRAY) ? 
        *((ushort *)(pFormat + 4)) : *((ulong UNALIGNED *)(pFormat + 6));

    if ( ( ((long)pStubMsg->ActualCount) < 0 ) ||
         ( ((long)pStubMsg->Offset) < 0 ) ||
         ( (pStubMsg->Offset + pStubMsg->ActualCount) > Elements ) )
        RpcRaiseException( RPC_X_INVALID_BOUND );

    if ( ! pStubMsg->ActualCount )
        return;

    LENGTH_ALIGN(pStubMsg->BufferLength, pFormat[1]);

    if (*pFormat == FC_SMVARRAY) 
        {
        ElementSize = *((ushort *)(pFormat + 6));
        pFormat += 12;
        }
    else
        {
        ElementSize = *((ushort *)(pFormat + 10));
        pFormat += 16;
        }
    CORRELATION_DESC_INCREMENT( pFormat );

    pStubMsg->BufferLength += ElementSize * pStubMsg->ActualCount;

    if ( *pFormat == FC_PP ) 
        {
        //
        // MaxCount must contain the number of shipped elements in the array
        // before sizing embedded pointers.
        //
        pStubMsg->MaxCount = pStubMsg->ActualCount;

        NdrpEmbeddedPointerBufferSize( pStubMsg,
                                       pMemory,
                                       pFormat );
        }
}


void RPC_ENTRY
NdrComplexArrayBufferSize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Computes the buffer size needed for a top level complex array.

    Used for FC_BOGUS_STRUCT.

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the array being sized.
    pFormat     - Array's format string description.

Return :

    None.

Note.

    Array of ref pointers does not have wire representation for the pointers
    themselves, regardless whether array is top level or embedded in a struct.
    
--*/
{
    bool fSetPointerBufferMark = !pStubMsg->IgnoreEmbeddedPointers &&
                                 (! pStubMsg->PointerBufferMark );

    if ( fSetPointerBufferMark )
        {
        //
        // Save the current conformance and variance fields.  The sizing
        // routine can overwrite them.
        //
        ULONG_PTR MaxCountSave = pStubMsg->MaxCount;
        ulong OffsetSave = pStubMsg->Offset;
        ulong ActualCountSave = pStubMsg->ActualCount;
        ulong BufferLengthSave = pStubMsg->BufferLength;
        pStubMsg->IgnoreEmbeddedPointers = TRUE;

        NdrComplexArrayBufferSize( pStubMsg,
                                   pMemory,
                                   pFormat );


        // If the size of the flat part is zero and this is the first item to be
        // marshalled, add a small offset to the buffer so that we can continue
        // to use PointerBufferMark as an is embedded flag.
        if ( !pStubMsg->BufferLength) 
            {
            pStubMsg->BufferLength      += NDR_MAX_BUFFER_ALIGNMENT;
             BufferLengthSave           += NDR_MAX_BUFFER_ALIGNMENT;
            }

        pStubMsg->PointerBufferMark = (uchar *) UlongToPtr(pStubMsg->BufferLength);
        
        pStubMsg->IgnoreEmbeddedPointers = FALSE;

        // Restore conformance and variance fields.
        pStubMsg->MaxCount = MaxCountSave;
        pStubMsg->Offset = OffsetSave;
        pStubMsg->ActualCount = ActualCountSave;
        pStubMsg->BufferLength = BufferLengthSave;

        }

    //
    // Add in conformance sizes if we are the outermost dimension.
    //
    if ( pStubMsg->pArrayInfo == 0 )
        {
        //
        // Align and add size for any conformance count(s).
        //
        if ( *((long UNALIGNED *)(pFormat + 4)) != 0xffffffff )
            {
            LENGTH_ALIGN(pStubMsg->BufferLength,0x3);
    
            pStubMsg->BufferLength += NdrpArrayDimensions( pStubMsg, pFormat, FALSE ) * 4;
            }
        }

    NdrpComplexArrayBufferSize( pStubMsg,
                                pMemory,
                                pFormat );
    
    if ( fSetPointerBufferMark )
        {
        pStubMsg->BufferLength = PtrToUlong(pStubMsg->PointerBufferMark);
        pStubMsg->PointerBufferMark = NULL;
        }

}


void 
NdrpComplexArrayBufferSize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Private routine for determing the buffer size of a complex array.  This 
    is the entry point for buffer sizing an embedded complex array.

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the array being sized.
    pFormat     - Array's format string description.

Return :

    None.

--*/
{
    ARRAY_INFO      ArrayInfo;
    PARRAY_INFO     pArrayInfo;
    PSIZE_ROUTINE   pfnSize;
    PFORMAT_STRING  pFormatStart;
    ulong           Elements;
    ulong           Offset, Count;
    ulong           MemoryElementSize;
    long            Dimension;
    uchar           Alignment;
    
    //
    // Lots of setup if we are the outer dimension.
    //
    if ( ! pStubMsg->pArrayInfo )
        {
        NdrpInitArrayInfo(pStubMsg, &ArrayInfo );
        //
        // Set this to 0 so that NdrpMemoryIncrement will know to call 
        // NdrpComputeConformance when computing our size.
        //
        pStubMsg->pArrayInfo->BufferConformanceMark = 0;
        }

    pFormatStart = pFormat;

    pArrayInfo = pStubMsg->pArrayInfo;

    Dimension = pArrayInfo->Dimension;

    // Get the array alignment.
    Alignment = pFormat[1];

    pFormat += 2;

    // Get the number of elements (0 if conformance present). 
    Elements = *((ushort *&)pFormat)++;

    //
    // Check for conformance description.
    //
    if ( *((long UNALIGNED *)pFormat) != 0xffffffff )
        {
        Elements = (ulong) NdrpComputeConformance( pStubMsg,
                                                   pMemory,
                                                   pFormatStart );
        }

    pFormat += 4;
    CORRELATION_DESC_INCREMENT( pFormat );

    //
    // Check for variance description.
    //
    if ( *((long UNALIGNED *)pFormat) != 0xffffffff )
        {
        NdrpComputeVariance( pStubMsg,
                             pMemory,
                             pFormatStart );

        Offset = pStubMsg->Offset;
        Count = pStubMsg->ActualCount;

        if ( Dimension == 0 )
            {
            //
            // Align and add in size of variance count(s).
            //
            LENGTH_ALIGN(pStubMsg->BufferLength,0x3);
    
            pStubMsg->BufferLength += 
                    NdrpArrayDimensions( pStubMsg, pFormatStart, TRUE ) * 8;
            }
        }
    else
        {
        Offset = 0;
        Count = Elements;
        }

    pFormat += 4;
    CORRELATION_DESC_INCREMENT( pFormat );

    // Check bounds

    if ( ( ((long)Elements) < 0 ) ||
         ( ((long)Count) < 0 ) ||
         ( ((long)Offset) < 0 ) ||
         ( (Offset + Count) > Elements ) )
        RpcRaiseException( RPC_X_INVALID_BOUND );

    if ( Count )
        {
        LENGTH_ALIGN( pStubMsg->BufferLength, Alignment );

        if ( *pFormat == FC_EMBEDDED_COMPLEX )
            {
            ulong           CountSave;
            uchar*          pMemorySave;
            PFORMAT_STRING  pFormatSave;

            pFormat += 2;
            pFormat += *((signed short *)pFormat);

            if ( FC_IP == *pFormat )
                goto PointerSizing;

            pfnSize = pfnSizeRoutines[ROUTINE_INDEX(*pFormat)];

            pArrayInfo->Dimension = Dimension + 1;

            MemoryElementSize = (ulong) ( NdrpMemoryIncrement( pStubMsg,
                                                               pMemory,
                                                               pFormat ) - pMemory );
            if ( ! IS_ARRAY_OR_STRING(*pFormat) )
                pStubMsg->pArrayInfo = 0;

            //
            // If there is variance then increment the memory pointer to the first
            // element actually being sized.
            //
            if ( Offset )
                pMemory += Offset * MemoryElementSize;

            pFormatSave = pFormat;
            pMemorySave = pMemory;
            CountSave = Count;

            for ( ; Count--; )
                {
                // Keep track of multidimensional array dimension.
                if ( IS_ARRAY_OR_STRING(*pFormat) )
                    pArrayInfo->Dimension = Dimension + 1;

                (*pfnSize)( pStubMsg,
                            pMemory,
                            pFormat );

                pMemory += MemoryElementSize;
                }

            pMemory += MemoryElementSize;

            }
        else if ( *pFormat == FC_UP || *pFormat == FC_FP || *pFormat == FC_OP || *pFormat == FC_RP ||
                  *pFormat == FC_IP ) 
            {
PointerSizing:
            //
            // Shallow size the array
            //
            if ( *pFormat != FC_RP ) 
                 {
                 pStubMsg->BufferLength += Count * PTR_WIRE_SIZE;
                 }

            //
            // If there is variance then increment the memory pointer to the first
            // element actually being sized.
            //
            if ( Offset )
                pMemory += Offset * PTR_MEM_SIZE;

            //
            // size the pointees
            //
            if ( !pStubMsg->IgnoreEmbeddedPointers ) 
                {
                bool UseBrokenInterfacePointerRep = 
                    (FC_IP == *pFormat) && !FixWireRepForDComVerGTE54( pStubMsg );
                
                // If this is the broken interface pointer format, make sure we
                // have enough space for both the pointer and pointee where
                // the pointer should have been.

                if ( UseBrokenInterfacePointerRep )
                    SET_BROKEN_INTERFACE_POINTER( pStubMsg->uFlags );

                // Need this in case we have a variant offset.
                pStubMsg->pArrayInfo = 0;
                
                // Switch to the pointee buffer.
                POINTER_BUFFERLENGTH_SWAP_CONTEXT SwapContext( pStubMsg );

                for ( ; Count--; )
                     {
                     NdrpPointerBufferSize( 
                         pStubMsg,
                         *((uchar **&)pMemory)++,
                         pFormat );
                    }
                
                if ( UseBrokenInterfacePointerRep )
                   RESET_BROKEN_INTERFACE_POINTER( pStubMsg->uFlags );
                
                }

            }
        else if (*pFormat == FC_RANGE )
            {
            pStubMsg->BufferLength += Count * SIMPLE_TYPE_BUFSIZE( pFormat[1] );
            }
        else
            {
            NDR_ASSERT( IS_SIMPLE_TYPE(*pFormat), "NdrpComplexArrayBufferSize : bad format char" );
            pStubMsg->BufferLength += Count * SIMPLE_TYPE_BUFSIZE(*pFormat);
            }
        }

    // pArrayInfo must be zero when not valid.
    pStubMsg->pArrayInfo = (Dimension == 0) ? 0 : pArrayInfo;
}


void RPC_ENTRY
NdrNonConformantStringBufferSize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Computes the buffer size needed for a non conformant string.

    Used for FC_CSTRING, FC_WSTRING, FC_SSTRING, and FC_BSTRING (NT Beta2
    compatability only).

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the array being sized.
    pFormat     - Array's format string description.

Return :

    None.

--*/
{
    long    MaxSize;
    long    Length;

    // Align and add size for variance counts.
    LENGTH_ALIGN(pStubMsg->BufferLength,0x3);

    pStubMsg->BufferLength += 8;

    switch ( *pFormat )
        {
        case FC_CSTRING : 
        case FC_BSTRING : 
            Length = strlen((char*)pMemory) + 1;
            break;
        case FC_WSTRING : 
            Length = (wcslen((wchar_t *)pMemory) + 1) * sizeof(wchar_t);
            break;
        case FC_SSTRING : 
            Length = NdrpStringStructLen( pMemory, pFormat[1] ) + 1;
            Length *= pFormat[1];
            break;
        default :
            NDR_ASSERT(0,"NdrNonConformantStringBufferSize : Bad format type");
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            return;
        }

    // Check bounds

    MaxSize = *((ushort *)(pFormat + 2));

    switch ( *pFormat ) 
        {
        case FC_WSTRING : 
            MaxSize *= sizeof(wchar_t);
            break;
        case FC_SSTRING : 
            MaxSize *= pFormat[1];
            break;
        default :
            break;
        }

    if ( Length > MaxSize )
        RpcRaiseException(RPC_X_INVALID_BOUND);

    pStubMsg->BufferLength += Length;
}


void RPC_ENTRY
NdrConformantStringBufferSize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Computes the buffer size needed for a top level conformant string.

    Used for FC_C_CSTRING, FC_C_WSTRING, FC_C_SSTRING, and FC_C_BSTRING 
    (NT Beta2 compatability only).

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the array being sized.
    pFormat     - Array's format string description.

Return :

    None.

--*/
{
    //
    // Add in size for conformance marshalling only if this string is not
    // in a multidimensional array.
    //
    if ( pStubMsg->pArrayInfo == 0 )
        {
        // Align and add size for conformance count.
        LENGTH_ALIGN(pStubMsg->BufferLength,0x3);

        pStubMsg->BufferLength += 4;
        }

    NdrpConformantStringBufferSize( pStubMsg,
                                    pMemory,
                                    pFormat );
}


void 
NdrpConformantStringBufferSize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Private routine for computing the buffer size needed for a conformant 
    string.  This is the entry point for an embedded conformant string.

    Used for FC_C_CSTRING, FC_C_WSTRING, FC_C_SSTRING, and FC_C_BSTRING
    (NT Beta2 compatability only).

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the array being sized.
    pFormat     - Array's format string description.

Return :

    None.

--*/
{
    long    MaxSize;
    long    Length;

    // Align and add size for variance.
    LENGTH_ALIGN(pStubMsg->BufferLength,0x3);

    pStubMsg->BufferLength += 8;

    switch ( *pFormat )
        {
        case FC_C_CSTRING : 
        case FC_C_BSTRING : 
            Length = strlen((char*)pMemory) + 1;
            break;
        case FC_C_WSTRING : 
            Length = (wcslen((wchar_t *)pMemory) + 1) * sizeof(wchar_t);
            break;
        case FC_C_SSTRING : 
            Length = NdrpStringStructLen( pMemory, pFormat[1] ) + 1;
            Length *= pFormat[1];
            break;
        default :
            NDR_ASSERT(0,"NdrpConformantStringBufferSize : Bad format type");
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            return;
        }

    //
    // Do bounds checking.
    //
    if ( ((*pFormat != FC_C_SSTRING) && (pFormat[1] == FC_STRING_SIZED)) ||
         ((*pFormat == FC_C_SSTRING) && (pFormat[2] == FC_STRING_SIZED)) )
        {
        MaxSize = (ulong) NdrpComputeConformance( pStubMsg,
                                                  pMemory,
                                                  pFormat );
    
        switch ( *pFormat )
            {
            case FC_C_WSTRING : 
                MaxSize *= sizeof(wchar_t);
                break;
            case FC_C_SSTRING : 
                MaxSize *= pFormat[1];
                break;
            default :
                break;
            }

        if ( (MaxSize < 0) || (Length > MaxSize) )
            RpcRaiseException(RPC_X_INVALID_BOUND);
        }   

    pStubMsg->BufferLength += Length;
}


void RPC_ENTRY
NdrEncapsulatedUnionBufferSize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Computes the buffer size needed for an encapsulated union.

    Used for FC_ENCAPSULATED_UNION.

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the union being sized.
    pFormat     - Union's format string description.

Return :

    None.

--*/
{
    long    SwitchIs;
    uchar   SwitchType;

    NO_CORRELATION;

    SwitchType = LOW_NIBBLE(pFormat[1]);

    switch ( SwitchType )
        {
        case FC_SMALL :
        case FC_CHAR :
            SwitchIs = (long) *((char *)pMemory);
            break;
        case FC_USMALL :
            SwitchIs = (long) *((uchar *)pMemory);
            break;

        case FC_ENUM16 :
        case FC_SHORT :
            SwitchIs = (long) *((short *)pMemory);
            break;

        case FC_USHORT :
        case FC_WCHAR :
            SwitchIs = (long) *((ushort *)pMemory);
            break;
        case FC_LONG :
        case FC_ULONG :
        case FC_ENUM32 :
          // FC_INT3264 is mapped to FC_LONG.
            SwitchIs = *((long *)pMemory);
            break;
        default :
            NDR_ASSERT(0,"NdrEncapsulatedBufferSize : bad switch type");
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            return;
        }

    // Increment memory pointer to the union.
    pMemory += HIGH_NIBBLE(pFormat[1]);

    NdrpUnionBufferSize( pStubMsg,
                         pMemory,
                         pFormat + 2,
                         SwitchIs,
                         SwitchType );
}


void RPC_ENTRY
NdrNonEncapsulatedUnionBufferSize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Computes the buffer size needed for a non encapsulated union.

    Used for FC_NON_ENCAPSULATED_UNION.

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the union being sized.
    pFormat     - Union's format string description.

Return :

    None.

--*/
{
    long    SwitchIs;
    uchar   SwitchType;

    SwitchType = pFormat[1];

    SwitchIs = (ulong) NdrpComputeSwitchIs( pStubMsg,
                                            pMemory,
                                            pFormat );

    //
    // Set the format string to the memory size and arm description.
    //
    pFormat += 6;
    CORRELATION_DESC_INCREMENT( pFormat );
    pFormat += *((signed short *)pFormat);

    NdrpUnionBufferSize( pStubMsg,
                         pMemory,
                         pFormat,
                         SwitchIs,
                         SwitchType );
}


void 
NdrpUnionBufferSize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat,
    long                SwitchIs,
    uchar               SwitchType )
/*++

Routine Description :

    Private routine for computing the buffer size needed for a union.  This
    routine is used for sizing both encapsulated and non-encapsulated unions.

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the union being sized.
    pFormat     - Union's format string description.
    SwitchIs    - The union's switch is.
    SwitchType  - The union's switch type.

Return :

    None.

--*/
{
    long    Arms;
    long    Alignment;

    //
    // Size the switch_is.
    //
    LENGTH_ALIGN(pStubMsg->BufferLength,SIMPLE_TYPE_ALIGNMENT(SwitchType));
    
    pStubMsg->BufferLength += SIMPLE_TYPE_BUFSIZE(SwitchType);

    // Skip the memory size field.
    pFormat += 2;

    //
    // Get the union alignment (0 if this is a DCE union) and align the 
    // buffer on this alignment.
    //
    Alignment = (uchar) ( *((ushort *)pFormat) >> 12 );

    LENGTH_ALIGN(pStubMsg->BufferLength,Alignment);

    Arms = (long) ( *((ushort *&)pFormat)++ & 0x0fff );

    //
    // Search for the arm.
    //
    for ( ; Arms; Arms-- )
        {
        if ( *((long UNALIGNED *&)pFormat)++ == SwitchIs )
            {
            //
            // Found the right arm, break out.
            //
            break;
            }

        // Else increment format string.
        pFormat += 2;
        }

    //
    // Check if we took the default arm and no default arm is specified.
    //
    if ( ! Arms && (*((ushort *)pFormat) == (ushort) 0xffff) )
        {
        RpcRaiseException( RPC_S_INVALID_TAG );
        }

    //
    // Return if the arm is empty.
    //
    if ( ! *((ushort *)pFormat) )
        return;

    //
    // Get the arm's description.
    //
    // We need a real solution after beta for simple type arms.  This could
    // break if we have a format string larger than about 32K.
    //
    if ( IS_MAGIC_UNION_BYTE(pFormat) )
        {
        // Re-align again, only does something usefull for DCE unions.

        unsigned char FcType = pFormat[0];

        LENGTH_ALIGN( pStubMsg->BufferLength, SIMPLE_TYPE_ALIGNMENT( FcType ));
        pStubMsg->BufferLength += SIMPLE_TYPE_BUFSIZE( FcType );
        }
    else
        {
        pFormat += *((signed short *)pFormat);

        //
        // If the union arm we take is a pointer, we have to dereference the
        // current memory pointer since we're passed a pointer to the union
        // (regardless of whether the actual parameter was a by-value union
        // or a pointer to a union).
        //
        if ( IS_POINTER_TYPE(*pFormat) )
            {

            if ( pStubMsg->IgnoreEmbeddedPointers )
                {
                // 
                // If we're ignoring pointers then just add in the size of a pointer
                // here and return.
                //
                LENGTH_ALIGN(pStubMsg->BufferLength,0x3);
                pStubMsg->BufferLength += PTR_WIRE_SIZE;
                
                return;
                }

            pMemory = *((uchar **)pMemory);

            if ( pStubMsg->PointerBufferMark )
                {
                
                // If the union is embedded, tread it specially
                LENGTH_ALIGN(pStubMsg->BufferLength,0x3);
                pStubMsg->BufferLength += PTR_WIRE_SIZE;

                if ( !pStubMsg->IgnoreEmbeddedPointers )
                    {
                    POINTER_BUFFERLENGTH_SWAP_CONTEXT SwapContext(pStubMsg);

                    NdrpPointerBufferSize( pStubMsg,
                                           pMemory,
                                           pFormat );                    
                    }

                return;
                }

            }

        // Call the appropriate sizing routine
        (*pfnSizeRoutines[ROUTINE_INDEX(*pFormat)])( pStubMsg,
                                                     pMemory,
                                                     pFormat );
        }
}


void RPC_ENTRY
NdrByteCountPointerBufferSize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Computes the buffer size needed for a byte count pointer.

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - The byte count pointer being sized.
    pFormat     - Byte count pointer's format string description.

Return :

    None.

--*/
{
    //
    // We don't do anything special here.  Just pass things on to the
    // right sizing routine.
    //
    if ( pFormat[1] != FC_PAD )
        {
        SIMPLE_TYPE_BUF_INCREMENT(pStubMsg->BufferLength, pFormat[1]);
        }
    else
        {
        pFormat += 6;
        CORRELATION_DESC_INCREMENT( pFormat );
        pFormat += *((signed short *)pFormat);

        (*pfnSizeRoutines[ROUTINE_INDEX(*pFormat)])( pStubMsg,
                                                     pMemory,
                                                     pFormat );
        }
}


void RPC_ENTRY
NdrXmitOrRepAsBufferSize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat ) 
/*++

Routine Description :

    Computes the buffer size needed for a transmit as or represent as object.

    See mrshl.c for the description of the FC layout.

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the transmit/represent as object being sized.
    pFormat     - Object's format string description.

Return :

    None.

--*/
{
    const XMIT_ROUTINE_QUINTUPLE * pQuintuple;
    unsigned short                 QIndex, XmitTypeSize;
    BOOL                           fXmitByPtr = *pFormat == FC_TRANSMIT_AS_PTR ||
                                                *pFormat == FC_REPRESENT_AS_PTR;
    
    // Fetch the QuintupleIndex.

    QIndex = *(unsigned short *)(pFormat + 2);

    // We size the transmitted object, of course.

    pFormat += 6;
    XmitTypeSize = *((unsigned short *)pFormat);

    pQuintuple = pStubMsg->StubDesc->aXmitQuintuple;

    if ( XmitTypeSize )
        {
        // lower nibble of the flag word has the alignment

        unsigned long Align = LOW_NIBBLE(*(pFormat - 5));

        LENGTH_ALIGN( pStubMsg->BufferLength, Align );
        pStubMsg->BufferLength += XmitTypeSize;
        }
    else
        {
        // We have to create an object to size it.

        unsigned char *  pTransmittedType;

        // First translate the presented type into the transmitted type.
        // This includes an allocation of a transmitted type object.
    
        pStubMsg->pPresentedType = pMemory;
        pStubMsg->pTransmitType = NULL;
        pQuintuple[ QIndex ].pfnTranslateToXmit( pStubMsg );
    
        // bufsize the transmitted type.
    
        pFormat += 2;
        pFormat = pFormat + *(short *)pFormat;
    
        pTransmittedType = pStubMsg->pTransmitType;

        // If transmitted type is a pointer, dereference it.
        {
            // Set the current queue to NULL so that all the embedded
            // pointers in the transmitted type will be sized together
            uchar *PointerBufferMarkSave = pStubMsg->PointerBufferMark;
            pStubMsg->PointerBufferMark = 0;
            NDR_POINTER_QUEUE *pOldQueue = NULL;

            if ( pStubMsg->pPointerQueueState )
                {
                pOldQueue = pStubMsg->pPointerQueueState->GetActiveQueue();
                pStubMsg->pPointerQueueState->SetActiveQueue(NULL);
                }
            RpcTryFinally
                {
                (*pfnSizeRoutines[ ROUTINE_INDEX(*pFormat) ])
                    ( pStubMsg,
                      fXmitByPtr ? *(uchar **)pTransmittedType
                                 : pTransmittedType,
                      pFormat );
                }
            RpcFinally
                {
                pStubMsg->PointerBufferMark = PointerBufferMarkSave;
                if ( pStubMsg->pPointerQueueState )
                    {
                    pStubMsg->pPointerQueueState->SetActiveQueue(pOldQueue);
                    }
                }
            RpcEndFinally
        }

        pStubMsg->pTransmitType = pTransmittedType;
    
        // Free the temporary transmitted object (it was alloc'ed by the user).
    
        pQuintuple[ QIndex ].pfnFreeXmit( pStubMsg );
        }
}

void
NdrpUserMarshalBufferSize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat ) 
/*++

Routine Description :

    Computes the buffer size needed for a usr_marshall object.
    See mrshl.c for the description of the FC layout and wire layout.

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the usr_marshall object to buffer size.
    pFormat     - Object's format string description.

Return :

    None.

--*/
{
    const USER_MARSHAL_ROUTINE_QUADRUPLE *  pQuadruple;
    unsigned short                          QIndex;
    unsigned long                           UserOffset;
    USER_MARSHAL_CB                         UserMarshalCB;

    
	if ( pFormat[1] & USER_MARSHAL_POINTER )
	{
        // This is an overestimate to correct the size generated
        // by MIDL's state machine for sizing arguments.
        // The maximum alignment gap VARIANT might consume is 11:
        // 4 for the leading pad between unique pointer and wireVARIANT,
        // and 7 bytes if variant is a BSTR, and following parameter is
        // a CY (stuff that's aligned to 8).

        // MZ: Since were overcompensating here, just make this something
        // reasonable like 0x10 which is probably a good max alignment.
        pStubMsg->BufferLength += 0x10;

	}
 

    // We are here to size a flat object or a pointee object.
    // Optimization: if we know the wire size, don't call the user to size it.

    if ( *(unsigned short *)(pFormat + 6) != 0 )
        {
        pStubMsg->BufferLength += *(unsigned short *)(pFormat + 6);
        }
    else
        {
        // Unknown wire size: Call the user to size his stuff.
        NdrpInitUserMarshalCB( pStubMsg,
                               pFormat,
                               USER_MARSHAL_CB_BUFFER_SIZE,
                               & UserMarshalCB);

        UserOffset = pStubMsg->BufferLength;

        QIndex     = *(unsigned short *)(pFormat + 2);
        pQuadruple = pStubMsg->StubDesc->aUserMarshalQuadruple;

        UserOffset = pQuadruple[ QIndex ].pfnBufferSize( (ulong*) &UserMarshalCB,
                                                         UserOffset,
                                                         pMemory );
        pStubMsg->BufferLength = UserOffset;
        }
}

void 
NDR_USR_MRSHL_BUFSIZE_POINTER_QUEUE_ELEMENT::Dispatch(MIDL_STUB_MESSAGE *pStubMsg)
{
    NdrpUserMarshalBufferSize( pStubMsg,
                               pMemory,
                               pFormat );
}
#if defined(DBG)
void 
NDR_USR_MRSHL_BUFSIZE_POINTER_QUEUE_ELEMENT::Print()
{
    DbgPrint("NDR_USR_MRSHL_BUFSIZE_POINTER_QUEUE_ELEMENT\n");
    DbgPrint("pMemory:                 %p\n", pMemory );
    DbgPrint("pFormat:                 %p\n", pFormat );
}
#endif


void RPC_ENTRY
NdrUserMarshalBufferSize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
{

    // Check if the object is embedded.
    // Pointer buffer mark is set only when in a complex struct or array.
    // For unions, when the union is embedded in a complex struct or array.
    // If the union is top level, it's the same like a top level object.

    // For unique pointers we don't have to check embedding, we always add 4.
    // For ref pointer we need to check embedding.

    // Align for the flat object or a pointer to the user object.
    LENGTH_ALIGN( pStubMsg->BufferLength, LOW_NIBBLE(pFormat[1]) );

    if ( pFormat[1] & USER_MARSHAL_POINTER )
        {
        if ( (pFormat[1] & USER_MARSHAL_UNIQUE)  ||
             ((pFormat[1] & USER_MARSHAL_REF) && pStubMsg->PointerBufferMark) )
            {
            pStubMsg->BufferLength += PTR_WIRE_SIZE;
            }

        if ( pStubMsg->IgnoreEmbeddedPointers )
            return;
        
        POINTER_BUFFERLENGTH_SWAP_CONTEXT SwapContext( pStubMsg );

        if ( !pStubMsg->pPointerQueueState ||
             !pStubMsg->pPointerQueueState->GetActiveQueue() )
            {
            NdrpUserMarshalBufferSize( 
                pStubMsg,
                pMemory,
                pFormat );

            }
        else
            {
            NDR_USR_MRSHL_BUFSIZE_POINTER_QUEUE_ELEMENT*pElement = 
                new(pStubMsg->pPointerQueueState) 
                    NDR_USR_MRSHL_BUFSIZE_POINTER_QUEUE_ELEMENT(pMemory,
                                                                pFormat);
            pStubMsg->pPointerQueueState->GetActiveQueue()->Enque( pElement );
            }

        return;
        }

   NdrpUserMarshalBufferSize( pStubMsg,
                              pMemory,
                              pFormat );
}


void
NdrpInterfacePointerBufferSize ( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Computes the buffer size needed for an interface pointer.

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - The interface pointer being sized.
    pFormat     - Interface pointer's format string description.

Return :

    None.

--*/
{
    IID iid;
    IID *piid;
    unsigned long size = 0;
    HRESULT hr;

    //
    // Get an IID pointer.
    //
    if ( pFormat[1] != FC_CONSTANT_IID )
        {
        //
        // We do it same way as we compute variance with a long.
        //
        piid = (IID *) NdrpComputeIIDPointer( pStubMsg,
                                               pMemory,
                                               pFormat );

        if(piid == 0)
            RpcRaiseException( RPC_S_INVALID_ARG );
        }
    else
        {
        // 
        // The IID may not be aligned properly in the format string,
        // so we copy it to a local variable.
        //

        piid = &iid;
        RpcpMemoryCopy( &iid, &pFormat[2], sizeof(iid) );
        }

    // Allocate space for the length and array bounds.

    LENGTH_ALIGN(pStubMsg->BufferLength,0x3);
    pStubMsg->BufferLength += sizeof(unsigned long) + sizeof(unsigned long);

    hr = (*pfnCoGetMarshalSizeMax)(&size, *piid, (IUnknown *)pMemory, pStubMsg->dwDestContext, pStubMsg->pvDestContext, 0);
    if(FAILED(hr))
        {
        RpcRaiseException(hr);
        }

    pStubMsg->BufferLength += size;
}

void RPC_ENTRY
NdrInterfacePointerBufferSize ( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
{
    // This function is called only for toplevel interface pointers and 
    // backward compatibity

    LENGTH_ALIGN(pStubMsg->BufferLength,0x3);
    pStubMsg->BufferLength += PTR_WIRE_SIZE;

    if ( pStubMsg->IgnoreEmbeddedPointers )
        return;

    // If the pointer is null, we counted everything.

    if ( pMemory == 0 )
        return;

    NdrpInterfacePointerBufferSize( pStubMsg,
                                    pMemory,
                                    pFormat );
}


void 
NdrpEmbeddedPointerBufferSize ( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Private routine for computing the buffer size needed for a structure's
    or array's embedded pointers.

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the embedding structure or array. 
    pFormat     - Format string pointer layout description.

Return :

    None.

--*/
{

    if ( pStubMsg->IgnoreEmbeddedPointers ) 
        return;

    POINTER_BUFFERLENGTH_SWAP_CONTEXT SwapContext( pStubMsg );
    void **     ppMemPtr;
    uchar *     pMemorySave;
    ULONG_PTR   MaxCountSave;
    long        OffsetSave;

    MaxCountSave = pStubMsg->MaxCount;
    OffsetSave = pStubMsg->Offset;
    pMemorySave = pStubMsg->Memory;

    // Set new memory context.
    pStubMsg->Memory = pMemory;

    // 
    // Increment past the FC_PP and pad.
    //
    pFormat += 2;

    for (;;)
        {

        if ( *pFormat == FC_END )
            {
            pStubMsg->Memory = pMemorySave;
            break;
            }

        //
        // Check for FC_FIXED_REPEAT or FC_VARIABLE_REPEAT.
        //
        if ( *pFormat != FC_NO_REPEAT )
            {
            pStubMsg->MaxCount = MaxCountSave;
            pStubMsg->Offset = OffsetSave;

            NdrpEmbeddedRepeatPointerBufferSize( pStubMsg,
                                                 pMemory,
                                                 &pFormat );

            // Continue to the next pointer.
            continue;
            }

        // Compute the pointer to the pointer in memory to size.
        ppMemPtr = (void **) (pMemory + *((signed short *)(pFormat + 2)));

        // Increment to the pointer description.
        pFormat += 6;

        NdrpPointerBufferSize( 
            pStubMsg,
            (uchar*)*ppMemPtr,
            pFormat );
        
        // Increment past pointer description.
        pFormat += 4;
        }


}


void 
NdrpEmbeddedRepeatPointerBufferSize ( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING *    ppFormat )
/*++

Routine Description :

    Private routine for computing the buffer size needed for an array's 
    embedded pointers.

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the embedding array.
    pFormat     - The array's format string pointer layout description.

Return :

    None.

--*/
{
    uchar **        ppMemPtr;
    PFORMAT_STRING  pFormat;
    PFORMAT_STRING  pFormatSave;
    uchar *         pMemorySave;
    ulong           RepeatCount,RepeatIncrement, Pointers, PointersSave;

    pMemorySave = pStubMsg->Memory;

    // Get current format string pointer.
    pFormat = *ppFormat;

    switch ( *pFormat )
        {
        case FC_FIXED_REPEAT :
            // Increment past the FC_FIXED_REPEAT and FC_PAD.
            pFormat += 2;

            // Get the total number of times to repeat the pointer marshall.
            RepeatCount = *((ushort *&)pFormat)++;

            break;

        case FC_VARIABLE_REPEAT :
            // Get the total number of times to repeat the pointer marshall.
            RepeatCount = (ulong)pStubMsg->MaxCount;

            //
            // Check if this variable repeat instance also has a variable
            // offset (this would be the case for a conformant varying array
            // of pointers).  If so then increment the memory pointer to point
            // to the actual first array element which is being marshalled.
            //
            if ( pFormat[1] == FC_VARIABLE_OFFSET )
                pMemory += *((ushort *)(pFormat + 2)) * pStubMsg->Offset;

            // else pFormat[1] == FC_FIXED_OFFSET - do nothing

            // Increment past the FC_VARIABLE_REPEAT and FC_PAD.
            pFormat += 2;

            break;

        default :
            NDR_ASSERT(0,"NdrpEmbeddedRepeatPointerMarshall : bad format char");
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            return;
        }

    // Get the increment amount between successive pointers.
    RepeatIncrement = *((ushort *&)pFormat)++;

    //
    // Add the offset to the beginning of this array to the Memory
    // pointer.  This is the offset from any currently embedding structure
    // to the array whose pointers we're marshalling.
    //
    pStubMsg->Memory += *((ushort *&)pFormat)++;

    // Get the number of pointers in this repeat instance.
    PointersSave = Pointers = *((ushort *&)pFormat)++;

    pFormatSave = pFormat;

    //
    // Loop over the number of elements in the array.
    //
    for ( ; RepeatCount--;
            pMemory += RepeatIncrement,
            pStubMsg->Memory += RepeatIncrement )
        {
        pFormat = pFormatSave;
        Pointers = PointersSave;

        //
        // Loop over the number of pointers in each array element (this can
        // be greater than one if we have an array of structures).
        //
        for ( ; Pointers--; )
            {
            // Pointer to the pointer in memory.
            ppMemPtr = (uchar **)(pMemory + *((signed short *)pFormat));

            // Increment to pointer description.
            pFormat += 4;

            NdrpPointerBufferSize( 
                pStubMsg,
                (uchar*)*ppMemPtr,
                pFormat );

            // Increment to the next pointer description.
            pFormat += 4;
            }
        }

    // Update format string pointer past this repeat pointer description.
    *ppFormat = pFormatSave + PointersSave * 8;

    pStubMsg->Memory = pMemorySave;
}


void RPC_ENTRY
NdrContextHandleSize(
    PMIDL_STUB_MESSAGE     pStubMsg,
    uchar *                pMemory,
    PFORMAT_STRING         pFormat )
/*++

Routine Description :

    Computes the buffer size needed for a context handle.

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - Ignored.
    pFormat     - Ignored.

Return :

    None.

--*/
{
    LENGTH_ALIGN(pStubMsg->BufferLength,0x3);
    pStubMsg->BufferLength += CONTEXT_HANDLE_WIRE_SIZE;
}

#ifdef _CS_CHAR_
void RPC_ENTRY
NdrCsTagBufferSize(
    PMIDL_STUB_MESSAGE     pStubMsg,
    uchar *                pMemory,
    PFORMAT_STRING         pFormat )
/*++

Routine Description :

    Computes the buffer size needed for a cs tag param.  Also copies the 
    sending tag value to the stub message for use by NdrCsArrayXXX.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the embedding array.
    pFormat     - Pointer to the FC_CSTAG entry in the format string.

Return :

    None.

--*/
{
    // We need to set the tag in the stub message so that we can properly
    // size subsequent cs_char arrays.

    NdrpGetSetCSTagMarshall( pStubMsg, pMemory, (NDR_CS_TAG_FORMAT *) pFormat);

    LENGTH_ALIGN( pStubMsg->BufferLength, 3 );
    pStubMsg->BufferLength += sizeof( unsigned long );
}
 

void RPC_ENTRY
NdrCsArrayBufferSize(
    PMIDL_STUB_MESSAGE     pStubMsg,
    uchar *                pMemory,
    PFORMAT_STRING         pFormat )
/*++

Routine Description :

    Computes the buffer size needed for a cs_char array

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the embedding array.
    pFormat     - Pointer to the FC_CSARRAY entry in the format string.

Return :

    None.

--*/
{
    NDR_CS_ARRAY_FORMAT        *pCSFormat = (NDR_CS_ARRAY_FORMAT *) pFormat;
    ulong                       Size;
    ulong                       Length;
    ulong                       WireSize;

    NDR_ASSERT( NULL != pStubMsg->pCSInfo, "cs_char stub info not set up");

    // Skip pFormat to the underlying array descriptor

    pFormat += pCSFormat->DescriptionOffset;

    // Leave room for the max count / offset / actual count

    if ( NdrpIsVaryingArray( pFormat ) )
        {
        LENGTH_ALIGN( pStubMsg->BufferLength, 3 );
        pStubMsg->BufferLength += 8;
        }
    if ( NdrpIsConformantArray( pFormat ) )
        {
        LENGTH_ALIGN( pStubMsg->BufferLength, 3 );
        pStubMsg->BufferLength += 4;
        }

    // Get the base size and length

    NdrpGetArraySizeLength (
            pStubMsg,
            pMemory,
            pFormat,
            1,
            (long*)&Size,
            (long*)&Length,
            (long*)&WireSize );

    // Call XXX_net_size to estimate the buffer space required to store this
    // array after conversion.  For fixed or varying arrays the buffer
    // space is equal to the fixed upper bound specified in the idl file.


    if ( !NdrpIsVaryingArray( pFormat ) )
        {
        NDR_CS_SIZE_CONVERT_ROUTINES   *CSRoutines;
        CS_TYPE_NET_SIZE_ROUTINE        SizingRoutine;
        IDL_CS_CONVERT                  ConversionType;
        error_status_t                  Status;

        CSRoutines = pStubMsg->StubDesc->CsRoutineTables->pSizeConvertRoutines;
        SizingRoutine = CSRoutines[ pCSFormat->CSRoutineIndex ].pfnNetSize;

        SizingRoutine(
            NULL,
            pStubMsg->pCSInfo->WireCodeset,
            Size,
            (IDL_CS_CONVERT*)&ConversionType,
            &Size,
            &Status);
                
        if (RPC_S_OK != Status)
            RpcRaiseException(Status);
        }

    pStubMsg->BufferLength += Size;
}
#endif // _CS_CHAR_


void
NdrPartialIgnoreClientBufferSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    void *                              pMemory 
    )
{
     LENGTH_ALIGN( pStubMsg->BufferLength, 0x3 );
     pStubMsg->Buffer += PTR_WIRE_SIZE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr20\chkrobust.cxx ===
/**********************************************************************

Copyright (c) 2002 Microsoft Corporation

Module Name :

    chkrobust.cxx

Abstract :

    This file contains the routines to check if -robust flag is presented on all the methods
    in an interface. This includes both raw rpc interfaces and DCOM interfaces.

Author :

    Yong Qu     yongqu      March 2002

Revision History :

  **********************************************************************/
#include "ndrp.h"
#include "ndrole.h"

static const RPC_SYNTAX_IDENTIFIER gOleServer[] = 
{
   {0x69C09EA0, 0x4A09, 0x101B, 0xAE, 0x4B, 0x08, 0x00, 0x2B, 0x34, 0x9A, 0x02,
    {0, 0}},
   {0x00000131, 0x0000, 0x0000, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46,
    {0, 0}},
   {0x69C09EA0, 0x4A09, 0x101B, 0xAE, 0x4B, 0x08, 0x00, 0x2B, 0x34, 0x9A, 0x02,
    {0, 0}}    
};

// called from RpcServerRegisterIf(x) family
RPC_STATUS
CheckForRobust (
    RPC_SERVER_INTERFACE * pRpcServerIf )
{
    NDR_ASSERT( pRpcServerIf != NULL, "invalid input RPC_SERVER_INTERFACE" );

    if ( pRpcServerIf->DefaultManagerEpv )
        {
        // use_epv, it's not secure
        return RPC_X_BAD_STUB_DATA;
        }

    // either OLE or /Os stub altogether. 
    if ( pRpcServerIf->InterpreterInfo == NULL )
        {
        // there are three "fake" ole interfaces that do their own dispatching
        for ( ulong i = 0; i < 3; i++)
            {
            if ( memcmp(&(pRpcServerIf->InterfaceId), &gOleServer[i], sizeof(RPC_SYNTAX_IDENTIFIER) )== 0 )
                return RPC_S_OK;
            }
        return RPC_X_BAD_STUB_DATA;
        }

#if !defined(__RPC_WIN64__)
    // I don't like this. This is the only way to check for /Oi,Oic stub for raw rpc interface
    for (  ulong i = 0; i < pRpcServerIf->DispatchTable->DispatchTableCount ; i ++ )
        {
        if (pRpcServerIf->DispatchTable->DispatchTable[i] == NdrServerCall )
            return RPC_X_BAD_STUB_DATA;
        }
#endif    
    return NdrpCheckMIDLRobust ( (MIDL_SERVER_INFO *)pRpcServerIf->InterpreterInfo, pRpcServerIf->DispatchTable->DispatchTableCount , FALSE);
}


// called from NdrpCheckRpcServerRobust or from NdrDllRegisterProxy
DWORD
NdrpCheckMIDLRobust( IN const MIDL_SERVER_INFO * pMServerInfo, ulong ProcCount , BOOL IsObjectIntf )
{
    NDR_ASSERT( pMServerInfo != NULL, "invalid MIDL_SERVER_INFO" );
    PMIDL_STUB_DESC  pStubDesc = pMServerInfo->pStubDesc;
    BOOL fHasNoRobust = FALSE;
//    ulong i = IsObjectIntf? 2:0;

    if (pStubDesc->mFlags & RPCFLG_HAS_MULTI_SYNTAXES )
        {
        // -protocol ndr64 or -protocol all has to be robust
        return RPC_S_OK;
        }

    if ( MIDL_VERSION_3_0_39 > pStubDesc->MIDLVersion )
        {
        // we don't support ROBUST in early version of MIDL
        return RPC_X_BAD_STUB_DATA;
        }

    if ( pStubDesc->Version < NDR_VERSION_2_0 )
        {
        // we don't support ROBUST in early version of NDR
        return RPC_X_BAD_STUB_DATA;
        }
        

    NDR_ASSERT( pMServerInfo->FmtStringOffset != NULL, "invalid format string offset" );

    // there might be some interpreter mode method in this interface
    // 

    // We are just checking the last one for performance; we don't care about mixed case (where
    // midl roll back to /Os mode
        // we can't check delegation case.
        if ( pMServerInfo->FmtStringOffset[ProcCount-1] != 0xffff )
            {
            PFORMAT_STRING ProcFormat = &(pMServerInfo->ProcString[pMServerInfo->FmtStringOffset[ProcCount-1]] );
                NDR_PROC_CONTEXT ProcContext;
                if ( !IsObjectIntf || ( ProcFormat[1] & Oi_OBJ_USE_V2_INTERPRETER ) )
                    {
                    MulNdrpInitializeContextFromProc(XFER_SYNTAX_DCE , ProcFormat, &ProcContext , NULL , FALSE );
                    if (ProcContext.NdrInfo.pProcDesc->Oi2Flags.HasExtensions && ProcContext.NdrInfo.pProcDesc->NdrExts.Flags2.HasNewCorrDesc )
                        return RPC_S_OK;
                    }
            }
     return RPC_X_BAD_STUB_DATA;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr20\cvtg.cxx ===
/* file:  cvt_vax_g.c */

/*
**
**                         COPYRIGHT (c) 1989, 1990 BY
**           DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.
**                          ALL RIGHTS RESERVED.
**
**  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED
**  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE
**  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER
**  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
**  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY
**  TRANSFERRED.
**
**  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE
**  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT
**  CORPORATION.
**
**  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS
**  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
**
*/

/*
**++
**  Facility:
**
**      CVT Run-Time Library
**
**  Abstract:
**
**      This module contains routines to convert VAX G_Float floating
**      point data into other supported floating point formats.
**
**  Authors:
**
**      Math RTL
**
**  Creation Date:     December 5, 1989.
**
**  Modification History:
**
**      1-001   Original created.       MRTL 5-Dec-1989.
**      1-002   Add VMS and F77 bindings.  TS 26-Mar-1990.
**
**--
*/

/*
**
**  TABLE OF CONTENTS
**
**      cvt_vax_g_to_cray
**      cvt_vax_g_to_ibm_long
**      cvt_vax_g_to_ieee_double
**
*/


#include <stdio.h>
#include <sysinc.h>
#include <rpc.h>
#include "cvt.h"
#include "cvtpvt.h"

//
// Added for the MS NT environment
//

#include <stdlib.h>


/*
**
**  Routine:
**
**      cvt_vax_g_to_ieee_double
**
**  Functional Description:
**
**      This routine converts a VAX G_Float floating point number
**      into an IEEE double precision floating point number.
**
**  Formal Parameters:
**
**      input_value     A VAX G_Float floating point number.
**
**      options         An integer bit mask.  Set bits in the mask represent
**                      selected routine options.  Applicable options are:
**
**                           CVT_C_BIG_ENDIAN       - default is little endian
**                           CVT_C_ERR_UNDERFLOW    - Raise underflows
**                           CVT_C_TRUNCATE         - truncate
**                           CVT_C_ROUND_TO_POS     - round to +infinity
**                           CVT_C_ROUND_TO_NEG     - round to -infinity
**                           CVT_C_ROUND_TO_NEAREST - round to nearest
**                           CVT_C_VAX_ROUNDING     - VAX rounding
**
**                      NOTE: If no rounding mode is selected the following
**                      default rounding mode is assumed:
**
**                              CVT_C_ROUND_TO_NEAREST.
**
**      output_value    The IEEE double precision representation of the VAX
**                      G_Float number.
**
**  Side Effects/Signaled Errors:
**
**      cvt__invalid_value      - an invalid input value was specified.
**      cvt__invalid_option     - an invalid option was specified.
**      cvt__underflow          - an underlow occurred during conversion while
**                                Raise underflow was set.
**
*/

/*
 * C binding
 */
void cvt_vax_g_to_ieee_double( 
    CVT_VAX_G input_value,
    CVT_SIGNED_INT options,
    CVT_IEEE_DOUBLE output_value )
{
    int i, round_bit_position;
    UNPACKED_REAL r;

    switch ( options & ~(CVT_C_BIG_ENDIAN | CVT_C_ERR_UNDERFLOW) ) {
        case 0                      : options |= CVT_C_ROUND_TO_NEAREST;
        case CVT_C_ROUND_TO_NEAREST :
        case CVT_C_TRUNCATE         :
        case CVT_C_ROUND_TO_POS     :
        case CVT_C_ROUND_TO_NEG     :
        case CVT_C_VAX_ROUNDING     : break;
        default : RAISE(cvt__invalid_option);
    }

//  ===========================================================================
//
// This file used to be included as a separate file.
//#include "unp_vaxg.c"
//
//  ===========================================================================

/* file: unpack_vax_g.c */


/*
**
**			   COPYRIGHT (c) 1989 BY
**	     DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.
**			    ALL RIGHTS RESERVED.
**
**  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED
**  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE
**  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER
**  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
**  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY
**  TRANSFERRED.
**
**  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE
**  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT
**  CORPORATION.
**
**  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS
**  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
**
*/


/*
**++
**  Facility:
**
**      CVT Run-Time Library
**
**  Abstract:
**
**      This module contains code to extract information from a VAX
**      g_floating number and to initialize an UNPACKED_REAL structure
**      with those bits.
**
**		This module is meant to be used as an include file.
**
**  Author: Math RTL
**
**  Creation Date:  November 24, 1989.
**
**  Modification History:
**
**--
*/


/*
**++
**  Functional Description:
**
**  This module contains code to extract information from a VAX
**  g_floating number and to initialize an UNPACKED_REAL structure
**  with those bits.
**
**  See the header files for a description of the UNPACKED_REAL
**  structure.
** 
**  A VAX g_floating number in (16 bit words) looks like:
** 
**      [0]: Sign bit, 11 exp bits (bias 1024), 4 fraction bits
**      [1]: 16 more fraction bits
**      [2]: 16 more fraction bits
**      [3]: 16 more fraction bits
**
**      0.5 <= fraction < 1.0, MSB implicit
**
**
**  Implicit parameters:
**
**  	input_value: a pointer to the input parameter.
**
**  	r: an UNPACKED_REAL structure
**
**--
*/


	RpcpMemoryCopy(&r[1], input_value, 8);

	/* Initialize FLAGS and perhaps set NEGATIVE bit */

	r[U_R_FLAGS] = (r[1] >> 15) & U_R_NEGATIVE;

	/* Extract VAX biased exponent */

	r[U_R_EXP] = (r[1] >> 4) & 0x000007FFL;

	if (r[U_R_EXP] == 0) {

		if (r[U_R_FLAGS])
			r[U_R_FLAGS] |= U_R_INVALID;
		else
			r[U_R_FLAGS] = U_R_ZERO;

	} else {

		/* Adjust for VAX 16 bit floating format */

		r[1] = ((r[1] << 16) | (r[1] >> 16));
		r[2] = ((r[2] << 16) | (r[2] >> 16));

		/* Add unpacked real bias and subtract VAX bias */

		r[U_R_EXP] += (U_R_BIAS - 1024);

		/* Set hidden bit */

		r[1] |= 0x00100000L;

		/* Left justify fraction bits */

		r[1] <<= 11;
		r[1] |= (r[2] >> 21);
		r[2] <<= 11;

		/* Clear uninitialized part of unpacked real */

		r[3] = 0;
		r[4] = 0;

	}

// end of file: unpack_vax_g.c
//
//  ===========================================================================
//
// This file used to be included as a separate file.
//#include "pack_iet.c"
//
//  ===========================================================================

/* file: pack_ieee_t.c */


/*
**
**                         COPYRIGHT (c) 1989 BY
**           DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.
**                          ALL RIGHTS RESERVED.
**
**  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED
**  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE
**  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER
**  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
**  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY
**  TRANSFERRED.
**
**  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE
**  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT
**  CORPORATION.
**
**  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS
**  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
**
*/


/*
**++
**  Facility:
**
**      CVT Run-Time Library
**
**  Abstract:
**
**      This module contains code to extract information from an
**      UNPACKED_REAL structure and to create an IEEE double floating number
**      with those bits.
**
**              This module is meant to be used as an include file.
**
**  Author: Math RTL
**
**  Creation Date:  November 24, 1989.
**
**  Modification History:
**
**--
*/


/*
**++
**  Functional Description:
**
**  This module contains code to extract information from an
**  UNPACKED_REAL structure and to create an IEEE double floating number
**  with those bits.
**
**  See the header files for a description of the UNPACKED_REAL
**  structure.
**
**  A normalized IEEE double precision floating number looks like:
**
**      [0]: 32 low order fraction bits
**      [1]: Sign bit, 11 exp bits (bias 1023), 20 fraction bits
**
**      1.0 <= fraction < 2.0, MSB implicit
**
**  For more details see "Mips R2000 Risc Architecture"
**  by Gerry Kane, page 6-8 or ANSI/IEEE Std 754-1985.
**
**
**  Implicit parameters:
**
**      options: a word of flags, see include files.
**
**      output_value: a pointer to the input parameter.
**
**      r: an UNPACKED_REAL structure.
**
**              i: a temporary integer variable
**
**--
*/



    if (r[U_R_FLAGS] & U_R_UNUSUAL) {

        if (r[U_R_FLAGS] & U_R_ZERO)

                if (r[U_R_FLAGS] & U_R_NEGATIVE)
                        RpcpMemoryCopy(output_value, IEEE_T_NEG_ZERO, 8);
                else
                        RpcpMemoryCopy(output_value, IEEE_T_POS_ZERO, 8);

        else if (r[U_R_FLAGS] & U_R_INFINITY) {

                if (r[U_R_FLAGS] & U_R_NEGATIVE)
                        RpcpMemoryCopy(output_value, IEEE_T_NEG_INFINITY, 8);
                else
                        RpcpMemoryCopy(output_value, IEEE_T_POS_INFINITY, 8);

        } else if (r[U_R_FLAGS] & U_R_INVALID) {

                RpcpMemoryCopy(output_value, IEEE_T_INVALID, 8);
                RAISE(cvt__invalid_value);

        }

    } else {

        /* Precision varies if value will be a denorm */
        /* So, figure out where to round (0 <= i <= 53). */

        round_bit_position = r[U_R_EXP] - ((U_R_BIAS - 1022) - 52);
        if (round_bit_position < 0)
                round_bit_position = 0;
        else if (round_bit_position > 53)
                round_bit_position = 53;

#include "round.cxx"

        if (r[U_R_EXP] < (U_R_BIAS - 1021)) {

                /* Denorm or underflow */

                if (r[U_R_EXP] < ((U_R_BIAS - 1021) - 52)) {

                        /* Value is too small for a denorm, so underflow */

                        if (r[U_R_FLAGS] & U_R_NEGATIVE)
                                RpcpMemoryCopy(output_value, IEEE_T_NEG_ZERO, 8);
                        else
                               RpcpMemoryCopy(output_value, IEEE_T_POS_ZERO, 8);
                        if (options & CVT_C_ERR_UNDERFLOW) {
                                RAISE(cvt__underflow);
                        }

                } else {

                        /* Figure leading zeros for denorm and right-justify fraction */

                        i = 64 - (r[U_R_EXP] - ((U_R_BIAS - 1022) - 52));

                        if (i > 31) {
                                i -= 32;
                                r[2] = (r[1] >> i);
                                r[1] = 0;
                        } else {
                                r[2] >>= i;
                                r[2] |= (r[1] << (32 - i));
                                r[1] >>= i;
                        }

                        /* OR in sign bit */

                        r[1] |= (r[U_R_FLAGS] << 31);

                        if (options & CVT_C_BIG_ENDIAN) {

                                r[0]  = ((r[1] << 24) | (r[1] >> 24));
                                r[0] |= ((r[1] << 8) & 0x00FF0000L);
                                r[0] |= ((r[1] >> 8) & 0x0000FF00L);
                                r[1]  = ((r[2] << 24) | (r[2] >> 24));
                                r[1] |= ((r[2] << 8) & 0x00FF0000L);
                                r[1] |= ((r[2] >> 8) & 0x0000FF00L);

                        } else {

                                r[0] = r[2];

                        }

                        RpcpMemoryCopy(output_value, r, 8);
                }

        } else if (r[U_R_EXP] > (U_R_BIAS + 1024)) {

                /* Overflow */

                if (options & CVT_C_TRUNCATE) {

                        if (r[U_R_FLAGS] & U_R_NEGATIVE)
                                RpcpMemoryCopy(output_value, IEEE_T_NEG_HUGE, 8);
                        else
                                RpcpMemoryCopy(output_value, IEEE_T_POS_HUGE, 8);

                } else if ((options & CVT_C_ROUND_TO_POS)
                                        && (r[U_R_FLAGS] & U_R_NEGATIVE)) {

                                RpcpMemoryCopy(output_value, IEEE_T_NEG_HUGE, 8);

                } else if ((options & CVT_C_ROUND_TO_NEG)
                                        && !(r[U_R_FLAGS] & U_R_NEGATIVE)) {

                                RpcpMemoryCopy(output_value, IEEE_T_POS_HUGE, 8);

                } else {

                        if (r[U_R_FLAGS] & U_R_NEGATIVE)
                                RpcpMemoryCopy(output_value, IEEE_T_NEG_INFINITY, 8);
                        else
                                RpcpMemoryCopy(output_value, IEEE_T_POS_INFINITY, 8);

                }

                RAISE(cvt__overflow);

        } else {

                /* Adjust bias of exponent */

                r[U_R_EXP] -= (U_R_BIAS - 1022);

                /* Make room for exponent and sign bit */

                r[2] >>= 11;
                r[2] |= (r[1] << 21);
                r[1] >>= 11;

                /* Clear implicit bit */

                r[1] &= 0x000FFFFFL;

                /* OR in exponent and sign bit */

                r[1] |= (r[U_R_EXP] << 20);
                r[1] |= (r[U_R_FLAGS] << 31);

                if (options & CVT_C_BIG_ENDIAN) {

                        r[0]  = ((r[1] << 24) | (r[1] >> 24));
                        r[0] |= ((r[1] << 8) & 0x00FF0000L);
                        r[0] |= ((r[1] >> 8) & 0x0000FF00L);
                        r[1]  = ((r[2] << 24) | (r[2] >> 24));
                        r[1] |= ((r[2] << 8) & 0x00FF0000L);
                        r[1] |= ((r[2] >> 8) & 0x0000FF00L);

                } else {

                        r[0] = r[2];

                }

                RpcpMemoryCopy(output_value, r, 8);
        }

    }

// end of file: pack_iet.c
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr20\cvt.h ===
/* file: cvt.h */

/*
**
**                         COPYRIGHT (c) 1989, 1990 BY
**           DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.
**                          ALL RIGHTS RESERVED.
**
**  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED
**  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE
**  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER
**  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
**  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY
**  TRANSFERRED.
**
**  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE
**  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT
**  CORPORATION.
**
**  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS
**  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
**
*/

/*
**++
**  Facility:
**
**      CVT Run-Time Library
**
**  Abstract:
**
**      This module contains the public include file for the cvt_* routines.
**      This module contains rountine interfaces as well as necessary
**      definitions.
**
**  Author:
**
**      Math RTL
**
**  Creation Date:     December 5, 1989.
**
**  Modification History:
**
**      1-001   Original created.       MRTL 5-Dec-1989.
**      1-002   Add GEM FORTRAN stuff.  TS 27-Mar-1990.
**
**--
*/


#ifndef CVT
#define CVT 1

/*
 *
 *    Type Definitions
 *
 */

typedef unsigned char CVT_BYTE;
typedef CVT_BYTE *CVT_BYTE_PTR;

typedef CVT_BYTE CVT_VAX_F[4];
typedef CVT_BYTE CVT_VAX_D[8];
typedef CVT_BYTE CVT_VAX_G[8];
typedef CVT_BYTE CVT_VAX_H[16];
typedef CVT_BYTE CVT_IEEE_SINGLE[4];
typedef CVT_BYTE CVT_IEEE_DOUBLE[8];
typedef CVT_BYTE CVT_IBM_SHORT[4];
typedef CVT_BYTE CVT_IBM_LONG[8];
typedef CVT_BYTE CVT_CRAY[8];
typedef float    CVT_SINGLE;
typedef double   CVT_DOUBLE;
typedef long     CVT_SIGNED_INT;
typedef unsigned long CVT_UNSIGNED_INT;
typedef unsigned long CVT_STATUS;


/*
 *
 *    Constant Definitions
 *
 */

#define CVT_C_ROUND_TO_NEAREST               1
#define CVT_C_TRUNCATE                       2
#define CVT_C_ROUND_TO_POS                   4
#define CVT_C_ROUND_TO_NEG                   8
#define CVT_C_VAX_ROUNDING                  16
#define CVT_C_BIG_ENDIAN                    32
#define CVT_C_ERR_UNDERFLOW                 64
#define CVT_C_ZERO_BLANKS                  128
#define CVT_C_SKIP_BLANKS                  256
#define CVT_C_SKIP_UNDERSCORES             512
#define CVT_C_SKIP_UNDERSCORE              512
#define CVT_C_SKIP_TABS                   1024
#define CVT_C_ONLY_E                      2048
#define CVT_C_EXP_LETTER_REQUIRED         4096
#define CVT_C_FORCE_SCALE                 8192
#define CVT_C_EXPONENTIAL_FORMAT         16384
#define CVT_C_FORCE_PLUS                 32768
#define CVT_C_FORCE_EXPONENT_SIGN        65536
#define CVT_C_SUPPRESS_TRAILING_ZEROES  131072
#define CVT_C_FORCE_EXPONENTIAL_FORMAT  262144
#define CVT_C_FORCE_FRACTIONAL_FORMAT   524288
#define CVT_C_EXPONENT_D                1048576
#define CVT_C_EXPONENT_E                2097152
#define CVT_C_SEMANTICS_FORTRAN         4194304
#define CVT_C_SEMANTICS_PASCAL          8388608


#define cvt__normal                     1
#define cvt__invalid_character          2
#define cvt__invalid_option             3
#define cvt__invalid_radix              4
#define cvt__invalid_size               5
#define cvt__invalid_value              6
#define cvt__neg_infinity               7
#define cvt__output_conversion_error    8
#define cvt__overflow                   9
#define cvt__pos_infinity               10
#define cvt__underflow                  11
#define cvt__input_conversion_error     12

#define cvt_s_normal                    cvt__normal
#define cvt_s_invalid_character         cvt__invalid_character
#define cvt_s_invalid_option            cvt__invalid_option
#define cvt_s_invalid_radix             cvt__invalid_radix
#define cvt_s_invalid_size              cvt__invalid_size
#define cvt_s_invalid_value             cvt__invalid_value
#define cvt_s_neg_infinity              cvt__neg_infinity
#define cvt_s_input_conversion_error    cvt__input_conversion_error
#define cvt_s_output_conversion_error   cvt__output_conversion_error
#define cvt_s_overflow                  cvt__overflow
#define cvt_s_pos_infinity              cvt__pos_infinity
#define cvt_s_underflow                 cvt__underflow

#define CVT_C_BIN  2
#define CVT_C_OCT  8
#define CVT_C_DEC 10
#define CVT_C_HEX 16


/*
 *
 *    Routine interfaces
 *
 */

#ifndef PCC

extern void cvt_cray_to_vax_f (
                CVT_CRAY input_value,
                CVT_SIGNED_INT options,
                CVT_VAX_F output_value
                );

extern void cvt_cray_to_vax_d (
                CVT_CRAY input_value,
                CVT_SIGNED_INT options,
                CVT_VAX_D output_value
                );

extern void cvt_cray_to_vax_g (
                CVT_CRAY input_value,
                CVT_SIGNED_INT options,
                CVT_VAX_G output_value
                );

extern void cvt_cray_to_vax_h (
                CVT_CRAY input_value,
                CVT_SIGNED_INT options,
                CVT_VAX_H output_value
                );

extern void cvt_cray_to_ieee_single (
                CVT_CRAY input_value,
                CVT_SIGNED_INT options,
                CVT_IEEE_SINGLE output_value
                );

extern void cvt_cray_to_ieee_double (
                CVT_CRAY input_value,
                CVT_SIGNED_INT options,
                CVT_IEEE_DOUBLE output_value
                );




extern void cvt_ibm_short_to_vax_f (
                CVT_IBM_SHORT input_value,
                CVT_SIGNED_INT options,
                CVT_VAX_F output_value
                );

extern void cvt_ibm_short_to_ieee_single (
                CVT_IBM_SHORT input_value,
                CVT_SIGNED_INT options,
                CVT_IEEE_SINGLE output_value
                );




extern void cvt_ibm_long_to_vax_d (
                CVT_IBM_LONG input_value,
                CVT_SIGNED_INT options,
                CVT_VAX_D output_value
                );

extern void cvt_ibm_long_to_vax_g (
                CVT_IBM_LONG input_value,
                CVT_SIGNED_INT options,
                CVT_VAX_G output_value
                );

extern void cvt_ibm_long_to_vax_h (
                CVT_IBM_LONG input_value,
                CVT_SIGNED_INT options,
                CVT_VAX_H output_value
                );

extern void cvt_ibm_long_to_ieee_double (
                CVT_IBM_LONG input_value,
                CVT_SIGNED_INT options,
                CVT_IEEE_DOUBLE output_value
                );




extern void cvt_ieee_single_endian (
                CVT_IEEE_SINGLE input_value,
                CVT_IEEE_SINGLE output_value
                );

extern void cvt_ieee_single_to_cray (
                CVT_IEEE_SINGLE input_value,
                CVT_SIGNED_INT options,
                CVT_CRAY output_value
                );

extern void cvt_ieee_single_to_ibm_short (
                CVT_IEEE_SINGLE input_value,
                CVT_SIGNED_INT options,
                CVT_IBM_SHORT output_value
                );

extern void cvt_ieee_single_to_vax_f (
                CVT_IEEE_SINGLE input_value,
                CVT_SIGNED_INT options,
                CVT_VAX_F output_value
                );




extern void cvt_ieee_double_endian (
                CVT_IEEE_DOUBLE input_value,
                CVT_IEEE_DOUBLE output_value
                );

extern void cvt_ieee_double_to_cray (
                CVT_IEEE_DOUBLE input_value,
                CVT_SIGNED_INT options,
                CVT_CRAY output_value
                );

extern void cvt_ieee_double_to_ibm_long (
                CVT_IEEE_DOUBLE input_value,
                CVT_SIGNED_INT options,
                CVT_IBM_LONG output_value
                );

extern void cvt_ieee_double_to_vax_d (
                CVT_IEEE_DOUBLE input_value,
                CVT_SIGNED_INT options,
                CVT_VAX_D output_value
                );

extern void cvt_ieee_double_to_vax_g (
                CVT_IEEE_DOUBLE input_value,
                CVT_SIGNED_INT options,
                CVT_VAX_G output_value
                );

extern void cvt_ieee_double_to_vax_h (
                CVT_IEEE_DOUBLE input_value,
                CVT_SIGNED_INT options,
                CVT_VAX_H output_value
                );




extern void cvt_vax_f_to_cray (
                CVT_VAX_F input_value,
                CVT_SIGNED_INT options,
                CVT_CRAY output_value
                );

extern void cvt_vax_f_to_ibm_short (
                CVT_VAX_F input_value,
                CVT_SIGNED_INT options,
                CVT_IBM_SHORT output_value
                );

extern void cvt_vax_f_to_ieee_single (
                CVT_VAX_F input_value,
                CVT_SIGNED_INT options,
                CVT_IEEE_SINGLE output_value
                );




extern void cvt_vax_d_to_cray (
                CVT_VAX_D input_value,
                CVT_SIGNED_INT options,
                CVT_CRAY output_value
                );

extern void cvt_vax_d_to_ibm_long (
                CVT_VAX_D input_value,
                CVT_SIGNED_INT options,
                CVT_IBM_LONG output_value
                );

extern void cvt_vax_d_to_ieee_double (
                CVT_VAX_D input_value,
                CVT_SIGNED_INT options,
                CVT_IEEE_DOUBLE output_value
                );




extern void cvt_vax_g_to_cray (
                CVT_VAX_G input_value,
                CVT_SIGNED_INT options,
                CVT_CRAY output_value
                );

extern void cvt_vax_g_to_ibm_long (
                CVT_VAX_G input_value,
                CVT_SIGNED_INT options,
                CVT_IBM_LONG output_value
                );

extern void cvt_vax_g_to_ieee_double (
                CVT_VAX_G input_value,
                CVT_SIGNED_INT options,
                CVT_IEEE_DOUBLE output_value
                );




extern void cvt_vax_h_to_cray (
                CVT_VAX_H input_value,
                CVT_SIGNED_INT options,
                CVT_CRAY output_value
                );

extern void cvt_vax_h_to_ibm_long (
                CVT_VAX_H input_value,
                CVT_SIGNED_INT options,
                CVT_IBM_LONG output_value
                );

extern void cvt_vax_h_to_ieee_double (
                CVT_VAX_H input_value,
                CVT_SIGNED_INT options,
                CVT_VAX_H output_value
                );




extern CVT_SINGLE cvt_integer_to_single(
                        CVT_SIGNED_INT,         /* input_value */
                        CVT_SIGNED_INT          /* options     */
                        );

extern CVT_DOUBLE cvt_integer_to_double(
                        CVT_SIGNED_INT          /* input_value */
                        );

#ifdef VAX
extern CVT_SIGNED_INT cvt_single_to_integer(
                        CVT_DOUBLE,             /* input_value */
                        CVT_SIGNED_INT          /* options     */
                        );
#else
extern CVT_SIGNED_INT cvt_single_to_integer(
                        CVT_SINGLE,             /* input_value */
                        CVT_SIGNED_INT          /* options     */
                        );
#endif

extern CVT_SIGNED_INT cvt_double_to_integer(
                        CVT_DOUBLE,             /* input_value */
                        CVT_SIGNED_INT          /* options     */
                        );

#ifdef VAX
extern CVT_DOUBLE cvt_single_to_double(
                        CVT_DOUBLE              /* input_value */
                        );
#else
extern CVT_DOUBLE cvt_single_to_double(
                        CVT_SINGLE              /* input_value */
                        );
#endif

extern CVT_SINGLE cvt_double_to_single(
                        CVT_DOUBLE,             /* input_value */
                        CVT_SIGNED_INT          /* options     */
                        );



extern void cvt_integer_endian (
                CVT_UNSIGNED_INT,               /* input_value     */
                CVT_UNSIGNED_INT *              /* output_value    */
                );

extern void cvt_data_endian (
                unsigned char *,                /* input_value     */
                CVT_SIGNED_INT,                 /* value_size      */
                unsigned char *                 /* output_value    */
                );

extern CVT_STATUS cvt_text_to_integer(
                        char *,                 /* input_string    */
                        CVT_SIGNED_INT,         /* string_size     */
                        CVT_SIGNED_INT,         /* options         */
                        CVT_SIGNED_INT *        /* resultant value */
                        );

extern CVT_STATUS cvt_text_to_unsigned(
                        char *,                 /* input_string    */
                        CVT_SIGNED_INT,         /* string_size     */
                        CVT_SIGNED_INT,         /* radix           */
                        CVT_SIGNED_INT,         /* options         */
                        CVT_UNSIGNED_INT *      /* resultant value */
                        );

extern CVT_STATUS cvt_integer_to_text(
                        CVT_SIGNED_INT,         /* input_value      */
                        CVT_SIGNED_INT,         /* string_size      */
                        CVT_SIGNED_INT,         /* number_of_digits */
                        CVT_SIGNED_INT,         /* options          */
                        char *                  /* resultant_string */
                        );

extern CVT_STATUS cvt_unsigned_to_text(
                        CVT_UNSIGNED_INT,       /* input_value      */
                        CVT_SIGNED_INT,         /* string_size      */
                        CVT_SIGNED_INT,         /* radix            */
                        CVT_SIGNED_INT,         /* number_of_digits */
                        char *                  /* resultant_string */
                        );

extern CVT_STATUS cvt_text_to_data(
                        char *,                 /* input_string */
                        CVT_SIGNED_INT,         /* string_size  */
                        CVT_SIGNED_INT,         /* value_size   */
                        CVT_SIGNED_INT,         /* radix        */
                        CVT_SIGNED_INT,         /* options      */
                        unsigned char *);       /* resultant value */

extern CVT_STATUS cvt_data_to_text(
                        unsigned char *,        /* input_value */
                        CVT_SIGNED_INT,         /* string_size */
                        CVT_SIGNED_INT,         /* value_size   */
                        CVT_SIGNED_INT,         /* radix */
                        CVT_SIGNED_INT,         /* number_of_digits */
                        char *);                /* resultant_string */

extern CVT_STATUS cvt_text_to_boolean (
                        char *,                 /* input_string */
                        CVT_SIGNED_INT,         /* string_size  */
                        CVT_SIGNED_INT,         /* options      */
                        CVT_SIGNED_INT *);      /* resultant value */

extern CVT_STATUS cvt_boolean_to_text (
                        CVT_SIGNED_INT,         /* input_value */
                        CVT_SIGNED_INT,         /* string_size */
                        CVT_SIGNED_INT,         /* options */
                        char *);                /* resultant_string */

#else // PCC

extern void cvt_cray_to_vax_f ();
extern void cvt_cray_to_vax_d ();
extern void cvt_cray_to_vax_g ();
extern void cvt_cray_to_vax_h ();
extern void cvt_cray_to_ieee_single ();
extern void cvt_cray_to_ieee_double ();

extern void cvt_ibm_short_to_vax_f ();
extern void cvt_ibm_short_to_ieee_single ();

extern void cvt_ibm_long_to_vax_d ();
extern void cvt_ibm_long_to_vax_g ();
extern void cvt_ibm_long_to_vax_h ();
extern void cvt_ibm_long_to_ieee_double ();

extern void cvt_ieee_single_endian ();
extern void cvt_ieee_single_to_cray ();
extern void cvt_ieee_single_to_ibm_short ();
extern void cvt_ieee_single_to_vax_f ();

extern void cvt_ieee_double_endian ();
extern void cvt_ieee_double_to_cray ();
extern void cvt_ieee_double_to_ibm_long ();
extern void cvt_ieee_double_to_vax_d ();
extern void cvt_ieee_double_to_vax_g ();
extern void cvt_ieee_double_to_vax_h ();

extern void cvt_vax_f_to_cray ();
extern void cvt_vax_f_to_ibm_short ();
extern void cvt_vax_f_to_ieee_single ();

extern void cvt_vax_d_to_cray ();
extern void cvt_vax_d_to_ibm_long ();
extern void cvt_vax_d_to_ieee_double ();

extern void cvt_vax_g_to_cray ();
extern void cvt_vax_g_to_ibm_long ();
extern void cvt_vax_g_to_ieee_double ();

extern void cvt_vax_h_to_cray ();
extern void cvt_vax_h_to_ibm_long ();
extern void cvt_vax_h_to_ieee_double ();

extern void cvt_integer_endian ();
extern void cvt_data_endian ();

extern CVT_SINGLE cvt_integer_to_single();
extern CVT_DOUBLE cvt_integer_to_double();

extern CVT_SIGNED_INT cvt_single_to_integer();
extern CVT_SIGNED_INT cvt_double_to_integer();

extern CVT_DOUBLE cvt_single_to_double();
extern CVT_SINGLE cvt_double_to_single();

extern CVT_STATUS cvt_text_to_integer();
extern CVT_STATUS cvt_text_to_unsigned();

extern CVT_STATUS cvt_integer_to_text();
extern CVT_STATUS cvt_unsigned_to_text();

extern CVT_STATUS cvt_text_to_boolean();
extern CVT_STATUS cvt_text_to_data();

extern CVT_STATUS cvt_boolean_to_text();
extern CVT_STATUS cvt_data_to_text();

#endif
#endif                  /* end of CVT.H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr20\cvtglo.cxx ===
/* file: cvt__globals.c */

/*
**
**                         COPYRIGHT (c) 1989 BY
**           DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.
**                          ALL RIGHTS RESERVED.
**
**  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED
**  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE
**  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER
**  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
**  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY
**  TRANSFERRED.
**
**  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE
**  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT
**  CORPORATION.
**
**  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS
**  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
**
*/

/*
**++
**  Facility:
**
**      CVT Run-Time Library
**
**  Abstract:
**
**
**  Authors:
**
**      Math RTL
**
**  Creation Date:     December 5, 1989.
**
**  Modification History:
**
**      1-001   Original created.
**              MRTL 5-Dec-1989.
**
**--
*/


#include "cvt.h"
#include "cvtpvt.h"


extern const unsigned long vax_c[] = {

        0x00008000, 0x00000000, 0x00000000, 0x00000000,         /* ROPs */
        0x00000000, 0x00000000, 0x00000000, 0x00000000,         /* zeros */
        0xffff7fff, 0xffffffff, 0xffffffff, 0xffffffff,         /* +huge */
        0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,         /* -huge */

};


extern const unsigned long ieee_s[] = {

        0x7fbfffff,             /* little endian ieee s nan */
        0xffffbf7f,             /* big endian ieee s nan */
        0x00000000,             /* le ieee s +zero */
        0x00000000,             /* be ieee s +zero */
        0x80000000,             /* le ieee s -zero */
        0x00000080,             /* be ieee s -zero */
        0x7f7fffff,             /* le ieee s +huge */
        0xffff7f7f,             /* be ieee s +huge */
        0xff7fffff,             /* le ieee s -huge */
        0xffff7fff,             /* be ieee s -huge */
        0x7f800000,             /* le ieee s +infinity */
        0x0000807f,             /* be ieee s +infinity */
        0xff800000,             /* le ieee s -infinity */
        0x000080ff,             /* be ieee s -infinity */

};

extern const unsigned long ieee_t[] = {

        0xffffffff, 0x7ff7ffff,         /* le ieee t nan */
        0xfffff77f, 0xffffffff,         /* be ieee t nan */
        0x00000000, 0x00000000,         /* le ieee t +zero */
        0x00000000, 0x00000000,         /* be ieee t +zero */
        0x00000000, 0x80000000,         /* le ieee t -zero */
        0x00000080, 0x00000000,         /* be ieee t -zero */
        0xffffffff, 0x7fefffff,         /* le ieee s +huge */
        0xffffef7f, 0xffffffff,         /* be ieee s +huge */
        0xffffffff, 0xffefffff,         /* le ieee s -huge */
        0xffffefff, 0xffffffff,         /* be ieee s -huge */
        0x00000000, 0x7ff00000,         /* le ieee t +infinity */
        0x0000f07f, 0x00000000,         /* be ieee t +infinity */
        0x00000000, 0xfff00000,         /* le ieee t -infinity */
        0x0000f0ff, 0x00000000,         /* be ieee t -infinity */

};


extern const unsigned long ibm_s[] = {

   0x000000ff,          /* ibm s invalid */
   0x00000000,          /* ibm s +zero */
   0x00000080,          /* ibm s -zero */
   0xffffff7f,          /* ibm s +huge */
   0xffffffff,          /* ibm s -huge */
   0xffffff7f,          /* ibm s +infinity */
   0xffffffff,          /* ibm s -infinity */

};

extern const unsigned long ibm_l[] = {

   0x000000ff, 0x00000000,              /* ibm t invalid */
   0x00000000, 0x00000000,              /* ibm t +zero */
   0x00000080, 0x00000000,              /* ibm t -zero */
   0xffffff7f, 0xffffffff,              /* ibm t +huge */
   0xffffffff, 0xffffffff,              /* ibm t -huge */
   0xffffff7f, 0xffffffff,              /* ibm t +infinity */
   0xffffffff, 0xffffffff,              /* ibm t -infinity */

};


extern const unsigned long cray[] = {

        0x00000060, 0x00000000,         /* cray invalid */
        0x00000000, 0x00000000,         /* cray +zero */
        0x00000080, 0x00000000,         /* cray -zero */
        0xffffff5f, 0xffffffff,         /* cray +huge */
        0xffffffdf, 0xffffffff,         /* cray -huge */
        0x00000060, 0x00000000,         /* cray +infinity */
        0x000000e0, 0x00000000,         /* cray -infinity */

};


extern const unsigned long int_c[] = {

        0x00000000,             /* le int nan */
        0x00000000,             /* be int nan */
        0x00000000,             /* le int zero */
        0x00000000,             /* be int zero */
        0x7fffffff,             /* le int +huge */
        0xffffff7f,             /* be int +huge */
        0x80000000,             /* le int -huge */
        0x00000080,             /* be int -huge */
        0x7fffffff,             /* le int +infinity */
        0xffffff7f,             /* be int +infinity */
        0x80000000,             /* le int -infinity */
        0x00000080,             /* be int -infinity */

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr20\cltcall.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1993-2000 Microsoft Corporation

Module Name :

    cltcall.c

Abstract :

    This file contains the single call Ndr routine for the client side.

Author :

    David Kays    dkays    October 1993.

Revision History :

    brucemc     11/15/93    Added struct by value support, corrected
                            varargs use.
    brucemc     12/20/93    Binding handle support
    ryszardk    3/12/94     handle optimization and fixes

---------------------------------------------------------------------*/

#define USE_STUBLESS_PROXY
#define CINTERFACE

#include <stdarg.h>
#include "ndrp.h"
#include "hndl.h"
#include "interp2.h"
#include "pipendr.h"
#include "attack.h"

#include "ndrole.h"
#include "rpcproxy.h"

#pragma code_seg(".orpc")

#if defined ( DEBUG_142065 )

#define    _STUB_CALCSIZE           0x1
#define    _STUB_GETBUFFER          0x2
#define    _STUB_MARSHAL            0x4
#define    _STUB_SENDRECEIVE        0x8
#define    _STUB_UNMARSHAL          0x10
#define    _STUB_EXCEPTION          0x20
#define    _STUB_AFTER_EXCEPTION    0x40
#define    _STUB_FREE               0x80

typedef struct _STUB_TRACKING_INFO
    {
    PMIDL_STUB_MESSAGE      pStubMsg;
    RPC_MESSAGE             RpcMsg;
    ulong                   StubPhase;
    ulong                   ExceptionCode;    
    }   STUB_TRACKING_INFO;

#endif


CLIENT_CALL_RETURN RPC_ENTRY
NdrpClientCall2(
    PMIDL_STUB_DESC     pStubDescriptor,
    PFORMAT_STRING      pFormat,
    uchar *             StartofStack
    );

#if ! defined(__RPC_WIN64__)
// The old interpreter is not supported on 64b platforms.

CLIENT_CALL_RETURN RPC_VAR_ENTRY
NdrClientCall(
    PMIDL_STUB_DESC     pStubDescriptor,
    PFORMAT_STRING      pFormat,
    ...
    )
{
    RPC_MESSAGE                 RpcMsg;
    MIDL_STUB_MESSAGE           StubMsg;
    PFORMAT_STRING              pFormatParam, pFormatParamSaved;
    PFORMAT_STRING              pHandleFormatSave;
    ulong                       ProcNum;
    ulong                       RpcFlags;
    long                        StackSize;
    long                        TotalStackSize;
    CLIENT_CALL_RETURN          ReturnValue;
    va_list                     ArgList;
    void *                      pArg;
    void **                     ppArg;
    uchar *                     StartofStack;
    handle_t                    Handle;
    handle_t                    SavedGenericHandle = NULL;
    uchar                       HandleType;
    void *                      pThis;
    INTERPRETER_FLAGS           InterpreterFlags;

    ARG_QUEUE                   ArgQueue;
    ARG_QUEUE_ELEM              QueueElements[QUEUE_LENGTH];
    PARG_QUEUE_ELEM             pQueue;
    long                        Length;

    ArgQueue.Length = 0;
    ArgQueue.Queue = QueueElements;

    HandleType = *pFormat++;

    InterpreterFlags = *((PINTERPRETER_FLAGS)pFormat++);

    StubMsg.FullPtrXlatTables = 0;

    if ( InterpreterFlags.HasRpcFlags )
        RpcFlags = *((ulong UNALIGNED *&)pFormat)++;
    else
        RpcFlags = 0;

    ProcNum = *((ushort *&)pFormat)++;

    TotalStackSize = *((ushort *&)pFormat)++;

    if ( (TotalStackSize / sizeof(REGISTER_TYPE)) > QUEUE_LENGTH )
        {
        ArgQueue.Queue = (PARG_QUEUE_ELEM)
            I_RpcAllocate( (unsigned int)
                           (((TotalStackSize / sizeof(REGISTER_TYPE)) + 1) *
                           sizeof(ARG_QUEUE_ELEM) ) );
        }

    ReturnValue.Pointer = 0;

    //
    // Get address of argument to this function following pFormat. This
    // is the address of the address of the first argument of the function
    // calling this function.
    //
    INIT_ARG( ArgList, pFormat);

    //
    // Get the address of the first argument of the function calling this
    // function. Save this in a local variable and in the main data structure.
    //
    GET_FIRST_IN_ARG(ArgList);
    StartofStack = (uchar*)GET_STACK_START(ArgList);

    //
    // Wrap everything in a try-finally pair. The finally clause does the
    // required freeing of resources (RpcBuffer and Full ptr package).
    //
    RpcTryFinally
        {
        //
        // Use a nested try-except pair to support OLE. In OLE case, test the
        // exception and map it if required, then set the return value. In
        // nonOLE case, just reraise the exception.
        //
        RpcTryExcept
            {
            //
            // Stash away the place in the format string describing the handle.
            //
            pHandleFormatSave = pFormat;

            // Bind the client to the server. Check for an implicit or
            // explicit generic handle.
            //

            if ( InterpreterFlags.ObjectProc )
                {
                pThis = *(void **)StartofStack;
                NdrProxyInitialize( pThis,
                                    &RpcMsg,
                                    &StubMsg,
                                    pStubDescriptor,
                                    ProcNum );
                }
            else
                {
                if ( InterpreterFlags.UseNewInitRoutines )
                    {
                    NdrClientInitializeNew( &RpcMsg,
                                            &StubMsg,
                                            pStubDescriptor,
                                            (uint) ProcNum );
                    }
                else
                    {
                    NdrClientInitialize( &RpcMsg,
                                         &StubMsg,
                                         pStubDescriptor,
                                         (uint) ProcNum );
		            }

                if ( HandleType )
                    {
                    //
                    // We have an implicit handle.
                    //
                    Handle = ImplicitBindHandleMgr( pStubDescriptor,
                                                    HandleType,
                                                    &SavedGenericHandle);
                    }
                else
                    {
                    Handle = ExplicitBindHandleMgr( pStubDescriptor,
                                                    StartofStack,
                                                    pFormat,
                                                    &SavedGenericHandle );

                    pFormat += (*pFormat == FC_BIND_PRIMITIVE) ?  4 :  6;
                    }
                }

            if ( InterpreterFlags.RpcSsAllocUsed )
                NdrRpcSmSetClientToOsf( &StubMsg );

            // Set Rpc flags after the call to client initialize.
            StubMsg.RpcMsg->RpcFlags = RpcFlags;

            // Must do this before the sizing pass!
            StubMsg.StackTop = StartofStack;

            //
            // Make ArgQueue check after all setup/binding is finished.
            //
            if ( ! ArgQueue.Queue )
                RpcRaiseException( RPC_S_OUT_OF_MEMORY );

            if ( InterpreterFlags.FullPtrUsed )
                StubMsg.FullPtrXlatTables = NdrFullPointerXlatInit( 0, XLAT_CLIENT );

            // Save beginning of param description.
            pFormatParamSaved = pFormat;

            //
            // ----------------------------------------------------------------
            // Sizing Pass.
            // ----------------------------------------------------------------
            //

            //
            // If it's an OLE interface, then the this pointer will occupy
            // the first dword on the stack. For each loop hereafter, skip
            // the first dword.
            //
            if ( InterpreterFlags.ObjectProc )
                {
		        GET_NEXT_C_ARG(ArgList,long);
                GET_STACK_POINTER(ArgList,long);
                }

            for ( pQueue = ArgQueue.Queue; ; ArgQueue.Length++, pQueue++ )
                {
                //
                // Clear out flags IsReturn, IsBasetype, IsIn, IsOut,
                // IsOutOnly, IsDeferredFree, IsDontCallFreeInst.
                //
                *((long *)(((char *)pQueue) + 0xc)) = 0;

                switch ( *pFormat )
                    {
                    case FC_IN_PARAM_BASETYPE :
                        pQueue->IsIn = TRUE;
                        pQueue->IsBasetype = TRUE;

                        SIMPLE_TYPE_BUF_INCREMENT(StubMsg.BufferLength,
                                                  pFormat[1]);

                        //
                        // Increment arg list pointer correctly.
                        //
                        switch ( pFormat[1] )
                            {
                            case FC_HYPER :
                                pArg = GET_STACK_POINTER(ArgList,hyper);
                                GET_NEXT_C_ARG(ArgList,hyper);
                                break;

                            case FC_LONG:
                                pArg = GET_STACK_POINTER(ArgList,long);
                                GET_NEXT_C_ARG(ArgList,long);
                                break;

                            default :
                                pArg = GET_STACK_POINTER(ArgList,int);
                                GET_NEXT_C_ARG(ArgList,int);
                                break;
                            }

                        pQueue->pFormat = &pFormat[1];
                        pQueue->pArg = (uchar*)pArg;

                        pFormat += 2;
                        continue;

                    case FC_IN_PARAM :
                    case FC_IN_PARAM_NO_FREE_INST :
                        pQueue->IsIn = TRUE;
                        break;

                    case FC_IN_OUT_PARAM :
                        pQueue->IsIn = TRUE;
                        pQueue->IsOut = TRUE;
                        break;

                    case FC_OUT_PARAM :
                        pQueue->IsOut = TRUE;
                        pQueue->IsOutOnly = TRUE;

                        //
                        // An [out] param ALWAYS eats up at 4 bytes of stack
                        // space on x86, MIPS and PPC and 8 bytes on axp
                        // because it must be a pointer or an array.
                        //
                        ppArg = (void **) GET_STACK_POINTER(ArgList,long);
			            GET_NEXT_C_ARG(ArgList,long);

                        pFormat += 2;
                        pFormatParam = pStubDescriptor->pFormatTypes +
                                       *((short *)pFormat);
                        pFormat += 2;

                        pQueue->pFormat = pFormatParam;
                        pQueue->ppArg = (uchar **)ppArg;

                        if ( InterpreterFlags.ObjectProc )
                            {
                            NdrClientZeroOut( &StubMsg,
                                              pFormatParam,
                                              (uchar*)*ppArg );
                            }

                        continue;

                    case FC_RETURN_PARAM_BASETYPE :
                        pQueue->IsOut = TRUE;
                        pQueue->IsBasetype = TRUE;

                        pQueue->pFormat = &pFormat[1];
                        pQueue->pArg = (uchar *)&ReturnValue;

                        ArgQueue.Length++;
                        goto SizeLoopExit;

                    case FC_RETURN_PARAM :
                        pQueue->IsOut = TRUE;

                        pFormat += 2;
                        pFormatParam = pStubDescriptor->pFormatTypes +
                                       *((short *)pFormat);

                        pQueue->pFormat = pFormatParam;

                        if ( IS_BY_VALUE(*pFormatParam) )
                            {
                            pQueue->pArg = (uchar *)&ReturnValue;
                            pQueue->ppArg = &(pQueue->pArg);
                            }
                        else
                            {
                            pQueue->ppArg = (uchar **)&ReturnValue;
                            }

                        ArgQueue.Length++;
                        goto SizeLoopExit;

                    default :
                        goto SizeLoopExit;
                    }

                //
                // Get the paramter's format string description.
                //
                pFormat += 2;
                pFormatParam = pStubDescriptor->pFormatTypes +
                               *((short *)pFormat);

                pQueue->pFormat = pFormatParam;

                // Increment main format string past offset field.
                pFormat += 2;

                pArg = (uchar *) GET_STACK_POINTER(ArgList, int);
		        GET_NEXT_C_ARG(ArgList, int);

                if ( IS_BY_VALUE( *pFormatParam ) )
                    {
                    pQueue->pArg = (uchar*)pArg;
                    // Only transmit as will ever need this.
                    pQueue->ppArg = &pQueue->pArg;
                    }
                else
                    {
                    pQueue->pArg = *((uchar **)pArg);
                    pQueue->ppArg = (uchar**)pArg;

                    pArg = *((uchar **)pArg);
                    }

                //
                // The second byte of a param's description gives the number of
                // ints occupied by the param on the stack.
                //
                StackSize = pFormat[-3] * sizeof(int);

		        if ( StackSize > sizeof(REGISTER_TYPE) )
                    {

                    StackSize -= sizeof(REGISTER_TYPE);
                    SKIP_STRUCT_ON_STACK(ArgList, StackSize);
                    }

                (*pfnSizeRoutines[ROUTINE_INDEX(*pFormatParam)])
		        ( &StubMsg,
		          (uchar*)pArg,
		          pFormatParam );

                } // for(;;) sizing pass

SizeLoopExit:

            //
            // Make the new GetBuffer call.
            //
            if ( (HandleType == FC_AUTO_HANDLE) &&
                 (! InterpreterFlags.ObjectProc) )
                {
                NdrNsGetBuffer( &StubMsg,
                                StubMsg.BufferLength,
                                Handle );
                }
            else
                {
                if ( InterpreterFlags.ObjectProc )
                    NdrProxyGetBuffer( pThis,
                                       &StubMsg );
                else
                    NdrGetBuffer( &StubMsg,
                                  StubMsg.BufferLength,
                                  Handle );
                }

            NDR_ASSERT( StubMsg.fBufferValid, "Invalid buffer" );

            //
            // ----------------------------------------------------------
            // Marshall Pass.
            // ----------------------------------------------------------
            //

            for ( Length = ArgQueue.Length, pQueue = ArgQueue.Queue;
                  Length--;
                  pQueue++ )
                {
                if ( pQueue->IsIn )
                    {
                    if ( pQueue->IsBasetype )
                        {
                        NdrSimpleTypeMarshall( &StubMsg,
                                              pQueue->pArg,
                                              *(pQueue->pFormat) );
                        }
                    else
                        {
                        pFormatParam = pQueue->pFormat;

                        (*pfnMarshallRoutines[ROUTINE_INDEX(*pFormatParam)])
                        ( &StubMsg,
                          pQueue->pArg,
                          pFormatParam );
                        }
                    }
                }

            //
            // Make the RPC call.
            //
            if ( (HandleType == FC_AUTO_HANDLE) &&
                 (!InterpreterFlags.ObjectProc) )
                {
                NdrNsSendReceive( &StubMsg,
                                  StubMsg.Buffer,
                                  (RPC_BINDING_HANDLE *) pStubDescriptor->
                                      IMPLICIT_HANDLE_INFO.pAutoHandle );
                }
            else
                {
                if ( InterpreterFlags.ObjectProc )
                    NdrProxySendReceive( pThis, &StubMsg );
                else
                    NdrSendReceive( &StubMsg, StubMsg.Buffer );
                }

            //
            // Do endian/floating point conversions.
            //
            if ( (RpcMsg.DataRepresentation & 0X0000FFFFUL) !=
                  NDR_LOCAL_DATA_REPRESENTATION )
                NdrConvert( &StubMsg, pFormatParamSaved );

            //
            // ----------------------------------------------------------
            // Unmarshall Pass.
            // ----------------------------------------------------------
            //

            for ( Length = ArgQueue.Length, pQueue = ArgQueue.Queue;
                  Length--;
                  pQueue++ )
                {
                if ( pQueue->IsOut )
                    {
                    if ( pQueue->IsBasetype )
                        {
                        NdrSimpleTypeUnmarshall( &StubMsg,
                                                 pQueue->pArg,
                                                 *(pQueue->pFormat) );
                        }
                    else
                        {
                        pFormatParam = pQueue->pFormat;

                        (*pfnUnmarshallRoutines[ROUTINE_INDEX(*pFormatParam)])
                        ( &StubMsg,
                          pQueue->ppArg,
                          pFormatParam,
                          FALSE );
                        }
                    }
                }
            }
        RpcExcept( EXCEPTION_FLAG )
            {
            RPC_STATUS ExceptionCode = RpcExceptionCode();

            //
            // In OLE, since they don't know about error_status_t and wanted to
            // reinvent the wheel, check to see if we need to map the exception.
            // In either case, set the return value and then try to free the
            // [out] params, if required.
            //
            if ( InterpreterFlags.ObjectProc )
                {
                ReturnValue.Simple = NdrProxyErrorHandler(ExceptionCode);

                //
                // Set the Buffer endpoints so the NdrFree routines work.
                //
                StubMsg.BufferStart = 0;
                StubMsg.BufferEnd   = 0;

                for ( Length = ArgQueue.Length, pQueue = ArgQueue.Queue;
                      Length--;
                      pQueue++ )
                    {
                    if ( pQueue->IsOutOnly )
                        {
                        NdrClearOutParameters( &StubMsg,
                                               pQueue->pFormat,
                                               *(pQueue->ppArg) );
                        }
                    }
                }
            else
                {
                if ( InterpreterFlags.HasCommOrFault )
                    {
                    NdrClientMapCommFault( &StubMsg,
                                           ProcNum,
                                           ExceptionCode,
                                           (ulong*)&ReturnValue.Simple );
                    }
                else
                    {
                    RpcRaiseException(ExceptionCode);
                    }
                }
            }
        RpcEndExcept
        }
    RpcFinally
        {
        NdrFullPointerXlatFree(StubMsg.FullPtrXlatTables);

        //
        // Free the RPC buffer.
        //
        if ( InterpreterFlags.ObjectProc )
            {
            NdrProxyFreeBuffer( pThis, &StubMsg );
            }
        else
            NdrFreeBuffer( &StubMsg );

        //
        // Unbind if generic handle used.  We do this last so that if the
        // the user's unbind routine faults, then all of our internal stuff
        // will already have been freed.
        //
        if ( SavedGenericHandle )
            {
            GenericHandleUnbind( pStubDescriptor,
                                 StartofStack,
                                 pHandleFormatSave,
                                 (HandleType) ? IMPLICIT_MASK : 0,
                                 &SavedGenericHandle );
            }

        if ( ((TotalStackSize / sizeof(REGISTER_TYPE)) > QUEUE_LENGTH) &&
             ArgQueue.Queue )
            {
            I_RpcFree( ArgQueue.Queue );
            }
        }
    RpcEndFinally

    return ReturnValue;
}

#endif  // ! defined(__RPC_WIN64__)


void
NdrClientZeroOut(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat,
    uchar *             pArg
    )
{
    LONG_PTR   Size;

    //
    // In an object proc, we must zero all [out] unique and interface
    // pointers which occur as the referent of a ref pointer or embedded in a
    // structure or union.
    //

    // Let's not die on a null ref pointer.

    if ( !pArg )
        return;

    //
    // The only top level [out] type allowed is a ref pointer or an array.
    //
    if ( *pFormat == FC_RP )
        {
        // Double pointer.
        if ( POINTER_DEREF(pFormat[1]) )
            {
            *((void **)pArg) = 0;
            return;
            }

        // we need to zero out basetype because it might be conformant/
        // varying descriptor.
        if ( SIMPLE_POINTER(pFormat[1]) )
            {
            MIDL_memset( pArg, 0, (uint) SIMPLE_TYPE_MEMSIZE(pFormat[2]) );
            return;
            }

        // Pointer to struct, union, or array.
        pFormat += 2;
        pFormat += *((short *)pFormat);
        }

    Size = (LONG_PTR)NdrpMemoryIncrement( pStubMsg,
                                          0,
                                          pFormat );

    MIDL_memset( pArg, 0, (size_t)Size );
}

void RPC_ENTRY
NdrClearOutParameters(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat,
    void  *             pArgVoid
    )
/*++

Routine Description :

    Free and clear an [out] parameter in case of exceptions for object
    interfaces.

Arguments :

    pStubMsg    - pointer to stub message structure
    pFormat     - The format string offset
    pArg        - The [out] pointer to clear.

Return :

    NA

Notes:

--*/
{
    uchar *     pArgSaved;
    ULONG_PTR   Size;
    uchar *     pArg = (uchar*)pArgVoid;

    if( pStubMsg->dwStubPhase != PROXY_UNMARSHAL)
        return;

    // Let's not die on a null ref pointer.

    if ( !pArg )
        return;

    Size = 0;

    pArgSaved = pArg;

    //
    // Look for a non-Interface pointer.
    //
    if ( IS_BASIC_POINTER(*pFormat) )
        {
        // Pointer to a basetype.
        if ( SIMPLE_POINTER(pFormat[1]) )
            {
            //
            // It seems wierd to zero an [out] pointer to a basetypes, but this
            // is what we did in NT 3.5x and I wouldn't be surprised if
            // something broke if we changed this behavior.
            //
            Size = SIMPLE_TYPE_MEMSIZE(pFormat[2]);
            goto DoZero;
            }

        // Pointer to a pointer.
        if ( POINTER_DEREF(pFormat[1]) )
            {
            Size = PTR_MEM_SIZE;
            pArg = *((uchar **)pArg);
            }

        pFormat += 2;
        pFormat += *((short *)pFormat);

        if ( *pFormat == FC_BIND_CONTEXT )
            {
            *((NDR_CCONTEXT *)pArg) = (NDR_CCONTEXT) 0;
            return;
            }
        }

    (*pfnFreeRoutines[ROUTINE_INDEX(*pFormat)])
    ( pStubMsg,
      pArg,
      pFormat );


    if ( ! Size )
        {
        Size = (ULONG_PTR)NdrpMemoryIncrement( pStubMsg,
                                               0,
                                               pFormat );
        }

DoZero:

    MIDL_memset( pArgSaved, 0, (size_t)Size );
}

void
NdrClientMapCommFault(
    PMIDL_STUB_MESSAGE  pStubMsg,
    long                ProcNum,
    RPC_STATUS          ExceptionCode,
    ULONG_PTR *         pReturnValue
    )
/*
    This routine will map exception code to the related placeholder in the app.

    The mapping is based on the information generated by the compiler into
    the CommFaultOffset table.
    The table may have the following entries in the comm and fault cells:
        -2    - not mapped
        -1    - mapped to the returned value
        0<=   - mapped to an out parameter, the value is the param stack offset.

    Mapping to a parameter is not allowed in the handle-less asynchronous calls.
    For handle-less async calls, the exception doesn't come from the server, 
    it is just a way for the client stub to signal if the dispatch was succesful.

    Note for 64b platforms. error_status_t has a size of a long and so that is 
    why we leave pReturnValue as well as pComm and pFault as long pointers.

*/
{
    PMIDL_STUB_DESC             pStubDescriptor;
    RPC_STATUS                  Status;
    uchar *                     StartofStack;
    void **                     ppArg;
    const COMM_FAULT_OFFSETS *  Offsets;
    ulong *                     pComm;
    ulong *                     pFault;

    pStubDescriptor = pStubMsg->StubDesc;
    StartofStack = pStubMsg->StackTop;

    Offsets = pStubDescriptor->CommFaultOffsets;

    switch ( Offsets[ProcNum].CommOffset )
        {
        case -2 :
            pComm = 0;
            break;
        case -1 :
            pComm = (ulong*)pReturnValue;
            break;
        default :
            ppArg = (void **)(StartofStack + Offsets[ProcNum].CommOffset);
            pComm = (ulong *) *ppArg;
            break;
        }

    switch ( Offsets[ProcNum].FaultOffset )
        {
        case -2 :
            pFault = 0;
            break;
        case -1 :
            pFault = (ulong*)pReturnValue;
            break;
        default :
            ppArg = (void **)(StartofStack + Offsets[ProcNum].FaultOffset);
            pFault = (ulong *) *ppArg;
            break;
        }

    Status = NdrMapCommAndFaultStatus(
                pStubMsg,
                pComm,
                pFault,
                ExceptionCode
                );

    if ( Status )
        RpcRaiseException(Status);
}

CLIENT_CALL_RETURN RPC_VAR_ENTRY
NdrClientCall2(
    PMIDL_STUB_DESC     pStubDescriptor,
    PFORMAT_STRING      pFormat,
    ...
    )
/*
    This routine is called from the object stubless proxy dispatcher.
*/
{
    va_list                     ArgList;

#if defined(_WIN64)
    // Get address of the virtual stack as forced on the ia64 C compiler.
    // On ia64 the call takes the actual args, not the address to args as usual,
    // so we split the code path with NdrpClientCall2. That is needed for calls
    // from the stubless proxy codepath. This routine is used for call_as.
    //
    INIT_ARG( ArgList, pFormat);
    GET_FIRST_IN_ARG(ArgList);
    uchar *StartofStack = (uchar*)GET_STACK_START(ArgList);

    return NdrpClientCall2( pStubDescriptor, pFormat, StartofStack );
}

CLIENT_CALL_RETURN RPC_ENTRY
NdrpClientCall2(
    PMIDL_STUB_DESC     pStubDescriptor,
    PFORMAT_STRING      pFormat,
    uchar *             StartofStack
    )
{
#endif // _WIN64

    RPC_MESSAGE                 RpcMsg;
    MIDL_STUB_MESSAGE           StubMsg;
    CLIENT_CALL_RETURN          ReturnValue;
    ulong                       ProcNum, RpcFlags;
    uchar *                     pArg;
    void *                      pThis = NULL;
    handle_t                    Handle;
    NDR_PROC_CONTEXT            ProcContext;

    ReturnValue.Pointer = 0;

#if !defined(_WIN64)
    //
    // Get address of argument to this function following pFormat. This
    // is the address of the address of the first argument of the function
    // calling this function.
    //
    INIT_ARG( ArgList, pFormat);

    //
    // Get the address of the stack where the parameters are.
    //
    GET_FIRST_IN_ARG(ArgList);
    uchar *StartofStack = (uchar*)GET_STACK_START(ArgList);
#endif

    // StartofStack points to the virtual stack at this point.
    ProcNum = MulNdrpInitializeContextFromProc( XFER_SYNTAX_DCE, 
                                                pFormat, 
                                                &ProcContext, 
                                                StartofStack );
    //
    // Wrap everything in a try-finally pair. The finally clause does the
    // required freeing of resources (RpcBuffer and Full ptr package).
    //
    RpcTryFinally
        {
        //
        // Use a nested try-except pair to support OLE. In OLE case, test the
        // exception and map it if required, then set the return value. In
        // nonOLE case, just reraise the exception.
        //
        RpcTryExcept
            {
            // Do this for the sake of the -Os client stubs.
            StubMsg.FullPtrXlatTables = 0;
            StubMsg.pContext = &ProcContext;
            StubMsg.StackTop = ProcContext.StartofStack;

            if ( ProcContext.IsObject )
                {
                pThis = *(void **)StartofStack;

                NdrProxyInitialize( pThis,
                                    &RpcMsg,
                                    &StubMsg,
                                    pStubDescriptor,
                                    ProcNum );
                }
            else
                {
                NdrClientInitializeNew( &RpcMsg,
                                        &StubMsg,
                                        pStubDescriptor,
                                        (uint) ProcNum );

                if ( ProcContext.HandleType )
                    {
                    //
                    // We have an implicit handle.
                    //
                    Handle = ImplicitBindHandleMgr( pStubDescriptor,
                                                    ProcContext.HandleType,
                                                    &ProcContext.SavedGenericHandle);
                    }
                else
                    {
                    Handle = ExplicitBindHandleMgr( pStubDescriptor,
                                                    StartofStack,
                                                    ProcContext.pHandleFormatSave,
                                                    &ProcContext.SavedGenericHandle );
                    }
                }

            NdrpClientInit( &StubMsg, &ReturnValue );


            //
            // Skip buffer size pass if possible.
            //
            if ( ProcContext.NdrInfo.pProcDesc->Oi2Flags.ClientMustSize  )
                {
                NdrpSizing( &StubMsg, TRUE );   // IsClient
                }
                // Compiler prevents variable size non-pipe args for NT v.4.0.


            //
            // Do the GetBuffer.
            //
            if ( ProcContext.HasPipe )
                NdrGetPipeBuffer( &StubMsg,
                                  StubMsg.BufferLength,
                                  Handle );
            else
                {
                if ( ProcContext.IsObject )
                    NdrProxyGetBuffer( pThis,
                                       &StubMsg );
                else
                    {
                    if ( ProcContext.HandleType != FC_AUTO_HANDLE )
                        {
                        NdrGetBuffer( &StubMsg,
                                      StubMsg.BufferLength,
                                      Handle );
                        }
                    else
                        NdrNsGetBuffer( &StubMsg,
                                        StubMsg.BufferLength,
                                        Handle );
                    }
                }

            NdrRpcSetNDRSlot( &StubMsg );

            NDR_ASSERT( StubMsg.fBufferValid, "Invalid buffer" );

            //
            // ----------------------------------------------------------
            // Marshall Pass.
            // ----------------------------------------------------------
            //

            NdrpClientMarshal( &StubMsg, ProcContext.IsObject );


            //
            // Make the RPC call.
            //

            if ( ProcContext.HasPipe )
                NdrPipeSendReceive( & StubMsg, ProcContext.pPipeDesc );
            else
                {
                if ( ProcContext.IsObject )
                    NdrProxySendReceive( pThis, &StubMsg );
                else
                    if ( ProcContext.HandleType != FC_AUTO_HANDLE )

                        NdrSendReceive( &StubMsg, StubMsg.Buffer );
                    else
                        NdrNsSendReceive( &StubMsg,
                                          StubMsg.Buffer,
                                          (RPC_BINDING_HANDLE*) pStubDescriptor
                                            ->IMPLICIT_HANDLE_INFO.pAutoHandle );
                }


            NdrpClientUnMarshal( &StubMsg, &ReturnValue ); 

            }
        RpcExcept(  ProcContext.ExceptionFlag  )
            {          
            if ( ProcContext.IsObject ) 
                NdrpDcomClientExceptionHandling( &StubMsg, ProcNum, RpcExceptionCode(), &ReturnValue);
            else
                NdrpClientExceptionHandling( &StubMsg, ProcNum, RpcExceptionCode(), &ReturnValue );

            }
        RpcEndExcept
        }
    RpcFinally
        {       
        NdrpClientFinally( &StubMsg, pThis );
        }
    RpcEndFinally

    return ReturnValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr20\cvtf.cxx ===
/* file:  cvt_vax_f.c */

/*
**
**                         COPYRIGHT (c) 1989, 1990 BY
**           DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.
**                          ALL RIGHTS RESERVED.
**
**  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED
**  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE
**  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER
**  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
**  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY
**  TRANSFERRED.
**
**  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE
**  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT
**  CORPORATION.
**
**  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS
**  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
**
*/

/*
**++
**  Facility:
**
**      CVT Run-Time Library
**
**  Abstract:
**
**      This module contains routines to convert VAX F_Float floating
**      point data into other supported floating point formats.
**
**  Authors:
**
**      Math RTL
**
**  Creation Date:     December 5, 1989.
**
**  Modification History:
**
**      1-001   Original created.       MRTL 5-Dec-1989.
**      1-002   Add VMS and F77 bindings.  TS 26-Mar-1990.
**
**--
*/

/*
**
**  TABLE OF CONTENTS
**
**      cvt_vax_f_to_cray
**      cvt_vax_f_to_ibm_short
**      cvt_vax_f_to_ieee_single
**
*/


#include <stdio.h>
#include <sysinc.h>
#include <rpc.h>
#include "cvt.h"
#include "cvtpvt.h"


//
// Added for the MS NT environment
//

#include <stdlib.h>


/*
 * C binding
 */
void cvt_vax_f_to_ieee_single(
    CVT_VAX_F input_value,
    CVT_SIGNED_INT options,
    CVT_IEEE_SINGLE output_value
    )
{
    int i, round_bit_position;
    UNPACKED_REAL r;


    switch ( options & ~(CVT_C_BIG_ENDIAN | CVT_C_ERR_UNDERFLOW) ) {
        case 0                      : options |= CVT_C_ROUND_TO_NEAREST;
        case CVT_C_ROUND_TO_NEAREST :
        case CVT_C_TRUNCATE         :
        case CVT_C_ROUND_TO_POS     :
        case CVT_C_ROUND_TO_NEG     :
        case CVT_C_VAX_ROUNDING     : break;
        default : RAISE(cvt__invalid_option);
    }


//  ===========================================================================
//
// This file used to be included as a separate file.
//#include "unp_vaxf.c"
//
//  ===========================================================================

/* file: unpack_vax_f.c */


/*
**
**                         COPYRIGHT (c) 1989 BY
**           DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.
**                          ALL RIGHTS RESERVED.
**
**  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED
**  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE
**  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER
**  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
**  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY
**  TRANSFERRED.
**
**  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE
**  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT
**  CORPORATION.
**
**  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS
**  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
**
*/


/*
**++
**  Facility:
**
**      CVT Run-Time Library
**
**  Abstract:
**
**      This module contains code to extract information from a VAX
**      f_floating number and to initialize an UNPACKED_REAL structure
**      with those bits.
**
**              This module is meant to be used as an include file.
**
**  Author: Math RTL
**
**  Creation Date:  November 24, 1989.
**
**  Modification History:
**
**--
*/


/*
**++
**  Functional Description:
**
**  This module contains code to extract information from a VAX
**  f_floating number and to initialize an UNPACKED_REAL structure
**  with those bits.
**
**  See the header files for a description of the UNPACKED_REAL
**  structure.
**
**  A VAX f_floating number in (16 bit words) looks like:
**
**      [0]: Sign bit, 8 exp bits (bias 128), 7 fraction bits
**      [1]: 16 more fraction bits
**
**      0.5 <= fraction < 1.0, MSB implicit
**
**
**  Implicit parameters:
**
**      input_value: a pointer to the input parameter.
**
**      r: an UNPACKED_REAL structure
**
**--
*/



        RpcpMemoryCopy(&r[1], input_value, 4);

        /* Initialize FLAGS and perhaps set NEGATIVE bit */

        r[U_R_FLAGS] = (r[1] >> 15) & U_R_NEGATIVE;

        /* Extract VAX biased exponent */

        r[U_R_EXP] = (r[1] >> 7) & 0x000000FFL;

        if (r[U_R_EXP] == 0) {

                if (r[U_R_FLAGS])
                        r[U_R_FLAGS] |= U_R_INVALID;
                else
                        r[U_R_FLAGS] = U_R_ZERO;

        } else {

                /* Adjust for VAX 16 bit floating format */

                r[1] = ((r[1] << 16) | (r[1] >> 16));

                /* Add unpacked real bias and subtract VAX bias */

                r[U_R_EXP] += (U_R_BIAS - 128);

                /* Set hidden bit */

                r[1] |= 0x00800000L;

                /* Left justify fraction bits */

                r[1] <<= 8;

                /* Clear uninitialized parts for unpacked real */

                r[2] = 0;
                r[3] = 0;
                r[4] = 0;

        }

// end of file: unpack_vax_f.c
//
//  ===========================================================================
//
// This file used to be included as a separate file.
//#include "pack_ies.c"
//
//  ===========================================================================

/* file: pack_ieee_s.c */


/*
**
**                         COPYRIGHT (c) 1989 BY
**           DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.
**                          ALL RIGHTS RESERVED.
**
**  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED
**  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE
**  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER
**  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
**  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY
**  TRANSFERRED.
**
**  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE
**  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT
**  CORPORATION.
**
**  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS
**  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
**
*/


/*
**++
**  Facility:
**
**      CVT Run-Time Library
**
**  Abstract:
**
**      This module contains code to extract information from an
**      UNPACKED_REAL structure and to create an IEEE single floating number
**      with those bits.
**
**              This module is meant to be used as an include file.
**
**  Author: Math RTL
**
**  Creation Date:  November 24, 1989.
**
**  Modification History:
**
**--
*/


/*
**++
**  Functional Description:
**
**  This module contains code to extract information from an
**  UNPACKED_REAL structure and to create an IEEE single number
**  with those bits.
**
**  See the header files for a description of the UNPACKED_REAL
**  structure.
**
**  A normalized IEEE single precision floating number looks like:
**
**      Sign bit, 8 exp bits (bias 127), 23 fraction bits
**
**      1.0 <= fraction < 2.0, MSB implicit
**
**  For more details see "Mips R2000 Risc Architecture"
**  by Gerry Kane, page 6-8 or ANSI/IEEE Std 754-1985.
**
**
**  Implicit parameters:
**
**      options: a word of flags, see include files.
**
**      output_value: a pointer to the input parameter.
**
**      r: an UNPACKED_REAL structure.
**
**--
*/


    if (r[U_R_FLAGS] & U_R_UNUSUAL) {

        if (r[U_R_FLAGS] & U_R_ZERO)

                if (r[U_R_FLAGS] & U_R_NEGATIVE)
                        RpcpMemoryCopy(output_value, IEEE_S_NEG_ZERO, 4);
                else
                        RpcpMemoryCopy(output_value, IEEE_S_POS_ZERO, 4);

        else if (r[U_R_FLAGS] & U_R_INFINITY) {

                if (r[U_R_FLAGS] & U_R_NEGATIVE)
                        RpcpMemoryCopy(output_value, IEEE_S_NEG_INFINITY, 4);
                else
                        RpcpMemoryCopy(output_value, IEEE_S_POS_INFINITY, 4);

        } else if (r[U_R_FLAGS] & U_R_INVALID) {

                RpcpMemoryCopy(output_value, IEEE_S_INVALID, 4);
                RAISE(cvt__invalid_value);

        }

    } else {

        /* Precision varies if value will be a denorm */
        /* So, figure out where to round (0 <= i <= 24). */

        round_bit_position = r[U_R_EXP] - ((U_R_BIAS - 126) - 23);
        if (round_bit_position < 0)
                round_bit_position = 0;
        else if (round_bit_position > 24)
                round_bit_position = 24;

#include "round.cxx"

        if (r[U_R_EXP] < (U_R_BIAS - 125)) {

                /* Denorm or underflow */

                if (r[U_R_EXP] < ((U_R_BIAS - 125) - 23)) {

                        /* Value is too small for a denorm, so underflow */

                        if (r[U_R_FLAGS] & U_R_NEGATIVE)
                              RpcpMemoryCopy(output_value, IEEE_S_NEG_ZERO, 4);
                        else
                              RpcpMemoryCopy(output_value, IEEE_S_POS_ZERO, 4);
                        if (options & CVT_C_ERR_UNDERFLOW) {
                                RAISE(cvt__underflow);
                        }

                } else {

                        /* Figure leading zeros for denorm and right-justify fraction */

                        i = 32 - (r[U_R_EXP] - ((U_R_BIAS - 126) - 23));
                        r[1] >>= i;

                        /* Set sign bit */

                        r[1] |= (r[U_R_FLAGS] << 31);

                        if (options & CVT_C_BIG_ENDIAN) {

                                r[0]  = ((r[1] << 24) | (r[1] >> 24));
                                r[0] |= ((r[1] << 8) & 0x00FF0000L);
                                r[0] |= ((r[1] >> 8) & 0x0000FF00L);
                                RpcpMemoryCopy(output_value, r, 4);

                        } else {

                                RpcpMemoryCopy(output_value, &r[1], 4);

                        }
                }

        } else if (r[U_R_EXP] > (U_R_BIAS + 128)) {

                /* Overflow */

                if (options & CVT_C_TRUNCATE) {

                        if (r[U_R_FLAGS] & U_R_NEGATIVE)
                               RpcpMemoryCopy(output_value, IEEE_S_NEG_HUGE, 4);
                        else
                               RpcpMemoryCopy(output_value, IEEE_S_POS_HUGE, 4);

                } else if ((options & CVT_C_ROUND_TO_POS)
                                        && (r[U_R_FLAGS] & U_R_NEGATIVE)) {

                              RpcpMemoryCopy(output_value, IEEE_S_NEG_HUGE, 4);

                } else if ((options & CVT_C_ROUND_TO_NEG)
                                        && !(r[U_R_FLAGS] & U_R_NEGATIVE)) {

                              RpcpMemoryCopy(output_value, IEEE_S_POS_HUGE, 4);

                } else {

                        if (r[U_R_FLAGS] & U_R_NEGATIVE)
                              RpcpMemoryCopy(output_value, IEEE_S_NEG_INFINITY, 4);
                        else
                              RpcpMemoryCopy(output_value, IEEE_S_POS_INFINITY, 4);

                }

                RAISE(cvt__overflow);

        } else {

                /* Adjust bias of exponent */

                r[U_R_EXP] -= (U_R_BIAS - 126);

                /* Make room for exponent and sign bit */

                r[1] >>= 8;

                /* Clear implicit bit */

                r[1] &= 0x007FFFFFL;

                /* OR in exponent and sign bit */

                r[1] |= (r[U_R_EXP] << 23);
                r[1] |= (r[U_R_FLAGS] << 31);

                if (options & CVT_C_BIG_ENDIAN) {

                        r[0]  = ((r[1] << 24) | (r[1] >> 24));
                        r[0] |= ((r[1] << 8) & 0x00FF0000L);
                        r[0] |= ((r[1] >> 8) & 0x0000FF00L);
                        RpcpMemoryCopy(output_value, r, 4);

                } else {

                        RpcpMemoryCopy(output_value, &r[1], 4);

                }
        }

    }

// end of file: pack_ies.c

}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr20\cvtpvt.h ===
/* file: cvt__private.h */

/*
**
**                         COPYRIGHT (c) 1989, 1990 BY
**           DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.
**                          ALL RIGHTS RESERVED.
**
**  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED
**  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE
**  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER
**  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
**  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY
**  TRANSFERRED.
**
**  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE
**  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT
**  CORPORATION.
**
**  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS
**  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
**
*/

/*
**++
**  Facility:
**
**      CVT Run-Time Library
**
**  Abstract:
**
**      This module contains the private include file for the cvt_* routines.
**
**  Authors:
**
**      Math RTL
**
**  Creation Date:     December 5, 1989.
**
**  Modification History:
**
**      1-001   Original created.       MRTL 5-Dec-1989.
**      1-002   Add GEM FORTRAN stuff.  TS 27-Mar-1990.
**
**--
*/


#ifndef CVT__PRIVATE
#define CVT__PRIVATE

#define F77_BINDING

#ifndef VMS
#define VMS_BINDING
#endif

#include "descrip.h"

#define C_TAB           '\t'
#define C_BLANK         ' '
#define C_PLUS          '+'
#define C_MINUS         '-'
#define C_ASTERISK      '*'
#define C_UNDERSCORE    '_'
#define C_DECIMAL_POINT '.'
#define C_DOT           '.'
#define C_ZERO          '0'
#define C_ONE           '1'
#define C_TWO           '2'
#define C_THREE         '3'
#define C_FOUR          '4'
#define C_FIVE          '5'
#define C_SIX           '6'
#define C_SEVEN         '7'
#define C_EIGHT         '8'
#define C_NINE          '9'
#define C_A             'A'
#define C_B             'B'
#define C_C             'C'
#define C_D             'D'
#define C_E             'E'
#define C_F             'F'
#define C_L             'L'
#define C_R             'R'
#define C_S             'S'
#define C_T             'T'
#define C_U             'U'
#define C_W             'W'
#define C_a             'a'
#define C_b             'b'
#define C_c             'c'
#define C_d             'd'
#define C_e             'e'
#define C_f             'f'
#define C_t             't'


#define RAISE(i) \
        { \
           RpcRaiseException(i); \
        }



/*
UNPACKED REAL:

[0]: excess 2147483648 (2 ^ 31) binary exponent
[1]: mantissa: msb ------>
[2]: -------------------->
[3]: -------------------->
[4]: ----------------> lsb
[5]: 28 unused bits, invalid bit, infinity bit, zero bit, negative bit

All fraction bits are explicit and are normalized s.t. 0.5 <= fraction < 1.0

*/

typedef struct dsc_descriptor_s DESC_S;
typedef unsigned long  UNPACKED_REAL[6];
typedef UNPACKED_REAL *UNPACKED_REAL_PTR;

#define U_R_EXP 0
#define U_R_FLAGS 5

#define U_R_NEGATIVE 1
#define U_R_ZERO 2
#define U_R_INFINITY 4
#define U_R_INVALID  8
#define U_R_UNUSUAL (U_R_ZERO | U_R_INFINITY | U_R_INVALID)

#define U_R_BIAS 2147483648L




extern const unsigned long vax_c[];

#define VAX_F_INVALID &vax_c[0]
#define VAX_D_INVALID &vax_c[0]
#define VAX_G_INVALID &vax_c[0]
#define VAX_H_INVALID &vax_c[0]

#define VAX_F_ZERO &vax_c[4]
#define VAX_D_ZERO &vax_c[4]
#define VAX_G_ZERO &vax_c[4]
#define VAX_H_ZERO &vax_c[4]

#define VAX_F_POS_HUGE &vax_c[8]
#define VAX_D_POS_HUGE &vax_c[8]
#define VAX_G_POS_HUGE &vax_c[8]
#define VAX_H_POS_HUGE &vax_c[8]

#define VAX_F_NEG_HUGE &vax_c[12]
#define VAX_D_NEG_HUGE &vax_c[12]
#define VAX_G_NEG_HUGE &vax_c[12]
#define VAX_H_NEG_HUGE &vax_c[12]


extern const unsigned long ieee_s[];

#define IEEE_S_INVALID ((options & CVT_C_BIG_ENDIAN) ? \
        &ieee_s[1] : &ieee_s[0])
#define IEEE_S_POS_ZERO ((options & CVT_C_BIG_ENDIAN) ? \
        &ieee_s[3] : &ieee_s[2])
#define IEEE_S_NEG_ZERO ((options & CVT_C_BIG_ENDIAN) ? \
        &ieee_s[5] : &ieee_s[4])
#define IEEE_S_POS_HUGE ((options & CVT_C_BIG_ENDIAN) ? \
        &ieee_s[7] : &ieee_s[6])
#define IEEE_S_NEG_HUGE ((options & CVT_C_BIG_ENDIAN) ? \
        &ieee_s[9] : &ieee_s[8])
#define IEEE_S_POS_INFINITY ((options & CVT_C_BIG_ENDIAN) ? \
        &ieee_s[11] : &ieee_s[10])
#define IEEE_S_NEG_INFINITY ((options & CVT_C_BIG_ENDIAN) ? \
        &ieee_s[13] : &ieee_s[12])


extern const unsigned long ieee_t[];

#define IEEE_T_INVALID ((options & CVT_C_BIG_ENDIAN) ? \
        &ieee_t[2] : &ieee_t[0])
#define IEEE_T_POS_ZERO ((options & CVT_C_BIG_ENDIAN) ? \
        &ieee_t[6] : &ieee_t[4])
#define IEEE_T_NEG_ZERO ((options & CVT_C_BIG_ENDIAN) ? \
        &ieee_t[10] : &ieee_t[8])
#define IEEE_T_POS_HUGE ((options & CVT_C_BIG_ENDIAN) ? \
        &ieee_t[14] : &ieee_t[12])
#define IEEE_T_NEG_HUGE ((options & CVT_C_BIG_ENDIAN) ? \
        &ieee_t[18] : &ieee_t[16])
#define IEEE_T_POS_INFINITY ((options & CVT_C_BIG_ENDIAN) ? \
        &ieee_t[22] : &ieee_t[20])
#define IEEE_T_NEG_INFINITY ((options & CVT_C_BIG_ENDIAN) ? \
        &ieee_t[26] : &ieee_t[24])


extern const unsigned long ibm_s[];

#define IBM_S_INVALID   &ibm_s[0]
#define IBM_S_POS_ZERO  &ibm_s[1]
#define IBM_S_NEG_ZERO  &ibm_s[2]
#define IBM_S_POS_HUGE  &ibm_s[3]
#define IBM_S_NEG_HUGE  &ibm_s[4]
#define IBM_S_POS_INFINITY  &ibm_s[5]
#define IBM_S_NEG_INFINITY  &ibm_s[6]


extern const unsigned long ibm_l[];

#define IBM_L_INVALID   &ibm_l[0]
#define IBM_L_POS_ZERO  &ibm_l[2]
#define IBM_L_NEG_ZERO  &ibm_l[4]
#define IBM_L_POS_HUGE  &ibm_l[6]
#define IBM_L_NEG_HUGE  &ibm_l[8]
#define IBM_L_POS_INFINITY  &ibm_l[10]
#define IBM_L_NEG_INFINITY  &ibm_l[12]


extern const unsigned long cray[];

#define CRAY_INVALID    &cray[0]
#define CRAY_POS_ZERO   &cray[2]
#define CRAY_NEG_ZERO   &cray[4]
#define CRAY_POS_HUGE   &cray[6]
#define CRAY_NEG_HUGE   &cray[8]
#define CRAY_POS_INFINITY  &cray[10]
#define CRAY_NEG_INFINITY  &cray[12]


extern const unsigned long int_c[];

#define INT_INVALID ((options & CVT_C_BIG_ENDIAN) ? \
        &int_c[1] : &int_c[0])
#define INT_ZERO ((options & CVT_C_BIG_ENDIAN) ? \
        &int_c[3] : &int_c[2])
#define INT_POS_HUGE ((options & CVT_C_BIG_ENDIAN) ? \
        &int_c[5] : &int_c[4])
#define INT_NEG_HUGE ((options & CVT_C_BIG_ENDIAN) ? \
        &int_c[7] : &int_c[6])
#define INT_POS_INFINITY ((options & CVT_C_BIG_ENDIAN) ? \
        &int_c[9] : &int_c[8])
#define INT_NEG_INFINITY ((options & CVT_C_BIG_ENDIAN) ? \
        &int_c[11] : &int_c[10])


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr20\cvtibm.cxx ===
/*-----------------------------------------------------------------------------
 *
 * cvtibmf.c : IBM float/double <-> IEEE float/double conversion
 *
 *+++
 *
 * Copyright (c) Software AG 1996,1998. All rights reserved.
 *
 *---
 *
 * License:
 *
 * "According to the DCOM Porting Agreement Software AG grants to Microsoft
 *  an irrevocable, unlimited, royalty free license to use and market the
 *  enclosed piece of software code in source and object format for
 *  the purposes of Microsoft. 17-April-1998."
 *
 *----------------------------------------------------------------------------*/

#include <float.h>

#include <rpc.h>
#include <rpcndr.h>
#include "winerror.h"

/*
 * Convert floating point numbers from IBM/370 to IEEE representation or vice versa.
 *
 * Synopsis:
 *
 * void cvt_ibm_f_to_ieee_single(ULONG *ulFP);
 * void cvt_ibm_d_to_ieee_double(ULONG *ulFP);
 * void cvt_ieee_single_to_ibm_f(ULONG *ulFP);
 * void cvt_ieee_double_to_ibm_d(ULONG *ulFP);
 *
 * Note:
 *
 *  Overflow/Underflow during conversion results in RpcRaiseException(RPC_S_FP_OVERFLOW/
 *  RPC_S_FP_UNDERFLOW).
 *
 */

/* *******************************************************************************
 *
 * Floating point representations:
 *
 * ------------------------
 * IBM/370 single precision
 * ------------------------
 *
 * xxxx.xxxx xxxx.xxxx xxxx.xxxx xxxx.xxxx
 * s|-exp--| |--------fraction-----------|
 *    (7)               (24)
 *
 * value = (-1)**s * 16**(e - 64) * .f     range = 5.4E-79 ... 7.2E+75
 *
 * *******************************************************************************
 *
 * ---------------------
 * IEEE single precision
 * ---------------------
 *
 * xxxx.xxxx xxxx.xxxx xxxx.xxxx xxxx.xxxx
 * s|--exp---||-------fraction-----------|
 *     (8)              (23)
 *
 * value = (-1)**s * 2**(e - 127) * 1.f    range = 1.2E-38 ... 3.4E+38
 *
 * *******************************************************************************
 *
 * ------------------------
 * IBM/370 double precision
 * ------------------------
 *
 * xxxx.xxxx xxxx.xxxx xxxx.xxxx xxxx.xxxx yyyy.yyyy yyyy.yyyy yyyy.yyyy yyyy.yyyy
 * s|-exp--| |-------------------------------fraction----------------------------|
 *    (7)                                      (56)
 *
 * value = (-1)**s * 16**(e - 64) * .f     range = 5.4E-79 ... 7.2E+75
 *
 * *******************************************************************************
 *
 * ---------------------
 * IEEE double precision
 * ---------------------
 *
 * xxxx.xxxx xxxx.xxxx xxxx.xxxx xxxx.xxxx yyyy.yyyy yyyy.yyyy yyyy.yyyy yyyy.yyyy
 * s|--exponent-| |-------------------------fraction-----------------------------|
 *       (11)                                 (52)
 *
 *   value = (-1)**s * 2**(e - 1023) * 1.f   range = 2.2E-308 ... 1.8+308
 *
 * *******************************************************************************/

#if 1 /* We assume little endian for NT, this does not work: NDR_LOCAL_ENDIAN == NDR_LITTLE_ENDIAN */
#  define HI 1 /* index of high order LONG */
#  define LO 0 /* index of low order LONG */
#else
#  define HI 0 /* index of high order LONG */
#  define LO 1 /* index of low order LONG */
#endif

static float floatMin = FLT_MIN;
static float floatMax = FLT_MAX;

#define SIGN(src) 	(src[HI] & 0x80000000)

/* Convert IBM/370 "float" to IEEE "single" */
void cvt_ibm_f_to_ieee_single ( ULONG *ulFP )
{
   ULONG ulFraction ;
   LONG lExponent ;

   /* in this special case we just keep the sign */
   if ( ( *ulFP & 0x7fffffff ) == 0 )
   {
      return ;
   }

   /* fetch the exponent (excess-64 notation) and fraction */
   lExponent = ( (*ulFP & 0x7f000000) >> 24) - 64 ;
   ulFraction = *ulFP & 0x00ffffff ;

   /* convert from "16**exponent" to "2**exponent" */
   if ( lExponent >= 0 ) lExponent <<= 2 ;
   else                  lExponent = -((-lExponent) << 2) ;

   /* convert exponent for 24 bit fraction to 23 bit fraction */
   lExponent -= 1;

   /* normalize fraction */
   if ( ulFraction )
   {
	while ( (ulFraction & 0x00800000) == 0 )
        {
            ulFraction <<= 1 ;
            lExponent -= 1 ;
        }
   }

   /* remove the implied '1' preceeding the binary point */
   ulFraction &= 0x007fffff ;

   /* convert exponent to excess-127 notation and store the number if the exponent is not out of range */
   if ( (lExponent += 127) >= 255 )
     *ulFP = SIGN(ulFP) | *((ULONG *)&floatMax) ; /* floating overflow */
   else if ( lExponent <= 0 )
    *ulFP = SIGN(ulFP) | *((ULONG *)&floatMin) ;	 /* floating underflow */
   else
     *ulFP = SIGN(ulFP) | (lExponent << 23) | ulFraction ;
}

/* Convert IBM/370 "double" to IEEE "double" */
void cvt_ibm_d_to_ieee_double ( ULONG* ulFP )
{
   ULONG ulFraction[2] ;
   LONG  lExponent ;

   /* in this special case we just keep the sign */
   if ( (ulFP[HI] & 0x7fffffff) == 0 )
   {
      return ;
   }

   /* fetch the exponent (removing excess 64) and fraction */
   lExponent = ( (ulFP[HI] & 0x7f000000) >> 24 ) - 64 ;
   ulFraction[HI] = ulFP[HI] & 0x00ffffff ;
   ulFraction[LO] = ulFP[LO] ;

   /* convert from "16**exponent" to "2**exponent" */
   if ( lExponent >= 0 ) lExponent <<= 2 ;
   else                  lExponent = -((-lExponent) << 2);

   /* normalize the fraction (to 57 bits) */
   if ( ulFraction[HI] )
   {
       while ((ulFraction[HI] & 0x01000000) == 0)
       {
             ulFraction[HI] = ( ulFraction[HI] << 1 ) | ( ulFraction[LO] >> 31 ) ;
             ulFraction[LO] = ulFraction[LO] << 1 ;
             lExponent -= 1 ;
       }
   }

   /* convert 57 bit fraction to 53 bit fraction and remove the implied '1' preceeding the binary point */
   ulFraction[LO] = ( ulFraction[LO] >> 4 ) | ( ulFraction[HI] << 28 ) ;
   ulFraction[HI] = ( ulFraction[HI] >> 4 ) & 0x000fffff ;

   /* convert exponent to excess-1023 notation and store the number if the exponent is not out of range */
   if ( (lExponent += 1023) >= 2047 )
     RpcRaiseException ( RPC_S_FP_OVERFLOW ) ; /* should never happen */
   else if ( lExponent <= 0 )
     RpcRaiseException ( RPC_S_FP_UNDERFLOW ) ; /* should never happen */
   else
   {
      ulFP[HI] = SIGN(ulFP) | (lExponent << 20) | ulFraction[HI] ;
      ulFP[LO] = ulFraction[LO] ;
   }
}

/* The following is not used in Windows NT */

#if 0

/* Convert IEEE "single" to IBM/370 "float" */
void cvt_ieee_single_to_ibm_f ( ULONG* ulFP )
{
   ULONG ulFraction ;
   LONG	 lExponent ;

   /* in this special case we just keep the sign */
   if ( (*ulFP & 0x7fffffff) == 0 )
   {
      return ;
   }

   lExponent = ((*ulFP & 0x7f800000) >> 23) - 127 ;
   ulFraction = *ulFP & 0x007fffff ;

   /* convert 23 bit fraction to 24 bit fraction */
   ulFraction <<= 1 ;

   /* restore the implied '1' which preceeded the IEEE binary point */
   ulFraction |= 0x01000000 ; 

   /* convert from "2**exponent" to "16**exponent" (fraction is not normalized) */
   if ( lExponent >= 0 )
   {
      ulFraction <<= (lExponent & 3) ;
      lExponent >>= 2 ;
   }
   else
   {
      ulFraction >>= ((-lExponent) & 3) ; 
      lExponent = -((-lExponent) >> 2) ;
   }

   /* reduce fraction to 24 bits or less */
   if ( ulFraction & 0x0f000000 )
   {
      ulFraction >>= 4 ;
      lExponent += 1 ;
   }

   /* convert exponent to excess-64 notation and store the number if the exponent is not out of range */
   if ( (lExponent += 64) > 127 )
     RpcRaiseException ( RPC_S_FP_OVERFLOW ) ; /* should never happen */
   else if ( lExponent < 0 )
     RpcRaiseException ( RPC_S_FP_UNDERFLOW ) ; /* should never happen */
   else
     *ulFP = SIGN(ulFP) | (lExponent << 24) | ulFraction ;
}

/* Convert IEEE "double" to IBM/370 "double" */
void cvt_ieee_double_to_ibm_d ( ULONG* ulFP )
{
   ULONG 	ulFraction[2] ;
   LONG 	lExponent ;
   LONG		shift ;

   /* in this special case we just keep the sign and the low word */
   if ( (ulFP[HI] & 0x7fffffff) == 0 )
   {
      return ;
   }

   /* fetch the exponent (excess-1023 notation) and fraction */
   lExponent =  ((ulFP[HI] & 0x7ff00000) >> 20) - 1023 ;
   ulFraction[HI] = ulFP[HI] & 0x000fffff ;
   ulFraction[LO] = ulFP[LO] ;

   /* convert 52 bit fraction to 56 bit fraction and restore the '1' which preceeds the IEEE binary point*/
   ulFraction[HI] = ( ulFraction[HI] << 4 ) | ( ulFraction[LO] >> 28 ) | 0x01000000 ;
   ulFraction[LO] = ulFraction[LO] << 4 ;

   /* convert from "2**exponent" to "16**exponent" (fraction is not normalized) */
   if ( lExponent >= 0 )
   {
      shift = lExponent & 3 ;
      ulFraction[HI] = ( ulFraction[HI] << shift ) | ( ulFraction[LO] >> (32 - shift) ) ;
      ulFraction[LO] = ulFraction[LO] << shift ;
      lExponent >>= 2 ;
   }
   else
   {
      shift = (-lExponent) & 3 ;
      ulFraction[LO] = ( ulFraction[LO] >> shift ) | ( ulFraction[HI] << (32 - shift) ) ;
      ulFraction[HI] = ( ulFraction[HI] >> shift ) ;
      lExponent = -((-lExponent) >> 2) ;
   }

   /* reduce fraction to 56 bits or less */
   if ( ulFraction[HI] & 0x0f000000 )
   {
      ulFraction[LO] = ( ulFraction[LO] >> 4 ) | ( ulFraction[HI] << 28 ) ;
      ulFraction[HI] = ( ulFraction[HI] >> 4 ) ;
      lExponent += 1 ;
   }

   /* convert exponent to excess-64 notation and store the number */
   if ( (lExponent += 64) > 127 ) 
   {  /* we store the highest IBM float but we keep the sign ! */ 
      ulFP[HI] = SIGN(ulFP) | 0x7FFFFFFF ;
      ulFP[LO] = 0xFFFFFFFF ;
   }
   else if ( lExponent < 0 )      
   {  /* we store 0 but we keep the sign ! */
      ulFP[HI] = SIGN(ulFP) ;
      ulFP[LO] = 0 ;
   }
   else
   {
      ulFP[HI] = SIGN(ulFP) | (lExponent << 24) | ulFraction[HI] ;
      ulFP[LO] = ulFraction[LO] ;
   }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr20\descrip.h ===
#ifndef DESCRIP_H_DEFINED
/*
 *      DESCRIP.H - V3.0-003 - Argument Descriptor Formats
 *      Copyright (c) 1993-1999 Microsoft Corporation
 *      (Based on the VAX Procedure Calling and Condition Handling Standard, Revision 9.4 [13 March 1984];
 *       see the "Introduction to VMS System Routines" manual for further information.)
 */


/*
 *      Descriptor Prototype - each class of descriptor consists of at least the following fields:
 */
struct  dsc_descriptor
{
        unsigned short  dsc_w_length;   /* specific to descriptor class;  typically a 16-bit (unsigned) length */
        unsigned char   dsc_b_dtype;    /* data type code */
        unsigned char   dsc_b_class;    /* descriptor class code */
        char            *dsc_a_pointer; /* address of first byte of data element */
};


/*
 *      Fixed-Length Descriptor:
 */
struct  dsc_descriptor_s
{
        unsigned short  dsc_w_length;   /* length of data item in bytes,
                                             or if dsc_b_dtype is DSC_K_DTYPE_V, bits,
                                             or if dsc_b_dtype is DSC_K_DTYPE_P, digits (4 bits each) */
        unsigned char   dsc_b_dtype;    /* data type code */
        unsigned char   dsc_b_class;    /* descriptor class code = DSC_K_CLASS_S */
        char            *dsc_a_pointer; /* address of first byte of data storage */
};


/*
 *      Dynamic String Descriptor:
 */
struct  dsc_descriptor_d
{
        unsigned short  dsc_w_length;   /* length of data item in bytes,
                                             or if dsc_b_dtype is DSC_K_DTYPE_V, bits,
                                             or if dsc_b_dtype is DSC_K_DTYPE_P, digits (4 bits each) */
        unsigned char   dsc_b_dtype;    /* data type code */
        unsigned char   dsc_b_class;    /* descriptor class code = DSC_K_CLASS_D */
        char            *dsc_a_pointer; /* address of first byte of data storage */
};


/*
 *      Array Descriptor:
 */
struct  dsc_descriptor_a
{
        unsigned short  dsc_w_length;   /* length of an array element in bytes,
                                             or if dsc_b_dtype is DSC_K_DTYPE_V, bits,
                                             or if dsc_b_dtype is DSC_K_DTYPE_P, digits (4 bits each) */
        unsigned char   dsc_b_dtype;    /* data type code */
        unsigned char   dsc_b_class;    /* descriptor class code = DSC_K_CLASS_A */
        char            *dsc_a_pointer; /* address of first actual byte of data storage */
        char            dsc_b_scale;    /* signed power-of-two or -ten multiplier, as specified by
                                             dsc_v_fl_binscale, to convert from internal to external form */
        unsigned char   dsc_b_digits;   /* if nonzero, number of decimal digits in internal representation */
#ifdef vms
        struct
        {
                unsigned                 : 3;   /* reserved;  must be zero */
                unsigned dsc_v_fl_binscale : 1; /* if set, dsc_b_scale is a power-of-two, otherwise, -ten */
                unsigned dsc_v_fl_redim  : 1;   /* if set, indicates the array can be redimensioned */
                unsigned dsc_v_fl_column : 1;   /* if set, indicates column-major order (FORTRAN) */
                unsigned dsc_v_fl_coeff  : 1;   /* if set, indicates the multipliers block is present */
                unsigned dsc_v_fl_bounds : 1;   /* if set, indicates the bounds block is present */
        }               dsc_b_aflags;   /* array flag bits */
#else
        unsigned char dsc_b_aflags;
#endif
        unsigned char   dsc_b_dimct;    /* number of dimensions */
        unsigned long   dsc_l_arsize;   /* total size of array in bytes,
                                             or if dsc_b_dtype is DSC_K_DTYPE_P, digits (4 bits each) */
        /*
         * One or two optional blocks of information may follow contiguously at this point;
         * the first block contains information about the dimension multipliers (if present,
         * dsc_b_aflags.dsc_v_fl_coeff is set), the second block contains information about
         * the dimension bounds (if present, dsc_b_aflags.dsc_v_fl_bounds is set).  If the
         * bounds information is present, the multipliers information must also be present.
         *
         * The multipliers block has the following format:
         *      char    *dsc_a_a0;              Address of the element whose subscripts are all zero
         *      long    dsc_l_m [DIMCT];        Addressing coefficients (multipliers)
         *
         * The bounds block has the following format:
         *      struct
         *      {
         *              long    dsc_l_l;        Lower bound
         *              long    dsc_l_u;        Upper bound
         *      } dsc_bounds [DIMCT];
         *
         * (DIMCT represents the value contained in dsc_b_dimct.)
         */
};


/*
 *      Procedure Descriptor:
 */
struct  dsc_descriptor_p
{
        unsigned short  dsc_w_length;   /* length associated with the function value */
        unsigned char   dsc_b_dtype;    /* function value data type code */
        unsigned char   dsc_b_class;    /* descriptor class code = DSC_K_CLASS_P */
        int             (*dsc_a_pointer)();     /* address of function entry mask */
};


/*
 *      Decimal String Descriptor:
 */
struct  dsc_descriptor_sd
{
        unsigned short  dsc_w_length;   /* length of data item in bytes,
                                             or if dsc_b_dtype is DSC_K_DTYPE_V, bits,
                                             or if dsc_b_dtype is DSC_K_DTYPE_P, digits (4 bits each) */
        unsigned char   dsc_b_dtype;    /* data type code */
        unsigned char   dsc_b_class;    /* descriptor class code = DSC_K_CLASS_SD */
        char            *dsc_a_pointer; /* address of first byte of data storage */
        char            dsc_b_scale;    /* signed power-of-two or -ten multiplier, as specified by
                                             dsc_v_fl_binscale, to convert from internal to external form */
        unsigned char   dsc_b_digits;   /* if nonzero, number of decimal digits in internal representation */
        struct
        {
                unsigned                : 3;    /* reserved;  must be zero */
                unsigned dsc_v_fl_binscale : 1; /* if set, dsc_b_scale is a power-of-two, otherwise, -ten */
                unsigned                : 4;    /* reserved;  must be zero */
        }               dsc_b_sflags;   /* scalar flag bits */
        unsigned        : 8;            /* reserved;  must be zero */
};


/*
 *      Noncontiguous Array Descriptor:
 */
struct  dsc_descriptor_nca
{
        unsigned short  dsc_w_length;   /* length of an array element in bytes,
                                             or if dsc_b_dtype is DSC_K_DTYPE_V, bits,
                                             or if dsc_b_dtype is DSC_K_DTYPE_P, digits (4 bits each) */
        unsigned char   dsc_b_dtype;    /* data type code */
        unsigned char   dsc_b_class;    /* descriptor class code = DSC_K_CLASS_NCA */
        char            *dsc_a_pointer; /* address of first actual byte of data storage */
        char            dsc_b_scale;    /* signed power-of-two or -ten multiplier, as specified by
                                             dsc_v_fl_binscale, to convert from internal to external form */
        unsigned char   dsc_b_digits;   /* if nonzero, number of decimal digits in internal representation */
        struct
        {
                unsigned                 : 3;   /* reserved;  must be zero */
                unsigned dsc_v_fl_binscale : 1; /* if set, dsc_b_scale is a power-of-two, otherwise, -ten */
                unsigned dsc_v_fl_redim  : 1;   /* must be zero */
                unsigned                 : 3;   /* reserved;  must be zero */
        }               dsc_b_aflags;   /* array flag bits */
        unsigned char   dsc_b_dimct;    /* number of dimensions */
        unsigned long   dsc_l_arsize;   /* if elements are actually contiguous, total size of array in bytes,
                                             or if dsc_b_dtype is DSC_K_DTYPE_P, digits (4 bits each) */
        /*
         * Two blocks of information must follow contiguously at this point;  the first block
         * contains information about the difference between the addresses of two adjacent
         * elements in each dimension (the stride).  The second block contains information
         * about the dimension bounds.
         *
         * The strides block has the following format:
         *      char            *dsc_a_a0;              Address of the element whose subscripts are all zero
         *      unsigned long   dsc_l_s [DIMCT];        Strides
         *
         * The bounds block has the following format:
         *      struct
         *      {
         *              long    dsc_l_l;                Lower bound
         *              long    dsc_l_u;                Upper bound
         *      } dsc_bounds [DIMCT];
         *
         * (DIMCT represents the value contained in dsc_b_dimct.)
         */
};


/*
 *      The Varying String Descriptor and Varying String Array Descriptor are used with strings
 *      of the following form:
 *
 *              struct
 *              {
 *                      unsigned short  CURLEN;         The current length of BODY in bytes
 *                      char    BODY [MAXSTRLEN];       A fixed-length area containing the string
 *              };
 *
 *      where MAXSTRLEN is the value contained in the dsc_w_maxstrlen field in the descriptor.
 */


/*
 *      Varying String Descriptor:
 */
struct  dsc_descriptor_vs
{
        unsigned short  dsc_w_maxstrlen; /* maximum length of the BODY field of the varying string in bytes */
        unsigned char   dsc_b_dtype;    /* data type code = DSC_K_DTYPE_VT */
        unsigned char   dsc_b_class;    /* descriptor class code = DSC_K_CLASS_VS */
        char            *dsc_a_pointer; /* address of the CURLEN field of the varying string */
};


/*
 *      Varying String Array Descriptor:
 */
struct  dsc_descriptor_vsa
{
        unsigned short  dsc_w_maxstrlen; /* maximum length of the BODY field of an array element in bytes */
        unsigned char   dsc_b_dtype;    /* data type code = DSC_K_DTYPE_VT */
        unsigned char   dsc_b_class;    /* descriptor class code = DSC_K_CLASS_VSA */
        char            *dsc_a_pointer; /* address of first actual byte of data storage */
        char            dsc_b_scale;    /* signed power-of-two or -ten multiplier, as specified by
                                             dsc_v_fl_binscale, to convert from internal to external form */
        unsigned char   dsc_b_digits;   /* if nonzero, number of decimal digits in internal representation */
        struct
        {
                unsigned                 : 3;   /* reserved;  must be zero */
                unsigned dsc_v_fl_binscale : 1; /* if set, dsc_b_scale is a power-of-two, otherwise, -ten */
                unsigned dsc_v_fl_redim  : 1;   /* must be zero */
                unsigned                 : 3;   /* reserved;  must be zero */
        }               dsc_b_aflags;   /* array flag bits */
        unsigned char   dsc_b_dimct;    /* number of dimensions */
        unsigned long   dsc_l_arsize;   /* if elements are actually contiguous, total size of array in bytes */
        /*
         * Two blocks of information must follow contiguously at this point;  the first block
         * contains information about the difference between the addresses of two adjacent
         * elements in each dimension (the stride).  The second block contains information
         * about the dimension bounds.
         *
         * The strides block has the following format:
         *      char            *dsc_a_a0;              Address of the element whose subscripts are all zero
         *      unsigned long   dsc_l_s [DIMCT];        Strides
         *
         * The bounds block has the following format:
         *      struct
         *      {
         *              long    dsc_l_l;                Lower bound
         *              long    dsc_l_u;                Upper bound
         *      } dsc_bounds [DIMCT];
         *
         * (DIMCT represents the value contained in dsc_b_dimct.)
         */
};


/*
 *      Unaligned Bit String Descriptor:
 */
struct  dsc_descriptor_ubs
{
        unsigned short  dsc_w_length;   /* length of data item in bits */
        unsigned char   dsc_b_dtype;    /* data type code = DSC_K_DTYPE_VU */
        unsigned char   dsc_b_class;    /* descriptor class code = DSC_K_CLASS_UBS */
        char            *dsc_a_base;    /* address to which dsc_l_pos is relative */
        long            dsc_l_pos;      /* bit position relative to dsc_a_base of first bit in string */
};


/*
 *      Unaligned Bit Array Descriptor:
 */
struct  dsc_descriptor_uba
{
        unsigned short  dsc_w_length;   /* length of data item in bits */
        unsigned char   dsc_b_dtype;    /* data type code = DSC_K_DTYPE_VU */
        unsigned char   dsc_b_class;    /* descriptor class code = DSC_K_CLASS_UBA */
        char            *dsc_a_base;    /* address to which effective bit offset is relative */
        char            dsc_b_scale;    /* reserved;  must be zero */
        unsigned char   dsc_b_digits;   /* reserved;  must be zero */
        struct
        {
                unsigned                 : 3;   /* reserved;  must be zero */
                unsigned dsc_v_fl_binscale : 1; /* must be zero */
                unsigned dsc_v_fl_redim  : 1;   /* must be zero */
                unsigned                 : 3;   /* reserved;  must be zero */
        }               dsc_b_aflags;   /* array flag bits */
        unsigned char   dsc_b_dimct;    /* number of dimensions */
        unsigned long   dsc_l_arsize;   /* total size of array in bits */
        /*
         * Three blocks of information must follow contiguously at this point;  the first block
         * contains information about the difference between the bit addresses of two adjacent
         * elements in each dimension (the stride).  The second block contains information
         * about the dimension bounds.  The third block is the relative bit position with
         * respect to dsc_a_base of the first actual bit of the array.
         *
         * The strides block has the following format:
         *      long            dsc_l_v0;               Bit offset of the element whose subscripts are all zero,
         *                                              with respect to dsc_a_base
         *      unsigned long   dsc_l_s [DIMCT];        Strides
         *
         * The bounds block has the following format:
         *      struct
         *      {
         *              long    dsc_l_l;                Lower bound
         *              long    dsc_l_u;                Upper bound
         *      } dsc_bounds [DIMCT];
         *
         * The last block has the following format:
         *      long    dsc_l_pos;
         *
         * (DIMCT represents the value contained in dsc_b_dimct.)
         */
        };


/*
 *      String with Bounds Descriptor:
 */
struct  dsc_descriptor_sb
{
        unsigned short  dsc_w_length;   /* length of string in bytes */
        unsigned char   dsc_b_dtype;    /* data type code = DSC_K_DTYPE_T */
        unsigned char   dsc_b_class;    /* descriptor class code = DSC_K_CLASS_SB */
        char            *dsc_a_pointer; /* address of first byte of data storage */
        long            dsc_l_sb_l1;    /* lower bound */
        long            dsc_l_sb_u1;    /* upper bound */
};


/*
 *      Unaligned Bit String with Bounds Descriptor:
 */
struct  dsc_descriptor_ubsb
{
        unsigned short  dsc_w_length;   /* length of data item in bits */
        unsigned char   dsc_b_dtype;    /* data type code = DSC_K_DTYPE_VU */
        unsigned char   dsc_b_class;    /* descriptor class code = DSC_K_CLASS_UBSB */
        char            *dsc_a_base;    /* address to which dsc_l_pos is relative */
        long            dsc_l_pos;      /* bit position relative to dsc_a_base of first bit in string */
        long            dsc_l_ubsb_l1;  /* lower bound */
        long            dsc_l_ubsb_u1;  /* upper bound */
};


/*
 *      Codes for dsc_b_dtype:
 */

/*
 *      Atomic data types:
 */
#define DSC_K_DTYPE_Z   0               /* unspecified */
#define DSC_K_DTYPE_BU  2               /* byte (unsigned);  8-bit unsigned quantity */
#define DSC_K_DTYPE_WU  3               /* word (unsigned);  16-bit unsigned quantity */
#define DSC_K_DTYPE_LU  4               /* longword (unsigned);  32-bit unsigned quantity */
#define DSC_K_DTYPE_QU  5               /* quadword (unsigned);  64-bit unsigned quantity */
#define DSC_K_DTYPE_OU  25              /* octaword (unsigned);  128-bit unsigned quantity */
#define DSC_K_DTYPE_B   6               /* byte integer (signed);  8-bit signed 2's-complement integer */
#define DSC_K_DTYPE_W   7               /* word integer (signed);  16-bit signed 2's-complement integer */
#define DSC_K_DTYPE_L   8               /* longword integer (signed);  32-bit signed 2's-complement integer */
#define DSC_K_DTYPE_Q   9               /* quadword integer (signed);  64-bit signed 2's-complement integer */
#define DSC_K_DTYPE_O   26              /* octaword integer (signed);  128-bit signed 2's-complement integer */
#define DSC_K_DTYPE_F   10              /* F_floating;  32-bit single-precision floating point */
#define DSC_K_DTYPE_D   11              /* D_floating;  64-bit double-precision floating point */
#define DSC_K_DTYPE_G   27              /* G_floating;  64-bit double-precision floating point */
#define DSC_K_DTYPE_H   28              /* H_floating;  128-bit quadruple-precision floating point */
#define DSC_K_DTYPE_FC  12              /* F_floating complex */
#define DSC_K_DTYPE_DC  13              /* D_floating complex */
#define DSC_K_DTYPE_GC  29              /* G_floating complex */
#define DSC_K_DTYPE_HC  30              /* H_floating complex */
#define DSC_K_DTYPE_CIT 31              /* COBOL Intermediate Temporary */
/*
 *      String data types:
 */
#define DSC_K_DTYPE_T   14              /* character string;  a single 8-bit character or a sequence of characters */
#define DSC_K_DTYPE_VT  37              /* varying character string;  16-bit count, followed by a string */
#define DSC_K_DTYPE_NU  15              /* numeric string, unsigned */
#define DSC_K_DTYPE_NL  16              /* numeric string, left separate sign */
#define DSC_K_DTYPE_NLO 17              /* numeric string, left overpunched sign */
#define DSC_K_DTYPE_NR  18              /* numeric string, right separate sign */
#define DSC_K_DTYPE_NRO 19              /* numeric string, right overpunched sign */
#define DSC_K_DTYPE_NZ  20              /* numeric string, zoned sign */
#define DSC_K_DTYPE_P   21              /* packed decimal string */
#define DSC_K_DTYPE_V   1               /* aligned bit string */
#define DSC_K_DTYPE_VU  34              /* unaligned bit string */
/*
 *      Miscellaneous data types:
 */
#define DSC_K_DTYPE_ZI  22              /* sequence of instructions */
#define DSC_K_DTYPE_ZEM 23              /* procedure entry mask */
#define DSC_K_DTYPE_DSC 24              /* descriptor */
#define DSC_K_DTYPE_BPV 32              /* bound procedure value */
#define DSC_K_DTYPE_BLV 33              /* bound label value */
#define DSC_K_DTYPE_ADT 35              /* absolute date and time */
/*
 *      Reserved data type codes:
 *      codes 38-191 are reserved to DIGITAL;
 *      codes 160-191 are reserved to DIGITAL facilities for facility-specific purposes;
 *      codes 192-255 are reserved for DIGITAL's Computer Special Systems Group
 *        and for customers for their own use.
 */


/*
 *      Codes for dsc_b_class:
 */
#define DSC_K_CLASS_S   1               /* fixed-length descriptor */
#define DSC_K_CLASS_D   2               /* dynamic string descriptor */
/*      DSC_K_CLASS_V                   ** variable buffer descriptor;  reserved for use by DIGITAL */
#define DSC_K_CLASS_A   4               /* array descriptor */
#define DSC_K_CLASS_P   5               /* procedure descriptor */
/*      DSC_K_CLASS_PI                  ** procedure incarnation descriptor;  obsolete */
/*      DSC_K_CLASS_J                   ** label descriptor;  reserved for use by the VMS Debugger */
/*      DSC_K_CLASS_JI                  ** label incarnation descriptor;  obsolete */
#define DSC_K_CLASS_SD  9               /* decimal string descriptor */
#define DSC_K_CLASS_NCA 10              /* noncontiguous array descriptor */
#define DSC_K_CLASS_VS  11              /* varying string descriptor */
#define DSC_K_CLASS_VSA 12              /* varying string array descriptor */
#define DSC_K_CLASS_UBS 13              /* unaligned bit string descriptor */
#define DSC_K_CLASS_UBA 14              /* unaligned bit array descriptor */
#define DSC_K_CLASS_SB  15              /* string with bounds descriptor */
#define DSC_K_CLASS_UBSB 16             /* unaligned bit string with bounds descriptor */
/*
 *      Reserved descriptor class codes:
 *      codes 15-191 are reserved to DIGITAL;
 *      codes 160-191 are reserved to DIGITAL facilities for facility-specific purposes;
 *      codes 192-255 are reserved for DIGITAL's Computer Special Systems Group
 *        and for customers for their own use.
 */


/*
 *      A simple macro to construct a string descriptor:
 */

#define DESCRIPTOR(name,string)         struct dsc_descriptor_s name = { sizeof(string)-1, DSC_K_DTYPE_T, DSC_K_CLASS_S, string }
#define DSC_DESCRIPTOR(name,string)     struct dsc_descriptor_s name = { sizeof(string)-1, DSC_K_DTYPE_T, DSC_K_CLASS_S, string }

#define DESCRIP_H_DEFINED
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr20\endian.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1993-2000 Microsoft Corporation

Module Name :

    endian.c

Abstract :

    This file contains the routines called by MIDL 2.0 stubs and the
    interpreter to perform endian, floating pointer, and character conversions.

Author :

    David Kays  dkays   December 1993.

Revision History :

  ---------------------------------------------------------------------*/

#include "cvt.h"
#include "ndrp.h"
#include "interp2.h"
#include "attack.h"
#include "pointerq.h"

void
NdrUDTSimpeTypeConvert(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat,
    uchar               fEmbeddedPointerPass );

void cvt_ibm_f_to_ieee_single( ULONG *ulFP );
void cvt_ibm_d_to_ieee_double( ULONG *ulFP );


//
// Conversion routine table.
//
const
PCONVERT_ROUTINE    ConvertRoutinesTable[] =
                    {
                    NdrUDTSimpeTypeConvert,
                    NdrUDTSimpeTypeConvert,
                    NdrUDTSimpeTypeConvert,
                    NdrUDTSimpeTypeConvert,
                    NdrUDTSimpeTypeConvert,
                    NdrUDTSimpeTypeConvert,
                    NdrUDTSimpeTypeConvert,
                    NdrUDTSimpeTypeConvert,
                    NdrUDTSimpeTypeConvert,
                    NdrUDTSimpeTypeConvert,
                    NdrUDTSimpeTypeConvert,
                    NdrUDTSimpeTypeConvert,
                    NdrUDTSimpeTypeConvert,
                    NdrUDTSimpeTypeConvert,
                    NdrUDTSimpeTypeConvert,
                    NdrUDTSimpeTypeConvert,
                    NdrUDTSimpeTypeConvert,
                    
                    NdrPointerConvert,
                    NdrPointerConvert,
                    NdrPointerConvert,
                    NdrPointerConvert,

                    NdrSimpleStructConvert,
                    NdrSimpleStructConvert,
                    NdrConformantStructConvert,
                    NdrConformantStructConvert,
                    NdrConformantStructConvert,     // same as FC_CARRAY

                    NdrComplexStructConvert,

                    NdrConformantArrayConvert,
                    NdrConformantVaryingArrayConvert,
                    NdrFixedArrayConvert,
                    NdrFixedArrayConvert,
                    NdrVaryingArrayConvert,
                    NdrVaryingArrayConvert,

                    NdrComplexArrayConvert,

                    NdrConformantStringConvert,
                    NdrConformantStringConvert,
                    NdrConformantStringConvert,
                    NdrConformantStringConvert,

                    NdrNonConformantStringConvert,
                    NdrNonConformantStringConvert,
                    NdrNonConformantStringConvert,
                    NdrNonConformantStringConvert,

                    NdrEncapsulatedUnionConvert,
                    NdrNonEncapsulatedUnionConvert,

                    NdrByteCountPointerConvert,

                    NdrXmitOrRepAsConvert,   // transmit as
                    NdrXmitOrRepAsConvert,   // represent as

                    NdrInterfacePointerConvert,

                    NdrContextHandleConvert,

                    0,                       // NdrHardStructConvert,

                    NdrXmitOrRepAsConvert,   // transmit as ptr
                    NdrXmitOrRepAsConvert,   // represent as ptr

                    NdrUserMarshalConvert,

                    0,   // FC_PIPE 
                    0,   // FC_BLK_HOLE

                    NdrpRangeConvert
                    };

extern const
PCONVERT_ROUTINE * pfnConvertRoutines = ConvertRoutinesTable;

#ifdef TEST_CONVERT
    #define   CHECK_AFTER_CONVERT(pStubMsg, pBuffer, Size ) CheckAfterConvert(pStubMsg,  pBuffer, Size)
#else
    #define   CHECK_AFTER_CONVERT(pStubMsg, pBuffer, Size ) 
#endif

void
NdrUDTSimpeTypeConvert(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat,
    uchar               fEmbeddedPointerPass )
{
    if ( fEmbeddedPointerPass )
    {
        ALIGN(pStubMsg->Buffer,SIMPLE_TYPE_ALIGNMENT(*pFormat));
        pStubMsg->Buffer += SIMPLE_TYPE_BUFSIZE(*pFormat);
    }
    else
    {
        NdrSimpleTypeConvert( pStubMsg,
                              *pFormat );
    }
}

//
// Array for ebcdic to ascii conversions. Use ebcdic value as index into
// array whose corresponding value is the correct ascii value.
// The table below maps from IBM 1047 EBCDIC codeset to ANSI 1252 code page.
//
// Note that due to a disagreement among the code page experts both within Msft
// and between Msft and SAG, I could not determine what the proper mapping 
// between these 2 code pages should be.
// The following 2 characters where in dispute:
//   0x15 maps to 0x0a - this is most likely right, as per experts' majority vote
//   0x25 maps to 0x85 - no agreement here at all, except that for back mapping
//                       it cannot be 0x0a again. 
//                       So, I resolved to use the mapping that worked for SAG.
// Ryszardk, Dec 4, 97
//
extern const
unsigned char EbcdicToAscii[] =
    {
    0x00, 0x01, 0x02, 0x03, 0x9c, 0x09, 0x86, 0x7f, 
    0x97, 0x8d, 0x8e, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 

    0x10, 0x11, 0x12, 0x13, 0x9d, 0x0a, 0x08, 0x87,          // 0x15 -> 0x0a
    0x18, 0x19, 0x92, 0x8f, 0x1c, 0x1d, 0x1e, 0x1f, 

    0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x17, 0x1b,          // 0x25 -> 0x85
    0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x05, 0x06, 0x07, 

    0x90, 0x91, 0x16, 0x93, 0x94, 0x95, 0x96, 0x04, 
    0x98, 0x99, 0x9a, 0x9b, 0x14, 0x15, 0x9e, 0x1a, 
                                            
    0x20, 0xa0, 0xe2, 0xe4, 0xe0, 0xe1, 0xe3, 0xe5, 
    0xe7, 0xf1, 0xa2, 0x2e, 0x3c, 0x28, 0x2b, 0x7c, 

    0x26, 0xe9, 0xea, 0xeb, 0xe8, 0xed, 0xee, 0xef, 
    0xec, 0xdf, 0x21, 0x24, 0x2a, 0x29, 0x3b, 0x5e, 

    0x2d, 0x2f, 0xc2, 0xc4, 0xc0, 0xc1, 0xc3, 0xc5, 
    0xc7, 0xd1, 0xa6, 0x2c, 0x25, 0x5f, 0x3e, 0x3f, 

    0xf8, 0xc9, 0xca, 0xcb, 0xc8, 0xcd, 0xce, 0xcf, 
    0xcc, 0x60, 0x3a, 0x23, 0x40, 0x27, 0x3d, 0x22, 

    0xd8, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 
    0x68, 0x69, 0xab, 0xbb, 0xf0, 0xfd, 0xfe, 0xb1, 

    0xb0, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 
    0x71, 0x72, 0xaa, 0xba, 0xe6, 0xb8, 0xc6, 0xa4, 

    0xb5, 0x7e, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 
    0x79, 0x7a, 0xa1, 0xbf, 0xd0, 0x5b, 0xde, 0xae, 

    0xac, 0xa3, 0xa5, 0xb7, 0xa9, 0xa7, 0xb6, 0xbc, 
    0xbd, 0xbe, 0xdd, 0xa8, 0xaf, 0x5d, 0xb4, 0xd7, 

    0x7b, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 
    0x48, 0x49, 0xad, 0xf4, 0xf6, 0xf2, 0xf3, 0xf5, 

    0x7d, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 
    0x51, 0x52, 0xb9, 0xfb, 0xfc, 0xf9, 0xfa, 0xff, 

    0x5c, 0xf7, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 
    0x59, 0x5a, 0xb2, 0xd4, 0xd6, 0xd2, 0xd3, 0xd5, 

    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 
    0x38, 0x39, 0xb3, 0xdb, 0xdc, 0xd9, 0xda, 0x9f  
    
    };


void RPC_ENTRY
NdrConvert2(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat,
    long                NumberParams )
/*--

Routine description :

    This is the new stub and interpreter entry point for endian conversion.
    This routine handles the conversion of all parameters in a procedure.

Arguments :

    pStubMsg        - Pointer to stub message.
    pFormat         - Format string description of procedure's parameters.
    NumberParams    - The number of parameters in the procedure.

Return :

    None.

--*/
{
    uchar *             pBuffer;
    PFORMAT_STRING      pFormatComplex;
    PFORMAT_STRING      pFormatTypes;
    PPARAM_DESCRIPTION  Params;
    int                 fClientSide;
    long                n;


#ifdef TEST_CONVERT
    pStubMsg->Reserved51_1 = (INT_PTR) I_RpcAllocate( pStubMsg->RpcMsg->BufferLength);
    if ( pStubMsg->Reserved51_1 == NULL )
        RpcRaiseException( RPC_S_OUT_OF_MEMORY );
    memset( (void *)pStubMsg->Reserved51_1, 0xff, pStubMsg->RpcMsg->BufferLength);
#else    
    //
    // Check if we need to do any converting.
    //
    if ( (pStubMsg->RpcMsg->DataRepresentation & (unsigned long)0X0000FFFF) ==
          NDR_LOCAL_DATA_REPRESENTATION )
        return;
#endif

    // Save the original buffer pointer to restore later.
    pBuffer = pStubMsg->Buffer;

    // Get the type format string.
    pFormatTypes = pStubMsg->StubDesc->pFormatTypes;

    fClientSide = pStubMsg->IsClient;

    Params = (PPARAM_DESCRIPTION) pFormat;

    for ( n = 0; n < NumberParams; n++ )
        {
        if ( fClientSide )
            {
            if ( ! Params[n].ParamAttr.IsOut )
                continue;
            }
        else
            {

            if ( Params[n].ParamAttr.IsPartialIgnore )
                {
                NdrSimpleTypeConvert( pStubMsg, FC_POINTER );
                continue;
                }

            if ( ! Params[n].ParamAttr.IsIn )
                continue;
            }

        if ( Params[n].ParamAttr.IsPipe )
            continue;

        if ( Params[n].ParamAttr.IsBasetype )
            {
            NdrSimpleTypeConvert( pStubMsg, Params[n].SimpleType.Type );
            }
        else
            {
            //
            // Complex type or pointer to complex type.
            //
            pFormatComplex = pFormatTypes + Params[n].TypeOffset;

            (*pfnConvertRoutines[ROUTINE_INDEX(*pFormatComplex)])
                ( pStubMsg,
                  pFormatComplex,
                  FALSE );
            }
        }

#ifdef TEST_CONVERT
    I_RpcFree( (void *) pStubMsg->Reserved51_1 );
#endif
    pStubMsg->Buffer = pBuffer;
}


void RPC_ENTRY
NdrConvert(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat )
/*--

Routine description :

    This is the stub and interpreter entry point for endian conversion.
    This routine handles the conversion of all parameters in a procedure.

Arguments :

    pStubMsg    - Pointer to stub message.
    pFormat     - Format string description of procedure's parameters.

Return :

    None.

--*/
{
    uchar *             pBuffer;
    PFORMAT_STRING      pFormatComplex;
    PFORMAT_STRING      pFormatTypes;
    int                 fClientSide;

    //
    // Check if we need to do any converting.
    //
    if ( (pStubMsg->RpcMsg->DataRepresentation & (unsigned long)0X0000FFFF) ==
          NDR_LOCAL_DATA_REPRESENTATION )
        return;

    // Save the original buffer pointer to restore later.
    pBuffer = pStubMsg->Buffer;

    // Get the type format string.
    pFormatTypes = pStubMsg->StubDesc->pFormatTypes;

    fClientSide = pStubMsg->IsClient;

    for ( ;; )
        {
        switch ( *pFormat )
            {
            case FC_IN_PARAM :
            case FC_IN_PARAM_NO_FREE_INST :
                if ( fClientSide )
                    {
                    pFormat += 4;
                    continue;
                    }

                break;

            case FC_IN_PARAM_BASETYPE :
                if ( ! fClientSide )
                    NdrSimpleTypeConvert( pStubMsg, pFormat[1] );

                pFormat += 2;
                continue;
       
            case FC_PARTIAL_IGNORE_PARAM:
                if ( ! fClientSide )
                    {
                    NdrSimpleTypeConvert( pStubMsg, FC_LONG );
                    pFormat += 4;
                    continue;
                    }
            // Intentional fallthrough
            case FC_IN_OUT_PARAM :
                break;

            case FC_OUT_PARAM :
                if ( ! fClientSide )
                    {
                    pFormat += 4;
                    continue;
                    }

                break;

            case FC_RETURN_PARAM :
                if ( ! fClientSide )
                    {
                    pStubMsg->Buffer = pBuffer;
                    return;
                    }

                break;

            case FC_RETURN_PARAM_BASETYPE :
                if ( fClientSide )
                    NdrSimpleTypeConvert( pStubMsg, pFormat[1] );

                // We're done.  Fall through.

            default :
                pStubMsg->Buffer = pBuffer;
                return;
            }

        //
        // Complex type or pointer to complex type.
        //
        pFormatComplex = pFormatTypes + *((ushort *)(pFormat + 2));

        (*pfnConvertRoutines[ROUTINE_INDEX(*pFormatComplex)])
            ( pStubMsg,
              pFormatComplex,
              FALSE );

        if ( *pFormat == FC_RETURN_PARAM )
            {
            pStubMsg->Buffer = pBuffer;
            return;
            }

        pFormat += 4;
        }
}

#ifdef TEST_CONVERT
void CheckAfterConvert( PMIDL_STUB_MESSAGE pStubMsg, void *pBuffer , ulong Size )
{   
    ulong Value = 0;
    uchar * pCheckBuffer = (uchar *) pStubMsg->Reserved51_1 + ((uchar *)pBuffer- (uchar *)pStubMsg->RpcMsg->Buffer );
    switch ( Size )
        {
        case 1:
            Value = *((char *)pCheckBuffer);
            break;
        case 2:
            Value = *((ushort *)pCheckBuffer );
            break;
        case 4:
            Value = *((ulong *)pCheckBuffer );
            break;
        case 8:
        default:
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
        }
    if ( Value != 0 )
        RpcRaiseException ( RPC_X_BAD_STUB_DATA );
}

void CheckBeforeConvert( PMIDL_STUB_MESSAGE pStubMsg,
                                        ulong Size )
{
    uchar * pCheckBuffer = (uchar *) pStubMsg->Reserved51_1 + ((uchar *)pStubMsg->Buffer- (uchar *)pStubMsg->RpcMsg->Buffer);
    switch (Size )
        {
        case 1:
                {
            uchar *cValue = (uchar *)pCheckBuffer;
            (*cValue)++;
            CheckAfterConvert( pStubMsg, pStubMsg->Buffer, 1 );
            }
            break;

        case 2:
                {
            ushort *sValue = (ushort *)pCheckBuffer;
            (*sValue)++;
            CheckAfterConvert( pStubMsg, pStubMsg->Buffer, 2 );
            }
            break;

        case 4:
                {
            ulong *lValue = (ulong *)pCheckBuffer;
            (*lValue)++;
            CheckAfterConvert( pStubMsg, pStubMsg->Buffer, 4 );
            }
            break;

        case 8:
                {
            ulong *hValue = (ulong *)pCheckBuffer;
            (*hValue)++;
            CheckAfterConvert( pStubMsg, pStubMsg->Buffer, 4 );
            // failure will be catch the first time.
            hValue++;
            *hValue = 0;
            }
            break;
        default:
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            break;
        }
}


void
NdrSimpleTypeConvert(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar               FormatChar )
{
    switch ( FormatChar )
        {
        case FC_CHAR:
        case FC_BYTE :
        case FC_SMALL :
        case FC_USMALL :
            CHECK_EOB_RAISE_BSD( pStubMsg->Buffer + 1 );            
            CheckBeforeConvert( pStubMsg, 1 );
            pStubMsg->Buffer += 1;
            break;

        case FC_SHORT :
        case FC_USHORT :
        case FC_WCHAR :
        case FC_ENUM16 :
            ALIGN(pStubMsg->Buffer,1);
            CHECK_EOB_RAISE_BSD( pStubMsg->Buffer + 2 );
            CheckBeforeConvert( pStubMsg, 2 );
            pStubMsg->Buffer +=2;
            break;

        case FC_LONG :
        case FC_ULONG :
#if defined(__RPC_WIN64__)
        case FC_INT3264:
        case FC_UINT3264:
#endif
        case FC_POINTER :
        case FC_ENUM32 :
        case FC_ERROR_STATUS_T:
        case FC_FLOAT :
            ALIGN(pStubMsg->Buffer,3);
            CHECK_EOB_RAISE_BSD( pStubMsg->Buffer + 4 );
            CheckBeforeConvert( pStubMsg, 4 );

            pStubMsg->Buffer += 4;
            break;

        case FC_HYPER :
        case FC_DOUBLE:
            ALIGN(pStubMsg->Buffer,7);
            CHECK_EOB_RAISE_BSD( pStubMsg->Buffer + 8 );
            CheckBeforeConvert( pStubMsg, 8 );

            pStubMsg->Buffer += 8;
            break;

        case FC_IGNORE:
            break;

        default :
            NDR_ASSERT(0,"NdrSimpleTypeConvert : Bad format type");
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            return;
            
        }
}

#else

void
NdrSimpleTypeConvert(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar               FormatChar )
/*--

Routine description :

    Converts a simple type.

Arguments :

    pStubMsg    - Pointer to stub message.
    FormatChar  - Simple type format character.

Return :

    None.

--*/
{
    switch ( FormatChar )
        {
        case FC_CHAR :
            CHECK_EOB_RAISE_BSD( pStubMsg->Buffer + 1 );            

            if ( (pStubMsg->RpcMsg->DataRepresentation & NDR_CHAR_REP_MASK) ==
                 NDR_EBCDIC_CHAR )
                *(pStubMsg->Buffer) = EbcdicToAscii[*(pStubMsg->Buffer)];

            pStubMsg->Buffer += 1;
            break;

        case FC_BYTE :
        case FC_SMALL :
        case FC_USMALL :
            CHECK_EOB_RAISE_BSD( pStubMsg->Buffer + 1 );

            pStubMsg->Buffer++;
            break;

        case FC_SHORT :
        case FC_USHORT :
        case FC_WCHAR :
        case FC_ENUM16 :
            ALIGN(pStubMsg->Buffer,1);
            CHECK_EOB_RAISE_BSD( pStubMsg->Buffer + 2 );

            if ( (pStubMsg->RpcMsg->DataRepresentation & NDR_INT_REP_MASK) !=
                  NDR_LOCAL_ENDIAN )
                {
                *((ushort *)pStubMsg->Buffer) = RtlUshortByteSwap((*(ushort *)pStubMsg->Buffer));
                }

            pStubMsg->Buffer += 2;
            break;

        case FC_LONG :
        case FC_ULONG :
#if defined(__RPC_WIN64__)
        case FC_INT3264:
        case FC_UINT3264:
#endif
        case FC_POINTER :
        case FC_ENUM32 :
        case FC_ERROR_STATUS_T:
            ALIGN(pStubMsg->Buffer,3);
            CHECK_EOB_RAISE_BSD( pStubMsg->Buffer + 4 );

            if ( (pStubMsg->RpcMsg->DataRepresentation & NDR_INT_REP_MASK) !=
                  NDR_LOCAL_ENDIAN )
                {
                *((ulong *)pStubMsg->Buffer) = RtlUlongByteSwap(*(ulong *)pStubMsg->Buffer);
                }

            pStubMsg->Buffer += 4;
            break;

        case FC_HYPER :
            ALIGN(pStubMsg->Buffer,7);
            CHECK_EOB_RAISE_BSD( pStubMsg->Buffer + 8 );

            if ( (pStubMsg->RpcMsg->DataRepresentation & NDR_INT_REP_MASK) !=
                 NDR_LOCAL_ENDIAN )
                {
                *((MIDL_uhyper *)pStubMsg->Buffer) = RtlUlonglongByteSwap(*(MIDL_uhyper *)pStubMsg->Buffer);
                }

            pStubMsg->Buffer += 8;
            break;

        //
        // VAX floating point conversions is the only one supported.
        //

        case FC_FLOAT :
            ALIGN(pStubMsg->Buffer,3);
            CHECK_EOB_RAISE_BSD( pStubMsg->Buffer + 4 );

            if ( (pStubMsg->RpcMsg->DataRepresentation & NDR_FLOAT_INT_MASK)
                 != NDR_LOCAL_ENDIAN_IEEE_REP )
                {
                BOOL fEndianessDone = FALSE;

                if ( (pStubMsg->RpcMsg->DataRepresentation &
                      NDR_INT_REP_MASK) != NDR_LOCAL_ENDIAN )
                    {
                    NdrSimpleTypeConvert( pStubMsg, (uchar) FC_LONG );
                    fEndianessDone = TRUE;
                    }

                if ( (pStubMsg->RpcMsg->DataRepresentation &
                      NDR_FLOAT_REP_MASK) != NDR_IEEE_FLOAT )
                    {
                    if ( fEndianessDone )
                        pStubMsg->Buffer -= 4;

                    if ( (pStubMsg->RpcMsg->DataRepresentation &
                          NDR_FLOAT_REP_MASK) == NDR_VAX_FLOAT )
                        {
                        cvt_vax_f_to_ieee_single( pStubMsg->Buffer,
                                                  0,
                                                  pStubMsg->Buffer );
                        pStubMsg->Buffer += 4;
                        }
                    else if ( (pStubMsg->RpcMsg->DataRepresentation & 
                               NDR_FLOAT_REP_MASK) == NDR_IBM_FLOAT )
                        {
                        cvt_ibm_f_to_ieee_single( (ULONG *)pStubMsg->Buffer ) ;
                        pStubMsg->Buffer += 4 ;
                        }
                    else
                        RpcRaiseException(RPC_X_BAD_STUB_DATA);
                    }
                }
            else
                pStubMsg->Buffer += 4;

            break;

        case FC_DOUBLE :
            ALIGN(pStubMsg->Buffer,7);
            CHECK_EOB_RAISE_BSD( pStubMsg->Buffer + 8 );

            if ( (pStubMsg->RpcMsg->DataRepresentation & NDR_FLOAT_INT_MASK)
                 != NDR_LOCAL_ENDIAN_IEEE_REP )
                {
                BOOL fEndianessDone = FALSE;

                if ( (pStubMsg->RpcMsg->DataRepresentation &
                      NDR_INT_REP_MASK) != NDR_LOCAL_ENDIAN )
                    {
                    NdrSimpleTypeConvert( pStubMsg, (uchar) FC_HYPER );
                    fEndianessDone = TRUE;
                    }

                if ( (pStubMsg->RpcMsg->DataRepresentation &
                      NDR_FLOAT_REP_MASK) != NDR_IEEE_FLOAT )
                    {
                    if ( fEndianessDone )
                        pStubMsg->Buffer -= 8;

                    if ( (pStubMsg->RpcMsg->DataRepresentation &
                          NDR_FLOAT_REP_MASK) == NDR_VAX_FLOAT )
                        {
                        cvt_vax_g_to_ieee_double( pStubMsg->Buffer,
                                                  0,
                                                  pStubMsg->Buffer );
                        pStubMsg->Buffer += 8;
                        }
                    else if ( (pStubMsg->RpcMsg->DataRepresentation & 
                               NDR_FLOAT_REP_MASK) == NDR_IBM_FLOAT )
                        {
                        cvt_ibm_d_to_ieee_double( (ULONG *)pStubMsg->Buffer ) ;
                        pStubMsg->Buffer += 8 ;
                        }
                    else
                        RpcRaiseException(RPC_X_BAD_STUB_DATA);
                    }
                }
            else
                pStubMsg->Buffer += 8;

            break;

        case FC_IGNORE:
            break;

        default :
            NDR_ASSERT(0,"NdrSimpleTypeConvert : Bad format type");
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            return;
        }
}
#endif 

void
NdrpRangeConvert(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat,
    uchar               fEmbeddedPointerPass )
/*--

Routine description :

--*/
{
    uchar    FcType = pFormat[1] & 0x0f;

    if ( fEmbeddedPointerPass )
        pStubMsg->Buffer += SIMPLE_TYPE_BUFSIZE( FcType );
    else
        NdrSimpleTypeConvert( pStubMsg, FcType );
}


void
NdrPointerConvert(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat,
    uchar               fEmbeddedPointerPass )
/*--

Routine description :

    Converts a top level pointer and the data it points to.
    Pointers embedded in structures, arrays, or unions call
    NdrpPointerConvert directly.

    Used for FC_RP, FC_UP, FC_FP, FC_OP.

Arguments :

    pStubMsg                - Pointer to stub message.
    pFormat                 - Pointer's format string description.
    fEmbeddedPointerPass    - TRUE if a pass is being to convert only embedded
                              pointers in a struct/array.

Return :

    None.

--*/
{
    uchar *     pBufferMark;

    if ( *pFormat != FC_RP )
        {
        ALIGN(pStubMsg->Buffer,3);

        pBufferMark = pStubMsg->Buffer;

        if ( fEmbeddedPointerPass )
            pStubMsg->Buffer += PTR_WIRE_SIZE;
        else
            NdrSimpleTypeConvert( pStubMsg, (uchar) FC_LONG );
        }
    else
        pBufferMark = 0;

    NdrpPointerConvert( pStubMsg,
                        pBufferMark,
                        pFormat );
}


void
NdrpPointerConvertInternal(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pBufferMark,
    PFORMAT_STRING      pFormat )
/*--

Routine description :

    Private routine for converting a pointer and the data it points to.
    This is the entry point for pointers embedded in structures, arrays,
    and unions.

    Used for FC_RP, FC_UP, FC_FP, FC_OP.

Arguments :

    pStubMsg                - Pointer to stub message.
    pFormat                 - Pointer's format string description.
    fEmbeddedPointerPass    - TRUE if a pass is being to convert only embedded
                              pointers in a struct/array.

Return :

    None.

--*/
{
    uchar   uFlagsSave;

    switch ( *pFormat )
        {
        case FC_RP :
            break;

        case FC_UP :
        case FC_OP :
            if ( ! *((long *)pBufferMark) )
                return;

            break;

        case FC_FP :
            //
            // Check if we have already seen this full pointer ref id during
            // endian coversion.  If so then we are finished with this pointer.
            //
            //
            if ( NdrFullPointerQueryRefId( pStubMsg->FullPtrXlatTables,
                                           *((ulong *)pBufferMark),
                                           FULL_POINTER_CONVERTED,
                                           0 ) )
                return;

            break;

        default :
            NDR_ASSERT(0,"NdrpPointerConvert : Bad format type");
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            return;
        }

    //
    // Pointer to complex type.
    //
    if ( ! SIMPLE_POINTER(pFormat[1]) )
        {
        pFormat += 2;

        //
        // Get the pointee format string.
        // Cast must be to a signed short since some offsets are negative.
        //
        pFormat += *((signed short *)pFormat);
        }
    else
        {
        switch ( pFormat[2] )
            {
            case FC_C_CSTRING :
            case FC_C_BSTRING :
            case FC_C_WSTRING :
            case FC_C_SSTRING :
                // Get to the string's description.
                pFormat += 2;
                break;

            default :
                // Else it's a pointer to a simple type.
                NdrSimpleTypeConvert( pStubMsg,
                                      pFormat[2] );
                return;
            }
        }

    //
    // Now lookup the proper conversion routine.
    //
    uFlagsSave = pStubMsg->uFlags;
    RESET_CONF_FLAGS_TO_STANDALONE(pStubMsg->uFlags);

    (*pfnConvertRoutines[ROUTINE_INDEX(*pFormat)])( pStubMsg,
                                                    pFormat,
                                                    FALSE );
    pStubMsg->uFlags = uFlagsSave;
}


NDR_CONVERT_POINTER_QUEUE_ELEMENT::NDR_CONVERT_POINTER_QUEUE_ELEMENT( 
    MIDL_STUB_MESSAGE *pStubMsg,
    uchar             *pBufferMarkNew,
    PFORMAT_STRING     pFormatNew ) :

        pFormat(pFormatNew),
        pBufferMark(pBufferMarkNew),
        uFlags(pStubMsg->uFlags) 
{

}

void 
NDR_CONVERT_POINTER_QUEUE_ELEMENT::Dispatch(
    MIDL_STUB_MESSAGE *pStubMsg) 
{
    SAVE_CONTEXT<uchar> uFlagsSave( pStubMsg->uFlags, uFlags );
    NDR_ASSERT( !pStubMsg->PointerBufferMark, "PointerBufferMark is not 0!\n");

    NdrpPointerConvertInternal( pStubMsg,
                                   pBufferMark,
                                   pFormat );

}

void
NdrpEnquePointerConvert(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pBufferMark,
    PFORMAT_STRING      pFormat )
{
    NDR32_POINTER_CONTEXT PointerContext( pStubMsg );

    RpcTryFinally
        {

        NDR_CONVERT_POINTER_QUEUE_ELEMENT*pElement = 
            new(PointerContext.GetActiveState()) 
                NDR_CONVERT_POINTER_QUEUE_ELEMENT(pStubMsg,
                                                  pBufferMark,
                                                  pFormat );
        PointerContext.Enque( pElement );
        PointerContext.DispatchIfRequired();
        }
    RpcFinally
        {
        PointerContext.EndContext();
        }
    RpcEndFinally

}

void
NdrpPointerConvert(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pBufferMark,
    PFORMAT_STRING      pFormat )
{
    if ( !NdrIsLowStack( pStubMsg ) )
        {
        NdrpPointerConvertInternal( 
            pStubMsg,
            pBufferMark,
            pFormat );

        return;
        }

    NdrpEnquePointerConvert(
        pStubMsg,
        pBufferMark,
        pFormat );
}



void
NdrSimpleStructConvert(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat,
    uchar               fEmbeddedPointerPass )
/*--

Routine description :

    Converts a simple structure.

    Used for FC_STRUCT and FC_PSTRUCT.

Arguments :

    pStubMsg                - Pointer to stub message.
    pFormat                 - Structure's format string description.
    fEmbeddedPointerPass    - TRUE if a pass is being to convert only embedded
                              pointers in a struct/array.

Return :

    None.

--*/
{
    uchar *         pBufferMark;
    PFORMAT_STRING  pFormatLayout;

    ALIGN(pStubMsg->Buffer,pFormat[1]);

    // Remember where the struct starts in the buffer.
    pBufferMark = pStubMsg->Buffer;

    pFormat += 4;

    if ( *pFormat == FC_PP )
        pFormatLayout = NdrpSkipPointerLayout( pFormat );
    else
        pFormatLayout = pFormat;

    //
    // Convert or skip the flat part of the structure.
    //
    NdrpStructConvert( pStubMsg,
                       pFormatLayout,
                       0,
                       fEmbeddedPointerPass );

    //
    // Convert the pointers.  This will do nothing if
    // pStubMsg->IgnoreEmbeddedPointers is TRUE.
    //
    if ( *pFormat == FC_PP )
        {
        pStubMsg->BufferMark = pBufferMark;

        NdrpEmbeddedPointerConvert( pStubMsg, pFormat );
        }
}


void
NdrConformantStructConvert(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat,
    uchar               fEmbeddedPointerPass )
/*--

Routine description :

    Converts a conformant or conformant varying structure.

    Used for FC_CSTRUCT, FC_CPSTRUCT and FC_CVSTRUCT.

Arguments :

    pStubMsg                - Pointer to stub message.
    pFormat                 - Structure's format string description.
    fEmbeddedPointerPass    - TRUE if a pass is being to convert only embedded
                              pointers in a struct/array.
                              
                         Note that for a top level struct it can only be FALSE.

Return :

    None.

Notes.
    These pearls of wisdom should be recorded for posterity in the main NDR doc,
    but just in case, let's have them here as well.

    Pointer layout is generated for all structs with pointers, however it is very
    much different for bogus structs.
    A conformant struct has a pointer layout that's complete, i.e. includes pointers
    from conformant arrays in conformant structs. In other words, pointer layout
    propagates up the embedding chain of conf structs.
    For bogus structs, the layout has only the pointers from the current level
    of the bogus struct, the pointers from emebedded bogus structs are with the 
    embedded struct and the pointers from the array are with the array.
    
    Now, arrays in conf structs don't have their own pointer layout description.
    However, top level arrays do have a pointer layout description as appropriate,
    and also conformant arrays from bogus structures do have pointer layout.

    So the bottom line is that a bogus struct depends on its conformant structure 
    or on its conformant array to walk the pointers embedded therein. The only 
    pointers described within the bogus struct are its member level pointers.

    Another look at it is that a conformant struct always has a full description of
    all the pointers contained within itself, whether in the flat portion or in the
    array, and so a conformant struct embedded in a bogus struct can be treated 
    like a top level struct as far as walking its embedded pointers.
    (Then the outer bogus struct cannot walk its array for embedded pointers as it
    would if the embedded struct was another bogus struct.)
    
    So, the rule for the conformant size is simple: whoever picks up the size
    should also process the array for the flat part.
    For the embedded pointers the situation is somewhat unpleasant for the conf 
    struct inside a bogus struct but we simplify by walking both levels. 
    The topmost conf struct has to be walked to see the pointers and the bogus
    can be walked as the walk would be an empty operation.
--*/
{
    PPRIVATE_CONVERT_ROUTINE    pfnConvert;
    uchar *                     pStructStart;
    PFORMAT_STRING              pFormatArray;
    PFORMAT_STRING              pFormatLayout;
    long                        MaxCount = 0;
    uchar                       fTopLevelStruct, fTopmostConfStruct;

    // We can't use pStubMsg->PointerBufferMark == 0 due to dual way ComplexStruct
    // routine is called. One is when embedded, another is a recursion for
    // embedded pointer pass.

    // Top level means a standalone struct, topmost means topmost conf struct, 
    // that is topmost may be embedded in a bogus struct.

    fTopLevelStruct = ! IS_EMBED_CONF_STRUCT( pStubMsg->uFlags );
    fTopmostConfStruct = ! IS_TOPMOST_CONF_STRUCT( pStubMsg->uFlags );

    if ( fTopLevelStruct )
        {
        ALIGN(pStubMsg->Buffer,3);

        // Remember the conformant size position.
        pStubMsg->BufferMark = pStubMsg->Buffer;
        //
        // Convert conformance count if needed.
        //
        if ( fEmbeddedPointerPass )
            pStubMsg->Buffer += 4;
        else
            NdrSimpleTypeConvert( pStubMsg, (uchar) FC_LONG );

        // Get the conformance count.
        // This is valid because a conf struct would have only a single dim array.

        MaxCount = *((long *)(pStubMsg->Buffer - 4));
        CHECK_AFTER_CONVERT( pStubMsg, pStubMsg->Buffer - 4, 4 );
        }
    else
        {
        // This will be used only for the topmost case, set by bogus struct.
        CHECK_AFTER_CONVERT( pStubMsg, pStubMsg->BufferMark , 4 );
        MaxCount = *((long *)(pStubMsg->BufferMark));
        }

    ALIGN(pStubMsg->Buffer,pFormat[1]);

    // Remember where the struct starts in the buffer.
    pStructStart = pStubMsg->Buffer;

    pFormat += 4;

    // Get the array description.
    pFormatArray = pFormat + *((signed short *)pFormat);

    pFormat += 2;

    if ( *pFormat == FC_PP )
        pFormatLayout = NdrpSkipPointerLayout( pFormat );
    else
        pFormatLayout = pFormat;

    // When walking the struct we can descend into embedded conf structs
    // so mark that the top level already happened.
    //
    SET_EMBED_CONF_STRUCT(pStubMsg->uFlags);
    SET_TOPMOST_CONF_STRUCT(pStubMsg->uFlags);

    //
    // Convert or skip the flat part of the structure.
    //
    NdrpStructConvert( pStubMsg,
                       pFormatLayout,
                       0,
                       fEmbeddedPointerPass );

    // Convert the flat part of the array only if top level, as the array 
    // description gets propagated up the embeddings.
    // See a note about propagating array and pointer descriptions above.

    if ( fTopmostConfStruct && !fEmbeddedPointerPass )
        {
        switch ( *pFormatArray )
            {
            case FC_CARRAY :
                pfnConvert = NdrpConformantArrayConvert;
                break;
            case FC_CVARRAY :
                pfnConvert = NdrpConformantVaryingArrayConvert;
                break;
            default :
                //
                // Conformant strings, but use the non-conformant string conversion
                // routine since we've already converted the conformant size.
                //
                NdrNonConformantStringConvert( pStubMsg,
                                               pFormatArray,
                                               fEmbeddedPointerPass );
                goto CheckPointers;
            }

        pStubMsg->MaxCount = MaxCount;

        (*pfnConvert)( pStubMsg,
                       pFormatArray,
                       fEmbeddedPointerPass );

        SET_CONF_ARRAY_DONE( pStubMsg->uFlags );
        }

CheckPointers:

    // Convert embedded pointers for the whole structure including the array

    RESET_EMBED_CONF_STRUCT(pStubMsg->uFlags);
    RESET_TOPMOST_CONF_STRUCT(pStubMsg->uFlags);
    
    // Convert pointees if the structure is standalone or if it is
    //   topmost embedded and pointer pass
    
    if ( fTopLevelStruct // standalone && !fEmbeddedPointerPass  
        ||
         fEmbeddedPointerPass && fTopmostConfStruct )
        {
        // Top level, or topmost within a bogus struct: walk the pointers.
        // Convert the pointers.  This will do nothing if
        // pStubMsg->IgnoreEmbeddedPointers is TRUE.
        //
        if ( *pFormat == FC_PP )
            {
            pStubMsg->BufferMark = pStructStart;
    
            NdrpEmbeddedPointerConvert( pStubMsg, pFormat );
            }

        SET_CONF_ARRAY_DONE( pStubMsg->uFlags );
        }

    // Restore flags.
    if ( ! fTopLevelStruct)
        SET_EMBED_CONF_STRUCT(pStubMsg->uFlags);

    if ( ! fTopmostConfStruct)
        SET_TOPMOST_CONF_STRUCT(pStubMsg->uFlags);
}


#if 0
void
NdrHardStructConvert(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat,
    uchar               fEmbeddedPointerPass )
/*--

Routine description :

    Converts a hard structure.

    Used for FC_HARD_STRUCT.

Arguments :

    pStubMsg                - Pointer to stub message.
    pFormat                 - Structure's format string description.
    fEmbeddedPointerPass    - TRUE if a pass is being to convert only embedded
                              pointers in a struct/array.

Return :

    None.

Notes:

    pStubMsg->PointerBufferMark
        ! NULL      indicates embedding in a complex struct.
        NULL        indicates top level or embedding in something else

    So the algoritm here is
        if the hard struct is in a complex struct, then the complex
            struct is issuing two calls, first with FALSE, then with TRUE.
        if the hard struct is NOT in a complex struct then there is only
            one call and the union has to be called explicitely.
--*/
{
    uchar *   BufferSaved;

    ALIGN(pStubMsg->Buffer,pFormat[1]);

    // Remember where the struct starts in the buffer.
    BufferSaved = pStubMsg->Buffer;

    //
    // Convert or skip the flat part of the structure.
    //
    NdrpStructConvert( pStubMsg,
                       pFormat + 16,
                       0,  // no pointer layout
                       fEmbeddedPointerPass );

    if ( ! pStubMsg->PointerBufferMark )
        {
        //
        // Convert the pointers.  This will do nothing if
        // pStubMsg->IgnoreEmbeddedPointers is TRUE.
        //
        // See if we have a union, as the pointer may be only there.
        //
        pFormat += 14;
        if ( *((short *)pFormat) )
            {
            //
            // Set the pointer to the beginning of the union:
            // the copy size is the struct buffer size without the union.
            //

            pStubMsg->Buffer = BufferSaved + *((short *)&pFormat[-4]);

            pFormat += *((short *)pFormat);

            (*pfnConvertRoutines[ ROUTINE_INDEX( *pFormat )])
                ( pStubMsg,
                  pFormat,
                  TRUE );    // convert the pointer only, if any.
            }
        }
}
#endif


void
NdrComplexStructConvert(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat,
    uchar               fEmbeddedPointerPass )
/*--

Routine description :

    Converts a complex structure.

    Used for FC_BOGUS_STRUCT.

Arguments :

    pStubMsg                - Pointer to stub message.
    pFormat                 - Structure's format string description.
    fEmbeddedPointerPass    - TRUE if a pass is being to convert only embedded
                              pointers in a struct/array.
                              
                     Notice a recursive call to this routine at the end.
                     Hence, the flag can be TRUE or FALSE even for the top level
                     bogus structures.
                     Also, for the recursive call pStubMsg->PointerBufferMark is
                     not 0, even for top level bogus struct.

Return :

    None.
    
Note about the recursive use of this routine:

    First pass - flat conversion pass.
    Convert flat part of the struct, then convert the array. For the embedded
    structs or arrays, go in and convert all of them without walking their
    pointers. The embedded conformant arrays should not be walked, only the 
    top level one.
    
    Second pass - converting the pointees.
    It has to increment over the conformant size.
    It needs to go through the flat part of any embedded thing as for bogus
    the pointer members are described only at their level.
    It needs to go through the conf array at the top level only.


--*/
{
    uchar *         pBufferSave;
    uchar *         pBufferMark;
    PFORMAT_STRING  pFormatSave;
    PFORMAT_STRING  pFormatArray;
    PFORMAT_STRING  pFormatPointers;
    uchar           Alignment;
    uchar           fTopLevelStruct;

    // We can't base the fTopLevelStruct flag upon check if
    // pStubMsg->PointerBufferMark == 0 due to dual way this routine is called. 
    // One is when embedded in another struct (or array), another is a recursion
    // from the same level for embedded pointer pass.
    // Luckily, when embedded in an array, the struct can be bogus but not
    // conformant. 

    fTopLevelStruct = ! IS_EMBED_CONF_STRUCT( pStubMsg->uFlags );
    
    pFormatSave = pFormat;

    // Remember the beginning of the structure in the buffer.
    pBufferSave = pStubMsg->Buffer;

    Alignment = pFormat[1];

    pFormat += 4;

    // Get conformant array description.
    if ( *((ushort *)pFormat) )
        {
        long    Dimensions;
        long    i;

        pFormatArray = pFormat + *((signed short *)pFormat);

        // Skip conformant size(s) for embedded struct.

        if ( fTopLevelStruct )
            {
            ALIGN(pStubMsg->Buffer,3);
    
            // Mark the conformance start.
            pStubMsg->BufferMark = pStubMsg->Buffer;
    
            Dimensions = NdrpArrayDimensions( pStubMsg, pFormatArray, FALSE );
    
            if ( ! fEmbeddedPointerPass )
                {
                for ( i = 0; i < Dimensions; i++ )
                    NdrSimpleTypeConvert( pStubMsg, (uchar) FC_LONG );
                }
            else
                {
                pStubMsg->Buffer += Dimensions * 4;
                }
            }
        }
    else
        pFormatArray = 0;

    // Position of the conf size(s) - we will pass it to conf struct routine.
    pBufferMark = pStubMsg->BufferMark;

    pFormat += 2;

    // Get pointer layout description.
    if ( *((ushort *)pFormat) )
        pFormatPointers = pFormat + *((ushort *)pFormat);
    else
        pFormatPointers = 0;

    pFormat += 2;

    ALIGN(pStubMsg->Buffer,Alignment);

    //
    // Check if we are not embedded inside of another complex struct or array.
    //
    // Notice that this check depends on PointerBufferMark that gets changed.
    // Hence, fComplexEntry will come out FALSE for the top level struct during
    // the embedded pointer pass recursive call.

    if ( fTopLevelStruct )
        {
        //
        // Mark PointerBufferMark with a non-null value so complex array's
        // embeddings work properly.
        //
        if ( pStubMsg->PointerBufferMark == 0 )
            pStubMsg->PointerBufferMark = (uchar *) UlongToPtr( 0xffffffff );
        }

    //
    // Convert the flat part of the structure.
    // Or convert pointers of the flat part of the structure.
    //
    SET_EMBED_CONF_STRUCT( pStubMsg->uFlags );

    NdrpStructConvert( pStubMsg,
                       pFormat,
                       pFormatPointers,
                       fEmbeddedPointerPass );

    //
    // Convert any conformant array, if present.
    // This converts the array flat on the first pass and the array's pointees
    // during the recursive pass.
    //
    // Convert the array only for a top level bogus struct but not if there was
    // an embedded conformant struct as this had been done already.

    if ( pFormatArray  &&  fTopLevelStruct  &&
         ! IS_CONF_ARRAY_DONE( pStubMsg->uFlags ) )
        {
        PPRIVATE_CONVERT_ROUTINE    pfnConvert;
        uchar                       fOldIgnore;

        switch ( *pFormatArray )
            {
            case FC_CARRAY :
                pfnConvert = NdrpConformantArrayConvert;
                break;

            case FC_CVARRAY :
                pfnConvert = NdrpConformantVaryingArrayConvert;
                break;

            case FC_BOGUS_ARRAY :
                pfnConvert = NdrpComplexArrayConvert;
                break;

            // case FC_C_CSTRING :
            // case FC_C_BSTRING :
            // case FC_C_SSTRING :
            // case FC_C_WSTRING :

            default :
                //
                // Call the non-conformant string routine since we've
                // already handled the conformance count.
                //
                NdrNonConformantStringConvert( pStubMsg,
                                               pFormatArray,
                                               fEmbeddedPointerPass );
                goto ComplexConvertPointers;
            }

        fOldIgnore = (uchar) pStubMsg->IgnoreEmbeddedPointers;

        //
        // Ignore embedded pointers if fEmbeddedPointerPass is false.
        //
        pStubMsg->IgnoreEmbeddedPointers = ! fEmbeddedPointerPass;

        // Get the outermost max count for unidimensional arrays.
        pStubMsg->MaxCount = *((ulong *)pBufferMark);

        // Mark where conformance count(s) are.
        pStubMsg->BufferMark = pBufferMark;

        (*pfnConvert)( pStubMsg,
                       pFormatArray,
                       fEmbeddedPointerPass );

        pStubMsg->IgnoreEmbeddedPointers = fOldIgnore;
        }

ComplexConvertPointers:

    // Setup for the recursive call.
    // Now start a conversion pass for embedded pointers for the complex
    // struct if we're not embedded inside of another complex struct or array.
    //
    if ( fTopLevelStruct  &&  ! fEmbeddedPointerPass )
        {
        RESET_EMBED_CONF_STRUCT(pStubMsg->uFlags);
        RESET_CONF_ARRAY_DONE( pStubMsg->uFlags );

        // The first pointee.
        pStubMsg->PointerBufferMark = pStubMsg->Buffer;

        // Starting from the conf size again.
        pStubMsg->Buffer = pBufferSave;

        NdrComplexStructConvert( pStubMsg,
                                 pFormatSave,
                                 TRUE );

        pStubMsg->Buffer = pStubMsg->PointerBufferMark;

        pStubMsg->PointerBufferMark = 0;
        }

    // Restore the flag
    if ( fTopLevelStruct )
        {
        RESET_EMBED_CONF_STRUCT(pStubMsg->uFlags);
        RESET_CONF_ARRAY_DONE( pStubMsg->uFlags );
        }
    else
        SET_EMBED_CONF_STRUCT(pStubMsg->uFlags);
}


void
NdrpStructConvert(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat,
    PFORMAT_STRING      pFormatPointers,
    uchar               fEmbeddedPointerPass )
/*++

Routine description :

    Converts any type of structure given a structure layout.
    Does one pass converting flat part or the pointees per fEmbeddedPointerPass.

Arguments :

    pStubMsg                - Pointer to stub message.
    pFormat                 - Structure layout format string description.
    pFormatPointers         - Pointer layout if the structure is complex,
                              otherwise 0.
    fEmbeddedPointerPass    - TRUE if a pass is being to convert only embedded
                              pointers in a struct/array.
                              
    
        We set this to TRUE during our first pass over the structure in which
        we convert the flat part of the structure and ignore embedded pointers.
        This will make any embedded ok structs or ok arrays ignore their
        embedded pointers until the second pass to convert embedded pointers
        (at which point we'll have the correct buffer pointer to where the
        pointees are).
        
    pStubMsg->IgnoreEmbeddedPointers is preserved but does not change anything.
    pStubMsg->BufferMark is preserved and passed on for the embedded conf structs.

Return :

    None.

--*/
{
    PFORMAT_STRING  pFormatComplex;
    uchar           fOldIgnore;
    uchar *         pBufferMarkSave = pStubMsg->BufferMark;

    fOldIgnore = (uchar) pStubMsg->IgnoreEmbeddedPointers;

    pStubMsg->IgnoreEmbeddedPointers = ! fEmbeddedPointerPass;

    //
    // Convert the structure member by member.
    //
    for ( ; ; pFormat++ )
        {
        switch ( *pFormat )
            {
            //
            // simple types
            //
            case FC_CHAR :
            case FC_BYTE :
            case FC_SMALL :
            case FC_WCHAR :
            case FC_SHORT :
            case FC_LONG :
#if defined(__RPC_WIN64__)
            case FC_INT3264 :
            case FC_UINT3264 :
#endif
            case FC_FLOAT :
            case FC_HYPER :
            case FC_DOUBLE :
            case FC_ENUM16 :
            case FC_ENUM32 :
            case FC_ERROR_STATUS_T:
                if ( fEmbeddedPointerPass )
                    {
                    ALIGN(pStubMsg->Buffer,SIMPLE_TYPE_ALIGNMENT(*pFormat));
                    pStubMsg->Buffer += SIMPLE_TYPE_BUFSIZE(*pFormat);
                    }
                else
                    {
                    NdrSimpleTypeConvert( pStubMsg,
                                          *pFormat );
                    }
                break;

            case FC_IGNORE :
                ALIGN(pStubMsg->Buffer,3);
                pStubMsg->Buffer += PTR_WIRE_SIZE;
                break;
                
            case FC_POINTER :
                //
                // We can only get an FC_POINTER in a complex struct's layout.
                // Pointers show up as FC_LONG in ok struct's layouts.
                //
                if ( fEmbeddedPointerPass )
                    {
                    uchar *     pBuffer;
                    uchar       fEmbedStruct = IS_EMBED_CONF_STRUCT( pStubMsg->uFlags );

                    NDR_ASSERT(pFormatPointers != 0,"Internal error");

                    ALIGN(pStubMsg->Buffer,3);

                    pBuffer = pStubMsg->Buffer;

                    pStubMsg->Buffer = pStubMsg->PointerBufferMark;

                    pStubMsg->PointerBufferMark = 0;
                    RESET_EMBED_CONF_STRUCT(pStubMsg->uFlags);

                    NdrpPointerConvert( pStubMsg,
                                        pBuffer,
                                        pFormatPointers );

                    // Restore the flag
                    if ( fEmbedStruct )
                        SET_EMBED_CONF_STRUCT(pStubMsg->uFlags);

                    pStubMsg->PointerBufferMark = pStubMsg->Buffer;

                    pStubMsg->Buffer = pBuffer + PTR_WIRE_SIZE;

                    pFormatPointers += 4;

                    break;
                    }
                else
                    {
                    NdrSimpleTypeConvert( pStubMsg,
                                          (uchar) FC_LONG );
                    }
                break;

            //
            // Embedded structures
            //
            case FC_EMBEDDED_COMPLEX :
                pFormat += 2;

                // Get the type's description.
                pFormatComplex = pFormat + *((signed short UNALIGNED *)pFormat);

                pStubMsg->BufferMark = pBufferMarkSave;

                (*pfnConvertRoutines[ROUTINE_INDEX(*pFormatComplex)])
                ( pStubMsg,
                  pFormatComplex,
                  fEmbeddedPointerPass );  // the argument as it came in

                // Increment the main format string one byte.  The loop
                // will increment it one more byte past the offset field.
                pFormat++;

                break;

            //
            // Unused for endian conversion.
            //
            case FC_ALIGNM2 :
            case FC_ALIGNM4 :
            case FC_ALIGNM8 :
                break;

            case FC_STRUCTPAD1 :
            case FC_STRUCTPAD2 :
            case FC_STRUCTPAD3 :
            case FC_STRUCTPAD4 :
            case FC_STRUCTPAD5 :
            case FC_STRUCTPAD6 :
            case FC_STRUCTPAD7 :
                break;

            case FC_STRUCTPADN :
                // FC_STRUCTPADN 0 <unsigned short>
                pFormat += 3;
                break;

            case FC_PAD :
                break;

            //
            // Done with layout.
            //
            case FC_END :
                pStubMsg->IgnoreEmbeddedPointers = fOldIgnore;
                return;

            default :
                NDR_ASSERT(0,"NdrpStructConvert : Bad format type");
                RpcRaiseException( RPC_S_INTERNAL_ERROR );
                return;
            }
        }

    pStubMsg->BufferMark = pBufferMarkSave;

}


void
NdrFixedArrayConvert(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat,
    uchar               fEmbeddedPointerPass )
/*--

Routine description :

    Converts a fixed array of any number of dimensions.

    Used for FC_SMFARRAY and FC_LGFARRAY.

Arguments :

    pStubMsg                - Pointer to stub message.
    pFormat                 - Array's format string description.
    fEmbeddedPointerPass    - TRUE if a pass is being to convert only embedded
                              pointers in a struct/array.

Return :

    None.

--*/
{
    PFORMAT_STRING  pFormatLayout;
    uchar *         pBufferMark;
    long            Elements;
    uchar           fOldIgnore;

    ALIGN(pStubMsg->Buffer,pFormat[1]);

    pBufferMark = pStubMsg->Buffer;

    // Get the number of array elements.
    Elements = NdrpArrayElements( pStubMsg,
                                  0,
                                  pFormat );

    pFormat += (*pFormat == FC_SMFARRAY) ? 4 : 6;

    if ( *pFormat == FC_PP )
        pFormatLayout = NdrpSkipPointerLayout( pFormat );
    else
        pFormatLayout = pFormat;

    fOldIgnore = (uchar) pStubMsg->IgnoreEmbeddedPointers;

    pStubMsg->IgnoreEmbeddedPointers = TRUE;

    NdrpArrayConvert( pStubMsg,
                      pFormatLayout,
                      Elements,
                      fEmbeddedPointerPass );

    pStubMsg->IgnoreEmbeddedPointers = fOldIgnore;

    if ( *pFormat == FC_PP )
        {
        pStubMsg->BufferMark = pBufferMark;

        NdrpEmbeddedPointerConvert( pStubMsg, pFormat );
        }
}


void
NdrConformantArrayConvert(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat,
    uchar               fEmbeddedPointerPass )
/*--

Routine description :

    Converts top level a one dimensional conformant array.

    Used for FC_CARRAY.

Arguments :

    pStubMsg                - Pointer to stub message.
    pFormat                 - Array's format string description.
    fEmbeddedPointerPass    - TRUE if a pass is being to convert only embedded
                              pointers in a struct/array.

Return :

    None.

--*/
{
    ALIGN(pStubMsg->Buffer,3);

    if ( fEmbeddedPointerPass )
        pStubMsg->Buffer += 4;
    else
        NdrSimpleTypeConvert( pStubMsg, (uchar) FC_LONG );

    pStubMsg->MaxCount = *((long *)(pStubMsg->Buffer - 4));

    NdrpConformantArrayConvert( pStubMsg,
                                pFormat,
                                fEmbeddedPointerPass );
}


void
NdrpConformantArrayConvert(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat,
    uchar               fEmbeddedPointerPass )
/*--

Routine description :

    Private routine for converting a one dimensional conformant array.
    This is the entry point for an embedded conformant array.

Arguments :

    pStubMsg                - Pointer to stub message.
    pFormat                 - Array's format string description.
    fEmbeddedPointerPass    - TRUE if a pass is being to convert only embedded
                              pointers in a struct/array.

Return :

    None.

--*/
{
    PFORMAT_STRING  pFormatLayout;
    uchar *         pBufferMark;
    long            Elements;
    uchar           fOldIgnore;

    Elements = (ulong)pStubMsg->MaxCount;

    if ( ! Elements )
        return;

    ALIGN(pStubMsg->Buffer,pFormat[1]);

    pBufferMark = pStubMsg->Buffer;

    pFormat += 8;
    CORRELATION_DESC_INCREMENT( pFormat );

    if ( *pFormat == FC_PP )
        pFormatLayout = NdrpSkipPointerLayout( pFormat );
    else
        pFormatLayout = pFormat;

    fOldIgnore = (uchar) pStubMsg->IgnoreEmbeddedPointers;

    pStubMsg->IgnoreEmbeddedPointers = TRUE;

    NdrpArrayConvert( pStubMsg,
                      pFormatLayout,
                      Elements,
                      fEmbeddedPointerPass );

    pStubMsg->IgnoreEmbeddedPointers = fOldIgnore;

    if ( *pFormat == FC_PP )
        {
        pStubMsg->BufferMark = pBufferMark;

        pStubMsg->MaxCount = Elements;

        NdrpEmbeddedPointerConvert( pStubMsg, pFormat );
        }
}


void
NdrConformantVaryingArrayConvert(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat,
    uchar               fEmbeddedPointerPass )
/*--

Routine description :

    Converts a top level one dimensional conformant varying array.

    Used for FC_CVARRAY.

Arguments :

    pStubMsg                - Pointer to stub message.
    pFormat                 - Array's format string description.
    fEmbeddedPointerPass    - TRUE if a pass is being to convert only embedded
                              pointers in a struct/array.

Return :

    None.

--*/
{
    ALIGN(pStubMsg->Buffer,3);

    if ( fEmbeddedPointerPass )
        pStubMsg->Buffer += 4;
    else
        NdrSimpleTypeConvert( pStubMsg, (uchar) FC_LONG );

    // We don't care about the max count.

    NdrpConformantVaryingArrayConvert( pStubMsg,
                                       pFormat,
                                       fEmbeddedPointerPass );
}


void
NdrpConformantVaryingArrayConvert(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat,
    uchar               fEmbeddedPointerPass )
/*--

Routine description :

    Private routine for converting a one dimensional conformant varying array.
    This is the entry point for converting an embedded conformant varying
    array.

    Used for FC_CVARRAY.

Arguments :

    pStubMsg                - Pointer to stub message.
    pFormat                 - Array's format string description.
    fEmbeddedPointerPass    - TRUE if a pass is being to convert only embedded
                              pointers in a struct/array.

Return :

    None.

--*/
{
    PFORMAT_STRING  pFormatLayout;
    uchar *         pBufferMark;
    long            Elements;
    uchar           fOldIgnore;

    ALIGN(pStubMsg->Buffer,3);

    // Convert offset and actual count.
    if ( fEmbeddedPointerPass )
        pStubMsg->Buffer += 8;
    else
        {
        NdrSimpleTypeConvert( pStubMsg, (uchar) FC_LONG );
        NdrSimpleTypeConvert( pStubMsg, (uchar) FC_LONG );
        }

    CHECK_AFTER_CONVERT( pStubMsg, pStubMsg->Buffer - 4, 4 );
    Elements = *((long *)(pStubMsg->Buffer - 4));

    if ( ! Elements )
        return;

    ALIGN(pStubMsg->Buffer,pFormat[1]);

    pBufferMark = pStubMsg->Buffer;

    pFormat += 12;
    CORRELATION_DESC_INCREMENT( pFormat );
    CORRELATION_DESC_INCREMENT( pFormat );

    if ( *pFormat == FC_PP )
        pFormatLayout = NdrpSkipPointerLayout( pFormat );
    else
        pFormatLayout = pFormat;

    fOldIgnore = (uchar) pStubMsg->IgnoreEmbeddedPointers;

    pStubMsg->IgnoreEmbeddedPointers = TRUE;

    NdrpArrayConvert( pStubMsg,
                      pFormatLayout,
                      Elements,
                      fEmbeddedPointerPass );

    pStubMsg->IgnoreEmbeddedPointers = fOldIgnore;

    if ( *pFormat == FC_PP )
        {
        pStubMsg->BufferMark = pBufferMark;

        pStubMsg->MaxCount = Elements;

        NdrpEmbeddedPointerConvert( pStubMsg, pFormat );
        }
}


void
NdrVaryingArrayConvert(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat,
    uchar               fEmbeddedPointerPass )
/*--

Routine description :

    Converts a top level or embedded varying array.

    Used for FC_SMVARRAY and FC_LGVARRAY.

Arguments :

    pStubMsg                - Pointer to stub message.
    pFormat                 - Array's format string description.
    fEmbeddedPointerPass    - TRUE if a pass is being to convert only embedded
                              pointers in a struct/array.

Return :

    None.

--*/
{
    PFORMAT_STRING  pFormatLayout;
    uchar *         pBufferMark;
    long            Elements;
    uchar           fOldIgnore;

    ALIGN(pStubMsg->Buffer,3);

    // Convert offset and actual count.
    if ( fEmbeddedPointerPass )
        pStubMsg->Buffer += 8;
    else
        {
        NdrSimpleTypeConvert( pStubMsg, (uchar) FC_LONG );
        NdrSimpleTypeConvert( pStubMsg, (uchar) FC_LONG );
        }

    CHECK_AFTER_CONVERT( pStubMsg, pStubMsg->Buffer - 4, 4 );
    Elements = *((long *)(pStubMsg->Buffer - 4));

    if ( ! Elements )
        return;

    ALIGN(pStubMsg->Buffer,pFormat[1]);

    pBufferMark = pStubMsg->Buffer;

    pFormat += (*pFormat == FC_SMVARRAY) ? 12 : 16;
    CORRELATION_DESC_INCREMENT( pFormat );

    if ( *pFormat == FC_PP )
        pFormatLayout = NdrpSkipPointerLayout( pFormat );
    else
        pFormatLayout = pFormat;

    fOldIgnore = (uchar) pStubMsg->IgnoreEmbeddedPointers;

    pStubMsg->IgnoreEmbeddedPointers = TRUE;

    NdrpArrayConvert( pStubMsg,
                      pFormatLayout,
                      Elements,
                      fEmbeddedPointerPass );

    pStubMsg->IgnoreEmbeddedPointers = fOldIgnore;

    if ( *pFormat == FC_PP )
        {
        pStubMsg->BufferMark = pBufferMark;

        pStubMsg->MaxCount = Elements;

        NdrpEmbeddedPointerConvert( pStubMsg, pFormat );
        }
}


void
NdrComplexArrayConvert(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat,
    uchar               fEmbeddedPointerPass )
/*--

Routine description :

    Converts a top level complex array.

    Used for FC_BOGUS_STRUCT.

Arguments :

    pStubMsg                - Pointer to stub message.
    pFormat                 - Array's format string description.
    fEmbeddedPointerPass    - TRUE if a pass is being to convert only embedded
                              pointers in a struct/array.

Return :

    None.

--*/
{
    long    Dimensions;
    long    i;

    if ( ( *((long UNALIGNED *)(pFormat + 4)) != 0xffffffff ) &&
         ( pStubMsg->pArrayInfo == 0 ) )
        {
        ALIGN(pStubMsg->Buffer,3);

        // Mark where conformance is.
        pStubMsg->BufferMark = pStubMsg->Buffer;

        Dimensions = NdrpArrayDimensions(  pStubMsg, pFormat, FALSE );

       if ( ! fEmbeddedPointerPass )
            {
            for ( i = 0; i < Dimensions; i++ )
                NdrSimpleTypeConvert( pStubMsg, (uchar) FC_LONG );
            }
        else
            pStubMsg->Buffer += Dimensions * 4;
        }

    NdrpComplexArrayConvert( pStubMsg,
                             pFormat,
                             fEmbeddedPointerPass );
}


void
NdrpComplexArrayConvert(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat,
    uchar               fEmbeddedPointerPass )
/*--

Routine description :

    Private routine for converting a complex array.  This is the entry
    point for converting an embedded complex array.

    Used for FC_BOGUS_ARRAY.

Arguments :

    pStubMsg                - Pointer to stub message.
    pFormat                 - Array's format string description.
    fEmbeddedPointerPass    - TRUE if a pass is being to convert only embedded
                              pointers in a struct/array.

Return :

    None.

--*/
{
    ARRAY_INFO      ArrayInfo;
    PARRAY_INFO     pArrayInfo;
    PFORMAT_STRING  pFormatSave;
    uchar *         pBuffer;
    ULONG_PTR       MaxCountSave;
    long            Elements;
    long            Dimension;
    uchar           Alignment;

    //
    // Setup if we are the outer dimension.
    //
    if ( ! pStubMsg->pArrayInfo )
        {
        NdrpInitArrayInfo( pStubMsg,  &ArrayInfo);
        }

    pFormatSave = pFormat;

    pArrayInfo = pStubMsg->pArrayInfo;

    Dimension = pArrayInfo->Dimension;

    // Remember the start of the array in the buffer.
    pBuffer = pStubMsg->Buffer;

    // Get the array alignment.
    Alignment = pFormat[1];

    pFormat += 2;

    // Get number of elements (0 if conformance present).
    Elements = *((ushort *&)pFormat)++;

    //
    // Check for conformance description.
    //
    if ( *((long UNALIGNED *)pFormat) != 0xffffffff )
        {
        Elements = pArrayInfo->BufferConformanceMark[Dimension];
        pStubMsg->MaxCount = Elements;
        }

    MaxCountSave = pStubMsg->MaxCount;

    pFormat += 4;
    CORRELATION_DESC_INCREMENT( pFormat );

    //
    // Check for variance description.
    //
    if ( *((long UNALIGNED *)pFormat) != 0xffffffff )
        {
        long    TotalDimensions;
        long    i;

        if ( Dimension == 0 )
            {
            ALIGN(pStubMsg->Buffer,3);

            pArrayInfo->BufferVarianceMark = (unsigned long *)pStubMsg->Buffer;

            TotalDimensions = NdrpArrayDimensions(  pStubMsg, pFormatSave, TRUE );

            if ( ! fEmbeddedPointerPass )
                {
                //
                // Convert offsets and lengths.
                //
                for ( i = 0; i < TotalDimensions; i++ )
                    {
                    NdrSimpleTypeConvert( pStubMsg, (uchar) FC_LONG );
                    NdrSimpleTypeConvert( pStubMsg, (uchar) FC_LONG );
                    }
                }
            else
                pStubMsg->Buffer += TotalDimensions * 8;
            }

        CHECK_AFTER_CONVERT(  pStubMsg, &pArrayInfo->BufferVarianceMark[(Dimension * 2) + 1], 4 );
        // Overwrite Elements with the actual count.
        Elements = pArrayInfo->BufferVarianceMark[(Dimension * 2) + 1];
        }

    pFormat += 4;
    CORRELATION_DESC_INCREMENT( pFormat );

    if ( Elements )
        {
        BOOL    fComplexEntry;
        uchar   fIsEmbedStruct = ! IS_EMBED_CONF_STRUCT( pStubMsg->uFlags );

        ALIGN(pStubMsg->Buffer,Alignment);
    
        //
        // Check if we are not embedded inside of another complex struct or array.
        //
        if ( fComplexEntry = (pStubMsg->PointerBufferMark == 0) )
            {
            //
            // Mark PointerBufferMark with a non-null value so complex array's
            // or struct's which we embed will get fComplexEntry = false.
            //
            pStubMsg->PointerBufferMark = (uchar *) UlongToPtr( 0xffffffff );
            SET_EMBED_CONF_STRUCT( pStubMsg->uFlags );
            }
    
        NdrpArrayConvert( pStubMsg,
                          pFormat,
                          Elements,
                          fEmbeddedPointerPass );
    
        pArrayInfo->Dimension = Dimension;
    
         //
         // Now convert pointers in the array members.
         //
         if ( ! fEmbeddedPointerPass && fComplexEntry )
            {
            pStubMsg->PointerBufferMark = pStubMsg->Buffer;
    
            pStubMsg->Buffer = pBuffer;
    
            // Restore BufferMark to handle multiD arrays.
            pStubMsg->BufferMark = (uchar *) pArrayInfo->BufferConformanceMark;
    
            // Restore the original max count if we had one.
            pStubMsg->MaxCount = MaxCountSave;
    
            NdrpComplexArrayConvert( pStubMsg,
                                     pFormatSave,
                                     TRUE );
    
            pStubMsg->Buffer = pStubMsg->PointerBufferMark;

            pStubMsg->PointerBufferMark = 0;
            }
        
        // Restore the entry values of these flags.

        if ( fComplexEntry )
            {
            pStubMsg->PointerBufferMark = 0;

            if ( ! fIsEmbedStruct )
                RESET_EMBED_CONF_STRUCT( pStubMsg->uFlags );
            }
        }

    // pArrayInfo must be zero when not valid.
    pStubMsg->pArrayInfo = (Dimension == 0) ? 0 : pArrayInfo;
}


void
NdrpArrayConvert(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat,
    long                Elements,
    uchar               fEmbeddedPointerPass )
/*--

Routine description :

    Private routine for converting any kind of array.

Arguments :

    pStubMsg                - Pointer to stub message.
    pFormat                 - Array's element format string description.
    Elements                - Number of elements in the array.
    fEmbeddedPointerPass    - TRUE if a pass is being to convert only embedded
                              pointers in a struct/array.

Return :

    None.

--*/
{
    PCONVERT_ROUTINE    pfnConvert;
    uchar *             pBufferSave;
    long                Dimension;
    long                i;
    uchar *             pPointerIdMark = 0;

    // Used for FC_RP only.
    pBufferSave = 0;

    switch ( *pFormat )
        {
        case FC_EMBEDDED_COMPLEX :
            //
            // Get the complex type description.
            //
            pFormat += 2;
            pFormat += *((signed short UNALIGNED *)pFormat);

            pfnConvert = pfnConvertRoutines[ROUTINE_INDEX(*pFormat)];
            break;

        case FC_RP :
        case FC_IP :
            // we don't want to change the behavior of these two
            if (! fEmbeddedPointerPass)
                return;

            // fall through otherwise
        case FC_UP :
        case FC_FP :
        case FC_OP :
            pPointerIdMark = pStubMsg->Buffer;

            if ( ! fEmbeddedPointerPass )
            {
                for ( i = 0; i < Elements; i++ )
                    NdrSimpleTypeConvert(pStubMsg, FC_LONG);
                return;
            }

            if ( pStubMsg->PointerBufferMark )
                {
                pBufferSave = pStubMsg->Buffer;

                pStubMsg->Buffer = pStubMsg->PointerBufferMark;

                pStubMsg->PointerBufferMark = 0;
                }

            pfnConvert = (*pFormat == FC_IP) ? NdrInterfacePointerConvert:
                            (PCONVERT_ROUTINE) NdrpPointerConvert ;
            break;

        case FC_RANGE:
                if ( fEmbeddedPointerPass )
                    {
                    ulong RangeSize = Elements * SIMPLE_TYPE_BUFSIZE( pFormat[1] );
                    
                    CHECK_EOB_WITH_WRAP_RAISE_BSD( pStubMsg->Buffer, RangeSize );
                    pStubMsg->Buffer += RangeSize;
                    return;
                    }

                for ( i = 0; i < Elements; i++ )
                    {
                    NdrpRangeConvert( pStubMsg,  pFormat,  fEmbeddedPointerPass);
                    }
                break;
        default :
            //
            // Simple type.
            //
            if ( fEmbeddedPointerPass )
                {
                unsigned long ArrSize = Elements * SIMPLE_TYPE_BUFSIZE(*pFormat);

                CHECK_EOB_WITH_WRAP_RAISE_BSD( pStubMsg->Buffer, ArrSize );
                pStubMsg->Buffer += ArrSize;
                return;
                }

            // Optimize out an array of bytes

            if ( *pFormat == FC_BYTE )
                {
                CHECK_EOB_WITH_WRAP_RAISE_BSD( pStubMsg->Buffer, Elements );
                pStubMsg->Buffer += Elements;

                return;
                }

            for ( i = 0; i < Elements; i++ )
                {
                NdrSimpleTypeConvert( pStubMsg,
                                      *pFormat );
                }

            return;
        }

    if ( ! IS_ARRAY_OR_STRING(*pFormat) )
        {
        pStubMsg->pArrayInfo = 0;
        }
    else
        {
        //
        // If we're dealing with a multidimensional fixed array, then pArrayInfo will
        // be NULL.  For non-fixed multidimensional arrays it will be valid.
        //
        if ( pStubMsg->pArrayInfo )
            Dimension = pStubMsg->pArrayInfo->Dimension;
        }

    if ( pfnConvert == (PCONVERT_ROUTINE) NdrpPointerConvert )
        {
        ALIGN( pPointerIdMark, 3);
        for ( i = 0; i < Elements; i++, pPointerIdMark += PTR_WIRE_SIZE )
            {
            NdrpPointerConvert( pStubMsg,
                                pPointerIdMark,
                                pFormat );
            }
        }
    else
        {
        for ( i = 0; i < Elements; i++ )
            {
            if ( IS_ARRAY_OR_STRING(*pFormat) && pStubMsg->pArrayInfo )
                pStubMsg->pArrayInfo->Dimension = Dimension + 1;

            (*pfnConvert)( pStubMsg,
                           pFormat,
                           fEmbeddedPointerPass );
            }
        }

    if ( pBufferSave )
        {
        pStubMsg->PointerBufferMark = pStubMsg->Buffer;

        pStubMsg->Buffer = pBufferSave;
        }
}


void
NdrConformantStringConvert(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat,
    uchar               fEmbeddedPointerPass )
/*--

Routine description :

    Converts a top level conformant string.

    Used for FC_C_CSTRING, FC_C_WSTRING, FC_C_SSTRING, and FC_C_BSTRING
    (NT Beta2 compatability only).

Arguments :

    pStubMsg                - Pointer to stub message.
    pFormat                 - String's format string description.
    fEmbeddedPointerPass    - TRUE if a pass is being to convert only embedded
                              pointers in a struct/array.

Return :

    None.

--*/
{
    //
    // If this is not part of a multidimensional array then we check if we
    // have to convert the max count.
    //
    if ( pStubMsg->pArrayInfo == 0 )
        {
        ALIGN(pStubMsg->Buffer,3);

        if ( fEmbeddedPointerPass )
            pStubMsg->Buffer += 4;
        else
            NdrSimpleTypeConvert( pStubMsg, (uchar) FC_LONG );
        }

    NdrNonConformantStringConvert( pStubMsg,
                                   pFormat,
                                   fEmbeddedPointerPass );
}


void
NdrNonConformantStringConvert(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat,
    uchar               fEmbeddedPointerPass )
/*--

Routine description :

    Converts a non conformant string.  This routine is also used to convert
    conformant strings and is also the entry point for an embeded conformant
    string.

    Used for FC_CSTRING, FC_WSTRING, FC_SSTRING, FC_BSTRING (NT Beta2
    compatability only), FC_C_CSTRING, FC_C_WSTRING, FC_C_SSTRING, and
    FC_C_BSTRING (NT Beta2 compatability only).

Arguments :

    pStubMsg                - Pointer to stub message.
    pFormat                 - String's format string description.
    fEmbeddedPointerPass    - TRUE if a pass is being to convert only embedded
                              pointers in a struct/array.

Return :

    None.

--*/
{
    uchar * pBuffer;
    long    Elements;

    ALIGN(pStubMsg->Buffer,3);

    if ( fEmbeddedPointerPass )
        pStubMsg->Buffer += 8;
    else
        {
        NdrSimpleTypeConvert( pStubMsg, (uchar) FC_LONG );
        NdrSimpleTypeConvert( pStubMsg, (uchar) FC_LONG );
        }

    CHECK_AFTER_CONVERT(  pStubMsg, pStubMsg->Buffer - 4, 4 );
    Elements = *((long *)(pStubMsg->Buffer - 4));

    pBuffer = pStubMsg->Buffer;

    //
    // Convert string.  Remember that NdrConformantStringConvert calls this
    // routine too.
    //
    switch ( *pFormat )
        {
        case FC_C_CSTRING :
        case FC_C_BSTRING :
        case FC_CSTRING :
        case FC_BSTRING :
            CHECK_ULONG_BOUND( Elements );
            CHECK_EOB_WITH_WRAP_RAISE_BSD( pStubMsg->Buffer , Elements );
        
            if ( ((pStubMsg->RpcMsg->DataRepresentation & NDR_CHAR_REP_MASK) ==
                  NDR_EBCDIC_CHAR) && ! fEmbeddedPointerPass )
                {
                for ( ; Elements-- > 0; )
                    *pBuffer++ = EbcdicToAscii[*pBuffer];
                }
            else
                pBuffer += Elements;

            break;

        case FC_C_WSTRING :
        case FC_WSTRING :
            {
            ulong uSize = MultiplyWithOverflowCheck(Elements, 2 );
            CHECK_ULONG_BOUND( uSize );
            CHECK_EOB_WITH_WRAP_RAISE_BSD( pStubMsg->Buffer , uSize );
        
            if ( ((pStubMsg->RpcMsg->DataRepresentation & NDR_INT_REP_MASK) !=
                  NDR_LOCAL_ENDIAN) && ! fEmbeddedPointerPass )
                {
                for ( ; Elements-- > 0; )
                    *((ushort *&)pBuffer)++ =
                            (*((ushort *)pBuffer) & MASK_A_) >> 8 |
                            (*((ushort *)pBuffer) & MASK__B) << 8 ;
                }
            else
                pBuffer += Elements * 2;
            }
            break;

        case FC_C_SSTRING :
        case FC_SSTRING :
            // Never anything to convert.
            {
            ulong uSize = MultiplyWithOverflowCheck( Elements, pFormat[1]);
            CHECK_ULONG_BOUND( uSize );
            CHECK_EOB_WITH_WRAP_RAISE_BSD( pStubMsg->Buffer , uSize  );

            pBuffer += uSize;
            }
            break;

        default :
            NDR_ASSERT(0,"NdrNonConformantStringConvert : bad format char");
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            return;
        }

    pStubMsg->Buffer = pBuffer;
}


void
NdrEncapsulatedUnionConvert(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat,
    uchar               fEmbeddedPointerPass )
/*--

Routine description :

    Converts an encapsulated union.

    Used for FC_ENCAPSULATED_UNION.

Arguments :

    pStubMsg                - Pointer to stub message.
    pFormat                 - Union's format string description.
    fEmbeddedPointerPass    - TRUE if a pass is being to convert only embedded
                              pointers in a struct/array.

Return :

    None.

--*/
{
    uchar   SwitchType;

    NO_CORRELATION;

    SwitchType = LOW_NIBBLE(pFormat[1]);

    NdrpUnionConvert( pStubMsg,
                      pFormat + 4,
                      SwitchType,
                      fEmbeddedPointerPass );
}


void
NdrNonEncapsulatedUnionConvert(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat,
    uchar               fEmbeddedPointerPass )
/*--

Routine description :

    Converts an non-encapsulated union.

    Used for FC_NON_ENCAPSULATED_UNION.

Arguments :

    pStubMsg                - Pointer to stub message.
    pFormat                 - Union's format string description.
    fEmbeddedPointerPass    - TRUE if a pass is being to convert only embedded
                              pointers in a struct/array.

Return :

    None.

--*/
{
    uchar   SwitchType;

    SwitchType = pFormat[1];

    pFormat += 6;
    CORRELATION_DESC_INCREMENT( pFormat );
    pFormat += *((signed short *)pFormat);

    pFormat += 2;

    NdrpUnionConvert( pStubMsg,
                      pFormat,
                      SwitchType,
                      fEmbeddedPointerPass );
}


void
NdrpUnionConvert(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat,
    uchar               SwitchType,
    uchar               fEmbeddedPointerPass )
/*--

Routine description :

    Private routine for converting a union shared by encapsulated and
    non-encapsulated unions.

Arguments :

    pStubMsg                - Pointer to stub message.
    pFormat                 - Union's format string description.
    SwitchType              - Union's format char switch type.
    fEmbeddedPointerPass    - TRUE if a pass is being to convert only embedded
                              pointers in a struct/array.

Return :

    None.

--*/
{
    long    SwitchIs;
    long    Arms;
    uchar   Alignment;

    //
    // Convert the switch_is().
    //
    if ( fEmbeddedPointerPass )
        {
        ALIGN(pStubMsg->Buffer,SIMPLE_TYPE_ALIGNMENT(SwitchType));
        pStubMsg->Buffer += SIMPLE_TYPE_BUFSIZE(SwitchType);
        }
    else
        {
        NdrSimpleTypeConvert( pStubMsg,
                              SwitchType );
        }


    CHECK_AFTER_CONVERT( pStubMsg, pStubMsg->Buffer - SIMPLE_TYPE_BUFSIZE(SwitchType), SIMPLE_TYPE_BUFSIZE(SwitchType) );
    
    switch ( SwitchType )
        {
        case FC_SMALL :
        case FC_CHAR :
            SwitchIs = (long) *((char *)(pStubMsg->Buffer - 1));
            break;
        case FC_USMALL :
            SwitchIs = (long) *((uchar *)(pStubMsg->Buffer - 1));
            break;
        case FC_SHORT :
        case FC_ENUM16 :
            SwitchIs = (long) *((short *)(pStubMsg->Buffer - 2));
            break;
        case FC_USHORT :
        case FC_WCHAR :
            SwitchIs = (long) *((ushort *)(pStubMsg->Buffer - 2));
            break;
        case FC_LONG :
        case FC_ULONG :
        case FC_ENUM32 :
          // FC_INT3264 gets mapped to FC_LONG.
            SwitchIs = *((long *)(pStubMsg->Buffer - 4));
            break;
        default :
            NDR_ASSERT(0,"NdrpUnionConvert : bad switch value");
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            return;
        }

    //
    // We're at the union_arms<2> field now, which contains both the
    // Microsoft union aligment value and the number of union arms.
    //

    //
    // Get the union alignment (0 if this is a DCE union).
    //
    Alignment = (uchar) ( *((ushort *)pFormat) >> 12 );

    ALIGN(pStubMsg->Buffer,Alignment);

    //
    // Number of arms is the lower 12 bits.
    //
    Arms = (long) ( *((ushort *&)pFormat)++ & 0x0fff);

    for ( ; Arms; Arms-- )
        {
        if ( *((long UNALIGNED *&)pFormat)++ == SwitchIs )
            {
            //
            // Found the right arm, break out.
            //
            break;
            }

        // Else increment format string.
        pFormat += 2;
        }

    //
    // Check if we took the default arm and no default arm is specified.
    //
    if ( ! Arms && (*((ushort *)pFormat) == (ushort) 0xffff) )
        {
        RpcRaiseException( RPC_S_INVALID_TAG );
        }

    //
    // Return if the arm has no description.
    //
    if ( ! *((ushort *)pFormat) )
        return;

    //
    // Get the arm's description.
    //
    // We need a real solution after beta for simple type arms.  This could
    // break if we have a format string larger than about 32K.
    //
    if ( IS_MAGIC_UNION_BYTE(pFormat) )
        {
        // Convert an arm of a simple type

        if ( fEmbeddedPointerPass )
            {
            ALIGN( pStubMsg->Buffer, SIMPLE_TYPE_ALIGNMENT( pFormat[0] ));
            pStubMsg->Buffer += SIMPLE_TYPE_BUFSIZE( pFormat[0] );
            }
        else
            NdrSimpleTypeConvert( pStubMsg, pFormat[0] );

        return;
        }

    pFormat += *((signed short *)pFormat);

    //
    // We have to do special things for a union arm which is a pointer when
    // we have a union embedded in a complex struct or array.
    //
    if ( IS_BASIC_POINTER(*pFormat) && pStubMsg->PointerBufferMark )
        {
        uchar * pBufferMark;

        //
        // If we're not in the embedded pointer pass then just convert the
        // pointer value.
        //
        if ( ! fEmbeddedPointerPass )
            {
            NdrSimpleTypeConvert( pStubMsg, (uchar) FC_LONG );
            return;
            }

        pBufferMark = pStubMsg->Buffer;

        // Align pBufferMark.
        ALIGN(pBufferMark,3);

        pStubMsg->Buffer = pStubMsg->PointerBufferMark;

        pStubMsg->PointerBufferMark = 0;

        //
        // We must call the private pointer conversion routine.
        //
        NdrpPointerConvert( pStubMsg,
                            pBufferMark,
                            pFormat );

        pStubMsg->PointerBufferMark = pStubMsg->Buffer;

        pStubMsg->Buffer = pBufferMark + PTR_WIRE_SIZE;

        return;
        }

    //
    // Union arm of a complex type.
    //
    (*pfnConvertRoutines[ROUTINE_INDEX(*pFormat)])( pStubMsg,
                                                    pFormat,
                                                    fEmbeddedPointerPass );
}


void
NdrByteCountPointerConvert(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat,
    uchar               fEmbeddedPointerPass )
/*--

Routine description :

    Converts a byte count pointer.

    Used for FC_BYTE_COUNT_POINTER.

Arguments :

    pStubMsg                - Pointer to stub message.
    pFormat                 - Byte count pointer format string description.
    fEmbeddedPointerPass    - TRUE if a pass is being to convert only embedded
                              pointers in a struct/array.

Return :

    None.

--*/
{
    if ( pFormat[1] != FC_PAD )
        {
        NdrSimpleTypeConvert( pStubMsg, pFormat[1] );
        return;
        }

    pFormat += 6;
    CORRELATION_DESC_INCREMENT( pFormat );
    pFormat += *((short *)pFormat);

    (*pfnConvertRoutines[ROUTINE_INDEX(*pFormat)])( pStubMsg,
                                                    pFormat,
                                                    fEmbeddedPointerPass );
}


void
NdrXmitOrRepAsConvert(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat,
    uchar               fEmbeddedPointerPass )
/*--

Routine description :

    Converts a transmit as or represent as transmited object.

Arguments :

    pStubMsg                - Pointer to stub message.
    pFormat                 - s format string description.
    fEmbeddedPointerPass    - TRUE if a pass is being to convert only embedded
                              pointers in a struct/array.

Return :

    None.

--*/
{
    PFORMAT_STRING           pTransFormat;

    // Transmitted type cannot have pointers in it, as of now,
    // so if this is a embedded pointer pass, just return.

    if ( fEmbeddedPointerPass )
        return;

    // Go to the transmitted type and convert it.

    pFormat += 8;
    pTransFormat = pFormat + *(short *)pFormat;

    if ( IS_SIMPLE_TYPE( *pTransFormat ) )
        {
        NdrSimpleTypeConvert( pStubMsg, *pTransFormat );
        }
    else
        {
        (*pfnConvertRoutines[ ROUTINE_INDEX( *pTransFormat) ])
                    ( pStubMsg,
                      pTransFormat,
                      fEmbeddedPointerPass );
        }
}


void
NdrUserMarshalConvert(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat,
    uchar               fEmbeddedPointerPass )
/*--

Routine description :

    Converts a user_marshal object using the transmissible type description.

Arguments :

    pStubMsg                - Pointer to stub message.
    pFormat                 - not used
    fEmbeddedPointerPass    - not used


Return :

    None.

--*/
{
    PFORMAT_STRING           pTransFormat;

    // Go to the transmissible type and convert it.

    pFormat += 8;
    pTransFormat = pFormat + *(short *)pFormat;

    if ( IS_SIMPLE_TYPE( *pTransFormat ) )
        {
        if ( fEmbeddedPointerPass )
            return;

        NdrSimpleTypeConvert( pStubMsg, *pTransFormat );
        }
    else
        {
        // It may have pointers in it.

        if ( IS_POINTER_TYPE(*pTransFormat) &&  pStubMsg->PointerBufferMark )
            {
            // Embedded case and the type is a pointer type.

            if ( fEmbeddedPointerPass )
                {
                uchar * BufferSave = pStubMsg->Buffer;

                // Get the pointee type and convert it.

                pStubMsg->Buffer = pStubMsg->PointerBufferMark;

                pTransFormat += 2;
                pTransFormat += *(short *)pTransFormat;

                if ( IS_SIMPLE_TYPE( *pTransFormat ) )
                    {
                    NdrSimpleTypeConvert( pStubMsg, *pTransFormat );
                    }
                else
                    {
                    uchar uFlagsSave;
                    uFlagsSave = pStubMsg->uFlags;
                    RESET_CONF_FLAGS_TO_STANDALONE(pStubMsg->uFlags);
                    // Convert the pointee as if not embedded.

                    pStubMsg->PointerBufferMark = 0;
                    (*pfnConvertRoutines[ ROUTINE_INDEX( *pTransFormat) ])
                            ( pStubMsg,
                              pTransFormat,
                              FALSE );
                    pStubMsg->uFlags = uFlagsSave;

                    // Set the pointee marker behind the converted whole.

                    pStubMsg->PointerBufferMark = pStubMsg->Buffer;
                    }

                // Now step over the original pointer.

                pStubMsg->Buffer = BufferSave;

                ALIGN(pStubMsg->Buffer,3);
                pStubMsg->Buffer += PTR_WIRE_SIZE;
                }
            else
                {
                // Convert the pointer itself only.
                // We can't call ptr convert routine because of the pointee.

                NdrSimpleTypeConvert( pStubMsg, FC_LONG );
                }
            }
        else
            {
            // Non embedded pointer type or
            // (embedded or not) a non-pointer or a non-simple type.
            // Just call the appropriate conversion routine.

            (*pfnConvertRoutines[ ROUTINE_INDEX( *pTransFormat) ])
                    ( pStubMsg,
                      pTransFormat,
                      fEmbeddedPointerPass );
            }
        }
}


unsigned char *  RPC_ENTRY
NdrUserMarshalSimpleTypeConvert(
    unsigned long * pFlags,
    unsigned char * pBuffer,
    unsigned char   FormatChar )
/*--

Routine description :

    Converts a simple type supplied from a user_marshal unmarshaled routine.

    Note that this is *not* supposed to be called when the NDR engine walks
    the wire type description to convert.

Arguments :

    pFlags      - flags as for user_marshal routines: data rep, context.
    pBuffer     - current buffer pointer supplied by the user
    FormatChar  - specifies the type

Return :

    None.

--*/
{
    uchar *             pBufferSave;
    USER_MARSHAL_CB *   pUserCB  = (USER_MARSHAL_CB *)pFlags;
    MIDL_STUB_MESSAGE * pStubMsg = pUserCB->pStubMsg;
    
    if ( pBuffer < pStubMsg->BufferStart  ||  
         pBuffer > pStubMsg->BufferEnd  ||
         ( (*pFlags >> 16)  !=
           (pStubMsg->RpcMsg->DataRepresentation & (ulong)0x0000FFFF) )
       )
        RpcRaiseException( RPC_S_INVALID_ARG );

    pBufferSave = pStubMsg->Buffer;

    pStubMsg->Buffer = pBuffer;
    NdrSimpleTypeConvert( pStubMsg, FormatChar );
    pBuffer = pStubMsg->Buffer;

    pStubMsg->Buffer = pBufferSave;

    return ( pBuffer );
}


void
NdrInterfacePointerConvert(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat,
    uchar               fEmbeddedPointerPass )
/*--

Routine description :

    Converts an interface pointer.

Arguments :

    pStubMsg                - Pointer to stub message.
    pFormat                 - Xmit/Rep as format string description.
    fEmbeddedPointerPass    - TRUE if a pass is being to convert only embedded
                              pointers in a struct/array.

Return :

    None.

--*/
{
    uchar * pBufferSave;
    unsigned long *pLength;

    // Align for getting the pointer's node id.
    ALIGN( pStubMsg->Buffer, 0x3 );

    //
    // If we're ignoring embedded pointers then we simply convert the pointer's
    // node id and return.  Otherwise, we skip the pointer's node id and
    // continue on to convert the actuall interface pointer.
    //
    if ( ! fEmbeddedPointerPass )
        {
        NdrSimpleTypeConvert( pStubMsg, FC_LONG );

        if ( pStubMsg->PointerBufferMark != 0 )
            return;

        pStubMsg->Buffer -= PTR_WIRE_SIZE;
        }

    // Skip the pointer's node id, which will already have been converted.
    //
    // Also, we don't have the pointee if the pointer itself is null;
    // An interface pointer behaves like a unique pointer.

    if ( *((long *&)pStubMsg->Buffer)++ == 0 )
        return;

    //
    // Check if we're handling pointers in a complex struct, and re-set the
    // Buffer pointer if so.
    //
    if ( pStubMsg->PointerBufferMark )
        {
        pBufferSave = pStubMsg->Buffer;

        pStubMsg->Buffer = pStubMsg->PointerBufferMark;

        pStubMsg->PointerBufferMark = 0;
        }
    else
        pBufferSave = 0;

    //
    // Convert the conformant size and the count field.
    //
    NdrSimpleTypeConvert( pStubMsg, FC_LONG );

    pLength = (unsigned long *) pStubMsg->Buffer;
    NdrSimpleTypeConvert( pStubMsg, FC_LONG );

    // Skip over the marshalled interface pointer.

    CHECK_EOB_WITH_WRAP_RAISE_IB( pStubMsg->Buffer , *pLength );

    pStubMsg->Buffer += *pLength;

    //
    // Re-set the buffer pointer if needed.
    //
    if ( pBufferSave )
        {
        pStubMsg->PointerBufferMark = pStubMsg->Buffer;

        pStubMsg->Buffer = pBufferSave;
        }
}


void
NdrContextHandleConvert(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat,
    uchar               fEmbeddedPointerPass )
/*--

Routine description :

    Conversion routine for context handles, only increments the buffer.

Arguments :

    pStubMsg                - Pointer to stub message.
    pFormat                 - Format string description.
    fEmbeddedPointerPass    - TRUE if a pass is being to convert only embedded
                              pointers in a struct/array.

Return :

    None.

--*/
{
    ALIGN(pStubMsg->Buffer,0x3);

    CHECK_EOB_RAISE_BSD( pStubMsg->Buffer + CONTEXT_HANDLE_WIRE_SIZE );
    pStubMsg->Buffer += CONTEXT_HANDLE_WIRE_SIZE;
}


void
NdrpEmbeddedPointerConvert(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat )
/*--

Routine description :

    Private routine for converting an array's or a structure's embedded
    pointers.

Arguments :

    pStubMsg                - Pointer to stub message.
    pFormat                 - Pointer layout format string description.

Return :

    None.

--*/
{
    uchar * pBufferMark;
    uchar * pBufferPointer;
    uchar * pBufferSave;
    ULONG_PTR MaxCountSave;

    MaxCountSave = pStubMsg->MaxCount;

    //
    // Return if we're ignoring embedded pointers.
    //
    if ( pStubMsg->IgnoreEmbeddedPointers )
        return;

    //
    // Check if we're handling pointers in a complex struct, and re-set the
    // Buffer pointer if so.
    //
    if ( pStubMsg->PointerBufferMark )
        {
        pBufferSave = pStubMsg->Buffer;

        pStubMsg->Buffer = pStubMsg->PointerBufferMark;

        pStubMsg->PointerBufferMark = 0;
        }
    else
        pBufferSave = 0;

    pBufferMark = pStubMsg->BufferMark;

    //
    // Increment past the FC_PP and pad.
    //
    pFormat += 2;

    for (;;)
        {
        if ( *pFormat == FC_END )
            {
            if ( pBufferSave )
                {
                pStubMsg->PointerBufferMark = pStubMsg->Buffer;

                pStubMsg->Buffer = pBufferSave;
                }
            return;
            }

        // Check for a repeat pointer.
        if ( *pFormat != FC_NO_REPEAT )
            {
            pStubMsg->MaxCount = MaxCountSave;

            pFormat = NdrpEmbeddedRepeatPointerConvert( pStubMsg, pFormat );

            // Continue to the next pointer.
            continue;
            }

        // Increment to the buffer pointer offset.
        pFormat += 4;

        pBufferPointer = pBufferMark + *((signed short *&)pFormat)++;

        NdrpPointerConvert( pStubMsg,
                            pBufferPointer,
                            pFormat );

        // Increment past the pointer description.
        pFormat += 4;
        }
}


PFORMAT_STRING
NdrpEmbeddedRepeatPointerConvert(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat )
/*--

Routine description :

    Private routine for converting an array's embedded pointers.

Arguments :

    pStubMsg                - Pointer to stub message.
    pFormat                 - Pointer layout format string description.

Return :

    Format string pointer past the array's pointer layout description.

--*/
{
    uchar *         pBufPtr;
    uchar *         pBufferMark;
    PFORMAT_STRING  pFormatSave;
    ulong           RepeatCount,RepeatIncrement, Pointers, PointersSave;

    pBufferMark = pStubMsg->BufferMark;

    // Get the repeat count.
    switch ( *pFormat )
        {
        case FC_FIXED_REPEAT :
            pFormat += 2;

            RepeatCount = *((ushort *)pFormat);

            break;

        case FC_VARIABLE_REPEAT :
            RepeatCount = (ulong)pStubMsg->MaxCount;

            break;

        default :
            NDR_ASSERT(0,"NdrpEmbeddedRepeatPointerConvert : bad format");
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            return 0;
        }

    pFormat += 2;

    RepeatIncrement = *((ushort *&)pFormat)++;

    // array_offset is ignored
    pFormat += 2;

    // Get number of pointers.
    Pointers = *((ushort *&)pFormat)++;

    pFormatSave = pFormat;
    PointersSave = Pointers;

    for ( ; RepeatCount--;
            pBufferMark += RepeatIncrement )
        {
        pFormat = pFormatSave;
        Pointers = PointersSave;

        for ( ; Pointers--; )
            {
            pFormat += 2;

            pBufPtr = pBufferMark + *((signed short *&)pFormat)++;

            NdrpPointerConvert( pStubMsg,
                                pBufPtr,
                                pFormat );

            // Increment past the pointer description.
            pFormat += 4;
            }
        }

    return pFormatSave + PointersSave * 8;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr20\freep.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright <c> 1993 Microsoft Corporation

Module Name :

    freep.h

Abtract :

    Contains private sizing routine definitions.

Author :

    David Kays  dkays   October 1993

Revision History :

--------------------------------------------------------------------*/

typedef     void    (RPC_ENTRY * PFREE_ROUTINE)( 
						PMIDL_STUB_MESSAGE, 
					 	uchar *, 
						PFORMAT_STRING
					);

IMPORTSPEC
extern const PFREE_ROUTINE * pfnFreeRoutines;

void 
NdrpUnionFree(
	PMIDL_STUB_MESSAGE		pStubMsg,
    uchar *          		pMemory,
    PFORMAT_STRING   		pFormat,
	long					SwitchIs
    );

void
NdrpEmbeddedPointerFree(
	PMIDL_STUB_MESSAGE		pStubMsg,
    uchar *          		pMemory,
    PFORMAT_STRING   		pFormat
    );

PFORMAT_STRING
NdrpEmbeddedRepeatPointerFree(
	PMIDL_STUB_MESSAGE		pStubMsg,
    uchar *   		        pMemory,
    PFORMAT_STRING 		    pFormat
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr20\fmtstr.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       FMTSTR.H
//
//  Contents:   Canned format string for 32bit and 64bit platforms.
//              This format string is generated from oandr.idl 
//              checkin ndr directory but not being built generally.
//              build mode: /Oicf /no_robust
//
//
//  History:    July 2nd, 1999 YongQu  Created
//
//----------------------------------------------------------------------------

#ifndef _FMTSTR_H_
#define _FMTSTR_H_

#if !defined(__RPC_WIN64__)

#define TYPE_FORMAT_STRING_SIZE   2364
#else
#define TYPE_FORMAT_STRING_SIZE   2508
#endif

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;


#if !defined(__RPC_WIN64__)

// 32 bit format string
#define BSTR_TYPE_FS_OFFSET 26              //bstr
#define LPWSTR_TYPE_FS_OFFSET 38            // lpwstr
#define LPSTR_TYPE_FS_OFFSET 42             // lpstr
#define EMBEDDED_LPWSTR_TYPE_FS_OFFSET 1028 // lpwstr
#define EMBEDDED_LPSTR_TYPE_FS_OFFSET 1036  // lpstr
#define VARIANT_TYPE_FS_OFFSET 986          // variant
#define DISPATCH_TYPE_FS_OFFSET 344         // pdispatch
#define UNKNOWN_TYPE_FS_OFFSET 326          // punk
#define DECIMAL_TYPE_FS_OFFSET 946          // decimal
#define SAFEARRAY_TYPE_FS_OFFSET 996        // pSafeArray


#define BYREF_BSTR_TYPE_FS_OFFSET 1014      // pBSTR
#define BYREF_LPWSTR_TYPE_FS_OFFSET 1024    // ppwsz
#define BYREF_LPSTR_TYPE_FS_OFFSET 1032     // ppsz
#define BYREF_VARIANT_TYPE_FS_OFFSET 1048   // pVariant
#define BYREF_DISPATCH_TYPE_FS_OFFSET 1062  // ppdistatch
#define BYREF_UNKNOWN_TYPE_FS_OFFSET 1058   // ppunk
#define BYREF_DECIMAL_TYPE_FS_OFFSET 958    // pDecimal
#define BYREF_SAFEARRAY_TYPE_FS_OFFSET 1082 // ppSafeArray


#define STREAM_TYPE_FS_OFFSET 1092          // pStream
#define BYREF_STREAM_TYPE_FS_OFFSET 1110    // ppStream
#define STORAGE_TYPE_FS_OFFSET 1114         // pStorage
#define BYREF_STORAGE_TYPE_FS_OFFSET 1132   // ppStorage
#define FILETIME_TYPE_FS_OFFSET 854         // FileTime
#define BYREF_FILETIME_TYPE_FS_OFFSET 1136  // pfileTime


#define BYREF_I1_TYPE_FS_OFFSET 898
#define BYREF_I2_TYPE_FS_OFFSET 902
#define BYREF_I4_TYPE_FS_OFFSET 906
#define BYREF_R4_TYPE_FS_OFFSET 910
#define BYREF_R8_TYPE_FS_OFFSET 914


#define I1_VECTOR_TYPE_FS_OFFSET 1150       // cab
#define I2_VECTOR_TYPE_FS_OFFSET 774        // cai
#define I4_VECTOR_TYPE_FS_OFFSET 804        // cal
#define R4_VECTOR_TYPE_FS_OFFSET 1180       // caflt
#define ERROR_VECTOR_TYPE_FS_OFFSET 804             // cascode
#define I8_VECTOR_TYPE_FS_OFFSET 1214               // cah
#define R8_VECTOR_TYPE_FS_OFFSET 1244       // cadbl
#define CY_VECTOR_TYPE_FS_OFFSET 1214       // cacy
#define DATE_VECTOR_TYPE_FS_OFFSET 1244             // cadate
#define FILETIME_VECTOR_TYPE_FS_OFFSET 1278         // cafiletime
#define BSTR_VECTOR_TYPE_FS_OFFSET 1434             // cabstr
#define BSTRBLOB_VECTOR_TYPE_FS_OFFSET 1486         // cabstrblob
#define LPSTR_VECTOR_TYPE_FS_OFFSET 1536            // calpstr
#define LPWSTR_VECTOR_TYPE_FS_OFFSET 1586           // calpwstr


#define BYREF_I1_VECTOR_TYPE_FS_OFFSET 2304 // pcab
#define BYREF_I2_VECTOR_TYPE_FS_OFFSET 2308 // pcai
#define BYREF_I4_VECTOR_TYPE_FS_OFFSET 2312 // pcal
#define BYREF_R4_VECTOR_TYPE_FS_OFFSET 2316 // pcaflt
#define BYREF_ERROR_VECTOR_TYPE_FS_OFFSET 2312      // pcascode
#define BYREF_I8_VECTOR_TYPE_FS_OFFSET 2320         // pcah
#define BYREF_R8_VECTOR_TYPE_FS_OFFSET 2324 // pcadbl
#define BYREF_CY_VECTOR_TYPE_FS_OFFSET 2320 // pcacy
#define BYREF_DATE_VECTOR_TYPE_FS_OFFSET 2324       // pcadate
#define BYREF_FILETIME_VECTOR_TYPE_FS_OFFSET 2328   // pcafiletime
#define BYREF_BSTR_VECTOR_TYPE_FS_OFFSET 2340       // pcabstr
#define BYREF_BSTRBLOB_VECTOR_TYPE_FS_OFFSET 2344   // pcabstrblob
#define BYREF_LPSTR_VECTOR_TYPE_FS_OFFSET 2348      // pcalpstr
#define BYREF_LPWSTR_VECTOR_TYPE_FS_OFFSET 2352     // pcalpwstr



/* File created by MIDL compiler version 5.03.0276 */
/* at Fri Jul 02 14:15:57 1999
 */
/* Compiler settings for oandr.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data
    VC __declspec() decoration level:
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/


static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x12, 0x0,	/* FC_UP */
/*  4 */	NdrFcShort( 0xc ),	/* Offset= 12 (16) */
/*  6 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/*  8 */	NdrFcShort( 0x2 ),	/* 2 */
/* 10 */	0x9,		/* Corr desc: FC_ULONG */
			0x0,		/*  */
/* 12 */	NdrFcShort( 0xfffc ),	/* -4 */
/* 14 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 16 */	
			0x17,		/* FC_CSTRUCT */
			0x3,		/* 3 */
/* 18 */	NdrFcShort( 0x8 ),	/* 8 */
/* 20 */	NdrFcShort( 0xfffffff2 ),	/* Offset= -14 (6) */
/* 22 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 24 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 26 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 28 */	NdrFcShort( 0x0 ),	/* 0 */
/* 30 */	NdrFcShort( 0x4 ),	/* 4 */
/* 32 */	NdrFcShort( 0x0 ),	/* 0 */
/* 34 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (2) */
/* 36 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 38 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 40 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 42 */	
			0x22,		/* FC_C_CSTRING */
			0x5c,		/* FC_PAD */
/* 44 */	
			0x12, 0x0,	/* FC_UP */
/* 46 */	NdrFcShort( 0x398 ),	/* Offset= 920 (966) */
/* 48 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0x9,		/* FC_ULONG */
/* 50 */	0x7,		/* Corr desc: FC_USHORT */
			0x0,		/*  */
/* 52 */	NdrFcShort( 0xfff8 ),	/* -8 */
/* 54 */	NdrFcShort( 0x2 ),	/* Offset= 2 (56) */
/* 56 */	NdrFcShort( 0x10 ),	/* 16 */
/* 58 */	NdrFcShort( 0x2b ),	/* 43 */
/* 60 */	NdrFcLong( 0x3 ),	/* 3 */
/* 64 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 66 */	NdrFcLong( 0x11 ),	/* 17 */
/* 70 */	NdrFcShort( 0x8001 ),	/* Simple arm type: FC_BYTE */
/* 72 */	NdrFcLong( 0x2 ),	/* 2 */
/* 76 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 78 */	NdrFcLong( 0x4 ),	/* 4 */
/* 82 */	NdrFcShort( 0x800a ),	/* Simple arm type: FC_FLOAT */
/* 84 */	NdrFcLong( 0x5 ),	/* 5 */
/* 88 */	NdrFcShort( 0x800c ),	/* Simple arm type: FC_DOUBLE */
/* 90 */	NdrFcLong( 0xb ),	/* 11 */
/* 94 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 96 */	NdrFcLong( 0xa ),	/* 10 */
/* 100 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 102 */	NdrFcLong( 0x6 ),	/* 6 */
/* 106 */	NdrFcShort( 0xd6 ),	/* Offset= 214 (320) */
/* 108 */	NdrFcLong( 0x7 ),	/* 7 */
/* 112 */	NdrFcShort( 0x800c ),	/* Simple arm type: FC_DOUBLE */
/* 114 */	NdrFcLong( 0x8 ),	/* 8 */
/* 118 */	NdrFcShort( 0xffffff8c ),	/* Offset= -116 (2) */
/* 120 */	NdrFcLong( 0xd ),	/* 13 */
/* 124 */	NdrFcShort( 0xca ),	/* Offset= 202 (326) */
/* 126 */	NdrFcLong( 0x9 ),	/* 9 */
/* 130 */	NdrFcShort( 0xd6 ),	/* Offset= 214 (344) */
/* 132 */	NdrFcLong( 0x2000 ),	/* 8192 */
/* 136 */	NdrFcShort( 0xe2 ),	/* Offset= 226 (362) */
/* 138 */	NdrFcLong( 0x24 ),	/* 36 */
/* 142 */	NdrFcShort( 0x2f0 ),	/* Offset= 752 (894) */
/* 144 */	NdrFcLong( 0x4024 ),	/* 16420 */
/* 148 */	NdrFcShort( 0x2ea ),	/* Offset= 746 (894) */
/* 150 */	NdrFcLong( 0x4011 ),	/* 16401 */
/* 154 */	NdrFcShort( 0x2e8 ),	/* Offset= 744 (898) */
/* 156 */	NdrFcLong( 0x4002 ),	/* 16386 */
/* 160 */	NdrFcShort( 0x2e6 ),	/* Offset= 742 (902) */
/* 162 */	NdrFcLong( 0x4003 ),	/* 16387 */
/* 166 */	NdrFcShort( 0x2e4 ),	/* Offset= 740 (906) */
/* 168 */	NdrFcLong( 0x4004 ),	/* 16388 */
/* 172 */	NdrFcShort( 0x2e2 ),	/* Offset= 738 (910) */
/* 174 */	NdrFcLong( 0x4005 ),	/* 16389 */
/* 178 */	NdrFcShort( 0x2e0 ),	/* Offset= 736 (914) */
/* 180 */	NdrFcLong( 0x400b ),	/* 16395 */
/* 184 */	NdrFcShort( 0x2ce ),	/* Offset= 718 (902) */
/* 186 */	NdrFcLong( 0x400a ),	/* 16394 */
/* 190 */	NdrFcShort( 0x2cc ),	/* Offset= 716 (906) */
/* 192 */	NdrFcLong( 0x4006 ),	/* 16390 */
/* 196 */	NdrFcShort( 0x2d2 ),	/* Offset= 722 (918) */
/* 198 */	NdrFcLong( 0x4007 ),	/* 16391 */
/* 202 */	NdrFcShort( 0x2c8 ),	/* Offset= 712 (914) */
/* 204 */	NdrFcLong( 0x4008 ),	/* 16392 */
/* 208 */	NdrFcShort( 0x2ca ),	/* Offset= 714 (922) */
/* 210 */	NdrFcLong( 0x400d ),	/* 16397 */
/* 214 */	NdrFcShort( 0x2c8 ),	/* Offset= 712 (926) */
/* 216 */	NdrFcLong( 0x4009 ),	/* 16393 */
/* 220 */	NdrFcShort( 0x2c6 ),	/* Offset= 710 (930) */
/* 222 */	NdrFcLong( 0x6000 ),	/* 24576 */
/* 226 */	NdrFcShort( 0x2c4 ),	/* Offset= 708 (934) */
/* 228 */	NdrFcLong( 0x400c ),	/* 16396 */
/* 232 */	NdrFcShort( 0x2c2 ),	/* Offset= 706 (938) */
/* 234 */	NdrFcLong( 0x10 ),	/* 16 */
/* 238 */	NdrFcShort( 0x8002 ),	/* Simple arm type: FC_CHAR */
/* 240 */	NdrFcLong( 0x12 ),	/* 18 */
/* 244 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 246 */	NdrFcLong( 0x13 ),	/* 19 */
/* 250 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 252 */	NdrFcLong( 0x16 ),	/* 22 */
/* 256 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 258 */	NdrFcLong( 0x17 ),	/* 23 */
/* 262 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 264 */	NdrFcLong( 0xe ),	/* 14 */
/* 268 */	NdrFcShort( 0x2a6 ),	/* Offset= 678 (946) */
/* 270 */	NdrFcLong( 0x400e ),	/* 16398 */
/* 274 */	NdrFcShort( 0x2ac ),	/* Offset= 684 (958) */
/* 276 */	NdrFcLong( 0x4010 ),	/* 16400 */
/* 280 */	NdrFcShort( 0x2aa ),	/* Offset= 682 (962) */
/* 282 */	NdrFcLong( 0x4012 ),	/* 16402 */
/* 286 */	NdrFcShort( 0x268 ),	/* Offset= 616 (902) */
/* 288 */	NdrFcLong( 0x4013 ),	/* 16403 */
/* 292 */	NdrFcShort( 0x266 ),	/* Offset= 614 (906) */
/* 294 */	NdrFcLong( 0x4016 ),	/* 16406 */
/* 298 */	NdrFcShort( 0x260 ),	/* Offset= 608 (906) */
/* 300 */	NdrFcLong( 0x4017 ),	/* 16407 */
/* 304 */	NdrFcShort( 0x25a ),	/* Offset= 602 (906) */
/* 306 */	NdrFcLong( 0x0 ),	/* 0 */
/* 310 */	NdrFcShort( 0x0 ),	/* Offset= 0 (310) */
/* 312 */	NdrFcLong( 0x1 ),	/* 1 */
/* 316 */	NdrFcShort( 0x0 ),	/* Offset= 0 (316) */
/* 318 */	NdrFcShort( 0xffffffff ),	/* Offset= -1 (317) */
/* 320 */	
			0x15,		/* FC_STRUCT */
			0x7,		/* 7 */
/* 322 */	NdrFcShort( 0x8 ),	/* 8 */
/* 324 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 326 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 328 */	NdrFcLong( 0x0 ),	/* 0 */
/* 332 */	NdrFcShort( 0x0 ),	/* 0 */
/* 334 */	NdrFcShort( 0x0 ),	/* 0 */
/* 336 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 338 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 340 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 342 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 344 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 346 */	NdrFcLong( 0x20400 ),	/* 132096 */
/* 350 */	NdrFcShort( 0x0 ),	/* 0 */
/* 352 */	NdrFcShort( 0x0 ),	/* 0 */
/* 354 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 356 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 358 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 360 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 362 */	
			0x12, 0x10,	/* FC_UP [pointer_deref] */
/* 364 */	NdrFcShort( 0x2 ),	/* Offset= 2 (366) */
/* 366 */	
			0x12, 0x0,	/* FC_UP */
/* 368 */	NdrFcShort( 0x1fc ),	/* Offset= 508 (876) */
/* 370 */	
			0x2a,		/* FC_ENCAPSULATED_UNION */
			0x49,		/* 73 */
/* 372 */	NdrFcShort( 0x18 ),	/* 24 */
/* 374 */	NdrFcShort( 0xa ),	/* 10 */
/* 376 */	NdrFcLong( 0x8 ),	/* 8 */
/* 380 */	NdrFcShort( 0x58 ),	/* Offset= 88 (468) */
/* 382 */	NdrFcLong( 0xd ),	/* 13 */
/* 386 */	NdrFcShort( 0x78 ),	/* Offset= 120 (506) */
/* 388 */	NdrFcLong( 0x9 ),	/* 9 */
/* 392 */	NdrFcShort( 0x94 ),	/* Offset= 148 (540) */
/* 394 */	NdrFcLong( 0xc ),	/* 12 */
/* 398 */	NdrFcShort( 0xbc ),	/* Offset= 188 (586) */
/* 400 */	NdrFcLong( 0x24 ),	/* 36 */
/* 404 */	NdrFcShort( 0x114 ),	/* Offset= 276 (680) */
/* 406 */	NdrFcLong( 0x800d ),	/* 32781 */
/* 410 */	NdrFcShort( 0x130 ),	/* Offset= 304 (714) */
/* 412 */	NdrFcLong( 0x10 ),	/* 16 */
/* 416 */	NdrFcShort( 0x148 ),	/* Offset= 328 (744) */
/* 418 */	NdrFcLong( 0x2 ),	/* 2 */
/* 422 */	NdrFcShort( 0x160 ),	/* Offset= 352 (774) */
/* 424 */	NdrFcLong( 0x3 ),	/* 3 */
/* 428 */	NdrFcShort( 0x178 ),	/* Offset= 376 (804) */
/* 430 */	NdrFcLong( 0x14 ),	/* 20 */
/* 434 */	NdrFcShort( 0x190 ),	/* Offset= 400 (834) */
/* 436 */	NdrFcShort( 0xffffffff ),	/* Offset= -1 (435) */
/* 438 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 440 */	NdrFcShort( 0x4 ),	/* 4 */
/* 442 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 444 */	NdrFcShort( 0x0 ),	/* 0 */
/* 446 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 448 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 450 */	NdrFcShort( 0x4 ),	/* 4 */
/* 452 */	NdrFcShort( 0x0 ),	/* 0 */
/* 454 */	NdrFcShort( 0x1 ),	/* 1 */
/* 456 */	NdrFcShort( 0x0 ),	/* 0 */
/* 458 */	NdrFcShort( 0x0 ),	/* 0 */
/* 460 */	0x12, 0x0,	/* FC_UP */
/* 462 */	NdrFcShort( 0xfffffe42 ),	/* Offset= -446 (16) */
/* 464 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 466 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 468 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 470 */	NdrFcShort( 0x8 ),	/* 8 */
/* 472 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 474 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 476 */	NdrFcShort( 0x4 ),	/* 4 */
/* 478 */	NdrFcShort( 0x4 ),	/* 4 */
/* 480 */	0x11, 0x0,	/* FC_RP */
/* 482 */	NdrFcShort( 0xffffffd4 ),	/* Offset= -44 (438) */
/* 484 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 486 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 488 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 490 */	NdrFcShort( 0x0 ),	/* 0 */
/* 492 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 494 */	NdrFcShort( 0x0 ),	/* 0 */
/* 496 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 500 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 502 */	NdrFcShort( 0xffffff50 ),	/* Offset= -176 (326) */
/* 504 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 506 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 508 */	NdrFcShort( 0x8 ),	/* 8 */
/* 510 */	NdrFcShort( 0x0 ),	/* 0 */
/* 512 */	NdrFcShort( 0x6 ),	/* Offset= 6 (518) */
/* 514 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 516 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 518 */	
			0x11, 0x0,	/* FC_RP */
/* 520 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (488) */
/* 522 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 524 */	NdrFcShort( 0x0 ),	/* 0 */
/* 526 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 528 */	NdrFcShort( 0x0 ),	/* 0 */
/* 530 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 534 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 536 */	NdrFcShort( 0xffffff40 ),	/* Offset= -192 (344) */
/* 538 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 540 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 542 */	NdrFcShort( 0x8 ),	/* 8 */
/* 544 */	NdrFcShort( 0x0 ),	/* 0 */
/* 546 */	NdrFcShort( 0x6 ),	/* Offset= 6 (552) */
/* 548 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 550 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 552 */	
			0x11, 0x0,	/* FC_RP */
/* 554 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (522) */
/* 556 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 558 */	NdrFcShort( 0x4 ),	/* 4 */
/* 560 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 562 */	NdrFcShort( 0x0 ),	/* 0 */
/* 564 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 566 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 568 */	NdrFcShort( 0x4 ),	/* 4 */
/* 570 */	NdrFcShort( 0x0 ),	/* 0 */
/* 572 */	NdrFcShort( 0x1 ),	/* 1 */
/* 574 */	NdrFcShort( 0x0 ),	/* 0 */
/* 576 */	NdrFcShort( 0x0 ),	/* 0 */
/* 578 */	0x12, 0x0,	/* FC_UP */
/* 580 */	NdrFcShort( 0x182 ),	/* Offset= 386 (966) */
/* 582 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 584 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 586 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 588 */	NdrFcShort( 0x8 ),	/* 8 */
/* 590 */	NdrFcShort( 0x0 ),	/* 0 */
/* 592 */	NdrFcShort( 0x6 ),	/* Offset= 6 (598) */
/* 594 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 596 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 598 */	
			0x11, 0x0,	/* FC_RP */
/* 600 */	NdrFcShort( 0xffffffd4 ),	/* Offset= -44 (556) */
/* 602 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 604 */	NdrFcLong( 0x2f ),	/* 47 */
/* 608 */	NdrFcShort( 0x0 ),	/* 0 */
/* 610 */	NdrFcShort( 0x0 ),	/* 0 */
/* 612 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 614 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 616 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 618 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 620 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 622 */	NdrFcShort( 0x1 ),	/* 1 */
/* 624 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 626 */	NdrFcShort( 0x4 ),	/* 4 */
/* 628 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 630 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 632 */	NdrFcShort( 0x10 ),	/* 16 */
/* 634 */	NdrFcShort( 0x0 ),	/* 0 */
/* 636 */	NdrFcShort( 0xa ),	/* Offset= 10 (646) */
/* 638 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 640 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 642 */	NdrFcShort( 0xffffffd8 ),	/* Offset= -40 (602) */
/* 644 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 646 */	
			0x12, 0x0,	/* FC_UP */
/* 648 */	NdrFcShort( 0xffffffe4 ),	/* Offset= -28 (620) */
/* 650 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 652 */	NdrFcShort( 0x4 ),	/* 4 */
/* 654 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 656 */	NdrFcShort( 0x0 ),	/* 0 */
/* 658 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 660 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 662 */	NdrFcShort( 0x4 ),	/* 4 */
/* 664 */	NdrFcShort( 0x0 ),	/* 0 */
/* 666 */	NdrFcShort( 0x1 ),	/* 1 */
/* 668 */	NdrFcShort( 0x0 ),	/* 0 */
/* 670 */	NdrFcShort( 0x0 ),	/* 0 */
/* 672 */	0x12, 0x0,	/* FC_UP */
/* 674 */	NdrFcShort( 0xffffffd4 ),	/* Offset= -44 (630) */
/* 676 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 678 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 680 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 682 */	NdrFcShort( 0x8 ),	/* 8 */
/* 684 */	NdrFcShort( 0x0 ),	/* 0 */
/* 686 */	NdrFcShort( 0x6 ),	/* Offset= 6 (692) */
/* 688 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 690 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 692 */	
			0x11, 0x0,	/* FC_RP */
/* 694 */	NdrFcShort( 0xffffffd4 ),	/* Offset= -44 (650) */
/* 696 */	
			0x1d,		/* FC_SMFARRAY */
			0x0,		/* 0 */
/* 698 */	NdrFcShort( 0x8 ),	/* 8 */
/* 700 */	0x2,		/* FC_CHAR */
			0x5b,		/* FC_END */
/* 702 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 704 */	NdrFcShort( 0x10 ),	/* 16 */
/* 706 */	0x8,		/* FC_LONG */
			0x6,		/* FC_SHORT */
/* 708 */	0x6,		/* FC_SHORT */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 710 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffff1 ),	/* Offset= -15 (696) */
			0x5b,		/* FC_END */
/* 714 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 716 */	NdrFcShort( 0x18 ),	/* 24 */
/* 718 */	NdrFcShort( 0x0 ),	/* 0 */
/* 720 */	NdrFcShort( 0xa ),	/* Offset= 10 (730) */
/* 722 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 724 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 726 */	NdrFcShort( 0xffffffe8 ),	/* Offset= -24 (702) */
/* 728 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 730 */	
			0x11, 0x0,	/* FC_RP */
/* 732 */	NdrFcShort( 0xffffff0c ),	/* Offset= -244 (488) */
/* 734 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 736 */	NdrFcShort( 0x1 ),	/* 1 */
/* 738 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 740 */	NdrFcShort( 0x0 ),	/* 0 */
/* 742 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 744 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 746 */	NdrFcShort( 0x8 ),	/* 8 */
/* 748 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 750 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 752 */	NdrFcShort( 0x4 ),	/* 4 */
/* 754 */	NdrFcShort( 0x4 ),	/* 4 */
/* 756 */	0x12, 0x0,	/* FC_UP */
/* 758 */	NdrFcShort( 0xffffffe8 ),	/* Offset= -24 (734) */
/* 760 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 762 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 764 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/* 766 */	NdrFcShort( 0x2 ),	/* 2 */
/* 768 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 770 */	NdrFcShort( 0x0 ),	/* 0 */
/* 772 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 774 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 776 */	NdrFcShort( 0x8 ),	/* 8 */
/* 778 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 780 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 782 */	NdrFcShort( 0x4 ),	/* 4 */
/* 784 */	NdrFcShort( 0x4 ),	/* 4 */
/* 786 */	0x12, 0x0,	/* FC_UP */
/* 788 */	NdrFcShort( 0xffffffe8 ),	/* Offset= -24 (764) */
/* 790 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 792 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 794 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 796 */	NdrFcShort( 0x4 ),	/* 4 */
/* 798 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 800 */	NdrFcShort( 0x0 ),	/* 0 */
/* 802 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 804 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 806 */	NdrFcShort( 0x8 ),	/* 8 */
/* 808 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 810 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 812 */	NdrFcShort( 0x4 ),	/* 4 */
/* 814 */	NdrFcShort( 0x4 ),	/* 4 */
/* 816 */	0x12, 0x0,	/* FC_UP */
/* 818 */	NdrFcShort( 0xffffffe8 ),	/* Offset= -24 (794) */
/* 820 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 822 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 824 */	
			0x1b,		/* FC_CARRAY */
			0x7,		/* 7 */
/* 826 */	NdrFcShort( 0x8 ),	/* 8 */
/* 828 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 830 */	NdrFcShort( 0x0 ),	/* 0 */
/* 832 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 834 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 836 */	NdrFcShort( 0x8 ),	/* 8 */
/* 838 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 840 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 842 */	NdrFcShort( 0x4 ),	/* 4 */
/* 844 */	NdrFcShort( 0x4 ),	/* 4 */
/* 846 */	0x12, 0x0,	/* FC_UP */
/* 848 */	NdrFcShort( 0xffffffe8 ),	/* Offset= -24 (824) */
/* 850 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 852 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 854 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 856 */	NdrFcShort( 0x8 ),	/* 8 */
/* 858 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 860 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 862 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 864 */	NdrFcShort( 0x8 ),	/* 8 */
/* 866 */	0x7,		/* Corr desc: FC_USHORT */
			0x0,		/*  */
/* 868 */	NdrFcShort( 0xffd8 ),	/* -40 */
/* 870 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 872 */	NdrFcShort( 0xffffffee ),	/* Offset= -18 (854) */
/* 874 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 876 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 878 */	NdrFcShort( 0x28 ),	/* 40 */
/* 880 */	NdrFcShort( 0xffffffee ),	/* Offset= -18 (862) */
/* 882 */	NdrFcShort( 0x0 ),	/* Offset= 0 (882) */
/* 884 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 886 */	0x38,		/* FC_ALIGNM4 */
			0x8,		/* FC_LONG */
/* 888 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 890 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffdf7 ),	/* Offset= -521 (370) */
			0x5b,		/* FC_END */
/* 894 */	
			0x12, 0x0,	/* FC_UP */
/* 896 */	NdrFcShort( 0xfffffef6 ),	/* Offset= -266 (630) */
/* 898 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 900 */	0x1,		/* FC_BYTE */
			0x5c,		/* FC_PAD */
/* 902 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 904 */	0x6,		/* FC_SHORT */
			0x5c,		/* FC_PAD */
/* 906 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 908 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 910 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 912 */	0xa,		/* FC_FLOAT */
			0x5c,		/* FC_PAD */
/* 914 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 916 */	0xc,		/* FC_DOUBLE */
			0x5c,		/* FC_PAD */
/* 918 */	
			0x12, 0x0,	/* FC_UP */
/* 920 */	NdrFcShort( 0xfffffda8 ),	/* Offset= -600 (320) */
/* 922 */	
			0x12, 0x10,	/* FC_UP [pointer_deref] */
/* 924 */	NdrFcShort( 0xfffffc66 ),	/* Offset= -922 (2) */
/* 926 */	
			0x12, 0x10,	/* FC_UP [pointer_deref] */
/* 928 */	NdrFcShort( 0xfffffda6 ),	/* Offset= -602 (326) */
/* 930 */	
			0x12, 0x10,	/* FC_UP [pointer_deref] */
/* 932 */	NdrFcShort( 0xfffffdb4 ),	/* Offset= -588 (344) */
/* 934 */	
			0x12, 0x10,	/* FC_UP [pointer_deref] */
/* 936 */	NdrFcShort( 0xfffffdc2 ),	/* Offset= -574 (362) */
/* 938 */	
			0x12, 0x10,	/* FC_UP [pointer_deref] */
/* 940 */	NdrFcShort( 0x2 ),	/* Offset= 2 (942) */
/* 942 */	
			0x12, 0x0,	/* FC_UP */
/* 944 */	NdrFcShort( 0x16 ),	/* Offset= 22 (966) */
/* 946 */	
			0x15,		/* FC_STRUCT */
			0x7,		/* 7 */
/* 948 */	NdrFcShort( 0x10 ),	/* 16 */
/* 950 */	0x6,		/* FC_SHORT */
			0x1,		/* FC_BYTE */
/* 952 */	0x1,		/* FC_BYTE */
			0x38,		/* FC_ALIGNM4 */
/* 954 */	0x8,		/* FC_LONG */
			0x39,		/* FC_ALIGNM8 */
/* 956 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 958 */	
			0x12, 0x0,	/* FC_UP */
/* 960 */	NdrFcShort( 0xfffffff2 ),	/* Offset= -14 (946) */
/* 962 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 964 */	0x2,		/* FC_CHAR */
			0x5c,		/* FC_PAD */
/* 966 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x7,		/* 7 */
/* 968 */	NdrFcShort( 0x20 ),	/* 32 */
/* 970 */	NdrFcShort( 0x0 ),	/* 0 */
/* 972 */	NdrFcShort( 0x0 ),	/* Offset= 0 (972) */
/* 974 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 976 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 978 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 980 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 982 */	NdrFcShort( 0xfffffc5a ),	/* Offset= -934 (48) */
/* 984 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 986 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 988 */	NdrFcShort( 0x1 ),	/* 1 */
/* 990 */	NdrFcShort( 0x10 ),	/* 16 */
/* 992 */	NdrFcShort( 0x0 ),	/* 0 */
/* 994 */	NdrFcShort( 0xfffffc4a ),	/* Offset= -950 (44) */
/* 996 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 998 */	NdrFcShort( 0x2 ),	/* 2 */
/* 1000 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1002 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1004 */	NdrFcShort( 0xfffffd7e ),	/* Offset= -642 (362) */
/* 1006 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 1008 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1014) */
/* 1010 */	
			0x13, 0x0,	/* FC_OP */
/* 1012 */	NdrFcShort( 0xfffffc1c ),	/* Offset= -996 (16) */
/* 1014 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 1016 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1018 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1020 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1022 */	NdrFcShort( 0xfffffff4 ),	/* Offset= -12 (1010) */
/* 1024 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 1026 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1028) */
/* 1028 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 1030 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 1032 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 1034 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1036) */
/* 1036 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 1038 */	
			0x22,		/* FC_C_CSTRING */
			0x5c,		/* FC_PAD */
/* 1040 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 1042 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1048) */
/* 1044 */	
			0x13, 0x0,	/* FC_OP */
/* 1046 */	NdrFcShort( 0xffffffb0 ),	/* Offset= -80 (966) */
/* 1048 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 1050 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1052 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1054 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1056 */	NdrFcShort( 0xfffffff4 ),	/* Offset= -12 (1044) */
/* 1058 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 1060 */	NdrFcShort( 0xfffffd22 ),	/* Offset= -734 (326) */
/* 1062 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 1064 */	NdrFcShort( 0xfffffd30 ),	/* Offset= -720 (344) */
/* 1066 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 1068 */	NdrFcShort( 0xffffff86 ),	/* Offset= -122 (946) */
/* 1070 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 1072 */	NdrFcShort( 0xa ),	/* Offset= 10 (1082) */
/* 1074 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 1076 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1078) */
/* 1078 */	
			0x13, 0x0,	/* FC_OP */
/* 1080 */	NdrFcShort( 0xffffff34 ),	/* Offset= -204 (876) */
/* 1082 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 1084 */	NdrFcShort( 0x2 ),	/* 2 */
/* 1086 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1088 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1090 */	NdrFcShort( 0xfffffff0 ),	/* Offset= -16 (1074) */
/* 1092 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1094 */	NdrFcLong( 0xc ),	/* 12 */
/* 1098 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1100 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1102 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 1104 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 1106 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 1108 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 1110 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 1112 */	NdrFcShort( 0xffffffec ),	/* Offset= -20 (1092) */
/* 1114 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1116 */	NdrFcLong( 0xb ),	/* 11 */
/* 1120 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1122 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1124 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 1126 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 1128 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 1130 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 1132 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 1134 */	NdrFcShort( 0xffffffec ),	/* Offset= -20 (1114) */
/* 1136 */	
			0x12, 0x0,	/* FC_UP */
/* 1138 */	NdrFcShort( 0xfffffee4 ),	/* Offset= -284 (854) */
/* 1140 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 1142 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1144 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1146 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1148 */	0x2,		/* FC_CHAR */
			0x5b,		/* FC_END */
/* 1150 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1152 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1154 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1156 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1158 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1160 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1162 */	0x12, 0x0,	/* FC_UP */
/* 1164 */	NdrFcShort( 0xffffffe8 ),	/* Offset= -24 (1140) */
/* 1166 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1168 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1170 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 1172 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1174 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1176 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1178 */	0xa,		/* FC_FLOAT */
			0x5b,		/* FC_END */
/* 1180 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1182 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1184 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1186 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1188 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1190 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1192 */	0x12, 0x0,	/* FC_UP */
/* 1194 */	NdrFcShort( 0xffffffe8 ),	/* Offset= -24 (1170) */
/* 1196 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1198 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1200 */	
			0x1b,		/* FC_CARRAY */
			0x7,		/* 7 */
/* 1202 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1204 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1206 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1208 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1210 */	NdrFcShort( 0xfffffc86 ),	/* Offset= -890 (320) */
/* 1212 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1214 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1216 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1218 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1220 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1222 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1224 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1226 */	0x12, 0x0,	/* FC_UP */
/* 1228 */	NdrFcShort( 0xffffffe4 ),	/* Offset= -28 (1200) */
/* 1230 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1232 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1234 */	
			0x1b,		/* FC_CARRAY */
			0x7,		/* 7 */
/* 1236 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1238 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1240 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1242 */	0xc,		/* FC_DOUBLE */
			0x5b,		/* FC_END */
/* 1244 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1246 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1248 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1250 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1252 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1254 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1256 */	0x12, 0x0,	/* FC_UP */
/* 1258 */	NdrFcShort( 0xffffffe8 ),	/* Offset= -24 (1234) */
/* 1260 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1262 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1264 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 1266 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1268 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1270 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1272 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1274 */	NdrFcShort( 0xfffffe5c ),	/* Offset= -420 (854) */
/* 1276 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1278 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1280 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1282 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1284 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1286 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1288 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1290 */	0x12, 0x0,	/* FC_UP */
/* 1292 */	NdrFcShort( 0xffffffe4 ),	/* Offset= -28 (1264) */
/* 1294 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1296 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1298 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 1300 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1302 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1304 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1306 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1308 */	NdrFcShort( 0xfffffda2 ),	/* Offset= -606 (702) */
/* 1310 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1312 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1314 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1316 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1318 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1320 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1322 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1324 */	0x12, 0x0,	/* FC_UP */
/* 1326 */	NdrFcShort( 0xffffffe4 ),	/* Offset= -28 (1298) */
/* 1328 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1330 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1332 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 1334 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1336 */	0x10,		/* Corr desc:  field pointer,  */
			0x59,		/* FC_CALLBACK */
/* 1338 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1340 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 1342 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1344 */	NdrFcShort( 0xc ),	/* 12 */
/* 1346 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1348 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1350 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1352 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1354 */	0x12, 0x0,	/* FC_UP */
/* 1356 */	NdrFcShort( 0xffffffe8 ),	/* Offset= -24 (1332) */
/* 1358 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1360 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1362 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1364 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 1366 */	NdrFcShort( 0xc ),	/* 12 */
/* 1368 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1370 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1372 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1374 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 1376 */	NdrFcShort( 0xc ),	/* 12 */
/* 1378 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1380 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1382 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1384 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1386 */	0x12, 0x0,	/* FC_UP */
/* 1388 */	NdrFcShort( 0xffffffc8 ),	/* Offset= -56 (1332) */
/* 1390 */	
			0x5b,		/* FC_END */

			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 1392 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffcd ),	/* Offset= -51 (1342) */
			0x5b,		/* FC_END */
/* 1396 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1398 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1400 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1402 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1404 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1406 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1408 */	0x12, 0x0,	/* FC_UP */
/* 1410 */	NdrFcShort( 0xffffffd2 ),	/* Offset= -46 (1364) */
/* 1412 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1414 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1416 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 1418 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1420 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1422 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1424 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 1428 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1430 */	NdrFcShort( 0xfffffa84 ),	/* Offset= -1404 (26) */
/* 1432 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1434 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1436 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1438 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1440 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1442 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1444 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1446 */	0x12, 0x0,	/* FC_UP */
/* 1448 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (1416) */
/* 1450 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1452 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1454 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 1456 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1458 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1460 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1462 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1464 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 1466 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1468 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1470 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1472 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1474 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1476 */	0x12, 0x0,	/* FC_UP */
/* 1478 */	NdrFcShort( 0xfffffd18 ),	/* Offset= -744 (734) */
/* 1480 */	
			0x5b,		/* FC_END */

			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 1482 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffd1d ),	/* Offset= -739 (744) */
			0x5b,		/* FC_END */
/* 1486 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1488 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1490 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1492 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1494 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1496 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1498 */	0x12, 0x0,	/* FC_UP */
/* 1500 */	NdrFcShort( 0xffffffd2 ),	/* Offset= -46 (1454) */
/* 1502 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1504 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1506 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 1508 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1510 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1512 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1514 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1516 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 1518 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1520 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1522 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1524 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1526 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1528 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 1530 */	
			0x22,		/* FC_C_CSTRING */
			0x5c,		/* FC_PAD */
/* 1532 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1534 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1536 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1538 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1540 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1542 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1544 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1546 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1548 */	0x12, 0x0,	/* FC_UP */
/* 1550 */	NdrFcShort( 0xffffffd4 ),	/* Offset= -44 (1506) */
/* 1552 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1554 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1556 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 1558 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1560 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1562 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1564 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1566 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 1568 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1570 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1572 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1574 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1576 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1578 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 1580 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 1582 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1584 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1586 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1588 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1590 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1592 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1594 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1596 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1598 */	0x12, 0x0,	/* FC_UP */
/* 1600 */	NdrFcShort( 0xffffffd4 ),	/* Offset= -44 (1556) */
/* 1602 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1604 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1606 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0x7,		/* FC_USHORT */
/* 1608 */	0x0,		/* Corr desc:  */
			0x59,		/* FC_CALLBACK */
/* 1610 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1612 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1614) */
/* 1614 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1616 */	NdrFcShort( 0x61 ),	/* 97 */
/* 1618 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1622 */	NdrFcShort( 0x0 ),	/* Offset= 0 (1622) */
/* 1624 */	NdrFcLong( 0x1 ),	/* 1 */
/* 1628 */	NdrFcShort( 0x0 ),	/* Offset= 0 (1628) */
/* 1630 */	NdrFcLong( 0x10 ),	/* 16 */
/* 1634 */	NdrFcShort( 0x8002 ),	/* Simple arm type: FC_CHAR */
/* 1636 */	NdrFcLong( 0x11 ),	/* 17 */
/* 1640 */	NdrFcShort( 0x8002 ),	/* Simple arm type: FC_CHAR */
/* 1642 */	NdrFcLong( 0x2 ),	/* 2 */
/* 1646 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 1648 */	NdrFcLong( 0x12 ),	/* 18 */
/* 1652 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 1654 */	NdrFcLong( 0x3 ),	/* 3 */
/* 1658 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 1660 */	NdrFcLong( 0x13 ),	/* 19 */
/* 1664 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 1666 */	NdrFcLong( 0x16 ),	/* 22 */
/* 1670 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 1672 */	NdrFcLong( 0x17 ),	/* 23 */
/* 1676 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 1678 */	NdrFcLong( 0xe ),	/* 14 */
/* 1682 */	NdrFcShort( 0xfffffaae ),	/* Offset= -1362 (320) */
/* 1684 */	NdrFcLong( 0x14 ),	/* 20 */
/* 1688 */	NdrFcShort( 0xfffffaa8 ),	/* Offset= -1368 (320) */
/* 1690 */	NdrFcLong( 0x15 ),	/* 21 */
/* 1694 */	NdrFcShort( 0xfffffaa2 ),	/* Offset= -1374 (320) */
/* 1696 */	NdrFcLong( 0x4 ),	/* 4 */
/* 1700 */	NdrFcShort( 0x800a ),	/* Simple arm type: FC_FLOAT */
/* 1702 */	NdrFcLong( 0x5 ),	/* 5 */
/* 1706 */	NdrFcShort( 0x800c ),	/* Simple arm type: FC_DOUBLE */
/* 1708 */	NdrFcLong( 0xb ),	/* 11 */
/* 1712 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 1714 */	NdrFcLong( 0xffff ),	/* 65535 */
/* 1718 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 1720 */	NdrFcLong( 0xa ),	/* 10 */
/* 1724 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 1726 */	NdrFcLong( 0x6 ),	/* 6 */
/* 1730 */	NdrFcShort( 0xfffffa7e ),	/* Offset= -1410 (320) */
/* 1732 */	NdrFcLong( 0x7 ),	/* 7 */
/* 1736 */	NdrFcShort( 0x800c ),	/* Simple arm type: FC_DOUBLE */
/* 1738 */	NdrFcLong( 0x40 ),	/* 64 */
/* 1742 */	NdrFcShort( 0xfffffc88 ),	/* Offset= -888 (854) */
/* 1744 */	NdrFcLong( 0x48 ),	/* 72 */
/* 1748 */	NdrFcShort( 0x1c6 ),	/* Offset= 454 (2202) */
/* 1750 */	NdrFcLong( 0x47 ),	/* 71 */
/* 1754 */	NdrFcShort( 0x1c4 ),	/* Offset= 452 (2206) */
/* 1756 */	NdrFcLong( 0x8 ),	/* 8 */
/* 1760 */	NdrFcShort( 0xfffff93a ),	/* Offset= -1734 (26) */
/* 1762 */	NdrFcLong( 0xfff ),	/* 4095 */
/* 1766 */	NdrFcShort( 0xfffffc02 ),	/* Offset= -1022 (744) */
/* 1768 */	NdrFcLong( 0x41 ),	/* 65 */
/* 1772 */	NdrFcShort( 0xfffffbfc ),	/* Offset= -1028 (744) */
/* 1774 */	NdrFcLong( 0x46 ),	/* 70 */
/* 1778 */	NdrFcShort( 0xfffffbf6 ),	/* Offset= -1034 (744) */
/* 1780 */	NdrFcLong( 0x1e ),	/* 30 */
/* 1784 */	NdrFcShort( 0x1aa ),	/* Offset= 426 (2210) */
/* 1786 */	NdrFcLong( 0x1f ),	/* 31 */
/* 1790 */	NdrFcShort( 0x1a8 ),	/* Offset= 424 (2214) */
/* 1792 */	NdrFcLong( 0xd ),	/* 13 */
/* 1796 */	NdrFcShort( 0xfffffa42 ),	/* Offset= -1470 (326) */
/* 1798 */	NdrFcLong( 0x9 ),	/* 9 */
/* 1802 */	NdrFcShort( 0xfffffa4e ),	/* Offset= -1458 (344) */
/* 1804 */	NdrFcLong( 0x42 ),	/* 66 */
/* 1808 */	NdrFcShort( 0xfffffd34 ),	/* Offset= -716 (1092) */
/* 1810 */	NdrFcLong( 0x44 ),	/* 68 */
/* 1814 */	NdrFcShort( 0xfffffd2e ),	/* Offset= -722 (1092) */
/* 1816 */	NdrFcLong( 0x43 ),	/* 67 */
/* 1820 */	NdrFcShort( 0xfffffd3e ),	/* Offset= -706 (1114) */
/* 1822 */	NdrFcLong( 0x45 ),	/* 69 */
/* 1826 */	NdrFcShort( 0xfffffd38 ),	/* Offset= -712 (1114) */
/* 1828 */	NdrFcLong( 0x49 ),	/* 73 */
/* 1832 */	NdrFcShort( 0x182 ),	/* Offset= 386 (2218) */
/* 1834 */	NdrFcLong( 0x2010 ),	/* 8208 */
/* 1838 */	NdrFcShort( 0xfffffcb6 ),	/* Offset= -842 (996) */
/* 1840 */	NdrFcLong( 0x2011 ),	/* 8209 */
/* 1844 */	NdrFcShort( 0xfffffcb0 ),	/* Offset= -848 (996) */
/* 1846 */	NdrFcLong( 0x2002 ),	/* 8194 */
/* 1850 */	NdrFcShort( 0xfffffcaa ),	/* Offset= -854 (996) */
/* 1852 */	NdrFcLong( 0x2012 ),	/* 8210 */
/* 1856 */	NdrFcShort( 0xfffffca4 ),	/* Offset= -860 (996) */
/* 1858 */	NdrFcLong( 0x2003 ),	/* 8195 */
/* 1862 */	NdrFcShort( 0xfffffc9e ),	/* Offset= -866 (996) */
/* 1864 */	NdrFcLong( 0x2013 ),	/* 8211 */
/* 1868 */	NdrFcShort( 0xfffffc98 ),	/* Offset= -872 (996) */
/* 1870 */	NdrFcLong( 0x2016 ),	/* 8214 */
/* 1874 */	NdrFcShort( 0xfffffc92 ),	/* Offset= -878 (996) */
/* 1876 */	NdrFcLong( 0x2017 ),	/* 8215 */
/* 1880 */	NdrFcShort( 0xfffffc8c ),	/* Offset= -884 (996) */
/* 1882 */	NdrFcLong( 0x2004 ),	/* 8196 */
/* 1886 */	NdrFcShort( 0xfffffc86 ),	/* Offset= -890 (996) */
/* 1888 */	NdrFcLong( 0x2005 ),	/* 8197 */
/* 1892 */	NdrFcShort( 0xfffffc80 ),	/* Offset= -896 (996) */
/* 1894 */	NdrFcLong( 0x2006 ),	/* 8198 */
/* 1898 */	NdrFcShort( 0xfffffc7a ),	/* Offset= -902 (996) */
/* 1900 */	NdrFcLong( 0x2007 ),	/* 8199 */
/* 1904 */	NdrFcShort( 0xfffffc74 ),	/* Offset= -908 (996) */
/* 1906 */	NdrFcLong( 0x2008 ),	/* 8200 */
/* 1910 */	NdrFcShort( 0xfffffc6e ),	/* Offset= -914 (996) */
/* 1912 */	NdrFcLong( 0x200b ),	/* 8203 */
/* 1916 */	NdrFcShort( 0xfffffc68 ),	/* Offset= -920 (996) */
/* 1918 */	NdrFcLong( 0x200e ),	/* 8206 */
/* 1922 */	NdrFcShort( 0xfffffc62 ),	/* Offset= -926 (996) */
/* 1924 */	NdrFcLong( 0x2009 ),	/* 8201 */
/* 1928 */	NdrFcShort( 0xfffffc5c ),	/* Offset= -932 (996) */
/* 1930 */	NdrFcLong( 0x200d ),	/* 8205 */
/* 1934 */	NdrFcShort( 0xfffffc56 ),	/* Offset= -938 (996) */
/* 1936 */	NdrFcLong( 0x200a ),	/* 8202 */
/* 1940 */	NdrFcShort( 0xfffffc50 ),	/* Offset= -944 (996) */
/* 1942 */	NdrFcLong( 0x200c ),	/* 8204 */
/* 1946 */	NdrFcShort( 0xfffffc4a ),	/* Offset= -950 (996) */
/* 1948 */	NdrFcLong( 0x1010 ),	/* 4112 */
/* 1952 */	NdrFcShort( 0xfffffcde ),	/* Offset= -802 (1150) */
/* 1954 */	NdrFcLong( 0x1011 ),	/* 4113 */
/* 1958 */	NdrFcShort( 0xfffffcd8 ),	/* Offset= -808 (1150) */
/* 1960 */	NdrFcLong( 0x1002 ),	/* 4098 */
/* 1964 */	NdrFcShort( 0xfffffb5a ),	/* Offset= -1190 (774) */
/* 1966 */	NdrFcLong( 0x1012 ),	/* 4114 */
/* 1970 */	NdrFcShort( 0xfffffb54 ),	/* Offset= -1196 (774) */
/* 1972 */	NdrFcLong( 0x1003 ),	/* 4099 */
/* 1976 */	NdrFcShort( 0xfffffb6c ),	/* Offset= -1172 (804) */
/* 1978 */	NdrFcLong( 0x1013 ),	/* 4115 */
/* 1982 */	NdrFcShort( 0xfffffb66 ),	/* Offset= -1178 (804) */
/* 1984 */	NdrFcLong( 0x1014 ),	/* 4116 */
/* 1988 */	NdrFcShort( 0xfffffcfa ),	/* Offset= -774 (1214) */
/* 1990 */	NdrFcLong( 0x1015 ),	/* 4117 */
/* 1994 */	NdrFcShort( 0xfffffcf4 ),	/* Offset= -780 (1214) */
/* 1996 */	NdrFcLong( 0x1004 ),	/* 4100 */
/* 2000 */	NdrFcShort( 0xfffffccc ),	/* Offset= -820 (1180) */
/* 2002 */	NdrFcLong( 0x1005 ),	/* 4101 */
/* 2006 */	NdrFcShort( 0xfffffd06 ),	/* Offset= -762 (1244) */
/* 2008 */	NdrFcLong( 0x100b ),	/* 4107 */
/* 2012 */	NdrFcShort( 0xfffffb2a ),	/* Offset= -1238 (774) */
/* 2014 */	NdrFcLong( 0x100a ),	/* 4106 */
/* 2018 */	NdrFcShort( 0xfffffb42 ),	/* Offset= -1214 (804) */
/* 2020 */	NdrFcLong( 0x1006 ),	/* 4102 */
/* 2024 */	NdrFcShort( 0xfffffcd6 ),	/* Offset= -810 (1214) */
/* 2026 */	NdrFcLong( 0x1007 ),	/* 4103 */
/* 2030 */	NdrFcShort( 0xfffffcee ),	/* Offset= -786 (1244) */
/* 2032 */	NdrFcLong( 0x1040 ),	/* 4160 */
/* 2036 */	NdrFcShort( 0xfffffd0a ),	/* Offset= -758 (1278) */
/* 2038 */	NdrFcLong( 0x1048 ),	/* 4168 */
/* 2042 */	NdrFcShort( 0xfffffd26 ),	/* Offset= -730 (1312) */
/* 2044 */	NdrFcLong( 0x1047 ),	/* 4167 */
/* 2048 */	NdrFcShort( 0xfffffd74 ),	/* Offset= -652 (1396) */
/* 2050 */	NdrFcLong( 0x1008 ),	/* 4104 */
/* 2054 */	NdrFcShort( 0xfffffd94 ),	/* Offset= -620 (1434) */
/* 2056 */	NdrFcLong( 0x1fff ),	/* 8191 */
/* 2060 */	NdrFcShort( 0xfffffdc2 ),	/* Offset= -574 (1486) */
/* 2062 */	NdrFcLong( 0x101e ),	/* 4126 */
/* 2066 */	NdrFcShort( 0xfffffdee ),	/* Offset= -530 (1536) */
/* 2068 */	NdrFcLong( 0x101f ),	/* 4127 */
/* 2072 */	NdrFcShort( 0xfffffe1a ),	/* Offset= -486 (1586) */
/* 2074 */	NdrFcLong( 0x100c ),	/* 4108 */
/* 2078 */	NdrFcShort( 0xd2 ),	/* Offset= 210 (2288) */
/* 2080 */	NdrFcLong( 0x4010 ),	/* 16400 */
/* 2084 */	NdrFcShort( 0xfffffb9e ),	/* Offset= -1122 (962) */
/* 2086 */	NdrFcLong( 0x4011 ),	/* 16401 */
/* 2090 */	NdrFcShort( 0xfffffb98 ),	/* Offset= -1128 (962) */
/* 2092 */	NdrFcLong( 0x4002 ),	/* 16386 */
/* 2096 */	NdrFcShort( 0xfffffb56 ),	/* Offset= -1194 (902) */
/* 2098 */	NdrFcLong( 0x4012 ),	/* 16402 */
/* 2102 */	NdrFcShort( 0xfffffb50 ),	/* Offset= -1200 (902) */
/* 2104 */	NdrFcLong( 0x4003 ),	/* 16387 */
/* 2108 */	NdrFcShort( 0xfffffb4e ),	/* Offset= -1202 (906) */
/* 2110 */	NdrFcLong( 0x4013 ),	/* 16403 */
/* 2114 */	NdrFcShort( 0xfffffb48 ),	/* Offset= -1208 (906) */
/* 2116 */	NdrFcLong( 0x4016 ),	/* 16406 */
/* 2120 */	NdrFcShort( 0xfffffb42 ),	/* Offset= -1214 (906) */
/* 2122 */	NdrFcLong( 0x4017 ),	/* 16407 */
/* 2126 */	NdrFcShort( 0xfffffb3c ),	/* Offset= -1220 (906) */
/* 2128 */	NdrFcLong( 0x4004 ),	/* 16388 */
/* 2132 */	NdrFcShort( 0xfffffb3a ),	/* Offset= -1222 (910) */
/* 2134 */	NdrFcLong( 0x4005 ),	/* 16389 */
/* 2138 */	NdrFcShort( 0xfffffb38 ),	/* Offset= -1224 (914) */
/* 2140 */	NdrFcLong( 0x400b ),	/* 16395 */
/* 2144 */	NdrFcShort( 0xfffffb26 ),	/* Offset= -1242 (902) */
/* 2146 */	NdrFcLong( 0x400e ),	/* 16398 */
/* 2150 */	NdrFcShort( 0xfffffb58 ),	/* Offset= -1192 (958) */
/* 2152 */	NdrFcLong( 0x400a ),	/* 16394 */
/* 2156 */	NdrFcShort( 0xfffffb1e ),	/* Offset= -1250 (906) */
/* 2158 */	NdrFcLong( 0x4006 ),	/* 16390 */
/* 2162 */	NdrFcShort( 0xfffffb24 ),	/* Offset= -1244 (918) */
/* 2164 */	NdrFcLong( 0x4007 ),	/* 16391 */
/* 2168 */	NdrFcShort( 0xfffffb1a ),	/* Offset= -1254 (914) */
/* 2170 */	NdrFcLong( 0x4008 ),	/* 16392 */
/* 2174 */	NdrFcShort( 0x42 ),	/* Offset= 66 (2240) */
/* 2176 */	NdrFcLong( 0x400d ),	/* 16397 */
/* 2180 */	NdrFcShort( 0xfffffb1a ),	/* Offset= -1254 (926) */
/* 2182 */	NdrFcLong( 0x4009 ),	/* 16393 */
/* 2186 */	NdrFcShort( 0xfffffb18 ),	/* Offset= -1256 (930) */
/* 2188 */	NdrFcLong( 0x6000 ),	/* 24576 */
/* 2192 */	NdrFcShort( 0x34 ),	/* Offset= 52 (2244) */
/* 2194 */	NdrFcLong( 0x400c ),	/* 16396 */
/* 2198 */	NdrFcShort( 0x32 ),	/* Offset= 50 (2248) */
/* 2200 */	NdrFcShort( 0xffffffff ),	/* Offset= -1 (2199) */
/* 2202 */	
			0x12, 0x0,	/* FC_UP */
/* 2204 */	NdrFcShort( 0xfffffa22 ),	/* Offset= -1502 (702) */
/* 2206 */	
			0x12, 0x0,	/* FC_UP */
/* 2208 */	NdrFcShort( 0xfffffc9e ),	/* Offset= -866 (1342) */
/* 2210 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 2212 */	
			0x22,		/* FC_C_CSTRING */
			0x5c,		/* FC_PAD */
/* 2214 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 2216 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 2218 */	
			0x12, 0x0,	/* FC_UP */
/* 2220 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2222) */
/* 2222 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 2224 */	NdrFcShort( 0x14 ),	/* 20 */
/* 2226 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2228 */	NdrFcShort( 0xc ),	/* Offset= 12 (2240) */
/* 2230 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 2232 */	NdrFcShort( 0xfffffa06 ),	/* Offset= -1530 (702) */
/* 2234 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 2236 */	NdrFcShort( 0xfffffb88 ),	/* Offset= -1144 (1092) */
/* 2238 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 2240 */	
			0x12, 0x0,	/* FC_UP */
/* 2242 */	NdrFcShort( 0xfffff758 ),	/* Offset= -2216 (26) */
/* 2244 */	
			0x12, 0x0,	/* FC_UP */
/* 2246 */	NdrFcShort( 0xfffffb1e ),	/* Offset= -1250 (996) */
/* 2248 */	
			0x12, 0x0,	/* FC_UP */
/* 2250 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2252) */
/* 2252 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x7,		/* 7 */
/* 2254 */	NdrFcShort( 0x10 ),	/* 16 */
/* 2256 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2258 */	NdrFcShort( 0x0 ),	/* Offset= 0 (2258) */
/* 2260 */	0x6,		/* FC_SHORT */
			0x1,		/* FC_BYTE */
/* 2262 */	0x1,		/* FC_BYTE */
			0x38,		/* FC_ALIGNM4 */
/* 2264 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 2266 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffd6b ),	/* Offset= -661 (1606) */
			0x5b,		/* FC_END */
/* 2270 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x7,		/* 7 */
/* 2272 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2274 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 2276 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2278 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 2282 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 2284 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (2252) */
/* 2286 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 2288 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 2290 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2292 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2294 */	NdrFcShort( 0x6 ),	/* Offset= 6 (2300) */
/* 2296 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 2298 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 2300 */	
			0x12, 0x0,	/* FC_UP */
/* 2302 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (2270) */
/* 2304 */	
			0x12, 0x0,	/* FC_UP */
/* 2306 */	NdrFcShort( 0xfffffb7c ),	/* Offset= -1156 (1150) */
/* 2308 */	
			0x12, 0x0,	/* FC_UP */
/* 2310 */	NdrFcShort( 0xfffffa00 ),	/* Offset= -1536 (774) */
/* 2312 */	
			0x12, 0x0,	/* FC_UP */
/* 2314 */	NdrFcShort( 0xfffffa1a ),	/* Offset= -1510 (804) */
/* 2316 */	
			0x12, 0x0,	/* FC_UP */
/* 2318 */	NdrFcShort( 0xfffffb8e ),	/* Offset= -1138 (1180) */
/* 2320 */	
			0x12, 0x0,	/* FC_UP */
/* 2322 */	NdrFcShort( 0xfffffbac ),	/* Offset= -1108 (1214) */
/* 2324 */	
			0x12, 0x0,	/* FC_UP */
/* 2326 */	NdrFcShort( 0xfffffbc6 ),	/* Offset= -1082 (1244) */
/* 2328 */	
			0x12, 0x0,	/* FC_UP */
/* 2330 */	NdrFcShort( 0xfffffbe4 ),	/* Offset= -1052 (1278) */
/* 2332 */	
			0x12, 0x0,	/* FC_UP */
/* 2334 */	NdrFcShort( 0xfffffc02 ),	/* Offset= -1022 (1312) */
/* 2336 */	
			0x12, 0x0,	/* FC_UP */
/* 2338 */	NdrFcShort( 0xfffffc52 ),	/* Offset= -942 (1396) */
/* 2340 */	
			0x12, 0x0,	/* FC_UP */
/* 2342 */	NdrFcShort( 0xfffffc74 ),	/* Offset= -908 (1434) */
/* 2344 */	
			0x12, 0x0,	/* FC_UP */
/* 2346 */	NdrFcShort( 0xfffffca4 ),	/* Offset= -860 (1486) */
/* 2348 */	
			0x12, 0x0,	/* FC_UP */
/* 2350 */	NdrFcShort( 0xfffffcd2 ),	/* Offset= -814 (1536) */
/* 2352 */	
			0x12, 0x0,	/* FC_UP */
/* 2354 */	NdrFcShort( 0xfffffd00 ),	/* Offset= -768 (1586) */
/* 2356 */	
			0x12, 0x0,	/* FC_UP */
/* 2358 */	NdrFcShort( 0xffffffba ),	/* Offset= -70 (2288) */

			0x0, 0x0, 0x0, 0x0
        }
    };


#else // __RPC_WIN64__

#define BSTR_TYPE_FS_OFFSET 28              //bstr
#define LPWSTR_TYPE_FS_OFFSET 40            // lpwstr
#define LPSTR_TYPE_FS_OFFSET 44             // lpstr
#define EMBEDDED_LPWSTR_TYPE_FS_OFFSET 1010 // lpwstr
#define EMBEDDED_LPSTR_TYPE_FS_OFFSET 1018  // lpstr
#define VARIANT_TYPE_FS_OFFSET 968          // variant
#define DISPATCH_TYPE_FS_OFFSET 348         // pdispatch
#define UNKNOWN_TYPE_FS_OFFSET 330          // punk
#define DECIMAL_TYPE_FS_OFFSET 928          // decimal
#define SAFEARRAY_TYPE_FS_OFFSET 978        // pSafeArray


#define BYREF_BSTR_TYPE_FS_OFFSET 996       //pBSTR
#define BYREF_LPWSTR_TYPE_FS_OFFSET 1006    // ppwsz
#define BYREF_LPSTR_TYPE_FS_OFFSET 1014     // ppsz
#define BYREF_VARIANT_TYPE_FS_OFFSET 1030   // pVariant
#define BYREF_UNKNOWN_TYPE_FS_OFFSET 1040   // ppunk
#define BYREF_DISPATCH_TYPE_FS_OFFSET 1044  // ppdistatch
#define BYREF_DECIMAL_TYPE_FS_OFFSET 940    // pDecimal
#define BYREF_SAFEARRAY_TYPE_FS_OFFSET 1064 // ppSafeArray

#define STREAM_TYPE_FS_OFFSET 1074          // pStream
#define BYREF_STREAM_TYPE_FS_OFFSET 1092    // ppStream
#define STORAGE_TYPE_FS_OFFSET 1096         // pStorage
#define BYREF_STORAGE_TYPE_FS_OFFSET 1114   // ppStorage
#define FILETIME_TYPE_FS_OFFSET 834         // FileTime
#define BYREF_FILETIME_TYPE_FS_OFFSET 1118  // pfileTime


#define BYREF_I1_TYPE_FS_OFFSET 880
#define BYREF_I2_TYPE_FS_OFFSET 884
#define BYREF_I4_TYPE_FS_OFFSET 888
#define BYREF_R4_TYPE_FS_OFFSET 892
#define BYREF_R8_TYPE_FS_OFFSET 896

#define I1_VECTOR_TYPE_FS_OFFSET 1134       // cab
#define I2_VECTOR_TYPE_FS_OFFSET 1166       // cai
#define I4_VECTOR_TYPE_FS_OFFSET 1214       // cal
#define R4_VECTOR_TYPE_FS_OFFSET 1258       // caflt
#define ERROR_VECTOR_TYPE_FS_OFFSET 1274            // cascode
#define I8_VECTOR_TYPE_FS_OFFSET 1306               // cah
#define R8_VECTOR_TYPE_FS_OFFSET 1350       // cadbl
#define CY_VECTOR_TYPE_FS_OFFSET 1366       // cacy
#define DATE_VECTOR_TYPE_FS_OFFSET 1382             // cadate
#define FILETIME_VECTOR_TYPE_FS_OFFSET 1414         // cafiletime
#define BSTR_VECTOR_TYPE_FS_OFFSET 1552             // cabstr
#define BSTRBLOB_VECTOR_TYPE_FS_OFFSET 1606         // cabstrblob
#define LPSTR_VECTOR_TYPE_FS_OFFSET 1644            // calpstr
#define LPWSTR_VECTOR_TYPE_FS_OFFSET 1682           // calpwstr


#define BYREF_I1_VECTOR_TYPE_FS_OFFSET 2418 // pcab
#define BYREF_I2_VECTOR_TYPE_FS_OFFSET 2426 // pcai
#define BYREF_I4_VECTOR_TYPE_FS_OFFSET 2438 // pcal
#define BYREF_R4_VECTOR_TYPE_FS_OFFSET 2446 // pcaflt
#define BYREF_ERROR_VECTOR_TYPE_FS_OFFSET 2450      // pcascode
#define BYREF_I8_VECTOR_TYPE_FS_OFFSET 2454         // pcah
#define BYREF_R8_VECTOR_TYPE_FS_OFFSET 2462 // pcadbl
#define BYREF_CY_VECTOR_TYPE_FS_OFFSET 2466 // pcacy
#define BYREF_DATE_VECTOR_TYPE_FS_OFFSET 2470       // pcadate
#define BYREF_FILETIME_VECTOR_TYPE_FS_OFFSET 2474   // pcafiletime
#define BYREF_BSTR_VECTOR_TYPE_FS_OFFSET 2486       // pcabstr
#define BYREF_BSTRBLOB_VECTOR_TYPE_FS_OFFSET 2490   // pcabstrblob
#define BYREF_LPSTR_VECTOR_TYPE_FS_OFFSET 2494      // pcalpstr
#define BYREF_LPWSTR_VECTOR_TYPE_FS_OFFSET 2498     // pcalpwstr




 /* File created by MIDL compiler version 5.03.0276 */
/* at Mon Jul 05 13:57:41 1999
 */
/* Compiler settings for oandr.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win64 (32b run), ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x12, 0x0,	/* FC_UP */
/*  4 */	NdrFcShort( 0xe ),	/* Offset= 14 (18) */
/*  6 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/*  8 */	NdrFcShort( 0x2 ),	/* 2 */
/* 10 */	0x9,		/* Corr desc: FC_ULONG */
			0x0,		/*  */
/* 12 */	NdrFcShort( 0xfffc ),	/* -4 */
/* 14 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 16 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 18 */	
			0x17,		/* FC_CSTRUCT */
			0x3,		/* 3 */
/* 20 */	NdrFcShort( 0x8 ),	/* 8 */
/* 22 */	NdrFcShort( 0xfffffff0 ),	/* Offset= -16 (6) */
/* 24 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 26 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 28 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 30 */	NdrFcShort( 0x0 ),	/* 0 */
/* 32 */	NdrFcShort( 0x8 ),	/* 8 */
/* 34 */	NdrFcShort( 0x0 ),	/* 0 */
/* 36 */	NdrFcShort( 0xffffffde ),	/* Offset= -34 (2) */
/* 38 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 40 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 42 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 44 */	
			0x22,		/* FC_C_CSTRING */
			0x5c,		/* FC_PAD */
/* 46 */	
			0x12, 0x0,	/* FC_UP */
/* 48 */	NdrFcShort( 0x384 ),	/* Offset= 900 (948) */
/* 50 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0x9,		/* FC_ULONG */
/* 52 */	0x7,		/* Corr desc: FC_USHORT */
			0x0,		/*  */
/* 54 */	NdrFcShort( 0xfff8 ),	/* -8 */
/* 56 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 58 */	NdrFcShort( 0x2 ),	/* Offset= 2 (60) */
/* 60 */	NdrFcShort( 0x10 ),	/* 16 */
/* 62 */	NdrFcShort( 0x2b ),	/* 43 */
/* 64 */	NdrFcLong( 0x3 ),	/* 3 */
/* 68 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 70 */	NdrFcLong( 0x11 ),	/* 17 */
/* 74 */	NdrFcShort( 0x8001 ),	/* Simple arm type: FC_BYTE */
/* 76 */	NdrFcLong( 0x2 ),	/* 2 */
/* 80 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 82 */	NdrFcLong( 0x4 ),	/* 4 */
/* 86 */	NdrFcShort( 0x800a ),	/* Simple arm type: FC_FLOAT */
/* 88 */	NdrFcLong( 0x5 ),	/* 5 */
/* 92 */	NdrFcShort( 0x800c ),	/* Simple arm type: FC_DOUBLE */
/* 94 */	NdrFcLong( 0xb ),	/* 11 */
/* 98 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 100 */	NdrFcLong( 0xa ),	/* 10 */
/* 104 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 106 */	NdrFcLong( 0x6 ),	/* 6 */
/* 110 */	NdrFcShort( 0xd6 ),	/* Offset= 214 (324) */
/* 112 */	NdrFcLong( 0x7 ),	/* 7 */
/* 116 */	NdrFcShort( 0x800c ),	/* Simple arm type: FC_DOUBLE */
/* 118 */	NdrFcLong( 0x8 ),	/* 8 */
/* 122 */	NdrFcShort( 0xffffff88 ),	/* Offset= -120 (2) */
/* 124 */	NdrFcLong( 0xd ),	/* 13 */
/* 128 */	NdrFcShort( 0xca ),	/* Offset= 202 (330) */
/* 130 */	NdrFcLong( 0x9 ),	/* 9 */
/* 134 */	NdrFcShort( 0xd6 ),	/* Offset= 214 (348) */
/* 136 */	NdrFcLong( 0x2000 ),	/* 8192 */
/* 140 */	NdrFcShort( 0xe2 ),	/* Offset= 226 (366) */
/* 142 */	NdrFcLong( 0x24 ),	/* 36 */
/* 146 */	NdrFcShort( 0x2da ),	/* Offset= 730 (876) */
/* 148 */	NdrFcLong( 0x4024 ),	/* 16420 */
/* 152 */	NdrFcShort( 0x2d4 ),	/* Offset= 724 (876) */
/* 154 */	NdrFcLong( 0x4011 ),	/* 16401 */
/* 158 */	NdrFcShort( 0x2d2 ),	/* Offset= 722 (880) */
/* 160 */	NdrFcLong( 0x4002 ),	/* 16386 */
/* 164 */	NdrFcShort( 0x2d0 ),	/* Offset= 720 (884) */
/* 166 */	NdrFcLong( 0x4003 ),	/* 16387 */
/* 170 */	NdrFcShort( 0x2ce ),	/* Offset= 718 (888) */
/* 172 */	NdrFcLong( 0x4004 ),	/* 16388 */
/* 176 */	NdrFcShort( 0x2cc ),	/* Offset= 716 (892) */
/* 178 */	NdrFcLong( 0x4005 ),	/* 16389 */
/* 182 */	NdrFcShort( 0x2ca ),	/* Offset= 714 (896) */
/* 184 */	NdrFcLong( 0x400b ),	/* 16395 */
/* 188 */	NdrFcShort( 0x2b8 ),	/* Offset= 696 (884) */
/* 190 */	NdrFcLong( 0x400a ),	/* 16394 */
/* 194 */	NdrFcShort( 0x2b6 ),	/* Offset= 694 (888) */
/* 196 */	NdrFcLong( 0x4006 ),	/* 16390 */
/* 200 */	NdrFcShort( 0x2bc ),	/* Offset= 700 (900) */
/* 202 */	NdrFcLong( 0x4007 ),	/* 16391 */
/* 206 */	NdrFcShort( 0x2b2 ),	/* Offset= 690 (896) */
/* 208 */	NdrFcLong( 0x4008 ),	/* 16392 */
/* 212 */	NdrFcShort( 0x2b4 ),	/* Offset= 692 (904) */
/* 214 */	NdrFcLong( 0x400d ),	/* 16397 */
/* 218 */	NdrFcShort( 0x2b2 ),	/* Offset= 690 (908) */
/* 220 */	NdrFcLong( 0x4009 ),	/* 16393 */
/* 224 */	NdrFcShort( 0x2b0 ),	/* Offset= 688 (912) */
/* 226 */	NdrFcLong( 0x6000 ),	/* 24576 */
/* 230 */	NdrFcShort( 0x2ae ),	/* Offset= 686 (916) */
/* 232 */	NdrFcLong( 0x400c ),	/* 16396 */
/* 236 */	NdrFcShort( 0x2ac ),	/* Offset= 684 (920) */
/* 238 */	NdrFcLong( 0x10 ),	/* 16 */
/* 242 */	NdrFcShort( 0x8002 ),	/* Simple arm type: FC_CHAR */
/* 244 */	NdrFcLong( 0x12 ),	/* 18 */
/* 248 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 250 */	NdrFcLong( 0x13 ),	/* 19 */
/* 254 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 256 */	NdrFcLong( 0x16 ),	/* 22 */
/* 260 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 262 */	NdrFcLong( 0x17 ),	/* 23 */
/* 266 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 268 */	NdrFcLong( 0xe ),	/* 14 */
/* 272 */	NdrFcShort( 0x290 ),	/* Offset= 656 (928) */
/* 274 */	NdrFcLong( 0x400e ),	/* 16398 */
/* 278 */	NdrFcShort( 0x296 ),	/* Offset= 662 (940) */
/* 280 */	NdrFcLong( 0x4010 ),	/* 16400 */
/* 284 */	NdrFcShort( 0x294 ),	/* Offset= 660 (944) */
/* 286 */	NdrFcLong( 0x4012 ),	/* 16402 */
/* 290 */	NdrFcShort( 0x252 ),	/* Offset= 594 (884) */
/* 292 */	NdrFcLong( 0x4013 ),	/* 16403 */
/* 296 */	NdrFcShort( 0x250 ),	/* Offset= 592 (888) */
/* 298 */	NdrFcLong( 0x4016 ),	/* 16406 */
/* 302 */	NdrFcShort( 0x24a ),	/* Offset= 586 (888) */
/* 304 */	NdrFcLong( 0x4017 ),	/* 16407 */
/* 308 */	NdrFcShort( 0x244 ),	/* Offset= 580 (888) */
/* 310 */	NdrFcLong( 0x0 ),	/* 0 */
/* 314 */	NdrFcShort( 0x0 ),	/* Offset= 0 (314) */
/* 316 */	NdrFcLong( 0x1 ),	/* 1 */
/* 320 */	NdrFcShort( 0x0 ),	/* Offset= 0 (320) */
/* 322 */	NdrFcShort( 0xffffffff ),	/* Offset= -1 (321) */
/* 324 */	
			0x15,		/* FC_STRUCT */
			0x7,		/* 7 */
/* 326 */	NdrFcShort( 0x8 ),	/* 8 */
/* 328 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 330 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 332 */	NdrFcLong( 0x0 ),	/* 0 */
/* 336 */	NdrFcShort( 0x0 ),	/* 0 */
/* 338 */	NdrFcShort( 0x0 ),	/* 0 */
/* 340 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 342 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 344 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 346 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 348 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 350 */	NdrFcLong( 0x20400 ),	/* 132096 */
/* 354 */	NdrFcShort( 0x0 ),	/* 0 */
/* 356 */	NdrFcShort( 0x0 ),	/* 0 */
/* 358 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 360 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 362 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 364 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 366 */	
			0x12, 0x10,	/* FC_UP [pointer_deref] */
/* 368 */	NdrFcShort( 0x2 ),	/* Offset= 2 (370) */
/* 370 */	
			0x12, 0x0,	/* FC_UP */
/* 372 */	NdrFcShort( 0x1e6 ),	/* Offset= 486 (858) */
/* 374 */	
			0x2a,		/* FC_ENCAPSULATED_UNION */
			0x89,		/* 137 */
/* 376 */	NdrFcShort( 0x20 ),	/* 32 */
/* 378 */	NdrFcShort( 0xa ),	/* 10 */
/* 380 */	NdrFcLong( 0x8 ),	/* 8 */
/* 384 */	NdrFcShort( 0x50 ),	/* Offset= 80 (464) */
/* 386 */	NdrFcLong( 0xd ),	/* 13 */
/* 390 */	NdrFcShort( 0x70 ),	/* Offset= 112 (502) */
/* 392 */	NdrFcLong( 0x9 ),	/* 9 */
/* 396 */	NdrFcShort( 0x90 ),	/* Offset= 144 (540) */
/* 398 */	NdrFcLong( 0xc ),	/* 12 */
/* 402 */	NdrFcShort( 0xb0 ),	/* Offset= 176 (578) */
/* 404 */	NdrFcLong( 0x24 ),	/* 36 */
/* 408 */	NdrFcShort( 0x104 ),	/* Offset= 260 (668) */
/* 410 */	NdrFcLong( 0x800d ),	/* 32781 */
/* 414 */	NdrFcShort( 0x120 ),	/* Offset= 288 (702) */
/* 416 */	NdrFcLong( 0x10 ),	/* 16 */
/* 420 */	NdrFcShort( 0x13a ),	/* Offset= 314 (734) */
/* 422 */	NdrFcLong( 0x2 ),	/* 2 */
/* 426 */	NdrFcShort( 0x150 ),	/* Offset= 336 (762) */
/* 428 */	NdrFcLong( 0x3 ),	/* 3 */
/* 432 */	NdrFcShort( 0x166 ),	/* Offset= 358 (790) */
/* 434 */	NdrFcLong( 0x14 ),	/* 20 */
/* 438 */	NdrFcShort( 0x17c ),	/* Offset= 380 (818) */
/* 440 */	NdrFcShort( 0xffffffff ),	/* Offset= -1 (439) */
/* 442 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 444 */	NdrFcShort( 0x0 ),	/* 0 */
/* 446 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 448 */	NdrFcShort( 0x0 ),	/* 0 */
/* 450 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 452 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 456 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 458 */	
			0x12, 0x0,	/* FC_UP */
/* 460 */	NdrFcShort( 0xfffffe46 ),	/* Offset= -442 (18) */
/* 462 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 464 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 466 */	NdrFcShort( 0x10 ),	/* 16 */
/* 468 */	NdrFcShort( 0x0 ),	/* 0 */
/* 470 */	NdrFcShort( 0x6 ),	/* Offset= 6 (476) */
/* 472 */	0x8,		/* FC_LONG */
			0x39,		/* FC_ALIGNM8 */
/* 474 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 476 */	
			0x11, 0x0,	/* FC_RP */
/* 478 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (442) */
/* 480 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 482 */	NdrFcShort( 0x0 ),	/* 0 */
/* 484 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 486 */	NdrFcShort( 0x0 ),	/* 0 */
/* 488 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 490 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 494 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 496 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 498 */	NdrFcShort( 0xffffff58 ),	/* Offset= -168 (330) */
/* 500 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 502 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 504 */	NdrFcShort( 0x10 ),	/* 16 */
/* 506 */	NdrFcShort( 0x0 ),	/* 0 */
/* 508 */	NdrFcShort( 0x6 ),	/* Offset= 6 (514) */
/* 510 */	0x8,		/* FC_LONG */
			0x39,		/* FC_ALIGNM8 */
/* 512 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 514 */	
			0x11, 0x0,	/* FC_RP */
/* 516 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (480) */
/* 518 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 520 */	NdrFcShort( 0x0 ),	/* 0 */
/* 522 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 524 */	NdrFcShort( 0x0 ),	/* 0 */
/* 526 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 528 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 532 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 534 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 536 */	NdrFcShort( 0xffffff44 ),	/* Offset= -188 (348) */
/* 538 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 540 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 542 */	NdrFcShort( 0x10 ),	/* 16 */
/* 544 */	NdrFcShort( 0x0 ),	/* 0 */
/* 546 */	NdrFcShort( 0x6 ),	/* Offset= 6 (552) */
/* 548 */	0x8,		/* FC_LONG */
			0x39,		/* FC_ALIGNM8 */
/* 550 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 552 */	
			0x11, 0x0,	/* FC_RP */
/* 554 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (518) */
/* 556 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 558 */	NdrFcShort( 0x0 ),	/* 0 */
/* 560 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 562 */	NdrFcShort( 0x0 ),	/* 0 */
/* 564 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 566 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 570 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 572 */	
			0x12, 0x0,	/* FC_UP */
/* 574 */	NdrFcShort( 0x176 ),	/* Offset= 374 (948) */
/* 576 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 578 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 580 */	NdrFcShort( 0x10 ),	/* 16 */
/* 582 */	NdrFcShort( 0x0 ),	/* 0 */
/* 584 */	NdrFcShort( 0x6 ),	/* Offset= 6 (590) */
/* 586 */	0x8,		/* FC_LONG */
			0x39,		/* FC_ALIGNM8 */
/* 588 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 590 */	
			0x11, 0x0,	/* FC_RP */
/* 592 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (556) */
/* 594 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 596 */	NdrFcLong( 0x2f ),	/* 47 */
/* 600 */	NdrFcShort( 0x0 ),	/* 0 */
/* 602 */	NdrFcShort( 0x0 ),	/* 0 */
/* 604 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 606 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 608 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 610 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 612 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 614 */	NdrFcShort( 0x1 ),	/* 1 */
/* 616 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 618 */	NdrFcShort( 0x4 ),	/* 4 */
/* 620 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 622 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 624 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 626 */	NdrFcShort( 0x18 ),	/* 24 */
/* 628 */	NdrFcShort( 0x0 ),	/* 0 */
/* 630 */	NdrFcShort( 0xc ),	/* Offset= 12 (642) */
/* 632 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 634 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 636 */	NdrFcShort( 0xffffffd6 ),	/* Offset= -42 (594) */
/* 638 */	0x39,		/* FC_ALIGNM8 */
			0x36,		/* FC_POINTER */
/* 640 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 642 */	
			0x12, 0x0,	/* FC_UP */
/* 644 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (612) */
/* 646 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 648 */	NdrFcShort( 0x0 ),	/* 0 */
/* 650 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 652 */	NdrFcShort( 0x0 ),	/* 0 */
/* 654 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 656 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 660 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 662 */	
			0x12, 0x0,	/* FC_UP */
/* 664 */	NdrFcShort( 0xffffffd8 ),	/* Offset= -40 (624) */
/* 666 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 668 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 670 */	NdrFcShort( 0x10 ),	/* 16 */
/* 672 */	NdrFcShort( 0x0 ),	/* 0 */
/* 674 */	NdrFcShort( 0x6 ),	/* Offset= 6 (680) */
/* 676 */	0x8,		/* FC_LONG */
			0x39,		/* FC_ALIGNM8 */
/* 678 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 680 */	
			0x11, 0x0,	/* FC_RP */
/* 682 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (646) */
/* 684 */	
			0x1d,		/* FC_SMFARRAY */
			0x0,		/* 0 */
/* 686 */	NdrFcShort( 0x8 ),	/* 8 */
/* 688 */	0x2,		/* FC_CHAR */
			0x5b,		/* FC_END */
/* 690 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 692 */	NdrFcShort( 0x10 ),	/* 16 */
/* 694 */	0x8,		/* FC_LONG */
			0x6,		/* FC_SHORT */
/* 696 */	0x6,		/* FC_SHORT */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 698 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffff1 ),	/* Offset= -15 (684) */
			0x5b,		/* FC_END */
/* 702 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 704 */	NdrFcShort( 0x20 ),	/* 32 */
/* 706 */	NdrFcShort( 0x0 ),	/* 0 */
/* 708 */	NdrFcShort( 0xa ),	/* Offset= 10 (718) */
/* 710 */	0x8,		/* FC_LONG */
			0x39,		/* FC_ALIGNM8 */
/* 712 */	0x36,		/* FC_POINTER */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 714 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffe7 ),	/* Offset= -25 (690) */
			0x5b,		/* FC_END */
/* 718 */	
			0x11, 0x0,	/* FC_RP */
/* 720 */	NdrFcShort( 0xffffff10 ),	/* Offset= -240 (480) */
/* 722 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 724 */	NdrFcShort( 0x1 ),	/* 1 */
/* 726 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 728 */	NdrFcShort( 0x0 ),	/* 0 */
/* 730 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 732 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 734 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 736 */	NdrFcShort( 0x10 ),	/* 16 */
/* 738 */	NdrFcShort( 0x0 ),	/* 0 */
/* 740 */	NdrFcShort( 0x6 ),	/* Offset= 6 (746) */
/* 742 */	0x8,		/* FC_LONG */
			0x39,		/* FC_ALIGNM8 */
/* 744 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 746 */	
			0x12, 0x0,	/* FC_UP */
/* 748 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (722) */
/* 750 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/* 752 */	NdrFcShort( 0x2 ),	/* 2 */
/* 754 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 756 */	NdrFcShort( 0x0 ),	/* 0 */
/* 758 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 760 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 762 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 764 */	NdrFcShort( 0x10 ),	/* 16 */
/* 766 */	NdrFcShort( 0x0 ),	/* 0 */
/* 768 */	NdrFcShort( 0x6 ),	/* Offset= 6 (774) */
/* 770 */	0x8,		/* FC_LONG */
			0x39,		/* FC_ALIGNM8 */
/* 772 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 774 */	
			0x12, 0x0,	/* FC_UP */
/* 776 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (750) */
/* 778 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 780 */	NdrFcShort( 0x4 ),	/* 4 */
/* 782 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 784 */	NdrFcShort( 0x0 ),	/* 0 */
/* 786 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 788 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 790 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 792 */	NdrFcShort( 0x10 ),	/* 16 */
/* 794 */	NdrFcShort( 0x0 ),	/* 0 */
/* 796 */	NdrFcShort( 0x6 ),	/* Offset= 6 (802) */
/* 798 */	0x8,		/* FC_LONG */
			0x39,		/* FC_ALIGNM8 */
/* 800 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 802 */	
			0x12, 0x0,	/* FC_UP */
/* 804 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (778) */
/* 806 */	
			0x1b,		/* FC_CARRAY */
			0x7,		/* 7 */
/* 808 */	NdrFcShort( 0x8 ),	/* 8 */
/* 810 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 812 */	NdrFcShort( 0x0 ),	/* 0 */
/* 814 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 816 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 818 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 820 */	NdrFcShort( 0x10 ),	/* 16 */
/* 822 */	NdrFcShort( 0x0 ),	/* 0 */
/* 824 */	NdrFcShort( 0x6 ),	/* Offset= 6 (830) */
/* 826 */	0x8,		/* FC_LONG */
			0x39,		/* FC_ALIGNM8 */
/* 828 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 830 */	
			0x12, 0x0,	/* FC_UP */
/* 832 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (806) */
/* 834 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 836 */	NdrFcShort( 0x8 ),	/* 8 */
/* 838 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 840 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 842 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 844 */	NdrFcShort( 0x8 ),	/* 8 */
/* 846 */	0x7,		/* Corr desc: FC_USHORT */
			0x0,		/*  */
/* 848 */	NdrFcShort( 0xffc8 ),	/* -56 */
/* 850 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 852 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 854 */	NdrFcShort( 0xffffffec ),	/* Offset= -20 (834) */
/* 856 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 858 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 860 */	NdrFcShort( 0x38 ),	/* 56 */
/* 862 */	NdrFcShort( 0xffffffec ),	/* Offset= -20 (842) */
/* 864 */	NdrFcShort( 0x0 ),	/* Offset= 0 (864) */
/* 866 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 868 */	0x38,		/* FC_ALIGNM4 */
			0x8,		/* FC_LONG */
/* 870 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 872 */	0x4,		/* 4 */
			NdrFcShort( 0xfffffe0d ),	/* Offset= -499 (374) */
			0x5b,		/* FC_END */
/* 876 */	
			0x12, 0x0,	/* FC_UP */
/* 878 */	NdrFcShort( 0xffffff02 ),	/* Offset= -254 (624) */
/* 880 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 882 */	0x1,		/* FC_BYTE */
			0x5c,		/* FC_PAD */
/* 884 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 886 */	0x6,		/* FC_SHORT */
			0x5c,		/* FC_PAD */
/* 888 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 890 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 892 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 894 */	0xa,		/* FC_FLOAT */
			0x5c,		/* FC_PAD */
/* 896 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 898 */	0xc,		/* FC_DOUBLE */
			0x5c,		/* FC_PAD */
/* 900 */	
			0x12, 0x0,	/* FC_UP */
/* 902 */	NdrFcShort( 0xfffffdbe ),	/* Offset= -578 (324) */
/* 904 */	
			0x12, 0x10,	/* FC_UP [pointer_deref] */
/* 906 */	NdrFcShort( 0xfffffc78 ),	/* Offset= -904 (2) */
/* 908 */	
			0x12, 0x10,	/* FC_UP [pointer_deref] */
/* 910 */	NdrFcShort( 0xfffffdbc ),	/* Offset= -580 (330) */
/* 912 */	
			0x12, 0x10,	/* FC_UP [pointer_deref] */
/* 914 */	NdrFcShort( 0xfffffdca ),	/* Offset= -566 (348) */
/* 916 */	
			0x12, 0x10,	/* FC_UP [pointer_deref] */
/* 918 */	NdrFcShort( 0xfffffdd8 ),	/* Offset= -552 (366) */
/* 920 */	
			0x12, 0x10,	/* FC_UP [pointer_deref] */
/* 922 */	NdrFcShort( 0x2 ),	/* Offset= 2 (924) */
/* 924 */	
			0x12, 0x0,	/* FC_UP */
/* 926 */	NdrFcShort( 0x16 ),	/* Offset= 22 (948) */
/* 928 */	
			0x15,		/* FC_STRUCT */
			0x7,		/* 7 */
/* 930 */	NdrFcShort( 0x10 ),	/* 16 */
/* 932 */	0x6,		/* FC_SHORT */
			0x1,		/* FC_BYTE */
/* 934 */	0x1,		/* FC_BYTE */
			0x38,		/* FC_ALIGNM4 */
/* 936 */	0x8,		/* FC_LONG */
			0x39,		/* FC_ALIGNM8 */
/* 938 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 940 */	
			0x12, 0x0,	/* FC_UP */
/* 942 */	NdrFcShort( 0xfffffff2 ),	/* Offset= -14 (928) */
/* 944 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 946 */	0x2,		/* FC_CHAR */
			0x5c,		/* FC_PAD */
/* 948 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x7,		/* 7 */
/* 950 */	NdrFcShort( 0x20 ),	/* 32 */
/* 952 */	NdrFcShort( 0x0 ),	/* 0 */
/* 954 */	NdrFcShort( 0x0 ),	/* Offset= 0 (954) */
/* 956 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 958 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 960 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 962 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 964 */	NdrFcShort( 0xfffffc6e ),	/* Offset= -914 (50) */
/* 966 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 968 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 970 */	NdrFcShort( 0x1 ),	/* 1 */
/* 972 */	NdrFcShort( 0x18 ),	/* 24 */
/* 974 */	NdrFcShort( 0x0 ),	/* 0 */
/* 976 */	NdrFcShort( 0xfffffc5e ),	/* Offset= -930 (46) */
/* 978 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 980 */	NdrFcShort( 0x2 ),	/* 2 */
/* 982 */	NdrFcShort( 0x8 ),	/* 8 */
/* 984 */	NdrFcShort( 0x0 ),	/* 0 */
/* 986 */	NdrFcShort( 0xfffffd94 ),	/* Offset= -620 (366) */
/* 988 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 990 */	NdrFcShort( 0x6 ),	/* Offset= 6 (996) */
/* 992 */	
			0x13, 0x0,	/* FC_OP */
/* 994 */	NdrFcShort( 0xfffffc30 ),	/* Offset= -976 (18) */
/* 996 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 998 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1000 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1002 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1004 */	NdrFcShort( 0xfffffff4 ),	/* Offset= -12 (992) */
/* 1006 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 1008 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1010) */
/* 1010 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 1012 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 1014 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 1016 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1018) */
/* 1018 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 1020 */	
			0x22,		/* FC_C_CSTRING */
			0x5c,		/* FC_PAD */
/* 1022 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 1024 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1030) */
/* 1026 */	
			0x13, 0x0,	/* FC_OP */
/* 1028 */	NdrFcShort( 0xffffffb0 ),	/* Offset= -80 (948) */
/* 1030 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 1032 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1034 */	NdrFcShort( 0x18 ),	/* 24 */
/* 1036 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1038 */	NdrFcShort( 0xfffffff4 ),	/* Offset= -12 (1026) */
/* 1040 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 1042 */	NdrFcShort( 0xfffffd38 ),	/* Offset= -712 (330) */
/* 1044 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 1046 */	NdrFcShort( 0xfffffd46 ),	/* Offset= -698 (348) */
/* 1048 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 1050 */	NdrFcShort( 0xffffff86 ),	/* Offset= -122 (928) */
/* 1052 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 1054 */	NdrFcShort( 0xa ),	/* Offset= 10 (1064) */
/* 1056 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 1058 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1060) */
/* 1060 */	
			0x13, 0x0,	/* FC_OP */
/* 1062 */	NdrFcShort( 0xffffff34 ),	/* Offset= -204 (858) */
/* 1064 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 1066 */	NdrFcShort( 0x2 ),	/* 2 */
/* 1068 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1070 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1072 */	NdrFcShort( 0xfffffff0 ),	/* Offset= -16 (1056) */
/* 1074 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1076 */	NdrFcLong( 0xc ),	/* 12 */
/* 1080 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1082 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1084 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 1086 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 1088 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 1090 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 1092 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 1094 */	NdrFcShort( 0xffffffec ),	/* Offset= -20 (1074) */
/* 1096 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1098 */	NdrFcLong( 0xb ),	/* 11 */
/* 1102 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1104 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1106 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 1108 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 1110 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 1112 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 1114 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 1116 */	NdrFcShort( 0xffffffec ),	/* Offset= -20 (1096) */
/* 1118 */	
			0x12, 0x0,	/* FC_UP */
/* 1120 */	NdrFcShort( 0xfffffee2 ),	/* Offset= -286 (834) */
/* 1122 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 1124 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1126 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1128 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1130 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1132 */	0x2,		/* FC_CHAR */
			0x5b,		/* FC_END */
/* 1134 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1136 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1138 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1140 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1146) */
/* 1142 */	0x8,		/* FC_LONG */
			0x39,		/* FC_ALIGNM8 */
/* 1144 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1146 */	
			0x12, 0x0,	/* FC_UP */
/* 1148 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (1122) */
/* 1150 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1152 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1154 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1156 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1162) */
/* 1158 */	0x8,		/* FC_LONG */
			0x39,		/* FC_ALIGNM8 */
/* 1160 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1162 */	
			0x12, 0x0,	/* FC_UP */
/* 1164 */	NdrFcShort( 0xffffffd6 ),	/* Offset= -42 (1122) */
/* 1166 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1168 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1170 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1172 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1178) */
/* 1174 */	0x8,		/* FC_LONG */
			0x39,		/* FC_ALIGNM8 */
/* 1176 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1178 */	
			0x12, 0x0,	/* FC_UP */
/* 1180 */	NdrFcShort( 0xfffffe52 ),	/* Offset= -430 (750) */
/* 1182 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1184 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1186 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1188 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1194) */
/* 1190 */	0x8,		/* FC_LONG */
			0x39,		/* FC_ALIGNM8 */
/* 1192 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1194 */	
			0x12, 0x0,	/* FC_UP */
/* 1196 */	NdrFcShort( 0xfffffe42 ),	/* Offset= -446 (750) */
/* 1198 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1200 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1202 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1204 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1210) */
/* 1206 */	0x8,		/* FC_LONG */
			0x39,		/* FC_ALIGNM8 */
/* 1208 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1210 */	
			0x12, 0x0,	/* FC_UP */
/* 1212 */	NdrFcShort( 0xfffffe32 ),	/* Offset= -462 (750) */
/* 1214 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1216 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1218 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1220 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1226) */
/* 1222 */	0x8,		/* FC_LONG */
			0x39,		/* FC_ALIGNM8 */
/* 1224 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1226 */	
			0x12, 0x0,	/* FC_UP */
/* 1228 */	NdrFcShort( 0xfffffe3e ),	/* Offset= -450 (778) */
/* 1230 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1232 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1234 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1236 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1242) */
/* 1238 */	0x8,		/* FC_LONG */
			0x39,		/* FC_ALIGNM8 */
/* 1240 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1242 */	
			0x12, 0x0,	/* FC_UP */
/* 1244 */	NdrFcShort( 0xfffffe2e ),	/* Offset= -466 (778) */
/* 1246 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 1248 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1250 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1252 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1254 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1256 */	0xa,		/* FC_FLOAT */
			0x5b,		/* FC_END */
/* 1258 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1260 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1262 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1264 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1270) */
/* 1266 */	0x8,		/* FC_LONG */
			0x39,		/* FC_ALIGNM8 */
/* 1268 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1270 */	
			0x12, 0x0,	/* FC_UP */
/* 1272 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (1246) */
/* 1274 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1276 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1278 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1280 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1286) */
/* 1282 */	0x8,		/* FC_LONG */
			0x39,		/* FC_ALIGNM8 */
/* 1284 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1286 */	
			0x12, 0x0,	/* FC_UP */
/* 1288 */	NdrFcShort( 0xfffffe02 ),	/* Offset= -510 (778) */
/* 1290 */	
			0x1b,		/* FC_CARRAY */
			0x7,		/* 7 */
/* 1292 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1294 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1296 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1298 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1300 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1302 */	NdrFcShort( 0xfffffc2e ),	/* Offset= -978 (324) */
/* 1304 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1306 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1308 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1310 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1312 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1318) */
/* 1314 */	0x8,		/* FC_LONG */
			0x39,		/* FC_ALIGNM8 */
/* 1316 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1318 */	
			0x12, 0x0,	/* FC_UP */
/* 1320 */	NdrFcShort( 0xffffffe2 ),	/* Offset= -30 (1290) */
/* 1322 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1324 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1326 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1328 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1334) */
/* 1330 */	0x8,		/* FC_LONG */
			0x39,		/* FC_ALIGNM8 */
/* 1332 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1334 */	
			0x12, 0x0,	/* FC_UP */
/* 1336 */	NdrFcShort( 0xffffffd2 ),	/* Offset= -46 (1290) */
/* 1338 */	
			0x1b,		/* FC_CARRAY */
			0x7,		/* 7 */
/* 1340 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1342 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1344 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1346 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1348 */	0xc,		/* FC_DOUBLE */
			0x5b,		/* FC_END */
/* 1350 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1352 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1354 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1356 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1362) */
/* 1358 */	0x8,		/* FC_LONG */
			0x39,		/* FC_ALIGNM8 */
/* 1360 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1362 */	
			0x12, 0x0,	/* FC_UP */
/* 1364 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (1338) */
/* 1366 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1368 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1370 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1372 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1378) */
/* 1374 */	0x8,		/* FC_LONG */
			0x39,		/* FC_ALIGNM8 */
/* 1376 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1378 */	
			0x12, 0x0,	/* FC_UP */
/* 1380 */	NdrFcShort( 0xffffffa6 ),	/* Offset= -90 (1290) */
/* 1382 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1384 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1386 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1388 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1394) */
/* 1390 */	0x8,		/* FC_LONG */
			0x39,		/* FC_ALIGNM8 */
/* 1392 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1394 */	
			0x12, 0x0,	/* FC_UP */
/* 1396 */	NdrFcShort( 0xffffffc6 ),	/* Offset= -58 (1338) */
/* 1398 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 1400 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1402 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1404 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1406 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1408 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1410 */	NdrFcShort( 0xfffffdc0 ),	/* Offset= -576 (834) */
/* 1412 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1414 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1416 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1418 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1420 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1426) */
/* 1422 */	0x8,		/* FC_LONG */
			0x39,		/* FC_ALIGNM8 */
/* 1424 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1426 */	
			0x12, 0x0,	/* FC_UP */
/* 1428 */	NdrFcShort( 0xffffffe2 ),	/* Offset= -30 (1398) */
/* 1430 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 1432 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1434 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1436 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1438 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1440 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1442 */	NdrFcShort( 0xfffffd10 ),	/* Offset= -752 (690) */
/* 1444 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1446 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1448 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1450 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1452 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1458) */
/* 1454 */	0x8,		/* FC_LONG */
			0x39,		/* FC_ALIGNM8 */
/* 1456 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1458 */	
			0x12, 0x0,	/* FC_UP */
/* 1460 */	NdrFcShort( 0xffffffe2 ),	/* Offset= -30 (1430) */
/* 1462 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 1464 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1466 */	0x10,		/* Corr desc:  field pointer,  */
			0x59,		/* FC_CALLBACK */
/* 1468 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1470 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 1472 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 1474 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1476 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1478 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1480 */	NdrFcShort( 0x8 ),	/* Offset= 8 (1488) */
/* 1482 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1484 */	0x39,		/* FC_ALIGNM8 */
			0x36,		/* FC_POINTER */
/* 1486 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1488 */	
			0x12, 0x0,	/* FC_UP */
/* 1490 */	NdrFcShort( 0xffffffe4 ),	/* Offset= -28 (1462) */
/* 1492 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 1494 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1496 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1498 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1500 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1502 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 1506 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 1508 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1510 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (1474) */
/* 1512 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1514 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1516 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1518 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1520 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1526) */
/* 1522 */	0x8,		/* FC_LONG */
			0x39,		/* FC_ALIGNM8 */
/* 1524 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1526 */	
			0x12, 0x0,	/* FC_UP */
/* 1528 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (1492) */
/* 1530 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 1532 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1534 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1536 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1538 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1540 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 1544 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 1546 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1548 */	NdrFcShort( 0xfffffa10 ),	/* Offset= -1520 (28) */
/* 1550 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1552 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1554 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1556 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1558 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1564) */
/* 1560 */	0x8,		/* FC_LONG */
			0x39,		/* FC_ALIGNM8 */
/* 1562 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1564 */	
			0x12, 0x0,	/* FC_UP */
/* 1566 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (1530) */
/* 1568 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1570 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1572 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1574 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1580) */
/* 1576 */	0x8,		/* FC_LONG */
			0x39,		/* FC_ALIGNM8 */
/* 1578 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1580 */	
			0x12, 0x0,	/* FC_UP */
/* 1582 */	NdrFcShort( 0xfffffca4 ),	/* Offset= -860 (722) */
/* 1584 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 1586 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1588 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1590 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1592 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1594 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 1598 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 1600 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1602 */	NdrFcShort( 0xffffffde ),	/* Offset= -34 (1568) */
/* 1604 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1606 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1608 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1610 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1612 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1618) */
/* 1614 */	0x8,		/* FC_LONG */
			0x39,		/* FC_ALIGNM8 */
/* 1616 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1618 */	
			0x12, 0x0,	/* FC_UP */
/* 1620 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (1584) */
/* 1622 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 1624 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1626 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1628 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1630 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1632 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 1636 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 1638 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 1640 */	
			0x22,		/* FC_C_CSTRING */
			0x5c,		/* FC_PAD */
/* 1642 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1644 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1646 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1648 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1650 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1656) */
/* 1652 */	0x8,		/* FC_LONG */
			0x39,		/* FC_ALIGNM8 */
/* 1654 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1656 */	
			0x12, 0x0,	/* FC_UP */
/* 1658 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (1622) */
/* 1660 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 1662 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1664 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1666 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1668 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1670 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 1674 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 1676 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 1678 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 1680 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1682 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1684 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1686 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1688 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1694) */
/* 1690 */	0x8,		/* FC_LONG */
			0x39,		/* FC_ALIGNM8 */
/* 1692 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1694 */	
			0x12, 0x0,	/* FC_UP */
/* 1696 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (1660) */
/* 1698 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0x7,		/* FC_USHORT */
/* 1700 */	0x0,		/* Corr desc:  */
			0x59,		/* FC_CALLBACK */
/* 1702 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1704 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 1706 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1708) */
/* 1708 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1710 */	NdrFcShort( 0x61 ),	/* 97 */
/* 1712 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1716 */	NdrFcShort( 0x0 ),	/* Offset= 0 (1716) */
/* 1718 */	NdrFcLong( 0x1 ),	/* 1 */
/* 1722 */	NdrFcShort( 0x0 ),	/* Offset= 0 (1722) */
/* 1724 */	NdrFcLong( 0x10 ),	/* 16 */
/* 1728 */	NdrFcShort( 0x8002 ),	/* Simple arm type: FC_CHAR */
/* 1730 */	NdrFcLong( 0x11 ),	/* 17 */
/* 1734 */	NdrFcShort( 0x8002 ),	/* Simple arm type: FC_CHAR */
/* 1736 */	NdrFcLong( 0x2 ),	/* 2 */
/* 1740 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 1742 */	NdrFcLong( 0x12 ),	/* 18 */
/* 1746 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 1748 */	NdrFcLong( 0x3 ),	/* 3 */
/* 1752 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 1754 */	NdrFcLong( 0x13 ),	/* 19 */
/* 1758 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 1760 */	NdrFcLong( 0x16 ),	/* 22 */
/* 1764 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 1766 */	NdrFcLong( 0x17 ),	/* 23 */
/* 1770 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 1772 */	NdrFcLong( 0xe ),	/* 14 */
/* 1776 */	NdrFcShort( 0xfffffa54 ),	/* Offset= -1452 (324) */
/* 1778 */	NdrFcLong( 0x14 ),	/* 20 */
/* 1782 */	NdrFcShort( 0xfffffa4e ),	/* Offset= -1458 (324) */
/* 1784 */	NdrFcLong( 0x15 ),	/* 21 */
/* 1788 */	NdrFcShort( 0xfffffa48 ),	/* Offset= -1464 (324) */
/* 1790 */	NdrFcLong( 0x4 ),	/* 4 */
/* 1794 */	NdrFcShort( 0x800a ),	/* Simple arm type: FC_FLOAT */
/* 1796 */	NdrFcLong( 0x5 ),	/* 5 */
/* 1800 */	NdrFcShort( 0x800c ),	/* Simple arm type: FC_DOUBLE */
/* 1802 */	NdrFcLong( 0xb ),	/* 11 */
/* 1806 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 1808 */	NdrFcLong( 0xffff ),	/* 65535 */
/* 1812 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 1814 */	NdrFcLong( 0xa ),	/* 10 */
/* 1818 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 1820 */	NdrFcLong( 0x6 ),	/* 6 */
/* 1824 */	NdrFcShort( 0xfffffa24 ),	/* Offset= -1500 (324) */
/* 1826 */	NdrFcLong( 0x7 ),	/* 7 */
/* 1830 */	NdrFcShort( 0x800c ),	/* Simple arm type: FC_DOUBLE */
/* 1832 */	NdrFcLong( 0x40 ),	/* 64 */
/* 1836 */	NdrFcShort( 0xfffffc16 ),	/* Offset= -1002 (834) */
/* 1838 */	NdrFcLong( 0x48 ),	/* 72 */
/* 1842 */	NdrFcShort( 0x1c6 ),	/* Offset= 454 (2296) */
/* 1844 */	NdrFcLong( 0x47 ),	/* 71 */
/* 1848 */	NdrFcShort( 0x1c4 ),	/* Offset= 452 (2300) */
/* 1850 */	NdrFcLong( 0x8 ),	/* 8 */
/* 1854 */	NdrFcShort( 0xfffff8de ),	/* Offset= -1826 (28) */
/* 1856 */	NdrFcLong( 0xfff ),	/* 4095 */
/* 1860 */	NdrFcShort( 0xfffffedc ),	/* Offset= -292 (1568) */
/* 1862 */	NdrFcLong( 0x41 ),	/* 65 */
/* 1866 */	NdrFcShort( 0x1b6 ),	/* Offset= 438 (2304) */
/* 1868 */	NdrFcLong( 0x46 ),	/* 70 */
/* 1872 */	NdrFcShort( 0x1b0 ),	/* Offset= 432 (2304) */
/* 1874 */	NdrFcLong( 0x1e ),	/* 30 */
/* 1878 */	NdrFcShort( 0x1ba ),	/* Offset= 442 (2320) */
/* 1880 */	NdrFcLong( 0x1f ),	/* 31 */
/* 1884 */	NdrFcShort( 0x1b8 ),	/* Offset= 440 (2324) */
/* 1886 */	NdrFcLong( 0xd ),	/* 13 */
/* 1890 */	NdrFcShort( 0xfffff9e8 ),	/* Offset= -1560 (330) */
/* 1892 */	NdrFcLong( 0x9 ),	/* 9 */
/* 1896 */	NdrFcShort( 0xfffff9f4 ),	/* Offset= -1548 (348) */
/* 1898 */	NdrFcLong( 0x42 ),	/* 66 */
/* 1902 */	NdrFcShort( 0xfffffcc4 ),	/* Offset= -828 (1074) */
/* 1904 */	NdrFcLong( 0x44 ),	/* 68 */
/* 1908 */	NdrFcShort( 0xfffffcbe ),	/* Offset= -834 (1074) */
/* 1910 */	NdrFcLong( 0x43 ),	/* 67 */
/* 1914 */	NdrFcShort( 0xfffffcce ),	/* Offset= -818 (1096) */
/* 1916 */	NdrFcLong( 0x45 ),	/* 69 */
/* 1920 */	NdrFcShort( 0xfffffcc8 ),	/* Offset= -824 (1096) */
/* 1922 */	NdrFcLong( 0x49 ),	/* 73 */
/* 1926 */	NdrFcShort( 0x192 ),	/* Offset= 402 (2328) */
/* 1928 */	NdrFcLong( 0x2010 ),	/* 8208 */
/* 1932 */	NdrFcShort( 0xfffffc46 ),	/* Offset= -954 (978) */
/* 1934 */	NdrFcLong( 0x2011 ),	/* 8209 */
/* 1938 */	NdrFcShort( 0xfffffc40 ),	/* Offset= -960 (978) */
/* 1940 */	NdrFcLong( 0x2002 ),	/* 8194 */
/* 1944 */	NdrFcShort( 0xfffffc3a ),	/* Offset= -966 (978) */
/* 1946 */	NdrFcLong( 0x2012 ),	/* 8210 */
/* 1950 */	NdrFcShort( 0xfffffc34 ),	/* Offset= -972 (978) */
/* 1952 */	NdrFcLong( 0x2003 ),	/* 8195 */
/* 1956 */	NdrFcShort( 0xfffffc2e ),	/* Offset= -978 (978) */
/* 1958 */	NdrFcLong( 0x2013 ),	/* 8211 */
/* 1962 */	NdrFcShort( 0xfffffc28 ),	/* Offset= -984 (978) */
/* 1964 */	NdrFcLong( 0x2016 ),	/* 8214 */
/* 1968 */	NdrFcShort( 0xfffffc22 ),	/* Offset= -990 (978) */
/* 1970 */	NdrFcLong( 0x2017 ),	/* 8215 */
/* 1974 */	NdrFcShort( 0xfffffc1c ),	/* Offset= -996 (978) */
/* 1976 */	NdrFcLong( 0x2004 ),	/* 8196 */
/* 1980 */	NdrFcShort( 0xfffffc16 ),	/* Offset= -1002 (978) */
/* 1982 */	NdrFcLong( 0x2005 ),	/* 8197 */
/* 1986 */	NdrFcShort( 0xfffffc10 ),	/* Offset= -1008 (978) */
/* 1988 */	NdrFcLong( 0x2006 ),	/* 8198 */
/* 1992 */	NdrFcShort( 0xfffffc0a ),	/* Offset= -1014 (978) */
/* 1994 */	NdrFcLong( 0x2007 ),	/* 8199 */
/* 1998 */	NdrFcShort( 0xfffffc04 ),	/* Offset= -1020 (978) */
/* 2000 */	NdrFcLong( 0x2008 ),	/* 8200 */
/* 2004 */	NdrFcShort( 0xfffffbfe ),	/* Offset= -1026 (978) */
/* 2006 */	NdrFcLong( 0x200b ),	/* 8203 */
/* 2010 */	NdrFcShort( 0xfffffbf8 ),	/* Offset= -1032 (978) */
/* 2012 */	NdrFcLong( 0x200e ),	/* 8206 */
/* 2016 */	NdrFcShort( 0xfffffbf2 ),	/* Offset= -1038 (978) */
/* 2018 */	NdrFcLong( 0x2009 ),	/* 8201 */
/* 2022 */	NdrFcShort( 0xfffffbec ),	/* Offset= -1044 (978) */
/* 2024 */	NdrFcLong( 0x200d ),	/* 8205 */
/* 2028 */	NdrFcShort( 0xfffffbe6 ),	/* Offset= -1050 (978) */
/* 2030 */	NdrFcLong( 0x200a ),	/* 8202 */
/* 2034 */	NdrFcShort( 0xfffffbe0 ),	/* Offset= -1056 (978) */
/* 2036 */	NdrFcLong( 0x200c ),	/* 8204 */
/* 2040 */	NdrFcShort( 0xfffffbda ),	/* Offset= -1062 (978) */
/* 2042 */	NdrFcLong( 0x1010 ),	/* 4112 */
/* 2046 */	NdrFcShort( 0xfffffc70 ),	/* Offset= -912 (1134) */
/* 2048 */	NdrFcLong( 0x1011 ),	/* 4113 */
/* 2052 */	NdrFcShort( 0xfffffc7a ),	/* Offset= -902 (1150) */
/* 2054 */	NdrFcLong( 0x1002 ),	/* 4098 */
/* 2058 */	NdrFcShort( 0xfffffc84 ),	/* Offset= -892 (1166) */
/* 2060 */	NdrFcLong( 0x1012 ),	/* 4114 */
/* 2064 */	NdrFcShort( 0xfffffc8e ),	/* Offset= -882 (1182) */
/* 2066 */	NdrFcLong( 0x1003 ),	/* 4099 */
/* 2070 */	NdrFcShort( 0xfffffca8 ),	/* Offset= -856 (1214) */
/* 2072 */	NdrFcLong( 0x1013 ),	/* 4115 */
/* 2076 */	NdrFcShort( 0xfffffcb2 ),	/* Offset= -846 (1230) */
/* 2078 */	NdrFcLong( 0x1014 ),	/* 4116 */
/* 2082 */	NdrFcShort( 0xfffffcf8 ),	/* Offset= -776 (1306) */
/* 2084 */	NdrFcLong( 0x1015 ),	/* 4117 */
/* 2088 */	NdrFcShort( 0xfffffd02 ),	/* Offset= -766 (1322) */
/* 2090 */	NdrFcLong( 0x1004 ),	/* 4100 */
/* 2094 */	NdrFcShort( 0xfffffcbc ),	/* Offset= -836 (1258) */
/* 2096 */	NdrFcLong( 0x1005 ),	/* 4101 */
/* 2100 */	NdrFcShort( 0xfffffd12 ),	/* Offset= -750 (1350) */
/* 2102 */	NdrFcLong( 0x100b ),	/* 4107 */
/* 2106 */	NdrFcShort( 0xfffffc74 ),	/* Offset= -908 (1198) */
/* 2108 */	NdrFcLong( 0x100a ),	/* 4106 */
/* 2112 */	NdrFcShort( 0xfffffcba ),	/* Offset= -838 (1274) */
/* 2114 */	NdrFcLong( 0x1006 ),	/* 4102 */
/* 2118 */	NdrFcShort( 0xfffffd10 ),	/* Offset= -752 (1366) */
/* 2120 */	NdrFcLong( 0x1007 ),	/* 4103 */
/* 2124 */	NdrFcShort( 0xfffffd1a ),	/* Offset= -742 (1382) */
/* 2126 */	NdrFcLong( 0x1040 ),	/* 4160 */
/* 2130 */	NdrFcShort( 0xfffffd34 ),	/* Offset= -716 (1414) */
/* 2132 */	NdrFcLong( 0x1048 ),	/* 4168 */
/* 2136 */	NdrFcShort( 0xfffffd4e ),	/* Offset= -690 (1446) */
/* 2138 */	NdrFcLong( 0x1047 ),	/* 4167 */
/* 2142 */	NdrFcShort( 0xfffffd8c ),	/* Offset= -628 (1514) */
/* 2144 */	NdrFcLong( 0x1008 ),	/* 4104 */
/* 2148 */	NdrFcShort( 0xfffffdac ),	/* Offset= -596 (1552) */
/* 2150 */	NdrFcLong( 0x1fff ),	/* 8191 */
/* 2154 */	NdrFcShort( 0xfffffddc ),	/* Offset= -548 (1606) */
/* 2156 */	NdrFcLong( 0x101e ),	/* 4126 */
/* 2160 */	NdrFcShort( 0xfffffdfc ),	/* Offset= -516 (1644) */
/* 2162 */	NdrFcLong( 0x101f ),	/* 4127 */
/* 2166 */	NdrFcShort( 0xfffffe1c ),	/* Offset= -484 (1682) */
/* 2168 */	NdrFcLong( 0x100c ),	/* 4108 */
/* 2172 */	NdrFcShort( 0xe6 ),	/* Offset= 230 (2402) */
/* 2174 */	NdrFcLong( 0x4010 ),	/* 16400 */
/* 2178 */	NdrFcShort( 0xfffffb2e ),	/* Offset= -1234 (944) */
/* 2180 */	NdrFcLong( 0x4011 ),	/* 16401 */
/* 2184 */	NdrFcShort( 0xfffffb28 ),	/* Offset= -1240 (944) */
/* 2186 */	NdrFcLong( 0x4002 ),	/* 16386 */
/* 2190 */	NdrFcShort( 0xfffffae6 ),	/* Offset= -1306 (884) */
/* 2192 */	NdrFcLong( 0x4012 ),	/* 16402 */
/* 2196 */	NdrFcShort( 0xfffffae0 ),	/* Offset= -1312 (884) */
/* 2198 */	NdrFcLong( 0x4003 ),	/* 16387 */
/* 2202 */	NdrFcShort( 0xfffffade ),	/* Offset= -1314 (888) */
/* 2204 */	NdrFcLong( 0x4013 ),	/* 16403 */
/* 2208 */	NdrFcShort( 0xfffffad8 ),	/* Offset= -1320 (888) */
/* 2210 */	NdrFcLong( 0x4016 ),	/* 16406 */
/* 2214 */	NdrFcShort( 0xfffffad2 ),	/* Offset= -1326 (888) */
/* 2216 */	NdrFcLong( 0x4017 ),	/* 16407 */
/* 2220 */	NdrFcShort( 0xfffffacc ),	/* Offset= -1332 (888) */
/* 2222 */	NdrFcLong( 0x4004 ),	/* 16388 */
/* 2226 */	NdrFcShort( 0xfffffaca ),	/* Offset= -1334 (892) */
/* 2228 */	NdrFcLong( 0x4005 ),	/* 16389 */
/* 2232 */	NdrFcShort( 0xfffffac8 ),	/* Offset= -1336 (896) */
/* 2234 */	NdrFcLong( 0x400b ),	/* 16395 */
/* 2238 */	NdrFcShort( 0xfffffab6 ),	/* Offset= -1354 (884) */
/* 2240 */	NdrFcLong( 0x400e ),	/* 16398 */
/* 2244 */	NdrFcShort( 0xfffffae8 ),	/* Offset= -1304 (940) */
/* 2246 */	NdrFcLong( 0x400a ),	/* 16394 */
/* 2250 */	NdrFcShort( 0xfffffaae ),	/* Offset= -1362 (888) */
/* 2252 */	NdrFcLong( 0x4006 ),	/* 16390 */
/* 2256 */	NdrFcShort( 0xfffffab4 ),	/* Offset= -1356 (900) */
/* 2258 */	NdrFcLong( 0x4007 ),	/* 16391 */
/* 2262 */	NdrFcShort( 0xfffffaaa ),	/* Offset= -1366 (896) */
/* 2264 */	NdrFcLong( 0x4008 ),	/* 16392 */
/* 2268 */	NdrFcShort( 0x52 ),	/* Offset= 82 (2350) */
/* 2270 */	NdrFcLong( 0x400d ),	/* 16397 */
/* 2274 */	NdrFcShort( 0xfffffaaa ),	/* Offset= -1366 (908) */
/* 2276 */	NdrFcLong( 0x4009 ),	/* 16393 */
/* 2280 */	NdrFcShort( 0xfffffaa8 ),	/* Offset= -1368 (912) */
/* 2282 */	NdrFcLong( 0x6000 ),	/* 24576 */
/* 2286 */	NdrFcShort( 0x44 ),	/* Offset= 68 (2354) */
/* 2288 */	NdrFcLong( 0x400c ),	/* 16396 */
/* 2292 */	NdrFcShort( 0x42 ),	/* Offset= 66 (2358) */
/* 2294 */	NdrFcShort( 0xffffffff ),	/* Offset= -1 (2293) */
/* 2296 */	
			0x12, 0x0,	/* FC_UP */
/* 2298 */	NdrFcShort( 0xfffff9b8 ),	/* Offset= -1608 (690) */
/* 2300 */	
			0x12, 0x0,	/* FC_UP */
/* 2302 */	NdrFcShort( 0xfffffcc4 ),	/* Offset= -828 (1474) */
/* 2304 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 2306 */	NdrFcShort( 0x10 ),	/* 16 */
/* 2308 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2310 */	NdrFcShort( 0x6 ),	/* Offset= 6 (2316) */
/* 2312 */	0x8,		/* FC_LONG */
			0x39,		/* FC_ALIGNM8 */
/* 2314 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 2316 */	
			0x12, 0x0,	/* FC_UP */
/* 2318 */	NdrFcShort( 0xfffff9c4 ),	/* Offset= -1596 (722) */
/* 2320 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 2322 */	
			0x22,		/* FC_C_CSTRING */
			0x5c,		/* FC_PAD */
/* 2324 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 2326 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 2328 */	
			0x12, 0x0,	/* FC_UP */
/* 2330 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2332) */
/* 2332 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 2334 */	NdrFcShort( 0x18 ),	/* 24 */
/* 2336 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2338 */	NdrFcShort( 0xc ),	/* Offset= 12 (2350) */
/* 2340 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 2342 */	NdrFcShort( 0xfffff98c ),	/* Offset= -1652 (690) */
/* 2344 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 2346 */	NdrFcShort( 0xfffffb08 ),	/* Offset= -1272 (1074) */
/* 2348 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 2350 */	
			0x12, 0x0,	/* FC_UP */
/* 2352 */	NdrFcShort( 0xfffff6ec ),	/* Offset= -2324 (28) */
/* 2354 */	
			0x12, 0x0,	/* FC_UP */
/* 2356 */	NdrFcShort( 0xfffffa9e ),	/* Offset= -1378 (978) */
/* 2358 */	
			0x12, 0x0,	/* FC_UP */
/* 2360 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2362) */
/* 2362 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x7,		/* 7 */
/* 2364 */	NdrFcShort( 0x18 ),	/* 24 */
/* 2366 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2368 */	NdrFcShort( 0x0 ),	/* Offset= 0 (2368) */
/* 2370 */	0x6,		/* FC_SHORT */
			0x1,		/* FC_BYTE */
/* 2372 */	0x1,		/* FC_BYTE */
			0x38,		/* FC_ALIGNM4 */
/* 2374 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 2376 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffd59 ),	/* Offset= -679 (1698) */
			0x5b,		/* FC_END */
/* 2380 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x7,		/* 7 */
/* 2382 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2384 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 2386 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2388 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 2390 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 2394 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 2396 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 2398 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (2362) */
/* 2400 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 2402 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 2404 */	NdrFcShort( 0x10 ),	/* 16 */
/* 2406 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2408 */	NdrFcShort( 0x6 ),	/* Offset= 6 (2414) */
/* 2410 */	0x8,		/* FC_LONG */
			0x39,		/* FC_ALIGNM8 */
/* 2412 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 2414 */	
			0x12, 0x0,	/* FC_UP */
/* 2416 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (2380) */
/* 2418 */	
			0x12, 0x0,	/* FC_UP */
/* 2420 */	NdrFcShort( 0xfffffafa ),	/* Offset= -1286 (1134) */
/* 2422 */	
			0x12, 0x0,	/* FC_UP */
/* 2424 */	NdrFcShort( 0xfffffb06 ),	/* Offset= -1274 (1150) */
/* 2426 */	
			0x12, 0x0,	/* FC_UP */
/* 2428 */	NdrFcShort( 0xfffffb12 ),	/* Offset= -1262 (1166) */
/* 2430 */	
			0x12, 0x0,	/* FC_UP */
/* 2432 */	NdrFcShort( 0xfffffb1e ),	/* Offset= -1250 (1182) */
/* 2434 */	
			0x12, 0x0,	/* FC_UP */
/* 2436 */	NdrFcShort( 0xfffffb2a ),	/* Offset= -1238 (1198) */
/* 2438 */	
			0x12, 0x0,	/* FC_UP */
/* 2440 */	NdrFcShort( 0xfffffb36 ),	/* Offset= -1226 (1214) */
/* 2442 */	
			0x12, 0x0,	/* FC_UP */
/* 2444 */	NdrFcShort( 0xfffffb42 ),	/* Offset= -1214 (1230) */
/* 2446 */	
			0x12, 0x0,	/* FC_UP */
/* 2448 */	NdrFcShort( 0xfffffb5a ),	/* Offset= -1190 (1258) */
/* 2450 */	
			0x12, 0x0,	/* FC_UP */
/* 2452 */	NdrFcShort( 0xfffffb66 ),	/* Offset= -1178 (1274) */
/* 2454 */	
			0x12, 0x0,	/* FC_UP */
/* 2456 */	NdrFcShort( 0xfffffb82 ),	/* Offset= -1150 (1306) */
/* 2458 */	
			0x12, 0x0,	/* FC_UP */
/* 2460 */	NdrFcShort( 0xfffffb8e ),	/* Offset= -1138 (1322) */
/* 2462 */	
			0x12, 0x0,	/* FC_UP */
/* 2464 */	NdrFcShort( 0xfffffba6 ),	/* Offset= -1114 (1350) */
/* 2466 */	
			0x12, 0x0,	/* FC_UP */
/* 2468 */	NdrFcShort( 0xfffffbb2 ),	/* Offset= -1102 (1366) */
/* 2470 */	
			0x12, 0x0,	/* FC_UP */
/* 2472 */	NdrFcShort( 0xfffffbbe ),	/* Offset= -1090 (1382) */
/* 2474 */	
			0x12, 0x0,	/* FC_UP */
/* 2476 */	NdrFcShort( 0xfffffbda ),	/* Offset= -1062 (1414) */
/* 2478 */	
			0x12, 0x0,	/* FC_UP */
/* 2480 */	NdrFcShort( 0xfffffbf6 ),	/* Offset= -1034 (1446) */
/* 2482 */	
			0x12, 0x0,	/* FC_UP */
/* 2484 */	NdrFcShort( 0xfffffc36 ),	/* Offset= -970 (1514) */
/* 2486 */	
			0x12, 0x0,	/* FC_UP */
/* 2488 */	NdrFcShort( 0xfffffc58 ),	/* Offset= -936 (1552) */
/* 2490 */	
			0x12, 0x0,	/* FC_UP */
/* 2492 */	NdrFcShort( 0xfffffc8a ),	/* Offset= -886 (1606) */
/* 2494 */	
			0x12, 0x0,	/* FC_UP */
/* 2496 */	NdrFcShort( 0xfffffcac ),	/* Offset= -852 (1644) */
/* 2498 */	
			0x12, 0x0,	/* FC_UP */
/* 2500 */	NdrFcShort( 0xfffffcce ),	/* Offset= -818 (1682) */
/* 2502 */	
			0x12, 0x0,	/* FC_UP */
/* 2504 */	NdrFcShort( 0xffffff9a ),	/* Offset= -102 (2402) */

			0x0, 0x0
        }
    };

#endif // __RPC_WIN64__

const BYTE VT_FC_MAP [] = 
{
FC_ZERO,
FC_ZERO,
FC_SHORT,
FC_LONG,
FC_FLOAT,
FC_DOUBLE,
FC_HYPER,
FC_DOUBLE,
FC_EMBEDDED_COMPLEX,    // vt_bstr
FC_EMBEDDED_COMPLEX,    // vt_dispatch
FC_LONG,
FC_SHORT,                          // vt_bool
FC_EMBEDDED_COMPLEX,    // vt_variant
FC_EMBEDDED_COMPLEX,    // vt_unknown
FC_EMBEDDED_COMPLEX,    // vt_decimal
FC_ZERO,        // reserved,
FC_SMALL,
FC_SMALL,
FC_SHORT,
FC_LONG,
FC_HYPER,       // VT_I8
FC_HYPER,
FC_LONG,
FC_LONG,
FC_ZERO,        //VT_VOID
FC_LONG,
FC_ZERO,    //VT_PTR
FC_ZERO,    // we don't have a canned string for safearray
FC_ZERO,
FC_ZERO,    // VT_USERDEFINED
FC_EMBEDDED_COMPLEX,
FC_EMBEDDED_COMPLEX,
FC_ZERO,
FC_ZERO,
FC_ZERO,
FC_ZERO,
FC_ZERO,    //VT_RECORD
FC_ZERO,    // VT_INT_PTR
FC_ZERO,    // RESERVED
FC_ZERO,
FC_ZERO,
FC_ZERO,
FC_ZERO,
FC_ZERO,
FC_ZERO,
FC_ZERO,
FC_ZERO,
FC_ZERO,
FC_ZERO,
FC_ZERO,
FC_ZERO,
FC_ZERO,
FC_ZERO,
FC_ZERO,
FC_ZERO,
FC_ZERO,
FC_ZERO,
FC_ZERO,
FC_ZERO,
FC_ZERO,
FC_ZERO,
FC_ZERO,
FC_ZERO,
FC_ZERO,
FC_EMBEDDED_COMPLEX,        // vt_filetime
FC_ZERO,
FC_EMBEDDED_COMPLEX,        // VT_STREAM
FC_EMBEDDED_COMPLEX,        // VT_STORAGE
FC_ZERO,
FC_ZERO,
FC_ZERO,
FC_ZERO,
FC_ZERO,
FC_ZERO
};

C_ASSERT( sizeof( VT_FC_MAP) == sizeof(BYTE)*(VT_VERSIONED_STREAM+1) );

// array of offset of different vartypes in the canned format string
// 0xffff is invalid value, 0 means irrelavant (simple type)
// first dimension is the vt value, second is byref or not.
const ushort OffsetArray[][2]=
{
0xffff,                                         0xffff,
0xffff,                                         0xffff,
0,                                                  BYREF_I2_TYPE_FS_OFFSET,
0,                                                  BYREF_I4_TYPE_FS_OFFSET,
0,                                                  BYREF_R4_TYPE_FS_OFFSET,
0,                                                  BYREF_R8_TYPE_FS_OFFSET,
0,                                                  0xffff,
0,                                                  BYREF_R8_TYPE_FS_OFFSET,
BSTR_TYPE_FS_OFFSET,                 BYREF_BSTR_TYPE_FS_OFFSET,
DISPATCH_TYPE_FS_OFFSET,          BYREF_DISPATCH_TYPE_FS_OFFSET,
0,                                                  BYREF_I4_TYPE_FS_OFFSET,    //vt_error
0,                                                  BYREF_I2_TYPE_FS_OFFSET,    //vt_bool
VARIANT_TYPE_FS_OFFSET,            BYREF_VARIANT_TYPE_FS_OFFSET,
UNKNOWN_TYPE_FS_OFFSET,          BYREF_UNKNOWN_TYPE_FS_OFFSET,
// this is for top level parameter only. (srv alloc). in struct case a FC_UP is added.
DECIMAL_TYPE_FS_OFFSET,            DECIMAL_TYPE_FS_OFFSET, //vt_decimal
0xffff,                                         0xffff,     // reserved
0,                                                  BYREF_I1_TYPE_FS_OFFSET,
0,                                                  BYREF_I1_TYPE_FS_OFFSET,    // vt_ui1
0,                                                  BYREF_I2_TYPE_FS_OFFSET,    // vt_ui2
0,                                                  BYREF_I4_TYPE_FS_OFFSET,    // vt_ui4
// we don't have pointer to fc_hyper in the canned string.
0,                                                  0xffff,
0,                                                  0xffff,
0,                                                  BYREF_I4_TYPE_FS_OFFSET,    // vt_int
0,                                                  BYREF_I4_TYPE_FS_OFFSET,    // vt_uint
0xffff,                                         0xffff,                                  // vt_void
0,                                                  BYREF_I4_TYPE_FS_OFFSET,    // vt_hresult
0xffff,                                         0xffff,                                  // vt_ptr
0xffff,                                         0xffff,                                 // vt_safearray
0xffff,                                         0xffff,                                 // vt_carray
0xffff,                                         0xffff,                                 // vt_userdefined
LPSTR_TYPE_FS_OFFSET,                BYREF_LPSTR_TYPE_FS_OFFSET,
LPWSTR_TYPE_FS_OFFSET,             BYREF_LPWSTR_TYPE_FS_OFFSET,
0xffff,                                         0xffff,     // reserved
0xffff,                                         0xffff,     // reserved
0xffff,                                         0xffff,     // reserved
0xffff,                                         0xffff,     // reserved
0xffff,                                         0xffff,     // vt_record
0xffff,                                         0xffff,     // vt_int_ptr
0xffff,                                         0xffff,     // vt_uint_ptr
0xffff,                                         0xffff,     // reserved
0xffff,                                         0xffff,     // reserved
0xffff,                                         0xffff,     // reserved
0xffff,                                         0xffff,     // reserved
0xffff,                                         0xffff,     // reserved
0xffff,                                         0xffff,     // reserved
0xffff,                                         0xffff,     // reserved
0xffff,                                         0xffff,     // reserved
0xffff,                                         0xffff,     // reserved
0xffff,                                         0xffff,     // reserved
0xffff,                                         0xffff,     // reserved
0xffff,                                         0xffff,     // reserved
0xffff,                                         0xffff,     // reserved
0xffff,                                         0xffff,     // reserved
0xffff,                                         0xffff,     // reserved
0xffff,                                         0xffff,     // reserved
0xffff,                                         0xffff,     // reserved
0xffff,                                         0xffff,     // reserved
0xffff,                                         0xffff,     // reserved
0xffff,                                         0xffff,     // reserved
0xffff,                                         0xffff,     // reserved
0xffff,                                         0xffff,     // reserved
0xffff,                                         0xffff,     // reserved
0xffff,                                         0xffff,     // reserved
0xffff,                                         0xffff,     // reserved
FILETIME_TYPE_FS_OFFSET,            BYREF_FILETIME_TYPE_FS_OFFSET,
0xffff,                                         0xffff,     // vt_blob
STREAM_TYPE_FS_OFFSET,              BYREF_STREAM_TYPE_FS_OFFSET,
STORAGE_TYPE_FS_OFFSET,           BYREF_STORAGE_TYPE_FS_OFFSET,
0xffff,                                         0xffff,     // vt_streamed_object
0xffff,                                         0xffff,     // vt_stored_object
0xffff,                                         0xffff,     // vt_blob_object
0xffff,                                         0xffff,     // vt_cf
0xffff,                                         0xffff,     // vt_clsid
0xffff,                                         0xffff,     // vt_interface
};

C_ASSERT( sizeof( OffsetArray) == (VT_VERSIONED_STREAM+1)*sizeof(short)*2 );

// memory and wire information about a vt datatype. sometimes the wiresize
// is irrelavant (like UDT or interface pointer). we only use wiresize for asserting
// invalid value and calcSize. memsize/memalign & wirealign are used.
const MemoryInfo VarMemInfo[] = 
{
{0,0,0,0},              
{0,0,0,0},
{2,1,2,1},
{4,3,4,3},
{4,3,4,3},
{8,7,8,7},
{8,7,8,7},
{8,7,8,7},
{sizeof(BSTR),PTR_MEM_ALIGN, 4,3},  // VT_BSTR
{PTR_MEM_SIZE,PTR_MEM_ALIGN, 4,3},  // vt_dispatch
{4,3,4,3},
{2,1,2,1},
{sizeof(VARIANT),7, sizeof(VARIANT),7},                       // vt_variant
{PTR_MEM_SIZE,PTR_MEM_ALIGN, 4,3},  // vt_unknown
// decimal is naturally aligned so the wiresize is always same as memsize
{sizeof(DECIMAL), 7, sizeof(DECIMAL), 7},
{0,0,0,0},          // reserved
{1,0,1,0},          // vt_ui1
{1,0,1,0},
{2,1,2,1},          // vt_ui2
{4,3,4,3},      
{8,7,8,7},
{8,7,8,7},          // vt_ui8
{4,3,4,3},      
{4,3,4,3},      
{0,0,0,0},          // vt_void
{4,3,4,3},      
{PTR_MEM_SIZE,PTR_MEM_ALIGN, 4,3},  // vt_ptr
{PTR_MEM_SIZE,PTR_MEM_ALIGN, 4,3},  // safearray
{0,0,0,0},           // vt_carray
{0,0,0,0},           // vt_userdefined
{PTR_MEM_SIZE,PTR_MEM_ALIGN, 4,3},  // vt_lpstr
{PTR_MEM_SIZE,PTR_MEM_ALIGN, 4,3},  // vt_lpwstr
{0,0,0,0},          // reserved
{0,0,0,0},          // reserved
{0,0,0,0},          // reserved
{0,0,0,0},          // reserved
{0,0,0,0},           // vt_record
{0,0,0,0},          // vt_int_ptr
{0,0,0,0},          // vt_uint_ptr
{0,0,0,0},          // reserved
{0,0,0,0},          // reserved
{0,0,0,0},          // reserved
{0,0,0,0},          // reserved
{0,0,0,0},          // reserved
{0,0,0,0},          // reserved
{0,0,0,0},          // reserved
{0,0,0,0},          // reserved
{0,0,0,0},          // reserved
{0,0,0,0},          // reserved
{0,0,0,0},          // reserved
{0,0,0,0},          // reserved
{0,0,0,0},          // reserved
{0,0,0,0},          // reserved
{0,0,0,0},          // reserved
{0,0,0,0},          // reserved
{0,0,0,0},          // reserved
{0,0,0,0},          // reserved
{0,0,0,0},          // reserved
{0,0,0,0},          // reserved
{0,0,0,0},          // reserved
{0,0,0,0},          // reserved
{0,0,0,0},          // reserved
{0,0,0,0},          // reserved
{0,0,0,0},          // reserved
{8,3,8,3},          // vt_filetime
{0,0,0,0},          // vt_blob
{PTR_MEM_SIZE,PTR_MEM_ALIGN, 4,3},  // vt_stream
{PTR_MEM_SIZE,PTR_MEM_ALIGN, 4,3},  // vt_storage
{0,0,0,0},          // vt_blob
{0,0,0,0},          // vt_blob
{0,0,0,0},          // vt_blob
{0,0,0,0},          // vt_blob
{0,0,0,0},          // vt_blob
{PTR_MEM_SIZE,PTR_MEM_ALIGN, 4,3},  // vt_interface
};

C_ASSERT( sizeof(VarMemInfo) == sizeof(MemoryInfo)*(VT_VERSIONED_STREAM+1) );

#endif // _FMTSTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr20\fullptr.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1993 Microsoft Corporation

Module Name :

    fullptr.c

Abstract :

    This file contains the APIs for handling full pointers in the NDR engine
    and inlined stubs for MIDL 2.0.

Author :

    David Kays  dkays   January 1994.

Revision History :

  ---------------------------------------------------------------------*/

#include "ndrp.h"

static void 
NdrFullPointerXlatRealloc ( PFULL_PTR_XLAT_TABLES pXlatTables, ulong RefId );


PFULL_PTR_XLAT_TABLES RPC_ENTRY
NdrFullPointerXlatInit( 
    ulong       NumberOfPointers,
    XLAT_SIDE   XlatSide )
/***

Routine description :

    Allocates full pointer support data structures for an RPC call.

Arguments :

    NumberOfPointer - If possible, the stub passes in the total number
                      of possible full pointers that will be used during a call.

Return value :

    A pointer to the full pointer translations tables used during an rpc call.

 ***/
{
    PFULL_PTR_XLAT_TABLES   pXlatTables;
    uint                    RefIdToPointerEntries;
    uint                    PointerToRefIdBuckets;
    BOOL                    fOutOfMemory = FALSE;

    pXlatTables = (PFULL_PTR_XLAT_TABLES) 
                  I_RpcAllocate(sizeof(FULL_PTR_XLAT_TABLES));

    // Because old compilers didn't initialize the xlat ptr in stubmsg
    // at the client in Os mode, we cannot raise exception right away.

    if ( ! pXlatTables )
        fOutOfMemory = TRUE;
    else
        {
        //
        // Determine the size of both translation tables.
        //
        if ( NumberOfPointers )
            {
            ulong       Shift, Bitmask;
    
            RefIdToPointerEntries = (uint) NumberOfPointers;
    
            //
            // Find the smallest power of 2 which is greater than
            // RefIdToPointerEntries.
            //
            for ( Shift = 0, Bitmask = 0x80000000;
                  ! (Bitmask & (ulong) RefIdToPointerEntries);
                  Shift++, Bitmask >>= 1 )
                ;
    
            PointerToRefIdBuckets = (uint)((0xffffffff >> Shift) + 1);
            }
        else
            {
            RefIdToPointerEntries = DEFAULT_REF_ID_TO_POINTER_TABLE_ELEMENTS;
            PointerToRefIdBuckets = DEFAULT_POINTER_TO_REF_ID_TABLE_BUCKETS;
            }
    
        // Make sure we can clean up correctly later if case of an exception.
    
        pXlatTables->RefIdToPointer.XlatTable  = 0;
        pXlatTables->RefIdToPointer.StateTable = 0;
        pXlatTables->PointerToRefId.XlatTable  = 0;
        pXlatTables->RefIdToPointer.NumberOfEntries = 0;
        pXlatTables->PointerToRefId.NumberOfBuckets = 0;
    
        //
        // Initialize the ref id to pointer tables.
        //
        pXlatTables->RefIdToPointer.XlatTable =
            (void **) I_RpcAllocate( RefIdToPointerEntries * sizeof(void *) );
    
        if ( ! pXlatTables->RefIdToPointer.XlatTable )
            fOutOfMemory = TRUE;
        else
            {
            MIDL_memset( pXlatTables->RefIdToPointer.XlatTable,
                         0,
                         RefIdToPointerEntries * sizeof(void *) );
    
            pXlatTables->RefIdToPointer.StateTable =
                (uchar *) I_RpcAllocate( RefIdToPointerEntries * sizeof(uchar) );
        
            if ( ! pXlatTables->RefIdToPointer.StateTable )
                fOutOfMemory = TRUE;
            else
                {
                MIDL_memset( pXlatTables->RefIdToPointer.StateTable,
                             0,
                             RefIdToPointerEntries * sizeof(uchar) );
        
                pXlatTables->RefIdToPointer.NumberOfEntries = RefIdToPointerEntries;
            
                //
                // Intialize the pointer to ref id tables.
                //
                pXlatTables->PointerToRefId.XlatTable =
                    (PFULL_PTR_TO_REFID_ELEMENT *) 
                    I_RpcAllocate( PointerToRefIdBuckets * 
                                   sizeof(PFULL_PTR_TO_REFID_ELEMENT) );
            
                if ( ! pXlatTables->PointerToRefId.XlatTable )
                    fOutOfMemory = TRUE;
                else
                    {
                    MIDL_memset( pXlatTables->PointerToRefId.XlatTable,
                                 0,
                                 PointerToRefIdBuckets * sizeof(PFULL_PTR_TO_REFID_ELEMENT) );
                    }
                }
            }
        }

    if ( fOutOfMemory )
        {
        NdrFullPointerXlatFree( pXlatTables );

        if ( XlatSide == XLAT_SERVER )
            RpcRaiseException( RPC_S_OUT_OF_MEMORY );
        else
            {
            // The old compilers generate a code for the client side that
            // doesn't initialize the table pointer and the stub msg
            // initialization is after call to xlat initialize.
            // So, we are down to checking the pointer when used.

            return( 0 );
            }
        }

    pXlatTables->PointerToRefId.NumberOfBuckets = PointerToRefIdBuckets;
    pXlatTables->PointerToRefId.HashMask = PointerToRefIdBuckets - 1;

    pXlatTables->NextRefId = 1;

    pXlatTables->XlatSide = XlatSide;

    return pXlatTables;
}


void RPC_ENTRY
NdrFullPointerXlatFree( 
    PFULL_PTR_XLAT_TABLES pXlatTables )
/*** 

Routine description :

    Free the full pointer support data structures for an rpc call.

Arguments :

    pXlatTables        - Full pointer translation tables data structure to free.

 ***/
{
    PFULL_PTR_TO_REFID_ELEMENT *    HashTable;
    PFULL_PTR_TO_REFID_ELEMENT      pElement, pTemp;
    ulong                           Buckets;
    ulong                           i;

    if ( ! pXlatTables )
        return;

    //
    // Free the ref id to pointer tables.
    //
    if ( pXlatTables->RefIdToPointer.XlatTable )
        I_RpcFree( pXlatTables->RefIdToPointer.XlatTable );

    if ( pXlatTables->RefIdToPointer.StateTable )
        I_RpcFree( pXlatTables->RefIdToPointer.StateTable );

    //
    // Free the pointer to ref id table.
    //
    HashTable = pXlatTables->PointerToRefId.XlatTable;

    if ( HashTable )
        {
        Buckets = pXlatTables->PointerToRefId.NumberOfBuckets;
    
        for ( i = 0; i < Buckets; i++ )
            if ( HashTable[i] )
                for ( pElement = HashTable[i]; pElement; pElement = pTemp )
                    {
                    pTemp = pElement->Next;
    
                    I_RpcFree(pElement);
                    }
    
        I_RpcFree( HashTable );
        }

    //
    // Free the translation table structure.
    //
    I_RpcFree( pXlatTables );
}


int RPC_ENTRY
NdrFullPointerQueryPointer( 
    PFULL_PTR_XLAT_TABLES   pXlatTables,
    void *                  pPointer,
    uchar                   QueryType,
    ulong *                 pRefId )
/***

Routine description :

    This routine checks if a full pointer is in the full pointer translation 
    table and is marked with the given state.

    If there is no current translation for this pointer then a translation is 
    inserted in the given translation table and a ref id is assigned if pRefId
    is non-null.  

Arguments :

    pXlatTable  - The full pointer translation tables.
    pPointer    - The pointer to check.
    QueryType   - The type of query, either FULL_POINTER_MARSHALLED or 
                    FULL_POINTER_BUF_SIZED.
    pRefId      - The ref id for the pointer is returned if this parameter 
                    is non-null.

Return Value :

    TRUE if the given pointer was null or a translation for the full pointer 
    was found and had the QueryType set, FALSE otherwise.

    A return value of FALSE indicates that the pointee should be sized or 
    marshalled.

 ***/
{
    PFULL_PTR_TO_REFID_ELEMENT *    HashTable;
    PFULL_PTR_TO_REFID_ELEMENT      pElement;
    ulong                           HashTableIndex;

    if ( ! pPointer ) 
        {
        if ( pRefId )
            *pRefId = 0;

        return TRUE;
        }

    if ( ! pXlatTables )
        RpcRaiseException( RPC_S_OUT_OF_MEMORY );

    HashTable = pXlatTables->PointerToRefId.XlatTable;

    //
    // Lookup pPointer in PointerToRefId table.
    //

    HashTableIndex = PTR_HASH( pPointer, pXlatTables->PointerToRefId.HashMask );

    for (  pElement = HashTable[HashTableIndex]; 
           pElement;  
           pElement = pElement->Next ) 
        {
        if ( pElement->Pointer == pPointer ) 
            {
            if ( CHECK_FULL_POINTER_STATE( pElement->State, QueryType ) ) 
                {
                if ( pRefId )
                    *pRefId = pElement->RefId;

                return TRUE;
                }
            else 
                {
                //
                // Assign a ref id now if it doesn't have one and pRefId is 
                // non null.
                //
                if ( pRefId && ! pElement->RefId ) 
                    pElement->RefId = pXlatTables->NextRefId++;

                SET_FULL_POINTER_STATE( pElement->State, QueryType ); 
                }
            break;
            }
        }

    //
    // If there is no translation for the pointer then insert a new one.
    //
    if ( ! pElement ) 
        {
        pElement = (PFULL_PTR_TO_REFID_ELEMENT) 
                   I_RpcAllocate( sizeof(FULL_PTR_TO_REFID_ELEMENT) );

        if ( ! pElement )
            RpcRaiseException( RPC_S_OUT_OF_MEMORY );

        pElement->State = 0;

        SET_FULL_POINTER_STATE( pElement->State, QueryType );

        pElement->Pointer = pPointer;

        if ( pRefId )
            pElement->RefId = pXlatTables->NextRefId++;
        else
            pElement->RefId = 0;

        pElement->Next = HashTable[HashTableIndex];
        HashTable[HashTableIndex] = pElement;
        }

    //
    // Set the ref id return value.
    //
    if ( pRefId )
        {
        //
        // We get here the first time we marshall a new full pointer.
        //
        *pRefId = pElement->RefId;

        //
        // We insert the reverse translation if we're on the client side.
        //
        if ( pXlatTables->XlatSide == XLAT_CLIENT )
            {
            if ( *pRefId >= pXlatTables->RefIdToPointer.NumberOfEntries ) 
                NdrFullPointerXlatRealloc( pXlatTables, *pRefId );

            pXlatTables->RefIdToPointer.XlatTable[*pRefId] = pPointer;
            }
        }

    return FALSE;
}


int RPC_ENTRY
NdrFullPointerQueryRefId( 
    PFULL_PTR_XLAT_TABLES   pXlatTables,
    ulong                   RefId,
    uchar                   QueryType,
    void **                 ppPointer )
/***

Routine description :

    This routine checks if a ref id is in the full pointer translation table
    and is marked with the given state.

    If a translation is found and ppPointer is non-null then *ppPointer is set
    to the value of the ref id's pointer value.

    If this routine returns FALSE for a FULL_POINTER_UNMARSHALLED query then 
    the full pointer should be allocated and a call to 
    NdrFullPointerInsertRefId must be made. 

    If this routine returns FALSE for a FULL_POINTER_MEM_SIZED query then 
    the size of the full pointer's pointee should be added to the current 
    memory sizing calculation.

Arguments :

    pXlatTable   - The full pointer translation tables.
    pRefId       - The ref id to search for.
    QueryType    - The type of query, either FULL_POINTER_UNMARSHALLED or
                    FULL_POINTER_MEM_SIZED.
    ppPointer    - Holds the returned pointer value for the ref id if it is 
                    found.

Return Value :

    TRUE if the ref id is 0 or a translation for the ref id is found and had 
    the QueryType set, FALSE otherwise.

    A return value of FALSE indicates that the pointee should be sized or 
    unmarshalled.

 ***/
{
    uchar *     StateTable;
    void *      Pointer;

    if ( ! RefId ) 
        {
        return TRUE;
        }

    if ( ! pXlatTables )
        RpcRaiseException( RPC_S_OUT_OF_MEMORY );

    if ( RefId >= pXlatTables->NextRefId )
        {
        pXlatTables->NextRefId = RefId + 1;
        if ( pXlatTables->NextRefId < RefId )
            RpcRaiseException( RPC_X_BAD_STUB_DATA );
        }

    if ( RefId >= pXlatTables->RefIdToPointer.NumberOfEntries ) 
        NdrFullPointerXlatRealloc( pXlatTables, RefId );

    StateTable = pXlatTables->RefIdToPointer.StateTable;

    Pointer = pXlatTables->RefIdToPointer.XlatTable[RefId];

    //
    // We make this check first.  It's possible that we will already have
    // a translation for the ref id, but it simply won't be marked yet with
    // the proper state.  In this case we still want to return the correct
    // pointer value from the translation tables, but we'll still end up 
    // returning false when we make the state check.
    //
    if ( ppPointer )
        {
        // 
        // We have to make sure and always copy the pointer's value from
        // the table.  This way we handle the case when a pointer's VALUE 
        // changes to a pointer which has a currently valid RefId (an 
        // example of this could happen when a server swaps the values of 
        // two [in,out] double pointers).
        //
        // Pointer will be null if this is the first time we've seen or used
        // this ref id.
        //
        *ppPointer = Pointer;
        }

    if ( CHECK_FULL_POINTER_STATE( StateTable[RefId], QueryType ) )
        {
        return TRUE;
        }
    else
        {
        SET_FULL_POINTER_STATE( StateTable[RefId], QueryType );
    
        return FALSE;
        }
}


void RPC_ENTRY
NdrFullPointerInsertRefId( 
    PFULL_PTR_XLAT_TABLES     pXlatTables,
    ulong                     RefId,
    void *                    pPointer )
/***

Routine description :

    This routine inserts a ref id to pointer translation in the full pointer
    translation table.

Arguments :

    pXlatTable    - The full pointer translation tables.
    pRefId        - The ref id. 
    pPointer      - The pointer. 

Return Value :

    None.

 ***/
{
    // unused: uchar *        StateTable;

    if ( ! pXlatTables )
        RpcRaiseException( RPC_S_OUT_OF_MEMORY );

    // 
    // Ref id should be non-zero.
    //
    NDR_ASSERT( RefId, "NdrFullPointerInsertRefId : Ref id is zero" ); 

    //
    // Ref id should fit in the current table.
    //
    NDR_ASSERT( RefId < pXlatTables->RefIdToPointer.NumberOfEntries,
                "NdrFullPointerInsertRefId : Ref Id too large" );

    //
    // There should currently be no pointer translation for this ref id.
    //
    NDR_ASSERT( ! pXlatTables->RefIdToPointer.XlatTable[RefId],
                "NdrFullPointerInsertRefId : Translation already exists" );

    //
    // Insert the translation.
    //
    pXlatTables->RefIdToPointer.XlatTable[RefId] = pPointer;

    //
    // If we're on the server side then insert the inverse translation.
    //
    if ( pXlatTables->XlatSide == XLAT_SERVER )
        {
        PFULL_PTR_TO_REFID_ELEMENT  pElement;
        long                        HashTableIndex;

        pElement = (PFULL_PTR_TO_REFID_ELEMENT) 
                   I_RpcAllocate( sizeof(FULL_PTR_TO_REFID_ELEMENT) );

        if ( ! pElement )
            RpcRaiseException( RPC_S_OUT_OF_MEMORY );

        pElement->State = 0;
        pElement->Pointer = pPointer;
        pElement->RefId = RefId;

        HashTableIndex = PTR_HASH( pPointer, 
                                   pXlatTables->PointerToRefId.HashMask );

        pElement->Next = pXlatTables->PointerToRefId.XlatTable[HashTableIndex];
        pXlatTables->PointerToRefId.XlatTable[HashTableIndex] = pElement;
        }
}


int RPC_ENTRY
NdrFullPointerFree( 
    PFULL_PTR_XLAT_TABLES     pXlatTables,
    void *                    pPointer )
/*** 

Routine description :

    Removes a full pointer from the translation tables, and frees it's 
    associated translation data.

Return value :

    TRUE if the pointer has not yet been freed or is null, FALSE otherwise.

 ***/
{
    PFULL_PTR_TO_REFID_ELEMENT *    HashTable;
    PFULL_PTR_TO_REFID_ELEMENT      pElement; 
    ulong                           HashTableIndex;

    if ( ! pPointer ) 
         return FALSE;

    if ( ! pXlatTables )
        RpcRaiseException( RPC_S_OUT_OF_MEMORY );

    HashTable = pXlatTables->PointerToRefId.XlatTable;

    //
    // Lookup pPointer in PointerToRefId table.
    //

    HashTableIndex = PTR_HASH( pPointer, pXlatTables->PointerToRefId.HashMask );

    for ( pElement = HashTable[HashTableIndex]; 
          pElement;   
          pElement = pElement->Next ) 
        {
        if ( pElement->Pointer == pPointer ) 
            {
            if ( CHECK_FULL_POINTER_STATE(pElement->State,FULL_POINTER_FREED) )
                {
                return FALSE;
                }
            else
                {
                SET_FULL_POINTER_STATE(pElement->State,FULL_POINTER_FREED);
                return TRUE;
                }
            }
        }

    //
    // There is an instance when a full pointer is encountered for the first
    // time during freeing.  This occurs if an [in] full pointer is changed
    // by the server manager routine.  If this occurs we must insert the new
    // full pointer so we can keep track of it so that we don't free it more
    // than once.
    //

    pElement = (PFULL_PTR_TO_REFID_ELEMENT)
               I_RpcAllocate( sizeof(FULL_PTR_TO_REFID_ELEMENT) );

    if ( ! pElement )
        RpcRaiseException( RPC_S_OUT_OF_MEMORY );

    pElement->State = 0;
    pElement->Pointer = pPointer;

    HashTableIndex = PTR_HASH( pPointer,
                               pXlatTables->PointerToRefId.HashMask );

    pElement->Next = pXlatTables->PointerToRefId.XlatTable[HashTableIndex];
    pXlatTables->PointerToRefId.XlatTable[HashTableIndex] = pElement;

    SET_FULL_POINTER_STATE( pElement->State, FULL_POINTER_FREED );

    return TRUE;
}


static void
NdrFullPointerXlatRealloc( 
    PFULL_PTR_XLAT_TABLES pXlatTables,
    ulong   RefId)
{
    void *  pMemory;
    uint    Entries;

    if ( ! pXlatTables )
        RpcRaiseException( RPC_S_OUT_OF_MEMORY );

    Entries = (uint) pXlatTables->RefIdToPointer.NumberOfEntries;

    // If the number is much larger than the previous one, most likely the
    // number is invalid. Before we have a concrete solution to replace the
    // current fixed array of RefIdToPointer lookup, this can catch most 
    // of the failures. 
    if ( RefId >= 2 * Entries )
        RpcRaiseException( RPC_X_BAD_STUB_DATA );
    //
    // Realloc RefIdToPointerTable.  Allocate twice as many entries.
    //
    pMemory = I_RpcAllocate( Entries * sizeof(void *) * 2 );

    if ( ! pMemory )
        RpcRaiseException( RPC_S_OUT_OF_MEMORY );

    //
    // Now copy the current entries into the new memory.
    //
    RpcpMemoryCopy( pMemory,
                    pXlatTables->RefIdToPointer.XlatTable,
                    Entries * sizeof( void * ) );

    //
    // Set the new entries to 0.
    //
    MIDL_memset( (char *) pMemory + Entries * sizeof( void *),
                 0,
                 Entries * sizeof( void *) );

    //
    // Free the old table.
    //
    I_RpcFree( pXlatTables->RefIdToPointer.XlatTable );

    //
    // Get the new table.
    //
    pXlatTables->RefIdToPointer.XlatTable = (void**)pMemory;

    //
    // Realloc RefIdToPointerState
    //
    pMemory = I_RpcAllocate( Entries * sizeof(uchar) * 2 );

    if ( ! pMemory )
        RpcRaiseException( RPC_S_OUT_OF_MEMORY );

    //
    // Now copy the current entries into the new memory.
    //
    RpcpMemoryCopy( pMemory,
                    pXlatTables->RefIdToPointer.StateTable,
                    Entries * sizeof(uchar) );

    //
    // Set the new entries to 0.
    //
    MIDL_memset( (char *) pMemory + Entries * sizeof(uchar),
                 0,
                 Entries * sizeof(uchar) );

    //
    // Free the old table.
    //
    I_RpcFree( pXlatTables->RefIdToPointer.StateTable );

    //
    // Get the new table.
    //
    pXlatTables->RefIdToPointer.StateTable = (uchar*)pMemory;

    //
    // Update number of entries.
    //
    pXlatTables->RefIdToPointer.NumberOfEntries *= 2;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr20\endianp.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright <c> 1993 Microsoft Corporation

Module Name :

    endianp.h

Abtract :

    Contains private sizing routine definitions.

Author :

    David Kays  dkays   December 1993

Revision History :

--------------------------------------------------------------------*/

#ifndef _ENDIANP_
#define _ENDIANP_

//
// These are no-exported APIs.
//
void 
NdrSimpleTypeConvert(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char                       FormatChar
    );

void 
NdrPointerConvert(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat,
    unsigned char                       fConvertPointersOnly
    );

/* Structures */

void 
NdrSimpleStructConvert(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat,
    unsigned char                       fConvertPointersOnly
    );

void 
NdrConformantStructConvert(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat,
    unsigned char                       fConvertPointersOnly
    );

void 
NdrHardStructConvert(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat,
    unsigned char                       fConvertPointersOnly
    );

void 
NdrComplexStructConvert(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat,
    unsigned char                       fConvertPointersOnly
    );

/* Arrays */

void 
NdrFixedArrayConvert(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat,
    unsigned char                       fConvertPointersOnly
    );

void 
NdrConformantArrayConvert(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat,
    unsigned char                       fConvertPointersOnly
    );

void 
NdrConformantVaryingArrayConvert(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat,
    unsigned char                       fConvertPointersOnly
    );

void 
NdrVaryingArrayConvert(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat,
    unsigned char                       fConvertPointersOnly
    );

void 
NdrComplexArrayConvert(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat,
    unsigned char                       fConvertPointersOnly
    );

/* Strings */

void 
NdrNonConformantStringConvert(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat,
    unsigned char                       fConvertPointersOnly
    );

void 
NdrConformantStringConvert(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat,
    unsigned char                       fConvertPointersOnly
    );

/* Unions */

void 
NdrEncapsulatedUnionConvert(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat,
    unsigned char                       fConvertPointersOnly
    );

void 
NdrNonEncapsulatedUnionConvert(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat,
    unsigned char                       fConvertPointersOnly
    );

/* Byte count pointer */

void 
NdrByteCountPointerConvert(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat,
    unsigned char                       fConvertPointersOnly
    );

/* Transmit as and represent as convert */

void 
NdrXmitOrRepAsConvert(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat,
    unsigned char                       fConvertPointersOnly
    );

/* User_marshall convert */

void 
NdrUserMarshalConvert(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat,
    unsigned char                       fConvertPointersOnly
    );

void 
NdrInterfacePointerConvert(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat,
    unsigned char                       fConvertPointersOnly
    );

void
NdrContextHandleConvert(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat,
    unsigned char                       fConvertPointersOnly
    );

//
// Other helper routines.
//

void
NdrpPointerConvert( 
	PMIDL_STUB_MESSAGE			pStubMsg, 
	uchar *						pBufferMark,
	PFORMAT_STRING				pFormat
	);

void
NdrpStructConvert( 
	PMIDL_STUB_MESSAGE 			pStubMsg, 
	PFORMAT_STRING				pFormat,
	PFORMAT_STRING 				pFormatPointers,
	uchar						fConvertPointersOnly
	);

void
NdrpConformantArrayConvert( 
	PMIDL_STUB_MESSAGE			pStubMsg, 
	PFORMAT_STRING				pFormat,
	uchar						fConvertPointersOnly
	);

void
NdrpConformantVaryingArrayConvert( 
	PMIDL_STUB_MESSAGE			pStubMsg, 
	PFORMAT_STRING				pFormat,
	uchar						fConvertPointersOnly
	);

void
NdrpComplexArrayConvert( 
	PMIDL_STUB_MESSAGE			pStubMsg, 
	PFORMAT_STRING				pFormat,
	uchar						fConvertPointersOnly
	);

void
NdrpArrayConvert( 
	PMIDL_STUB_MESSAGE	 		pStubMsg, 
	PFORMAT_STRING				pFormat,
	long						Elements,
	uchar						fConvertPointersOnly
	);

void
NdrpUnionConvert( 
	PMIDL_STUB_MESSAGE			pStubMsg, 
	PFORMAT_STRING				pFormat,
	uchar 						SwitchType,
	uchar						fConvertPointersOnly
	);

void
NdrpEmbeddedPointerConvert( 
	PMIDL_STUB_MESSAGE			pStubMsg, 
	PFORMAT_STRING				pFormat
	);

PFORMAT_STRING
NdrpEmbeddedRepeatPointerConvert( 
	PMIDL_STUB_MESSAGE			pStubMsg, 
	PFORMAT_STRING				pFormat
	);

typedef void	(* PCONVERT_ROUTINE)(
					PMIDL_STUB_MESSAGE, 
					PFORMAT_STRING,
					uchar  
				);

typedef void 	(* PPRIVATE_CONVERT_ROUTINE)( 
					PMIDL_STUB_MESSAGE, 
					PFORMAT_STRING,
					uchar  
				);

// function table defined in endian.c
extern const PCONVERT_ROUTINE * pfnConvertRoutines;

//
// Conversion stuff.
//
extern const unsigned char EbcdicToAscii[];

#define NDR_FLOAT_INT_MASK                  (unsigned long)0X0000FFF0L

#define NDR_BIG_IEEE_REP                    (unsigned long)0X00000000L
#define NDR_LITTLE_IEEE_REP                 (unsigned long)0X00000010L

#define NDR_LOCAL_ENDIAN_IEEE_REP           NDR_LITTLE_IEEE_REP

//
// Masks defined for short byte swapping:
//

#define MASK_A_          (unsigned short)0XFF00
#define MASK__B          (unsigned short)0X00FF

//
// Masks defined for long byte swapping:
//

#define MASK_AB__        (unsigned long)0XFFFF0000L
#define MASK___CD        (unsigned long)0X0000FFFFL
#define MASK_A_C_        (unsigned long)0XFF00FF00L
#define MASK__B_D        (unsigned long)0X00FF00FFL

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr20\free.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1993-2000 Microsoft Corporation

Module Name :

    free.c

Abstract :

    This file contains the routines called by MIDL 2.0 stubs and the 
    interpreter for freeing unmarshalled data on the server. 

Author :

    David Kays  dkays   September 1993.

Revision History :

  ---------------------------------------------------------------------*/

#include "ndrp.h"
#include "ndrole.h"
#include "attack.h"
#include "pointerq.h"

RPCRTAPI
void
RPC_ENTRY
NdrpNoopFree(
    PMIDL_STUB_MESSAGE  pStubMsg,
    unsigned char *     pMemory,
    PFORMAT_STRING      pFormat
    );


//
// Free routine table.
//
extern const
PFREE_ROUTINE   FreeRoutinesTable[] = 
                {
                NdrpNoopFree,                        // 0x00
                NdrpNoopFree,                        // 0x01
                NdrpNoopFree,                        // 0x02
                NdrpNoopFree,                        // 0x03
                NdrpNoopFree,                        // 0x04
                NdrpNoopFree,                        // 0x05
                NdrpNoopFree,                        // 0x06
                NdrpNoopFree,                        // 0x07
                NdrpNoopFree,                        // 0x08
                NdrpNoopFree,                        // 0x09
                NdrpNoopFree,                        // 0x0A
                NdrpNoopFree,                        // 0x0B
                NdrpNoopFree,                        // 0x0C
                NdrpNoopFree,                        // 0x0D
                NdrpNoopFree,                        // 0x0E
                NdrpNoopFree,                        // 0x0F
                NdrpNoopFree,                        // 0x10
                                                     
                NdrPointerFree,                      // 0x11
                NdrPointerFree,                      // 0x12
                NdrPointerFree,                      // 0x13
                NdrPointerFree,                      // 0x14

                NdrpNoopFree,                        // 0x15 Simple struct
                NdrSimpleStructFree,                 // 0x16
                NdrpNoopFree,                        // 0x17 Conformant struct
                NdrConformantStructFree,             // 0x18
                NdrConformantVaryingStructFree,      // 0x19

                NdrComplexStructFree,                // 0x1A

                NdrConformantArrayFree,              // 0x1B
                NdrConformantVaryingArrayFree,       // 0x1C

                NdrFixedArrayFree,                   // 0x1D
                NdrFixedArrayFree,                   // 0x1E
                NdrVaryingArrayFree,                 // 0x1F Small varying array
                NdrVaryingArrayFree,                 // 0x20 Large varying array

                NdrComplexArrayFree,                 // 0x21

                NdrpNoopFree,                        // 0x22 Conformant string
                NdrpNoopFree,                        // 0x23 Conformant string
                NdrpNoopFree,                        // 0x24 Conformant string
                NdrpNoopFree,                        // 0x25 Conformant string

                NdrpNoopFree,                        // 0x26 NonConformant string
                NdrpNoopFree,                        // 0x27 NonConformant string
                NdrpNoopFree,                        // 0x28 NonConformant string
                NdrpNoopFree,                        // 0x29 NonConformant string

                NdrEncapsulatedUnionFree,            // 0x2A 
                NdrNonEncapsulatedUnionFree,         // 0x2B 

                NdrByteCountPointerFree,             // 0x2C 

                NdrXmitOrRepAsFree,                  // 0x2D transmit as 
                NdrXmitOrRepAsFree,                  // 0x2E represent as

                NdrPointerFree,                      // 0x2F

                NdrpNoopFree,                        // 0x30 Context handle

                // New Post NT 3.5 token serviced from here on.

                NdrpNoopFree,                        // 0x31 NdrHardStructFree,

                NdrXmitOrRepAsFree,                  // 0x32 transmit as ptr
                NdrXmitOrRepAsFree,                  // 0x33 represent as ptr

                NdrUserMarshalFree,                  // 0x34

                NdrpNoopFree,                        // 0x35 FC_PIPE 
                NdrpNoopFree,                        // 0x36 FC_BLK_HOLE

                NdrpRangeFree,                       // 0x37

                NdrpNoopFree,                        // 0x38
                NdrpNoopFree,                        // 0x39
                NdrpNoopFree,                        // 0x3A
                NdrpNoopFree,                        // 0x3B
                NdrpNoopFree,                        // 0x3C
                NdrpNoopFree,                        // 0x3D
                NdrpNoopFree,                        // 0x3E
                NdrpNoopFree,                        // 0x3F

                };

extern const
PFREE_ROUTINE * pfnFreeRoutines = FreeRoutinesTable;

RPCRTAPI
void RPC_ENTRY
NdrTypeFree(PMIDL_STUB_MESSAGE                   pStubMsg,
			unsigned char __RPC_FAR *            pMemory,
			PFORMAT_STRING                       pFormat )
{
	if (pfnFreeRoutines[ROUTINE_INDEX(*pFormat)])
	{
		(*pfnFreeRoutines[ROUTINE_INDEX(*pFormat)])( pStubMsg,
													 pMemory,
													 pFormat );
	}
}


void RPC_ENTRY
NdrpNoopFree( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Frees a top level or embedded simple type.

    Used for VT_USERDEFINED but in fact simple types,
    like TKIND_ENUM and TKIND_ALIAS

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to be freed.
    pFormat     - Pointer's format string description.

Return :

    None.

--*/
{
    return;
}

inline void
NdrFreeTypeMemory( 
    PMIDL_STUB_MESSAGE pStubMsg,
    uchar *            pMemory )
{

    if ( !pStubMsg->pPointerQueueState ||
         !pStubMsg->pPointerQueueState->GetActiveQueue() )
        {
        (*pStubMsg->pfnFree)(pMemory);
        }
    else
        {
        NDR_PFNFREE_POINTER_QUEUE_ELEMENT*pElement = 
            new(pStubMsg->pPointerQueueState) 
                NDR_PFNFREE_POINTER_QUEUE_ELEMENT(pStubMsg->pfnFree,
                                                  pMemory );
        pStubMsg->pPointerQueueState->GetActiveQueue()->Enque( pElement );

        }
}




__forceinline void 
NdrPointerFreeInternal( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Frees a top level or embedded pointer to anything.

    Used for FC_RP, FC_UP, FC_FP, FC_OP.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to be freed.
    pFormat     - Pointer's format string description.

Return :

    None.

--*/
{
    PFORMAT_STRING  pFormatPointee;
    uchar *         pMemoryPointee;

    pMemoryPointee = pMemory;

    if ( ! pMemory )
        return;

    switch( *pFormat )
        {
        case FC_FP:
            //
            // Check if we've already freed this full pointer.
            //
            if ( ! NdrFullPointerFree( pStubMsg->FullPtrXlatTables,
                                       pMemory ) )
                return;
            break;

        case FC_IP:
            if(pMemory != 0)
                {
                ((IUnknown *)pMemory)->Release();
                pMemory = 0;
                }
            return;
        default:
            break;
        }

    if ( pFormat[1] == 0 )
        goto FreeEmbeddedPointers;

    //
    // Check if this pointer and any possible embedded pointers should not
    // be freed.
    //
    if ( DONT_FREE(pFormat[1]) )
        return;

    // 
    // Just go free a pointer to a simple type.
    //
    if ( SIMPLE_POINTER(pFormat[1]) ) 
        goto FreeTopPointer;

    // 
    // Check if this is an allocate all nodes pointer.  
    // IDL symantics say that we only free the top most allocate all nodes
    // pointer on the server even in the [out] only case.  So jump to the 
    // check for the pointer free at the end of the routine.  
    //  
    if ( ALLOCATE_ALL_NODES(pFormat[1]) )
        goto FreeTopPointer;

    if ( POINTER_DEREF(pFormat[1]) )
        pMemoryPointee = *((uchar **)pMemory);

FreeEmbeddedPointers:

    pFormatPointee = pFormat + 2;
    pFormatPointee += *((signed short *)pFormatPointee);

    //
    // Call the correct free routine if one exists for this type.
    //
    if ( pfnFreeRoutines[ROUTINE_INDEX(*pFormatPointee)] )
        {
        uchar   uFlagsSave = pStubMsg->uFlags;

        RESET_CONF_FLAGS_TO_STANDALONE(pStubMsg->uFlags);

        (*pfnFreeRoutines[ROUTINE_INDEX(*pFormatPointee)])
        ( pStubMsg,
          pMemoryPointee,
          pFormatPointee );

        pStubMsg->uFlags = uFlagsSave;
        }

FreeTopPointer:

    //
    // Now free the pointer.  Pointer guaranteed to be non-null here.
    //
    // We only free the pointer if it lies outside of the message buffer
    // that the server stub received from the RPC runtime. Otherwise we
    // used the RPC buffer to hold the pointer's data and should not free it.
    //
    if ( (pMemory < pStubMsg->BufferStart) || (pMemory > pStubMsg->BufferEnd) )
        {
        //
        // Also check to make sure that the pointer was not allocated on the
        // server stub's stack (this may happen for ref pointers).
        //
        // full pointer can't be allocated on stack (it's possible that 
        // an embedded FP points to the stack slot and got free first, and 
        // it will try to free the stack memory ). But currently MIDL still
        // generate allocated_on_stack flag for FC_FP. The workaround is 
        // that in unmarshall, we always allocate new, and in free, we should
        // free despite the flag. 
        if ( ! ALLOCED_ON_STACK(pFormat[1]) || ( *pFormat == FC_FP ))
            {

            NdrFreeTypeMemory( 
                pStubMsg,
                pMemory );
            }
        }
}


NDR_FREE_POINTER_QUEUE_ELEMENT::NDR_FREE_POINTER_QUEUE_ELEMENT( 
    MIDL_STUB_MESSAGE *pStubMsg, 
    uchar * const pMemoryNew,
    const PFORMAT_STRING pFormatNew) :
        pMemory(pMemoryNew),
        pFormat(pFormatNew),
        Memory(pStubMsg->Memory),
        uFlags(pStubMsg->uFlags) 
{

}

void 
NDR_FREE_POINTER_QUEUE_ELEMENT::Dispatch(
    MIDL_STUB_MESSAGE *pStubMsg) 
{
    SAVE_CONTEXT<uchar*> MemorySave( pStubMsg->Memory, Memory );
    SAVE_CONTEXT<uchar> uFlagsSave( pStubMsg->uFlags, uFlags );

    NdrPointerFreeInternal( pStubMsg,
                            pMemory,
                            pFormat );
}

#if defined(DBG)
void 
NDR_FREE_POINTER_QUEUE_ELEMENT::Print() 
{
    DbgPrint("NDR_FREE_POINTER_QUEUE_ELEMENT\n");
    DbgPrint("pNext:                   %p\n", pNext );
    DbgPrint("pMemory:                 %p\n", pMemory );
    DbgPrint("pFormat:                 %p\n", pFormat );
    DbgPrint("Memory:                  %p\n", Memory );
    DbgPrint("uFlags:                  %x\n", uFlags );

}
#endif

void 
NdrpEnquePointerFree(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
{
    NDR32_POINTER_CONTEXT PointerContext( pStubMsg );    
    
    RpcTryFinally
    {
        NDR_FREE_POINTER_QUEUE_ELEMENT*pElement = 
            new(PointerContext.GetActiveState()) 
                NDR_FREE_POINTER_QUEUE_ELEMENT(pStubMsg,
                                               pMemory,
                                               pFormat);
        PointerContext.Enque( pElement );
        PointerContext.DispatchIfRequired();
    }
    RpcFinally
    {
        PointerContext.EndContext();    
    }
    RpcEndFinally
}


void RPC_ENTRY
NdrPointerFree( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
{

    if ( !NdrIsLowStack(pStubMsg) )
        {
        NdrPointerFreeInternal( 
            pStubMsg,
            pMemory,
            pFormat );
        return;
        }
    
    NdrpEnquePointerFree( 
        pStubMsg,
        pMemory,
        pFormat );

}



void RPC_ENTRY
NdrpRangeFree( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++
--*/
{
    return;
}


void RPC_ENTRY
NdrSimpleStructFree( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Frees a simple structure's embedded pointers which were allocated during 
    a remote call.  

    Used for FC_STRUCT and FC_PSTRUCT.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to be freed.
    pFormat     - Pointer's format string description.

Return :

    None.

--*/
{
    if ( *pFormat == FC_PSTRUCT ) 
        {
        NdrpEmbeddedPointerFree( pStubMsg,
                                 pMemory,
                                 pFormat + 4 );
        }
}


void RPC_ENTRY
NdrConformantStructFree( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Frees a conformant structure's embedded pointers which were allocated 
    during a remote call.

    Used for FC_CSTRUCT and FC_CPSTRUCT.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to be freed.
    pFormat     - Pointer's format string description.

Return :

    None.
    
--*/
{
    PFORMAT_STRING  pFormatArray;

    if ( *pFormat == FC_CSTRUCT )
        return;

    // Get a pointer to the conformant array's description.
    pFormatArray = pFormat + 4;
    pFormatArray += *((signed short *)pFormatArray);

    //
    // Get the conformance count.  Pass a memory pointer to the beginning 
    // of the array.
    //
    NdrpComputeConformance( pStubMsg,
                            pMemory + *((ushort *)(pFormat + 2)),
                            pFormatArray );

    // Must pass a format string pointing to the pointer layout.
    NdrpEmbeddedPointerFree( pStubMsg,
                             pMemory,
                             pFormat + 6 );

    // Above, we walk the array pointers as well.

    if ( IS_EMBED_CONF_STRUCT( pStubMsg->uFlags ) )
        SET_CONF_ARRAY_DONE( pStubMsg->uFlags );
}


void RPC_ENTRY
NdrConformantVaryingStructFree( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Frees a conformant varying structure's embedded pointers which were 
    allocated during a remote call.  

    Used for FC_CVSTRUCT.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to be freed.
    pFormat     - Pointer's format string description.

Return :

    None.

--*/
{
    PFORMAT_STRING  pFormatArray;

    if ( *(pFormat + 6) != FC_PP ) 
        return;

    //
    // Set the memory pointer to the start of the conformant array/string.
    //

    // Get the conformant array/string description.
    pFormatArray = pFormat + 4;
    pFormatArray += *((signed short *)pFormatArray);

    NdrpComputeConformance( pStubMsg,
                            pMemory + *((ushort *)(pFormat + 2)),
                            pFormatArray );

    NdrpComputeVariance( pStubMsg,
                         pMemory + *((ushort *)(pFormat + 2)),
                         pFormatArray );

    pStubMsg->MaxCount = pStubMsg->ActualCount;                         

    // Must pass a format string pointing to the pointer layout.
    NdrpEmbeddedPointerFree( pStubMsg,
                             pMemory,
                             pFormat + 6 );

    // Above, we walk the array pointers as well.

    if ( IS_EMBED_CONF_STRUCT( pStubMsg->uFlags ) )
        SET_CONF_ARRAY_DONE( pStubMsg->uFlags );
}


#if 0
void RPC_ENTRY
NdrHardStructFree( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Frees a hard structure's embedded pointers which were allocated during 
    a remote call.  

    Used for FC_HARD_STRUCT.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to be freed.
    pFormat     - Pointer's format string description.

Return :

    None.

--*/
{
    if ( *((short *)&pFormat[14]) )
        {
        pFormat += 12;

        pMemory += *((ushort *)pFormat)++;

        pFormat += *((short *)pFormat);

        (*pfnFreeRoutines[ROUTINE_INDEX(*pFormat)])( pStubMsg,
                                                     pMemory,
                                                     pFormat );
        }
}
#endif


void RPC_ENTRY
NdrComplexStructFree( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Frees a complex structure's embedded pointers which were allocated during 
    a remote call.  

    Used for FC_BOGUS_STRUCT.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to be freed.
    pFormat     - Pointer's format string description.

Return :

    None.

--*/
{
    uchar *         pMemorySave;
    PFORMAT_STRING  pFormatPointers;
    PFORMAT_STRING  pFormatArray;
    PFORMAT_STRING  pFormatComplex;
    long            Align8Mod;
    uchar           fIsEmbeddedStruct = IS_EMBED_CONF_STRUCT( pStubMsg->uFlags );

    //
    // This is used for support of structs with doubles passed on an
    // i386 stack.
    //
    // A cast to long is what we need.
    Align8Mod = 0x7 & PtrToLong( pMemory );

    pMemorySave = pStubMsg->Memory;
    pStubMsg->Memory = pMemory;

    pFormat += 4;

    // Get conformant array description.
    if ( *((ushort *)pFormat) )
        pFormatArray = pFormat + *((signed short *)pFormat);
    else
        pFormatArray = 0;

    pFormat += 2;

    // Get pointer layout description.
    if ( *((ushort *)pFormat) )
        pFormatPointers = pFormat + *((ushort *)pFormat);
    else
        pFormatPointers = 0;

    pFormat += 2;

    SET_EMBED_CONF_STRUCT( pStubMsg->uFlags );

    //
    // Free the structure member by member.
    //
    for ( ; ; pFormat++ )
        {
        switch ( *pFormat )
            {
            //
            // simple types
            //
            case FC_CHAR :
            case FC_BYTE :
            case FC_SMALL :
            case FC_WCHAR :
            case FC_SHORT :
            case FC_LONG :
#if defined(__RPC_WIN64__)
            case FC_INT3264 :
            case FC_UINT3264 :
#endif
            case FC_FLOAT :
            case FC_HYPER :
            case FC_DOUBLE :
            case FC_ENUM16 :
            case FC_ENUM32 :
            case FC_IGNORE :
                pMemory += SIMPLE_TYPE_MEMSIZE(*pFormat);
                break;

            case FC_POINTER :
                NdrPointerFree( pStubMsg,
                                *((uchar **)pMemory),
                                pFormatPointers );

                pMemory += PTR_MEM_SIZE;

                pFormatPointers += 4;
                break;

            //
            // Embedded complex types.
            //
            case FC_EMBEDDED_COMPLEX :
                // Add padding.
                pMemory += pFormat[1];   

                pFormat += 2;

                // Get the type's description.
                pFormatComplex = pFormat + *((signed short UNALIGNED *)pFormat);

                if ( pfnFreeRoutines[ROUTINE_INDEX(*pFormatComplex)] )
                    {
                    (*pfnFreeRoutines[ROUTINE_INDEX(*pFormatComplex)])
                    ( pStubMsg,
                      (*pFormatComplex == FC_IP) ? *(uchar **)pMemory : pMemory,
                      pFormatComplex );
                    }

                pMemory = NdrpMemoryIncrement( pStubMsg,
                                               pMemory,
                                               pFormatComplex );

                //
                // Increment the main format string one byte.  The loop
                // will increment it one more byte past the offset field.
                //
                pFormat++;

                break;

            case FC_ALIGNM2 :
                ALIGN( pMemory, 0x1 );
                break;

            case FC_ALIGNM4 :
                ALIGN( pMemory, 0x3 );
                break;

            case FC_ALIGNM8 :
                //
                // We have to play some tricks for the i386 to handle the case
                // when an 8 byte aligned structure is passed by value.  The
                // alignment of the struct on the stack is not guaranteed to be
                // on an 8 byte boundary.
                //
                pMemory -= Align8Mod;
                ALIGN( pMemory, 0x7 );
                pMemory += Align8Mod;

                break;

            case FC_STRUCTPAD1 :
            case FC_STRUCTPAD2 :
            case FC_STRUCTPAD3 :
            case FC_STRUCTPAD4 :
            case FC_STRUCTPAD5 :
            case FC_STRUCTPAD6 :
            case FC_STRUCTPAD7 :
                pMemory += (*pFormat - FC_STRUCTPAD1) + 1; 
                break;

            case FC_STRUCTPADN :
                // FC_STRUCTPADN 0 <unsigned short>
                pMemory += *(((unsigned short *)pFormat) + 1);
                pFormat += 3;
                break;

            case FC_PAD :
                break;

            //
            // Done with layout.
            //
            case FC_END :
                goto ComplexFreeEnd;

            default :
                NDR_ASSERT(0,"NdrComplexStructFree : bad format char");
                RpcRaiseException( RPC_S_INTERNAL_ERROR );
                return;
            } // switch
        } // for

ComplexFreeEnd :

    // Walk the array at the top level only.

    if ( pFormatArray && !fIsEmbeddedStruct  &&  
         ! IS_CONF_ARRAY_DONE( pStubMsg->uFlags ) )
        {
        PFREE_ROUTINE   pfnFree;

        switch ( *pFormatArray )
            {
            case FC_CARRAY :
                pfnFree = NdrConformantArrayFree;
                break;

            case FC_CVARRAY :
                pfnFree = NdrConformantVaryingArrayFree;
                break;

            case FC_BOGUS_ARRAY :
                pfnFree = NdrComplexArrayFree;
                break;

            // case FC_C_CSTRING :
            // case FC_C_BSTRING :
            // case FC_C_WSTRING :
            // case FC_C_SSTRING :

            default :
                pfnFree = 0;
                break;
            }

        if ( pfnFree )
            {
            (*pfnFree)( pStubMsg,
                        pMemory,
                        pFormatArray );
            }
        }

    if ( fIsEmbeddedStruct )
        SET_EMBED_CONF_STRUCT( pStubMsg->uFlags );
    else
        RESET_CONF_ARRAY_DONE( pStubMsg->uFlags );

    pStubMsg->Memory = pMemorySave;
}


void RPC_ENTRY
NdrFixedArrayFree( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Frees a fixed array's embedded pointers which were allocated during 
    a remote call.  

    Used for FC_SMFARRAY and FC_LGFARRAY.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to be freed.
    pFormat     - Pointer's format string description.

Return :

    None.

--*/
{
    //
    // We have to check this in case we get an exception before actually 
    // unmarshalling the array.
    // 
    if ( ! pMemory ) 
        return;
    
    if ( *pFormat == FC_SMFARRAY ) 
        pFormat += 4;
    else // *pFormat == FC_LGFARRAY 
        pFormat += 6;

    if ( *pFormat == FC_PP ) 
        NdrpEmbeddedPointerFree( pStubMsg,
                                 pMemory,
                                 pFormat ); 
}


void RPC_ENTRY
NdrConformantArrayFree( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Frees a one dimensional conformant array's embedded pointers which were 
    allocated during a remote call.  Called for both top level and embedded
    conformant arrays.

    Used for FC_CARRAY.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to be freed.
    pFormat     - Pointer's format string description.

Return :

    None.

--*/
{
    PFORMAT_STRING  pFormatPP;

    //
    // We have to check this in case we get an exception before actually 
    // unmarshalling the array.
    // 
    if ( ! pMemory ) 
        return;
    
    pFormatPP = pFormat + 8;
    CORRELATION_DESC_INCREMENT( pFormatPP );

    if ( *pFormatPP == FC_PP ) 
        {
        NdrpComputeConformance( pStubMsg,
                                pMemory,
                                pFormat );

        NdrpEmbeddedPointerFree( pStubMsg,
                                 pMemory,
                                 pFormatPP );
        }
}


void RPC_ENTRY
NdrConformantVaryingArrayFree( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Frees a one dimensional conformant varying array's embedded pointers which 
    were allocated during a remote call.  Called for both top level and 
    embedded conformant varying arrays.

    Used for FC_CVARRAY.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to be freed.
    pFormat     - Pointer's format string description.

Return :

    None.

--*/
{
    PFORMAT_STRING  pFormatPP;

    //
    // We have to check this in case we get an exception before actually 
    // unmarshalling the array.
    // 
    if ( ! pMemory ) 
        return;

    pFormatPP = pFormat + 12;
    CORRELATION_DESC_INCREMENT( pFormatPP );
    CORRELATION_DESC_INCREMENT( pFormatPP );
    
    if ( *(pFormatPP) == FC_PP ) 
        {
        NdrpComputeConformance( pStubMsg,
                                pMemory,
                                pFormat );

        NdrpComputeVariance( pStubMsg,
                             pMemory,
                             pFormat );

        //
        // Set MaxCount equal to the number of shipped elements.
        //
        pStubMsg->MaxCount = pStubMsg->ActualCount;

        NdrpEmbeddedPointerFree( pStubMsg,
                                 pMemory,
                                 pFormatPP );
        }
}


void RPC_ENTRY
NdrVaryingArrayFree( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Frees a varying array's embedded pointers which were allocated 
    during a remote call.  Called for both top level and embedded varying
    arrays.


    Used for FC_SMVARRAY and FC_LGVARRAY.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to be freed.
    pFormat     - Pointer's format string description.

Return :

    None.

--*/
{
    PFORMAT_STRING  pFormatPointers;

    //
    // We have to check this in case we get an exception before actually 
    // unmarshalling the array.
    // 
    if ( ! pMemory ) 
        return;
    
    if ( *pFormat == FC_SMVARRAY ) 
        pFormatPointers = pFormat + 12;
    else // *pFormat == FC_LGVARRAY
        pFormatPointers = pFormat + 16;
    CORRELATION_DESC_INCREMENT( pFormatPointers );

    if ( *pFormatPointers == FC_PP ) 
        {
        NdrpComputeVariance( pStubMsg,
                             pMemory,
                             pFormat );

        //
        // Set MaxCount equal to the number of shipped elements. 
        //
        pStubMsg->MaxCount = pStubMsg->ActualCount;

        NdrpEmbeddedPointerFree( pStubMsg,
                                 pMemory,
                                 pFormatPointers );
        }
}


void RPC_ENTRY
NdrComplexArrayFree( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Frees a complex array's embedded pointers which were allocated 
    during a remote call.  Called for both top level and embedded complex
    arrays.

    Used for FC_BOGUS_STRUCT.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to be freed.
    pFormat     - Pointer's format string description.

Return :

    None.

--*/
{
    ARRAY_INFO      ArrayInfo;
    PARRAY_INFO     pArrayInfo;
    PFREE_ROUTINE   pfnFree;
    PFORMAT_STRING  pFormatStart;
    uchar *         pMemorySave;
    ulong           Elements;
    ulong           Offset, Count;
    ulong           MemoryElementSize;
    long            Dimension;

    //
    // We have to check this in case we get an exception before actually 
    // unmarshalling the array.
    // 
    if ( ! pMemory ) 
        return;

    //
    // Lots of setup if we are the outer dimension.
    //
    if ( ! pStubMsg->pArrayInfo )
        {
        NdrpInitArrayInfo(pStubMsg, &ArrayInfo );
        }

    pArrayInfo = pStubMsg->pArrayInfo;

    Dimension = pArrayInfo->Dimension;
    
    pFormatStart = pFormat;

    pFormat += 2;

    // Get number of elements (0 if conformance present). 
    Elements = *((ushort *&)pFormat)++;

    //
    // Check for conformance description.
    //
    if ( *((long UNALIGNED *&)pFormat) != 0xffffffff )
        {
        Elements = (ulong) NdrpComputeConformance( pStubMsg,
                                                   pMemory,
                                                   pFormatStart );
        }

    pFormat += 4;
    CORRELATION_DESC_INCREMENT( pFormat );

    //
    // Check for variance description.
    //
    if ( *((long UNALIGNED *)pFormat) != 0xffffffff )
        {
        NdrpComputeVariance( pStubMsg,
                             pMemory,
                             pFormatStart );

        Offset = pStubMsg->Offset;
        Count = pStubMsg->ActualCount;
        }
    else
        {
        Offset = 0;
        Count = Elements;
        }

    pFormat += 4;
    CORRELATION_DESC_INCREMENT( pFormat );

    switch ( *pFormat )
        {
        case FC_EMBEDDED_COMPLEX :
            pFormat += 2;
            pFormat += *((signed short *)pFormat);

            if ( ! (pfnFree = pfnFreeRoutines[ROUTINE_INDEX(*pFormat)]) )
                goto ComplexArrayFreeEnd;

            pArrayInfo->Dimension = Dimension + 1;

            MemoryElementSize = (ulong)
                                ( NdrpMemoryIncrement( pStubMsg,
                                                       pMemory,
                                                       pFormat ) - pMemory );
            break;

        case FC_RP :
        case FC_UP :
        case FC_FP :
        case FC_OP :
            pfnFree = NdrPointerFree;

            // Need this in case we have a variant offset.
            MemoryElementSize = PTR_MEM_SIZE;
            break;

        case FC_IP :
            pfnFree = NdrInterfacePointerFree;

            // Need this in case we have a variant offset.
            MemoryElementSize = PTR_MEM_SIZE;
            break;

        default :
            // Must be a basetype.
            goto ComplexArrayFreeEnd;
        }

    pMemorySave = pMemory;

    //
    // If there is variance then increment the memory pointer to the first
    // element actually being marshalled.
    //
    if ( Offset )
        pMemory += Offset * MemoryElementSize;

    if ( pfnFree == NdrPointerFree )
        {
        pStubMsg->pArrayInfo = 0;

        for(; Count--; )
            {

            NdrPointerFree( pStubMsg,
                            *((uchar **)pMemory),
                            pFormat );
            
            // Increment the memory pointer by the element size.
            pMemory += PTR_MEM_SIZE;
            
            }

        goto ComplexArrayFreeEnd;
        }

    if ( ! IS_ARRAY_OR_STRING(*pFormat) )
        pStubMsg->pArrayInfo = 0;

    for ( ; Count--; )
        {
        // Keep track of multidimensional array dimension.
        if ( IS_ARRAY_OR_STRING(*pFormat) )
            pArrayInfo->Dimension = Dimension + 1;

        (*pfnFree)( pStubMsg,
                    pMemory,
                    pFormat );

        // Increment the memory pointer by the element size.
        pMemory += MemoryElementSize;
        }

ComplexArrayFreeEnd:

    // pArrayInfo must be zero when not valid.
    pStubMsg->pArrayInfo = (Dimension == 0) ? 0 : pArrayInfo;

}


void RPC_ENTRY
NdrEncapsulatedUnionFree( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Frees an encapsulated union's embedded pointers which were allocated 
    during a remote call.  

    Used for FC_ENCAPSULATED_UNION.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to be freed.
    pFormat     - Pointer's format string description.

Return :

    None.

--*/
{
    long    SwitchIs;

    NO_CORRELATION;

    switch ( LOW_NIBBLE(pFormat[1]) )
        {
        case FC_SMALL :
        case FC_CHAR :
            SwitchIs = (long) *((char *)pMemory);
            break;
        case FC_USMALL :
            SwitchIs = (long) *((uchar *)pMemory);
            break;

        case FC_ENUM16 :
        case FC_SHORT :
            SwitchIs = (long) *((short *)pMemory);
            break;

        case FC_USHORT :
        case FC_WCHAR :
            SwitchIs = (long) *((ushort *)pMemory);
            break;
        case FC_LONG :
        case FC_ULONG :
        case FC_ENUM32 :
          // FC_INT3264 gets mapped to FC_LONG.
            SwitchIs = *((long *)pMemory);
            break;
        default :
            NDR_ASSERT(0,"NdrEncapsulatedUnionFree : bad switch type");
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            return;
        }

    // Increment memory pointer to the union.
    pMemory += HIGH_NIBBLE(pFormat[1]);

    NdrpUnionFree( pStubMsg,
                   pMemory,
                   pFormat + 2,
                   SwitchIs );
}


void RPC_ENTRY
NdrNonEncapsulatedUnionFree( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Frees a non-encapsulated union's embedded pointers which were allocated 
    during a remote call.  

    Used for FC_NON_ENCAPSULATED_UNION.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to be freed.
    pFormat     - Pointer's format string description.

Return :

    None.

--*/
{
    long    SwitchIs;

    SwitchIs = (ulong) NdrpComputeSwitchIs( pStubMsg,
                                            pMemory,
                                            pFormat );

    //
    // Set the format string to the memory size and arm description.
    //
    pFormat += 6;
    CORRELATION_DESC_INCREMENT( pFormat );
    pFormat += *((signed short *)pFormat);

    NdrpUnionFree( pStubMsg,
                   pMemory,
                   pFormat,
                   SwitchIs );
}


void 
NdrpUnionFree( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat,
    long                SwitchIs )
/*++

Routine Description :

    Private routine shared by encapsulated and non-encapsulated unions for 
    freeing a union's embedded pointers which were allocated during a remote 
    call.  

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to be freed.
    pFormat     - Pointer's format string description.
    SwitchIs    - The union's switch is.

Return :

    None.

--*/
{
    long            Arms;
    PFREE_ROUTINE   pfnFree;

    // Skip the memory size field.
    pFormat += 2;

    Arms = (long) ( *((ushort *&)pFormat)++ & 0x0fff );

    // 
    // Search for the arm.
    //
    for ( ; Arms; Arms-- )
        {
        if ( *((long UNALIGNED *&)pFormat)++ == SwitchIs )
            {
            //
            // Found the right arm, break out.
            //
            break;
            }

        // Else increment format string.
        pFormat += 2;
        }

    //
    // Check if we took the default arm and no default arm is specified.
    //
    if ( ! Arms && (*((ushort *)pFormat) == (ushort) 0xffff) )
        {
        return;
        }

    //
    // Return if the arm is empty.
    //
    if ( ! *((ushort *)pFormat) )
        return;

    //
    // Get the arm's description.
    //
    // We need a real solution after beta for simple type arms.  This could
    // break if we have a format string larger than about 32K.
    //
    if ( IS_MAGIC_UNION_BYTE(pFormat) )
        return;

    pFormat += *((signed short *)pFormat);

    //
    // If the union arm we take is a pointer, we have to dereference the
    // current memory pointer since we're passed a pointer to the union
    // (regardless of whether the actual parameter was a by-value union
    // or a pointer to a union).
    //
    if ( IS_POINTER_TYPE(*pFormat) )
        pMemory = *((uchar **)pMemory);

    if ( pfnFree = pfnFreeRoutines[ROUTINE_INDEX(*pFormat)] ) 
        {
        (*pfnFree)( pStubMsg,
                    pMemory,
                    pFormat );
        }
}


void RPC_ENTRY
NdrByteCountPointerFree( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Frees a byte count pointer.

    Used for FC_BYTE_COUNT_POINTER.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to be freed.
    pFormat     - Pointer's format string description.

Return :

    None.

--*/
{
    if ( ! pMemory )
        return;

    //
    // Free it if we didn't use the rpc buffer for it.
    //
    if ( (pMemory < pStubMsg->BufferStart) || (pMemory > pStubMsg->BufferEnd) )
        (*pStubMsg->pfnFree)(pMemory);
}


void RPC_ENTRY
NdrXmitOrRepAsFree( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Frees the transmit-as object (actually the presented type instance)
    and steps over the object.

    There is an exceptional situation where the spec forbids stub to free
    the instance. This happens when there is an [in] only parameter with
    a [transmit_as()] on a component of the parameter, and the presented
    typedef is composed of one or more pointers.
    We have a flag in the stub msg that is set when this happens.

    See mrshl.c for the description of the FC layout.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to be freed.
    pFormat     - Pointer's format string description.

Return :

    None.

--*/
{
    const XMIT_ROUTINE_QUINTUPLE * pQuintuple;
    unsigned short                 QIndex;

    // Skip the token itself and Oi flag. Fetch the QuintupleIndex.

    QIndex = *(unsigned short *)(pFormat + 2);
    pQuintuple = pStubMsg->StubDesc->aXmitQuintuple;

    // Free the presented type instance unless forbidden explicitely.

    if ( ! pStubMsg->fDontCallFreeInst )
        {
        pStubMsg->pPresentedType = pMemory;
        pQuintuple[ QIndex ].pfnFreeInst( pStubMsg );
        }
}


void RPC_ENTRY
NdrUserMarshalFree( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Frees the usr_marshal object and steps over the object.
    See mrshl.c for the description of the layouts.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to be freed.
    pFormat     - Pointer's format string description.

Return :

    None.

--*/
{
    const USER_MARSHAL_ROUTINE_QUADRUPLE *  pQuadruple;
    unsigned short                          QIndex;
    USER_MARSHAL_CB                         UserMarshalCB;

    QIndex = *(unsigned short *)(pFormat + 2);
    pQuadruple = pStubMsg->StubDesc->aUserMarshalQuadruple;

    // Call the user to free his stuff.

    NdrpInitUserMarshalCB( pStubMsg,
                           pFormat,
                           USER_MARSHAL_CB_FREE,
                           & UserMarshalCB);

    // The user shouldn't ever free the top level object as we free it.
    // He should free only pointees of his top level object.

    pQuadruple[ QIndex ].pfnFree( (ulong*) &UserMarshalCB, pMemory );

    // NdrpMemoryIncrement steps over the memory object.
}


void RPC_ENTRY
NdrInterfacePointerFree( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Frees any memory associated with an interface pointer.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Interface pointer.
    pFormat     - Interface pointer's format string description.

Return :

    None.

--*/
{
    if(pMemory != 0)
        {
        ((IUnknown *)pMemory)->Release();
        pMemory = 0;
        }
}


void 
NdrpEmbeddedPointerFree( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Frees an array's or a structure's embedded pointers which were allocated 
    during a remote call.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to be freed.
    pFormat     - Pointer's format string description.

Return :

    None.

--*/
{
    uchar **    ppMemPtr;
    uchar *     pMemorySave;
    ULONG_PTR   MaxCountSave;
    long        OffsetSave;

    MaxCountSave = pStubMsg->MaxCount;
    OffsetSave = pStubMsg->Offset;

    pMemorySave = pStubMsg->Memory;

    pStubMsg->Memory = pMemory;

    // Increment past the FC_PP and pad.
    pFormat += 2; 

    for (;;) 
        {
        if ( *pFormat == FC_END ) 
            {
            pStubMsg->Memory = pMemorySave;
            break;
            }

        // Check for FC_FIXED_REPEAT or FC_VARIABLE_REPEAT.
        if ( *pFormat != FC_NO_REPEAT ) 
            {
            pStubMsg->MaxCount = MaxCountSave;
            pStubMsg->Offset = OffsetSave;

            pFormat = NdrpEmbeddedRepeatPointerFree( pStubMsg,
                                                     pMemory,
                                                     pFormat );

            // Continue loop to next pointer.
            continue;
            }

        // Get the pointer to the pointer to free.
        ppMemPtr = (uchar **)( pMemory + *((signed short *)(pFormat + 2)) );

        // Increment to pointer description.
        pFormat += 6;

        NdrPointerFree( 
            pStubMsg,
            *ppMemPtr,
            pFormat );
        
        // Increment to the next pointer description.
        pFormat += 4;
        }
}


PFORMAT_STRING
NdrpEmbeddedRepeatPointerFree( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Frees an array's embedded pointers which were allocated during a remote 
    call.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to be freed.
    pFormat     - Pointer's format string description.

Return :

    Format string pointer after the array's pointer description.

--*/
{
    uchar **        ppMemPtr;
    uchar *         pMemorySave;
    PFORMAT_STRING  pFormatSave;
    ulong           RepeatCount, RepeatIncrement, Pointers, PointersSave;

    pMemorySave = pStubMsg->Memory;

    switch ( *pFormat ) 
        {
        case FC_FIXED_REPEAT :
            // Increment past the FC_FIXED_REPEAT and FC_PAD.
            pFormat += 2;
    
            // Get the total number of times to repeat the pointer marshall.
            RepeatCount = *((ushort *&)pFormat)++;

            break;

        case FC_VARIABLE_REPEAT :
            // Get the total number of times to repeat the pointer marshall.
            RepeatCount = (ulong)pStubMsg->MaxCount;

            //
            // Check if this variable repeat instance also has a variable
            // offset (this would be the case for a conformant varying array
            // of pointers).  If so then increment the memory pointer to point
            // to the actual first array element which is being marshalled.
            //
            if ( pFormat[1] == FC_VARIABLE_OFFSET )
                pMemory += *((ushort *)(pFormat + 2)) * pStubMsg->Offset;

            // else pFormat[1] == FC_FIXED_OFFSET - do nothing

            // Move the format string to the increment field.
            pFormat += 2;
        
            break;

        default :
            NDR_ASSERT(0,"NdrEmbeddedRepeatPointerFree : bad format char");
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            return 0;
        }

    // Get the increment amount between successive pointers.
    // This is actually increment to the next element, same position.
    RepeatIncrement = *((ushort *&)pFormat)++;

    //
    // Add the offset to the beginning of this array to the Memory
    // pointer.  This is the offset from the current embedding structure
    // to the array whose pointers we're marshalling.
    //
    pStubMsg->Memory += *((ushort *&)pFormat)++;

    // Get the number of pointers in this repeat instance.
    PointersSave = Pointers = *((ushort *&)pFormat)++;

    pFormatSave = pFormat;

    //
    // Loop over the number of array elements.
    //
    for ( ; RepeatCount--;
            pMemory += RepeatIncrement,
            pStubMsg->Memory += RepeatIncrement )
        {
        pFormat = pFormatSave;
        Pointers = PointersSave;

        // 
        // Loop over the number of pointers per array element (this can be
        // zero for an array of structures).
        //
        for ( ; Pointers--; )
            {
            ppMemPtr = (uchar **)(pMemory + *((signed short *)pFormat));
            
            // Increment to pointer's description.
            pFormat += 4;

            NdrPointerFree( 
                pStubMsg,
                *ppMemPtr,
                pFormat );

            // Increment to the next pointer's offset_in_memory.
            pFormat += 4;
            }
        }

    pStubMsg->Memory = pMemory;

    // Return format string pointer past the array's pointer layout.
    return pFormatSave + PointersSave * 8;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr20\factory.cxx ===
/*++

Microsoft Windows
Copyright (c) 1994-2000 Microsoft Corporation.  All rights reserved.

Module Name:
    factory.c

Abstract:
    Implements the IPSFactoryBuffer interface.

Author:
    ShannonC    12-Oct-1994

Environment:
    Windows NT, Windows 95 and PowerMac.
    We do not support DOS and Win16 or Mac.

Revision History:
    YongQu      1-Oct-1998  Unlimit vtbl

--*/

#define CINTERFACE
#define USE_STUBLESS_PROXY

#include <ndrp.h>
#include <ndrole.h>
#include <rpcproxy.h>

//
// Internal CLSCTX used for loading Proxy/Stub DLLs
//
#define CLSCTX_PS_DLL                 0x80000000
extern void ** StublessClientVtbl;
EXTERN_C extern const void * g_StublessClientVtbl[];

#define MAX_STUBLESS_PROC 128
ULONG    g_dwVtblSize = MAX_STUBLESS_PROC;
ULONG    g_dwForwardVtblSize = MAX_STUBLESS_PROC;


static I_RPC_MUTEX TemplateMutex = 0 ,VtblMutex = 0 ;


HRESULT CreateStublessProcBuffer(ULONG numMethods, void *** lpTempVtbl);
HRESULT CreateForwardProcBuffer(ULONG numMethods, void *** lpTempVtbl);

HRESULT STDMETHODCALLTYPE
CStdPSFactoryBuffer_QueryInterface (
    IPSFactoryBuffer *This,
    REFIID iid,
    void **ppv );

ULONG STDMETHODCALLTYPE
CStdPSFactoryBuffer_AddRef(
    IPSFactoryBuffer *This);

ULONG STDMETHODCALLTYPE
CStdPSFactoryBuffer_Release(
    IPSFactoryBuffer *This);

HRESULT STDMETHODCALLTYPE
CStdPSFactoryBuffer_CreateProxy
(
    IPSFactoryBuffer *This,
    IUnknown *punkOuter,
    REFIID riid,
    IRpcProxyBuffer **ppProxy,
    void **ppv
);

HRESULT STDMETHODCALLTYPE
CStdPSFactoryBuffer_CreateStub
(
    IPSFactoryBuffer *This,
    REFIID riid,
    IUnknown *punkServer,
    IRpcStubBuffer **ppStub
);

HRESULT STDMETHODCALLTYPE
CStdPSFactoryBuffer_HkGetProxyFileInfo
(
    IN  IPSFactoryBuffer    *This,
    IN  REFIID              riid,
    OUT PINT                pOffset,
    OUT PVOID               *ppProxyFileInfo
);

extern "C"
{

void STDMETHODCALLTYPE
NdrProxyForwardingFunction3(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction4(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction5(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction6(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction7(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction8(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction9(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction10(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction11(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction12(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction13(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction14(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction15(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction16(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction17(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction18(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction19(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction20(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction21(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction22(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction23(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction24(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction25(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction26(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction27(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction28(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction29(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction30(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction31(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction32(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction33(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction34(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction35(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction36(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction37(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction38(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction39(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction40(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction41(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction42(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction43(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction44(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction45(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction46(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction47(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction48(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction49(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction50(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction51(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction52(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction53(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction54(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction55(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction56(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction57(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction58(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction59(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction60(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction61(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction62(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction63(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction64(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction65(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction66(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction67(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction68(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction69(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction70(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction71(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction72(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction73(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction74(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction75(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction76(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction77(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction78(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction79(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction80(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction81(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction82(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction83(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction84(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction85(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction86(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction87(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction88(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction89(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction90(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction91(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction92(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction93(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction94(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction95(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction96(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction97(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction98(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction99(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction100(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction101(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction102(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction103(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction104(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction105(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction106(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction107(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction108(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction109(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction110(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction111(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction112(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction113(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction114(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction115(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction116(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction117(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction118(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction119(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction120(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction121(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction122(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction123(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction124(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction125(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction126(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction127(void);

#if defined(_WIN64)

void STDMETHODCALLTYPE
NdrProxyForwardingFunction128(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction129(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction130(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction131(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction132(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction133(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction134(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction135(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction136(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction137(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction138(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction139(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction140(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction141(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction142(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction143(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction144(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction145(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction146(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction147(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction148(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction149(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction150(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction151(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction152(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction153(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction154(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction155(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction156(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction157(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction158(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction159(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction160(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction161(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction162(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction163(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction164(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction165(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction166(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction167(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction168(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction169(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction170(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction171(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction172(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction173(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction174(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction175(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction176(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction177(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction178(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction179(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction180(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction181(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction182(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction183(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction184(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction185(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction186(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction187(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction188(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction189(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction190(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction191(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction192(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction193(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction194(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction195(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction196(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction197(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction198(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction199(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction200(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction201(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction202(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction203(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction204(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction205(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction206(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction207(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction208(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction209(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction210(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction211(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction212(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction213(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction214(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction215(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction216(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction217(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction218(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction219(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction220(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction221(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction222(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction223(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction224(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction225(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction226(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction227(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction228(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction229(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction230(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction231(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction232(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction233(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction234(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction235(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction236(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction237(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction238(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction239(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction240(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction241(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction242(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction243(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction244(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction245(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction246(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction247(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction248(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction249(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction250(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction251(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction252(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction253(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction254(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction255(void);

#endif // defined(_WIN64)

}


//+-------------------------------------------------------------------------
//
//  Global data
//
//--------------------------------------------------------------------------

// Hook Factory

extern const IPSFactoryHookVtbl CStdPSFactoryBufferVtbl = {
    CStdPSFactoryBuffer_QueryInterface,
    CStdPSFactoryBuffer_AddRef,
    CStdPSFactoryBuffer_Release,
    CStdPSFactoryBuffer_CreateProxy,
    CStdPSFactoryBuffer_CreateStub,
    CStdPSFactoryBuffer_HkGetProxyFileInfo };

// Nondelegated synchronous StubBuffer vtable

extern const IRpcStubBufferVtbl CStdStubBufferVtbl= {
    CStdStubBuffer_QueryInterface,
    CStdStubBuffer_AddRef,
    0,                          // sync stub is not aggregated
    CStdStubBuffer_Connect,
    CStdStubBuffer_Disconnect,
    CStdStubBuffer_Invoke,
    CStdStubBuffer_IsIIDSupported,
    CStdStubBuffer_CountRefs,
    CStdStubBuffer_DebugServerQueryInterface,
    CStdStubBuffer_DebugServerRelease };

// Delegated synchronous StubBuffer vtable

extern const IRpcStubBufferVtbl CStdStubBuffer2Vtbl= {
    CStdStubBuffer_QueryInterface,
    CStdStubBuffer_AddRef,
    0,                          // sync stub is not aggregated
    CStdStubBuffer2_Connect,
    CStdStubBuffer2_Disconnect,
    CStdStubBuffer_Invoke,
    CStdStubBuffer_IsIIDSupported,
    CStdStubBuffer2_CountRefs,
    CStdStubBuffer_DebugServerQueryInterface,
    CStdStubBuffer_DebugServerRelease };

extern const IRpcProxyBufferVtbl CStdProxyBufferVtbl;
extern const IRpcProxyBufferVtbl CStdProxyBuffer2Vtbl;

extern const ICallFactoryVtbl CStdProxyBuffer_CallFactoryVtbl;
extern const ICallFactoryVtbl CStdProxyBuffer2_CallFactoryVtbl;

extern const ICallFactoryVtbl CStdStubBuffer_CallFactoryVtbl;
extern const ICallFactoryVtbl CStdStubBuffer2_CallFactoryVtbl;

extern const IReleaseMarshalBuffersVtbl CStdProxyBuffer_ReleaseMarshalBuffersVtbl;
extern const IReleaseMarshalBuffersVtbl CStdStubBuffer_ReleaseMarshalBuffersVtbl;
extern const IReleaseMarshalBuffersVtbl CStdAsyncProxyBuffer_ReleaseMarshalBuffersVtbl;
extern const IReleaseMarshalBuffersVtbl CStdAsyncStubBuffer_ReleaseMarshalBuffersVtbl;


extern const IRpcStubBufferVtbl CStdAsyncStubBufferVtbl= {
    CStdAsyncStubBuffer_QueryInterface,
    CStdAsyncStubBuffer_AddRef,
    CStdAsyncStubBuffer_Release,
    CStdAsyncStubBuffer_Connect,        //
    CStdAsyncStubBuffer_Disconnect,     //
    CStdAsyncStubBuffer_Invoke,
    CStdStubBuffer_IsIIDSupported,
    CStdStubBuffer_CountRefs,
    CStdStubBuffer_DebugServerQueryInterface,
    CStdStubBuffer_DebugServerRelease };


extern const IRpcStubBufferVtbl CStdAsyncStubBuffer2Vtbl= {
    CStdAsyncStubBuffer_QueryInterface,
    CStdAsyncStubBuffer_AddRef,
    CStdAsyncStubBuffer2_Release,
    CStdAsyncStubBuffer2_Connect,       //
    CStdAsyncStubBuffer2_Disconnect,    //
    CStdAsyncStubBuffer_Invoke,
    CStdStubBuffer_IsIIDSupported,
    CStdStubBuffer2_CountRefs,
    CStdStubBuffer_DebugServerQueryInterface,
    CStdStubBuffer_DebugServerRelease };



extern void * const g_ForwardingVtbl[] = {
    Forwarding_QueryInterface,
    Forwarding_AddRef,
    Forwarding_Release,
    NdrProxyForwardingFunction3,
    NdrProxyForwardingFunction4,
    NdrProxyForwardingFunction5,
    NdrProxyForwardingFunction6,
    NdrProxyForwardingFunction7,
    NdrProxyForwardingFunction8,
    NdrProxyForwardingFunction9,
    NdrProxyForwardingFunction10,
    NdrProxyForwardingFunction11,
    NdrProxyForwardingFunction12,
    NdrProxyForwardingFunction13,
    NdrProxyForwardingFunction14,
    NdrProxyForwardingFunction15,
    NdrProxyForwardingFunction16,
    NdrProxyForwardingFunction17,
    NdrProxyForwardingFunction18,
    NdrProxyForwardingFunction19,
    NdrProxyForwardingFunction20,
    NdrProxyForwardingFunction21,
    NdrProxyForwardingFunction22,
    NdrProxyForwardingFunction23,
    NdrProxyForwardingFunction24,
    NdrProxyForwardingFunction25,
    NdrProxyForwardingFunction26,
    NdrProxyForwardingFunction27,
    NdrProxyForwardingFunction28,
    NdrProxyForwardingFunction29,
    NdrProxyForwardingFunction30,
    NdrProxyForwardingFunction31,
    NdrProxyForwardingFunction32,
    NdrProxyForwardingFunction33,
    NdrProxyForwardingFunction34,
    NdrProxyForwardingFunction35,
    NdrProxyForwardingFunction36,
    NdrProxyForwardingFunction37,
    NdrProxyForwardingFunction38,
    NdrProxyForwardingFunction39,
    NdrProxyForwardingFunction40,
    NdrProxyForwardingFunction41,
    NdrProxyForwardingFunction42,
    NdrProxyForwardingFunction43,
    NdrProxyForwardingFunction44,
    NdrProxyForwardingFunction45,
    NdrProxyForwardingFunction46,
    NdrProxyForwardingFunction47,
    NdrProxyForwardingFunction48,
    NdrProxyForwardingFunction49,
    NdrProxyForwardingFunction50,
    NdrProxyForwardingFunction51,
    NdrProxyForwardingFunction52,
    NdrProxyForwardingFunction53,
    NdrProxyForwardingFunction54,
    NdrProxyForwardingFunction55,
    NdrProxyForwardingFunction56,
    NdrProxyForwardingFunction57,
    NdrProxyForwardingFunction58,
    NdrProxyForwardingFunction59,
    NdrProxyForwardingFunction60,
    NdrProxyForwardingFunction61,
    NdrProxyForwardingFunction62,
    NdrProxyForwardingFunction63,
    NdrProxyForwardingFunction64,
    NdrProxyForwardingFunction65,
    NdrProxyForwardingFunction66,
    NdrProxyForwardingFunction67,
    NdrProxyForwardingFunction68,
    NdrProxyForwardingFunction69,
    NdrProxyForwardingFunction70,
    NdrProxyForwardingFunction71,
    NdrProxyForwardingFunction72,
    NdrProxyForwardingFunction73,
    NdrProxyForwardingFunction74,
    NdrProxyForwardingFunction75,
    NdrProxyForwardingFunction76,
    NdrProxyForwardingFunction77,
    NdrProxyForwardingFunction78,
    NdrProxyForwardingFunction79,
    NdrProxyForwardingFunction80,
    NdrProxyForwardingFunction81,
    NdrProxyForwardingFunction82,
    NdrProxyForwardingFunction83,
    NdrProxyForwardingFunction84,
    NdrProxyForwardingFunction85,
    NdrProxyForwardingFunction86,
    NdrProxyForwardingFunction87,
    NdrProxyForwardingFunction88,
    NdrProxyForwardingFunction89,
    NdrProxyForwardingFunction90,
    NdrProxyForwardingFunction91,
    NdrProxyForwardingFunction92,
    NdrProxyForwardingFunction93,
    NdrProxyForwardingFunction94,
    NdrProxyForwardingFunction95,
    NdrProxyForwardingFunction96,
    NdrProxyForwardingFunction97,
    NdrProxyForwardingFunction98,
    NdrProxyForwardingFunction99,
    NdrProxyForwardingFunction100,
    NdrProxyForwardingFunction101,
    NdrProxyForwardingFunction102,
    NdrProxyForwardingFunction103,
    NdrProxyForwardingFunction104,
    NdrProxyForwardingFunction105,
    NdrProxyForwardingFunction106,
    NdrProxyForwardingFunction107,
    NdrProxyForwardingFunction108,
    NdrProxyForwardingFunction109,
    NdrProxyForwardingFunction110,
    NdrProxyForwardingFunction111,
    NdrProxyForwardingFunction112,
    NdrProxyForwardingFunction113,
    NdrProxyForwardingFunction114,
    NdrProxyForwardingFunction115,
    NdrProxyForwardingFunction116,
    NdrProxyForwardingFunction117,
    NdrProxyForwardingFunction118,
    NdrProxyForwardingFunction119,
    NdrProxyForwardingFunction120,
    NdrProxyForwardingFunction121,
    NdrProxyForwardingFunction122,
    NdrProxyForwardingFunction123,
    NdrProxyForwardingFunction124,
    NdrProxyForwardingFunction125,
    NdrProxyForwardingFunction126,
    NdrProxyForwardingFunction127
#if defined (_WIN64)
    ,
    NdrProxyForwardingFunction128,
    NdrProxyForwardingFunction129,
    NdrProxyForwardingFunction130,
    NdrProxyForwardingFunction131,
    NdrProxyForwardingFunction132,
    NdrProxyForwardingFunction133,
    NdrProxyForwardingFunction134,
    NdrProxyForwardingFunction135,
    NdrProxyForwardingFunction136,
    NdrProxyForwardingFunction137,
    NdrProxyForwardingFunction138,
    NdrProxyForwardingFunction139,
    NdrProxyForwardingFunction140,
    NdrProxyForwardingFunction141,
    NdrProxyForwardingFunction142,
    NdrProxyForwardingFunction143,
    NdrProxyForwardingFunction144,
    NdrProxyForwardingFunction145,
    NdrProxyForwardingFunction146,
    NdrProxyForwardingFunction147,
    NdrProxyForwardingFunction148,
    NdrProxyForwardingFunction149,
    NdrProxyForwardingFunction150,
    NdrProxyForwardingFunction151,
    NdrProxyForwardingFunction152,
    NdrProxyForwardingFunction153,
    NdrProxyForwardingFunction154,
    NdrProxyForwardingFunction155,
    NdrProxyForwardingFunction156,
    NdrProxyForwardingFunction157,
    NdrProxyForwardingFunction158,
    NdrProxyForwardingFunction159,
    NdrProxyForwardingFunction160,
    NdrProxyForwardingFunction161,
    NdrProxyForwardingFunction162,
    NdrProxyForwardingFunction163,
    NdrProxyForwardingFunction164,
    NdrProxyForwardingFunction165,
    NdrProxyForwardingFunction166,
    NdrProxyForwardingFunction167,
    NdrProxyForwardingFunction168,
    NdrProxyForwardingFunction169,
    NdrProxyForwardingFunction170,
    NdrProxyForwardingFunction171,
    NdrProxyForwardingFunction172,
    NdrProxyForwardingFunction173,
    NdrProxyForwardingFunction174,
    NdrProxyForwardingFunction175,
    NdrProxyForwardingFunction176,
    NdrProxyForwardingFunction177,
    NdrProxyForwardingFunction178,
    NdrProxyForwardingFunction179,
    NdrProxyForwardingFunction180,
    NdrProxyForwardingFunction181,
    NdrProxyForwardingFunction182,
    NdrProxyForwardingFunction183,
    NdrProxyForwardingFunction184,
    NdrProxyForwardingFunction185,
    NdrProxyForwardingFunction186,
    NdrProxyForwardingFunction187,
    NdrProxyForwardingFunction188,
    NdrProxyForwardingFunction189,
    NdrProxyForwardingFunction190,
    NdrProxyForwardingFunction191,
    NdrProxyForwardingFunction192,
    NdrProxyForwardingFunction193,
    NdrProxyForwardingFunction194,
    NdrProxyForwardingFunction195,
    NdrProxyForwardingFunction196,
    NdrProxyForwardingFunction197,
    NdrProxyForwardingFunction198,
    NdrProxyForwardingFunction199,
    NdrProxyForwardingFunction200,
    NdrProxyForwardingFunction201,
    NdrProxyForwardingFunction202,
    NdrProxyForwardingFunction203,
    NdrProxyForwardingFunction204,
    NdrProxyForwardingFunction205,
    NdrProxyForwardingFunction206,
    NdrProxyForwardingFunction207,
    NdrProxyForwardingFunction208,
    NdrProxyForwardingFunction209,
    NdrProxyForwardingFunction210,
    NdrProxyForwardingFunction211,
    NdrProxyForwardingFunction212,
    NdrProxyForwardingFunction213,
    NdrProxyForwardingFunction214,
    NdrProxyForwardingFunction215,
    NdrProxyForwardingFunction216,
    NdrProxyForwardingFunction217,
    NdrProxyForwardingFunction218,
    NdrProxyForwardingFunction219,
    NdrProxyForwardingFunction220,
    NdrProxyForwardingFunction221,
    NdrProxyForwardingFunction222,
    NdrProxyForwardingFunction223,
    NdrProxyForwardingFunction224,
    NdrProxyForwardingFunction225,
    NdrProxyForwardingFunction226,
    NdrProxyForwardingFunction227,
    NdrProxyForwardingFunction228,
    NdrProxyForwardingFunction229,
    NdrProxyForwardingFunction230,
    NdrProxyForwardingFunction231,
    NdrProxyForwardingFunction232,
    NdrProxyForwardingFunction233,
    NdrProxyForwardingFunction234,
    NdrProxyForwardingFunction235,
    NdrProxyForwardingFunction236,
    NdrProxyForwardingFunction237,
    NdrProxyForwardingFunction238,
    NdrProxyForwardingFunction239,
    NdrProxyForwardingFunction240,
    NdrProxyForwardingFunction241,
    NdrProxyForwardingFunction242,
    NdrProxyForwardingFunction243,
    NdrProxyForwardingFunction244,
    NdrProxyForwardingFunction245,
    NdrProxyForwardingFunction246,
    NdrProxyForwardingFunction247,
    NdrProxyForwardingFunction248,
    NdrProxyForwardingFunction249,
    NdrProxyForwardingFunction250,
    NdrProxyForwardingFunction251,
    NdrProxyForwardingFunction252,
    NdrProxyForwardingFunction253,
    NdrProxyForwardingFunction254,
    NdrProxyForwardingFunction255

#endif // defined(_WIN64))
    };

void ** ProxyForwardVtbl = (void **)g_ForwardingVtbl;



#pragma code_seg(".orpc")


//+---------------------------------------------------------------------------
//
//  Function:   GetTemplateVtbl
//
//  Synopsis:   retrieve a copy of stublessclientvtbl and addref it.
//
//  Arguments:  void *** pppVtbl stublessclientvtbl to return.
//
//  Note:       StublessClientVtbl - sizeof(LONG) is the ref count .
//
//  Returns:
//
//----------------------------------------------------------------------------
void GetTemplateVtbl(void *** pppVtbl)
{
    LPLONG pTemp;
    void **ppVtbl;
    I_RpcRequestMutex(&TemplateMutex);
    ppVtbl = StublessClientVtbl;
    pTemp = (LPLONG)ppVtbl;
    *pppVtbl = ppVtbl;

    if (ppVtbl == (void**)g_StublessClientVtbl)
    {
        I_RpcClearMutex(TemplateMutex);
        return ;
    }

    pTemp--;
    (*pTemp) ++ ;
    I_RpcClearMutex(TemplateMutex);

}

// release the vtbl, free the memory if necessary.
void ReleaseTemplateVtbl(void ** pVtbl)
{
    LPLONG pTemp;

    I_RpcRequestMutex(&TemplateMutex);
    pTemp = (LPLONG)pVtbl;
    if (pVtbl == (void**)g_StublessClientVtbl)
    {
        I_RpcClearMutex(TemplateMutex);
        return;
    }

    pTemp--;
    (*pTemp)--;
    if (0 == *pTemp )
    {
        I_RpcFree(pTemp);
    }
    I_RpcClearMutex(TemplateMutex);
}


//+---------------------------------------------------------------------------
//
//  Function:   GetTemplateForwardVtbl
//
//  Synopsis:   retrieve a copy of stublessclientvtbl and addref it.
//
//  Arguments:  void *** pppVtbl stublessclientvtbl to return.
//
//  Note:       StublessClientVtbl - sizeof(LONG) is the ref count .
//
//  Returns:
//
//----------------------------------------------------------------------------
void GetTemplateForwardVtbl(void *** pppVtbl)
{
    LPLONG pTemp;
    void **ppVtbl;
    I_RpcRequestMutex(&TemplateMutex);
    ppVtbl = ProxyForwardVtbl;
    pTemp = (LPLONG)ppVtbl;
    *pppVtbl = ppVtbl;

    if (ppVtbl == g_ForwardingVtbl)
    {
        I_RpcClearMutex(TemplateMutex);
        return ;
    }

    pTemp--;
    (*pTemp) ++ ;
    I_RpcClearMutex(TemplateMutex);

}

// release the vtbl, free the memory if necessary.
void ReleaseTemplateForwardVtbl(void ** pVtbl)
{
    LPLONG pTemp;

    I_RpcRequestMutex(&TemplateMutex);
    pTemp = (LPLONG)pVtbl;
    if (pVtbl == g_ForwardingVtbl)
    {
        I_RpcClearMutex(TemplateMutex);
        return;
    }

    pTemp--;
    (*pTemp)--;
    if (0 == *pTemp )
    {
        I_RpcFree(pTemp);
    }
    I_RpcClearMutex(TemplateMutex);
}



//+---------------------------------------------------------------------------
//
//  Function:   NdrpInitializeStublessVtbl
//
//  Synopsis:   Initialize a stubless vtbl list for current process. increase the size of
//              vtbl link list  and regenerate the vtbl array if necessary.
//
//  Note:       The actural vtbl size created might be larger than requested: we will fill
//              in the whole block of link list .
//
//  Arguments:  numMethods  number of methods in the interface.
//
//  Returns:
//    S_OK
//
//----------------------------------------------------------------------------
HRESULT NdrpInitializeStublessVtbl(ULONG numMethods)
{
    void ** TempVtbl, ** pOldVtbl = NULL;   // ole vtbl template to be freed.
    HRESULT hr;

    // request a mutex might fail because of OUT_OF_MEMORY, and exception would be thrown. 
    // we don't want to throw exception in ole call, so we initialize it first and catch the exceptions.
    if ( VtblMutex == NULL )
        {
        hr = NdrpInitializeMutex( &VtblMutex );
        if ( FAILED( hr ) )
            return hr;  
        }

    if ( TemplateMutex == NULL )
        {
        hr = NdrpInitializeMutex( &TemplateMutex );
        if ( FAILED( hr ) )
            return hr;
        }
    
#if defined(_WIN64)
    if (numMethods <= 1024)
        return S_OK;
    else
        return E_FAIL;
#else

    if (numMethods <= MAX_STUBLESS_PROC)
        return S_OK;

    
    I_RpcRequestMutex(&VtblMutex);
    if (numMethods > g_dwVtblSize)
    {
        // create a
        hr = CreateStublessProcBuffer(numMethods,&TempVtbl);

        if (FAILED(hr))
        {
            I_RpcClearMutex(VtblMutex);
            return hr;
        }

        pOldVtbl = StublessClientVtbl;

        StublessClientVtbl = TempVtbl;

    }

    I_RpcClearMutex(VtblMutex);

    if (pOldVtbl)
        ReleaseTemplateVtbl(pOldVtbl);

    return S_OK;
#endif // defined(_WIN64)
}



//+---------------------------------------------------------------------------
//
//  Function:   NdrpInitializeForwardVtbl
//
//  Synopsis:   Initialize a stubless vtbl list for current process. increase the size of
//              vtbl link list  and regenerate the vtbl array if necessary.
//
//  Note:       The actural vtbl size created might be larger than requested: we will fill
//              in the whole block of link list .
//
//  Arguments:  numMethods  number of methods in the interface.
//
//  Returns:
//    S_OK
//
//----------------------------------------------------------------------------
HRESULT NdrpInitializeForwardVtbl(ULONG numMethods)
{
    void ** TempVtbl, ** pOldVtbl = NULL;   // ole vtbl template to be freed.
    HRESULT hr;
#if defined(_WIN64)
    if (numMethods <= 256)
        return S_OK;
    else
        return E_FAIL;
#else


    if (numMethods <= MAX_STUBLESS_PROC)
        return S_OK;

    I_RpcRequestMutex(&VtblMutex);
    if (numMethods > g_dwForwardVtblSize)
    {
        // create a
        hr = CreateForwardProcBuffer(numMethods,&TempVtbl);

        if (FAILED(hr) )
        {
            I_RpcClearMutex(VtblMutex);
            return hr;
        }

        pOldVtbl = ProxyForwardVtbl;

        ProxyForwardVtbl = TempVtbl;

    }

    I_RpcClearMutex(VtblMutex);

    if (pOldVtbl)
        ReleaseTemplateForwardVtbl(pOldVtbl);

    return S_OK;
#endif // defined(_WIN64)
}



BOOL NdrpFindInterface(
    IN  const ProxyFileInfo **  pProxyFileList,
    IN  REFIID                  riid,
    OUT const ProxyFileInfo **  ppProxyFileInfo,
    OUT long *                  pIndex)
/*++

Routine Description:
    Search the ProxyFileInfo and find the specified interface.
    If the count is specified in the ProxyFileInfo, then the interfaces in
    the file are sorted by IID.  This means that we can perform a binary
    search for the IID.

Arguments:
    pProxyFileList  - Specifies a list of proxy files to be searched.
    riid            - Specifies the interface ID to be found.
    ppProxyFileInfo - Returns a pointer to the proxy file info.
    pIndex          - Returns the index of the interface in the proxy file info.

Return Value:
    TRUE    - The interface was found.
    FALSE   - The interface was not found.

--*/
{
    long 				j;
    BOOL 				fFound 			= FALSE;
	ProxyFileInfo	**	ppProxyFileCur;
	ProxyFileInfo	*	pProxyFileCur;

    //Search the list of proxy files.
    for( ppProxyFileCur = (ProxyFileInfo **) pProxyFileList;
        (*ppProxyFileCur != 0) && (fFound != TRUE);
        ppProxyFileCur++)
	    {
	    //Search for the interface proxy vtable.
        pProxyFileCur = *ppProxyFileCur;

        // see if it has a lookup routine already
        if ( ( pProxyFileCur->TableVersion >= 1 ) &&
			 ( pProxyFileCur->pIIDLookupRtn ) )	
			{
			fFound = (*pProxyFileCur->pIIDLookupRtn)( &riid, (int*)&j );
			}
		else	//Linear search.
	        {
	        for(j = 0;
	            (pProxyFileCur->pProxyVtblList[j] != 0);
	            j++)
		        {
	            if(memcmp(&riid,
	                pProxyFileCur->pStubVtblList[j]->header.piid,
	                sizeof(IID)) == 0)
		            {
	                fFound = TRUE;
		            break;
		            }
		        }
			}
	    }

	if ( fFound )
		{
        //We found the interface!
        if(ppProxyFileInfo != 0)
            *ppProxyFileInfo = pProxyFileCur;

        if(pIndex != 0)
            *pIndex = j;
		}

    return fFound;
 }



__inline
void NdrpInitializeProxyVtbl(
    CInterfaceProxyVtbl *pProxyVtbl,
    unsigned long count,
    BOOL IsDelegated,
    unsigned short ProxyVersion)
/*++

Routine Description:
    Initialize the proxy vtbl.

Arguments:
    pProxyVtbl  - Supplies vtbl to be initialized.
    count       - Supplies number of entries in the vtbl.
    IsDelegated - TRUE if the interface is delegated, FALSE otherwise.

Return Value:
    None.

--*/
{
    unsigned long k;
    void **  Vtbl;
    void **  pStublessVtbl, **pForwardingVtbl;
    void **  SourceVtbl;

    GetTemplateVtbl(&pStublessVtbl);
    GetTemplateForwardVtbl(&pForwardingVtbl);

    SourceVtbl = IsDelegated ?
                           pForwardingVtbl : pStublessVtbl;

    Vtbl = pProxyVtbl->Vtbl;

    //
    // Proxies after NT 3.51 Beta have a ProxyHeader 4 bytes
    // larger to support stubless proxies.  So in older proxies
    // subtract 4 bytes to get the the Vtable.
    //
    if ( ProxyVersion < 2 )
        Vtbl = (void **) ((char*)Vtbl - PTR_MEM_SIZE);


    // Initialize forwarding or stubless proxy functions if necessary.

    if ( IsDelegated )
        {
        Vtbl[0] = IUnknown_QueryInterface_Proxy;
        Vtbl[1] = IUnknown_AddRef_Proxy;
        Vtbl[2] = IUnknown_Release_Proxy;
        k = 3;
        }
    else
        k = 0;


    for( ; k < count; k++)
    {
        if(!Vtbl[k])
        {
            Vtbl[k] = SourceVtbl[k];
        }
        else if ( -1 == (ULONG_PTR)Vtbl[k] )
        {
            Vtbl[k] = pStublessVtbl[k];
        }
    }

    ReleaseTemplateVtbl(pStublessVtbl);
    ReleaseTemplateForwardVtbl(pForwardingVtbl);
}

__inline
void NdrpInitializeStubVtbl(
    CInterfaceStubVtbl *pStubVtbl,
    unsigned long version)
/*++

Routine Description:
    Initialize the stub vtbl.

Arguments:
    pStubVtbl  - Supplies vtbl to be initialized.
    version

Return Value:
    None.

--*/
{
    void * * pVtbl = (void **) &pStubVtbl->Vtbl;
    void * * pSourceVtbl;
    int      i;

    switch ( version )
        {
        case 2:
            pSourceVtbl = (void **)&CStdStubBuffer2Vtbl;
            break;

        case 3:
            pSourceVtbl = (void **)&CStdAsyncStubBufferVtbl;
            break;

        case 4:
            pSourceVtbl = (void **)&CStdAsyncStubBuffer2Vtbl;
            break;

        default:
            pSourceVtbl = (void **)&CStdStubBufferVtbl;

        }

    for ( i=0; i < sizeof(IRpcStubBufferVtbl)/PTR_MEM_SIZE; i++ )
        {
        if ( !pVtbl[i] )
            pVtbl[i] = pSourceVtbl[i];
        }

}


HRESULT NdrpInitializeProxyDll(
    IN  const ProxyFileInfo **  pProxyFileList,
    IN CStdPSFactoryBuffer *    pPSFactoryBuffer )
/*++

Routine Description:
    Initialize the proxy DLL.

Arguments:
    pProxyFileList   - Specifies a list of proxy files to be searched.
    pPSFactoryBuffer - Pointer to class factory for proxy DLL.

Return Value:
    None.

--*/
{
    long i, j;
    HRESULT hr;
    unsigned long version, lStublessMaxCount = 0, lForwardMaxCount = 0;

    // set up the PSFactory object if we are the first
    // note that the refcount is NOT altered right here to avoid races
    if (pPSFactoryBuffer->lpVtbl != 0)
        return S_OK;

    for (i = 0; pProxyFileList[i] != 0; i++)
        for (j = 0; pProxyFileList[i]->pProxyVtblList[j] != 0; j++)
        {
            if((pProxyFileList[i]->pDelegatedIIDs != 0) &&
               (pProxyFileList[i]->pDelegatedIIDs[j] != 0))
            {
                if (lForwardMaxCount < pProxyFileList[i]->pStubVtblList[j]->header.DispatchTableCount)
                    lForwardMaxCount = pProxyFileList[i]->pStubVtblList[j]->header.DispatchTableCount;
            }
            if (lStublessMaxCount < pProxyFileList[i]->pStubVtblList[j]->header.DispatchTableCount)
                lStublessMaxCount = pProxyFileList[i]->pStubVtblList[j]->header.DispatchTableCount;
        }

    hr = NdrpInitializeStublessVtbl(lStublessMaxCount);
    if (SUCCEEDED(hr))
        hr = NdrpInitializeForwardVtbl(lForwardMaxCount);

    if (FAILED(hr))
        return hr;

    //iterate over the list of proxy files in the proxy DLL.
    for(i = 0;
        pProxyFileList[i] != 0;
        i++)
    {
        //iterate over the list of interfaces in the proxy file.
        for(j = 0;
            pProxyFileList[i]->pProxyVtblList[j] != 0;
            j++)
        {
            if((pProxyFileList[i]->pDelegatedIIDs != 0) &&
               (pProxyFileList[i]->pDelegatedIIDs[j] != 0))
                version = 2;
            else
                version = 0;

            //Initialize the proxy vtbl.
            NdrpInitializeProxyVtbl(pProxyFileList[i]->pProxyVtblList[j],
                                    pProxyFileList[i]->pStubVtblList[j]->header.DispatchTableCount,
                                    (version == 2),
                                    pProxyFileList[i]->TableVersion);

            //Initialize the stub vtbl.

            // See if this is an async uuid interface.
            if ( (pProxyFileList[i]->TableVersion  &  NDR_PROXY_FILE_ASYNC_UUID)  &&
                 (ULONG_PTR)pProxyFileList[i]->pAsyncIIDLookup[j] == -1 )
                {
                if (version == 2)
                    {
                    // delegated async
                    version = 4;
                    }
                else
                    {
                    // non-delegated async
                    version = 3;
                    }
                }

            NdrpInitializeStubVtbl(pProxyFileList[i]->pStubVtblList[j],
                                   version);

            //Initialize the stub dispatch table.

        }
    }

    pPSFactoryBuffer->pProxyFileList = pProxyFileList;

    //Set the lpVtbl.  This code is safe for multiple threads.
    InterlockedExchangePointer((PVOID *) &pPSFactoryBuffer->lpVtbl,
                               (PVOID) &CStdPSFactoryBufferVtbl);

    return hr;
 }

HRESULT RPC_ENTRY NdrDllGetClassObject (
    IN  REFCLSID                rclsid,
    IN  REFIID                  riid,
    OUT void **                 ppv,
    IN const ProxyFileInfo **   pProxyFileList,
    IN const CLSID *            pclsid,
    IN CStdPSFactoryBuffer *    pPSFactoryBuffer )
/*++

Routine Description:
    Searches the linked list for the required class.

Arguments:
    rclsid -- class id to find
    riid   -- interface to return
    ppv    -- output pointer
    ppfinfo-- proxyfile info data structure
    pclsid -- proxy file classid
    pPSFactoryBuffer -- pointer to class factory for dll

Return Value:
    CLASS_E_CLASSNOTAVAILABLE if class not found
    Otherwise, whatever is returned by the class's QI

--*/
{
    HRESULT hr;
    RPC_STATUS rc;
    BOOL    fFound;

    //Initialize the RPC heap.
    rc = NdrpPerformRpcInitialization();

    if (RPC_S_OK == rc)
        hr = NdrpInitializeProxyDll(pProxyFileList, pPSFactoryBuffer);
    else
        hr = HRESULT_FROM_WIN32(rc);

    if (SUCCEEDED(hr))
    {
        if((pclsid != 0) && (memcmp(&rclsid, pclsid, sizeof(IID)) == 0))
            fFound = TRUE;
        else
        {
            //Search the list of proxy files.
            fFound = NdrpFindInterface(pProxyFileList, rclsid, 0, 0);
        }

        if(fFound != TRUE)
            hr = CLASS_E_CLASSNOTAVAILABLE;
        else
        {
            // see if they asked for one of our interfaces
            hr = pPSFactoryBuffer->lpVtbl->QueryInterface(
                (IPSFactoryBuffer *)pPSFactoryBuffer, riid, ppv);
        }
    }

    if(FAILED(hr))
        *ppv  = 0;

    return hr;
}

HRESULT RPC_ENTRY
NdrDllCanUnloadNow(
    IN CStdPSFactoryBuffer * pPSFactoryBuffer)
/*++

Routine Description:

Arguments:

Return Value:
    S_OK if DLL reference count is zero
    S_FALSE otherwise

--*/
{
    HRESULT hr;

    if(pPSFactoryBuffer->RefCount == 0)
        hr = S_OK;
    else
        hr = S_FALSE;

    return hr;
}


EXTERN_C HRESULT NdrpCreateProxy(
    IN  REFIID              riid,
    IN  IUnknown *          punkOuter,
    OUT IRpcProxyBuffer **  ppProxy,
    OUT void **             ppv)
/*++

Routine Description:
    Create a proxy for the specified interface.

Arguments:
    riid        - Specifies the interface ID.
    punkOuter   - Specifies the controlling unknown.
    ppProxy     - Returns a pointer to the IRpcProxyBuffer interface on the proxy.
    ppv         - Returns a pointer to the interface proxy.

Return Value:
    S_OK
    REGDB_E_IIDNOTREG
    REGDB_E_READREGDB
    REGDB_E_INVALIDVALUE
    E_NOINTERFACE

--*/
{
    HRESULT             hr;
    CLSID               clsid;
    IPSFactoryBuffer *  pFactory;

    hr = (*pfnCoGetPSClsid)(riid, &clsid);

    if(SUCCEEDED(hr))
    {
        hr = (*pfnCoGetClassObject)(clsid,
                                    CLSCTX_INPROC_SERVER | CLSCTX_PS_DLL,
                                    0,
                                    IID_IPSFactoryBuffer,
                                    (void**)&pFactory);

        if(SUCCEEDED(hr))
        {
            hr = pFactory->lpVtbl->CreateProxy(pFactory, punkOuter, riid,  ppProxy, ppv);
            if(SUCCEEDED(hr))
            {
                //Note that CreateProxy increments the reference count on punkOuter.
                //In order to eliminate the circular reference,
                //we release the punkOuter here.
                if((*ppv != 0) && (punkOuter != 0))
                    punkOuter->lpVtbl->Release(punkOuter);
            }
            pFactory->lpVtbl->Release(pFactory);
        }
    }

    if(FAILED(hr))
    {
        *ppProxy = 0;
        *ppv = 0;
    }

    return hr;
}


EXTERN_C HRESULT NdrpCreateStub(
    IN  REFIID              riid,
    IN  IUnknown *          punkServer,
    OUT IRpcStubBuffer **   ppStub)
/*++

Routine Description:
    Create a stub for the specified interface.

Arguments:
    riid        - Species the interface ID.
    punkServer  - Specifies the controlling unknown.
    ppStub      - Returns a pointer to the stub.

Return Value:
    S_OK
    REGDB_E_IIDNOTREG
    REGDB_E_READREGDB
    REGDB_E_INVALIDVALUE
    E_NOINTERFACE

--*/
{
    HRESULT             hr;
    CLSID               clsid;
    IPSFactoryBuffer *  pFactory;

    hr = (*pfnCoGetPSClsid)(riid, &clsid);

    if(SUCCEEDED(hr))
    {
        hr = (*pfnCoGetClassObject)(clsid,
                                    CLSCTX_INPROC_SERVER | CLSCTX_PS_DLL,
                                    0,
                                    IID_IPSFactoryBuffer,
                                    (void**)&pFactory);

        if(SUCCEEDED(hr))
        {
            hr = pFactory->lpVtbl->CreateStub(pFactory, riid, punkServer, ppStub);
            pFactory->lpVtbl->Release(pFactory);
        }
    }

    if(FAILED(hr))
        *ppStub = 0;

    return hr;
}


HRESULT STDMETHODCALLTYPE
CStdPSFactoryBuffer_QueryInterface (
    IN  IPSFactoryBuffer *  This,
    IN  REFIID              iid,
    OUT void **             ppv )
/*++

Routine Description:
    Query for an interface on the PSFactoryBuffer.  The PSFactoryBuffer
    supports the IUnknown and IPSFactoryBuffer interfaces.

Arguments:
    iid - Specifies the interface ID.
    ppv - Returns a pointer to the specified interface.

Return Value:
    S_OK
    E_NOINTERFACE

--*/
{
    HRESULT hr;

    if ((memcmp(&iid, &IID_IUnknown, sizeof(IID)) == 0) ||
        (memcmp(&iid, &IID_IPSFactoryBuffer, sizeof(IID)) == 0) ||
        (memcmp(&iid, &IID_IPSFactoryHook, sizeof(IID)) == 0))
    {
        *ppv = This;
        This->lpVtbl->AddRef(This);
        hr = S_OK;
    }
    else
    {
        *ppv = 0;
        hr = E_NOINTERFACE;
    }

    return hr;
}


ULONG STDMETHODCALLTYPE
CStdPSFactoryBuffer_AddRef(
    IN  IPSFactoryBuffer *This)
/*++

Routine Description:
    Increment reference count. Since we have a single instance of the
    CStdPSFactoryBuffer per DLL, we can use the PSFactory reference
    count as the DLL reference count.

Arguments:

Return Value:
    Reference count.

--*/
{
    InterlockedIncrement(&((CStdPSFactoryBuffer *) This)->RefCount);

    return (unsigned long) ((CStdPSFactoryBuffer *) This)->RefCount;
}

ULONG STDMETHODCALLTYPE
CStdPSFactoryBuffer_Release(
    IN  IPSFactoryBuffer *This)
/*++

Routine Description:
    Decrement reference count.

Arguments:

Return Value:
    Reference count.

--*/
{
    ULONG       count;

    NDR_ASSERT(((CStdPSFactoryBuffer *)This)->RefCount > 0, "Invalid reference count");

    count = (ULONG) ((CStdPSFactoryBuffer *)This)->RefCount - 1;

    if(InterlockedDecrement(&((CStdPSFactoryBuffer *)This)->RefCount) == 0)
    {
        count = 0;
    }

    return count;
}



HRESULT STDMETHODCALLTYPE
CStdPSFactoryBuffer_CreateProxy
(
    IN  IPSFactoryBuffer *  This,
    IN  IUnknown *          punkOuter,
    IN  REFIID              riid,
    OUT IRpcProxyBuffer **  ppProxy,
    OUT void **             ppv
)
/*++

Routine Description:
    Create a proxy for the specified interface.

Arguments:
    punkOuter   - Specifies the controlling unknown.
    riid        - Specifies the interface ID.
    ppProxy     - Returns a pointer to the IRpcProxyBuffer interface.
    ppv         - Returns a pointer to the specified interface.

Return Value:
    S_OK
    E_NOINTERFACE
    E_OUTOFMEMORY

--*/
{
    HRESULT             hr;
    BOOL                fFound;
    long                j;
    BOOL                fDelegate = FALSE;
    const ProxyFileInfo *pProxyFileInfo;

    fFound = NdrpFindInterface(((CStdPSFactoryBuffer *)This)->pProxyFileList, riid, &pProxyFileInfo, &j);

    if(fFound != TRUE)
        hr = E_NOINTERFACE;
    else if ( (pProxyFileInfo->TableVersion  &  NDR_PROXY_FILE_ASYNC_UUID)  &&
              (ULONG_PTR)pProxyFileInfo->pAsyncIIDLookup[j] == -1 )
        {
        // An attempt to create a sync proxy for an async interface.
        hr = E_NOINTERFACE;
        }
    else
    {
        if((pProxyFileInfo->pDelegatedIIDs != 0) &&
           (pProxyFileInfo->pDelegatedIIDs[j] != 0) &&
           (!IsEqualIID(*pProxyFileInfo->pDelegatedIIDs[j], IID_IUnknown)))
        {
            //Need to delegate to the proxy for the base interface..
            //Allocate memory for the new proxy buffer.
            CStdProxyBuffer2 *pProxyBuffer =
                (CStdProxyBuffer2*)(*pfnCoTaskMemAlloc)(sizeof(CStdProxyBuffer2));

            if(0 == pProxyBuffer)
                hr = E_OUTOFMEMORY;
            else
            {
                hr = S_OK;

                //Initialize the new proxy buffer.
                memset(pProxyBuffer, 0, sizeof(CStdProxyBuffer2));

                pProxyBuffer->lpVtbl = &CStdProxyBuffer2Vtbl;
                pProxyBuffer->RefCount = 1;
                pProxyBuffer->punkOuter = punkOuter ? punkOuter : (IUnknown *) pProxyBuffer;
                pProxyBuffer->pProxyVtbl = &pProxyFileInfo->
                                               pProxyVtblList[j]->Vtbl;
                if ( pProxyFileInfo->TableVersion < 2 )
                    pProxyBuffer->pRMBVtbl = NULL;
                else
                    pProxyBuffer->pRMBVtbl = &CStdProxyBuffer_ReleaseMarshalBuffersVtbl;

                if ( (pProxyFileInfo->TableVersion  &  NDR_PROXY_FILE_ASYNC_UUID)  &&
                     pProxyFileInfo->pAsyncIIDLookup[j] != 0 )
                    {
                    // The interface has an async counterpart.
                    pProxyBuffer->pCallFactoryVtbl = & CStdProxyBuffer2_CallFactoryVtbl;
                    pProxyBuffer->pAsyncIID = pProxyFileInfo->pAsyncIIDLookup[j];
                    pProxyBuffer->pRMBVtbl = &CStdAsyncProxyBuffer_ReleaseMarshalBuffersVtbl;
                    }

                //
                // Proxies after NT 3.51 Beta have a ProxyHeader 4 bytes
                // larger to support stubless proxies.  So in older proxies
                // subtract 4 bytes to get the the Vtable.
                //
                if ( pProxyFileInfo->TableVersion < 2 )
                    pProxyBuffer->pProxyVtbl = (void *)
                                      ((char *)pProxyBuffer->pProxyVtbl - PTR_MEM_SIZE);



                //Increment the DLL reference count for DllCanUnloadNow.
                This->lpVtbl->AddRef(This);
                pProxyBuffer->pPSFactory = This;

                pProxyBuffer->iidBase = *pProxyFileInfo->pDelegatedIIDs[j];

                //Create a proxy for the base interface.
                hr = NdrpCreateProxy(*pProxyFileInfo->pDelegatedIIDs[j],
                                     (IUnknown *) pProxyBuffer,
                                     &pProxyBuffer->pBaseProxyBuffer,
                                     (void**)&pProxyBuffer->pBaseProxy);

                if(FAILED(hr))
                    {
                    (*pfnCoTaskMemFree)(pProxyBuffer);
                    }
                else
                    {
                    *ppProxy = (IRpcProxyBuffer *) pProxyBuffer;
                    *ppv = (void *) &pProxyBuffer->pProxyVtbl;
                    ((IUnknown *) *ppv)->lpVtbl->AddRef((IUnknown *) *ppv);
                    }
            }
        }
        else
        {
            //Allocate memory for the new proxy buffer.
            CStdProxyBuffer *pProxyBuffer =
                (CStdProxyBuffer*)(*pfnCoTaskMemAlloc)(sizeof(CStdProxyBuffer));

            if(0 == pProxyBuffer)
                hr = E_OUTOFMEMORY;
            else
            {
                hr = S_OK;

                //Initialize the new proxy buffer.
                memset(pProxyBuffer, 0, sizeof(CStdProxyBuffer));

                pProxyBuffer->lpVtbl = &CStdProxyBufferVtbl;
                pProxyBuffer->RefCount = 1;
                pProxyBuffer->punkOuter = punkOuter ? punkOuter : (IUnknown *) pProxyBuffer;

                pProxyBuffer->pProxyVtbl = &pProxyFileInfo->
                                               pProxyVtblList[j]->Vtbl;

                if ( pProxyFileInfo->TableVersion < 2 )
                    pProxyBuffer->pRMBVtbl = NULL;
                else
                    pProxyBuffer->pRMBVtbl = &CStdProxyBuffer_ReleaseMarshalBuffersVtbl;


                if ( (pProxyFileInfo->TableVersion  &  NDR_PROXY_FILE_ASYNC_UUID)  &&
                     pProxyFileInfo->pAsyncIIDLookup[j] != 0 )
                    {
                    pProxyBuffer->pCallFactoryVtbl = & CStdProxyBuffer_CallFactoryVtbl;
                    pProxyBuffer->pAsyncIID = pProxyFileInfo->pAsyncIIDLookup[j];
                    pProxyBuffer->pRMBVtbl = &CStdAsyncProxyBuffer_ReleaseMarshalBuffersVtbl;
                    }

                //
                // Proxies after NT 3.51 Beta have a ProxyHeader 4 bytes
                // larger to support stubless proxies.  So in older proxies
                // subtract 4 bytes to get the the Vtable.
                //
                if ( pProxyFileInfo->TableVersion < 2 )
                    pProxyBuffer->pProxyVtbl = (void *)
                               ((char*)pProxyBuffer->pProxyVtbl - PTR_MEM_SIZE);

                //Increment the DLL reference count for DllCanUnloadNow.
                This->lpVtbl->AddRef(This);
                pProxyBuffer->pPSFactory = This;

                *ppProxy = (IRpcProxyBuffer *) pProxyBuffer;
                *ppv = (void *) &pProxyBuffer->pProxyVtbl;
                ((IUnknown *) *ppv)->lpVtbl->AddRef((IUnknown *) *ppv);
            }
        }
    }

    if(FAILED(hr))
    {
        *ppProxy = 0;
        *ppv = 0;
    }

    return hr;
}


HRESULT STDMETHODCALLTYPE
CStdPSFactoryBuffer_CreateStub
(
    IN  IPSFactoryBuffer *  This,
    IN  REFIID              riid,
    IN  IUnknown *          punkServer,
    OUT IRpcStubBuffer **   ppStub
)
/*++

Routine Description:
    Create a stub for the specified interface.

Arguments:

Return Value:

--*/
{
    HRESULT                 hr;
    const ProxyFileInfo *   pProxyFileInfo;
    long                    j;

    BOOL fFound = NdrpFindInterface(((CStdPSFactoryBuffer *)This)->pProxyFileList,
                                    riid,
                                    &pProxyFileInfo,
                                    &j);

    if(fFound != TRUE)
        hr = E_NOINTERFACE;
    else if ( (pProxyFileInfo->TableVersion  &  NDR_PROXY_FILE_ASYNC_UUID)  &&
              (ULONG_PTR)pProxyFileInfo->pAsyncIIDLookup[j] == -1 )
        {
        // An attempt to create a sync stub for an async interface.
        hr = E_NOINTERFACE;
        }
    else
    {
        if((pProxyFileInfo->pDelegatedIIDs != 0) &&
           (pProxyFileInfo->pDelegatedIIDs[j] != 0) &&
           (!IsEqualIID(*pProxyFileInfo->pDelegatedIIDs[j], IID_IUnknown)))
        {
            IUnknown *              punkForward;

            //We need to delegate to the stub for the base interface.
            CStdStubBuffer2 *pStubBuffer =
                (CStdStubBuffer2*)(*pfnCoTaskMemAlloc)(sizeof(CStdStubBuffer2));

            if(0 == pStubBuffer)
                hr = E_OUTOFMEMORY;
            else
            {
                void ** pForwardingVtbl;
                GetTemplateForwardVtbl(&pForwardingVtbl);
                //Initialize the new stub buffer.
                memset(pStubBuffer, 0, sizeof(CStdStubBuffer2));

                pStubBuffer->lpForwardingVtbl = pForwardingVtbl;
                pStubBuffer->lpVtbl = &pProxyFileInfo->pStubVtblList[j]->Vtbl;
                pStubBuffer->RefCount= 1;
                pStubBuffer->pPSFactory = This;
                if ( pProxyFileInfo->TableVersion < 2 )
                    pStubBuffer->pRMBVtbl = NULL;
                else
                    pStubBuffer->pRMBVtbl = &CStdStubBuffer_ReleaseMarshalBuffersVtbl;

                if ( (pProxyFileInfo->TableVersion  &  NDR_PROXY_FILE_ASYNC_UUID)  &&
                     pProxyFileInfo->pAsyncIIDLookup[j] != 0 )
                    {
                    pStubBuffer->pCallFactoryVtbl = &CStdStubBuffer2_CallFactoryVtbl;
                    pStubBuffer->pAsyncIID = pProxyFileInfo->pAsyncIIDLookup[j];
                    pStubBuffer->pRMBVtbl = &CStdAsyncStubBuffer_ReleaseMarshalBuffersVtbl;
                    }

                //Increment the DLL reference count for DllCanUnloadNow.
                This->lpVtbl->AddRef(This);
                *ppStub = (IRpcStubBuffer *) &pStubBuffer->lpVtbl;

                 //Connect the stub to the server object.
                if(punkServer != 0)
                {
                    hr = punkServer->lpVtbl->QueryInterface(
                        punkServer,
                        riid,
                        (void**)&pStubBuffer->pvServerObject);
                }
                else
                {
                    hr = S_OK;
                }

                if(SUCCEEDED(hr))
                {
                    if(punkServer != 0)
                        punkForward = (IUnknown *) &pStubBuffer->lpForwardingVtbl;
                    else
                        punkForward = 0;

                    //Create a stub for the base interface
                    hr = NdrpCreateStub(*pProxyFileInfo->pDelegatedIIDs[j],
                                        punkForward,
                                        &pStubBuffer->pBaseStubBuffer);
                }

                if(FAILED(hr))
                {
                    ReleaseTemplateForwardVtbl(pForwardingVtbl);
                    (*pfnCoTaskMemFree)(pStubBuffer);
                }
            }
        }
        else
        {
            //Create an ordinary stub buffer.
            CStdStubBuffer *pStubBuffer =
                (CStdStubBuffer*)(*pfnCoTaskMemAlloc)(sizeof(CStdStubBuffer));

            if(0 == pStubBuffer)
                hr = E_OUTOFMEMORY;
            else
            {
                //Initialize the new stub buffer.
                memset(pStubBuffer, 0, sizeof(CStdStubBuffer));

                pStubBuffer->lpVtbl = &pProxyFileInfo->pStubVtblList[j]->Vtbl;
                pStubBuffer->RefCount= 1;
                pStubBuffer->pPSFactory = This;

                if ( pProxyFileInfo->TableVersion < 2 )
                    pStubBuffer->pRMBVtbl = NULL;
                else
                    pStubBuffer->pRMBVtbl = &CStdStubBuffer_ReleaseMarshalBuffersVtbl;

                if ( (pProxyFileInfo->TableVersion  &  NDR_PROXY_FILE_ASYNC_UUID)  &&
                     pProxyFileInfo->pAsyncIIDLookup[j] != 0 )
                    {
                    pStubBuffer->pCallFactoryVtbl = &CStdStubBuffer_CallFactoryVtbl;
                    pStubBuffer->pAsyncIID = pProxyFileInfo->pAsyncIIDLookup[j];
                    pStubBuffer->pRMBVtbl = &CStdAsyncStubBuffer_ReleaseMarshalBuffersVtbl;
                    }

                if(0 == punkServer)
                    hr = S_OK;
                else
                {
                    hr = punkServer->lpVtbl->QueryInterface(
                        punkServer,
                        riid,
                        (void**)&pStubBuffer->pvServerObject);
                }

                if(SUCCEEDED(hr))
                {
                    //Increment the DLL reference count for DllCanUnloadNow.
                    This->lpVtbl->AddRef(This);
                    *ppStub = (IRpcStubBuffer *) pStubBuffer;
                }
                else
                {
                    (*pfnCoTaskMemFree)(pStubBuffer);
                }
            }
        }
    }

    if(FAILED(hr))
        *ppStub = 0;

    return hr;
}

HRESULT STDMETHODCALLTYPE
CStdPSFactoryBuffer_HkGetProxyFileInfo
(
    IN  IPSFactoryBuffer    *This,
    IN  REFIID              riid,
    OUT PINT                pOffset,
    OUT PVOID               *ppProxyFileInfo
)

/*++

Routine Description:

    This function returns the proxy information for a particular
    interface.  HookOle requires information such as the number
    of methods in the vtable and a pointer to the
    StublessProxyInfo structure.


Arguments:

    This - This pointer for the proxy object.
    riid - IID of the interface we are asking about.
    pOffset - Offset into the ProxyFileInfo lists for this
        particular interface.
    ppProxyFileInfo - Pointer to location where a pointer to the
        ProxyFileInfo structure can be stored.

Return Value:


--*/
{
    HRESULT         hr=E_NOINTERFACE;
    ProxyFileInfo   *pProxyFileInfo=NULL;

    //
    // Find the index into the FileList for this iid.
    //
    if (NdrpFindInterface(
        ((CStdPSFactoryBuffer *)This)->pProxyFileList,
        riid,
        (const ProxyFileInfo**)&pProxyFileInfo,
        (long*)pOffset)) {

        *ppProxyFileInfo = (PVOID)pProxyFileInfo;
        hr = S_OK;
    }

    return(hr);
}

// initialize mutex, and return error instead of throwing. In OLE world, people 
// expect error code instead of exception.
HRESULT 
NdrpInitializeMutex( I_RPC_MUTEX * pMutex )
{
    RPC_STATUS rc = RPC_S_OK;

    GlobalMutexRequestExternal();
    if ( *pMutex == NULL )
        {
        __try
            {
            I_RpcRequestMutex( pMutex );
            I_RpcClearMutex( *pMutex );
            }
        __except( EXCEPTION_EXECUTE_HANDLER )
            {
            // we want to catch all the exception here in OLE land
            rc = RpcExceptionCode();
            }
        }
    GlobalMutexClearExternal();
    
    return HRESULT_FROM_WIN32( rc );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr20\hndl.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 
Copyright (c) 1993  - 1999 Microsoft Corporation

Module Name :

    hndl.c

Abstract :

    To hold support routines for interpreting handles
    in support of Format Strings.

Author :
    
    Bruce McQuistan (brucemc)

Revision History :

    ryszardk    3/12/94     handle optimization and fixes

  ---------------------------------------------------------------------*/

#include "ndrp.h"
#include "hndl.h"
#include "interp.h"

extern const IID GUID_NULL;

handle_t
GenericHandleMgr(
    PMIDL_STUB_DESC     pStubDesc,
    uchar *             ArgPtr,
    PFORMAT_STRING      pFormat,
    uint                Flags,
    handle_t *          pGenericHandle
    )
/*++

Description :

    Provides a filter for generic binding handle management issues.
    Deals with implicit or explicit generic binding handles calling
    user functions as appropriate.

Arguments :

    pStubDesc - pointer to current StubDescriptor.
    ArgPtr    - pointer to handle.
    pFormat   - pointer to Format string such that *pFormat is a
                handle descriptor.
    Flag      - flag indicating either binding or unbinding.

Returns :     

    Valid binding handle.

*/
{
    uchar                                GHandleSize;
    handle_t                             ReturnHandle = 0;
    BOOL                                 fBinding;
    GENERIC_BINDING_ROUTINE              pBindFunc = 0;
    GENERIC_UNBIND_ROUTINE               pUnBindFunc = 0;
    const GENERIC_BINDING_ROUTINE_PAIR * Table;
    BOOL                                 fIsPtr = FALSE;

    Table = pStubDesc->aGenericBindingRoutinePairs;

    fBinding = (Flags & BINDING_MASK);

    if ( Flags & IMPLICIT_MASK )
        {
        //
        // Implicit generic: All the info is taken from the implicit generic
        // handle info structure accessed via stub descriptor.
        //
        PGENERIC_BINDING_INFO pGenHandleInfo;

        pGenHandleInfo = pStubDesc->IMPLICIT_HANDLE_INFO.pGenericBindingInfo;

        GHandleSize = (uchar) pGenHandleInfo->Size;

        if ( fBinding )
            pBindFunc = pGenHandleInfo->pfnBind;
        else
            pUnBindFunc = pGenHandleInfo->pfnUnbind;
        }
    else
        {
        //
        // Explicit generic: Get index into array of function ptrs and
        // the gen handle size the format string.
        //
        uchar TableIndex = pFormat[4];

        GHandleSize = LOW_NIBBLE(pFormat[1]);

        if ( fBinding )
            pBindFunc = Table[TableIndex].pfnBind;
        else
            pUnBindFunc = Table[TableIndex].pfnUnbind;

        if ( IS_HANDLE_PTR(pFormat[1]) )
            fIsPtr = TRUE;           
        }

    //
    // Call users routine on correctly dereferenced pointer.
    //
    switch (GHandleSize)
        {
        case 1:
            {
            uchar HandlePtr = (uchar)(ULONG_PTR)ArgPtr;
            if ( fIsPtr )
                HandlePtr = * (uchar *)ArgPtr;
                
            if ( fBinding )
                ReturnHandle = 
                    (handle_t)(ULONG_PTR)
                    (*(GENERIC_BIND_FUNC_ARGCHAR)pBindFunc)(
                        (uchar)(ULONG_PTR)HandlePtr );
            else
                (*(GENERIC_UNBIND_FUNC_ARGCHAR)pUnBindFunc)(
                    (uchar)(ULONG_PTR)HandlePtr,
                    *pGenericHandle );
            break;
            }

        case 2:
            {
            ushort HandlePtr = (ushort)(ULONG_PTR)ArgPtr;
            if ( fIsPtr )
                HandlePtr = * (ushort *)ArgPtr;

            if ( fBinding )
                ReturnHandle = 
                    (handle_t)(ULONG_PTR)
                    (*(GENERIC_BIND_FUNC_ARGSHORT)pBindFunc)(
                        (ushort)(ULONG_PTR)HandlePtr );
            else
                (*(GENERIC_UNBIND_FUNC_ARGSHORT)pUnBindFunc)(
                    (ushort)(ULONG_PTR)HandlePtr,
                    *pGenericHandle );
            break;
            }

        case 4:
            {
            ulong HandlePtr = (ulong)(ULONG_PTR)ArgPtr;
            if ( fIsPtr )
                HandlePtr = * (ulong *)ArgPtr;
        
            if ( fBinding )
                ReturnHandle = 
                    (handle_t)(ULONG_PTR)
                    (*(GENERIC_BIND_FUNC_ARGLONG)pBindFunc)(
                        (ulong)(ULONG_PTR)HandlePtr );
            else
                (*(GENERIC_UNBIND_FUNC_ARGLONG)pUnBindFunc)(
                    (ulong)(ULONG_PTR)HandlePtr,
                    *pGenericHandle );
            break;
            }
#if defined(__RPC_WIN64__)
        case 8:
            {
            ULONG_PTR HandlePtr = (ULONG_PTR)ArgPtr;
            if ( fIsPtr )
                HandlePtr = * (ULONG_PTR *)ArgPtr;
        
            if ( fBinding )
                ReturnHandle = 
                    (handle_t)(ULONG_PTR)
                    (*(GENERIC_BIND_FUNC_ARGINT64)pBindFunc)(
                        (ULONG_PTR)HandlePtr );
            else
                (*(GENERIC_UNBIND_FUNC_ARGINT64)pUnBindFunc)(
                    (ULONG_PTR)HandlePtr,
                    *pGenericHandle );
            break;
            }
#endif

        default:
            NDR_ASSERT(0,"GenericHandleMgr : Handle size too big");
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            return 0;
        }

    if ( fBinding )
        {
        *pGenericHandle = ReturnHandle;
        if ( ReturnHandle == NULL )
            RpcRaiseException( RPC_S_INVALID_BINDING );
        }
    else
        *pGenericHandle = NULL;

    return ReturnHandle;
}


void
GenericHandleUnbind(
    PMIDL_STUB_DESC     pStubDesc,
    uchar *             ArgPtr,
    PFORMAT_STRING      pFormat,
    uint                Flags,
    handle_t *          pGenericHandle
    )
/*++

Description :

    Unbinds a generic handle: checks if it is implicit or explicit,
    gets the handle and calls GenericHandleMgr.

Arguments :

    pStubDesc - pointer to current StubDescriptor.
    ArgPtr    - pointer to beginning of the stack.
    pFormat   - pointer to Format string such that *pFormat is a
                  handle descriptor.
    Flag      - flag indicating implicit vs. explicit.

 --*/
{
    if ( Flags & IMPLICIT_MASK )
        {
        PGENERIC_BINDING_INFO BindInfo;

        BindInfo = pStubDesc->IMPLICIT_HANDLE_INFO.pGenericBindingInfo;

        NDR_ASSERT( BindInfo != 0, "GenericHandleUnbind : null bind info" );

        ArgPtr = (uchar *) BindInfo->pObj;
        }
    else
        {
        ArgPtr += *(ushort *)(pFormat + 2);

        ArgPtr = *(uchar **)ArgPtr;

        }

    (void) GenericHandleMgr( pStubDesc,
                             ArgPtr,
                             pFormat,
                             Flags,
                             pGenericHandle );
}


handle_t
ImplicitBindHandleMgr(
    PMIDL_STUB_DESC pStubDesc,
    uchar           HandleType,
    handle_t *      pSavedGenericHandle
    )
/*++

Description :

    Provides a filter for implicit handle management issues. Deals
    with binding handles (generic, primitive or auto), extracting
    a valid handle from pStubDesc.

Arguments :

    pStubDesc  - pointer to current StubDescriptor.
    HandleType - handle format code.

Return :     
    
    Valid handle.

--*/
{
    handle_t                ReturnHandle;
    PGENERIC_BINDING_INFO   pBindInfo;

    switch ( HandleType )
        {
        case FC_BIND_PRIMITIVE :
            ReturnHandle = *(pStubDesc->IMPLICIT_HANDLE_INFO.pPrimitiveHandle);
            break;

        case FC_BIND_GENERIC :
            pBindInfo = pStubDesc->IMPLICIT_HANDLE_INFO.pGenericBindingInfo;

            NDR_ASSERT( pBindInfo != 0, 
                        "ImplicitBindHandleMgr : no generic bind info" );

            ReturnHandle = GenericHandleMgr( pStubDesc,
                                             (uchar *)pBindInfo->pObj,
                                             &HandleType,
                                             BINDING_MASK | IMPLICIT_MASK,
                                             pSavedGenericHandle );
            break;

        case FC_AUTO_HANDLE :
            ReturnHandle = *(pStubDesc->IMPLICIT_HANDLE_INFO.pAutoHandle);
            break;

        case FC_CALLBACK_HANDLE :
            ReturnHandle = GET_CURRENT_CALL_HANDLE();
            break;

        default :
            NDR_ASSERT(0, "ImplicitBindHandleMgr : bad handle type");
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            return 0;
        }

    return ReturnHandle;
}


handle_t
ExplicitBindHandleMgr(
    PMIDL_STUB_DESC pStubDesc,
    uchar *         ArgPtr,
    PFORMAT_STRING  pFormat,
    handle_t *      pSavedGenericHandle
    )
/*

Description :

    Provides a filter for explicit binding handle management issues.
    Deals with binding handles (primitive, generic or context), calling
    either no routine, NDR routines or user functions as appropriate.

    To be called in the following cases:
    1) if handle is explicit.
        a) before calling I_RpcGetBuffer (to bind).
        b) after unmarshalling (to unbind).

Arguments :

    pStubDesc - pointer to current StubDescriptor.
    ArgPtr    - Pointer to start of stack
    pFormat   - pointer to Format string such that *pFormat is a
                  handle descriptor.

Return :     

    Valid binding handle.

*/
{
    handle_t    ReturnHandle;

    //
    // We need to manage Explicit and Implicit handles.
    // Implicit handles are managed with info accessed via the StubMessage.
    // Explicit handles have their information stored in the format string.
    // We manage explicit handles for binding here.
    //

    //
    // Get location in stack of handle referent.
    //
    ArgPtr += *((ushort *)(pFormat + 2));

    ArgPtr = *(uchar **)ArgPtr;

    //
    // At this point ArgPtr is an address of the handle.
    //
    switch ( *pFormat )
        {
        case FC_BIND_PRIMITIVE :
            if ( IS_HANDLE_PTR(pFormat[1]) )
                ArgPtr = *(uchar **)ArgPtr;
            ReturnHandle = (handle_t)(ULONG_PTR)ArgPtr;
            break;

        case FC_BIND_GENERIC :
            ReturnHandle = GenericHandleMgr( pStubDesc,
                                             ArgPtr,
                                             pFormat,
                                             BINDING_MASK,
                                             pSavedGenericHandle );
            break;
    
        case FC_BIND_CONTEXT :
            if ( IS_HANDLE_PTR(pFormat[1]) )
                ArgPtr = *(uchar **)ArgPtr;

            if ( (!(ArgPtr)) && (!IS_HANDLE_OUT(pFormat[1])) )
                 RpcRaiseException( RPC_X_SS_IN_NULL_CONTEXT );

            ReturnHandle = 0;    // covers NULL case below.

            if ( ArgPtr && ! 
                 (ReturnHandle = NDRCContextBinding((NDR_CCONTEXT)ArgPtr)) )
                 RpcRaiseException( RPC_X_SS_CONTEXT_MISMATCH );

            break;

        default :
            NDR_ASSERT( 0, "ExplictBindHandleMgr : bad handle type" );
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            return 0;
        }

    return ReturnHandle;
}


unsigned char * RPC_ENTRY
NdrMarshallHandle(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pArg,
    PFORMAT_STRING      pFormat
    )
/*++

Routine description :

    Marshalls a context handle.

Arguments :
    
    pStubMsg    - Pointer to stub message.
    pArg        - Context handle to marshall (NDR_CCONTEXT or NDR_SCONTEXT).
    pFormat     - Context handle's format string description.

Return :

    Buffer pointer after marshalling the context handle.

--*/
{
    long    Index;

    NDR_ASSERT( *pFormat == FC_BIND_CONTEXT, 
                "NdrMarshallHandle : Expected a context handle" );


    if ( pStubMsg->IsClient )
        {
        NDR_CCONTEXT Context;

        ALIGN( pStubMsg->Buffer, 0x3 );

        //
        // Get the context handle.
        //
        Context = IS_HANDLE_PTR(pFormat[1]) ? 
                        *((NDR_CCONTEXT *)pArg) : (NDR_CCONTEXT)pArg;

        //
        // An [in] only context handle must be non-zero.
        //
        if ( ! Context && ! IS_HANDLE_OUT(pFormat[1]) )
            RpcRaiseException( RPC_X_SS_IN_NULL_CONTEXT );

        NDRCContextMarshall( Context, (void *) pStubMsg->Buffer );

        pStubMsg->Buffer += CONTEXT_HANDLE_WIRE_SIZE;

        }
    else    
        {
 
        //
        // The NT 3.5 Interpreter used the stub message to keep track of
        // parameter number, newer Interpreters have the param number in the 
        // context handle's description.
        //
        if ( pStubMsg->StubDesc->Version == NDR_VERSION_1_1 )
            {
            Index = pStubMsg->ParamNumber;
            }
        else
            {
            Index = (long) pFormat[3];

            if ( IS_HANDLE_RETURN(pFormat[1]) )
                {
                NDR_SCONTEXT    SContext;

                //
                // Initialize the context handle.
                //
                SContext = NdrContextHandleInitialize ( pStubMsg,
                                                        pFormat );

                //
                // Put the user context that was returned into the context
                // handle.
                //
                *((uchar **)NDRSContextValue(SContext)) = pArg;

                pStubMsg->SavedContextHandles[Index] = SContext;
                }
            }
        // If the new value is NULL, after marshalling, runtime will deallocate the buffer
        // We need to zero out the saved context to avoid referencing garbage.
        NDR_SCONTEXT pContext = pStubMsg->SavedContextHandles[Index];
        pStubMsg->SavedContextHandles[Index] = (NDR_SCONTEXT) CONTEXT_HANDLE_BEFORE_MARSHAL_MARKER;
        
        NdrServerContextNewMarshall( pStubMsg,
                                     pContext,
                                     pStubMsg->StubDesc->apfnNdrRundownRoutines[pFormat[2]],
                                     pFormat );

        pStubMsg->SavedContextHandles[Index] = (NDR_SCONTEXT)CONTEXT_HANDLE_AFTER_MARSHAL_MARKER;
        }


    return 0;
}

unsigned char * RPC_ENTRY
NdrUnmarshallHandle(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppArg,
    PFORMAT_STRING      pFormat,
    uchar		        fIgnored
    )
/*++

Routine description :

    Unmarshall a context handle.

Arguments :
    
    pStubMsg    - Pointer to stub message.
    ppArg       - Pointer to the context handle on the client/server stack.
                  On the client this is a NDR_CCONTEXT *.  On the server
                  side this is a NDR_SCONTEXT (regardless of direction).
    pFormat     - Context handle's format string description.
    fIgnored    - Ignored, but needed to match necessary routine prototype.

Return :

    Buffer pointer after unmarshalling the context handle.

--*/
{
    NDR_ASSERT( *pFormat == FC_BIND_CONTEXT, 
                "NdrUnmarshallHHandle : Expected a context handle" );

    if ( pStubMsg->IsClient )
        {

        ALIGN( pStubMsg->Buffer, 0x3 );

        //
        // Check if we have a pointer to a context handle
        // (the pointer can't be null).
        //
        if ( IS_HANDLE_PTR(pFormat[1]) )
            {
            ppArg = (uchar **) *ppArg;
            }

        //
        // Zero an [out] only context handle before unmarshalling.
        //
        if ( ! IS_HANDLE_IN(pFormat[1]) )
            *ppArg = 0;

        //
        // We must use the original binding handle in this call.   
        //
        NDRCContextUnmarshall( (NDR_CCONTEXT *)ppArg,
                               pStubMsg->SavedHandle,
                               (void *)pStubMsg->Buffer,
                               pStubMsg->RpcMsg->DataRepresentation );

        pStubMsg->Buffer += CONTEXT_HANDLE_WIRE_SIZE;

        }
    else
        {

        NDR_SCONTEXT    SContext;

        SContext = NdrServerContextNewUnmarshall( pStubMsg,
                                                  pFormat );

        NdrSaveContextHandle( pStubMsg, 
                              SContext, 
                              ppArg, 
                              pFormat );
        }

    return 0;
}


void 
NdrSaveContextHandle (
    PMIDL_STUB_MESSAGE  pStubMsg,
    NDR_SCONTEXT        CtxtHandle,
    uchar **            ppArg,
    PFORMAT_STRING      pFormat )
/*++

Routine Description : 

    Saves a context handle's current value and then extracts the user's
    context value.

Arguments :

    pStubMsg    - The stub message.
    CtxtHandle  - The context handle.
    ppArg       - Pointer to where user's context value should go.

Return : 

    None.

*/
{
    long    Index;

    //
    // The NT 3.5 Interpreter used the stub message to keep track of
    // parameter number, newer Interpreters have the param number in the 
    // context handle's description.
    //
    if ( pStubMsg->StubDesc->Version == NDR_VERSION_1_1 )
        Index = pStubMsg->ParamNumber;
    else
        Index = (long) pFormat[3];

    pStubMsg->SavedContextHandles[Index] = CtxtHandle;

    // On 32b alphas, a handle pointer needs to be properly sign extended
    // to a 64b virtual stack value, as this will become the register value.
    // So, we cast to the REGISTER_TYPE to get the sign extension

    if ( ! IS_HANDLE_PTR(pFormat[1]) )
        *((REGISTER_TYPE*)ppArg) = (REGISTER_TYPE) *(NDRSContextValue(CtxtHandle));
    else
        *((REGISTER_TYPE*)ppArg) = (REGISTER_TYPE) NDRSContextValue(CtxtHandle);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr20\global.cxx ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright <c> 1993 Microsoft Corporation

Module Name :

    global.c

Abtract :

    Contains some global variable declarations for the NDR library.

Author :

    David Kays  dkays   October 1993

Revision History :

--------------------------------------------------------------------*/

#include "ndrp.h"

//
// Simple type buffer alignment masks.
//
extern const unsigned char SimpleTypeAlignment[] =
				{
    			0, 		// FC_ZERO

    			0, 		// FC_BYTE
    			0, 		// FC_CHAR
    			0, 		// FC_SMALL
    			0, 		// FC_USMALL

    			1, 		// FC_WCHAR
    			1, 		// FC_SHORT
    			1, 		// FC_USHORT

    			3, 		// FC_LONG
    			3, 		// FC_ULONG
    			3, 		// FC_FLOAT

    			7, 		// FC_HYPER
    			7, 		// FC_DOUBLE

				1, 		// FC_ENUM16
				3, 		// FC_ENUM32
				3, 		// FC_IGNORE
				3, 		// FC_ERROR_STATUS_T

                  0,0,0, 0,0,0,0,  0,0,0,0, 0,0,0,0,  // 0x11 .. 1f
                0,0,0,0, 0,0,0,0,  0,0,0,0, 0,0,0,0,  // 0x20 .. 2f
                0,0,0,0, 0,0,0,0,  0,0,0,0, 0,0,0,0,  // 0x30 .. 3f
                0,0,0,0, 0,0,0,0,  0,0,0,0, 0,0,0,0,  // 0x40 .. 4f
                0,0,0,0, 0,0,0,0,  0,0,0,0, 0,0,0,0,  // 0x50 .. 5f
                0,0,0,0, 0,0,0,0,  0,0,0,0, 0,0,0,0,  // 0x60 .. 6f
                0,0,0,0, 0,0,0,0,  0,0,0,0, 0,0,0,0,  // 0x70 .. 7f
                0,0,0,0, 0,0,0,0,  0,0,0,0, 0,0,0,0,  // 0x80 .. 8f
                0,0,0,0, 0,0,0,0,  0,0,0,0, 0,0,0,0,  // 0x90 .. 9f
                0,0,0,0, 0,0,0,0,  0,0,0,0, 0,0,0,0,  // 0xa0 .. af
                0,0,0,0, 0,0,0,0,                     // 0xb0 .. b7

                3,      // FC_INT3264
                3,      // FC_UINT3264
                
                0,      // 0xbb (FC_CSARRAY)
                3,      // 0xbc (FC_CS_TAG)
				};

#if !defined(NDR_GLOBAL_TABLES_ONLY)

RPCRTAPI
unsigned char 
RPC_ENTRY
NdrGetSimpleTypeBufferAlignment( unsigned char FormatChar )
{
     return SimpleTypeAlignment[FormatChar];
} 

#endif

//
// Simple type buffer sizes.
//
extern const unsigned char SimpleTypeBufferSize[] =
				{
    			0, 		// FC_ZERO

    			1, 		// FC_BYTE
    			1, 		// FC_CHAR
    			1, 		// FC_SMALL
    			1, 		// FC_USMALL

    			2, 		// FC_WCHAR
    			2, 		// FC_SHORT
    			2, 		// FC_USHORT

    			4, 		// FC_LONG
    			4, 		// FC_ULONG
    			4, 		// FC_FLOAT

    			8, 		// FC_HYPER
    			8, 		// FC_DOUBLE

				2, 		// FC_ENUM16
				4, 		// FC_ENUM32
				4, 		// FC_IGNORE
				4, 		// FC_ERROR_STATUS_T

                  0,0,0, 0,0,0,0,  0,0,0,0, 0,0,0,0,  // 0x11 .. 1f
                0,0,0,0, 0,0,0,0,  0,0,0,0, 0,0,0,0,  // 0x20 .. 2f
                0,0,0,0, 0,0,0,0,  0,0,0,0, 0,0,0,0,  // 0x30 .. 3f
                0,0,0,0, 0,0,0,0,  0,0,0,0, 0,0,0,0,  // 0x40 .. 4f
                0,0,0,0, 0,0,0,0,  0,0,0,0, 0,0,0,0,  // 0x50 .. 5f
                0,0,0,0, 0,0,0,0,  0,0,0,0, 0,0,0,0,  // 0x60 .. 6f
                0,0,0,0, 0,0,0,0,  0,0,0,0, 0,0,0,0,  // 0x70 .. 7f
                0,0,0,0, 0,0,0,0,  0,0,0,0, 0,0,0,0,  // 0x80 .. 8f
                0,0,0,0, 0,0,0,0,  0,0,0,0, 0,0,0,0,  // 0x90 .. 9f
                0,0,0,0, 0,0,0,0,  0,0,0,0, 0,0,0,0,  // 0xa0 .. af
                0,0,0,0, 0,0,0,0,                     // 0xb0 .. b7

                4,      // FC_INT3264
                4,      // FC_UINT3264

                0,      // 0xbb (FC_CSARRAY)
                4       // 0xbc (FC_CS_TAG)
				};

#if !defined(NDR_GLOBAL_TABLES_ONLY)

RPCRTAPI
unsigned char 
RPC_ENTRY
NdrGetSimpleTypeBufferSize( unsigned char FormatChar )
{
    return SimpleTypeBufferSize[FormatChar];
}

#endif

//
// Simple type memory sizes.
//
extern const unsigned char SimpleTypeMemorySize[] =
				{
    			0, 		// FC_ZERO

    			1, 		// FC_BYTE
    			1, 		// FC_CHAR
    			1, 		// FC_SMALL
    			1, 		// FC_USMALL

    			2, 		// FC_WCHAR
    			2, 		// FC_SHORT
    			2, 		// FC_USHORT

    			4, 		// FC_LONG
    			4, 		// FC_ULONG
    			4, 		// FC_FLOAT

    			8, 		// FC_HYPER
    			8, 		// FC_DOUBLE

				sizeof(int), 		// FC_ENUM16
				sizeof(int), 		// FC_ENUM32
				PTR_MEM_SIZE, 	    // FC_IGNORE
				4, 					// FC_ERROR_STATUS_T

                  0,0,0, 0,0,0,0,  0,0,0,0, 0,0,0,0,  // 0x11 .. 1f
                0,0,0,0, 0,0,0,0,  0,0,0,0, 0,0,0,0,  // 0x20 .. 2f
                0,0,0,0, 0,0,0,0,  0,0,0,0, 0,0,0,0,  // 0x30 .. 3f
                0,0,0,0, 0,0,0,0,  0,0,0,0, 0,0,0,0,  // 0x40 .. 4f
                0,0,0,0, 0,0,0,0,  0,0,0,0, 0,0,0,0,  // 0x50 .. 5f
                0,0,0,0, 0,0,0,0,  0,0,0,0, 0,0,0,0,  // 0x60 .. 6f
                0,0,0,0, 0,0,0,0,  0,0,0,0, 0,0,0,0,  // 0x70 .. 7f
                0,0,0,0, 0,0,0,0,  0,0,0,0, 0,0,0,0,  // 0x80 .. 8f
                0,0,0,0, 0,0,0,0,  0,0,0,0, 0,0,0,0,  // 0x90 .. 9f
                0,0,0,0, 0,0,0,0,  0,0,0,0, 0,0,0,0,  // 0xa0 .. af
                0,0,0,0, 0,0,0,0,                     // 0xb0 .. b7

                PTR_MEM_SIZE,      // FC_INT3264 : 4 for 32b, 8 for 64b
                PTR_MEM_SIZE,      // FC_UINT3264: 4 for 32b, 8 for 64b

                0,      // 0xbb (FC_CSARRAY)
                4       // 0xbc (FC_CS_TAG)
				};

#if !defined(NDR_GLOBAL_TABLES_ONLY)

RPCRTAPI
unsigned char 
RPC_ENTRY
NdrGetSimpleTypeMemorySize( unsigned char FormatChar )
{
   return SimpleTypeMemorySize[ FormatChar ];
}

#endif

//
// Contains information about individual ndr types defined in ndrtypes.h.
// Currently is used only by the interpreter.  A set entry indicates that
// the type is a by-value type.  This may be expanded in the future to 
// contain additional attributes.
//
extern const unsigned long NdrTypeFlags[] =
    {
    0,        

    //
    // Simple types
    //
    _SIMPLE_TYPE_,        
    _SIMPLE_TYPE_,
    _SIMPLE_TYPE_,
    _SIMPLE_TYPE_,
    _SIMPLE_TYPE_,
    _SIMPLE_TYPE_,
    _SIMPLE_TYPE_,
    _SIMPLE_TYPE_,
    _SIMPLE_TYPE_,
    _SIMPLE_TYPE_,
    _SIMPLE_TYPE_,
    _SIMPLE_TYPE_,
    _SIMPLE_TYPE_,
    _SIMPLE_TYPE_,
    _SIMPLE_TYPE_,
    _SIMPLE_TYPE_,

    //
    // Pointer types
    //
    _BASIC_POINTER_ | _POINTER_,        
    _BASIC_POINTER_ | _POINTER_,
    _BASIC_POINTER_ | _POINTER_,
    _BASIC_POINTER_ | _POINTER_,

    //
    // Structures
    //
    _STRUCT_ | _BY_VALUE_,        
    _STRUCT_ | _BY_VALUE_,
    _STRUCT_ | _BY_VALUE_,
    _STRUCT_ | _BY_VALUE_,
    _STRUCT_ | _BY_VALUE_,
    _STRUCT_ | _BY_VALUE_,

    //
    // Arrays
    //
    _ARRAY_,        
    _ARRAY_,
    _ARRAY_,
    _ARRAY_,
    _ARRAY_,
    _ARRAY_,
    _ARRAY_,

    //
    // Conformant Strings
    //
    _STRING_,        
    _STRING_,
    _STRING_,
    _STRING_,

    //
    // Non-conformant String.
    //
    _STRING_,        
    _STRING_,
    _STRING_,
    _STRING_,

    // Encapsulated Union
    _UNION_ | _BY_VALUE_,        

    // Non-encapsulated Union
    _UNION_ | _BY_VALUE_,        

    // Byte count pointer (does NOT get _POINTER_ attribute)
    0,        

    // Transmit as
    _XMIT_AS_ | _BY_VALUE_,        

    // Represent as
    _XMIT_AS_ | _BY_VALUE_,        

    // Interface pointer 
    _POINTER_,        

    // Handles (only explicit handles get the _HANDLE_ attribute)
    _HANDLE_,        
    _HANDLE_,
    _HANDLE_,
    0,
    0,
    0,

    // ** Unused section ***
    0,

    0,
    0,
    0,
    0,
    0,
    0,

    0,
    0,
    0,
    0,
    0,
    0,
    0,

    0,
    0,

    0,
    0,
    0,
    0,
    0,

    0,

    0,

    0,
    0,
    0,
    0,
    0,
    0,
    0,

    0,
    0,
    0,
    0,
    0,
    0,

    0,

    0,        // FC_END
    0,        // FC_PAD
    // ** Unused section end ***

    // ** Gap before new format string types ** 
    0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
    0,
    // ** Gap before new format string types end **

    // 
    // Post NT 3.5 format characters.
    //

    // Hard struct
    _STRUCT_ | _BY_VALUE_,

    // Transmit_as and Represent_as via poiner

    _XMIT_AS_ | _BY_VALUE_,        
    _XMIT_AS_ | _BY_VALUE_,        

    // User_marshal

    _XMIT_AS_ | _BY_VALUE_,

    0,  // FC_PIPE
    0,  // FC_BLKHOLE

    0,  // RANGE

    _SIMPLE_TYPE_,   // FC_INT3264
    _SIMPLE_TYPE_,   // FC_UINT3264

    0,  // FC_CSARRAY
    0   // FC_CS_TAG
    };

#if !defined(NDR_GLOBAL_TABLES_ONLY)

RPCRTAPI
unsigned long 
RPC_ENTRY
NdrGetTypeFlags( unsigned char FormatChar )
{
    return NdrTypeFlags[ FormatChar ];
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr20\iid.cxx ===
// Copyright (c) 1993-1999 Microsoft Corporation

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;


extern "C"
{

extern const IID IID_IPSFactoryHook = {0x2f5c0480, 0x6bc0, 0x11cf, {0x89, 0xb9, 0x0, 0xaa, 0x0, 0x57, 0xb1, 0x49}};

extern const IID IID_IDispatch = {0x00020400,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};

extern const IID IID_IStream = {0x0000000c,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};

extern const IID IID_IUnknown      = {0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};
extern const IID IID_IClassFactory = {0x00000001,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};

extern const IID IID_IRpcChannelBuffer  = {0xD5F56B60,0x593B,0x101A,{0xB5,0x69,0x08,0x00,0x2B,0x2D,0xBF,0x7A}};
extern const IID IID_IRpcChannelBuffer2 = {0x594f31d0,0x7f19,0x11d0,{0xb1,0x94,0x00,0xa0,0xc9,0x0d,0xc8,0xbf}};
extern const IID IID_IRpcChannelBuffer3 = {0x25B15600,0x0115,0x11d0,{0xBF,0x0D,0x00,0xAA,0x00,0xB8,0xDF,0xD2}};
extern const IID IID_IAsyncRpcChannelBuffer = {0xa5029fb6,0x3c34,0x11d1,{0x9c,0x99,0x00,0xc0,0x4f,0xb9,0x98,0xaa}};
                                     
extern const IID IID_IRpcProxyBuffer = {0xD5F56A34,0x593B,0x101A,{0xB5,0x69,0x08,0x00,0x2B,0x2D,0xBF,0x7A}};
extern const IID IID_IRpcStubBuffer  = {0xD5F56AFC,0x593B,0x101A,{0xB5,0x69,0x08,0x00,0x2B,0x2D,0xBF,0x7A}};

extern const IID IID_IPSFactoryBuffer = {0xD5F569D0,0x593B,0x101A,{0xB5,0x69,0x08,0x00,0x2B,0x2D,0xBF,0x7A}};

extern const IID GUID_NULL = {0x0,0x0,0x0,{0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0}};

extern const IID IID_ISynchronize  = {0x00000030,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};
extern const IID IID_ICallFactory  = {0x1c733a30,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};

extern const IID IID_ITypeFactory = {0x0000002E,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};
extern const IID IID_ITypeMarshal = {0x0000002D,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};

extern const IID IID_IMarshal = {0x00000003,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};

extern const IID IID_IRpcHelper  = {0x00000149,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};
extern const IID CLSID_RpcHelper = {0x0000032a,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};

extern const IID IID_IReleaseMarshalBuffers = {0xeb0cb9e8,0x7996,0x11d2,{0x87,0x2e,0x00,0x00,0xf8,0x08,0x08,0x59}};

extern const IID IID_IRpcSyntaxNegotiate = {0x58a08519,0x24c8,0x4935,{0xb4,0x82,0x3f,0xd8,0x23,0x33,0x3a,0x4f}};

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr20\fullptr.h ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1993 Microsoft Corporation

Module Name :

    fullptr.h

Abstract :

    This file contains private definitions for the NDR full pointer package.

Author :

    David Kays  dkays   January 1994.

Revision History :

  ---------------------------------------------------------------------*/

#ifndef _FULLPTR_
#define _FULLPTR_

#define FULL_POINTER_MARSHALLED     0x01
#define FULL_POINTER_UNMARSHALLED   0x02 
#define FULL_POINTER_BUF_SIZED      0x04
#define FULL_POINTER_MEM_SIZED      0x08
#define FULL_POINTER_CONVERTED      0x10
#define FULL_POINTER_FREED          0x20
#define FULL_POINTER_RMBED          0x40

#define CHECK_FULL_POINTER_STATE( State, StateType ) \
				( (State) & (StateType) )

#define SET_FULL_POINTER_STATE( State, StateType ) \
				( (State) |= (StateType) )

#define	DEFAULT_REF_ID_TO_POINTER_TABLE_ELEMENTS	512
#define	DEFAULT_POINTER_TO_REF_ID_TABLE_BUCKETS		512

#define	PTR_HASH( Pointer, HashMask )	\
				(ulong)( ((LONG_PTR)(Pointer) >> 3) & (HashMask) )

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr20\hndl.h ===
/************************************************************************

Copyright (c) 1993 Microsoft Corporation

Module Name :

    hndl.h

Abstract :

    To hold prototypes of support routines for interpreting handles in 
    support of Format Strings.

Author :

    Bruce McQuistan (brucemc)

Revision History :

  ***********************************************************************/

#ifndef __HNDL_H__
#define __HNDL_H__

//
// The following is to be used in as masks for flags passed in these
// routines.
//
#define     MARSHALL_MASK           0x2
#define     IMPLICIT_MASK           0x4
#define     BINDING_MASK            0x8

//
// Next, a macro for getting the current call handle. On dos,win16, it'll
// never be called.
//
#define GET_CURRENT_CALL_HANDLE()   I_RpcGetCurrentCallHandle()

//
// Some typedefs to keep the front end of the C compiler happy and possibly to
// improve code generation.
//
typedef void *  (__RPC_API * GENERIC_BIND_FUNC_ARGCHAR)(uchar);
typedef void *  (__RPC_API * GENERIC_BIND_FUNC_ARGSHORT)(ushort);
typedef void *  (__RPC_API * GENERIC_BIND_FUNC_ARGLONG)(ulong);

typedef void    (__RPC_API * GENERIC_UNBIND_FUNC_ARGCHAR)(uchar, handle_t);
typedef void    (__RPC_API * GENERIC_UNBIND_FUNC_ARGSHORT)(ushort, handle_t);
typedef void    (__RPC_API * GENERIC_UNBIND_FUNC_ARGLONG)(ulong, handle_t);

#if defined(__RPC_WIN64__)
typedef void *  (__RPC_API * GENERIC_BIND_FUNC_ARGINT64)(uint64);
typedef void    (__RPC_API * GENERIC_UNBIND_FUNC_ARGINT64)(uint64, handle_t);
#endif

handle_t
GenericHandleMgr(
    PMIDL_STUB_DESC         pStubDesc,
    uchar *                 ArgPtr,
    PFORMAT_STRING          FmtString,
    uint                    Flags,
    handle_t *              pSavedGenericHandle
    );

void
GenericHandleUnbind(
    PMIDL_STUB_DESC         pStubDesc,
    uchar *                 ArgPtr,
    PFORMAT_STRING          FmtString,
    uint                    Flags,
    handle_t *              pSavedGenericHandle
    );

handle_t
ExplicitBindHandleMgr(
    PMIDL_STUB_DESC         pStubDesc,
    uchar *                 ArgPtr,
    PFORMAT_STRING          FmtString,
    handle_t *              pSavedGenericHandle
    );

handle_t
ImplicitBindHandleMgr(
    PMIDL_STUB_DESC         pStubDesc,
    uchar                   HandleType,
    handle_t *              pSavedGenericHandle
    );

unsigned char * RPC_ENTRY
NdrMarshallHandle(
    PMIDL_STUB_MESSAGE      pStubMsg,
    uchar *                 pArg,
    PFORMAT_STRING          FmtString
    );

unsigned char * RPC_ENTRY
NdrUnmarshallHandle(
    PMIDL_STUB_MESSAGE      pStubMsg,
    uchar **                ppArg,
    PFORMAT_STRING          FmtString,
	uchar				    fIgnored
    );

void
NdrSaveContextHandle (
    PMIDL_STUB_MESSAGE      pStubMsg,
    NDR_SCONTEXT            CtxtHandle,
    uchar **                ppArg,
    PFORMAT_STRING          pFormat
    );

void
NdrContextHandleQueueFree(
    PMIDL_STUB_MESSAGE      pStubMsg,
    void *                  FixedArray
    );

#endif __HNDL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr20\interp2.h ===
/************************************************************************

Copyright (c) 1993 - 1999 Microsoft Corporation

Module Name :

    newintrp.h

Abstract :

    Definitions for the new client and server stub interpreter.

Author :

    DKays       December 1994

Revision History :

  ***********************************************************************/

#ifndef _NEWINTRP_
#define _NEWINTRP_

#include "interp.h"

extern "C"
{
void
NdrClientZeroOut(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat,
    uchar *             pArg
    );

void
NdrClientMapCommFault(
    PMIDL_STUB_MESSAGE  pStubMsg,
    long                ProcNum,
    RPC_STATUS          ExceptionCode,
    ULONG_PTR *          pReturnValue
    );

void
NdrpFreeParams(
    MIDL_STUB_MESSAGE       * pStubMsg,
    long                    NumberParams,
    PPARAM_DESCRIPTION      Params,
    uchar *                 pArgBuffer
    );

void
Ndr64ClientZeroOut(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PNDR64_FORMAT       pFormat,
    uchar *             pArg
    );


void
Ndr64pFreeParams(
    MIDL_STUB_MESSAGE       *           pStubMsg,
    long                                NumberParams,
    NDR64_PARAM_FORMAT      *           Params,
    uchar *                             pArgBuffer
    );


REGISTER_TYPE
Invoke(
    MANAGER_FUNCTION pFunction,
    REGISTER_TYPE *  pArgumentList,
#if defined(_WIN64)
    ulong            FloatArgMask,
#endif
    ulong            cArguments);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr20\interp.h ===
/************************************************************************

Copyright (c) 1993 Microsoft Corporation

Module Name :

    interp.h

Abstract :

    Definitions for the client and server stub interpreter.  Compiled from
    previous files srvcall.h, srvoutp.h, and getargs.h.

Author :

    DKays       October 1994

Revision History :

  ***********************************************************************/

#ifndef _INTERP_
#define _INTERP_

//
// Stack and argument defines.
//

#if defined(_IA64_) || defined(_AMD64_)
#define REGISTER_TYPE               _int64
#else
#define REGISTER_TYPE               int
#endif

#define RETURN_SIZE                 8

//
// Define interpreter limitations.
//

#define ARGUMENT_COUNT_THRESHOLD    16

#define MAX_STACK_SIZE              ARGUMENT_COUNT_THRESHOLD * sizeof(double)

//
// The maximum number of context handles parameters in a procedure that we
// can handle.
//

#define MAX_CONTEXT_HNDL_NUMBER     8

//
// Argument caching data structures.
//

#define QUEUE_LENGTH                ARGUMENT_COUNT_THRESHOLD

typedef struct _ARG_QUEUE_INFO
    {
    PFORMAT_STRING  pFormat;

    uchar *         pArg;
    uchar **        ppArg;

    short           ParamNum;

    short           IsReturn            : 1;
    short           IsBasetype          : 1;
    short           IsIn                : 1;
    short           IsOut               : 1;
    short           IsOutOnly           : 1;

    short           IsDeferredFree      : 1;

    short           IsDontCallFreeInst  : 1;
    } ARG_QUEUE_ELEM, *PARG_QUEUE_ELEM;

typedef struct _ARG_QUEUE
    {
    long                Length;
    ARG_QUEUE_ELEM *    Queue;
    } ARG_QUEUE, *PARG_QUEUE;

//
// Argument retrieval macros.
//

#define INIT_ARG(argptr,arg0)   va_start(argptr, arg0)

//
// Both MIPS and x86 are 4 byte aligned stacks, with MIPS supporting 8byte
// alignment on the stack as well. Their va_list is essentially an
// unsigned char *.
//

#if     defined(_IA64_)
#define GET_FIRST_IN_ARG(argptr)
#define GET_FIRST_OUT_ARG(argptr)
#elif   defined(_AMD64_)
#define GET_FIRST_IN_ARG(argptr)
#define GET_FIRST_OUT_ARG(argptr)
#else
#define GET_FIRST_IN_ARG(argptr)            argptr = *(va_list *)argptr
#define GET_FIRST_OUT_ARG(argptr)           argptr = *(va_list *)argptr
#endif

#define GET_NEXT_C_ARG(argptr,type)         va_arg(argptr,type)

#define SKIP_STRUCT_ON_STACK(ArgPtr, Size)	ArgPtr += Size

#define GET_STACK_START(ArgPtr)			    ArgPtr
#define GET_STACK_POINTER(ArgPtr, mode)		ArgPtr

//
// Use the following macro _after_ argptr has been saved or processed
//
#define SKIP_PROCESSED_ARG(argptr, type) \
                    GET_NEXT_C_ARG(argptr, type); \
                    GET_STACK_POINTER(argptr,type)

#define GET_NEXT_S_ARG(argptr,type)     argptr += sizeof(type)

//
// Some typedefs so that the C compiler front end won't complain about calling
// the server manager function with a specific number of arguments. This may
// help the C compiler code generator too.
//

typedef _int64 (__RPC_API * MANAGER_FUNCTION)(void);
typedef _int64 (__RPC_API * MANAGER_FUNCTION1)(
            REGISTER_TYPE);
typedef _int64 (__RPC_API * MANAGER_FUNCTION2)(
            REGISTER_TYPE, REGISTER_TYPE);
typedef _int64 (__RPC_API * MANAGER_FUNCTION3)(
            REGISTER_TYPE, REGISTER_TYPE, REGISTER_TYPE);
typedef _int64 (__RPC_API * MANAGER_FUNCTION4)(
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE);
typedef _int64 (__RPC_API * MANAGER_FUNCTION5)(
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE);
typedef _int64 (__RPC_API * MANAGER_FUNCTION6)(
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE);
typedef _int64 (__RPC_API * MANAGER_FUNCTION7)(
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE);
typedef _int64 (__RPC_API * MANAGER_FUNCTION8)(
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE);
typedef _int64 (__RPC_API * MANAGER_FUNCTION9)(
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE);
typedef _int64 (__RPC_API * MANAGER_FUNCTION10)(
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE);
typedef _int64 (__RPC_API * MANAGER_FUNCTION11)(
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE);
typedef _int64 (__RPC_API * MANAGER_FUNCTION12)(
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE);
typedef _int64 (__RPC_API * MANAGER_FUNCTION13)(
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE);
typedef _int64 (__RPC_API * MANAGER_FUNCTION14)(
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE);
typedef _int64 (__RPC_API * MANAGER_FUNCTION15)(
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE);
typedef _int64 (__RPC_API * MANAGER_FUNCTION16)(
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE);
typedef _int64 (__RPC_API * MANAGER_FUNCTION17)(
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE);
typedef _int64 (__RPC_API * MANAGER_FUNCTION18)(
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE);
typedef _int64 (__RPC_API * MANAGER_FUNCTION19)(
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE);
typedef _int64 (__RPC_API * MANAGER_FUNCTION20)(
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE);
typedef _int64 (__RPC_API * MANAGER_FUNCTION21)(
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE);
typedef _int64 (__RPC_API * MANAGER_FUNCTION22)(
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE);
typedef _int64 (__RPC_API * MANAGER_FUNCTION23)(
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE);
typedef _int64 (__RPC_API * MANAGER_FUNCTION24)(
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE);
typedef _int64 (__RPC_API * MANAGER_FUNCTION25)(
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE);
typedef _int64 (__RPC_API * MANAGER_FUNCTION26)(
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE);
typedef _int64 (__RPC_API * MANAGER_FUNCTION27)(
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE);
typedef _int64 (__RPC_API * MANAGER_FUNCTION28)(
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE);
typedef _int64 (__RPC_API * MANAGER_FUNCTION29)(
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE);
typedef _int64 (__RPC_API * MANAGER_FUNCTION30)(
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE);
typedef _int64 (__RPC_API * MANAGER_FUNCTION31)(
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE);
typedef _int64 (__RPC_API * MANAGER_FUNCTION32)(
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE);


#if !defined(__RPC_WIN64__)

void
NdrServerFree(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat,
    void *              pThis
    );

void
NdrCallServerManager (
    MANAGER_FUNCTION    pFtn,
    double *            pArgs,
    ulong               NumRegisterArgs,
    BOOL                fHasReturn
    );

#endif // !defined(__RPC_WIN64__)

void
Ndr64OutInit(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PNDR64_FORMAT           pFormat,
    uchar **                ppArg
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr20\memsize.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1993-2000 Microsoft Corporation

Module Name :

    memsize.c

Abstract :

    This file contains the routines called by MIDL 2.0 stubs and the
    intepreter for computing the memory size needed to hold a parameter being
    unmarshalled.

Author :

    David Kays  dkays   November 1993.

Revision History :

Note:
    Simple types are not checked for buffer over-run since we are 
    only reading from the buffer and not writing from it.  So if
    a buffer overun actually occures, no real damage is done.

  ---------------------------------------------------------------------*/

#include "ndrp.h"
#include "interp2.h"
#include "attack.h"
#include "pointerq.h"

unsigned long
NdrUDTSimpleTypeMemsize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat );

extern const
PMEM_SIZE_ROUTINE   MemSizeRoutinesTable[] =
                    {
                    
                    // dummies for 64b C compiler workaround
                    //
                    NdrUDTSimpleTypeMemsize,
                    NdrUDTSimpleTypeMemsize,
                    NdrUDTSimpleTypeMemsize,
                    NdrUDTSimpleTypeMemsize,
                    NdrUDTSimpleTypeMemsize,
                    NdrUDTSimpleTypeMemsize,
                    NdrUDTSimpleTypeMemsize,
                    NdrUDTSimpleTypeMemsize,      // FC_ZERO - FC_USHORT
                    NdrUDTSimpleTypeMemsize,
                    NdrUDTSimpleTypeMemsize,
                    NdrUDTSimpleTypeMemsize,
                    NdrUDTSimpleTypeMemsize,
                    NdrUDTSimpleTypeMemsize,
                    NdrUDTSimpleTypeMemsize,
                    NdrUDTSimpleTypeMemsize,
                    NdrUDTSimpleTypeMemsize,      // FC_LONG - FC_IGNORE
                    NdrUDTSimpleTypeMemsize,      // FC_ERROR_STATUS_T

                    NdrPointerMemorySize,
                    NdrPointerMemorySize,
                    NdrPointerMemorySize,
                    NdrPointerMemorySize,

                    NdrSimpleStructMemorySize,
                    NdrSimpleStructMemorySize,
                    NdrConformantStructMemorySize,
                    NdrConformantStructMemorySize,
                    NdrConformantVaryingStructMemorySize,

                    NdrComplexStructMemorySize,

                    NdrConformantArrayMemorySize,
                    NdrConformantVaryingArrayMemorySize,
                    NdrFixedArrayMemorySize,
                    NdrFixedArrayMemorySize,
                    NdrVaryingArrayMemorySize,
                    NdrVaryingArrayMemorySize,

                    NdrComplexArrayMemorySize,

                    NdrConformantStringMemorySize,
                    NdrConformantStringMemorySize,
                    NdrConformantStringMemorySize,
                    NdrConformantStringMemorySize,

                    NdrNonConformantStringMemorySize,
                    NdrNonConformantStringMemorySize,
                    NdrNonConformantStringMemorySize,
                    NdrNonConformantStringMemorySize,

                    NdrEncapsulatedUnionMemorySize,
                    NdrNonEncapsulatedUnionMemorySize,

                    0,                           // byte count

                    NdrXmitOrRepAsMemorySize,    // transmit as
                    NdrXmitOrRepAsMemorySize,    // represent as

                    NdrPointerMemorySize,

                    0,

                    // New Post NT 3.5 token serviced from here on.

                    0,                         // NdrHardStructMemorySize,

                    NdrXmitOrRepAsMemorySize,  // transmit as ptr
                    NdrXmitOrRepAsMemorySize,  // represent as ptr

                    NdrUserMarshalMemorySize,

                    0,   // FC_PIPE 
                    0,   // FC_BLK_HOLE

                    NdrpRangeMemorySize,

                    0,   // FC_INT3264
                    0,   // FC_UINT3264

                    0, // NdrCsArrayMemorySize,
                    0, // NdrCsTagMemorySize
                    };

extern const
PMEM_SIZE_ROUTINE * pfnMemSizeRoutines = MemSizeRoutinesTable;

void
NdrpInterfacePointerMemorySize (
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat );

unsigned long
NdrUDTSimpleTypeMemsize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat )
{
    ALIGN( pStubMsg->Buffer, SIMPLE_TYPE_ALIGNMENT(*pFormat) );
    pStubMsg->Buffer += SIMPLE_TYPE_BUFSIZE(*pFormat);
    pStubMsg->MemorySize += SIMPLE_TYPE_MEMSIZE(*pFormat);
    return pStubMsg->MemorySize;
}


unsigned long RPC_ENTRY
NdrpRangeMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat )
/*++
--*/
{
    FORMAT_CHARACTER    FcType = (FORMAT_CHARACTER)(pFormat[1] & 0x0f);

    ALIGN(pStubMsg->Buffer,SIMPLE_TYPE_ALIGNMENT(FcType));
   
    pStubMsg->Buffer += SIMPLE_TYPE_BUFSIZE(FcType);

    switch ( pFormat[2] )
        {
        case FC_ENUM16 :
            //
            // We can't use the simple type tables for enum16.
            //
            LENGTH_ALIGN( pStubMsg->MemorySize, sizeof(int) - 1 );
            pStubMsg->MemorySize += sizeof(int);
            break;

        default :
            LENGTH_ALIGN( pStubMsg->MemorySize,
                          SIMPLE_TYPE_ALIGNMENT(FcType) );
            pStubMsg->MemorySize += SIMPLE_TYPE_MEMSIZE(FcType);
            break;
        }

    return pStubMsg->MemorySize;
}


unsigned long RPC_ENTRY
NdrPointerMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Computes the memory size required for a top level pointer to anything.
    Pointers embedded in structures, arrays, or unions call
    NdrpPointerMemorySize directly.

    Used for FC_RP, FC_UP, FC_FP, FC_OP.

Arguments :

    pStubMsg    - Pointer to stub message.
    pFormat     - Pointer's format string description.

Return :

    The computed memory size.

--*/
{
    uchar * pBufferMark;

    //
    // If this is not a ref pointer then mark where the pointer's id is in
    // the buffer and increment the stub message buffer pointer.
    //
    if ( *pFormat != FC_RP )
        {
        ALIGN(pStubMsg->Buffer,0x3);

        pBufferMark = pStubMsg->Buffer;
        
        pStubMsg->Buffer += PTR_WIRE_SIZE;
        }
    else
        pBufferMark = 0;

    // Else we can leave pBufferMark unitialized.

    return NdrpPointerMemorySize( pStubMsg,
                                  pBufferMark,
                                  pFormat );
}


__forceinline unsigned long
NdrpPointerMemorySizeInternal(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pBufferMark,
    PFORMAT_STRING      pFormat )
/*++

Routi